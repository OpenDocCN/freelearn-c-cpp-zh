- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ Is Backward Compatible ...Even with C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*And of course, with C, and B ... and even A ... and @* *maybe?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the beginning, there was the word, and the word was used in BCPL. Pronounced
    like Basic Combined Programming Language, not Baltimore County Public Library.
    It was the first of its kind that ruled the land of compilers with an iron syntax
    for several iterations. However, the trials of time were not kind to it. New features,
    doctrines, and syntax passed through and soon a new heir to the throne rose from
    the bits: *B* . Not too many considered *B* ’s typeless nature and advantage and
    soon *B* ceased to be, as a new contender to the throne of programming languages
    replaced *B* : *C* [1](B22235_11.xhtml#footnote-029) .'
  prefs: []
  type: TYPE_NORMAL
- en: '[1](B22235_11.xhtml#footnote-029-backlink) [https://www.bell-labs.com/usr/dmr/www/chist.html](https://www.bell-labs.com/usr/dmr/www/chist.html)'
  prefs: []
  type: TYPE_NORMAL
- en: The rest is history. *C* became the de-facto language of low-level system programming,
    and its syntax crept into all popular programming languages of the last and this
    century (hello, curly braces). *C* is like glue, binding together various programming
    languages to perform sacred rites in Computerlandia.
  prefs: []
  type: TYPE_NORMAL
- en: And the programmers looked and saw that it was good.
  prefs: []
  type: TYPE_NORMAL
- en: 'Except for one Prometheus [2](B22235_11.xhtml#footnote-028) , a bringer of
    classes into *C* , soon to give people, *C with classes* , and *Cfront* , the
    first ever compiler that digested C++ code and spat out C code which sadly is
    long gone from our realm, but its legacy remains. The language, the dozens of
    C++ standard-compliant compilers (each, in their time was standard conformant...
    more or less), several hundreds of undefined behavior cases, and various iterations
    of the standard over the last three decades (the last working one being C++23,
    while the committee is laboring the latest and greatest C++26) are all here and
    constitute the programming language we all love: C++.'
  prefs: []
  type: TYPE_NORMAL
- en: '[2](B22235_11.xhtml#footnote-028-backlink) Yes, Bjarne, we are talking about
    you'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will have you glued to your seat – like traffic at rush hour –
    with the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Is C++ really backward-compatible with C ?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is C++ really backward-compatible with C++?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is C really forward-compatible with C++?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will be a bit of exploration, covering most of the banally boring
    bothersome beliefs concerning whether C++ is really backward compatible with C.
    As we were indoctrinated through the decades by our tutors, teachers, and trainers,
    C++ is mostly backward compatible with C. This means that much of C code can be
    compiled and run in C++ with little modification, as they share similar syntax
    and standard libraries.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: C and C++ may be closely related, like two siblings in a dysfunctional family,
    but still have many differences, leading to a love-hate relationship when it comes
    to compatibility. However, over time, the two languages have diverged significantly.
    According to the core rules, C is more permissive with looser typing rules, especially
    around pointers, and allows constructs like implicit pointer conversions, which
    C++ strictly forbids. For instance, in C, you can assign a **void*** to any other
    pointer type without a cast, while C++ will demand an explicit cast to maintain
    type safety.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, C++ (especially the newer iterations of the language) has stricter
    rules regarding enumerations, making them distinct types, whereas in C, enums
    are simply treated as **int** . This difference extends to many other areas: variable
    initialization, type qualifiers, and even memory allocation ( ***alloc()** ) work
    differently between the two. This is especially true of functions such as **malloc**
    , **calloc** , and so on. While in C they’re just your run-of-the-mill functions,
    as mundane as your morning cup of coffee, if they occur in any kind of C++ code,
    suddenly it’s like opening a portal to the seven circles of developer hell. This
    is particularly true during code reviews where acolyte C++ programmers are clutching
    their keyboards in terror, pointing out how you should not use C functions in
    C++ code when you have perfectly valid **new** and **delete** . They might also
    ask why you even need to allocate memory. It’s 2024. We have smart pointers. Or
    at least, if you can restrain yourself, we beg you not to use C-style casting.
    That’s because there are perfectly functioning cast operators introduced in the
    C++ standard more than a decade ago.'
  prefs: []
  type: TYPE_NORMAL
- en: According to what was just discussed (but not exclusively), while young C++
    emphasizes stricter type rules and more predictable, safe programming practices,
    granddaddy C remains the pragmatic and flexible, albeit riskier, option.
  prefs: []
  type: TYPE_NORMAL
- en: To the horror of C++ acolytes, the two languages are often used together, especially
    in C++ projects that need to use libraries written in C, but ensure code compatibility
    between the two languages. Oh, the nightmares of software development.
  prefs: []
  type: TYPE_NORMAL
- en: To aid the preceding scenario, developers often have to use **extern "C"** declarations,
    which prevent C++’s name mangling and allow smooth function linking across libraries
    written in various dialects. This is because, despite their similarities, the
    object files generated by C and C++ compilers are handled differently (yes, name
    mangling, we’re talking about you).
  prefs: []
  type: TYPE_NORMAL
- en: To top the previous flat facts, in addition, there are a plethora of C99-specific
    keywords, such as **_Alignas** , **_Alignof** , **_Atomic** , **_Bool** , **_Complex**
    , **_Generic** , **_Imaginary** , **_Noreturn** , and **_Static_assert** , that
    are not part of standard C++, though some may have C++ equivalents or be available
    through compiler extensions. To make life more interesting, these were actually
    retired starting from C23, due to some efforts to bring C closer to C++.
  prefs: []
  type: TYPE_NORMAL
- en: And we didn’t even mention designated initializers. Too late for them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'However, C was certainly not thought up with the idea that someday, there would
    be a future programming language called C++. That’s why the following C code is
    perfectly valid while all law-abiding C++ compilers (and pure C++ developers too)
    will choke on it heavily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'While looking like the nightmare out of the C pits, regardless of it, this
    piece of pure C code is perfectly valid, and what a surprise, it even calculates
    the Fibonacci numbers. But let’s not be overly fiendish towards you, dear reader
    (although considering what other mythical code snippets you had to suffer through
    this book till you reached this chapter, I hardly doubt this piece of code may
    come as a shock to you ... no worries, this is the penultimate chapter, so the
    suffering is almost over ... till then, however: do you remember in [*Chapter
    9*](B22235_09.xhtml#_idTextAnchor096) where we defined main to be return and return
    to be main?), and let us present another interesting feature of C, that was not
    ported over to C++.'
  prefs: []
  type: TYPE_NORMAL
- en: No, we are not talking about variable length arrays, regardless of the fact
    that just due to the peculiar syntax of **void funny_fun(int n, int array[][*])**
    , they also deserve a litany of their own (the syntax is an exemplification of
    how to pass in a 2D variable length array to a function in the declaration of
    its prototype). Variable length arrays have been discussed [3](B22235_11.xhtml#footnote-027)
    in detail [4](B22235_11.xhtml#footnote-026) throughout the last decade by authorities
    who are much more qualified to discuss this than our humble person. Regardless
    of those discussions, they (the VLAs) still did not make it into the C++ standard,
    so there must be a valid reason behind this decision (not just the potential stack-related
    issues, of assuming a theoretically unlimited stack, and the type mayhem the non-compile
    time type deduction might induce with VLAs, but also that in C++ there are much
    better mechanisms to handle this specific use case).
  prefs: []
  type: TYPE_NORMAL
- en: '[3](B22235_11.xhtml#footnote-027-backlink) [https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3810.pdf](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3810.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[4](B22235_11.xhtml#footnote-026-backlink) [https://nullprogram.com/blog/2019/10/27/](https://nullprogram.com/blog/2019/10/27/)'
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter of the book, we will discuss some C-specific features that
    the author finds highly useful, but that sadly still did not make it into the
    C++ standard in their original form.
  prefs: []
  type: TYPE_NORMAL
- en: The magic of the parameter list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start with a simple function, the simplest of all, which is **int foo()**
    . It’s not a very sophisticated function, but it does its job as expected, whatever
    that might be.
  prefs: []
  type: TYPE_NORMAL
- en: When compiled as C, a function with an empty parameter list means the function
    can take an unspecified number of arguments, which can lead to ambiguity and potential
    errors if arguments are passed to the function. That’s because the compiler will
    not enforce parameter constraints.
  prefs: []
  type: TYPE_NORMAL
- en: To explicitly specify that a function takes no arguments in C, we must use **void**
    in the parameter list, as in **int foo(void)** , which clearly indicates that
    the function accepts no arguments and passing any would result in a compile-time
    error.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, C++ simplifies this by treating an empty parameter list as equivalent
    to specifying **void** , meaning that **int foo()** in C++ denotes a function
    that takes no arguments, just like **int foo(void)** , making the use of the **void**
    optional in C++.
  prefs: []
  type: TYPE_NORMAL
- en: This makes the syntax cleaner in C++, where functions with no parameters can
    simply be declared with empty parentheses. While C still requires **void** for
    clarity and correctness, C++ allows both forms, though the typical practice is
    to omit **void** and use the simpler **int foo()** . Neat, isn’t it?
  prefs: []
  type: TYPE_NORMAL
- en: However, what if we want to add some parameters to our function? Let’s modify
    it in the form of **int foo(int** **array[static 10])** .
  prefs: []
  type: TYPE_NORMAL
- en: The **int foo(int array[static 10])** declaration is a feature introduced in
    *C99* that provides additional information to the compiler about the parameters
    passed to a function, specifically when dealing with arrays.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the **static** keyword within the array parameter indicates to
    the compiler that the **fun** function is expected to be called with an array
    that has at least 10 elements. The number 10 specifies the minimum size of the
    array that will be passed to the function, which can help the compiler make certain
    assumptions, such as enabling optimizations based on the guaranteed size of the
    array.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, when using static in the array parameter like this, the compiler
    assumes that the array pointer cannot be **NULL** . That’s because a null pointer
    would imply that there are no valid elements, which violates the condition that
    the array must have at least 10 elements. This provides an extra layer of safety
    and clarity, as it eliminates the need for the function to check whether the array
    is **NULL** before proceeding, which can reduce runtime overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Decent Recent versions of **clang** (well, basically all above 3.1.0) even
    emit a warning if you call a function having this very specific declaration, with
    the infamous **NULL** pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Sadly, this very handy feature did not make it into any of the C++ standards,
    nor can all today’s C compilers digest it (we could not convince MSVC to successfully
    compile this piece of code, regardless of the requested C standard). Regardless,
    for programmers not targeting these platforms, this might indeed come in as a
    great help in times of need.
  prefs: []
  type: TYPE_NORMAL
- en: Another handy feature restricted to the circles of C programmers is the **restrict**
    keyword, introduced in C99, which is a type qualifier that provides hints to the
    compiler for optimizing memory access involving pointers. It tells the compiler
    that the pointer to which **restrict** is applied is the only means by which the
    referenced object (memory) will be accessed in the current scope. This allows
    the compiler to make aggressive optimizations because it can assume that no other
    pointer will alias or reference the same memory.
  prefs: []
  type: TYPE_NORMAL
- en: When you use the **restrict** qualifier on a pointer, you are promising the
    compiler that, for the lifetime of that pointer, the object it points to will
    not be accessed by any other pointer. This enables the compiler to generate more
    efficient code by avoiding unnecessary memory reloads or re-fetches, which might
    otherwise be required due to potential aliasing (multiple pointers pointing to
    the same memory).
  prefs: []
  type: TYPE_NORMAL
- en: Without **restrict** , the compiler must assume that any two pointers may reference
    the same memory, limiting its ability to optimize code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the compiler must assume that ***a** and ***b** could alias each
    other, so it may reload ***a** or ***b** from memory just in case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is its counterpart with **restrict** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we have told the compiler that ***a** and ***b** do not alias,
    so it can optimize without worrying about memory aliasing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following listings (generated by **GCC** 14.2, using **–O3** optimization)
    are the assembly code generated for the two different functions, with some explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the other one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Surprisingly, the one with **restrict** has a few more instructions, but once
    we go through the generated code, we can easily spot the effect of the **restrict**
    keyword. Supposedly, the parameters to the function are at the memory locations
    pointed at by **[rsi]** and **[rdi]** . The first one (without **restrict** )
    has to do all the addition work in memory, thus leading to slightly slower code,
    while the second one can delegate these costly operations to two ultra-fast register-based
    additions.
  prefs: []
  type: TYPE_NORMAL
- en: Also, a big difference between these two is that the second one ( **update2**
    , with **restrict** ) can assume that the value of the second parameter will not
    change after the first operation, so the carefully crafted register initializations
    and additions can play a vital part. The first one needs to consider that the
    ***a = *a + *b;** operation might change the value of **b** too (found at **[rsi]**
    ). Hence, it needs to perform the operations in memory, always making the current
    value available to the upcoming operations.
  prefs: []
  type: TYPE_NORMAL
- en: While for a simple operation like these simple additions, the effects, and the
    outcoming result might not be as spectacular as for a larger example which would
    not have had enough space in this book, we still have enough evidence that the
    **restrict** keyword has factual effects on the generated code. Too bad this didn’t
    make it into C++ either.
  prefs: []
  type: TYPE_NORMAL
- en: However, that’s enough bashing of C++ and its lack of compatibility with C.
    They were never meant to compete, but rather, they complement each other. Let’s
    move on to more interesting fields. Is C++ really compatible with itself?
  prefs: []
  type: TYPE_NORMAL
- en: Whitespace matters – until it doesn’t
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following piece of code is not an extraordinarily complicated snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The not-so-complex code defines a series of macros to manipulate strings and
    concatenate tokens. **STR_I(x)** stringifies its argument, **STR(x)** ensures
    full macro expansion before stringification, **JOIN(x,y)** concatenates two arguments
    with a space, and **Hello(x)** is defined but, strangely, unused.
  prefs: []
  type: TYPE_NORMAL
- en: What comes up are two most important **printf** calls in the lifetime of this
    short program. In the first **printf** call, **JOIN(Hello, World)** expands to
    **(Hello World)** , which is then stringified to **"(Hello World)"** . That’s
    nothing overly complicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the fun part comes now: in the second **printf** call, **JOIN(Hello,World)**
    (without the space between the comma and **World** ) behaves differently depending
    on the GCC version.'
  prefs: []
  type: TYPE_NORMAL
- en: In GCC 9.4 (and below), this results in **(HelloWorld)** without a space, while
    in GCC 9.5 (and above), the preprocessor adds a space between the tokens, making
    both **printf** calls produce **"(** **Hello World)"** .
  prefs: []
  type: TYPE_NORMAL
- en: This difference between GCC 9.4 and 9.5 stems from how each version handles
    token concatenation and whitespace between macro arguments, with GCC 9.4 not inserting
    spaces where none are explicitly given, and GCC 9.5 handling them more consistently
    by adding a space even when omitted in the macro invocation.
  prefs: []
  type: TYPE_NORMAL
- en: While the C and C++ standards do not explicitly say “whitespace is ignored between
    macro arguments and commas,” it is implied by the way the preprocessor handles
    tokenization and macro expansion. Regardless, the rules state that arguments are
    separated by commas, and whitespace does not affect this separation. It seems
    that GCC (before 9.4) had a somewhat liberal interpretation of the lack of specification,
    which was re-interpreted in GCC 9.5 and after.
  prefs: []
  type: TYPE_NORMAL
- en: The whole misunderstanding is caused by the presence of the **Hello** macro,
    defined as a function-like macro, but used as a plain old replacement macro. It’s
    highly possible that the main issue is (or rather, was) a bug in older GCC, which
    certainly we do not use anymore, because we all know, that newer compilers are
    more standard compliant, and certainly, we all write standard compliant code,
    don’t we?
  prefs: []
  type: TYPE_NORMAL
- en: That’s an interesting piece of historical forward compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: The 11th guest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++11 brought a range of new features while maintaining backward compatibility
    with C++98, ensuring that developers could adopt the modern capabilities incrementally
    without breaking existing code. One of the most transformative additions was **move
    semantics** , which introduced some new syntax that C++98 compilers could not
    digest. This was facilitated by rvalue references, a syntax again not supported
    by older compilers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the **auto** keyword simplified type declarations by automatically
    inferring types, yet developers could continue using it to explicitly specify
    that the variable has automatic storage, like they never did in C++98. This choice
    was made because let’s admit it, no one ever used auto as it was intended for
    in the C language (from where it was inherited, but even there it was still useless,
    unless in the B language, where it originated, as correctly denoting the storage
    for a variable: the stack).'
  prefs: []
  type: TYPE_NORMAL
- en: New syntax such as **range-based for loops** allowed for cleaner iteration over
    containers, but the classic **for** loops from C++98 remained fully functional,
    thankfully, because lots of people still use them. The introduction of **nullptr**
    replaced the old **NULL** macro with a type-safe alternative, though **NULL**
    was still supported for backward compatibility, regardless of the fact that it
    was not that different from 0.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these core language improvements, C++11 introduced modern functional
    programming features such as **lambda expressions** , which allowed anonymous
    functions to be written inline, facilitating cleaner and more concise code.
  prefs: []
  type: TYPE_NORMAL
- en: The new **constexpr** feature allowed certain functions to be evaluated at compile
    time, offering performance improvements, but developers could still rely on the
    C++98 approach of runtime function evaluation if needed with the use of overly
    complicated templated recursions because, well, **constexpr** is not supported
    by old compilers either.
  prefs: []
  type: TYPE_NORMAL
- en: However, none of those groundbreaking changes can be more confusing to older
    users of C++ than the change of parsing for the C++ templates double right-angle
    brackets. In C++98, when using nested template arguments, the parser required
    spaces between consecutive right-angle brackets ( **> >** ) to distinguish them
    from the shift operator ( **>>** ). This was necessary because, in C++98, the
    parser would interpret two consecutive **>** symbols as the bitwise right-shift
    operator rather than as the closing of two nested templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C++11 and later, the compiler is smart enough to recognize that in this
    context, **>>** refers to closing two nested template brackets, not performing
    a right-shift operation. This makes the syntax cleaner and less error-prone, as
    developers no longer need to manually add spaces between right-angle brackets
    in nested template expressions. However, this also unfortunately means that the
    following program will display two different values depending on whether it was
    compiled with a compiler supporting C++11 standard, or with a compiler that only
    supports C++98:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When we dig deeper into the intricacies of the program, it is perfectly clear
    why it has this strange behavior. If it is still not clear yet, let’s break it
    down.
  prefs: []
  type: TYPE_NORMAL
- en: OK, let’s not break down the entire program. That would be too long. Instead,
    we’ll focus on just **D<C< ::value>>::value>::value>::value** , which is the key
    to all the feature identification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using C++98 syntax, this will be parsed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: So, it all boils down to the value of **D<int>::value** due to the fact that
    **::value>>::value** will be parsed as **1 >> 1** , resulting in **0** . This
    goes into **C<0>::value** , which is a plain **typedef** to **int** . From there,
    we reach **D<int>::value** .
  prefs: []
  type: TYPE_NORMAL
- en: Since we have defined it to be **2** , **if** certainly will be **true** , and
    we have executed the C++98 identification branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, when parsing the code with a C++11-compliant compiler, the expression
    will be parsed as the following, slightly more complex expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As may not be obvious from the long and complex set of right-angle brackets,
    in the end, this will be parsed like two comparisons. That’s because the following
    **D<C<1>>::value** turns out to be **2** (because **C<1>** is also a type by itself,
    so we end up in a specialization of the **D** class with **C<1>** ). Then, this
    is compared to **::value** , which will turn out to be true **(2>1)** . From this,
    in the end, after a series of interesting conversions, the end result will look
    like **1>1** . This turns out to be **false** ; hence, we enter the C++11 branch.
  prefs: []
  type: TYPE_NORMAL
- en: With this in place, we have a nice and short, albeit overly complicated and
    useless, way to identify whether our code was compiled with a C++11 conforming
    compiler. However, checking for the value of **__cplusplus** is much easier than
    this and should be used in any production-ready code.
  prefs: []
  type: TYPE_NORMAL
- en: The auto surprise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you, dear reader, do remember that in [*Chapter 9*](B22235_09.xhtml#_idTextAnchor096)
    , we had an interesting section called *The definition of zero* , then all is
    good. That’s because our next pitch will be about this highly influential number
    again. If you don’t remember that chapter, then life is still good, because hopefully,
    you have purchased a full book with all the chapters inside, and you can turn
    the pages back to read it (again).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The program is not an overly complicated one again. It just uses the fancy
    **auto** keyword and initializes variables to **0** using all kinds of mechanisms,
    mostly presented in the chapter mentioned earlier. If you do not know what the
    **auto** keyword does, then here is a short recap: the **auto** keyword in C++11
    was hijacked from C, and its new role is to allow automatic type inference, enabling
    the compiler to deduce the type of a variable based on its initializer. This simplifies
    code by removing the need for explicit type declarations, and shortens the handling
    of complex or verbose types, such as iterators or templated types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Anyway, back to our code. After careful consideration, we can conclude the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**auto a1 = 0;** : For this simple case, **a1** is deduced to be **int** since
    0 is an integer literal. This is a straightforward copy initialization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**auto a2(0);** : Again, a simple one, **a2** is also deduced to be **int**
    because 0 is directly initialized as an integer literal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**auto a3 {0};** : Then, **a3** is deduced to be **int** , as the **{0}** list
    initialization initializes it to an integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**auto a4 = {0};** : This is a bit tricky, however. For this case, **a4** is
    deduced to be **std::initializer_list<int>** because **auto** with brace initialization
    deduces an **initializer_list** . This is a special rule for **auto** when used
    with brace-enclosed initializers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output of the program using MSVC is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Using GCC (recent/decent versions), the output will be a bit less verbose,
    but you get the idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'However, there is a catch. If we compile this piece of code with GCC versions
    older than version 5.0 we get an ugly surprise. The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'What an unexpected surprise of backward compatibility. The real help comes
    from clang (3.7), however. If we compile the program with it, we get the following
    rather helpful message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: So, it seems that at some stage during its evolution, the meaning of **{x}**
    combined with **auto** but not **=** , in this very specific scenario, has changed
    (around the birth date of C++17). However, thankfully, early compilers had thought
    of this peculiar scenario, with this very specific and direct warning. Very backward
    compatible, isn’t it?
  prefs: []
  type: TYPE_NORMAL
- en: 'So, with all this in mind, it should not come as a huge surprise that the following
    code does not even compile (considering that we are still in the confines of our
    previous short program):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Why should it? Which type would **{0}** be deduced to, considering all the
    chaos and mayhem with the preceding syntax? Would it be deduced to an **int**
    type? Or maybe to an **initializer_list** type? Would it be a null pointer ( **nullptr**
    )? Or an object that can be built from a number, like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Or is this not so fun anymore?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned that C++ has evolved and diverged significantly
    from its humble C (as well as B and BCPL) origins. We learned that C++ has introduced
    modern features and stricter rules to enhance safety and efficiency, and to support
    modern programming paradigms. While it maintains much of C’s syntax, the two languages
    have heavily branched off over time, leading to compatibility challenges, especially
    when mixing older C code with features requiring newer C++ standards. We discussed
    this extensively in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Within modern C++ itself, the introduction of features such as move semantics,
    stricter template parsing, and changes in the behavior of keywords such as **auto**
    have added layers of complexity (not that there were not enough). We also learned
    this in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Despite these challenges, we explored the fact that C++ continues to build on
    its rich legacy, offering powerful tools for developers while requiring careful
    attention to evolving standards and backward compatibility without incurring too
    much contradiction with its previous self. It remains a language where tradition
    and innovation meet, often in unexpected and fascinating ways.
  prefs: []
  type: TYPE_NORMAL
- en: But for how long? Will it survive the surfacing threat of the new kid on the
    block? Will Rust replace C++? That’s up to you, dear reader, and it will be detailedly
    debated by Alex in our next chapter.
  prefs: []
  type: TYPE_NORMAL
