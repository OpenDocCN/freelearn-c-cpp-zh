# 第11章。与系统一起工作

在本章中，我们将介绍以下内容：

+   列出目录中的文件

+   删除和创建文件和目录

+   快速从一个进程传递到另一个进程的数据

+   同步进程间通信

+   在共享内存中使用指针

+   读取文件的最快方式

+   协程 - 保存状态和推迟执行

# 简介

每个操作系统都有许多系统调用，以略微不同的方式执行几乎相同的事情。这些调用在性能上有所不同，并且在不同操作系统之间有所不同。Boost为这些调用提供了可移植和安全的包装器。了解这些包装器对于编写良好的程序至关重要。

本章致力于操作系统的工作。我们在[第6章](ch06.html "第6章。操作任务")“操作任务”中看到了如何处理网络通信和信号。在本章中，我们将更深入地研究文件系统以及创建和删除文件。我们将了解数据如何在不同的系统进程之间传递，如何以最大速度读取文件，以及如何执行其他技巧。

# 列出目录中的文件

有STL函数和类可以读取和写入文件中的数据。但没有函数可以列出目录中的文件，获取文件类型，或获取文件访问权限。

让我们看看如何使用Boost来修复这样的不公正。我们将创建一个程序，列出当前目录中的文件名、写访问权限和文件类型。

## 准备工作

一些基本的C++知识就足够使用此配方了。

此配方需要链接到`boost_system`和`boost_filesystem`库。

## 如何操作...

此配方和下一个配方是关于用于处理文件系统的可移植包装器：

1.  我们需要包含以下两个头文件：

    [PRE0]

1.  现在需要指定一个目录：

    [PRE1]

1.  指定目录后，遍历其内容：

    [PRE2]

1.  下一步是获取文件信息：

    [PRE3]

1.  现在输出文件信息：

    [PRE4]

1.  最后一步将是输出文件名：

    [PRE5]

就这样。现在，如果我们运行程序，它将输出类似以下内容：

[PRE6]

## 它是如何工作的...

`Boost.Filesystem`的函数和类只是围绕系统特定的函数来处理文件。

注意第2步中`/`的使用。POSIX系统使用斜杠来指定路径；默认情况下，Windows使用反斜杠。然而，Windows也理解正斜杠，所以`./`在所有流行的操作系统上都会工作，它表示“当前目录”。

看看第3步，我们正在默认构造`boost::filesystem::directory_iterator`类。它就像一个`std::istream_iterator`类，在默认构造时充当`end`迭代器。

第4步有点棘手，不是因为这个函数难以理解，而是因为发生了许多转换。取消引用 `begin` 迭代器返回 `boost::filesystem::directory_entry`，它被隐式转换为 `boost::filesystem::path`，用作 `boost::filesystem::status` 函数的参数。实际上，我们可以做得更好：

[PRE7]

### 小贴士

仔细阅读参考文档以避免不必要的隐式转换。

第5步很明显，所以我们正在转向第6步，在那里再次发生隐式路径转换。一个更好的解决方案将是以下：

[PRE8]

在这里，`begin->path()` 返回一个对包含在 `boost::filesystem::directory_entry` 中的 `boost::filesystem::path` 变量的常量引用。

## 还有更多...

不幸的是，`Boost.Filesystem` 不是 C++11 的一部分，但它被提议包含在下一个 C++ 标准中。`Boost.Filesystem` 目前缺少对右值引用的支持，但仍然是最简单和最可移植的文件系统交互库之一。

## 参考以下内容

+   *删除和创建文件及目录* 菜谱将展示 `Boost.Filesystem` 的另一个使用示例。

+   读取Boost的官方文档以获取关于`Boost.Filesystem`更多功能的信息；它可在以下链接找到：

    [http://www.boost.org/doc/libs/1_53_0/libs/filesystem/doc/index.htm](http://www.boost.org/doc/libs/1_53_0/libs/filesystem/doc/index.htm)。

+   `Boost.Filesystem` 库被提议包含在 C++1y 中。草案可在 [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3399.html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3399.h) 找到。

# 删除和创建文件及目录

让我们考虑以下代码行：

[PRE9]

在这些行中，我们尝试在 `dir/subdir` 目录中的 `file.txt` 写入一些内容。如果没有这样的目录，这个尝试将会失败。与文件系统交互的能力对于编写良好的工作代码是必要的。

在这个菜谱中，我们将构建一个目录和子目录，将一些数据写入文件，并尝试创建`symlink`，如果创建符号链接失败，将删除创建的文件。我们还将避免使用异常作为错误报告的机制，而更倾向于使用某种形式的返回代码。

让我们看看如何使用 Boost 以优雅的方式做到这一点。

## 准备工作

为了这个菜谱，需要具备 C++ 和 `std::ofstream` 类的基本知识。`Boost.Filesystem` 不是一个仅包含头文件的库，因此这个菜谱中的代码需要链接到 `boost_system` 和 `boost_filesystem` 库。

## 如何做到这一点...

我们继续处理文件系统的可移植包装，在这个菜谱中，我们将看到如何修改目录内容：

1.  和往常一样，我们需要包含一些头文件：

    [PRE10]

1.  现在我们需要一个变量来存储错误（如果有）：

    [PRE11]

1.  如果需要，我们还将创建目录，如下所示：

    [PRE12]

1.  然后我们将向文件写入数据：

    [PRE13]

1.  我们需要尝试创建 `symlink`：

    [PRE14]

1.  然后我们需要检查文件是否可以通过`symlink`访问：

    [PRE15]

1.  或者，如果`symlink`创建失败，则删除创建的文件：

    [PRE16]

## 它是如何工作的...

我们在几乎所有关于*操作任务*的配方中看到了`boost::system::error_code`的使用。它可以存储有关错误的信息，并在Boost库中得到广泛使用。

### 注意

如果你没有向`Boost.Filesystem`函数提供一个`boost::system::error_code`实例，代码将编译良好，但发生错误时，将抛出异常。通常，除非你在分配内存方面遇到问题，否则会抛出`boost::filesystem::filesystem_error`异常。

仔细查看第3步。我们使用了`boost::filesystem::create_directories`函数，而不是`boost::filesystem::create_directory`，因为后者不能创建子目录。

剩余步骤很容易理解，不应引起任何麻烦。

## 还有更多...

`boost::system::error_code`类是C++11的一部分，可以在`std::`命名空间中的`<system_error>`头文件中找到。`Boost.Filesystem`的类不是C++11的一部分，但它们被提议包含在C++1y中，预计将在2014年准备好。

最后，对那些将要使用`Boost.Filesystem`的人有一个小建议；当文件系统操作中发生的错误是常规的，使用`boost::system::error_codes`。否则，捕获异常更可取且更可靠。

## 另请参阅

+   *列出目录中的文件*配方还包含有关`Boost.Filesystem`的信息。阅读Boost的官方文档以获取更多信息及示例，请访问[http://www.boost.org/doc/libs/1_53_0/libs/filesystem/doc/index.htm](http://www.boost.org/doc/libs/1_53_0/libs/filesystem/doc/index.htm)。

# 快速从一个进程传递数据到另一个进程

有时我们编写的程序将大量相互通信。当程序在不同的机器上运行时，使用套接字是通信最常见的技术。但如果多个进程在单个机器上运行，我们可以做得更好！

让我们看看如何使用`Boost.Interprocess`库使单个内存片段在不同进程间可用。

## 准备工作

此配方需要具备C++的基本知识。还需要了解原子变量（有关原子变量的更多信息，请参阅*另请参阅*部分）。某些平台需要链接到运行时库。

## 如何操作...

在此示例中，我们将在进程间共享一个单一的原子变量，使其在新的进程启动时增加，在进程终止时减少：

1.  我们需要包含以下头文件以进行进程间通信：

    [PRE17]

1.  在头文件、`typedef`和检查之后，将帮助我们确保原子变量可用于此示例：

    [PRE18]

1.  创建或获取共享内存段：

    [PRE19]

1.  获取或构造一个`原子`变量：

    [PRE20]

1.  以通常的方式处理`原子`变量：

    [PRE21]

1.  销毁`原子`变量：

    [PRE22]

那就结束了！现在如果我们同时运行这个程序的多实例，我们会看到每个新的实例都会增加它的索引值。

## 它是如何工作的...

这个方法的核心理念是获取一个对所有进程可见的内存段，并在其中放置一些数据。让我们看看第3步，我们在这里检索这样一个内存段。在这里，`shm-cache`是段的名称（不同的段名称不同）；你可以给段起任何你喜欢的名字。第一个参数是`boost::interprocess::open_or_create`，这意味着`boost::interprocess::managed_shared_memory`将打开一个名为`shm-cache`的现有段，或者如果不存在，则构造它。最后一个参数是段的尺寸。

### 注意

分段的尺寸必须足够大，以便能够容纳`Boost.Interprocess`库特定的数据。这就是为什么我们使用了`1024`而不是`sizeof(atomic_t)`。但实际上这并不重要，因为操作系统会将这个值四舍五入到最近的更大的支持值，这通常等于或大于4千字节。

第4步是一个棘手的部分，因为我们在这里同时执行多个任务。在这一步的`2`部分，我们将在段中查找或构造一个名为`shm-counter`的变量。在第4步的`3`部分，我们将提供一个参数，如果它在第2步中没有找到，这个参数将被用来初始化变量。只有在变量没有找到并且需要构造时，这个参数才会被使用，否则它将被忽略。仔细看看第二行（`1`部分）。看到对解引用操作符`*`的调用。我们这样做是因为`segment.find_or_construct<atomic_t>`返回一个指向`atomic_t`的指针，而在C++中使用裸指针是一种不良风格。

### 注意

注意，我们正在使用共享内存中的原子变量！这是必需的，因为两个或多个进程可以同时操作同一个`shm-counter`原子变量。

当你与共享内存中的对象一起工作时，你必须非常小心；不要忘记销毁它们！在第6步，我们正在使用它们的名称销毁对象和段。

## 还有更多...

仔细看看第2步，我们在这里检查`BOOST_ATOMIC_INT_LOCK_FREE != 2`。我们检查`atomic_t`不会使用互斥锁。这非常重要，因为通常互斥锁在共享内存中不会工作。所以如果`BOOST_ATOMIC_INT_LOCK_FREE`不等于`2`，我们将得到未定义的行为。

不幸的是，C++11没有提供跨进程类，据我所知，`Boost.Interprocess`没有被提议包含在C++1y中。

### 注意

一旦创建了一个管理段，它就不能增加大小！确保你创建的段足够大以满足你的需求，或者查看`*另请参阅*`部分以获取有关增加管理段的信息。

共享内存是进程间通信最快的方式，适用于可以共享内存的进程。这通常意味着这些进程必须在同一主机上运行或在**对称多处理**（**SMP**）集群上运行。

## 参见

+   *同步进程间通信*配方将向您介绍更多关于共享内存、进程间通信以及同步访问共享内存中的资源。

+   参见第5章，多线程中的*使用原子操作快速访问公共资源*配方，以获取有关原子的更多信息。

+   Boost的官方文档`Boost.Interprocess`也可能有所帮助；它可在[http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html](http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html)找到。

+   如何增加管理段在[http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_advanced_features.growin](http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_advanced_features.growin)[g_managed_memory](http://g_managed_memory)中描述。

# 同步进程间通信

在上一个配方中，我们看到了如何创建共享内存以及如何将一些对象放入其中。现在是我们做一些有用的事情的时候了。让我们从一个例子开始，这个例子来自第5章的*创建work_queue类*配方，*多线程*，并使其适用于多个进程。在这个例子的最后，我们将得到一个可以存储不同任务并在进程间传递它们的类。

## 准备工作

本配方使用前一个配方中的技术。您还需要阅读第5章的*创建work_queue类*配方，*多线程*，并理解其主要思想。这个例子需要在某些平台上链接到运行时库。

## 如何做到这一点...

被认为是在线程之外创建单独的子进程而不是线程可以使程序更可靠，因为子进程的终止不会终止主进程。我们不会对这个假设进行争论，只是看看进程间数据共享如何实现。

1.  本配方需要很多头文件：

    [PRE23]

1.  现在我们需要定义我们的结构，`task_structure`，它将被用来存储任务：

    [PRE24]

1.  让我们开始编写`work_queue`类：

    [PRE25]

1.  按照以下方式编写`work_queue`的成员：

    [PRE26]

1.  成员的初始化应如下所示：

    [PRE27]

1.  我们需要对`work_queue`的成员函数做一些小的修改，例如使用`scoped_lock_t`而不是原始的唯一锁：

    [PRE28]

## 它是如何工作的...

在这个菜谱中，我们几乎与第5章中“创建工作队列类”菜谱中做的是完全相同的事情，即*多线程*，但是在我们在共享内存中分配数据时，进行内存分配或使用同步原语时必须格外小心。

在存储具有指针或引用作为成员字段的共享内存对象时，请格外小心。我们将在下一菜谱中看到如何处理指针。

看看步骤2。我们没有使用`boost::function`作为任务类型，因为它包含指针，所以在共享内存中不会工作。

第3步之所以有趣，是因为`allocator_t`。它是一种所有容器都必须用来分配元素的分配器类型。它是一个有状态的分配器，这意味着它将与容器一起复制。此外，它不能被默认构造。

如果没有从共享内存段分配内存，它将不可用于其他进程；这就是为什么需要一个特定于容器的分配器的原因。

第4步相当简单，除了我们只有对`tasks_`、`mutex_`和`cond_`的引用。这样做是因为对象本身是在共享内存中构建的。因此，`work_queue`只能存储它们的引用。

在第5步中，我们正在初始化成员。这段代码对你来说很熟悉；我们在前一个菜谱中做了完全相同的事情。请注意，我们在构建时向`tasks_`提供了一个分配器实例。这是因为`allocator_t`不能由容器本身构造。

### 注意

共享内存不会在进程的退出事件中被销毁，因此我们可以运行程序一次，将任务发布到工作队列中，停止程序，启动其他程序，并获取由程序的第一实例存储的任务。共享内存只有在重启时或显式调用`segment.deallocate("work-queue");`时才会被销毁。

## 还有更多...

如前一个菜谱中提到的，C++11没有`Boost.Interprocess`中的类。此外，你不得在共享内存段中使用C++11或C++03容器。其中一些容器可能可以工作，但这种行为是不可移植的。

如果你查看一些`<boost/interprocess/containers/*.hpp>`头文件，你会发现它们只是使用了`Boost.Containers`库中的容器：

[PRE29]

`Boost.Interprocess`的容器具有`Boost.Containers`库的所有优点，包括右值引用及其在较旧编译器上的模拟。

`Boost.Interprocess`是同一台机器上运行的进程之间通信的最快解决方案。

## 参见

+   *使用共享内存中的指针*菜谱

+   有关同步原语和多线程的更多信息，请参阅[第5章](ch05.html "Chapter 5. Multithreading")，*多线程*。

+   请参阅Boost官方文档中的`Boost.Interprocess`库以获取更多示例和信息；它可在以下链接中找到：

    [http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html](http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html)

# 在共享内存中使用指针

很难想象在不使用指针的情况下编写一些C++核心类。指针和引用在C++中无处不在，它们在共享内存中不起作用！所以如果我们有一个这样的结构在共享内存中，并将共享内存中某个整数的地址赋给`pointer_`，我们不会在尝试从`with_pointer`的这个实例使用`pointer_`的其他进程中得到正确的地址：

[PRE30]

我们如何修复这个问题？

## 准备工作

之前的配方是理解这个配方所必需的。示例在某些平台上需要链接到运行时系统库。

## 如何做到这一点...

修复它非常简单；我们只需要用`offset_ptr<>`替换指针：

[PRE31]

现在我们可以像使用普通指针一样使用它：

[PRE32]

## 它是如何工作的...

我们不能在共享内存中使用指针，因为当一块共享内存被映射到进程的地址空间时，其地址仅对该进程有效。当我们获取变量的地址时，它只是该进程的一个局部地址；其他进程将共享内存映射到不同的基本地址，因此变量地址将不同。

![如何工作...](img/4880OS_11_01.jpg)

那么，我们如何处理一个始终变化的地址呢？有一个技巧！因为指针和结构在同一个共享内存段中，它们之间的距离不会改变。`boost::interprocess::offset_ptr`背后的想法是记住这个距离，在解引用时，将距离值添加到`offset_ptr`变量的进程相关地址。

偏移指针模仿指针的行为，因此它是一个可以快速应用的即插即用替换品。

### 小贴士

不要将可能包含指针或引用的类放入共享内存！

## 还有更多...

偏移指针比常规指针稍微慢一些，因为每次解引用时都需要计算地址。但这种差异通常不足以让你烦恼。

C++11没有偏移指针。

## 参见

+   Boost的官方文档包含了大量示例和更高级的`Boost.Interprocess`功能；它可在[http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html](http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html)找到。

+   “*最快读取文件*”配方中包含了关于`Boost.Interprocess`库一些非传统用法的信息。

# 最快读取文件的方法

在整个互联网上，人们都在问“最快读取文件的方法是什么？”。让我们使这个配方的任务更加困难：“最快且最便携的读取二进制文件的方法是什么？”

## 准备工作

为了这个配方，需要具备C++和`std::fstream`容器的基本知识。

## 如何做到这一点...

来自这个配方的技术被许多对输入输出性能至关重要的应用程序广泛使用。

1.  我们需要包含来自`Boost.Interprocess`库的两个头文件：

    [PRE33]

1.  现在我们需要打开一个文件：

    [PRE34]

1.  这个菜谱的主要部分是将所有文件映射到内存中：

    [PRE35]

1.  获取文件中数据的指针：

    [PRE36]

就这样！现在我们可以像使用正常内存一样处理文件：

[PRE37]

## 它是如何工作的...

所有流行的操作系统都具有将文件映射到进程地址空间的能力。完成此类映射后，进程可以像使用正常内存一样使用这些地址。操作系统将负责所有的文件操作，例如缓存和预读。

为什么它比传统的读写操作更快？那是因为在大多数情况下，读写操作被实现为内存映射和将数据复制到用户指定的缓冲区。所以读取通常要做更多的工作。

正如STL的情况一样，我们在打开文件时必须提供一个打开模式。请参阅第2步，其中我们提供了`boost::interprocess::read_only`模式。

请参阅第3步，其中我们一次性映射了整个文件。这个操作实际上非常快，因为操作系统不会从磁盘读取数据，而是等待请求成为映射区域的一部分。在请求映射区域的一部分后，操作系统将从磁盘加载该部分的文件。正如我们所见，内存映射操作是懒加载的，映射区域的大小不会影响性能。

### 注意

然而，32位操作系统无法内存映射大文件，因此您需要分块映射它们。POSIX（Linux）操作系统要求定义`_FILE_OFFSET_BITS=64`，以便整个项目能够在32位平台上处理大文件。否则，操作系统将无法映射超过4GB的文件部分。

现在是时候测量性能了：

[PRE38]

正如预期的那样，内存映射文件比传统的读取操作略快。我们还可以看到，纯C方法与C++的`std::ifstream`类的性能相同，所以请勿在C++中使用与`FILE*`相关的函数。这些函数仅适用于C，不适用于C++！

为了`std::ifstream`的最佳性能，请务必以二进制模式打开文件并按块读取数据：

[PRE39]

## 还有更多...

不幸的是，内存映射文件的类不是C++11的一部分，而且看起来它们也不会在C++14中出现。

向内存映射区域写入也是一种非常快速的操作。操作系统将缓存写入操作，并且不会立即将修改刷新到磁盘。操作系统和`std::ofstream`数据缓存之间有一个区别。如果`std::ofstream`数据被应用程序缓存并且应用程序终止，那么缓存的数据可能会丢失。当数据被操作系统缓存时，应用程序的终止不会导致数据丢失。电源故障和系统崩溃在这两种情况下都会导致数据丢失。

如果多个进程映射同一个文件，并且其中一个进程修改了映射区域，那么这些更改将立即对其他进程可见。

## 另请参阅

+   `Boost`.`Interprocess`库包含了许多与系统一起工作的有用功能；本书并未涵盖所有这些功能。您可以在官方网站上了解更多关于这个伟大库的信息：

    [http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html](http://www.boost.org/doc/libs/1_53_0/doc/html/interproces)

# 协程 – 保存状态和推迟执行

现在，许多嵌入式设备仍然只有单核。开发者为这些设备编写代码，试图从中榨取最大性能。对于这样的设备使用`Boost.Threads`或其他线程库并不有效；操作系统将被迫调度线程以执行，管理资源等等，因为硬件无法并行运行它们。

那么，我们如何在主程序等待某些资源时切换程序到子程序的执行？

## 准备工作

为了使用这个配方，需要具备C++和模板的基本知识。阅读一些关于`Boost.Function`的配方也可能有所帮助。

## 如何实现...

这个配方是关于协程，允许有多个入口点的子程序。多个入口点使我们能够在特定位置暂停和恢复程序的执行，切换到/从其他子程序。

1.  `Boost.Coroutine`库将负责几乎所有的事情。我们只需要包含其头文件：

    [PRE40]

1.  使用所需的签名创建一个协程类型：

    [PRE41]

1.  创建一个协程：

    [PRE42]

1.  现在我们可以执行子程序，同时在主程序中等待事件：

    [PRE43]

1.  协程方法应该看起来像这样：

    [PRE44]

## 工作原理...

在第2步，我们使用函数签名`std::string& (std::size_t)`作为模板参数来描述我们的子程序签名。这意味着子程序接受`std::size_t`并返回一个字符串的引用。

第3步之所以有趣，是因为`coroutine_task`的签名。请注意，这个签名适用于所有协程任务。`caller`是用于从调用者获取参数并将执行结果返回给调用者的变量。

第3步需要额外的注意，因为`corout_t`的构造函数将自动启动协程执行。这就是为什么我们在协程任务开始时调用`caller(result)`（它将我们带回到`main`方法）。

当我们在第4步中调用`coroutine(10)`时，我们正在导致协程程序执行。执行将在第一个`caller(result)`方法之后跳转到第5步，在那里我们将从`caller.get()`获取一个值`10`并继续我们的执行，直到`caller(result)`。之后，执行将返回到第4步，紧随`coroutine(10)`调用之后。接下来，对`coroutine(10)`或`coroutine(300)`的调用将继续从第5步中第二个`caller(result)`方法之后的地点继续子程序的执行。

![工作原理...](img/4880OS_11_02.jpg)

在第4步中查看`std::string& s = coroutine.get()`。在这里，我们将从第5步中描述的`coroutine_task`的开始获取`std::string`的结果。我们甚至可以修改它，`coroutine_task`将看到修改后的值。让我描述一下协程和线程之间的主要区别。当一个协程执行时，主任务什么都不做。当主任务执行时，协程任务什么都不做。你无法对线程有这种保证。使用协程，你可以明确指定何时开始子任务以及何时结束它。在单核环境中，线程可以在任何时刻切换；你无法控制这种行为。

### 注意

不要使用线程的局部存储，不要在同一协程内部调用`boost::coroutines::coroutine<>::operator()`；当协程任务完成时，不要调用`boost::coroutines::coroutine<>::get()`。这些操作会导致未定义的行为。

## 还有更多...

在切换线程时，操作系统会做很多工作，因此这不是一个很快的操作。然而，使用协程，你可以完全控制任务切换；此外，你不需要执行任何特定于操作系统的内核工作。切换协程比切换线程要快得多，但它的速度不如调用`boost::function`。

`Boost.Coroutine`库将负责调用协程任务中的变量的析构函数，因此无需担心泄漏。

### 注意

协程使用`boost::coroutines::detail::forced_unwind`异常来释放非`std::exception`派生的资源。你必须注意不要在协程任务中捕获该异常。

C++11没有协程。但协程尽可能使用C++11的特性，甚至在C++03编译器上模拟右值引用。你不能复制`boost::coroutines::coroutine<>`，但你可以使用`Boost.Move`来移动它们。

## 参见

+   Boost的官方文档包含了`Boost.Coroutines`库的更多示例、性能注释、限制和使用案例；它可在以下链接找到：

    [http://www.boost.org/doc/libs/1_53_0/libs/coroutine/doc/html/index.htm](http://www.boost.org/doc/libs/1_53_0/libs/coroutine/doc/html/index.htm)

+   查看第3章（[Chapter 3. Managing Resources](ch03.html "Chapter 3. Managing Resources")）的食谱，*Managing Resources*，以及第5章（[Chapter 5. Multithreading](ch05.html "Chapter 5. Multithreading")）的*Multithreading*，以了解`Boost.Coroutine`、`Boost.Thread`和`Boost.Function`库之间的区别
