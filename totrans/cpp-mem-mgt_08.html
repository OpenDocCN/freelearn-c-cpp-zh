<html><head></head><body>
<div epub:type="chapter" id="_idContainer035">
<h1 class="chapter-number" id="_idParaDest-126"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-127"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.2.1">Writing a Naïve Leak Detector</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In </span><a href="B21071_07.xhtml#_idTextAnchor116"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.5.1">, we examined various ways to overload the memory allocation operators, which are </span><strong class="source-inline"><span class="koboSpan" id="kobo.6.1">new</span></strong><span class="koboSpan" id="kobo.7.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.8.1">new[]</span></strong><span class="koboSpan" id="kobo.9.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.10.1">delete</span></strong><span class="koboSpan" id="kobo.11.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.12.1">delete[]</span></strong><span class="koboSpan" id="kobo.13.1">, in order to grasp the syntax involved in writing these operators as well as how they can be used in client code. </span><span class="koboSpan" id="kobo.13.2">We discussed how these operators interact with exceptions (even in the case of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.14.1">nothrow</span></strong><span class="koboSpan" id="kobo.15.1"> versions) and saw why they should, in most cases, be written in groups of four or multiples thereof. </span><span class="koboSpan" id="kobo.15.2">For example, code that calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.16.1">nothrow</span></strong><span class="koboSpan" id="kobo.17.1"> version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.18.1">operator new()</span></strong><span class="koboSpan" id="kobo.19.1"> to obtain some pointer, </span><strong class="source-inline"><span class="koboSpan" id="kobo.20.1">pV</span></strong><span class="koboSpan" id="kobo.21.1"> and later on calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.22.1">delete p</span></strong><span class="koboSpan" id="kobo.23.1"> will quickly get in trouble if one overloads the </span><strong class="source-inline"><span class="koboSpan" id="kobo.24.1">nothrow</span></strong><span class="koboSpan" id="kobo.25.1"> version but not the “regular” one, as both might then end up not being compatible with </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">one another.</span></span></p>
<p><span class="koboSpan" id="kobo.27.1">What we have not really discussed is how our code could benefit from taking control of these operators. </span><span class="koboSpan" id="kobo.27.2">There are indeed multiple uses for this: tracing how or where memory is allocated, measuring memory fragmentation in a process, implementing a specialized strategy to control performance characteristics of the allocation or deallocation process, and so on. </span><span class="koboSpan" id="kobo.27.3">Since this book has a finite size, we cannot hope to cover examples of all possible options so we will pick one, hoping that this example is sufficiently inspirational to let you explore other avenues on </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">your own.</span></span></p>
<p><span class="koboSpan" id="kobo.29.1">The example we will explore in this chapter is a simple yet functional memory leak detector. </span><span class="koboSpan" id="kobo.29.2">In more detail, we will do </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">the following:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.31.1">We will first detail the plan, giving an overview of how our leak detector will work and what tricks we will use to meet </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">our objectives.</span></span></li>
<li><span class="koboSpan" id="kobo.33.1">Then, we will implement the first version of our tool, and that version will seem to work, at least on the surface. </span><span class="koboSpan" id="kobo.33.2">We will walk through a call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.34.1">operator new()</span></strong><span class="koboSpan" id="kobo.35.1"> and the corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">operator delete()</span></strong><span class="koboSpan" id="kobo.37.1"> to understand what happens in memory throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">this process.</span></span></li>
<li><span class="koboSpan" id="kobo.39.1">At this point, we will use the knowledge acquired in previous chapters to identify the flaws in our first solution as well as ways in which we can </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">fix them.</span></span></li>
<li><span class="koboSpan" id="kobo.41.1">Finally, we will revisit our initial implementation and end up with something that is simple yet usable in </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">real code.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.43.1">Since this will be a very concrete chapter, you can expect to develop (or refine) some useful skills as </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">we go:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.45.1">The first one is to plan before coding. </span><span class="koboSpan" id="kobo.45.2">We will be writing very low-level code in this chapter, which makes it particularly important for us to have a clear direction in mind. </span><span class="koboSpan" id="kobo.45.3">After all, when coding “close to the machine” and playing with raw memory, the compiler-provided safety net that is the type system tends to be a bit thinner and it’s easier to make mistakes (costly ones at that) if we’re </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">not careful.</span></span></li>
<li><span class="koboSpan" id="kobo.47.1">The second one is to safely use shared mutable resources. </span><span class="koboSpan" id="kobo.47.2">Our leak detector will use the global versions of the memory allocation operators in order to cover allocation requests for all types, at least unless users decide to use specialized versions of these operators, and as such, we will need to manage the state that will be global to our program. </span><span class="koboSpan" id="kobo.47.3">In addition, we know that user code might be multithreaded so our accounting of the allocated memory will require a form of synchronization to avoid </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">data races.</span></span></li>
<li><span class="koboSpan" id="kobo.49.1">The third one will be to acknowledge the impact of alignment when bypassing the type system. </span><span class="koboSpan" id="kobo.49.2">As we will handle raw memory for the a priori unknown needs of client code, we will learn to make choices that work for all “natural” (in the sense of “non-overaligned”) memory allocation </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">use cases.</span></span></li>
<li><span class="koboSpan" id="kobo.51.1">Finally, we will examine how to debug our code based on the contents of raw memory. </span><span class="koboSpan" id="kobo.51.2">Since we aim to keep this book tooling-agnostic, we will apply a schematical approach to this problem, but in practice, you should adapt what we do in this chapter to the metaphors of your favorite debugging utility. </span><span class="koboSpan" id="kobo.51.3">All reasonable debuggers will let you examine the contents of a specific memory address, something you will assuredly want to do </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">on occasion.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.53.1">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">dive in!</span></span></p>
<h1 id="_idParaDest-128"><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.55.1">Technical requirements</span></h1>
<p><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.56.1">You can find the code files for this chapter in the book’s GitHub repository </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">here: </span></span><a href="https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter8"><span class="No-Break"><span class="koboSpan" id="kobo.58.1">https://github</span></span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter8</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.60.1">.</span></span></p>
<h1 id="_idParaDest-129"><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.61.1">The plan</span></h1>
<p><span class="koboSpan" id="kobo.62.1">We are planning to write a memory leak detector, a task that might seem strange and abstract at first. </span><span class="koboSpan" id="kobo.62.2">How do we start? </span><span class="koboSpan" id="kobo.62.3">Well, one way to clarify what we need to do is to write a small </span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.63.1">test program, showing at once how we expect our tool to be used and highlighting the key aspects of our tool from the perspective of </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">user code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.65.1">
#include &lt;iostream&gt;
// this is incomplete (for now)
int main() {
   auto pre = // current amount of allocated memory
   { // BEGIN
      int *p = new int{ 3 };
      int *q = new int[10]{ }; // initialized to zero
      delete p;
     // oops! </span><span class="koboSpan" id="kobo.65.2">Forgot to delete[] q
   } // END
   auto post = // current amount of allocated memory
   // with this code, supposing sizeof(int)==4, we
   // expect to see "Leaked 40 bytes" printed
   if(post != pre)
      std::cout &lt;&lt; "Leaked " &lt;&lt; (post - pre) &lt;&lt; " bytes\n";
}</span></pre> <p><span class="koboSpan" id="kobo.66.1">As you can see, this “deliberately leaky” program performs two allocations but only a single deallocation, “forgetting” (conveniently for our purposes) to deallocate an array of ten </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">int</span></strong><span class="koboSpan" id="kobo.68.1"> objects. </span><span class="koboSpan" id="kobo.68.2">Supposing </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">sizeof(int)==4</span></strong><span class="koboSpan" id="kobo.70.1">, our leak detector should allow the program to report a leak of </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">40 bytes.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">This program does not tell us how we will (portably) obtain the amount of dynamically allocated memory at a given time (we will write this service in this chapter, after all), but it does show the allocations and deallocations being located between a pair of braces (see </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">BEGIN</span></strong><span class="koboSpan" id="kobo.74.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">END</span></strong><span class="koboSpan" id="kobo.76.1"> in the comments of that example program). </span><span class="koboSpan" id="kobo.76.2">In C++, as you know, matching braces delimit a scope, and scope ensures the destruction of automatic variables defined therein. </span><span class="koboSpan" id="kobo.76.3">The idea here is that we want to detect leaks even in the presence of RAII objects (see </span><a href="B21071_04.xhtml#_idTextAnchor062"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.77.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.78.1">) as they too could have bugs, so we want to make sure they are destroyed before we try to issue </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">a diagnostic.</span></span></p>
<p><span class="koboSpan" id="kobo.80.1">As mentioned in this chapter’s introduction, we will implement our leak detector through the overloading of the </span><em class="italic"><span class="koboSpan" id="kobo.81.1">global</span></em><span class="koboSpan" id="kobo.82.1"> forms of memory allocation operators. </span><span class="koboSpan" id="kobo.82.2">As you might have already guessed, these operators will need to share some state: at the very least, they will </span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.83.1">need shared knowledge of the amount of memory allocated at a given moment since the </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">new</span></strong><span class="koboSpan" id="kobo.85.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">new[]</span></strong><span class="koboSpan" id="kobo.87.1"> operators will increment that amount and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">delete</span></strong><span class="koboSpan" id="kobo.89.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">delete[]</span></strong><span class="koboSpan" id="kobo.91.1"> operators will </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">decrement it.</span></span></p>
<p><span class="koboSpan" id="kobo.93.1">Note that for our leak detector, the array and non-array forms of these operators will be identical but that is </span><em class="italic"><span class="koboSpan" id="kobo.94.1">not</span></em><span class="koboSpan" id="kobo.95.1"> always the case: one could envision different strategies to allocate scalars and arrays, for example, just as one could want to track what these two forms do separately in a program. </span><span class="koboSpan" id="kobo.95.2">For simplicity, in this chapter, we will often simply mention </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">new</span></strong><span class="koboSpan" id="kobo.97.1"> to describe both </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">new</span></strong><span class="koboSpan" id="kobo.99.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">new[]</span></strong><span class="koboSpan" id="kobo.101.1"> and will use the same approach </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">delete</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.105.1">Since these are free functions, not member functions of some object, we will need to resort to a </span><em class="italic"><span class="koboSpan" id="kobo.106.1">global variable</span></em><span class="koboSpan" id="kobo.107.1"> for this state. </span><span class="koboSpan" id="kobo.107.2">I know global variables are often frowned upon, mostly for good reasons, but they exist for cases such </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">as this.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.109.1">Global variables, oh my!</span></p>
<p class="callout"><span class="koboSpan" id="kobo.110.1">Reasons to dislike </span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.111.1">global variables abound: they make local reasoning difficult (who knows where and when they are being accessed?), they tend to be bottlenecks for cache access and slow programs down, they tend to require synchronization in contemporary (potentially multithreaded) programs, and so on. </span><span class="koboSpan" id="kobo.111.2">We are resorting to this mechanism here because we need to: C++ provides us with a wide variety of tools because it is a language that is used to solve a wide variety of problems, so there’s no shame in using these tools when they are the right tools for the task at hand. </span><span class="koboSpan" id="kobo.111.3">Just ensure you make informed choices that you </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">can justify!</span></span></p>
<p><span class="koboSpan" id="kobo.113.1">To reduce (ever so slightly) the feeling </span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.114.1">of apparent revulsion that global variables provide to so many of us, we will encapsulate that state in an object, but of course, this object will also </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">be global.</span></span></p>
<p><span class="koboSpan" id="kobo.116.1">We will apply the </span><strong class="bold"><span class="koboSpan" id="kobo.117.1">singleton</span></strong><span class="koboSpan" id="kobo.118.1"> design </span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.119.1">pattern (also reviled by programmers at large, I know) to that end, a singleton being a class of which there is only one instance in a program. </span><span class="koboSpan" id="kobo.119.2">The benefit of this approach will be that we will control the ways in which the global state will be accessed; hopefully, it will also help clarify what we are doing. </span><span class="koboSpan" id="kobo.119.3">We will name our singleton class </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">Accountant</span></strong><span class="koboSpan" id="kobo.121.1"> since its responsibilities will be to help the memory allocation operators keep track of the number of bytes allocated and deallocated during </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">program execution.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.123.1">Singletons, oh my!</span></p>
<p class="callout"><span class="koboSpan" id="kobo.124.1">As far as design patterns go, the singleton is probably one of the least liked ones, for reasons similar to those behind the dislike of global variables: difficult to test or mock, requires synchronization, tends to become a performance bottleneck, and so on. </span><span class="koboSpan" id="kobo.124.2">The real culprit </span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.125.1">here to be honest is </span><strong class="bold"><span class="koboSpan" id="kobo.126.1">shared mutable state</span></strong><span class="koboSpan" id="kobo.127.1">, made worse by the fact that this state is globally accessible throughout the program. </span><span class="koboSpan" id="kobo.127.2">As you might have guessed by now, since the shared mutable state is exactly what we need to keep track of the amount of memory allocated at a given time, well… this is what we </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">will use!</span></span></p>
<p><span class="koboSpan" id="kobo.129.1">Now, for the actual implementation, we will need to develop a strategy to track the number of bytes allocated and deallocated. </span><span class="koboSpan" id="kobo.129.2">The overall idea is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">operator new()</span></strong><span class="koboSpan" id="kobo.131.1"> will tell the </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">Accountant</span></strong><span class="koboSpan" id="kobo.133.1"> object that bytes have been allocated, and that </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">operator delete()</span></strong><span class="koboSpan" id="kobo.135.1"> will tell the </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">Accountant</span></strong><span class="koboSpan" id="kobo.137.1"> object that bytes have been deallocated. </span><span class="koboSpan" id="kobo.137.2">Now, for the purpose of this activity, we will use the traditional (up to and including C++11) form of these operators. </span><span class="koboSpan" id="kobo.137.3">As you might remember from </span><a href="B21071_07.xhtml#_idTextAnchor116"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.138.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.139.1">, their signatures are </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.141.1">
void *operator new(std::size_t n);
void *operator new[](std::size_t n);
void operator delete(void*p) noexcept;
void operator delete[](void*p) noexcept;</span></pre> <p><span class="koboSpan" id="kobo.142.1">Since you are reading this book, you are assuredly a most astute reader, so you might have already noticed a problem here: our allocation functions know from their argument the number </span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.143.1">of bytes to allocate, but our deallocation functions do not have that privilege, being only provided the address where the block to deallocate begins. </span><span class="koboSpan" id="kobo.143.2">This means that we need a way to make the connection between the address returned by </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">operator new()</span></strong><span class="koboSpan" id="kobo.145.1"> and the size of the associated </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">memory block.</span></span></p>
<p><span class="koboSpan" id="kobo.147.1">That seems like an easy enough problem to solve: just allocate the moral equivalent of something like </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">std::vector&lt;std::pair&lt;void*,std::size_t&gt;&gt;</span></strong><span class="koboSpan" id="kobo.149.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">std::map&lt;void*,std::size_t&gt;</span></strong><span class="koboSpan" id="kobo.151.1"> to make it easy to retrieve the </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">std::size_t</span></strong><span class="koboSpan" id="kobo.153.1"> associated with a given address, but such containers need to allocate memory, and that would mean allocating memory in order to implement the way in which we allocate memory. </span><span class="koboSpan" id="kobo.153.2">This could get problematic, to say the least, so we need </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">another solution.</span></span></p>
<p><span class="koboSpan" id="kobo.155.1">We will do </span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.156.1">what any sane programmer would do under similar circumstances: we will lie. </span><span class="koboSpan" id="kobo.156.2">Yes, we will! </span><span class="koboSpan" id="kobo.156.3">Why do you think we took the time to look at tricky and dangerous code in those </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">first chapters?</span></span></p>
<p><span class="koboSpan" id="kobo.158.1">How will lying help us solve the problem, you say? </span><span class="koboSpan" id="kobo.158.2">Well, remember that writing the following code leads to calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">operator new()</span></strong><span class="koboSpan" id="kobo.160.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">sizeof(X)</span></strong><span class="koboSpan" id="kobo.162.1"> as </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">an argument:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.164.1">
X *p = new X{ /* ... </span><span class="koboSpan" id="kobo.164.2">*/ };</span></pre> <p><span class="koboSpan" id="kobo.165.1">Let us name this argument </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">n</span></strong><span class="koboSpan" id="kobo.167.1">. </span><span class="koboSpan" id="kobo.167.2">This means that if the allocation and the ensuing construction both succeed, from the perspective of client code, the situation will be </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer027">
<span class="koboSpan" id="kobo.169.1"><img alt="Figure 8.1 – Allocated block of memory from the perspective of client code" src="image/B21071_08_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.170.1">Figure 8.1 – Allocated block of memory from the perspective of client code</span></p>
<p><span class="koboSpan" id="kobo.171.1">In order for </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">operator delete()</span></strong><span class="koboSpan" id="kobo.173.1"> to be able to find the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">n</span></strong><span class="koboSpan" id="kobo.175.1"> based on </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">p</span></strong><span class="koboSpan" id="kobo.177.1">, one strategy (and the one we will adopt for this example) will be to hide the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">n</span></strong><span class="koboSpan" id="kobo.179.1"> just before </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">p</span></strong><span class="koboSpan" id="kobo.181.1">. </span><span class="koboSpan" id="kobo.181.2">The actual layout in memory from our own code’s perspective would then be </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer028">
<span class="koboSpan" id="kobo.183.1"><img alt="Figure 8.2 – Allocated block of memory from the perspective of the allocation operators." src="image/B21071_08_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.184.1">Figure 8.2 – Allocated block of memory from the perspective of the allocation operators.</span></p>
<p><span class="koboSpan" id="kobo.185.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">p</span></strong><span class="koboSpan" id="kobo.187.1"> would be the address as seen from the client code, but </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">p'</span></strong><span class="koboSpan" id="kobo.189.1"> would be where the actually allocated </span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.190.1">block of memory starts. </span><span class="koboSpan" id="kobo.190.2">Clearly, </span><em class="italic"><span class="koboSpan" id="kobo.191.1">this is a lie</span></em><span class="koboSpan" id="kobo.192.1">: the address returned by the allocation function will be a valid address where an object can be constructed, but it will not be the start of the memory block we have actually allocated. </span><span class="koboSpan" id="kobo.192.2">As long as the space between </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">p</span></strong><span class="koboSpan" id="kobo.194.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">p'</span></strong><span class="koboSpan" id="kobo.196.1"> is known to both </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">operator new()</span></strong><span class="koboSpan" id="kobo.198.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">operator delete()</span></strong><span class="koboSpan" id="kobo.200.1">, this can be made </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">to work.</span></span></p>
<p><span class="koboSpan" id="kobo.202.1">For obvious reasons, overloading </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">operator new()</span></strong><span class="koboSpan" id="kobo.204.1"> to do this trickery means that we have to overload </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">operator delete()</span></strong><span class="koboSpan" id="kobo.206.1"> to do the reverse gymnastics: given some pointer </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">p</span></strong><span class="koboSpan" id="kobo.208.1">, go backward in memory where </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">p'</span></strong><span class="koboSpan" id="kobo.210.1"> was, find the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">n</span></strong><span class="koboSpan" id="kobo.212.1"> that was hidden there, and inform the </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">Accountant</span></strong><span class="koboSpan" id="kobo.214.1"> object of the fact that </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">n</span></strong><span class="koboSpan" id="kobo.216.1"> bytes </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">were released.</span></span></p>
<p><span class="koboSpan" id="kobo.218.1">Now, let’s see how we will </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">do this.</span></span></p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.220.1">A first implementation (that almost works)</span></h1>
<p><span class="koboSpan" id="kobo.221.1">We now </span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.222.1">have a plan, so we are ready to start implementing the initial version of our leak detector. </span><span class="koboSpan" id="kobo.222.2">This implementation will be slightly naïve but will help us understand the general idea; we will examine the more delicate aspects of the implementation once the basic infrastructure is in place. </span><em class="italic"><span class="koboSpan" id="kobo.223.1">Do not use this first version in production code</span></em><span class="koboSpan" id="kobo.224.1"> as it will be (slightly yet dangerously) incorrect. </span><span class="koboSpan" id="kobo.224.2">We will provide a correct version later in this chapter, </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">of course.</span></span></p>
<p><span class="koboSpan" id="kobo.226.1">As a suggestion, try to see if you can identify the “rough edges” of our implementation by yourself before we cover them later in this chapter. </span><span class="koboSpan" id="kobo.226.2">There will be clues left here and there for you, and if you read the chapters that preceded this one, you might already have an idea of what you should be </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">looking for.</span></span></p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.228.1">The Accountant singleton class</span></h2>
<p><span class="koboSpan" id="kobo.229.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">Accountant</span></strong><span class="koboSpan" id="kobo.231.1"> class will be a reification of the singleton design pattern whose role will be to </span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.232.1">allow the global overloads of the memory allocation operators to keep track of the number of bytes of dynamically allocated </span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.233.1">memory in a program. </span><span class="koboSpan" id="kobo.233.2">As previously mentioned, a singleton is an idea: a class for which there is only one instance in a program. </span><span class="koboSpan" id="kobo.233.3">This idea can be reified in various languages (at least those supporting some variant of the object-oriented paradigm) in ways that respect the particularities of </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">each language.</span></span></p>
<p><span class="koboSpan" id="kobo.235.1">One key particularity of C++ is the presence of actual objects, not just references to objects, in user </span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.236.1">code. </span><span class="koboSpan" id="kobo.236.2">This means that a C++ singleton will usually have the </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">following characteristics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.238.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">private</span></strong><span class="koboSpan" id="kobo.240.1"> default constructor, since if that constructor was </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">public</span></strong><span class="koboSpan" id="kobo.242.1">, it could be called more than once which would make the class </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">a non-singleton.</span></span></li>
<li><span class="koboSpan" id="kobo.244.1">Deleted copy operations, as allowing copies of our object would make it </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">a non-singleton.</span></span></li>
<li><span class="koboSpan" id="kobo.246.1">A way to ensure the singleton can be created and, of course, accessed. </span><span class="koboSpan" id="kobo.246.2">That mechanism has to be such that it cannot be abused to create more than one object. </span><span class="koboSpan" id="kobo.246.3">Since our default constructor will be </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">private</span></strong><span class="koboSpan" id="kobo.248.1">, this mechanism will either be a </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">static</span></strong><span class="koboSpan" id="kobo.250.1"> member function (this will be our choice) or a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">friend</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.252.1"> function.</span></span></li>
<li><span class="koboSpan" id="kobo.253.1">Finally, the state used for the object’s representation and the services offered by the singleton, </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">if any.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.255.1">An object of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">Accountant</span></strong><span class="koboSpan" id="kobo.257.1"> class will expose three services: one to let the </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">new</span></strong><span class="koboSpan" id="kobo.259.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">new[]</span></strong><span class="koboSpan" id="kobo.261.1"> operators inform the </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">Accountant</span></strong><span class="koboSpan" id="kobo.263.1"> object that memory has been taken, one to inform it that memory has been given back, and one to let client code know how much memory is used at a </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">given time.</span></span></p>
<p><span class="koboSpan" id="kobo.265.1">An incomplete </span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.266.1">view of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">Accountant</span></strong><span class="koboSpan" id="kobo.268.1"> class given </span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.269.1">what we have discussed so far would be </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.271.1">
#ifndef LEAK_DETECTOR_H
#define LEAK_DETECTOR_H
#include &lt;cstddef&gt;
#include &lt;new&gt;
class Accountant {
</span><strong class="bold"><span class="koboSpan" id="kobo.272.1">   Accountant(); // note: private</span></strong><span class="koboSpan" id="kobo.273.1">
   //...
</span><span class="koboSpan" id="kobo.273.2">public:
   // deleted copy operations
</span><strong class="bold"><span class="koboSpan" id="kobo.274.1">   Accountant(const Accountant&amp;) = delete;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.275.1">   Accountant&amp; operator=(const Accountant&amp;) = delete;</span></strong><span class="koboSpan" id="kobo.276.1">
   // to access the singleton object
</span><strong class="bold"><span class="koboSpan" id="kobo.277.1">   static Accountant&amp; get();</span></strong><span class="koboSpan" id="kobo.278.1">
   // services offered by the object
   // n bytes were allocated
</span><strong class="bold"><span class="koboSpan" id="kobo.279.1">   void take(std::size_t n);</span></strong><span class="koboSpan" id="kobo.280.1">
   // n bytes were deallocated
</span><strong class="bold"><span class="koboSpan" id="kobo.281.1">   void give_back(std::size_t n);</span></strong><span class="koboSpan" id="kobo.282.1">
   // number of bytes currently allocated
</span><strong class="bold"><span class="koboSpan" id="kobo.283.1">   std::size_t how_much() const;</span></strong><span class="koboSpan" id="kobo.284.1">
};
// allocation operators (free functions)
void *operator new(std::size_t);
void *operator new[](std::size_t);
void operator delete(void*) noexcept;
void operator delete[](void*) noexcept;
#endif</span></pre> <p><span class="koboSpan" id="kobo.285.1">With this, we can </span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.286.1">already complete the skeleton of our test program </span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.287.1">as presented earlier in </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">this chapter:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.289.1">#include "leak_detector.h"</span></strong><span class="koboSpan" id="kobo.290.1">
#include &lt;iostream&gt;
int main() {
</span><strong class="bold"><span class="koboSpan" id="kobo.291.1">   auto pre = Accountant::get().how_much();</span></strong><span class="koboSpan" id="kobo.292.1">
   { // BEGIN
      int *p = new int{ 3 };
      int *q = new int[10]{ }; // initialized to zero
      delete p;
     // oops! </span><span class="koboSpan" id="kobo.292.2">Forgot to delete[] q
   } // END
</span><strong class="bold"><span class="koboSpan" id="kobo.293.1">   auto post = Accountant::get().how_much();</span></strong><span class="koboSpan" id="kobo.294.1">
   // with this code, supposing sizeof(int)==4, we
   // expect to see "Leaked 40 bytes" printed
   if(post != pre)
      std::cout &lt;&lt; "Leaked " &lt;&lt; (post - pre) &lt;&lt; " bytes\n";
}</span></pre> <p><span class="koboSpan" id="kobo.295.1">Now, we need to examine the implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">Accountant</span></strong><span class="koboSpan" id="kobo.297.1"> class. </span><span class="koboSpan" id="kobo.297.2">The first thing we need to decide is how and where the actual object will be created. </span><span class="koboSpan" id="kobo.297.3">It happens that there are surprisingly many ways to do this, but in our case (where we are not concerned </span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.298.1">by execution speed), the simplest </span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.299.1">way to correctly instantiate the object is what is called a </span><strong class="bold"><span class="koboSpan" id="kobo.300.1">Meyers Singleton</span></strong><span class="koboSpan" id="kobo.301.1">, in honor </span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.302.1">of the now-retired but always respected </span><strong class="bold"><span class="koboSpan" id="kobo.303.1">Scott Meyers</span></strong><span class="koboSpan" id="kobo.304.1">, who suggested that technique as part of </span><em class="italic"><span class="koboSpan" id="kobo.305.1">item 47</span></em><span class="koboSpan" id="kobo.306.1"> in his well-known book, </span><em class="italic"><span class="koboSpan" id="kobo.307.1">Effective C++: Specific Ways to Improve Your Programs and Designs (3rd Edition), </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.308.1">Addison-Wesley Professional</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.310.1">The Meyers Singleton technique</span></p>
<p class="callout"><span class="koboSpan" id="kobo.311.1">The Meyers Singleton technique aims to avoid something colloquially called the </span><strong class="bold"><span class="koboSpan" id="kobo.312.1">static initialization order fiasco</span></strong><span class="koboSpan" id="kobo.313.1">, an informal name given to the fact that in a C++ program made of multiple translation units, one cannot know from the source code in which order the global objects will be constructed (the problem also exists for the order of destruction, although the Meyers technique is not helpful </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">for this).</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.315.1">The trick is to declare the singleton object as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">static</span></strong><span class="koboSpan" id="kobo.317.1"> local variable in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">static</span></strong><span class="koboSpan" id="kobo.319.1"> member function that provides access to the object (here, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">get()</span></strong><span class="koboSpan" id="kobo.321.1"> function): doing so ensures the object will be created only once, the first time the function is called, and will keep its state throughout the execution of the program. </span><span class="koboSpan" id="kobo.321.2">There is a slight but measurable cost to doing so as there is a form of low-level implicit synchronization surrounding the object’s construction to avoid the object being created more than once even in a </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">multithreaded program.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.323.1">This technique ensures all such singletons are created in the correct order (meaning that, if the constructor of singleton A needs a service from singleton B, this will lead to singleton B being constructed “just in time”) even if they are technically “global” variables, as long as there is no cycle in the calls that create them </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">of course.</span></span></p>
<p><span class="koboSpan" id="kobo.325.1">In terms of state, since </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">take()</span></strong><span class="koboSpan" id="kobo.327.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">give_back()</span></strong><span class="koboSpan" id="kobo.329.1"> both accept an argument of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">std::size_t</span></strong><span class="koboSpan" id="kobo.331.1">, it would be tempting to represent the current amount of memory also as </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">std::size_t</span></strong><span class="koboSpan" id="kobo.333.1">, but allow me to recommend something else. </span><span class="koboSpan" id="kobo.333.2">Indeed, </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">std::size_t</span></strong><span class="koboSpan" id="kobo.335.1"> is an alias for an </span><em class="italic"><span class="koboSpan" id="kobo.336.1">unsigned</span></em><span class="koboSpan" id="kobo.337.1"> integral type, which means that this representation would make it difficult to detect a case where there have been more bytes </span><em class="italic"><span class="koboSpan" id="kobo.338.1">deallocated</span></em><span class="koboSpan" id="kobo.339.1"> than allocated, an unpleasant situation we would surely like to handle. </span><span class="koboSpan" id="kobo.339.2">For that reason, we will use a (large) signed </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">integral instead.</span></span></p>
<p><span class="koboSpan" id="kobo.341.1">Fine, you might think: we can use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">long long</span></strong><span class="koboSpan" id="kobo.343.1"> representation then! </span><span class="koboSpan" id="kobo.343.2">However, remember that memory allocation and deallocation mechanisms need to be thread-safe, so we need </span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.344.1">to ensure that all accesses to that integral representation </span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.345.1">will be synchronized. </span><span class="koboSpan" id="kobo.345.2">There are many ways to do this, but the simplest one is probably to use an atomic type, in our case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">std::atomic&lt;long long&gt;</span></strong><span class="koboSpan" id="kobo.347.1">. </span><span class="koboSpan" id="kobo.347.2">Note that atomic objects are uncopiable so our singleton would implicitly be uncopiable, but there’s no harm in stating that fact explicitly as we did when deleting the </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">copy operations.</span></span></p>
<p><span class="koboSpan" id="kobo.349.1">A complete implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">Accountant</span></strong><span class="koboSpan" id="kobo.351.1"> class would be </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.353.1">
#ifndef LEAK_DETECTOR_H
#define LEAK_DETECTOR_H
#include &lt;cstddef&gt;
</span><strong class="bold"><span class="koboSpan" id="kobo.354.1">#include &lt;atomic&gt;</span></strong><span class="koboSpan" id="kobo.355.1">
#include &lt;new&gt;
class Accountant {
</span><strong class="bold"><span class="koboSpan" id="kobo.356.1">   std::atomic&lt;long long&gt; cur;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.357.1">   Accountant() : cur{ 0LL } { // note: private</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.358.1">   }</span></strong><span class="koboSpan" id="kobo.359.1">
public:
   // deleted copy operations
   Accountant(const Accountant&amp;) = delete;
   Accountant&amp; operator=(const Accountant&amp;) = delete;
   // to access the singleton object
</span><strong class="bold"><span class="koboSpan" id="kobo.360.1">   static auto&amp; get() { // auto used for simplicity</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.361.1">      static Accountant singleton; // here it is</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.362.1">      return singleton;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.363.1">   }</span></strong><span class="koboSpan" id="kobo.364.1">
   // services offered by the object
   // n bytes were allocated
</span><strong class="bold"><span class="koboSpan" id="kobo.365.1">   void take(std::size_t n) { cur += n; }</span></strong><span class="koboSpan" id="kobo.366.1">
   // n bytes were deallocated
</span><strong class="bold"><span class="koboSpan" id="kobo.367.1">   void give_back(std::size_t n) { cur -= n; }</span></strong><span class="koboSpan" id="kobo.368.1">
   // number of bytes currently allocated
</span><strong class="bold"><span class="koboSpan" id="kobo.369.1">   std::size_t how_much() const { return cur.load(); }</span></strong><span class="koboSpan" id="kobo.370.1">
};
// allocation operators (free functions)
void *operator new(std::size_t);
void *operator new[](std::size_t);
void operator delete(void*) noexcept;
void operator delete[](void*) noexcept;
#endif</span></pre> <p><span class="koboSpan" id="kobo.371.1">The services </span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.372.1">are probably trivial to understand </span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.373.1">for the most part. </span><span class="koboSpan" id="kobo.373.2">Since </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">cur</span></strong><span class="koboSpan" id="kobo.375.1"> is an atomic object, operations such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">+=</span></strong><span class="koboSpan" id="kobo.377.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">-=</span></strong><span class="koboSpan" id="kobo.379.1"> modify </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">cur</span></strong><span class="koboSpan" id="kobo.381.1"> in a synchronized manner, avoiding data races. </span><span class="koboSpan" id="kobo.381.2">Two subtle aspects of </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">how_much()</span></strong><span class="koboSpan" id="kobo.383.1"> deserve a </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">short discussion:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.385.1">The first is that we are returning </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">cur.load()</span></strong><span class="koboSpan" id="kobo.387.1">, not </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">cur</span></strong><span class="koboSpan" id="kobo.389.1">, since we care about the value represented by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">atomic</span></strong><span class="koboSpan" id="kobo.391.1"> object, not the atomic object itself (which is a synchronization mechanism, not an integral value, and is uncopiable as previously mentioned). </span><span class="koboSpan" id="kobo.391.2">It’s like taking a picture of that value at a specific point in </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">time, really.</span></span></li>
<li><span class="koboSpan" id="kobo.393.1">The second, a consequence of the first, is that by the time the client code gets the value returned by that function, the actual value might have changed, so this function is inherently “racy” if used in a multithreaded situation. </span><span class="koboSpan" id="kobo.393.2">It’s not a problem for our test code, of course, but it’s something to be </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">aware of.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.395.1">Now that we have put in place a scaffolding for keeping track of the number of bytes allocated, we can start to write the actual allocation and </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">deallocation functions.</span></span></p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.397.1">Implementing the new and new[] operators</span></h2>
<p><span class="koboSpan" id="kobo.398.1">If you remember our plan, what we will do in our memory allocation operators is take the number </span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.399.1">of bytes, </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">n</span></strong><span class="koboSpan" id="kobo.401.1">, requested by client code, then </span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.402.1">allocate slightly more because we will hide </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">n</span></strong><span class="koboSpan" id="kobo.404.1"> just before the beginning of the block of </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">n</span></strong><span class="koboSpan" id="kobo.406.1"> bytes we will end up returning to </span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.407.1">our client. </span><span class="koboSpan" id="kobo.407.2">Minimally, we will need to allocate </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">n + sizeof n</span></strong><span class="koboSpan" id="kobo.409.1"> bytes to </span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.410.1">achieve this. </span><span class="koboSpan" id="kobo.410.2">In this example, we will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">std::malloc()</span></strong><span class="koboSpan" id="kobo.412.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">std::free()</span></strong><span class="koboSpan" id="kobo.414.1"> to perform the low-level </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">allocation operations.</span></span></p>
<p><span class="koboSpan" id="kobo.416.1">We will signal failure to allocate by throwing </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">std::bad_alloc</span></strong><span class="koboSpan" id="kobo.418.1"> as is customary in C++. </span><span class="koboSpan" id="kobo.418.2">If the allocation succeeds, we will then inform the </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">Accountant</span></strong><span class="koboSpan" id="kobo.420.1"> object that </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">n</span></strong><span class="koboSpan" id="kobo.422.1"> bytes have been allocated, even though we will have allocated a bit more. </span><span class="koboSpan" id="kobo.422.2">The fact that our strategy leads us to allocate more than requested is an artifact that does not concern client code, and that might even be confusing when trying to diagnose problems: a program that allocates a single byte and is informed that it leaked much more than this would be </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">somewhat awkward.</span></span></p>
<p><span class="koboSpan" id="kobo.424.1">A complete but naïve (and slightly incorrect, as announced) implementation would be </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.426.1">
#include &lt;cstdlib&gt;
void *operator new(std::size_t n) {
</span><strong class="bold"><span class="koboSpan" id="kobo.427.1">   // allocate n bytes plus enough space to hide n</span></strong><span class="koboSpan" id="kobo.428.1">
   void *p = std::malloc(n + sizeof n); </span><strong class="bold"><span class="koboSpan" id="kobo.429.1">// to revisit</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.430.1">   // signal failure to meet postconditions if needed</span></strong><span class="koboSpan" id="kobo.431.1">
   if(!p) throw std::bad_alloc{};
</span><strong class="bold"><span class="koboSpan" id="kobo.432.1">   // hide n at the beginning of the allocated block</span></strong><span class="koboSpan" id="kobo.433.1">
   auto q = static_cast&lt;std::size_t*&gt;(p);
   *q = n; </span><strong class="bold"><span class="koboSpan" id="kobo.434.1">// to revisit</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.435.1">   // inform the Accountant of the allocation</span></strong><span class="koboSpan" id="kobo.436.1">
   Accountant::get().take(n);
</span><strong class="bold"><span class="koboSpan" id="kobo.437.1">   // return the beginning of the requested block memory</span></strong><span class="koboSpan" id="kobo.438.1">
   return q + 1; </span><strong class="bold"><span class="koboSpan" id="kobo.439.1">// to revisit</span></strong><span class="koboSpan" id="kobo.440.1">
}
void *operator new[](std::size_t n) {
   // exactly the same as operator new above
}</span></pre> <p><span class="koboSpan" id="kobo.441.1">Remember that </span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.442.1">even though </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">operator new()</span></strong><span class="koboSpan" id="kobo.444.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">operator new[]()</span></strong><span class="koboSpan" id="kobo.446.1"> are identical </span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.447.1">in this example, there is no obligation </span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.448.1">to make them the same in all situations. </span><span class="koboSpan" id="kobo.448.2">Also, note </span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.449.1">that some of the lines in this excerpt have a comment stating “to revisit” as we will want to take a closer look at these later in </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">this chapter.</span></span></p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.451.1">Implementing the delete and delete[] operators</span></h2>
<p><span class="koboSpan" id="kobo.452.1">Our deallocation </span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.453.1">operators will collaborate in the elaborate lie prepared </span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.454.1">by the allocation operators: we know that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">new</span></strong><span class="koboSpan" id="kobo.456.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">new[]</span></strong><span class="koboSpan" id="kobo.458.1"> operators </span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.459.1">return pointers to a block </span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.460.1">of </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">n</span></strong><span class="koboSpan" id="kobo.462.1"> bytes, but that block is not what has really been allocated, it’s “just” the place where an object lived for a while. </span><span class="koboSpan" id="kobo.462.2">For that reason, it’s important that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">delete</span></strong><span class="koboSpan" id="kobo.464.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">delete[]</span></strong><span class="koboSpan" id="kobo.466.1"> operators do the required address adjustment before performing the </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">actual deallocation.</span></span></p>
<p><span class="koboSpan" id="kobo.468.1">The rules for a correct implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">operator delete</span></strong><span class="koboSpan" id="kobo.470.1"> are </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.472.1">Applying </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">operator delete()</span></strong><span class="koboSpan" id="kobo.474.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">operator delete[]()</span></strong><span class="koboSpan" id="kobo.476.1"> on a null pointer is </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">a no-op</span></span></li>
<li><span class="koboSpan" id="kobo.478.1">Deallocation functions should </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">not throw</span></span></li>
<li><span class="koboSpan" id="kobo.480.1">The deallocation code should be coherent with the associated </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">allocation function</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.482.1">Not all null pointers are the same</span></p>
<p class="callout"><span class="koboSpan" id="kobo.483.1">While it’s true that given some </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">T*</span></strong><span class="koboSpan" id="kobo.485.1"> object named </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">p</span></strong><span class="koboSpan" id="kobo.487.1">, writing </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">delete p</span></strong><span class="koboSpan" id="kobo.489.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">delete [] p</span></strong><span class="koboSpan" id="kobo.491.1"> will be a no-op if </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">p==nullptr</span></strong><span class="koboSpan" id="kobo.493.1">. </span><span class="koboSpan" id="kobo.493.2">However, writing </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">delete nullptr</span></strong><span class="koboSpan" id="kobo.495.1"> will fail to compile as </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">nullptr</span></strong><span class="koboSpan" id="kobo.497.1"> is an object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">std::nullptr_t</span></strong><span class="koboSpan" id="kobo.499.1">, not </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">a pointer.</span></span></p>
<p><span class="koboSpan" id="kobo.501.1">Given the </span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.502.1">implementation of our allocation operators in the previous </span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.503.1">section, this means a mostly adequate </span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.504.1">deallocation operator could be </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">as </span></span><span class="No-Break"><a id="_idIndexMarker471"/></span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.507.1">
void operator delete(void *p) noexcept {
</span><strong class="bold"><span class="koboSpan" id="kobo.508.1">   // delete on a null pointer is a no-op</span></strong><span class="koboSpan" id="kobo.509.1">
   if(!p) return;
</span><strong class="bold"><span class="koboSpan" id="kobo.510.1">   // find the beginning of the block that was allocated</span></strong><span class="koboSpan" id="kobo.511.1">
   auto q = static_cast&lt;std::size_t*&gt;(p) - 1; </span><strong class="bold"><span class="koboSpan" id="kobo.512.1">// to revisit</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.513.1">   // inform the Accountant of the deallocation</span></strong><span class="koboSpan" id="kobo.514.1">
   Accountant::get().give_back(*q);
</span><strong class="bold"><span class="koboSpan" id="kobo.515.1">   // free the memory</span></strong><span class="koboSpan" id="kobo.516.1">
   std::free(q);
}
void operator delete[](void *p) noexcept {
   // exactly the same as operator delete above
}</span></pre> <p><span class="koboSpan" id="kobo.517.1">That completes the lie, or so to say, and it completes the leak detector, at least for this first (and imperfect) implementation. </span><span class="koboSpan" id="kobo.517.2">If you run the test program with our implementation on a compiler where </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">sizeof(int)==4</span></strong><span class="koboSpan" id="kobo.519.1">, you can expect it to display that its execution leaked 40 bytes </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">as expected.</span></span></p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.521.1">Visualizing it all</span></h2>
<p><span class="koboSpan" id="kobo.522.1">When enjoying low-level programming such as this (taking over the memory allocation functions </span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.523.1">of your program, manipulating raw memory blocks, hiding information, and playing tricks with addresses), it can be hard to visualize what one is doing, and what the </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">consequences are.</span></span></p>
<p><span class="koboSpan" id="kobo.525.1">If your favorite debugger allows you to do so, you might want to try to go through the test program’s execution step by step. </span><span class="koboSpan" id="kobo.525.2">Please make sure you work in so-called “debug” (unoptimized) mode to fully benefit from the experience, as optimized code is often sufficiently transformed by the compiler to make the association between source code and generated code difficult </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">to make.</span></span></p>
<p><span class="koboSpan" id="kobo.527.1">Let’s walk through a call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">operator new()</span></strong><span class="koboSpan" id="kobo.529.1"> step by step. </span><span class="koboSpan" id="kobo.529.2">The first thing we do is ask </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">Accountant</span></strong><span class="koboSpan" id="kobo.531.1"> for the amount of dynamically allocated memory at the beginning of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">main()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.533.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.534.1">
int main() {
</span><strong class="bold"><span class="koboSpan" id="kobo.535.1">   auto pre = Accountant::get().how_much();</span></strong><span class="koboSpan" id="kobo.536.1">
   { // BEGIN
</span><strong class="bold"><span class="koboSpan" id="kobo.537.1">      int *p = new int{ 3 };</span></strong><span class="koboSpan" id="kobo.538.1">
      int *q = new int[10]{ }; // initialized to zero
      delete p;
     // oops! </span><span class="koboSpan" id="kobo.538.2">Forgot to delete[] q
   } // END
</span><strong class="bold"><span class="koboSpan" id="kobo.539.1">   auto post = Accountant::get().how_much();</span></strong><span class="koboSpan" id="kobo.540.1">
   if(post != pre)
      std::cout &lt;&lt; "Leaked " &lt;&lt; (post - pre) &lt;&lt; " bytes\n";
}</span></pre> <p><span class="koboSpan" id="kobo.541.1">One can expect </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">pre==0</span></strong><span class="koboSpan" id="kobo.543.1"> at this point but there are situations, such as a global object calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">new</span></strong><span class="koboSpan" id="kobo.545.1"> in its constructor, that could lead to </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">pre</span></strong><span class="koboSpan" id="kobo.547.1"> having other values. </span><span class="koboSpan" id="kobo.547.2">This is fine, as what we are monitoring with this approach is whether there is a leak in between the braces marked with </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">BEGIN</span></strong><span class="koboSpan" id="kobo.549.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">END</span></strong><span class="koboSpan" id="kobo.551.1">, and this should hold regardless of whether the amount of bytes allocated outside of those braces is zero </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">or not.</span></span></p>
<p><span class="koboSpan" id="kobo.553.1">The next </span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.554.1">step is calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">operator new()</span></strong><span class="koboSpan" id="kobo.556.1"> and requesting a memory block big enough to store an </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">int</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.558.1"> object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.559.1">
int main() {
</span><strong class="bold"><span class="koboSpan" id="kobo.560.1">   auto pre = Accountant::get().how_much();</span></strong><span class="koboSpan" id="kobo.561.1">
   { // BEGIN
</span><strong class="bold"><span class="koboSpan" id="kobo.562.1">      int *p = new int{ 3 };</span></strong><span class="koboSpan" id="kobo.563.1">
      int *q = new int[10]{ }; // initialized to zero
      delete p;
     // oops! </span><span class="koboSpan" id="kobo.563.2">Forgot to delete[] q
   } // END
</span><strong class="bold"><span class="koboSpan" id="kobo.564.1">   auto post = Accountant::get().how_much();</span></strong><span class="koboSpan" id="kobo.565.1">
   if(post != pre)
      std::cout &lt;&lt; "Leaked " &lt;&lt; (post - pre) &lt;&lt; " bytes\n";
}</span></pre> <p><span class="koboSpan" id="kobo.566.1">This leads us to our implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">operator new()</span></strong><span class="koboSpan" id="kobo.568.1"> where </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">n==sizeof(int)</span></strong><span class="koboSpan" id="kobo.570.1">. </span><span class="koboSpan" id="kobo.570.2">Supposing </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">sizeof(int)==4</span></strong><span class="koboSpan" id="kobo.572.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">sizeof(std::size_t)==8</span></strong><span class="koboSpan" id="kobo.574.1"> for the sake of this example, our call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">std::malloc()</span></strong><span class="koboSpan" id="kobo.576.1"> will request a block of at least </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">12 bytes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.578.1">
void *operator new(</span><strong class="bold"><span class="koboSpan" id="kobo.579.1">std::size_t n</span></strong><span class="koboSpan" id="kobo.580.1">) {
</span><strong class="bold"><span class="koboSpan" id="kobo.581.1">   void *p = std::malloc(n + sizeof n);</span></strong><span class="koboSpan" id="kobo.582.1">
   if(!p) throw std::bad_alloc{};
   auto q = static_cast&lt;std::size_t*&gt;(p);
   *q = n;
   Accountant::get().take(n);
   return q + 1;
}</span></pre> <p><span class="koboSpan" id="kobo.583.1">If you look at the memory pointed to by </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">p</span></strong><span class="koboSpan" id="kobo.585.1"> with your debugger once the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">std::malloc()</span></strong><span class="koboSpan" id="kobo.587.1"> completes, you might see something like the following (all numbers are expressed in </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">hexadecimal form):</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<span class="koboSpan" id="kobo.589.1"><img alt="Figure 8.3 – Possible initial state for the allocated block" src="image/B21071_08_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.590.1">Figure 8.3 – Possible initial state for the allocated block</span></p>
<p><span class="koboSpan" id="kobo.591.1">Note that there is no guarantee that you will see these specific values as C++ does not impose any </span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.592.1">requirement on the initialization of the memory block returned by </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">std::malloc()</span></strong><span class="koboSpan" id="kobo.594.1">. </span><span class="koboSpan" id="kobo.594.2">These </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">0xcd</span></strong><span class="koboSpan" id="kobo.596.1"> hexadecimal values (or similar recognizable patterns) are however probable when using a “debug build” as libraries compiled for debugging will often place recognizable bit patterns in uninitialized memory to help detect </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">programming errors.</span></span></p>
<p><span class="koboSpan" id="kobo.598.1">You might also notice the trailing four bytes (each containing </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">0xfd</span></strong><span class="koboSpan" id="kobo.600.1">), which are also suspiciously recognizable, suggesting that the implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">std::malloc()</span></strong><span class="koboSpan" id="kobo.602.1"> I used allocated more than what I requested and stored a marker just after the block my code requested, probably to help detect buffer overruns. </span><span class="koboSpan" id="kobo.602.2">Our library has the same implementation freedom as we do, </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">after all!</span></span></p>
<p><span class="koboSpan" id="kobo.604.1">The first lie we did was the overallocation of memory with respect to the actual request we got. </span><span class="koboSpan" id="kobo.604.2">We now commit a second lie about the very nature of the memory we are </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">pointing to:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.606.1">
void *operator new(std::size_t n) {
</span><strong class="bold"><span class="koboSpan" id="kobo.607.1">   </span></strong><strong class="bold"><span class="koboSpan" id="kobo.608.1">void *p = std::malloc(n + sizeof n);</span></strong><span class="koboSpan" id="kobo.609.1">
   if(!p) throw std::bad_alloc{};
</span><strong class="bold"><span class="koboSpan" id="kobo.610.1">   auto q = static_cast&lt;std::size_t*&gt;(p);</span></strong><span class="koboSpan" id="kobo.611.1">
   *q = n;
   Accountant::get().take(n);
   return q + 1;
}</span></pre> <p><span class="koboSpan" id="kobo.612.1">Converting a pointer from or to </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">void*</span></strong><span class="koboSpan" id="kobo.614.1"> can be done efficiently with </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">static_cast</span></strong><span class="koboSpan" id="kobo.616.1">, as explained in </span><a href="B21071_03.xhtml#_idTextAnchor047"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.617.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.618.1">. </span><span class="koboSpan" id="kobo.618.2">We now have two perspectives on the same memory block with </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">p</span></strong><span class="koboSpan" id="kobo.620.1"> claiming that the block holds raw memory and </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">q</span></strong><span class="koboSpan" id="kobo.622.1"> claiming (erroneously) that it holds at least </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">one </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">std::size_t</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer030">
<span class="koboSpan" id="kobo.626.1"><img alt="Figure 8.4 – Two perspectives on the same memory block" src="image/B21071_08_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.627.1">Figure 8.4 – Two perspectives on the same memory block</span></p>
<p><span class="koboSpan" id="kobo.628.1">Through </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">q</span></strong><span class="koboSpan" id="kobo.630.1">, we hide the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">n</span></strong><span class="koboSpan" id="kobo.632.1"> at the beginning of the allocated memory block. </span><span class="koboSpan" id="kobo.632.2">Remember </span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.633.1">that this is not what we will be returning to our caller, so this is done without the client </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">code’s knowledge:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.635.1">
void *operator new(std::size_t n) {
</span><strong class="bold"><span class="koboSpan" id="kobo.636.1">   void *p = std::malloc(n + sizeof n);</span></strong><span class="koboSpan" id="kobo.637.1">
   if(!p) throw std::bad_alloc{};
</span><strong class="bold"><span class="koboSpan" id="kobo.638.1">   auto q = static_cast&lt;std::size_t*&gt;(p);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.639.1">   *q = n;</span></strong><span class="koboSpan" id="kobo.640.1">
   Accountant::get().take(n);
   return q + 1;
}</span></pre> <p><span class="koboSpan" id="kobo.641.1">One possible view of the memory pointed to by both </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">p</span></strong><span class="koboSpan" id="kobo.643.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">q</span></strong><span class="koboSpan" id="kobo.645.1"> would now be </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer031">
<span class="koboSpan" id="kobo.647.1"><img alt="Figure 8.5 – Possible state of the memory block after hiding the value of n" src="image/B21071_08_5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.648.1">Figure 8.5 – Possible state of the memory block after hiding the value of n</span></p>
<p><span class="koboSpan" id="kobo.649.1">Again, your view might differ from this one: we wrote an eight-byte integral value, which explains the number of consecutive bytes affected by this write, but the order of bytes in an integer depends on the underlying hardware architecture: some architectures are </span><strong class="bold"><span class="koboSpan" id="kobo.650.1">big-endian</span></strong><span class="koboSpan" id="kobo.651.1"> and store the </span><em class="italic"><span class="koboSpan" id="kobo.652.1">most</span></em><span class="koboSpan" id="kobo.653.1"> significant byte of an integer at its lowest memory address; others are </span><strong class="bold"><span class="koboSpan" id="kobo.654.1">little-endian</span></strong><span class="koboSpan" id="kobo.655.1"> and store the </span><em class="italic"><span class="koboSpan" id="kobo.656.1">least</span></em><span class="koboSpan" id="kobo.657.1"> significant byte at the highest memory address. </span><span class="koboSpan" id="kobo.657.2">Within a program, you typically will not notice this unless you serialize data to persistent storage or on a network. </span><span class="koboSpan" id="kobo.657.3">As such, on another machine, you could see the value </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">4</span></strong><span class="koboSpan" id="kobo.659.1"> closer to the right and of that eight-byte write instead of being on the left as it is in </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">this example.</span></span></p>
<p><span class="koboSpan" id="kobo.661.1">After informing </span><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">Accountant</span></strong><span class="koboSpan" id="kobo.663.1"> that we allocated 4 bytes (not 12, remember), we reach the point </span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.664.1">where we return to our caller the beginning of the 4-byte block that was </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">actually requested:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.666.1">
void *operator new(std::size_t n) {
</span><strong class="bold"><span class="koboSpan" id="kobo.667.1">   void *p = std::malloc(n + sizeof n);</span></strong><span class="koboSpan" id="kobo.668.1">
   if(!p) throw std::bad_alloc{};
</span><strong class="bold"><span class="koboSpan" id="kobo.669.1">   auto q = static_cast&lt;std::size_t*&gt;(p);</span></strong><span class="koboSpan" id="kobo.670.1">
   *q = n;
   Accountant::get().take(n);
</span><strong class="bold"><span class="koboSpan" id="kobo.671.1">   return q + 1;</span></strong><span class="koboSpan" id="kobo.672.1">
}</span></pre> <p><span class="koboSpan" id="kobo.673.1">Looking at our memory block, the situation is now </span><span class="No-Break"><span class="koboSpan" id="kobo.674.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer032">
<span class="koboSpan" id="kobo.675.1"><img alt="Figure 8.6 – State of the memory block at the point of return" src="image/B21071_08_6.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.676.1">Figure 8.6 – State of the memory block at the point of return</span></p>
<p><span class="koboSpan" id="kobo.677.1">Returning to the caller, the constructor of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">int</span></strong><span class="koboSpan" id="kobo.679.1"> object is applied to the block returned by </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">operator new()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.682.1">
int main() {
</span><strong class="bold"><span class="koboSpan" id="kobo.683.1">   auto pre = Accountant::get().how_much();</span></strong><span class="koboSpan" id="kobo.684.1">
   { // BEGIN
</span><strong class="bold"><span class="koboSpan" id="kobo.685.1">      int *p = new int{ 3 };</span></strong><span class="koboSpan" id="kobo.686.1">
      int *q = new int[10]{ }; // initialized to zero
      delete p;
     // oops! </span><span class="koboSpan" id="kobo.686.2">Forgot to delete[] q
   } // END
</span><strong class="bold"><span class="koboSpan" id="kobo.687.1">   </span></strong><strong class="bold"><span class="koboSpan" id="kobo.688.1">auto post = Accountant::get().how_much();</span></strong><span class="koboSpan" id="kobo.689.1">
   if(post != pre)
      std::cout &lt;&lt; "Leaked " &lt;&lt; (post - pre) &lt;&lt; " bytes\n";
}</span></pre> <p><span class="koboSpan" id="kobo.690.1">After having </span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.691.1">applied the constructor on the memory pointed to by </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">p</span></strong><span class="koboSpan" id="kobo.693.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">main()</span></strong><span class="koboSpan" id="kobo.695.1">, our memory block looks like </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">the following:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer033">
<span class="koboSpan" id="kobo.697.1"><img alt="Figure 8.7 – Possible state of the memory block after constructing *p" src="image/B21071_08_7.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.698.1">Figure 8.7 – Possible state of the memory block after constructing *p</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.699.1">Voilà</span></em><span class="koboSpan" id="kobo.700.1">! </span><span class="koboSpan" id="kobo.700.2">The beauty of all this is that client code (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">main()</span></strong><span class="koboSpan" id="kobo.702.1"> function) has no idea that we played those tricks and performed those lies, just as we really have no idea what other tricks </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">std::malloc()</span></strong><span class="koboSpan" id="kobo.704.1"> did for us (unless we can look at its source code, of course). </span><span class="koboSpan" id="kobo.704.2">Program execution continues normally and </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">*p</span></strong><span class="koboSpan" id="kobo.706.1"> can be used like any other </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">int</span></strong><span class="koboSpan" id="kobo.708.1"> until we reach the point where we decide to </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">deallocate it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.710.1">
int main() {
</span><strong class="bold"><span class="koboSpan" id="kobo.711.1">   auto pre = Accountant::get().how_much();</span></strong><span class="koboSpan" id="kobo.712.1">
   { // BEGIN
</span><strong class="bold"><span class="koboSpan" id="kobo.713.1">      int *p = new int{ 3 };</span></strong><span class="koboSpan" id="kobo.714.1">
      int *q = new int[10]{ }; // initialized to zero
</span><strong class="bold"><span class="koboSpan" id="kobo.715.1">      delete p;</span></strong><span class="koboSpan" id="kobo.716.1">
     // oops! </span><span class="koboSpan" id="kobo.716.2">Forgot to delete[] q
   } // END
</span><strong class="bold"><span class="koboSpan" id="kobo.717.1">   </span></strong><strong class="bold"><span class="koboSpan" id="kobo.718.1">auto post = Accountant::get().how_much();</span></strong><span class="koboSpan" id="kobo.719.1">
   if(post != pre)
      std::cout &lt;&lt; "Leaked " &lt;&lt; (post - pre) &lt;&lt; " bytes\n";
}</span></pre> <p><span class="koboSpan" id="kobo.720.1">When entering </span><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">operator delete()</span></strong><span class="koboSpan" id="kobo.722.1">, you might notice that the memory pointed to by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">p</span></strong><span class="koboSpan" id="kobo.724.1"> argument </span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.725.1">begins with value </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">3</span></strong><span class="koboSpan" id="kobo.727.1"> (the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">int</span></strong><span class="koboSpan" id="kobo.729.1">), not value </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">4</span></strong><span class="koboSpan" id="kobo.731.1">. </span><span class="koboSpan" id="kobo.731.2">This makes sense as </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">p</span></strong><span class="koboSpan" id="kobo.733.1"> points to the memory block that was given to the client code, not to the beginning of the block we </span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">actually allocated:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer034">
<span class="koboSpan" id="kobo.735.1"><img alt="Figure 8.8 – State of the memory block prior to destruction (caller’s perspective)" src="image/B21071_08_8.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.736.1">Figure 8.8 – State of the memory block prior to destruction (caller’s perspective)</span></p>
<p><span class="koboSpan" id="kobo.737.1">Before continuing, it’s important to understand here that the reason why you probably see </span><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">3</span></strong><span class="koboSpan" id="kobo.739.1"> here is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.740.1">int</span></strong><span class="koboSpan" id="kobo.741.1"> is a trivially destructible type so its destructor was essentially a no-op. </span><span class="koboSpan" id="kobo.741.2">Normally, at the point where </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">operator delete()</span></strong><span class="koboSpan" id="kobo.743.1"> begins its execution, the destructor for the pointed-to object has already run and the memory block could contain pretty </span><span class="No-Break"><span class="koboSpan" id="kobo.744.1">much anything.</span></span></p>
<p><span class="koboSpan" id="kobo.745.1">Within </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">operator delete()</span></strong><span class="koboSpan" id="kobo.747.1">, our first task is to retrieve the location where we hid the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">n</span></strong><span class="koboSpan" id="kobo.749.1"> during the corresponding call to </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">operator new()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.751.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.752.1">
void operator delete(void *p) noexcept {
   if(!p) return;
</span><strong class="bold"><span class="koboSpan" id="kobo.753.1">   auto q = static_cast&lt;std::size_t*&gt;(p) - 1;</span></strong><span class="koboSpan" id="kobo.754.1">
   Accountant::get().give_back(*q);
   std::free(q);
}</span></pre> <p><span class="koboSpan" id="kobo.755.1">At this point, </span><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">q</span></strong><span class="koboSpan" id="kobo.757.1"> is the location where the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">n</span></strong><span class="koboSpan" id="kobo.759.1"> was stored as well at the beginning of the memory block that was allocated. </span><span class="koboSpan" id="kobo.759.2">We inform </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">Accountant</span></strong><span class="koboSpan" id="kobo.761.1"> of the fact that </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">n</span></strong><span class="koboSpan" id="kobo.763.1"> bytes were deallocated, and call </span><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">std::free()</span></strong><span class="koboSpan" id="kobo.765.1"> to perform the </span><span class="No-Break"><span class="koboSpan" id="kobo.766.1">actual deallocation.</span></span></p>
<p><span class="koboSpan" id="kobo.767.1">If you are observing the memory pointed to by </span><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">q</span></strong><span class="koboSpan" id="kobo.769.1"> when calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">std::free()</span></strong><span class="koboSpan" id="kobo.771.1">, it is possible (but not guaranteed) that you will see that memory being written to. </span><span class="koboSpan" id="kobo.771.2">It is also possible (but also not guaranteed) that you will see memory written to </span><em class="italic"><span class="koboSpan" id="kobo.772.1">before</span></em> <strong class="source-inline"><span class="koboSpan" id="kobo.773.1">q</span></strong><span class="koboSpan" id="kobo.774.1"> as well as </span><em class="italic"><span class="koboSpan" id="kobo.775.1">after</span></em><span class="koboSpan" id="kobo.776.1"> the end of the bytes memory block you had allocated. </span><span class="koboSpan" id="kobo.776.2">Remember that </span><strong class="source-inline"><span class="koboSpan" id="kobo.777.1">std::free()</span></strong><span class="koboSpan" id="kobo.778.1">, like </span><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">std::malloc()</span></strong><span class="koboSpan" id="kobo.780.1">, can do whatever bookkeeping tasks it requires just as it can overwrite </span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.781.1">memory blocks that have been freed, particularly in builds meant for debugging; or, it can just leave the memory as it was, which is more probable with </span><span class="No-Break"><span class="koboSpan" id="kobo.782.1">optimized builds.</span></span></p>
<p><span class="koboSpan" id="kobo.783.1">That was fun, wasn’t it? </span><span class="koboSpan" id="kobo.783.2">It seems to work indeed, at least on some machines. </span><span class="koboSpan" id="kobo.783.3">Yet, as stated earlier, this version of our leak detector has bugs, and these bugs can really hurt us. </span><span class="koboSpan" id="kobo.783.4">As a hint, know that if we compile this leak detector on a compiler where </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">std::size_t</span></strong><span class="koboSpan" id="kobo.785.1"> is four bytes wide and try to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">new double</span></strong><span class="koboSpan" id="kobo.787.1">, we might get into </span><em class="italic"><span class="koboSpan" id="kobo.788.1">very</span></em><span class="koboSpan" id="kobo.789.1"> serious trouble. </span><span class="koboSpan" id="kobo.789.2">It is now time to take a closer look at our implementation to grasp why this is so and fix the problems </span><span class="No-Break"><span class="koboSpan" id="kobo.790.1">we caused.</span></span></p>
<h1 id="_idParaDest-135"><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.791.1">Identifying (and fixing) the problems</span></h1>
<p><span class="koboSpan" id="kobo.792.1">Our initial implementation has in fact one real problem, as well as something that works but could be </span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.793.1">cleaner and </span><span class="No-Break"><span class="koboSpan" id="kobo.794.1">deserves discussion.</span></span></p>
<p><span class="koboSpan" id="kobo.795.1">The real problem is that we express our lies in dangerous ways and that we are not giving proper consideration to alignment requirements. </span><span class="koboSpan" id="kobo.795.2">Indeed, look at our initial implementation of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.796.1">operator new()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.798.1">
void *operator new(std::size_t n) {
   // allocate n bytes plus enough space to hide n
</span><strong class="bold"><span class="koboSpan" id="kobo.799.1">   void *p = std::malloc(n + sizeof n); // to revisit</span></strong><span class="koboSpan" id="kobo.800.1">
   // signal failure to meet postconditions if needed
   if(!p) throw std::bad_alloc{};
   // hide n at the beginning of the allocated block
   auto q = static_cast&lt;std::size_t*&gt;(p);
   *q = n; // to revisit
   // inform the Accountant of the allocation
   Accountant::get().take(n);
   // return the beginning of the requested block memory
</span><strong class="bold"><span class="koboSpan" id="kobo.801.1">   return q + 1; // to revisit</span></strong><span class="koboSpan" id="kobo.802.1">
}</span></pre> <p><span class="koboSpan" id="kobo.803.1">We know for a fact that the memory returned by </span><strong class="source-inline"><span class="koboSpan" id="kobo.804.1">std::malloc()</span></strong><span class="koboSpan" id="kobo.805.1"> has to be aligned appropriately for the strictest (meaning </span><em class="italic"><span class="koboSpan" id="kobo.806.1">worst</span></em><span class="koboSpan" id="kobo.807.1">) natural alignment of our machine: indeed, since that </span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.808.1">function does not know what object will be constructed once the allocation has completed, it has to make sure that the memory block allocated will be properly aligned in all “natural” cases. </span><span class="koboSpan" id="kobo.808.2">C++ compilers offer </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">std::max_align_t</span></strong><span class="koboSpan" id="kobo.810.1"> as an alias for the type with the strictest natural alignment in a machine, which is often, but not necessarily, type </span><strong class="source-inline"><span class="koboSpan" id="kobo.811.1">double</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.812.1">in practice.</span></span></p>
<p><span class="koboSpan" id="kobo.813.1">Now, we allocate a bit more than was requested, </span><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">sizeof(std::size_t)</span></strong><span class="koboSpan" id="kobo.815.1"> more bytes to be precise. </span><span class="koboSpan" id="kobo.815.2">That’s fine up to a point: we can assuredly store </span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">std::size_t</span></strong><span class="koboSpan" id="kobo.817.1"> at the beginning of the block returned by </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">std::malloc()</span></strong><span class="koboSpan" id="kobo.819.1"> since that block is well aligned even in the </span><span class="No-Break"><span class="koboSpan" id="kobo.820.1">worst case.</span></span></p>
<p><span class="koboSpan" id="kobo.821.1">Then, we “jump over” </span><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">std::size_t</span></strong><span class="koboSpan" id="kobo.823.1"> and return an address that is </span><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">sizeof(std::size_t)</span></strong><span class="koboSpan" id="kobo.825.1"> bytes more than the one we allocated. </span><span class="koboSpan" id="kobo.825.2">This can be fine if it still yields a correctly aligned address even in the worst case, but that is only the case if </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">std::size_t</span></strong><span class="koboSpan" id="kobo.827.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">std::max_align_t</span></strong><span class="koboSpan" id="kobo.829.1"> are of the same size, something that is </span><em class="italic"><span class="koboSpan" id="kobo.830.1">not</span></em><span class="koboSpan" id="kobo.831.1"> guaranteed (in practice, their sizes are </span><span class="No-Break"><span class="koboSpan" id="kobo.832.1">often different).</span></span></p>
<p><span class="koboSpan" id="kobo.833.1">What happens if these types are of different sizes and, consequently, the address returned by </span><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">operator new()</span></strong><span class="koboSpan" id="kobo.835.1"> does not match the alignment requirements of </span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">std::max_align_t</span></strong><span class="koboSpan" id="kobo.837.1">? </span><span class="koboSpan" id="kobo.837.2">Well, </span><span class="No-Break"><span class="koboSpan" id="kobo.838.1">it depends:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.839.1">It can work if we get “lucky” and the address returned is aligned correctly for the type we want to construct. </span><span class="koboSpan" id="kobo.839.2">For example, suppose that </span><strong class="source-inline"><span class="koboSpan" id="kobo.840.1">alignof(int)==4</span></strong><span class="koboSpan" id="kobo.841.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">alignof(std::max_align_t)==8</span></strong><span class="koboSpan" id="kobo.843.1">, then calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">new int</span></strong><span class="koboSpan" id="kobo.845.1"> will work even if </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">operator new</span></strong><span class="koboSpan" id="kobo.847.1"> returns an address that is a multiple of four but not of eight. </span><span class="koboSpan" id="kobo.847.2">However, it’s probable that calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">new double</span></strong><span class="koboSpan" id="kobo.849.1"> will only lead to pain. </span><span class="koboSpan" id="kobo.849.2">This sort of “luck” can be a curse, hiding a latent, damaging bug for a while and making for unpleasant </span><span class="No-Break"><span class="koboSpan" id="kobo.850.1">surprises later.</span></span></li>
<li><span class="koboSpan" id="kobo.851.1">You can end up with slow and dangerous code, as some hardware will support access to misaligned objects. </span><span class="koboSpan" id="kobo.851.2">You don’t want to do that, however, as for the machine to achieve this, it needs to perform acrobatics and transform a seemingly simple </span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.852.1">operation such as loading </span><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">double</span></strong><span class="koboSpan" id="kobo.854.1"> in a register into a sequence of operations (load the “low” bytes, load the “high” bytes, and make a </span><strong class="source-inline"><span class="koboSpan" id="kobo.855.1">double</span></strong><span class="koboSpan" id="kobo.856.1"> out of these two parts through bitwise manipulations). </span><span class="koboSpan" id="kobo.856.2">This leads to code that is significantly slower to execute, obviously, but also dangerous if you have a multithreaded program as one thread could </span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.857.1">read a partially formed object (this is called a </span><strong class="bold"><span class="koboSpan" id="kobo.858.1">torn read</span></strong><span class="koboSpan" id="kobo.859.1">) or write to a </span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.860.1">partially formed object (a </span><strong class="bold"><span class="koboSpan" id="kobo.861.1">torn write</span></strong><span class="koboSpan" id="kobo.862.1">). </span><span class="koboSpan" id="kobo.862.2">You really do not want to debug code where </span><span class="No-Break"><span class="koboSpan" id="kobo.863.1">this happens.</span></span></li>
<li><span class="koboSpan" id="kobo.864.1">Your code can simply crash, as will be the case on many embedded platforms (including quite a few game consoles). </span><span class="koboSpan" id="kobo.864.2">It’s arguably the most reasonable outcome in such </span><span class="No-Break"><span class="koboSpan" id="kobo.865.1">a situation.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.866.1">To fix this problem, we need to ensure that the address returned from our overloaded </span><strong class="source-inline"><span class="koboSpan" id="kobo.867.1">operator new()</span></strong><span class="koboSpan" id="kobo.868.1"> is properly aligned for </span><strong class="source-inline"><span class="koboSpan" id="kobo.869.1">std::max_align_t</span></strong><span class="koboSpan" id="kobo.870.1">, and that </span><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">operator delete()</span></strong><span class="koboSpan" id="kobo.872.1"> is adjusted accordingly. </span><span class="koboSpan" id="kobo.872.2">One way to do this would be to ensure that the size of the “hiding spot” for </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">n</span></strong><span class="koboSpan" id="kobo.874.1"> is such that jumping over that additional memory block still results in an address that is properly aligned for a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">std::max_align_t</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.876.1"> object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.877.1">
void *operator new(std::size_t n) {
</span><strong class="bold"><span class="koboSpan" id="kobo.878.1">   // allocate n bytes plus enough space to hide n,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.879.1">   // taking worst case natural alignment into account</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.880.1">   void *p = std::malloc(sizeof(std::max_align_t) + n);</span></strong><span class="koboSpan" id="kobo.881.1">
   // signal failure to meet postconditions if needed
   if(!p) throw std::bad_alloc{};
   // hide n at the beginning of the allocated block
   *static_cast&lt;std::size_t*&gt;(p) = n; // to revisit
   // inform the Accountant of the allocation
   Accountant::get().take(n);
</span><strong class="bold"><span class="koboSpan" id="kobo.882.1">   // return the beginning of the requested block memory</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.883.1">   return static_cast&lt;std::max_align_t*&gt;(p) + 1;</span></strong><span class="koboSpan" id="kobo.884.1">
}</span></pre> <p><span class="koboSpan" id="kobo.885.1">As you can see, this implementation allocates space for </span><strong class="source-inline"><span class="koboSpan" id="kobo.886.1">std::max_align_t</span></strong><span class="koboSpan" id="kobo.887.1"> in addition to the requested </span><strong class="source-inline"><span class="koboSpan" id="kobo.888.1">n</span></strong><span class="koboSpan" id="kobo.889.1"> bytes, then “jumps over” that additional storage to yield an address that </span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.890.1">is still properly aligned for the worst case. </span><span class="koboSpan" id="kobo.890.2">This might mean wasting more space than in the initial (incorrect) implementation if </span><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">sizeof(std::size_t)</span></strong><span class="koboSpan" id="kobo.892.1"> happens to be less than </span><strong class="source-inline"><span class="koboSpan" id="kobo.893.1">sizeof(std::max_align_t)</span></strong><span class="koboSpan" id="kobo.894.1">, but at least we know that client code will be able to construct its </span><span class="No-Break"><span class="koboSpan" id="kobo.895.1">object there.</span></span></p>
<p><span class="koboSpan" id="kobo.896.1">The corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">operator delete()</span></strong><span class="koboSpan" id="kobo.898.1"> will do the same pointer gymnastics but in reverse, going back </span><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">sizeof(std::max_align_t)</span></strong><span class="koboSpan" id="kobo.900.1"> bytes </span><span class="No-Break"><span class="koboSpan" id="kobo.901.1">in memory:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.902.1">
void operator delete(void *p) noexcept {
   // delete on a null pointer is a no-op
   if(!p) return;
</span><strong class="bold"><span class="koboSpan" id="kobo.903.1">   // find the beginning of the block that was allocated</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.904.1">   p = static_cast&lt;std::max_align_t*&gt;(p) - 1;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.905.1">   // inform the Accountant of the deallocation</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.906.1">   Accountant::get().give_back(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.907.1">     *static_cast&lt;std::size_t*&gt;(p)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.908.1">   );</span></strong><span class="koboSpan" id="kobo.909.1">
   // free the memory
   std::free(p);
}</span></pre> <p><span class="koboSpan" id="kobo.910.1">Note that this implementation assigns </span><strong class="source-inline"><span class="koboSpan" id="kobo.911.1">std::max_align_t*</span></strong><span class="koboSpan" id="kobo.912.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.913.1">void*</span></strong><span class="koboSpan" id="kobo.914.1"> (pointer </span><strong class="source-inline"><span class="koboSpan" id="kobo.915.1">p</span></strong><span class="koboSpan" id="kobo.916.1">), something that is perfectly legal and does not require </span><span class="No-Break"><span class="koboSpan" id="kobo.917.1">a cast.</span></span></p>
<p><span class="koboSpan" id="kobo.918.1">The other </span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.919.1">issue we should discuss is not technically a problem in this implementation but is a problem in general. </span><span class="koboSpan" id="kobo.919.2">Look at this excerpt from </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.920.1">operator new()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.921.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.922.1">
void *operator new(std::size_t n) {
   void *p = std::malloc(n + sizeof(std::max_align_t));
   if(!p) throw std::bad_alloc{};
</span><strong class="bold"><span class="koboSpan" id="kobo.923.1">   // hide n at the beginning of the allocated block</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.924.1">   </span></strong><strong class="bold"><span class="koboSpan" id="kobo.925.1">*static_cast&lt;std::size_t*&gt;(p) = n; // to revisit</span></strong><span class="koboSpan" id="kobo.926.1">
   Accountant::get().take(n);
   return static_cast&lt;std::max_align_t*&gt;(p) + 1;
}</span></pre> <p><span class="koboSpan" id="kobo.927.1">Do you notice something strange? </span><span class="koboSpan" id="kobo.927.2">The highlighted line of code performs an assignment where </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">p</span></strong><span class="koboSpan" id="kobo.929.1"> points, but the assignment only makes sense on an existing object. </span><span class="koboSpan" id="kobo.929.2">Is there an object at location </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">*p</span></strong><span class="koboSpan" id="kobo.931.1"> at </span><span class="No-Break"><span class="koboSpan" id="kobo.932.1">that moment?</span></span></p>
<p><span class="koboSpan" id="kobo.933.1">The answer is… strange. </span><span class="koboSpan" id="kobo.933.2">To create an object, one has to call its constructor, but we never called the constructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.934.1">std::size_t</span></strong><span class="koboSpan" id="kobo.935.1"> at location </span><strong class="source-inline"><span class="koboSpan" id="kobo.936.1">p</span></strong><span class="koboSpan" id="kobo.937.1"> in this code. </span><span class="koboSpan" id="kobo.937.2">This might make you wonder why our code seems to work. </span><span class="koboSpan" id="kobo.937.3">It happens that the following is </span><span class="No-Break"><span class="koboSpan" id="kobo.938.1">the case:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.939.1">Some types in </span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.940.1">C++ are said to be </span><strong class="bold"><span class="koboSpan" id="kobo.941.1">implicit lifetime types</span></strong><span class="koboSpan" id="kobo.942.1">. </span><span class="koboSpan" id="kobo.942.2">These types include scalars (pointers, pointer to members, arithmetic types, enumerations, </span><strong class="source-inline"><span class="koboSpan" id="kobo.943.1">std::nullptr_t</span></strong><span class="koboSpan" id="kobo.944.1"> including their cv-qualified counterparts) and implicit lifetime classes (aggregates with no user-provided destructor, at least one eligible trivial constructor as well as a non-deleted trivial destructor). </span><span class="koboSpan" id="kobo.944.2">You will notice that </span><strong class="source-inline"><span class="koboSpan" id="kobo.945.1">std::size_t</span></strong><span class="koboSpan" id="kobo.946.1">, being an alias for an unsigned integral type, falls under the umbrella of implicit lifetime types. </span><span class="koboSpan" id="kobo.946.2">If you have a C++23 compiler, you can programmatically test if some type </span><strong class="source-inline"><span class="koboSpan" id="kobo.947.1">T</span></strong><span class="koboSpan" id="kobo.948.1"> qualifies as an implicit lifetime type through the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.949.1">std::is_implicit_lifetime&lt;T&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.950.1"> trait.</span></span></li>
<li><span class="koboSpan" id="kobo.951.1">Some standard library functions implicitly start the lifetime of objects of implicit lifetime types. </span><span class="koboSpan" id="kobo.951.2">These include some C functions, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">std::memcpy()</span></strong><span class="koboSpan" id="kobo.953.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">std::memmove()</span></strong><span class="koboSpan" id="kobo.955.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.956.1">std::malloc()</span></strong><span class="koboSpan" id="kobo.957.1">, but also </span><strong class="source-inline"><span class="koboSpan" id="kobo.958.1">std::bit_cast</span></strong><span class="koboSpan" id="kobo.959.1">, some functions in allocators (see </span><a href="B21071_14.xhtml#_idTextAnchor199"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.960.1">Chapter 14</span></em></span></a><span class="koboSpan" id="kobo.961.1">) as well as two functions from C++23 respectively named </span><strong class="source-inline"><span class="koboSpan" id="kobo.962.1">std::start_lifetime_as()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.963.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.964.1">std::start_lifetime_as_array()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.965.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.966.1">What makes this assignment operation work in this specific case is that we are writing to an object </span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.967.1">of an implicit lifetime type in a block of memory that is properly aligned and has been allocated with one of these special functions that have the property of implicitly starting the lifetime of objects. </span><span class="koboSpan" id="kobo.967.2">If we had decided to store something more elaborate than an object of some implicit lifetime type, our assignment would either fail at compile-time (if our compiler is nice enough to notice our mistake) or risk causing damage </span><span class="No-Break"><span class="koboSpan" id="kobo.968.1">at runtime.</span></span></p>
<p><span class="koboSpan" id="kobo.969.1">A better, and in general, safer approach to the act of hiding the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.970.1">n</span></strong><span class="koboSpan" id="kobo.971.1"> in some uninitialized storage is to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.972.1">placement new</span></strong><span class="koboSpan" id="kobo.973.1">, as seen in </span><a href="B21071_07.xhtml#_idTextAnchor116"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.974.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.975.1">. </span><span class="koboSpan" id="kobo.975.2">The following implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.976.1">operator new()</span></strong><span class="koboSpan" id="kobo.977.1"> is thus preferable in general as it avoids an (often misguided) assignment to </span><span class="No-Break"><span class="koboSpan" id="kobo.978.1">a non-object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.979.1">
void *operator new(std::size_t n) {
   void *p = std::malloc(n + sizeof(std::max_align_t));
   if(!p) throw std::bad_alloc{};
</span><strong class="bold"><span class="koboSpan" id="kobo.980.1">   // hide n at the beginning of the allocated block</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.981.1">   </span></strong><strong class="bold"><span class="koboSpan" id="kobo.982.1">new (p) std::size_t{ n };</span></strong><span class="koboSpan" id="kobo.983.1">
   Accountant::get().take(n);
   return static_cast&lt;std::max_align_t*&gt;(p) + 1;
}</span></pre> <p><span class="koboSpan" id="kobo.984.1">Note that since </span><strong class="source-inline"><span class="koboSpan" id="kobo.985.1">std::size_t</span></strong><span class="koboSpan" id="kobo.986.1"> has a trivial destructor, there is no need to call its destructor in </span><strong class="source-inline"><span class="koboSpan" id="kobo.987.1">operator delete()</span></strong><span class="koboSpan" id="kobo.988.1">; simply freeing its underlying storage is sufficient to end its lifetime. </span><span class="koboSpan" id="kobo.988.2">We now have a correct, working </span><span class="No-Break"><span class="koboSpan" id="kobo.989.1">leak detector!</span></span></p>
<h1 id="_idParaDest-136"><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.990.1">Revisiting our implementation (and lessons learned)</span></h1>
<p><span class="koboSpan" id="kobo.991.1">We just overloaded memory allocation operators, blatantly lied our way through the protections </span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.992.1">of the type system, performed potentially dangerous operations that risked leading to misaligned objects, and saw how to avoid this pitfall. </span><span class="koboSpan" id="kobo.992.2">That was an interesting adventure indeed, but the astute reader that you are is probably wondering about the cost of this trick, particularly in terms of how much memory </span><span class="No-Break"><span class="koboSpan" id="kobo.993.1">it consumes.</span></span></p>
<p><span class="koboSpan" id="kobo.994.1">With our “allocate more than requested and hide </span><strong class="source-inline"><span class="koboSpan" id="kobo.995.1">n</span></strong><span class="koboSpan" id="kobo.996.1"> at the beginning” approach, each allocation consumes </span><strong class="source-inline"><span class="koboSpan" id="kobo.997.1">sizeof(std::max_align_t)</span></strong><span class="koboSpan" id="kobo.998.1"> bytes more than needed by client code. </span><span class="koboSpan" id="kobo.998.2">If our code allocates large objects, that cost might be minor, but if we allocate smaller objects, this overhead can be unreasonable and dominate the memory consumption of our </span><span class="No-Break"><span class="koboSpan" id="kobo.999.1">entire program.</span></span></p>
<p><span class="koboSpan" id="kobo.1000.1">Remember from </span><a href="B21071_07.xhtml#_idTextAnchor116"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1001.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.1002.1"> that C++14 made it possible to provide an overload of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1003.1">operator delete()</span></strong><span class="koboSpan" id="kobo.1004.1"> that accepts the size of the just-destroyed object as an argument. </span><span class="koboSpan" id="kobo.1004.2">This makes the act of hiding </span><strong class="source-inline"><span class="koboSpan" id="kobo.1005.1">n</span></strong><span class="koboSpan" id="kobo.1006.1"> during </span><strong class="source-inline"><span class="koboSpan" id="kobo.1007.1">operator new()</span></strong><span class="koboSpan" id="kobo.1008.1"> redundant, as we did so precisely in order to retrieve </span><strong class="source-inline"><span class="koboSpan" id="kobo.1009.1">n</span></strong><span class="koboSpan" id="kobo.1010.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1011.1">operator delete()</span></strong><span class="koboSpan" id="kobo.1012.1">, something we no longer need </span><span class="No-Break"><span class="koboSpan" id="kobo.1013.1">to do.</span></span></p>
<p><span class="koboSpan" id="kobo.1014.1">Since we do not need to hide </span><strong class="source-inline"><span class="koboSpan" id="kobo.1015.1">n</span></strong><span class="koboSpan" id="kobo.1016.1">, we can both simplify our implementation and significantly reduce our </span><span class="No-Break"><span class="koboSpan" id="kobo.1017.1">memory consumption:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1018.1">
void *operator new(std::size_t n) {
</span><strong class="bold"><span class="koboSpan" id="kobo.1019.1">   // allocate n bytes (no need for more!)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1020.1">   void *p = std::malloc(n);</span></strong><span class="koboSpan" id="kobo.1021.1">
   // signal failure to meet postconditions if needed
   if(!p) throw std::bad_alloc{};
   // inform the Accountant of the allocation
   Accountant::get().take(n);
</span><strong class="bold"><span class="koboSpan" id="kobo.1022.1">   // return the beginning of the requested block memory</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1023.1">   return p;</span></strong><span class="koboSpan" id="kobo.1024.1">
}
void *operator new[](std::size_t n) {
   // exactly the same as operator new above
}
void operator delete(void *p</span><strong class="bold"><span class="koboSpan" id="kobo.1025.1">, std::size_t n</span></strong><span class="koboSpan" id="kobo.1026.1">) noexcept {
   // delete on a null pointer is a no-op
   if(!p) return;
</span><strong class="bold"><span class="koboSpan" id="kobo.1027.1">   // inform the Accountant of the deallocation</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1028.1">   Accountant::get().give_back(n);</span></strong><span class="koboSpan" id="kobo.1029.1">
   // free the memory
   std::free(p);
}
void operator delete[](void *p</span><strong class="bold"><span class="koboSpan" id="kobo.1030.1">, std::size_t n</span></strong><span class="koboSpan" id="kobo.1031.1">) noexcept {
   // exactly the same as operator delete above
}</span></pre> <p><span class="koboSpan" id="kobo.1032.1">This leak </span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.1033.1">detector still works and represents a strict upgrade when compared with the more naïve version that </span><span class="No-Break"><span class="koboSpan" id="kobo.1034.1">preceded it.</span></span></p>
<h1 id="_idParaDest-137"><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.1035.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1036.1">That was fun, wasn’t it? </span><span class="koboSpan" id="kobo.1036.2">You can take this very simple tool and make it more interesting: for example, you could use it to check for overflow and underflow of the allocated memory blocks by injecting sentinel values before and after each block, or you could use it to make a sort of map of the way your memory is </span><span class="No-Break"><span class="koboSpan" id="kobo.1037.1">being used.</span></span></p>
<p><span class="koboSpan" id="kobo.1038.1">This concludes our first foray into applications that benefit from taking charge of the memory allocation facilities at our disposal. </span><span class="koboSpan" id="kobo.1038.2">Our next step, and next chapter, will lead us to examine how a C++ program can interact with atypical memory or deal with atypical </span><span class="No-Break"><span class="koboSpan" id="kobo.1039.1">allocation situations.</span></span></p>
<p><span class="koboSpan" id="kobo.1040.1">Of course, no programming language (even one as versatile and wide-ranging as C++) can profess to cover all possible types of memory that an operating system could provide services for, nor should that be the language’s role. </span><span class="koboSpan" id="kobo.1040.2">Still, as we will see, C++ provides us with the kind of “syntactic glue” required to build bridges between atypical needs and the rest of </span><span class="No-Break"><span class="koboSpan" id="kobo.1041.1">the program.</span></span></p>
</div>
</body></html>