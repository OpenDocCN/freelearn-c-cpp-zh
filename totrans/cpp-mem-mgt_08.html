<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-126"><a id="_idTextAnchor128"/>8</h1>
<h1 id="_idParaDest-127"><a id="_idTextAnchor129"/>Writing a Naïve Leak Detector</h1>
<p>In <a href="B21071_07.xhtml#_idTextAnchor116"><em class="italic">Chapter 7</em></a>, we examined various ways to overload the memory allocation operators, which are <code>new</code>, <code>new[]</code>, <code>delete</code>, and <code>delete[]</code>, in order to grasp the syntax involved in writing these operators as well as how they can be used in client code. We discussed how these operators interact with exceptions (even in the case of the <code>nothrow</code> versions) and saw why they should, in most cases, be written in groups of four or multiples thereof. For example, code that calls the <code>nothrow</code> version of <code>operator new()</code> to obtain some pointer, <code>pV</code> and later on calls <code>delete p</code> will quickly get in trouble if one overloads the <code>nothrow</code> version but not the “regular” one, as both might then end up not being compatible with one another.</p>
<p>What we have not really discussed is how our code could benefit from taking control of these operators. There are indeed multiple uses for this: tracing how or where memory is allocated, measuring memory fragmentation in a process, implementing a specialized strategy to control performance characteristics of the allocation or deallocation process, and so on. Since this book has a finite size, we cannot hope to cover examples of all possible options so we will pick one, hoping that this example is sufficiently inspirational to let you explore other avenues on your own.</p>
<p>The example we will explore in this chapter is a simple yet functional memory leak detector. In more detail, we will do the following:</p>
<ol>
<li>We will first detail the plan, giving an overview of how our leak detector will work and what tricks we will use to meet our objectives.</li>
<li>Then, we will implement the first version of our tool, and that version will seem to work, at least on the surface. We will walk through a call to <code>operator new()</code> and the corresponding <code>operator delete()</code> to understand what happens in memory throughout this process.</li>
<li>At this point, we will use the knowledge acquired in previous chapters to identify the flaws in our first solution as well as ways in which we can fix them.</li>
<li>Finally, we will revisit our initial implementation and end up with something that is simple yet usable in real code.</li>
</ol>
<p>Since this will be a very concrete chapter, you can expect to develop (or refine) some useful skills as we go:</p>
<ul>
<li>The first one is to plan before coding. We will be writing very low-level code in this chapter, which makes it particularly important for us to have a clear direction in mind. After all, when coding “close to the machine” and playing with raw memory, the compiler-provided safety net that is the type system tends to be a bit thinner and it’s easier to make mistakes (costly ones at that) if we’re not careful.</li>
<li>The second one is to safely use shared mutable resources. Our leak detector will use the global versions of the memory allocation operators in order to cover allocation requests for all types, at least unless users decide to use specialized versions of these operators, and as such, we will need to manage the state that will be global to our program. In addition, we know that user code might be multithreaded so our accounting of the allocated memory will require a form of synchronization to avoid data races.</li>
<li>The third one will be to acknowledge the impact of alignment when bypassing the type system. As we will handle raw memory for the a priori unknown needs of client code, we will learn to make choices that work for all “natural” (in the sense of “non-overaligned”) memory allocation use cases.</li>
<li>Finally, we will examine how to debug our code based on the contents of raw memory. Since we aim to keep this book tooling-agnostic, we will apply a schematical approach to this problem, but in practice, you should adapt what we do in this chapter to the metaphors of your favorite debugging utility. All reasonable debuggers will let you examine the contents of a specific memory address, something you will assuredly want to do on occasion.</li>
</ul>
<p>Let’s dive in!</p>
<h1 id="_idParaDest-128"><a id="_idTextAnchor130"/>Technical requirements</h1>
<p><a id="_idTextAnchor131"/>You can find the code files for this chapter in the book’s GitHub repository here: <a href="https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter8">https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter8</a>.</p>
<h1 id="_idParaDest-129"><a id="_idTextAnchor132"/>The plan</h1>
<p>We are planning to write a memory leak detector, a task that might seem strange and abstract at first. How do we start? Well, one way to clarify what we need to do is to write a small <a id="_idIndexMarker432"/>test program, showing at once how we expect our tool to be used and highlighting the key aspects of our tool from the perspective of user code:</p>
<pre class="source-code">
#include &lt;iostream&gt;
// this is incomplete (for now)
int main() {
   auto pre = // current amount of allocated memory
   { // BEGIN
      int *p = new int{ 3 };
      int *q = new int[10]{ }; // initialized to zero
      delete p;
     // oops! Forgot to delete[] q
   } // END
   auto post = // current amount of allocated memory
   // with this code, supposing sizeof(int)==4, we
   // expect to see "Leaked 40 bytes" printed
   if(post != pre)
      std::cout &lt;&lt; "Leaked " &lt;&lt; (post - pre) &lt;&lt; " bytes\n";
}</pre> <p>As you can see, this “deliberately leaky” program performs two allocations but only a single deallocation, “forgetting” (conveniently for our purposes) to deallocate an array of ten <code>int</code> objects. Supposing <code>sizeof(int)==4</code>, our leak detector should allow the program to report a leak of 40 bytes.</p>
<p>This program does not tell us how we will (portably) obtain the amount of dynamically allocated memory at a given time (we will write this service in this chapter, after all), but it does show the allocations and deallocations being located between a pair of braces (see <code>BEGIN</code> and <code>END</code> in the comments of that example program). In C++, as you know, matching braces delimit a scope, and scope ensures the destruction of automatic variables defined therein. The idea here is that we want to detect leaks even in the presence of RAII objects (see <a href="B21071_04.xhtml#_idTextAnchor062"><em class="italic">Chapter 4</em></a>) as they too could have bugs, so we want to make sure they are destroyed before we try to issue a diagnostic.</p>
<p>As mentioned in this chapter’s introduction, we will implement our leak detector through the overloading of the <em class="italic">global</em> forms of memory allocation operators. As you might have already guessed, these operators will need to share some state: at the very least, they will <a id="_idIndexMarker433"/>need shared knowledge of the amount of memory allocated at a given moment since the <code>new</code> and <code>new[]</code> operators will increment that amount and the <code>delete</code> and <code>delete[]</code> operators will decrement it.</p>
<p>Note that for our leak detector, the array and non-array forms of these operators will be identical but that is <em class="italic">not</em> always the case: one could envision different strategies to allocate scalars and arrays, for example, just as one could want to track what these two forms do separately in a program. For simplicity, in this chapter, we will often simply mention <code>new</code> to describe both <code>new</code> and <code>new[]</code> and will use the same approach for <code>delete</code>.</p>
<p>Since these are free functions, not member functions of some object, we will need to resort to a <em class="italic">global variable</em> for this state. I know global variables are often frowned upon, mostly for good reasons, but they exist for cases such as this.</p>
<p class="callout-heading">Global variables, oh my!</p>
<p class="callout">Reasons to dislike <a id="_idIndexMarker434"/>global variables abound: they make local reasoning difficult (who knows where and when they are being accessed?), they tend to be bottlenecks for cache access and slow programs down, they tend to require synchronization in contemporary (potentially multithreaded) programs, and so on. We are resorting to this mechanism here because we need to: C++ provides us with a wide variety of tools because it is a language that is used to solve a wide variety of problems, so there’s no shame in using these tools when they are the right tools for the task at hand. Just ensure you make informed choices that you can justify!</p>
<p>To reduce (ever so slightly) the feeling <a id="_idIndexMarker435"/>of apparent revulsion that global variables provide to so many of us, we will encapsulate that state in an object, but of course, this object will also be global.</p>
<p>We will apply the <code>Accountant</code> since its responsibilities will be to help the memory allocation operators keep track of the number of bytes allocated and deallocated during program execution.</p>
<p class="callout-heading">Singletons, oh my!</p>
<p class="callout">As far as design patterns go, the singleton is probably one of the least liked ones, for reasons similar to those behind the dislike of global variables: difficult to test or mock, requires synchronization, tends to become a performance bottleneck, and so on. The real culprit <a id="_idIndexMarker437"/>here to be honest is <strong class="bold">shared mutable state</strong>, made worse by the fact that this state is globally accessible throughout the program. As you might have guessed by now, since the shared mutable state is exactly what we need to keep track of the amount of memory allocated at a given time, well… this is what we will use!</p>
<p>Now, for the actual implementation, we will need to develop a strategy to track the number of bytes allocated and deallocated. The overall idea is that <code>operator new()</code> will tell the <code>Accountant</code> object that bytes have been allocated, and that <code>operator delete()</code> will tell the <code>Accountant</code> object that bytes have been deallocated. Now, for the purpose of this activity, we will use the traditional (up to and including C++11) form of these operators. As you might remember from <a href="B21071_07.xhtml#_idTextAnchor116"><em class="italic">Chapter 7</em></a>, their signatures are as follows:</p>
<pre class="source-code">
void *operator new(std::size_t n);
void *operator new[](std::size_t n);
void operator delete(void*p) noexcept;
void operator delete[](void*p) noexcept;</pre> <p>Since you are reading this book, you are assuredly a most astute reader, so you might have already noticed a problem here: our allocation functions know from their argument the number <a id="_idIndexMarker438"/>of bytes to allocate, but our deallocation functions do not have that privilege, being only provided the address where the block to deallocate begins. This means that we need a way to make the connection between the address returned by <code>operator new()</code> and the size of the associated memory block.</p>
<p>That seems like an easy enough problem to solve: just allocate the moral equivalent of something like <code>std::vector&lt;std::pair&lt;void*,std::size_t&gt;&gt;</code> or <code>std::map&lt;void*,std::size_t&gt;</code> to make it easy to retrieve the <code>std::size_t</code> associated with a given address, but such containers need to allocate memory, and that would mean allocating memory in order to implement the way in which we allocate memory. This could get problematic, to say the least, so we need another solution.</p>
<p>We will do <a id="_idIndexMarker439"/>what any sane programmer would do under similar circumstances: we will lie. Yes, we will! Why do you think we took the time to look at tricky and dangerous code in those first chapters?</p>
<p>How will lying help us solve the problem, you say? Well, remember that writing the following code leads to calling <code>operator new()</code> with <code>sizeof(X)</code> as an argument:</p>
<pre class="source-code">
X *p = new X{ /* ... */ };</pre> <p>Let us name this argument <code>n</code>. This means that if the allocation and the ensuing construction both succeed, from the perspective of client code, the situation will be as follows:</p>
<div><div><img alt="Figure 8.1 – Allocated block of memory from the perspective of client code" src="img/B21071_08_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Allocated block of memory from the perspective of client code</p>
<p>In order for <code>operator delete()</code> to be able to find the value of <code>n</code> based on <code>p</code>, one strategy (and the one we will adopt for this example) will be to hide the value of <code>n</code> just before <code>p</code>. The actual layout in memory from our own code’s perspective would then be as follows:</p>
<div><div><img alt="Figure 8.2 – Allocated block of memory from the perspective of the allocation operators." src="img/B21071_08_2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Allocated block of memory from the perspective of the allocation operators.</p>
<p>Here, <code>p</code> would be the address as seen from the client code, but <code>p'</code> would be where the actually allocated <a id="_idIndexMarker440"/>block of memory starts. Clearly, <em class="italic">this is a lie</em>: the address returned by the allocation function will be a valid address where an object can be constructed, but it will not be the start of the memory block we have actually allocated. As long as the space between <code>p</code> and <code>p'</code> is known to both <code>operator new()</code> and <code>operator delete()</code>, this can be made to work.</p>
<p>For obvious reasons, overloading <code>operator new()</code> to do this trickery means that we have to overload <code>operator delete()</code> to do the reverse gymnastics: given some pointer <code>p</code>, go backward in memory where <code>p'</code> was, find the value of <code>n</code> that was hidden there, and inform the <code>Accountant</code> object of the fact that <code>n</code> bytes were released.</p>
<p>Now, let’s see how we will do this.</p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor133"/>A first implementation (that almost works)</h1>
<p>We now <a id="_idIndexMarker441"/>have a plan, so we are ready to start implementing the initial version of our leak detector. This implementation will be slightly naïve but will help us understand the general idea; we will examine the more delicate aspects of the implementation once the basic infrastructure is in place. <em class="italic">Do not use this first version in production code</em> as it will be (slightly yet dangerously) incorrect. We will provide a correct version later in this chapter, of course.</p>
<p>As a suggestion, try to see if you can identify the “rough edges” of our implementation by yourself before we cover them later in this chapter. There will be clues left here and there for you, and if you read the chapters that preceded this one, you might already have an idea of what you should be looking for.</p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor134"/>The Accountant singleton class</h2>
<p>Our <code>Accountant</code> class will be a reification of the singleton design pattern whose role will be to <a id="_idIndexMarker442"/>allow the global overloads of the memory allocation operators to keep track of the number of bytes of dynamically allocated <a id="_idIndexMarker443"/>memory in a program. As previously mentioned, a singleton is an idea: a class for which there is only one instance in a program. This idea can be reified in various languages (at least those supporting some variant of the object-oriented paradigm) in ways that respect the particularities of each language.</p>
<p>One key particularity of C++ is the presence of actual objects, not just references to objects, in user <a id="_idIndexMarker444"/>code. This means that a C++ singleton will usually have the following characteristics:</p>
<ul>
<li>A <code>private</code> default constructor, since if that constructor was <code>public</code>, it could be called more than once which would make the class a non-singleton.</li>
<li>Deleted copy operations, as allowing copies of our object would make it a non-singleton.</li>
<li>A way to ensure the singleton can be created and, of course, accessed. That mechanism has to be such that it cannot be abused to create more than one object. Since our default constructor will be <code>private</code>, this mechanism will either be a <code>static</code> member function (this will be our choice) or a <code>friend</code> function.</li>
<li>Finally, the state used for the object’s representation and the services offered by the singleton, if any.</li>
</ul>
<p>An object of our <code>Accountant</code> class will expose three services: one to let the <code>new</code> and <code>new[]</code> operators inform the <code>Accountant</code> object that memory has been taken, one to inform it that memory has been given back, and one to let client code know how much memory is used at a given time.</p>
<p>An incomplete <a id="_idIndexMarker445"/>view of the <code>Accountant</code> class given <a id="_idIndexMarker446"/>what we have discussed so far would be as follows:</p>
<pre class="source-code">
#ifndef LEAK_DETECTOR_H
#define LEAK_DETECTOR_H
#include &lt;cstddef&gt;
#include &lt;new&gt;
class Accountant {
<strong class="bold">   Accountant(); // note: private</strong>
   //...
public:
   // deleted copy operations
<strong class="bold">   Accountant(const Accountant&amp;) = delete;</strong>
<strong class="bold">   Accountant&amp; operator=(const Accountant&amp;) = delete;</strong>
   // to access the singleton object
<strong class="bold">   static Accountant&amp; get();</strong>
   // services offered by the object
   // n bytes were allocated
<strong class="bold">   void take(std::size_t n);</strong>
   // n bytes were deallocated
<strong class="bold">   void give_back(std::size_t n);</strong>
   // number of bytes currently allocated
<strong class="bold">   std::size_t how_much() const;</strong>
};
// allocation operators (free functions)
void *operator new(std::size_t);
void *operator new[](std::size_t);
void operator delete(void*) noexcept;
void operator delete[](void*) noexcept;
#endif</pre> <p>With this, we can <a id="_idIndexMarker447"/>already complete the skeleton of our test program <a id="_idIndexMarker448"/>as presented earlier in this chapter:</p>
<pre class="source-code">
<strong class="bold">#include "leak_detector.h"</strong>
#include &lt;iostream&gt;
int main() {
<strong class="bold">   auto pre = Accountant::get().how_much();</strong>
   { // BEGIN
      int *p = new int{ 3 };
      int *q = new int[10]{ }; // initialized to zero
      delete p;
     // oops! Forgot to delete[] q
   } // END
<strong class="bold">   auto post = Accountant::get().how_much();</strong>
   // with this code, supposing sizeof(int)==4, we
   // expect to see "Leaked 40 bytes" printed
   if(post != pre)
      std::cout &lt;&lt; "Leaked " &lt;&lt; (post - pre) &lt;&lt; " bytes\n";
}</pre> <p>Now, we need to examine the implementation of the <code>Accountant</code> class. The first thing we need to decide is how and where the actual object will be created. It happens that there are surprisingly many ways to do this, but in our case (where we are not concerned <a id="_idIndexMarker449"/>by execution speed), the simplest <a id="_idIndexMarker450"/>way to correctly instantiate the object is what is called a <strong class="bold">Meyers Singleton</strong>, in honor <a id="_idIndexMarker451"/>of the now-retired but always respected <strong class="bold">Scott Meyers</strong>, who suggested that technique as part of <em class="italic">item 47</em> in his well-known book, <em class="italic">Effective C++: Specific Ways to Improve Your Programs and Designs (3rd Edition), </em><em class="italic">Addison-Wesley Professional</em>.</p>
<p class="callout-heading">The Meyers Singleton technique</p>
<p class="callout">The Meyers Singleton technique aims to avoid something colloquially called the <strong class="bold">static initialization order fiasco</strong>, an informal name given to the fact that in a C++ program made of multiple translation units, one cannot know from the source code in which order the global objects will be constructed (the problem also exists for the order of destruction, although the Meyers technique is not helpful for this).</p>
<p class="callout">The trick is to declare the singleton object as a <code>static</code> local variable in the <code>static</code> member function that provides access to the object (here, the <code>get()</code> function): doing so ensures the object will be created only once, the first time the function is called, and will keep its state throughout the execution of the program. There is a slight but measurable cost to doing so as there is a form of low-level implicit synchronization surrounding the object’s construction to avoid the object being created more than once even in a multithreaded program.</p>
<p class="callout">This technique ensures all such singletons are created in the correct order (meaning that, if the constructor of singleton A needs a service from singleton B, this will lead to singleton B being constructed “just in time”) even if they are technically “global” variables, as long as there is no cycle in the calls that create them of course.</p>
<p>In terms of state, since <code>take()</code> and <code>give_back()</code> both accept an argument of type <code>std::size_t</code>, it would be tempting to represent the current amount of memory also as <code>std::size_t</code>, but allow me to recommend something else. Indeed, <code>std::size_t</code> is an alias for an <em class="italic">unsigned</em> integral type, which means that this representation would make it difficult to detect a case where there have been more bytes <em class="italic">deallocated</em> than allocated, an unpleasant situation we would surely like to handle. For that reason, we will use a (large) signed integral instead.</p>
<p>Fine, you might think: we can use a <code>long long</code> representation then! However, remember that memory allocation and deallocation mechanisms need to be thread-safe, so we need <a id="_idIndexMarker452"/>to ensure that all accesses to that integral representation <a id="_idIndexMarker453"/>will be synchronized. There are many ways to do this, but the simplest one is probably to use an atomic type, in our case, <code>std::atomic&lt;long long&gt;</code>. Note that atomic objects are uncopiable so our singleton would implicitly be uncopiable, but there’s no harm in stating that fact explicitly as we did when deleting the copy operations.</p>
<p>A complete implementation of the <code>Accountant</code> class would be as follows:</p>
<pre class="source-code">
#ifndef LEAK_DETECTOR_H
#define LEAK_DETECTOR_H
#include &lt;cstddef&gt;
<strong class="bold">#include &lt;atomic&gt;</strong>
#include &lt;new&gt;
class Accountant {
<strong class="bold">   std::atomic&lt;long long&gt; cur;</strong>
<strong class="bold">   Accountant() : cur{ 0LL } { // note: private</strong>
<strong class="bold">   }</strong>
public:
   // deleted copy operations
   Accountant(const Accountant&amp;) = delete;
   Accountant&amp; operator=(const Accountant&amp;) = delete;
   // to access the singleton object
<strong class="bold">   static auto&amp; get() { // auto used for simplicity</strong>
<strong class="bold">      static Accountant singleton; // here it is</strong>
<strong class="bold">      return singleton;</strong>
<strong class="bold">   }</strong>
   // services offered by the object
   // n bytes were allocated
<strong class="bold">   void take(std::size_t n) { cur += n; }</strong>
   // n bytes were deallocated
<strong class="bold">   void give_back(std::size_t n) { cur -= n; }</strong>
   // number of bytes currently allocated
<strong class="bold">   std::size_t how_much() const { return cur.load(); }</strong>
};
// allocation operators (free functions)
void *operator new(std::size_t);
void *operator new[](std::size_t);
void operator delete(void*) noexcept;
void operator delete[](void*) noexcept;
#endif</pre> <p>The services <a id="_idIndexMarker454"/>are probably trivial to understand <a id="_idIndexMarker455"/>for the most part. Since <code>cur</code> is an atomic object, operations such as <code>+=</code> or <code>-=</code> modify <code>cur</code> in a synchronized manner, avoiding data races. Two subtle aspects of <code>how_much()</code> deserve a short discussion:</p>
<ul>
<li>The first is that we are returning <code>cur.load()</code>, not <code>cur</code>, since we care about the value represented by the <code>atomic</code> object, not the atomic object itself (which is a synchronization mechanism, not an integral value, and is uncopiable as previously mentioned). It’s like taking a picture of that value at a specific point in time, really.</li>
<li>The second, a consequence of the first, is that by the time the client code gets the value returned by that function, the actual value might have changed, so this function is inherently “racy” if used in a multithreaded situation. It’s not a problem for our test code, of course, but it’s something to be aware of.</li>
</ul>
<p>Now that we have put in place a scaffolding for keeping track of the number of bytes allocated, we can start to write the actual allocation and deallocation functions.</p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor135"/>Implementing the new and new[] operators</h2>
<p>If you remember our plan, what we will do in our memory allocation operators is take the number <a id="_idIndexMarker456"/>of bytes, <code>n</code>, requested by client code, then <a id="_idIndexMarker457"/>allocate slightly more because we will hide <code>n</code> just before the beginning of the block of <code>n</code> bytes we will end up returning to <a id="_idIndexMarker458"/>our client. Minimally, we will need to allocate <code>n + sizeof n</code> bytes to <a id="_idIndexMarker459"/>achieve this. In this example, we will use <code>std::malloc()</code> and <code>std::free()</code> to perform the low-level allocation operations.</p>
<p>We will signal failure to allocate by throwing <code>std::bad_alloc</code> as is customary in C++. If the allocation succeeds, we will then inform the <code>Accountant</code> object that <code>n</code> bytes have been allocated, even though we will have allocated a bit more. The fact that our strategy leads us to allocate more than requested is an artifact that does not concern client code, and that might even be confusing when trying to diagnose problems: a program that allocates a single byte and is informed that it leaked much more than this would be somewhat awkward.</p>
<p>A complete but naïve (and slightly incorrect, as announced) implementation would be as follows:</p>
<pre class="source-code">
#include &lt;cstdlib&gt;
void *operator new(std::size_t n) {
<strong class="bold">   // allocate n bytes plus enough space to hide n</strong>
   void *p = std::malloc(n + sizeof n); <strong class="bold">// to revisit</strong>
<strong class="bold">   // signal failure to meet postconditions if needed</strong>
   if(!p) throw std::bad_alloc{};
<strong class="bold">   // hide n at the beginning of the allocated block</strong>
   auto q = static_cast&lt;std::size_t*&gt;(p);
   *q = n; <strong class="bold">// to revisit</strong>
<strong class="bold">   // inform the Accountant of the allocation</strong>
   Accountant::get().take(n);
<strong class="bold">   // return the beginning of the requested block memory</strong>
   return q + 1; <strong class="bold">// to revisit</strong>
}
void *operator new[](std::size_t n) {
   // exactly the same as operator new above
}</pre> <p>Remember that <a id="_idIndexMarker460"/>even though <code>operator new()</code> and <code>operator new[]()</code> are identical <a id="_idIndexMarker461"/>in this example, there is no obligation <a id="_idIndexMarker462"/>to make them the same in all situations. Also, note <a id="_idIndexMarker463"/>that some of the lines in this excerpt have a comment stating “to revisit” as we will want to take a closer look at these later in this chapter.</p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor136"/>Implementing the delete and delete[] operators</h2>
<p>Our deallocation <a id="_idIndexMarker464"/>operators will collaborate in the elaborate lie prepared <a id="_idIndexMarker465"/>by the allocation operators: we know that the <code>new</code> and <code>new[]</code> operators <a id="_idIndexMarker466"/>return pointers to a block <a id="_idIndexMarker467"/>of <code>n</code> bytes, but that block is not what has really been allocated, it’s “just” the place where an object lived for a while. For that reason, it’s important that the <code>delete</code> and <code>delete[]</code> operators do the required address adjustment before performing the actual deallocation.</p>
<p>The rules for a correct implementation of <code>operator delete</code> are as follows:</p>
<ul>
<li>Applying <code>operator delete()</code> or <code>operator delete[]()</code> on a null pointer is a no-op</li>
<li>Deallocation functions should not throw</li>
<li>The deallocation code should be coherent with the associated allocation function</li>
</ul>
<p class="callout-heading">Not all null pointers are the same</p>
<p class="callout">While it’s true that given some <code>T*</code> object named <code>p</code>, writing <code>delete p</code> or <code>delete [] p</code> will be a no-op if <code>p==nullptr</code>. However, writing <code>delete nullptr</code> will fail to compile as <code>nullptr</code> is an object of type <code>std::nullptr_t</code>, not a pointer.</p>
<p>Given the <a id="_idIndexMarker468"/>implementation of our allocation operators in the previous <a id="_idIndexMarker469"/>section, this means a mostly adequate <a id="_idIndexMarker470"/>deallocation operator could be as <a id="_idIndexMarker471"/>follows:</p>
<pre class="source-code">
void operator delete(void *p) noexcept {
<strong class="bold">   // delete on a null pointer is a no-op</strong>
   if(!p) return;
<strong class="bold">   // find the beginning of the block that was allocated</strong>
   auto q = static_cast&lt;std::size_t*&gt;(p) - 1; <strong class="bold">// to revisit</strong>
<strong class="bold">   // inform the Accountant of the deallocation</strong>
   Accountant::get().give_back(*q);
<strong class="bold">   // free the memory</strong>
   std::free(q);
}
void operator delete[](void *p) noexcept {
   // exactly the same as operator delete above
}</pre> <p>That completes the lie, or so to say, and it completes the leak detector, at least for this first (and imperfect) implementation. If you run the test program with our implementation on a compiler where <code>sizeof(int)==4</code>, you can expect it to display that its execution leaked 40 bytes as expected.</p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor137"/>Visualizing it all</h2>
<p>When enjoying low-level programming such as this (taking over the memory allocation functions <a id="_idIndexMarker472"/>of your program, manipulating raw memory blocks, hiding information, and playing tricks with addresses), it can be hard to visualize what one is doing, and what the consequences are.</p>
<p>If your favorite debugger allows you to do so, you might want to try to go through the test program’s execution step by step. Please make sure you work in so-called “debug” (unoptimized) mode to fully benefit from the experience, as optimized code is often sufficiently transformed by the compiler to make the association between source code and generated code difficult to make.</p>
<p>Let’s walk through a call to <code>operator new()</code> step by step. The first thing we do is ask <code>Accountant</code> for the amount of dynamically allocated memory at the beginning of the <code>main()</code> function:</p>
<pre class="source-code">
int main() {
<strong class="bold">   auto pre = Accountant::get().how_much();</strong>
   { // BEGIN
<strong class="bold">      int *p = new int{ 3 };</strong>
      int *q = new int[10]{ }; // initialized to zero
      delete p;
     // oops! Forgot to delete[] q
   } // END
<strong class="bold">   auto post = Accountant::get().how_much();</strong>
   if(post != pre)
      std::cout &lt;&lt; "Leaked " &lt;&lt; (post - pre) &lt;&lt; " bytes\n";
}</pre> <p>One can expect <code>pre==0</code> at this point but there are situations, such as a global object calling <code>new</code> in its constructor, that could lead to <code>pre</code> having other values. This is fine, as what we are monitoring with this approach is whether there is a leak in between the braces marked with <code>BEGIN</code> and <code>END</code>, and this should hold regardless of whether the amount of bytes allocated outside of those braces is zero or not.</p>
<p>The next <a id="_idIndexMarker473"/>step is calling <code>operator new()</code> and requesting a memory block big enough to store an <code>int</code> object:</p>
<pre class="source-code">
int main() {
<strong class="bold">   auto pre = Accountant::get().how_much();</strong>
   { // BEGIN
<strong class="bold">      int *p = new int{ 3 };</strong>
      int *q = new int[10]{ }; // initialized to zero
      delete p;
     // oops! Forgot to delete[] q
   } // END
<strong class="bold">   auto post = Accountant::get().how_much();</strong>
   if(post != pre)
      std::cout &lt;&lt; "Leaked " &lt;&lt; (post - pre) &lt;&lt; " bytes\n";
}</pre> <p>This leads us to our implementation of <code>operator new()</code> where <code>n==sizeof(int)</code>. Supposing <code>sizeof(int)==4</code> and <code>sizeof(std::size_t)==8</code> for the sake of this example, our call to <code>std::malloc()</code> will request a block of at least 12 bytes:</p>
<pre class="source-code">
void *operator new(<strong class="bold">std::size_t n</strong>) {
<strong class="bold">   void *p = std::malloc(n + sizeof n);</strong>
   if(!p) throw std::bad_alloc{};
   auto q = static_cast&lt;std::size_t*&gt;(p);
   *q = n;
   Accountant::get().take(n);
   return q + 1;
}</pre> <p>If you look at the memory pointed to by <code>p</code> with your debugger once the call to <code>std::malloc()</code> completes, you might see something like the following (all numbers are expressed in hexadecimal form):</p>
<div><div><img alt="Figure 8.3 – Possible initial state for the allocated block" src="img/B21071_08_3.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Possible initial state for the allocated block</p>
<p>Note that there is no guarantee that you will see these specific values as C++ does not impose any <a id="_idIndexMarker474"/>requirement on the initialization of the memory block returned by <code>std::malloc()</code>. These <code>0xcd</code> hexadecimal values (or similar recognizable patterns) are however probable when using a “debug build” as libraries compiled for debugging will often place recognizable bit patterns in uninitialized memory to help detect programming errors.</p>
<p>You might also notice the trailing four bytes (each containing <code>0xfd</code>), which are also suspiciously recognizable, suggesting that the implementation of <code>std::malloc()</code> I used allocated more than what I requested and stored a marker just after the block my code requested, probably to help detect buffer overruns. Our library has the same implementation freedom as we do, after all!</p>
<p>The first lie we did was the overallocation of memory with respect to the actual request we got. We now commit a second lie about the very nature of the memory we are pointing to:</p>
<pre class="source-code">
void *operator new(std::size_t n) {
<strong class="bold">   </strong><strong class="bold">void *p = std::malloc(n + sizeof n);</strong>
   if(!p) throw std::bad_alloc{};
<strong class="bold">   auto q = static_cast&lt;std::size_t*&gt;(p);</strong>
   *q = n;
   Accountant::get().take(n);
   return q + 1;
}</pre> <p>Converting a pointer from or to <code>void*</code> can be done efficiently with <code>static_cast</code>, as explained in <a href="B21071_03.xhtml#_idTextAnchor047"><em class="italic">Chapter 3</em></a>. We now have two perspectives on the same memory block with <code>p</code> claiming that the block holds raw memory and <code>q</code> claiming (erroneously) that it holds at least one <code>std::size_t</code>:</p>
<div><div><img alt="Figure 8.4 – Two perspectives on the same memory block" src="img/B21071_08_4.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – Two perspectives on the same memory block</p>
<p>Through <code>q</code>, we hide the value of <code>n</code> at the beginning of the allocated memory block. Remember <a id="_idIndexMarker475"/>that this is not what we will be returning to our caller, so this is done without the client code’s knowledge:</p>
<pre class="source-code">
void *operator new(std::size_t n) {
<strong class="bold">   void *p = std::malloc(n + sizeof n);</strong>
   if(!p) throw std::bad_alloc{};
<strong class="bold">   auto q = static_cast&lt;std::size_t*&gt;(p);</strong>
<strong class="bold">   *q = n;</strong>
   Accountant::get().take(n);
   return q + 1;
}</pre> <p>One possible view of the memory pointed to by both <code>p</code> and <code>q</code> would now be as follows:</p>
<div><div><img alt="Figure 8.5 – Possible state of the memory block after hiding the value of n" src="img/B21071_08_5.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – Possible state of the memory block after hiding the value of n</p>
<p>Again, your view might differ from this one: we wrote an eight-byte integral value, which explains the number of consecutive bytes affected by this write, but the order of bytes in an integer depends on the underlying hardware architecture: some architectures are <code>4</code> closer to the right and of that eight-byte write instead of being on the left as it is in this example.</p>
<p>After informing <code>Accountant</code> that we allocated 4 bytes (not 12, remember), we reach the point <a id="_idIndexMarker476"/>where we return to our caller the beginning of the 4-byte block that was actually requested:</p>
<pre class="source-code">
void *operator new(std::size_t n) {
<strong class="bold">   void *p = std::malloc(n + sizeof n);</strong>
   if(!p) throw std::bad_alloc{};
<strong class="bold">   auto q = static_cast&lt;std::size_t*&gt;(p);</strong>
   *q = n;
   Accountant::get().take(n);
<strong class="bold">   return q + 1;</strong>
}</pre> <p>Looking at our memory block, the situation is now as follows:</p>
<div><div><img alt="Figure 8.6 – State of the memory block at the point of return" src="img/B21071_08_6.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – State of the memory block at the point of return</p>
<p>Returning to the caller, the constructor of the <code>int</code> object is applied to the block returned by <code>operator new()</code>:</p>
<pre class="source-code">
int main() {
<strong class="bold">   auto pre = Accountant::get().how_much();</strong>
   { // BEGIN
<strong class="bold">      int *p = new int{ 3 };</strong>
      int *q = new int[10]{ }; // initialized to zero
      delete p;
     // oops! Forgot to delete[] q
   } // END
<strong class="bold">   </strong><strong class="bold">auto post = Accountant::get().how_much();</strong>
   if(post != pre)
      std::cout &lt;&lt; "Leaked " &lt;&lt; (post - pre) &lt;&lt; " bytes\n";
}</pre> <p>After having <a id="_idIndexMarker477"/>applied the constructor on the memory pointed to by <code>p</code> in <code>main()</code>, our memory block looks like the following:</p>
<div><div><img alt="Figure 8.7 – Possible state of the memory block after constructing *p" src="img/B21071_08_7.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 – Possible state of the memory block after constructing *p</p>
<p><em class="italic">Voilà</em>! The beauty of all this is that client code (the <code>main()</code> function) has no idea that we played those tricks and performed those lies, just as we really have no idea what other tricks <code>std::malloc()</code> did for us (unless we can look at its source code, of course). Program execution continues normally and <code>*p</code> can be used like any other <code>int</code> until we reach the point where we decide to deallocate it:</p>
<pre class="source-code">
int main() {
<strong class="bold">   auto pre = Accountant::get().how_much();</strong>
   { // BEGIN
<strong class="bold">      int *p = new int{ 3 };</strong>
      int *q = new int[10]{ }; // initialized to zero
<strong class="bold">      delete p;</strong>
     // oops! Forgot to delete[] q
   } // END
<strong class="bold">   </strong><strong class="bold">auto post = Accountant::get().how_much();</strong>
   if(post != pre)
      std::cout &lt;&lt; "Leaked " &lt;&lt; (post - pre) &lt;&lt; " bytes\n";
}</pre> <p>When entering <code>operator delete()</code>, you might notice that the memory pointed to by the <code>p</code> argument <a id="_idIndexMarker478"/>begins with value <code>3</code> (the value of the <code>int</code>), not value <code>4</code>. This makes sense as <code>p</code> points to the memory block that was given to the client code, not to the beginning of the block we actually allocated:</p>
<div><div><img alt="Figure 8.8 – State of the memory block prior to destruction (caller’s perspective)" src="img/B21071_08_8.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.8 – State of the memory block prior to destruction (caller’s perspective)</p>
<p>Before continuing, it’s important to understand here that the reason why you probably see <code>3</code> here is that <code>int</code> is a trivially destructible type so its destructor was essentially a no-op. Normally, at the point where <code>operator delete()</code> begins its execution, the destructor for the pointed-to object has already run and the memory block could contain pretty much anything.</p>
<p>Within <code>operator delete()</code>, our first task is to retrieve the location where we hid the value of <code>n</code> during the corresponding call to <code>operator new()</code>:</p>
<pre class="source-code">
void operator delete(void *p) noexcept {
   if(!p) return;
<strong class="bold">   auto q = static_cast&lt;std::size_t*&gt;(p) - 1;</strong>
   Accountant::get().give_back(*q);
   std::free(q);
}</pre> <p>At this point, <code>q</code> is the location where the value of <code>n</code> was stored as well at the beginning of the memory block that was allocated. We inform <code>Accountant</code> of the fact that <code>n</code> bytes were deallocated, and call <code>std::free()</code> to perform the actual deallocation.</p>
<p>If you are observing the memory pointed to by <code>q</code> when calling <code>std::free()</code>, it is possible (but not guaranteed) that you will see that memory being written to. It is also possible (but also not guaranteed) that you will see memory written to <em class="italic">before</em> <code>q</code> as well as <em class="italic">after</em> the end of the bytes memory block you had allocated. Remember that <code>std::free()</code>, like <code>std::malloc()</code>, can do whatever bookkeeping tasks it requires just as it can overwrite <a id="_idIndexMarker479"/>memory blocks that have been freed, particularly in builds meant for debugging; or, it can just leave the memory as it was, which is more probable with optimized builds.</p>
<p>That was fun, wasn’t it? It seems to work indeed, at least on some machines. Yet, as stated earlier, this version of our leak detector has bugs, and these bugs can really hurt us. As a hint, know that if we compile this leak detector on a compiler where <code>std::size_t</code> is four bytes wide and try to call <code>new double</code>, we might get into <em class="italic">very</em> serious trouble. It is now time to take a closer look at our implementation to grasp why this is so and fix the problems we caused.</p>
<h1 id="_idParaDest-135"><a id="_idTextAnchor138"/>Identifying (and fixing) the problems</h1>
<p>Our initial implementation has in fact one real problem, as well as something that works but could be <a id="_idIndexMarker480"/>cleaner and deserves discussion.</p>
<p>The real problem is that we express our lies in dangerous ways and that we are not giving proper consideration to alignment requirements. Indeed, look at our initial implementation of <code>operator new()</code>:</p>
<pre class="source-code">
void *operator new(std::size_t n) {
   // allocate n bytes plus enough space to hide n
<strong class="bold">   void *p = std::malloc(n + sizeof n); // to revisit</strong>
   // signal failure to meet postconditions if needed
   if(!p) throw std::bad_alloc{};
   // hide n at the beginning of the allocated block
   auto q = static_cast&lt;std::size_t*&gt;(p);
   *q = n; // to revisit
   // inform the Accountant of the allocation
   Accountant::get().take(n);
   // return the beginning of the requested block memory
<strong class="bold">   return q + 1; // to revisit</strong>
}</pre> <p>We know for a fact that the memory returned by <code>std::malloc()</code> has to be aligned appropriately for the strictest (meaning <em class="italic">worst</em>) natural alignment of our machine: indeed, since that <a id="_idIndexMarker481"/>function does not know what object will be constructed once the allocation has completed, it has to make sure that the memory block allocated will be properly aligned in all “natural” cases. C++ compilers offer <code>std::max_align_t</code> as an alias for the type with the strictest natural alignment in a machine, which is often, but not necessarily, type <code>double</code> in practice.</p>
<p>Now, we allocate a bit more than was requested, <code>sizeof(std::size_t)</code> more bytes to be precise. That’s fine up to a point: we can assuredly store <code>std::size_t</code> at the beginning of the block returned by <code>std::malloc()</code> since that block is well aligned even in the worst case.</p>
<p>Then, we “jump over” <code>std::size_t</code> and return an address that is <code>sizeof(std::size_t)</code> bytes more than the one we allocated. This can be fine if it still yields a correctly aligned address even in the worst case, but that is only the case if <code>std::size_t</code> and <code>std::max_align_t</code> are of the same size, something that is <em class="italic">not</em> guaranteed (in practice, their sizes are often different).</p>
<p>What happens if these types are of different sizes and, consequently, the address returned by <code>operator new()</code> does not match the alignment requirements of <code>std::max_align_t</code>? Well, it depends:</p>
<ul>
<li>It can work if we get “lucky” and the address returned is aligned correctly for the type we want to construct. For example, suppose that <code>alignof(int)==4</code> and <code>alignof(std::max_align_t)==8</code>, then calling <code>new int</code> will work even if <code>operator new</code> returns an address that is a multiple of four but not of eight. However, it’s probable that calling <code>new double</code> will only lead to pain. This sort of “luck” can be a curse, hiding a latent, damaging bug for a while and making for unpleasant surprises later.</li>
<li>You can end up with slow and dangerous code, as some hardware will support access to misaligned objects. You don’t want to do that, however, as for the machine to achieve this, it needs to perform acrobatics and transform a seemingly simple <a id="_idIndexMarker482"/>operation such as loading <code>double</code> in a register into a sequence of operations (load the “low” bytes, load the “high” bytes, and make a <code>double</code> out of these two parts through bitwise manipulations). This leads to code that is significantly slower to execute, obviously, but also dangerous if you have a multithreaded program as one thread could <a id="_idIndexMarker483"/>read a partially formed object (this is called a <strong class="bold">torn read</strong>) or write to a <a id="_idIndexMarker484"/>partially formed object (a <strong class="bold">torn write</strong>). You really do not want to debug code where this happens.</li>
<li>Your code can simply crash, as will be the case on many embedded platforms (including quite a few game consoles). It’s arguably the most reasonable outcome in such a situation.</li>
</ul>
<p>To fix this problem, we need to ensure that the address returned from our overloaded <code>operator new()</code> is properly aligned for <code>std::max_align_t</code>, and that <code>operator delete()</code> is adjusted accordingly. One way to do this would be to ensure that the size of the “hiding spot” for <code>n</code> is such that jumping over that additional memory block still results in an address that is properly aligned for a <code>std::max_align_t</code> object:</p>
<pre class="source-code">
void *operator new(std::size_t n) {
<strong class="bold">   // allocate n bytes plus enough space to hide n,</strong>
<strong class="bold">   // taking worst case natural alignment into account</strong>
<strong class="bold">   void *p = std::malloc(sizeof(std::max_align_t) + n);</strong>
   // signal failure to meet postconditions if needed
   if(!p) throw std::bad_alloc{};
   // hide n at the beginning of the allocated block
   *static_cast&lt;std::size_t*&gt;(p) = n; // to revisit
   // inform the Accountant of the allocation
   Accountant::get().take(n);
<strong class="bold">   // return the beginning of the requested block memory</strong>
<strong class="bold">   return static_cast&lt;std::max_align_t*&gt;(p) + 1;</strong>
}</pre> <p>As you can see, this implementation allocates space for <code>std::max_align_t</code> in addition to the requested <code>n</code> bytes, then “jumps over” that additional storage to yield an address that <a id="_idIndexMarker485"/>is still properly aligned for the worst case. This might mean wasting more space than in the initial (incorrect) implementation if <code>sizeof(std::size_t)</code> happens to be less than <code>sizeof(std::max_align_t)</code>, but at least we know that client code will be able to construct its object there.</p>
<p>The corresponding <code>operator delete()</code> will do the same pointer gymnastics but in reverse, going back <code>sizeof(std::max_align_t)</code> bytes in memory:</p>
<pre class="source-code">
void operator delete(void *p) noexcept {
   // delete on a null pointer is a no-op
   if(!p) return;
<strong class="bold">   // find the beginning of the block that was allocated</strong>
<strong class="bold">   p = static_cast&lt;std::max_align_t*&gt;(p) - 1;</strong>
<strong class="bold">   // inform the Accountant of the deallocation</strong>
<strong class="bold">   Accountant::get().give_back(</strong>
<strong class="bold">     *static_cast&lt;std::size_t*&gt;(p)</strong>
<strong class="bold">   );</strong>
   // free the memory
   std::free(p);
}</pre> <p>Note that this implementation assigns <code>std::max_align_t*</code> to <code>void*</code> (pointer <code>p</code>), something that is perfectly legal and does not require a cast.</p>
<p>The other <a id="_idIndexMarker486"/>issue we should discuss is not technically a problem in this implementation but is a problem in general. Look at this excerpt from <code>operator new()</code>:</p>
<pre class="source-code">
void *operator new(std::size_t n) {
   void *p = std::malloc(n + sizeof(std::max_align_t));
   if(!p) throw std::bad_alloc{};
<strong class="bold">   // hide n at the beginning of the allocated block</strong>
<strong class="bold">   </strong><strong class="bold">*static_cast&lt;std::size_t*&gt;(p) = n; // to revisit</strong>
   Accountant::get().take(n);
   return static_cast&lt;std::max_align_t*&gt;(p) + 1;
}</pre> <p>Do you notice something strange? The highlighted line of code performs an assignment where <code>p</code> points, but the assignment only makes sense on an existing object. Is there an object at location <code>*p</code> at that moment?</p>
<p>The answer is… strange. To create an object, one has to call its constructor, but we never called the constructor of <code>std::size_t</code> at location <code>p</code> in this code. This might make you wonder why our code seems to work. It happens that the following is the case:</p>
<ul>
<li>Some types in <a id="_idIndexMarker487"/>C++ are said to be <code>std::nullptr_t</code> including their cv-qualified counterparts) and implicit lifetime classes (aggregates with no user-provided destructor, at least one eligible trivial constructor as well as a non-deleted trivial destructor). You will notice that <code>std::size_t</code>, being an alias for an unsigned integral type, falls under the umbrella of implicit lifetime types. If you have a C++23 compiler, you can programmatically test if some type <code>T</code> qualifies as an implicit lifetime type through the <code>std::is_implicit_lifetime&lt;T&gt;</code> trait.</li>
<li>Some standard library functions implicitly start the lifetime of objects of implicit lifetime types. These include some C functions, such as <code>std::memcpy()</code>, <code>std::memmove()</code>, and <code>std::malloc()</code>, but also <code>std::bit_cast</code>, some functions in allocators (see <a href="B21071_14.xhtml#_idTextAnchor199"><em class="italic">Chapter 14</em></a>) as well as two functions from C++23 respectively named <code>std::start_lifetime_as()</code> and <code>std::start_lifetime_as_array()</code>.</li>
</ul>
<p>What makes this assignment operation work in this specific case is that we are writing to an object <a id="_idIndexMarker488"/>of an implicit lifetime type in a block of memory that is properly aligned and has been allocated with one of these special functions that have the property of implicitly starting the lifetime of objects. If we had decided to store something more elaborate than an object of some implicit lifetime type, our assignment would either fail at compile-time (if our compiler is nice enough to notice our mistake) or risk causing damage at runtime.</p>
<p>A better, and in general, safer approach to the act of hiding the value of <code>n</code> in some uninitialized storage is to use <code>placement new</code>, as seen in <a href="B21071_07.xhtml#_idTextAnchor116"><em class="italic">Chapter 7</em></a>. The following implementation of <code>operator new()</code> is thus preferable in general as it avoids an (often misguided) assignment to a non-object:</p>
<pre class="source-code">
void *operator new(std::size_t n) {
   void *p = std::malloc(n + sizeof(std::max_align_t));
   if(!p) throw std::bad_alloc{};
<strong class="bold">   // hide n at the beginning of the allocated block</strong>
<strong class="bold">   </strong><strong class="bold">new (p) std::size_t{ n };</strong>
   Accountant::get().take(n);
   return static_cast&lt;std::max_align_t*&gt;(p) + 1;
}</pre> <p>Note that since <code>std::size_t</code> has a trivial destructor, there is no need to call its destructor in <code>operator delete()</code>; simply freeing its underlying storage is sufficient to end its lifetime. We now have a correct, working leak detector!</p>
<h1 id="_idParaDest-136"><a id="_idTextAnchor139"/>Revisiting our implementation (and lessons learned)</h1>
<p>We just overloaded memory allocation operators, blatantly lied our way through the protections <a id="_idIndexMarker489"/>of the type system, performed potentially dangerous operations that risked leading to misaligned objects, and saw how to avoid this pitfall. That was an interesting adventure indeed, but the astute reader that you are is probably wondering about the cost of this trick, particularly in terms of how much memory it consumes.</p>
<p>With our “allocate more than requested and hide <code>n</code> at the beginning” approach, each allocation consumes <code>sizeof(std::max_align_t)</code> bytes more than needed by client code. If our code allocates large objects, that cost might be minor, but if we allocate smaller objects, this overhead can be unreasonable and dominate the memory consumption of our entire program.</p>
<p>Remember from <a href="B21071_07.xhtml#_idTextAnchor116"><em class="italic">Chapter 7</em></a> that C++14 made it possible to provide an overload of <code>operator delete()</code> that accepts the size of the just-destroyed object as an argument. This makes the act of hiding <code>n</code> during <code>operator new()</code> redundant, as we did so precisely in order to retrieve <code>n</code> in <code>operator delete()</code>, something we no longer need to do.</p>
<p>Since we do not need to hide <code>n</code>, we can both simplify our implementation and significantly reduce our memory consumption:</p>
<pre class="source-code">
void *operator new(std::size_t n) {
<strong class="bold">   // allocate n bytes (no need for more!)</strong>
<strong class="bold">   void *p = std::malloc(n);</strong>
   // signal failure to meet postconditions if needed
   if(!p) throw std::bad_alloc{};
   // inform the Accountant of the allocation
   Accountant::get().take(n);
<strong class="bold">   // return the beginning of the requested block memory</strong>
<strong class="bold">   return p;</strong>
}
void *operator new[](std::size_t n) {
   // exactly the same as operator new above
}
void operator delete(void *p<strong class="bold">, std::size_t n</strong>) noexcept {
   // delete on a null pointer is a no-op
   if(!p) return;
<strong class="bold">   // inform the Accountant of the deallocation</strong>
<strong class="bold">   Accountant::get().give_back(n);</strong>
   // free the memory
   std::free(p);
}
void operator delete[](void *p<strong class="bold">, std::size_t n</strong>) noexcept {
   // exactly the same as operator delete above
}</pre> <p>This leak <a id="_idIndexMarker490"/>detector still works and represents a strict upgrade when compared with the more naïve version that preceded it.</p>
<h1 id="_idParaDest-137"><a id="_idTextAnchor140"/>Summary</h1>
<p>That was fun, wasn’t it? You can take this very simple tool and make it more interesting: for example, you could use it to check for overflow and underflow of the allocated memory blocks by injecting sentinel values before and after each block, or you could use it to make a sort of map of the way your memory is being used.</p>
<p>This concludes our first foray into applications that benefit from taking charge of the memory allocation facilities at our disposal. Our next step, and next chapter, will lead us to examine how a C++ program can interact with atypical memory or deal with atypical allocation situations.</p>
<p>Of course, no programming language (even one as versatile and wide-ranging as C++) can profess to cover all possible types of memory that an operating system could provide services for, nor should that be the language’s role. Still, as we will see, C++ provides us with the kind of “syntactic glue” required to build bridges between atypical needs and the rest of the program.</p>
</div>
</body></html>