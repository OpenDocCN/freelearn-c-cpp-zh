<html><head></head><body>
		<div><h1 id="_idParaDest-270"><a id="_idTextAnchor279"/><em class="italic">Chapter 13</em>: Sound Effects, File I/O, and Finishing the Game</h1>
			<p>We are nearly there. This short chapter will demonstrate how we can easily manipulate files stored on the hard drive using the C++ standard library, and we will also add sound effects. Of course, we know how to add sound effects, but we will discuss exactly where in the code the calls to the <code>play</code> function will go. We will also tie up a few loose ends to make the game complete.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Saving and loading the hi-score using file input and file output</li>
				<li>Adding sound effects</li>
				<li>Allowing the player to level up</li>
				<li>Creating multiple never-ending waves</li>
			</ul>
			<h1 id="_idParaDest-271"><a id="_idTextAnchor280"/>Saving and loading the high score</h1>
			<p>File <code>fstream</code>.</p>
			<p>First, we include <code>fstream</code> in the same way we included <code>sstream</code>:</p>
			<pre>#include &lt;sstream&gt;
<strong class="bold">#include &lt;fstream&gt;</strong>
#include &lt;SFML/Graphics.hpp&gt;
#include "ZombieArena.h"
#include "Player.h"
#include "TextureHolder.h"
#include "Bullet.h"
#include "Pickup.h"
using namespace sf;</pre>
			<p>Now, add a new folder in the <code>ZombieArena</code> folder called <code>gamedata</code>. Next, right-click in this folder and create a new file called <code>scores.txt</code>. It is in this file that we will save the player's high score. You can easily open the file and add a score to it. If you do, make sure it is quite a low score so that we can easily test whether beating that score results in the new score being added. Be sure to close the file once you are done with it or the game will not be able to access it. </p>
			<p>In the following code, we will create an <code>ifstream</code> object called <code>inputFile</code> and send the folder and file we just created as a parameter to its constructor.</p>
			<p><code>if(inputFile.is_open())</code> checks that the file exists and is ready to read from. We then put the contents of the file into <code>hiScore</code> and close the file. Add the following highlighted code:</p>
			<pre>// Score
Text scoreText;
scoreText.setFont(font);
scoreText.setCharacterSize(55);
scoreText.setColor(Color::White);
scoreText.setPosition(20, 0);
<strong class="bold">// Load the high score from a text file</strong>
<strong class="bold">std::ifstream inputFile("gamedata/scores.txt");</strong>
<strong class="bold">if (inputFile.is_open())</strong>
<strong class="bold">{</strong>
<strong class="bold">    // &gt;&gt; Reads the data</strong>
<strong class="bold">    inputFile &gt;&gt; hiScore;</strong>
<strong class="bold">    inputFile.close();</strong>
<strong class="bold">}</strong>
// Hi Score
Text hiScoreText;
hiScoreText.setFont(font);
hiScoreText.setCharacterSize(55);
hiScoreText.setColor(Color::White);
hiScoreText.setPosition(1400, 0);
std::stringstream s;
s &lt;&lt; "Hi Score:" &lt;&lt; hiScore;
hiScoreText.setString(s.str());</pre>
			<p>Now, we can handle saving a potentially new high score. Within the block that handles the player's health being less than or equal to zero, we need to create an <code>ofstream</code> object called <code>outputFile</code>, write the value of <code>hiScore</code> to the text file, and then close the file, like so:</p>
			<pre>// Have any zombies touched the player            
for (int i = 0; i &lt; numZombies; i++)
{
    if (player.getPosition().intersects
        (zombies[i].getPosition()) &amp;&amp; zombies[i].isAlive())
    {
        if (player.hit(gameTimeTotal))
        {
            // More here later
        }
        if (player.getHealth() &lt;= 0)
        {
            state = State::GAME_OVER;
<strong class="bold">            std::ofstream outputFile("gamedata/scores.txt");</strong>
<strong class="bold">            // &lt;&lt; writes the data</strong>
<strong class="bold">            outputFile &lt;&lt; hiScore;</strong>
<strong class="bold">            outputFile.close();</strong>
            
        }
    }
}// End player touched</pre>
			<p>You can play the game and your hi-score will be saved. Quit the game and notice that your hi-score is still there if you play it again.</p>
			<p>Let's make some noise.</p>
			<h1 id="_idParaDest-272"><a id="_idTextAnchor281"/>Preparing sound effects</h1>
			<p>In this section, we will create all the <code>SoundBuffer</code> and <code>Sound</code> objects that we need to add a range of sound effects to the game.</p>
			<p>Start by adding the required SFML <code>#include</code> statements:</p>
			<pre>#include &lt;sstream&gt;
#include &lt;fstream&gt;
#include &lt;SFML/Graphics.hpp&gt;
<strong class="bold">#include &lt;SFML/Audio.hpp&gt;</strong>
#include "ZombieArena.h"
#include "Player.h"
#include "TextureHolder.h"
#include "Bullet.h"
#include "Pickup.h"</pre>
			<p>Now, go ahead and add the seven <code>SoundBuffer</code> and <code>Sound</code> objects that load and prepare the seven sound files that we prepared in <a href="B14278_08_Final_AG_ePub.xhtml#_idTextAnchor183"><em class="italic">Chapter 8</em></a><em class="italic">, SFML Views – Starting the Zombie Shooter Game</em>:</p>
			<pre>// When did we last update the HUD?
int framesSinceLastHUDUpdate = 0;
// What time was the last update
Time timeSinceLastUpdate;
// How often (in frames) should we update the HUD
int fpsMeasurementFrameInterval = 1000;
<strong class="bold">// Prepare the hit sound</strong>
<strong class="bold">SoundBuffer hitBuffer;</strong>
<strong class="bold">hitBuffer.loadFromFile("sound/hit.wav");</strong>
<strong class="bold">Sound hit;</strong>
<strong class="bold">hit.setBuffer(hitBuffer);</strong>
<strong class="bold">// Prepare the splat sound</strong>
<strong class="bold">SoundBuffer splatBuffer;</strong>
<strong class="bold">splatBuffer.loadFromFile("sound/splat.wav");</strong>
<strong class="bold">Sound splat;</strong>
<strong class="bold">splat.setBuffer(splatBuffer);</strong>
<strong class="bold">// Prepare the shoot sound</strong>
<strong class="bold">SoundBuffer shootBuffer;</strong>
<strong class="bold">shootBuffer.loadFromFile("sound/shoot.wav");</strong>
<strong class="bold">Sound shoot;</strong>
<strong class="bold">shoot.setBuffer(shootBuffer);</strong>
<strong class="bold">// Prepare the reload sound</strong>
<strong class="bold">SoundBuffer reloadBuffer;</strong>
<strong class="bold">reloadBuffer.loadFromFile("sound/reload.wav");</strong>
<strong class="bold">Sound reload;</strong>
<strong class="bold">reload.setBuffer(reloadBuffer);</strong>
<strong class="bold">// Prepare the failed sound</strong>
<strong class="bold">SoundBuffer reloadFailedBuffer;</strong>
<strong class="bold">reloadFailedBuffer.loadFromFile("sound/reload_failed.wav");</strong>
<strong class="bold">Sound reloadFailed;</strong>
<strong class="bold">reloadFailed.setBuffer(reloadFailedBuffer);</strong>
<strong class="bold">// Prepare the powerup sound</strong>
<strong class="bold">SoundBuffer powerupBuffer;</strong>
<strong class="bold">powerupBuffer.loadFromFile("sound/powerup.wav");</strong>
<strong class="bold">Sound powerup;</strong>
<strong class="bold">powerup.setBuffer(powerupBuffer);</strong>
<strong class="bold">// Prepare the pickup sound</strong>
<strong class="bold">SoundBuffer pickupBuffer;</strong>
<strong class="bold">pickupBuffer.loadFromFile("sound/pickup.wav");</strong>
<strong class="bold">Sound pickup;</strong>
<strong class="bold">pickup.setBuffer(pickupBuffer);</strong>
// The main game loop
while (window.isOpen())</pre>
			<p>Now, the seven sound effects are ready to play. We just need to work out where in our code each of the calls to the <code>play</code> function will go.</p>
			<h1 id="_idParaDest-273"><a id="_idTextAnchor282"/>Leveling up</h1>
			<p>The following code we will add allows the player to level up between waves. It is because of the work we have already done that this is straightforward to achieve.</p>
			<p>Add the following highlighted code to the <code>LEVELING_UP</code> state where we handle player input:</p>
			<pre>// Handle the LEVELING up state
if (state == State::LEVELING_UP)
{
    // Handle the player LEVELING up
    if (event.key.code == Keyboard::Num1)
    {
<strong class="bold">        // Increase fire rate</strong>
<strong class="bold">        fireRate++;</strong>
        state = State::PLAYING;
    }
    if (event.key.code == Keyboard::Num2)
    {
<strong class="bold">        // Increase clip size</strong>
<strong class="bold">        clipSize += clipSize;</strong>
        state = State::PLAYING;
    }
    if (event.key.code == Keyboard::Num3)
    {
<strong class="bold">        // Increase health</strong>
<strong class="bold">        player.upgradeHealth();</strong>
        state = State::PLAYING;
    }
    if (event.key.code == Keyboard::Num4)
    {
<strong class="bold">        // Increase speed</strong>
<strong class="bold">        player.upgradeSpeed();</strong>
        state = State::PLAYING;
    }
    if (event.key.code == Keyboard::Num5)
    {
<strong class="bold">        // Upgrade pickup</strong>
<strong class="bold">        healthPickup.upgrade();</strong>
        state = State::PLAYING;
    }
    if (event.key.code == Keyboard::Num6)
    {
<strong class="bold">        // Upgrade pickup</strong>
<strong class="bold">        ammoPickup.upgrade();</strong>
        state = State::PLAYING;
    }
    if (state == State::PLAYING)
    {</pre>
			<p>The player can now level up each time a wave of zombies is cleared. We can't, however, increase the number of zombies or the size of the level just yet.</p>
			<p>In the next part of the <code>LEVELING_UP</code> state, right after the code we have just added, amend the code that runs when the state changes from <code>LEVELING_UP</code> to <code>PLAYING</code>.</p>
			<p>Here is the code in full. I have highlighted the lines that are either new or have been slightly amended.</p>
			<p>Add or amend the following highlighted code:</p>
			<pre>    if (event.key.code == Keyboard::Num6)
    {
        ammoPickup.upgrade();
        state = State::PLAYING;
    }
    if (state == State::PLAYING)
    {
<strong class="bold">        // Increase the wave number</strong>
<strong class="bold">        wave++;</strong>
        // Prepare the level
        // We will modify the next two lines later
<strong class="bold">        arena.width = 500 * wave;</strong>
<strong class="bold">        arena.height = 500 * wave;</strong>
        arena.left = 0;
        arena.top = 0;
        // Pass the vertex array by reference 
        // to the createBackground function
        int tileSize = createBackground(background, arena);
        // Spawn the player in the middle of the arena
        player.spawn(arena, resolution, tileSize);
        // Configure the pick-ups
        healthPickup.setArena(arena);
        ammoPickup.setArena(arena);
        // Create a horde of zombies
<strong class="bold">        numZombies = 5 * wave;</strong>
        // Delete the previously allocated memory (if it exists)
        delete[] zombies;
        zombies = createHorde(numZombies, arena);
        numZombiesAlive = numZombies;
<strong class="bold">        // Play the powerup sound</strong>
<strong class="bold">        powerup.play();</strong>
        // Reset the clock so there isn't a frame jump
        clock.restart();
    }
}// End LEVELING up</pre>
			<p>The previous code starts by incrementing the <code>wave</code> variable. Then, the code is amended to make the number of zombies and size of the arena relative to the new value of <code>wave</code>. Finally, we add the call to <code>powerup.play()</code> to play the leveling up sound effect.</p>
			<h1 id="_idParaDest-274"><a id="_idTextAnchor283"/>Restarting the game</h1>
			<p>We already determine the size of the arena and the number of zombies by the value of the <code>wave</code> variable. We must also reset the ammo and gun-related variables, as well as setting <code>wave</code> and <code>score</code> to zero at the start of each new game. Find the following code in the event-handling section of the game loop and add the following highlighted code:</p>
			<pre>// Start a new game while in GAME_OVER state
else if (event.key.code == Keyboard::Return &amp;&amp;
    state == State::GAME_OVER)
{
    state = State::LEVELING_UP;
<strong class="bold">    wave = 0;</strong>
<strong class="bold">    score = 0;</strong>
<strong class="bold">    // Prepare the gun and ammo for next game</strong>
<strong class="bold">    currentBullet = 0;</strong>
<strong class="bold">    bulletsSpare = 24;</strong>
<strong class="bold">    bulletsInClip = 6;</strong>
<strong class="bold">    clipSize = 6;</strong>
<strong class="bold">    fireRate = 1;</strong>
<strong class="bold">    // Reset the player's stats</strong>
<strong class="bold">    player.resetPlayerStats();</strong>
}</pre>
			<p>Now, we can play the game, the player can get even more powerful, and the zombies will get ever more numerous within an arena of increasing size—until they die. Then, the game starts all over again.</p>
			<h1 id="_idParaDest-275"><a id="_idTextAnchor284"/>Playing the rest of the sounds</h1>
			<p>Now, we will add the rest of the calls to the <code>play</code> function. We will deal with each of them individually, as locating exactly where they go is key to playing them at the right moment.</p>
			<h2 id="_idParaDest-276"><a id="_idTextAnchor285"/>Adding sound effects while the player is reloading</h2>
			<p>Add the following highlighted code in three places to play the appropriate <code>reload</code> or <code>reloadFailed</code> sound when the player presses the <em class="italic">R</em> key to attempt to reload their gun:</p>
			<pre>if (state == State::PLAYING)
{
    // Reloading
    if (event.key.code == Keyboard::R)
    {
        if (bulletsSpare &gt;= clipSize)
        {
            // Plenty of bullets. Reload.
            bulletsInClip = clipSize;
            bulletsSpare -= clipSize;        
<strong class="bold">            reload.play();</strong>
        }
        else if (bulletsSpare &gt; 0)
        {
            // Only few bullets left
            bulletsInClip = bulletsSpare;
            bulletsSpare = 0;                
<strong class="bold">            reload.play();</strong>
        }
        else
        {
            // More here soon?!
<strong class="bold">            reloadFailed.play();</strong>
        }
    }
}</pre>
			<p>The player will now get an audible response when they reload or attempt to reload. Let's move on to playing a shooting sound.</p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor286"/>Making a shooting sound</h2>
			<p>Add the following highlighted call to <code>shoot.play()</code> near the end of the code that handles the player clicking the left mouse button:</p>
			<pre>// Fire a bullet
if (sf::Mouse::isButtonPressed(sf::Mouse::Left))
{
    if (gameTimeTotal.asMilliseconds()
        - lastPressed.asMilliseconds()
        &gt; 1000 / fireRate &amp;&amp; bulletsInClip &gt; 0)
    {
        // Pass the centre of the player and crosshair
        // to the shoot function
        bullets[currentBullet].shoot(
            player.getCenter().x, player.getCenter().y,
            mouseWorldPosition.x, mouseWorldPosition.y);
        currentBullet++;
        if (currentBullet &gt; 99)
        {
            currentBullet = 0;
        }
        lastPressed = gameTimeTotal;
<strong class="bold">        shoot.play();</strong>
        bulletsInClip--;
    }
}// End fire a bullet</pre>
			<p>The game will now play a satisfying shooting sound. Next, we will play a sound when the player is hit by a zombie.</p>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor287"/>Playing a sound when the player is hit </h2>
			<p>In this following code, we wrap the call to <code>hit.play</code> in a test to see if the <code>player.hit</code> function returns true. Remember that the <code>player.hit </code>function tests to see if a hit has been recorded in the previous 100 milliseconds. This will have the effect of playing a fast-repeating thud sound, but not so fast that the sound blurs into one noise.</p>
			<p>Add the call to <code>hit.play</code>, as highlighted in the following code:</p>
			<pre>// Have any zombies touched the player            
for (int i = 0; i &lt; numZombies; i++)
{
    if (player.getPosition().intersects
        (zombies[i].getPosition()) &amp;&amp; zombies[i].isAlive())
    {
        if (player.hit(gameTimeTotal))
        {
            // More here later
<strong class="bold">            hit.play();</strong>
        }
        if (player.getHealth() &lt;= 0)
        {
            state = State::GAME_OVER;
            std::ofstream OutputFile("gamedata/scores.txt");
            OutputFile &lt;&lt; hiScore;
            OutputFile.close();
            
        }
    }
}// End player touched</pre>
			<p>The player will hear an ominous thudding sound when a zombie touches them, and this sound will repeat around five times per second if the zombie continues touching them. The logic for this is contained in the <code>hit</code> function of the <code>Player</code> class.</p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor288"/>Playing a sound when getting a pickup</h2>
			<p>When the player picks up a health pickup, we will play the regular pickup sound. However, when the player gets an ammo pickup, we will play the reload sound effect.</p>
			<p>Add the two calls to play sounds within the appropriate collision detection code:</p>
			<pre>// Has the player touched health pickup
if (player.getPosition().intersects
    (healthPickup.getPosition()) &amp;&amp; healthPickup.isSpawned())
{
    player.increaseHealthLevel(healthPickup.gotIt());
<strong class="bold">    // Play a sound</strong>
<strong class="bold">    pickup.play();</strong>
    
}
// Has the player touched ammo pickup
if (player.getPosition().intersects
    (ammoPickup.getPosition()) &amp;&amp; ammoPickup.isSpawned())
{
    bulletsSpare += ammoPickup.gotIt();
<strong class="bold">    // Play a sound</strong>
<strong class="bold">    reload.play();</strong>
    
}</pre>
			<h2 id="_idParaDest-280"><a id="_idTextAnchor289"/>Making a splat sound when a zombie is shot</h2>
			<p>Add a call to <code>splat.play</code> at the end of the section of code that detects a bullet colliding with a zombie:</p>
			<pre>// Have any zombies been shot?
for (int i = 0; i &lt; 100; i++)
{
    for (int j = 0; j &lt; numZombies; j++)
    {
        if (bullets[i].isInFlight() &amp;&amp; 
            zombies[j].isAlive())
        {
            if (bullets[i].getPosition().intersects
                (zombies[j].getPosition()))
            {
                // Stop the bullet
                bullets[i].stop();
                // Register the hit and see if it was a kill
                if (zombies[j].hit()) {
                    // Not just a hit but a kill too
                    score += 10;
                    if (score &gt;= hiScore)
                    {
                        hiScore = score;
                    }
                    numZombiesAlive--;
                    // When all the zombies are dead (again)
                    if (numZombiesAlive == 0) {
                        state = State::LEVELING_UP;
                    }
                }    
<strong class="bold">                // Make a splat sound</strong>
<strong class="bold">                splat.play();</strong>
                
            }
        }
    }
}// End zombie being shot</pre>
			<p>You can now play the completed game and watch the number of zombies and the arena increase each wave. Choose your level-ups carefully:</p>
			<div><div><img src="img/B14278_13_01.jpg" alt=""/>
				</div>
			</div>
			<p>Congratulations!</p>
			<h1 id="_idParaDest-281"><a id="_idTextAnchor290"/>Summary</h1>
			<p>We've finished the Zombie Arena game. It has been quite a journey. We have learned a whole bunch of C++ fundamentals, such as references, pointers, OOP, and classes. In addition, we have used SFML to manage cameras (views), vertex arrays, and collision detection. We learned how to use sprite sheets to reduce the number of calls to <code>window.draw</code> and speed up the frame rate. Using C++ pointers, the STL, and a little bit of OOP, we built a singleton class to manage our textures. In the next project, we will extend this idea to manage all of our game's assets.</p>
			<p>Coming up in the penultimate project of this book, we will discover particle effects, directional sound, and split-screen co-op gaming. In C++, we will encounter inheritance, polymorphism, and a few more new concepts as well.</p>
			<h1 id="_idParaDest-282"><a id="_idTextAnchor291"/>FAQ</h1>
			<p>Here are some questions that might be on your mind:</p>
			<p>Q) Despite using classes, I am finding that the code is getting very long and unmanageable again.</p>
			<p>A) One of the biggest issues is the structure of our code. As we learn more C++, we will also learn ways to make the code more manageable and generally less lengthy. We will do so in the next project and the final project too. By the end of this book, you will know about a number of strategies that you can use to manage your code.</p>
			<p>Q) The sound effects seem a bit flat and unrealistic. How can they be improved?</p>
			<p>A) One way to significantly improve the feeling the player gets from sound is to make the sound directional, as well as changing the volume based on the distance of the sound source to the player character. We will use SFML's advanced sound features in the next project.</p>
		</div>
	</body></html>