- en: '*Chapter 5*: Collisions, Sound, and End Conditions – Making the Game Playable'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the final phase of the first project. By the end of this chapter, you
    will have your first completed game. Once you have Timber!!! up and running, be
    sure to read the last section of this chapter as it will suggest ways to make
    the game better.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the rest of the sprites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling the player input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating the flying log
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling death
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding sound effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding features and improving Timber!!!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing the player (and other sprites)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's add the code for the player's sprite as well as a few more sprites and
    textures at the same time. The following, quite large, block of code also adds
    a gravestone sprite for when the player gets squashed, an axe sprite to chop with,
    and a log sprite that can whiz away each time the player chops.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that, after the `spritePlayer` object, we declare a `side` variable,
    `playerSide`, to keep track of where the player is currently standing. Furthermore,
    we add some extra variables for the `spriteLog` object, including `logSpeedX`,
    `logSpeedY`, and `logActive`, to store how fast the log will move and whether
    it is currently moving. The `spriteAxe` also has two related `float` constant
    variables to remember where the ideal pixel position is on both the left and the
    right.
  prefs: []
  type: TYPE_NORMAL
- en: Add the following block of code just before the `while(window.isOpen())` code,
    like we have done so often before. Note that all of the code in the following
    block is new, not just the highlighted code. I haven't provided any extra context
    for this block of code as the `while(window.isOpen())` should be easy to identify.
    The highlighted code is the code we have just discussed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the entirety of the following code, just before the `while(window.isOpen())`
    line, and make a mental note of the highlighted lines we briefly discussed. It
    will make the rest of this chapter''s code easier to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we added quite a few new variables. They are hard to
    explain in full until we get to where we actually use them, but here is an overview
    of what they will be used for. There is a variable of the `side` enumeration type
    called `playerSide` that is initialized to `left`. This will track which side
    of the tree the player is on.
  prefs: []
  type: TYPE_NORMAL
- en: There are two `const float` values that determine the horizontal position the
    axe will be drawn at, depending on whether the player is on the left-or right-hand
    side of the tree.
  prefs: []
  type: TYPE_NORMAL
- en: There are also three variables to help to keep control of the log as it is chopped
    and flies off of the tree, `bool` to determine whether the log is in motion (`logActive`)
    and two `float` values to hold the horizontal and vertical speeds of the log.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can draw all of our new sprites.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the player and other sprites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we add the code to move the player and use all of our new sprites, let's
    draw them. We are doing it this way so that as we add code to update/change/move
    them, we will be able to see what is happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following highlighted code to draw the four new sprites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code passes our four new sprites, one after the other, to the
    `draw` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the game and you will see our new sprites in the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14278_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We are really close to a working game now. The next task is to write some code
    to allow the player to control what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the player's input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A few different things depend on the movement of the player, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When to show the axe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to begin animating the log
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to move all of the branches down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, it makes sense to set up keyboard handling for the player who's chopping.
    Once this is done, we can put all of the features we just mentioned into the same
    part of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's think for a moment about how we detect keyboard presses. Each frame, we
    test whether a particular keyboard key is currently being held down. If it is,
    we take action. If the *Esc* key is being held down, we quit the game, and if
    the *Enter* key is being held down, we restart the game. So far, this has been
    sufficient for our needs.
  prefs: []
  type: TYPE_NORMAL
- en: There is, however, a problem with this approach when we try and handle the chopping
    of the tree. The problem has always been there; it just didn't matter until now.
    Depending on how powerful your PC is, the game loop could be executing thousands
    of times per second. Each and every pass through the game loop that a key is held
    down, it is detected, and the related code will execute.
  prefs: []
  type: TYPE_NORMAL
- en: So, actually, every time you press *Enter* to restart the game, you are most
    likely restarting it well in excess of a hundred times. This is because even the
    briefest of presses will last a significant fraction of a second. You can verify
    this by running the game and holding down the *Enter* key. Note that the time-bar
    doesn't move. This is because the game is being restarted over and over again,
    hundreds or even thousands of times a second.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we don''t use a different approach for the player chopping, then just one
    attempted chop will bring the entire tree down in a mere fraction of a second.
    We need to be a bit more sophisticated. What we will do is allow the player to
    chop, and then when they do so, disable the code that detects a key press. We
    will then detect when the player removes their finger from a key and then reenable
    the detection of key presses. Here are the steps laid out clearly:'
  prefs: []
  type: TYPE_NORMAL
- en: Wait for the player to use the left or right arrow keys to chop a log.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the player chops, disable key press detection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for the player to remove their finger from a key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reenable chop detection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat from step 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This might sound complicated but, with SFML's help, this will be straightforward.
    Let's implement this now, one step at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following highlighted line of code, which declares a `bool` variable
    called `acceptInput`, which will be used to determine when to listen for chops
    and when to ignore them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our Boolean set up, we can move on to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Handling setting up a new game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So that we''re ready to handle chops, add the following highlighted code to
    the `if` block that starts a new game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we are using a `for` loop to prepare the tree with no
    branches. This is fair to the player because, if the game started with a branch
    right above their head, it would be considered unsporting. Then, we simply move
    the gravestone off of the screen and the player into their starting location on
    the left. The last thing the preceding code does is set `acceptInput` to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to receive chopping key presses.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the player chopping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we can handle the left and right cursor key presses. Add this simple `if`
    block, which only executes when `acceptInput` is `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, inside the `if` block that we just coded, add the following highlighted
    code to handle what happens when the player presses the right cursor key on the
    keyboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Quite a bit is happening in that preceding code, so let''s go through it:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we detect whether the player has chopped on the right-hand side of the
    tree. If they have, then we set `playerSide` to `side::RIGHT`. We will respond
    to the value of `playerSide` later in the code. Then, we add one to the score
    with `score ++`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next line of code is slightly mysterious, but all that is happening is we
    are adding to the amount of time remaining. We are rewarding the player for taking
    action. The problem for the player, however, is that the higher the score gets,
    the less additional time is added on. You can play with this formula to make the
    game easier or harder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, the axe is moved into its right-hand-side position with `spriteAxe.setPosition`
    and the player sprite is moved into its right-hand-position as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we call `updateBranches` to move all the branches down one place and spawn
    a new random branch (or space) at the top of the tree.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, `spriteLog` is moved into its starting position, camouflaged against the
    tree, and its `speedX` variable is set to a negative number so that it whizzes
    off to the left. Also, `logActive` is set to `true` so that the log moving code
    that we will write soon animates the log each frame.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, `acceptInput` is set to `false`. At this point, no more chops can be
    made by the player. We have solved the problem of the presses being detected too
    frequently, and we will see how we can reenable chopping soon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, still inside the `if(acceptInput)` block that we just coded, add the following
    highlighted code to handle what happens when the player presses the left cursor
    key on the keyboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The previous code is just the same as the code that handles the right-hand-side
    chop, except that the sprites are positioned differently and the `logSpeedX` variable
    is set to a positive value so that the log whizzes to the right.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can code what happens when a keyboard key is released.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting a key being released
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make the preceding code work beyond the first chop, we need to detect when
    the player releases a key and then set `acceptInput` back to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: This is slightly different to the key handling we have seen so far. SFML has
    two different ways of detecting keyboard input from the player. We have already
    seen the first way when we handled the *Enter* key, and it is dynamic and instantaneous,
    which is exactly what we need to respond immediately to a key press.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code uses the method of detecting when a key is released. Enter
    the following highlighted code at the top of the `Handle the players input` section
    and then we will go through it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we declare an object of the `Event` type called `event`.
    Then, we call the `window.pollEvent` function, passing in our new object, `event`.
    The `pollEvent` function puts data into the `event` object that describes an operating
    system event. This could be a key press, key release, mouse movement, mouse click,
    game controller action, or something that happened to the window itself (resized,
    moved, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: The reason that we wrap our code in a `while` loop is because there might be
    many events stored in a queue. The `window.pollEvent` function will load them,
    one at a time, into `event`. With each pass through the loop, we will see whether
    we are interested in the current event and respond if we are. When `window.pollEvent`
    returns `false`, that means there are no more events in the queue and the `while`
    loop will exit.
  prefs: []
  type: TYPE_NORMAL
- en: This `if` condition `(event.type == Event::KeyReleased && !paused)` executes
    when both a key has been released and the game is not paused.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `if` block, we set `acceptInput` back to `true` and hide the axe
    sprite off screen.
  prefs: []
  type: TYPE_NORMAL
- en: You can now run the game and gaze in awe at the moving tree, swinging axe, and
    animated player. It won't, however, squash the player, and the log doesn't move
    yet when chopped.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to making the log move.
  prefs: []
  type: TYPE_NORMAL
- en: Animating the chopped logs and the axe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the player chops, `logActive` is set to `true`, so we can wrap some code
    in a block that only executes when `logActive` is `true`. Furthermore, each chop
    sets `logSpeedX` to either a positive or negative number, so the log is ready
    to start flying away from the tree in the correct direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following highlighted code right after where we update the branch sprites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The code sets the position of the sprite by getting its current horizontal and
    vertical location with `getPosition` and then adding to it using `logSpeedX` and
    `logSpeedY`, respectively, multiplied by `dt.asSeconds`.
  prefs: []
  type: TYPE_NORMAL
- en: After the log sprite has been moved each frame, the code uses an `if` block
    to see whether the sprite has disappeared out of view on either the left or the
    right. If it has, the log is moved back to its starting point, ready for the next
    chop.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the game now, you will be able to see the log flying off to the
    appropriate side of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14278_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's move on to a more sensitive subject.
  prefs: []
  type: TYPE_NORMAL
- en: Handling death
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every game must end badly with either the player running out of time (which
    we have already handled) or getting squashed by a branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Detecting the player getting squashed is really simple. All we want to know
    is: does the last branch in the `branchPositions` array equal `playerSide`? If
    it does, the player is dead.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following highlighted code that detects and executes when the player
    is squashed by a branch. We will talk about it later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first thing the preceding code does, after the player's demise, is set `paused`
    to `true`. Now, the loop will complete this frame and won't run the update part
    of the loop again until a new game is started by the player.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we move the gravestone into position, near where the player was standing,
    and hide the player sprite off screen.
  prefs: []
  type: TYPE_NORMAL
- en: We set the String of `messageText` to `"Squished!!"` and then use the usual
    technique to center it on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now run the game and play it for real. The following screenshot shows
    the player''s final score and their gravestone, as well as the **SQUISHED** message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14278_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There is just one more problem to deal with. Is it just me, or is it a little
    bit quiet?
  prefs: []
  type: TYPE_NORMAL
- en: Simple sound FX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will add three sounds. Each sound will be played on a particular
    game event, that is, a simple thud sound whenever the player chops, a gloomy losing
    sound when the player runs out of time, and a retro crushing sound when the player
    is squashed to death.
  prefs: []
  type: TYPE_NORMAL
- en: How SFML sound works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SFML plays sound effects using two different classes. The first class is the
    `SoundBuffer` class. This is the class that holds the actual audio data from the
    sound file. It is `SoundBuffer` that is responsible for loading the `.wav` files
    into the PC's RAM in a format that can be played without any further decoding
    work.
  prefs: []
  type: TYPE_NORMAL
- en: When we write code for the sound effects in a minute, we will see that, once
    we have a `SoundBuffer` object with our sound stored in it, we will then create
    another object of the `Sound` type. We can then associate this `Sound` object
    with a `SoundBuffer` object. Then, at the appropriate moment in our code, we will
    be able to call the `play` function of the appropriate `Sound` object.
  prefs: []
  type: TYPE_NORMAL
- en: When to play the sounds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we will see very soon, the C++ code to load and play sounds is really simple.
    What we need to consider, however, is *when* we call the `play` function, where
    in our code will we put the function calls to `play`? Let''s see:'
  prefs: []
  type: TYPE_NORMAL
- en: The chop sound can be called from the key presses of the left and right cursor
    keys.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The death sound can be played from the `if` block that detects that a tree has
    mangled the player.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The out of time sound can be played from the `if` block which detects whether
    `timeRemaining` is less than zero.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we can write our sound code.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the sound code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will add another `#include` directive to make the SFML sound-related
    classes available. Add the following highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will declare three different `SoundBuffer` objects, load three different
    sound files into them, and associate three different objects of the `Sound` type
    with the related objects of the `SoundBuffer` type. Add the following highlighted
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can play our first sound effect. Add the following single line of code
    to the `if` block, which detects that the player has pressed the right cursor
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Add exactly the same code at the end of the next block of code that starts with
    `if (Keyboard::isKeyPressed(Keyboard::Left))` to make a chopping sound when the
    player chops on the left-hand side of the tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the code that deals with the player running out of time and add the following
    highlighted code to play the out of time-related sound effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to play the death sound when the player is squished, add the following
    highlighted code to the `if` block, which executes when the bottom branch is on
    the same side as the player:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: That's it! We have finished the first game. Let's discuss some possible enhancements
    before we move on to the second project.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the game and the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take a look at these suggested enhancements for the Timber!!! project. You
    can see the enhancements in action in the `Runnable` folder of the download bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sstream` code in a block that only executes occasionally. After all, we don''t
    need to update the score thousands of times a second!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Debugging console:** Let''s add some more text so that we can see the current
    frame rate. Like the score, we don''t need to update this too often. Once every
    hundred frames will do.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Add more trees to the background:** Simply add some more tree sprites and
    draw them in whatever position looks good (some nearer the camera and some further
    away).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RectangleShape` objects behind the score and the FPS counter. Black with a
    bit of transparency will look quite good.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Make the cloud code more efficient:** As we alluded to a few times already,
    we can use our knowledge of arrays to make the cloud code a lot shorter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the game in action with extra trees, clouds, and a transparent
    background for the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14278_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To see the code for these enhancements, take a look in the `Timber Enhanced
    Version` folder of the download bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we added the finishing touches and graphics to the Timber!!!
    game. If, prior to this book, you had never coded a single line of C++, then you
    can give yourself a big pat on the back. In just five modest chapters, you have
    gone from zero knowledge to a working game.
  prefs: []
  type: TYPE_NORMAL
- en: However, we will not be congratulating ourselves for too long because, in the
    next chapter, we will move straight on to some slightly more hardcore C++. While
    the next game, a simple Pong game, in some ways is simpler than Timber!!, learning
    about writing our own classes will prepare us for building more complicated and
    fuller-featured games.
  prefs: []
  type: TYPE_NORMAL
- en: FAQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q) I admit that the arrays solution for the clouds was more efficient. But do
    we really need three separate arrays—one for active, one for speed, and one for
    the sprite itself?
  prefs: []
  type: TYPE_NORMAL
- en: A) If we look at the properties/variables that various objects have, for example,
    `Sprite` objects, we will see they are numerous. Sprites have position, color,
    size, rotation, and more as well. But it would be just perfect if they had `active`,
    `speed`, and perhaps some more. The problem is that the coders at SFML can't possibly
    predict all of the ways that we will want to use their `Sprite` class. Fortunately,
    we can make our own classes. We could make a class called `Cloud` that has a Boolean
    for `active` and `int` for speed. We can even give our `Cloud` class an SFML `Sprite`
    object. We could then simplify our cloud code even further. We will look at designing
    our own classes in the next chapter.
  prefs: []
  type: TYPE_NORMAL
