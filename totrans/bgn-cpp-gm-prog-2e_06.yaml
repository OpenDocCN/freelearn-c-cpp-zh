- en: '*Chapter 5*: Collisions, Sound, and End Conditions – Making the Game Playable'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*：碰撞、音效和结束条件 – 使游戏可玩'
- en: This is the final phase of the first project. By the end of this chapter, you
    will have your first completed game. Once you have Timber!!! up and running, be
    sure to read the last section of this chapter as it will suggest ways to make
    the game better.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个项目的最后阶段。到本章结束时，你将拥有你的第一个完成的游戏。一旦你让 Timber!!! 运行起来，务必阅读本章的最后部分，因为它将建议如何使游戏变得更好。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Adding the rest of the sprites
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加其余的精灵
- en: Handling the player input
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理玩家输入
- en: Animating the flying log
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画飞行的木材
- en: Handling death
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理死亡
- en: Adding sound effects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加音效
- en: Adding features and improving Timber!!!
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加功能和改进 Timber!!!
- en: Preparing the player (and other sprites)
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备玩家（和其他精灵）
- en: Let's add the code for the player's sprite as well as a few more sprites and
    textures at the same time. The following, quite large, block of code also adds
    a gravestone sprite for when the player gets squashed, an axe sprite to chop with,
    and a log sprite that can whiz away each time the player chops.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们同时添加玩家精灵以及一些更多精灵和纹理的代码。以下相当大的代码块还添加了一个用于玩家被压扁时的墓碑精灵，一个用于砍伐的斧头精灵，以及一个每次玩家砍伐时都会飞走的木材精灵。
- en: Notice that, after the `spritePlayer` object, we declare a `side` variable,
    `playerSide`, to keep track of where the player is currently standing. Furthermore,
    we add some extra variables for the `spriteLog` object, including `logSpeedX`,
    `logSpeedY`, and `logActive`, to store how fast the log will move and whether
    it is currently moving. The `spriteAxe` also has two related `float` constant
    variables to remember where the ideal pixel position is on both the left and the
    right.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 `spritePlayer` 对象之后，我们声明了一个 `side` 变量，`playerSide`，以跟踪玩家当前站立的位置。此外，我们还为
    `spriteLog` 对象添加了一些额外的变量，包括 `logSpeedX`、`logSpeedY` 和 `logActive`，以存储木材的移动速度以及它是否正在移动。`spriteAxe`
    还有两个相关的 `float` 常量变量，用于记住左右两侧理想的像素位置。
- en: Add the following block of code just before the `while(window.isOpen())` code,
    like we have done so often before. Note that all of the code in the following
    block is new, not just the highlighted code. I haven't provided any extra context
    for this block of code as the `while(window.isOpen())` should be easy to identify.
    The highlighted code is the code we have just discussed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `while(window.isOpen())` 代码之前添加以下代码块，就像我们之前经常做的那样。请注意，以下代码块中的所有代码都是新的，而不仅仅是突出显示的代码。我没有为这个代码块提供任何额外的上下文，因为
    `while(window.isOpen())` 应该很容易识别。突出显示的代码是我们刚刚讨论过的代码。
- en: 'Add the entirety of the following code, just before the `while(window.isOpen())`
    line, and make a mental note of the highlighted lines we briefly discussed. It
    will make the rest of this chapter''s code easier to understand:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `while(window.isOpen())` 行之前添加以下代码的全部内容，并在心中记住我们简要讨论过的突出显示的行。这将使本章其余的代码更容易理解：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, we added quite a few new variables. They are hard to
    explain in full until we get to where we actually use them, but here is an overview
    of what they will be used for. There is a variable of the `side` enumeration type
    called `playerSide` that is initialized to `left`. This will track which side
    of the tree the player is on.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了许多新的变量。在真正使用它们之前，很难完全解释它们，但这里简要概述一下它们将用于什么。有一个名为 `playerSide` 的
    `side` 枚举类型变量，初始化为 `left`。这将跟踪玩家位于树的哪一侧。
- en: There are two `const float` values that determine the horizontal position the
    axe will be drawn at, depending on whether the player is on the left-or right-hand
    side of the tree.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个 `const float` 类型的值用于确定斧头将被绘制在水平位置，这取决于玩家是否位于树的左侧或右侧。
- en: There are also three variables to help to keep control of the log as it is chopped
    and flies off of the tree, `bool` to determine whether the log is in motion (`logActive`)
    and two `float` values to hold the horizontal and vertical speeds of the log.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 除了帮助控制被砍伐并飞离树木的木材外，还有三个变量，`bool` 类型的 `logActive` 用于确定木材是否在运动，以及两个 `float` 类型的值用于存储木材的水平速度和垂直速度。
- en: Now, we can draw all of our new sprites.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以绘制所有新的精灵。
- en: Drawing the player and other sprites
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制玩家和其他精灵
- en: Before we add the code to move the player and use all of our new sprites, let's
    draw them. We are doing it this way so that as we add code to update/change/move
    them, we will be able to see what is happening.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加移动玩家和使用所有新精灵的代码之前，让我们先绘制它们。我们这样做是为了当我们添加代码来更新/更改/移动它们时，我们能够看到正在发生的事情。
- en: 'Add the following highlighted code to draw the four new sprites:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下突出显示的代码以绘制四个新的精灵：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code passes our four new sprites, one after the other, to the
    `draw` function.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将四个新精灵依次传递给`draw`函数。
- en: 'Run the game and you will see our new sprites in the scene:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏，你将看到场景中的新精灵：
- en: '![](img/B14278_05_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14278_05_01.jpg)'
- en: We are really close to a working game now. The next task is to write some code
    to allow the player to control what happens.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在离一个可工作的游戏非常近了。下一个任务是编写一些代码，让玩家能够控制发生的事情。
- en: Handling the player's input
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理玩家的输入
- en: 'A few different things depend on the movement of the player, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家的移动会影响几个不同的事情，如下所示：
- en: When to show the axe
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时显示斧头
- en: When to begin animating the log
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时开始动画木头
- en: When to move all of the branches down
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时移动所有树枝向下
- en: Therefore, it makes sense to set up keyboard handling for the player who's chopping.
    Once this is done, we can put all of the features we just mentioned into the same
    part of the code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为正在砍伐的玩家设置键盘处理是有意义的。一旦完成这项工作，我们就可以将我们刚才提到的所有功能放入代码的同一部分。
- en: Let's think for a moment about how we detect keyboard presses. Each frame, we
    test whether a particular keyboard key is currently being held down. If it is,
    we take action. If the *Esc* key is being held down, we quit the game, and if
    the *Enter* key is being held down, we restart the game. So far, this has been
    sufficient for our needs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时思考一下我们是如何检测键盘按键的。每一帧，我们都会测试是否有特定的键盘键被按下。如果是，我们就采取行动。如果*Esc*键被按下，我们就退出游戏，如果*Enter*键被按下，我们就重新开始游戏。到目前为止，这已经足够满足我们的需求了。
- en: There is, however, a problem with this approach when we try and handle the chopping
    of the tree. The problem has always been there; it just didn't matter until now.
    Depending on how powerful your PC is, the game loop could be executing thousands
    of times per second. Each and every pass through the game loop that a key is held
    down, it is detected, and the related code will execute.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们尝试处理树木的砍伐时，这种方法存在一个问题。这个问题一直存在；只是直到现在才变得重要。根据你的PC性能如何，游戏循环每秒可能执行数千次。每次通过游戏循环，只要按键被按下，就会检测到，并执行相关代码。
- en: So, actually, every time you press *Enter* to restart the game, you are most
    likely restarting it well in excess of a hundred times. This is because even the
    briefest of presses will last a significant fraction of a second. You can verify
    this by running the game and holding down the *Enter* key. Note that the time-bar
    doesn't move. This is because the game is being restarted over and over again,
    hundreds or even thousands of times a second.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，实际上，每次你按下*Enter*键重新开始游戏，你很可能已经重新开始了一百多次以上。这是因为即使是最短暂的按键也会持续一秒钟的很大一部分。你可以通过运行游戏并按住*Enter*键来验证这一点。请注意，时间条不会移动。这是因为游戏正在一次又一次地重新开始，每秒数百次甚至数千次。
- en: 'If we don''t use a different approach for the player chopping, then just one
    attempted chop will bring the entire tree down in a mere fraction of a second.
    We need to be a bit more sophisticated. What we will do is allow the player to
    chop, and then when they do so, disable the code that detects a key press. We
    will then detect when the player removes their finger from a key and then reenable
    the detection of key presses. Here are the steps laid out clearly:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不使用不同的方法来处理玩家的砍伐，那么仅仅一次尝试砍伐就会在短短的一瞬间将整棵树砍倒。我们需要更加复杂一些。我们将允许玩家砍伐，然后当玩家这样做时，禁用检测按键的代码。然后我们将检测玩家何时从按键上移开手指，然后重新启用按键检测。以下是将这些步骤清晰地列出的步骤：
- en: Wait for the player to use the left or right arrow keys to chop a log.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待玩家使用左右箭头键砍伐一根木头。
- en: When the player chops, disable key press detection.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当玩家砍伐时，禁用按键检测。
- en: Wait for the player to remove their finger from a key.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待玩家从按键上移开手指。
- en: Reenable chop detection.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启用砍伐检测。
- en: Repeat from step 1.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从步骤1重复。
- en: This might sound complicated but, with SFML's help, this will be straightforward.
    Let's implement this now, one step at a time.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来很复杂，但有了SFML的帮助，这将变得简单直接。让我们现在一步一步地实现它。
- en: 'Add the following highlighted line of code, which declares a `bool` variable
    called `acceptInput`, which will be used to determine when to listen for chops
    and when to ignore them:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下突出显示的代码行，它声明了一个名为`acceptInput`的`bool`变量，该变量将用于确定何时监听砍伐，何时忽略它们：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that we have our Boolean set up, we can move on to the next step.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了布尔值，我们可以继续下一步。
- en: Handling setting up a new game
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理设置新游戏
- en: 'So that we''re ready to handle chops, add the following highlighted code to
    the `if` block that starts a new game:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备好处理砍伐，将以下突出显示的代码添加到开始新游戏的`if`块中：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the previous code, we are using a `for` loop to prepare the tree with no
    branches. This is fair to the player because, if the game started with a branch
    right above their head, it would be considered unsporting. Then, we simply move
    the gravestone off of the screen and the player into their starting location on
    the left. The last thing the preceding code does is set `acceptInput` to `true`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们使用一个`for`循环来准备没有分支的树。这对玩家是公平的，因为如果游戏从他们头顶上方的一个分支开始，那将被视为不公平。然后，我们简单地将墓碑移出屏幕，并将玩家移动到左侧的起始位置。前述代码所做的最后一件事是将`acceptInput`设置为`true`。
- en: We are now ready to receive chopping key presses.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好接收砍伐按键。
- en: Detecting the player chopping
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测玩家砍伐
- en: 'Now, we can handle the left and right cursor key presses. Add this simple `if`
    block, which only executes when `acceptInput` is `true`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以处理左右光标键的按下。添加以下简单的`if`块，它仅在`acceptInput`为`true`时执行：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, inside the `if` block that we just coded, add the following highlighted
    code to handle what happens when the player presses the right cursor key on the
    keyboard:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在刚刚编写的`if`块内部，添加以下突出显示的代码来处理当玩家按下键盘上的右光标键时会发生什么：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Quite a bit is happening in that preceding code, so let''s go through it:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述代码中发生了很多事情，让我们逐一分析：
- en: First, we detect whether the player has chopped on the right-hand side of the
    tree. If they have, then we set `playerSide` to `side::RIGHT`. We will respond
    to the value of `playerSide` later in the code. Then, we add one to the score
    with `score ++`.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们检测玩家是否在树的右侧进行了砍伐。如果是，则将`playerSide`设置为`side::RIGHT`。我们将在代码的后续部分响应`playerSide`的值。然后，使用`score
    ++`给分数加一分。
- en: The next line of code is slightly mysterious, but all that is happening is we
    are adding to the amount of time remaining. We are rewarding the player for taking
    action. The problem for the player, however, is that the higher the score gets,
    the less additional time is added on. You can play with this formula to make the
    game easier or harder.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一行代码有点神秘，但所发生的一切只是我们在剩余时间上增加。我们在奖励玩家采取行动。然而，对玩家来说，分数越高，额外增加的时间就越少。你可以调整这个公式来使游戏更容易或更难。
- en: Then, the axe is moved into its right-hand-side position with `spriteAxe.setPosition`
    and the player sprite is moved into its right-hand-position as well.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，使用`spriteAxe.setPosition`将斧头移动到其右侧位置，并将玩家精灵也移动到其右侧位置。
- en: Next, we call `updateBranches` to move all the branches down one place and spawn
    a new random branch (or space) at the top of the tree.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们调用`updateBranches`来将所有分支向下移动一个位置，并在树的顶部生成一个新的随机分支（或空间）。
- en: Then, `spriteLog` is moved into its starting position, camouflaged against the
    tree, and its `speedX` variable is set to a negative number so that it whizzes
    off to the left. Also, `logActive` is set to `true` so that the log moving code
    that we will write soon animates the log each frame.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，将`spriteLog`移动到其起始位置，使其与树木融为一体，并将其`speedX`变量设置为负数，以便它向左飞驰。同时，将`logActive`设置为`true`，以便我们即将编写的移动木头的代码在每一帧中动画化木头。
- en: Finally, `acceptInput` is set to `false`. At this point, no more chops can be
    made by the player. We have solved the problem of the presses being detected too
    frequently, and we will see how we can reenable chopping soon.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，将`acceptInput`设置为`false`。此时，玩家不能再进行砍伐。我们已经解决了按键检测过于频繁的问题，我们很快将看到如何重新启用砍伐。
- en: 'Now, still inside the `if(acceptInput)` block that we just coded, add the following
    highlighted code to handle what happens when the player presses the left cursor
    key on the keyboard:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，仍然在刚刚编写的`if(acceptInput)`块内部，添加以下突出显示的代码来处理当玩家按下键盘上的左光标键时会发生什么：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The previous code is just the same as the code that handles the right-hand-side
    chop, except that the sprites are positioned differently and the `logSpeedX` variable
    is set to a positive value so that the log whizzes to the right.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码与处理右侧切割的代码相同，只是精灵的位置不同，并且将`logSpeedX`变量设置为正值，这样木材就会向右飞去。
- en: Now, we can code what happens when a keyboard key is released.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写当键盘按键释放时发生的事情的代码。
- en: Detecting a key being released
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测按键释放
- en: To make the preceding code work beyond the first chop, we need to detect when
    the player releases a key and then set `acceptInput` back to `true`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要使前面的代码在第一次切割之后仍然有效，我们需要检测玩家何时释放按键，然后将`acceptInput`重置为`true`。
- en: This is slightly different to the key handling we have seen so far. SFML has
    two different ways of detecting keyboard input from the player. We have already
    seen the first way when we handled the *Enter* key, and it is dynamic and instantaneous,
    which is exactly what we need to respond immediately to a key press.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前我们看到的关键字处理方式略有不同。SFML有两种不同的方式来检测玩家的键盘输入。我们已经在前处理*Enter*键时看到了第一种方式，它是动态的和即时的，这正是我们立即对按键做出响应所需要的。
- en: 'The following code uses the method of detecting when a key is released. Enter
    the following highlighted code at the top of the `Handle the players input` section
    and then we will go through it:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用检测按键释放的方法。在`Handle the players input`部分的顶部输入以下高亮代码，然后我们将对其进行讲解：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we declare an object of the `Event` type called `event`.
    Then, we call the `window.pollEvent` function, passing in our new object, `event`.
    The `pollEvent` function puts data into the `event` object that describes an operating
    system event. This could be a key press, key release, mouse movement, mouse click,
    game controller action, or something that happened to the window itself (resized,
    moved, and so on).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了一个名为`event`的`Event`类型对象。然后，我们调用`window.pollEvent`函数，传入我们新创建的对象`event`。`pollEvent`函数将描述操作系统事件的
    数据放入`event`对象中。这可能是按键、按键释放、鼠标移动、鼠标点击、游戏控制器动作，或者是窗口本身发生的事情（如大小调整、移动等）。
- en: The reason that we wrap our code in a `while` loop is because there might be
    many events stored in a queue. The `window.pollEvent` function will load them,
    one at a time, into `event`. With each pass through the loop, we will see whether
    we are interested in the current event and respond if we are. When `window.pollEvent`
    returns `false`, that means there are no more events in the queue and the `while`
    loop will exit.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将代码包裹在`while`循环中的原因是因为队列中可能存储了多个事件。`window.pollEvent`函数会逐个将它们加载到`event`中。随着每次循环的进行，我们会检查是否对当前事件感兴趣，并在感兴趣时做出响应。当`window.pollEvent`返回`false`时，这意味着队列中没有更多事件，`while`循环将退出。
- en: This `if` condition `(event.type == Event::KeyReleased && !paused)` executes
    when both a key has been released and the game is not paused.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个键被释放且游戏未暂停时，执行此`if`条件`(event.type == Event::KeyReleased && !paused)`。
- en: Inside the `if` block, we set `acceptInput` back to `true` and hide the axe
    sprite off screen.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`块内部，我们将`acceptInput`重置为`true`，并将斧头精灵隐藏到屏幕之外。
- en: You can now run the game and gaze in awe at the moving tree, swinging axe, and
    animated player. It won't, however, squash the player, and the log doesn't move
    yet when chopped.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以运行游戏，并敬畏地注视着移动的树木、挥舞的斧头和动画化的玩家。然而，它不会压扁玩家，而且当切割时，木材还没有移动。
- en: Let's move on to making the log move.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续制作日志移动效果。
- en: Animating the chopped logs and the axe
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画切割的木材和斧头
- en: When the player chops, `logActive` is set to `true`, so we can wrap some code
    in a block that only executes when `logActive` is `true`. Furthermore, each chop
    sets `logSpeedX` to either a positive or negative number, so the log is ready
    to start flying away from the tree in the correct direction.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家切割时，`logActive`被设置为`true`，因此我们可以将一些代码包裹在一个只有当`logActive`为`true`时才执行的代码块中。此外，每次切割都会将`logSpeedX`设置为正数或负数，这样木材就可以在正确的方向上开始从树木飞离。
- en: 'Add the following highlighted code right after where we update the branch sprites:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新分支精灵之后，添加以下高亮代码：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The code sets the position of the sprite by getting its current horizontal and
    vertical location with `getPosition` and then adding to it using `logSpeedX` and
    `logSpeedY`, respectively, multiplied by `dt.asSeconds`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 代码通过使用`getPosition`获取精灵的当前水平和垂直位置，然后分别使用`logSpeedX`和`logSpeedY`以及`dt.asSeconds`的乘积来添加，从而设置精灵的位置。
- en: After the log sprite has been moved each frame, the code uses an `if` block
    to see whether the sprite has disappeared out of view on either the left or the
    right. If it has, the log is moved back to its starting point, ready for the next
    chop.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个帧移动日志精灵之后，代码使用一个`if`块来检查精灵是否已经从左侧或右侧消失在视野之外。如果是这样，日志就会移回到起始点，为下一次切割做好准备。
- en: 'If you run the game now, you will be able to see the log flying off to the
    appropriate side of the screen:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行游戏，你将能够看到日志飞向屏幕的适当一侧：
- en: '![](img/B14278_05_02.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_05_02.jpg)'
- en: Now, let's move on to a more sensitive subject.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向一个更敏感的话题。
- en: Handling death
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理死亡
- en: Every game must end badly with either the player running out of time (which
    we have already handled) or getting squashed by a branch.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每个游戏都必须以糟糕的方式结束，要么是玩家用完时间（这我们已经处理过了），要么是被树枝压扁。
- en: 'Detecting the player getting squashed is really simple. All we want to know
    is: does the last branch in the `branchPositions` array equal `playerSide`? If
    it does, the player is dead.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 检测玩家被压扁非常简单。我们只想知道：`branchPositions`数组中的最后一个树枝位置是否等于`playerSide`？如果是，玩家就死了。
- en: 'Add the following highlighted code that detects and executes when the player
    is squashed by a branch. We will talk about it later:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下高亮代码，用于检测和执行玩家被树枝压扁的情况。我们稍后会讨论它：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first thing the preceding code does, after the player's demise, is set `paused`
    to `true`. Now, the loop will complete this frame and won't run the update part
    of the loop again until a new game is started by the player.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩家死亡之后，前面的代码首先将`paused`设置为`true`。现在，循环将完成这一帧，并且不会再次运行循环的更新部分，直到玩家开始新的一局。
- en: Then, we move the gravestone into position, near where the player was standing,
    and hide the player sprite off screen.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将墓碑移动到位置，靠近玩家曾经站立的地方，并将玩家精灵隐藏在屏幕之外。
- en: We set the String of `messageText` to `"Squished!!"` and then use the usual
    technique to center it on the screen.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`messageText`字符串设置为`"Squished!!"`，然后使用常规技术将其居中显示在屏幕上。
- en: 'You can now run the game and play it for real. The following screenshot shows
    the player''s final score and their gravestone, as well as the **SQUISHED** message:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以运行游戏并真正地玩一玩。以下截图显示了玩家的最终得分和他们的墓碑，以及**SQUISHED**信息：
- en: '![](img/B14278_05_03.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_05_03.jpg)'
- en: There is just one more problem to deal with. Is it just me, or is it a little
    bit quiet?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个问题需要解决。是我一个人这样觉得吗，还是它有点安静？
- en: Simple sound FX
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的声音效果
- en: In this section, we will add three sounds. Each sound will be played on a particular
    game event, that is, a simple thud sound whenever the player chops, a gloomy losing
    sound when the player runs out of time, and a retro crushing sound when the player
    is squashed to death.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将添加三个声音。每个声音将在特定的游戏事件上播放，即玩家每次切割时发出简单的砰砰声，玩家用完时间时发出忧郁的失败声，以及玩家被压扁至死时的复古压碎声。
- en: How SFML sound works
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SFML声音是如何工作的
- en: SFML plays sound effects using two different classes. The first class is the
    `SoundBuffer` class. This is the class that holds the actual audio data from the
    sound file. It is `SoundBuffer` that is responsible for loading the `.wav` files
    into the PC's RAM in a format that can be played without any further decoding
    work.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: SFML使用两个不同的类来播放声音效果。第一个类是`SoundBuffer`类。这是一个包含实际音频数据的类，它负责将`.wav`文件加载到PC的RAM中，以可以播放的格式，无需进一步解码工作。
- en: When we write code for the sound effects in a minute, we will see that, once
    we have a `SoundBuffer` object with our sound stored in it, we will then create
    another object of the `Sound` type. We can then associate this `Sound` object
    with a `SoundBuffer` object. Then, at the appropriate moment in our code, we will
    be able to call the `play` function of the appropriate `Sound` object.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写下一分钟的声音效果代码时，我们会看到，一旦我们有一个存储了声音的`SoundBuffer`对象，我们就会创建另一个`Sound`类型的对象。然后，我们可以将这个`Sound`对象与`SoundBuffer`对象关联起来。然后，在代码的适当时刻，我们将能够调用相应`Sound`对象的`play`函数。
- en: When to play the sounds
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时播放声音
- en: 'As we will see very soon, the C++ code to load and play sounds is really simple.
    What we need to consider, however, is *when* we call the `play` function, where
    in our code will we put the function calls to `play`? Let''s see:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们很快就会看到的，加载和播放声音的C++代码非常简单。然而，我们需要考虑的是*何时*调用`play`函数，在哪里放置`play`函数的调用？让我们看看：
- en: The chop sound can be called from the key presses of the left and right cursor
    keys.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切割声音可以通过左右光标键的按键来调用。
- en: The death sound can be played from the `if` block that detects that a tree has
    mangled the player.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以从检测到树木弄伤玩家的 `if` 块中播放死亡声音。
- en: The out of time sound can be played from the `if` block which detects whether
    `timeRemaining` is less than zero.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以从检测 `timeRemaining` 小于零的 `if` 块中播放超时声音。
- en: Now, we can write our sound code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写我们的声音代码了。
- en: Adding the sound code
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加声音代码
- en: 'First, we will add another `#include` directive to make the SFML sound-related
    classes available. Add the following highlighted code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加另一个 `#include` 指令，以便使 SFML 声音相关类可用。添加以下突出显示的代码：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we will declare three different `SoundBuffer` objects, load three different
    sound files into them, and associate three different objects of the `Sound` type
    with the related objects of the `SoundBuffer` type. Add the following highlighted
    code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将声明三个不同的 `SoundBuffer` 对象，将三个不同的声音文件加载到它们中，并将三个不同的 `Sound` 类型的对象与相关的 `SoundBuffer`
    类型的对象关联起来。添加以下突出显示的代码：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we can play our first sound effect. Add the following single line of code
    to the `if` block, which detects that the player has pressed the right cursor
    key:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以播放第一个音效了。将以下单行代码添加到检测玩家按下右光标键的 `if` 块中：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Add exactly the same code at the end of the next block of code that starts with
    `if (Keyboard::isKeyPressed(Keyboard::Left))` to make a chopping sound when the
    player chops on the left-hand side of the tree.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在以 `if (Keyboard::isKeyPressed(Keyboard::Left))` 开头的下一块代码的末尾添加完全相同的代码，以便当玩家在树的左侧砍伐时发出砍伐声。
- en: 'Find the code that deals with the player running out of time and add the following
    highlighted code to play the out of time-related sound effect:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 找到处理玩家耗尽时间的代码，并将以下突出显示的代码添加到播放超时相关声音效果的代码中：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, to play the death sound when the player is squished, add the following
    highlighted code to the `if` block, which executes when the bottom branch is on
    the same side as the player:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当玩家被挤压时播放死亡声音，将以下突出显示的代码添加到执行时底部树枝与玩家在同一侧的 `if` 块中：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: That's it! We have finished the first game. Let's discuss some possible enhancements
    before we move on to the second project.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们完成了第一个游戏。在我们继续进行第二个项目之前，让我们讨论一些可能的改进。
- en: Improving the game and the code
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进游戏和代码
- en: 'Take a look at these suggested enhancements for the Timber!!! project. You
    can see the enhancements in action in the `Runnable` folder of the download bundle:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 查看这些针对 Timber!!! 项目的建议增强功能。你可以在下载包的 `Runnable` 文件夹中看到这些增强功能的效果：
- en: '`sstream` code in a block that only executes occasionally. After all, we don''t
    need to update the score thousands of times a second!'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在仅偶尔执行的代码块中的 `sstream` 代码。毕竟，我们不需要每秒更新分数数千次！
- en: '**Debugging console:** Let''s add some more text so that we can see the current
    frame rate. Like the score, we don''t need to update this too often. Once every
    hundred frames will do.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试控制台：** 让我们添加一些文本，以便我们可以看到当前的帧率。就像分数一样，我们不需要太频繁地更新它。每百帧更新一次即可。'
- en: '**Add more trees to the background:** Simply add some more tree sprites and
    draw them in whatever position looks good (some nearer the camera and some further
    away).'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在背景中添加更多树木：** 简单地添加一些更多的树木精灵，并将它们绘制在看起来好的位置（一些靠近相机，一些远离）。'
- en: '`RectangleShape` objects behind the score and the FPS counter. Black with a
    bit of transparency will look quite good.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在分数和 FPS 计数器后面的 `RectangleShape` 对象。黑色带有一点透明度看起来相当不错。
- en: '**Make the cloud code more efficient:** As we alluded to a few times already,
    we can use our knowledge of arrays to make the cloud code a lot shorter.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使云代码更高效：** 正如我们之前多次提到的，我们可以利用我们对数组的了解来使云代码变得更短。'
- en: 'Take a look at the game in action with extra trees, clouds, and a transparent
    background for the text:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 查看带有额外树木、云彩和透明背景文本的游戏动作：
- en: '![](img/B14278_05_04.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_05_04.jpg)'
- en: To see the code for these enhancements, take a look in the `Timber Enhanced
    Version` folder of the download bundle.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这些增强功能的代码，请查看下载包的 `Timber Enhanced Version` 文件夹。
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we added the finishing touches and graphics to the Timber!!!
    game. If, prior to this book, you had never coded a single line of C++, then you
    can give yourself a big pat on the back. In just five modest chapters, you have
    gone from zero knowledge to a working game.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为 Timber!!! 游戏添加了最后的修饰和图形。如果你在本书之前从未编写过任何 C++ 代码，那么你可以给自己一个大大的掌声。仅仅五章，你就从零知识到了一个可工作的游戏。
- en: However, we will not be congratulating ourselves for too long because, in the
    next chapter, we will move straight on to some slightly more hardcore C++. While
    the next game, a simple Pong game, in some ways is simpler than Timber!!, learning
    about writing our own classes will prepare us for building more complicated and
    fuller-featured games.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不会因此而过于自满，因为在下一章中，我们将直接进入一些稍微更复杂的 C++ 内容。虽然下一款游戏，一个简单的乒乓球游戏，在某些方面比 Timber!!
    简单，但了解如何编写自己的类将为我们构建更复杂和功能更齐全的游戏做好准备。
- en: FAQ
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题解答
- en: Q) I admit that the arrays solution for the clouds was more efficient. But do
    we really need three separate arrays—one for active, one for speed, and one for
    the sprite itself?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Q) 我承认对于云的数组解决方案更有效率。但我们真的需要三个独立的数组——一个用于 `active`，一个用于速度，以及一个用于精灵本身吗？
- en: A) If we look at the properties/variables that various objects have, for example,
    `Sprite` objects, we will see they are numerous. Sprites have position, color,
    size, rotation, and more as well. But it would be just perfect if they had `active`,
    `speed`, and perhaps some more. The problem is that the coders at SFML can't possibly
    predict all of the ways that we will want to use their `Sprite` class. Fortunately,
    we can make our own classes. We could make a class called `Cloud` that has a Boolean
    for `active` and `int` for speed. We can even give our `Cloud` class an SFML `Sprite`
    object. We could then simplify our cloud code even further. We will look at designing
    our own classes in the next chapter.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: A) 如果我们观察各种对象所具有的属性/变量，例如，`Sprite` 对象，我们会发现它们有很多。精灵具有位置、颜色、大小、旋转等属性。但如果它们有 `active`、`speed`
    以及可能的一些其他属性那就更完美了。问题是 SFML 的编码者不可能预测到我们会以所有可能的方式使用他们的 `Sprite` 类。幸运的是，我们可以创建自己的类。我们可以创建一个名为
    `Cloud` 的类，它有一个布尔值用于 `active` 和一个整型用于速度。我们甚至可以给我们的 `Cloud` 类一个 SFML `Sprite` 对象。这样我们甚至可以进一步简化我们的云代码。我们将在下一章中探讨如何设计自己的类。
