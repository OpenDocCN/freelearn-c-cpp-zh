- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Atypical Allocation Mechanisms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非典型分配机制
- en: We are progressing in our exploration of memory management with C++. In [*Chapter
    7*](B21071_07.xhtml#_idTextAnchor116), we explored the various syntactic ways
    in which one can overload `operator new()` and `operator delete()` (as well as
    their array counterparts), and in [*Chapter 8*](B21071_08.xhtml#_idTextAnchor128),
    we wrote an actual, real-life example (a memory leak detector) relying on the
    capacity to write such overloads. It’s a nice start, showing concretely that this
    knowledge has practical uses, but you might (rightfully) wonder what else we can
    do when controlling memory management facilities.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在使用 C++ 进行内存管理方面的探索中取得了进展。在[*第7章*](B21071_07.xhtml#_idTextAnchor116)中，我们探讨了可以通过哪些语法方式来重载
    `operator new()` 和 `operator delete()`（以及它们的数组对应物），而在[*第8章*](B21071_08.xhtml#_idTextAnchor128)中，我们编写了一个实际的真实例子（一个内存泄漏检测器），这个例子依赖于编写这样的重载的能力。这是一个很好的开始，具体地展示了这些知识有实际的应用，但你可能会（正确地）想知道在控制内存管理功能时我们还能做些什么。
- en: 'This chapter will be slightly different from the others. What we will do here
    is present a non-exhaustive set of ways in which one can benefit from taking control
    of the memory allocation functions of C++. More precisely, we will show the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将与其他章节略有不同。在这里，我们将展示一系列非详尽的方法，说明如何通过控制 C++ 的内存分配函数来受益。更确切地说，我们将展示以下内容：
- en: How placement `new` can let us drive memory-mapped hardware efficiently
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 placement `new` 高效地驱动内存映射硬件
- en: How one can simplify usage of error management with the `nothrow` version of
    `operator new()`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过 `operator new()` 的 `nothrow` 版本简化错误管理
- en: How one can install and use `std::new_handler` to make it easier to react to
    out-of-memory situations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装和使用 `std::new_handler` 来使处理内存不足情况变得更加容易
- en: How one can handle “exotic” memories such as shared memory or persistent memory
    through the mediation of standard C++
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过标准 C++ 的中介处理“奇特”的内存，如共享内存或持久内存
- en: At the end of this chapter, we will have a broader view of what opportunities
    the basic memory allocation facilities of C++ provide us with. Later chapters
    will return to more focused topics such as arena-based allocation ([*Chapter 10*](B21071_10.xhtml#_idTextAnchor153)),
    deferred reclamation ([*Chapter 11*](B21071_11.xhtml#_idTextAnchor163)), and,
    in later chapters, how to control memory allocation with containers and allocators.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将对 C++ 基本内存分配功能为我们提供的机遇有一个更广阔的视角。后续章节将回到更具体的话题，例如基于区域的分配([*第10章*](B21071_10.xhtml#_idTextAnchor153))、延迟回收([*第11章*](B21071_11.xhtml#_idTextAnchor163))，以及在后续章节中，如何使用容器和分配器来控制内存分配。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the code files for this chapter in the book’s GitHub repository
    here: [https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter9](https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter9).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的 GitHub 仓库中找到本章的代码文件：[https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter9](https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter9)。
- en: Placement new and memory-mapped hardware
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Placement new 和内存映射硬件
- en: There are many uses for placement `new` (an important feature discussed in [*Chapter
    7*](B21071_07.xhtml#_idTextAnchor116), as you might remember) but one use that
    is particularly interesting is that it allows us to map software objects to memory-mapped
    hardware, effectively allowing us to drive hardware as if it was software.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: placement `new`（如你可能记得，在第 [*7章*](B21071_07.xhtml#_idTextAnchor116) 中讨论的一个重要特性）有许多用途，但其中一个特别有趣的使用是它允许我们将软件对象映射到内存映射硬件，从而有效地允许我们像操作软件一样驱动硬件。
- en: A working example of this feature would be tricky to write as we would find
    ourselves in “non-portable code land,” using operating-system-specific features
    to get the address of a particular device and discussing ways to get read and
    write privileges to memory locations normally accessed by software drivers. For
    that reason, we will craft an artificial yet illustrative example and ask you,
    esteemed reader, to imagine that the missing parts of this example exist.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写一个这个特性的工作示例会相当棘手，因为我们可能会发现自己处于“非可移植代码地带”，使用操作系统特定的功能来获取特定设备的地址，并讨论获取通常由软件驱动程序访问的内存位置的读写权限的方法。因此，我们将构建一个人工但具有说明性的示例，并要求您，尊敬的读者，想象这个示例中缺失的部分。
- en: 'First, suppose that we are developing a driver for a new video card, one that
    is so wonderful that its codename is `super_video_card`. For the sake of this
    illustration, we will model this through the following class:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，假设我们正在开发一个新显卡的驱动程序，这款显卡非常出色，其代号为`super_video_card`。为了说明这一点，我们将通过以下类来模拟：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The important aspects of this class for our purpose are the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，这个类的重要方面如下：
- en: It is an uncopiable type, as it is meant to map to a specific zone of memory.
    Copying an object of this type would be counterproductive, to say the least.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个不可复制的类型，因为它旨在映射到特定的内存区域。复制此类对象至少是无效的。
- en: It has been designed in such a way that its state can conceptually be superimposed
    on its hardware equivalent. For example, given the preceding class declaration,
    starting at the beginning of the hardware’s memory layout, we expect four 32-bit
    integral registers followed by four 32-bit floating point registers. We used `<cstdint>`
    to get the aliases for fixed-width integral types on our compiler.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它被设计成这样的方式，其状态在概念上可以叠加到其硬件等价物上。例如，给定前面的类声明，从硬件内存布局的开始处开始，我们期望有四个32位整数寄存器，然后是四个32位浮点寄存器。我们使用了`<cstdint>`来获取我们编译器上固定宽度整数类型的别名。
- en: As should be the case under such circumstances, we express our expectations
    through `static_assert` whenever possible. Also, since the state of the hardware
    registers can change through other actions than that of our program, we qualified
    the register-equivalents as `volatile` such that accesses to these member variables
    will be equivalent to I/O operations for the purpose of C++’s abstract machine.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，我们应该通过`static_assert`来表述我们的期望。此外，由于硬件寄存器的状态可以通过我们程序之外的其他操作而改变，我们将寄存器等价物标记为`volatile`，这样对这些成员变量的访问将等同于C++抽象机中的I/O操作。
- en: Why do we use volatile variables in this example?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们在这个例子中使用`volatile`变量？
- en: If you are not used to `volatile` variables, you might be wondering why we used
    this qualification on the data members of our memory-mapped hardware-representing
    class. The reason why this is important is that we want to avoid our compiler
    optimizing code based on the (wrong, in this case) assumption that if our code
    does not touch these variables, then they do not change state or that if our writes
    to these variables are not followed by reads in our code, then that can be assumed
    to have no effect. Through `volatile`-qualified variables, we are effectively
    telling the compiler “*There are things you do not know happening on these objects,
    so please do not assume* *too much*.”
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太习惯`volatile`变量，你可能会想知道为什么我们在内存映射硬件表示类的数据成员上使用了这个限定符。这样做之所以重要，是因为我们希望避免编译器基于（在这种情况下是错误的）假设来优化代码，即如果我们的代码没有触摸这些变量，那么它们的状态不会改变，或者如果我们的代码中对这些变量的写入没有跟随读取，那么可以假设没有效果。通过`volatile`限定的变量，我们实际上在告诉编译器“*这里有一些你不知道的事情在这些对象上发生，所以请不要假设太多*。”
- en: For simplicity, we used a constructor that zeros out the data members and a
    trivial destructor, but in practice, we could have used constructors (default
    or otherwise) to initialize the state of the memory-mapped device to match our
    needs and the destructor to reset the state of that device to some acceptable
    state.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们使用了一个将数据成员清零的构造函数和一个平凡的析构函数，但在实践中，我们本可以使用构造函数（默认或其他）来初始化内存映射设备的状态以符合我们的需求，并使用析构函数将设备状态重置为某种可接受的状态。
- en: 'Normally, for a program to access the memory-mapped hardware, we would probably
    communicate with the operating system with services that accept as argument the
    required information to identify the device whose address we seek. In our case,
    we will simply make it look like we can access a zone of memory of the right size
    and alignment to which we can read and write. The memory address is exposed as
    raw memory (of type `void*`), which is what we can realistically expect from an
    operating system function under similar circumstances:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，为了程序能够访问内存映射的硬件，我们可能会通过操作系统提供的服务与操作系统通信，这些服务接受作为参数的所需信息来识别我们寻求地址的设备。在我们的情况下，我们将简单地让它看起来我们可以访问一个正确大小和对齐的内存区域，我们可以从中读取和写入。内存地址以原始内存（`void*`类型）的形式暴露出来，这是在类似情况下我们可以从操作系统函数中合理期望的：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We then arrive at how one can use placement `new` to map an object to some
    memory-mapped hardware location. Note that we need to include the `<new>` header
    as this is where placement `new` is defined. The steps to meet our objective are
    as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们到达了如何使用放置`new`将对象映射到某些内存映射硬件位置的方法。请注意，我们需要包含`<new>`头文件，因为这是放置`new`定义的地方。达到我们目标的方法如下：
- en: First, obtain the address where we want to map our carefully crafted `super_video_card`
    object.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，获取我们想要映射我们精心制作的`super_video_card`对象的地址。
- en: Then, through placement `new` at that address, construct a `super_video_card`
    object such that the data members of that object correspond to the address of
    the registers they represent.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过在该地址的放置`new`，构造一个`super_video_card`对象，使得该对象的数据成员对应于它们所代表的寄存器的地址。
- en: For the duration of that object’s lifetime, use the object through the corresponding
    pointer (the `the_card` variable in the following code excerpt).
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该对象的生命周期内，通过相应的指针（以下代码摘录中的`the_card`变量）使用该对象。
- en: When we are done, the one thing we do not want to do is apply `operator delete()`
    on `the_card` as we never allocated the associated memory in the first place.
    We do want to finalize the object through `~super_video_card()`, however, to make
    sure the cleanup or reset code (if any) for that object is run.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们完成工作后，我们最不想做的事情就是在`the_card`上应用`operator delete()`，因为我们一开始就没有分配相关的内存。然而，我们确实希望通过`~super_video_card()`来最终化这个对象，以确保运行该对象的清理或重置代码（如果有的话）。
- en: 'We thus end up with the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到了以下结果：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If the explicit destructor call is a problem, such as in code where exceptions
    could be thrown along the way, we can use a `std::unique_ptr` object with a custom
    deleter (see [*Chapter 5*](B21071_05.xhtml#_idTextAnchor079)) to finalize the
    `super_video_card` object:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果显式析构函数调用是一个问题，例如在可能抛出异常的代码中，我们可以使用一个带有自定义删除器的`std::unique_ptr`对象来最终化`super_video_card`对象（参见[*第5章*](B21071_05.xhtml#_idTextAnchor079)）：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this case, the `std::unique_ptr` object finalizes the pointee (the `super_video_card`
    object) but does not free its memory storage, leading to more robust code in the
    presence of exceptions during the lifetime of the `the_card` variable.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`std::unique_ptr`对象最终化了指针（即`super_video_card`对象），但没有释放其内存存储，这使得在`the_card`变量生命周期中存在异常时，代码更加健壮。
- en: Simplifying nothrow new usage
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化nothrow new的使用
- en: As mentioned in [*Chapter 7*](B21071_07.xhtml#_idTextAnchor116), the default
    behavior of `operator new()` when unable to perform an allocation request is to
    throw an exception. This can result from such situations as running out of memory
    or otherwise being unable to service the allocation request, in which case, one
    usually throws `std::bad_alloc`; from an incorrect array length (for example,
    a negative length of one exceeding implementation-defined limits), usually leading
    to `std::bad_array_new_length` being thrown; or from failure to complete the subsequent
    construction of the object following the completion of `operator new()`, in which
    case, the exception that will be thrown will be whatever was thrown from the failing
    constructor.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第7章*](B21071_07.xhtml#_idTextAnchor116)所述，当`operator new()`无法执行分配请求时，其默认行为是抛出异常。这可能是由于内存不足或其他无法满足分配请求的情况，在这种情况下，通常抛出`std::bad_alloc`；由于数组长度不正确（例如，一个长度为负的一维数组超过了实现定义的限制），通常会导致抛出`std::bad_array_new_length`；或者由于在`operator
    new()`完成后未能完成对象的后续构造，在这种情况下，将被抛出的异常将是来自失败构造函数的任何异常。
- en: 'Exceptions are the “normal” way for a C++ function to signal failure to meet
    the function’s postconditions. In some cases, such as a constructor or an overloaded
    operator, it’s the only real, workable way to do so: a constructor has no return
    value, and the signature of functions that overload operators generally does not
    leave room for additional arguments or error-reporting return values, although
    one could make a case for some types such as `std::optional` or `std::expected`
    as allowing an alternative for some overloaded operator use cases.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是C++函数表示未能满足函数后置条件的“正常”方式。在某些情况下，例如构造函数或重载运算符，这是唯一真正可行的方式：构造函数没有返回值，并且重载运算符的函数签名通常没有为额外的参数或错误报告返回值留下空间，尽管对于某些类型（如`std::optional`或`std::expected`）可以提出一些重载运算符使用情况的替代方案。
- en: 'Of course, some domains typically do not use exceptions: a significant number
    of video games are compiled without exception support, for example, and the same
    goes for a lot of programs written for embedded systems. Reasons invoked go from
    the technical (fear of overhead considered undesirable in terms of memory space
    consumption, execution speed, or both) to the more philosophical (dislike for
    what is seen as hidden control paths), but no matter what the reasons are, the
    fact is that C++ code compiled without exception support exists and the `nothrow`
    version of `operator new()` is a reality.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有些领域通常不使用异常：例如，许多视频游戏在没有异常支持的情况下编译，同样，为嵌入式系统编写的许多程序也是如此。提出的原因从技术上的（对内存空间消耗、执行速度或两者都视为不希望的开销的恐惧）到更哲学上的（不喜欢被视为隐藏的控制路径），但无论原因是什么，事实是，没有异常支持的C++代码确实存在，`nothrow`版本的`operator
    new()`是一个现实。
- en: 'This does mean, of course, that even seemingly simple code such as the following
    can lead to **undefined** **behavior** (**UB**):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这也意味着即使是看似简单的代码，如以下所示，也可能导致**未定义行为**（UB）：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The reason for this potential UB is that if the `nothrow` version of `operator
    new()` fails (unlikely but not impossible, especially in memory-constrained situations),
    then `p` will be null, and accessing the `n` data member through `p` will be…
    a very bad idea.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这种潜在的不确定行为（UB）的原因是，如果`operator new()`的`nothrow`版本失败（虽然不太可能，但并非不可能，尤其是在内存受限的情况下），那么`p`将会是空指针，通过`p`访问`n`数据成员将是一个非常糟糕的想法。
- en: 'Of course, the solution is simple, and being the astute reader that you are,
    you have probably noticed it already: just test the pointer before using it! This
    works, of course, as shown here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，解决方案很简单，鉴于你是一位敏锐的读者，你可能已经注意到了：在使用它之前先测试指针！当然，这在这里是有效的，如下所示：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The problem with this approach is that code quickly becomes littered with tests,
    as there is rarely only one pointer in a program, reminding us that the beauty
    of code using exceptions is that one does not need to worry about those tests.
    With exceptions, either `operator new()` and the subsequent construction both
    succeeded and one can use the resulting pointer confidently, or one of these steps
    failed and code execution did not reach the point where one could get into trouble:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是代码很快就会充满测试，因为程序中很少只有一个指针，这提醒我们，使用异常的代码之美在于不需要担心这些测试。使用异常，要么`operator
    new()`和随后的构造都成功了，可以自信地使用结果指针，要么这些步骤中有一个失败了，代码执行没有达到可能陷入麻烦的点：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Of course, one can get in trouble even with exceptions, for example, if there
    is an execution path that lets `p` remain null or uninitialized and others where
    that cannot happen (you can usually avoid this by initializing your objects on
    declaration, but that is not always possible); let us leave these code hygiene
    considerations aside for now as they would deviate from our topic of interest.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，即使有异常，也可能遇到麻烦，例如，如果存在一个执行路径让`p`保持为空或未初始化，而其他路径则不会发生这种情况（你通常可以通过在声明时初始化对象来避免这种情况，但这并不总是可能的）；让我们现在暂时将这些代码卫生考虑放在一边，因为它们会偏离我们感兴趣的主题。
- en: An important consideration when facing a failure-to-allocate situation is what
    to do when it happens. Whether our code base uses exceptions or not, we most probably
    do not want to let the execution of our program continue and therefore incur UB
    through such things as the improper use of a null pointer.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 面对分配失败的情况时，一个重要的考虑是当它发生时应该做什么。无论我们的代码库是否使用异常，我们很可能不希望程序执行继续，从而通过诸如不正确使用空指针之类的操作导致未定义行为（UB）。
- en: 'A common way to stop execution at the point of failure-to-allocate is to wrap
    the tentative allocation and construction operation, the subsequent test on the
    resulting pointer, and the action to take if the pointer is null in some code
    construct. The code we want to wrap will be something like the following, supposing
    we want to allocate-then-construct an `int` object:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在失败分配点停止执行的一种常见方法是在某些代码结构中包装尝试分配和构造操作、对结果指针的后续测试以及如果指针为空要采取的行动。我们想要包装的代码可能如下所示，假设我们想要分配并构造一个`int`对象：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code used `std::abort()` as a mechanism to end program execution; exceptions
    would provide us with potentially recoverable errors, but without exceptions,
    most standard mechanisms at our disposal will lead to program termination, and
    `std::abort()` is a reasonable choice in this case.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用`std::abort()`作为结束程序执行的机制；异常会给我们提供可能可恢复的错误，但没有异常，我们可用的大多数标准机制都会导致程序终止，在这种情况下，`std::abort()`是一个合理的选择。
- en: Ways to conclude program execution
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 结束程序执行的方式
- en: 'A C++ program can conclude in many different ways: reaching the end of the
    `main()` function is the most obvious one, but other examples exist. For example,
    `std::exit()` is used for normal program termination accompanied by cleanup steps;
    `std::quick_exit()` is used for program termination without cleanup steps. One
    can use `std::atexit()` and `std::at_quick_exit()` to register some functions
    to be called before exiting, and `std::abort()` is used to signal abnormal program
    termination without cleanup steps. The `std::terminate()` function is used when
    some unpleasantness in a documented list of situations occurs (this list includes
    such things as an exception being thrown from the constructor of a `static` variable
    or from the body of a `noexcept` function). In our case, the only mechanism that
    really fit was `std::abort()`.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: C++程序可以以许多不同的方式结束：到达`main()`函数的末尾是最明显的一种，但还有其他例子。例如，`std::exit()`用于带有清理步骤的正常程序终止；`std::quick_exit()`用于不带清理步骤的程序终止。可以使用`std::atexit()`和`std::at_quick_exit()`注册一些在退出前要调用的函数，而`std::abort()`用于在没有清理步骤的情况下发出程序异常终止的信号。当在文档列表中的某些不愉快情况发生时（这个列表包括从`static`变量的构造函数或`noexcept`函数体中抛出的异常等情况），使用`std::terminate()`函数。在我们的情况下，唯一真正适合的机制是`std::abort()`。
- en: 'One possible approach to solve this problem is to use a macro and an **immediately-invoked
    function expression** (**IIFE**), which is the name given to an expression made
    from an anonymous lambda that is at once created, executed, and discarded. To
    make our solution general, we need to be able to do the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题的一个可能方法是使用一个宏和一个立即调用的函数表达式（**IIFE**），这是对一个匿名lambda表达式所构成的、立即创建、执行和丢弃的表达式的称呼。为了使我们的解决方案通用，我们需要能够做到以下几步：
- en: Specify the type of object to create
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定要创建的对象类型
- en: Make the macro variadic, as we need to be able to pass any number of arguments
    of any type to the object’s constructor
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使宏可变参数，因为我们需要能够将任何类型和数量的参数传递给对象的构造函数
- en: 'A possible implementation of such a macro would be `TRY_NEW` as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一个宏的可能实现是`TRY_NEW`，如下所示：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Not everyone is familiar with variadic macros, so let’s take it step by step:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个人都熟悉可变参数宏，所以让我们一步一步来：
- en: The “signature” of our macro is `TRY_NEW(T,...)`, meaning `T` is mandatory and
    `...` could be any number of tokens (including none at all) separated by commas.
    Unsurprisingly, we will use `T` for the type to construct and `...` for the arguments
    to pass to the constructor that will be invoked.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们宏的“签名”是`TRY_NEW(T,...)`，这意味着`T`是必需的，而`...`可以是任何数量的标记（包括一个都没有），由逗号分隔。不出所料，我们将使用`T`来表示要构造的类型，而`...`用于传递给将被调用的构造函数的参数。
- en: Since we wrote the macro on more than one line (for readability), each line
    but the last terminates with a space followed by a backslash to inform the preprocessor
    that it should continue parsing on the next line.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们为了可读性将宏写在了多行上，除了最后一行外，每一行都以一个空格后跟一个反斜杠结束，以通知预处理器它应该在下一行继续解析。
- en: The symbols on `...` are relayed through the special macro named `__VA_ARGS__`,
    which expands to what `...` contained and can be empty if `...` itself is empty.
    This works in both C and C++. Note that we use parentheses, not braces, in the
    constructor call as we want to avoid unwittingly building an initializer list
    if all elements of `__VA_ARGS__` are of the same type.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`...`上的符号通过名为`__VA_ARGS__`的特殊宏进行中继，该宏展开为`...`包含的内容，如果`...`本身为空，则可以是空的。这在C和C++中都有效。请注意，我们在构造函数调用中使用括号而不是花括号，因为我们想避免无意中构建一个初始化列表，如果`__VA_ARGS__`的所有元素都是同一类型的话。'
- en: We test the `p` pointer resulting from the call to a `std::nothrow` version
    of `operator new()` and call `std::abort()` if `p` is null.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们测试由调用`operator new()`的`std::nothrow`版本产生的`p`指针，如果`p`为空，则调用`std::abort()`。
- en: This entire sequence of operations is, as announced, wrapped in an IIFE and
    the newly allocated pointer is returned. Note that we could also have returned
    a `std::unique_ptr<T>` object from that lambda if we had wanted to do so. Also,
    note that this lambda expression uses a `[&]` capture block to ensure the availability
    of tokens in `__VA_ARGS__` within the scope of the lambda.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，整个操作序列被一个立即执行函数表达式（IIFE）包裹，并返回新分配的指针。请注意，如果我们愿意，我们也可以从那个lambda表达式返回一个`std::unique_ptr<T>`对象。另外，请注意，这个lambda表达式使用了一个`[&]`捕获块来确保在lambda的作用域内`__VA_ARGS__`中的标记可用。
- en: A small but interesting side effect
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小但有趣的影响
- en: 'Note that since we used parentheses (the same would hold for braces), an empty
    `__VAR_ARGS__` will lead this macro to zero-initialize fundamental types such
    as `int` instead of leaving them uninitialized. You can compare: as of C++23,
    `new int;` yields a pointer to an uninitialized `int` object, but `new int();`
    and `new int{};` both initialize the allocated block with a value of zero. There
    is an upside to this, as with this macro, we will not end up with a pointer to
    an uninitialized object, even for trivial types. However, there is also a downside
    as we will be paying for an initialization even in cases where it might not have
    been necessary.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于我们使用了括号（同样适用于花括号），一个空的`__VAR_ARGS__`将导致这个宏将基本类型（如`int`）初始化为零，而不是将它们留作未初始化。您可以比较：截至C++23，`new
    int;`产生一个指向未初始化`int`对象的指针，但`new int();`和`new int{};`都将分配的块初始化为零。这有一个优点，就像这个宏一样，即使对于平凡类型，我们也不会得到一个指向未初始化对象的指针。然而，也有一个缺点，因为我们甚至在不必要的情况下也要为初始化付费。
- en: 'Another approach would be to use a variadic function template, which might
    lead to a better debugging experience in practice. It has slightly different-looking
    client code but is otherwise similar in usage and effect:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法可能是使用变长参数函数模板，这在实践中可能会带来更好的调试体验。它的客户端代码看起来略有不同，但在使用和效果上与其他类似：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The call syntax for the variadic function version looks like a cast, and arguments
    passed to `try_new()` are perfectly forwarded to the constructor of `T` to ensure
    that the expected constructor is called in the end. As was the case with the macro,
    we could have chosen to return a `std::unique_ptr<T>` object instead of a `T*`
    object with this function.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 可变参数函数版本的调用语法看起来像是一个类型转换，传递给`try_new()`的参数被完美转发到`T`的构造函数中，以确保最终调用预期的构造函数。就像宏的情况一样，我们可以选择用这个函数返回一个`std::unique_ptr<T>`对象，而不是`T*`对象。
- en: Out-of-memory situations and new_handler
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存不足的情况和new_handler
- en: So far in this book, including this chapter, we have stated that `operator new()`
    and `operator new[]()` typically throw `std::bad_alloc` when failing to allocate
    memory. It’s true to a wide extent, but there is a subtlety we have avoided so
    far and to which we will now give some time and attention.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，包括本章在内，我们已声明`operator new()`和`operator new[]()`在无法分配内存时通常会抛出`std::bad_alloc`异常。这在很大程度上是正确的，但我们之前避免了一个细微之处，现在我们将花些时间和精力来关注它。
- en: 'Imagine a situation where user code has specialized the memory allocation functions
    to fetch memory blocks from a pre-allocated data structure with interesting performance
    characteristics. Suppose that this data structure initially allocates space for
    a small number of blocks and then goes on to allocate more space once the user
    code exhausts the blocks from the initial allocation. Expressed otherwise: in
    this situation, we have an initial, fast setting (let’s call that the “optimistic”
    state) and a secondary setting (let’s call that the “second chance” state) that
    lets user code continue allocating once the “optimistic” state’s resources have
    been consumed.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一种情况，用户代码已经专门化了内存分配函数，以便从具有有趣性能特性的预分配数据结构中获取内存块。假设这个数据结构最初为少量块分配空间，然后在用户代码耗尽初始分配的块之后继续分配更多空间。换句话说：在这种情况下，我们有一个初始的快速设置（让我们称它为“乐观”状态）和一个次要设置（让我们称它为“第二次机会”状态），允许用户代码在“乐观”状态的资源耗尽后继续分配。
- en: For a scenario such as this to be seamless, with a transparent change of allocation
    strategy achievable without the explicit intervention of user code, explicitly
    throwing `std::bad_alloc` would be insufficient. Throwing would complete the execution
    of `operator new()` and client code could catch the exception and take action,
    of course, but in this (reasonable) scenario, we would like failure to allocate
    to lead to some action being taken and `operator new()` to try again with the
    updated state of things, if any.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此类场景无缝，在不显式干预用户代码的情况下实现透明的分配策略更改，仅显式抛出`std::bad_alloc`是不够的。抛出会完成`operator
    new()`的执行，客户端代码可以捕获异常并采取行动，当然，但在这种（合理的）场景中，我们希望分配失败导致采取某些行动，并且`operator new()`在更新后的状态（如果有的话）下再次尝试。
- en: 'In C++, scenarios such as this are handled through a `std::new_handler`, which
    is an alias for a function pointer of type `void(*)()`. What one needs to know
    is the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，此类场景通过`std::new_handler`来处理，它是类型为`void(*)()`的函数指针的别名。需要了解的是以下内容：
- en: There is a global `std::new_handler` in a program, and by default, its value
    is `nullptr`.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序中有一个全局的`std::new_handler`，默认情况下其值为`nullptr`。
- en: One can set the active `std::new_handler` through the `std::set_new_handler()`
    function, and one can get the active `std::new_handler` through the `std::get_new_handler()`
    function. Note that as a convenience, `std::set_new_handler()` returns the `std::new_handler`
    that is being replaced.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过`std::set_new_handler()`函数设置活动的`std::new_handler`，并且可以通过`std::get_new_handler()`函数获取活动的`std::new_handler`。请注意，为了方便起见，`std::set_new_handler()`返回正在被替换的`std::new_handler`。
- en: When an allocation function such as `operator new()` fails, what it should do
    is first get the active `std::new_handler`. If that pointer is null, then the
    allocation function should throw `std::bad_alloc` as we have done so far; otherwise,
    it should call that `std::new_handler` and try again under the new conditions
    that this call installed.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个分配函数，如`operator new()`失败时，它应该首先获取活动的`std::new_handler`。如果该指针为空，则分配函数应该抛出`std::bad_alloc`，就像我们迄今为止所做的那样；否则，它应该调用该`std::new_handler`并在新条件下重试。
- en: As could be expected, your standard library should already implement this algorithm,
    but our own overloads of `operator new()` and `operator new[]()` have not done
    so, at least so far. To show how to benefit from a `std::new_handler`, we will
    now implement an artificial version of the aforementioned two-step scenario.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，你的标准库应该已经实现了这个算法，但我们的`operator new()`和`operator new[]()`的重载函数还没有这样做，至少到目前为止是这样。为了展示如何从`std::new_handler`中受益，我们现在将实现上述两步场景的人工版本。
- en: 'This toy implementation will use the member version of the allocation operators
    for some `X` type and behave as if we initially had enough memory for `limit`
    objects of that type (normally, we would actually manage that memory, and you
    can see an example of such management in [*Chapter 10*](B21071_10.xhtml#_idTextAnchor153)
    where we will provide a more realistic example). We will install a `std::new_handler`
    that, when called, changes `limit` to a higher number, and then resets the active
    handler to `nullptr` such that subsequent failures to allocate `X` objects will
    lead to throwing `std::bad_alloc`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个玩具实现将使用某些`X`类型的分配操作符的成员版本，并表现得好像我们最初有足够内存来存储该类型的`limit`个对象（通常，我们实际上会管理这些内存，你可以在[*第10章*](B21071_10.xhtml#_idTextAnchor153)中看到一个这样的管理示例，我们将提供一个更现实的例子）。我们将安装一个`std::new_handler`，当被调用时，将`limit`改为一个更大的数字，然后重置活动处理程序为`nullptr`，这样后续尝试分配`X`对象失败将导致抛出`std::bad_alloc`：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note the way that `X::operator new()` handles failure: if it notices that it
    will not be able to meet its postconditions, it gets the active `std::new_handler`,
    and if it’s non-null, calls it before trying again. This means that the `std::new_handler`,
    when called, has to either change the situation in such a way that a subsequent
    tentative allocation could succeed or change the `std::new_handler` to `nullptr`
    such that failure will lead to an exception being thrown. Failure to respect these
    rules could lead to an infinite loop and much sadness would ensue.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`X::operator new()`处理失败的方式：如果它注意到它将无法满足其后续条件，它会获取活动的`std::new_handler`，如果它不为空，则在再次尝试之前调用它。这意味着当`std::new_handler`被调用时，它必须以某种方式改变情况，使得后续的尝试分配可以成功，或者将`std::new_handler`改为`nullptr`，这样失败将导致抛出异常。不遵守这些规则可能导致无限循环，并随之而来的是许多悲伤。
- en: 'The handler installed in `main()` for this toy example does this: when called,
    it changes the conditions under which the allocations will be performed (it raises
    the value of `X::limit`). It then calls `std::set_new_handler()` with `nullptr`
    as we have not planned for another approach after the “optimistic” and “second
    chance” situations, so if we exhaust the second chance resources, we (as they
    say) are toast.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main()` 中为这个玩具示例安装的处理程序执行以下操作：当被调用时，它改变执行分配的条件（它增加了 `X::limit` 的值）。然后，它使用
    `nullptr` 调用 `std::set_new_handler()`，因为我们没有计划在“乐观”和“第二次机会”情况之后采取另一种方法，所以如果我们耗尽了第二次机会的资源，我们（正如他们所说）就完蛋了。
- en: A lambda as new_handler?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: lambda 作为 new_handler？
- en: You might have noticed that we described the `std::new_handler` type as being
    an alias for a function pointer of the `void(*)()` type, yet in our toy example,
    we installed a lambda. Why does that work? Well, it happens that a stateless lambda—a
    lambda expression with an empty capture block—is implicitly convertible to a function
    pointer with the same calling signature. It’s a useful thing to know under many
    circumstances, such as when writing C++ code that interfaces with C code or operating
    system APIs.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我们将 `std::new_handler` 类型描述为 `void(*)()` 类型函数指针的别名，然而在我们的玩具示例中，我们安装了一个
    lambda。为什么这行得通？好吧，碰巧无状态的 lambda——一个空的捕获块的 lambda 表达式——可以隐式转换为具有相同调用签名的函数指针。这在许多情况下都是很有用的，比如当编写与
    C 代码或操作系统 API 交互的 C++ 代码时。
- en: We are now about to enter a strange and quite technical part of this chapter,
    where we will see how to leverage C++ to handle atypical memory.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在即将进入本章的一个奇怪且相当技术性的部分，我们将看到如何利用 C++ 来处理非典型内存。
- en: Standard C++ and exotic memory
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准C++和奇异内存
- en: Our last example in this slightly strange chapter with examples of unusual memory
    management usage is concerned with the ways in which we can write standard C++
    programs that deal with “exotic” memory. By “exotic,” we mean memory that requires
    explicit actions to “touch” (allocate, read from, write to, deallocate, and so
    on) and that differs from a “normal” memory block under the control of our program,
    such as the one used in the illustrative example of memory-mapped usage with placement
    `new` earlier in this chapter. Examples of such memory include persistent (non-volatile)
    memory or shared memory, but anything *out of the ordinary* will do, really.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个有点奇怪的章节的最后，我们关注的是我们可以如何编写处理“奇异”内存的标准 C++ 程序。通过“奇异”，我们指的是需要显式操作来“接触”（分配、读取、写入、释放等）的内存，并且与我们的程序控制的“正常”内存块不同，例如本章前面使用
    placement `new` 的内存映射使用示例。这类内存的例子包括持久（非易失）内存或共享内存，但实际上任何 *非同寻常的* 都可以。
- en: Since we have to pick an example, we will write an example using a (fictional)
    shared memory block.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们必须选择一个示例，我们将编写一个使用（虚构的）共享内存块的示例。
- en: A little white lie…
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小小的谎言……
- en: It’s important to understand that we are describing a mechanism for memory that
    would normally be shared between *processes*, but inter-process communication
    is the domain of the operating system. Standard C++ only describes the rules for
    sharing data between *threads* in a process; for that reason, we will tell a little
    white lie and write a multithreaded system, not a multiple-process one, using
    that memory to share data. Our focus is on memory management facilities, not inter-process
    communication, so that should not pose a problem.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，我们正在描述的是一个通常会在 *进程* 之间共享的内存机制，但进程间通信是操作系统的领域。标准 C++ 只描述了在进程中的 *线程* 之间共享数据的规则；因此，我们将说一个小小的谎言，并编写一个多线程系统，而不是多进程系统，使用该内存来共享数据。我们的重点是内存管理功能，而不是进程间通信，所以这不应该构成问题。
- en: 'Following the same approach as we did in previous sections of this chapter,
    we will craft a portable illustration of how to proceed in code that seeks to
    manage atypical memory, and let you map the details to the services of your chosen
    platform. Our example code will take the following shape:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 按照本章前面部分的做法，我们将构建一个可移植的示例，展示如何在代码中管理非典型内存，并让您将这些细节映射到您选择平台的服务。我们的示例代码将具有以下形式：
- en: A shared memory block will be allocated. We will make it look like this memory
    is special in the sense that one needs special operating system functions to create
    it, allocate it, or deallocate it, but we will deliberately avoid using actual
    operating system functions. This means that if you want to use the code in this
    section for a real application, you will need to adapt it to your chosen platform’s
    API.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将分配一个共享内存块。我们将让它看起来这个内存是特殊的，因为需要特殊的操作系统函数来创建它、分配它或释放它，但我们故意避免使用实际的操作系统函数。这意味着，如果您想将本节中的代码用于实际应用，您需要将其适配到您选择的平台API。
- en: We will craft a “handmade” version of a toy program that uses this fictional
    API for shared memory in order to illustrate what user code would look like under
    these circumstances.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将制作一个使用这个虚构的共享内存API的“手工”版本玩具程序，以此来展示在这些情况下用户代码会是什么样子。
- en: Then, we will show how understanding the memory management facilities of C++
    can help us write more pleasant and “normal looking” user code that does the same
    thing as the “handmade” one… or even better.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将展示理解C++的内存管理功能如何帮助我们编写更愉快且“看起来更正常”的用户代码，这些代码与“手工”代码做同样的事情……甚至更好。
- en: Fictional realism?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虚构的现实感？
- en: This entire section on C++ and exotic memory, which we cover next, will hopefully
    be interesting, and the code we will write will strive to be realistic with respect
    to memory management. As mentioned previously, since the C++ standard is mostly
    silent on the idea of multi-process systems, we will try to make multithreaded
    code look kind of like multi-process code. I hope you, astute reader, will accept
    this proposition.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论C++和异构内存，希望这将是有趣的，我们将编写的代码将力求在内存管理方面具有现实性。如前所述，由于C++标准在多进程系统方面的内容很少，我们将尝试使多线程代码看起来有点像多进程代码。我希望你，敏锐的读者，会接受这个提议。
- en: Please note that there will be a small amount of low-level synchronization in
    user code for this section, including some through atomic variables. I tried to
    keep it minimal yet reasonably realistic and hope you will be able to accept it
    even though I will not explain it all in detail, with this book’s focus being
    on memory management rather than on concurrent computing (another fine topic,
    of course). Feel free to use your favorite concurrent programming resource if
    you want to know more about such things as waiting on atomics or using thread
    fences.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，本节用户代码中会有一些低级同步，包括一些通过原子变量。我尽量保持其最小化且合理现实，希望即使我不会详细解释所有内容，你也能接受，因为本书的重点是内存管理而不是并发计算（当然，这也是一个很好的主题）。如果你想知道更多关于等待原子变量或使用线程栅栏等事情，请自由使用你喜欢的并发编程资源。
- en: Ready? Let’s do this!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好了吗？让我们开始吧！
- en: A fictional shared memory API
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个虚构的共享内存API
- en: We will write an API that is fictional but inspired by what one finds in most
    operating systems, except that we will report errors through exceptions to simplify
    user code. Operating systems mostly report errors through error codes expressed
    from return values, but this leads to user code that is more involved. I hope
    this seems like an acceptable compromise to you, dear reader.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个虚构但受大多数操作系统启发（除了我们将通过异常报告错误以简化用户代码之外）的API。操作系统主要通过从返回值中表达的错误代码来报告错误，但这会导致用户代码更加复杂。我希望这对你，亲爱的读者，来说似乎是一个可以接受的折衷方案。
- en: As most operating systems do, we will abstract the actual resource through a
    form of handle, or key; creating a “shared memory” segment of some size will yield
    a key (an integral identifier), after which, accessing that memory will require
    that key, and so will destroying that memory. As can be expected with a facility
    meant to be used to share data between processes, destroying the memory will not
    finalize the objects therein, so user code will need to ensure that objects in
    the shared memory are destroyed before releasing the shared memory segment.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如大多数操作系统所做的那样，我们将通过一种形式的手柄或键来抽象实际的资源；创建一个某个大小的“共享内存”段将产生一个键（一个整数标识符），之后，访问该内存将需要这个键，销毁该内存也是如此。正如预期的那样，对于一个旨在用于在进程之间共享数据的设施，销毁内存不会最终确定其中的对象，因此用户代码需要确保在释放共享内存段之前销毁共享内存中的对象。
- en: 'The signatures and types for our API will be as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们API的签名和类型如下：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You might notice that we are using an `enum` type for `shared_mem_id`. The
    reason for this is that `enum` types are distinct types in C++, not just aliases
    as one would get from `using` or `typedef`. Having distinct types can be useful
    when overloading functions based on the types of their arguments. It’s a useful
    trick to know: if we write two functions with the same name (one that takes an
    argument of the `shared_mem_id` type and another that takes an argument of the
    `std::size_t` type), these will be distinct functions, even though the underlying
    type of `shared_mem_id` is `std::size_t`.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到我们正在使用`enum`类型为`shared_mem_id`。这样做的原因是`enum`类型在C++中是不同的类型，而不仅仅是`using`或`typedef`会得到的一个别名。当基于它们的参数类型重载函数时，具有不同的类型可能很有用。这是一个有用的技巧：如果我们编写两个具有相同名称的函数（一个接受`shared_mem_id`类型的参数，另一个接受`std::size_t`类型的参数），这些将是不同的函数，尽管`shared_mem_id`的底层类型是`std::size_t`。
- en: Since we are building an artificial implementation of “shared memory” to show
    how memory allocation functions can simplify user code, the implementation for
    the functions of our API will be written to be simple, but let us write client
    code that behaves as if it were using shared memory. We will define a shared memory
    segment as a `shared_mem_block` modeled by a pair made from an array of bytes
    and a size in bytes. We will keep a `std::vector` object of that type, using the
    indices in that array as `shared_mem_id`. This means that when a `shared_mem_block`
    object is destroyed, we will not reuse its index in the `std::vector` (the container
    will eventually have “holes,” so to speak).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在构建一个“共享内存”的人工实现来展示内存分配函数如何简化用户代码，因此我们的API函数实现将编写得简单，但让我们编写客户端代码，使其表现得好像它正在使用共享内存。我们将定义一个共享内存段为一个由字节数组及其字节大小组成的`shared_mem_block`对。我们将保持一个该类型的`std::vector`对象，使用该数组中的索引作为`shared_mem_id`。这意味着当`shared_mem_block`对象被销毁时，我们不会在`std::vector`中重用其索引（容器最终会有“空洞”，换句话说）。
- en: 'Our implementation is as follows. Note that it is not thread-safe, but that
    does not impact our memory management-related discourse:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实施方案如下。请注意，它不是线程安全的，但这不会影响我们与内存管理相关的讨论：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you want to experiment, you can replace the implementation of these functions
    with equivalent implementations that call the functions of your chosen operating
    system, adjusting the API if needed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想进行实验，你可以用你选择的操作系统的等效实现替换这些函数的实现，如果需要，调整API。
- en: Equipped with this implementation, we can now compare a “handmade” example of
    shared memory-using code with one that benefits from the facilities of C++. We
    will do this comparison with code where one allocates some chunk of data from
    a shared memory segment and then launches two threads (a writer and a reader).
    The writer will write to that shared data, and then (with minimal synchronization)
    the reader will read from it. As mentioned previously, our code will use *intra*-process
    synchronization (C++ atomic variables), but in real code, you should use *inter*-process
    synchronization mechanisms provided by the operating system.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 配备了这个实现，我们现在可以比较一个使用共享内存的“手工”代码示例和一个受益于C++设施的实现。我们将通过以下代码进行这种比较：一个从共享内存段分配一些数据块，然后启动两个线程（一个写线程和一个读线程）。写线程将写入共享数据，然后（通过最小化同步）读线程将从它读取。如前所述，我们的代码将使用*进程内*同步（C++原子变量），但在实际代码中，你应该使用操作系统提供的*进程间*同步机制。
- en: A note on lifetime
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 关于生命周期
- en: You might remember from [*Chapter 1*](B21071_01.xhtml#_idTextAnchor016) that
    each object has an associated lifetime, and that the compiler keeps track of this
    fact in your programs. Our fictional multiple-process example is really a single-process,
    multithreaded example, so the usual C++ lifetime rules apply.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得从[*第一章*](B21071_01.xhtml#_idTextAnchor016)中了解到，每个对象都有一个关联的生命周期，编译器会在你的程序中跟踪这一事实。我们的虚构多进程示例实际上是一个单进程、多线程示例，因此通常的C++生命周期规则适用。
- en: If you want to take the code in this section and write a real multi-process
    system to run some tests, you might want to consider using `std::start_lifetime_as()`
    from C++23 in those processes that did not explicitly create the `data` object,
    and avoid detrimental optimizations from happening based on the compiler’s reasoning
    that, in these processes, the objects have never been constructed. In earlier
    compilers, one trick that generally works is calling `std::memcpy()` of the not-officially-constructed
    object onto itself, effectively starting its lifetime.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将本节中的代码用于编写一个真正的多进程系统以运行一些测试，你可能需要考虑在这些没有明确创建`data`对象的进程中使用C++23中的`std::start_lifetime_as()`，并避免基于编译器的推理产生的有害优化，即在这些进程中，对象从未被构造。在早期的编译器中，一个通常有效的方法是将未正式构造的对象的`std::memcpy()`调用到自身上，从而有效地开始其生命周期。
- en: 'In both our “handmade” and our standard-looking implementations, we will be
    using a `data` object made of an `int` value and a Boolean `ready` flag:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的“手工制作”和标准外观的实现中，我们将使用由一个`int`值和一个布尔`ready`标志组成的`data`对象：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In a single-process implementation, a better choice for the completion flag
    would be an `atomic<bool>` object as we want to make sure the write to the `ready`
    flag happens before the write to the value, but since we want this example to
    look like we are using inter-process shared memory, we will limit ourselves to
    a simple `bool` and ensure this synchronization through other means.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在单进程实现中，对于完成标志，更好的选择是`atomic<bool>`对象，因为我们想确保在写入`ready`标志之前写入值，但由于我们希望这个示例看起来像我们正在使用进程间共享内存，我们将限制自己使用简单的`bool`，并通过其他方式确保这种同步。
- en: A word on synchronization
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 关于同步的一席话
- en: In a contemporary program, optimizing compilers will often reorder operations
    that seem independent to generate better code, and processors will do the same
    once the code has been generated in order to maximize usage of the processor’s
    internal pipeline. Concurrent code sometimes contains dependencies that are neither
    visible to the compiler nor to the processor. In our examples, we will want the
    `ready` completion flag to become `true` only after the write to `value` has been
    performed; this order is only important because the writes are performed in one
    thread but *another* thread will look at `ready` to know whether `value` can be
    read.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个现代程序中，优化编译器通常会重新排序看似独立的操作以生成更好的代码，处理器在代码生成后也会进行同样的操作，以最大化处理器内部流水线的使用。并发代码有时会包含既对编译器也对处理器不可见的依赖。在我们的示例中，我们希望`ready`完成标志仅在`value`写入操作完成后变为`true`；这个顺序之所以重要，是因为写入操作在一个线程中执行，但另一个线程将查看`ready`以确定是否可以读取`value`。
- en: Not enforcing the `value`-then-`ready` sequence of writes through some form
    of synchronization would let either the compiler or the processor reorder these
    (seemingly independent) writes and break our assumptions on the meaning of `ready`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不通过某种形式的同步强制执行`value`-`ready`写入顺序，编译器或处理器可能会重新排序这些（看似独立的）写入，并破坏我们对`ready`含义的假设。
- en: A handmade user code example
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个手工的用户代码示例
- en: 'We can, of course, write user code that uses our fictional API without resorting
    to specialized memory management facilities of C++, simply relying on placement
    `new` usage as seen in [*Chapter 7*](B21071_07.xhtml#_idTextAnchor116). It might
    be tempting to think of placement `new` as a specialized facility since you might
    have learned of it from this book, but if that is your perspective, you are invited
    to reconsider: the placement `new` mechanism is a fundamental memory management
    tool used in almost every program, whether user code is aware of it or not.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以编写使用我们虚构的API的用户代码，而无需求助于C++的特殊内存管理设施，仅仅依靠如[*第7章*](B21071_07.xhtml#_idTextAnchor116)中看到的放置`new`的使用。可能会诱使人们认为放置`new`是一种特殊设施，因为你可能从这本书中了解到它，但如果这是你的观点，我们邀请你重新考虑：放置`new`机制是一种几乎在所有程序中使用的根本性内存管理工具，无论用户代码是否意识到它。
- en: 'As a reminder, our example program will do the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，我们的示例程序将执行以下操作：
- en: Create a shared memory segment of some size (we will allocate much more than
    we need in this case).
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个指定大小的共享内存段（在这种情况下，我们将分配比所需更多的内存）。
- en: Construct a `data` object at the beginning of that segment, obviously through
    placement `new`.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在该段的开始处构造一个`data`对象，显然是通过放置`new`来完成的。
- en: Start a thread that will wait for a signal on the `go` variable of type `atomic<bool>`,
    then obtain access to the shared memory segment, write to the `value` data member
    and then only signal that the write has occurred through the `ready` data member.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动一个线程，该线程将等待 `go` 变量（类型为 `atomic<bool>`）上的信号，然后获得对共享内存段的访问权限，写入 `value` 数据成员，然后仅通过
    `ready` 数据成员发出写入已发生的信号。
- en: Start another thread that will obtain access to the shared memory segment, get
    a pointer to the shared `data` object therein, and then do some (very inefficient)
    busy waiting on the `ready` flag to change state, after which `value` will be
    read and used. Once this has been done, completion will be signaled through the
    `done` flag of type `atomic<bool>`.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动另一个线程，该线程将获得对共享内存段的访问权限，获取其中共享 `data` 对象的指针，然后对 `ready` 标志进行一些（非常低效的）忙等待以改变状态，之后将读取并使用
    `value`。一旦完成，将通过 `done` 标志（类型为 `atomic<bool>`）发出完成信号。
- en: Our program will then read a key from the keyboard, signal the threads (the
    writer thread, really) that it’s time to start working, and wait until they are
    done before freeing the shared memory segment and concluding its work.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们的程序将从键盘读取一个键，向线程（实际上是写入线程）发出信号，表明是时候开始工作了，并在释放共享内存段并结束工作之前等待它们完成。
- en: 'We thus end up with the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们最终得到以下结果：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We made this work: we have an infrastructure of sorts to manage shared memory
    segments, we can use these memory blocks to share data, and we can write code
    that reads from that shared data as well as writes to it. Note that we captured
    the key in each thread in a `key` variable and then obtained the memory block
    within each lambda through that key, but it would also be reasonable to simply
    capture the `p_data` pointer and use it.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使这项工作得以实现：我们有一种某种形式的基础设施来管理共享内存段，我们可以使用这些内存块来共享数据，我们可以编写读取该共享数据的代码，也可以写入它。请注意，我们在每个线程中捕获了
    `key` 变量中的密钥，然后通过该密钥在每个 lambda 中获取内存块，但简单地捕获 `p_data` 指针并使用它也是合理的。
- en: 'Notice, however, that we did not really manage that block: we created it and
    used a small chunk of size `sizeof(data)` at the beginning. Now, what if we had
    wanted to create multiple objects in that zone? And what if we had wanted to write
    code that both creates and destroys objects, introducing the need to manage what
    parts of that block are in use at a given time? With what we just wrote, that
    would mean doing it all in user code, a somewhat burdensome endeavor.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，我们并没有真正管理那个块：我们创建了它，并在开始时使用了一个大小为 `sizeof(data)` 的小块。现在，如果我们想在那个区域创建多个对象呢？如果我们想编写既创建又销毁对象的代码，引入了在给定时间管理该块哪些部分正在使用的需求呢？根据我们刚才写的，这意味着所有这些都在用户代码中完成，这是一个相当繁重的任务。
- en: Keeping that in mind, we will now solve the same problem but with a different
    approach.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这一点，我们现在将用不同的方法解决相同的问题。
- en: A standard-looking user code equivalent
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个看起来标准的用户代码等效
- en: 'So, what mechanism does C++ offer us if we want to use “exotic” memory in a
    more idiomatic manner? Well, one way to do so is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们想以更习惯的方式使用“奇特”内存，C++ 提供了什么机制呢？嗯，这样做的一种方法如下：
- en: To write a manager class for the “exotic” memory, encapsulating the non-portable
    interface to the operating system and exposing services that are closer to what
    C++ user code would expect
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个用于“奇特”内存的管理器类，封装对操作系统的不可移植接口，并公开更接近 C++ 用户代码预期的服务
- en: To write overloads of the memory allocation operators (`operator new()`, `operator
    delete()`, and so on) that take a reference to such a manager object as an additional
    argument
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写内存分配操作符的重载（如 `operator new()`、`operator delete()` 等），这些重载接受对这样一个管理对象的引用作为额外的参数
- en: To make these overloaded memory allocation operators bridge the gap between
    portable and non-portable code through delegation on the memory manager object
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在内存管理器对象上委托来使这些重载的内存分配操作符在可移植和非可移植代码之间架起桥梁
- en: This way, user code can be written essentially as “normal looking” code that
    calls `new` and `delete` operators, except that these calls will use the same
    kind of extended notation seen in [*Chapter 7*](B21071_07.xhtml#_idTextAnchor116)
    for such things as the `nothrow` or placement versions of `operator new()`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，用户代码可以基本上写成“看起来正常”的代码，调用 `new` 和 `delete` 操作符，只是这些调用将使用与 [*第 7 章*](B21071_07.xhtml#_idTextAnchor116)
    中类似的那种扩展符号，例如 `nothrow` 或放置版本的 `operator new()`。
- en: Our `shared_mem_mgr` class will use the fictional operating system API described
    earlier in this section but, normally, one would write a class that encapsulates
    whatever operating system services are required to access the atypical memory
    one aims to use in a program.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `shared_mem_mgr` 类将使用本节前面描述的虚构操作系统 API，但通常，人们会编写一个封装所需操作系统服务的类，以便在程序中使用目标内存。
- en: Being an example made for simplicity, mostly to show how the feature works and
    can be used, the astute reader that you are will hopefully see much room for improvement
    and optimization… Indeed, this manager is really slow and memory consuming, keeping
    a `std::vector<bool>` object where each `bool` value indicates whether a byte
    in the memory block is taken or not and performing a naïve linear search through
    that container whenever an allocation request is made (also, it’s not thread-safe,
    which is bad!). We will examine some quality of implementation considerations
    in [*Chapter 10*](B21071_10.xhtml#_idTextAnchor153), but nothing stops you from
    taking `shared_mem_mgr` and making it significantly better in the meantime.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个为了简单而制作的示例，主要是为了展示功能的工作方式和如何使用，聪明的读者你可能会看到很多改进和优化的空间…确实，这个管理器非常慢，且占用内存，它保持一个
    `std::vector<bool>` 对象，其中每个 `bool` 值指示内存块中的字节是否已被占用，并且每当有分配请求时，都会在这个容器中进行简单的线性搜索（此外，它不是线程安全的，这是不好的！）。我们将在
    [*第10章*](B21071_10.xhtml#_idTextAnchor153) 中检查一些实现质量的考虑因素，但没有任何阻止你在同时期将 `shared_mem_mgr`
    改进得更好的事情。
- en: 'You will notice that `shared_mem_mgr` has been expressed as an RAII type: its
    constructor creates a shared memory segment, its destructor frees that memory
    segment, and the `shared_mem_mgr` type has been made uncopiable as is often the
    case for RAII types. The key member functions to look at in the following code
    excerpt are `allocate()` and `deallocate()`; the former tries to allocate a block
    from the shared memory segment and notes that this has been done, whereas the
    latter frees the memory associated with an address within the block:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到 `shared_mem_mgr` 被表达为一个 RAII 类型：它的构造函数创建一个共享内存段，它的析构函数释放该内存段，并且 `shared_mem_mgr`
    类型已经被设置为不可复制的，这在 RAII 类型中很常见。在下面的代码摘录中，需要查看的关键成员函数是 `allocate()` 和 `deallocate()`；前者尝试从共享内存段分配一个块并记录这一行为，而后者释放与块内地址关联的内存：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, `shared_mem_mgr` really is a class that manages a chunk of memory,
    and there is no magic involved. Should someone want to improve the memory management
    algorithms, one could do so without touching the interface of this class, benefiting
    from the low coupling that stems from encapsulation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`shared_mem_mgr` 确实是一个管理内存块段的类，其中并不涉及任何魔法。如果有人想要改进内存管理算法，他们可以在不触及这个类的接口的情况下做到这一点，从而受益于封装带来的低耦合。
- en: If you want to play…
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想玩…
- en: One interesting way to refine `shared_mem_mgr` would be to first make this class
    responsible for allocating and freeing the shared memory, as it already does,
    then write a different class to manage the memory within that shared memory block,
    and finally, make them work together. This way, one could use `shared_mem_mgr`
    with different memory management algorithms and pick management strategies based
    on the needs of individual programs, or sections thereof. Something to try if
    you want to have fun!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一种有趣的改进 `shared_mem_mgr` 的方法可能是首先让这个类负责分配和释放共享内存，正如它已经做的那样，然后编写一个不同的类来管理该共享内存块内的内存，最后使它们协同工作。这样，人们可以使用
    `shared_mem_mgr` 与不同的内存管理算法，并根据个别程序或其部分的需求选择管理策略。如果你想要找些乐子，这是一个可以尝试的方法！
- en: 'The next step is to implement the allocation operator overloads that take an
    argument of type `shared_mem_mgr&`. This is essentially trivial since all these
    overloads need to do is delegate the work to the manager:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是实现接受 `shared_mem_mgr&` 类型参数的分配运算符重载。这基本上是微不足道的，因为这些重载只需要将工作委托给管理器：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Equipped with our manager and these overloads, we can write our test program
    that performs the same task as the “handmade” one from the previous section. In
    this case, however, there are some differences:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 配备了我们的管理器和这些重载，我们可以编写我们的测试程序，该程序执行与上一节中“手工”相同的任务。然而，在这种情况下，有一些不同之处：
- en: We do not need to manage the shared memory segment’s creation and destruction.
    These tasks are handled by the `shared_mem_mgr` object as part of its implementation
    of the RAII idiom.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不需要管理共享内存段的创建和销毁。这些任务由 `shared_mem_mgr` 对象作为其实现 RAII 习语的组成部分来处理。
- en: We do not need to manage the shared memory block at all, as this task is assigned
    to the `shared_mem_mgr` object. Finding a location in the block to put an object,
    tracking how the block is being used for objects, ensuring that it’s possible
    to distinguish used areas from unused ones, and so on are all part of that class’s
    responsibilities.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们根本不需要管理共享内存块，因为这个任务分配给了`shared_mem_mgr`对象。在块中找到一个放置对象的位置，跟踪块如何被对象使用，确保可以区分已使用区域和未使用区域，等等，这些都是该类职责的一部分。
- en: As a corollary, in the “handmade” version, we constructed an object at the beginning
    of the shared memory block and stated that it would be a burden on user code to
    construct more objects or manage the shared memory segment to take into account
    numerous calls to the `new` and `delete` operators, but in this implementation,
    we can freely call `new` and `delete` as much as we want since this memory management
    becomes transparent to client code.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为推论，在“手工”版本中，我们在共享内存块的开始处构建了一个对象，并指出构建更多对象或管理共享内存段以考虑对`new`和`delete`操作符的多次调用将给用户代码带来负担，但在这个实现中，我们可以自由地调用`new`和`delete`，因为我们希望这种内存管理对客户端代码来说是透明的。
- en: 'The construction aspect of objects in atypical memory is rather easy: just
    pass the additional argument in the call to the `new` and `new[]`operators. The
    finalization part of objects managed through a manager such as this is slightly
    more complex though: we cannot write the equivalent of `delete p` on our pointers
    as this would try to finalize the object *and* deallocate the memory through “normal”
    means. Instead, we need to manually finalize the objects, and then manually call
    the appropriate version of the `operator delete()` function in order to do the
    exotic memory cleanup tasks. Of course, given what we have written in [*Chapter
    6*](B21071_06.xhtml#_idTextAnchor096), you could encapsulate these tasks in a
    smart pointer of your own to get simpler and safer user code.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在非典型内存中构建对象方面，相当简单：只需在调用`new`和`new[]`操作符时传递额外的参数即可。然而，通过此类经理对象管理的对象的最终化部分则稍微复杂一些：我们不能在我们的指针上写`delete
    p`这样的代码，因为这会尝试最终化对象并通过“正常”方式释放内存。相反，我们需要手动最终化对象，然后手动调用适当的`operator delete()`函数版本，以执行异构的内存清理任务。当然，鉴于我们在[*第6章*](B21071_06.xhtml#_idTextAnchor096)中写的内容，你可以将这些任务封装在你自己的智能指针中，以获得更简单、更安全的用户代码。
- en: 'We end up with the following example program:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终得到了以下示例程序：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is still not a trivial example, but the memory management aspect is clearly
    simpler than in the “handmade” version, and the compartmentalization of tasks
    makes it easier to optimize the way in which memory is managed.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然不是一个简单的例子，但内存管理方面显然比“手工”版本简单，任务的模块化使得优化内存管理方式变得更容易。
- en: And… we’re done. Whew! That was quite the ride, once more!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后……我们就完成了。呼！这真是一次相当刺激的旅程，又一次！
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter explored various ways in which one can use the C++ memory management
    facilities in unusual ways: mapping objects onto memory-mapped hardware, integrating
    basic forms of error handling with the `nothrow` version of `operator new()`,
    reacting to out-of-memory situations with a `std::exception_handler`, and accessing
    atypical memory with non-portable services through a specialization of the “normal”
    allocation operator and a manager object. This gives us a broader overview of
    memory management facilities in C++ and how one can use them to one’s advantage.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了各种使用C++内存管理设施的特殊方式：将对象映射到内存映射硬件上，将基本的错误处理与`nothrow`版本的`operator new()`集成，使用`std::exception_handler`来应对内存不足的情况，以及通过“正常”分配操作符和经理对象的专业化来访问非典型内存。这为我们提供了对C++内存管理设施的更广泛概述，以及如何利用它们来发挥优势。
- en: 'One thing we have mentioned but not yet discussed is optimization: how to make
    memory allocation and memory allocation fast, blazingly fast even, and deterministic
    in terms of execution speed when some conditions are met. This is what we will
    do in [*Chapter 10*](B21071_10.xhtml#_idTextAnchor153) when explaining how to
    write arena-based allocation code.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到过但尚未讨论的一件事是优化：如何在满足某些条件时使内存分配和内存释放变得快速，甚至非常快，并且在执行速度方面是确定的。这就是我们在[*第10章*](B21071_10.xhtml#_idTextAnchor153)中解释如何编写基于竞技场的分配代码时将要做的。
- en: Oh, and as a bonus, we will kill Orcs.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，而且作为额外奖励，我们将消灭奥克瑞斯。
- en: Orcs? What are you talking about?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 奥克瑞斯？你在说什么？
- en: Orcs are fictional creatures found in numerous works of fictional fantasy, usually
    mean beasts used as foes and that have an unhealthy relation to Elves, another
    kind of fictional creature that often has a better reputation. As your friendly
    author has worked a lot with game programmers over the last few decades, Orcs
    tend to appear in his examples and will be central to the code we write in [*Chapter
    10*](B21071_10.xhtml#_idTextAnchor153).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 兽人是一种虚构的生物，出现在众多虚构幻想作品中，通常被用作敌人，与精灵（另一种虚构生物，通常有更好的声誉）有不健康的关联。由于你的友好作者在过去几十年里与游戏程序员合作了很多，兽人往往会出现在他的例子中，并且将是我们在[*第10章*](B21071_10.xhtml#_idTextAnchor153)中编写的代码的核心。
- en: Sounds good? Then, on to the next chapter!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来不错吗？那么，接下来是下一章！
