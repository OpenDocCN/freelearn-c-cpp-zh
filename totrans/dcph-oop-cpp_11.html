<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-191"><a id="_idTextAnchor488"/>11</h1>
<h1 id="_idParaDest-192"><a id="_idTextAnchor489"/>Handling Exceptions</h1>
<p>This chapter will begin our quest to expand your C++ programming repertoire beyond OOP concepts, with the goal of enabling you to write more robust and extensible code. We will begin this endeavor by exploring exception handling in C++. Adding language-prescribed methods in our code to handle errors will allow us to achieve less buggy and more reliable programs. By using the formal exception handling mechanisms <em class="italic">built into the language</em>, we can achieve a uniform handling of errors, which leads to more easily maintainable code. </p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>Understanding exception handling basics – <code>try</code>, <code>throw</code>, and <code>catch</code></li>
<li>Exploring exception handling mechanics – trying code that may raise exceptions, raising (throwing), catching, and handling exceptions using several variations</li>
<li>Utilizing exception hierarchies with standard exception objects or by creating customized exception classes</li>
</ul>
<p>By the end of this chapter, you will understand how to utilize exception handling in C++. You will see how to identify an error to raise an exception, transfer control of the program to a designated area by throwing an exception, and then handle the error by catching the exception and hopefully repairing the problem at hand. </p>
<p>You will also learn how to utilize standard exceptions from the C++ Standard Library, as well as create customized exception objects. A hierarchy of exception classes can be designed to add robust error detection and handling capabilities.</p>
<p>Let’s increase our understanding of C++ by expanding our programming repertoire by exploring the built-in language mechanisms of exception handling.</p>
<h1 id="_idParaDest-193"><a id="_idTextAnchor490"/>Technical requirements</h1>
<p>Online code for full program examples can be found in the following GitHub URL: <a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter11">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter11</a>. Each full program example can be found in the GitHub under the appropriate chapter heading (subdirectory) in a file that corresponds to the chapter number, followed by a dash, followed by the example number in the chapter at hand. For example, the first full program in this chapter can be found in the subdirectory <code>Chapter11</code> in a file named <code>Chp11-Ex1.cpp</code> under the aforementioned GitHub directory.</p>
<p>The CiA video for this chapter can be viewed at: <a href="https://bit.ly/3QZi638">https://bit.ly/3QZi638</a>.</p>
<h1 id="_idParaDest-194"><a id="_idTextAnchor491"/><a id="_idTextAnchor492"/>Understanding exception handling</h1>
<p>Error conditions <a id="_idIndexMarker760"/>may occur within an application that would prevent a program from continuing correctly. Such error conditions may include data values that exceed application limits, necessary input files or databases have become unavailable, heap memory has become exhausted, or any other imaginable issue. C++ exceptions provide a uniform, language-supported manner for handling program anomalies.</p>
<p>Prior to the introduction of language supported exception handling mechanisms, each programmer would handle errors in their own manner, and sometimes not at all. Program errors and exceptions that are not handled imply that somewhere further in the application, an unexpected result will occur and the application will most often terminate abnormally. These potential outcomes are certainly undesirable!</p>
<p>C++ <strong class="bold">exception handling</strong> provides a language supported mechanism to detect and correct program anomalies so that an application can remain running, rather than ending abruptly.</p>
<p>Let’s take a look at the mechanics, starting with the language supported keywords <code>try</code>, <code>throw</code>, and <code>catch</code>, which comprise exception handling in C++.<a id="_idTextAnchor493"/></p>
<h2 id="_idParaDest-195"><a id="_idTextAnchor494"/>Utilizing exception handling with try, throw, and catch</h2>
<p><strong class="bold">Exception handling</strong> detects <a id="_idIndexMarker761"/>a program <a id="_idIndexMarker762"/>anomaly, as<a id="_idIndexMarker763"/> defined by the programmer or by a class library, and passes control to another portion of the application where the specific problem may be handled. Only as a last resort will it be necessary to exit an application.</p>
<p>Let’s begin by taking a look at the keywords that support exception handling. The keywords are as foll<a id="_idTextAnchor495"/>ows:</p>
<ul>
<li><code>try</code>: Allows programmers to <em class="italic">try</em> a portion of code that might cause an exception. </li>
<li><code>throw</code>: Once an error is found, <code>throw</code> raises the exception. This will cause a jump to the catch block below the associated try block; <code>throw</code> will allow an argument to be returned to the associated catch block. The argument thrown may be of any standard or user defined type.</li>
<li><code>catch</code>: Designates a block of code designed to seek exceptions that have been thrown, to attempt to correct the situation. Each catch block in the same scope will handle an exception of a different type.</li>
</ul>
<p>When utilizing exception handling, it is useful to review the idea of backtracking. When a sequence of functions is called, we build up, on the stack, state information applicable to each successive function call (parameters, local variables, and return value space), as well as the return address for each function. When an exception is thrown, we may need to unwind the stack to the point of origination where this sequence of function calls (or try blocks) began, resetting the stack pointer as well. This process is known as <strong class="bold">backtracking</strong> and <a id="_idIndexMarker764"/>allows a program <a id="_idIndexMarker765"/>to <a id="_idIndexMarker766"/>return to an earlier sequence in the code. Backtracking applies not only to function calls but to nested blocks including nested try blocks.</p>
<p>Here is a simple example to illustrate basic exception handling syntax and usage. Though portions of the code are not shown to save space, the complete example can be found in our GitHub as f<a id="_idTextAnchor496"/>ollows:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex1.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex1.cpp</a></p>
<pre class="source-code">
// Assume Student class is as seen before, but with one
// additional virtual mbr function. Assume usual headers.
void Student::Validate() // defined as <strong class="bold">virtual</strong> in class def
{                        // so derived classes may override
    // check constructed Student; see if standards are<a id="_idTextAnchor497"/> met
    // if not, throw an exception
    <strong class="bold">throw string("Does not meet prerequisites");</strong>
}
int main()
{
    Student s1("Sara", "Lin", 'B', "Dr.", 3.9,
               "C++", "23PSU");
    <strong class="bold">try</strong>      // Let's 'try' this block of code -- 
    {        // Validate() may raise an exception
        s1.Validate(); // does s1 meet admission standards?
    }
    <strong class="bold">catch (const string &amp;err)</strong> 
    {
        cout &lt;&lt; err &lt;&lt; endl;
        // try to fix problem here…
        exit(1); // only if you can't fix error, 
    }            // exit as gracefully as possible
    cout &lt;&lt; "Moving onward with remainder of code.";
    cout &lt;&lt; endl;
    return 0;
}</pre>
<p>In the previous code fragment, we can see the keywords <code>try</code>, <code>throw</code>, and <code>catch</code> in action. First, let’s notice the <code>Student::Validate()</code> member function. Imagine, in this virtual method, we verify that a <code>Student</code> meets admission standards. If so, the function ends normally. If not, an exception is thrown. In this example, a simple <code>string</code> is thrown encapsulating the message <code>"Does not meet prerequisites"</code>. </p>
<p>In our <code>main()</code> function, we first instantiate a <code>Student</code>, namely <code>s1</code>. Then, we nest our call to <code>s1.Validate()</code> within a try block. We are literally saying that we’d like to <em class="italic">try</em> this block of code. Should <code>Student::Validate()</code> work as expected, error-free, our program completes the try block, skips the catch block(s) below the try block, and merely continues with the code below any catch blocks. </p>
<p>However, should <code>Student::Validate()</code> throw an exception, we will skip any remaining code in our try block and seek an exception matching the type of <code>const string &amp;</code> in a subsequently defined catch block. Here, in the matching catch block, our goal is to correct the error if at all possible. If we are successful, our program will continue with<a id="_idIndexMarker767"/> the <a id="_idIndexMarker768"/>code <a id="_idIndexMarker769"/>below the catcher. If not, our job is to end the program gracefully. </p>
<p>Let’s look at the output for the aforementioned program: </p>
<pre>Student does not meet prerequisites </pre>
<p>Next, let us summarize the overall flow of exception handling with the following logistics:</p>
<ul>
<li>When a program completes a try block without encountering any thrown exceptions, the code sequence continues with the statement following the catch block. Multiple catch blocks (with different argument types) may follow a try block.</li>
<li>When an exception is thrown, the program must backtrack and return to the try block containing the originating function call. The program may have to backtrack past multiple functions. When backtracking occurs, the objects encountered on the stack will be popped off, and hence destructed.</li>
<li>Once a program (with an exception raised) backtracks to the function where the try block was executed, the program will continue with the catch block (following the try block) whose signature matches the type of the exception that was thrown.</li>
<li>Type conversion (with the exception of upcasting objects related through public inheritance) will not be done to match potential catch blocks. However, a catch block with ellipses (<code>…</code>) may be used as the most general type of catch block and can catch any type of exception.</li>
<li>If a matching catch block does not exist, the program will call <code>terminate()</code> from the C++ Standard Library. Note that <code>terminate()</code> will call <code>abort()</code>; however, the programmer may instead register another function for <code>terminate()</code> to call via the <code>set_terminate()</code> function.</li>
</ul>
<p>Now, let’s see how to register a function with <code>set_terminate()</code>. Though we only show key portions <a id="_idIndexMarker770"/>of<a id="_idIndexMarker771"/> the <a id="_idIndexMarker772"/>code here, the complete program can be found in our GitHub:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex2.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex2.cpp</a></p>
<pre class="source-code">
void AppSpecificTerminate()
{   // first, do what's necessary to end program gracefully
    cout &lt;&lt; "Uncaught exception. Program terminating";
    cout &lt;&lt; endl;
    exit(1);
}
int main()
{   
    <strong class="bold">set_terminate</strong>(AppSpecificTerminate);  // register fn.
    return 0;
}</pre>
<p>In the previous code fragment, we define our own <code>AppSpecificTerminate()</code> function. This is the function we wish to have the <code>terminate()</code> function call rather than its default behavior of calling <code>abort()</code>. Perhaps we use <code>AppSpecificTerminate()</code> to end our application a bit more gracefully, saving key data structures or database values. Of course, we would also then <code>exit()</code> (or <code>abort()</code>) ourselves.</p>
<p>In <code>main()</code>, we merely call <code>set_terminate(AppSpecificTerminate)</code> to register our terminate function with <code>set_terminate()</code>. Now, when <code>abort()</code> would otherwise be called, our function will be called instead. </p>
<p>It is interesting to note that <code>set_terminate()</code> returns a function pointer to the previously installed <code>terminate_handler</code> (which upon its first call will be a pointer to <code>abort()</code>). Should we choose to save this value, we can use it to reinstate previously registered terminate handlers. Notice that we have not opted to save this function pointer in this example.</p>
<p>Here is what <a id="_idIndexMarker773"/>the <a id="_idIndexMarker774"/>output <a id="_idIndexMarker775"/>would look like for an uncaught exception using the aforementioned code:</p>
<pre>Uncaught exception. Prog<a id="_idTextAnchor498"/>ram terminating</pre>
<p>Keep in mind that functions such as <code>terminate()</code>, <code>abort()</code>, and <code>set_terminate()</code> are from the Standard Library. Though we may precede their names with the library name using the scope resolution operator, such as <code>std::terminate()</code>, this is not necessary.</p>
<p class="callout-heading">Note</p>
<p class="callout">Exception handling is not meant to take the place of simple programmer error checking; exception handling has greater overhead. Exception handling should be reserved to handle more severe programmatic errors in a uniform manner and in a c<a id="_idTextAnchor499"/>ommon location.</p>
<p>Now that we have seen the basic mechanics for exception handling, let’s take a look at slightly more complex exception handling examples. </p>
<h2 id="_idParaDest-196"><a id="_idTextAnchor500"/>Exploring exception handling mechanics with typical variations</h2>
<p>Exception<a id="_idIndexMarker776"/> handling <a id="_idIndexMarker777"/>can be more sophisticated and flexible than the basic mechanics previously illustrated. Let’s take a look at various combinations and variations of exception handling basics, as each may be applicable to different programming situations.</p>
<h3>Passing exceptions to outer handlers</h3>
<p>Caught exceptions <a id="_idIndexMarker778"/>may be passed up to outer handlers for processing. Alternatively, exceptions may be partially handled and then thrown to outer scopes for further handling. </p>
<p>Let’s build on our previous example to demonstrate this principle. The full program can be seen in the following GitHub directory:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex3.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex3.cpp</a></p>
<pre class="source-code">
// Assume Student class is as seen before, but with
// two additional member fns. Assume usual header files.
void Student::Validate() // defined as <strong class="bold">virtual</strong> in class def
{                        // so derived classes may override
    // check constructed student; see if standards are met
    // if not, throw an exception
    <strong class="bold">throw string("Does not meet prerequisites");</strong>
}
bool Student::TakePrerequisites()  
{
    // Assume this function can correct the issue at hand
    // if not, it returns false
    return false;
}
int main()
{
    Student s1("Alex", "Ren", 'Z', "Dr.", 3.9, 
               "C++", "89CU");
    <strong class="bold">try</strong>    // illustrates a nested try block 
    {   
        // Assume another important task occurred in this
        // scope, which may have also raised an exception
        <strong class="bold">try</strong>
        {   
            s1.Validate();  // may raise an exception
        }
        <strong class="bold">catch (const string &amp;err)</strong>
        {
            cout &lt;&lt; err &lt;&lt; endl;
            // try to correct (or partially handle) error.
            // If you cannot, pass exception to outer scope
            if (!s1.TakePrerequisites())
                <strong class="bold">throw;</strong>    // re-throw the exception
        }
    }
    <strong class="bold">catch (const string &amp;err)</strong> // outer scope catcher 
    {                         // (e.g. handler)
        cout &lt;&lt; err &lt;&lt; endl;
        // try to fix problem here…
        exit(1); // only if you can't fix, exit gracefully
<a id="_idTextAnchor501"/>    } 
    cout &lt;&lt; "Moving onward with remainder of code. ";
    cout &lt;&lt; endl;
    return 0;
}</pre>
<p>In the aforementioned code, let’s assume that we have our usual header files included and the usual class definition for <code>Student</code> defined. We will now augment the <code>Student</code> class by adding the <code>Student::Validate()</code> method (virtual, so that it may be overridden) and the <code>Student::TakePrerequisites()</code> method (not virtual, descendants should use it as-is). </p>
<p>Notice that our <code>Student::Validate()</code> method throws an exception, which is merely a string literal containing a message indicating the issue at hand. We can imagine the complete<a id="_idIndexMarker779"/> im<a id="_idTextAnchor502"/>plementation of the <code>Student::TakePrerequisites()</code> method verifies that the <code>Student</code> has met the appropriate prerequisites, and returns a boolean value of <code>true</code> or <code>false</code> accordingly.</p>
<p>In our <code>main()</code> function, we now notice a set of nested try blocks. The purpose here is to illustrate an inner try block that may call a method, such as <code>s1.Validate()</code>, which may raise an exception. Notice that the same level handler as the inner try block catches this exception. Ideally, an exception is handled at the level equal to the try block from which it originates, so let’s assume that the catcher in this scope tries to do so. For example, our innermost catch block presumably tries to correct the error and tests whether the correction has been made using a call to <code>s1.TakePrerequisites()</code>.</p>
<p>But perhaps this catcher is only able to process the exception partially. Perhaps there is the knowledge that an outer level handler knows how to do the remaining corrections. In such cases, it is acceptable to re-throw this exception to an outer (nested) level. Our simple <code>throw;</code> statement in the innermost catch block does just this. Notice that there is a catcher at the outer level. Should the thrown exception match, type-wise, this outer level will now have the opportunity to further handle the exception and hopefully correct the problem so that the application can continue. Only if this outer catch block is unable to correct the error should the application be exited. In our example, each catcher prints out the string representing the error message; therefore, this message occurs t<a id="_idTextAnchor503"/>wice in the output.</p>
<p>Let’s look at the output for the aforementioned program: </p>
<pre>Student does not meet prerequisites
Student does not meet prerequisites</pre>
<p>Now that we have seen how to use nested try and catch blocks, let us move forward to see how a variety<a id="_idIndexMarker780"/> of thrown types and a variety of catch blocks can be used together.</p>
<h3>Adding an assortment of handlers</h3>
<p>Sometimes, a <a id="_idIndexMarker781"/>variety of exceptions may be raised from an inner scope, creating the necessity to craft handlers for a variety of data types. Exception handlers (that is, catch blocks) can receive an exception of any data type. We can minimize the number of catchers we introduce by utilizing catch blocks with base class types; we know that derived class objects (related through public inheritance) can always be upcast to their base class type. We can also use the ellipses (<code>…</code>) in a catch block to allow us to catch anything not previously specified.</p>
<p>Let’s build on our initial example to illustrate assorted handlers in action. Though abbreviated, our full program example can be found in our GitHub as follows:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex4.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex4.cpp</a></p>
<pre class="source-code">
// Assume Student class is as seen before, but with one
// additional virtual member function, Graduate(). Assume 
// a simple Course class exists. All headers are as usual.
void Student::Graduate()
{   // Assume the below if statements are fully implemented 
    if (gpa &lt; 2.0) // if gpa doesn't meet requirements
        <strong class="bold">throw gpa;</strong>
    // if Student is short credits, throw number missing
        <strong class="bold">throw numCreditsMissing;</strong>  // assume this is an int
    // or if Student is missing a Course, construct, then
    // throw the missing Course as a referenceable object
    // Assume appropriate Course constructor exists
        <strong class="bold">throw Course("Intro. To Programming", 1234);</strong> 
    // or if another issue, throw a diagnostic message
        <strong class="bold">throw string("Does not meet requirements");</strong> 
}
int ma<a id="_idTextAnchor504"/>in()
{
    Student s1("Ling", "Mau", 'I', "Ms.", 3.1, 
               "C++", "55UD");
    <strong class="bold">try</strong>  
    {  
        s1.Graduate();
    }
    <strong class="bold">catch (f<a id="_idTextAnchor505"/>loat err)</strong>
    {
        cout &lt;&lt; "Too low gpa: " &lt;&lt; err &lt;&lt; endl;
        exit(1); // only if you can't fix, exit gracefully
    } 
    <strong class="bold">catch (int err)</strong>
    {
        cout &lt;&lt; "Missing " &lt;&lt; err &lt;&lt; " credits" &lt;&lt; endl;
        exit(2);
    }
    <strong class="bold">catch (const Course &amp;err)</strong>
    {
        cout &lt;&lt; "Need to take: " &lt;&lt; err.GetTitle() &lt;&lt; endl;
        cout &lt;&lt; "Course #: " &lt;&lt; err.GetCourseNum() &lt;&lt; endl; 
        // Ideally, correct the error, and continue program 
        exit(3); // Otherwise, exit, gracefully if possible
    }             
    <strong class="bold">catch (const string &amp;err)</strong>
    {
        cout &lt;&lt; err &lt;&lt; endl;
        exit(4); 
    }
    <strong class="bold">catch (...)</strong>
    {
        cout &lt;&lt; "Exiting" &lt;&lt; endl;
        exit(5);
    }
    cout &lt;&lt; "Moving onward with remainder of code.";
    cout &lt;&lt; endl;
    return 0;
}</pre>
<p>In the aforementioned segment of code, we first examine the <code>Student::Graduate()</code> member function. Here, we can imagine that this method runs through many graduation requirements, and as such, can potentially raise a variety of different types of exceptions. For example, should the <code>Student</code> instance have too low of a <code>gpa</code>, a float is thrown as the exception, indicating the student’s poor <code>gpa</code>. Should the <code>Student</code> have too few credits, an integer is thrown, indicating how many credits the <code>Student</code> still needs to earn their degree. </p>
<p>Perhaps the most interesting potential error that <code>Student::Graduate()</code> might raise would be if a required <code>Course</code> is missing from a student’s graduation requirements. In this scenario, <code>Student::Graduate()</code> would instantiate a new <code>Course</code> object, filling it with the <code>Course</code> name and number via construction. This anonymous object would then be thrown from <code>Student::Graduate()</code>, much as an anonymous <code>string</code> object<a id="_idIndexMarker782"/> may be alternatively thrown in this method. The handler may then catch the <code>Course</code> (or <code>string</code>) object by reference. </p>
<p>In the <code>main()</code> function, we merely wrap the call to <code>Student::Graduate()</code> within a try block, as this statement may raise an exception. A sequence of catchers follows the try block – one <code>catch</code> statement per type of object that may be thrown. The last catch block in this sequence uses ellipses (<code>…</code>), indicating that this catcher will handle any other type of exception thrown by <code>Student::Graduate()</code> that has not been caught by the other catchers. </p>
<p>The catch block that is actually engaged is the one in which a <code>Course</code> is caught using <code>const Course &amp;err</code>. With the <code>const</code> qualifier, we may not modify the <code>Course</code> in the handler, so we may only apply <code>const</code> member functions to this object.</p>
<p>Note that though each earlier catcher shown merely prints out an error and then exits, ideally, a catcher would try to correct the error so that the application would not need to terminate, allowing code below the catch blocks to continue onward.</p>
<p>Let’s look at the output for the aforementioned program: </p>
<pre>Need to take: Intro. to Programming
Course #: 1234</pre>
<p>Now that we have seen a variety of thrown types and a variety of catch blocks, let us move forward<a id="_idIndexMarker783"/> to understand what we should group together wit<a id="_idTextAnchor506"/>hin a single try block.</p>
<h3>Grouping together dependent items within a try block</h3>
<p>It is important<a id="_idIndexMarker784"/> to<a id="_idIndexMarker785"/> remember that when a line of code in a try block encounters an exception, the remainder of the try block is ignored. Instead, the program continues with a matching catcher (or calls <code>terminate()</code> if no suitable catcher exists). Then, if the error is repaired, the code beyond the catcher commences. Note that we never return to complete the remainder of the initial try block. The implication of this behavior is that you should only group together elements within a try block that go together. That is, if one item causes an exception, it is no longer important to complete the other item in that grouping.</p>
<p>Keep in mind that the goal of a catcher is to correct an error if at all possible. This means that the program may continue forward after the applicable catch block. You may ask: Is it now acceptable that an item was skipped in the associated try block? Should the answer be no, then rewrite your code. For example, you may want to add a loop around the <code>try</code>-<code>catch</code> grouping such that if an error is corrected by a catcher, the whole enterprise is retried starting with the initial try block. </p>
<p>Alternatively, make smaller, successive <code>try</code>-<code>catch</code> groupings. That is, <em class="italic">try</em> only one important task in its own try block (followed by applicable catchers). Then <em class="italic">try</em> the next task in its own try block with its associated catchers and so on.</p>
<p>Next, let’s take a look at a way to include in a function’s prototype the type of<a id="_idTextAnchor507"/> exceptions it may throw.</p>
<h3>Examining exception specifications in function prototypes</h3>
<p>We can<a id="_idIndexMarker786"/> optionally<a id="_idIndexMarker787"/> specify the types of exceptions a C++ function may throw by extending the signature of that function to include the object types of what may be thrown. However, because a function may throw more than one type of exception (or none at all), checking which type is actually thrown must be done at runtime. For this reason, these augmented specifiers in the function prototype are also known as <code>noexcept</code> specifier, which we’ll see shortly. Uses of dynamic exceptions also occur in existing code bases and libraries, so let’s briefly examine its usage.</p>
<p>Let’s see an example using exception types in the exte<a id="_idTextAnchor508"/>nded signature of a function:</p>
<pre class="source-code">
void Student::Graduate() <strong class="bold">throw(float, int, </strong>
<strong class="bold">                               Course &amp;, string)</strong>
{
   // this method might throw any type included in 
   // its extended signature
}
void Student::Enroll() <strong class="bold">throw()</strong>
{
   // this method might throw any type of exception
}</pre>
<p>In the aforementioned<a id="_idIndexMarker789"/> code<a id="_idIndexMarker790"/> fragment, we see two member functions of <code>Student</code>. <code>Student::Graduate()</code> includes the <code>throw</code> keyword after its parameter list and then, as part of this method’s extended signature, includes the types of objects that may be thrown from this function. Notice that the <code>Student::Enroll()</code> method merely has an empty list following <code>throw()</code> in its extended signature. This means that <code>Student::Enroll()</code> might throw any type of exception.</p>
<p>In both cases, by adding the <code>throw()</code> keyword with optional data types to the signature, we are providing a means to announce to the user of this function what types of objects might be thrown. We are then asking programmers to include any calls to this method within a try block followed by appropriate catchers.</p>
<p>We will see that though the idea of an extended signature seems very helpful, it has unfavorable issues in practice. For this reason, dynamic exception specifications have been <em class="italic">deprecated</em>. Because you may still see these specifications used in existing code, including Standard Library prototypes (such as with exceptions), this deprecated feature is still supported by compilers, and you will need to understand their usage. </p>
<p>Though dynamic exceptions (extended function signatures as previously described) have been deprecated, a specifier with a similar purpose has been added to the language, the <code>noexcept</code> keyword.</p>
<p> This specifier can be added after the extended signature as follows:</p>
<pre class="source-code">
void Student::Graduate() <strong class="bold">noexcept</strong>   // will not throw() 
{          // same as  <strong class="bold">noexcept(true)</strong> in extended signature
}          // same as deprecated <strong class="bold">throw()</strong> in ext. signature
void Student::Enroll() <strong class="bold">noexcept(false)</strong>  // may throw()
{                                       // an exception
}                                     </pre>
<p>Nonetheless, let’s <a id="_idIndexMarker791"/>investigate<a id="_idIndexMarker792"/> why unfavorable issues exist relating to dynamic exceptions by looking at what happens when our application throws exceptions that are not part of a function’s extended signature.</p>
<h3>Dealing with unexpected types of dynamic exceptions </h3>
<p>Should<a id="_idIndexMarker793"/> an <a id="_idIndexMarker794"/>exception be thrown of a type other than that specified in the extended function prototype, <code>unexpected()</code>, from the C++ Standard Library, will be called. You can register your own function with <code>unexpected()</code>, much as we registered our own function with <code>set_terminate()</code> earlier in<a id="_idTextAnchor509"/> this chapter. </p>
<p>You can allow your <code>AppSpecificUnexpected()</code> function to rethrow an exception of the type that the originating function should have thrown; however, if that does not occur, <code>terminate()</code> will then be called. Furthermore, if no possible matching catcher exists to handle what is correctly thrown from the originating function (or rethrown by <code>AppSpecificUnexpected()</code>), then <code>terminate()</code> will be called.</p>
<p>Let’s see how to use <code>set_unexpected()</code> with our own function:</p>
<pre class="source-code">
void AppSpecificUnexpected()
{
    cout &lt;&lt; "An unexpected type was thrown" &lt;&lt; endl;
    // optionally re-throw the correct type, or
    // terminate() will be called.
}
int main()
{
   <strong class="bold">set_unexpected</strong>(AppSpecificUnexpected)
}</pre>
<p>Registering our own function with <code>set_unexpected()</code> is very simple, as illustrated in the aforementioned code fragment. </p>
<p>Historically, one motivating reason for employing exception specification in a function’s extended signature was to provide a documentative effect. That is, you could see which exceptions a function might possibly throw simply by examining its signature. You could then plan to enclose that function call within a try block and provide appropriate catchers to handle any potential situation. </p>
<p>Nonetheless, regarding dynamic exceptions, it is useful to note that compilers do not check that<a id="_idIndexMarker795"/> the <a id="_idIndexMarker796"/>types of exceptions <em class="italic">actually</em> thrown in a function body match the types specified in the function’s extended signature. It is up to the programmer to ensure that they are in sync. Therefore, this deprecated feature can be error-prone and, overall, less useful than its original intention. </p>
<p>Though well intended, dynamic exceptions are currently unused, except in large quantities of library code such as the Standard C++ Library. Since you will inevitably utilize these libraries, it is important to understand these anachronisms.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Dynamic exception specifications (that is, the ability to specify exception types in a method’s extended signature) have been <em class="italic">deprecated</em> in C++. This is because compilers are not able to validate their use, which must then be delayed until runtime. Their use, though still supported (many libraries have such specifications), is now deprecated. </p>
<p>Now that we have seen an assortment of exception handling detection, raising, catching, and (hopefully) correction schemes, let’s take a look at how we might create a hierarchy of exception <a id="_idIndexMarker797"/>classes <a id="_idIndexMarker798"/>to add sophistication to our error handling abilities.</p>
<h1 id="_idParaDest-197"><a id="_idTextAnchor510"/>Utilizing exception hierarchies</h1>
<p>Creating a class to <a id="_idIndexMarker799"/>encapsulate the details relating to a program error seems like a useful endeavor. In fact, the C++ Standard Library has created one such generic class, <code>exception</code>, to provide the basis for building an entire hierarchy of useful exception classes.</p>
<p>Let’s take a look at the <code>exception</code> class with its Standard Library descendants, and then how we may<a id="_idTextAnchor511"/> extend <code>exception</code> with our own cl<a id="_idTextAnchor512"/><a id="_idTextAnchor513"/>asses.</p>
<h2 id="_idParaDest-198"><a id="_idTextAnchor514"/>Using standard exception objects</h2>
<p>The <code>&lt;exception&gt;</code> header. The <code>exception</code> class includes virtual<a id="_idTextAnchor515"/> functions with the following signatures: <code>virtual const char *what() const noexcept</code> and <code>virtual const char *what() const throw()</code>. These signatures indicate that derived classes should redefine <code>what()</code> to return a <code>const char *</code> with a description of the error at hand. The <code>const</code> keyword after <code>what()</code> indicates that these are <code>const</code> member functions; they will not change any members of the derived class. The <code>noexcept</code> usage in the first prototype indicates that <code>what()</code> is non-throwing. The <code>throw()</code> in the extended signature of the second prototype indicates that this function may throw any type. The usage of <code>throw()</code> in the second signature is a deprecated anachronism and should not be used in new code.</p>
<p>The <code>std::exception</code> class is the base class of a variety of predefined C++ exception classes, including <code>bad_alloc</code>, <code>bad_cast</code>, <code>bad_exception</code>, <code>bad_function_call</code>, <code>bad_typeid</code>, <code>bad_weak_ptr</code>, <code>logic_error</code>, <code>runtime_error</code>, and nested class <code>ios_base::failure</code>. Many of these derived classes have descendants themselves, adding additional standard exceptions to the predefined hierarchy of exceptions.</p>
<p>Should a function throw any of the aforementioned exceptions, these exceptions may be caught by either catching the base class type, <code>exception</code>, or by catching an individual derived class type. Depending on what course of action your handler will take, you can decide whether you wish to catch one such exception as its generalized base class type or as its specific type.</p>
<p>Just as the Standard <a id="_idIndexMarker802"/>Library has set up a hierarchy of classes <a id="_idIndexMarker803"/>based on the <code>exception</code> class, so may you. Let’s next take a look at how we might do just this!</p>
<h2 id="_idParaDest-199"><a id="_idTextAnchor516"/>Creating customized exception classes</h2>
<p>As a programmer, you<a id="_idIndexMarker804"/> may decide that it is advantageous to<a id="_idIndexMarker805"/> establish your own specialized exception types. Each type can pack useful information into an object detailing just what went wrong with the application. Additionally, you may be able to pack clues into the object (which will be thrown) as to how to correct the error at hand. Simply derive your class from the Standard Library <code>exception</code> class. </p>
<p>Let’s take a look at how easily this may be done by examining the critical portions of our next example, which can be found as a full program in our GitHub:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex5.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex5.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
<strong class="bold">#include &lt;exception&gt;</strong>
// See online code for many using std:: inclusions
class StudentException<strong class="bold">: public exception</strong>
{
private:
    int errCode = 0;  // in-class init, will be over-
    // written with bonified value after successful 
    // alternate constructor completion
    string details;
public:
    StudentException(const string &amp;det, int num):
                     errCode(num), details(det) { } 
    // Base class destructor (exception class) is virtual. 
    // Override at this level if there's work to do. 
    // We can omit the default destructor prototype.
    // ~StudentException() override = default;
    <strong class="bold">const char *what() const noexcept override</strong>
    {   // overridden<a id="_idTextAnchor517"/> function from exception class
        return "Student Exception";
    } 
    int GetCode() const { return errCode; }
    const string &amp;GetDetails() const { return details; }
};
// Assume Student class is as we've seen before, but with
// one additional virtual member function, Graduate() 
void Student::Graduate() // fn. may throw StudentException
{
   // if something goes wrong, construct a 
   // StudentException, packing it with relevant data, 
   // and then throw it as a referenceable object
   <strong class="bold">throw StudentException("Missing Credits", 4);</strong>
}
int main()
{
    Student s1("Alexandra", "Doone", 'G', "Miss", 3.95, 
               "C++", "231GWU");
    <strong class="bold">try</strong>
    {
        s1.Graduate();
    }
    <strong class="bold">catch (const StudentException &amp;e)</strong>  // catch exc. by ref
    { 
        cout &lt;&lt; <strong class="bold">e.what()</strong> &lt;&lt; endl;
        cout &lt;&lt; <strong class="bold">e.GetCode()</strong> &lt;&lt; " " &lt;&lt; <strong class="bold">e.GetDetails()</strong>;
        cout &lt;&lt; endl;
        // Grab useful info from e and try to fix problem
        // so that the program can continue.
        exit(1);  // only exit if we can't fix the problem!
    }
    return 0;
}</pre>
<p>Let’s take a few minutes to examine the previous segment of code. Foremost, notice that we define our own exception class, <code>StudentException</code>. It is a derived class from t<a id="_idTextAnchor518"/>he C++ Standard Library <code>exception</code> class. </p>
<p>The <code>StudentException</code> class contains data members to hold an error code as well as alphanumeric details describing the error condition using data members <code>errCode</code> and <code>details</code>, respectively. We have two simple access functions, <code>StudentException::GetCode()</code> and <code>StudentException::GetDetails()</code>, to easily retrieve these values. As these methods do not modify the object, they are <code>const</code> member functions.</p>
<p>We notice that the <code>StudentException</code> constructor initializes the two data members – one through the member initialization list and one in the body of the constructor. We also override the <code>virtual const char *what() const noexcept</code> method (as introduced by the <code>exception</code> class) in our <code>StudentException</code> class to return the string of characters <code>"Student Exception"</code>. </p>
<p>Next, let’s examine our <code>Student::Graduate()</code> method. This method may throw a <code>StudentException</code>. If an exception must be thrown, we instantiate one, constructing it <a id="_idIndexMarker806"/>with <a id="_idIndexMarker807"/>diagnostic data, and then <code>throw</code> the <code>StudentException</code> from this function. Note that the object thrown has no local identifier in this method – there’s no need, as any such local variable name would soon be popped off the stack after the throw occurred.</p>
<p>In our <code>main()</code> function, we wrap our call to <code>s1.Graduate()</code> within a try block, and it is followed by a catch block that accepts a reference (<code>&amp;</code>) to a <code>StudentException</code>, which we treat as <code>const</code>. Here, we first call our overridden <code>what()</code> method and then print out the diagnostic details from within the exception, <code>e</code>. Ideally, we would use this information to try to correct the error at hand and<a id="_idTextAnchor519"/> only exit the application if truly necessary. </p>
<p>Let’s look at the output for the aforementioned program: </p>
<pre>Student Exception
4 Missing Credits</pre>
<p>Though the most usual way to create a customized exception class is to derive a class from the Standard <code>exception</code> class, you may also wish to utilize a different technique, that of an<a id="_idIndexMarker808"/> embedded<a id="_idIndexMarker809"/> exception class.</p>
<h3>Creating a nested exception class</h3>
<p>As an alternative<a id="_idIndexMarker810"/> implementation, exception handling may be embedded into a class by adding a nested class definition in the public access region for a particular outer class. The inner class will represent the customized exception class. </p>
<p>Objects of nested, user defined types may be created and thrown to catchers anticipating such types. These nested classes are built into the public access region of the outer class, making them easily available for derived class usage and specialization. In general, exception classes built into an outer class must be public so that the instances of nested types thrown can be caught and handled outside the scope of the outer class (that is, in the scope where the primary, outer instance exists). </p>
<p>Let’s take a look at this alternate implementation of an exception class by examining key segments of code, which can be found as a full program in our GitHub:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex6.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter11/Chp11-Ex6.cpp</a></p>
<pre class="source-code">
// Assume Student class is as before, but with the addition 
// of a nested exception class. All headers are as usual.
class Student: public Person
{
private:  // assume usual data members
public:   // usual constructors, destructor, and methods
    virtual void Graduate();
    <strong class="bold">class StudentException</strong>   <strong class="bold">// nested exception class</strong>
    <strong class="bold">{</strong>
    <strong class="bold">private:</strong>
        <strong class="bold">int number = 0;</strong>  <strong class="bold">// will be over-written after </strong>
        <strong class="bold">// successful alternate constructor </strong>
<strong class="bold">        // note: there is no default constructor</strong>
    <strong class="bold">public:</strong>
        <strong class="bold">StudentException(int num): number(num) { }</strong>
        <strong class="bold">// Remember, it is unnecessary to proto. default ~</strong>
        <strong class="bold">// ~StudentException() = default;</strong>
        <strong class="bold">int GetNum() const { return number; }</strong>
    <strong class="bold">};</strong>
};
void Student::Graduate()
{   // assume we determine an error and wish to throw
    // the nested exception type
    <strong class="bold">throw StudentException(5);</strong>
}
int main()
{
    Student s1("Ling", "Mau", 'I', "Ms.", 3.1, 
               "C++", "55UD");
    try
    {
        s1.Graduate();
    }
    // following is one of many catch blocks in online code
    <strong class="bold">catch (const Student::StudentException &amp;err)</strong>
    {
        cout &lt;&lt; "Error: " &lt;&lt; <strong class="bold">err.GetNum()</strong> &lt;&lt; endl;
        // If you correct error, continue the program
        exit(5);  // Otherwise, exit application 
    }
    cout &lt;&lt; "Moving onward with remainder of code.";
    cout &lt;&lt; endl;
    return 0;
}</pre>
<p>In the previous code fragments, we expanded our <code>Stude<a id="_idTextAnchor520"/>nt</code> class to include a private, nested class <a id="_idIndexMarker811"/>called <code>StudentException</code>. Though the class shown is overly simplified, the nested class ideally should define a means to catalog the error in question as well as collect any useful diagnostic information.</p>
<p>In our <code>main()</code> function, we instantiate a <code>Student</code>, namely <code>s1</code>. In a try block, we then call <code>s1.Graduate();</code>. Our <code>Student::Graduate()</code> method presumably checks that the <code>Student</code> has met graduation requirements, and if not, throws an exception of the nested class type, <code>Student::StudentException</code> (which will be instantiated as needed).</p>
<p>Notice that our corresponding catch block utilizes scope resolution to specify the inner class type for <code>err</code>, the referenced object (that is, <code>const Student::StudentException &amp;err</code>). Though we ideally would like to correct the program error within the handler, if we cannot, we simply print a message and <code>exit()</code>. </p>
<p>Let’s look at t<a id="_idTextAnchor521"/>he output for the aforementioned program: </p>
<pre>Error: 5</pre>
<p>Understanding how to create our own exception class (both as a nested class or derived from <code>std::exception</code>) is useful. We may additionally wish to create a hierarchy of application-specific <a id="_idIndexMarker812"/>exceptions. Let’s move ahead to see how to do so.</p>
<h2 id="_idParaDest-200"><a id="_idTextAnchor522"/>Creating hierarchies of user defined exception types</h2>
<p>An application <a id="_idIndexMarker813"/>may wish to <a id="_idIndexMarker814"/>define a series of classes that support exception handling to raise specific errors, and hopefully, also provide a means to collect diagnostics for an error so that the error may be addressed in an appropriate segment of the code.</p>
<p>You may wish to create a subhierarchy, derived from the C++ Standard Library <code>exception</code>, of your own exception classes. Be sure to use public inheritance. When utilizing these classes, you will instantiate an object of your desired exception type (filling it with valuable diagnostic information), and then throw that object. </p>
<p>Also, if you create a hierarchy of exception types, your catchers can catch specific derived class types or more general base class types. The option is yours, depending on how you will plan to handle the exception. Keep in mind, however, that if you have a catcher for both the base and derived class types, place the derived class types first – otherwise your thrown object will first match to the base class type catcher without realizing that a more appropriate derived class match is available. </p>
<p>We have now seen both the hierarchy of C++ Standard Library exception classes, as well as how to create and utilize your own exception classes. Let’s now briefly recap the exception features we’ve learned in this chapter, before moving forward to our next chapter.</p>
<h1 id="_idParaDest-201"><a id="_idTextAnchor523"/>Summary</h1>
<p>In this chapter, we have begun expanding our C++ programming repertoire beyond OOP language features to include features that will enable us to write more robust programs. User code can inevitably be error-prone by nature; using language supported exception handling can help us achieve less buggy and more reliable code. </p>
<p>We have seen how to utilize the core exception handling features with <code>try</code>, <code>throw</code>, and <code>catch</code>. We’ve seen a variety of uses of these keywords – throwing exceptions to outer handlers, using an assortment of handlers featuring various types, and selectively grouping program elements together within a single try block, for example. We have seen how to register our own functions with <code>set_terminate()</code> and <code>set_unexpected()</code>. We have seen how to utilize the existing C++ Standard Library <code>exception</code> hierarchy. We have additionally explored defining our own exception classes to extend this hierarchy.</p>
<p>We have added key features to our C++ skills by exploring exception handling mechanisms. We are now ready to move forward to <a href="B19087_12.xhtml#_idTextAnchor526"><em class="italic">Chapter 12</em></a>, <em class="italic">Friends and Operator Overloading</em>, so that we can continue expanding our C++ programming repertoire with useful language features that will ma<a id="_idTextAnchor524"/>ke us better programmers. Let’s move forward!</p>
<h1 id="_idParaDest-202"><a id="_idTextAnchor525"/>Questions</h1>
<ol>
<li>Add exception handling to your previous <code>Student</code> / <code>University</code> exercise from <a href="B19087_10.xhtml#_idTextAnchor454"><em class="italic">Chapter 10</em></a>, <em class="italic">Implementing Association, Aggregation, and Composition</em>, as follows:<ol><li>Should a <code>Student</code> try to enroll in more than the <code>MAX</code> defined number of allowable courses per <code>Student</code>, throw a <code>TooFullSchedule</code> exception. This class may be derived from the Standard Library <code>exception</code> class.</li><li>Should a <code>Student</code> try to enroll in a <code>Course</code> that is already full, have the <code>Course::AddStudent(Student *)</code> method throw a <code>CourseFull</code> exception. This class may be derived from the Standard Library <code>exception</code> class.</li><li>There are many other areas in the <code>Student</code> / <code>University</code> application that could utilize exception handling. Decide which areas should employ simple error checking and which are worthy of exception handling.</li></ol></li>
</ol>
</div>
</div></body></html>