["```cpp\nstruct MeshTriangle {\n  int index;\n  std::array<glm::vec3, 3> points;\n  BoundingBox3D boundingBox;\n}; \n```", "```cpp\n int intersectingChildren = 0;\n    for (int i = 0; i < node->childs.size(); ++i) {\n      BoundingBox3D childBox = getChildOctant(box, i);\n      if (childBox.intersects(triangle.boundingBox)) {\n        intersectingChildren++;\n      }\n    } \n```", "```cpp\n if (intersectingChildren > 1) {\n      node->triangles.emplace_back(triangle);\n    } else {\n      int i = getOctantId(box, triangle.boundingBox);\n      if (i != -1) {\n        add(node->childs.at(i), depth + 1,\n         getChildOctant(box, i), triangle);\n      }\n    } \n```", "```cpp\n if (intersectingChildren > 1) {\n      newTriangles.emplace_back(triangle);\n    } else {\n      int i = getOctantId(box, triangle.boundingBox);\n      if (i != -1) {\n        node->childs.at(i)\n          ->triangles.emplace_back(triangle);\n      }\n    } \n```", "```cpp\nstd::shared_ptr<TriangleOctree> mTriangleOctree = nullptr;\nvoid initTriangleOctree(int thresholdPerBox, int maxDepth);\nvoid generateLevelOctree(); \n```", "```cpp\n int rdLevelOctreeThreshold = 10;\n  int rdLevelOctreeMaxDepth = 5; \n```", "```cpp\nvoid OGLRenderer::initTriangleOctree(int thresholdPerBox,\n  int maxDepth) {\n  mTriangleOctree = std::make_shared<TriangleOctree>(\n    mWorldBoundaries, thresholdPerBox, maxDepth);\n} \n```", "```cpp\n std::vector<OGLMesh> levelMeshes =\n      level->getLevelMeshes();\n      glm::mat4 transformMat =\n        level->getWorldTransformMatrix();\n      glm::mat3 normalMat =\n        level->getNormalTransformMatrix();\n    for (const auto& mesh : levelMeshes) {\n      int index = 0;\n      for (int i = 0; i < mesh.indices.size(); i += 3) { \n```", "```cpp\n MeshTriangle tri{};\n        tri.points.at(0) = transformMat *\n          glm::vec4(glm::vec3(mesh.vertices.at(\n          mesh.indices.at(i)).position), 1.0f);\n        tri.points.at(1) = transformMat *\n          glm::vec4(glm::vec3(mesh.vertices.at(\n          mesh.indices.at(i + 1)).position), 1.0f);\n        tri.points.at(2) = transformMat *\n          glm::vec4(glm::vec3(mesh.vertices.at(\n          mesh.indices.at(i + 2)).position), 1.0f); \n```", "```cpp\n AABB triangleAABB;\n        triangleAABB.clear();\n        triangleAABB.addPoint(tri.points.at(0));\n        triangleAABB.addPoint(tri.points.at(1));\n        triangleAABB.addPoint(tri.points.at(2)); \n```", "```cpp\n tri.boundingBox = BoundingBox3D(\n          triangleAABB.getMinPos() -\n          glm::vec3(0.0001f),\n          triangleAABB.getMaxPos() -\n          triangleAABB.getMinPos() + glm::vec3(0.0002f)); \n```", "```cpp\n tri.index = index++;\n        mTriangleOctree->add(tri);\n     } \n```", "```cpp\nvoid OGLRenderer::generateLevelVertexData() {\n  generateLevelAABB();\n  generateLevelOctree();\n} \n```", "```cpp\n     std::vector<MeshTriangle> isCollidingTriangles{}; \n    ```", "```cpp\n    void AssimpInstance::setCollidingTriangles(\n        std::vector<MeshTriangle>& collidingTriangles) {\n      mInstanceSettings.isCollidingTriangles =\n       collidingTriangles;\n    } \n    ```", "```cpp\n    void OGLRenderer::checkForLevelCollisions() {\n      for (const auto& instance :\n          mModelInstCamData.micAssimpInstances) {\n        InstanceSettings instSettings =\n          instance->getInstanceSettings();\n        if (instSettings.isInstanceIndexPosition == 0)\n          continue;\n        } \n    ```", "```cpp\n     std::vector<MeshTriangle> collidingTriangles =\n          mTriangleOctree→query(instance->getBoundingBox()); \n    ```", "```cpp\n     instances.at(i)->setCollidingTriangles(\n          collidingTriangles);\n      }\n    } \n    ```", "```cpp\n     std::shared_ptr<OGLLineMesh>\n          mLevelCollidingTriangleMesh = nullptr; \n    ```", "```cpp\n     mLevelCollidingTriangleMesh->vertices.clear(); \n    ```", "```cpp\n     for (const auto& tri : collidingTriangles) {\n         OGLLineVertex vert;\n         vert.color = glm::vec3(1.0f, 0.0f, 0.0f);\n         vert.position = glm::vec4(tri.points.at(0), 1.0f);\n         mLevelCollidingTriangleMesh->vertices.push_back(vert);\n         vert.position = glm::vec4(tri.points.at(1), 1.0f);\n         mLevelCollidingTriangleMesh->vertices.push_back(vert);\n         vert.position = glm::vec4(tri.points.at(1), 1.0f);\n         mLevelCollidingTriangleMesh->vertices.push_back(vert);\n         vert.position = glm::vec4(tri.points.at(2), 1.0f);\n         mLevelCollidingTriangleMesh->vertices.push_back(vert);\n         vert.position = glm::vec4(tri.points.at(2), 1.0f);\n         mLevelCollidingTriangleMesh->vertices.push_back(vert);\n         vert.position = glm::vec4(tri.points.at(0), 1.0f);\n         mLevelCollidingTriangleMesh->vertices.push_back(vert);\n      } \n    ```", "```cpp\n    mLineVertexBuffer.uploadData(*mLevelCollidingTriangleMesh);\n      if (mLevelCollidingTriangleMesh->vertices.size() > 0) {\n        mLineShader.use();\n        mLineVertexBuffer.bindAndDraw(GL_LINES, 0,\n          mLevelCollidingTriangleMesh->vertices.size());\n      } \n    ```", "```cpp\n    enum class nodeEvent : uint8_t {\n      ...\n     **instanceToLevelCollision,**\n      NUM\n    }; \n    ```", "```cpp\n     mModelInstCamData.micNodeUpdateMap[\n        nodeEvent::instanceToLevelCollision] =\n        “Inst to Level collision”; \n    ```", "```cpp\n     if (collidingTriangles.size() > 0) {\n          mModelInstCamData.micNodeEventCallbackFunction(\n            instSettings.isInstanceIndexPosition,\n            nodeEvent::instanceToLevelCollision);\n        } \n    ```", "```cpp\nstruct MeshTriangle {\n  ...\n **glm::vec3 normal;**\n  BoundingBox3D boundingBox;\n}; \n```", "```cpp\n tri.normal = glm::normalize(normalMat *\n          glm::vec3(mesh.vertices.at(\n          mesh.indices.at(i)).normal)); \n```", "```cpp\n glm::vec3 edge1 = glm::vec3(mesh.vertices.at(\n          mesh.indices.at(i + 1)).position -\n          mesh.vertices.at(mesh.indices.at(i)).position);\n        glm::vec3 edge2 = glm::vec3(mesh.vertices.at(\n          mesh.indices.at(i + 2)).position -\n          mesh.vertices.at(mesh.indices.at(i)).position);\n        tri.normal = glm::normalize(normalMat *\n          glm::cross(edge1, edge2)); \n```", "```cpp\n float rdMaxLevelGroundSlopeAngle = 0.0f; \n```", "```cpp\n if (glm::dot(tri.normal, glm::vec3(0.0f, 1.0f, 0.0f))\n         >= glm::cos(glm::radians(\n         mRenderData.rdMaxLevelGroundSlopeAngle))) { \n```", "```cpp\n vertexColor = glm::vec3(0.0f, 0.0f, 1.0f);\n     } else {\n        vertexColor = glm::vec3(1.0f, 0.0f, 0.0f);\n        mModelInstCamData.micNodeEventCallbackFunction(\n          instSettings.isInstanceIndexPosition,\n          nodeEvent::instanceToLevelCollision);\n        } \n```", "```cpp\n ImGui::Text(\"Max Ground Slope:\");\n    ImGui::SameLine();\n    ImGui::SliderFloat(\"##MaxSlope\",\n      &renderData.rdMaxLevelGroundSlopeAngle,\n      0.0f, 45.0f, \"%.2f\", flags); \n```", "```cpp\nvoid AssimpInstance::applyGravity(float deltaTime) {\n  glm::vec3 gravity =\n    glm::vec3(0.0f, GRAVITY_CONSTANT * deltaTime, 0.0f);\n  mInstanceSettings.isWorldPosition -= gravity;\n} \n```", "```cpp\n if (mRenderData.rdEnableSimpleGravity) {\n            instances.at(i)->applyGravity(deltaTime);\n          } \n```", "```cpp\n ImGui::Text(\"Simple Gravity:  \");\n    ImGui::SameLine();\n    ImGui::Checkbox(\"##EnableGravity\",\n      &renderData.rdEnableSimpleGravity); \n```", "```cpp\n     bool isInstanceOnGround = false; \n    ```", "```cpp\n    void AssimpInstance::setInstanceOnGround(bool value) {\n      mInstanceSettings.isInstanceOnGround = value;\n    } \n    ```", "```cpp\n     if (!mInstanceSettings.isInstanceOnGround) {\n          mInstanceSettings.isWorldPosition -= gravity;\n        } \n    ```", "```cpp\n     bool instanceOnGround = true;\n        if (mRenderData.rdEnableSimpleGravity) {\n          glm::vec3 gravity =\n            glm::vec3(0.0f, 9.81 * deltaTime, 0.0f);\n          glm::vec3 footPoint =\n            instSettings.isWorldPosition; \n    ```", "```cpp\n     instanceOnGround = false;\n            for (const auto& tri : collidingTriangles) { \n    ```", "```cpp\n     if (glm::dot(tri.normal, glm::vec3(0.0f, 1.0f,\n                0.0f)) >= glm::cos(glm::radians(\n                mRenderData.rdMaxLevelGroundSlopeAngle))) { \n    ```", "```cpp\n     std::optional<glm::vec3> result =\n                    Tools::rayTriangleIntersection(\n                    instSettings.isWorldPosition – gravity,\n                    glm::vec3(0.0f, 1.0f, 0.0f), tri);\n                    if (result.has_value()) {\n                      footPoint = result.value();\n                      instances.at(i)->setWorldPosition(\n                        footPoint);\n                      instanceOnGround = true;\n                   }\n                 } \n    ```", "```cpp\n     instances.at(i)-setInstanceOnGround(instanceOnGround);\n        instances.at(i)->applyGravity(deltaTime); \n    ```", "```cpp\nNodePositions := OrigNodePositions\nStoreOriginalBoneLengths\nRootNodePos := NodePositions[LastPosition];\nFor NumIterations; Do\n    EffectorPos := NodePositions[0]\n    If TargetIsCloseToEffector\n       Return\n    SolveForward(TargetNodePos)\n    SolveBackwards(RootNodePos)\nEndFor \n```", "```cpp\nNodePositions[0] = TargetNodePos\nFor i = 1; i < NodePositions.Size; i += 1\n    BoneDirection = NodePositions[i] - NodePositions[i-1]\n    NewOffset = BoneDirection * BoneLengths[i - 1]\n    NodePositions[i] = NodePositions[i-1] + NewOffset\nEndFor \n```", "```cpp\n     std::vector<glm::vec3> solveFARBIK(\n          std::vector<glm::mat4>& nodeMatrices,\n        glm::vec3 targetPos); \n    ```", "```cpp\n     std::vector<glm::vec3> mNodePositions{};\n        std::vector<float> mBoneLengths{};\n        void solveFABRIKForward(glm::vec3 targetPos);\n        void solveFABRIKBackwards(glm::vec3 rootPos);\n        void calculateOrigBoneLengths(); \n    ```", "```cpp\n    void IKSolver::solveFABRIKForward(glm::vec3 targetPos) {\n      mNodePositions.at(0) = targetPos;\n      for (size_t i = 1; i < mNodePositions.size(); ++i) {\n        glm::vec3 boneDirection =\n          glm::normalize(mNodePositions.at(i) -\n          mNodePositions.at(i – 1));\n        glm::vec3 offset = boneDirection *\n          mBoneLengths.at(i – 1);\n        mNodePositions.at(i) =\n          mNodePositions.at(i - 1) + offset;\n      }\n    } \n    ```", "```cpp\n    void IKSolver::solveFABRIKBackwards(glm::vec3 rootPos) {\n      mNodePositions.at(mNodePositions.size() - 1) = rootPos;\n      for (int i = mNodePositions.size() - 2; i >= 0; --i) {\n        glm::vec3 boneDirection =\n          glm::normalize(mNodePositions.at(i) -\n          mNodePositions.at(i + 1));\n        glm::vec3 offset = boneDirection * mBoneLengths.at(i);\n        mNodePositions.at(i) =\n          mNodePositions.at(i + 1) + offset;\n      }\n    } \n    ```", "```cpp\n    std::vector<glm::vec3> IKSolver::solveFARBIK(\n        std::vector<glm::mat4>& nodeMatrices,\n        glm::vec3 targetPos) {\n      if (nodeMatrices.size() == 0) {\n        return std::vector<glm::vec3>{};\n      } \n    ```", "```cpp\n     mNodePositions.resize(nodeMatrices.size());\n      for (int i = 0; i < nodeMatrices.size(); ++i) {\n        mNodePositions.at(i) =\n          Tools::extractGlobalPosition(\n          nodeMatrices.at(i));\n      } \n    ```", "```cpp\n     calculateOrigBoneLengths();\n      glm::vec3 rootPos =\n        mNodePositions.at(mNodePositions.size() - 1); \n    ```", "```cpp\n     for (unsigned int i = 0; i < mIterations; ++i) {\n        glm::vec3 effector = mNodePositions.at(0);\n        if(glm::length(targetPos - effector) <\n            mCloseThreshold) {\n          return mNodePositions;\n        } \n    ```", "```cpp\n     solveFABRIKForward(targetPos);\n        solveFABRIKBackwards(rootPos);\n      } \n    ```", "```cpp\n     return mNodePositions;\n    } \n    ```", "```cpp\n std::array<std::pair<int, int>, 2> msFootIKChainPair{};\n  std::array<std::vector<int>, 2> msFootIKChainNodes{}; \n```", "```cpp\nstruct TRSMat {\n  vec4 translation;\n  vec4 rotation;\n  vec4 scale;\n}; \n```", "```cpp\n uint index = node + numberOfBones * instance;\n  trsMat[index].translation = finalTranslation;\n  trsMat[index].rotation = finalRotation;\n  trsMat[index].scale = finalScale; \n```", "```cpp\n mat4 nodeMatrix = **createTRSMatrix(****index****)**;\n  ...\n  nodeMatrix = **createTRSMatrix(parent)** * nodeMatrix; \n```", "```cpp\n size_t trsMatrixSize = numberOfBones *\n    numberOfInstances * 3 * sizeof(glm::vec4); \n```", "```cpp\nstruct TRSMatrixData{\n  glm::vec4 translation;\n  glm::quat rotation;\n  glm::vec4 scale;\n}; \n```", "```cpp\n mTRSData =\n      mShaderTRSMatrixBuffer.getSsboDataTRSMatrixData(); \n```", "```cpp\n for (int foot = 0; foot <\n      modSettings.msFootIKChainPair.size(); ++foot) {\n      int nodeChainSize =\n        modSettings.msFootIKChainNodes[foot].size();\n      if (nodeChainSize == 0) {\n        continue;\n      } \n```", "```cpp\n for (int index = nodeChainSize - 1; index > 0;\n          --index) {\n        for (size_t i = 0; i < numberOfInstances; ++i) { \n```", "```cpp\n int nodeId =\n            modSettings.msFootIKChainNodes[foot].at(index);\n          int nextNodeId =\n            modSettings.msFootIKChainNodes[foot]\n            .at(index - 1); \n```", "```cpp\n glm::vec3 position = Tools::extractGlobalPosition(\n          mWorldPosMatrices.at(i) *\n          mShaderBoneMatrices.at(i * numberOfBones +\n          nodeId) *\n          model->getInverseBoneOffsetMatrix(nodeId));\n        glm::vec3 nextPosition =\n          Tools::extractGlobalPosition(\n          mWorldPosMatrices.at(i) *\n          mShaderBoneMatrices.at(i * numberOfBones +\n          nextNodeId) *\n          model->getInverseBoneOffsetMatrix(nextNodeId)); \n```", "```cpp\n glm::vec3 toNext = glm::normalize(nextPosition -\n            position); \n```", "```cpp\n int newNodePosOffset = i * nodeChainSize + index;\n          glm::vec3 toDesired = glm::normalize(\n            mNewNodePositions.at(foot)\n            .at(newNodePosOffset - 1) –\n            mNewNodePositions.at(foot)\n            .at(newNodePosOffset));\n          glm::quat nodeRotation = glm::rotation(toNext,\n            toDesired); \n```", "```cpp\n glm::quat rotation = Tools::extractGlobalRotation(\n          mWorldPosMatrices.at(i) *\n          mShaderBoneMatrices.at(i * numberOfBones +\n          nodeId) *\n          model->getInverseBoneOffsetMatrix(nodeId));\n        glm::quat localRotation = rotation *\n          nodeRotation * glm::conjugate(rotation); \n```", "```cpp\n glm::quat currentRotation = mTRSData.at(i *\n            numberOfBones + nodeId).rotation;\n          glm::quat newRotation = currentRotation *\n            localRotation;\n          mTRSData.at(i*numberOfBones + nodeId).rotation =\n            newRotation;\n        } \n```", "```cpp\n int footNodeId =\n          modSettings.msFootIKChainPair.at(foot).first;\n        glm::vec3 footWorldPos =\n          Tools::extractGlobalPosition(\n          mWorldPosMatrices.at(i) *\n          mShaderBoneMatrices.at(i * numberOfBones +\n          footNodeId) *\n          model->getInverseBoneOffsetMatrix(footNodeId)); \n```", "```cpp\n float footDistAboveGround = std::fabs(\n          instSettings.isWorldPosition.y - footWorldPos.y); \n```", "```cpp\n AABB instanceAABB = model->getAABB(instSettings);\n        float instanceHeight = instanceAABB.getMaxPos().y -\n          instanceAABB.getMinPos().y;\n        float instanceHalfHeight = instanceHeight / 2.0f \n```", "```cpp\n glm::vec3 hitPoint = footWorldPos;\n        for (const auto& tri :\n          instSettings.isCollidingTriangles) {\n           std::optional<glm::vec3> result{}; \n```", "```cpp\n result = Tools::rayTriangleIntersection(\n            footWorldPos +\n            glm::vec3(0.0f, instanceHalfHeight, 0.0f),\n            glm::vec3(0.0f, -instanceHeight, 0.0f), tri); \n```", "```cpp\n if (result.has_value()) {\n            hitPoint = result.value() +\n              glm::vec3(0.0f, footDistAboveGround, 0.0f);\n          } \n```", "```cpp\n mIKWorldPositionsToSolve.clear();\n        for (int nodeId :\n            modSettings.msFootIKChainNodes[foot]) {\n          mIKWorldPositionsToSolve.emplace_back(\n            mWorldPosMatrices.at(i) *\n            mShaderBoneMatrices.at(i * numberOfBones +\n            nodeId) *\n            model->getInverseBoneOffsetMatrix(nodeId));\n        } \n```", "```cpp\n mIKSolvedPositions = mIKSolver.solveFARBIK(\n          mIKWorldPositionsToSolve, hitPoint);\n        mNewNodePositions.at(foot).insert(\n          mNewNodePositions.at(foot).end(),\n          mIKSolvedPositions.begin(),\n          mIKSolvedPositions.end()); \n```"]