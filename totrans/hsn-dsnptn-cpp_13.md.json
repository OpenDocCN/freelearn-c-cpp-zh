["```cpp\n// Example 01\n#include <iostream>\n#include <typeinfo>\nusing std::cout;\nusing std::endl;\ntemplate <typename T>\nauto type(T&& t) { return typeid(t).name(); }\nclass A {\n  public:\n  A() { cout << \"A::A(): \" << type(*this) << endl; }\n  virtual\n  ~A() { cout << \"A::~A(): \" << type(*this) << endl; }\n};\nclass B : public A {\n  public:\n  B() { cout << \"B::B(): \" << type(*this) << endl; }\n  ~B() { cout << \"B::~B(): \" << type(*this) << endl; }\n};\nclass C : public B {\n  public:\n  C() { cout << \"C::C(): \" << type(*this) << endl; }\n  ~C() { cout << \"C::~C(): \" << type(*this) << endl; }\n};\nint main() {\n  C c;\n}\n```", "```cpp\nA::A(): 1A\nB::B(): 1B\nC::C(): 1C\nC::~C(): 1C\nB::~B(): 1B\nA::~A(): 1A\n```", "```cpp\n$ c++filt -t 1A\nA\n```", "```cpp\n// Example 2\n#include <cxxabi.h>\ntemplate <typename T> auto type(T&& p) {\n  int r;\n  std::string name;\n  char* mangled_name =\n    abi::__cxa_demangle(typeid(p).name(), 0, 0, &r);\n  name += mangled_name;\n  ::free(mangled_name);\n  return name;\n}\n```", "```cpp\nclass A {\n  public:\n  void f() const { cout << type(*this) << endl; }\n};\n...\nC c;\nc.f();\n```", "```cpp\n// Example 03\ntemplate <typename T> auto type(T&& p) {\n  std::string name;\n  using TT = std::remove_reference_t<T>;\n  if (std::is_const<TT>::value) name += \"const \";\n  if (std::is_volatile<TT>::value) name += \"volatile \";\n  int r;\n  name += abi::__cxa_demangle(typeid(p).name(), 0, 0, &r);\n  return name;\n}\n```", "```cpp\nint main() {\n  C c;\n}\n```", "```cpp\n// Example 04\nclass A {\n  public:\n  A() { whoami(); }\n  virtual ~A() { whoami(); }\n  virtual void whoami() const {\n    std::cout << \"A::whoami\" << std::endl;\n  }\n};\nclass B : public A {\n  public:\n  B() { whoami(); }\n  ~B() { whoami(); }\n  void whoami() const override {\n    std::cout << \"B::whoami\" << std::endl;\n  }\n};\nclass C : public B {\n  public:\n  C() { whoami(); }\n  ~C() { whoami(); }\n  void whoami() const override {\n    std::cout << \"C::whoami\" << std::endl;\n  }\n};\nint main() {\n  C c;\n  c.whoami();\n}\n```", "```cpp\nA::whoami\nB::whoami\nC::whoami\nC::whoami\nC::whoami\nB::whoami\nA::whoami\n```", "```cpp\nC* c = new C;\nc->whoami();\ndelete c;\n```", "```cpp\nclass Base { ... };\nclass Derived : public Base { ... };\nBase* p = ClassFactory(type_identifier, ... arguments );\n```", "```cpp\n// Example 05\nenum Buildings {\n  FARM, FORGE, MILL, GUARDHOUSE, KEEP, CASTLE\n};\nclass Building {\n  public:\n  virtual ~Building() {}\n};\nclass Farm : public Building { ... };\nclass Forge : public Building { ... };\n```", "```cpp\nBuilding* new_farm = MakeBuilding(FARM);\n```", "```cpp\n// Example 05\nBuilding* MakeBuilding(Buildings building_type) {\n  switch (building_type) {\n    case FARM: return new Farm;\n    case FORGE: return new Forge;\n    ...\n  }\n}\n```", "```cpp\n// Example 06:\nclass Building {\n  public:\n  enum Type {FARM, FORGE, ...};\n  virtual ~Building() {}\n  auto MakeBuilding(Type building_type);\n};\nauto Building::MakeBuilding(Type building_type) {\n  using result_t = std::unique_ptr<Building>;\n  switch (building_type) {\n    case FARM: return result_t{new Farm};\n    case FORGE: return result_t{new Forge};\n    ...\n  }\n}\n```", "```cpp\nclass Point {\n  double x_ {};\n  double y_ {};\n  public:\n  Point(double x, double y) : x_(x), y_(y) {}\n};\n```", "```cpp\nclass Point() {\n  ...\n  Point(double r, double angle);\n};\n```", "```cpp\n// Example 07\nclass Point {\n  double x_ {};\n  double y_ {};\n  Point(double x, double y) : x_(x), y_(y) {}\n  public:\n  static Point new_cartesian(double x, double y) {\n    return Point(x, y);\n  }\n  static Point new_polar(double r, double phi) {\n    return Point(r*std::cos(phi), r*std::sin(phi));\n  }\n};\nPoint p1(Point::new_cartesian(3, 4));\nPoint p2(Point::new_polar(5, 0.927295));\n```", "```cpp\n// Example 08\nclass Point {\n  double x_ {};\n  double y_ {};\n  public:\n  struct cartesian_t {} static constexpr cartesian {};\n  Point(cartesian_t, double x, double y) : x_(x), y_(y) {}\n  struct polar_t {} static constexpr polar {};\n  Point(polar_t, double r, double phi) :\n    Point(cartesian, r*std::cos(phi), r*std::sin(phi)) {}\n};\nPoint p1(Point::cartesian, 3, 4);\nPoint p2(Point::polar, 5, 0.927295);\n```", "```cpp\n// Example 09\ntemplate <typename... Args>\nauto Building::MakeBuilding(Type type, Args&&... args) {\n  using result_t = std::unique_ptr<Building>;\n  switch (type) {\n    case FARM: return\n      result_t{new Farm(std::forward<Args>(args)...)};\n    case FORGE: return\n      result_t{new Forge(std::forward<Args>(args)...)};\n    ...\n  }\n}\n```", "```cpp\n// Example 09\nclass Farm : public Building {\n  public:\n  explicit Farm(double size);\n};\nclass Forge : public Building {\n  public:\n  static constexpr size_t weaponsmith = 0x1;\n  static constexpr size_t welder = 0x2;\n  static constexpr size_t farrier = 0x4;\n  Forge(size_t staff, size_t services);\n};\nstd::unique_ptr<Building> forge =\n  Building::MakeBuilding(Building::FORGE, 2,\n    Forge::weaponsmith | Forge::welder | Forge::farrier);\n```", "```cpp\n// Example 09\nclass Farm : public Building {\n  public:\n  explicit Farm(...) { abort(); }\n  ...\n};\n```", "```cpp\n// Example 10\ntemplate <typename T, typename... Args>\nauto new_T(Args&&... args) ->\n  decltype(T(std::forward<Args>(args)...))* {\n  return new T(std::forward<Args>(args)...);\n}\ntemplate <typename T>\nT* new_T(...) { abort(); return nullptr; }\ntemplate <typename... Args>\nauto Building::MakeBuilding(Type type, Args&&... args) {\n  using result_t = std::unique_ptr<Building>;\n  switch (type) {\n    case FARM: return\n      result_t{new_T<Farm>(std::forward<Args>(args)...)};\n    case FORGE: return\n      result_t{new_T<Forge>(std::forward<Args>(args)...)};\n    ...\n  }\n}\n```", "```cpp\n// Example 11\nstruct BuildingSpec {\n  virtual Building::Type type() const = 0;\n};\nstruct FarmSpec : public BuildingSpec {\n  Building::Type type() const override {\n    return Building::FARM;\n  }\n  bool with_pasture;\n  int number_of_stalls;\n};\nstruct ForgeSpec : public BuildingSpec {\n  Building::Type type() const override {\n    return Building::FORGE;\n  }\n  bool magic_forge;\n  int number_of_apprentices;\n};\n```", "```cpp\n// Example 11\nauto Building::MakeBuilding(const BuildingSpec& spec) {\n  using result_t = std::unique_ptr<Building>;\n  switch (spec.type()) {\n    case FARM: return result_t{\n      new Farm(static_cast<const FarmSpec&>(spec))};\n    case FORGE: return result_t{\n      new Forge(static_cast<const ForgeSpec&>(spec))};\n    ...\n  }\n}\n```", "```cpp\n// Example 11\nclass FarmSpec {\n  ...\n  bool with_pasture {};\n  int number_of_stalls {};\n  FarmSpec() = default;\n  FarmSpec& SetPasture(bool with_pasture) {\n    this->with_pasture = with_pasture;\n    return *this;\n  }\n  FarmSpec& SetStalls(int number_of_stalls) {\n    this->number_of_stalls = number_of_stalls;\n    return *this;\n  }\n};\nstruct ForgeSpec : public BuildingSpec {\n  ...\n  bool magic_forge {};\n  int number_of_apprentices {};\n  ForgeSpec() = default;\n  ForgeSpec& SetMagic(bool magic_forge) {\n    this->magic_forge = magic_forge;\n    return *this;\n  }\n  ForgeSpec& SetApprentices(int number_of_apprentices) {\n    this->number_of_apprentices = number_of_apprentices;\n    return *this;\n  }\n};\n...\nstd::unique_ptr<Building> farm =\n  Building::MakeBuilding(FarmSpec()\n                         .SetPasture(true)\n                         .SetStalls(2));\nstd::unique_ptr<Building> forge =\n  Building::MakeBuilding(ForgeSpec()\n                         .SetMagic(false)\n                         .SetApprentices(4));\n```", "```cpp\nclass Forge : public Building {\n  public:\n  static Building* MakeBuilding() { return new Forge; }\n};\n```", "```cpp\nclass Building;\nusing BuildingFactory = Building*(*)();\nstd::vector<BuildingFactory> building_registry;\n```", "```cpp\nsize_t building_type_count = 0;\nvoid RegisterBuilding(BuildingFactory factory) {\n  building_registry.push_back(factory));\n  ++building_type_count;\n}\n```", "```cpp\n// Example 12\nclass Building {\n  static size_t building_type_count;\n  using BuildingFactory = Building* (*)();\n  static std::vector<BuildingFactory> registry;\n  public:\n  static size_t (BuildingFactory factory) {\n    registry.push_back(factory);\n    return building_type_count++;\n  }\n  static auto MakeBuilding(size_t building_type) {\n    BuildingFactory RegisterBuilding factory =\n        registry[building_type];\n    return std::unique_ptr<Building>(factory());\n  }\n};\nstd::vector<Building::BuildingFactory> Building::registry;\nsize_t Building::building_type_count = 0;\n```", "```cpp\nclass Forge : public Building {\n  public:\n  static void Register() {\n    RegisterBuilding(Forge::MakeBuilding);\n  }\n};\n```", "```cpp\n// Example 12\nclass Forge : public Building {\n  public:\n  static void Register() {\n    RegisterBuilding(Forge::MakeBuilding);\n  }\n  static const size_t type_tag;\n};\nconst size_t Forge::type_tag =\n  RegisterBuilding(Forge::MakeBuilding);\n```", "```cpp\n// Example 12\nclass Farm : public Building {\n  public:\n  static const size_t type_tag;\n};\nconst size_t Farm::type_tag =\n  RegisterBuilding([]()->Building* { return new Farm; });\n```", "```cpp\nstd::unique_ptr<Building> farm =\n  Building::MakeBuilding(Farm::type_tag);\nstd::unique_ptr<Building> forge =\n  Building::MakeBuilding(Forge::type_tag);\n```", "```cpp\nusing BuildingFactory = std::function<Building*()>;\n```", "```cpp\n// Example 13\nclass Forge : public Building {\n  public:\n  static const size_t type_tag;\n};\nclass ForgeFactory {\n  public:\n  Building* operator()() const { return new Forge; }\n};\nconst size_t Forge::type_tag =\n  RegisterBuilding(ForgeFactory{});\n```", "```cpp\n// Example 14\nstruct BuildingSpec {};\nclass Building {\n  ...\n  using BuildingFactory =\n    Building* (*)(const BuildingSpec&);\n  static auto MakeBuilding(size_t building_type,\n                           const BuildingSpec& spec) {\n    BuildingFactory factory = registry[building_type];\n    return std::unique_ptr<Building>(factory(spec));\n  }\n};\nstruct FarmSpec : public BuildingSpec {\n  bool with_pasture {};\n  int number_of_stalls {};\n  FarmSpec() = default;\n  FarmSpec& SetPasture(bool with_pasture) {\n    this->with_pasture = with_pasture;\n    return *this;\n  }\n  FarmSpec& SetStalls(int number_of_stalls) {\n    this->number_of_stalls = number_of_stalls;\n    return *this;\n  }\n};\nclass Farm : public Building {\n  public:\n  explicit Farm(const FarmSpec& spec);\n  ...\n};\nconst size_t Farm::type_tag = RegisterBuilding(\n  [](const BuildingSpec& spec)->Building* {\n    return new Farm(static_cast<const FarmSpec&>(spec));\n  });\nstruct ForgeSpec : public BuildingSpec { ... };\nclass Forge : public Building { ... };\nstd::unique_ptr<Building> farm =\n  Building::MakeBuilding(FarmSpec()\n                         .SetPasture(true)\n                         .SetStalls(2));\nstd::unique_ptr<Building> forge =\n  Building::MakeBuilding(ForgeSpec()\n                         .SetMagic(false)\n                         .SetApprentices(4));\n```", "```cpp\n// Example 15\nclass Unit {};\nclass Knight : public Unit { ... };\nclass Mage : public Unit { ... };\nclass Spider : public Unit { ... };\nclass Building {\n  public:\n  virtual Unit* MakeUnit() const = 0;\n};\nclass Castle : public Building {\n  public:\n  Knight* MakeUnit() const { return new Knight; }\n};\nclass Tower : public Building {\n  public:\n  Mage* MakeUnit() const { return new Mage; }\n};\nclass Mound : public Building {\n  public:\n  Spider* MakeUnit() const { return new Spider; }\n};\n```", "```cpp\nstd::vector<std::unique_ptr<Building>> buildings;\nstd::vector<std::unique_ptr<Unit>> units;\nfor (const auto& b : buildings) {\n  units.emplace_back(b->MakeUnit());\n}\n```", "```cpp\n// Example 16\nclass Base {\n  public:\n  virtual Base* clone() const = 0;\n};\nclass Derived : public Base {\n  public:\n  Derived* clone() const override {\n    return new Derived(*this);\n  }\n};\nBase* b0 = ... get an object somewhere ...\nBase* b1 = b->clone();\n```", "```cpp\nclass Base {\n  public:\n  virtual std::unique_ptr<Base> clone() const = 0;\n};\nclass Derived : public Base {\n  public:\n  std::unique_ptr<Base> clone() const override {\n    return std::unique_ptr<Base>(new Derived(*this));\n  }\n};\nstd::unique_ptr<Base> b(... make an object ...);\nstd::unique_ptr<Base> b1 = b->clone();\n```", "```cpp\n// Example 18\ntemplate <typename Derived> class Base {\n  public:\n  virtual std::unique_ptr<Derived> clone() const = 0;\n};\nclass Derived : public Base<Derived> {\n  public:\n  std::unique_ptr<Derived> clone() const override {\n    return std::unique_ptr<Derived>(new Derived(*this));\n  }\n};\nstd::unique_ptr<Derived> b0(new Derived);\nstd::unique_ptr<Derived> b1 = b0->clone();\n```", "```cpp\ntemplate <typename Derived> class Base {\n  public:\n  virtual std::unique_ptr<Derived> clone() const = 0;\n  Base() {\n    static_assert(std::is_base_of_v<Base, Derived>;\n  }\n};\n```", "```cpp\n// Example 19\ntemplate <typename Derived> class Base {\n  public:\n  std::unique_ptr<Derived> clone() const {\n    return std::unique_ptr<Derived>(\n      new Derived(*static_cast<const Derived*>(this)));\n  }\n};\nclass Derived : public Base<Derived> { ... };\n```", "```cpp\n// Example 20\nclass Base {\n  public:\n  virtual Base* clone() const = 0;\n};\ntemplate <typename Derived> class Cloner : public Base {\n  public:\n  Base* clone() const {\n    return new Derived(*static_cast<const Derived*>(this));\n  }\n};\nclass Derived : public Cloner<Derived> {\n  ...\n};\nBase* b0(new Derived);\nBase* b1 = b0->clone();\n```", "```cpp\n// Example 21\nclass SerializerBase {\n  static size_t type_count;\n  using Factory = SerializerBase* (*)(std::istream& s);\n  static std::vector<Factory> registry;\n  protected:\n  virtual void Serialize(std::ostream& s) const = 0;\n  public:\n  virtual ~SerializerBase() {}\n  static size_t RegisterType(Factory factory) {\n    registry.push_back(factory);\n    return type_count++;\n  }\n  static auto Deserialize(size_t type, std::istream& s) {\n    Factory factory = registry[type];\n    return std::unique_ptr<SerializerBase>(factory(s));\n  }\n};\nstd::vector<SerializerBase::Factory>\n  SerializerBase::registry;\nsize_t SerializerBase::type_count = 0;\n```", "```cpp\n// Example 21\nclass Derived1 : public SerializerBase {\n  int i_;\n  public:\n  Derived1(int i) : i_(i) {...}\n  void Serialize(std::ostream& s) const override {\n    s << type_tag << \" \" << i_ << std::endl;\n  }\n  static const size_t type_tag;\n};\nconst size_t Derived1::type_tag =\n  RegisterType([](std::istream& s)->SerializerBase* {\n    int i; s >> i; return new Derived1(i); });\n```", "```cpp\nstd::ostream S ... – construct the stream as needed\nDerived1 d(42);\nd.Serialize(S);\n```", "```cpp\n// Example 21\nclass DeserializerFactory {\n  std::istream& s_;\n  public:\n  explicit DeserializerFactory(std::istream& s) : s_(s) {}\n  template <typename It>\n  void Deserialize(It iter) {\n    while (true) {\n      size_t type;\n      s_ >> type;\n      if (s_.eof()) return;\n      iter = SerializerBase::Deserialize(type, s_);\n    }\n  }\n};\n```", "```cpp\n// Example 21\nstd::vector<std::unique_ptr<SerializerBase>> v;\nDeserializerFactory F(S);\nF.Deserialize(std::back_inserter(v));\n```", "```cpp\n// Example 21\nclass Derived2 : public SerializerBase {\n  double x_, y_;\n  public:\n  Derived2(double x, double y) : x_(x), y_(y) {...}\n  void Serialize(std::ostream& s) const override {\n    s << type_tag << \" \" << x_ << \" \" << y_ << std::endl;\n  }\n  static const size_t type_tag;\n};\nconst size_t Derived2::type_tag =\n  RegisterType([](std::istream& s)->SerializerBase* {\n    double x, y; s >> x >> y;\n    return new Derived2(x, y);\n});\n```", "```cpp\n// Example 21\nclass Derived3 : public SerializerBase {\n  bool integer_;\n  int i_ {};\n  double x_ {};\n  public:\n  Derived3(int i) : integer_(true), i_(i) {...}\n  Derived3(double x) : integer_(false), x_(x) {...}\n  void Serialize(std::ostream& s) const override {\n    s << type_tag << \" \" << integer_ << \" \";\n    if (integer_) s << i_; else s << x_;\n    s << std::endl;\n  }\n  static const size_t type_tag;\n};\nconst size_t Derived3::type_tag =\n  RegisterType([](std::istream& s)->SerializerBase* {\n    bool integer; s >> integer;\n    if (integer) {\n      int i; s >> i; return new Derived3(i);\n    } else {\n      double x; s >> x; return new Derived3(x);\n  }\n});\n```"]