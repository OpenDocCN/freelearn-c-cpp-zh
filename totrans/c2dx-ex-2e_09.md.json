["```cpp\n    auto scene = GameLayer::scene();\n    // run\n    director->runWithScene(scene);\n    ```", "```cpp\n    Scene* MenuLayer::scene()\n    {\n        // 'scene' is an autorelease object\n        auto scene = Scene::create();\n        // add layer as a child to scene\n        auto layer = new MenuLayer();\n        scene->addChild(layer);\n        layer->release();\n        return scene;\n    }\n    ```", "```cpp\n    Director::getInstance()->replaceScene(MenuLayer::scene());\n    ```", "```cpp\n    auto newScene = TransitionMoveInR::create(0.2f,  LevelSelectLayer::scene());\n    Director::getInstance()->replaceScene(newScene);\n    ```", "```cpp\n    Scene* GameLayer::scene(int level, int levelsCompleted)\n    {\n        // 'scene' is an autorelease object\n        auto scene = Scene::create();\n       // add layer as a child to scene\n        scene->addChild(GameLayer::create(level, levelsCompleted));\n       return scene;\n    }\n    ```", "```cpp\n    GameLayer * GameLayer::create (int level, int levelsCompleted) {\n        if (!_instance) {\n            _instance = new GameLayer();\n        } else {\n            _instance->clearLayer();\n        }\n        _instance->setLevelsCompleted(levelsCompleted);\n        _instance->loadLevel(level);\n        _instance->scheduleUpdate();\n        return _instance;\n    }\n    ```", "```cpp\n    static GameLayer* _instance = nullptr;\n    ```", "```cpp\n    auto newScene = TransitionMoveInR::create(0.2f,  GameLayer::scene(_firstIndex + i, _levelsCompleted));\n    Director::sharedDirector()->replaceScene(newScene);\n    ```", "```cpp\n//when leaving\nunscheduleUpdate();\nauto newScene = TransitionMoveInL::create(0.2f, MenuLayer::scene());\nDirector::sharedDirector()->replaceScene(newScene);\n\n//when returning\n_instance->scheduleUpdate();\n```", "```cpp\n    _levels = FileUtils::getInstance()- >getValueVectorFromFile(\"levels.plist\");\n    ```", "```cpp\n    ValueMap levelData = _levels.at(_currentLevel).asValueMap();\n    ```", "```cpp\n    _gravity = levelData.at(\"gravity\").asInt();\n    switch (_gravity) {\n        case kDirectionUp:\n            _world->SetGravity(b2Vec2(0,FORCE_GRAVITY));\n            break;\n        case kDirectionDown:\n            _world->SetGravity(b2Vec2(0,-FORCE_GRAVITY));\n            break;\n        case kDirectionLeft:\n            _world->SetGravity(b2Vec2(-FORCE_GRAVITY, 0));\n            break;\n        case kDirectionRight:\n            _world->SetGravity(b2Vec2(FORCE_GRAVITY, 0));\n            break;\n    }\n\n    _player->setSpritePosition(Vec2(\n        levelData.at(\"startx\").asFloat() * TILE,\n        levelData.at(\"starty\").asFloat() * TILE\n    ));\n\n    _igloo->initIgloo(_gravity, Vec2(\n        levelData.at(\"endx\").asFloat() * TILE,\n        levelData.at(\"endy\").asFloat() * TILE\n    ));\n    ```", "```cpp\n    ValueVector platforms =  levelData.at(\"platforms\").asValueVector();\n    ValueVector switches =  levelData.at(\"switches\").asValueVector();\n    ```", "```cpp\n    for ( auto platformData : platforms){\n       ValueMap data = platformData.asValueMap();\n       platform->initPlatform ( data.at(\"width\").asInt() * TILE,\n                             data.at(\"angle\").asFloat(),\n                             Vec2(data.at(\"x\").asFloat() * TILE,\n                             data.at(\"y\").asFloat() * TILE));\n    }\n\n     for (int i = 0; i < switches.size(); i++) {\n            auto gswitch = _gSwitchPool.at(i);\n            ValueMap data = switches.at(i).asValueMap();\n            gswitch->initGSwitch(data.at(\"gravity\").asInt(),\n                        Vec2(data.at(\"x\").asFloat() * TILE,\n                        data.at(\"y\").asFloat() * TILE));\n    }\n    ```", "```cpp\nUserDefault::getInstance()->setIntegerForKey(\"levelsCompleted\", _levelsCompleted);\nUserDefault::getInstance()->flush();\n```", "```cpp\n    _levelsCompleted = UserDefault::getInstance()- >getIntegerForKey(\"levelsCompleted\");\n    ```", "```cpp\n    if (_levelsCompleted == 0) {\n        _levelsCompleted = 1;\n        UserDefault::getInstance()->setIntegerForKey(\"levelsCompleted\", 1);\n        UserDefault::getInstance()->flush();\n    }\n    ```", "```cpp\n    if (_currentLevel > _levelsCompleted) {\n        _levelsCompleted = _currentLevel;\n        UserDefault::getInstance()->setIntegerForKey(\"levelsCompleted\", _levelsCompleted);\n        UserDefault::getInstance()->flush();\n    }\n    ```", "```cpp\n    auto onGravityChanged = [=] (EventCustom * event) {\n           if (this->isVisible()) {\n                switchTexture();\n            }\n    };\n    Director::getInstance()->getEventDispatcher()- addEventListenerWithSceneGraphPriority(EventListenerCustom::create  (GameLayer::NOTIFICATION_GRAVITY_SWITCH, onGravityChanged), this);\n    ```", "```cpp\n    #define EVENT_DISPATCHER Director::getInstance()- >getEventDispatcher()\n    #define ADD_NOTIFICATION( __target__, __notification__,  __handler__) EVENT_DISPATCHER- addEventListenerWithSceneGraphPriority(EventListenerCustom::create  (__notification__, __handler__), __target__);\n    ```", "```cpp\n    ADD_NOTIFICATION(this, GameLayer::NOTIFICATION_GRAVITY_SWITCH, onGravityChanged);\n    ```", "```cpp\n    const char* GameLayer::NOTIFICATION_GRAVITY_SWITCH =  \"NOTIFICATION_GRAVITY_SWITCH\";\n    ```", "```cpp\n    Director::getInstance()->getEventDispatcher()- >dispatchCustomEvent( GameLayer::NOTIFICATION_GRAVITY_SWITCH);\n    ```", "```cpp\n    EVENT_DISPATCHER->dispatchCustomEvent(  GameLayer::NOTIFICATION_GRAVITY_SWITCH);\n    ```", "```cpp\n    event->getUserData();\n    ```", "```cpp\n    Device::setAccelerometerEnabled(true);\n    ```", "```cpp\n    auto listenerAccelerometer =  \n    EventListenerAcceleration::create(CC_CALLBACK_2 (GameLayer::onAcceleration, this));\n    _eventDispatcher->addEventListenerWithSceneGraphPriority(listenerAccelerometer,  this);\n    ```", "```cpp\n    void GameLayer::onAcceleration(Acceleration *acc, Event *event) {\n        _acceleration = Vec2(acc->x * ACCELEROMETER_MULTIPLIER,\n                            acc->y * ACCELEROMETER_MULTIPLIER);\n    }\n    ```", "```cpp\nif (_player->getBody()->GetContactList()) \n```", "```cpp\n    if (_body->GetFixtureList() ) {\n        _body->DestroyFixture(_body->GetFixtureList());\n    }\n    ```", "```cpp\n    _body->SetActive(false);\n    ```", "```cpp\n    //Define shape\n    b2PolygonShape box;\n    box.SetAsBox(width * 0.5f /PTM_RATIO, PLATFORM_HEIGHT *  0.5f / PTM_RATIO);\n\n    //Define fixture\n    b2FixtureDef fixtureDef;\n    fixtureDef.shape = &box;\n    fixtureDef.density = 1;\n    fixtureDef.restitution = 0;\n\n    //reutilize body from the pool: so destroy any existent fixture\n    if (_body->GetFixtureList()) {\n        _body->DestroyFixture(_body->GetFixtureList());\n    }\n    _body->CreateFixture(&fixtureDef);\n    _body->SetTransform(b2Vec2(position.x / PTM_RATIO, position.y /  PTM_RATIO), _DEGREES_TO_RADIANS(-angle));\n    _body->SetActive(true);\n    ```", "```cpp\n    android:screenOrientation=\"portrait\"   \n    ```", "```cpp\n    LOCAL_SRC_FILES := hellocpp/main.cpp \\\n                       ../../Classes/AppDelegate.cpp \\\n                       ../../Classes/b2Sprite.cpp \\\n                       ../../Classes/Eskimo.cpp \\\n                       ../../Classes/GSwitch.cpp \\\n                       ../../Classes/Igloo.cpp \\\n                       ../../Classes/Platform.cpp \\\n                       ../../Classes/LevelSelectLayer.cpp \\\n                       ../../Classes/MenuLayer.cpp \\\n                       ../../Classes/GameLayer.cpp\n    ```"]