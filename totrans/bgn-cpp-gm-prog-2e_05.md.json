["```cpp\nwhile (window.isOpen())\n{\n}\n```", "```cpp\nint numberOfZombies = 100;\nwhile(numberOfZombies > 0)\n{\n    // Player kills a zombie\n    numberOfZombies--;\n    // numberOfZombies decreases each pass through the loop\n}\n// numberOfZombies is no longer greater than 0\n```", "```cpp\nint availableCoins = 10;\nwhile(availableCoins > 10)\n{\n    // more code here.\n    // Won't run unless availableCoins is greater than 10\n}\n```", "```cpp\nint playerLives = 3;\nint alienShips = 10;\nwhile(playerLives !=0 && alienShips !=0 )\n{\n    // Handle input\n    // Update the scene\n    // Draw the scene\n}\n// continue here when either playerLives or alienShips equals 0\n```", "```cpp\nint x = 1;\nwhile(x > 0)\n{\n    x--;\n    // x is now 0 so the condition is false\n    // But this line still runs\n    // and this one\n    // and me!\n}\n// Now I'm done!\n```", "```cpp\nint y = 0;\nwhile(true)\n{\n    y++; // Bigger... Bigger...\n}\n```", "```cpp\nint z = 0;\nwhile(true)\n{\n    z++; // Bigger... Bigger...\n    break; // No you're not\n\n    // Code doesn't reach here\n}\n```", "```cpp\nint x = 0;\nint max = 10;\nwhile(true)\n{\n    x++; // Bigger... Bigger...\n    if(x == max){\n        break;\n    } // No you're not\n    // code reaches here only until max = 10\n}\n```", "```cpp\nfor(int x = 0; x < 100; x ++)\n{\n    // Something that needs to happen 100 times goes here\n}\n```", "```cpp\nfor(; ; )\n```", "```cpp\nfor(int i = 10; i > 0; i--)\n{\n    // countdown\n}\n// blast off\n```", "```cpp\nint someInts[10];\n```", "```cpp\nsomeInts[0] = 99;\n```", "```cpp\nsomeInts[1] = 999;\n```", "```cpp\nsomeInts[9] = 3;\n```", "```cpp\nsomeInts[2] = someInts[0] + someInts[1];\n```", "```cpp\nint a = 9999;\nsomeInts[4] = a;\n```", "```cpp\nfloat myFloatingPointArray[3] {3.14f, 1.63f, 99.0f};\n```", "```cpp\nfor(int i = 0; i < 10; i++)\n{\n    uselessArray[i] = i;\n}\n```", "```cpp\n// someArray[4] is declared and initialized to 9999\nfor(int i = 0; i < someArray[4]; i++)\n{\n    // Loop executes 9999 times\n}\n```", "```cpp\nZombie horde [5] {zombie1, zombie2, zombie3}; // etc...\n```", "```cpp\nswitch(expression)\n{\n    // More code here\n}\n```", "```cpp\ncase x:\n    //code for x\n    break;\n\ncase y:\n    //code for y\n    break;\n```", "```cpp\ndefault: // Look no value\n    // Do something here if no other case statements are true\n    break;\n```", "```cpp\n// get input from user in a char called command\nswitch(command){\n    case 'n':\n        // Handle move here\n        break;\n    case 'e':\n        // Handle move here\n        break;\n    case 's':\n        // Handle move here\n        break;\n    case 'w':\n        // Handle move here\n        break;\n\n    // more possible cases\n    default:\n        // Ask the player to try again\n        break;\n}\n```", "```cpp\nenum class zombieTypes {\n   REGULAR, RUNNER, \n   CRAWLER, SPITTER, BLOATER \n};\n```", "```cpp\nzombieType jeremy = zombieTypes::CRAWLER;\nzombieType anna = zombieTypes::SPITTER;\nzombieType diane = zombieTypes::BLOATER;\n/*\n    Zombies are fictional creatures and any resemblance\n    to real people is entirely coincidental\n*/\n```", "```cpp\nenum class side { LEFT, RIGHT, NONE };\n```", "```cpp\n// The player starts on the left\nside playerSide = side::LEFT;\n```", "```cpp\nbranchPositions[3] = side::NONE;\n```", "```cpp\nif(branchPositions[5] == playerSide)\n{\n    // The lowest branch is the same side as the player\n    // SQUISHED!!\n}\n```", "```cpp\nvoid shootLazers(int power, int direction);\n```", "```cpp\nvoid shootLazers(int power, int direction)\n{\n    // ZAPP!\n}\n```", "```cpp\n// Attack the player\nshootLazers(50, 180) // Run the code in the function\n// I'm back again - code continues here after the function ends\n```", "```cpp\nint addAToB(int a, int b)\n{\n    int answer = a + b;\n    return answer;\n}\n```", "```cpp\nint myAnswer = addAToB(2, 4);\n```", "```cpp\nreturn type | name of function | (parameters)\n```", "```cpp\nint addAToB(int a, int b){\n\n    int answer = a + b;\n    return answer;\n\n}\n```", "```cpp\nvoid doWhatever(){\n\n    // our code\n    // I'm done going back to calling code here\n    // no return is necessary\n\n}\n```", "```cpp\nvoid doSomethingCool(){\n\n    // our code\n\n    // I can do this if I don't try and use a value\n    return;\n}\n```", "```cpp\nvoid doYetAnotherThing(){\n    // some code\n\n    if(someCondition){\n\n        // if someCondition is true returning to calling code\n        // before the end of the function body\n        return;\n    }\n\n    // More code that might or might not get executed\n\n    return;\n\n    // As I'm at the bottom of the function body\n    // and the return type is void, I'm\n    // really not necessary but I suppose I make it\n    // clear that the function is over.\n}\n\nbool detectCollision(Ship a, Ship b){\n\n    // Detect if collision has occurred\n    if(collision)\n    {\n        // Bam!!!\n        return true;\n    }\n    else\n    {\n        // Missed\n        return false;\n    }\n\n}\n```", "```cpp\n// OK time to call some functions\ndoWhatever();\ndoSomethingCool();\ndoYetAnotherThing();\n\nif (detectCollision(milleniumFalcon, lukesXWing))\n{\n    // The jedi are doomed!\n    // But there is always Leia.\n    // Unless she was on the Falcon?\n}\nelse\n{\n    // Live to fight another day\n}\n\n// Continue with code from here\n```", "```cpp\nvoid functionaroonieboonie(int blibbityblob, float floppyfloatything)\n{\n    //code here\n}\n```", "```cpp\nvoid doSomeVerySpecificTask()\n{\n    //code here\n}\n\nint getMySpaceShipHealth()\n{\n    //code here\n}\n\nvoid startNewGame()\n{\n    //code here\n}\n```", "```cpp\nint addAToB(int a, int b)\n{ \n    int answer = a + b;\n    return answer; \n}\n```", "```cpp\n// code here\n// some code\n```", "```cpp\n// The prototype\n// Notice the semicolon on the end\nint addAToB(int a, int b);\n\nint main()\n{ \n    // Call the function\n    // Store the result in answer\n    int answer = addAToB(2,2);\n\n    // Called before the definition\n    // but that's OK because of the prototype\n\n    // Exit main\n    return 0;\n\n}// End of main\n\n// The function definition\nint addAToB(int a, int b)\n{\n    return a + b;\n}\n```", "```cpp\nspriteBee.setPosition...\nwindow.draw...\n// etc\n```", "```cpp\n#include <sstream>\n#include <SFML/Graphics.hpp>\nusing namespace sf;\n// Function declaration\nvoid updateBranches(int seed);\nconst int NUM_BRANCHES = 6;\nSprite branches[NUM_BRANCHES];\n// Where is the player/branch?\n// Left or Right\nenum class side { LEFT, RIGHT, NONE };\nside branchPositions[NUM_BRANCHES];\nint main()\n```", "```cpp\n// Position the text\nFloatRect textRect = messageText.getLocalBounds();\nmessageText.setOrigin(textRect.left +\n    textRect.width / 2.0f,\n    textRect.top +\n    textRect.height / 2.0f);\nmessageText.setPosition(1920 / 2.0f, 1080 / 2.0f);\nscoreText.setPosition(20, 20);\n// Prepare 6 branches\nTexture textureBranch;\ntextureBranch.loadFromFile(\"graphics/branch.png\");\n// Set the texture for each branch sprite\nfor (int i = 0; i < NUM_BRANCHES; i++) {\n    branches[i].setTexture(textureBranch);\n    branches[i].setPosition(-2000, -2000);\n    // Set the sprite's origin to dead centre\n    // We can then spin it round without changing its position\n    branches[i].setOrigin(220, 20);\n}\nwhile (window.isOpen())\n```", "```cpp\n    // Update the score text\n    std::stringstream ss;\n    ss << \"Score: \" << score;\n    scoreText.setString(ss.str());\n    // update the branch sprites\n    for (int i = 0; i < NUM_BRANCHES; i++)\n    {\n        float height = i * 150;\n        if (branchPositions[i] == side::LEFT)\n        {\n            // Move the sprite to the left side\n            branches[i].setPosition(610, height);\n            // Flip the sprite round the other way\n            branches[i].setRotation(180);\n        }\n        else if (branchPositions[i] == side::RIGHT)\n        {\n            // Move the sprite to the right side\n            branches[i].setPosition(1330, height);\n            // Set the sprite rotation to normal\n            branches[i].setRotation(0);\n        }\n        else\n        {\n            // Hide the branch\n            branches[i].setPosition(3000, height);\n        }\n    }\n} // End if(!paused)\n/*\n****************************************\nDraw the scene\n****************************************\n```", "```cpp\nif()\n{\n}\nelse if()\n{\n}\nelse\n{\n}\n```", "```cpp\n// Draw the clouds\nwindow.draw(spriteCloud1);\nwindow.draw(spriteCloud2);\nwindow.draw(spriteCloud3);\n// Draw the branches\nfor (int i = 0; i < NUM_BRANCHES; i++) {\n    window.draw(branches[i]);\n}\n// Draw the tree\nwindow.draw(spriteTree);\n```", "```cpp\n// Function definition\nvoid updateBranches(int seed)\n{\n    // Move all the branches down one place\n    for (int j = NUM_BRANCHES-1; j > 0; j--) {\t\n        branchPositions[j] = branchPositions[j - 1];\n    }\n}\n```", "```cpp\n// Function definition\nvoid updateBranches(int seed)\n{\n    // Move all the branches down one place\n    for (int j = NUM_BRANCHES-1; j > 0; j--) {\t\n        branchPositions[j] = branchPositions[j - 1];\n    }\n    // Spawn a new branch at position 0\n    // LEFT, RIGHT or NONE\n    srand((int)time(0)+seed);\n    int r = (rand() % 5);\n    switch (r) {\n    case 0:\n        branchPositions[0] = side::LEFT;\n        break;\n    case 1:\n        branchPositions[0] = side::RIGHT;\n        break;\n    default:\n        branchPositions[0] = side::NONE;\n        break;\n    }\n}\n```", "```cpp\nupdateBranches(1);\nupdateBranches(2);\nupdateBranches(3);\nupdateBranches(4);\nupdateBranches(5);\nwhile (window.isOpen())\n{\n```"]