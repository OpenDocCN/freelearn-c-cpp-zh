- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Space Rocks: Build a 2D Arcade Classic with Physics'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By now, you should be getting more comfortable with working in Godot: adding
    nodes, creating scripts, modifying properties in the Inspector, and so on. If
    you find yourself stuck or feeling like you don’t remember how something is done,
    you can jump back to a project where it was first explained. As you repeat the
    more common actions in Godot, they’ll start to feel more and more familiar. At
    the same time, each chapter will introduce you to more nodes and techniques to
    expand your understanding of Godot’s features.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this project, you’ll make a space shooter game similar to the arcade classic
    *Asteroids*. The player will control a ship that can rotate and move in any direction.
    The goal will be to avoid the floating “space rocks” and shoot them with the ship’s
    laser. Here’s a screenshot of the final game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1: Space Rocks screenshot](img/B19289_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Space Rocks screenshot'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll learn about the following key topics in this project:'
  prefs: []
  type: TYPE_NORMAL
- en: Using custom input actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physics using `RigidBody2D`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing game logic with finite state machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a dynamic, scalable UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sound and music
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Particle effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Download the game assets from the following link below and unzip them into
    your new project folder: [https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also find the complete code for this chapter on GitHub at: [https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter03%20-%20Space%20Rocks](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter03%20-%20Space%20Rocks)'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new project and download the project assets from the following URL:
    [https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads).'
  prefs: []
  type: TYPE_NORMAL
- en: For this project, you’ll set up custom input actions in the **Input Map**. Using
    this feature, you can define custom input events and assign different keys, mouse
    events, or other inputs to them. This allows more flexibility in designing your
    game, as your code can be written to respond to the “jump” input, for example,
    without needing to know exactly what key and/or button the user pressed to make
    that event happen. This allows you to make the same code work on different devices,
    even if they have different hardware. In addition, since many gamers expect to
    be able to customize a game’s inputs, this enables you to provide that option
    to the user as well.
  prefs: []
  type: TYPE_NORMAL
- en: To set up the inputs for this game, open **Project** | **Project Settings**
    and select the **Input** **Map** tab.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need to create four new input actions: `rotate_left`, `rotate_right`,
    `thrust`, and `shoot`. Type the name of each action into the **Add New Action**
    box and hit *Enter* or click the **Add** button. Make sure you type the names
    exactly as shown since they’ll be used in code later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, for each action, click the **+** button to its right. In the pop-up window,
    you can manually select a specific type of input, or you can press the physical
    button and Godot will detect it. You can add multiple inputs to each action. For
    example, to allow players to use both the arrow keys and the WASD keys, the setup
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2: Input actions](img/B19289_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: Input actions'
  prefs: []
  type: TYPE_NORMAL
- en: If you have a gamepad or other controller connected to your computer, you can
    also add its inputs to the actions in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We’re only considering button-style inputs at this stage, so while you’ll be
    able to use a D-pad for this project, using an analog joystick would require changes
    to the project’s code.
  prefs: []
  type: TYPE_NORMAL
- en: Rigid body physics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In game development, you often need to know when two objects in the game space
    intersect or come into contact. This is known as **collision detection**. When
    a collision is detected, you typically want something to happen. This is known
    as **collision response**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Godot offers three kinds of physics bodies, grouped under the `PhysicsBody2D`
    node type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`StaticBody2D`: A static body is one that is not moved by the physics engine.
    It participates in collision detection but does not move in response. This type
    of body is most often used for objects that are part of the environment or do
    not need to have any dynamic behavior, such as walls or the ground.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RigidBody2D`: This is the physics body that provides simulated physics. This
    means that you don’t control a `RigidBody2D` physics body’s position directly.
    Instead, you apply forces to it (gravity, impulses, and so on) and Godot’s built-in
    physics engine calculates the resultant movement, including collisions, bouncing,
    rotating, and other effects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CharacterBody2D`: This body type provides collision detection but no physics.
    All movement must be implemented in code, and you must implement any collision
    response yourself. Kinematic bodies are most often used for player characters
    or other actors that require *arcade-style* physics rather than realistic simulation,
    or when you need more precise control over how the body moves.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding when to use a particular physics body type is a big part of building
    your game. Using the right type can simplify your development, while trying to
    force the wrong node to do the job can lead to frustration and poor results. As
    you work with each type of body, you’ll come to learn their pros and cons and
    get a feel for when they can help build what you need.
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll be using the `RigidBody2D` node for the ship as well
    as the rocks themselves. You’ll learn about the other body types in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Individual `RigidBody2D` nodes have many properties you can use to customize
    their behavior, such as **Mass**, **Friction**, or **Bounce**. These properties
    can be set in the Inspector.
  prefs: []
  type: TYPE_NORMAL
- en: Rigid bodies are also affected by global properties, which can be set in **Project
    Settings** under **Physics** | **2D**. These settings apply to all bodies in the
    world.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3: Project physics settings](img/B19289_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: Project physics settings'
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, you won’t need to modify these settings. However, note that by
    default, gravity has a value of `980` and a direction of `(0, 1)`, or downward.
    If you want to change the world’s gravity, you can do that here.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click the **Advanced Settings** toggle in the upper right of the **Project
    Settings** window, you’ll see many advanced configuration values for the physics
    engine. You should be aware of two of them in particular: **Default Linear Damp**
    and **Default Angular Damp**. These properties control how quickly a body will
    lose forward speed and rotation speed, respectively. Setting them to lower values
    will make the world feel frictionless, while using larger values will make it
    feel like your objects are moving through mud. This can be a great way to apply
    different movement styles to suit various game objects and environments.'
  prefs: []
  type: TYPE_NORMAL
- en: Area physics override
  prefs: []
  type: TYPE_NORMAL
- en: '`Area2D` nodes can also be used to influence rigid body physics by using their
    **Space Override** property. Custom gravity and damping values will then be applied
    to any bodies that enter the area.'
  prefs: []
  type: TYPE_NORMAL
- en: Since this game will be taking place in outer space, gravity won’t be needed,
    so set `0`. You can leave the other settings as they are.
  prefs: []
  type: TYPE_NORMAL
- en: That completes the project setup tasks. It’s a good idea to look back through
    this section and make sure you didn’t miss anything, since the changes you’ve
    made here will affect the behavior of many game objects. You’ll see this in the
    next section, where you’ll make the player’s ship.
  prefs: []
  type: TYPE_NORMAL
- en: The player’s ship
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The player’s ship is the heart of this game. Most of the code you’ll write for
    this project will be about making the ship work. It will be controlled in the
    classic “Asteroids style, with left/right rotation and forward thrust. The player
    will also be able to fire the laser and destroy floating rocks.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4: The player’s ship](img/B19289_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: The player’s ship'
  prefs: []
  type: TYPE_NORMAL
- en: Body and physics setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new scene and add a `RigidBody2D` named `Player` as the root node,
    with `Sprite2D` and `CollisionShape2D` children. Add the `res://assets/player_ship.png`
    image to the `Sprite2D`. The ship image is quite large, so set the `Sprite2D`
    to `(0.5, 0.5)` and `90`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5: Player sprite settings](img/B19289_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: Player sprite settings'
  prefs: []
  type: TYPE_NORMAL
- en: Sprite orientation
  prefs: []
  type: TYPE_NORMAL
- en: The image for the ship is drawn pointing upward. In Godot, a rotation of `0`
    degrees points to the right (along the `x`-axis). This means that you need to
    rotate the sprite so that it will match the body’s direction. If you use art that
    is drawn in the correct orientation, you can avoid this step. However, it’s very
    common to find art that’s drawn in an upward orientation, so you should know what
    to do.
  prefs: []
  type: TYPE_NORMAL
- en: In the `CollisionShape2D`, add a `CircleShape2D` and scale it to cover the image
    as closely as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6: Player collision shape](img/B19289_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: Player collision shape'
  prefs: []
  type: TYPE_NORMAL
- en: The player ship is drawn in a pixel art style, but if you zoom in, you may notice
    it looks vary blurred and “smoothed out.” Godot’s default filter setting for drawing
    textures uses this smoothing technique, which looks good with some art, but typically
    isn’t wanted for pixel art. You can set the filtering individually on each sprite
    (in the **CanvasItem** section), or you can set it globally in **Project Settings**.
  prefs: []
  type: TYPE_NORMAL
- en: Open **Project Settings** and check the **Advanced Settings** toggle, and then
    find the **rendering/textures** section. Near the bottom, you’ll see two settings
    for **Canvas Textures**. Set **Default Texture Filter** to **Nearest**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7: Default Texture Filter settings](img/B19289_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7: Default Texture Filter settings'
  prefs: []
  type: TYPE_NORMAL
- en: Save the scene. When working on larger-scale projects, it is recommended to
    organize your scenes and scripts into folders based on each game object rather
    than saving them all in the root project folder. For example, if you make a “player”
    folder, you can save all player-related files there. This makes it easier to find
    and modify your various game objects. While this project is relatively small –
    you’ll only have a few scenes – it’s a good habit to adopt as your projects grow
    in size and complexity.
  prefs: []
  type: TYPE_NORMAL
- en: State machines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The player’s ship can be in a number of different states during gameplay. For
    example, when *alive*, the ship is visible and can be controlled by the player,
    but it is vulnerable to being hit by rocks. On the other hand, when *invulnerable*,
    the ship should appear semi-transparent, and it is immune to damage.
  prefs: []
  type: TYPE_NORMAL
- en: One way that programmers often handle situations like this is to add Boolean
    variables, or *flags*, to the code. For example, the `invulnerable` flag is set
    to `true` when the player first spawns, or `alive` is set to `false` when the
    player is dead. However, this can lead to errors and strange situations when,
    for some reason, both `alive` and `invulnerable` are set to `false` at the same
    time. What happens when a rock hits the player in this situation? It would be
    better if the ship could only be in one clearly defined state at a time.
  prefs: []
  type: TYPE_NORMAL
- en: A solution to this problem is to use a **finite state machine** (**FSM**). When
    using an FSM, an entity can only be in one state at a given time. To design your
    FSM, you define a number of states and what events or actions can cause a transition
    from one state to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts the FSM for the player’s ship:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8: State machine diagram](img/B19289_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.8: State machine diagram'
  prefs: []
  type: TYPE_NORMAL
- en: There are four states, shown by the ovals, and the arrows indicate what transitions
    can occur between states, as well as what triggers the transition. By checking
    the current state, you can decide what the player is allowed to do. For example,
    in the **DEAD** state, don’t allow input, or in the **INVULNERABLE** state, allow
    movement but don’t allow shooting.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced FSM implementations can become quite complex, and the details are beyond
    the scope of this book (see the *Appendix* for further reading). In the purest
    sense, you won’t be creating a true FSM here, but for the purposes of this project,
    it will be sufficient to illustrate the concept and keep you from running into
    the Boolean flag problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a script to the `Player` node and start by creating the skeleton of the
    FSM implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'An `enum` statement in the preceding code is equivalent to writing the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create the `change_state()` function to handle state transitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Whenever you need to change the state of the player, you’ll call the `change_state()`
    function and pass it the value of the new state. Then, by using a `match` statement,
    you can execute whatever code should accompany the transition to the new state
    or disallow it if you don’t want that transition to happen. To illustrate this,
    the `CollisionShape2D` node is being enabled/disabled by the new state. In `_ready()`,we
    set `ALIVE` as the initial state – this is for testing, but we’ll change it to
    `INIT` later.
  prefs: []
  type: TYPE_NORMAL
- en: Adding player controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the following variables at the top of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`engine_power` and `spin_power` control how fast the ship can accelerate and
    turn. `thrust` represents the force being applied by the engine: either `(0, 0)`
    when coasting or a vector pointing forward when the engine is on. `rotation_dir`
    represents in which direction the ship is turning so that you can apply a *torque*
    or rotational force.'
  prefs: []
  type: TYPE_NORMAL
- en: As we saw earlier in `1` and `5`. You can adjust these later to change how the
    ship handles.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to detect the input and move the ship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `get_input()` function captures the key actions and sets the ship’s thrust
    on or off. Note that the direction of the thrust is based on the body’s `transform.x`,
    which always represents the body’s “forward” direction (see the *Appendix* for
    an overview of transforms).
  prefs: []
  type: TYPE_NORMAL
- en: '`Input.get_axis()` returns a value based on two inputs, representing negative
    and positive values. So, `rotation_dir` will be clockwise, counter-clockwise,
    or zero, depending on the state of the two input actions.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when using physics bodies, their movement and related functions should
    always be called in `_physics_process()`. Here, you can apply the forces set by
    the inputs to actually move the body.
  prefs: []
  type: TYPE_NORMAL
- en: Play the scene, and you should be able to fly around freely.
  prefs: []
  type: TYPE_NORMAL
- en: Screen wrap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another feature of classic 2D arcade games is *screen wrap*. If the player
    goes off one side of the screen, they appear on the other side. In practice, you
    teleport the ship to the other side by instantly changing its position. You’ll
    need to know the size of the screen, so add the following variable to the top
    of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And add this to `_ready()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Later, you can have the game’s main script handle setting `screensize` for all
    the game’s objects, but for now, this will allow you to test the screen wrapping
    with just the player’s scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'When first approaching this problem, you might think you could use the body’s
    `position` property and, if it exceeds the bounds of the screen, set it to the
    opposite side. And if you were using any other node type, that would work just
    fine; however, when using `RigidBody2D`, you can’t directly set `position` because
    that would conflict with the movement that the physics engine is calculating.
    A common mistake is to try adding something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: And if you wanted to try this with the `Area2D` in *Coin Dash*, it would work
    perfectly fine. Here, it will fail, trapping the player on the edge of the screen
    and glitching unpredictably at the corners. So, what is the answer?
  prefs: []
  type: TYPE_NORMAL
- en: 'To quote the `RigidBody2D` documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: You should not change a RigidBody2D’s `position` or `linear_velocity`
    every frame or even very often. If you need to directly affect the body’s state,
    use `_integrate_forces`, which allows you to directly access the physics state.'
  prefs: []
  type: TYPE_NORMAL
- en: 'And in the description for `_integrate_forces()`:'
  prefs: []
  type: TYPE_NORMAL
- en: (It) Allows you to read and safely modify the simulation state for the object.
    Use this instead of `_physics_process` if you need to directly change the body’s
    position or other physics properties.
  prefs: []
  type: TYPE_NORMAL
- en: So, the answer is to use this separate function when you want to directly affect
    the rigid body’s position. Using `_integrate_forces(`) gives you access to the
    body’s `PhysicsDirectBodyState2D` – a Godot object containing a great deal of
    useful information about the current state of the body. Since you want to change
    the body’s location, that means you need to modify its `Transform2D`.
  prefs: []
  type: TYPE_NORMAL
- en: A `origin` property of the `Transform2D`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this information, you can implement the wrap-around effect by adding
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `wrapf()` function takes a value (the first argument) and “wraps” it between
    any min/max values you choose. So, if the value goes below `0`, it becomes `screensize.x`,
    and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you’re using `physics_state` for the parameter name rather than the
    default of `state`. This is to avoid confusion since `state` is already being
    used to track the player’s state.
  prefs: []
  type: TYPE_NORMAL
- en: Run the scene again and check that everything is working as expected. Make sure
    you try wrapping around in all four directions.
  prefs: []
  type: TYPE_NORMAL
- en: Shooting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now it’s time to give your ship some weapons. When pressing the `shoot` action,
    a bullet/laser should be spawned at the front of the ship and then travel in a
    straight line until it exits the screen. The player isn’t allowed to shoot again
    until a small amount of time has passed (also known as a **cooldown**).
  prefs: []
  type: TYPE_NORMAL
- en: Bullet scene
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the node setup for the bullet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Area2D` named `Bullet`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sprite2D`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CollisionShape2D`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VisibleOnScreenNotifier2D`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use `res://assets/laser.png` from the assets folder for the `Sprite2D` and
    a `CapsuleShape2D` for the collision shape. You’ll need to set `CollisionShape2D`
    to `90` so that it is oriented correctly. You should also scale `Sprite2D` down
    to about half the size: `(``0.5, 0.5)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following script to the `Bullet` node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You’ll call the `start()` function whenever you spawn a new bullet. By passing
    it a transform, you can give it the correct position *and* rotation – typically
    that of the ship’s gun (more about this later).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `VisibleOnScreenNotifier2D` is a node that informs you (via a signal) whenever
    a node becomes visible/invisible. You can use this to automatically delete a bullet
    that goes offscreen. Connect the node’s `screen_exited` signal and add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, connect the bullet’s `body_entered` signal so that it can detect when
    it hits a rock. The bullet doesn’t need to know anything about rocks, just that
    it has hit something. When you create the rock, you’ll add it to a group called
    `rocks` and give it an `explode()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Firing bullets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next step is to create instances of the `Bullet` scene whenever the player
    presses the `shoot` action. However, if you make the bullet a child of the player,
    then it will move and rotate along with the player instead of moving independently.
    You could add the bullet to the main scene using `get_parent().add_child()`, since
    the `Main` scene will be the parent of the player when the game is running. However,
    this would mean that you could no longer run and test the `Player` scene by itself.
    Or, if you decided to rearrange your `Main` scene, making the player a child of
    some other node, the bullet wouldn’t be added where you expect.
  prefs: []
  type: TYPE_NORMAL
- en: In general, it is a bad idea to write code that assumes a fixed tree layout.
    Especially try to avoid situations where you use `get_parent()` if at all possible.
    You may find it difficult to think this way at first, but it will result in a
    much more modular design and prevent some common mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, the `SceneTree` will always exist, and for this game, it will be
    fine to make the bullet a child of the tree’s root, which is the `Window` containing
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: Add a `Marker2D` node to the player and name it `Muzzle`. This will mark the
    muzzle of the gun – the location where the bullet will spawn. Set `(50, 0)` to
    place it directly in front of the ship.
  prefs: []
  type: TYPE_NORMAL
- en: Next, add a `Timer` node and name it `GunCooldown`. This will provide a cooldown
    to the gun, preventing a new bullet from firing until a certain amount of time
    has passed. Check the **One Shot** and **Autostart** boxes to “on.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these new variables to the player’s script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Drag the `bullet.tscn` file onto the new **Bullet** property in the Inspector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this line to `_ready()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And this to `get_input()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create the `shoot()` function, which will handle creating the bullet(s):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When shooting, you first set `can_shoot` to `false` so that the action no longer
    calls `shoot()`. Then you add the new bullet as a child of whatever node is the
    root of the scene tree. Finally, you call the bullet’s `start()` function and
    give it the muzzle node’s *global* transform. Note that if you used `transform`
    here, you’d be giving it the muzzle’s position relative to the player (which is
    `(50, 0)`, remember?), and so the bullet would spawn in entirely the wrong place.
    This is another example of how important it is to understand the distinction between
    local and global coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow the gun to shoot again, connect the `timeout` signal of `GunCooldown`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Testing the player’s ship
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Create a new scene using a `Node` named `Main` and add a `Sprite2D` named `Background`
    as a child. Use `res://assets/space_background.png` in the `Player` to the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Play the main scene and test that you can fly and shoot.
  prefs: []
  type: TYPE_NORMAL
- en: Now that your player’s ship works, it’s a good time to pause and check your
    understanding. Working with rigid bodies can be tricky; take a few minutes to
    experiment with some of the settings and code from this section. Just make sure
    to change them back before moving on to the next section, where you’ll add the
    asteroids to the game.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the rocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of the game is to destroy the floating space rocks, so now that you
    can shoot, it’s time to add them. Like the ship, the rocks will use `RigidBody2D`,
    which will make them travel in a straight line at a steady speed unless disturbed.
    They’ll also bounce off each other in a realistic fashion. To make things more
    interesting, rocks will start out large and, when you shoot them, break into multiple
    smaller rocks.
  prefs: []
  type: TYPE_NORMAL
- en: Scene setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start a new scene with a `RigidBody2D` node named `Rock`, and add a `Sprite2D`
    child using the `res://assets/rock.png` texture. Add a `CollisionShape2D`, but
    *don’t* set its shape yet. Because you’ll be spawning different-sized rocks, the
    collision shape will need to be set in code and adjusted to the correct size.
  prefs: []
  type: TYPE_NORMAL
- en: You don’t want the rocks coasting to a stop, so they need to ignore the default
    linear and angular damping. Set both `0` and `New PhysicsMaterial` and then click
    on it to expand. Set the displayed `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Variable size rocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Attach a script to `Rock` and define the member variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `Main` script will handle spawning new rocks, both at the beginning of a
    level as well as the smaller rocks that will appear after a large one explodes.
    A large rock will have a size of `3`, break into rocks of size `2`, and so on.
    The `scale_factor` is multiplied by `size` to set the `Sprite2D` scale, the collision
    radius, and so on. You can adjust this later to change how big each category of
    rock is.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of this will be set by the `start()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is where you calculate the correct collision size based on the rock’s `size`.
    Note that since `position` and `size` are already in use as class variables, you
    can use an underscore for the function’s arguments to prevent conflict.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rocks also need to wrap around the screen like the player, so use the same
    technique with `_integrate_forces()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The one difference here is that including the rock’s `radius` in the calculation
    results in smoother-looking teleportation. The rock will appear to fully exit
    the screen before entering the opposite side. You may want to do the same thing
    with the player’s ship. Try it and see which you like better.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating rocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When new rocks are spawned, the main scene will need to pick a random starting
    location. To do this, you could use some math to pick a random point along the
    perimeter of the screen, but instead, you can take advantage of another Godot
    node type. You’ll draw a path around the edge of the screen, and the script will
    pick a random location along that path.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Main` scene, add a `Path2D` node and name it `RockPath`. When you select
    the node, you will see some new buttons appear at the top of the editor window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9: Path drawing tools](img/B19289_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.9: Path drawing tools'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the middle one (**Add Point**) to draw the path by clicking the points
    shown in the following screenshot. To make the points align, make sure **Use Grid
    Snap** is checked. This option is found in the icon bar at the top of the editor
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10: Enabling grid snapping](img/B19289_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.10: Enabling grid snapping'
  prefs: []
  type: TYPE_NORMAL
- en: 'Draw the points in the order shown in the following screenshot. After clicking
    the fourth point, click the **Close Curve** button (marked *5* in the screenshot)
    and your path will be complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11: Path drawing order](img/B19289_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.11: Path drawing order'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t click in the editor window again if you have `RockPath` selected! If you
    do, you’ll add additional points to the curve, and your rocks may not spawn where
    you want them to. You can press *Ctrl* + *Z* to undo any extra points you may
    have added.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the path is defined, add a `PathFollow2D` as a child of `RockPath`
    and name it `RockSpawn`. This node’s purpose is to automatically move along its
    parent path using its **Progress** property, which represents an offset along
    the path. The higher the offset, the further along the path it goes. Since our
    path is closed, it will also loop if the offset value is bigger than the path’s
    length.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following script to `Main.gd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You start by getting the `screensize` so that you can pass it to the rocks when
    they’re spawned. Then, you spawn three rocks of size `3`. Don’t forget to drag
    `rock.tscn` onto the **Rock** property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `spawn_rock()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This function serves two purposes. When called with only a `size` parameter,
    it picks a random position along the `RockPath` and a random velocity. However,
    if those values are provided, it will use them instead. This will let you spawn
    the smaller rocks at the location of the explosion by specifying their properties.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game and you should see three rocks floating around, but your bullets
    don’t affect them.
  prefs: []
  type: TYPE_NORMAL
- en: Exploding rocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The bullet checks for bodies in the `rocks` group, so in the `Rock` scene,
    select the `rocks` and click **Add**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12: Adding a “rocks” group](img/B19289_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.12: Adding a “rocks” group'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you run the game and shoot a rock, you’ll see an error message because
    the bullet is trying to call the rock’s `explode()` method, which you haven’t
    defined yet. This method needs to do three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the rock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play an explosion animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notify `Main` to spawn new, smaller rocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explosion scene
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The explosion will be a separate scene, which you can add to the `Rock` and
    later to the `Player`. It will contain two nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Sprite2D` named `Explosion`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AnimationPlayer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the `Sprite2D` node’s `res://assets/explosion.png`. You’ll notice this is
    a `Sprite2D` node supports using them.
  prefs: []
  type: TYPE_NORMAL
- en: In the Inspector, find the sprite’s `8`. This will slice the sprite sheet into
    its 64 individual images. You can verify this by changing the `0` and `63`. Make
    sure to set it back to `0` before you continue.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13: Sprite Animation settings](img/B19289_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.13: Sprite Animation settings'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AnimationPlayer` node can be used to animate any property of any node.
    You’ll use it to change the **Frame** property over time. Start by selecting the
    node and you’ll see the **Animation** panel open at the bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14: Animation panel](img/B19289_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.14: Animation panel'
  prefs: []
  type: TYPE_NORMAL
- en: Click the `explosion`. Set `0.64` and `0.01`. Select the `Sprite2D` node and
    you’ll notice that each property in the Inspector now has a key symbol next to
    it. Clicking on a key will create a *keyframe* in the current animation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15: Animation time settings](img/B19289_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.15: Animation time settings'
  prefs: []
  type: TYPE_NORMAL
- en: Click the key next to the `Explosion` node’s `AnimationPlayer` that at time
    `0`, you want the sprite’s `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Slide the scrubber to time `0.64` (you can adjust the zoom using the slider
    if you can’t see it). Set `63` and click the key again. Now the animation knows
    to use the last image at the animation’s final time. However, you also need to
    let the `AnimationPlayer` know that you want to use all the intermediate values
    in the times between those two points. At the right side of the animation track
    is an **Update Mode** dropdown. It’s currently set to **Discrete**, and you need
    to change it to **Continuous**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16: Setting Update Mode](img/B19289_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.16: Setting Update Mode'
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Play** button in the **Animation** panel to see the animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now add the explosion to the rock. In the `Rock` scene, add an instance
    of `Explosion` and click the eye icon next to the node to make it hidden. Add
    this line to `start()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure the explosion is scaled to match the rock’s size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a signal called `exploded` at the top of the script, then add the `explode()`
    function, which will be called when the bullet hits the rock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, you hide the rock and play the explosion, waiting for it to finish before
    removing the rock. When you emit the `exploded` signal, you also include all the
    rock’s information, so that `spawn_rock()` in `Main` will be able to spawn the
    smaller rocks at the same location.
  prefs: []
  type: TYPE_NORMAL
- en: Test the game and check that you can see explosions when you shoot the rocks.
  prefs: []
  type: TYPE_NORMAL
- en: Spawning smaller rocks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Rock` scene is emitting the signal, but `Main` isn’t listening for it
    yet. You can’t connect the signal in the `spawn_rock()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This connects the rock’s signal to a function in `Main`, which you also need
    to create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this function, you create two new rocks unless the rock that was just destroyed
    was of size `1` (the smallest size). The `offset` loop variable ensures that the
    two new rocks travel in opposite directions (that is, one’s velocity will be negative).
    The `dir` variable finds the vector between the player and the rock, then uses
    `orthogonal()` to get a vector that’s perpendicular. This ensures that the new
    rocks don’t fly straight toward the player.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.17: Explosion diagram](img/B19289_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.17: Explosion diagram'
  prefs: []
  type: TYPE_NORMAL
- en: Play the game once again and check that everything is working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a good place to stop and review what you’ve done so far. You’ve completed
    all the basic functionality of the game: the player can fly around and shoot;
    the rocks float, bounce, and explode; and new rocks are spawned. You should be
    feeling more comfortable using rigid bodies at this point. In the next section,
    you’ll start building the interface to allow the player to start the game and
    see important information during gameplay.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a UI for your game can be very complex, or at least time-consuming.
    Precisely placing individual elements and ensuring they work across different-sized
    screens and devices is the least interesting part of game development for many
    programmers. Godot provides a wide variety of `Control` nodes to assist in this
    process. Learning how to use the various `Control` nodes will help lessen the
    pain of creating a polished UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this game, you don’t need a very complex UI. The game needs to provide
    the following information and interactions:'
  prefs: []
  type: TYPE_NORMAL
- en: Start button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Status message (such as “Get Ready” or “Game Over”)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Score
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lives counter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a preview of what you will make:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.18: UI layout](img/B19289_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.18: UI layout'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene and add a `CanvasLayer` node with the name `HUD` as the root
    node. You’ll build the UI on this layer using the `Control` node’s layout features.
  prefs: []
  type: TYPE_NORMAL
- en: Layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Godot’s `Control` nodes include a number of specialized containers. These nodes
    can be nested inside each other to create the exact layout you need. For example,
    a `MarginContainer` automatically adds padding around its contents, while `HBoxContainer`
    and `VBoxContainer` organize their contents in rows or columns, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to build the layout:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by adding `Timer` and `MarginContainer children`, which will hold the
    score and life counters. In the **Layout** dropdown, select **Top Wide**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.19: Top Wide control alignment](img/B19289_03_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.19: Top Wide control alignment'
  prefs: []
  type: TYPE_NORMAL
- en: In the Inspector, set the four margins in **Theme Overrides/Constants** to 20.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `Timer` to on and its `2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a child of the container, add an `HBoxContainer`, which will position the
    score counter on the left and the lives counter on the right. Under this container,
    add a `Label` (name it `ScoreLabel`) and another `HBoxContainer` (named `LivesCounter`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `ScoreLabel's` `0`, and under `res://assets/kenvector_future_thin.ttf`
    and setting the font size to `64`.
  prefs: []
  type: TYPE_NORMAL
- en: Select `LivesCounter` and set `20`, then add a child `TextureRect` and name
    it `L1`. Drag `res://assets/player_small.png` to the `L1` node selected and press
    *duplicate* (*Ctrl* + *D*) twice to create `L2` and `L3` (they’ll be named automatically).
    During the game, the `HUD` will show or hide these three textures to indicate
    how many lives the player has left.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a larger, more complex UI, you might save this section as its own scene and
    embed it in other section(s) of the UI. However, this game only needs a few more
    elements, so it’s fine to combine them all in one scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a child of `HUD`, add a `VBoxContainer`, and inside it, add a `Label` named
    `Message` and a `TextureButton` named `StartButton`. Set the layout of the `VBoxContainer`
    to `100`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `res://assets` folder, there are two textures for `StartButton`, one
    normal (`play_button.png`) and one to show when the mouse is hovering over it
    (`'play_button_h.png`). Drag these to **Textures/Normal** and **Textures/Hover**
    in the Inspector. Set the button’s **Layout/Container Sizing/Horizontal** to **Shrink
    Center** so that it will be centered horizontally.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `Message` text to “Space Rocks!” and set its font using the same settings
    as `ScoreLabel`. Set **Horizontal Alignment** to **Center**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When finished, your scene tree should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.20: HUD node layout](img/B19289_03_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.20: HUD node layout'
  prefs: []
  type: TYPE_NORMAL
- en: Scripting the UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ve completed the UI layout, now add a script to `HUD`. Since the nodes you’ll
    need to reference are located under containers, you can store references to them
    in variables at the start. Since this needs to happen after nodes are added to
    the tree, you can use the `@onready` decorator to cause the variable’s value to
    be set at the same time as the `_ready()` function runs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You’ll emit the `start_game` signal when the player clicks the `StartButton`.
    The `lives_counter` variable is an array holding references to the three life-counter
    images so they can be hidden/shown as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you need functions to handle updating the displayed information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`Main` will call these functions whenever the relevant value changes. Now add
    a function to handle the end of the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Connect the `pressed` signal of `StartButton` and the `timeout` signal of `Timer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The Main scene’s UI code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add an instance of the `HUD` scene to the `Main` scene. Add these variables
    to `main.gd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And a function to handle starting a new game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note the `$Player.reset()` line – don’t worry, you’ll add that soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the player destroys all the rocks, they’ll advance to the next level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You’ll call this function every time the level changes. It announces the level
    number and spawns a number of rocks to match. Note that since you initialized
    `level` to `0`, this will set it to `1` for the first level. You should also remove
    the code that’s spawning rocks in `_ready()` – you don’t need that anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'To detect when the level has ended, you need to check how many rocks are left:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Next, you need to connect the `HUD`’s `start_game` signal to the `new_game()`
    function of Main.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the `HUD` instance in `Main` and find its `start_game` signal in the
    `Main`, and you can select the `new_game()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.21: Connecting a signal to an existing function](img/B19289_03_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.21: Connecting a signal to an existing function'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this function to handle what happens when the game ends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Player code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the new signals and a new variable to `player.gd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: For the `lives` variable, you’ve added something called a `lives` changes, the
    `set_lives()` function will be called. This lets you automatically emit the signal
    as well as checking when it reaches `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `reset()` function is called by `Main` when a new game starts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Resetting the player means setting its position back to the center of the screen.
    As we saw before, that needs to be done in `_integrate_forces()` in order to work.
    Add this to that function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Back in the `Main` scene, select the `Player` instance and find its `lives_changed`
    signal in the `HUD` node and type `update_lives` in **Receiver Method**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.22: Connecting the player signal to HUD](img/B19289_03_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.22: Connecting the player signal to HUD'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, you made a much more complex UI than in previous projects,
    including some new `Control` nodes such as `TextureProgressBar`, and used signals
    to connect everything together. In the next section, you’ll handle the end of
    the game: what should happen when the player dies.'
  prefs: []
  type: TYPE_NORMAL
- en: Ending the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you’ll make the player detect when it is hit by rocks, add
    an invulnerability feature, and end the game when the player runs out of lives.
  prefs: []
  type: TYPE_NORMAL
- en: Add an instance of the `Explosion` scene to the `Player` scene and uncheck its
    `Timer` node named `InvulnerabilityTimer` and set `2` and **One Shot** to “on.”
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll emit the `dead` signal to notify `Main` that the game should end. Before
    that, however, you need to update the state machine to do a little more with each
    state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `modulate.a` property of a sprite sets its alpha channel (transparency).
    Setting it to `0.5` makes it semi-transparent, while `1.0` is solid.
  prefs: []
  type: TYPE_NORMAL
- en: 'After entering the `INVULNERABLE` state, you start the timer. Connect its `timeout`
    signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Detecting collisions between rigid bodies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you fly around, the ship bounces off rocks because both are rigid bodies.
    However, if you want to make something happen when two rigid bodies collide, you
    need to enable `Player` scene, select the `Player` node, and in the Inspector,
    set `1`. Now the player will emit a signal when it comes into contact with another
    body. Click on the `body_entered` signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now go to the `Main` scene and connect the `Player` instance’s `dead` signal
    to the `game_over()` method. Play the game and try running into a rock. Your ship
    should explode, become invulnerable for two seconds, and lose one life. Also check
    that the game ends if you get hit three times.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, you learned about rigid body collisions and used them to handle
    the ship colliding with rocks. The full game cycle is now complete: the start
    screen leads to gameplay, which ends with a game over display. In the remaining
    sections of the chapter, you’ll add some additional features to the game, such
    as a pause function.'
  prefs: []
  type: TYPE_NORMAL
- en: Pausing the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many games require some sort of pause mode to allow the player to take a break
    from the action. In Godot, pausing is a function of the `SceneTree` and can be
    set using its `paused` property. When the `SceneTree` is paused, three things
    happen:'
  prefs: []
  type: TYPE_NORMAL
- en: The physics thread stops running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_process()` and `_physics_process()` are no longer called on any nodes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `_input()` and `_input_event()` methods are also not called for inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When pause mode is triggered, every node in the running game reacts accordingly,
    based on how you’ve configured it. This behavior is set via the node’s **Process/Mode**
    property, which you’ll find near the bottom of the Inspector list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pause mode can be set to the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Inherit` – The node uses the same mode as its parent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pausable` – The node pauses when the scene tree is paused'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`When Paused` – The node only runs when the tree is paused'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Always` – The node always runs, ignoring the tree’s paused state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Disabled` – The node never runs, ignoring the tree’s paused state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open the `pause`. Assign a key you’d like to use to toggle pause mode. `P` is
    a good choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following function to `Main.gd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This code detects pressing the key and toggles the tree’s `paused` state to
    the opposite of its current state. It also displays **Paused** on the screen so
    that it doesn’t just appear that the game has frozen.
  prefs: []
  type: TYPE_NORMAL
- en: If you were to run the game now, you’d have a problem – all nodes are paused,
    including `Main`. That means it’s not processing `_input()` anymore, so it can’t
    detect the input again to unpause the game! To fix this, set `Main` node to **Always**.
  prefs: []
  type: TYPE_NORMAL
- en: The pause function is a very useful one to know about. You can use this technique
    in any game you make, so review it to make sure you understand how it works. You
    can even try going back and adding it to *Coin Dash*. Our next section adds to
    the action by adding enemies to the game.
  prefs: []
  type: TYPE_NORMAL
- en: Enemies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Space is filled with more dangers than just rocks. In this section, you’ll create
    an enemy spaceship that will periodically appear and shoot at the player.
  prefs: []
  type: TYPE_NORMAL
- en: Following a path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the enemy appears, it should follow a path across the screen. It’ll also
    look better if it’s not just a straight line. To keep it from looking too repetitive,
    you can create multiple paths and randomly choose one when the enemy appears.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new scene and add a `Node`. Name it `EnemyPaths` and save it. To draw
    the path, add a `Path2D` node. As you saw earlier, this node allows you to draw
    a series of connected points. Selecting this node displays a new menu bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.23: Path drawing options](img/B19289_03_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.23: Path drawing options'
  prefs: []
  type: TYPE_NORMAL
- en: 'These buttons let you draw and modify the path’s points. Click the one with
    the green **+** symbol to add points. Click to start the path somewhere just outside
    the game window, and then click a few more points to make a curve. Note that the
    arrows indicate the direction of the path. Don’t worry about making it smooth
    yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.24: An example path](img/B19289_03_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.24: An example path'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the enemy follows the path, it will not look very smooth when it hits
    the sharp corners. To smooth the curve, click the second button in the path toolbar
    (its tooltip says **Select Control Points**). Now, if you click and drag any of
    the curve’s points, you will add a control point that allows you to curve the
    line at that point. Smoothing the line above results in something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.25: Using control points](img/B19289_03_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.25: Using control points'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add two or three more `Path2D` nodes to the scene and draw the paths however
    you like. Adding loops and curves rather than straight lines will make the enemy
    look more dynamic (and make it harder to hit). Remember that the first point you
    click will be the start of the path, so make sure to start them on different sides
    of the screen for variety. Here are three example paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.26: Adding multiple paths](img/B19289_03_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.26: Adding multiple paths'
  prefs: []
  type: TYPE_NORMAL
- en: Save the scene. You’ll add this to the enemy’s scene to give it the paths it
    can follow.
  prefs: []
  type: TYPE_NORMAL
- en: Enemy scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new scene for the enemy, using an `Area2D` as its root node. Add a
    `Sprite2D` child and use `res://assets/enemy_saucer.png` as its `3` so that you
    can choose between the different colored saucers:'
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve done before, add a `CollisionShape2D` and give it a `CircleShape2D`
    scaled to cover the image. Add an instance of the `EnemyPaths` scene and an `AnimationPlayer`.
    In the `AnimationPlayer`, you’ll add an animation to create a flash effect when
    the saucer is hit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an animation named `flash`. Set `0.25` and `0.01`. The property you’ll be
    animating is the `Sprite2D`’s `0.04` and change the `0.04` and change the color
    back to white.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat this process two more times so that you have three flashes in total.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an instance of the `Explosion` scene and hide it. Add a `Timer` node named
    `GunCooldown` to control how often the enemy will shoot. Set `1.5` and **Autostart**
    to on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a script to the enemy and connect the timer’s `timeout`. Don’t add anything
    to the function yet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `enemies`. As with the rocks, this will give you a way to identify the
    object, even if there are multiple enemies on the screen at the same time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Moving the enemy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin, you’ll write the code to select a path and move the enemy along it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Recall that the `PathFollow2D` node automatically moves along a parent `Path2D`.
    By default, it loops around the path when it reaches the end, so you need to set
    that to `false` to disable it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to move along the path and remove the enemy when it reaches
    the end of the path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: You can detect the end of the path when `progress` is greater than the total
    path length. However, it’s more straightforward to use `progress_ratio`, which
    varies from zero to one over the length of the path, so you don’t need to know
    how long each path is.
  prefs: []
  type: TYPE_NORMAL
- en: Spawning enemies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `Main` scene, add a new `Timer` node called `EnemyTimer`. Set its `main.gd`,
    add a variable to reference the enemy scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Add this line to `new_level()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Connect the `EnemyTimer`’s `timeout` signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This code instances the enemy whenever `EnemyTimer` times out. You don’t want
    another enemy for a while, so the timer is restarted with a longer delay.
  prefs: []
  type: TYPE_NORMAL
- en: Play the game, and you should see a saucer appear and fly along its path.
  prefs: []
  type: TYPE_NORMAL
- en: Shooting and collisions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The enemy needs to shoot at the player as well as react when hit by the player
    or the player’s bullets.
  prefs: []
  type: TYPE_NORMAL
- en: The enemy’s bullet will be similar to the player’s, but we’ll use a different
    texture. You can create it again from scratch or use the following process to
    reuse the node setup.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Bullet` scene and choose `enemy_bullet.tscn` (afterward, don’t forget
    to rename the root node as well). Remove the script by clicking the **Detach the
    script** button. Disconnect the signal connections by clicking the **Node** tab
    and choosing **Disconnect**. You can see which nodes have their signals connected
    by looking for the ![](img/B19289_03_27.png) icon next to the node name.
  prefs: []
  type: TYPE_NORMAL
- en: Replace the sprite’s texture with the `laser_green.png` image, and add a new
    script to the root node.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script for the enemy bullet will be very similar to the regular bullet.
    Connect the area’s `body_entered` signal and the `screen_exited` signal of `VisibleOnScreenNotifier2D`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note that you’ll need to specify a position and direction for the bullet. That’s
    because, unlike the player, who always shoots forward, the enemy will always shoot
    toward the player.
  prefs: []
  type: TYPE_NORMAL
- en: For now, the bullet won’t do any damage to the player. You’ll be adding a shield
    to the player in the next section, so you can add it at that time.
  prefs: []
  type: TYPE_NORMAL
- en: Save the scene and drag it into the `Enemy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `enemy.gd`, add a variable for some random variation to the bullet, and
    the `shoot()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: First, you find the vector pointing to the player’s position, then add a little
    bit of randomness so that it can “miss.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Call the `shoot()` function whenever `GunCooldown` times out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'For an extra challenge, you can make the enemy shoot in pulses or multiple
    rapid shots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This will shoot a given number of bullets, `n`, with `delay` seconds between
    them. You can call this instead when the cooldown triggers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This will shoot a pulse of `3` bullets with `0.15` seconds between them. Tough
    to dodge!
  prefs: []
  type: TYPE_NORMAL
- en: Next, the enemy needs to take damage when it’s hit by a shot from the player.
    It will flash using the animation you made and then explode when its health reaches
    `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these functions to `enemy.gd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, connect the enemy’s `body_entered` signal so that the enemy will explode
    if the player runs into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Again, you’re waiting for the player shield to be implemented before doing damage
    to the player, so for now, this collision only destroys the enemy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, the player’s bullet is only detecting rocks because its `body_entered`
    signal isn’t triggered by the enemy, which is an `Area2D`. To detect the enemy,
    go to the `Bullet` scene and connect the `area_entered` signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Try playing the game again and you’ll be doing battle with an aggressive alien
    opponent! Verify that all the collision combinations are being handled (except
    for the enemy shooting the player). Also note that the enemy’s bullets can be
    blocked by rocks – maybe you can hide behind them for cover!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the game has enemies, it’s a lot more challenging. If you still find
    it too easy, try increasing the enemy’s properties: how often it appears, how
    much damage it does, and how many shots it takes to destroy it. It’s OK if you
    make it too hard because, in the next section, you’ll give the player a little
    help by adding a shield to absorb damage.'
  prefs: []
  type: TYPE_NORMAL
- en: Player shield
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you’ll add a shield to the player and a display element to
    the `HUD` showing the current shield level.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the following to the top of the `player.gd` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `shield` variable works similarly to `lives`, emitting a signal whenever
    it changes. Since the value will be added to by the shield’s regeneration, you
    need to make sure it doesn’t go above the `max_shield` value. Then, when you emit
    the `shield_changed` signal, you pass the ratio of `shield` / `max_shield` rather
    than the actual value. This way, the `HUD`’s display doesn’t need to know anything
    about how big the shield actually is, just its percentage.
  prefs: []
  type: TYPE_NORMAL
- en: You should also remove the `explode()` line from `_on_body_entered()`, since
    you now don’t want just hitting a rock to blow up the ship – that will now only
    happen when the shield runs out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hitting a rock will damage the shield, and bigger rocks should do more damage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The enemy’s bullets should also do damage, so make this change to `enemy_bullet.gd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, running into the enemy should damage the player, so update this in `enemy.gd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'If the player’s shield runs out and they lose a life, you should reset the
    shield to its maximum. Add this line to `set_lives()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The last addition to the player script is to regenerate the shield each frame.
    Add this line to `_process()` in `player.gd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Now that the code is complete, you need to add a new display element to the
    `HUD` scene. Rather than display the shield’s value as a number, you’ll make a
    `TextureProgressBar` is a `Control` node that displays a given value as a filled
    bar. It also allows you to assign a texture to be used for the bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the `HUD` scene and add two new nodes as children of the existing `HBoxContainer`:
    `TextureRect` and `TextureProgressBar`. Rename `TextureProgressBar` to `ShieldBar`.
    Place them after the `Score` label and before `LivesCounter`. Your node setup
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.27: Updated HUD node layout](img/B19289_03_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.27: Updated HUD node layout'
  prefs: []
  type: TYPE_NORMAL
- en: Drag `res://assets/shield_gold.png` into the `TextureRect`. This will be an
    icon indicating that this bar shows the shield value. Change **Stretch Mode**
    to **Keep Centered** so that the texture won’t be distorted.
  prefs: []
  type: TYPE_NORMAL
- en: The `ShieldBar` has three `res://assets/bar_green_200.png` into this property.
    The other two texture properties let you customize the appearance by setting an
    image to be drawn above or below the progress texture. Drag `res://assets/bar_glass_200.png`
    into the **Over** property.
  prefs: []
  type: TYPE_NORMAL
- en: In the `0` and `1`, as this bar will show the ratio of the shield to its maximum,
    not its numerical value. This means `0.01`. `.75` to see the bar partly filled.
    Also, in the **Layout/Container Sizing** section, check the **Expand** box and
    set **Vertical** to **Shrink Center**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `HUD` should look like this when you’re done:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.28: Updated HUD with shield bar](img/B19289_03_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.28: Updated HUD with shield bar'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now update the script to set the value of the shield bar, as well as
    to make it change color as it gets closer to zero. Add these variables to `hud.gd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to the green bar, you also have red and yellow bars in the `assets`
    folder. This allows you to change the shield bar’s color as the value decreases.
    Loading the textures in this way makes them easier to access later in the script
    when you want to assign the appropriate image to the bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Finally, click on the `Main` scene’s `Player` node and connect the `shield_changed`
    signal to the `HUD`’s `update_shield()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game and verify that the shield is working. You may want to increase
    or decrease the shield regeneration rate to give it a speed you’re happy with.
    When you’re ready to move on, in the next section, you’ll add some sound to the
    game.
  prefs: []
  type: TYPE_NORMAL
- en: Sound and visual effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The structure and gameplay of the game is complete. In this section, you’ll
    add some additional effects to the game to improve the game experience.
  prefs: []
  type: TYPE_NORMAL
- en: Sound and music
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `res://assets/sounds` folder are several audio effects for the game.
    To play a sound, it needs to be loaded by an `AudioStreamPlayer` node. Add two
    of these nodes to the `Player` scene, naming them `LaserSound` and `EngineSound`.
    Drag the respective sound files into each node’s `shoot()` in `player.gd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Play the game and try shooting. If you find the sound too loud, you can adjust
    the `-10` to start.
  prefs: []
  type: TYPE_NORMAL
- en: 'The engine sounds works a little differently. It needs to play when the thrust
    is on, but if you just try to call `play()` on the sound in the `get_input()`
    function when the player presses the key, it will restart the sound every frame.
    This doesn’t sound good, so you only want to start playing the sound if it isn’t
    already playing. Here is the relevant section of the `get_input()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that a problem can occur: if the player dies while holding down the thrust
    key, the engine sound will remain stuck playing because, in the `$EngineSound.stop()`
    to the `change_state()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Main` scene, add three more `AudioStreamPlayer` nodes: `ExplosionSound`,
    `LevelupSound`, and `Music`. In their `explosion.wav`, `levelup.ogg`, and `Funky-Gameplay_Looping.ogg`.'
  prefs: []
  type: TYPE_NORMAL
- en: Add `$ExplosionSound.play()` as the first line of `_on_rock_exploded()`, and
    add `$LevelupSound.play()` to `new_level()`.
  prefs: []
  type: TYPE_NORMAL
- en: To start and stop the background music, add `$Music.play()` to `new_game()`
    and `$Music.stop()` to `game_over()`.
  prefs: []
  type: TYPE_NORMAL
- en: The enemy also needs `ExplosionSound` and `ShootSound` nodes. You can use `enemy_laser.wav`
    for their shooting sound.
  prefs: []
  type: TYPE_NORMAL
- en: Particles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The player ship’s thrust is a perfect use of particle effects, creating a streaming
    flame from the engine.
  prefs: []
  type: TYPE_NORMAL
- en: Add a `CPUParticles2D` node and name it `Exhaust`. You might want to zoom in
    on the ship while you’re doing this part.
  prefs: []
  type: TYPE_NORMAL
- en: Particle node types
  prefs: []
  type: TYPE_NORMAL
- en: 'Godot offers two types of particle nodes: one that uses the CPU and one that
    uses the GPU for rendering. Since not all platforms, especially mobile or older
    desktops, support hardware acceleration for particles, you can use the CPU version
    for wider compatibility. If you know your game will be running on more powerful
    systems, you can use the GPU version.'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll see a line of white dots streaming down from the center of the ship.
    Your challenge now is to turn those dots into an exhaust flame.
  prefs: []
  type: TYPE_NORMAL
- en: There are a very large number of properties to choose from when configuring
    particles. As you go through the process of setting up this effect, feel free
    to experiment with them to see how they affect the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set these properties of the `Exhaust` node:'
  prefs: []
  type: TYPE_NORMAL
- en: '`25`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Drawing/Local** **Coords**: On'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(-``28, 0)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`180`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visibility/Show Behind** **Parent**: On'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remaining properties you’ll change will affect the behavior of the particles.
    Start with `(1, 5)`. The particles are now emitted over a small area instead of
    a single point.
  prefs: []
  type: TYPE_NORMAL
- en: Next, set `0` and `(0, 0)`. Note that the particles are not falling or spreading
    out, although they are moving very slowly.
  prefs: []
  type: TYPE_NORMAL
- en: Set `400`, then scroll down to `8`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the size change over time, you can set **Scale Amount Curve**. Select
    **New Curve** and then click to open it. In the small graph that shows, right-click
    to add two points – one on the left and one on the right. Drag the right-hand
    dot down until the curve looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.29: Adding a particle scale curve](img/B19289_03_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.29: Adding a particle scale curve'
  prefs: []
  type: TYPE_NORMAL
- en: You should now see the particles shrinking as they stream out from the back
    of the ship.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last section to adjust is **Color**. To make the particles appear like
    a flame, they should start out bright orange-yellow and shift to red as they fade
    out. In the **Color Ramp** property, click on **New Gradient**, and you’ll see
    a gradient editor that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.30: Color Ramp settings](img/B19289_03_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.30: Color Ramp settings'
  prefs: []
  type: TYPE_NORMAL
- en: The two rectangular sliders labeled *1* and *2* set the starting and ending
    colors of the gradient. Clicking on either of them will show its color in the
    box labeled *3*. Select slider *1* and then click box *3* to open a color picker.
    Choose an orange color, and then do the same for slider *2*, choosing a dark red.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the particles have the correct appearance, they’re lasting far too
    long. In the node’s `0.1`.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, your ship’s exhaust looks somewhat like a flame. If it doesn’t, feel
    free to adjust the properties until you are happy with how it looks.
  prefs: []
  type: TYPE_NORMAL
- en: Once the flame is looking good, it needs to be turned on and off based on the
    player’s input. Go to `player.gd` and add `$Exhaust.emitting = false` at the beginning
    of `get_input()`. Then, under the `if` statement that checks for `thrust` input,
    add `$Exhaust.emitting =` `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Enemy trail
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also use particles to give the enemy saucer a sparkling trail. Add
    a `CPUParticles2D` to the enemy scene and configure these settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`20`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visibility/Show Behind** **Parent**: On'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sphere`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`25`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(``0, 0)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should now have particles appearing all across the radius of the saucer
    (you can hide the `Sprite2D` during this part if you want to see them better).
    The default shape for particles is a square, but you can also use a texture for
    even more visual appeal. Add `res://assets/corona.png` to **Drawing/Texture**.
  prefs: []
  type: TYPE_NORMAL
- en: This image gives a nice glowing effect, but it’s quite large compared to the
    saucer, so set `0.1`. You’ll also notice that this image is white on a black background.
    In order to look correct, it needs its **blend mode** changed. To do this, find
    the **Material** property and select **New CanvasItemMaterial**. There, you can
    change **Blend Mode** from **Mix** to **Add**.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can make the particles fade away by using **Scale Amount Curve**
    in the **Scale** section, just as you did with the player particles.
  prefs: []
  type: TYPE_NORMAL
- en: Play your game and admire the effects. What else could you add with particles?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to work with `RigidBody2D` nodes and learned
    more about how Godot’s physics works. You also implemented a basic finite state
    machine – something you’ll find useful as your projects grow larger and that you’ll
    use again in future chapters. You saw how `Container` nodes help organize and
    keep UI nodes aligned. Finally, you added sound effects and got your first taste
    of advanced visual effects by using the `Animation` and `CPUParticles2D` nodes.
  prefs: []
  type: TYPE_NORMAL
- en: You also continued to create game objects using standard Godot hierarchies,
    such as `CollisionShapes` attached to `CollisionObjects` and signals being used
    to handle communication between nodes. At this point, these practices should be
    starting to look familiar to you.
  prefs: []
  type: TYPE_NORMAL
- en: Are you prepared to try and remake this project on your own? Try repeating all,
    or even part, of this chapter without looking at the book. It’s a good way to
    check what information you absorbed and what you need to review again. You can
    also try remaking it with your own variations rather than making an exact copy.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re ready to move on, in the next chapter, you’ll make another style
    of game that’s very popular: a platformer in the tradition of Super Mario Bros.'
  prefs: []
  type: TYPE_NORMAL
