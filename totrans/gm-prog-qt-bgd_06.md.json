["```cpp\nQGraphicsItem *parentItem = new QGraphicsItem();\nQGraphicsItem *firstChildItem = new QGraphicsItem(parentItem);\nQGraphicsItem *secondChildItem = new QGraphicsItem();\nsecondChildItem->setParentItem(parentItem);\ndelete parentItem;\n\n```", "```cpp\nif (!d_ptr->children.isEmpty()) {\n  while (!d_ptr->children.isEmpty())\n    delete d_ptr->children.first();\n  Q_ASSERT(d_ptr->children.isEmpty());\n}\n```", "```cpp\nclass BlackRectangle : public QGraphicsItem {\npublic:\n  explicit BlackRectangle(QGraphicsItem *parent = 0)\n    : QGraphicsItem(parent) {}\n  virtual ~BlackRectangle() {}\n\n  QRectF boundingRect() const {\n    return QRectF(0, 0, 75, 25);\n  }\n\n  void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget) {\n    Q_UNUSED(option)\n    Q_UNUSED(widget)\n    painter->fillRect(boundingRect(), Qt::black);\n  }\n};\n```", "```cpp\nvoid paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget) {\n  Q_UNUSED(widget)\n  if (option->state & QStyle::State_Selected)\n    painter->fillRect(boundingRect(), Qt::red);\n  else\n    painter->fillRect(boundingRect(), Qt::black);\n}\n```", "```cpp\nif (option->state.testFlag(QStyle::State_Selected))\n```", "```cpp\nclass BlackRectangle : public QGraphicsItem {\npublic:\n  BlackRectangle(QGraphicsItem *parent = 0)\n    : QGraphicsItem(parent), m_rect(0, 0, 75, 25) {}\n//...\n  QRectF boundingRect() const {\n    return m_rect;\n  }\n//...\n  QRectF rect() const {\n    return m_rect;\n  }\n  void setRect(const QRectF& rect) {\n    if (rect == m_rect)\n      return;\n    prepareGeometryChange();\n    m_rect = rect;\n}\nprivate:\n  QRectF m_rect;\n};\n```", "```cpp\nQGraphicsRectItem *item = new QGraphicsRectItem();\nitem->setRect(QRectF(0, 0, 25, 25));\n```", "```cpp\nQGraphicsRectItem *item = new QGraphicsRectItem(QRectF(0, 0, 25, 25));\n```", "```cpp\nQGraphicsRectItem *item = new QGraphicsRectItem(0, 0, 25, 25);\n```", "```cpp\nQGraphicsRectItem *itemA = QGraphicsRectItem(-10, -10, 20, 20);\nQGraphicsRectItem *itemB = QGraphicsRectItem(0, 0, 20, 20);\nQGraphicsRectItem *itemC = QGraphicsRectItem(10, 10, 20, 20);\n```", "```cpp\nitemB->setRotation(-45);\n```", "```cpp\nQGraphicsRectItem *itemC = QGraphicsRectItem(10, 10, 20, 20);\nitemC->setTransformOriginPoint(20, 20);\nitemC->rotate(-45);\n```", "```cpp\nQGraphicsItem *item = new QGraphicsRectItem(0, 0, 5, 5);\nQGraphicsRectItem *rectItem = qgraphicsitem_cast<QGraphicsRectItem*>(item);\nif (rectItem)\n  rectItem->setRect(0, 0, 10, 15);\n```", "```cpp\nQGraphicsScene scene;\nQGraphicsRectItem *rectItem = new QGraphicsRectItem(0,0,50,50);\nscene.addItem(rectItem);\n```", "```cpp\nQGraphicsScene firstScene;\nQGraphicsScene secondScene;\nQGraphicsRectItem *item = new QGraphicsRectItem;\nfirstScene.addItem(item);\nqDebug() << firstScene.items().count(); // 1\nsecondScene.addItem(item);\nqDebug() << firstScene.items().count(); // 0\n```", "```cpp\nQGraphicsScene scene;\nQGraphicsRectItem *rectItem = new QGraphicsRectItem();\nrectItem->setRect(0,0,50,50);\nrectItem->setBrush(Qt::green);\nrectItem->setPen(QColor(255,0,0));\nscene.addItem(rectItem);\n```", "```cpp\nQRect rect = scene.sceneRect().toAlignedRect();\nQImage image(rect.size(), QImage::Format_ARGB32);\nimage.fill(Qt::transparent);\nQPainter painter(&image);\nscene.render(&painter);\nimage.save(\"scene.png\", \"PNG\");\n```", "```cpp\nQGraphicsScene scene;\nQGraphicsRectItem *item = QGraphicsRectItem(0, 0, 10, 10);\nscene.addItem(item);\nitem.setPos(50,50);\n```", "```cpp\nQGraphicsScene scene;\nQGraphicsRectItem *rectA = new QGraphicsRectItem(0,0,45,45);\nQGraphicsRectItem *rectB = new QGraphicsRectItem(0,0,45,45);\nQGraphicsRectItem *rectC = new QGraphicsRectItem(0,0,45,45);\nQGraphicsRectItem *rectD = new QGraphicsRectItem(0,0,45,45);\nrectB->moveBy(50,0);\nrectC->moveBy(0,50);\nrectD->moveBy(50,50);\nQGraphicsItemGroup *group = new QGraphicsItemGroup;\ngroup->addToGroup(rectA);\ngroup->addToGroup(rectB);\ngroup->addToGroup(rectC);\nrectD->setGroup(group);\ngroup->setRotation(70);\nrectA->setRotation(-25);\nrectB->setRotation(-25);\nrectC->setRotation(-25);\nrectD->setRotation(-25);\nscene.addItem(group);\n```", "```cpp\n#include <QApplication>\n#include <QGraphicsView>\n#include <QGraphicsRectItem>\nint main(int argc, char *argv[]) {\n  QApplication app(argc, argv);\n  QGraphicsScene scene;\n  scene.addEllipse(QRectF(0, 0, 100, 100), QColor(0, 0, 0));\n  scene.addLine(0, 50, 100, 50, QColor(0, 0, 255));\n  QGraphicsRectItem *item = scene.addRect(0, 0, 25, 25, Qt::NoPen, Qt::red);\n  item->setPos(scene.sceneRect().center() - item->rect().center());\n  QGraphicsView view;\n  view.setScene(&scene);\n  view.show();\n  return app.exec();\n}\n```", "```cpp\nQGraphicsEllipseItem *item = new QGraphicsEllipseItem;\nitem->setRect(0, 0, 100, 100);\nitem->setPen(QColor(0, 0, 0));\nscene.addItem(item);\n```", "```cpp\nview.setRenderHint(QPainter::Antialiasing);\n```", "```cpp\nQGraphicsLineItem *line = scene.addLine(0, 50, 100, 50, QColor (0, 0, 255));\nconst qreal shift = line->pen().widthF() / 2.0;\nline->moveBy(-shift, -shift);\n```", "```cpp\nline->setPosition(item.pos() - QPointF(shift, shift))\n```", "```cpp\nvoid ScaleItem::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget) {\n  Q_UNUSED(option)\n  Q_UNUSED(widget)\n  const QPen oldPen = painter->pen();\n\n  const QRectF r = rect();\n  const QColor fillColor = Qt::red;\n  const qreal square = r.width() / 10.0;\n  painter->fillRect(QRectF(0, 0, square, square), fillColor);\n  painter->fillRect(QRectF(r.width() - square, 0, square, square), fillColor);\n  painter->fillRect(QRectF(0,r.height() - square, square, square), fillColor);\n  painter->fillRect(QRectF(r.width() - square, r.height() - square,square, square), fillColor);\n\n  painter->setPen(Qt::black);\n  painter->drawRect(r);\n  painter->drawLine(r.topLeft(), r.bottomRight());\n  painter->drawLine(r.topRight(), r.bottomLeft());\n  const qreal padding = r.width() / 4;\n  painter->drawRect(r.adjusted(padding, padding, -padding, - padding));\n\n  painter->setPen(oldPen);\n}\n```", "```cpp\nvoid MyView::wheelEvent(QWheelEvent *event) {\n  const qreal factor = 1.1;\n  if (event->angleDelta().y() > 0)\n    scale(factor, factor);\n  else\n    scale(1/factor, 1/factor);\n}\n```", "```cpp\nvoid MyView::mousePressEvent(QMouseEvent *event) {\n  if (Qt::LeftButton == event->button()) {\n    m_pressed = true;\n    m_lastMousePos = event->pos();\n  }\n  QGraphicsView::mousePressEvent(event);\n}\n\nvoid MyView::mouseReleaseEvent(QMouseEvent *event) {\n  if (Qt::LeftButton == event->button())\n    m_pressed = false;\n  QGraphicsView::mouseReleaseEvent(event);\n}\n```", "```cpp\nvoid MyView::mouseMoveEvent(QMouseEvent *event) {\n  if (!m_pressed)\n    return QGraphicsView::mouseMoveEvent(event);\n\n  QPoint diff = m_lastMousePos - event->pos();\n  if (QScrollBar *hbar = horizontalScrollBar())\n    hbar->setValue(hbar->value() + diff.x());\n  if (QScrollBar *vbar = verticalScrollBar())\n    vbar->setValue(vbar->value() + diff.y());\n  m_lastMousePos = event->pos();\n  return QGraphicsView::mouseMoveEvent(event);\n}\n```", "```cpp\nvoid MyView::mousePressEvent(QMouseEvent *event) {\n  if (Qt::LeftButton == event->button()\n    && (event->modifiers() & Qt::ShiftModifier)) {\n    m_pressed = true;\n      //...\n```", "```cpp\nconst qreal detail = option->levelOfDetailFromTransform(painter->worldTransform());\nconst QColor fillColor = (detail >= 5) ? Qt::yellow : Qt::red;\n```", "```cpp\npainter->setPen(Qt::black);\n```", "```cpp\nQPen p(Qt::black);\np.setCosmetic(true);\npainter->setPen(p);\n```", "```cpp\nPlayer::Player(QGraphicsItem *parent)\n  : QGraphicsPixmapItem(parent), m_direction(0) {\n    setPixmap(QPixmap(\":/elephant\"));\n    setTransformOriginPoint(boundingRect().center());\n}\n```", "```cpp\nint Player::direction() const {\n  return m_direction;\n}\n```", "```cpp\nvoid Player::addDirection(int direction) {\n  direction = qBound(-1, direction, 1);\n  m_direction += direction;\n  if (0 == m_direction)\n    return;\n\n  if (-1 == m_direction)\n    setTransform(QTransform(-1, 0, 0, 1, boundingRect().width(), 0));\n  else\n    setTransform(QTransform());\n}\n```", "```cpp\nm_timer.setInterval(30);\nconnect(&m_timer, &QTimer::timeout, this, &MyScene::movePlayer);\n```", "```cpp\nvoid MyScene::keyPressEvent(QKeyEvent *event) {\n  if (event->isAutoRepeat())\n    return;\n\n  switch (event->key()) {\n    case Qt::Key_Right:\n      m_player->addDirection(1);\n      checkTimer();\n      break;\n    case Qt::Key_Left:\n      m_player->addDirection(-1);\n      checkTimer();\n      break;\n    //...\n    default:\n      break;\n  }\n}\n```", "```cpp\nvoid MyScene::checkTimer() {\n  if (0 == m_player->direction())\n    m_timer.stop();\n  else if (!m_timer.isActive())\n    m_timer.start();\n}\n```", "```cpp\nvoid MyScene::movePlayer() {\n  const int direction = m_player->direction();\n  if (0 == direction)\n    return;\n```", "```cpp\n  const int dx = direction * m_velocity;\n  qreal newPos = m_realPos + dx;\n  newPos = qBound(m_minX, newPos, m_maxX);\n  if (newPos == m_realPos)\n    return;\n  m_realPos = newPos;\n```", "```cpp\n  const int leftBorder = 150;\n  const int rightBorder = 350 - m_player->boundingRect().width();\n```", "```cpp\n  if (direction > 0) {\n    if (m_realPos > m_fieldWidth - (width() - rightBorder)) {\n      m_player->moveBy(dx, 0);\n    } else {\n      if (m_realPos - m_skippedMoving < rightBorder) {\n        m_player->moveBy(dx, 0);\n      } else {\n        m_skippedMoving += dx;\n      }\n    }\n  } else {\n    if (m_realPos < leftBorder && m_realPos >= m_minX) {\n      m_player->moveBy(dx, 0);\n    } else {\n      if (m_realPos - m_skippedMoving > leftBorder) {\n        m_player->moveBy(dx, 0);\n      } else {\n        m_skippedMoving = qMax(0, m_skippedMoving + dx);\n      }\n    }\n  }\n  //...\n}\n```", "```cpp\nqreal ff = qMin(1.0, m_skippedMoving/(m_fieldWidth - width()));\nm_sky->setPos(-(m_sky->boundingRect().width() - width()) * ff, 0);\nm_grass->setPos(-(m_grass->boundingRect().width() - width()) * ff, m_grass->y());\nm_trees->setPos(-(m_trees->boundingRect().width() - width()) * ff, m_trees->y());\nm_ground->setPos(-(m_ground->boundingRect().width() - width()) * ff, m_ground->y());\n```", "```cpp\nclass Player : public QObject, public QGraphicsPixmapItem {\n  Q_OBJECT\n```", "```cpp\nQ_PROPERTY(qreal jumpFactor READ jumpFactor WRITE setjumpFactor NOTIFY jumpFactorChanged)\n```", "```cpp\nvoid Player::setjumpFactor(const qreal pos) {\n  if (pos == m_jumpFactor)\n    return;\n  m_jumpFactor = pos;\n  emit jumpFactorChanged(m_jumpFactor);\n}\n```", "```cpp\nm_animation = new QPropertyAnimation(this);\nm_animation->setTargetObject(this);\nm_animation->setPropertyName(\"jumpFactor\");\nm_animation->setStartValue(0);\nm_animation->setKeyValueAt(0.5, 1);\nm_animation->setEndValue(0);\nm_animation->setDuration(800);\nm_animation->setEasingCurve(QEasingCurve::OutInQuad);\n```", "```cpp\nvoid Player::jump() {\n  if (QAbstractAnimation::Stopped == m_animation->state())\n    m_animation->start();\n}\n```", "```cpp\ncase Qt::Key_Space:\n  m_player->jump();\n  break;\n```", "```cpp\nvoid MyScene::jumpPlayer(qreal factor) {\n  const qreal y = (m_groundLevel - m_player->boundingRect().height()) - factor * m_jumpHeight;\n  m_player->setPos(m_player->pos().x(), y);\n  //...\n}\n```", "```cpp\nQ_PROPERTY(qreal opacity READ opacity WRITE setOpacity)\nQ_PROPERTY(QRectF rect READ rect WRITE setRect)\n```", "```cpp\nQPropertyAnimation *fadeAnimation = /* set up */\nQPropertyAnimation *scaleAnimation = /* set up */\nQParallelAnimationGroup *group = new QParallelAnimationGroup(this);\ngroup->addAnimation(fadeAnimation);\ngroup->addAnimation(scaleAnimation);\ngroup->start();\n```", "```cpp\nQList<QGraphicsItem*> items =  collidingItems(m_player);\nfor (int i = 0, total = items.count(); i < total; ++i) {\n  if (Coin *c = qgraphicsitem_cast<Coin*>(items.at(i)))\n    c->explode();\n}\n```", "```cpp\nQPainterPath BackgroundItem::shape() const {\n  return QPainterPath();\n}\n```", "```cpp\nconst int xrange = (m_maxX - m_minX) * 0.94;\nm_coins = new QGraphicsRectItem(0,0,m_fieldWidth, m_jumpHeight);\nm_coins->setPen(Qt::NoPen);\nfor (int i = 0; i < 25; ++i) {\n  Coin *c = new Coin(m_coins);\n  c->setPos(m_minX + qrand()%xrange, qrand()%m_jumpHeight);\n}\naddItem(m_coins);\nm_coins->setPos(0, m_groundLevel - m_jumpHeight);\n```", "```cpp\nm_coins->setPos(-(m_coins->boundingRect().width() - width()) * ff,m_coins->y());\n```", "```cpp\nQTimeLine *timeLine = new QTimeLine(5000, this);\ntimeLine->setFrameRange(0, 10);\n```", "```cpp\nQSpinBox *box = new QSpinBox;\nQGraphicsProxyWidget *proxyItem = new QGraphicsProxyWidget;\nproxyItem->setWidget(box);\nQGraphicsScene scene;\nscene.addItem(proxyItem);\nproxyItem->setScale(2);\nproxyItem->setRotation(45);\n```", "```cpp\nQGraphicsScene scene;\nQGraphicsProxyWidget *edit = scene.addWidget(\n  new QLineEdit(\"Some Text\"));\nQGraphicsProxyWidget *button = scene.addWidget(\n  new QPushButton(\"Click me!\"));\nQGraphicsLinearLayout *layout = new QGraphicsLinearLayout;\nlayout->addItem(edit);\nlayout->addItem(button);\nQGraphicsWidget *graphicsWidget = new QGraphicsWidget;\ngraphicsWidget->setLayout(layout);\nscene.addItem(graphicsWidget);\n```", "```cpp\nQGraphicsProxyWidget *proxy = new QGraphicsProxyWidget(0);\nproxy->setWidget(new QLineEdit(\"Some Text\"));\nscene.addItem(proxy);\n```", "```cpp\nGraphicsView view;\nview.setViewport(new QGLWidget(&view));\n```"]