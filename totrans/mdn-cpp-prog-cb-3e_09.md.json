["```cpp\n    void throwing_func()\n    {\n      throw std::runtime_error(\"timed out\");\n    }\n    void another_throwing_func()\n    {\n      throw std::system_error(\n        std::make_error_code(std::errc::timed_out));\n    } \n    ```", "```cpp\n    try\n    {\n      throwing_func(); // throws std::runtime_error\n    }\n    catch (std::exception const & e)\n    {\n      std::cout << e.what() << '\\n';\n    } \n    ```", "```cpp\n    auto exprint = [](std::exception const & e)\n    {\n      std::cout << e.what() << '\\n';\n    };\n    try\n    {\n      another_throwing_func(); // throws std::system_error\n                               // 1st catch statements catches it\n    }\n    catch (std::system_error const & e)\n    {\n      exprint(e);\n    }\n    catch (std::runtime_error const & e)\n    {\n      exprint(e);\n    }\n    catch (std::exception const & e)\n    {\n      exprint(e);\n    } \n    ```", "```cpp\n    try\n    {\n      throwing_func();\n    }\n    catch (std::exception const & e)\n    {\n      std::cout << e.what() << '\\n';\n    }\n    catch (...)\n    {\n      std::cout << \"unknown exception\" << '\\n';\n    } \n    ```", "```cpp\n    void handle_exception()\n    {\n      try\n      {\n        throw; // throw current exception\n      }\n      catch (const std::logic_error & e)\n      { /* ... */ }\n      catch (const std::runtime_error & e)\n      { /* ... */ }\n      catch (const std::exception & e)\n      { /* ... */ }\n    }\n    try\n    {\n      throwing_func();\n    }\n    catch (...)\n    {\n      handle_exception();\n    } \n    ```", "```cpp\n    int f1(int& result)\n    {\n      if (...) return 1;\n      // do something\n    if (...) return 2;\n      // do something more\n      result = 42;\n      return 0;\n    }\n    enum class error_codes {success, error_1, error_2};\n    error_codes f2(int& result)\n    {\n      if (...) return error_codes::error_1;\n      // do something\n    if (...) return error_codes::error_2;\n      // do something more\n      result = 42;\n      return error_codes::success;\n    } \n    ```", "```cpp\n    bool g(int& result)\n    {\n      if (...) return false;\n      // do something\n    if (...) return false;\n      // do something more\n      result = 42;\n      return true;\n    } \n    ```", "```cpp\n    std::optional<int> h()\n    {\n      if (...) return {};\n      // do something\n    if (...) return {};\n      // do something more\n    return 42;\n    } \n    ```", "```cpp\nclass simple_error : public std::exception\n{\npublic:\n  virtual const char* what() const noexcept override\n {\n    return \"simple exception\";\n  }\n};\ntry\n{\n   throw simple_error{};\n}\ncatch (std::exception e)\n{\n   std::cout << e.what() << '\\n'; // prints \"Unknown exception\"\n} \n```", "```cpp\n    class simple_error : public std::exception\n    {\n    public:\n      virtual const char* what() const noexcept override\n     {\n        return \"simple exception\";\n      }\n    }; \n    ```", "```cpp\n    class another_logic_error : public std::logic_error\n    {\n    public:\n      another_logic_error():\n        std::logic_error(\"simple logic exception\")\n      {}\n    }; \n    ```", "```cpp\n    class advanced_error : public std::runtime_error\n    {\n      int error_code;\n      std::string make_message(int const e)\n     {\n        std::stringstream ss;\n        ss << \"error with code \" << e;\n        return ss.str();\n      }\n    public:\n      advanced_error(int const e) :\n        std::runtime_error(make_message(e).c_str()),error_code(e)\n      {\n      }\n      int error() const noexcept\n     {\n        return error_code;\n      }\n    }; \n    ```", "```cpp\n    void func_no_throw() noexcept\n    {\n    } \n    ```", "```cpp\n    template <typename T>\n    T generic_func_1()\n     noexcept(std::is_nothrow_constructible_v<T>)\n    {\n      return T{};\n    } \n    ```", "```cpp\n    template <typename T>\n    T generic_func_2() noexcept(noexcept(T{}))\n    {\n      return T{};\n    }\n    template <typename F, typename A>\n    auto func(F&& f, A&& arg) noexcept\n    {\n      static_assert(noexcept(f(arg)), \"F is throwing!\");\n      return f(arg);\n    }\n    std::cout << noexcept(generic_func_2<int>) << '\\n'; \n    ```", "```cpp\nint double_it(int const i) noexcept\n{\n  return i + i;\n}\nint half_it(int const i)\n{\n  throw std::runtime_error(\"not implemented!\");\n}\nstruct foo\n{\n  foo() {}\n};\nstd::cout << std::boolalpha\n  << noexcept(func_no_throw()) <<  '\\n' // true\n  << noexcept(generic_func_1<int>()) <<  '\\n' // true\n  << noexcept(generic_func_1<std::string>()) <<  '\\n'// true\n  << noexcept(generic_func_2<int>()) << '\\n' // true\n  << noexcept(generic_func_2<std::string>()) <<  '\\n'// true\n  << noexcept(generic_func_2<foo>()) <<  '\\n' // false\n  << noexcept(double_it(42)) <<  '\\n' // true\n  << noexcept(half_it(42)) <<  '\\n' // false\n  << noexcept(func(double_it, 42)) <<  '\\n' // true\n  << noexcept(func(half_it, 42)) << '\\n';            // true \n```", "```cpp\n    struct session {};\n    session connect(std::string const & uri,\n     int const timeout = 2000)\n    {\n      /* do something */\n    return session { /* ... */ };\n    } \n    ```", "```cpp\n    class user_settings\n    {\n    public:\n      int const min_update_interval = 15;\n      /* other members */\n    }; \n    ```", "```cpp\n    class user_settings\n    {\n      bool show_online;\n    public:\n      bool can_show_online() const {return show_online;}\n      /* other members */\n    }; \n    ```", "```cpp\n    user_settings get_user_settings()\n    {\n      return user_settings {};\n    }\n    void update()\n    {\n      user_settings const us = get_user_settings();\n      if(us.can_show_online()) { /* do something */ }\n      /* do more */\n    } \n    ```", "```cpp\n    std::string greetings()\n    {\n       return \"Hello, World!\";\n    }\n    const std::string & s = greetings(); // must use const\n    std::cout << s << std::endl; \n    ```", "```cpp\nint const c = 42;\nint* x;\nint const ** p = &x; // this is an actual error\n*p = &c;\n*x = 0;              // this modifies c \n```", "```cpp\nclass computation\n{\n  double compute_value(double const input) const\n {\n    /* long running operation */\nreturn input + 42;\n  }\n  mutable std::map<double, double> cache;\npublic:\n  double compute(double const input) const\n {\n    auto it = cache.find(input);\n    if(it != cache.end()) return it->second;\n    auto result = compute_value(input);\n    cache[input] = result;\n    return result;\n  }\n}; \n```", "```cpp\ntemplate <typename T>\nclass container\n{\n  std::vector<T>     data;\n  mutable std::mutex mt;\npublic:\n  void add(T const & value)\n {\n    std::lock_guard<std::mutex> lock(mt);\n    data.push_back(value);\n  }\n  bool contains(T const & value) const\n {\n    std::lock_guard<std::mutex> lock(mt);\n    return std::find(std::begin(data), std::end(data), value)\n           != std::end(data);\n  }\n}; \n```", "```cpp\nclass contact {};\nclass addressbook\n{\n  std::vector<contact> contacts;\npublic:\n  contact& operator[](size_t const index);\n  contact const & operator[](size_t const index) const;\n}; \n```", "```cpp\n    constexpr unsigned int factorial(unsigned int const n)\n    {\n      return n > 1 ? n * factorial(n-1) : 1;\n    } \n    ```", "```cpp\n    class point3d\n    {\n      double const x_;\n      double const y_;\n      double const z_;\n    public:\n      constexpr point3d(double const x = 0,\n     double const y = 0,\n     double const z = 0)\n        :x_{x}, y_{y}, z_{z}\n      {}\n      constexpr double get_x() const {return x_;}\n      constexpr double get_y() const {return y_;}\n      constexpr double get_z() const {return z_;}\n    }; \n    ```", "```cpp\n    constexpr unsigned int size = factorial(6);\n    char buffer[size] {0};\n    constexpr point3d p {0, 1, 2};\n    constexpr auto x = p.get_x(); \n    ```", "```cpp\nconstexpr unsigned int size = factorial(6);\n// compile time evaluation\nint n;\nstd::cin >> n;\nauto result = factorial(n);\n// runtime evaluation \n```", "```cpp\nconstexpr const unsigned int size = factorial(6);\nconstexpr unsigned int size = factorial(6); \n```", "```cpp\nstatic constexpr int c = 42;\nconstexpr int const * p = &c; \n```", "```cpp\nstatic constexpr int const & r = c; \n```", "```cpp\nconstexpr char symbol_table(int const n)\n{\n  static constexpr char symbols[] = \"!@#$%^&*\"; // error until C++23\nreturn symbols[n % 8];\n}\nint main()\n{\n    constexpr char s = symbol_table(42);\n    std::cout << s << '\\n';\n} \n```", "```cpp\nstatic constexpr char symbols[] = \"!@#$%^&*\"; // OK\nconstexpr char symbol_table(int const n)\n{\n  return symbols[n % 8];\n} \n```", "```cpp\nconstexpr int factorial2(int const n)\n{\n   if(n <= 0) throw std::invalid_argument(\"n must be positive\");\n   return n > 1 ? n * factorial2(n - 1) : 1;\n}\nint main()\n{\n   try\n   {\n      int a = factorial2(5);\n      int b = factorial2(-5);\n   }\n   catch (std::exception const& ex)\n   {\n      std::cout << ex.what() << std::endl;\n   }         \n   constexpr int c = factorial2(5);\n   constexpr int d = factorial2(-5); // error\n} \n```", "```cpp\nstruct foo\n{\n  int a;\n  int b;\n};\nstruct bar\n{\n  int   value;\n  int*  ptr;\n  constexpr bar() :value{ 0 }, ptr{ nullptr } {}\n};\nstd::string text {};  // zero-initialized to unspecified value\ndouble arr[10];       // zero-initialized to ten 0.0\nint* ptr;             // zero-initialized to nullptr\nfoo f = foo();        // zero-initialized to a=0, b=0\nfoo const fc{ 1, 2 }; // const-initialized at runtime\nconstexpr bar b;      // const-initialized at compile-time \n```", "```cpp\nint f() { return 42; }\nconstexpr int g(bool const c) { return c ? 0 : f(); }\nconstinit int c = g(true);  // OK\nconstinit int d = g(false); /* error: variable does not have\n                                      a constant initializer */ \n```", "```cpp\nextern thread_local constinit int data;\nint get_data() { return data; } \n```", "```cpp\n    consteval unsigned int factorial(unsigned int const n)\n    {\n      return n > 1 ? n * factorial(n-1) : 1;\n    } \n    ```", "```cpp\n    class point3d\n    {\n      double x_;\n      double y_;\n      double z_;\n    public:\n      consteval point3d(double const x = 0,\n     double const y = 0,\n     double const z = 0)\n        :x_{x}, y_{y}, z_{z}\n      {}\n      consteval double get_x() const {return x_;}\n      consteval double get_y() const {return y_;}\n      consteval double get_z() const {return z_;}\n    }; \n    ```", "```cpp\nconstexpr unsigned int f = factorial(6);\nstd::cout << f << '\\n';\nconstexpr point3d p {0, 1, 2};\nstd::cout << p.get_x() << ' ' << p.get_y() << ' ' << p.get_z() << '\\n'; \n```", "```cpp\nunsigned int n;\nstd::cin >> n;\nconst unsigned int f2 = factorial(n); // error\ndouble x = 0, y = 1, z = 2;\nconstexpr point3d p2 {x, y, z};       // error \n```", "```cpp\nusing pfact = unsigned int(unsigned int);\npfact* pf = factorial;\nconstexpr unsigned int f3 = pf(42);   // error\nconsteval auto addr_factorial()\n{\n  return &factorial;\n}\nconsteval unsigned int invoke_factorial(unsigned int const n)\n{\n  return addr_factorial()(n);\n}\nconstexpr auto ptr = addr_factorial();\n// ERROR: cannot take the pointer of an immediate function\nconstexpr unsigned int f2 = invoke_factorial(5);\n// OK \n```", "```cpp\n    constexpr double power(double base, int exponent)\n    {\n       if(std::is_constant_evaluated())\n       {\n          double result = 1.0;\n          if (exponent == 0)\n          {\n              return result;\n          }\n          else if (exponent > 0) {\n              for (int i = 0; i < exponent; i++) {\n                  result *= base;\n              }\n          }\n          else {\n              exponent = -exponent;\n              for (int i = 0; i < exponent; i++) {\n                  result *= base;\n              }\n              result = 1.0 / result;\n          }\n          return result;\n       }\n       else\n       {\n           return std::pow(base, exponent);\n       }\n    }\n    int main()\n    {\n       constexpr double a = power(10, 5); // compile-time eval\n       std::cout << a << '\\n';\n       double b = power(10, 5);           // runtime eval\n       std::cout << b << '\\n';\n    } \n    ```", "```cpp\n    constexpr double power(double base, int exponent)\n    {\n       if consteval\n       {\n          double result = 1.0;\n          if (exponent == 0)\n          {\n              return result;\n          }\n          else if (exponent > 0) {\n              for (int i = 0; i < exponent; i++) {\n                  result *= base;\n              }\n          }\n          else {\n              exponent = -exponent;\n              for (int i = 0; i < exponent; i++) {\n                  result *= base;\n              }\n              result = 1.0 / result;\n          }\n          return result;\n       }\n       else\n       {\n           return std::pow(base, exponent);\n       }\n    } \n    ```", "```cpp\n    constexpr double a = power(10, 5); // [1] compile-time eval\n    double b = power(10, 5);           // [2] runtime eval \n    ```", "```cpp\n    constexpr double power(double base, int exponent)\n    {\n       if constexpr (std::is_constant_evaluated())\n     {\n       }\n    } \n    ```", "```cpp\nprog.cc: In function 'constexpr double power(double, int)':\nprog.cc:10:45: warning: 'std::is_constant_evaluated' always evaluates to true in 'if constexpr' [-Wtautological-compare]\n   10 |     if constexpr (std::is_constant_evaluated())\n      |                   ~~~~~~~~~~~~~~~~~~~~~~~~~~^~ \n```", "```cpp\nconstexpr double power(double base, int exponent)\n{\n   if consteval\n   {\n      /* ... */\n   }\n   else\n   {\n       return std::pow(base, exponent);\n   }\n} \n```", "```cpp\nif !consteval {/*statement*/}          // [1] equivalent to [2]\nif consteval {} else {/*statement*/}   // [2]\nif not consteval {/*statement1*/}      // [3] equivalent to [4]\nelse {/*statement2*/}              \nif consteval {/*statement2*/}          // [4]\nelse {/*statement1*/} \n```", "```cpp\nconsteval int plus_one(int const i) \n{ \n   return i + 1; \n}\nconsteval int plus_two(int i)\n{\n   return plus_one(i) + 1;\n}\nconstexpr int plus_two_alt(int const i)\n{\n   if (std::is_constant_evaluated())\n   {\n      return plus_one(i) + 1;\n   } \n   else\n   {\n      return i + 2;\n   }\n} \n```", "```cpp\nconstexpr int plus_two_alt(int const i)\n{\n   if consteval\n   {\n      return plus_one(i) + 1;\n   } \n   else\n   {\n      return i + 2;\n   }\n} \n```", "```cpp\nconstexpr bool is_constant_evaluated() noexcept\n{\n   if consteval {\n      return true;\n   } else {\n      return false;\n   }\n} \n```", "```cpp\nstruct dimension\n{\n   double width;\n   double height;\n}; \n```", "```cpp\nstruct document_type\n{\n   constexpr virtual ~document_type() {};\n   constexpr virtual dimension size() const = 0;\n};\nstruct document_a5 : document_type\n{\n   constexpr dimension size() const override { return { 148.5, 210 }; }\n};\nstruct envelope_type\n{\n   constexpr virtual ~envelope_type() {}\n   constexpr virtual dimension size() const = 0;\n   constexpr virtual dimension max_enclosure_size() const = 0;\n};\nstruct envelop_commercial_8 : envelope_type\n{\n   constexpr dimension size() const override { return { 219, 92 }; }\n   constexpr dimension max_enclosure_size() const override \n { return { 213, 86 }; }\n};\nconstexpr bool document_fits_envelope(document_type const& d, \n                                      envelope_type const& e)\n{\n   return e.max_enclosure_size().width >= d.size().width;\n}\nint main()\n{\n   constexpr envelop_commercial_8 e1;\n   constexpr document_a5          d1;\n   static_assert(document_fits_envelope(d1, e1));\n} \n```", "```cpp\n    enum options {one = 1, two, three};\n    int value = 1;\n    options op = static_cast<options>(value);\n    int x = 42, y = 13;\n    double d = static_cast<double>(x) / y;\n    int n = static_cast<int>(d); \n    ```", "```cpp\n    struct base\n    {\n      virtual void run() {}\n      virtual ~base() {}\n    };\n    struct derived : public base\n    {\n    };\n    derived d;\n    base b;\n    base* pb = dynamic_cast<base*>(&d);         // OK\n    derived* pd = dynamic_cast<derived*>(&b);   // fail\n    try\n    {\n      base& rb = dynamic_cast<base&>(d);       // OK\n      derived& rd = dynamic_cast<derived&>(b); // fail\n    }\n    catch (std::bad_cast const & e)\n    {\n      std::cout << e.what() << '\\n';\n    } \n    ```", "```cpp\n    void old_api(char* str, unsigned int size)\n    {\n      // do something without changing the string\n    }\n    std::string str{\"sample\"};\n    old_api(const_cast<char*>(str.c_str()),\n            static_cast<unsigned int>(str.size())); \n    ```", "```cpp\n    class widget\n    {\n    public:\n      typedef size_t data_type;\n      void set_data(data_type d) { data = d; }\n      data_type get_data() const { return data; }\n    private:\n      data_type data;\n    };\n    widget w;\n    user_data* ud = new user_data();\n    // write\n    w.set_data(reinterpret_cast<widget::data_type>(ud));\n    // read\n    user_data* ud2 = reinterpret_cast<user_data*>(w.get_data()); \n    ```", "```cpp\nint* pi = new int{ 42 };\ndouble* pd = static_cast<double*>(pi);   // compiler error \n```", "```cpp\nbase b;\nderived* pd = static_cast<derived*>(&b); // compilers OK, runtime error\nbase* pb1 = static_cast<base*>(pd);      // OK \n```", "```cpp\nint const c = 42;\nint* pc = static_cast<int*>(&c);         // compiler error \n```", "```cpp\nstruct struct1 {};\nstruct struct2 {};\nstruct1 s1;\nstruct2* ps2 = dynamic_cast<struct2*>(&s1); // compiler error \n```", "```cpp\nint* pi = new int{ 42 };\ndouble* pd = reinterpret_cast<double*>(pi); \n```", "```cpp\nint const a = 42;\nint const * p = &a;\nint* q = const_cast<int*>(p);\n*q = 0; // undefined behavior \n```", "```cpp\nclass Buffer\n{\n  unsigned char* ptr;\n  size_t length;\npublic:\n  Buffer(): ptr(nullptr), length(0)\n  {}\n  explicit Buffer(size_t const size):\n    ptr(new unsigned char[size] {0}), length(size)\n  {}\n  ~Buffer()\n  {\n    delete[] ptr;\n  }\n  Buffer(Buffer const& other):\n    ptr(new unsigned char[other.length]),\n    length(other.length)\n  {\n    std::copy(other.ptr, other.ptr + other.length, ptr);\n  }\n  Buffer& operator=(Buffer const& other)\n  {\n    if (this != &other)\n    {\n      delete[] ptr;\n      ptr = new unsigned char[other.length];\n      length = other.length;\n      std::copy(other.ptr, other.ptr + other.length, ptr);\n    }\n    return *this;\n  }\n  size_t size() const { return length;}\n  unsigned char* data() const { return ptr; }\n}; \n```", "```cpp\n    Buffer(Buffer&& other)\n    {\n    } \n    ```", "```cpp\n    ptr = other.ptr;\n    length = other.length; \n    ```", "```cpp\n    other.ptr = nullptr;\n    other.length = 0; \n    ```", "```cpp\nBuffer(Buffer&& other)\n{\n  ptr = other.ptr;\n  length = other.length;\n  other.ptr = nullptr;\n  other.length = 0;\n} \n```", "```cpp\n    Buffer& operator=(Buffer&& other)\n    {\n    } \n    ```", "```cpp\n    if (this != &other)\n    {\n    } \n    ```", "```cpp\n    delete[] ptr; \n    ```", "```cpp\n    ptr = other.ptr;\n    length = other.length; \n    ```", "```cpp\n    other.ptr = nullptr;\n    other.length = 0; \n    ```", "```cpp\n    return *this; \n    ```", "```cpp\nBuffer& operator=(Buffer&& other)\n{\n  if (this != &other)\n  {\n    delete[] ptr;\n    ptr = other.ptr;\n    length = other.length;\n    other.ptr = nullptr;\n    other.length = 0;\n  }\n  return *this;\n} \n```", "```cpp\nT a;\nT b = a;\nT c = a + b; \n```", "```cpp\nstd::vector<Buffer> c;\nc.push_back(Buffer(100));  // move\nBuffer b(200);\nc.push_back(b);            // copy\nc.push_back(std::move(b)); // move \n```", "```cpp\nBuffer b1;                // default constructor\nBuffer b2(100);           // explicit constructor\nBuffer b3(b2);            // copy constructor\nb1 = b3;                  // assignment operator\nBuffer b4(std::move(b1)); // move constructor\nb3 = std::move(b4);       // move assignment \n```", "```cpp\nBuffer(Buffer&& other) : ptr(nullptr), length(0)\n{\n  *this = std::move(other);\n} \n```", "```cpp\nclass foo\n{\n  int a;\n  double b;\n  std::string c;\npublic:\n  foo(int const a = 0, double const b = 0, \n std::string const & c = \"\") :a(a), b(b), c(c)\n  {}\n  void print() const\n {\n    std::cout << '(' << a << ',' << b << ',' << std::quoted(c) << ')'\n              << '\\n';\n  }\n}; \n```", "```cpp\n    std::unique_ptr<int>   pnull;\n    std::unique_ptr<int>   pi(new int(42));\n    std::unique_ptr<int[]> pa(new int[3]{ 1,2,3 });\n    std::unique_ptr<foo>   pf(new foo(42, 42.0, \"42\")); \n    ```", "```cpp\n    std::unique_ptr<int>   pi = std::make_unique<int>(42);\n    std::unique_ptr<int[]> pa = std::make_unique<int[]>(3);\n    std::unique_ptr<foo>   pf = std::make_unique<foo>(42, 42.0, \"42\"); \n    ```", "```cpp\n    std::unique_ptr<int>   pi = std::make_unique_for_overwrite<int>();\n    std::unique_ptr<foo[]> pa = std::make_unique_for_overwrite<foo[]>(); \n    ```", "```cpp\n    struct foo_deleter\n    {\n      void operator()(foo* pf) const\n     {\n        std::cout << \"deleting foo...\" << '\\n';\n        delete pf;\n      }\n    };\n    std::unique_ptr<foo, foo_deleter> pf(\n     new foo(42, 42.0, \"42\"),\n        foo_deleter()); \n    ```", "```cpp\n    auto pi = std::make_unique<int>(42);\n    auto qi = std::move(pi);\n    assert(pi.get() == nullptr);\n    assert(qi.get() != nullptr); \n    ```", "```cpp\n    void func(int* ptr)\n    {\n      if (ptr != nullptr)\n        std::cout << *ptr << '\\n';\n      else\n        std::cout << \"null\" << '\\n';\n    }\n    std::unique_ptr<int> pi;\n    func(pi.get()); // prints null\n    pi = std::make_unique<int>(42);\n    func(pi.get()); // prints 42 \n    ```", "```cpp\n    auto pi = std::make_unique<int>(42);\n    *pi = 21;\n    auto pf1 = std::make_unique<foo>();\n    pf1->print(); // prints (0,0,\"\")\n    auto pf2 = std::make_unique<foo>(42, 42.0, \"42\");\n    pf2->print(); // prints (42,42,\"42\") \n    ```", "```cpp\n    std::unique_ptr<int[]> pa = std::make_unique<int[]>(3);\n    for (int i = 0; i < 3; ++i)\n      pa[i] = i + 1; \n    ```", "```cpp\n    std::unique_ptr<int> pi(new int(42));\n    if (pi) std::cout << \"not null\" << '\\n'; \n    ```", "```cpp\n    std::vector<std::unique_ptr<foo>> data;\n    for (int i = 0; i < 5; i++)\n      data.push_back(\n    std::make_unique<foo>(i, i, std::to_string(i)));\n    auto pf = std::make_unique<foo>(42, 42.0, \"42\");\n    data.push_back(std::move(pf)); \n    ```", "```cpp\n    // allocate and initialize an array\n    std::unique_ptr<int[]> pa(new int[3]{ 1,2,3 });\n    // allocate and then initialize an array\n    std::unique_ptr<int[]> pa = std::make_unique<int[]>(3);\n    for (int i = 0; i < 3; ++i)\n      pa[i] = i + 1; \n    ```", "```cpp\nvoid some_function(std::unique_ptr<foo> p)\n{ /* do something */ }\nsome_function(std::unique_ptr<foo>(new foo()));\nsome_function(std::make_unique<foo>()); \n```", "```cpp\nvoid some_other_function(std::unique_ptr<foo> p, int const v)\n{\n}\nint function_that_throws()\n{\n  throw std::runtime_error(\"not implemented\");\n}\n// possible memory leak\nsome_other_function(std::unique_ptr<foo>(new foo),\n                    function_that_throws());\n// no possible memory leak\nsome_other_function(std::make_unique<foo>(),\n                    function_that_throws()); \n```", "```cpp\nstruct Base\n{\n  virtual ~Base()\n  {\n    std::cout << \"~Base()\" << '\\n';\n  }\n};\nstruct Derived : public Base\n{\n  virtual ~Derived()\n  {\n    std::cout << \"~Derived()\" << '\\n';\n  }\n};\nstd::unique_ptr<Derived> pd = std::make_unique<Derived>();\nstd::unique_ptr<Base> pb = std::move(pd); \n```", "```cpp\n~Derived()\n~Base() \n```", "```cpp\n    std::shared_ptr<int> pnull1;\n    std::shared_ptr<int> pnull2(nullptr);\n    std::shared_ptr<int> pi1(new int(42));\n    std::shared_ptr<int> pi2 = pi1;\n    std::shared_ptr<foo> pf1(new foo());\n    std::shared_ptr<foo> pf2(new foo(42, 42.0, \"42\")); \n    ```", "```cpp\n    std::shared_ptr<int> pi  = std::make_shared<int>(42);\n    std::shared_ptr<foo> pf1 = std::make_shared<foo>();\n    std::shared_ptr<foo> pf2 = std::make_shared<foo>(42, 42.0, \"42\"); \n    ```", "```cpp\n    std::shared_ptr<int> pi = std::make_shared_for_overwrite<int>();\n    std::shared_ptr<foo[]> pa = std::make_shared_for_overwrite<foo[]>(3); \n    ```", "```cpp\n    std::shared_ptr<foo> pf1(new foo(42, 42.0, \"42\"),\n                             foo_deleter());\n    std::shared_ptr<foo> pf2(\n     new foo(42, 42.0, \"42\"),\n            [](foo* p) {\n              std::cout << \"deleting foo from lambda...\" << '\\n';\n     delete p;}); \n    ```", "```cpp\n    std::shared_ptr<int> pa1(\n     new int[3]{ 1, 2, 3 },\n      std::default_delete<int[]>());\n    std::shared_ptr<int> pa2(\n     new int[3]{ 1, 2, 3 },\n      [](auto p) {delete[] p; }); \n    ```", "```cpp\n    void func(int* ptr)\n    {\n      if (ptr != nullptr)\n        std::cout << *ptr << '\\n';\n      else\n        std::cout << \"null\" << '\\n';\n    }\n    std::shared_ptr<int> pi;\n    func(pi.get());\n    pi = std::make_shared<int>(42);\n    func(pi.get()); \n    ```", "```cpp\n    std::shared_ptr<int> pi = std::make_shared<int>(42);\n    *pi = 21;\n    std::shared_ptr<foo> pf = std::make_shared<foo>(42, 42.0, \"42\");\n    pf->print(); \n    ```", "```cpp\n    std::shared_ptr<int[]> pa1(\n     new int[3]{ 1, 2, 3 },\n      std::default_delete<int[]>());\n    for (int i = 0; i < 3; ++i)\n      pa1[i] *= 2; \n    ```", "```cpp\n    std::shared_ptr<int> pnull;\n    if (pnull) std::cout << \"not null\" << '\\n';\n    std::shared_ptr<int> pi(new int(42));\n    if (pi) std::cout << \"not null\" << '\\n'; \n    ```", "```cpp\n    std::vector<std::shared_ptr<foo>> data;\n    for (int i = 0; i < 5; i++)\n      data.push_back(\n        std::make_shared<foo>(i, i, std::to_string(i)));\n    auto pf = std::make_shared<foo>(42, 42.0, \"42\");\n    data.push_back(std::move(pf));\n    assert(!pf); \n    ```", "```cpp\n    auto sp1 = std::make_shared<int>(42);\n    assert(sp1.use_count() == 1);\n    std::weak_ptr<int> wpi = sp1;\n    assert(sp1.use_count() == 1);\n    auto sp2 = wpi.lock(); // sp2 type is std::shared_ptr<int>\n    assert(sp1.use_count() == 2);\n    assert(sp2.use_count() == 2);\n    sp1.reset();\n    assert(sp1.use_count() == 0);\n    assert(sp2.use_count() == 1); \n    ```", "```cpp\n    struct Apprentice;\n    struct Master : std::enable_shared_from_this<Master>\n    {\n      ~Master() { std::cout << \"~Master\" << '\\n'; }\n      void take_apprentice(std::shared_ptr<Apprentice> a);\n    private:\n      std::shared_ptr<Apprentice> apprentice;\n    };\n    struct Apprentice\n    {\n      ~Apprentice() { std::cout << \"~Apprentice\" << '\\n'; }\n      void take_master(std::weak_ptr<Master> m);\n    private:\n      std::weak_ptr<Master> master;\n    };\n    void Master::take_apprentice(std::shared_ptr<Apprentice> a)\n    {\n      apprentice = a;\n      apprentice->take_master(shared_from_this());\n    }\n    void Apprentice::take_master(std::weak_ptr<Master> m)\n    {\n      master = m;\n    }\n    auto m = std::make_shared<Master>();\n    auto a = std::make_shared<Apprentice>();\n    m->take_apprentice(a); \n    ```", "```cpp\nstd::shared_ptr<Derived> pd = std::make_shared<Derived>();\nstd::shared_ptr<Base> pb = pd;\nstd::static_pointer_cast<Derived>(pb)->print(); \n```", "```cpp\n    class foo\n    {\n      int value;\n    public:\n      foo(int const v):value(v){}\n      bool operator==(foo const&) const = default;\n    }; \n    ```", "```cpp\n    class foo\n    {\n      int value;\n    public:\n      foo(int const v) :value(v) {}\n      auto operator<=>(foo const&) const = default;\n    }; \n    ```", "```cpp\n    class foo\n    {\n      int value;\n    public:\n      foo(int const v) :value(v) {}\n      bool operator==(foo const& other) const\n      { return value == other.value; }\n      auto operator<=>(foo const& other) const\n      { return value <=> other.value; }\n    }; \n    ```", "```cpp\nclass cost_unit_t\n{\n  // data members\npublic:\n  std::strong_ordering operator<=>(cost_unit_t const & other) const noexcept = default;\n};\nclass project_t : public cost_unit_t\n{\n  int         id;\n  int         type;\n  std::string name;\npublic:\n  bool operator==(project_t const& other) const noexcept\n  {\n    return (cost_unit_t&)(*this) == (cost_unit_t&)other &&\n           name == other.name &&\n           type == other.type &&\n           id == other.id;\n  }\n  std::strong_ordering operator<=>(project_t const & other) const noexcept\n  {\n    // compare the base class members\nif (auto cmp = (cost_unit_t&)(*this) <=> (cost_unit_t&)other;\n        cmp != 0)\n      return cmp;\n    // compare this class members in custom order\nif (auto cmp = name.compare(other.name); cmp != 0)\n      return cmp < 0 ? std::strong_ordering::less :\n                       std::strong_ordering::greater;\n    if (auto cmp = type <=> other.type; cmp != 0)\n      return cmp;\n    return id <=> other.id;\n  }\n}; \n```", "```cpp\nemployee_t that models employees in a company. An employee can have a manager, and an employee who is a manager has people that they manage. Conceptually, such a type could look as follows:\n```", "```cpp\nstruct employee_t\n{\n  bool is_managed_by(employee_t const&) const { /* ... */ }\n  bool is_manager_of(employee_t const&) const { /* ... */ }\n  bool is_same(employee_t const&) const { /* ... */ }\n  bool operator==(employee_t const & other) const\n  {\n    return is_same(other);\n  }\n  std::partial_ordering operator<=>(employee_t const& other) const noexcept\n  {\n    if (is_same(other))\n      return std::partial_ordering::equivalent;\n    if (is_managed_by(other))\n      return std::partial_ordering::less;\n    if (is_manager_of(other))\n      return std::partial_ordering::greater;\n    return std::partial_ordering::unordered;\n  }\n}; \n```", "```cpp\nstruct ipv4\n{\n  explicit ipv4(unsigned char const a=0, unsigned char const b=0,\n unsigned char const c=0, unsigned char const d=0) noexcept :\n    data{ a,b,c,d }\n  {}\n  unsigned long to_ulong() const noexcept\n {\n    return\n      (static_cast<unsigned long>(data[0]) << 24) |\n      (static_cast<unsigned long>(data[1]) << 16) |\n      (static_cast<unsigned long>(data[2]) << 8) |\n      static_cast<unsigned long>(data[3]);\n  }\n  auto operator<=>(ipv4 const&) const noexcept = default;\n  bool operator==(unsigned long const other) const noexcept\n  {\n    return to_ulong() == other;\n  }\n  std::strong_ordering\n  operator<=>(unsigned long const other) const noexcept\n  {\n    return to_ulong() <=> other;\n  }\nprivate:\n  std::array<unsigned char, 4> data;\n}; \n```", "```cpp\nipv4 ip(127, 0, 0, 1);\nif(ip == 0x7F000001) {}\nif(ip != 0x7F000001) {}\nif(0x7F000001 == ip) {}\nif(0x7F000001 != ip) {}\nif(ip < 0x7F000001)  {}\nif(0x7F000001 < ip)  {} \n```", "```cpp\nstruct A { int i; };\nstruct B\n{\n  B(A a) : i(a.i) { }\n  int i;\n};\ninline auto\noperator<=>(B const& lhs, B const& rhs) noexcept\n{\n  return lhs.i <=> rhs.i;\n}\nassert(A{ 2 } > A{ 1 }); \n```", "```cpp\nint a = -1;\nunsigned int b = 42;\nif (std::cmp_less(a, b)) // a is less than b so this returns true\n{\n   std::cout << \"-1 < 42\\n\";\n}\nelse\n{\n   std::cout << \"-1 >= 42\\n\";\n} \n```", "```cpp\nsigned -1 and unsigned 42 will print *-1 >= 42* because the actual comparison occurs between unsigned 4294967295 and unsigned 42.\n```", "```cpp\nint a = -1;\nunsigned int b = 42;\nif(a < b)\n{\n   std::cout << \"-1 < 42\\n\";\n}\nelse\n{\n   std::cout << \"-1 >= 42\\n\";\n} \n```", "```cpp\nif(a < 0 || static_cast<unsigned int>(a) < b) \n```", "```cpp\nif(std::cmp_less(a, b))\n{\n   std::cout << \"-1 < 42\\n\";\n}\nelse\n{\n   std::cout << \"-1 >= 42\\n\";\n} \n```", "```cpp\ntemplate<class T, class U>\nconstexpr bool cmp_less(T t, U u) noexcept\n{\n    if constexpr (std::is_signed_v<T> == std::is_signed_v<U>)\n return t < u;\n    else if constexpr (std::is_signed_v<T>)\n        return t < 0 || std::make_unsigned_t<T>(t) < u;\n    else\nreturn u >= 0 && t < std::make_unsigned_t<U>(u);\n} \n```", "```cpp\n__int64 a = -1;\nunsigned __int64 b = 42;\nif (std::cmp_less(a, b))  // OK\n{ }\nint32_t  a = -1;\nuint32_t b = 42;\nif (std::cmp_less(a, b))  // OK\n{ } \n```", "```cpp\nif (std::cmp_equal(true, 1)) // error\n{ } \n```"]