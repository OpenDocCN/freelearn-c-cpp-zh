<html><head></head><body><div><div><h1 id="_idParaDest-132"><em class="italic"><a id="_idTextAnchor179"/>Chapter 8</em>: Ranges and Algorithms</h1>
			<p>By reaching this point of the book, you have learned everything about the syntax and the mechanism of templates in C++, up to the latest version of the standard, C++20. This has equipped you with the necessary knowledge to write templates from simple forms to complex ones. Templates are the key to writing generic libraries. Even though you might not write such a library yourself, you’d still be using one or more. In fact, the everyday code that you’re writing in C++ uses templates. And the main reason for that is that as a modern C++ developer, you’re using the standard library, which is a library based on templates.</p>
			<p>However, the standard library is a collection of many libraries, such as the containers library, iterators library, algorithms library, numeric library, input/output library, filesystem library, regular expressions library, thread support library, utility libraries, and others. Overall, it’s a large library that could make the topic of at least an entire book. However, it is worth exploring some key parts of the library to help you get a better understanding of some of the concepts and types you are or could be using regularly.</p>
			<p>Because addressing this topic in a single chapter would lead to a significantly large chapter, we will split the discussion into two parts. In this chapter, we will address the following topics:</p>
			<ul>
				<li>Understanding the design of containers, iterators, and algorithms</li>
				<li>Creating a custom container and iterator</li>
				<li>Writing a custom general-purpose algorithm</li>
			</ul>
			<p>By the end of this chapter, you will have a good understanding of the three main pillars of the standard template library, which are containers, iterators, and algorithms.</p>
			<p>We will begin this chapter with an overview of what the standard library has to offer in this respect.</p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor180"/>Understanding the design of containers, iterators, and algorithms</h1>
			<p><strong class="bold">Containers</strong> are types that <a id="_idIndexMarker790"/>represent collections of elements. These collections can be implemented based on a variety of data structures, each with different semantics: lists, queues, trees, and so on. The standard library provides three categories of <a id="_idIndexMarker791"/>containers:</p>
			<ul>
				<li><code>vector</code>, <code>deque</code>, <code>list</code>, <code>array</code>, and <code>forward_list</code></li>
				<li><code>set</code>, <code>map</code>, <code>multiset</code>, and <code>multimap</code></li>
				<li><code>unordered_set</code>, <code>unordered_map</code>, <code>unordered_multiset</code>, and <code>unordered_multimap</code></li>
			</ul>
			<p>In addition to this, there are also container adaptors that provide a different interface for sequence containers. This category includes the <code>stack</code>, <code>queue</code>, and <code>priority_queue</code> classes. Finally, there is a class called <code>span</code> that represents a non-owning view over a contiguous sequence of objects.</p>
			<p>The rationale for these containers to be templates was presented in <a href="B18367_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Introduction to Templates</em>. You don’t want to write the same implementation again and again for each different type of element that you need to store in a container. Arguably, the most used containers from the standard library are the following:</p>
			<ul>
				<li><code>vector</code>: This is a variable-size collection of elements stored contiguously in memory. It’s the default container you would choose, provided no special requirements are defined. The internal storage expands or shrinks automatically as needed to accommodate the stored elements. The vector allocates more memory than needed so that the risk of having to expand is low. The expansion is a costly operation because new memory needs to be allocated, the content of the current storage needs to be copied to the new one, and lastly, the previous storage needs to be discarded. Because elements are stored contiguously in memory, they can be randomly accessed by an index in constant time.</li>
				<li><code>array</code>: This is a fixed-size collection of elements stored contiguously in memory. The size must be a compile-time constant expression. The semantics of the <code>array</code> class is the same as a structure holding a C-style array (<code>T[n]</code>). Just like the <code>vector</code> type, the elements of the <code>array</code> class can be accessed randomly in constant time.</li>
				<li><code>map</code>: This is a collection that associates a value to a unique key. Keys are sorted with a comparison function and the <code>map</code> class is typically implemented as a red-black tree. The operations to search, insert, or remove elements have logarithmic complexity.</li>
				<li><code>set</code>: This is a collection of unique keys. The keys are the actual values stored in the container; there are <a id="_idIndexMarker792"/>no key-value pairs as in the case of the <code>map</code> class. However, just like in the case of the <code>map</code> class, <code>set</code> is typically implemented as a red-black tree that has logarithmic complexity for searching, inserting, and the removing of elements.</li>
			</ul>
			<p>Regardless of their type, the standard containers have a few things in common:</p>
			<ul>
				<li>Several common member types</li>
				<li>An allocator for storage management (with the exception of the <code>std::array</code> class)</li>
				<li>Several common member functions (some of them are missing from one or another container)</li>
				<li>Access to the stored data with the help of iterators</li>
			</ul>
			<p>The following member types are defined by all standard containers:</p>
			<pre class="source-code">using value_type      = /* ... */;</pre>
			<pre class="source-code">using size_type       = std::size_t;</pre>
			<pre class="source-code">using difference_type = std::ptrdiff_t;</pre>
			<pre class="source-code">using reference       = value_type&amp;;</pre>
			<pre class="source-code">using const_reference = value_type const&amp;;</pre>
			<pre class="source-code">using pointer         = /* ... */;</pre>
			<pre class="source-code">using const_pointer   = /* ... */;</pre>
			<pre class="source-code">using iterator        = /* ... */;</pre>
			<pre class="source-code">using const_iterator  = /* ... */;</pre>
			<p>The actual types these names are aliasing may differ from container to container. For instance, for <code>std::vector</code>, <code>value_type</code> is the template argument <code>T</code>, but for <code>std::map,</code> <code>value_type</code> is the <code>std::pair&lt;const Key, T&gt;</code> type. The purpose of these member types is to help with generic programming.</p>
			<p>Except for<a id="_idIndexMarker793"/> the <code>std::array</code> class, which represents an array of a size known at compile time, all the other containers allocate memory dynamically. This is controlled with the help of an object called an <code>std::allocator</code> if none is specified. This standard allocator uses the global <code>new</code> and <code>delete</code> operators for allocating and releasing memory. All constructors of standard containers (including copy and move constructors) have overloads that allow us to specify an allocator.</p>
			<p>There are also common member functions defined in the standard containers. Here are some examples:</p>
			<ul>
				<li><code>size</code>, which returns the number of elements (not present in <code>std::forward_list</code>).</li>
				<li><code>empty</code>, which checks whether the container is empty.</li>
				<li><code>clear</code>, which clears the content of the container (not present in <code>std::array</code>, <code>std::stack</code>, <code>std::queue</code>, and <code>std::priority_queue</code>).</li>
				<li><code>swap</code>, which swaps the content of the container objects.</li>
				<li><code>begin</code> and <code>end</code> methods, which return iterators to the beginning and end of the container (not present in <code>std::stack</code>, <code>std::queue</code>, and <code>std::priority_queue</code>, although these are not containers but container adaptors).</li>
			</ul>
			<p>The last bullet mentions iterators. These are types that abstract the details of accessing elements in a container, providing a uniform way to identify and traverse the elements of containers. This is <a id="_idIndexMarker795"/>important because a key part of the standard library is represented by general-purpose algorithms. There are over one hundred such algorithms, ranging from sequence operations (such as <code>count</code>, <code>count_if</code>, <code>find</code>, and <code>for_each</code>) to modifying operations (such as <code>copy</code>, <code>fill</code>, <code>transform</code>, <code>rotate</code>, and <code>reverse</code>) to partitioning and sorting (<code>partition</code>, <code>sort</code>, <code>nth_element</code>, and more) and others. Iterators are key for ensuring they work generically. If each container had <a id="_idIndexMarker796"/>different ways to access its elements, writing generic algorithms would be virtually impossible.</p>
			<p>Let’s consider the simple operation of copying elements from one container to another. For instance, we have a <code>std::vector</code> object and we want to copy its elements to a <code>std::list</code> object. This could look as follows:</p>
			<pre class="source-code">std::vector&lt;int&gt; v {1, 2, 3};</pre>
			<pre class="source-code">std::list&lt;int&gt; l;</pre>
			<pre class="source-code">for (std::size_t i = 0; i &lt; v.size(); ++i)</pre>
			<pre class="source-code">   l.push_back(v[i]);</pre>
			<p>What if we want to copy from a <code>std::list</code> to a <code>std::set</code>, or from a <code>std::set</code> to a <code>std::array</code>? Each case would require different kinds of code. However, general-purpose algorithms enable us to do this in a uniform way. The following snippet shows such an example:</p>
			<pre class="source-code">std::vector&lt;int&gt; v{ 1, 2, 3 };</pre>
			<pre class="source-code">// copy vector to vector</pre>
			<pre class="source-code">std::vector&lt;int&gt; vc(v.size());</pre>
			<pre class="source-code">std::copy(v.begin(), v.end(), vc.begin());</pre>
			<pre class="source-code">// copy vector to list</pre>
			<pre class="source-code">std::list&lt;int&gt; l;</pre>
			<pre class="source-code">std::copy(v.begin(), v.end(), std::back_inserter(l));</pre>
			<pre class="source-code">// copy list to set</pre>
			<pre class="source-code">std::set&lt;int&gt; s;</pre>
			<pre class="source-code">std::copy(l.begin(), l.end(), std::inserter(s, s.begin()));</pre>
			<p>Here we have a <code>std::vector</code> object and we copy its content to another <code>std::vector</code>, but also to a <code>std::list</code> object. Consequently, the content of the <code>std::list</code> object is then copied to a <code>std::set</code> object. For all cases, the <code>std::copy</code> algorithm is used. This algorithm has several arguments: two iterators that define the beginning and <a id="_idIndexMarker797"/>end of the source, and an iterator that defines the beginning of the destination. The algorithm copies one element at a time from the input range to the element pointer by the output iterator and then increments the output iterator. Conceptually, it can be implemented as follows:</p>
			<pre class="source-code">template&lt;typename InputIt, class OutputIt&gt;</pre>
			<pre class="source-code">OutputIt copy(InputIt first, InputIt last, </pre>
			<pre class="source-code">              OutputIt d_first)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   for (; first != last; (void)++first, (void)++d_first)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      *d_first = *first;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   return d_first;</pre>
			<pre class="source-code">}</pre>
			<p class="callout-heading">Important Note</p>
			<p class="callout">This algorithm was discussed in <a href="B18367_05_ePub.xhtml#_idTextAnchor080"><em class="italic">Chapter 5</em></a>, <em class="italic">Type Traits and Conditional Compilation</em>, when we looked at how its implementation can be optimized with the help of type traits.</p>
			<p>Considering the previous example, there are cases when the destination container does not have its content already allocated for the copying to take place. This is the case with copying to the list and to the set. In this case, iterator-like types, <code>std::back_insert_iterator</code> and <code>std:insert_iterator</code>, are used—indirectly through the <code>std::back_inserter</code> and <code>std::inserter</code> helper functions, for inserting elements into a container. The <code>std::back_insert_iterator</code> class uses the <code>push_back</code> function and <code>std::insert_iterator</code> uses the <code>insert</code> function. </p>
			<p>There are <a id="_idIndexMarker798"/>six iterator categories in C++: </p>
			<ul>
				<li>Input iterator</li>
				<li>Output iterator</li>
				<li>Forward iterator</li>
				<li>Bidirectional iterator</li>
				<li>Random access iterator</li>
				<li>Contiguous iterator</li>
			</ul>
			<p>The contiguous iterator category was added in C++17. All operators can be incremented with the prefix or postfix increment operator. The following table shows the additional operations that each category defines:</p>
			<div><div><img src="img/Table_8.01_B18367.jpg" alt="Table 8.1&#13;&#10;" width="1570" height="1762"/>
				</div>
			</div>
			<p class="figure-caption">Table 8.1</p>
			<p>With the exception of the output category, each category includes everything about it. That means a forward iterator is <a id="_idIndexMarker799"/>an input iterator, a bidirectional iterator is a forward iterator, a <a id="_idIndexMarker800"/>random-access iterator is a bidirectional iterator, and, lastly, a contiguous iterator <a id="_idIndexMarker801"/>is a random-access iterator. However, iterators in any of the first five categories can also be output iterators at the same time. Such an iterator is called a <strong class="bold">mutable</strong> iterator. Otherwise, they <a id="_idIndexMarker802"/>are said <a id="_idIndexMarker803"/>to be <strong class="bold">constant</strong> iterators.</p>
			<p>The C++20 standard has added support for concepts and a concepts library. This library defines standard concepts for each of these iterator categories. The following table shows the correlation between them:</p>
			<div><div><img src="img/Table_8.02_B18367.jpg" alt="Table 8.2&#13;&#10;" width="1242" height="532"/>
				</div>
			</div>
			<p class="figure-caption">Table 8.2</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Iterator concepts were briefly discussed in <a href="B18367_06_ePub.xhtml#_idTextAnchor099"><em class="italic">Chapter 6</em></a>, <em class="italic">Concepts and Constraints</em>.</p>
			<p>All containers have the <a id="_idIndexMarker804"/>following members:</p>
			<ul>
				<li><code>begin</code>: It returns an iterator to the beginning of the container.</li>
				<li><code>end</code>: It returns an iterator to the end of the container.</li>
				<li><code>cbegin</code>: It returns a constant iterator to the beginning of the container.</li>
				<li><code>cend</code>: It returns a constant iterator to the end of the container.</li>
			</ul>
			<p>Some containers also have members that return reverse iterators:</p>
			<ul>
				<li><code>rbegin</code>: It returns a reverse iterator to the beginning of the reversed container.</li>
				<li><code>rend</code>: It returns a reverse iterator to the end of the reversed container.</li>
				<li><code>rcbegin</code>: It returns a constant reverse iterator to the beginning of the reversed container.</li>
				<li><code>rcend</code>: It returns a constant reverse iterator to the end of the reversed container.</li>
			</ul>
			<p>There are two things <a id="_idIndexMarker805"/>that must be well understood to be able to work with containers <a id="_idIndexMarker806"/> and iterators:</p>
			<ul>
				<li>The end of a container is not the last element of the container but the one past the last.</li>
				<li>Reversed iterators provide access to the elements in reverse order. A reversed iterator to the first element of a container is actually the last element of the non-reversed container.</li>
			</ul>
			<p>To better understand these two points, let’s look at the following example:</p>
			<pre class="source-code">std::vector&lt;int&gt; v{ 1,2,3,4,5 };</pre>
			<pre class="source-code">// prints 1 2 3 4 5</pre>
			<pre class="source-code">std::copy(v.begin(), v.end(),</pre>
			<pre class="source-code">          std::ostream_iterator&lt;int&gt;(std::cout, " "));</pre>
			<pre class="source-code">// prints 5 4 3 2 1</pre>
			<pre class="source-code">std::copy(v.rbegin(), v.rend(),</pre>
			<pre class="source-code">          std::ostream_iterator&lt;int&gt;(std::cout, " "));</pre>
			<p>The first call to <code>std::copy</code> prints the elements of the container in their given order. On the other hand, the second call to <code>std::copy</code> prints the elements in their reversed order.</p>
			<p>The following diagram illustrates the relationship between iterators and contain<a id="_idTextAnchor181"/>er elements:</p>
			<div><div><img src="img/Figure_8.1_B18367.jpg" alt="Figure 8.1&#13;&#10;" width="546" height="574"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1</p>
			<p>A sequence of elements (regardless of what kind of data structure they are stored in memory) delimited <a id="_idIndexMarker807"/>by two iterators (a begin and an end, which is the one past the last element) is called <a id="_idIndexMarker808"/>a <strong class="bold">range</strong>. This term is used extensively <a id="_idIndexMarker809"/>in the C++ standard (especially with algorithms) and in literature. It is also the term that gave the name to the ranges library in C++20, which will be discussed in <a href="B18367_09_ePub.xhtml#_idTextAnchor188"><em class="italic">Chapter 9</em></a>, <em class="italic">The Ranges Library</em>.</p>
			<p>Apart from the set of the begin/end member functions of the standard containers, there are also stand-alone functions with the same name. Their equivalence is presented in the following table:</p>
			<div><div><img src="img/Table_8.03_B18367.jpg" alt="Table 8.3&#13;&#10;" width="1358" height="619"/>
				</div>
			</div>
			<p class="figure-caption">Table 8.3</p>
			<p>Although these free functions do not bring much benefit when working with standard containers, they help us <a id="_idIndexMarker810"/>in writing generic code that can handle both standard containers <a id="_idIndexMarker811"/>and C-like arrays, since all these free functions are overloaded for static arrays. Here is an example:</p>
			<pre class="source-code">std::vector&lt;int&gt; v{ 1,2,3,4,5 };</pre>
			<pre class="source-code">std::copy(std::begin(v), std::end(v), </pre>
			<pre class="source-code">          std::ostream_iterator&lt;int&gt;(std::cout, " "));</pre>
			<pre class="source-code">int a[] = { 1,2,3,4,5 };</pre>
			<pre class="source-code">std::copy(std::begin(a), std::end(a),</pre>
			<pre class="source-code">          std::ostream_iterator&lt;int&gt;(std::cout, " "));</pre>
			<p>Without these functions, we would have to write <code>std::copy(a, a + 5, …)</code>. Perhaps a big benefit of these functions is that they enable us to use arrays with range-based for loops, as follows:</p>
			<pre class="source-code">std::vector&lt;int&gt; v{ 1,2,3,4,5 };</pre>
			<pre class="source-code">for (auto const&amp; e : v) </pre>
			<pre class="source-code">   std::cout &lt;&lt; e &lt;&lt; ' ';</pre>
			<pre class="source-code">int a[] = { 1,2,3,4,5 };</pre>
			<pre class="source-code">for (auto const&amp; e : a)</pre>
			<pre class="source-code">   std::cout &lt;&lt; e &lt;&lt; ' ';</pre>
			<p>It is not the purpose of this book to teach you how to use each container or the many standard algorithms. However, it should be helpful for you to learn how to create containers, iterators, and algorithms. This is what we will do next.</p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor182"/>Creating a custom container and iterator</h1>
			<p>The best way to understand how containers and iterators work is to experience them first-hand by creating <a id="_idIndexMarker812"/>your own. To avoid implementing something that already <a id="_idIndexMarker813"/>exists in the standard library, we will consider something different – more precisely, a <strong class="bold">circular buffer</strong>. This is a container that, when full, overwrites <a id="_idIndexMarker814"/>existing elements. We can think of different ways such a container could work; therefore, it’s important that we first define the requirements for it. These are as follows:</p>
			<ul>
				<li>The container should have a fixed capacity that is known at compile-time. Therefore, there would be no runtime memory management.</li>
				<li>The capacity is the number of elements the container can store, and the size is the number of elements it actually contains. When the size equals the capacity, we say the container is full.</li>
				<li>When the container is full, adding a new element will overwrite the oldest element in the container.</li>
				<li>Adding new elements is always done at the end; removing existing elements is always done at the beginning (the oldest element in the container).</li>
				<li>There should be random access to the elements of the container, both with the subscript operator and with iterators.</li>
			</ul>
			<p>Based on these requirements, we can think of the following implementation details:</p>
			<ul>
				<li>The elements could be stored in an array. For convenience, this could be the <code>std::array</code> class.</li>
				<li>We need two variables, which we call <code>head</code> and <code>tail</code>, to store the index of the first and last elements of the container. This is needed because due to the circular nature of the container, the beginning and the end shift over time.</li>
				<li>A third variable will store the number of elements in the container. This is useful because otherwise, we would not be able to differentiate whether the container is empty or has one element only from the values of the head and tail indexes.<p class="callout-heading">Important Note</p><p class="callout">The implementation shown here is provided for teaching purposes only and is not intended as a production-ready solution. The experienced reader will find different aspects of the implementation that could be optimized. However, the purpose here is to learn how to write a container and not how to optimize the implementation.</p></li>
			</ul>
			<p>The following diagram <a id="_idIndexMarker815"/>shows a visual representation of such a circular buffer, with a <a id="_idIndexMarker816"/>capacity of eight elements with different states:</p>
			<div><div><img src="img/Figure_8.2_B18367.jpg" alt="Figure 8.2&#13;&#10;" width="1525" height="1140"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2</p>
			<p>What we can see in this diagram is the following:</p>
			<ul>
				<li><strong class="bold">Figure A</strong>: This is an empty buffer. The capacity is 8, the size is 0, and the <strong class="bold">head</strong> and <strong class="bold">tail</strong> both point to index <strong class="bold">0</strong>.</li>
				<li><strong class="bold">Figure B</strong>: This buffer contains one element. The capacity is still 8, the size is 1, and the <strong class="bold">head</strong> and <strong class="bold">tail</strong> both still point to index <strong class="bold">0</strong>.</li>
				<li><strong class="bold">Figure C</strong>: This buffer contains two elements. The size is 2, the <strong class="bold">head</strong> contains index <strong class="bold">0</strong>, and the <strong class="bold">tail</strong> contains index <strong class="bold">1</strong>.</li>
				<li><strong class="bold">Figure D</strong>: This buffer is full. The size is 8, which is equal to the capacity, and the <strong class="bold">head</strong> contains index <strong class="bold">0</strong> and the <strong class="bold">tail</strong> contains index <strong class="bold">7</strong>.</li>
				<li><strong class="bold">Figure E</strong>: This buffer is still full, but an additional element has been added, triggering the overwriting of the oldest element in the buffer. The size is 8, the <strong class="bold">head</strong> contains index <strong class="bold">1</strong>, and the <strong class="bold">tail</strong> contains index <strong class="bold">0</strong>.</li>
			</ul>
			<p>Now that we have <a id="_idIndexMarker817"/>looked at the semantics of the circular buffer, we can start writing <a id="_idIndexMarker818"/>the implementation. We will begin with the container class.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor183"/>Implementing a circular buffer container</h2>
			<p>The code for the <a id="_idIndexMarker819"/>container class would be too long to be put in a single listing, so we’ll break it up into multiple snippets. The first is as follows:</p>
			<pre class="source-code">template &lt;typename T, std::size_t N&gt;</pre>
			<pre class="source-code">   requires(N &gt; 0)</pre>
			<pre class="source-code">class circular_buffer_iterator;</pre>
			<pre class="source-code">template &lt;typename T, std::size_t N&gt;</pre>
			<pre class="source-code">   requires(N &gt; 0)</pre>
			<pre class="source-code">class circular_buffer</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  // ...</pre>
			<pre class="source-code">};</pre>
			<p>There are two things here: the forward declaration of a class template called <code>circular_buffer_iterator</code>, and a class template called <code>circular_buffer</code>. Both have the same template arguments, a type template parameter <code>T</code>, representing the type of the elements, and a non-type template parameter, representing the capacity of the buffer. A constraint is used to ensure that the provided value for capacity is always positive. If you are not using C++20, you can replace the constraint with a <code>static_assert</code> statement or <code>enable_if</code> to enforce the same restriction. The following snippets are all part of the <code>circular_buffer</code> class.</p>
			<p>First, we have a series of member type definitions that provide aliases to different types that are relevant to the <code>circular_buffer</code> class template. These will be used in the implementation <a id="_idIndexMarker820"/>of the class. They are shown next:</p>
			<pre class="source-code">public:</pre>
			<pre class="source-code">   using value_type = T;</pre>
			<pre class="source-code">   using size_type = std::size_t;</pre>
			<pre class="source-code">   using difference_type = std::ptrdiff_t;</pre>
			<pre class="source-code">   using reference = value_type&amp;;</pre>
			<pre class="source-code">   using const_reference = value_type const&amp;;</pre>
			<pre class="source-code">   using pointer = value_type*;</pre>
			<pre class="source-code">   using const_pointer = value_type const*;</pre>
			<pre class="source-code">   using iterator = circular_buffer_iterator&lt;T, N&gt;;</pre>
			<pre class="source-code">   using const_iterator = </pre>
			<pre class="source-code">      circular_buffer_iterator&lt;T const, N&gt;;</pre>
			<p>Second, we have the data members that store the buffer state. The actual elements are stored in a <code>std::array</code> object. The head, tail, and size are all stored in a variable of the <code>size_type</code> data type. These members are all private:</p>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   std::array&lt;value_type, N&gt; data_;</pre>
			<pre class="source-code">   size_type                 head_ = 0;</pre>
			<pre class="source-code">   size_type                 tail_ = 0;</pre>
			<pre class="source-code">   size_type                 size_ = 0;</pre>
			<p>Third, we have the member functions that implement the functionality described earlier. All the following members are public. The first to list here are the constructors:</p>
			<pre class="source-code">constexpr circular_buffer() = default;</pre>
			<pre class="source-code">constexpr circular_buffer(value_type const (&amp;values)[N]) :</pre>
			<pre class="source-code">   size_(N), tail_(N-1)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::copy(std::begin(values), std::end(values), </pre>
			<pre class="source-code">             data_.begin());</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">constexpr circular_buffer(const_reference v):</pre>
			<pre class="source-code">   size_(N), tail_(N-1)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::fill(data_.begin(), data_.end(), v);</pre>
			<pre class="source-code">}</pre>
			<p>There are three constructors defined here (although we can think of additional ones). These are the <a id="_idIndexMarker821"/>default constructor (which is also defaulted) that initializes an empty buffer, a constructor from a C-like array of size <code>N</code>, which initializes a full buffer by copying the array elements, and, finally, a constructor that takes a single value and initializes a full buffer by copying that value into each element of the buffer. These constructors allow us to create circular buffers in any of the following ways:</p>
			<pre class="source-code">circular_buffer&lt;int, 1&gt; b1;              // {}</pre>
			<pre class="source-code">circular_buffer&lt;int, 3&gt; b2({ 1, 2, 3 }); // {1, 2, 3}</pre>
			<pre class="source-code">circular_buffer&lt;int, 3&gt; b3(42);          // {42, 42, 42}</pre>
			<p>Next, we define several member functions that describe the state of the circular buffer:</p>
			<pre class="source-code">constexpr size_type size() const noexcept </pre>
			<pre class="source-code">{ return size_; }</pre>
			<pre class="source-code">constexpr size_type capacity() const noexcept </pre>
			<pre class="source-code">{ return N; }</pre>
			<pre class="source-code">constexpr bool empty() const noexcept </pre>
			<pre class="source-code">{ return size_ == 0; }</pre>
			<pre class="source-code">constexpr bool full() const noexcept </pre>
			<pre class="source-code">{ return size_ == N; }</pre>
			<pre class="source-code">constexpr void clear() noexcept </pre>
			<pre class="source-code">{ size_ = 0; head_ = 0; tail_ = 0; };</pre>
			<p>The <code>size</code> function returns the number of elements in the buffer, the <code>capacity</code> function the number of elements that the buffer can hold, the <code>empty</code> function to check whether the buffer has no elements (the same as <code>size() == 0</code>), and the <code>full</code> function to <a id="_idIndexMarker822"/>check whether the buffer is full (the same as <code>size() == N</code>). There is also a function called <code>clear</code> that puts the circular buffer in the empty state. Beware that this function doesn't destroy any element (does not release memory or call destructors) but only resets the values defining the state of the buffer.</p>
			<p>We need to access the elements of the buffer; therefore, the following functions are defined for this purpose:</p>
			<pre class="source-code">constexpr reference operator[](size_type const pos)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return data_[(head_ + pos) % N];</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">constexpr const_reference operator[](size_type const pos) const</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return data_[(head_ + pos) % N];</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">constexpr reference at(size_type const pos)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if (pos &lt; size_)</pre>
			<pre class="source-code">      return data_[(head_ + pos) % N];</pre>
			<pre class="source-code">   throw std::out_of_range("Index is out of range");</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">constexpr const_reference at(size_type const pos) const</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if (pos &lt; size_)</pre>
			<pre class="source-code">      return data_[(head_ + pos) % N];</pre>
			<pre class="source-code">   throw std::out_of_range("Index is out of range");</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">constexpr reference front()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if (size_ &gt; 0) return data_[head_];</pre>
			<pre class="source-code">   throw std::logic_error("Buffer is empty");</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">constexpr const_reference front() const</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if (size_ &gt; 0) return data_[head_];</pre>
			<pre class="source-code">   throw std::logic_error("Buffer is empty");</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">constexpr reference back()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if (size_ &gt; 0) return data_[tail_];</pre>
			<pre class="source-code">   throw std::logic_error("Buffer is empty");</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">constexpr const_reference back() const</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if (size_ &gt; 0) return data_[tail_];</pre>
			<pre class="source-code">   throw std::logic_error("Buffer is empty");</pre>
			<pre class="source-code">}</pre>
			<p>Each of these members has a <code>const</code> overload that is called for constant instances of the buffer. The constant <a id="_idIndexMarker823"/>member returns a constant reference; the non-const member returns a normal reference. These methods are as follows:</p>
			<ul>
				<li>The subscript operator that returns a reference to the element specified by its index, without checking the value of the index</li>
				<li>The <code>at</code> method that works similarly to the subscript operator, except that it checks that the index is smaller than the size and, if not, throws an exception</li>
				<li>The <code>front</code> method that returns a reference to the first element; if the buffer is empty, it throws an exception</li>
				<li>The <code>back</code> method that returns a reference to the last element; if the buffer is empty, it throws an exception</li>
			</ul>
			<p>We have members to access the elements, but we need members for adding and removing elements <a id="_idIndexMarker824"/>to/from the buffer. Adding new elements always happens at the end, so we’ll call this <code>push_back</code>. Removing existing elements always happens at the beginning (the oldest element), so we’ll call this <code>pop_front</code>. Let’s look first at the former:</p>
			<pre class="source-code">constexpr void push_back(T const&amp; value)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if (empty())</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      data_[tail_] = value;</pre>
			<pre class="source-code">      size_++;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   else if (!full())</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      data_[++tail_] = value;</pre>
			<pre class="source-code">      size_++;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   else</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      head_ = (head_ + 1) % N;</pre>
			<pre class="source-code">      tail_ = (tail_ + 1) % N;</pre>
			<pre class="source-code">      data_[tail_] = value;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>This works based on the defined requirements and the visual representations from <em class="italic">Figure 8.2</em>:</p>
			<ul>
				<li>If the buffer is <a id="_idIndexMarker825"/>empty, copy the value to the element pointed by the <code>tail_</code> index and increment the size.</li>
				<li>If the buffer is neither empty nor full, do the same but also increment the value of the <code>tail_</code> index.</li>
				<li>If the buffer is full, increment both the <code>head_</code> and the <code>tail_</code> and then copy the value to the element pointed by the <code>tail_</code> index.</li>
			</ul>
			<p>This function copies the <code>value</code> argument to a buffer element. However, this could be optimized for temporaries or objects that are no longer needed after pushing to the buffer. Therefore, an overload that takes an rvalue reference is provided. This moves the value to the buffer, avoiding an unnecessary copy. This overload is shown in the following snippet:</p>
			<pre class="source-code">constexpr void push_back(T&amp;&amp; value)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if (empty())</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      data_[tail_] = value;</pre>
			<pre class="source-code">      size_++;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   else if (!full())</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      data_[++tail_] = std::move(value);</pre>
			<pre class="source-code">      size_++;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   else</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      head_ = (head_ + 1) % N;</pre>
			<pre class="source-code">      tail_ = (tail_ + 1) % N;</pre>
			<pre class="source-code">      data_[tail_] = std::move(value);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>A similar approach is used for implementing the <code>pop_back</code> function to remove elements from <a id="_idIndexMarker826"/>the buffer. Here is the implementation:</p>
			<pre class="source-code">constexpr T pop_front()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if (empty()) throw std::logic_error("Buffer is empty");</pre>
			<pre class="source-code">   size_type index = head_;</pre>
			<pre class="source-code">   head_ = (head_ + 1) % N;</pre>
			<pre class="source-code">   size_--;</pre>
			<pre class="source-code">   return data_[index];</pre>
			<pre class="source-code">}</pre>
			<p>This function throws an exception if the buffer is empty. Otherwise, it increments the value of the <code>head_</code> index and returns the value of the element from the previous position of the <code>head_</code>. This is described visually in the following diagram:</p>
			<div><div><img src="img/Figure_8.3_B18367.jpg" alt="Figure 8.3&#13;&#10;" width="1085" height="1013"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3</p>
			<p>What we can see here is the following:</p>
			<ul>
				<li><strong class="bold">Figure A</strong>: The buffer has 3 elements (1, 2, and 3), <strong class="bold">head</strong> is at index <strong class="bold">0</strong>, and <strong class="bold">tail</strong> is at index <strong class="bold">2</strong>.</li>
				<li><strong class="bold">Figure B</strong>: An element has been removed from the front, which was index <strong class="bold">0</strong>. Therefore, <strong class="bold">head</strong> is now index <strong class="bold">1</strong> and <strong class="bold">tail</strong> is still index <strong class="bold">2</strong>. The buffer now has two elements.</li>
				<li><strong class="bold">Figure C</strong>: The buffer has <a id="_idIndexMarker827"/>eight elements, which is its maximum capacity, and an element has been overwritten. The <strong class="bold">head</strong> is at index <strong class="bold">1</strong> and the <strong class="bold">tail</strong> is at index <strong class="bold">0</strong>.</li>
				<li><strong class="bold">Figure D</strong>: An element has been removed from the front, which was index <strong class="bold">1</strong>. The <strong class="bold">head</strong> is now at index <strong class="bold">2</strong> and the <strong class="bold">tail</strong> is still at index <strong class="bold">0</strong>. The buffer now has seven elements.</li>
			</ul>
			<p>An example of using both the <code>push_back</code> and the <code>pop_front</code> member functions is shown in the<a id="_idIndexMarker828"/> next snippet:</p>
			<pre class="source-code">circular_buffer&lt;int, 4&gt; b({ 1, 2, 3, 4 });</pre>
			<pre class="source-code">assert(b.size() == 4);</pre>
			<pre class="source-code">b.push_back(5);</pre>
			<pre class="source-code">b.push_back(6);</pre>
			<pre class="source-code">b.pop_front();</pre>
			<pre class="source-code">assert(b.size() == 3);</pre>
			<pre class="source-code">assert(b[0] == 4);</pre>
			<pre class="source-code">assert(b[1] == 5);</pre>
			<pre class="source-code">assert(b[2] == 6);</pre>
			<p>Finally, we have the member functions <code>begin</code> and <code>end</code> that return iterators to the first and one-past-the-last elements of the buffer. Here is their implementation:</p>
			<pre class="source-code">iterator begin()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return iterator(*this, 0);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">iterator end()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return iterator(*this, size_);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">const_iterator begin() const</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return const_iterator(*this, 0);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">const_iterator end() const</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return const_iterator(*this, size_);</pre>
			<pre class="source-code">}</pre>
			<p>To understand <a id="_idIndexMarker829"/>these, we need to see how the iterator class is actually implemented. We will explore this in the next section.</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor184"/>Implementing an iterator type for the circular buffer container</h2>
			<p>We declared <a id="_idIndexMarker830"/>the iterator class template <a id="_idIndexMarker831"/>at the beginning of the previous section when we started with the <code>circular_buffer</code> container. However, we need to define its implementation too. Yet, there is one more thing we must do: in order for the iterator class to be able to access the private members of the container it needs to be declared as a friend. This is done as follows:</p>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   friend circular_buffer_iterator&lt;T, N&gt;;</pre>
			<p>Let’s look now at the <code>circular_buffer_iterator</code> class, which actually has similarities with the container class. This includes the template parameters, the constraints, and the set of member types (some of them being common to those in <code>circular_buffer</code>). Here is a snippet of the class:</p>
			<pre class="source-code">template &lt;typename T, std::size_t N&gt;</pre>
			<pre class="source-code">requires(N &gt; 0)</pre>
			<pre class="source-code">class circular_buffer_iterator</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">public:</pre>
			<pre class="source-code">   using self_type = circular_buffer_iterator&lt;T, N&gt;;</pre>
			<pre class="source-code">   using value_type = T;</pre>
			<pre class="source-code">   using reference = value_type&amp;;</pre>
			<pre class="source-code">   using const_reference = value_type const &amp;;</pre>
			<pre class="source-code">   using pointer = value_type*;</pre>
			<pre class="source-code">   using const_pointer = value_type const*;</pre>
			<pre class="source-code">   using iterator_category =</pre>
			<pre class="source-code">      std::random_access_iterator_tag;</pre>
			<pre class="source-code">   using size_type = std::size_t;</pre>
			<pre class="source-code">   using difference_type = std::ptrdiff_t;</pre>
			<pre class="source-code">public:</pre>
			<pre class="source-code">   /* definitions */</pre>
			<pre class="source-code">private:</pre>
			<pre class="source-code">   std::reference_wrapper&lt;circular_buffer&lt;T, N&gt;&gt; buffer_;</pre>
			<pre class="source-code">   size_type              index_ = 0;</pre>
			<pre class="source-code">};</pre>
			<p>The <code>circular_buffer_iterator</code> class has a reference to a circular buffer and an index to the <a id="_idIndexMarker832"/>element in the buffer that it <a id="_idIndexMarker833"/>points to. The reference to <code>circular_buffer&lt;T, N&gt;</code> is wrapped inside a <code>std::reference_wrapper</code> object. The reason for this will be unveiled shortly. Such an iterator can be explicitly created by providing these two arguments. Therefore, the only constructor looks as follows:</p>
			<pre class="source-code">explicit circular_buffer_iterator(</pre>
			<pre class="source-code">   circular_buffer&lt;T, N&gt;&amp; buffer,</pre>
			<pre class="source-code">   size_type const index):</pre>
			<pre class="source-code">   buffer_(buffer), index_(index)</pre>
			<pre class="source-code">{ }</pre>
			<p>If we now look back at the definitions of the <code>begin</code> and <code>end</code> member functions of <code>circular_buffer</code>, we can see that the first argument was <code>*this</code>, and the second was 0 for the <a id="_idIndexMarker834"/>begin iterator and <code>size_</code> for the <a id="_idIndexMarker835"/>end iterator. The second value is the offset from the head of the element pointed by the iterator. Therefore, 0 is the first element, and <code>size_</code> is the one-past-the-last element in the buffer.</p>
			<p>We have decided that we need random access to the elements of the buffer; therefore, the iterator category is random-access. The member type <code>iterator_category</code> is an alias for <code>std::random_access_iterator_tag</code>. This implies that we need to provide all the operations supported for such an iterator. In the previous section of this chapter, we discussed the iterator categories and the required operations for each category. We will implement all the required ones next. </p>
			<p>We start with the requirements for an input iterator, which are as follows:</p>
			<pre class="source-code">self_type&amp; operator++()</pre>
			<pre class="source-code">{ </pre>
			<pre class="source-code">   if(index_ &gt;= buffer_.get().size())</pre>
			<pre class="source-code">      throw std::out_of_range("Iterator cannot be </pre>
			<pre class="source-code">                  incremented past the end of the range");</pre>
			<pre class="source-code">   index_++;</pre>
			<pre class="source-code">   return *this;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">self_type operator++(int)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   self_type temp = *this;</pre>
			<pre class="source-code">   ++*this;</pre>
			<pre class="source-code">   return temp;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">bool operator==(self_type const&amp; other) const</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return compatible(other) &amp;&amp; index_ == other.index_;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">bool operator!=(self_type const&amp; other) const</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return !(*this == other);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">const_reference operator*() const</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if (buffer_.get().empty() || !in_bounds())</pre>
			<pre class="source-code">      throw std::logic_error("Cannot dereferentiate the </pre>
			<pre class="source-code">                              iterator");</pre>
			<pre class="source-code">   return buffer_.get().data_[</pre>
			<pre class="source-code">      (buffer_.get().head_ + index_) % </pre>
			<pre class="source-code">       buffer_.get().capacity()];</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">const_reference operator-&gt;() const</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if (buffer_.get().empty() || !in_bounds())</pre>
			<pre class="source-code">      throw std::logic_error("Cannot dereferentiate the </pre>
			<pre class="source-code">                              iterator");</pre>
			<pre class="source-code">   return buffer_.get().data_[</pre>
			<pre class="source-code">      (buffer_.get().head_ + index_) % </pre>
			<pre class="source-code">       buffer_.get().capacity()];</pre>
			<pre class="source-code">}</pre>
			<p>We have implemented here incrementing (both pre- and post-fix), checking for equality/inequality, and <a id="_idIndexMarker836"/>dereferencing. The <code>*</code> and <code>-&gt;</code> operators <a id="_idIndexMarker837"/>throw an exception if the element cannot be dereferenced. The cases when this happens are when the buffer is empty, or the index is not within bounds (between <code>head_</code> and <code>tail_</code>). We used two helper functions (both private), called <code>compatible</code> and <code>is_bounds</code>. These are shown next:</p>
			<pre class="source-code">bool compatible(self_type const&amp; other) const</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return buffer_.get().data_.data() == </pre>
			<pre class="source-code">          other.buffer_.get().data_.data();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">bool in_bounds() const</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return</pre>
			<pre class="source-code">      !buffer_.get().empty() &amp;&amp;</pre>
			<pre class="source-code">      (buffer_.get().head_ + index_) % </pre>
			<pre class="source-code">       buffer_.get().capacity() &lt;= buffer_.get().tail_;</pre>
			<pre class="source-code">}</pre>
			<p>A <code>a</code> and <code>b</code> are two forward iterators and they are equal, then either they are non-dereferenceable, otherwise, their iterator values, <code>*a</code> and <code>*b</code>, refer to the same object. The opposite is also true, meaning that if <code>*a</code> and <code>*b</code> are equal, then <code>a</code> and <code>b</code> are also equal. This is true for our implementation.</p>
			<p>The other <a id="_idIndexMarker840"/>requirement for forward iterators is <a id="_idIndexMarker841"/>that they are swappable. That means if <code>a</code> and <code>b</code> are two forward iterators, then <code>swap(a, b)</code> should be a valid operation. This leads us back to using a <code>std::reference_wrapper</code> object to hold a reference to a <code>circular_buffer&lt;T, N&gt;</code>. References are not swappable, which would have made <code>circular_buffer_iterator</code> not swappable either. However, <code>std::reference_wrapper</code> is swappable, and that also makes our iterator type swappable. That can be verified with a <code>static_assert</code> statement, such as the following:</p>
			<pre class="source-code">static_assert(</pre>
			<pre class="source-code">   std::is_swappable_v&lt;circular_buffer_iterator&lt;int, 10&gt;&gt;);</pre>
			<p class="callout-heading">Important Note</p>
			<p class="callout">An alternative to using <code>std::reference_wrapper</code> is to use a raw pointer to a <code>circular_buffer</code> class, since pointers can be assigned values and are, therefore swappable. It is a matter of style and personal choice which one to use. In this example, I preferred the solution that avoided the raw pointer.</p>
			<p>For fulfilling the requirements for the bidirectional iterator category, we need to support <a id="_idIndexMarker842"/>decrementing. In the next snippet, you <a id="_idIndexMarker843"/>can see the implementation of both pre- and post-fix decrement operators:</p>
			<pre class="source-code">self_type&amp; operator--()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if(index_ &lt;= 0)</pre>
			<pre class="source-code">      throw std::out_of_range("Iterator cannot be </pre>
			<pre class="source-code">           decremented before the beginning of the range");</pre>
			<pre class="source-code">   index_--;</pre>
			<pre class="source-code">   return *this;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">self_type operator--(int)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   self_type temp = *this;</pre>
			<pre class="source-code">   --*this;</pre>
			<pre class="source-code">   return temp;</pre>
			<pre class="source-code">}</pre>
			<p>Finally, we have the requirements of the <code>+</code> and <code>-</code>) and compound (<code>+=</code> and <code>-=</code>) operations. These are shown next:</p>
			<pre class="source-code">self_type operator+(difference_type offset) const</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   self_type temp = *this;</pre>
			<pre class="source-code">   return temp += offset;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">self_type operator-(difference_type offset) const</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   self_type temp = *this;</pre>
			<pre class="source-code">   return temp -= offset;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">difference_type operator-(self_type const&amp; other) const</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return index_ - other.index_;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">self_type&amp; operator +=(difference_type const offset)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   difference_type next = </pre>
			<pre class="source-code">      (index_ + next) % buffer_.get().capacity();</pre>
			<pre class="source-code">   if (next &gt;= buffer_.get().size())</pre>
			<pre class="source-code">      throw std::out_of_range("Iterator cannot be </pre>
			<pre class="source-code">                incremented past the bounds of the range");</pre>
			<pre class="source-code">   index_ = next;</pre>
			<pre class="source-code">   return *this;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">self_type&amp; operator -=(difference_type const offset)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return *this += -offset;</pre>
			<pre class="source-code">}</pre>
			<p>Random-access iterators must support inequality comparison with other operations. That means, we need to overload the <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> operators. However, the <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> operators can <a id="_idIndexMarker845"/>be implemented based <a id="_idIndexMarker846"/>on the <code>&lt;</code> operator. Therefore, their definition can be as follows:</p>
			<pre class="source-code">bool operator&lt;(self_type const&amp; other) const</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return index_ &lt; other.index_;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">bool operator&gt;(self_type const&amp; other) const</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return other &lt; *this;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">bool operator&lt;=(self_type const&amp; other) const</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return !(other &lt; *this);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">bool operator&gt;=(self_type const&amp; other) const</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return !(*this &lt; other);</pre>
			<pre class="source-code">}</pre>
			<p>Last, but <a id="_idIndexMarker847"/>not least, we need to provide <a id="_idIndexMarker848"/>access to elements with the subscript operator (<code>[]</code>). A possible implementation is the following:</p>
			<pre class="source-code">value_type&amp; operator[](difference_type const offset)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return *((*this + offset));</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">value_type const &amp; operator[](difference_type const offset) const</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return *((*this + offset));</pre>
			<pre class="source-code">}</pre>
			<p>With this, we have completed the implementation of the iterator type for the circular buffer. If you had trouble following the multitude of code snippets for these two classes, you can find the complete implementation in the GitHub repository for the book. A simple example for using the iterator type is shown next:</p>
			<pre class="source-code">circular_buffer&lt;int, 3&gt; b({1, 2, 3});</pre>
			<pre class="source-code">std::vector&lt;int&gt; v;</pre>
			<pre class="source-code">for (auto it = b.begin(); it != b.end(); ++it)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   v.push_back(*it);</pre>
			<pre class="source-code">}</pre>
			<p>This code can be actually simplified with range-based for loops. In this case, we don’t use iterators <a id="_idIndexMarker849"/>directly, but the compiler-generated <a id="_idIndexMarker850"/>code does. Therefore, the following snippet is equivalent to the previous one:</p>
			<pre class="source-code">circular_buffer&lt;int, 3&gt; b({ 1, 2, 3 });</pre>
			<pre class="source-code">std::vector&lt;int&gt; v;</pre>
			<pre class="source-code">for (auto const e : b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   v.push_back(e);</pre>
			<pre class="source-code">}</pre>
			<p>However, the implementation provided here for <code>circular_buffer_iterator</code> does not allow the following piece of code to compile:</p>
			<pre class="source-code">circular_buffer&lt;int, 3&gt; b({ 1,2,3 });</pre>
			<pre class="source-code">*b.begin() = 0;</pre>
			<pre class="source-code">assert(b.front() == 0);</pre>
			<p>This requires that we are able to write elements through iterators. However, our implementation doesn’t meet the requirements for the output iterator category. This requires that expressions such as <code>*it = v</code>, or <code>*it++ = v</code> are valid. To do so, we need to provide non-const overloads of the <code>*</code> and <code>-&gt;</code> operators that return non-const reference types. This can be done as follows:</p>
			<pre class="source-code">reference operator*()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if (buffer_.get().empty() || !in_bounds())</pre>
			<pre class="source-code">      throw std::logic_error("Cannot dereferentiate the </pre>
			<pre class="source-code">                              iterator");</pre>
			<pre class="source-code">   return buffer_.get().data_[</pre>
			<pre class="source-code">      (buffer_.get().head_ + index_) % </pre>
			<pre class="source-code">       buffer_.get().capacity()];</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">reference operator-&gt;()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if (buffer_.get().empty() || !in_bounds())</pre>
			<pre class="source-code">      throw std::logic_error("Cannot dereferentiate the </pre>
			<pre class="source-code">                              iterator");</pre>
			<pre class="source-code">   return buffer_.get().data_[</pre>
			<pre class="source-code">      (buffer_.get().head_ + index_) % </pre>
			<pre class="source-code">       buffer_.get().capacity()];</pre>
			<pre class="source-code">}</pre>
			<p>More examples <a id="_idIndexMarker851"/>for using <a id="_idIndexMarker852"/>the <code>circular_buffer</code> class with and without iterators can be found in the GitHub repository. Next, we will focus our attention on implementing a general-purpose algorithm that works for any range, including the <code>circular_buffer</code> container we defined here.</p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor185"/>Writing a custom general-purpose algorithm</h1>
			<p>In the first section of this chapter, we saw why abstracting access to container elements with iterators is key <a id="_idIndexMarker853"/>for building general-purpose algorithms. However, it should be useful for you to practice writing such an algorithm because it can help you better understand the use of iterators. Therefore, in this section, we will write a general-purpose algorithm.</p>
			<p>The standard library features many such algorithms. One that is missing is a <strong class="bold">zipping algorithm</strong>. What zipping means is actually interpreted or understood differently by different people. For some, zipping <a id="_idIndexMarker854"/>means taking two or more input ranges and creating a new range with the elements from the input ranges intercalated. This is exemplified in the following diagram:</p>
			<div><div><img src="img/Figure_8.4_B18367.jpg" alt="Figure 8.4&#13;&#10;" width="1025" height="392"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4</p>
			<p>For others, zipping means taking two or more input ranges and creating a new range, with elements being <a id="_idIndexMarker855"/>tuples formed from the elements of the input ranges. This is shown in the next diagram:</p>
			<div><div><img src="img/Figure_8.5_B18367.jpg" alt="Figure 8.5&#13;&#10;" width="997" height="382"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5</p>
			<p>In this section, we will implement the first algorithm. In order to avoid confusion, we will call this <strong class="bold">flatzip</strong>. Here are the requirements for it:</p>
			<ul>
				<li>The algorithm takes two input ranges and writes to an output range.</li>
				<li>The algorithm takes iterators as arguments. A pair of first and last input iterators define the bounds of each input range. An output iterator defines the beginning of the output range where the elements will be written to.</li>
				<li>The two input ranges should contain elements of the same type. The output range must have elements of the same type or a type to which the input type is implicitly convertible.</li>
				<li>If the two input ranges are of different sizes, the algorithm stops when the smallest of the two has been processed (as shown in the previous diagrams).</li>
				<li>The return value is the output iterator to the one-past-the-last element that was copied.</li>
			</ul>
			<p>A possible implementation <a id="_idIndexMarker856"/>for the described algorithm is shown in the following listing:</p>
			<pre class="source-code">template &lt;typename InputIt1, typename InputIt2,</pre>
			<pre class="source-code">          typename OutputIt&gt;</pre>
			<pre class="source-code">OutputIt flatzip(</pre>
			<pre class="source-code">   InputIt1 first1, InputIt1 last1,</pre>
			<pre class="source-code">   InputIt2 first2, InputIt2 last2,</pre>
			<pre class="source-code">   OutputIt dest)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   auto it1 = first1;</pre>
			<pre class="source-code">   auto it2 = first2;</pre>
			<pre class="source-code">   while (it1 != last1 &amp;&amp; it2 != last2)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      *dest++ = *it1++;</pre>
			<pre class="source-code">      *dest++ = *it2++;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   return dest;</pre>
			<pre class="source-code">}</pre>
			<p>As you can see in the snippet, the implementation is quite simple. All we do here is iterate through both input ranges at the same time and copy elements alternately from them to the destination range. The iteration on both input ranges stops when the end of the smallest range is reached. We can use this algorithm as follows:</p>
			<pre class="source-code">// one range is empty</pre>
			<pre class="source-code">std::vector&lt;int&gt; v1 {1,2,3};</pre>
			<pre class="source-code">std::vector&lt;int&gt; v2;</pre>
			<pre class="source-code">std::vector&lt;int&gt; v3;</pre>
			<pre class="source-code">flatzip(v1.begin(), v1.end(), v2.begin(), v2.end(),</pre>
			<pre class="source-code">        std::back_inserter(v3));</pre>
			<pre class="source-code">assert(v3.empty());</pre>
			<pre class="source-code">// neither range is empty</pre>
			<pre class="source-code">std::vector&lt;int&gt; v1 {1, 2, 3};</pre>
			<pre class="source-code">std::vector&lt;int&gt; v2 {4, 5};</pre>
			<pre class="source-code">std::vector&lt;int&gt; v3;</pre>
			<pre class="source-code">flatzip(v1.begin(), v1.end(), v2.begin(), v2.end(),</pre>
			<pre class="source-code">        std::back_inserter(v3));</pre>
			<pre class="source-code">assert(v3 == std::vector&lt;int&gt;({ 1, 4, 2, 5 }));</pre>
			<p>These examples use <code>std::vector</code> for both the input and output ranges. However, the <code>flatzip</code> algorithm knows nothing about containers. The elements of the container are accessed with the <a id="_idIndexMarker857"/>help of iterators. Therefore, as long as the iterators meet the specified requirements, we can use any container. This includes the <code>circular_buffer</code> container we previously wrote since <code>circular_buffer_container</code> meets the requirements for both the input and output iterator categories. This means we can also write the following snippet:</p>
			<pre class="source-code">circular_buffer&lt;int, 4&gt; a({1, 2, 3, 4});</pre>
			<pre class="source-code">circular_buffer&lt;int, 3&gt; b({5, 6, 7});</pre>
			<pre class="source-code">circular_buffer&lt;int, 8&gt; c(0);</pre>
			<pre class="source-code">flatzip(a.begin(), a.end(), b.begin(), b.end(), c.begin());</pre>
			<pre class="source-code">std::vector&lt;int&gt; v;</pre>
			<pre class="source-code">for (auto e : c)</pre>
			<pre class="source-code">   v.push_back(e);</pre>
			<pre class="source-code">assert(v == std::vector&lt;int&gt;({ 1, 5, 2, 6, 3, 7, 0, 0 }));</pre>
			<p>We have two input circular buffers: <code>a</code>, which has four elements, and <code>b</code>, which has three elements. The destination <a id="_idIndexMarker858"/>circular buffer has a capacity of eight elements, all initialized with zero. After applying the flatzip algorithm, six elements of the destination circular buffer will be written with values from the <code>a</code> and <code>b</code> buffers. The result is that the circular buffer will contain the elements <code>1, 5, 2, 6, 3, 7, 0, 0</code>.</p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor186"/>Summary</h1>
			<p>This chapter was dedicated to seeing how templates can be used to build general-purpose libraries. Although we couldn’t cover these topics in great detail, we have explored the design of containers, iterators, and algorithms from the C++ standard library. These are the pillars of the standard library. We spent most of the chapter understanding what it takes to write a container similar to the standard ones as well as an iterator class to provide access to its elements. For this purpose, we implemented a class that represents a circular buffer, a data structure of fixed size where elements are overwritten once the container is full. Lastly, we implemented a general-purpose algorithm that zips elements from two ranges. This works for any container including the circular buffer container.</p>
			<p>Ranges, as discussed in this chapter, are an abstract concept. However, that changed with C++20, which introduced a more concrete concept of ranges with the new ranges library. This is what we will discuss in the final chapter of this book.</p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor187"/>Questions</h1>
			<ol>
				<li>What are the sequence containers from the standard library?</li>
				<li>What are the common member functions defined in the standard containers?</li>
				<li>What are iterators and how many categories exist?</li>
				<li>What operations does a random-access iterator support?</li>
				<li>What are range access functions?</li>
			</ol>
		</div>
		<div><div></div>
		</div>
	</div></body></html>