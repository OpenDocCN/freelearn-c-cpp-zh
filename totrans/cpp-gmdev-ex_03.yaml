- en: Mathematics and Graphics Concepts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数学与图形概念
- en: Before we begin rendering objects, it is essential that you are familiar with
    the math that will be used for the projects in this book. Mathematics plays a
    crucial role in game development, and graphics programming generally uses vectors
    and matrices extensively. In this chapter, you will understand where these math
    concepts can come in handy. First, we'll go over some key mathematical concepts
    and then apply them so that we can work with space transformations and render
    pipelines. There are dedicated books that cover all the math-related topics that
    you'll need for game development. However, since we will be covering graphics
    programming with C++, other mathematics topics are out of the scope of this book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始渲染对象之前，了解本书项目中将使用的数学知识是至关重要的。数学在游戏开发中起着至关重要的作用，图形编程通常广泛使用向量和矩阵。在本章中，你将了解这些数学概念如何派上用场。首先，我们将回顾一些关键数学概念，然后应用它们，以便我们可以处理空间变换和渲染管线。有专门的书籍涵盖了你在游戏开发中需要的所有数学相关主题。然而，由于我们将使用C++进行图形编程，其他数学主题超出了本书的范围。
- en: In the upcoming chapters, we will be using the OpenGL and Vulkan graphics APIs
    to render our objects and use the GLM math library to do the maths. In this chapter,
    we will explore the process of creating a 3D object in a virtual world using matrix
    and vector transforms. Then, we will look at how we can transform a 3D point into
    a 2D location using space transforms, as well as how the graphics pipeline helps
    us achieve this.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将使用OpenGL和Vulkan图形API来渲染我们的对象，并使用GLM数学库来进行数学运算。在本章中，我们将探讨在虚拟世界中使用矩阵和向量变换创建3D对象的过程。然后，我们将看看如何使用空间变换将3D点转换为2D位置，以及图形管线如何帮助我们实现这一点。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: 3D coordinate systems
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D坐标系
- en: Vectors
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量
- en: Matrices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵
- en: GLM OpenGL mathematics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GLM OpenGL数学
- en: OpenGL data types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL数据类型
- en: Space transformations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空间变换
- en: Render pipeline
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染管线
- en: 3D coordinate systems
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D坐标系
- en: 'Before we can specify a location, we have to specify a coordinate system. A
    3D coordinate system has three axes: the *x *axis, the *y* axis, and the *z* axis.
    These three axes start from the origin of where the three axes intersect.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够指定一个位置之前，我们必须指定一个坐标系。一个3D坐标系有三个轴：*x*轴、*y*轴和*z*轴。这三个轴从三个轴相交的原点开始。
- en: The positive x axis starts from the origin and starts moving endlessly in a
    certain direction, while the negative *x* axis moves in the opposite direction.
    The positive *y *axis starts from the origin and moves in an upward direction
    at 90 degrees to the *x *axis, and the negative *y *axis moves in the opposite
    direction. This describes a 2D XY plane, which forms the basis of a 2D coordinate
    system.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正的x轴从原点开始，并无限地向一个特定方向移动，而负的*x*轴则向相反方向移动。正的*y*轴从原点开始，以90度角向上移动，与*x*轴垂直，负的*y*轴则向相反方向移动。这描述了一个2D
    XY平面，它是2D坐标系的基础。
- en: The positive *z *axis starts from the same origin as the *x* and *y* axes and
    is perpendicular to the X and Y axes. The positive *z* axis can go in either direction
    of the XY plane in order to form a 3D coordinate system.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正的*z*轴与*x*轴和*y*轴有相同的原点，并且垂直于X轴和Y轴。正*z*轴可以沿着XY平面的任意方向移动，以形成一个3D坐标系。
- en: Assuming that the positive *x* axis is going to the right and the positive *y* axis
    is going up, then the *z *axis can either go into or out of the screen. This is
    because the *z *axis is perpendicular to the *x* and *y* axes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 假设正*x*轴向右，正*y*轴向上，那么*z*轴可以进入或离开屏幕。这是因为*z*轴与*x*轴和*y*轴垂直。
- en: When the positive *z *axis moves into the screen, this is known as a **left-handed
    coordinate system**. When the positive *z *axis comes out of the screen, this
    is known as a **ight-handed coordinate system**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当正的*z*轴进入屏幕时，这被称为**左手坐标系**。当正的*z*轴从屏幕出来时，这被称为**右手坐标系**。
- en: Extend your right arm so that it's in front of you, with your palm facing toward
    you, and make a fist. Extend your thumb to the right, and then extend your index
    finger upward. Now, extend your middle finger so that it faces you. This can be
    used to explain the right-handed coordinate system.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的右手臂伸直，使其在你面前，手掌朝向你，并握紧拳头。将你的大拇指向右伸直，然后伸直食指向上。现在，将你的中指伸直，使其朝向你。这可以用来解释右手坐标系。
- en: The thumb represents the direction of the positive *x* axis, the index finger
    represents the direction of the positive *y* axis, and the middle finger is the
    direction of the positive *z *axis. OpenGL, Vulkan, or any other graphics framework
    that uses these axes also use this coordinate system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 拇指代表正*x*轴的方向，食指代表正*y*轴的方向，中指代表正*z*轴的方向。OpenGL、Vulkan或任何使用这些轴的图形框架也使用这个坐标系。
- en: For the left-handed coordinate system, extend your left arm out so that it's
    in front of you, with the palm of your hand facing away from you, and make a fist.
    Next, extend your thumb and index finger in the right and upward directions, respectively.
    Now, extend your middle finger so that it's away from you. In this case, the thumb
    also represents the direction of the *x* axis and the index finger is pointing
    in the direction of the positive *y* axis. The *z *axis (the middle finger) is
    now facing away from you. Direct3D of DirectX uses this coordinate system.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于左手坐标系，伸出你的左臂，使其在你面前，手掌朝向你，然后握拳。接下来，伸出你的拇指和食指，分别指向右上方。现在，伸出你的中指，使其远离你。在这种情况下，拇指代表*x*轴的方向，食指指向正*y*轴的方向。*z*轴（中指）现在远离你。Direct3D的DirectX使用这个坐标系。
- en: 'In this book, since we are going to be covering OpenGL and Vulkan, we will
    be using the **right-handed coordinate system**:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，由于我们将要介绍OpenGL和Vulkan，我们将使用**右手坐标系**：
- en: '![](img/173e45a5-bdff-42fc-9d6b-ae4e42108aa6.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/173e45a5-bdff-42fc-9d6b-ae4e42108aa6.png)'
- en: Points
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点
- en: 'Now that we have defined the coordinate system, we can specify what a point
    is. A 3D point is a location in 3D space that''s specified by distance in terms
    of the **X**, **Y**, and **Z** axes and the origin of the coordinate system. It
    is specified as (X, Y, Z) where X, Y, and Z are the distance from the origin.
    But what is this origin we speak of? The origin is also the point where the three
    axes meet. The origin is at (0, 0, 0), and the location of the origin is specified
    in the coordinate system, as shown in the following diagram:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了坐标系，我们可以指定一个点的定义。一个3D点是在3D空间中的一个位置，它通过**X**、**Y**和**Z**轴的距离以及坐标系的起点来指定。它被指定为(X,
    Y, Z)，其中X、Y和Z是从原点到该点的距离。但我们所说的原点是什么？原点也是三个轴相交的点。原点位于(0, 0, 0)，原点的位置在坐标系中指定，如下所示：
- en: '![](img/7c1608c8-03a6-4a61-84f8-75278ce57907.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c1608c8-03a6-4a61-84f8-75278ce57907.png)'
- en: To specify points within a coordinate system, imagine that, in each direction,
    the axis is made of a smaller unit. This unit could be 1 millimeter, 1 centimeter,
    or 1 kilometer, depending on how much data you have.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定坐标系内的点，想象在每个方向上，轴由更小的单位组成。这个单位可以是1毫米、1厘米或1千米，具体取决于你有多少数据。
- en: 'If we just look at the X and Y axes, this would look something like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只看X轴和Y轴，这看起来可能就像这样：
- en: '![](img/14788c58-1d46-42dc-82c7-1470797f8f59.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/14788c58-1d46-42dc-82c7-1470797f8f59.png)'
- en: If we look at the *x* axis, the values 1 and 2 specify the distance along the
    axis of that point from the origin, which is at value 0\. So, point 1 in the *x* axis
    is at (1, 0, 0) along the *x* axis. Similarly, point 1, which is along the *y* axis,
    is at (0, 1, 0).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看*x*轴，值1和2指定了从原点（值为0）沿该轴的点的距离。所以，*x*轴上的点1位于(1, 0, 0)。同样，沿*y*轴的点1位于(0, 1,
    0)。
- en: In addition, the location of the red dot will be at (1, 1, 0); that is, 1 unit
    along the *x* axis and 1 unit along the *y* axis. Since Z is 0, we specify that
    its value is 0.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，红色点的位置将在(1, 1, 0)；也就是说，沿*x*轴和*y*轴各1个单位。由于Z值为0，我们指定其值为0。
- en: 'Similarly, the points in 3D space are represented as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，3D空间中的点如下表示：
- en: '![](img/96c28731-e7cc-4c6c-81a1-ee8e7285d42c.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/96c28731-e7cc-4c6c-81a1-ee8e7285d42c.png)'
- en: Vectors
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量
- en: A vector is a quantity that has a magnitude and a direction. Examples of quantities
    that have a magnitude and direction are displacement, velocity, acceleration,
    and force. With displacement, you can specify the direction as well as the net
    distance that the object has moved by.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 向量是一个具有大小和方向的量。具有大小和方向的量的例子包括位移、速度、加速度和力。对于位移，你可以指定方向以及物体移动的总距离。
- en: The difference between speed and velocity is that speed only specifies the speed
    that an object is moving at, but doesn't establish the direction the object is
    moving in. However, velocity specifies the magnitude, which includes speed and
    direction. Similar to velocity, we have acceleration. A form of acceleration is
    gravity, and we know that this always acts downward and is always approximately
    9.81 m/s²  – well, at least on Earth. It is 1/6^(th ) of this on the moon.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 速度和速度的区别在于，速度只指定物体移动的速度，但不确定物体移动的方向。然而，速度指定了大小，这包括速度和方向。与速度类似，我们还有加速度。加速度的一种形式是重力，我们知道它总是向下作用，并且总是大约9.81
    m/s²  —— 好吧，至少在地球上是这样。在月球上，这个值是地球的1/6。
- en: An example of force is weight. Weight also acts downward and is calculated as
    mass multiplied by acceleration.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 力的一个例子是重量。重量也向下作用，并且是质量乘以加速度的计算结果。
- en: Vectors are graphically represented by a pointed line segment, with the length
    of the line denoting the magnitude of the vector and the pointed arrow denoting
    the direction of the vector. We can move around a vector since doing this doesn't
    change the magnitude or direction of it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 向量通过一个带箭头的线段进行图形表示，线段的长度表示向量的模，而带箭头的箭头表示向量的方向。我们可以围绕一个向量移动，因为这样做不会改变其大小或方向。
- en: Two vectors are said to be equal if they both have the same magnitude and direction,
    even if they are in different locations. Vectors are denoted by arrow marks above
    the letter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 两个向量如果它们的大小和方向都相同，即使它们位于不同的位置，则称这两个向量相等。向量用字母上方的箭头表示。
- en: 'In the following diagram, vectors ![](img/2a1e581e-d673-4ab8-a190-742cc0f7cbfd.png) and ![](img/8bc6892d-8e78-4fcc-ba73-e642288cde44.png) start
    in different locations. Since the direction and magnitude of the are arrows the
    same, they are equal:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，向量![图片](img/2a1e581e-d673-4ab8-a190-742cc0f7cbfd.png)和![图片](img/8bc6892d-8e78-4fcc-ba73-e642288cde44.png)的起点不同。由于箭头的大小和方向相同，它们是相等的：
- en: '![](img/fa8b7924-63fc-4bfc-9e1a-140d1b32793a.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fa8b7924-63fc-4bfc-9e1a-140d1b32793a.png)'
- en: 'In a 3D coordinate system, a vector is specified by the coordinates with respect
    to the coordinate system. In the following diagram, the vector, ![](img/ac329482-d883-4a99-9f36-a6f0d7f49832.png) is
    equal to (2, 3, 1) and is denoted as ![](img/1798f038-6515-471c-8a07-2b61201db57d.png) =![](img/2dae2535-79ec-444f-b2eb-59341ded4914.png):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '在三维坐标系中，一个向量由相对于该坐标系的坐标来指定。在以下图中，向量![图片](img/ac329482-d883-4a99-9f36-a6f0d7f49832.png)等于(2,
    3, 1)并且表示为![图片](img/1798f038-6515-471c-8a07-2b61201db57d.png)=![](img/2dae2535-79ec-444f-b2eb-59341ded4914.png):'
- en: '![](img/ffc09b70-20e0-4a4f-a06e-67a53498412f.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ffc09b70-20e0-4a4f-a06e-67a53498412f.png)'
- en: Vector operations
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量运算
- en: Just like scalar information, vectors can also be added, subtracted, and multiplied.
    Suppose you have two vectors, ![](img/214bb708-9019-41ac-b71a-72773b5506e5.png) and ![](img/c708a57d-c191-4fa0-bc41-daea6143fb64.png) ,
    where ![](img/343aaa7e-9caa-4dfe-8520-6d6788753578.png)= (a[x], a[y], a[z]) and  ![](img/8ac3e72f-eca2-453e-8494-35b70b081f0d.png)=
    (b[x], b[y], b[z]). Let's look at how we can add and subtract these vectors to/from
    each other.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 就像标量信息一样，向量也可以相加、相减和相乘。假设你有两个向量![图片](img/214bb708-9019-41ac-b71a-72773b5506e5.png)和![图片](img/c708a57d-c191-4fa0-bc41-daea6143fb64.png)，其中![图片](img/343aaa7e-9caa-4dfe-8520-6d6788753578.png)=
    (a[x], a[y], a[z])和![图片](img/8ac3e72f-eca2-453e-8494-35b70b081f0d.png)= (b[x],
    b[y], b[z])。让我们看看我们如何将这些向量相加和相减。
- en: 'When adding vectors, we add the components individually to create a new vector:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加向量时，我们分别将分量相加以创建一个新的向量：
- en: '![](img/9d1bce52-2dfd-4ec3-9d3a-e74b6cef8c99.png)= ![](img/0dbf3fce-6ebc-4977-a9d4-aa03a1d86851.png) +  ![](img/09c33362-d2f1-4f5a-b394-ea0bc3dacc7e.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9d1bce52-2dfd-4ec3-9d3a-e74b6cef8c99.png)= ![图片](img/0dbf3fce-6ebc-4977-a9d4-aa03a1d86851.png)
    + ![图片](img/09c33362-d2f1-4f5a-b394-ea0bc3dacc7e.png)'
- en: '![](img/c74fa717-c4a9-4e66-99d4-d5aa515e3c2e.png)= ((ax + bx) , (ay + by) ,
    (az + bz ))'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c74fa717-c4a9-4e66-99d4-d5aa515e3c2e.png)= ((ax + bx) , (ay + by)
    , (az + bz ))'
- en: 'Now, let''s visualize the addition of two vectors in a graph. The Z value is
    kept as 0.0 for convenience. Here, ![](img/973328f0-7acb-424f-8ae3-e391aad4e811.png)=(1.0,
    0.4, 0.0 ) and  ![](img/4ea4a919-bf8d-46ea-9143-c0f4cf3c5abc.png)=(0.6, 2.0, 0.0),
    which means that the resultant vector,  ![](img/df084c7d-cb1b-42ab-9c8f-d0628d213d90.png)= ![](img/c7261b2a-0c1e-428d-9a36-fc659f099f4e.png) +  ![](img/01c1a38c-3785-497f-8ce2-86647d472448.png),
    = (1.0 + 0.6 , 0.4 + 2.0, 0.0 + 0.0) = (1.6, 2.4 , 0.0):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/521124c0-58e2-4239-bcb3-f3a0cd0943fb.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: Vectors are also commutative, meaning that  ![](img/695a78c8-3cbe-46b4-b06f-148bc930aa88.png) +  ![](img/341c8b1d-aece-41ec-93a7-c5aa1eecc1e4.png)  will
    give the same result as ![](img/f5079cea-ebc3-4e26-8636-23f403cfd5e9.png) + ![](img/eb876de9-01a5-4b7f-8b67-0ec8161f244c.png).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we add ![](img/34defdb7-77b3-4f41-b8f4-1b336a81016a.png) to ![](img/4b98cad1-6b37-4b07-90bc-cfed48e4b97b.png), then
    the dotted line will go from the vector ![](img/341c8b1d-aece-41ec-93a7-c5aa1eecc1e4.png) to
    vector ![](img/041962c2-03d2-43ad-8df1-89ce6c08461d.png) as shown in the preceding
    figure.  Furthermore, in vector subtraction, we subtract the individual components
    of the vectors to create a new vector:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6161b965-e04f-4219-96bb-1547d2383e8c.png)= ![](img/400bff09-6950-4856-9178-dda2eae4243a.png) -  ![](img/d289cba8-c3bc-4135-a3ab-9bc7227d8028.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: '![](img/041962c2-03d2-43ad-8df1-89ce6c08461d.png)= ((ax - bx) , (ay - by) ,
    (az - bz ))'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
- en: Now, let's visualize the subtraction of two vectors in a graph.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Here,  ![](img/baafd86e-4698-4ba9-8552-53869a81e01a.png) = (1.0, 0.4, 0.0 )
    and  ![](img/eba72c42-6fff-4904-ae61-0a3dff1662a4.png)= (0.6, 2.0, 0.0). Therefore, the
    resultant vector,  ![](img/e5218906-5593-4155-bb71-5d0d573b9545.png)= ![](img/9cb94812-72b8-40c5-b0fb-12eb9639e4f6.png) -  ![](img/ec2af80a-391a-42d6-825b-c5e413685224.png), =
    (1.0 - 0.6, 0.4 - 2.0, 0.0 - 0.0) = (0.4, -1.6, 0.0):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f597d24-de01-4226-8ca0-aa502bb06312.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: If vectors A and B are equal, the result will be a zero vector with all three
    components as zero.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: If  ![](img/fc0f6b71-42a0-4fe6-9a3e-1cd3e8ed70b7.png)= ![](img/356fd3ab-9b48-4c24-82ce-61a857a6dad3.png),
    this means that a[x] = b[x] , a[y] = b[y] , a[z] = b[z]. If this is the case,
    then, ![](img/fb484272-bc03-417f-ab5b-58e9eba98f9e.png)= ![](img/4728f4f8-ce7e-4d20-9503-27b0ad8e2441.png) -  ![](img/73224def-1249-491f-ad09-f32f5a84dafb.png)= (0,
    0, 0).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: We can multiply a scalar by a vector. The result is a vector with each component
    of the vector being multiplied by the scalar.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if A is multiplied by a single value of s, we will have the following
    result:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83a4ffeb-5a2c-489a-92df-0bb227e997e6.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: Vector magnitude
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The magnitude of the vector is equal to the length of the vector itself. But
    how do we calculate it mathematically?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'The magnitude of a vector is given by the Pythagorean theorem, which specifies
    that, in a right-handed triangle, the square of the length of a diagonal is equal
    to the sum of the squares of the adjacent sides. Let''s take a look at the following
    right-handed triangle, *c² = x² + y²*:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 向量的大小由勾股定理给出，该定理规定，在右手三角形中，对角线长度的平方等于相邻边的平方和。让我们看看以下右手三角形，*c² = x² + y²*：
- en: '![](img/841cc4e8-7755-4a4b-af66-f282e0a387b4.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/841cc4e8-7755-4a4b-af66-f282e0a387b4.png)'
- en: This can be extended to three dimensions with *c² = x² + y² + z²*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以扩展到三维，*c² = x² + y² + z²*。
- en: Magnitudes of vectors are indicated by double vertical bars, so the magnitude
    of a vector,
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 向量的大小用双竖线表示，所以向量的大小，
- en: '![](img/6be0b0cc-8c0a-4aeb-8e23-e0568ec4947f.png) is denoted by ![](img/9e90e49e-a576-416f-9463-986d8b3cc5cb.png).
    The magnitude is always greater than or equal to zero.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/6be0b0cc-8c0a-4aeb-8e23-e0568ec4947f.png)表示为![图片](img/9e90e49e-a576-416f-9463-986d8b3cc5cb.png)。大小始终大于或等于零。'
- en: 'So, if vector A = (X, Y, Z), then the magnitude is given by the following equation:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果向量A = (X, Y, Z)，那么大小由以下方程给出：
- en: '![](img/228d2181-2e99-4e79-a366-39c23826586e.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/228d2181-2e99-4e79-a366-39c23826586e.png)'
- en: 'If ![](img/20878924-54f2-4e0b-8d4f-375b4a6681d6.png) = (3, -5, 7), then we
    get the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果![图片](img/20878924-54f2-4e0b-8d4f-375b4a6681d6.png) = (3, -5, 7)，那么我们得到以下：
- en: '![](img/26935f31-c45e-4df4-beb5-5ead26087101.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/26935f31-c45e-4df4-beb5-5ead26087101.png)'
- en: Therefore,  ![](img/d5f5d2ef-1ae8-4fb5-9035-375298c51c41.png) is 9.11 units
    long.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，![图片](img/d5f5d2ef-1ae8-4fb5-9035-375298c51c41.png)的长度为9.11单位。
- en: Unit vectors
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单位向量
- en: In some cases, we don't care about the magnitude of the vector; we just want
    to know the direction of the vector. To find this out, we want the length of the
    vector in the X, Y, and Z directions to be equal to 1\. Such vectors are called
    unit vectors or normalized vectors.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们不在乎向量的大小；我们只想知道向量的方向。为了找出这一点，我们希望向量在X、Y和Z方向上的长度等于1。这样的向量被称为单位向量或归一化向量。
- en: 'In unit vectors, the X, Y, and Z components of the vector are divided by the
    magnitude to create a vector of unit length. They are denoted by a hat on top
    of the vector name instead of an arrow. So, a unit vector of A will be denoted
    as ![](img/dc50564b-a440-479d-b8eb-5a3b18bd05dd.png), like so:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在单位向量中，向量的X、Y和Z分量被除以大小以创建一个单位长度的向量。它们用向量名称上方的帽子表示，而不是箭头。因此，向量A的单位向量将表示为![图片](img/dc50564b-a440-479d-b8eb-5a3b18bd05dd.png)，如下所示：
- en: '![](img/daed6188-72d0-433c-bffa-b594f0975b6c.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/daed6188-72d0-433c-bffa-b594f0975b6c.png)'
- en: When a vector is converted into a unit vector, it is said to be normalized.
    This means that the value is always between 0.0 and 1.0\. The original value has
    been rescaled to be in this range. Let's normalize the vector ![](img/511f231c-a556-4ee7-aab1-f5c0dbcf3baa.png)=
    (3, -5, 7).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个向量被转换为单位向量时，它被称为归一化。这意味着值始终在0.0和1.0之间。原始值已被缩放到这个范围内。让我们将向量![图片](img/511f231c-a556-4ee7-aab1-f5c0dbcf3baa.png)=
    (3, -5, 7)归一化。
- en: First, we have to calculate the magnitude of ![](img/bf8003d7-bcd0-4ec4-b375-6951969677c3.png),
    which we have already done (it's 9.11).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须计算![图片](img/bf8003d7-bcd0-4ec4-b375-6951969677c3.png)的大小，这我们已经做了（它是9.11）。
- en: 'So, the unit vector  is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，单位向量如下：
- en: '![](img/eb11fae8-5f76-49c4-bbb5-99e1e509f170.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eb11fae8-5f76-49c4-bbb5-99e1e509f170.png)'
- en: The dot product
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点积
- en: The dot product is a type of vector multiplication in which the resultant vector
    is a scalar. It is also referred to as a scalar product for the same reason. The
    scalar product of two vectors is the sum of the products of the corresponding
    components.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 点积是一种向量乘法，其中结果向量是一个标量。它也被称为标量积，原因相同。两个向量的标量积是对应分量的乘积之和。
- en: 'If you have two vectors, A = (a[x], a[y], a[z]) and B = (b[x], b[y], b[z]),
    this is given by the following equation:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有两个向量，A = (a[x], a[y], a[z]) 和 B = (b[x], b[y], b[z])，这由以下方程给出：
- en: '![](img/39934380-70d0-4e52-9201-8a748093c538.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/39934380-70d0-4e52-9201-8a748093c538.png)'
- en: 'The dot product of two vectors is also equal to the cosine of the angle between
    the vectors that have been multiplied by the magnitudes of both vectors. Note
    that the dot product is represented as a dot between the vector:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 两个向量的点积也等于乘以两个向量大小后夹角的余弦。注意点积用向量之间的点表示：
- en: '![](img/ac795e9e-2f01-4909-9dd8-5191826ca2cc.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ac795e9e-2f01-4909-9dd8-5191826ca2cc.png)'
- en: 'θ is always between 0 and π. By putting an equation of 1 and 2 together, we
    can figure out the angle between two vectors:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: θ始终在0和π之间。通过将方程1和2结合起来，我们可以找出两个向量之间的角度：
- en: '![](img/7c319066-651c-490f-9d71-5d34200fd421.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c319066-651c-490f-9d71-5d34200fd421.png)'
- en: 'Consequently we get:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此我们得到：
- en: '![](img/883e2f82-bc67-4c79-953b-42e31ff5a246.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/883e2f82-bc67-4c79-953b-42e31ff5a246.png)'
- en: 'This form has some unique geometric properties:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式具有一些独特的几何特性：
- en: If ![](img/d9e77aee-35ae-4a77-9456-8d3befb50196.png)= 0, then ![](img/821d50ac-4d69-4174-82d6-fbce7ae8541e.png) is
    perpendicular to ![](img/a9c31b6b-9b19-4fdd-9775-9cbe74271628.png), that is, cos
    90 = 0.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 ![](img/d9e77aee-35ae-4a77-9456-8d3befb50196.png)= 0，那么 ![](img/821d50ac-4d69-4174-82d6-fbce7ae8541e.png) 垂直于 ![](img/a9c31b6b-9b19-4fdd-9775-9cbe74271628.png)，即
    cos 90 = 0。
- en: If ![](img/cb663a1e-8ba7-4eeb-89ea-551bf1b18b63.png) = ![](img/3a2bb232-fd3a-41b6-8572-e1a2d268d900.png) ,
    then the two vectors are parallel to each other, that is, cos 0 = 1.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 ![](img/cb663a1e-8ba7-4eeb-89ea-551bf1b18b63.png) = ![](img/3a2bb232-fd3a-41b6-8572-e1a2d268d900.png) ，那么这两个向量是平行的，即
    cos 0 = 1。
- en: If ![](img/bb285625-eec7-47da-886b-69606c36723f.png)> 0, then the angle between
    the vectors is less than 90 degrees.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 ![](img/bb285625-eec7-47da-886b-69606c36723f.png)> 0，那么向量之间的角度小于 90 度。
- en: If ![](img/524fcaca-2c97-45f3-ad1f-c50929ac458e.png)< 0, then the angle between
    the vectors is greater than 90 degrees.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 ![](img/524fcaca-2c97-45f3-ad1f-c50929ac458e.png)< 0，那么向量之间的角度大于 90 度。
- en: Now, let's look at an example of a dot product.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一个点积的例子。
- en: If ![](img/20486fd6-d306-47bf-8394-5512d2231b56.png)= (3, -5, 7) and  ![](img/f2c9b707-1e49-4113-adf6-95c35928682c.png) =
    (2, 4 , 1), then ![](img/274f44c4-038e-47f0-a41c-26251feb4a15.png) = 9.110 and ![](img/2fae8534-ebaf-4785-b2c6-f30c784a6d73.png).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 ![](img/20486fd6-d306-47bf-8394-5512d2231b56.png)= (3, -5, 7) 和 ![](img/f2c9b707-1e49-4113-adf6-95c35928682c.png) =
    (2, 4 , 1)，那么 ![](img/274f44c4-038e-47f0-a41c-26251feb4a15.png) = 9.110 和 ![](img/2fae8534-ebaf-4785-b2c6-f30c784a6d73.png)。
- en: 'Next, we calculate like so:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们这样计算：
- en: '![](img/12ad5de1-66f3-4449-a5b8-89ad506cdfd4.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12ad5de1-66f3-4449-a5b8-89ad506cdfd4.png)'
- en: The cross product
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 叉积
- en: The c oss product is another form of vector multiplication in which the resultant
    product of the multiplication is another vector. Taking the cross product between
    ![](img/da7b1b6f-4c7e-493b-b661-d60c12afcdc2.png) and ![](img/b1027b57-1635-4312-9d74-76cf0115b7d3.png) will
    result in a third vector that is perpendicular to vectors ![](img/2a67360a-658e-4526-9ff3-7d77546eece8.png) and ![](img/f521ea0d-f08d-4e19-b341-d867fe50082a.png) .
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 叉积是向量乘法的一种形式，其中乘积的结果是另一个向量。将 ![](img/da7b1b6f-4c7e-493b-b661-d60c12afcdc2.png) 和 ![](img/b1027b57-1635-4312-9d74-76cf0115b7d3.png) 的叉积将得到一个第三向量，该向量垂直于向量 ![](img/2a67360a-658e-4526-9ff3-7d77546eece8.png) 和 ![](img/f521ea0d-f08d-4e19-b341-d867fe50082a.png) 。
- en: 'If you have two vectors,  ![](img/1fb5a9f4-3b10-4592-8eeb-827a24111d48.png) =
    (a[x], a[y], a[z]) and  ![](img/aa92a4fd-2f9e-41a2-a4f7-4528edb9bc84.png) = (b[x],
    b[y], b[z]), then ![](img/671707f6-6e01-433e-81d7-a368278356c9.png) is given as
    follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有两个向量， ![](img/1fb5a9f4-3b10-4592-8eeb-827a24111d48.png) = (a[x], a[y], a[z])
    和 ![](img/aa92a4fd-2f9e-41a2-a4f7-4528edb9bc84.png) = (b[x], b[y], b[z])，那么 ![](img/671707f6-6e01-433e-81d7-a368278356c9.png) 如下所示：
- en: '![](img/638d5253-1053-409a-91c1-228c6761e795.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/638d5253-1053-409a-91c1-228c6761e795.png)'
- en: 'The following are matrix and graphical implementations of the cross product
    between vectors:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对向量叉积的矩阵和图形实现：
- en: '![](img/199f16fe-6475-4728-9686-b5741fdcaefe.png) ![](img/fdb31d82-e37f-463b-aef8-4a384926c543.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/199f16fe-6475-4728-9686-b5741fdcaefe.png) ![](img/fdb31d82-e37f-463b-aef8-4a384926c543.png)'
- en: The direction of the resultant normal vector will obey the right-hand rule,
    where curling the fingers on your right hand (from ![](img/0f2bdafb-8c63-48e7-86fa-d27f8d18dff1.png) to ![](img/70a3b724-bf19-4392-b0df-61d7f52ae352.png)) will
    cause the thumb to point in the direction of the resultant normal vector (![](img/20ec9163-4b0e-4971-97f9-48d3a7e0f5c6.png)).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 结果法向量的方向将遵循右手定则，即用右手的手指（从 ![](img/0f2bdafb-8c63-48e7-86fa-d27f8d18dff1.png) 到 ![](img/70a3b724-bf19-4392-b0df-61d7f52ae352.png)）弯曲时，拇指将指向结果法向量的方向 (![](img/20ec9163-4b0e-4971-97f9-48d3a7e0f5c6.png))。
- en: Also, note that the order in which you multiply the vectors is important because
    if you multiply the other way around, then the resultant vector will point in
    the opposite direction.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，你乘法时向量的顺序很重要，因为如果你反过来乘，那么结果向量将指向相反的方向。
- en: The cross product is very useful when we want to find the normal of the face
    of a polygon, such as a triangle.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要找到多边形面（如三角形）的法线时，叉积非常有用。
- en: 'The following equation helps us find the cross product of vectors  ![](img/3c5a82d4-e513-4969-ad08-16a5c8233559.png)=
    (3, -5, 7) and   ![](img/749b7e8e-3a7d-4e37-82ec-924263d4bebd.png)= (2, 4 , 1):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方程帮助我们找到向量 ![](img/3c5a82d4-e513-4969-ad08-16a5c8233559.png)= (3, -5, 7) 和 ![](img/749b7e8e-3a7d-4e37-82ec-924263d4bebd.png)=
    (2, 4 , 1) 的叉积：
- en: C = A × B = (ay bz - az by, az bx - ax bz, , ax by - ay bx)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: C = A × B = (ay bz - az by, az bx - ax bz, , ax by - ay bx)
- en: = (-5 * 1 - 7*4 , 7 * 2 - 3 * 1, 3 * 4 - (-5) * 2 )
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: = (-5 * 1 - 7*4 , 7 * 2 - 3 * 1, 3 * 4 - (-5) * 2 )
- en: = (-5-28, 14 - 3, 12 + 10)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: = (-5-28, 14 - 3, 12 + 10)
- en: = (-33, 11, 22)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: = (-33, 11, 22)
- en: Matrices
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵
- en: In computer graphics, matrices are used to calculate object transforms such
    as translation, that is, movement, scaling in the X, Y, and Z axes, and rotation
    around the X, Y, and Z axes. We will also be changing the position of objects
    from one coordinate system to an other, which is known as space transforms. We
    will see how matrices work and how they help to simplify the mathematics we have
    to use.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机图形学中，矩阵用于计算对象变换，例如平移，即移动，X、Y和Z轴上的缩放，以及围绕X、Y和Z轴的旋转。我们还将改变对象从一个坐标系到另一个坐标系的位置，这被称为空间变换。我们将看到矩阵是如何工作的，以及它们如何帮助我们简化必须使用的数学。
- en: Matrices have rows and columns. A matrix with *m* number of rows and *n* number
    of columns is said to be a matrix of size *m × n*. Each element of a matrix is
    represented as indices *ij*, where *i* specifies the row number and *j* represents
    the column number.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵有行和列。一个有*m*行和*n*列的矩阵被称为*m × n*矩阵。矩阵的每个元素表示为索引*ij*，其中*i*指定行号，*j*表示列号。
- en: 'So, a matrix, M, of size 3 × 2 is represented as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个大小为3 × 2的矩阵M表示如下：
- en: '![](img/f1a7ed5a-9ef6-475f-b376-c4d245fd7d73.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1a7ed5a-9ef6-475f-b376-c4d245fd7d73.png)'
- en: Here, matrix M has three rows and two columns and each element is represented
    as m11, m12, and so on until m32, which is the size of the matrix.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，矩阵M有三行两列，每个元素表示为m11，m12，依此类推，直到m32，这是矩阵的大小。
- en: 'In 3D graphics programming, we mostly deal with 4 × 4 matrices. Let''s look
    at another matrix that''s 4 x 4 in size:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D图形编程中，我们主要处理4 × 4矩阵。让我们看看另一个大小为4 x 4的矩阵：
- en: '![](img/a86f16b4-e714-4ee2-86ba-b7047c8cc6b4.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a86f16b4-e714-4ee2-86ba-b7047c8cc6b4.png)'
- en: 'Matrix A can be presented as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵A可以表示如下：
- en: '![](img/e618f69a-a18c-4d52-873e-447fc3567f1c.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e618f69a-a18c-4d52-873e-447fc3567f1c.png)'
- en: Here, the elements are A[11] = 3, A[32] = 1, and A[44] = 1 and the dimension
    of the matrix is 4 × 4.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，元素是A[11] = 3, A[32] = 1, 和 A[44] = 1，矩阵的维度是4 × 4。
- en: 'We can also have a single-dimension matrix with a vector shown as follows.
    Here, B is called the row vector and C is called a column vector:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以有一个一维矩阵，其中向量表示如下。在这里，B被称为行向量，C被称为列向量：
- en: '![](img/3e0e45e4-a37f-45c2-8fda-43e0a918ba04.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e0e45e4-a37f-45c2-8fda-43e0a918ba04.png)'
- en: Two matrices are equal if the number of rows and columns are the same and if
    the corresponding elements are of the same value.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果行数和列数相同，并且对应元素具有相同的值，则两个矩阵相等。
- en: Two matrices can be added together if they have the same number of rows and
    columns. We add each element of the corresponding location to both matrices to
    get a third matrix that has the same dimensions as the added matrices.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个矩阵具有相同的行数和列数，则可以将它们相加。我们将对应位置的每个元素加到两个矩阵上，以得到一个与相加矩阵具有相同维度的第三个矩阵。
- en: Matrix addition and subtraction
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵加法和减法
- en: 'Consider the following two matrices, A and B. Both of these are 3 x 3 in size:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下两个矩阵，A和B。这两个矩阵的大小都是3 x 3：
- en: '![](img/9d0d2993-e54b-4811-9527-0645a5f98517.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d0d2993-e54b-4811-9527-0645a5f98517.png)'
- en: 'Here, if C = A + B, then this can be represented like so:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，如果C = A + B，则可以表示如下：
- en: '![](img/4ac3dcf8-3ea9-4e29-87a9-c2d84aaa7cc1.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ac3dcf8-3ea9-4e29-87a9-c2d84aaa7cc1.png)'
- en: Matrix subtraction works in the same way when each element of the matrix is
    subtracted from the corresponding element of the other matrix.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当矩阵的每个元素从另一个矩阵的对应元素中减去时，矩阵减法以相同的方式工作。
- en: Matrix multiplication
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵乘法
- en: Let's look at how a scalar value can be multiplied to a matrix. We can do this
    by multiplying each element of the matrix by the same scalar value. This will
    give us a new matrix that has the same dimensions as the original matrix.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个标量值如何乘以一个矩阵。我们可以通过将矩阵的每个元素乘以相同的标量值来实现这一点。这将给我们一个新的矩阵，其维度与原始矩阵相同。
- en: 'Again, consider a Matrix, A, that''s been multiplied by some scalars. Here,
    s×A, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，考虑一个矩阵A，它已经被一些标量乘过。这里，s×A，如下所示：
- en: '![](img/01a79209-4c6f-43df-a073-e0d25e0465f4.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01a79209-4c6f-43df-a073-e0d25e0465f4.png)'
- en: 'Two A and B matrices can be multiplied together, provided that the number of
    columns in A is equal to the number of rows in B. So, if matrix A has the dimension
    a × b and B has the dimension X × Y, then for A to be multiplied by B, b should
    be equal to X:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 两个A和B矩阵可以相乘，前提是A的列数等于B的行数。所以，如果矩阵A的维度是a × b，B的维度是X × Y，那么为了A能够乘以B，b应该等于X：
- en: 'The resultant size of the matrix will be a × Y. Two matrices can be multiplied
    together like so:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的结果大小将是a × Y。两个矩阵可以像这样相乘：
- en: '![](img/e6838ac1-f95d-4299-a2d4-b314e80bdd1f.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e6838ac1-f95d-4299-a2d4-b314e80bdd1f.png)'
- en: 'Here, the size of A is 3 × 2 and the size of B is 2 × 3, which means that the
    resultant matrix, C, will be 3 × 3 in size:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，矩阵A的大小是3 × 2，矩阵B的大小是2 × 3，这意味着结果矩阵C的大小将是3 × 3：
- en: '![](img/dd17ad54-a2df-42aa-a29f-93f54b0083e0.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dd17ad54-a2df-42aa-a29f-93f54b0083e0.png)'
- en: However, keep in mind that matrix multiplication is not commutative, meaning
    that A×B ≠ B×A. In fact, in some cases, it isn't even possible to multiply the
    other way around, just like it isn't in this case. Here, we can't even multiply
    B×A since the number of columns of B is not equal to the number of rows of A.
    In other words, the internal dimensions of the matrices should match so that the
    dimensions are in the form of [a![](img/704dcf14-ac4f-4ac5-88d6-6e4892b833c2.png)t] and [t![](img/ce4238d9-5e4c-40a0-93f7-041fb1b9038c.png)b].
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，矩阵乘法不是交换律的，这意味着A×B ≠ B×A。实际上，在某些情况下，甚至无法以另一种方式相乘，就像在这个例子中一样。在这里，我们甚至不能乘以B×A，因为B的列数不等于A的行数。换句话说，矩阵的内部维度应该匹配，以便维度形式为 [a![](img/704dcf14-ac4f-4ac5-88d6-6e4892b833c2.png)t] 和 [t![](img/ce4238d9-5e4c-40a0-93f7-041fb1b9038c.png)b]。
- en: 'You can also multiply a vector matrix with a regular matrix, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将向量矩阵与普通矩阵相乘，如下所示：
- en: '![](img/82ccb486-b8b8-43a1-bfc5-f603a8e8f641.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/82ccb486-b8b8-43a1-bfc5-f603a8e8f641.png)'
- en: 'The result will be a one-dimensional vector of size 3 × 1, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是一个3 × 1大小的单维向量，如下所示：
- en: '![](img/d892153f-cd44-4ae0-bf49-8cf46e8dd5fb.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d892153f-cd44-4ae0-bf49-8cf46e8dd5fb.png)'
- en: Note that when multiplying the matrix with the vector-matrix, the vector is
    to the right of the matrix. This is done so that the matrix of size 3 × 3 is able
    to multiply the vector-matrix of size 3 × 1.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当用矩阵乘以向量矩阵时，向量位于矩阵的右侧。这样做是为了使3 × 3大小的矩阵能够乘以3 × 1大小的向量矩阵。
- en: When we have a matrix with just one column, this is called a column-major matrix.
    So, matrix C is a column-major matrix, just like matrix V.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个只有一列的矩阵时，这被称为列主序矩阵。因此，矩阵C是一个列主序矩阵，就像矩阵V一样。
- en: 'If the same vector, V, was expressed with just a row, it would be called a
    row-major matrix. This can be represented like so:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用一行来表示相同的向量V，它将被称为行主序矩阵。这可以表示如下：
- en: '![](img/a3184621-c6d0-4e20-8a54-8cb49544296d.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a3184621-c6d0-4e20-8a54-8cb49544296d.png)'
- en: So, how would we multiply a matrix, A, of size 3 × 3 with a row-major matrix,
    V, of size 1 × 3 if the internal dimensions don't match?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果内部维度不匹配，我们如何将一个大小为3 × 3的矩阵A与一个大小为1 × 3的行主序矩阵V相乘呢？
- en: The simple solution here is, instead of multiplying matrix A × V, we multiply
    V × A. This way, the internal dimensions of the vector-matrix and the regular
    matrix will match 1 × 3 and 3 × 3, and the resultant matrix will also be a row-major
    matrix.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的简单解决方案是，而不是乘以矩阵A × V，我们乘以V × A。这样，向量矩阵和普通矩阵的内部维度将匹配1 × 3和3 × 3，结果矩阵也将是一个行主序矩阵。
- en: Throughout this book, we will be using the column-major matrix.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将使用列主序矩阵。
- en: If we were going to use 4 × 4 matrices, for example, how would we multiply a
    4 × 4 matrix using the coordinates of x, y, and z?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要使用4 × 4矩阵，例如，我们如何使用x、y和z的坐标来乘以4 × 4矩阵？
- en: 'When multiplying a 4 × 4 matrix with points X, Y, and Z, we add one more row
    to the column-major matrix and set the value of it to 1\. The new point will be
    (X, Y, Z, 1), which is called a homogeneous point. This makes it easy to multiply
    a 4 × 4 matrix with a 4 × 1 vector:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当用X、Y和Z点乘以4 × 4矩阵时，我们在列主序矩阵中添加一行，并将其值设为1。新的点将是(X, Y, Z, 1)，这被称为齐次点。这使得用4 × 4矩阵乘以4
    × 1向量变得容易：
- en: '![](img/c19553c6-60de-4b74-9bc7-ad63331666fe.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c19553c6-60de-4b74-9bc7-ad63331666fe.png)'
- en: 'Matrix multiplication can be extrapolated to the multiplication of one 4 ×
    4 matrix with another 4 × 4 matrix. Let''s look at how we can do this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵乘法可以推广到乘以另一个4 × 4矩阵。让我们看看我们如何做到这一点：
- en: '![](img/b4576903-6bad-4c0e-ae57-ee41d4735e70.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b4576903-6bad-4c0e-ae57-ee41d4735e70.png)'
- en: '![](img/97b1de9b-b9f2-474e-aa2d-3acab4df20c0.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97b1de9b-b9f2-474e-aa2d-3acab4df20c0.png)'
- en: Identity matrix
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单位矩阵
- en: An identity matrix is a special kind of matrix in which the number of rows is
    equal to the number of columns. This is known as a square matrix. In an identity
    matrix, the elements in the diagonal of the matrix are all 1, while the rest of
    the elements are 0.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 单位矩阵是一种特殊的矩阵，其中行数等于列数。这被称为方阵。在单位矩阵中，矩阵对角线上的元素都是 1，而其余元素都是 0。
- en: 'Here is an example of a 4 × 4 identity matrix:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个 4 × 4 单位矩阵的例子：
- en: '![](img/1b1f9d8f-0a4b-4439-9c65-3dbf5bf11cc8.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b1f9d8f-0a4b-4439-9c65-3dbf5bf11cc8.png)'
- en: Identity matrices work similarly to how we get a result when we multiply any
    number with 1 and get the same number. Similarly, when we multiply any matrix
    with an identity matrix, we get the same matrix.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 单位矩阵的工作方式类似于我们乘以任何数与 1 相乘得到相同的数。同样，当我们乘以任何矩阵与单位矩阵时，我们得到相同的矩阵。
- en: 'For example, A×I = A, where A is a 4 ×4 matrix and I is an identity matrix
    of the same size. Let''s look at an example of this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，A×I = A，其中 A 是一个 4 × 4 矩阵，I 是相同大小的单位矩阵。让我们来看一个这个的例子：
- en: '![](img/2d2257c9-ad98-4e5d-abe9-23183926bf08.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2d2257c9-ad98-4e5d-abe9-23183926bf08.png)'
- en: Matrix transpose
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵转置
- en: 'A matrix transpose occurs when the rows and columns are interchanged with each
    other. So, the transpose of an m X n matrix is n X m. The transpose of any matrix,
    M, is written as M^T. The transpose of a matrix is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵转置发生在行和列相互交换时。所以，m X n 矩阵的转置是 n X m。任何矩阵的转置写作 M^T。矩阵的转置如下：
- en: '![](img/8273987f-a36a-46c0-8005-b0fa07a0cc18.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8273987f-a36a-46c0-8005-b0fa07a0cc18.png)'
- en: Observe how the elements in the diagonal of the matrix remain in the same place
    but all the elements around the diagonal have been swapped.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 观察矩阵对角线上的元素保持不变，但所有对角线周围的元素都被交换了。
- en: In matrices, this diagonal of the matrix, which runs from the top left to the
    bottom right, is called the main diagonal.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在矩阵中，这个从左上角到右下角的对角线被称为主对角线。
- en: Obviously, if you transpose a transposed matrix, you get the original matrix,
    so (A^T)^T = A.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果你对转置矩阵再次进行转置，你会得到原始矩阵，所以 (A^T)^T = A。
- en: Matrix inverse
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵逆
- en: The inverse of any matrix is where any matrix, when multiplied by its inverse,
    will result in an identity matrix. For matrix M, the inverse of the matrix is
    denoted as M^(-1).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 任何矩阵的逆是任何矩阵乘以其逆矩阵将得到单位矩阵的情况。对于矩阵 M，矩阵的逆表示为 M^(-1)。
- en: The inverse is very useful in graphics programming when we want to undo the
    multiplication of a matrix.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 逆矩阵在图形编程中非常有用，当我们想要撤销矩阵的乘法时。
- en: 'For example, Matrix M is equal to A × B × C × D, where A, B, C and D are also
    matrices. Now, let''s say we want to know what A× B × C is instead of multiplying
    the three matrices, which is a two-step operation: first, you will multiply A
    with B and then multiply the resulting matrix with C. You can multiply M with
    D^(-1) as that will yield the same result:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，矩阵 M 等于 A × B × C × D，其中 A、B、C 和 D 也是矩阵。现在，假设我们想知道 A× B × C 的结果，而不是将三个矩阵相乘，这是一个两步操作：首先，你将
    A 与 B 相乘，然后将得到的矩阵与 C 相乘。你可以将 M 与 D^(-1) 相乘，这将得到相同的结果：
- en: '![](img/62bbe4bc-41a7-491b-9648-3e2a4ffe67cf.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62bbe4bc-41a7-491b-9648-3e2a4ffe67cf.png)'
- en: GLM OpenGL mathematics
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GLM OpenGL 数学
- en: 'To carry out the mathematical operations we''ve just looked at in OpenGL and
    Vulkan projects, we will be using a header-only C++ mathematics library called
    GLM. This was initially developed to be used with OpenGL, but it can be used with
    Vulkan as well:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 OpenGL 和 Vulkan 项目中执行我们刚才看到的数学运算，我们将使用一个仅包含头文件的 C++ 数学库，称为 GLM。这最初是为了与 OpenGL
    一起使用而开发的，但它也可以与 Vulkan 一起使用：
- en: '![](img/564a8c99-efc2-4116-b27b-f892e1a0b4c3.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/564a8c99-efc2-4116-b27b-f892e1a0b4c3.png)'
- en: The latest version of GLM can be downloaded from [https://glm.g-truc.net/0.9.9/index.html](https://glm.g-truc.net/0.9.9/index.html).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最新版本的 GLM 可以从 [https://glm.g-truc.net/0.9.9/index.html](https://glm.g-truc.net/0.9.9/index.html)
    下载。
- en: 'Apart from being able to create points and perform vector addition and subtraction,
    GLM can also define matrices, carry out matrix transforms, generate random numbers,
    and generate noise. The following are a few examples of how these functions can
    be carried out:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够创建点和执行向量加法和减法之外，GLM 还可以定义矩阵，执行矩阵变换，生成随机数，以及生成噪声。以下是一些这些函数如何执行的例子：
- en: 'To define 2D and 3D points, we will need to include `#include <glm/glm.hpp>`,
    which uses the `glm` namespace. To define a 2D point in space, we use the following
    code:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要定义 2D 和 3D 点，我们需要包含 `#include <glm/glm.hpp>`，它使用 `glm` 命名空间。要定义空间中的 2D 点，我们使用以下代码：
- en: '[PRE0]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To define a 3D point, we use the following code:'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要定义 3D 点，我们使用以下代码：
- en: '[PRE1]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A 4 x 4 matrix can also be created using `glm`, as shown in the following code.
    A 4 x 4 matrix is of the `mat4` type and can be created like this:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `glm` 也可以创建一个 4x4 矩阵，如下面的代码所示。一个 4x4 矩阵是 `mat4` 类型，可以创建如下：
- en: '[PRE2]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For translation and rotation, you need to include the necessary GLM extensions,
    as shown in the following code:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于平移和旋转，您需要包含必要的 GLM 扩展，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To translate the object so that it''s (`3.0`, `4.0`, `8.0`) from its current
    position, do the following:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将对象平移到其当前位置的 (`3.0`, `4.0`, `8.0`)，请执行以下操作：
- en: '[PRE4]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can also scale the value so that it''s double its size in the *x*, *y*,
    and *z* directions:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以将值缩放，使其在 *x*、*y* 和 *z* 方向上是原来大小的两倍：
- en: '[PRE5]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code rotates the object by `45,0f` degrees along the *x* axis,
    `25.0f` degrees along the *y* axis, and `10.0f` degrees along the *z *axis.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码通过 *x* 轴旋转对象 `45,0f` 度，通过 *y* 轴旋转 `25.0f` 度，通过 *z* 轴旋转 `10.0f` 度。
- en: Note that we use `glm::radians()` here. This `glm` function converts degrees
    into radians. More GLM functions will be introduced throughout this chapter.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里使用 `glm::radians()`。这个 `glm` 函数将度数转换为弧度。本章将介绍更多的 GLM 函数。
- en: OpenGL data types
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenGL 数据类型
- en: OpenGL also has its own data types. These are portable across platforms.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL 也有它自己的数据类型。这些类型可以在不同平台上移植。
- en: 'OpenGL data types are prefixed with GL, followed by the data type. Consequently,
    a GL equivalent to an `int` variable is GLint, and so on. The following table
    shows a list of GL data types (the list can be viewed at [https://www.khronos.org/opengl/wiki/OpenGL_Type](https://www.khronos.org/opengl/wiki/OpenGL_Type)):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL 数据类型以 GL 前缀开头，后跟数据类型。因此，与 `int` 变量等效的 GL 类型是 GLint，依此类推。以下表格显示了一个 GL
    数据类型的列表（列表可查看于 [https://www.khronos.org/opengl/wiki/OpenGL_Type](https://www.khronos.org/opengl/wiki/OpenGL_Type)）：
- en: '![](img/2ee7f1f6-fd88-4c9b-ae22-6d5cc8091ef6.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ee7f1f6-fd88-4c9b-ae22-6d5cc8091ef6.png)'
- en: Space transformations
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空间变换
- en: 'The major job of 3D graphics is to simulate a 3D world and project that world
    into a 2D location, which is the viewport window. 3D or 2D objects that we want
    to render are nothing but collections of vertices. These vertices are then made
    into a collection of triangles to form the shape of the object sphere:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 3D 图形的主要任务是模拟一个 3D 世界，并将该世界投影到一个 2D 位置，即视口窗口。我们想要渲染的 3D 或 2D 对象不过是顶点的集合。然后这些顶点被组合成三角形的集合，以形成对象的球形：
- en: '![](img/cdd49492-69b0-4cca-9a57-4a1428d38a1b.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cdd49492-69b0-4cca-9a57-4a1428d38a1b.png)'
- en: The screenshot on the left shows the vertices that were passed in, whereas the
    screenshot on the right shows that the vertices were used to create triangles.
    Each triangle forms a small piece of the surface for the final shape of the object.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的截图显示了传入的顶点，而右侧的截图显示了顶点被用来创建三角形。每个三角形都形成了最终对象形状表面的一小部分。
- en: Local/object space
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地/对象空间
- en: 'When setting the vertices for any object, we start at the origin of a coordinate
    system. These vertices or points are placed and then connected to create the shape
    of the object, such as a triangle. This coordinate system that a model is created
    around is called the object space, model space, or local space:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置任何对象的顶点时，我们从坐标系的起点开始。这些顶点或点被放置，然后连接起来以创建对象的形状，例如三角形。围绕模型创建的这个坐标系被称为对象空间、模型空间或本地空间：
- en: '![](img/4ac3a96b-8985-4734-bf4c-10ab0d6bf76b.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ac3a96b-8985-4734-bf4c-10ab0d6bf76b.png)'
- en: World space
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 世界空间
- en: Now that we have specified the shape of the model, we want to place it in a
    scene, along with a couple of other shapes, such as a sphere and a cube. The cube
    and sphere shapes are also created using their own model space. When placing these
    objects into a 3D scene, we do so with respect to the coordinate system that the
    3D objects will be placed in. This new coordinate system is called the world coordinate
    system, or world space.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经指定了模型的形状，我们想要将它放置在一个场景中，以及一些其他形状，例如球体和立方体。立方体和球体形状也是使用它们自己的模型空间创建的。当我们将这些对象放置到
    3D 场景中时，我们是以 3D 对象将被放置的坐标系为基准来进行的。这个新的坐标系被称为世界坐标系，或世界空间。
- en: Moving the object from the object space to the world space is done through matrix
    transforms. The local position of the object is multiplied by the world space
    matrix. Consequently, each vertex is multiplied by the world space matrix to transform
    its scale, rotation, and position from the local space to the world space.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象从对象空间移动到世界空间是通过矩阵变换完成的。对象的局部位置乘以世界空间矩阵。因此，每个顶点都乘以世界空间矩阵，以将其缩放、旋转和位置从局部空间转换到世界空间。
- en: 'The world space matrix is a product of scale, rotation, and translation matrices,
    as shown in the following formula:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 世界空间矩阵是缩放、旋转和平移矩阵的乘积，如下面的公式所示：
- en: '*World Matrix = W = T × R ×S*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*世界矩阵 = W = T × R × S*'
- en: 'S, R, and T are the scale, rotation, and translation of the local space relative
    to the world space, respectively. Let''s take a look at each of them individually:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: S、R和T分别是相对于世界空间局部空间的缩放、旋转和平移。让我们分别看看它们：
- en: 'The scale matrix for a 3D space is a 4 x 4 matrix whose diagonal represents
    the scale in the *x*, *y*, and *z* directions, as follows:'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D空间的缩放矩阵是一个4x4矩阵，其对角线表示*x*、*y*和*z*方向上的缩放，如下所示：
- en: '![](img/d37b3b68-5f94-459f-b441-b5a6919bcb07.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片4](img/d37b3b68-5f94-459f-b441-b5a6919bcb07.png)'
- en: 'The rotation matrix can take three forms, depending on which axis you are rotating
    the object on. *Rx*, *Ry*, and *Rz* are the matrices we use for rotation along
    each axis, as shown in the following matrix:'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转矩阵可以采取三种形式，具体取决于你正在旋转对象的哪个轴。*Rx*、*Ry*和*Rz*是我们用于沿每个轴旋转的矩阵，如下面的矩阵所示：
- en: '![](img/57fc346b-4394-4ef6-9e89-4860ef7d1fd3.png)![](img/2499f72f-7177-4a8f-ac49-b079846dc449.png)![](img/f47b6148-236c-4034-9c0a-a83a707ab072.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/57fc346b-4394-4ef6-9e89-4860ef7d1fd3.png)![图片2](img/2499f72f-7177-4a8f-ac49-b079846dc449.png)![图片3](img/f47b6148-236c-4034-9c0a-a83a707ab072.png)'
- en: 'The translation matrix is an identity matrix where the last column represents
    the translation in the *x*, *y*, and *z* directions:'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平移矩阵是一个单位矩阵，其中最后一列表示在*x*、*y*和*z*方向上的平移：
- en: '![](img/a36a7f29-dedf-44da-8d53-db1ab0cfea6f.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片6](img/a36a7f29-dedf-44da-8d53-db1ab0cfea6f.png)'
- en: 'Now, we can get the world position by multiplying the local position of the
    objects with the world matrix, as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过将对象的局部位置与世界矩阵相乘来获取世界位置，如下所示：
- en: Position[World] = Matrix[World] X Position[local]
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 位置[世界] = 矩阵[世界] × 位置[局部]
- en: View space
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图空间
- en: For us to view the whole scene, we will need a camera. This camera will also
    decide which objects will be visible to us and which objects won't be rendered
    to the screen.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看整个场景，我们需要一个相机。这个相机还将决定哪些对象对我们是可见的，哪些对象不会被渲染到屏幕上。
- en: 'Consequently, we can place a virtual camera into the scene at a certain world
    location, as shown in the following diagram:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以在场景中放置一个虚拟相机，位于某个世界位置，如下面的图所示：
- en: '![](img/3c0e36de-a1eb-4fad-86c6-3c64682d14a4.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图片5](img/3c0e36de-a1eb-4fad-86c6-3c64682d14a4.png)'
- en: The objects in the scene are then transformed from the world space into a new
    coordinate system that's present at the location of the camera. This new coordinate
    system, which is at the location of the camera, is called the view space, camera
    space, or eye space. The *x *axis is red, the *y *axis is green, and the positive
    *z *axis is blue.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 场景中的对象随后从世界空间转换到一个新的坐标系，该坐标系位于相机位置。这个位于相机位置的新坐标系被称为视图空间、相机空间或视点空间。*x*轴是红色，*y*轴是绿色，正*z*轴是蓝色。
- en: To transform the points from the world space to the camera space, we have to
    translate them using the negative of the virtual camera location and rotate them
    using the negative of the camera orientation.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要将点从世界空间转换到相机空间，我们必须使用虚拟相机位置的负值来平移它们，并使用相机朝向的负值来旋转它们。
- en: 'However, there is an easier way to create the view matrix using GLM. We have
    to provide three variables to define the camera position, camera target position,
    and camera up vector, respectively:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用GLM创建视图矩阵有一个更简单的方法。我们必须提供三个变量来分别定义相机位置、相机目标位置和相机向上向量：
- en: '[PRE6]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can use these variables to create a view matrix by calling the `lookAt`
    function and passing the camera position, the look at position, and up vector,
    as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用`lookAt`函数并传递相机位置、观察位置和向上向量来使用这些变量创建视图矩阵，如下所示：
- en: '[PRE7]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once we have the view matrix, the local positions can be multiplied by the
    world and the view matrix to get the position in the view space, as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了视图矩阵，局部位置可以通过乘以世界矩阵和视图矩阵来得到视图空间中的位置，如下所示：
- en: Position[view] = View[matrix] × World[matrix] × Position[local]
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 位置[视图] = 视图[矩阵] × 世界[矩阵] × 位置[局部]
- en: Projection space
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 投影空间
- en: The next task is to project the 3D objects that can be viewed by the camera
    onto the 2D plane. Projection needs to be done in such a way that the furthest
    object appears smaller and the objects that are closer appear bigger. Basically,
    when viewing an object, the points need to converge at a vanishing point.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个任务是将在相机中可见的3D对象投影到2D平面上。投影需要以这种方式进行，使得最远的对象看起来更小，而较近的对象看起来更大。基本上，在观察一个对象时，点需要汇聚到一个消失点上。
- en: In the following screenshot, the image on the right shows a cube being rendered.
    Note how the lines on the longer sides are actually parallel.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，右边的图像显示了一个正在渲染的立方体。注意长边上的线条实际上是平行的。
- en: 'However, when the same box is viewed from the camera, the same side lines converge,
    and when these lines are extended, they will converge at a point behind the box:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当从相机观察同一个盒子时，相同的侧面线会汇聚，并且当这些线被延伸时，它们会在盒子后面的一个点上汇聚：
- en: '![](img/e549a806-59e4-4d19-858c-345497be1435.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e549a806-59e4-4d19-858c-345497be1435.png)'
- en: Now, we will introduce one more matrix, called the projection matrix, which
    allows objects to be rendered with perspective projection. The vertices of the
    objects will be transformed using what is called a projection matrix to perform
    the perspective projection transformation.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将介绍另一个矩阵，称为投影矩阵，它允许使用透视投影渲染对象。对象的顶点将使用所谓的投影矩阵进行变换，以执行透视投影变换。
- en: 'In the projection matrix, we define a projection volume called the frustum.
    All the objects inside the frustum will be projected onto the 2D display. The
    objects outside the projection plane will not be rendered:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在投影矩阵中，我们定义了一个称为视锥体的投影体积。视锥体内部的所有对象将被投影到2D显示上。投影平面之外的对象将不会被渲染：
- en: '![](img/d29e913b-c2d3-46df-b413-9de5bc628a3a.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d29e913b-c2d3-46df-b413-9de5bc628a3a.png)'
- en: 'The projection matrix is created as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 投影矩阵的创建如下：
- en: '![](img/e03b54bb-80f1-4690-87aa-c2fef3a73a77.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e03b54bb-80f1-4690-87aa-c2fef3a73a77.png)'
- en: '*q = 1/tan(FieldOfView/2)*'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*q = 1/tan(FieldOfView/2)*'
- en: '*A = q/Aspect Ratio*'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*A = q/Aspect Ratio*'
- en: '*B = (zNear + zFar)/(zNear - zFar)*'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*B = (zNear + zFar)/(zNear - zFar)*'
- en: '*C = 2 *(zNear * zFar)/(zNear - zFar)*'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*C = 2 *(zNear * zFar)/(zNear - zFar)*'
- en: The aspect ratio is the width of the projection plane divided by the height
    of the projection plane. *zNear* is the distance from the camera to the near plane.
    *zFar* is the distance from the camera to the far plane. The **field of view**
    (**FOV**) is the angle between the top and bottom planes of the view frustum.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 宽高比是投影平面的宽度除以投影平面的高度。`zNear` 是从相机到近平面的距离。`zFar` 是从相机到远平面的距离。**视场角**（**FOV**）是视图视锥体上下平面之间的角度。
- en: 'In GLM, there is a function we can use to create the perspective projection
    matrix, as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在GLM中，有一个我们可以用来创建透视投影矩阵的函数，如下所示：
- en: '[PRE8]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that `nearPlane` always needs to be greater than `0.0f` so that we can
    create the start of the frustum in front of the camera.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`nearPlane` 总是必须大于 `0.0f`，这样我们才能在相机前方创建视锥体的起始部分。
- en: 'The `glm::perspective` function takes four parameters:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`glm::perspective` 函数接受四个参数：'
- en: The `FOV`
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FOV**'
- en: The aspect ratio
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宽高比
- en: The distance to the near plane
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到近平面的距离
- en: The distance to the far plane
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到远平面的距离
- en: 'So, after obtaining the projection matrix, we can finally perform a perspective
    projection transform on our view-transformed points to project the vertices onto
    the screen:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在获得投影矩阵后，我们最终可以对我们的视图变换点执行透视投影变换，将顶点投影到屏幕上：
- en: Position[final] = Projection[matrix] × View[matrix] × World[matrix] × Position[local]
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Position[final] = Projection[matrix] × View[matrix] × World[matrix] × Position[local]
- en: Now that we understand this in theory, let's look at how we can actually implement
    this.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们从理论上理解了这一点，让我们看看我们如何实际实现它。
- en: Screen space
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 屏幕空间
- en: After multiplying the local position by the model, view, and projection matrix,
    OpenGL will transform the scene into screen space.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在将局部位置乘以模型、视图和投影矩阵之后，OpenGL会将场景转换到屏幕空间。
- en: 'If the screen size of your application has a resolution of 1,280 x 720, then
    it will project the scene onto the screen like so; this is what can be seen by
    the camera in the view-space heading:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序的屏幕大小分辨率为1,280 x 720，那么它将像这样将场景投影到屏幕上；这是相机在视图空间中的观察结果：
- en: '![](img/9c1e332d-5f27-4ab0-892f-474f4fdbfd81.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9c1e332d-5f27-4ab0-892f-474f4fdbfd81.png)'
- en: For this example, the width of the window will be 1,280 pixels and the height
    of the window will be 720 pixels.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，窗口的宽度将是1,280像素，窗口的高度将是720像素。
- en: Render pipeline
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染管线
- en: 'As I mentioned earlier, we have to convert 3D objects that are made up of vertices
    and textures and represent them on a 2D screen as pixels on the screen. This is
    done with what is called a render pipeline. The following diagram explains the
    steps involved:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所述，我们必须将由顶点和纹理组成的3D对象转换为2D屏幕上的像素，以便在屏幕上表示。这是通过所谓的渲染管线来完成的。以下图表解释了涉及的步骤：
- en: '![](img/e540fba9-fd41-41eb-9526-6d433e8ff8a1.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图表](img/e540fba9-fd41-41eb-9526-6d433e8ff8a1.png)'
- en: A pipeline is simply a series of steps that are carried out one after the other
    to achieve a certain objective. The stages that are highlighted in the orange
    boxes (or lightly shaded boxes, if you're reading a black and white copy of this
    book) in the preceding diagram are fixed, meaning that you cannot modify how the
    data in the stages is processed. The stages in the blue or darker boxes are programmable
    stages, meaning that you can write special programs to modify the output. The
    preceding diagram shows a basic pipeline, which includes the minimum stages we
    need to complete to render objects. There are other stages, such as Geometry,
    Tessellation, and Compute, which are all optional stages. However, these will
    not be discussed in this book since we are only introducing graphics programming.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 管道简单来说是一系列依次执行以实现特定目标的步骤。在前面的图表中，用橙色框（或如果你阅读的是黑白版本的这本书，则是浅色阴影框）突出显示的阶段是固定的，这意味着你不能修改这些阶段中数据的处理方式。蓝色或更深的框中的阶段是可编程阶段，这意味着你可以编写特殊的程序来修改输出。前面的图表显示了一个基本的管道，它包括我们完成渲染对象所需的最小阶段。还有一些其他阶段，如几何、细分和计算，这些都是可选阶段。然而，由于我们只介绍图形编程，这些内容将不会在本书中讨论。
- en: The graphics pipeline itself is common for both OpenGL and Vulkan. However,
    their implementation is different, but we will see this in the upcoming chapters.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图形管线本身对OpenGL和Vulkan都是通用的。然而，它们的实现方式不同，但我们将会在接下来的章节中看到这一点。
- en: The render pipeline is used to render 2D or 3D objects onto a TV or monitor.
    Let's look at each of the stages in the graphics pipeline in detail.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染管线用于将2D或3D对象渲染到电视或显示器上。让我们详细查看图形管线中的每个阶段。
- en: Vertex specification
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶点规范
- en: When we want to render an object to the screen, we set information regarding
    that object. The information that we will need to set is very basic, that is,
    the points or vertices that will make up the geometry. We will be creating the
    object by creating an array of vertices. This will be used to create a number
    of triangles that will make up the geometry we want to render. These vertices
    need to be sent to the graphics pipeline.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要将对象渲染到屏幕上时，我们设置有关该对象的信息。我们需要设置的信息非常基本，即构成几何形状的点或顶点。我们将通过创建顶点数组来创建对象。这将用于创建构成我们想要渲染的几何形状的多个三角形。这些顶点需要被发送到图形管线。
- en: To send information to the pipeline in OpenGL, for example, we use **vertex
    array objects** (**VAO**) and **vertex buffer objects** (**VBO**).VAOs are used
    to define what data each vertex has; VBOs have the actual vertex data.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要向OpenGL中的管道发送信息，我们使用**顶点数组对象**（**VAO**）和**顶点缓冲区对象**（**VBO**）。VAO用于定义每个顶点具有哪些数据；VBO包含实际的顶点数据。
- en: Vertex data can have a series of attributes. A vertex could have property attributes,
    such as position, color, normal, and so on. Obviously, one of the main attributes
    that any vertex needs to have is the position information. Apart from the position,
    we will also look at other types of information that can be passed in, such as
    the color of each vertex. We will look at a few more attributes in future chapters
    in [Section 3](e10cd758-82e9-4314-96d2-f3b93f90aca4.xhtml), *Modern OpenGL 3D
    Game Development,* when we cover rendering primitives using OpenGL.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点数据可以有一系列属性。一个顶点可以具有属性属性，如位置、颜色、法线等。显然，任何顶点都需要的主要属性之一是位置信息。除了位置之外，我们还将查看可以传递的其他类型的信息，例如每个顶点的颜色。我们将在未来的章节中查看更多属性，在[第3节](e10cd758-82e9-4314-96d2-f3b93f90aca4.xhtml)，*现代OpenGL
    3D游戏开发*中，当我们介绍使用OpenGL渲染原语时。
- en: 'Let''s say that we have an array of three points. Let''s look at how we would
    create the `VAO` and the `VBO`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个由三个点组成的数组。让我们看看我们如何创建`VAO`和`VBO`：
- en: '[PRE9]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'So, let''s begin:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们开始吧：
- en: 'First, we generate a vertex array object of the Glint type. OpenGL returns
    a handle to the actual object for future reference, as follows:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们生成一个Glint类型的顶点数组对象。OpenGL返回一个实际对象的句柄，以便将来引用，如下所示：
- en: '[PRE10]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we generate a vertex buffer object, as follows:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们生成一个顶点缓冲区对象，如下所示：
- en: '[PRE11]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we specify the type of buffer object. Here, it is of the `GL_ARRAY_BUFFER` type,
    meaning that this is an array buffer:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们指定缓冲区对象类型。在这里，它是`GL_ARRAY_BUFFER`类型，这意味着这是一个数组缓冲区：
- en: '[PRE12]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we bind the data to the buffer, as follows:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们按照以下方式将数据绑定到缓冲区：
- en: '[PRE13]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first parameter is a type of data buffer, which is of the `GL_ARRAY_BUFFER`
    type. The second parameter is the size of the data type that was passed in. `sizeof()`
    is a C++ keyword that gets the size of the data in bytes.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是数据缓冲区类型，它是`GL_ARRAY_BUFFER`类型。第二个参数是传入的数据类型的大小。`sizeof()`是C++关键字，用于获取数据的字节数。
- en: The next parameter is the data itself, while the last parameter is used to specify
    whether this data will change. `GL_STATIC_DRAW` means that the data will not be
    modified once the values have been stored.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个参数是数据本身，而最后一个参数用于指定这些数据是否会改变。`GL_STATIC_DRAW`表示一旦值被存储，数据将不会被修改。
- en: 'Then, we specify the vertex attributes, as follows:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们指定顶点属性，如下所示：
- en: The first parameter is the index of the attribute. In this case, we just have
    one attribute that has a position located at the 0th index.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是属性的索引。在这种情况下，我们只有一个位于第0个索引的位置属性。
- en: The second is the size of the attribute. Each vertex is represented by three
    floats for *x*, *y*, and *z*, so here, the value that's being specified is `3`.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个是属性的大小。每个顶点由三个浮点数表示*x*，*y*和*z*，所以这里指定的值是`3`。
- en: The third parameter is the type of data that is being passed in, which is of
    the `GL_FLOAT` type.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数是要传递的数据类型，它是`GL_FLOAT`类型。
- en: The fourth parameter is a Boolean asking whether the value should be normalized
    or used as is. We are specifying `GL_FALSE` since we don't want the data to be
    normalized.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个参数是一个布尔值，询问值是否应该被归一化或直接使用。我们指定`GL_FALSE`，因为我们不希望数据被归一化。
- en: The fifth parameter is called the stride; this specifies the offset between
    the attributes. Here, the value for the next position is the size of three floats,
    that is, *x*, *y*, and *z*.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第五个参数称为步长；它指定了属性之间的偏移量。在这里，下一个位置的值是三个浮点数的大小，即*x*，*y*和*z*。
- en: 'The final parameter specifies the starting offset of the first component, which
    is 0 here. We are typecasting the data to a more generic data type (`void*`),
    called a void pointer:'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个参数指定了第一个组件的起始偏移量，这里为0。我们将数据类型转换为更通用的数据类型（`void*`），称为空指针：
- en: '[PRE14]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we enable the attribute at the 0th index, as follows:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们启用第0个索引处的属性，如下所示：
- en: '[PRE15]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is a basic example. This changes when we add additional attributes, such
    as color.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本示例。当我们添加额外的属性，如颜色时，这会发生变化。
- en: Vertex shader
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶点着色器
- en: The vertex shader stage performs operations on a per-vertex basis. Depending
    on the number of vertices you have passed into the vertex shader, the vertex shader
    will be called that many times. If you are passing three vertices to form a triangle,
    then the vertex shader will be called three times.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器阶段对每个顶点执行操作。根据你传递给顶点着色器的顶点数量，顶点着色器将被调用相应次数。如果你传递三个顶点来形成一个三角形，那么顶点着色器将被调用三次。
- en: Depending on the attributes that are passed into the shader, the vertex shader
    modifies the value that is passed in and outputs the final value of that attribute.
    For example, when you pass in a position attribute, you can manipulate its value
    and send out the final position of that vertex at the end of the vertex shader.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 根据传入着色器的属性，顶点着色器会修改传入的值，并输出该属性的最终值。例如，当你传入一个位置属性时，你可以操作它的值，并在顶点着色器结束时发送出该顶点的最终位置。
- en: 'The following code is for a basic vertex shader for the single attribute that
    we passed in previously:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是为之前传入的单个属性的基本顶点着色器：
- en: '[PRE16]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Shaders are programs written in a language similar to C. The shader will always
    begin with the version of the **GL Shader Language** (**GLSL**). There are other
    shader languages, including the **High-Level Shading Language** (**HLSL**), which
    is used by Direct 3D and CG. CG is also used in Unity.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器是用类似于C的语言编写的程序。着色器总是以**GL着色器语言**（**GLSL**）的版本开始。还有其他着色器语言，包括**高级着色语言**（**HLSL**），它被Direct
    3D和CG使用。CG也被用于Unity。
- en: Now, we will declare all the input attributes that we want to use. For this,
    we use the `layout` keyword and specify the location or the index of the attribute
    we want to use in brackets. Since we passed in one attribute for the vertex position
    and specified the index for it as 0 while specifying the attribute pointer, we
    set the location as 0\. Then, we use the `in` keyword to say that we are receiving
    the information. We store each position's value in a variable type called `vec3`,
    along with a name position.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将声明我们想要使用的所有输入属性。为此，我们使用`layout`关键字，并在括号中指定我们想要使用的属性的位置或索引。由于我们传递了一个顶点位置属性，并为其指定了索引0，同时指定了属性指针，我们将位置设置为0。然后，我们使用`in`关键字来说明我们正在接收信息。我们将每个位置值存储在一个名为`vec3`的变量类型中，并附上名称位置。
- en: '`vec3`, which is a variable type, is used for vectors that are GLSL-intrinsic
    data types that can store data that''s been passed into the shader. Here, since
    we are passing in position information that has an *x*, *y*, and *z* component,
    it''s convenient to use a `vec3`. We also have a `vec4`, which has an additional
    `w` component that can be used to store color information, for example.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`vec3`，这是一个变量类型，用于存储传递到着色器的向量，它是GLSL内建数据类型。在这里，由于我们传递了具有*x*、*y*和*z*分量的位置信息，使用`vec3`很方便。我们还有一个`vec4`，它有一个额外的*w*分量，可以用来存储颜色信息，例如。'
- en: 'Each shader needs to have a main function in which the major function that''s
    relevant to the shader will be performed. Here, we are not doing anything too
    complicated: we''re just getting the `vec3`, converting it into a `vec4`, and
    then setting the value to `gl_Position`. We have to convert `vec3` into `vec4`
    since `gl_Position` is a `vec4`. It is also GLSL''s intrinsic variable, which
    is used to store and output values from the vertex shader.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 每个着色器都需要有一个主函数，在其中执行与着色器相关的重大功能。在这里，我们并没有做太复杂的事情：我们只是获取`vec3`，将其转换为`vec4`，然后将值设置为`gl_Position`。我们必须将`vec3`转换为`vec4`，因为`gl_Position`是一个`vec4`。它也是GLSL的内建变量，用于存储和从顶点着色器输出值。
- en: Since this is a basic example of a vertex shader, we are not going to multiply
    each point with the `ModelViewProjection` matrix to transform the point onto the
    projection space. We will expand on this example later in this book.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个基本的顶点着色器示例，我们不会将每个点与`ModelViewProjection`矩阵相乘以将点转换到投影空间。我们将在本书的后面扩展这个示例。
- en: Vertex post-processing
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶点后处理
- en: At this stage, clipping occurs. Objects that are not in the visible cone of
    the camera are not rendered to the screen. These primitives, which are not displayed,
    are said to be clipped.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，会发生裁剪。不在相机可见锥体内的对象不会被渲染到屏幕上。这些未显示的原始对象被称为裁剪。
- en: Let's say that only part of a sphere is visible. The primitive is broken into
    smaller primitives and only the primitives that are visible will be displayed.
    The vertex positions of the primitives are transformed from the clip space into
    the window space.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 假设只有部分球体是可见的。原始对象被分解成更小的原始对象，并且只有可见的原始对象将被显示。原始对象的顶点位置将从裁剪空间转换到窗口空间。
- en: 'For example, in the following diagram, only parts of the sphere, triangle,
    and cuboid are visible. The remaining parts of the shapes are not visible to the
    camera and so they have been clipped:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在下面的图中，只有球体、三角形和长方体的部分是可见的。形状的其余部分对相机不可见，因此它们已被裁剪：
- en: '![](img/23c03293-0fcc-4a7f-827d-f9abaf3df9c1.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/23c03293-0fcc-4a7f-827d-f9abaf3df9c1.png)'
- en: Primitive assembly
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始对象装配
- en: The primitive assembly stage gathers all the primitives that weren't clipped
    in the previous stage and creates a sequence of primitives.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 原始对象装配阶段收集了上一阶段未裁剪的所有原始对象，并创建了一系列原始对象。
- en: Face culling is also performed at this stage. Face culling is the process in
    which primitives that are in front of the view but are facing backward will be
    culled since they won't be visible. For example, when you are looking at a cube,
    you only see the front face of the cube and not the back of the cube, so there
    is no point in rendering the back of the cube when it is not visible. This is
    called back-face culling.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段也会执行面裁剪。面裁剪是一个过程，其中位于视图前方但朝向背面的原始对象将被裁剪，因为它们是不可见的。例如，当你观察一个立方体时，你只能看到立方体的前面，而不是背面，因此当背面不可见时，渲染立方体的背面是没有意义的。这被称为背面裁剪。
- en: Rasterization
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光栅化
- en: The GPU needs to convert the geometry that's been described in terms of vectors
    into pixels. We call this rasterization. The primitives that pass the previous
    stages of clipping and culling will be processed further so that they can be rasterized.
    The rasterization process creates a series of fragments from these primitives.
    The process of converting a primitive into a rasterized image is done by the GPU.
    In the process of rasterization (vector to pixel), we always lose information,
    hence the name f*ragments of primitives*. The fragment shader is used to calculate
    the final pixel's color value, which will be output to the screen.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: GPU需要将用向量描述的几何形状转换为像素。我们称之为光栅化。通过裁剪和剔除之前阶段的原始图形将被进一步处理，以便它们可以被光栅化。光栅化过程从这些原始图形中创建一系列片段。将原始图形转换为光栅化图像的过程由GPU完成。在光栅化过程中（从向量到像素），我们总是丢失信息，因此得名“原始片段的碎片”。片段着色器用于计算最终像素的颜色值，该值将被输出到屏幕。
- en: Fragment shader
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 片段着色器
- en: Fragments from the rasterization stage are then processed using the fragment
    shader. Just like the vertex shader stage, the fragment shader is also a program
    that can be written so that we can perform modifications on each fragment.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 光栅化阶段的片段随后将使用片段着色器进行处理。就像顶点着色器阶段一样，片段着色器也是一个程序，可以编写以对每个片段进行修改。
- en: The fragment shader will be called for each fragment from the previous stage.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 对于之前阶段的每个片段，将调用片段着色器。
- en: 'Here is an example of a basic fragment shader:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本片段着色器的示例：
- en: '[PRE17]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Just like the vertex shader, you need to specify the GLSL version to use.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 就像顶点着色器一样，你需要指定要使用的GLSL版本。
- en: We use the `out` keyword to send the output value from the fragment shader.
    Here, we want to send out a variable of the `vec4` type called `Color`. The main
    function is where all the magic happens. For each fragment that gets processed,
    we set the value of `Color` to `blue`. So, when the primitive gets rendered to
    the viewport, it will be completely blue.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`out`关键字从片段着色器发送输出值。在这里，我们想要发送一个名为`Color`的`vec4`类型的变量。主函数是所有魔法发生的地方。对于每个被处理的片段，我们将`Color`的值设置为`蓝色`。因此，当原始图形被渲染到视口时，它将完全呈现蓝色。
- en: This is how the sphere becomes blue.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是球体变成蓝色的原因。
- en: Per-sample operation
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每样本操作
- en: In the same way that the vertex post-processing stage clipped a primitive, the
    per-sample operation also removes fragments that won't be shown. Whether a fragment
    needs to be displayed on the screen depends on certain tests that can be enabled
    by the user.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 与顶点后处理阶段裁剪原始图形的方式相同，每样本操作也会移除不会显示的片段。一个片段是否需要在屏幕上显示取决于用户可以启用的某些测试。
- en: 'One of the more commonly used tests is the depth test. When enabled, this will
    check whether a fragment is behind another fragment. If this is the case, then
    the current fragment will be discarded. For example, here, only part of the cuboid
    is visible since it is behind the grey sphere:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个更常用的测试是深度测试。当启用时，这将检查一个片段是否位于另一个片段之后。如果是这种情况，则当前片段将被丢弃。例如，在这里，由于它位于灰色球体之后，只有部分立方体是可见的：
- en: '![](img/590f5164-1edf-4d8c-864d-5eceddc171cf.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/590f5164-1edf-4d8c-864d-5eceddc171cf.png)'
- en: There are other tests we can perform as well, such as scissor and stencil tests,
    which will only show a portion of the screen or object based on certain conditions
    that we specify.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以执行其他测试，例如裁剪和模板测试，这些测试将根据我们指定的某些条件只显示屏幕或对象的一部分。
- en: 'Color blending is also done at this stage. Here, based on certain blending
    equations, colors can be blended. For example, here, the sphere is transparent,
    so we can see the color of the cuboid blending into the color of the sphere:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色混合也在此阶段进行。在这里，基于某些混合方程，颜色可以进行混合。例如，在这里，球体是透明的，因此我们可以看到立方体的颜色与球体的颜色混合：
- en: '![](img/98373bc0-12bf-46ac-b338-adebee132395.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/98373bc0-12bf-46ac-b338-adebee132395.png)'
- en: Framebuffer
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 帧缓冲区
- en: Finally, when a per-sample operation is completed for all the fragments in a
    frame, the final image is rendered to the framebuffer, which is then presented
    on the screen.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当一帧中所有片段的每样本操作完成后，最终图像将被渲染到帧缓冲区，然后呈现在屏幕上。
- en: A framebuffer is a collection of images that are drawn per frame. Each of these
    images is attached to the framebuffer. The framebuffer has attachments, such as
    the color image that's shown on the screen. There are also other attachments,
    such as the depth or the image/texture; this just stores the depth information
    of each pixel. The end user never sees this, but it is sometimes used for graphical
    purposes by games.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 帧缓冲区是一组每帧绘制的图像。这些图像中的每一个都附加到帧缓冲区上。帧缓冲区有附加物，例如显示在屏幕上的颜色图像。还有其他附加物，例如深度或图像/纹理；这仅仅存储了每个像素的深度信息。最终用户看不到这些，但有时游戏会为了图形目的使用它。
- en: In OpenGL, the framebuffer is created automatically at the start. There are
    also user-created framebuffers that can be used to render the scene first, apply
    post-processing to it, and then hand it back to the system so that it can displayed
    on the screen.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL中，帧缓冲区在开始时自动创建。也存在用户创建的帧缓冲区，可以用来首先渲染场景，对其应用后处理，然后将它交还给系统以便在屏幕上显示。
- en: Summary
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered some of the basics of mathematics that we will be
    using throughout this book. In particular, we learned about coordinate systems,
    points, vectors, and matrices. Then, we learned how to apply these concepts to
    Open GL mathematics and space transforms. Afterward, we looked at GLM, which is
    a math library that we will be using to make our mathematic calculations easier.
    Finally, we covered space transforms and understood the flow of the graphics pipeline.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了本书中将要用到的一些数学基础知识。特别是，我们学习了坐标系、点、向量和矩阵。然后，我们学习了如何将这些概念应用到OpenGL数学和空间变换中。之后，我们了解了GLM，这是一个数学库，我们将使用它来简化我们的数学计算。最后，我们涵盖了空间变换并理解了图形管道的流程。
- en: In the next chapter we will look at how to use a simple framework like SFML
    to make a 2D game
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用像SFML这样的简单框架来制作2D游戏
