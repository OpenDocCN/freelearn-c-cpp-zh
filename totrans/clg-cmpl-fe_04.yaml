- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Clang AST
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clang AST
- en: The parsing stage of any compiler generates a parse tree, and the **Abstract**
    **Syntax Tree (AST)** is a fundamental algorithmic structure that is generated
    during the parsing of a given input program. The AST serves as the framework for
    the Clang frontend and is the primary tool for various Clang utilities, including
    linters. Clang offers sophisticated tools for searching (or matching) various
    AST nodes. These tools are implemented using a **Domain-Specific Language (DSL)**.
    It’s crucial to understand its implementation to use it effectively.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 任何编译器的解析阶段都会生成一个解析树，**抽象语法树 (AST)** 是在给定输入程序的解析过程中生成的基本算法结构。AST 作为 Clang 前端的框架，也是各种
    Clang 工具（包括代码检查器）的主要工具。Clang 提供了用于搜索（或匹配）各种 AST 节点的复杂工具。这些工具使用 **领域特定语言 (DSL)**
    实现。理解其实现对于有效地使用这些工具至关重要。
- en: 'We will start with the basic data structures and the class hierarchy that Clang
    uses to construct the AST. Additionally, we will explore the methods used for
    AST traversal and highlight some helper classes that facilitate node matching
    during this traversal. We will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 Clang 构建 AST 所使用的基层数据结构和类层次结构开始。此外，我们还将探索用于 AST 遍历的方法，并突出一些在遍历过程中帮助节点匹配的辅助类。我们将涵盖以下主题：
- en: Basic blocks used to construct the AST
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于构建 AST 的基本块
- en: How the AST can be traversed
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何遍历 AST
- en: The recursive visitor as the fundamental AST traversal tool
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归访问者是基本的 AST 遍历工具
- en: AST matchers and their role in assisting with AST traversal
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AST 匹配器和它们在辅助 AST 遍历中的作用
- en: Clang-Query as the basic tool to explore AST internals
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clang-Query 作为探索 AST 内部的基本工具
- en: Compilation errors and their impact on the AST
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译错误及其对 AST 的影响
- en: 3.1 Technical requirements
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 技术要求
- en: 'The source code for this chapter is located in the `chapter3` folder of the
    book’s GitHub repository: [https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter3](https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter3).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码位于本书 GitHub 仓库的 `chapter3` 文件夹中：[https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter3](https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter3)。
- en: 3.2 AST
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 AST
- en: The AST is usually depicted as a tree, with its leaf nodes corresponding to
    various objects, such as function declarations and loop bodies. Typically, the
    AST represents the result of syntax analysis, i.e., parsing. Clang’s AST nodes
    were designed to be immutable. This design requires that the Clang AST stores
    results from semantic analysis, meaning the Clang AST represents the outcomes
    of both syntax and semantic analyses.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: AST 通常被表示为树形结构，其叶节点对应于各种对象，例如函数声明和循环体。通常，AST 表示语法分析的结果，即解析。Clang 的 AST 节点被设计为不可变的。这种设计要求
    Clang AST 存储语义分析的结果，这意味着 Clang AST 代表了语法和语义分析的结果。
- en: Important note
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: Although Clang also employs an AST, it’s worth noting that the Clang AST is
    not a true tree. The presence of backward edges makes ”graph” a more appropriate
    term for describing Clang’s AST.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Clang 也使用 AST，但值得注意的是，Clang 的 AST 不是一个真正的树。存在反向边使得“图”这个词更适合描述 Clang 的 AST。
- en: 'Typical tree structure implemented in C++ has all nodes derived from a base
    class. Clang uses a different approach. It splits different C++ constructions
    into separate groups with basic classes for each of them:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中实现的典型树结构具有所有节点都从基类派生。Clang 采用不同的方法。它将不同的 C++ 构造分成不同的组，并为每个组提供基本类：
- en: 'Statements: `clang``::``Stmt` is the basic class for all statements. That includes
    ordinary statements such as `if` statements (`clang``::``IfStmt` class) as well
    as expressions and other C++ constructions.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语句：`clang::Stmt` 是所有语句的基本类。这包括普通语句，如 `if` 语句（`clang::IfStmt` 类），以及表达式和其他 C++
    构造。
- en: 'Declarations: `clang``::``Decl` is the base class for declarations. This includes
    a variable, typedef, function, struct, and more. There is also a separate base
    class for declarations with context, that is, declarations that might contain
    other declarations. The class is called `clang``::``DeclContext`. The declarations
    contained in `clang``::``DeclContext` can be accessed using the `clang``::``DeclContext``::``decls`
    method. Translation units (`clang``::``TranslationUnitDecl` class) and namespaces
    (`clang``::``NamespaceDecl` class) are typical examples of declarations with context.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明：`clang::Decl`是声明的基类。这包括变量、typedef、函数、结构体等。还有一个用于具有上下文声明的单独基类，即可能包含其他声明的声明。此类称为`clang::DeclContext`。`clang::DeclContext`中包含的声明可以通过`clang::DeclContext::decls`方法访问。翻译单元（`clang::TranslationUnitDecl`类）和命名空间（`clang::NamespaceDecl`类）是具有上下文声明的典型示例。
- en: 'Types: C++ has a rich type system. It includes basic types such as `int` for
    integers as well as custom defined types and type redefinition via `typedef` or
    `using`. Types in C++ can have qualifiers such as `const` and can represent different
    memory addressing modes, aka pointers, references, and so on. Clang uses `clang``::``Type`
    as the basic class for type representations in AST.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型：C++有一个丰富的类型系统。它包括基本类型，如用于整数的`int`，以及自定义定义的类型和通过`typedef`或`using`进行的类型重定义。C++中的类型可以有诸如`const`之类的限定符，并且可以表示不同的内存寻址模式，即指针、引用等。Clang使用`clang::Type`作为AST中类型表示的基本类。
- en: It’s worth noting that there are additional relations between the groups. For
    example, the `clang``::``DeclStmt` class, which inherits from `clang``::``Stmt`,
    has methods to retrieve corresponding declarations. Additionally, expressions
    (represented by the `clang``::``Expr` class), which inherit from `clang``::``Stmt`
    have methods to work with types. Let’s look at all the groups in detail.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，组之间存在额外的关系。例如，继承自`clang::Stmt`的`clang::DeclStmt`类有检索相应声明的功能。此外，继承自`clang::Stmt`的表达式（由`clang::Expr`类表示）有处理类型的方法。让我们详细看看所有这些组。
- en: 3.2.1 Statements
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 语句
- en: '`Stmt` is the basic class for all statements. The statements can be combined
    into two sets (see [Figure 3.1](#Figure3.1)). The first one contains statements
    with values and the opposite group is for statements without values.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stmt` 是所有语句的基本类。语句可以组合成两组（见[图3.1](#Figure3.1)）。第一组包含带有值的语句，而与之相反的组是用于不带值的语句。'
- en: '![Figure 3.1: Clang AST: statements ](img/Figure3.1_B19722.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1：Clang AST：语句](img/Figure3.1_B19722.png)'
- en: '**Figure 3.1**: Clang AST: statements'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.1**：Clang AST：语句'
- en: The group of statements without a value consist of different C++ constructions
    such as `if` statements (`clang``::``IfStmt` class) or compound statements (`clang``::``CompoundStmt`
    class). The majority of all statements fall into the group.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 不带值的语句组包括不同的C++构造，例如`if`语句（`clang::IfStmt`类）或复合语句（`clang::CompoundStmt`类）。所有语句中的大多数都归入这一组。
- en: The group of statements with a value consists of one base class `clang``::``ValueStmt`
    that has several children, such as `clang``::``LabelStmt` (for label representation)
    or `clang``::``ExprStmt` (for expression representation), see [Figure 3.2](#Figure3.2).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 带有值的语句组由一个基类`clang::ValueStmt`组成，它有几个子类，如`clang::LabelStmt`（用于标签表示）或`clang::ExprStmt`（用于表达式表示），见[图3.2](#Figure3.2)。
- en: '![Figure 3.2: Clang AST: statements with a value ](img/Figure3.2_B19722.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2：Clang AST：带有值的语句](img/Figure3.2_B19722.png)'
- en: '**Figure 3.2**: Clang AST: statements with a value'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.2**：Clang AST：带有值的语句'
- en: 3.2.2 Declarations
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2 声明
- en: 'Declarations can also be combined into two primary groups: declarations with
    context and without. Declarations with context can be considered as placeholders
    for other declarations. For example, a C++ namespace as well as a translation
    unit or function declaration might contain other declarations. A declaration of
    a friend entity (`clang``::``DeclFriend`) can be considered an example of a declaration
    without context.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 声明也可以组合成两个主要组：具有上下文和无上下文的声明。具有上下文的声明可以被认为是其他声明的占位符。例如，C++命名空间以及翻译单元或函数声明可能包含其他声明。友元实体声明（`clang::DeclFriend`）可以被认为是无上下文声明的例子。
- en: It has to be noted that classes that are inherited from `DeclContext` also have
    `clang``::``Decl` as their top parent.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意的是，从`DeclContext`继承的类也有`clang::Decl`作为它们的顶级父类。
- en: 'Some declarations can be redeclared, as in the following example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一些声明可以被重新声明，如下面的例子所示：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Figure 3.3**: Declarations example: redeclaration.cpp'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.3**: 声明示例：redeclaration.cpp'
- en: Such declarations have an additional parent that is implemented via a `clang``::``Redeclarable``<...>`
    template.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的声明有一个额外的父类，通过 `clang``::``Redeclarable``<...>` 模板实现。
- en: 3.2.3 Types
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.3 类型
- en: C++ is a statically typed language, which means that the types of variables
    must be declared at compile time. The types allow the compiler to make a reasonable
    conclusion about the program’s meaning, which makes types an important part of
    semantic analysis. `clang``::``Type` is the basic class for types in Clang.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: C++是一种静态类型语言，这意味着变量的类型必须在编译时声明。类型允许编译器对程序的意义做出合理的推断，这使得类型成为语义分析的重要组成部分。`clang``::``Type`
    是 Clang 中类型的基类。
- en: Types in C/C++ might have qualifiers that are called CV-qualifiers, as specified
    in the standard [[21](B19722_Bib.xhtml#Xstandard_cpp20), basic.type.qualifier].
    CV here stands for two keywords `const` and `volatile` that can be used as the
    qualifier for a type.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++中的类型可能有被称为 CV-限定符的限定符，如标准[[21](B19722_Bib.xhtml#Xstandard_cpp20)，basic.type.qualifier)]
    所述。在这里，CV 代表两个关键字 `const` 和 `volatile`，它们可以用作类型的限定符。
- en: Important note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The C99 standard has an additional type qualifier, `restrict`, which is also
    supported by Clang [[25](B19722_Bib.xhtml#Xstandard_c99), 6.7.3]. The type qualifier
    indicates to the compiler that, for the lifetime of the pointer, no other pointer
    will be used to access the object it points to. This allows the compiler to perform
    optimizations such as vectorization that wouldn’t be possible otherwise. `restrict`
    helps limit pointer aliasing effects, which occur when multiple pointers reference
    the same memory location, thereby aiding optimizations. However, if the programmer’s
    declaration of intent is not followed, and the object is accessed by an independent
    pointer, it results in undefined behavior.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: C99 标准有一个额外的类型限定符 `restrict`，Clang 也支持它[[25](B19722_Bib.xhtml#Xstandard_c99)，6.7.3]。类型限定符指示编译器，在指针的生命周期内，不会使用其他指针来访问它所指向的对象。这允许编译器执行诸如向量化等优化，否则这些优化是不可能的。`restrict`
    有助于限制指针别名效应，即当多个指针引用相同的内存位置时发生的效应，从而有助于优化。然而，如果程序员的意图声明没有得到遵循，并且对象被独立指针访问，则会导致未定义的行为。
- en: 'Clang has a special class to support a type with a qualifier, `clang``::``QualType`,
    which is a pair of a pointer to `clang``::``Type` and a bit mask with information
    about the type qualifier. The class has a method to retrieve a pointer to the
    `clang``::``Type` and check different qualifiers. The following code (LLVM 18.x,
    `clang/lib/AST/ExprConstant.cpp`, *Line* *3918*) shows how we can check a type
    for a const qualifier:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Clang 有一个特殊类来支持具有限定符的类型，`clang``::``QualType`，它是一个指向 `clang``::``Type` 的指针和一个包含类型限定符信息的位掩码。该类有一个方法来检索指向
    `clang``::``Type` 的指针并检查不同的限定符。以下代码（LLVM 18.x，`clang/lib/AST/ExprConstant.cpp`，*行*
    *3918*）展示了我们如何检查具有 const 限定符的类型：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Figure 3.4**: checkConst implementation from clang/lib/AST/ExprConstant.cpp'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.4**: 从 clang/lib/AST/ExprConstant.cpp 的 checkConst 实现'
- en: It’s worth mentioning that `clang``::``QualType` has `operator``->()` and `operator``*()`
    implemented, that is, it can be considered as a smart pointer for the underlying
    `clang``::``Type` class.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`clang``::``QualType` 实现了 `operator``->()` 和 `operator``*()`，这意味着它可以被视为底层
    `clang``::``Type` 类的智能指针。
- en: 'In addition to qualifiers, the type can have additional information that represents
    different memory address models. For instance, there can be a pointer to an object
    or reference. `clang``::``Type` has the following helper methods to check different
    address models:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 除了限定符之外，类型还可以有额外的信息，表示不同的内存地址模型。例如，可以有一个指向对象的指针或引用。`clang``::``Type` 有以下辅助方法来检查不同的地址模型：
- en: '`clang``::``Type``::``isPointerType``()` for pointer type check'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clang``::``Type``::``isPointerType``() 用于检查指针类型'
- en: '`clang``::``Type``::``isReferenceType``()` for reference type check'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clang``::``Type``::``isReferenceType``() 用于检查引用类型'
- en: Types in C/C++ can also use aliases, which are introduced by using the `typedef`
    or `using` keywords. The following code defines `foo` and `bar` as aliases for
    the `int` type.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++中的类型也可以使用别名，这些别名是通过使用 `typedef` 或 `using` 关键字引入的。以下代码将 `foo` 和 `bar` 定义为
    `int` 类型的别名。
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Figure 3.5**: Type alias declarations'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.5**: 类型别名声明'
- en: 'Original types, `int` in our case, are called canonical. You can test whether
    the type is canonical or not using the `clang``::``QualType``::``isCanonical``()`
    method. `clang``::``QualType` also provides a method to retrieve the canonical
    type from an alias: `clang``::``QualType``::``getCanonicalType``()`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 原始类型，在我们的例子中是`int`，被称为规范类型。你可以使用`clang::QualType::isCanonical()`方法测试类型是否为规范类型。`clang::QualType`还提供了一个方法来从别名中检索规范类型：`clang::QualType::getCanonicalType()`。
- en: After gaining knowledge of the basic blocks used for the AST in Clang, it’s
    time to investigate how these blocks can be used for AST traversal. This is the
    basic operation used by the compiler and compiler tools, and we will use it extensively
    throughout the book.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了Clang中用于AST的基本块之后，现在是时候研究如何使用这些块进行AST遍历了。这是编译器和编译器工具使用的基本操作，我们将在整本书中广泛使用它。
- en: 3.3 AST traversal
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 AST遍历
- en: 'The compiler requires traversal of the AST to generate IR code. Thus, having
    a well-structured data structure for tree traversal is paramount for AST design.
    To put it another way, the design of the AST should prioritize facilitating easy
    tree traversal. A standard approach in many systems is to have a common base class
    for all AST nodes. This class typically provides a method to retrieve the node’s
    children, allowing for tree traversal using popular algorithms such as Breadth-First
    Search (BFS) [[19](B19722_Bib.xhtml#Xbook_cormen2009introduction)]. Clang, however,
    takes a different approach: its AST nodes don’t share a common ancestor. This
    poses the question: how is tree traversal organized in Clang?'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器需要遍历AST以生成IR代码。因此，对于AST设计来说，拥有一个良好的树遍历数据结构至关重要。换句话说，AST的设计应优先考虑便于树遍历。在许多系统中，一个标准的方法是为所有AST节点提供一个公共基类。这个类通常提供了一个方法来检索节点的子节点，允许使用如广度优先搜索（BFS）[19](B19722_Bib.xhtml#Xbook_cormen2009introduction)等流行算法进行树遍历。然而，Clang采取了不同的方法：它的AST节点没有共同的祖先。这提出了一个问题：在Clang中树遍历是如何组织的？
- en: 'Clang employs three unique techniques:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Clang采用了三种独特的技术：
- en: The Curiously Recurring Template Pattern (CRTP) for visitor class definition
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于访问者类定义的奇特重复模板模式（CRTP）
- en: Ad hoc methods tailored specifically for different nodes
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对不同节点定制的临时方法
- en: Macros, which can be perceived as the connecting layer between the ad hoc methods
    and CRTP
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏，可以被视为临时方法和CRTP之间的连接层
- en: We will explore these techniques through a simple program designed to identify
    function definitions and display the function names together with their parameters.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个简单的程序来探索这些技术，该程序旨在识别函数定义并显示函数名及其参数。
- en: 3.3.1 DeclVisitor test tool
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 DeclVisitor测试工具
- en: Our test tool will build upon the `clang``::``DeclVisitor` class, which is defined
    as a straightforward visitor class aiding in the creation of visitors for C/C++
    declarations.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试工具将建立在`clang::DeclVisitor`类之上，该类被定义为一个简单的访问者类，有助于创建C/C++声明的访问者。
- en: 'We will use the same CMake file as was created for our first Clang tool (see
    [Figure 1.13](B19722_01.xhtml#x1-30031r13)). The sole addition to the new tool
    is the `clangAST` library. The resultant `CMakeLists.txt` is shown in [Figure 3.6](#x1-60029r6):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与我们的第一个Clang工具创建相同的CMake文件（参见[图1.13](B19722_01.xhtml#x1-30031r13)）。新工具的唯一添加是`clangAST`库。结果`CMakeLists.txt`文件如图3.6所示：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Figure 3.6**: CMakeLists.txt file for DeclVisitor test tool'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.6**: DeclVisitor测试工具的CMakeLists.txt文件'
- en: 'The `main` function of our tool is presented below:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们工具的`main`函数如下所示：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Figure 3.7**: The main function of the DeclVisitor test tool'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.7**: DeclVisitor测试工具的主函数'
- en: 'From *Lines 5 and 23*, it’s evident that we employ a custom frontend action
    specific to our project: `clangbook``::``declvisitor``::``FrontendAction`.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 从*第5行和第23行*可以看出，我们使用了针对我们项目定制的自定义前端操作：`clangbook::declvisitor::FrontendAction`。
- en: 'The following is the code for this class:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个类的代码：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Figure 3.8**: Custom FrontendAction class for the DeclVisitor test tool'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.8**: DeclVisitor测试工具的自定义FrontendAction类'
- en: You’ll notice that we have overridden the `CreateASTConsumer` function from
    `clang``::``ASTFrontendAction` class to instantiate an object of our custom AST
    consumer class `Consumer`, defined in `clangbook``::``declvisitor` namespace,
    as highlighted in [Figure 3.8](#x1-60077r8), *Lines 9-12*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们已覆盖了`clang::ASTFrontendAction`类中的`CreateASTConsumer`函数，以实例化我们自定义的AST消费者类`Consumer`，该类定义在`clangbook::declvisitor`命名空间中，如图3.8中突出显示的*第9-12行*。
- en: 'The implementation for the class is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 类的实现如下：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Figure 3.9**: Consumer class for the DeclVisitor test tool'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.9**：DeclVisitor测试工具的消费者类'
- en: Here, we can see that we’ve created a sample visitor and invoked it using an
    overridden method `HandleTranslationUnit` from the `clang``::``ASTConsumer` class
    (see [Figure 3.9](#x1-60100r9), *Line 11*).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们创建了一个示例访问者，并使用`clang::ASTConsumer`类中的重写方法`HandleTranslationUnit`来调用它（参见[图3.9](#x1-60100r9)，*第11行*）。
- en: 'However, the most intriguing portion is the code for the visitor:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最引人入胜的部分是访问者的代码：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Figure 3.10**: Visitor class implementation'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.10**：访问者类实现'
- en: We will explore the code in more depth later. For now, we observe that it prints
    the function name at *Line 8* and the parameter name at *Line* *14*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后更深入地探索代码。目前，我们观察到它在*第8行*打印函数名，在*第14行*打印参数名。
- en: We can compile our program using the same sequence of commands as we did for
    our test project, as detailed in [*Section** 1.4*](B19722_01.xhtml#x1-300004)*,
    Test project – syntax* *check with a Clang tool*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用与测试项目相同的命令序列来编译我们的程序，如[*第1.4节*](B19722_01.xhtml#x1-300004)中详细说明的，测试项目
    – 使用Clang工具进行语法检查。
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Figure 3.11**: Configure and build commands for the DeclVisitor test tool'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.11**：DeclVisitor测试工具的配置和构建命令'
- en: As you may notice, we used the `-DCMAKE``_BUILD``_TYPE=Debug` option for CMake.
    The option we are using will slow down the overall performance, but we use it
    because we might want to investigate the resulting program under debugger.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，我们为CMake使用了`-DCMAKE_BUILD_TYPE=Debug`选项。我们使用的选项将降低整体性能，但我们使用它是因为我们可能想要在调试器下调查生成的程序。
- en: Important note
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The build command we used for our tool assumes that the required libraries
    are installed under the `<...>/llvm-project/install` folder, which was specified
    with the`-DCMAKE``_INSTALL``_PREFIX` option during the CMake configure command,
    as described in [*Section** 1.4*](B19722_01.xhtml#x1-300004)*, Test project –*
    *syntax check with a Clang tool*. See [Figure 1.12](B19722_01.xhtml#x1-30003r12):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的工具使用的构建命令假设所需的库安装在了`<...>/llvm-project/install`文件夹下，这是在CMake配置命令期间通过`-DCMAKE_INSTALL_PREFIX`选项指定的，如[*第1.4节*](B19722_01.xhtml#x1-300004)中所述，测试项目
    – 使用Clang工具进行语法检查。参见[图1.12](B19722_01.xhtml#x1-30003r12)：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The required build artifacts must be installed using the `ninja install` command.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 必须使用`ninja install`命令安装所需的构建工件。
- en: 'We will use the same program we referenced in our previous investigations (see
    [Figure 2.5](B19722_02.xhtml#x1-37021r5)) to also study AST traversal:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们在之前的调查中引用的程序（参见[图2.5](B19722_02.xhtml#x1-37021r5)）来研究AST遍历：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Figure 3.12**: Test program max.cpp'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.12**：测试程序max.cpp'
- en: This program consists of a single function, `max`, which takes two parameters,
    `a` and `b`, and returns the maximum of the two.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序由一个名为`max`的单个函数组成，它接受两个参数`a`和`b`，并返回这两个数中的最大值。
- en: 'We can run our program as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式运行我们的程序：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Figure 3.13**: The result of running the declvisitor utility on a test file'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.13**：在测试文件上运行declvisitor实用程序的结果'
- en: Important note
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'We used ’- -’ to pass additional arguments to the compiler in [Figure 3.13](#x1-60147r13),
    specifically indicating that we want to use C++17 with the option ’-std=c++17’.
    We can also pass other compiler arguments. An alternative is to specify the compilation
    database path with the ’-p’ option, as shown below:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[图3.13](#x1-60147r13)中使用了`- -`来向编译器传递额外的参数，具体是指定我们想要使用C++17，并使用选项`-std=c++17`。我们也可以传递其他编译器参数。另一种选择是使用`-p`选项指定编译数据库路径，如下所示：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, `<path>` is the path to the folder containing the compilation database.
    You can find more information about the compilation database in [*Chapter** 9*](B19722_09.xhtml#x1-1810009)*,
    Appendix 1: Compilation Database*.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<path>`是包含编译数据库的文件夹的路径。你可以在[*第9章*](B19722_09.xhtml#x1-1810009)附录1：编译数据库中找到更多关于编译数据库的信息。
- en: Let’s investigate the `Visitor` class implementation in detail.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细调查`Visitor`类的实现。
- en: 3.3.2 Visitor implementation
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 访问者实现
- en: 'Let’s delve into the `Visitor` code (see [Figure 3.10](#x1-60128r10)). Firstly,
    you’ll notice an unusual construct where our class is derived from a base class
    parameterized by our own class:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨`Visitor`代码（参见[图3.10](#x1-60128r10)）。首先，你会注意到一个不寻常的结构，即我们的类是从一个由我们的类参数化的基类派生的：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Figure 3.14**: Visitor class declaration'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.14**：访问者类声明'
- en: This construct is known as the Curiously Recurring Template Pattern, or CRTP.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构被称为“奇特重复模板模式”，或简称CRTP。
- en: 'The Visitor class has several callbacks that are triggered when a corresponding
    AST node is encountered. The first callback targets the AST node representing
    a function declaration:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当遇到相应的AST节点时，Visitor类有几个回调会被触发。第一个回调针对的是表示函数声明的AST节点：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Figure 3.15**: FunctionDecl callback'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.15**: FunctionDecl回调'
- en: As shown in [Figure 3.15](#x1-61015r15), the function name is printed on *Line
    8*. Our subsequent step involves printing the names of the parameters. To retrieve
    the function parameters, we can utilize the `parameters``()` method from the `clang``::``FunctionDecl`
    class. This method was previously mentioned as an ad hoc approach for AST traversal.
    Each AST node provides its own methods to access child nodes. Since we have an
    AST node of a specific type (i.e., `clang``::``FunctionDecl``*`) as an argument,
    we can employ these methods.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图3.15](#x1-61015r15)所示，函数名在*第8行*打印出来。我们接下来的步骤是打印参数名。为了检索函数参数，我们可以利用`clang::FunctionDecl`类的`parameters()`方法。这个方法之前被提及为AST遍历的临时方法。每个AST节点都提供自己的方法来访问子节点。由于我们有一个特定类型的AST节点（即`clang::FunctionDecl`*）作为参数，我们可以使用这些方法。
- en: 'The function parameter is passed to the `Visit``(...)` method of the base class
    `clang``::``DeclVisitor``<>`, as shown in *Line 12* of [Figure 3.15](#x1-61015r15).
    This call is subsequently transformed into another callback, specifically for
    the `clang``::``ParmVarDecl` AST node:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数被传递到基类`clang::DeclVisitor<>`的`Visit(...)`方法，如[图3.15](#x1-61015r15)中的*第12行*所示。这个调用随后被转换成另一个回调，专门针对`clang::ParmVarDecl`
    AST节点：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Figure 3.16**: ParmVarDecl callback'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.16**: ParmVarDecl回调'
- en: You might be wondering how this conversion is achieved. The answer lies in a
    combination of the CRTP and C/C++ macros. To understand this, we need to dive
    into the `Visit``()` method implementation of the `clang``::``DeclVisitor``<>`
    class. This implementation heavily relies on C/C++ macros, so to get a glimpse
    of the actual code, we must expand these macros. This can be done using the `shell`-E
    compiler option. Let’s make some modifications to `CMakeLists.txt` and introduce
    a new custom target.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道这种转换是如何实现的。答案是CRTP和C/C++宏的组合。为了理解这一点，我们需要深入了解`clang::DeclVisitor<>`类的`Visit()`方法实现。这个实现严重依赖于C/C++宏，因此要查看实际代码，我们必须展开这些宏。这可以通过使用`shell`-E编译器选项来完成。让我们对`CMakeLists.txt`做一些修改，并引入一个新的自定义目标。
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Figure 3.17**: Custom target to expand macros'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.17**: 自定义目标以扩展宏'
- en: 'We can run the target as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式运行目标：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The resulting file can be located in the build folder specified earlier, named
    `DeclVisitor.cpp.preprocessed` . The build folder containig the file was specified
    by us earlier when executing the cmake command (see [Figure 3.11](#x1-60132r11)).
    Within this file, the generated code for the `Visit``()` method appears as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的文件可以位于之前指定的构建文件夹中，命名为`DeclVisitor.cpp.preprocessed`。包含该文件的构建文件夹是我们之前在执行cmake命令时指定的（参见[图3.11](#x1-60132r11)）。在这个文件中，`Visit()`方法的生成代码如下所示：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Figure 3.18**: Generated code for Visit() method'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.18**: Visit()方法的生成代码'
- en: This code showcases the use of the CRTP in Clang. In this context, CRTP is employed
    to redirect back to our `Visitor` class, which is referenced as `ImplClass`. CRTP
    allows the base class to call a method from an inherited class. This pattern can
    serve as an alternative to virtual functions and offers several advantages, the
    most notable being performance-related. Specifically, the method call is resolved
    at compile time, eliminating the need for a vtable lookup associated with virtual
    method calls.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了在Clang中使用CRTP。在此上下文中，CRTP被用来回退到我们的`Visitor`类，该类被引用为`ImplClass`。CRTP允许基类从继承的类中调用方法。这种模式可以作为虚拟函数的替代方案，并提供了几个优点，其中最显著的是与性能相关的优点。具体来说，方法调用是在编译时解决的，消除了与虚拟方法调用相关的vtable查找的需要。
- en: 'The code was generated using C/C++ macros, as demonstrated here. This particular
    code was sourced from the `clang/include/clang/AST/DeclVisitor.h` header:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是使用C/C++宏生成的，如这里所示。这个特定的代码来源于`clang/include/clang/AST/DeclVisitor.h`头文件：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Figure 3.19**: DISPATCH macro definition from clang/include/clang/AST/DeclVisitor.h'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.19**: 从`clang/include/clang/AST/DeclVisitor.h`中的DISPATCH宏定义'
- en: '`NAME` from [Figure 3.19](#x1-61049r19) is replaced with the node name; in
    our case, it’s `ParmVarDecl`.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.19](#x1-61049r19)中的`NAME`被节点名替换；在我们的例子中，它是`ParmVarDecl`。'
- en: '`DeclVisitor` is used to traverse C++ declarations. Clang also has `StmtVisitor`
    and `TypeVisitor` to traverse statements and types, respectively. These are built
    on the same principles as we considered in our example with the declaration visitor.
    However, these visitors come with several issues. They can only be used with specific
    groups of AST nodes. For instance, `DeclVisitor` can only be used with descendants
    of the `Decl` class. Another limitation is that we are required to implement recursion.
    For example, we set up recursion to traverse the function declaration in lines
    9-11 ([Figure 3.10](#x1-60128r10)). The same recursion was employed to traverse
    declarations within the translation unit (see [Figure 3.10](#x1-60128r10), *Lines
    17-19*). This brings up another concern: it’s possible to miss some parts of the
    recursion. For instance, our code will not function correctly if the `max` function
    declaration is specified inside a namespace. To address such scenarios, we would
    need to implement an additional visit method specifically for namespace declarations.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeclVisitor`用于遍历C++声明。Clang还有`StmtVisitor`和`TypeVisitor`分别用于遍历语句和类型。这些访问者基于与我们示例中的声明访问者相同的原理。然而，这些访问者存在一些问题。它们只能与特定的AST节点组一起使用。例如，`DeclVisitor`只能与`Decl`类的后代一起使用。另一个限制是我们需要实现递归。例如，我们在第9-11行设置了递归以遍历函数声明（参见[图3.10](#x1-60128r10)）。相同的递归被用于遍历翻译单元内的声明（参见[图3.10](#x1-60128r10)，*第17-19行*）。这又提出了另一个问题：可能会错过递归的一些部分。例如，如果`max`函数声明在命名空间内部指定，我们的代码将无法正确运行。为了解决此类场景，我们需要实现一个额外的特定于命名空间声明的访问方法。'
- en: These challenges are addressed by the recursive visitor, which we will discuss
    shortly.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些挑战将由递归访问者解决，我们将在稍后讨论。
- en: 3.4 Recursive AST visitor
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 递归AST访问者
- en: Recursive AST visitors address the limitations observed with specialized visitors.
    We will create the same program, which searches for and prints function declarations
    along with their parameters, but we’ll use a recursive visitor this time.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 递归AST访问者解决了观察到的专用访问者的局限性。我们将创建相同的程序，该程序搜索并打印函数声明及其参数，但这次我们将使用递归访问者。
- en: 'The `CMakeLists.txt` for recursive visitor test tool will be used in a similar
    way as before. Only the project name (*Lines 2 and 15-17* in [Figure 3.20](#x1-62028r20))
    and source filename (*Line 14* in [Figure 3.20](#x1-62028r20) were changed:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 递归访问者测试工具的`CMakeLists.txt`将以前类似的方式使用。只有项目名称（[图3.20](#x1-62028r20)中的*第2行和第15-17行*）和源文件名（[图3.20](#x1-62028r20)中的*第14行*）已更改：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Figure 3.20**: CMakeLists.txt file for the RecursiveVisitor test tool'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.20**：RecursiveVisitor测试工具的CMakeLists.txt文件'
- en: The `main` function for our tool is similar to the ‘DeclVisitor‘ one defined
    in [Figure 3.7](#x1-60057r7).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们工具的`main`函数与[图3.7](#x1-60057r7)中定义的‘DeclVisitor’类似。
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Figure 3.21**: The main function for the RecursiveVisitor test tool'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.21**：RecursiveVisitor测试工具的主函数'
- en: As you can see, we changed only the namespace name for our custom frontend action
    at *Line 23*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们仅在*第23行*更改了自定义前端动作的命名空间名称。
- en: The code for the frontend action and consumer is the same as in [Figure 3.8](#x1-60077r8)
    and [Figure 3.9](#x1-60100r9), with the only difference being the namespace change
    from `declvisitor` to `recursivevisitor`. The most interesting part of the program
    is the `Visitor` class implementation.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 前端动作和消费者的代码与[图3.8](#x1-60077r8)和[图3.9](#x1-60100r9)中的相同，唯一的区别是将命名空间从`declvisitor`更改为`recursivevisitor`。程序中最有趣的部分是`Visitor`类的实现。
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Figure 3.22**: Visitor class implementation'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.22**：Visitor类实现'
- en: 'There are several changes compared to the code for ‘DeclVisitor‘ (see [Figure 3.10](#x1-60128r10)).
    The first is that recursion isn’t implemented. We’ve only implemented the callbacks
    for nodes of interest to us. A reasonable question arises: how is the recursion
    controlled? The answer lies in another change: our callbacks now return a boolean
    result. The `false` value indicates that the recursion should stop, while `true`
    signals the visitor to continue the traversal.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与“DeclVisitor”的代码相比，有几个变化（参见[图3.10](#x1-60128r10)）。第一个变化是未实现递归。我们只实现了对我们感兴趣的节点回调。一个合理的问题出现了：递归是如何控制的？答案是另一个变化：我们的回调现在返回一个布尔结果。`false`值表示递归应停止，而`true`表示访问者应继续遍历。
- en: The program can be compiled using the same sequence of commands as we used previously.
    See [Figure 3.11](#x1-60132r11).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 程序可以使用与我们之前使用的相同命令序列进行编译。参见[图3.11](#x1-60132r11)。
- en: 'We can run our program as follows, see [Figure 3.23](#x1-62081r23):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像以下这样运行我们的程序，见[图3.23](#x1-62081r23)：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Figure 3.23**: The result of running the recursivevisitor utility on a test
    file'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.23**：在测试文件上运行recursivevisitor实用程序的结果'
- en: As we can see, it produces the same result as we obtained with the DeclVisitor
    implementation. The AST traversal techniques considered so far are not the only
    ways for AST traversal. Most of the tools that we will consider later will use
    a different approach based on AST matchers.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，它产生了与使用DeclVisitor实现获得的结果相同的结果。到目前为止考虑的AST遍历技术并不是AST遍历的唯一方法。我们后面考虑的大多数工具将使用基于AST匹配器的不同方法。
- en: 3.5 AST matchers
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 AST匹配器
- en: AST matchers [[16](B19722_Bib.xhtml#Xllvm_astmatchers)] provide another approach
    for locating specific AST nodes. They can be particularly useful in linters when
    searching for improper pattern usage or in refactoring tools when identifying
    AST nodes for modification.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: AST匹配器 [[16](B19722_Bib.xhtml#Xllvm_astmatchers)] 提供了定位特定AST节点的另一种方法。它们在搜索不正确的模式使用时特别有用，或者在重构工具中识别要修改的AST节点时也很有用。
- en: 'We will create a simple program to test AST matches. The program will identify
    a function definition with the name `max`. We will use a slightly modified `CMakeLists.txt`
    file from the previous examples to include the libraries required to support AST
    matches:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的程序来测试AST匹配。程序将识别一个名为 `max` 的函数定义。我们将使用之前示例中略微修改的 `CMakeLists.txt`
    文件来包含支持AST匹配所需的库：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Figure 3.24**: CMakeLists.txt for AST matchers test tool'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.24**：AST匹配器测试工具的CMakeLists.txt'
- en: 'There are two additional libraries added: `LLVMFrontendOpenMP` and `clangASTMatchers`
    (see *Lines 18 and 21* in [Figure 3.24](#x1-63030r24)). The `main` function for
    our tool looks like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 增加了两个额外的库：`LLVMFrontendOpenMP` 和 `clangASTMatchers`（见[图3.24](#x1-63030r24)中的第18和21行）。我们的工具的
    `main` 函数如下所示：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Figure 3.25**: The main function for AST matchers test tool'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.25**：AST匹配器测试工具的main函数'
- en: 'As you can observe (*Lines 21-23*), we employ the `MatchFinder` class and define
    a custom callback (included via the header in *Line 4*) that outlines the specific
    AST node we intend to match. The callback is implemented as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所观察到的 (*第21-23行*), 我们使用了 `MatchFinder` 类并定义了一个自定义回调（通过标题在第4行包含），该回调概述了我们打算匹配的特定AST节点。回调的实现如下：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Figure 3.26**: The match callback for the AST matchers test tool'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.26**：AST匹配器测试工具的匹配回调'
- en: 'The most crucial section of the code is located at lines 7-9\. Each matcher
    is identified by an ID, which, in our case, is ’match-id’. The matcher itself
    is defined in *Lines 8-9*:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中最关键的部分位于第7-9行。每个匹配器都有一个ID，在我们的情况下是’match-id’。匹配器本身在第8-9行定义：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This matcher seeks a function declaration that has a specific name, using `functionDecl``()`,
    as seen in `matchesName``()`. We utilized a specialized Domain-Specific Language
    (DSL) to specify the matcher. The DSL is implemented using C++ macros. We can
    also create our own matchers, as will be shown in [*Section** 7.3.3*](B19722_07.xhtml#x1-1440003)*,
    Check implementation*. It’s worth noting that the recursive AST visitor serves
    as the backbone for AST traversal inside the matcher’s implementation.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此匹配器寻找具有特定名称的函数声明，使用 `functionDecl``()`，如 `matchesName``()` 中所示。我们利用专门的领域特定语言（DSL）来指定匹配器。DSL是通过C++宏实现的。我们也可以创建自己的匹配器，如[第7.3.3节](B19722_07.xhtml#x1-1440003)*，检查实现*所示。值得注意的是，递归AST访问者作为匹配器实现中AST遍历的骨干。
- en: The program can be compiled using the same sequence of commands as we used previously.
    See [Figure 3.11](#x1-60132r11).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 程序可以使用我们之前使用的相同命令序列进行编译。见[图3.11](#x1-60132r11)。
- en: 'We will utilize a slightly modified version of the example shown in [Figure 2.5](B19722_02.xhtml#x1-37021r5),
    with an additional function added:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用[图2.5](B19722_02.xhtml#x1-37021r5)中显示的示例的略微修改版本，并添加一个额外的函数：
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**Figure 3.27**: Test program minmax.cpp for AST matchers'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.27**：用于AST匹配器的测试程序minmax.cpp'
- en: 'When we run our test tool on the example, we will obtain the following output:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在示例上运行我们的测试工具时，我们将获得以下输出：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**Figure 3.28**: The result of running the matchvisitor utility on a test file'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.28**：在测试文件上运行matchvisitor实用程序的结果'
- en: As we can see, it has located only one function declaration with the name specified
    for the matcher.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，它只找到了一个具有匹配器指定名称的函数声明。
- en: The DSL for matchers is typically employed in custom Clang tools, such as clang-tidy
    (as discussed in [*Chapter** 5*](B19722_05.xhtml#x1-990005)*, Clang-Tidy Linter
    Framework*), but it can also be used as a standalone tool. A specialized program
    called `clang-query` enables the execution of different match queries, which can
    be used to search for specific AST nodes in analyzed C++ code. Let’s see how the
    tool works.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配器的DSL通常用于自定义Clang工具，如clang-tidy（如第[*第5章*](B19722_05.xhtml#x1-990005)*，Clang-Tidy
    Linter Framework*）中讨论的），但它也可以作为一个独立的工具使用。一个名为`clang-query`的专用程序可以执行不同的匹配查询，这些查询可以用来在分析过的C++代码中搜索特定的AST节点。让我们看看这个工具是如何工作的。
- en: 3.6 Explore Clang AST with clang-query
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6 使用clang-query探索Clang AST
- en: 'AST matchers are incredibly useful, and there’s a utility that facilitates
    checking various matchers and analyzing the AST of your source code. This utility
    is known as `clang-query` tool. You can build and install this utility using the
    following command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: AST匹配器非常有用，有一个工具可以方便地检查各种匹配器并分析你的源代码的AST。这个工具被称为`clang-query`工具。你可以使用以下命令构建和安装这个工具：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Figure 3.29**: The clang-query installation'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.29**: clang-query的安装'
- en: 'You can run the tool as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按照以下方式运行这个工具：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**Figure 3.30**: Running clang-query on a test file'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.30**: 在测试文件上运行clang-query'
- en: 'We can use the `match` command as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下`match`命令：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**Figure 3.31**: Working with clang-query'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.31**: 使用clang-query进行操作'
- en: '[Figure 3.31](#x1-64007r31) demonstrates the default output, referred to as
    `’diag’` . Among several potential outputs, the most relevant one for us is `’dump’`
    . When the output is set to `’dump’` , clang-query will display the located AST
    node. For example, the following demonstrates how to match a function parameter
    named `a` :'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.31](#x1-64007r31)展示了默认输出，被称为`’diag’`。在几种可能的输出中，对我们来说最相关的一个是`’dump’`。当输出设置为`’dump’`时，clang-query将显示找到的AST节点。例如，以下展示了如何匹配名为`a`的函数参数：'
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**Figure 3.32**: Working with clang-query using dump output'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.32**: 使用dump输出进行clang-query操作'
- en: This tool proves useful when you wish to test a particular matcher or investigate
    a portion of the AST tree. We will utilize this tool to explore how Clang handles
    compilation errors.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想测试特定的匹配器或调查AST树的一部分时，这个工具非常有用。我们将使用这个工具来探索Clang如何处理编译错误。
- en: 3.7 Processing AST in the case of errors
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.7 错误情况下处理AST
- en: One of the most interesting aspects of Clang pertains to error processing. Error
    processing encompasses error detection, the display of corresponding error messages,
    and potential error recovery. The latter is particularly intriguing in terms of
    the Clang AST. Error recovery occurs when Clang doesn’t halt upon encountering
    a compilation error but continues to compile in order to detect additional issues.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Clang最有趣的特点之一与错误处理相关。错误处理包括错误检测、显示相应的错误消息以及潜在的错误恢复。后者在Clang AST方面尤其引人入胜。当Clang在遇到编译错误时不会停止，而是继续编译以检测更多问题时，就会发生错误恢复。
- en: Such behavior is beneficial for various reasons. The most evident one is user
    convenience. When programmers compile a program, they typically prefer to be informed
    about as many errors as possible in a single compilation run. If the compiler
    were to stop at the first error, the programmer would have to correct that error,
    recompile, then address the subsequent error, and recompile again, and so forth.
    This iterative process can be tedious and frustrating, especially with larger
    code bases or intricate errors. While this behavior is particularly useful for
    compiled languages such as C/C++, it’s worth noting that interpreted languages
    also exhibit this behavior, which can assist users in handling errors step by
    step.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为有各种好处。最明显的一个是用户便利性。当程序员编译程序时，他们通常希望在一次编译运行中尽可能多地了解错误。如果编译器在第一个错误处停止，程序员将不得不纠正该错误，重新编译，然后解决后续的错误，并再次重新编译，依此类推。这个过程可能会很繁琐和令人沮丧，尤其是在较大的代码库或复杂的错误中。虽然这种行为对编译语言如C/C++特别有用，但值得注意的是，解释型语言也表现出这种行为，这可以帮助用户逐步处理错误。
- en: Another compelling reason centers on IDE integration, which will be discussed
    in more detail in [*Chapter** 8*](B19722_08.xhtml#x1-1520008)*, IDE Support and
    Clangd*. IDEs offer navigation support coupled with an integrated compiler. We
    will explore `clangd` as one such tool. Editing code in IDEs often leads to compilation
    errors. Most errors are confined to specific sections of the code, and it might
    be suboptimal to cease navigation in such cases.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个令人信服的原因集中在IDE集成上，这将在[*第8章*](B19722_08.xhtml#x1-1520008)中更详细地讨论，即IDE支持和Clangd。IDEs提供结合了集成编译器的导航支持。我们将探讨`clangd`作为此类工具之一。在IDE中编辑代码通常会导致编译错误。大多数错误局限于代码的特定部分，在这种情况下停止导航可能不是最优的。
- en: Clang employs various techniques for error recovery. For the syntax stage of
    parsing, it utilizes heuristics; for instance, if a user forgets to insert a semicolon,
    Clang may attempt to add it as part of the recovery process. The Recovery Phase
    can be abbreviated as DIRT where D stands for Delete a character (for example,
    an extra semicolon), I stands for Insert a character (as in the example presented),
    R stands for Replace (which replaces a character to match a particular token),
    and T stands for Transpose (rearranging two characters to match a token).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Clang在错误恢复方面采用了各种技术。对于解析的语法阶段，它使用启发式方法；例如，如果用户忘记插入分号，Clang可能会尝试将其作为恢复过程的一部分添加。恢复阶段可以缩写为DIRT，其中D代表删除一个字符（例如，多余的分号），I代表插入一个字符（如示例所示），R代表替换（替换一个字符以匹配特定令牌），T代表转置（重新排列两个字符以匹配令牌）。
- en: Clang performs full recovery if it’s possible and produces an AST that corresponds
    to the modified file with all compilation errors fixed. The most interesting case
    is when full recovery is not possible, and Clang implements unique techniques
    to manage recovery while AST is created.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能，Clang将执行完全恢复，并生成一个与修改后的文件相对应的AST，其中所有编译错误都已修复。最有趣的情况是当无法进行完全恢复时，Clang在创建AST时实施独特的错误恢复管理技术。
- en: 'Consider a program (maxerr.cpp) that is syntactically correct but has a semantic
    error. For example, it might use an undeclared variable. In this program, refer
    to *Line 3* where the undeclared variable `ab` is used:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个程序（maxerr.cpp），它在语法上是正确的，但存在语义错误。例如，它可能使用了未声明的变量。在这个程序中，参考*第3行*，其中使用了未声明的变量`ab`：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**Figure 3.33**: The maxerr.cpp test program with a semantic error – undeclared
    variable'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.33**：包含语义错误（未声明的变量）的maxerr.cpp测试程序'
- en: 'We are interested in the AST result produced by Clang, and we will use `clang-query`
    to examine it, which can be run as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对Clang生成的AST结果感兴趣，我们将使用`clang-query`来检查它，可以按照以下方式运行：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**Figure 3.34**: Compilation error example'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.34**：编译错误示例'
- en: From the output, we can see that clang-query displayed a compilation error detected
    by the compiler. It’s worth noting that, despite this, an AST was produced for
    the program, and we can examine it. We are particularly interested in the return
    statements and can use the corresponding matcher to highlight the relevant parts
    of the AST.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以看到clang-query显示了编译器检测到的编译错误。值得注意的是，尽管如此，程序仍然生成了一个AST，我们可以检查它。我们特别感兴趣的是返回语句，并可以使用相应的匹配器突出显示AST的相关部分。
- en: 'We will also set up the output to produce the AST and search for return statements
    that are of interest to us:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将设置输出以生成AST并搜索我们感兴趣的返回语句：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**Figure 3.35**: Setting the matcher for return statement'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.35**：设置返回语句的匹配器'
- en: 'The resulting output identifies two return statements in our program: the first
    match on *Line 5* and the second match on *Line 3*:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的输出识别出我们程序中的两个返回语句：第一个匹配在*第5行*，第二个匹配在*第3行*：
- en: '[PRE37]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Figure 3.36**: ReturnStmt node matches at maxerr.cpp test program'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.36**：在maxerr.cpp测试程序中匹配ReturnStmt节点'
- en: 'As we can see, the first match corresponds to semantically correct code on
    *Line 5* and contains a reference to the `a` parameter. The second match is for
    *Line 3*, which has a compilation error. Notably, Clang has inserted a special
    type of AST node: `RecoveryExpr`. It’s worth noting that, in certain situations,
    Clang might produce an incomplete AST. This can cause issues with Clang tools,
    such as lint checks. In instances of compilation errors, lint checks might yield
    unexpected results because Clang couldn’t recover accurately from the compilation
    errors. We will revisit the problem when exploring the clang-tidy lint check framework
    in [*Chapter** 5*](B19722_05.xhtml#x1-990005)*, Clang-Tidy Linter Framework*.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，第一个匹配对应于第 5 行的语义正确代码，并包含对 `a` 参数的引用。第二个匹配对应于第 3 行，该行存在编译错误。值得注意的是，Clang
    插入了一种特殊的 AST 节点：`RecoveryExpr`。值得注意的是，在某些情况下，Clang 可能会生成一个不完整的 AST。这可能会影响 Clang
    工具，如 lint 检查。在编译错误的情况下，lint 检查可能会产生意外的结果，因为 Clang 无法从编译错误中准确恢复。我们将在探索第 5 章（Clang-Tidy
    Linter Framework）的 clang-tidy lint 检查框架时重新审视这个问题。
- en: 3.8 Summary
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.8 摘要
- en: We explored the Clang AST, a major instrument for creating various Clang tools.
    We learned about the architectural design principles chosen for the implementation
    of the Clang AST and investigated different methods for AST traversal. We delved
    into specialized traversal techniques, such as those for C/C++ declarations, and
    also looked into more universal techniques that employ recursive visitors and
    Clang AST matchers. Our exploration concluded with the `clang-query` tool and
    how it can be used for Clang AST exploration. Specifically, we used it to understand
    how Clang processes compilation errors.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了 Clang AST，这是创建各种 Clang 工具的主要工具。我们了解了 Clang AST 实现所选择的架构设计原则，并研究了 AST 遍历的不同方法。我们深入研究了专门的遍历技术，例如针对
    C/C++ 声明的遍历技术，还探讨了更通用的技术，这些技术使用了递归访问者和 Clang AST 匹配器。我们的探索以 `clang-query` 工具结束，并讨论了如何使用它来探索
    Clang AST。具体来说，我们用它来理解 Clang 如何处理编译错误。
- en: The next chapter will discuss the basic libraries used in Clang and LLVM development.
    We will explore the LLVM code style and foundational Clang/LLVM classes, such
    as `SourceManager` and `SourceLocation`. We will also cover the TableGen library,
    which is used for code generation, and the LLVM Integration Test (LIT) framework.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将讨论在 Clang 和 LLVM 开发中使用的库。我们将探讨 LLVM 代码风格和基础 Clang/LLVM 类，例如 `SourceManager`
    和 `SourceLocation`。我们还将介绍用于代码生成的 TableGen 库和 LLVM 集成测试 (LIT) 框架。
- en: 3.9 Further reading
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.9 进一步阅读
- en: 'How to write RecursiveASTVisitor: [https://clang.llvm.org/docs/RAVFrontendAction.html](https://clang.llvm.org/docs/RAVFrontendAction.html)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如何编写 RecursiveASTVisitor: [https://clang.llvm.org/docs/RAVFrontendAction.html](https://clang.llvm.org/docs/RAVFrontendAction.html)'
- en: 'AST Matcher Reference: [https://clang.llvm.org/docs/LibASTMatchersReference.html](https://clang.llvm.org/docs/LibASTMatchersReference.html)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'AST 匹配器参考: [https://clang.llvm.org/docs/LibASTMatchersReference.html](https://clang.llvm.org/docs/LibASTMatchersReference.html)'
