["```cpp\nconst aiScene* scene = aiImportFile(“deps/src/glTF-Sample-\n  Assets/Models/DamagedHelmet/glTF/DamagedHelmet.gltf”,\n    aiProcess_Triangulate);\n```", "```cpp\nstruct Vertex {\n  vec3 position;\n  vec4 color;\n  vec2 uv;\n};\n```", "```cpp\nstd::vector<Vertex> vertices;\nvertices.reserve(mesh->mNumVertices);\nfor (unsigned int i = 0; i != mesh->mNumVertices; i++) {\n  const aiVector3D v = mesh->mVertices[i];\n  const aiColor4D  c = mesh->mColors[0] ?\n    mesh->mColors[0][i] : aiColor4D(1, 1, 1, 1);\n  const aiVector3D t = mesh->mTextureCoords[0] ?\n    mesh->mTextureCoords[0][i] : aiVector3D(0, 0, 0);\n  vertices.push_back({ .position = vec3(v.x, v.y, v.z),\n                       .color    = vec4(c.r, c.g, c.b, c.a),\n                       .uv       = vec2(t.x, 1.0f - t.y) });\n}\n```", "```cpp\nstd::vector<uint32_t> indices;\nindices.reserve(3 * mesh->mNumFaces);\nfor (unsigned int i = 0; i != mesh->mNumFaces; i++) {\n  for (int j = 0; j != 3; j++)\n    indices.push_back(mesh->mFaces[i].mIndices[j]);\n}\n```", "```cpp\nlvk::Holder<lvk::TextureHandle> baseColorTexture =\n  loadTexture(ctx, “deps/src/glTF-Sample-\n    Assets/Models/DamagedHelmet/glTF/Default_albedo.jpg”);\n```", "```cpp\nlvk::Holder<lvk::BufferHandle> vertexBuffer = ctx->createBuffer(\n  { .usage     = lvk::BufferUsageBits_Vertex,\n    .storage   = lvk::StorageType_Device,\n    .size      = sizeof(Vertex) * vertices.size(),\n    .data      = vertices.data(),\n    .debugName = “Buffer: vertex” });\nlvk::Holder<lvk::BufferHandle> indexBuffer = ctx->createBuffer(\n  { .usage     = lvk::BufferUsageBits_Index,\n    .storage   = lvk::StorageType_Device,\n    .size      = sizeof(uint32_t) * indices.size(),\n    .data      = indices.data(),\n    .debugName = “Buffer: index” });\n```", "```cpp\nconst lvk::VertexInput vdesc = {\n  .attributes    = { { .location = 0,\n                       .format = lvk::VertexFormat::Float3,\n                       .offset = 0  },\n                   {   .location = 1,\n                       .format = lvk::VertexFormat::Float4,\n                       .offset = sizeof(vec3) },\n                   {   .location = 2,\n                       .format = lvk::VertexFormat::Float2,\n                       .offset = sizeof(vec3) + sizeof(vec4) }},\n  .inputBindings = { { .stride = sizeof(Vertex) } }};\nlvk::Holder<lvk::ShaderModuleHandle> vert =\n  loadShaderModule(ctx, “Chapter06/01_Unlit/src/main.vert”);\nlvk::Holder<lvk::ShaderModuleHandle> frag =\n  loadShaderModule(ctx, “Chapter06/01_Unlit/src/main.frag”);\nlvk::Holder<lvk::RenderPipelineHandle> pipelineSolid =\n  ctx->createRenderPipeline({\n    .vertexInput = vdesc,\n    .smVert      = vert,\n    .smFrag      = frag,\n    .color       = {{ .format = ctx->getSwapchainFormat() }},\n    .depthFormat = app.getDepthFormat(),\n    .cullMode    = lvk::CullMode_Back });\n```", "```cpp\nconst mat4 m1 = glm::rotate(\n  mat4(1.0f), glm::radians(+90.0f), vec3(1, 0, 0));\nconst mat4 m2 = glm::rotate(\n  mat4(1.0f), (float)glfwGetTime(), vec3(0.0f, 1.0f, 0.0f));\nconst mat4 v = app.camera_._.getViewMatrix();\nconst mat4 p = glm::perspective(\n  45.0f, aspectRatio, 0.1f, 1000.0f);\nstruct PerFrameData {\n  mat4 mvp;\n  vec4 baseColor;\n  uint32_t baseTextureId;\n} perFrameData = {\n  .mvp           = p * v * m2 * m1,\n  .baseColor     = vec4(1, 1, 1, 1),\n  .baseTextureId = baseColorTexture.index(),\n};\n```", "```cpp\nconst lvk::RenderPass renderPass = {\n  .color = { { .loadOp = lvk::LoadOp_Clear,\n               .clearColor = { 1.0f, 1.0f, 1.0f, 1.0f } } },\n  .depth = { .loadOp = lvk::LoadOp_Clear,\n             .clearDepth = 1.0f }\n};\nconst lvk::Framebuffer framebuffer = {\n  .color  = {{ .texture = ctx->getCurrentSwapchainTexture() }},\n  .depthStencil = { .texture = app.getDepthTexture() },\n};\nlvk::ICommandBuffer& buf = ctx->acquireCommandBuffer();\nbuf.cmdBeginRendering(renderPass, framebuffer);\nbuf.cmdBindVertexBuffer(0, vertexBuffer, 0);\nbuf.cmdBindIndexBuffer(indexBuffer, lvk::IndexFormat_UI32);\nbuf.cmdBindRenderPipeline(pipelineSolid);\nbuf.cmdBindDepthState({ .compareOp = lvk::CompareOp_Less,\n                        .isDepthWriteEnabled = true });\nbuf.cmdPushConstants(perFrameData);\nbuf.cmdDrawIndexed(indices.size());\n```", "```cpp\napp.drawGrid(buf, p, vec3(0, -1.0f, 0));\napp.imgui_->beginFrame(framebuffer);\napp.drawFPS();\napp.imgui_->endFrame(buf);\nbuf.cmdEndRendering();\nctx->submit(buf, ctx->getCurrentSwapchainTexture());\n```", "```cpp\nlayout(push_constant) uniform PerFrameData {\n  mat4 MVP;\n  vec4 baseColor;\n  uint textureId;\n};\nlayout (location = 0) in vec3 pos;\nlayout (location = 1) in vec4 color;\nlayout (location = 2) in vec2 uv;\nlayout (location = 0) out vec2 outUV;\nlayout (location = 1) out vec4 outVertexColor;\nvoid main() {\n  gl_Position = MVP * vec4(pos, 1.0);\n  outUV = uv;\n  outVertexColor = color * baseColor;\n}\n```", "```cpp\nlayout(push_constant) uniform PerFrameData {\n  mat4 MVP;\n  vec4 baseColor;\n  uint textureId;\n};\nlayout (location = 0) in vec2 uv;\nlayout (location = 1) in vec4 vertexColor;\nlayout (location=0) out vec4 out_FragColor;\nvoid main() {\n  vec4 baseColorTexture = textureBindless2D(textureId, 0, uv);\n  out_FragColor =\n    textureBindless2D(textureId, 0, uv) * vertexColor;\n}\n```", "```cpp\nconst uint32_t kBrdfW      = 256;\nconst uint32_t kBrdfH      = 256;\nconst uint32_t kNumSamples = 1024;\nconst uint32_t kBufferSize =\n  4u * sizeof(uint16_t) * kBrdfW * kBrdfH;\nvoid calculateLUT(const std::unique_ptr<lvk::IContext>& ctx,\n  void* output, uint32_t size)\n{\n  lvk::Holder<lvk::ShaderModuleHandle> comp = loadShaderModule(\n    ctx, “Chapter06/02_BRDF_LUT/src/main.comp”);\n  lvk:Holder<lvk::ComputePipelineHandle> computePipelineHandle =\n    ctx->createComputePipeline({\n      .smComp = comp,\n      .specInfo = {.entries = {{ .constantId = 0,\n                                 .size = sizeof(kNumSamples) }},\n                   .data     = &kNumSamples,\n                   .dataSize = sizeof(kNumSamples),},\n  });\n```", "```cpp\n lvk::Holder<lvk::BufferHandle> dstBuffer = ctx->createBuffer({\n    .usage     = lvk::BufferUsageBits_Storage,\n    .storage   = lvk::StorageType_HostVisible,\n    .size      = size,\n    .debugName = “Compute: BRDF LUT” });\n```", "```cpp\n lvk::ICommandBuffer& buf = ctx->acquireCommandBuffer();\n  buf.cmdBindComputePipeline(computePipelineHandle);\n  struct {\n    uint32_t w = kBrdfW;\n    uint32_t h = kBrdfH;\n    uint64_t addr;\n  } pc {\n    .addr = ctx->gpuAddress(dstBuffer),\n  };\n  buf.cmdPushConstants(pc);\n  buf.cmdDispatchThreadGroups({ kBrdfW / 16, kBrdfH / 16, 1 });\n```", "```cpp\n ctx->wait(ctx->submit(buf));\n  memcpy(output, ctx->getMappedPtr(dstBuffer), kBufferSize);\n}\n```", "```cpp\nlayout (local_size_x=16, local_size_y=16, local_size_z=1) in;\nlayout (constant_id = 0) const uint NUM_SAMPLES = 1024u;\nlayout(std430, buffer_reference) readonly buffer Data {\n  float16_t floats[];\n};\n```", "```cpp\nlayout (push_constant) uniform constants {\n  uint BRDF_W;\n  uint BRDF_H;\n  Data data;\n};\nconst float PI = 3.1415926536;\n```", "```cpp\nvoid main() {\n  vec2 uv;\n  uv.x = (float(gl_GlobalInvocationID.x) + 0.5) / float(BRDF_W);\n  uv.y = (float(gl_GlobalInvocationID.y) + 0.5) / float(BRDF_H);\n```", "```cpp\n vec3 v = BRDF(uv.x, 1.0 - uv.y);\n  uint offset = gl_GlobalInvocationID.y * BRDF_W +\n                gl_GlobalInvocationID.x;\n  data.floats[offset * 4 + 0] = float16_t(v.x);\n  data.floats[offset * 4 + 1] = float16_t(v.y);\n  data.floats[offset * 4 + 2] = float16_t(v.z);\n}\n```", "```cpp\nvec2 hammersley2d(uint i, uint N) {\n  uint bits = (i << 16u) | (i >> 16u);\n  bits = ((bits & 0x55555555u)<<1u)|((bits & 0xAAAAAAAAu)>>1u);\n  bits = ((bits & 0x33333333u)<<2u)|((bits & 0xCCCCCCCCu)>>2u);\n  bits = ((bits & 0x0F0F0F0Fu)<<4u)|((bits & 0xF0F0F0F0u)>>4u);\n  bits = ((bits & 0x00FF00FFu)<<8u)|((bits & 0xFF00FF00u)>>8u);\n  float rdi = float(bits) * 2.3283064365386963e-10;\n  return vec2(float(i) / float(N), rdi);\n}\n```", "```cpp\nfloat random(vec2 co) {\n  float a  = 12.9898;\n  float b  = 78.233;\n  float c  = 43758.5453;\n  float dt = dot( co.xy ,vec2(a,b) );\n  float sn = mod(dt, 3.14);\n  return fract(sin(sn) * c);\n}\n```", "```cpp\nvec3 importanceSample_GGX(vec2 Xi, float roughness, vec3 normal)\n{\n  float alpha = roughness * roughness;\n  float phi = 2.0 * PI * Xi.x + random(normal.xz) * 0.1;\n  float cosTheta =\n    sqrt((1.0 - Xi.y) / (1.0 + (alpha*  alpha - 1.0) * Xi.y));\n  float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n  vec3 H =\n    vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n```", "```cpp\n vec3 up = abs(normal.z) < 0.999 ?\n    vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n  vec3 tangentX = normalize(cross(up, normal));\n  vec3 tangentY = normalize(cross(normal, tangentX));\n  return normalize(tangentX * H.x +\n                   tangentY * H.y +\n                     normal * H.z);\n}\n```", "```cpp\nfloat G_SchlicksmithGGX(\n  float dotNL, float dotNV, float roughness)\n{\n  float k = (roughness * roughness) / 2.0;\n  float GL = dotNL / (dotNL * (1.0 - k) + k);\n  float GV = dotNV / (dotNV * (1.0 - k) + k);\n  return GL * GV;\n}\n```", "```cpp\nfloat V_Ashikhmin(float NdotL, float NdotV) {\n  return clamp(\n    1.0 / (4.0 * (NdotL + NdotV - NdotL * NdotV)), 0.0, 1.0);\n}\nfloat D_Charlie(float sheenRoughness, float NdotH) {\n  sheenRoughness = max(sheenRoughness, 0.000001); // clamp (0,1]\n  float invR = 1.0 / sheenRoughness;\n  float cos2h = NdotH * NdotH;\n  float sin2h = 1.0 - cos2h;\n  return (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * PI);\n}\n```", "```cpp\nvec3 importanceSample_Charlie(\n  vec2 Xi, float roughness, vec3 normal)\n{\n  float alpha = roughness * roughness;\n  float phi = 2.0 * PI * Xi.x;\n  float sinTheta = pow(Xi.y, alpha / (2.0*  alpha + 1.0));\n  float cosTheta = sqrt(1.0 - sinTheta * sinTheta);\n  vec3 H = vec3(\n    sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n  vec3 up = abs(normal.z) < 0.999 ?\n    vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n  vec3 tangentX = normalize(cross(up, normal));\n  vec3 tangentY = normalize(cross(normal, tangentX));\n  return normalize(tangentX * H.x +\n                   tangentY * H.y +\n                     normal * H.z);\n}\n```", "```cpp\nvec3 BRDF(float NoV, float roughness) {\n  const vec3 N = vec3(0.0, 0.0, 1.0);\n  vec3 V = vec3(sqrt(1.0 - NoV*  NoV), 0.0, NoV);\n  vec3 LUT = vec3(0.0);\n```", "```cpp\n for (uint i = 0u; i < NUM_SAMPLES; i++) {\n    vec2 Xi = hammersley2d(i, NUM_SAMPLES);\n    vec3 H = importanceSample_GGX(Xi, roughness, N);\n    vec3 L = 2.0 * dot(V, H) * H - V;\n    float dotNL = max(dot(N, L), 0.0);\n    float dotNV = max(dot(N, V), 0.0);\n    float dotVH = max(dot(V, H), 0.0); \n    float dotNH = max(dot(H, N), 0.0);\n    if (dotNL > 0.0) {\n      float G = G_SchlicksmithGGX(dotNL, dotNV, roughness);\n      float G_Vis = (G * dotVH) / (dotNH * dotNV);\n      float Fc = pow(1.0 - dotVH, 5.0);\n      LUT.rg += vec2((1.0 - Fc) * G_Vis, Fc * G_Vis);\n    }\n  }\n```", "```cpp\n for(uint i = 0u; i < NUM_SAMPLES; i++) {\n    vec2 Xi = hammersley2d(i, NUM_SAMPLES);\n    vec3 H = importanceSample_Charlie(Xi, roughness, N);\n    vec3 L = 2.0 * dot(V, H) * H - V;\n    float dotNL = max(dot(N, L), 0.0);\n    float dotNV = max(dot(N, V), 0.0);\n    float dotVH = max(dot(V, H), 0.0); \n    float dotNH = max(dot(H, N), 0.0);\n    if (dotNL > 0.0) {\n      float sheenDistribution = D_Charlie(roughness, dotNH);\n      float sheenVisibility = V_Ashikhmin(dotNL, dotNV);\n      LUT.b +=\n        sheenVisibility * sheenDistribution * dotNL * dotVH;\n    }\n  }\n  return LUT / float(NUM_SAMPLES);\n}\n```", "```cpp\nint main() {\n  std::unique_ptr<lvk::IContext> ctx =\n    lvk::createVulkanContextWithSwapchain(nullptr, 0, 0, {});\n  ktxTextureCreateInfo createInfo = {\n    .glInternalformat = GL_RGBA16F,\n    .vkFormat         = VK_FORMAT_R16G16B16A16_SFLOAT,\n    .baseWidth        = kBrdfW,\n    .baseHeight       = kBrdfH,\n    .baseDepth        = 1u,\n    .numDimensions    = 2u,\n    .numLevels        = 1,\n    .numLayers        = 1u,\n    .numFaces         = 1u,\n    .generateMipmaps  = KTX_FALSE,\n  };\n  ktxTexture1* lutTexture = nullptr;\n  ktxTexture1_Create(\n    &createInfo, KTX_TEXTURE_CREATE_ALLOC_STORAGE, &lutTexture);\n  calculateLUT(ctx, lutTexture->pData, kBufferSize);\n  ktxTexture_WriteToNamedFile(\n    ktxTexture(lutTexture), “data/brdfLUT.ktx”);\n  ktxTexture_Destroy(ktxTexture(lutTexture));\n  return 0;\n}\n```", "```cpp\nvec3 EnvBRDFApprox(vec3 specularColor, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4( 1,  0.0425,  1.04, -0.04 );\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  return specularColor * AB.x + AB.y;\n}\n```", "```cpp\nvoid prefilterCubemap(\n  const std::unique_ptr<lvk::IContext>& ctx,\n  ktxTexture1* cube, const char* envPrefilteredCubemap,\n  lvk::TextureHandle envMapCube,\n  Distribution distribution,\n  uint32_t sampler,\n  uint32_t sampleCount)\n{\n  lvk::Holder<lvk::TextureHandle> prefilteredMapCube =\n    ctx->createTexture({\n        .type         = lvk::TextureType_Cube,\n        .format       = lvk::Format_RGBA_F32,\n        .dimensions   = {cube->baseWidth, cube->baseHeight, 1},\n        .usage        = lvk::TextureUsageBits_Sampled |\n                        lvk::TextureUsageBits_Attachment,\n        .numMipLevels = (uint32_t)cube->numLevels,\n        .debugName    = envPrefilteredCubemap,\n      }, envPrefilteredCubemap);\n```", "```cpp\n lvk::Holder<lvk::ShaderModuleHandle> vert = loadShaderModule(\n    ctx, “Chapter06/03_FilterEnvmap/src/main.vert”);\n  lvk::Holder<lvk::ShaderModuleHandle> frag = loadShaderModule(\n    ctx, “Chapter06/03_FilterEnvmap/src/main.frag”);\n  lvk::Holder<lvk::RenderPipelineHandle> pipelineSolid =\n    ctx->createRenderPipeline({\n      .smVert   = vert,\n      .smFrag   = frag,\n      .color    = { { .format =\n                        ctx->getFormat(prefilteredMapCube) } },\n      .cullMode = lvk::CullMode_Back,\n  });\n```", "```cpp\n lvk::ICommandBuffer& buf = ctx,->acquireCommandBuffer();\n  for (uint32_t mip = 0; mip < cube->numLevels; mip++) {\n    for (uint32_t face = 0; face < 6; face++) {\n```", "```cpp\n buf.cmdBeginRendering(\n        { .color = { { .loadOp     = lvk::LoadOp_Clear,\n                       .layer      = (uint8_t)face,\n                       .level      = (uint8_t)mip,\n                       .clearColor = { 1.0f, 1.0f, 1.0f, 1.0f },\n                   } } },\n        { .color = {{ .texture = prefilteredMapCube }} });\n      buf.cmdBindRenderPipeline(pipelineSolid);\n      buf.cmdBindDepthState({});\n```", "```cpp\n struct PerFrameData {\n        uint32_t face;\n        float roughness;\n        uint32_t sampleCount;\n        uint32_t width;\n        uint32_t envMap;\n        uint32_t distribution;\n        uint32_t sampler;\n      } perFrameData = {\n        .face         = face,\n        .roughness    = (float)(mip) / (cube->numLevels - 1),\n        .sampleCount  = sampleCount,\n        .width        = cube->baseWidth,\n        .envMap       = envMapCube.index(),\n        .distribution = uint32_t(distribution),\n        .sampler      = sampler,\n      };\n      buf.cmdPushConstants(perFrameData);\n```", "```cpp\n buf.cmdDraw(3);\n      buf.cmdEndRendering();\n    }\n  }\n  ctx->submit(buf);\n  ... // save results to a .ktx file\n}\n```", "```cpp\nvoid main() {\n  vec2 newUV = uv * 2.0 - vec2(1.0);\n  vec3 scan = uvToXYZ(perFrameData.face, newUV);\n  vec3 direction = normalize(scan);\n  out_FragColor = vec4(filterColor(direction), 1.0);\n}\n```", "```cpp\nvec3 uvToXYZ(uint face, vec2 uv) {\n  if (face == 0) return vec3(   1., uv.y,  uv.x);\n  if (face == 1) return vec3(  -1., uv.y, -uv.x);\n  if (face == 2) return vec3(+uv.x,   1.,  uv.y);  \n  if (face == 3) return vec3(+uv.x,  -1., -uv.y);\n  if (face == 4) return vec3(+uv.x, uv.y,   -1.);\n  if (face == 5) return vec3(-uv.x, uv.y,    1.);\n}\n```", "```cpp\nvec3 filterColor(vec3 N) {\n  vec3  color  = vec3(0.f);\n  float weight = 0.0f;\n  for(uint i = 0; i < perFrameData.sampleCount; i++) {\n    vec4 importanceSample =\n      getImportanceSample(i, N, perFrameData.roughness);\n    vec3 H = vec3(importanceSample.xyz);\n    float pdf = importanceSample.w;\n```", "```cpp\n float lod = computeLod(pdf);\n    if (perFrameData.distribution == cLambertian) {\n      vec3 lambertian = textureBindlessCubeLod(\n        perFrameData.envMap,\n        perFrameData.samplerIdx, H, lod).xyz;\n      color += lambertian;\n    } else if (perFrameData.distribution == cGGX ||\n               perFrameData.distribution == cCharlie) {\n      vec3 V = N;\n      vec3 L = normalize(reflect(-V, H));\n      float NdotL = dot(N, L);\n      if (NdotL > 0.0) {\n        if (perFrameData.roughness == 0.0) lod = 0.0;\n        vec3 sampleColor = textureBindlessCubeLod(\n          perFrameData.envMap,\n          perFrameData.samplerIdx, L, lod).xyz;\n        color += sampleColor * NdotL;\n        weight += NdotL;\n      }\n    }\n  }\n```", "```cpp\n color /= (weight != 0.0f) ?\n    weight : float(perFrameData.sampleCount);\n  return color.rgb;\n}\n```", "```cpp\nstruct MicrofacetDistributionSample {\n  float pdf;\n  float cosTheta;\n  float sinTheta;\n  float phi;\n};\nvec4 getImportanceSample(\n  uint sampleIndex, vec3 N, float roughness)\n{\n  vec2 xi = hammersley2d(sampleIndex, perFrameData.sampleCount);\n  MicrofacetDistributionSample importanceSample;\n```", "```cpp\n if (perFrameData.distribution == cLambertian)\n    importanceSample = Lambertian(xi, roughness);\n  else if (perFrameData.distribution == cGGX)\n    importanceSample = GGX(xi, roughness);\n  else if (perFrameData.distribution == cCharlie)\n    importanceSample = Charlie(xi, roughness);\n```", "```cpp\n vec3 localSpaceDirection = normalize(vec3(\n    importanceSample.sinTheta * cos(importanceSample.phi), \n    importanceSample.sinTheta * sin(importanceSample.phi), \n    importanceSample.cosTheta));\n  mat3 TBN = generateTBN(N);\n  vec3 direction = TBN * localSpaceDirection;\n  return vec4(direction, importanceSample.pdf);\n}\n```", "```cpp\nfloat computeLod(float pdf) {\n  float w = float(perFrameData.width);\n  float h = float(perFrameData.height);\n  float sampleCount = float(perFrameData.sampleCount);\n  return 0.5 * log2( 6.0 * w * h / (sampleCount * pdf));\n}\n```", "```cpp\nstruct GLTFGlobalSamplers {\n  GLTFGlobalSamplers(const std::unique_ptr<lvk::IContext>& ctx);\n  lvk::Holder<lvk::SamplerHandle> clamp;\n  lvk::Holder<lvk::SamplerHandle> wrap;\n  lvk::Holder<lvk::SamplerHandle> mirror;\n};\n```", "```cpp\nGLTFGlobalSamplers(const std::unique_ptr<lvk::IContext>& ctx) {\n  clamp = ctx->createSampler({\n    .minFilter = lvk::SamplerFilter::SamplerFilter_Linear,\n    .magFilter = lvk::SamplerFilter::SamplerFilter_Linear,\n    .mipMap    = lvk::SamplerMip::SamplerMip_Linear,\n    .wrapU     = lvk::SamplerWrap::SamplerWrap_Clamp,\n    .wrapV     = lvk::SamplerWrap::SamplerWrap_Clamp,\n    .wrapW     = lvk::SamplerWrap::SamplerWrap_Clamp,\n    .debugName = “Clamp Sampler” });\n  wrap = ctx->createSampler({\n    .minFilter = lvk::SamplerFilter::SamplerFilter_Linear,\n    .magFilter = lvk::SamplerFilter::SamplerFilter_Linear,\n    .mipMap    = lvk::SamplerMip::SamplerMip_Linear,\n    .wrapU     = lvk::SamplerWrap::SamplerWrap_Repeat,\n    .wrapV     = lvk::SamplerWrap::SamplerWrap_Repeat,\n    .wrapW     = lvk::SamplerWrap::SamplerWrap_Repeat,\n    .debugName = “Wrap Sampler” });\n  mirror = ctx->createSampler({\n    .minFilter = lvk::SamplerFilter::SamplerFilter_Linear,\n    .magFilter = lvk::SamplerFilter::SamplerFilter_Linear,\n    .mipMap    = lvk::SamplerMip::SamplerMip_Linear,\n    .wrapU     = lvk::SamplerWrap::SamplerWrap_MirrorRepeat,\n    .wrapV     = lvk::SamplerWrap::SamplerWrap_MirrorRepeat,\n    .debugName = “Mirror Sampler” });\n  }\n```", "```cpp\nstruct EnvironmentMapTextures {\n  lvk::Holder<lvk::TextureHandle> texBRDF_LUT;\n  lvk::Holder<lvk::TextureHandle> envMapTexture;\n  lvk::Holder<lvk::TextureHandle> envMapTextureCharlie;\n  lvk::Holder<lvk::TextureHandle> envMapTextureIrradiance;\n```", "```cpp\n explicit EnvironmentMapTextures(\n    const std::unique_ptr<lvk::IContext>& ctx) :\n  EnvironmentMapTextures(ctx,\n    “data/brdfLUT.ktx”,\n    “data/piazza_bologni_1k_prefilter.ktx”,\n    “data/piazza_bologni_1k_irradiance.ktx”,\n    “data/piazza_bologni_1k_charlie.ktx”) {}\n  EnvironmentMapTextures(\n    const std::unique_ptr<lvk::IContext>& ctx,\n    const char* brdfLUT,\n    const char* prefilter,\n    const char* irradiance,\n    const char* prefilterCharlie = nullptr)\n  {\n    texBRDF_LUT = loadTexture(ctx, brdfLUT, lvk::TextureType_2D);\n    envMapTexture = loadTexture(\n      ctx, prefilter, lvk::TextureType_Cube);\n    envMapTextureIrradiance = loadTexture(\n      ctx, irradiance, lvk::TextureType_Cube);\n  }\n};\n```", "```cpp\nstruct GLTFMaterialTextures {\n  // MetallicRoughness / SpecularGlossiness     \n  lvk::Holder<lvk::TextureHandle> baseColorTexture;\n  lvk::Holder<lvk::TextureHandle> surfacePropertiesTexture;\n  // Common properties\n  lvk::Holder<lvk::TextureHandle> normalTexture;\n  lvk::Holder<lvk::TextureHandle> occlusionTexture;\n  lvk::Holder<lvk::TextureHandle> emissiveTexture;\n  // Sheen\n  lvk::Holder<lvk::TextureHandle> sheenColorTexture;\n  lvk::Holder<lvk::TextureHandle> sheenRoughnessTexture;\n  … many other textures go here\n}\n```", "```cpp\nGLTFMaterialTextures loadMaterialTextures(\n  const std::unique_ptr<lvk::IContext>& ctx,\n  const char* texAOFile,\n  const char* texEmissiveFile,\n  const char* texAlbedoFile,\n  const char* texMeRFile,\n  const char* texNormalFile)\n{\n  glTFMaterialTextures mat;\n  mat.baseColorTexture = loadTexture(\n    ctx, texAlbedoFile, lvk::TextureType_2D, true);\n  if (mat.baseColorTexture.empty()) return {};     \n  mat.occlusionTexture = loadTexture(ctx, texAOFile);\n  if (mat.occlusionTexture.empty()) return {};     \n  mat.normalTexture = loadTexture(ctx, texNormalFile);\n  if (mat.normalTexture.empty()) return {};\n  mat.emissiveTexture = loadTexture(\n    ctx, texEmissiveFile, lvk::TextureType_2D, true);\n  if (mat.emissiveTexture.empty()) return {};\n  mat.surfacePropertiesTexture = loadTexture(ctx, texMeRFile);\n  if (mat.surfacePropertiesTexture.empty()) return {};\n  mat.wasLoaded = true;\n  return mat;\n}} \n```", "```cpp\nstruct MetallicRoughnessData {\n  vec4 baseColorFactor = vec4(1.0f, 1.0f, 1.0f, 1.0f);\n```", "```cpp\n vec4 metallicRoughnessNormalOcclusion =\n    vec4(1.0f, 1.0f, 1.0f, 1.0f);\n  vec4 emissiveFactorAlphaCutoff = vec4(0.0f, 0.0f, 0.0f, 0.5f);\n```", "```cpp\n uint32_t occlusionTexture        = 0;\n  uint32_t occlusionTextureSampler = 0;\n  uint32_t occlusionTextureUV      = 0;\n  uint32_t emissiveTexture         = 0;\n  uint32_t emissiveTextureSampler  = 0;\n  uint32_t emissiveTextureUV       = 0;\n  uint32_t baseColorTexture        = 0;\n  uint32_t baseColorTextureSampler = 0;\n  uint32_t baseColorTextureUV              = 0;\n  uint32_t metallicRoughnessTexture        = 0;\n  uint32_t metallicRoughnessTextureSampler = 0;\n  uint32_t metallicRoughnessTextureUV      = 0;\n  uint32_t normalTexture        = 0;\n  uint32_t normalTextureSampler = 0;\n  uint32_t normalTextureUV      = 0;\n```", "```cpp\n uint32_t alphaMode = 0;\n  enum AlphaMode {\n    AlphaMode_Opaque = 0,\n    AlphaMode_Mask   = 1,\n    AlphaMode_Blend  = 2,\n  };\n};\n```", "```cpp\nMetallicRoughnessDataGPU setupMetallicRoughnessData(\n  const GLTFGlobalSamplers& samplers,\n  const GLTFMaterialTextures& mat,\n  const aiMaterial* mtlDescriptor)\n{\n  MetallicRoughnessDataGPU res = {\n    .baseColorFactor              = vec4(1.0f, 1.0f, 1.0f, 1.0f),\n    .metallicRoughnessNormalOcclusion =\n      vec4(1.0f, 1.0f, 1.0f, 1.0f),\n    .emissiveFactorAlphaCutoff    = vec4(0.0f, 0.0f, 0.0f, 0.5f),\n    .occlusionTexture             = mat.occlusionTexture.index(),\n    .emissiveTexture              = mat.emissiveTexture.index(),\n    .baseColorTexture             = mat.baseColorTexture.index(),\n    .metallicRoughnessTexture     =\n      mat.surfacePropertiesTexture.index(),\n    .normalTexture                = mat.normalTexture.index(),\n  };\n```", "```cpp\n aiColor4D aiColor;\n  if (mtlDescriptor->Get(AI_MATKEY_COLOR_DIFFUSE, aiColor) ==\n      AI_SUCCESS) {\n    res.baseColorFactor = vec4(\n      aiColor.r, aiColor.g, aiColor.b, aiColor.a);\n  }\n  assignUVandSampler(samplers,\n    mtlDescriptor,\n    aiTextureType_DIFFUSE,\n    res.baseColorTextureUV,\n    res.baseColorTextureSampler);\n  … many other glTF material properties are loaded here\n```", "```cpp\nbool assignUVandSampler(\n  const GLTFGlobalSamplers& samplers,\n  const aiMaterial* mtlDescriptor,\n  aiTextureType textureType,\n  uint32_t& uvIndex,\n  uint32_t& textureSampler, int index)\n{\n  aiString path;\n  aiTextureMapMode mapmode[3] = {\n    aiTextureMapMode_Clamp,\n    aiTextureMapMode_Clamp,\n    aiTextureMapMode_Clamp };\n  bool res = mtlDescriptor->GetTexture(textureType, index,\n    &path, 0, &uvIndex, 0, 0, mapmode) == AI_SUCCESS;\n  switch (mapmode[0]) {\n    case aiTextureMapMode_Clamp:\n      textureSampler = samplers.clamp.index();\n      break;\n    case aiTextureMapMode_Wrap:\n      textureSampler = samplers.wrap.index();\n      break;\n    case aiTextureMapMode_Mirror:\n      textureSampler = samplers.mirror.index();\n      break;\n  }\n  return res;\n}\n```", "```cpp\nconst aiScene* scene = aiImportFile(“deps/src/glTF-Sample-\n  Assets/Models/DamagedHelmet/glTF/DamagedHelmet.gltf”,\n  aiProcess_Triangulate);\nconst aiMesh* mesh = scene->mMeshes[0];\nconst vec4 white = vec4(1.0f, 1.0f, 1.0f, 1.0f);\n```", "```cpp\nstruct Vertex {\n  vec3 position;\n  vec3 normal;\n  vec4 color;\n  vec2 uv0;\n  vec2 uv1;\n};\nstd::vector<Vertex> vertices;\nfor (     uint32_t i = 0; i != mesh->mNumVertices; i++) {\n  const aiVector3D v   = mesh->mVertices[i];\n  const aiVector3D n   = mesh->mNormals ?\n    mesh->mNormals[i] : aiVector3D(0.0f, 1.0f, 0.0f);\n  const aiColor4D  c   = mesh->mColors[0] ?\n    mesh->mColors[0][i] : aiColor4D(1.0f, 1.0f, 1.0f, 1.0f);\n```", "```cpp\n const aiVector3D uv0 = mesh->mTextureCoords[0] ?\n    mesh->mTextureCoords[0][i] : aiVector3D(0.0f, 0.0f, 0.0f);\n  const aiVector3D uv1 = mesh->mTextureCoords[1] ?\n    mesh->mTextureCoords[1][i] : aiVector3D(0.0f, 0.0f, 0.0f);\n  vertices.push_back({ .position = vec3(v.x, v.y, v.z),\n                       .normal   = vec3(n.x, n.y, n.z),\n                       .color    = vec4(c.r, c.g, c.b, c.a),\n                       .uv0      = vec2(uv0.x, 1.0f - uv0.y),\n                       .uv1      = vec2(uv1.x, 1.0f - uv1.y) });\n}\n```", "```cpp\nstd::vector<uint32_t> indices;\nfor (unsigned int i = 0; i != mesh->mNumFaces; i++)\n  for (int j = 0; j != 3; j++)\n    indices.push_back(mesh->mFaces[i].mIndices[j]);\nlvk::Holder<BufferHandle> vertexBuffer = ctx->createBuffer({\n  .usage     = lvk::BufferUsageBits_Vertex,\n  .storage   = lvk::StorageType_Device,\n  .size      = sizeof(Vertex) * vertices.size(),\n  .data      = vertices.data(),\n  .debugName = “Buffer: vertex” });\nlvk::Holder<lvk::BufferHandle> indexBuffer = ctx->createBuffer({\n  .usage     = lvk::BufferUsageBits_Index,\n  .storage   = lvk::StorageType_Device,\n  .size      = sizeof(uint32_t) * indices.size(),\n  .data      = indices.data(),\n  .debugName = “Buffer: index” });\n```", "```cpp\nstd::unique_ptr<GLTFMaterialTextures> mat =\n  loadMaterialTextures(ctx,\n    “deps/src/glTF-Sample-Assets/Models/\n      DamagedHelmet/glTF/Default_AO.jpg”,\n    “deps/src/glTF-Sample-Assets/Models/\n      DamagedHelmet/glTF/Default_emissive.jpg”,\n    “deps/src/glTF-Sample-Assets/Models/\n      DamagedHelmet/glTF/Default_albedo.jpg”,\n    “deps/src/glTF-Sample-Assets/Models/\n      DamagedHelmet/glTF/Default_metalRoughness.jpg”,\n    “deps/src/glTF-Sample-Assets/Models/\n      DamagedHelmet/glTF/Default_normal.jpg”);\n```", "```cpp\nGLTFGlobalSamplers samplers(ctx);\nEnvironmentMapTextures envMapTextures(ctx);\n```", "```cpp\n const lvk::VertexInput vdesc = {\n    .attributes    = {\n      { .location=0, .format=VertexFormat::Float3, .offset=0  },\n      { .location=1, .format=VertexFormat::Float3, .offset=12 },\n      { .location=2, .format=VertexFormat::Float4, .offset=24 },\n      { .location=3, .format=VertexFormat::Float2, .offset=40 },\n      { .location=4, .format=VertexFormat::Float2, .offset=48 }},\n    .inputBindings = { { .stride = sizeof(Vertex) } },\n  };\n```", "```cpp\n lvk::Holder<lvk::ShaderModuleHandle> vert = loadShaderModule(\n    ctx, “Chapter06/04_MetallicRoughness/src/main.vert”);\n  lvk::Holder<lvk::ShaderModuleHandle> frag = loadShaderModule(\n    ctx, “Chapter06/04_MetallicRoughness/src/main.frag”);\n  lvk::Holder<lvk::RenderPipelineHandle> pipelineSolid =\n    ctx->createRenderPipeline({\n      .vertexInput = vdesc,\n      .smVert      = vert,\n      .smFrag      = frag,\n      .color       = { { .format = ctx->getSwapchainFormat() } },\n      .depthFormat = app.getDepthFormat(),\n      .cullMode    = lvk::CullMode_Back,\n    });\n```", "```cpp\n const aiMaterial* mtlDescriptor =\n    scene->mMaterials[mesh->mMaterialIndex];\n  const MetallicRoughnessMaterialsPerFrame matPerFrame = {\n    .materials = { setupMetallicRoughnessData(\n                     samplers, mat, mtlDescriptor) },\n  };\n```", "```cpp\n lvk::Holder<lvk::BufferHandle> matBuffer = ctx->createBuffer({\n    .usage     = lvk::BufferUsageBits_Uniform,\n    .storage   = lvk::StorageType_HostVisible,\n    .size      = sizeof(matPerFrame),\n    .data      = &matPerFrame,\n    .debugName = “PerFrame materials” });\n```", "```cpp\n const EnvironmentsPerFrame envPerFrame = {\n    .environments = { {\n      .envMapTexture =\n        envMapTextures.envMapTexture.index(),\n      .envMapTextureSampler = samplers.clamp.index(),\n      .envMapTextureIrradiance =\n        envMapTextures.envMapTextureIrradiance.index(),\n      .envMapTextureIrradianceSampler = samplers.clamp.index(),\n      .lutBRDFTexture = envMapTextures.texBRDF_LUT.index(),\n      .lutBRDFTextureSampler = samplers.clamp.index() } },\n  };\n  lvk::Holder<lvk::BufferHandle> envBuffer = ctx->createBuffer({\n    .usage     = lvk::BufferUsageBits_Uniform,\n    .storage   = lvk::StorageType_HostVisible,\n    .size      = sizeof(envPerFrame),\n    .data      = &envPerFrame,\n    .debugName = “PerFrame materials” });\n```", "```cpp\n struct PerDrawData {\n    mat4 model;\n    mat4 view;\n    mat4 proj;\n    vec4 cameraPos;\n    uint32_t matId;\n    uint32_t envId;\n  };\n  lvk::Holder<lvk::BufferHandle> drawableBuffers[2] = {\n    ctx->createBuffer({\n          .usage     = lvk::BufferUsageBits_Uniform,\n          .storage   = lvk::StorageType_HostVisible,\n          .size      = sizeof(PerDrawData),\n          .debugName = “PerDraw 1” }),\n    ctx->createBuffer({\n          .usage     = lvk::BufferUsageBits_Uniform,\n          .storage   = lvk::StorageType_HostVisible,\n          .size      = sizeof(PerDrawData),\n          .debugName = “PerDraw 2” }),\n  };\n```", "```cpp\nbuf.cmdBindVertexBuffer(0, vertexBuffer, 0);\nbuf.cmdBindIndexBuffer(indexBuffer, lvk::IndexFormat_UI32);\nbuf.cmdBindRenderPipeline(pipelineSolid);\nbuf.cmdBindDepthState({ .compareOp = lvk::CompareOp_Less,\n                        .isDepthWriteEnabled = true });\nstruct PerFrameData {\n  uint64_t draw;\n  uint64_t materials;\n  uint64_t environments;\n} perFrameData = {\n  .draw        = ctx->gpuAddress(drawableBuffers[currentBuffer]),\n  .materials   = ctx->gpuAddress(matBuffer),\n  .environments= ctx->gpuAddress(envBuffer),\n};\nbuf.cmdPushConstants(perFrameData);\nbuf.cmdDrawIndexed(indices.size());\n…\n```", "```cpp\nlayout(std430, buffer_reference) buffer Materials;\nlayout(std430, buffer_reference) buffer Environments;\nlayout(std430, buffer_reference) buffer PerDrawData {\n  mat4 model;\n  mat4 view;\n  mat4 proj;\n  vec4 cameraPos;\n  uint matId;\n  uint envId;\n};\n```", "```cpp\nlayout(push_constant) uniform PerFrameData {\n  PerDrawData drawable;\n  Materials materials;\n  Environments environments;\n} perFrame;\nuint getMaterialId() {\n  return perFrame.drawable.matId;\n}\nuint getEnvironmentId() {\n  return perFrame.drawable.envId;\n}\nMetallicRoughnessDataGPU getMaterial(uint idx) {\n  return perFrame.materials.material[idx];\n}\nEnvironmentMapDataGPU getEnvironment(uint idx) {\n  return perFrame.environments.environment[idx];\n}\n```", "```cpp\nvec4 sampleAO(InputAttributes tc, MetallicRoughnessDataGPU mat) {\n  return textureBindless2D(\n    mat.occlusionTexture,\n    mat.occlusionTextureSampler,\n    tc.uv[mat.occlusionTextureUV]);\n}\nvec4 sampleEmissive(\n  InputAttributes tc, MetallicRoughnessDataGPU mat) {\n  return textureBindless2D(\n      mat.emissiveTexture,\n      mat.emissiveTextureSampler,\n      tc.uv[mat.emissiveTextureUV]\n    ) * vec4(mat.emissiveFactorAlphaCutoff.xyz, 1.0f);\n}\nvec4 sampleAlbedo(\n  InputAttributes tc, MetallicRoughnessDataGPU mat) {\n  return textureBindless2D(\n    mat.baseColorTexture,\n    mat.baseColorTextureSampler,\n    tc.uv[mat.baseColorTextureUV]) * mat.baseColorFactor;\n}\n```", "```cpp\nlayout (location=0) in vec4 uv0uv1;\nlayout (location=1) in vec3 normal;\nlayout (location=2) in vec3 worldPos;\nlayout (location=3) in vec4 color;\nlayout (location=0) out vec4 out_FragColor;\nvoid main() {\n  InputAttributes tc;\n  tc.uv[0] = uv0uv1.xy;\n  tc.uv[1] = uv0uv1.zw;\n  MetallicRoughnessDataGPU mat = getMaterial(getMaterialId());\n  vec4 Kao = sampleAO(tc, mat);\n  vec4 Ke  = sampleEmissive(tc, mat);\n  vec4 Kd  = sampleAlbedo(tc, mat) * color;\n  vec4 mrSample = sampleMetallicRoughness(tc, mat);\n```", "```cpp\n vec3 n = normalize(normal); // world-space normal\n  vec3 normalSample = sampleNormal(tc, getMaterialId()).xyz;\n  n = perturbNormal(\n    n, worldPos, normalSample, getNormalUV(tc, mat));\n  if (!gl_FrontFacing) n *= -1.0f;\n```", "```cpp\n PBRInfo pbrInputs = calculatePBRInputsMetallicRoughness(\n    Kd, n, perFrame.drawable.cameraPos.xyz, worldPos, mrSample);\n```", "```cpp\n vec3 specular_color =\n    getIBLRadianceContributionGGX(pbrInputs, 1.0);\n  vec3 diffuse_color = getIBLRadianceLambertian(\n    pbrInputs.NdotV, n, pbrInputs.perceptualRoughness,\n    pbrInputs.diffuseColor, pbrInputs.reflectance0, 1.0);\n  vec3 color = specular_color + diffuse_color;\n```", "```cpp\n vec3 lightPos = vec3(0, 0, -5);\n  color += calculatePBRLightContribution(\n    pbrInputs, normalize(lightPos - worldPos), vec3(1.0) );\n```", "```cpp\n color = color * ( Kao.r < 0.01 ? 1.0 : Kao.r );\n```", "```cpp\n color = pow( Ke.rgb + color, vec3(1.0/2.2) );\n  out_FragColor = vec4(color, 1.0);\n}\n```", "```cpp\nstruct PBRInfo {\n  float NdotL; // cos angle between normal and light direction\n  float NdotV; // cos angle between normal and view direction\n  float NdotH; // cos angle between normal and half vector\n  float LdotH; // cos angle between light dir and half vector\n  float VdotH; // cos angle between view dir and half vector\n  vec3 n;      // normal at surface point\n  vec3 v;      // vector from surface point to camera\n```", "```cpp\n float perceptualRoughness; // roughness value (input to shader)\n  vec3 reflectance0;    // full reflectance color\n  vec3 reflectance90;   // reflectance color at grazing angle\n  float alphaRoughness; // remapped linear roughness\n  vec3 diffuseColor;    // contribution from diffuse lighting\n  vec3 specularColor;   // contribution from specular lighting\n};\n```", "```cpp\nvec4 SRGBtoLINEAR(vec4 srgbIn) {\n  vec3 linOut = pow( srgbIn.xyz,vec3(2.2) );\n  return vec4(linOut, srgbIn.a);\n}\n```", "```cpp\nvec3 getIBLRadianceLambertian(float NdotV, vec3 n,\n  float roughness, vec3 diffuseColor, vec3 F0,\n  float specularWeight)\n{\n  vec2 brdfSamplePoint =\n    clamp(vec2(NdotV, roughness), vec2(0., 0.), vec2(1., 1.));\n  EnvironmentMapDataGPU envMap =\n    getEnvironment(getEnvironmentId());\n  vec2 f_ab =\n    sampleBRDF_LUT(brdfSamplePoint, envMap).rg;\n  vec3 irradiance =\n    sampleEnvMapIrradiance(n.xyz, envMap).rgb;\n  vec3 Fr = max(vec3(1.0 - roughness), F0) - F0;\n  vec3 k_S = F0 + Fr * pow(1.0 - NdotV, 5.0);\n  vec3 FssEss = specularWeight * k_S * f_ab.x + f_ab.y;\n  float Ems = (1.0 - (f_ab.x + f_ab.y));\n  vec3 F_avg = specularWeight * (F0 + (1.0 - F0) / 21.0);\n  vec3 FmsEms = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);\n  vec3 k_D = diffuseColor * (1.0 - FssEss + FmsEms);\n  return (FmsEms + k_D) * irradiance;\n}\n```", "```cpp\nvec3 getIBLRadianceContributionGGX(\n  PBRInfo pbrInputs, float specularWeight)\n{\n  vec3 n = pbrInputs.n;\n  vec3 v =  pbrInputs.v;\n  vec3 reflection = -normalize(reflect(v, n));\n  EnvironmentMapDataGPU envMap =\n    getEnvironment(getEnvironmentId());\n  float mipCount =\n    float(sampleEnvMapQueryLevels(envMap));\n  float lod = pbrInputs.perceptualRoughness * (mipCount - 1);\n```", "```cpp\n vec2 brdfSamplePoint = clamp(\n    vec2(pbrInputs.NdotV, pbrInputs.perceptualRoughness),\n    vec2(0.0, 0.0),\n    vec2(1.0, 1.0));\n  vec3 brdf =\n    sampleBRDF_LUT(brdfSamplePoint, envMap).rgb;\n```", "```cpp\n vec3 specularLight =\n    sampleEnvMapLod(reflection.xyz, lod, envMap).rgb;\n  vec3 Fr = max(vec3(1.0 - pbrInputs.perceptualRoughness),\n                pbrInputs.reflectance0\n            ) - pbrInputs.reflectance0;\n  vec3 k_S =\n    pbrInputs.reflectance0 + Fr * pow(1.0-pbrInputs.NdotV, 5.0);\n  vec3 FssEss = k_S * brdf.x + brdf.y;\n  return specularWeight * specularLight * FssEss;\n}\n```", "```cpp\nvec3 diffuseBurley(PBRInfo pbrInputs) {\n  float f90 = 2.0 * pbrInputs.LdotH * pbrInputs.LdotH *\n    pbrInputs.alphaRoughness - 0.5;\n  return (pbrInputs.diffuseColor / M_PI) * \n    (1.0 + f90 * pow((1.0 - pbrInputs.NdotL), 5.0)) *\n    (1.0 + f90 * pow((1.0 - pbrInputs.NdotV), 5.0));\n}\n```", "```cpp\nvec3 specularReflection(PBRInfo pbrInputs) {\n  return pbrInputs.reflectance0 +\n    (pbrInputs.reflectance90 - pbrInputs.reflectance0) *\n     pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);\n}\n```", "```cpp\nfloat geometricOcclusion(PBRInfo pbrInputs) {\n  float NdotL = pbrInputs.NdotL;\n  float NdotV = pbrInputs.NdotV;\n  float rSqr =\n    pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;\n  float attenuationL = 2.0 * NdotL /\n    (NdotL + sqrt(rSqr + (1.0 - rSqr) * (NdotL * NdotL)));\n  float attenuationV = 2.0 * NdotV /\n    (NdotV + sqrt(rSqr + (1.0 - rSqr) * (NdotV * NdotV)));\n  return attenuationL * attenuationV;\n}\n```", "```cpp\nfloat microfacetDistribution(PBRInfo pbrInputs) {\n  float roughnessSq =\n    pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;\n  float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) *\n    pbrInputs.NdotH + 1.0;\n  return roughnessSq / (M_PI * f * f);\n}\n```", "```cpp\nvec3 perturbNormal(vec3 n, vec3 v, vec3 normalSample, vec2 uv) {\n  vec3 map = normalize( 2.0 * normalSample - vec3(1.0) );\n  mat3 TBN = cotangentFrame(n, v, uv);\n  return normalize(TBN * map);\n}\n```", "```cpp\nmat3 cotangentFrame( vec3 N, vec3 p, vec2 uv ) {\n  vec3 dp1 = dFdx( p );\n  vec3 dp2 = dFdy( p );\n  vec2 duv1 = dFdx( uv );\n  vec2 duv2 = dFdy( uv );\n  vec3 dp2perp = cross( dp2, N );\n  vec3 dp1perp = cross( N, dp1 );\n  vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n  vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n  float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );\n```", "```cpp\n float w = dot(cross(N, T), B) < 0.0 ? -1.0 : 1.0;\n  T = T * w;\n  return mat3( T * invmax, B * invmax, N );\n}\n```", "```cpp\nPBRInfo calculatePBRInputsMetallicRoughness( vec4 albedo,\n  vec3 normal, vec3 cameraPos, vec3 worldPos, vec4 mrSample)\n{\n  PBRInfo pbrInputs;\n  MetallicRoughnessDataGPU mat = getMaterial(getMaterialId());\n  float perceptualRoughness = \n    getRoughnessFactor(mat) * mrSample.g;\n  float metallic = getMetallicFactor(mat) * mrSample.b;\n  const float c_MinRoughness = 0.04;\n  perceptualRoughness =\n    clamp(perceptualRoughness, c_MinRoughness, 1.0);\n```", "```cpp\n float alphaRoughness = perceptualRoughness *\n                         perceptualRoughness;\n  vec4 baseColor = albedo;\n  vec3 f0 = vec3(0.04);\n  vec3 diffuseColor = mix(baseColor.rgb, vec3(0), metallic);\n  vec3 specularColor = mix(f0, baseColor.rgb, metallic);\n  float reflectance =\n    max(max(specularColor.r, specularColor.g), specularColor.b);\n```", "```cpp\n float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\n  vec3 specularEnvironmentR0 = specularColor.rgb;\n  vec3 specularEnvironmentR90 =\n    vec3(1.0, 1.0, 1.0) * reflectance90;\n  vec3 n = normalize(normal);\n  vec3 v = normalize(cameraPos - worldPos);\n```", "```cpp\n pbrInputs.NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);\n  pbrInputs.perceptualRoughness = perceptualRoughness;\n  pbrInputs.reflectance0 = specularEnvironmentR0;\n  pbrInputs.reflectance90 = specularEnvironmentR90;\n  pbrInputs.alphaRoughness = alphaRoughness;\n  pbrInputs.diffuseColor = diffuseColor;\n  pbrInputs.specularColor = specularColor;\n  pbrInputs.n = n;\n  pbrInputs.v = v;\n  return pbrInputs;\n}\n```", "```cpp\nvec3 calculatePBRLightContribution(\n  inout PBRInfo pbrInputs, vec3 lightDirection, vec3 lightColor)\n{\n  vec3 n = pbrInputs.n;\n  vec3 v = pbrInputs.v;\n  vec3 ld = normalize(lightDirection);\n  vec3 h = normalize(ld +  v);\n  float NdotV = pbrInputs.NdotV;\n  float NdotL = clamp(dot(n, ld), 0.001, 1.0);\n  float NdotH = clamp(dot(n, h), 0.0, 1.0);\n  float LdotH = clamp(dot(ld, h), 0.0, 1.0);\n  float VdotH = clamp(dot(v, h), 0.0, 1.0);\n  vec3 color = vec3(0);\n```", "```cpp\n if (NdotL > 0.0 || NdotV > 0.0) {\n    pbrInputs.NdotL = NdotL;\n    pbrInputs.NdotH = NdotH;\n    pbrInputs.LdotH = LdotH;\n    pbrInputs.VdotH = VdotH;\n    vec3  F = specularReflection(pbrInputs);\n    float G = geometricOcclusion(pbrInputs);\n    float D = microfacetDistribution(pbrInputs);\n```", "```cpp\n vec3 diffuseContrib = (1.0 - F) * diffuseBurley(pbrInputs);\n    vec3 specContrib = F * G * D / (4.0 * NdotL * NdotV);\n    color = NdotL * lightColor * (diffuseContrib + specContrib);\n  }\n  return color;\n}\n```", "```cpp\nstruct SpecularGlossinessDataGPU {\n  vec4 baseColorFactor = vec4(1.0f, 1.0f, 1.0f, 1.0f);\n  vec4 metallicRoughnessNormalOcclusion =\n    vec4(1.0f, 1.0f, 1.0f, 1.0f);\n  vec4 specularGlossiness = vec4(1.0f, 1.0f, 1.0f, 1.0f);\n  … everything else remains the same \n      as in the structure MetallicRoughnessDataGPU …\n  uint32_t materialType = 0;\n  uint32_t padding[3]   = {};\n  enum AlphaMode : uint32_t {\n    AlphaMode_Opaque = 0,\n    AlphaMode_Mask   = 1,\n    AlphaMode_Blend  = 2,\n  };\n};\n```", "```cpp\nMaterialType detectMaterialType(const aiMaterial* mtl) {\n  aiShadingMode shadingMode = aiShadingMode_NoShading;\n  if (mtl->Get(AI_MATKEY_SHADING_MODEL, shadingMode) ==\n      AI_SUCCESS) {\n    if (shadingMode == aiShadingMode_Unlit)\n      return MaterialType_Unlit;\n  }\n  if (shadingMode == aiShadingMode_PBR_BRDF) {\n    ai_real factor = 0;\n    if (mtl->Get(AI_MATKEY_GLOSSINESS_FACTOR, factor) ==\n        AI_SUCCESS) {\n      return MaterialType_SpecularGlossiness;\n    } else if (mtl->Get(AI_MATKEY_METALLIC_FACTOR, factor) ==\n               AI_SUCCESS) {\n      return MaterialType_MetallicRoughness;\n    }\n  }\n  LLOGW(“Unknown material type\\n”);\n  return MaterialType_Invalid;\n}\n```", "```cpp\nSpecularGlossinessDataGPU res;\n…\nif (materialType == MaterialType_SpecularGlossiness) {\n  ai_real specularFactor[3];\n  if (mtlDescriptor->Get(AI_MATKEY_SPECULAR_FACTOR,\n      specularFactor) == AI_SUCCESS) {\n    res.specularGlossiness.x = specularFactor[0];\n    res.specularGlossiness.y = specularFactor[1];\n    res.specularGlossiness.z = specularFactor[2];\n  }\n  assignUVandSampler(      samplers, mtlDescriptor,\n    aiTextureType_SPECULAR, res.surfacePropertiesTextureUV,\n    res.surfacePropertiesTextureSampler);\n  ai_real glossinessFactor;\n  if (mtlDescriptor->Get(AI_MATKEY_GLOSSINESS_FACTOR,\n                         glossinessFactor) == AI_SUCCESS) {\n    res.specularGlossiness.w = glossinessFactor;\n  }\n}\n```", "```cpp\nPBRInfo calculatePBRInputsMetallicRoughness( vec4 albedo,\n  vec3 normal, vec3 cameraPos, vec3 worldPos, vec4 mrSample)\n{\n  PBRInfo pbrInputs;\n  SpecularGlossinessDataGPU mat = getMaterial(getMaterialId());\n  bool isSpecularGlossiness =\n    getMaterialType(mat) == MaterialType_SpecularGlossiness;\n```", "```cpp\n float perceptualRoughness = isSpecularGlossiness ?\n    getGlossinessFactor(mat):\n    getRoughnessFactor(mat);\n  float metallic = getMetallicFactor(mat) * mrSample.b;\n  metallic = clamp(metallic, 0.0, 1.0);\n  vec3 f0 = isSpecularGlossiness ?\n    getSpecularFactor(mat) * mrSample.rgb :\n    vec3(0.04);\n  const float c_MinRoughness = 0.04;\n  perceptualRoughness = isSpecularGlossiness ?\n    1.0 - mrSample.a * perceptualRoughness :\n    clamp(mrSample.g * perceptualRoughness, c_MinRoughness, 1.0);\n  float alphaRoughness = perceptualRoughness *\n                         perceptualRoughness;\n  vec4 baseColor = albedo;\n  vec3 diffuseColor = isSpecularGlossiness ?\n    baseColor.rgb * (1.0 - max(max(f0.r, f0.g), f0.b)) :\n    mix(baseColor.rgb, vec3(0), metallic);\n  vec3 specularColor = isSpecularGlossiness ?\n    f0 : mix(f0, baseColor.rgb, metallic);\n  …\n}\n```"]