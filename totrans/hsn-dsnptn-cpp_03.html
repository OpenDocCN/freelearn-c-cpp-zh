<html><head></head><body>
<div id="_idContainer011">
<h1 class="chapter-number" id="_idParaDest-45"><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-46"><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.2.1">Memory and Ownership</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Memory mismanagement is one of the most common problems in C++ programs. </span><span class="koboSpan" id="kobo.3.2">Many of these problems boil down to incorrect assumptions about which part of the code or which entity owns a particular memory. </span><span class="koboSpan" id="kobo.3.3">Then, we get memory leaks, accessing unallocated memory, excessive memory use, and other problems that are difficult to debug. </span><span class="koboSpan" id="kobo.3.4">Modern C++ has a set of memory ownership idioms that, taken together, allow the programmer to clearly express their design intent when it comes to memory ownership. </span><span class="koboSpan" id="kobo.3.5">This, in turn, makes it much easier to write code that correctly allocates, accesses, and </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">deallocates memory.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">The following topics are covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">What is memory ownership and </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">resource ownership?</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">What are the characteristics of well-designed resource ownership? </span><span class="koboSpan" id="kobo.9.2">When and how should we be agnostic about resource ownership? </span><span class="koboSpan" id="kobo.9.3">How do we express exclusive memory ownership </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">in C++?</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">How do we express shared memory ownership </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">in C++?</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">What is the cost of different memory ownership </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">language constructs?</span></span></li>
</ul>
<h1 id="_idParaDest-47"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.15.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.16.1">You can find the C++ Core Guidelines </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">at </span></span><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md"><span class="No-Break"><span class="koboSpan" id="kobo.18.1">https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.19.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.20.1">You can find the C++ </span><strong class="bold"><span class="koboSpan" id="kobo.21.1">Guidelines Support Library</span></strong><span class="koboSpan" id="kobo.22.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.23.1">GSL</span></strong><span class="koboSpan" id="kobo.24.1">) at </span><a href="https://github.com/Microsoft/GSL"><span class="koboSpan" id="kobo.25.1">https://github.com/Microsoft/GSL</span></a><span class="koboSpan" id="kobo.26.1">. </span><span class="koboSpan" id="kobo.26.2">Examples are available </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">at </span></span><a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter03"><span class="No-Break"><span class="koboSpan" id="kobo.28.1">https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter03</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.29.1">.</span></span></p>
<h1 id="_idParaDest-48"><a id="_idTextAnchor113"/><a id="_idTextAnchor114"/><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.30.1">What is memory ownership?</span></h1>
<p><span class="koboSpan" id="kobo.31.1">In C++, the</span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.32.1"> term </span><em class="italic"><span class="koboSpan" id="kobo.33.1">memory ownership</span></em><span class="koboSpan" id="kobo.34.1"> refers to the entity that is responsible for enforcing the lifetime of a particular memory allocation. </span><span class="koboSpan" id="kobo.34.2">In reality, we rarely talk about the ownership of raw memory. </span><span class="koboSpan" id="kobo.34.3">Usually, we manage the ownership and the lifetime of the objects that reside in said memory and memory ownership is really just shorthand</span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.35.1"> for </span><em class="italic"><span class="koboSpan" id="kobo.36.1">object ownership</span></em><span class="koboSpan" id="kobo.37.1">. </span><span class="koboSpan" id="kobo.37.2">The concept of memory ownership is closely tied to that </span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.38.1">of </span><em class="italic"><span class="koboSpan" id="kobo.39.1">resource ownership</span></em><span class="koboSpan" id="kobo.40.1">. </span><span class="koboSpan" id="kobo.40.2">First of all, memory is a resource. </span><span class="koboSpan" id="kobo.40.3">It is not the only resource a program can manage, but it is by far the most commonly used one. </span><span class="koboSpan" id="kobo.40.4">Second, the C++ way of managing resources is to have objects own them. </span><span class="koboSpan" id="kobo.40.5">Thus, the problem of managing resources is reduced to the problem of managing the owning objects, which, as we just learned, is what we really mean when we talk about memory ownership. </span><span class="koboSpan" id="kobo.40.6">In this context, memory ownership is about owning more than memory, and mismanaged ownership can leak, miscount, or lose track of any resource that can be controlled by the program—memory, mutexes, files, database handles, c</span><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.41.1">at videos, airline seat reservations, or </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">nuclear warhead</span><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.43.1">s.</span></span></p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.44.1">Well-designed memory ownership</span></h2>
<p><span class="koboSpan" id="kobo.45.1">What does well-designed memory </span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.46.1">ownership look like? </span><span class="koboSpan" id="kobo.46.2">The naive answer that first comes up is that, at every point in the program, it is clear who owns which object. </span><span class="koboSpan" id="kobo.46.3">This, however, is overly constraining—most of the program does not deal with ownership of resources, including memory. </span><span class="koboSpan" id="kobo.46.4">These parts of the program merely use resources. </span><span class="koboSpan" id="kobo.46.5">When writing such code, it is sufficient to know that a particular function or class does not own the memory. </span><span class="koboSpan" id="kobo.46.6">It is completely irrelevant to know who </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">does what:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.48.1">
struct MyValues { long a, b, c, d; }
void Reset(MyValues* v) {
  // Don't care who owns v, as long as we don't
  v-&gt;a = v-&gt;b = v-&gt;c = v-&gt;d = 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.49.1">How about this, then—at every point in the program, is it clear who owns that object, or is it clear that the owner is not changing? </span><span class="koboSpan" id="kobo.49.2">This is better since most of the code will fall under the second part of our answer. </span><span class="koboSpan" id="kobo.49.3">However, it’s still too constraining—when taking ownership of an object, it is usually not important to know who it is </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">taken from:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.51.1">
class A {
  public:
  // Constructor transfers ownership from whomever
  A(std::vector&lt;int&gt;&amp;&amp; v) : v(std::move(v)) {}
  private:
  std::vector&lt;int&gt; v_;    // We own this now
};</span></pre>
<p><span class="koboSpan" id="kobo.52.1">Similarly, the whole point of shared ownership (expressed through the reference-counted </span><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.54.1">) is that we </span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.55.1">don’t need to know who else owns </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">the object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.57.1">
class A {
  public:
  // No idea who owns v, don't care
  A(std::shared_ptr&lt;std::vector&lt;int&gt;&gt; v) : v_(v) {}
  // Sharing ownership with any number of owners
  private:
  std::shared_ptr&lt;std::vector&lt;int&gt;&gt; v_;
};</span></pre>
<p><span class="koboSpan" id="kobo.58.1">A more accurate description of well-designed memory ownership takes more than one quoted sentence. </span><span class="koboSpan" id="kobo.58.2">Generally, the following are the attributes of good memory </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">ownership practices:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.60.1">If a function or a class does not alter memory ownership in any way, this should be clear to every client of this function or class, as well as </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">the implementer.</span></span></li>
<li><span class="koboSpan" id="kobo.62.1">If a function or a class takes exclusive ownership of some of the objects passed to it, this should be clear to the client (we assume that the implementer knows this already since they have to write </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">the code).</span></span></li>
<li><span class="koboSpan" id="kobo.64.1">If a function or a class shares ownership of an object passed to it, this should be clear to the client (or anyone who reads the client code, for </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">that matter).</span></span></li>
<li><span class="koboSpan" id="kobo.66.1">For every object that is created, for every unit of code where it’s used, it is clear whether</span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.67.1"> this code is expected to delete the object </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">or</span><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.69.1"> not.</span></span></li>
</ul>
<h2 id="_idParaDest-50"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.70.1">Poorly designed memory ownership</span></h2>
<p><span class="koboSpan" id="kobo.71.1">Just as</span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.72.1"> good memory ownership defies a simple description and instead is characterized by a set of criteria it satisfies, so can bad memory ownership practices be recognized by their common manifestations. </span><span class="koboSpan" id="kobo.72.2">In general, where a good design makes it clear whether a particular piece of code owns a resource or not, a bad design requires additional knowledge that cannot be deduced from the context. </span><span class="koboSpan" id="kobo.72.3">For example, who owns the object returned by the following </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">MakeWidget()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.74.1"> function?</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.75.1">
Widget* w = MakeWid</span><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.76.1">get();</span></pre>
<p><span class="koboSpan" id="kobo.77.1">Is the client expected to delete the widget when it’s no longer needed? </span><span class="koboSpan" id="kobo.77.2">If yes, how should it be deleted? </span><span class="koboSpan" id="kobo.77.3">If we decide to delete the widget and do it in the wrong way, for example, by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">operator delete</span></strong><span class="koboSpan" id="kobo.79.1"> on a widget that was not, in fact, allocated by </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">operator new</span></strong><span class="koboSpan" id="kobo.81.1">, memory corruption will certainly result. </span><span class="koboSpan" id="kobo.81.2">In the best-case scenario, the program will </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">just crash:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.83.1">
WidgetFactory WF;
Widget* w = WF.MakeAnother();</span></pre>
<p><span class="koboSpan" id="kobo.84.1">Does the Factory own the widgets it created? </span><span class="koboSpan" id="kobo.84.2">Will it delete them when the Factory object is deleted? </span><span class="koboSpan" id="kobo.84.3">Alternatively, is the client expected to do that? </span><span class="koboSpan" id="kobo.84.4">If we decide that the Factory probably knows what it created and will delete all such objects in due time, we may end up with a memory leak (or worse, if the objects owned some </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">other resources):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.86.1">
Widget* w = MakeWidget();
Widget* w1 = Transmogrify(w);</span></pre>
<p><span class="koboSpan" id="kobo.87.1">Does </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">Transmogrify()</span></strong><span class="koboSpan" id="kobo.89.1"> take ownership of the widget? </span><span class="koboSpan" id="kobo.89.2">Is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">w</span></strong><span class="koboSpan" id="kobo.91.1"> widget still around after </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">Transmogrify()</span></strong><span class="koboSpan" id="kobo.93.1"> is done with it? </span><span class="koboSpan" id="kobo.93.2">If the widget is deleted to construct a new, transmogrified, </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">w1</span></strong><span class="koboSpan" id="kobo.95.1"> widget, we now have a dangling pointer. </span><span class="koboSpan" id="kobo.95.2">If the widget is not deleted, but we assume it might be, we have a </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">memory leak.</span></span></p>
<p><span class="koboSpan" id="kobo.97.1">Lest you</span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.98.1"> think that all bad memory management practices can be recognized by the presence of raw pointers somewhere, here is an example of a rather poor approach to memory management that often arises as a knee-jerk response to the problems caused by the use of </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">raw pointers:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.100.1">
void Double(std::shared_ptr&lt;std::vector&lt;int&gt;&gt; v) {
  for (auto&amp; x : *v) {
    x *= 2;
  }
};
...
</span><span class="koboSpan" id="kobo.100.2">std::shared_ptr&lt;std::vector&lt;int&gt;&gt; v(...);
Double(</span><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.101.1">v);
...</span></pre>
<p><span class="koboSpan" id="kobo.102.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">Double()</span></strong><span class="koboSpan" id="kobo.104.1"> function is claiming in its interface that it takes shared ownership of the vector. </span><span class="koboSpan" id="kobo.104.2">However, that ownership is entirely gratuitous—there is no reason for </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">Double()</span></strong><span class="koboSpan" id="kobo.106.1"> to own its argument—it does not attempt to extend its lifetime and, it does not transfer ownership to anyone else; it merely modifies a vector passed in by the caller. </span><span class="koboSpan" id="kobo.106.2">We can reasonably expect that the caller owns the vector (or that somebody else even higher in the call stack does), and that the vector will still be around when </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">Double()</span></strong><span class="koboSpan" id="kobo.108.1"> returns control to the caller—after all, the caller wanted us to double the elements, presumably so that they can do something else </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">with them.</span></span></p>
<p><span class="koboSpan" id="kobo.110.1">While this list is hardly</span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.111.1"> complete, it serves to demonstrate the spectrum of </span><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.112.1">problems that can be caused by a slap-dash approach to memory ownership. </span><span class="koboSpan" id="kobo.112.2">In the next section, we review the patterns and guidelines developed by the C++ community to help to avoid these problems and express the programmer’s </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">intent </span><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.114.1">clearly.</span></span></p>
<h1 id="_idParaDest-51"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.115.1">Expressing memory ownership in C++</span></h1>
<p><span class="koboSpan" id="kobo.116.1">Throughout its history, the </span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.117.1">C++ language has evolved in its approach to expressing memory ownership. </span><span class="koboSpan" id="kobo.117.2">The same syntactic constructs have been, at times, imbued with different assumed semantics. </span><span class="koboSpan" id="kobo.117.3">This evolution was partially driven by new features added to the language (it’s hard to talk about shared memory ownership if you don’t have any shared pointers). </span><span class="koboSpan" id="kobo.117.4">On the other hand, most of the memory management tools added in C++ 11 and later were not new ideas or new concepts. </span><span class="koboSpan" id="kobo.117.5">The notion of a shared pointer has been around for a long time. </span><span class="koboSpan" id="kobo.117.6">This language support makes it easier to implement one (and having a shared pointer in the standard library makes most custom implementations unnecessary), but shared pointers were used in C++ long before C++ 11 added them to the standard. </span><span class="koboSpan" id="kobo.117.7">The more important change that has occurred was the evolution of the understanding of the C++ community and the emergence of common practices and idioms. </span><span class="koboSpan" id="kobo.117.8">It is in this sense, as a set of conventions and semantics commonly associated with different syntactic features, that we can talk about the set of memory management practices as a design pattern of the C++ language. </span><span class="koboSpan" id="kobo.117.9">Let’s now learn the different ways that we ca</span><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.118.1">n express different types of </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">memory ow</span><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.120.1">nership.</span></span></p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.121.1">Expressing non-ownership</span></h2>
<p><span class="koboSpan" id="kobo.122.1">Let’s start with the most </span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.123.1">common kind of memory ownership. </span><span class="koboSpan" id="kobo.123.2">Most code does not allocate, deallocate, construct, or delete. </span><span class="koboSpan" id="kobo.123.3">It just does its work on objects that were created by someone else earlier and will be deleted by someone else later. </span><span class="koboSpan" id="kobo.123.4">How do you express the notion that a function is going to operate on an object but will not attempt to delete it or, conversely, extend its lifetime past the completion of the </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">functi</span><a id="_idTextAnchor129"/><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.125.1">on itself?</span></span></p>
<p><span class="koboSpan" id="kobo.126.1">Very easily, in fact, and every C++ programmer has done it </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">many times:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.128.1">
// Example 01
void Transmogrify(Widget* w) {        // I will not delete w
  ...
</span><span class="koboSpan" id="kobo.128.2">}
void MustTransmogrify(Widget&amp; w) {   // Neither will I
  ...
</span><span class="koboSpan" id="kobo.128.3">}</span></pre>
<p><span class="koboSpan" id="kobo.129.1">In a well-written program, a function with a raw pointer parameter signals that it is not involved with the ownership of the corresponding object in any way; the same goes for references. </span><span class="koboSpan" id="kobo.129.2">Similarly, a class that contains a member function pointer refers to an object but expects someone else to own it and manage its lifetime. </span><span class="koboSpan" id="kobo.129.3">Note that the destructor of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">WidgetProcessor</span></strong><span class="koboSpan" id="kobo.131.1"> class in the next example does not delete the object the class points to – this is a sure sign that we</span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.132.1"> refuse ownership of </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">that object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.134.1">
// Example 02
class WidgetProcessor {
  public:
  WidgetProcessor(Widget* w) : w_(w) {}
  WidgetProcessor() {} // DO NOT delete w_!!!
</span><span class="koboSpan" id="kobo.134.2">    ...
</span><span class="koboSpan" id="kobo.134.3">  private:
  Widget* w_;    // I do not own w_
};</span></pre>
<p><span class="koboSpan" id="kobo.135.1">Non-owning access to an object should be granted by using raw pointers or references. </span><span class="koboSpan" id="kobo.135.2">Yes—even in C++ 14, with all its smart pointers, there is a place for raw pointers. </span><span class="koboSpan" id="kobo.135.3">Not only that but in the bulk of the code, the majority of pointers will be raw pointers—all the non-owning ones (as we will see in the next section, C++17 and C++20 take this point </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">much further).</span></span></p>
<p><span class="koboSpan" id="kobo.137.1">You might reasonably point out at this time that the preceding example of recommended practices for granting non-owning access looks exactly like one of the examples of bad practices shown earlier. </span><span class="koboSpan" id="kobo.137.2">The distinction is in the context—in a well-designed program, only non-owning access is granted through raw pointers and references. </span><span class="koboSpan" id="kobo.137.3">Actual ownership is always expressed in some other way. </span><span class="koboSpan" id="kobo.137.4">Thus, it is clear that when a raw pointer is encountered, the function or class is not going to mess with the ownership of the object in any way. </span><span class="koboSpan" id="kobo.137.5">This, of course, creates some confusion when it comes to converting old legacy code, with raw pointers everywhere, to modern practices. </span><span class="koboSpan" id="kobo.137.6">As a matter of clarity, it is recommended to convert such code one part at a time, with clearly indicated transitions between code that follows the modern guidelines and code that </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">does not.</span></span></p>
<p><span class="koboSpan" id="kobo.139.1">Another</span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.140.1"> issue to discuss here is the use of pointers versus references. </span><span class="koboSpan" id="kobo.140.2">As a matter of syntax, the reference is basically a pointer that is never null and cannot be left uninitialized. </span><span class="koboSpan" id="kobo.140.3">It is tempting to adopt a convention that any pointer passed to a function may be null and must, therefore, be checked, and any function that cannot accept a null pointer must instead take a reference. </span><span class="koboSpan" id="kobo.140.4">It is a good convention and widely used, but not widely enough to be considered an accepted design pattern. </span><span class="koboSpan" id="kobo.140.5">Perhaps in recognition of this, the C++ Core Guidelines library offers an alternative for expressing non-null pointers—</span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">not_null&lt;T*&gt;</span></strong><span class="koboSpan" id="kobo.142.1">. </span><span class="koboSpan" id="kobo.142.2">Note that this is not a part of the language itself</span><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.143.1">, but can be implemented in standard C++ without any </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">languag</span><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.145.1">e extension.</span></span></p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.146.1">Expressing exclusive ownership</span></h2>
<p><span class="koboSpan" id="kobo.147.1">The second most common type of </span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.148.1">ownership is exclusive ownership—the code creates an object and will delete it later. </span><span class="koboSpan" id="kobo.148.2">The task of deletion will not be delegated to someone else, and no extension of the lifetime of the object is permitted. </span><span class="koboSpan" id="kobo.148.3">This type of memory ownership is so common that we do it all the time without even thinking </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">about it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.150.1">
void Work() {
  Widget w;
  Transmogrify(w);
  Draw(w);
}</span></pre>
<p><span class="koboSpan" id="kobo.151.1">All local (stack) variables express unique memory ownership! </span><span class="koboSpan" id="kobo.151.2">Note that ownership in this context does not mean that someone else will not modify the object. </span><span class="koboSpan" id="kobo.151.3">It merely means that when the creator of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">w</span></strong><span class="koboSpan" id="kobo.153.1"> widget—the </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">DoWork()</span></strong><span class="koboSpan" id="kobo.155.1"> function, in our case—decides to delete it; the deletion will succeed (nobody has deleted it already) and the object will actually be deleted (nobody attempted to keep the object alive after the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">its scope).</span></span></p>
<p><span class="koboSpan" id="kobo.157.1">This is the oldest way to construct an object in C++, and it’s still the best one. </span><span class="koboSpan" id="kobo.157.2">If a stack variable does what you need, use it. </span><span class="koboSpan" id="kobo.157.3">C++ 11 provides another way to express unique ownership, and it is mainly used in cases where an object cannot be created on the stack but must be allocated on the heap. </span><span class="koboSpan" id="kobo.157.4">Heap allocation often happens when ownership is shared or transferred—after all, the stack-allocated object will be deleted at the end of the containing scope; there is no way around it. </span><span class="koboSpan" id="kobo.157.5">If we need to keep the object alive for longer, it has to be allocated somewhere else. </span><span class="koboSpan" id="kobo.157.6">The other reason to create objects on the heap is that the size or type of the object may not be known at compile time. </span><span class="koboSpan" id="kobo.157.7">This usually happens when the object is polymorphic—a derived object is created, but the base class pointer is used. </span><span class="koboSpan" id="kobo.157.8">Whatever the reason for not allocating objects on the stack, we have a way of expressing the exclusive ownership of such objects </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">std::unique_ptr</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.161.1">
// Example 03
class FancyWidget : public Widget { ... </span><span class="koboSpan" id="kobo.161.2">};
std::unique_ptr&lt;Widget&gt; w(new FancyWidget);</span></pre>
<p><span class="koboSpan" id="kobo.162.1">There is also a technical reason why you may have to construct objects on the heap even when a stack-allocated object seems sufficient: the stack size is quite limited, usually anywhere between 2 MB and 10 MB. </span><span class="koboSpan" id="kobo.162.2">That is the space for all stack allocations in one thread, and when it is exceeded, the program crashes. </span><span class="koboSpan" id="kobo.162.3">A large enough object can exhaust the stack space or push it too close to the limit for subsequent allocations. </span><span class="koboSpan" id="kobo.162.4">Such objects must be created on the heap and owned by stack-allocated unique pointers or other</span><a id="_idIndexMarker154"/> <span class="No-Break"><span class="koboSpan" id="kobo.163.1">resource-owning objects.</span></span></p>
<p><span class="koboSpan" id="kobo.164.1">What if the way to create an object is more complex than just </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">operator new</span></strong><span class="koboSpan" id="kobo.166.1">, and we need a Factory function? </span><span class="koboSpan" id="kobo.166.2">That is the type of ownership we will </span><a id="_idTextAnchor134"/><a id="_idTextAnchor135"/><a id="_idTextAnchor136"/><span class="No-Break"><span class="koboSpan" id="kobo.167.1">consider next.</span></span></p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.168.1">Expressing transfer of exclusive ownership</span></h2>
<p><span class="koboSpan" id="kobo.169.1">In the preceding </span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.170.1">example, a new object was created and immediately bound to a unique pointer, </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.172.1">, which guarantees exclusive ownership. </span><span class="koboSpan" id="kobo.172.2">The client code looks exactly the same if the object is created by </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">a Factory:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.174.1">
std::unique_ptr&lt;Widget&gt; w(WidgetFactory());</span></pre>
<p><span class="koboSpan" id="kobo.175.1">But what should the Factory function return? </span><span class="koboSpan" id="kobo.175.2">It could certainly return a raw pointer, </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">Widget*</span></strong><span class="koboSpan" id="kobo.177.1">. </span><span class="koboSpan" id="kobo.177.2">After all, that is what </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">new</span></strong><span class="koboSpan" id="kobo.179.1"> returns. </span><span class="koboSpan" id="kobo.179.2">But this opens the way to incorrect use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">WidgetFactory</span></strong><span class="koboSpan" id="kobo.181.1">—for example, instead of capturing the returned raw pointer in a unique pointer, we could pass it to a function such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">Transmogrify</span></strong><span class="koboSpan" id="kobo.183.1"> that takes a raw pointer because it does not deal with the ownership. </span><span class="koboSpan" id="kobo.183.2">Now, nobody owns the widget, and it ends up as a memory leak. </span><span class="koboSpan" id="kobo.183.3">Ideally, </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">WidgetFactory</span></strong><span class="koboSpan" id="kobo.185.1"> would be written in a way that would force the caller to take ownership of the </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">returned object.</span></span></p>
<p><span class="koboSpan" id="kobo.187.1">What we need here </span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.188.1">is an ownership transfer—</span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">WidgetFactory</span></strong><span class="koboSpan" id="kobo.190.1"> is certainly an exclusive owner of the object it constructs, but at some point, it needs to hand off that ownership to a new, also exclusive, owner. </span><span class="koboSpan" id="kobo.190.2">The code to do so is </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">very simple:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.192.1">
// Example 04
std::unique_ptr&lt;Widget&gt; WidgetFactory() {
  Widget* new_w = new Widget;
    ...
</span><span class="koboSpan" id="kobo.192.2">  return std::unique_ptr&lt;Widget&gt;(new_w);
}
std::unique_ptr&lt;Widget&gt; w(WidgetFactory());</span></pre>
<p><span class="koboSpan" id="kobo.193.1">This works exactly the way we want it to, but why? </span><span class="koboSpan" id="kobo.193.2">Doesn’t the unique pointer provide exclusive ownership? </span><span class="koboSpan" id="kobo.193.3">The answer is, it does, but it is also a movable object (it has a move constructor). </span><span class="koboSpan" id="kobo.193.4">Moving the content of a unique pointer into another one transfers the ownership of the object; the original pointer is left in the moved-from state (its destruction will not delete any objects). </span><span class="koboSpan" id="kobo.193.5">What is so good about this idiom? </span><span class="koboSpan" id="kobo.193.6">It clearly expresses, and forces at compile time, that the Factory expects the caller to take exclusive (or shared) ownership of the object. </span><span class="koboSpan" id="kobo.193.7">For example, the following code, which would have left the new widget with no owner, does </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">not compile:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.195.1">
void Transmogrify(Widget* w);
Transmogrify(WidgetFactory());</span></pre>
<p><span class="koboSpan" id="kobo.196.1">So, how do we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">Transmogrify()</span></strong><span class="koboSpan" id="kobo.198.1"> on a widget after we properly assumed ownership? </span><span class="koboSpan" id="kobo.198.2">This is still done with a </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">raw pointer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.200.1">
std::unique_ptr&lt;Widget&gt; w(WidgetFactory());
Transmogrify(w.get());
Transmogrify(&amp;*w);     // same as above </span><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.201.1">if w is not null</span></pre>
<p><span class="koboSpan" id="kobo.202.1">But what about the</span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.203.1"> stack variables? </span><span class="koboSpan" id="kobo.203.2">Can exclusive ownership be transferred to someone else before the variable is destroyed? </span><span class="koboSpan" id="kobo.203.3">This is going to be slightly more complicated—the memory for the object is allocated on the stack and is going away, so some amount of copying is involved. </span><span class="koboSpan" id="kobo.203.4">Exactly how much copying depends on whether the object is movable. </span><span class="koboSpan" id="kobo.203.5">Moving, in general, transfers the ownership from the moved-from object to the moved-to one. </span><span class="koboSpan" id="kobo.203.6">This can be used for return values but is more often used for passing arguments to functions that take exclusive ownership. </span><span class="koboSpan" id="kobo.203.7">Such functions must be declared to take the parameters by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">rvalue</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.205.1">reference </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">T&amp;&amp;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.208.1">
// Example 05
void Consume(Widget&amp;&amp; w) {
  auto my_w = std::move(w);
    ...
</span><span class="koboSpan" id="kobo.208.2">}
Widget w, w1;
Consume(std::move(w));    // No more w
// w is in a moved-from state now
Consume(w1);    // Does not compile - must consent to move</span></pre>
<p><span class="koboSpan" id="kobo.209.1">Note that the caller must explicitly give up ownership by wrapping the argument in </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">std::move</span></strong><span class="koboSpan" id="kobo.211.1">. </span><span class="koboSpan" id="kobo.211.2">This is one of the advantages of this idiom; without</span><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.212.1"> it, an ownership-transferring call would look exactly the same a</span><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.213.1">s a </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">regular call.</span></span></p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.215.1">Expressing shared ownership</span></h2>
<p><span class="koboSpan" id="kobo.216.1">The last type of ownership we </span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.217.1">need to cover is shared ownership, where multiple entities own the object equally. </span><span class="koboSpan" id="kobo.217.2">First, a word of caution—shared ownership is often misused, or over-used. </span><span class="koboSpan" id="kobo.217.3">Consider the preceding example, where a function was passed a shared pointer to an object it did not need to own. </span><span class="koboSpan" id="kobo.217.4">It is tempting to let the reference counting deal with the ownership of objects and </span><em class="italic"><span class="koboSpan" id="kobo.218.1">not worry about deletion</span></em><span class="koboSpan" id="kobo.219.1">. </span><span class="koboSpan" id="kobo.219.2">However, this is often a sign of poor design. </span><span class="koboSpan" id="kobo.219.3">In most systems, at some level, there is clear ownership of resources, and this should be reflected in the chosen design of resource management. </span><span class="koboSpan" id="kobo.219.4">The </span><em class="italic"><span class="koboSpan" id="kobo.220.1">not worry about deletion</span></em><span class="koboSpan" id="kobo.221.1"> concern remains valid; explicit deletion of objects should be rare, but automatic deletion does not require shared ownership, merely a clearly expressed one (unique pointers, data members, and containers provide automatic deletion just </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">as well).</span></span></p>
<p><span class="koboSpan" id="kobo.223.1">That being said, there are definite cases for shared ownership. </span><span class="koboSpan" id="kobo.223.2">The most common valid applications of shared ownership are at a low level, inside data structures such as lists, trees, and more. </span><span class="koboSpan" id="kobo.223.3">A data element may be owned by other nodes of the same data structure, by any number of iterators currently pointing to it, and, possibly by some temporary variables inside data structure member functions that operate on the entire structure or a part of it (such as rebalancing a tree). </span><span class="koboSpan" id="kobo.223.4">The ownership of the entire data structure is usually clear in a well-thought-out design. </span><span class="koboSpan" id="kobo.223.5">But the ownership of each node, or data element, may be truly shared in the sense that any owner is equal to any other; none is priv</span><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.224.1">ileged </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">or primary.</span></span></p>
<p><span class="koboSpan" id="kobo.226.1">In C++, the notion of shared</span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.227.1"> ownership is expressed through a shared </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">pointer, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">std::shared_ptr</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.231.1">
// Example 06
struct ListNode {
  T data;
  std::shared_ptr&lt;ListNode&gt; next, prev;
};
class ListIterator {
  ...
</span><span class="koboSpan" id="kobo.231.2">  std::shared_ptr&lt;ListNode&gt; node_;
};
class List {
  ...
</span><span class="koboSpan" id="kobo.231.3">  std::shared_ptr&lt;ListNode&gt; head_;
};</span></pre>
<p><span class="koboSpan" id="kobo.232.1">The advantage of this</span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.233.1"> design is that a list element that was unlinked from the list remains alive for as long as there is a way to access it through an iterator. </span><span class="koboSpan" id="kobo.233.2">This is not the way </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">std::list</span></strong><span class="koboSpan" id="kobo.235.1"> is done, and it does not provide such guarantees (deleting a </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">std::list</span></strong><span class="koboSpan" id="kobo.237.1"> object invalidates all iterators). </span><span class="koboSpan" id="kobo.237.2">Note that the doubly linked list of shared pointers makes it so any two consecutive nodes in the list own each other and neither is deleted even when the list head is deleted; this leaks the owned objects. </span><span class="koboSpan" id="kobo.237.3">For this reason, a real design would likely use </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">std::weak_pointer</span></strong><span class="koboSpan" id="kobo.239.1"> for one of </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">next</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.241.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">prev</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.244.1">Such complications aside, this may be a valid design for certain applications where the iterators need to own the data they refer to even after the list is deleted or some elements are erased from the list. </span><span class="koboSpan" id="kobo.244.2">One example is a thread-safe list, where it is very difficult to guarantee that one thread does not erase a list element while another still has an iterator pointing to it. </span><span class="koboSpan" id="kobo.244.3">Note that this particular application would also require atomic shared pointers, which are only available in C++ 20 (or you can write your own using </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">C++ 11).</span></span></p>
<p><span class="koboSpan" id="kobo.246.1">Now, what about functions taking shared pointers as parameters? </span><span class="koboSpan" id="kobo.246.2">In a program that follows good memory ownership practices, such a function conveys to the caller that it intends to take partial ownership that lasts longer than the function call itself—a copy of the shared pointer will be created. </span><span class="koboSpan" id="kobo.246.3">In the concurrent context, it may also indicate that the function needs to protect the object from deletion by another thread for at least as long as </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">it’s executing.</span></span></p>
<p><span class="koboSpan" id="kobo.248.1">There are several disadvantages to shared ownership that you must keep in mind. </span><span class="koboSpan" id="kobo.248.2">The best-known one is the bane of shared pointers, that is, the circular dependency. </span><span class="koboSpan" id="kobo.248.3">If two objects with shared pointers point to each other, the entire pair remains </span><em class="italic"><span class="koboSpan" id="kobo.249.1">in use </span></em><span class="koboSpan" id="kobo.250.1">indefinitely. </span><span class="koboSpan" id="kobo.250.2">C++ offers a solution to that in the form of </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">std::weak_ptr</span></strong><span class="koboSpan" id="kobo.252.1">, a counterpart to the shared pointer that provides a safe pointer to an object that may have already been deleted. </span><span class="koboSpan" id="kobo.252.2">If the previously mentioned pair of objects uses one shared and one weak pointer, the circular dependency </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">is broken.</span></span></p>
<p><span class="koboSpan" id="kobo.254.1">The circular dependency problem is real, but it happens more often in designs where shared ownership is used to conceal the larger problem of unclear resource ownership. </span><span class="koboSpan" id="kobo.254.2">However, there are other downsides to shared ownership. </span><span class="koboSpan" id="kobo.254.3">The performance of a shared pointer is always going to be lower than that of a raw pointer. </span><span class="koboSpan" id="kobo.254.4">On the other hand, a unique pointer can be just as efficient as a raw pointer (and in fact, </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.256.1"> is). </span><span class="koboSpan" id="kobo.256.2">When the shared pointer is first created, an additional memory allocation for the reference count must </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">take place.</span></span></p>
<p><span class="koboSpan" id="kobo.258.1">In C++ 11, </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">std::make_shared</span></strong><span class="koboSpan" id="kobo.260.1"> can be </span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.261.1">used to combine the allocations for the object itself and the reference counter, but this implies that the object is created with the intent to share (often, the object Factory returns unique pointers, some of which are later converted to shared pointers). </span><span class="koboSpan" id="kobo.261.2">Copying or deleting a shared pointer must also increment or decrement the reference counter. </span><span class="koboSpan" id="kobo.261.3">Shared pointers are often attractive in concurrent data structures, where, at least at the low level, the notion of ownership may indeed be fuzzy, with several accesses to the same object happening at the same time. </span><span class="koboSpan" id="kobo.261.4">However, designing a shared pointer to be thread-safe in all contexts is not easy and carries additional </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">runtime overhead.</span></span></p>
<p><span class="koboSpan" id="kobo.263.1">So far, we have mostly restricted ourselves to pointers as means of owning objects (and their memory and other resources). </span><span class="koboSpan" id="kobo.263.2">Non-ownership has been similarly expressed through raw pointers and references or simple non-owning pointers. </span><span class="koboSpan" id="kobo.263.3">However, this is not the only way to own resources (and we did mention that the most common form of exclusive ownership is a stack variable). </span><span class="koboSpan" id="kobo.263.4">We are now going to see how resource-owning objects can be used directly to express both ownership </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">and non-ownership.</span></span></p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.265.1">Owning objects and views</span></h1>
<p><span class="koboSpan" id="kobo.266.1">C++ has not been limited </span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.267.1">to owning pointers since its creation: any object can own resources, and we already mentioned that the simplest way to express exclusive ownership is to</span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.268.1"> create a local variable on the stack. </span><span class="koboSpan" id="kobo.268.2">Of course, any of such objects can also be owned by a pointer (unique or shared) and when non-owning access is desired, these objects are commonly accessed through raw pointers or references. </span><span class="koboSpan" id="kobo.268.3">However, in C++17 and C++20 a different pattern has emerged, and it is </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">worth exploring.</span></span></p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.270.1">Resource-owning objects</span></h2>
<p><span class="koboSpan" id="kobo.271.1">Every C++ programmer is</span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.272.1"> familiar with resource-owning objects; perhaps the most common one is </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">std::string</span></strong><span class="koboSpan" id="kobo.274.1"> – an object that owns a character string. </span><span class="koboSpan" id="kobo.274.2">Of course, it also has a lot of specialized member functions for operating on strings, but from the point of view of memory ownership, </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">std::string</span></strong><span class="koboSpan" id="kobo.276.1"> is essentially an owning </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">char*</span></strong><span class="koboSpan" id="kobo.278.1"> pointer. </span><span class="koboSpan" id="kobo.278.2">Similarly, </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">std::vector</span></strong><span class="koboSpan" id="kobo.280.1"> is an owning object for an array of objects of </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">arbitrary type.</span></span></p>
<p><span class="koboSpan" id="kobo.282.1">The most common way to construct such objects is either as local variables or as data members of a class. </span><span class="koboSpan" id="kobo.282.2">In the latter case, the issue of who owns the entire class is managed elsewhere, but, within the class, all data members are owned exclusively by the object itself. </span><span class="koboSpan" id="kobo.282.3">Consider this </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">simple example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.284.1">
class C {
  std::string s_;
};
 …
std::vector&lt;int&gt; v = … ;    // v owns the array of int
C c;                       // c owns the string s</span></pre>
<p><span class="koboSpan" id="kobo.285.1">So far, we have not said anything new compared to the section on exclusive ownership just a few pages earlier in this chapter. </span><span class="koboSpan" id="kobo.285.2">However, we have subtly changed the focus from owning pointers to owning objects. </span><span class="koboSpan" id="kobo.285.3">As long as we focus on the ownership aspect, these objects are essentially specialized owning (unique) pointers. </span><span class="koboSpan" id="kobo.285.4">There is an important difference, however: most such objects convey additional information, such as the length of the string for </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">std::string</span></strong><span class="koboSpan" id="kobo.287.1"> or the size of the array for </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">std::vector</span></strong><span class="koboSpan" id="kobo.289.1">. </span><span class="koboSpan" id="kobo.289.2">Keep this in mind: it is going to come up again when we get to the changes brought </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">by C++17/20.</span></span></p>
<p><span class="koboSpan" id="kobo.291.1">While resource-owning</span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.292.1"> objects have been around since the beginning of C++, they themselves have been often owned through pointers. </span><span class="koboSpan" id="kobo.292.2">There are, perhaps, two main reasons for this; both have been rendered obsolete by C++ advances. </span><span class="koboSpan" id="kobo.292.3">The first reason to own, for example, a string via an owning pointer is the need to transfer ownership. </span><span class="koboSpan" id="kobo.292.4">A stack object is destroyed at the end of the scope. </span><span class="koboSpan" id="kobo.292.5">A class data member is destroyed when the object is destroyed. </span><span class="koboSpan" id="kobo.292.6">In either case, there is no way to transfer the ownership of the object itself, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">std::string</span></strong><span class="koboSpan" id="kobo.294.1">, to someone else. </span><span class="koboSpan" id="kobo.294.2">However, if we focus on the ownership aspect, then the string object itself is just a (decorated) owning pointer, and the goal is to transfer the ownership of the underlying resource (the character string for </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">std::string</span></strong><span class="koboSpan" id="kobo.296.1">) to another owner. </span><span class="koboSpan" id="kobo.296.2">When we put it this way, the answer is obvious: since C++11, the string has move semantics, and moving a string is barely more expensive than moving a pointer (remember, the string is an owning pointer that also knows the length, so that has to be </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">moved too).</span></span></p>
<p><span class="koboSpan" id="kobo.298.1">We can say, more generally, that there is no reason to own a cheap-to-move owning object via a pointer if the only reason is ownership transfer. </span><span class="koboSpan" id="kobo.298.2">For example, consider this string </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">builder class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.300.1">
class Builder {
  std::string* str_;
  public:
  Builder(…) : str_(new std::string){
    … construct string str_ …
  }
  std::string* get(){
    std::string* tmp = str_;
    str_ = nullptr;
    return tmp;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.301.1">While it gets the job done, a much better way to write the same class is to simply move </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">the string:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.303.1">
// Example 07
class Builder {
  std::string str_;
  public:
  Builder(…){ … construct string str_ … }
  std::string get(){ return std::move(str_); }
};
std::string my_string = Builder(…).get();</span></pre>
<p><span class="koboSpan" id="kobo.304.1">The same is true for factories </span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.305.1">that construct owning cheap-to-move objects. </span><span class="koboSpan" id="kobo.305.2">Instead of returning them via </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.307.1">, the factory can return the </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">object itself:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.309.1">
std::string MakeString(…) {
  std::string str;
  … construct the string …
  return str;
}
std::string my_string = MakeString(…);</span></pre>
<p><span class="koboSpan" id="kobo.310.1">The return value may</span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.311.1"> benefit from the return-value optimization (the compiler constructs the return value directly in the memory allocated for the final object, </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">my_string</span></strong><span class="koboSpan" id="kobo.313.1">). </span><span class="koboSpan" id="kobo.313.2">But even without this optimization, we have a guarantee that there is no copying of the string here, only moving (if this move is optimized away, the optimization is sometimes </span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.314.1">called </span><strong class="bold"><span class="koboSpan" id="kobo.315.1">move elision</span></strong><span class="koboSpan" id="kobo.316.1">, similar to the better-known </span><strong class="bold"><span class="koboSpan" id="kobo.317.1">copy elision</span></strong><span class="koboSpan" id="kobo.318.1">, which</span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.319.1"> optimizes away </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">copy constructors).</span></span></p>
<p><span class="koboSpan" id="kobo.321.1">The second reason to use owning pointers for resource-owning objects is that the object’s existence itself may </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">be conditional:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.323.1">
std::unique_ptr&lt;std::string*&gt; str;
if (need_string) str.reset(new std::string(…args…));</span></pre>
<p><span class="koboSpan" id="kobo.324.1">In many cases, an “</span><em class="italic"><span class="koboSpan" id="kobo.325.1">empty</span></em><span class="koboSpan" id="kobo.326.1">” object can be used instead, such as a zero-length string. </span><span class="koboSpan" id="kobo.326.2">Again, for many owning objects, and certainly for all cheap-to-move STL containers, the cost of constructing such an object is trivial. </span><span class="koboSpan" id="kobo.326.3">But there could be a meaningful difference between the empty string and no string at all (that is, an empty string could be a valid result, and an absence of any string signifies something to the rest of the program). </span><span class="koboSpan" id="kobo.326.4">In C++17, we have a straightforward way to express this behavior </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">std::optional</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.330.1">
std::optional&lt;std::string&gt; str;
if (need_string) str.emplace(…args…);</span></pre>
<p><span class="koboSpan" id="kobo.331.1">The object of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">std::optional&lt;std::string&gt;</span></strong><span class="koboSpan" id="kobo.333.1"> type may contain a string or be empty. </span><span class="koboSpan" id="kobo.333.2">The non-empty </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">std::optional</span></strong><span class="koboSpan" id="kobo.335.1"> owns the object it contains (deleting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">std::optional</span></strong><span class="koboSpan" id="kobo.337.1"> will also delete the string). </span><span class="koboSpan" id="kobo.337.2">Unlike </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">std::unique_pointer</span></strong><span class="koboSpan" id="kobo.339.1">, there are no heap memory allocations here: the </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">std::optional</span></strong><span class="koboSpan" id="kobo.341.1"> object contains enough space within it to store a </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">std::string</span></strong><span class="koboSpan" id="kobo.343.1"> object. </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">std::optional</span></strong><span class="koboSpan" id="kobo.345.1"> is also movable, just like the string itself, so this pattern can be combined with the previous one. </span><span class="koboSpan" id="kobo.345.2">In general, we can say that in modern C++ there is no reason to own lightweight owning objects such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">std::string</span></strong><span class="koboSpan" id="kobo.347.1"> indirectly. </span><span class="koboSpan" id="kobo.347.2">However, expressing the non-ownership of such objects has not received </span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.348.1">as much attention </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">until recently.</span></span></p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.350.1">Non-owning access to resource-owning objects</span></h2>
<p><span class="koboSpan" id="kobo.351.1">We have seen how a </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">std::string</span></strong><span class="koboSpan" id="kobo.353.1"> object</span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.354.1"> can, for most purposes, replace an owning pointer to </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">char*</span></strong><span class="koboSpan" id="kobo.356.1"> (or to </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">std::string</span></strong><span class="koboSpan" id="kobo.358.1">). </span><span class="koboSpan" id="kobo.358.2">How do we, then, express non-owning access? </span><span class="koboSpan" id="kobo.358.3">Let us say that we need to pass a string to a function that operates on the string but does not take ownership of it (does not destroy it). </span><span class="koboSpan" id="kobo.358.4">This is a </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">trivial exercise:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.360.1">
void work_on_string(const std::string&amp; str);
std::string my_string = …;
work_on_string(my_string);</span></pre>
<p><span class="koboSpan" id="kobo.361.1">This is what we have been doing since C++ was created. </span><span class="koboSpan" id="kobo.361.2">But this simplicity hides a profound distinction: remember that, as long as we don’t care about all the extra methods and the features they provide, </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">std::string</span></strong><span class="koboSpan" id="kobo.363.1"> is just an owning pointer to a character string that also knows its length. </span><span class="koboSpan" id="kobo.363.2">So, how would we handle the same situation if we used an owning pointer instead of a string? </span><span class="koboSpan" id="kobo.363.3">The corresponding pointer is </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">std::unique_ptr&lt;char[]&gt;</span></strong><span class="koboSpan" id="kobo.365.1">, so we would write something </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.367.1">
void work_on_string(const char* str);
std::unique_ptr&lt;char[]&gt; my_string(new char[…length…]);
… initialize the string …
work_on_string(my_string.get());</span></pre>
<p><span class="koboSpan" id="kobo.368.1">Following the earlier guidelines, we passed a non-owning raw pointer to the function. </span><span class="koboSpan" id="kobo.368.2">We definitely would not write </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">this declaration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.370.1">
void work_on_string(const std::unique_ptr&lt;char[]&gt;&amp; str);</span></pre>
<p><span class="koboSpan" id="kobo.371.1">Yet we do this without a second thought when the same character array is owned by a </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">std::string</span></strong><span class="koboSpan" id="kobo.373.1"> object. </span><span class="koboSpan" id="kobo.373.2">Why do we approach these very similar problems so differently? </span><span class="koboSpan" id="kobo.373.3">This is the time to remember why a string is not just an owning pointer restricted to character arrays; it contains more information than just the pointer: it also knows the length of the string. </span><span class="koboSpan" id="kobo.373.4">There was no good way in C++ to grant non-owning access to such “</span><em class="italic"><span class="koboSpan" id="kobo.374.1">rich</span></em><span class="koboSpan" id="kobo.375.1">” owning pointers, short of passing the entire pointer object by reference. </span><span class="koboSpan" id="kobo.375.2">By contrast, a unique pointer (or any other owning pointer) contains the same information as a basic pointer, so when ownership is not required, the owning pointer naturally reduces to a raw pointer without any </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">information loss.</span></span></p>
<p><span class="koboSpan" id="kobo.377.1">The difference is about more than just symmetry. </span><span class="koboSpan" id="kobo.377.2">Consider that passing a string by a </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">const</span></strong><span class="koboSpan" id="kobo.379.1"> reference prevents the function </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">work_on_string</span></strong><span class="koboSpan" id="kobo.381.1"> from changing the content of the string. </span><span class="koboSpan" id="kobo.381.2">On the other hand, a non-</span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">const</span></strong><span class="koboSpan" id="kobo.383.1"> reference allows the function to clear the string (release the memory it owns), which is an ownership aspect. </span><span class="koboSpan" id="kobo.383.2">We are forced to muddle the clarity of intent by mixing together two unrelated types of access we can grant to a function: the ability to change the content of the data and the ownership of </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">the data.</span></span></p>
<p><span class="koboSpan" id="kobo.385.1">C++17 addressed this problem in a very limited context: specifically for strings, it introduced a new type </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">std::string_view</span></strong><span class="koboSpan" id="kobo.387.1">. </span><span class="koboSpan" id="kobo.387.2">A string view is a (</span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">const</span></strong><span class="koboSpan" id="kobo.389.1">) non-owning pointer to a string that also stores the length of the string. </span><span class="koboSpan" id="kobo.389.2">In other words, it is a perfect non-owning equivalent to </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">std::string</span></strong><span class="koboSpan" id="kobo.391.1">: a string view to a string is exactly what a </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">const</span></strong><span class="koboSpan" id="kobo.393.1"> raw pointer is to a unique pointer. </span><span class="koboSpan" id="kobo.393.2">Now, to grant non-owning access to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">std::string</span></strong><span class="koboSpan" id="kobo.395.1"> object, </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">we write:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.397.1">
// Example 09
void work_on_string(std::string_view str);
std::string my_string = …;
work_on_string(my_string);</span></pre>
<p><span class="koboSpan" id="kobo.398.1">In contrast, a function that takes ownership of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">std::string</span></strong><span class="koboSpan" id="kobo.400.1"> object must still take it by reference. </span><span class="koboSpan" id="kobo.400.2">Specifically, use an rvalue reference to transfer </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">the ownership:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.402.1">
// Example 09
void consume_string(std::string&amp;&amp; str);
std::string my_string = …;
consume_string(std::move(my_string));
// Do not use my_string anymore!</span></pre>
<p><span class="koboSpan" id="kobo.403.1">Use a non-</span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">const</span></strong><span class="koboSpan" id="kobo.405.1"> lvalue reference only to allow the function to change the string; in C++17, there is no good </span><em class="italic"><span class="koboSpan" id="kobo.406.1">rich pointer</span></em><span class="koboSpan" id="kobo.407.1"> equivalent to a non-</span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">const</span></strong><span class="koboSpan" id="kobo.409.1"> raw pointer. </span><span class="koboSpan" id="kobo.409.2">There is probably no need to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">const std::string&amp;</span></strong><span class="koboSpan" id="kobo.411.1"> except when the existing interfaces require it since </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">std::string_view</span></strong><span class="koboSpan" id="kobo.413.1"> offers </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">equivalent functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.415.1">There are other benefits </span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.416.1">and advantages of using </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">std::string_view</span></strong><span class="koboSpan" id="kobo.418.1"> (in particular, it greatly simplifies writing common code for processing C and C++ strings), but in this chapter, we focus on the ownership aspect. </span><span class="koboSpan" id="kobo.418.2">Also, remember that the string view is limited to character strings. </span><span class="koboSpan" id="kobo.418.3">We could have the exact same discussion about another owning class, for </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">example, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">std::vector&lt;int&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.422.1">We now see a new pattern emerge: for a “</span><em class="italic"><span class="koboSpan" id="kobo.423.1">rich</span></em><span class="koboSpan" id="kobo.424.1">” owning pointer that, in addition to owning memory, contains some information about the data it owns, the corresponding non-owning object (the equivalent of a raw pointer) should be a view object that contains the same information but does not own the resource. </span><span class="koboSpan" id="kobo.424.2">We find this view object in C++20 as </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">std::span</span></strong><span class="koboSpan" id="kobo.426.1">. </span><span class="koboSpan" id="kobo.426.2">Until then, the only good way to grant non-owning access to a vector of integers was to pass it </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">by reference:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.428.1">
void work_on_data(std::vector&lt;int&gt;&amp; data);
std::vector&lt;int&gt; my_data = …;
work_on_data(my_data);</span></pre>
<p><span class="koboSpan" id="kobo.429.1">In C++20, we can use the span to clearly differentiate the non-owning view (raw pointer equivalent) from the owning object (unique </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">pointer equivalent):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.431.1">
// Example 10
void ModifyData(std::span&lt;int&gt; data);
std::vector&lt;int&gt; my_data = …;
ModifyData(my_data); // Can change my_data</span></pre>
<p><span class="koboSpan" id="kobo.432.1">Thus, </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">std::span&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.434.1"> is a </span><em class="italic"><span class="koboSpan" id="kobo.435.1">rich pointer</span></em><span class="koboSpan" id="kobo.436.1"> equivalent to </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">int*</span></strong><span class="koboSpan" id="kobo.438.1">—it contains a non-</span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">const</span></strong><span class="koboSpan" id="kobo.440.1"> pointer and the size is cheap to copy and does not own the resource it points to. </span><span class="koboSpan" id="kobo.440.2">Unlike </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">std::string_view</span></strong><span class="koboSpan" id="kobo.442.1">, we can modify the object accessed through a span. </span><span class="koboSpan" id="kobo.442.2">But if we want the equivalent to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">const</span></strong><span class="koboSpan" id="kobo.444.1"> pointer, we can use </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">std::span&lt;const int&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.447.1">
// Example 10
void UseData(std::span&lt;const int&gt; data);
std::vector&lt;int&gt; my_data = …;
UseData(my_data); // Cannot change my_data</span></pre>
<p><span class="koboSpan" id="kobo.448.1">Since </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">std::string</span></strong><span class="koboSpan" id="kobo.450.1"> contains a contiguous array of characters, it too can be used with a span, in this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">std::span&lt;char&gt;</span></strong><span class="koboSpan" id="kobo.452.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">std::span&lt;const char&gt;</span></strong><span class="koboSpan" id="kobo.454.1">. </span><span class="koboSpan" id="kobo.454.2">The latter is essentially the same as </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">std::string_view</span></strong><span class="koboSpan" id="kobo.456.1">, including the option to construct them from string literals. </span><span class="koboSpan" id="kobo.456.2">The former is the equivalent of a non-</span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">const</span></strong><span class="koboSpan" id="kobo.458.1"> pointer </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">char</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.462.1">The span pairs well with a vector or a string because they offer a non-owning view of an array. </span><span class="koboSpan" id="kobo.462.2">But it does not work for other STL containers since they all allocate memory in multiple non-contiguous</span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.463.1"> allocations. </span><span class="koboSpan" id="kobo.463.2">For that, we need to use the C++20 ranges library. </span><span class="koboSpan" id="kobo.463.3">For example, the generalization of the preceding non-owning vector access to an arbitrary container can be written </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.465.1">
// Example 11
void ModifyData(std::ranges::view auto data) { … }
std::list&lt;int&gt; my_data = …;
ModifyData(std::views::all(my_data));</span></pre>
<p><span class="koboSpan" id="kobo.466.1">If you have never seen a C++20 template, this takes some getting used to. </span><span class="koboSpan" id="kobo.466.2">The first line is a template function: </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">auto</span></strong><span class="koboSpan" id="kobo.468.1"> parameters make “</span><em class="italic"><span class="koboSpan" id="kobo.469.1">ordinary</span></em><span class="koboSpan" id="kobo.470.1">” functions into templates even without the </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">template</span></strong><span class="koboSpan" id="kobo.472.1"> keyword. </span><span class="koboSpan" id="kobo.472.2">The incantation </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">std::ranges::view</span></strong><span class="koboSpan" id="kobo.474.1"> before </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">auto</span></strong><span class="koboSpan" id="kobo.476.1"> restricts the template parameters to those that satisfy the view concept. </span><span class="koboSpan" id="kobo.476.2">A view is a container-like object that has </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">begin()</span></strong><span class="koboSpan" id="kobo.478.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">end()</span></strong><span class="koboSpan" id="kobo.480.1"> member functions and, in addition, must be cheap to move and either cheap to copy or non-copyable (this is, of course, a loose paraphrasing of the exact requirements enumerated by the standard). </span><span class="koboSpan" id="kobo.480.2">We could have written the same function with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">template</span></strong><span class="koboSpan" id="kobo.482.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">requires</span></strong><span class="koboSpan" id="kobo.484.1"> keywords, but this compact syntax is idiomatic </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">in C++20.</span></span></p>
<p><span class="koboSpan" id="kobo.486.1">Note that, in this concept-based coding style, the restrictions on the function arguments are specified by the concept requirements. </span><span class="koboSpan" id="kobo.486.2">We could have written the same template function to require ranges instead </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">of views:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.488.1">
void ModifyData(std::ranges::range auto data) { … }
std::list&lt;int&gt; my_data = …;
ModifyData(my_data);</span></pre>
<p><span class="koboSpan" id="kobo.489.1">Ranges are essentially arbitrary objects with </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">begin()</span></strong><span class="koboSpan" id="kobo.491.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">end()</span></strong><span class="koboSpan" id="kobo.493.1">, so </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">std::list</span></strong><span class="koboSpan" id="kobo.495.1"> is a range (but not a view, it can be copied but not cheaply). </span><span class="koboSpan" id="kobo.495.2">Note that, as written, the function takes the argument by value, so a copy is made. </span><span class="koboSpan" id="kobo.495.3">Unless that was the intent (and in this case, it is not), the correct way to write this function is </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.497.1">
void ModifyData(std::ranges::range auto&amp;&amp; data) { … }</span></pre>
<p><span class="koboSpan" id="kobo.498.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">const</span></strong><span class="koboSpan" id="kobo.500.1"> reference would </span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.501.1">also work if we wanted to express non-modifying access. </span><span class="koboSpan" id="kobo.501.2">But the important point to note is that we did not have to do the same for views: by restricting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">work_on_data</span></strong><span class="koboSpan" id="kobo.503.1"> function to accept only views, we have limited it to cheap-to-copy types similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">std::string_view</span></strong><span class="koboSpan" id="kobo.505.1"> (or a raw pointer, for that matter). </span><span class="koboSpan" id="kobo.505.2">Indeed, passing a range by reference is exactly like passing a string or a vector itself: this gives the callee access to the ownership. </span><span class="koboSpan" id="kobo.505.3">If we want to write a function that explicitly does not take ownership of a range, the view is the right way to </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">express this.</span></span></p>
<p><span class="koboSpan" id="kobo.507.1">It is still too early to talk about patterns for C++20 ranges: they have not been around long enough to establish commonly recognized and accepted use practices (a necessary requirement for a pattern) and the library is still incomplete. </span><span class="koboSpan" id="kobo.507.2">C++23 is expected to contain several significant enhancements (in particular, there is no good equivalent to </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">std::span&lt;const char&gt;</span></strong><span class="koboSpan" id="kobo.509.1"> in C++20 ranges – it is going to be added </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">in C++23).</span></span></p>
<p><span class="koboSpan" id="kobo.511.1">However, we can confidently talk about the more general pattern becoming established in C++: resource ownership, including memory, should be handled by owning objects, while non-owning access should be granted through views. </span><span class="koboSpan" id="kobo.511.2">The owning objects can be smart pointers or more complex and specialized container objects. </span><span class="koboSpan" id="kobo.511.3">These containers, in addition to managing the memory in more complex ways, embed more information about the data they contain. </span><span class="koboSpan" id="kobo.511.4">In general, for each container, there should be a corresponding view that grants non-owning access while preserving all the additional information. </span><span class="koboSpan" id="kobo.511.5">For smart pointers, this view is a raw pointer or a reference. </span><span class="koboSpan" id="kobo.511.6">For </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">std::string</span></strong><span class="koboSpan" id="kobo.513.1">, this view is </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">std::string_view</span></strong><span class="koboSpan" id="kobo.515.1">. </span><span class="koboSpan" id="kobo.515.2">For </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">std::vector</span></strong><span class="koboSpan" id="kobo.517.1">, arrays, and any other containers that own contiguous memory, you will want </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">std::span</span></strong><span class="koboSpan" id="kobo.519.1">. </span><span class="koboSpan" id="kobo.519.2">For arbitrary containers, the</span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.520.1"> corresponding views may be found in the C++20 ranges library; for a custom container, you may have to write your own view objects as well (just make sure they sa</span><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.521.1">tisfy the relevant </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">view concepts).</span></span></p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.523.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.524.1">In C++, memory ownership is really just shorthand for object ownership, which, in turn, is the way to manage arbitrary resources, their ownership, and access. </span><span class="koboSpan" id="kobo.524.2">We have reviewed the contemporary idioms that the C++ community has developed to express different types of memory ownership. </span><span class="koboSpan" id="kobo.524.3">C++ allows the programmer to express exclusive or shared memory ownership. </span><span class="koboSpan" id="kobo.524.4">Just as important is expressing </span><em class="italic"><span class="koboSpan" id="kobo.525.1">non-ownership</span></em><span class="koboSpan" id="kobo.526.1"> in programs that are agnostic about the ownership of resources. </span><span class="koboSpan" id="kobo.526.2">We have also learned about the practices and attributes of resource ownership in a </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">well-designed program.</span></span></p>
<p><span class="koboSpan" id="kobo.528.1">We now have the idiomatic language to clearly express which entity in the program owns each object or resource, and when non-owning access is granted. </span><span class="koboSpan" id="kobo.528.2">The next chapter covers the idiom for the simplest operation o</span><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.529.1">n resources: the exchange, </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">or swap.</span></span></p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.531.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.532.1">Why is it important to clearly express memory ownership in </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">a program?</span></span></li>
<li><span class="koboSpan" id="kobo.534.1">What are the common problems that arise from unclear </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">memory ownership?</span></span></li>
<li><span class="koboSpan" id="kobo.536.1">What types of memory ownership can be expressed </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">in C++?</span></span></li>
<li><span class="koboSpan" id="kobo.538.1">How do you write non-memory-owning functions </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">and classes?</span></span></li>
<li><span class="koboSpan" id="kobo.540.1">Why should exclusive memory ownership be preferred to a </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">shared one?</span></span></li>
<li><span class="koboSpan" id="kobo.542.1">How do you express exclusive memory ownership </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">in C++?</span></span></li>
<li><span class="koboSpan" id="kobo.544.1">How do you express shared memory ownership </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">in C++?</span></span></li>
<li><span class="koboSpan" id="kobo.546.1">What are the potential downsides of shared </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">memory ownership?</span></span></li>
<li><span class="koboSpan" id="kobo.548.1">What are views? </span><span class="koboSpan" id="kobo.548.2">How is a string view better than passing a string </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">by reference?</span></span></li>
</ol>
<h1 id="_idParaDest-61"><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.550.1">Further reading</span></h1>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.551.1">C++20 STL Cookbook</span></em><span class="koboSpan" id="kobo.552.1"> by </span><em class="italic"><span class="koboSpan" id="kobo.553.1">Bill </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.554.1">Weinman</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">: </span></span><a href="https://www.packtpub.com/product/c20-stl-cookbook/9781803248714"><span class="No-Break"><span class="koboSpan" id="kobo.556.1">https://www.packtpub.com/product/c20-stl-cookbook/9781803248714</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.557.1">Template Metaprogramming with C++</span></em><span class="koboSpan" id="kobo.558.1"> by </span><em class="italic"><span class="koboSpan" id="kobo.559.1">Marius </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.560.1">Bancila</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">: </span></span><a href="https://www.packtpub.com/product/template-metaprogramming-with-c/9781803243450"><span class="No-Break"><span class="koboSpan" id="kobo.562.1">https://www.packtpub.com/product/template-metaprogramming-with-c/9781803243450</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.563.1">C++ Data Structures and Algorithms</span></em><span class="koboSpan" id="kobo.564.1"> by </span><em class="italic"><span class="koboSpan" id="kobo.565.1">Wisnu </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.566.1">Anggoro</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">: </span></span><a href="https://www.packtpub.com/application-development/c-data-structures-and-algorithms"><span class="No-Break"><span class="koboSpan" id="kobo.568.1">https://www.packtpub.com/application-development/c-data-structures-and-algorithms</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.569.1">Expert C++ Programming</span></em><span class="koboSpan" id="kobo.570.1"> by </span><em class="italic"><span class="koboSpan" id="kobo.571.1">Jeganathan Swaminathan</span></em><span class="koboSpan" id="kobo.572.1">, </span><em class="italic"><span class="koboSpan" id="kobo.573.1">Maya Posch</span></em><span class="koboSpan" id="kobo.574.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.575.1">Jacek </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.576.1">Galowicz</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">: </span></span><a href="https://www.packtpub.com/application-development/expert-c-programming"><span class="No-Break"><span class="koboSpan" id="kobo.578.1">https://www.packtpub.com/application-development/expert-c-programming</span></span></a></li>
</ul>
</div>


<div class="Content" id="_idContainer012">
<h1 id="_idParaDest-62"><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.1.1">Part 2: Common C++ Idioms</span></h1>
<p><span class="koboSpan" id="kobo.2.1">This part describes some of the more common C++ idioms: established, universally recognized ways to express a specific idea or implement a frequently needed task. </span><span class="koboSpan" id="kobo.2.2">The boundary between “patterns” and “idioms” is fuzzy at best. </span><span class="koboSpan" id="kobo.2.3">In this book, we consider more complete design solutions to be patterns, while simpler techniques are idioms. </span><span class="koboSpan" id="kobo.2.4">In other words, choosing a pattern may influence the design of your entire application or its major component, while using an idiom is more of an implementation decision that has been learned from someone </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">else’s mistakes.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B19262_04.xhtml#_idTextAnchor152"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 4</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Swap - From Simple to Subtle</span></em></li>
<li><a href="B19262_05.xhtml#_idTextAnchor199"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">A Comprehensive Look at RAII</span></em></li>
<li><a href="B19262_06.xhtml#_idTextAnchor266"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 6</span></em></a><span class="koboSpan" id="kobo.13.1">, </span><em class="italic"><span class="koboSpan" id="kobo.14.1">Understanding Type Erasure</span></em></li>
<li><a href="B19262_07.xhtml#_idTextAnchor314"><em class="italic"><span class="koboSpan" id="kobo.15.1">Chapter 7</span></em></a><span class="koboSpan" id="kobo.16.1">, </span><em class="italic"><span class="koboSpan" id="kobo.17.1">SFINAE, Concepts, and Overload Resolution Management</span></em></li>
</ul>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer013">
</div>
</div>
<div>
<div id="_idContainer014">
</div>
</div>
</body></html>