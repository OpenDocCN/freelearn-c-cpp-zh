<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-45"><a id="_idTextAnchor110"/>3</h1>
<h1 id="_idParaDest-46"><a id="_idTextAnchor111"/>Memory and Ownership</h1>
<p>Memory mismanagement is one of the most common problems in C++ programs. Many of these problems boil down to incorrect assumptions about which part of the code or which entity owns a particular memory. Then, we get memory leaks, accessing unallocated memory, excessive memory use, and other problems that are difficult to debug. Modern C++ has a set of memory ownership idioms that, taken together, allow the programmer to clearly express their design intent when it comes to memory ownership. This, in turn, makes it much easier to write code that correctly allocates, accesses, and deallocates memory.</p>
<p>The following topics are covered in this chapter:</p>
<ul>
<li>What is memory ownership and resource ownership?</li>
<li>What are the characteristics of well-designed resource ownership? When and how should we be agnostic about resource ownership? How do we express exclusive memory ownership in C++?</li>
<li>How do we express shared memory ownership in C++?</li>
<li>What is the cost of different memory ownership language constructs?</li>
</ul>
<h1 id="_idParaDest-47"><a id="_idTextAnchor112"/>Technical requirements</h1>
<p>You can find the C++ Core Guidelines at <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md</a>.</p>
<p>You can find the C++ <strong class="bold">Guidelines Support Library</strong> (<strong class="bold">GSL</strong>) at <a href="https://github.com/Microsoft/GSL">https://github.com/Microsoft/GSL</a>. Examples are available at <a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter03">https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter03</a>.</p>
<h1 id="_idParaDest-48"><a id="_idTextAnchor113"/><a id="_idTextAnchor114"/><a id="_idTextAnchor115"/>What is memory ownership?</h1>
<p>In C++, the<a id="_idIndexMarker140"/> term <em class="italic">memory ownership</em> refers to the entity that is responsible for enforcing the lifetime of a particular memory allocation. In reality, we rarely talk about the ownership of raw memory. Usually, we manage the ownership and the lifetime of the objects that reside in said memory and memory ownership is really just shorthand<a id="_idIndexMarker141"/> for <em class="italic">object ownership</em>. The concept of memory ownership is closely tied to that <a id="_idIndexMarker142"/>of <em class="italic">resource ownership</em>. First of all, memory is a resource. It is not the only resource a program can manage, but it is by far the most commonly used one. Second, the C++ way of managing resources is to have objects own them. Thus, the problem of managing resources is reduced to the problem of managing the owning objects, which, as we just learned, is what we really mean when we talk about memory ownership. In this context, memory ownership is about owning more than memory, and mismanaged ownership can leak, miscount, or lose track of any resource that can be controlled by the program—memory, mutexes, files, database handles, c<a id="_idTextAnchor116"/>at videos, airline seat reservations, or nuclear warhead<a id="_idTextAnchor117"/>s.</p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor118"/>Well-designed memory ownership</h2>
<p>What does well-designed memory <a id="_idIndexMarker143"/>ownership look like? The naive answer that first comes up is that, at every point in the program, it is clear who owns which object. This, however, is overly constraining—most of the program does not deal with ownership of resources, including memory. These parts of the program merely use resources. When writing such code, it is sufficient to know that a particular function or class does not own the memory. It is completely irrelevant to know who does what:</p>
<pre class="source-code">
struct MyValues { long a, b, c, d; }
void Reset(MyValues* v) {
  // Don't care who owns v, as long as we don't
  v-&gt;a = v-&gt;b = v-&gt;c = v-&gt;d = 0;
}</pre>
<p>How about this, then—at every point in the program, is it clear who owns that object, or is it clear that the owner is not changing? This is better since most of the code will fall under the second part of our answer. However, it’s still too constraining—when taking ownership of an object, it is usually not important to know who it is taken from:</p>
<pre class="source-code">
class A {
  public:
  // Constructor transfers ownership from whomever
  A(std::vector&lt;int&gt;&amp;&amp; v) : v(std::move(v)) {}
  private:
  std::vector&lt;int&gt; v_;    // We own this now
};</pre>
<p>Similarly, the whole point of shared ownership (expressed through the reference-counted <code>std::shared_ptr</code>) is that we <a id="_idIndexMarker144"/>don’t need to know who else owns the object:</p>
<pre class="source-code">
class A {
  public:
  // No idea who owns v, don't care
  A(std::shared_ptr&lt;std::vector&lt;int&gt;&gt; v) : v_(v) {}
  // Sharing ownership with any number of owners
  private:
  std::shared_ptr&lt;std::vector&lt;int&gt;&gt; v_;
};</pre>
<p>A more accurate description of well-designed memory ownership takes more than one quoted sentence. Generally, the following are the attributes of good memory ownership practices:</p>
<ul>
<li>If a function or a class does not alter memory ownership in any way, this should be clear to every client of this function or class, as well as the implementer.</li>
<li>If a function or a class takes exclusive ownership of some of the objects passed to it, this should be clear to the client (we assume that the implementer knows this already since they have to write the code).</li>
<li>If a function or a class shares ownership of an object passed to it, this should be clear to the client (or anyone who reads the client code, for that matter).</li>
<li>For every object that is created, for every unit of code where it’s used, it is clear whether<a id="_idIndexMarker145"/> this code is expected to delete the object or<a id="_idTextAnchor119"/> not.</li>
</ul>
<h2 id="_idParaDest-50"><a id="_idTextAnchor120"/>Poorly designed memory ownership</h2>
<p>Just as<a id="_idIndexMarker146"/> good memory ownership defies a simple description and instead is characterized by a set of criteria it satisfies, so can bad memory ownership practices be recognized by their common manifestations. In general, where a good design makes it clear whether a particular piece of code owns a resource or not, a bad design requires additional knowledge that cannot be deduced from the context. For example, who owns the object returned by the following <code>MakeWidget()</code> function?</p>
<pre class="source-code">
Widget* w = MakeWid<a id="_idTextAnchor121"/>get();</pre>
<p>Is the client expected to delete the widget when it’s no longer needed? If yes, how should it be deleted? If we decide to delete the widget and do it in the wrong way, for example, by calling <code>operator delete</code> on a widget that was not, in fact, allocated by <code>operator new</code>, memory corruption will certainly result. In the best-case scenario, the program will just crash:</p>
<pre class="source-code">
WidgetFactory WF;
Widget* w = WF.MakeAnother();</pre>
<p>Does the Factory own the widgets it created? Will it delete them when the Factory object is deleted? Alternatively, is the client expected to do that? If we decide that the Factory probably knows what it created and will delete all such objects in due time, we may end up with a memory leak (or worse, if the objects owned some other resources):</p>
<pre class="source-code">
Widget* w = MakeWidget();
Widget* w1 = Transmogrify(w);</pre>
<p>Does <code>Transmogrify()</code> take ownership of the widget? Is the <code>w</code> widget still around after <code>Transmogrify()</code> is done with it? If the widget is deleted to construct a new, transmogrified, <code>w1</code> widget, we now have a dangling pointer. If the widget is not deleted, but we assume it might be, we have a memory leak.</p>
<p>Lest you<a id="_idIndexMarker147"/> think that all bad memory management practices can be recognized by the presence of raw pointers somewhere, here is an example of a rather poor approach to memory management that often arises as a knee-jerk response to the problems caused by the use of raw pointers:</p>
<pre class="source-code">
void Double(std::shared_ptr&lt;std::vector&lt;int&gt;&gt; v) {
  for (auto&amp; x : *v) {
    x *= 2;
  }
};
...
std::shared_ptr&lt;std::vector&lt;int&gt;&gt; v(...);
Double(<a id="_idTextAnchor122"/>v);
...</pre>
<p>The <code>Double()</code> function is claiming in its interface that it takes shared ownership of the vector. However, that ownership is entirely gratuitous—there is no reason for <code>Double()</code> to own its argument—it does not attempt to extend its lifetime and, it does not transfer ownership to anyone else; it merely modifies a vector passed in by the caller. We can reasonably expect that the caller owns the vector (or that somebody else even higher in the call stack does), and that the vector will still be around when <code>Double()</code> returns control to the caller—after all, the caller wanted us to double the elements, presumably so that they can do something else with them.</p>
<p>While this list is hardly<a id="_idIndexMarker148"/> complete, it serves to demonstrate the spectrum of <a id="_idTextAnchor123"/>problems that can be caused by a slap-dash approach to memory ownership. In the next section, we review the patterns and guidelines developed by the C++ community to help to avoid these problems and express the programmer’s intent <a id="_idTextAnchor124"/>clearly.</p>
<h1 id="_idParaDest-51"><a id="_idTextAnchor125"/>Expressing memory ownership in C++</h1>
<p>Throughout its history, the <a id="_idIndexMarker149"/>C++ language has evolved in its approach to expressing memory ownership. The same syntactic constructs have been, at times, imbued with different assumed semantics. This evolution was partially driven by new features added to the language (it’s hard to talk about shared memory ownership if you don’t have any shared pointers). On the other hand, most of the memory management tools added in C++ 11 and later were not new ideas or new concepts. The notion of a shared pointer has been around for a long time. This language support makes it easier to implement one (and having a shared pointer in the standard library makes most custom implementations unnecessary), but shared pointers were used in C++ long before C++ 11 added them to the standard. The more important change that has occurred was the evolution of the understanding of the C++ community and the emergence of common practices and idioms. It is in this sense, as a set of conventions and semantics commonly associated with different syntactic features, that we can talk about the set of memory management practices as a design pattern of the C++ language. Let’s now learn the different ways that we ca<a id="_idTextAnchor126"/>n express different types of memory ow<a id="_idTextAnchor127"/>nership.</p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor128"/>Expressing non-ownership</h2>
<p>Let’s start with the most <a id="_idIndexMarker150"/>common kind of memory ownership. Most code does not allocate, deallocate, construct, or delete. It just does its work on objects that were created by someone else earlier and will be deleted by someone else later. How do you express the notion that a function is going to operate on an object but will not attempt to delete it or, conversely, extend its lifetime past the completion of the functi<a id="_idTextAnchor129"/><a id="_idTextAnchor130"/>on itself?</p>
<p>Very easily, in fact, and every C++ programmer has done it many times:</p>
<pre class="source-code">
// Example 01
void Transmogrify(Widget* w) {        // I will not delete w
  ...
}
void MustTransmogrify(Widget&amp; w) {   // Neither will I
  ...
}</pre>
<p>In a well-written program, a function with a raw pointer parameter signals that it is not involved with the ownership of the corresponding object in any way; the same goes for references. Similarly, a class that contains a member function pointer refers to an object but expects someone else to own it and manage its lifetime. Note that the destructor of the <code>WidgetProcessor</code> class in the next example does not delete the object the class points to – this is a sure sign that we<a id="_idIndexMarker151"/> refuse ownership of that object:</p>
<pre class="source-code">
// Example 02
class WidgetProcessor {
  public:
  WidgetProcessor(Widget* w) : w_(w) {}
  WidgetProcessor() {} // DO NOT delete w_!!!
    ...
  private:
  Widget* w_;    // I do not own w_
};</pre>
<p>Non-owning access to an object should be granted by using raw pointers or references. Yes—even in C++ 14, with all its smart pointers, there is a place for raw pointers. Not only that but in the bulk of the code, the majority of pointers will be raw pointers—all the non-owning ones (as we will see in the next section, C++17 and C++20 take this point much further).</p>
<p>You might reasonably point out at this time that the preceding example of recommended practices for granting non-owning access looks exactly like one of the examples of bad practices shown earlier. The distinction is in the context—in a well-designed program, only non-owning access is granted through raw pointers and references. Actual ownership is always expressed in some other way. Thus, it is clear that when a raw pointer is encountered, the function or class is not going to mess with the ownership of the object in any way. This, of course, creates some confusion when it comes to converting old legacy code, with raw pointers everywhere, to modern practices. As a matter of clarity, it is recommended to convert such code one part at a time, with clearly indicated transitions between code that follows the modern guidelines and code that does not.</p>
<p>Another<a id="_idIndexMarker152"/> issue to discuss here is the use of pointers versus references. As a matter of syntax, the reference is basically a pointer that is never null and cannot be left uninitialized. It is tempting to adopt a convention that any pointer passed to a function may be null and must, therefore, be checked, and any function that cannot accept a null pointer must instead take a reference. It is a good convention and widely used, but not widely enough to be considered an accepted design pattern. Perhaps in recognition of this, the C++ Core Guidelines library offers an alternative for expressing non-null pointers—<code>not_null&lt;T*&gt;</code>. Note that this is not a part of the language itself<a id="_idTextAnchor131"/>, but can be implemented in standard C++ without any languag<a id="_idTextAnchor132"/>e extension.</p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor133"/>Expressing exclusive ownership</h2>
<p>The second most common type of <a id="_idIndexMarker153"/>ownership is exclusive ownership—the code creates an object and will delete it later. The task of deletion will not be delegated to someone else, and no extension of the lifetime of the object is permitted. This type of memory ownership is so common that we do it all the time without even thinking about it:</p>
<pre class="source-code">
void Work() {
  Widget w;
  Transmogrify(w);
  Draw(w);
}</pre>
<p>All local (stack) variables express unique memory ownership! Note that ownership in this context does not mean that someone else will not modify the object. It merely means that when the creator of the <code>w</code> widget—the <code>DoWork()</code> function, in our case—decides to delete it; the deletion will succeed (nobody has deleted it already) and the object will actually be deleted (nobody attempted to keep the object alive after the end of its scope).</p>
<p>This is the oldest way to construct an object in C++, and it’s still the best one. If a stack variable does what you need, use it. C++ 11 provides another way to express unique ownership, and it is mainly used in cases where an object cannot be created on the stack but must be allocated on the heap. Heap allocation often happens when ownership is shared or transferred—after all, the stack-allocated object will be deleted at the end of the containing scope; there is no way around it. If we need to keep the object alive for longer, it has to be allocated somewhere else. The other reason to create objects on the heap is that the size or type of the object may not be known at compile time. This usually happens when the object is polymorphic—a derived object is created, but the base class pointer is used. Whatever the reason for not allocating objects on the stack, we have a way of expressing the exclusive ownership of such objects using <code>std::unique_ptr</code>:</p>
<pre class="source-code">
// Example 03
class FancyWidget : public Widget { ... };
std::unique_ptr&lt;Widget&gt; w(new FancyWidget);</pre>
<p>There is also a technical reason why you may have to construct objects on the heap even when a stack-allocated object seems sufficient: the stack size is quite limited, usually anywhere between 2 MB and 10 MB. That is the space for all stack allocations in one thread, and when it is exceeded, the program crashes. A large enough object can exhaust the stack space or push it too close to the limit for subsequent allocations. Such objects must be created on the heap and owned by stack-allocated unique pointers or other<a id="_idIndexMarker154"/> resource-owning objects.</p>
<p>What if the way to create an object is more complex than just <code>operator new</code>, and we need a Factory function? That is the type of ownership we will <a id="_idTextAnchor134"/><a id="_idTextAnchor135"/><a id="_idTextAnchor136"/>consider next.</p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor137"/>Expressing transfer of exclusive ownership</h2>
<p>In the preceding <a id="_idIndexMarker155"/>example, a new object was created and immediately bound to a unique pointer, <code>std::unique_ptr</code>, which guarantees exclusive ownership. The client code looks exactly the same if the object is created by a Factory:</p>
<pre class="source-code">
std::unique_ptr&lt;Widget&gt; w(WidgetFactory());</pre>
<p>But what should the Factory function return? It could certainly return a raw pointer, <code>Widget*</code>. After all, that is what <code>new</code> returns. But this opens the way to incorrect use of <code>WidgetFactory</code>—for example, instead of capturing the returned raw pointer in a unique pointer, we could pass it to a function such as <code>Transmogrify</code> that takes a raw pointer because it does not deal with the ownership. Now, nobody owns the widget, and it ends up as a memory leak. Ideally, <code>WidgetFactory</code> would be written in a way that would force the caller to take ownership of the returned object.</p>
<p>What we need here <a id="_idIndexMarker156"/>is an ownership transfer—<code>WidgetFactory</code> is certainly an exclusive owner of the object it constructs, but at some point, it needs to hand off that ownership to a new, also exclusive, owner. The code to do so is very simple:</p>
<pre class="source-code">
// Example 04
std::unique_ptr&lt;Widget&gt; WidgetFactory() {
  Widget* new_w = new Widget;
    ...
  return std::unique_ptr&lt;Widget&gt;(new_w);
}
std::unique_ptr&lt;Widget&gt; w(WidgetFactory());</pre>
<p>This works exactly the way we want it to, but why? Doesn’t the unique pointer provide exclusive ownership? The answer is, it does, but it is also a movable object (it has a move constructor). Moving the content of a unique pointer into another one transfers the ownership of the object; the original pointer is left in the moved-from state (its destruction will not delete any objects). What is so good about this idiom? It clearly expresses, and forces at compile time, that the Factory expects the caller to take exclusive (or shared) ownership of the object. For example, the following code, which would have left the new widget with no owner, does not compile:</p>
<pre class="source-code">
void Transmogrify(Widget* w);
Transmogrify(WidgetFactory());</pre>
<p>So, how do we call <code>Transmogrify()</code> on a widget after we properly assumed ownership? This is still done with a raw pointer:</p>
<pre class="source-code">
std::unique_ptr&lt;Widget&gt; w(WidgetFactory());
Transmogrify(w.get());
Transmogrify(&amp;*w);     // same as above <a id="_idTextAnchor138"/>if w is not null</pre>
<p>But what about the<a id="_idIndexMarker157"/> stack variables? Can exclusive ownership be transferred to someone else before the variable is destroyed? This is going to be slightly more complicated—the memory for the object is allocated on the stack and is going away, so some amount of copying is involved. Exactly how much copying depends on whether the object is movable. Moving, in general, transfers the ownership from the moved-from object to the moved-to one. This can be used for return values but is more often used for passing arguments to functions that take exclusive ownership. Such functions must be declared to take the parameters by the <code>rvalue</code> reference <code>T&amp;&amp;</code>:</p>
<pre class="source-code">
// Example 05
void Consume(Widget&amp;&amp; w) {
  auto my_w = std::move(w);
    ...
}
Widget w, w1;
Consume(std::move(w));    // No more w
// w is in a moved-from state now
Consume(w1);    // Does not compile - must consent to move</pre>
<p>Note that the caller must explicitly give up ownership by wrapping the argument in <code>std::move</code>. This is one of the advantages of this idiom; without<a id="_idTextAnchor139"/> it, an ownership-transferring call would look exactly the same a<a id="_idTextAnchor140"/>s a regular call.</p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor141"/>Expressing shared ownership</h2>
<p>The last type of ownership we <a id="_idIndexMarker158"/>need to cover is shared ownership, where multiple entities own the object equally. First, a word of caution—shared ownership is often misused, or over-used. Consider the preceding example, where a function was passed a shared pointer to an object it did not need to own. It is tempting to let the reference counting deal with the ownership of objects and <em class="italic">not worry about deletion</em>. However, this is often a sign of poor design. In most systems, at some level, there is clear ownership of resources, and this should be reflected in the chosen design of resource management. The <em class="italic">not worry about deletion</em> concern remains valid; explicit deletion of objects should be rare, but automatic deletion does not require shared ownership, merely a clearly expressed one (unique pointers, data members, and containers provide automatic deletion just as well).</p>
<p>That being said, there are definite cases for shared ownership. The most common valid applications of shared ownership are at a low level, inside data structures such as lists, trees, and more. A data element may be owned by other nodes of the same data structure, by any number of iterators currently pointing to it, and, possibly by some temporary variables inside data structure member functions that operate on the entire structure or a part of it (such as rebalancing a tree). The ownership of the entire data structure is usually clear in a well-thought-out design. But the ownership of each node, or data element, may be truly shared in the sense that any owner is equal to any other; none is priv<a id="_idTextAnchor142"/>ileged or primary.</p>
<p>In C++, the notion of shared<a id="_idIndexMarker159"/> ownership is expressed through a shared pointer, <code>std::shared_ptr</code>:</p>
<pre class="source-code">
// Example 06
struct ListNode {
  T data;
  std::shared_ptr&lt;ListNode&gt; next, prev;
};
class ListIterator {
  ...
  std::shared_ptr&lt;ListNode&gt; node_;
};
class List {
  ...
  std::shared_ptr&lt;ListNode&gt; head_;
};</pre>
<p>The advantage of this<a id="_idIndexMarker160"/> design is that a list element that was unlinked from the list remains alive for as long as there is a way to access it through an iterator. This is not the way <code>std::list</code> is done, and it does not provide such guarantees (deleting a <code>std::list</code> object invalidates all iterators). Note that the doubly linked list of shared pointers makes it so any two consecutive nodes in the list own each other and neither is deleted even when the list head is deleted; this leaks the owned objects. For this reason, a real design would likely use <code>std::weak_pointer</code> for one of <code>next</code> or <code>prev</code>.</p>
<p>Such complications aside, this may be a valid design for certain applications where the iterators need to own the data they refer to even after the list is deleted or some elements are erased from the list. One example is a thread-safe list, where it is very difficult to guarantee that one thread does not erase a list element while another still has an iterator pointing to it. Note that this particular application would also require atomic shared pointers, which are only available in C++ 20 (or you can write your own using C++ 11).</p>
<p>Now, what about functions taking shared pointers as parameters? In a program that follows good memory ownership practices, such a function conveys to the caller that it intends to take partial ownership that lasts longer than the function call itself—a copy of the shared pointer will be created. In the concurrent context, it may also indicate that the function needs to protect the object from deletion by another thread for at least as long as it’s executing.</p>
<p>There are several disadvantages to shared ownership that you must keep in mind. The best-known one is the bane of shared pointers, that is, the circular dependency. If two objects with shared pointers point to each other, the entire pair remains <em class="italic">in use </em>indefinitely. C++ offers a solution to that in the form of <code>std::weak_ptr</code>, a counterpart to the shared pointer that provides a safe pointer to an object that may have already been deleted. If the previously mentioned pair of objects uses one shared and one weak pointer, the circular dependency is broken.</p>
<p>The circular dependency problem is real, but it happens more often in designs where shared ownership is used to conceal the larger problem of unclear resource ownership. However, there are other downsides to shared ownership. The performance of a shared pointer is always going to be lower than that of a raw pointer. On the other hand, a unique pointer can be just as efficient as a raw pointer (and in fact, <code>std::unique_ptr</code> is). When the shared pointer is first created, an additional memory allocation for the reference count must take place.</p>
<p>In C++ 11, <code>std::make_shared</code> can be <a id="_idIndexMarker161"/>used to combine the allocations for the object itself and the reference counter, but this implies that the object is created with the intent to share (often, the object Factory returns unique pointers, some of which are later converted to shared pointers). Copying or deleting a shared pointer must also increment or decrement the reference counter. Shared pointers are often attractive in concurrent data structures, where, at least at the low level, the notion of ownership may indeed be fuzzy, with several accesses to the same object happening at the same time. However, designing a shared pointer to be thread-safe in all contexts is not easy and carries additional runtime overhead.</p>
<p>So far, we have mostly restricted ourselves to pointers as means of owning objects (and their memory and other resources). Non-ownership has been similarly expressed through raw pointers and references or simple non-owning pointers. However, this is not the only way to own resources (and we did mention that the most common form of exclusive ownership is a stack variable). We are now going to see how resource-owning objects can be used directly to express both ownership and non-ownership.</p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor143"/>Owning objects and views</h1>
<p>C++ has not been limited <a id="_idIndexMarker162"/>to owning pointers since its creation: any object can own resources, and we already mentioned that the simplest way to express exclusive ownership is to<a id="_idIndexMarker163"/> create a local variable on the stack. Of course, any of such objects can also be owned by a pointer (unique or shared) and when non-owning access is desired, these objects are commonly accessed through raw pointers or references. However, in C++17 and C++20 a different pattern has emerged, and it is worth exploring.</p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor144"/>Resource-owning objects</h2>
<p>Every C++ programmer is<a id="_idIndexMarker164"/> familiar with resource-owning objects; perhaps the most common one is <code>std::string</code> – an object that owns a character string. Of course, it also has a lot of specialized member functions for operating on strings, but from the point of view of memory ownership, <code>std::string</code> is essentially an owning <code>char*</code> pointer. Similarly, <code>std::vector</code> is an owning object for an array of objects of arbitrary type.</p>
<p>The most common way to construct such objects is either as local variables or as data members of a class. In the latter case, the issue of who owns the entire class is managed elsewhere, but, within the class, all data members are owned exclusively by the object itself. Consider this simple example:</p>
<pre class="source-code">
class C {
  std::string s_;
};
 …
std::vector&lt;int&gt; v = … ;    // v owns the array of int
C c;                       // c owns the string s</pre>
<p>So far, we have not said anything new compared to the section on exclusive ownership just a few pages earlier in this chapter. However, we have subtly changed the focus from owning pointers to owning objects. As long as we focus on the ownership aspect, these objects are essentially specialized owning (unique) pointers. There is an important difference, however: most such objects convey additional information, such as the length of the string for <code>std::string</code> or the size of the array for <code>std::vector</code>. Keep this in mind: it is going to come up again when we get to the changes brought by C++17/20.</p>
<p>While resource-owning<a id="_idIndexMarker165"/> objects have been around since the beginning of C++, they themselves have been often owned through pointers. There are, perhaps, two main reasons for this; both have been rendered obsolete by C++ advances. The first reason to own, for example, a string via an owning pointer is the need to transfer ownership. A stack object is destroyed at the end of the scope. A class data member is destroyed when the object is destroyed. In either case, there is no way to transfer the ownership of the object itself, such as <code>std::string</code>, to someone else. However, if we focus on the ownership aspect, then the string object itself is just a (decorated) owning pointer, and the goal is to transfer the ownership of the underlying resource (the character string for <code>std::string</code>) to another owner. When we put it this way, the answer is obvious: since C++11, the string has move semantics, and moving a string is barely more expensive than moving a pointer (remember, the string is an owning pointer that also knows the length, so that has to be moved too).</p>
<p>We can say, more generally, that there is no reason to own a cheap-to-move owning object via a pointer if the only reason is ownership transfer. For example, consider this string builder class:</p>
<pre class="source-code">
class Builder {
  std::string* str_;
  public:
  Builder(…) : str_(new std::string){
    … construct string str_ …
  }
  std::string* get(){
    std::string* tmp = str_;
    str_ = nullptr;
    return tmp;
  }
};</pre>
<p>While it gets the job done, a much better way to write the same class is to simply move the string:</p>
<pre class="source-code">
// Example 07
class Builder {
  std::string str_;
  public:
  Builder(…){ … construct string str_ … }
  std::string get(){ return std::move(str_); }
};
std::string my_string = Builder(…).get();</pre>
<p>The same is true for factories <a id="_idIndexMarker166"/>that construct owning cheap-to-move objects. Instead of returning them via <code>std::unique_ptr</code>, the factory can return the object itself:</p>
<pre class="source-code">
std::string MakeString(…) {
  std::string str;
  … construct the string …
  return str;
}
std::string my_string = MakeString(…);</pre>
<p>The return value may<a id="_idIndexMarker167"/> benefit from the return-value optimization (the compiler constructs the return value directly in the memory allocated for the final object, <code>my_string</code>). But even without this optimization, we have a guarantee that there is no copying of the string here, only moving (if this move is optimized away, the optimization is sometimes <a id="_idIndexMarker168"/>called <strong class="bold">move elision</strong>, similar to the better-known <strong class="bold">copy elision</strong>, which<a id="_idIndexMarker169"/> optimizes away copy constructors).</p>
<p>The second reason to use owning pointers for resource-owning objects is that the object’s existence itself may be conditional:</p>
<pre class="source-code">
std::unique_ptr&lt;std::string*&gt; str;
if (need_string) str.reset(new std::string(…args…));</pre>
<p>In many cases, an “<em class="italic">empty</em>” object can be used instead, such as a zero-length string. Again, for many owning objects, and certainly for all cheap-to-move STL containers, the cost of constructing such an object is trivial. But there could be a meaningful difference between the empty string and no string at all (that is, an empty string could be a valid result, and an absence of any string signifies something to the rest of the program). In C++17, we have a straightforward way to express this behavior using <code>std::optional</code>:</p>
<pre class="source-code">
std::optional&lt;std::string&gt; str;
if (need_string) str.emplace(…args…);</pre>
<p>The object of the <code>std::optional&lt;std::string&gt;</code> type may contain a string or be empty. The non-empty <code>std::optional</code> owns the object it contains (deleting the <code>std::optional</code> will also delete the string). Unlike <code>std::unique_pointer</code>, there are no heap memory allocations here: the <code>std::optional</code> object contains enough space within it to store a <code>std::string</code> object. <code>std::optional</code> is also movable, just like the string itself, so this pattern can be combined with the previous one. In general, we can say that in modern C++ there is no reason to own lightweight owning objects such as <code>std::string</code> indirectly. However, expressing the non-ownership of such objects has not received <a id="_idIndexMarker170"/>as much attention until recently.</p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor145"/>Non-owning access to resource-owning objects</h2>
<p>We have seen how a <code>std::string</code> object<a id="_idIndexMarker171"/> can, for most purposes, replace an owning pointer to <code>char*</code> (or to <code>std::string</code>). How do we, then, express non-owning access? Let us say that we need to pass a string to a function that operates on the string but does not take ownership of it (does not destroy it). This is a trivial exercise:</p>
<pre class="source-code">
void work_on_string(const std::string&amp; str);
std::string my_string = …;
work_on_string(my_string);</pre>
<p>This is what we have been doing since C++ was created. But this simplicity hides a profound distinction: remember that, as long as we don’t care about all the extra methods and the features they provide, <code>std::string</code> is just an owning pointer to a character string that also knows its length. So, how would we handle the same situation if we used an owning pointer instead of a string? The corresponding pointer is <code>std::unique_ptr&lt;char[]&gt;</code>, so we would write something like this:</p>
<pre class="source-code">
void work_on_string(const char* str);
std::unique_ptr&lt;char[]&gt; my_string(new char[…length…]);
… initialize the string …
work_on_string(my_string.get());</pre>
<p>Following the earlier guidelines, we passed a non-owning raw pointer to the function. We definitely would not write this declaration:</p>
<pre class="source-code">
void work_on_string(const std::unique_ptr&lt;char[]&gt;&amp; str);</pre>
<p>Yet we do this without a second thought when the same character array is owned by a <code>std::string</code> object. Why do we approach these very similar problems so differently? This is the time to remember why a string is not just an owning pointer restricted to character arrays; it contains more information than just the pointer: it also knows the length of the string. There was no good way in C++ to grant non-owning access to such “<em class="italic">rich</em>” owning pointers, short of passing the entire pointer object by reference. By contrast, a unique pointer (or any other owning pointer) contains the same information as a basic pointer, so when ownership is not required, the owning pointer naturally reduces to a raw pointer without any information loss.</p>
<p>The difference is about more than just symmetry. Consider that passing a string by a <code>const</code> reference prevents the function <code>work_on_string</code> from changing the content of the string. On the other hand, a non-<code>const</code> reference allows the function to clear the string (release the memory it owns), which is an ownership aspect. We are forced to muddle the clarity of intent by mixing together two unrelated types of access we can grant to a function: the ability to change the content of the data and the ownership of the data.</p>
<p>C++17 addressed this problem in a very limited context: specifically for strings, it introduced a new type <code>std::string_view</code>. A string view is a (<code>const</code>) non-owning pointer to a string that also stores the length of the string. In other words, it is a perfect non-owning equivalent to <code>std::string</code>: a string view to a string is exactly what a <code>const</code> raw pointer is to a unique pointer. Now, to grant non-owning access to a <code>std::string</code> object, we write:</p>
<pre class="source-code">
// Example 09
void work_on_string(std::string_view str);
std::string my_string = …;
work_on_string(my_string);</pre>
<p>In contrast, a function that takes ownership of a <code>std::string</code> object must still take it by reference. Specifically, use an rvalue reference to transfer the ownership:</p>
<pre class="source-code">
// Example 09
void consume_string(std::string&amp;&amp; str);
std::string my_string = …;
consume_string(std::move(my_string));
// Do not use my_string anymore!</pre>
<p>Use a non-<code>const</code> lvalue reference only to allow the function to change the string; in C++17, there is no good <em class="italic">rich pointer</em> equivalent to a non-<code>const</code> raw pointer. There is probably no need to use <code>const std::string&amp;</code> except when the existing interfaces require it since <code>std::string_view</code> offers equivalent functionality.</p>
<p>There are other benefits <a id="_idIndexMarker172"/>and advantages of using <code>std::string_view</code> (in particular, it greatly simplifies writing common code for processing C and C++ strings), but in this chapter, we focus on the ownership aspect. Also, remember that the string view is limited to character strings. We could have the exact same discussion about another owning class, for example, <code>std::vector&lt;int&gt;</code>.</p>
<p>We now see a new pattern emerge: for a “<em class="italic">rich</em>” owning pointer that, in addition to owning memory, contains some information about the data it owns, the corresponding non-owning object (the equivalent of a raw pointer) should be a view object that contains the same information but does not own the resource. We find this view object in C++20 as <code>std::span</code>. Until then, the only good way to grant non-owning access to a vector of integers was to pass it by reference:</p>
<pre class="source-code">
void work_on_data(std::vector&lt;int&gt;&amp; data);
std::vector&lt;int&gt; my_data = …;
work_on_data(my_data);</pre>
<p>In C++20, we can use the span to clearly differentiate the non-owning view (raw pointer equivalent) from the owning object (unique pointer equivalent):</p>
<pre class="source-code">
// Example 10
void ModifyData(std::span&lt;int&gt; data);
std::vector&lt;int&gt; my_data = …;
ModifyData(my_data); // Can change my_data</pre>
<p>Thus, <code>std::span&lt;int&gt;</code> is a <em class="italic">rich pointer</em> equivalent to <code>int*</code>—it contains a non-<code>const</code> pointer and the size is cheap to copy and does not own the resource it points to. Unlike <code>std::string_view</code>, we can modify the object accessed through a span. But if we want the equivalent to a <code>const</code> pointer, we can use <code>std::span&lt;const int&gt;</code>:</p>
<pre class="source-code">
// Example 10
void UseData(std::span&lt;const int&gt; data);
std::vector&lt;int&gt; my_data = …;
UseData(my_data); // Cannot change my_data</pre>
<p>Since <code>std::string</code> contains a contiguous array of characters, it too can be used with a span, in this case, <code>std::span&lt;char&gt;</code> or <code>std::span&lt;const char&gt;</code>. The latter is essentially the same as <code>std::string_view</code>, including the option to construct them from string literals. The former is the equivalent of a non-<code>const</code> pointer to <code>char</code>.</p>
<p>The span pairs well with a vector or a string because they offer a non-owning view of an array. But it does not work for other STL containers since they all allocate memory in multiple non-contiguous<a id="_idIndexMarker173"/> allocations. For that, we need to use the C++20 ranges library. For example, the generalization of the preceding non-owning vector access to an arbitrary container can be written like this:</p>
<pre class="source-code">
// Example 11
void ModifyData(std::ranges::view auto data) { … }
std::list&lt;int&gt; my_data = …;
ModifyData(std::views::all(my_data));</pre>
<p>If you have never seen a C++20 template, this takes some getting used to. The first line is a template function: <code>auto</code> parameters make “<em class="italic">ordinary</em>” functions into templates even without the <code>template</code> keyword. The incantation <code>std::ranges::view</code> before <code>auto</code> restricts the template parameters to those that satisfy the view concept. A view is a container-like object that has <code>begin()</code> and <code>end()</code> member functions and, in addition, must be cheap to move and either cheap to copy or non-copyable (this is, of course, a loose paraphrasing of the exact requirements enumerated by the standard). We could have written the same function with the <code>template</code> and <code>requires</code> keywords, but this compact syntax is idiomatic in C++20.</p>
<p>Note that, in this concept-based coding style, the restrictions on the function arguments are specified by the concept requirements. We could have written the same template function to require ranges instead of views:</p>
<pre class="source-code">
void ModifyData(std::ranges::range auto data) { … }
std::list&lt;int&gt; my_data = …;
ModifyData(my_data);</pre>
<p>Ranges are essentially arbitrary objects with <code>begin()</code> and <code>end()</code>, so <code>std::list</code> is a range (but not a view, it can be copied but not cheaply). Note that, as written, the function takes the argument by value, so a copy is made. Unless that was the intent (and in this case, it is not), the correct way to write this function is like this:</p>
<pre class="source-code">
void ModifyData(std::ranges::range auto&amp;&amp; data) { … }</pre>
<p>A <code>const</code> reference would <a id="_idIndexMarker174"/>also work if we wanted to express non-modifying access. But the important point to note is that we did not have to do the same for views: by restricting the <code>work_on_data</code> function to accept only views, we have limited it to cheap-to-copy types similar to <code>std::string_view</code> (or a raw pointer, for that matter). Indeed, passing a range by reference is exactly like passing a string or a vector itself: this gives the callee access to the ownership. If we want to write a function that explicitly does not take ownership of a range, the view is the right way to express this.</p>
<p>It is still too early to talk about patterns for C++20 ranges: they have not been around long enough to establish commonly recognized and accepted use practices (a necessary requirement for a pattern) and the library is still incomplete. C++23 is expected to contain several significant enhancements (in particular, there is no good equivalent to <code>std::span&lt;const char&gt;</code> in C++20 ranges – it is going to be added in C++23).</p>
<p>However, we can confidently talk about the more general pattern becoming established in C++: resource ownership, including memory, should be handled by owning objects, while non-owning access should be granted through views. The owning objects can be smart pointers or more complex and specialized container objects. These containers, in addition to managing the memory in more complex ways, embed more information about the data they contain. In general, for each container, there should be a corresponding view that grants non-owning access while preserving all the additional information. For smart pointers, this view is a raw pointer or a reference. For <code>std::string</code>, this view is <code>std::string_view</code>. For <code>std::vector</code>, arrays, and any other containers that own contiguous memory, you will want <code>std::span</code>. For arbitrary containers, the<a id="_idIndexMarker175"/> corresponding views may be found in the C++20 ranges library; for a custom container, you may have to write your own view objects as well (just make sure they sa<a id="_idTextAnchor146"/>tisfy the relevant view concepts).</p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor147"/>Summary</h1>
<p>In C++, memory ownership is really just shorthand for object ownership, which, in turn, is the way to manage arbitrary resources, their ownership, and access. We have reviewed the contemporary idioms that the C++ community has developed to express different types of memory ownership. C++ allows the programmer to express exclusive or shared memory ownership. Just as important is expressing <em class="italic">non-ownership</em> in programs that are agnostic about the ownership of resources. We have also learned about the practices and attributes of resource ownership in a well-designed program.</p>
<p>We now have the idiomatic language to clearly express which entity in the program owns each object or resource, and when non-owning access is granted. The next chapter covers the idiom for the simplest operation o<a id="_idTextAnchor148"/>n resources: the exchange, or swap.</p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor149"/>Questions</h1>
<ol>
<li>Why is it important to clearly express memory ownership in a program?</li>
<li>What are the common problems that arise from unclear memory ownership?</li>
<li>What types of memory ownership can be expressed in C++?</li>
<li>How do you write non-memory-owning functions and classes?</li>
<li>Why should exclusive memory ownership be preferred to a shared one?</li>
<li>How do you express exclusive memory ownership in C++?</li>
<li>How do you express shared memory ownership in C++?</li>
<li>What are the potential downsides of shared memory ownership?</li>
<li>What are views? How is a string view better than passing a string by reference?</li>
</ol>
<h1 id="_idParaDest-61"><a id="_idTextAnchor150"/>Further reading</h1>
<ul>
<li><em class="italic">C++20 STL Cookbook</em> by <em class="italic">Bill </em><em class="italic">Weinman</em>: <a href="https://www.packtpub.com/product/c20-stl-cookbook/9781803248714">https://www.packtpub.com/product/c20-stl-cookbook/9781803248714</a></li>
<li><em class="italic">Template Metaprogramming with C++</em> by <em class="italic">Marius </em><em class="italic">Bancila</em>: <a href="https://www.packtpub.com/product/template-metaprogramming-with-c/9781803243450">https://www.packtpub.com/product/template-metaprogramming-with-c/9781803243450</a></li>
<li><em class="italic">C++ Data Structures and Algorithms</em> by <em class="italic">Wisnu </em><em class="italic">Anggoro</em>: <a href="https://www.packtpub.com/application-development/c-data-structures-and-algorithms">https://www.packtpub.com/application-development/c-data-structures-and-algorithms</a></li>
<li><em class="italic">Expert C++ Programming</em> by <em class="italic">Jeganathan Swaminathan</em>, <em class="italic">Maya Posch</em>, and <em class="italic">Jacek </em><em class="italic">Galowicz</em>: <a href="https://www.packtpub.com/application-development/expert-c-programming">https://www.packtpub.com/application-development/expert-c-programming</a></li>
</ul>
</div>


<div><h1 id="_idParaDest-62"><a id="_idTextAnchor151"/>Part 2: Common C++ Idioms</h1>
<p>This part describes some of the more common C++ idioms: established, universally recognized ways to express a specific idea or implement a frequently needed task. The boundary between “patterns” and “idioms” is fuzzy at best. In this book, we consider more complete design solutions to be patterns, while simpler techniques are idioms. In other words, choosing a pattern may influence the design of your entire application or its major component, while using an idiom is more of an implementation decision that has been learned from someone else’s mistakes.</p>
<p>This part has the following chapters:</p>
<ul>
<li><a href="B19262_04.xhtml#_idTextAnchor152"><em class="italic">Chapter 4</em></a>, <em class="italic">Swap - From Simple to Subtle</em></li>
<li><a href="B19262_05.xhtml#_idTextAnchor199"><em class="italic">Chapter 5</em></a>, <em class="italic">A Comprehensive Look at RAII</em></li>
<li><a href="B19262_06.xhtml#_idTextAnchor266"><em class="italic">Chapter 6</em></a>, <em class="italic">Understanding Type Erasure</em></li>
<li><a href="B19262_07.xhtml#_idTextAnchor314"><em class="italic">Chapter 7</em></a>, <em class="italic">SFINAE, Concepts, and Overload Resolution Management</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</body></html>