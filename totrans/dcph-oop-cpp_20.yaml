- en: '20'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Removing Implementation Details Using the pImpl Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will wrap up our quest to expand your C++ programming repertoire
    beyond core OOP concepts, with the objective of further empowering you to solve
    recurring types of coding problems, utilizing common design patterns. Incorporating
    design patterns in your coding can not only provide refined solutions but also
    contribute to easier code maintenance and provide for potential code reuse.
  prefs: []
  type: TYPE_NORMAL
- en: The next design pattern that we will learn how to implement effectively in C++
    is the **pImpl pattern**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Comprehending the pImpl pattern and how it reduces compile-time dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how to implement the pImpl pattern in C++ using association and
    unique pointers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognizing performance issues relating to pImpl and necessary trade-offs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand the pImpl pattern and how it
    can be used to separate implementation details from a class interface to reduce
    compiler dependencies. Adding an additional design pattern to your skillset will
    help you become a more valuable programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s increase our programming skillset by examining another common design pattern,
    the pImpl pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter20](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter20).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter20` in a file named `Chp20-Ex1.cpp` under the aforementioned GitHub directory.
    Some programs are in applicable subdirectories as indicated in the examples.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3CfQxhR](https://bit.ly/3CfQxhR).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the pImpl pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **pImpl pattern** (**p**ointer to **Impl**ementation idiom) is a structural
    design pattern that separates the implementation of a class from its public interface.
    This pattern was originally known as the **Bridge pattern** by the **Gang of Four**
    (**GofF**) and is also known as the **Cheshire Cat**, **compiler-firewall idiom**,
    **d-pointer**, **opaque pointer**, or **Handle pattern**.
  prefs: []
  type: TYPE_NORMAL
- en: The primary purpose of this pattern is to minimize compile-time dependencies.
    The result of reducing compile-time dependencies is that changes in a class definition
    (most notably, the private access region) will not send a wave of timely recompilations
    throughout a developing or deployed application. Instead, the necessary recompiled
    code can be isolated to the *implementation* of the class itself. The other pieces
    of the application that depend on the class definition will no longer be affected
    by recompilation.
  prefs: []
  type: TYPE_NORMAL
- en: Private members within a class definition can affect a class with respect to
    recompilation. This is because changing the data members can alter the size of
    an instance of that type. Also, private member functions must be matched by signature
    to function calls for overloading resolution as well as potential type conversions.
  prefs: []
  type: TYPE_NORMAL
- en: The manner in which traditional header (`.h` or `.hpp`) and source code files
    (`.cpp`) specify dependencies trigger recompilation. By removing the class inner
    implementation details from a class header file (and placing these details in
    a source file), we can remove many dependencies. We can change which header files
    are included in other header and source code files, streamlining the dependencies
    and hence the recompilation burden.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pImpl pattern will compel the following adjustments to a class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: Private (non-virtual) members will instead be replaced by a pointer to a nested
    class type that includes the former private data members and methods. A forward
    declaration to the nested class will also be necessary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pointer to the implementation (`pImpl`) will be an association to which
    method calls of the class implementation will be delegated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The revised class definition will exist in a header file for the class embracing
    this idiom. Any formerly included header files that this header file once depended
    upon will now be moved to instead be included in the source code file for this
    class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other classes including the header file of a pImpl class will now not face recompilation
    should the implementation of the class within its private access region be modified.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To effectively manage dynamic memory resources of the associated object that
    represents the implementation, we will use a unique pointer (smart pointer).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The compilation freedom within the revised class definition takes advantage
    of the fact that pointers only require a forward declaration of the class type
    of the pointer to compile.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move forward to first examine a basic, and then a refined, implementation
    of the pImpl pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the pImpl pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to implement the pImpl pattern, we will need to revisit the typical
    header and source file composition. We will then replace the private members in
    a typical class definition with a pointer to the implementation, taking advantage
    of an association. The implementation will be encapsulated within a nested class
    of our target class. Our pImpl pointer will delegate all requests to our associated
    object that provides the inner class details or implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The inner (nested) class will be referred to as the **implementation class**.
    The original, now outer, class will be referred to as the **target** or **interface
    class**.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by reviewing the typical (non-pImpl pattern) file composition
    containing class definitions and member function definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing file and class contents to apply the pattern basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s first review the organization strategy of the typical C++ class with respect
    to file placement regarding the class definition and member function definitions.
    We will next consider the revised organization strategy of a class utilizing the
    pImpl pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing typical file and class layout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s take a look at a typical class definition and how we previously have organized
    a class with respect to source and header files, such as in our discussions in
    [*Chapter 5*](B19087_05.xhtml#_idTextAnchor222), *Exploring Classes in Detail*,
    and in [*Chapter 15*](B19087_15.xhtml#_idTextAnchor655), *Testing Classes and
    Components*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that we organized each class into a header (`.h` or `.hpp`) file containing
    the class definition and inline function definitions, plus a corresponding source
    code (`.cpp`) file containing the non-inline member function definitions. Let’s
    review a familiar sample class definition, `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned header file (`Person.h`), we have included our class definition
    for `Person` as well as inline function definitions for the class. Any larger
    inline function definitions not appearing within the class definition (indicated
    with the keyword `inline` in the prototype) would also appear in this file, after
    the class definition itself. Notice the use of preprocessor directives to ensure
    that a class definition is only included once per compilation unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s next review the contents of the corresponding source code file, `Person.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the previously defined source code file, we define all the non-inline member
    functions for the class, `Person`. Though not all methods are shown, all can be
    found in our GitHub code. Also, if the class definition contains any static data
    members, the definition of the external variables designating the memory for these
    members should be included in the source code file.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now consider how we can remove the implementation details from the `Person`
    class definition and its corresponding header file, by applying the pImpl pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the pImpl pattern with revised class and file layout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To employ the pImpl pattern, we will reorganize our class definition and its
    respective implementation. We will add a nested class within our existing class
    definition to represent the private members of our original class and the core
    of its implementation. Our outer class will include a pointer of the inner class
    type, serving as an association to our implementation. Our outer class will delegate
    all implementation requests to the inner, associated object. We will restructure
    the placement of classes and source code within the header and source code files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at our revised implementation for our class to understand
    each new detail required to implement the pImpl pattern. This example, composed
    of a source file `PersonImpl.cpp` and one header file `Person.h`, can be found
    in the same directory as a simple driver to test the pattern in our GitHub repository.
    To make a complete executable, you will need to compile and link together `PersonImp.cpp`
    and `Chp20-Ex1.cpp` (the driver), found in this same directory. Here is the GitHub
    repository URL for the driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter20/Chp20-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter20/Chp20-Ex1.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In our aforementioned revised class definition for `Person`, notice that we
    have removed the data members in the private access region. Any non-virtual private
    methods, had they existed, would have also been removed. Instead, we include a
    forward declaration to our nested class with `class PersonImpl;`. We also declare
    a pointer to the implementation using `PersonImpl *pImpl;`, which represents an
    association to the nested class members encapsulating the implementation. In our
    initial implementation, we will use a native (raw) C++ pointer to specify the
    association to the nested class. We will subsequently revise our implementation
    to utilize a *unique pointer*.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that our public interface for `Person` is much as before. All of our
    existing public and protected methods exist as expected, interface-wise. We notice,
    however, that the inline functions (which depend on the implementation of the
    data members) have been replaced with non-inline member function prototypes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move forward to see the class definition for our nested class, `PersonImpl`,
    as well as the placement of the member functions of `PersonImpl` and `Person`
    in a common source code file, `PersonImpl.cpp`. We will start with the nested
    `PersonImpl` class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the previously mentioned nested class definition for `PersonImpl`, notice
    that this class looks surprisingly similar to the original class definition for
    `Person`. We have private data members and a full host of member function prototypes,
    even some inline functions written for brevity (which won’t actually be inlined
    because they are virtual). `PersonImpl` represents the implementation for `Person`,
    so it is crucial that this class can access all data and implement each method
    fully. Notice that the scope resolution operator (`::`) in the definition of `class
    Person::PersonImpl` is used to specify that `PersonImpl` is a nested class of
    `Person`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s continue by taking a look at the member function definitions for `PersonImpl`,
    which will appear in the same source file `PersonImpl.cpp` as the class definition.
    Though some methods have been abbreviated, their full online code is available
    in our GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned code, we see the implementation for the overall `Person`
    class using the nested class `PersonImpl`. We see the member function definitions
    for `PersonImpl` and notice that the bodies of these methods are exactly how we
    previously implemented the methods in our original `Person` class without the
    pImpl pattern. Again, we notice the use of the scope resolution operator (`::`)
    to specify the class name for each member function definition, such as `void Person::PersonImpl::Print()
    const`. Here, `Person::PersonImpl` indicates the nested class of `PersonImpl`
    within the `Person` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s take a moment to review the member function definitions for `Person`,
    our class employing the pImpl pattern. These methods will additionally contribute
    to the `PersonImpl.cpp` source code file and can be found in our GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned member function definitions for `Person`, we notice that
    all methods delegate the required work to the nested class via the associated
    `pImpl`. In our constructors, we allocate the associated `pImpl` object and initialize
    it appropriately (using the member initialization list of each constructor). Our
    destructor is responsible for deleting the associated object using `delete pImpl;`.
  prefs: []
  type: TYPE_NORMAL
- en: Our `Person` copy constructor will set member `pImpl` to the newly allocated
    memory, while invoking the `PersonImpl` copy constructor for the nested object
    creation and initialization, passing `*(p.pImpl)` to the nested object’s copy
    constructor. That is, `p.pImpl` is a pointer, so we dereference the pointer using
    `*` to obtain a referenceable object for the `PersonImpl` copy constructor.
  prefs: []
  type: TYPE_NORMAL
- en: We use a similar strategy in our overloaded assignment operator for `Person`.
    That is, there are no data members other than `pImpl` to perform a deep assignment,
    so we merely call the `PersonImpl` assignment operator on associated object `pImpl`,
    again passing in `*(p.pImpl)` as the right-hand value.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let us consider a sample driver to demonstrate our pattern in action.
    Interestingly, our driver will work with either our originally specified non-pattern
    class (source and header files) or with our revised pImpl pattern-specific source
    and header files!
  prefs: []
  type: TYPE_NORMAL
- en: Bringing the pattern components together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s finally take a look at our `main()` function in our driver source file
    `Chp20-Ex1.cpp` to see how our pattern is orchestrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Reviewing our aforementioned `main()` function, we simply dynamically allocate
    several `Person` instances, call selected `Person` method(s) on the instances
    (`Print()`), and then delete each instance. We have included the `Person.h` header
    file, as expected, to be able to utilize this class. From the Client’s point of
    view, everything looks *as usual* and appears pattern unspecific.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we separately compile `PersonImp.cpp` and `Chp20-Ex1.cpp`, linking
    the object files together into an executable. However, due to the pImpl pattern,
    if we change the implementation for `Person`, the change will be encapsulated
    by its implementation in the `PersonImp` nested class. Only `PersonImp.cpp` will
    require recompilation. The Client will not need to recompile the driver, `Chp20-Ex1.cpp`,
    because the changes will not have occurred in the `Person.h` header file (which
    the driver depends on).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the output for this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned output, we see the expected results of our simple driver.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move forward to consider how we may improve our implementation of the
    pImpl pattern using a unique pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the pattern with a unique pointer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our initial implementation using an association with a native C++ pointer relieves
    many compiler dependencies. This is because the compiler only needs to see a forward
    class declaration of the pImpl pointer type in order to compile successfully.
    So far, we have achieved the core goal of using the pImpl pattern – reducing recompilation.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is always criticism of using native or *raw* pointers. We are
    responsible for managing the memory ourselves, including remembering to delete
    the allocated nested class type in our outer class destructor. Memory leaks, memory
    misuse, and memory errors are potential drawbacks for managing memory resources
    ourselves with raw pointers. For that reason, it is customary to implement the
    pImpl pattern using **smart pointers**.
  prefs: []
  type: TYPE_NORMAL
- en: We will continue our quest to implement pImpl by examining a key component often
    used with the pImpl pattern – smart pointers, or more specifically, the `unique_ptr`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by understanding smart pointer basics.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding smart pointers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To implement the pImpl pattern customarily, we must first understand smart pointers.
    A **smart pointer** is a small wrapper class that encapsulates a raw pointer,
    ensuring that the pointer it contains is automatically deleted when the wrapper
    object goes out of scope. The class implementing the smart pointer can be implemented
    using templates to create a smart pointer for any data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a very simple example of a smart pointer. This example can be found
    on our GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter20/Chp20-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter20/Chp20-Ex2.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the previously defined, straightforward `SmartPointer` class, we simply encapsulate
    a raw pointer. The key benefit is that the `SmartPointer` destructor will ensure
    that the raw pointer is destructed when the wrapper object is popped off the stack
    (for local instances) or before the program terminates (for static and extern
    instances). Certainly, this class is basic, and we must determine the desired
    behaviors for the copy constructor and the assignment operator. That is, allow
    shallow copies/assignment, require deep copies/assignment, or disallow all copies/assignment.
    Nonetheless, we can now visualize the concept of a smart pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output for our smart pointer example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The aforementioned output shows that the memory for each object contained within
    a `SmartPointer` is managed for us. We can quite easily see with the `"SmartPtr
    Destructor"` output strings that the destructor for each object is called on our
    behalf when the local objects in `main()` go out of scope and are popped off the
    stack.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding unique pointers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `unique_ptr` in the Standard C++ Library, is a type of smart pointer that
    encapsulates exclusive ownership and access to a given heap memory resource. A
    `unique_ptr` cannot be duplicated; the owner of a `unique_ptr` will have sole
    use of that pointer. Owners of unique pointers can choose to move these pointers
    to other resources, but the repercussions are that the original resource will
    no longer contain the `unique_ptr`. We must `#include <memory>` to include the
    definition for `unique_ptr`.
  prefs: []
  type: TYPE_NORMAL
- en: Additional types of smart pointers
  prefs: []
  type: TYPE_NORMAL
- en: Other types of smart pointers are available in the Standard C++ Library, in
    addition to `unique_ptr`, such as `weak_ptr` and `shared_ptr`. These additional
    types of smart pointers will be explored in [*Chapter 21*](B19087_21.xhtml#_idTextAnchor920),
    *Making C++ Safer*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modifying our smart pointer program to instead utilize `unique_ptr`, we now
    have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Our output will be similar to the `SmartPointer` example; the difference is
    that no `"SmartPtr Destructor"` call message will be displayed (as we are using
    a `unique_ptr` instead). Notice that because we included `using std::unique_ptr;`,
    we did not need to qualify `unique_ptr` with `std::` in the unique pointer declaration.
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, let’s add unique pointers to our pImpl pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Adding unique pointers to the pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To implement the pImpl pattern using a `unique_ptr`, we will make minimal changes
    to our previous implementation, starting with our `Person.h` header file. The
    full program example of our pImpl pattern utilizing a `unique_ptr` can be found
    in our GitHub repository and will additionally include a revised file for `PersonImpl.cpp`.
    Here is the URL for the driver, `Chp20-Ex3.cpp`; note the subdirectory, `unique`,
    in our GitHub repository for this complete example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter20/unique/Chp20-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter20/unique/Chp20-Ex3.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Notice, in the revised aforementioned class definition for `Person`, the unique
    pointer declaration of `std::unique_ptr<PersonImpl> pImpl;`. Here, we use the
    `std::` qualifier because the standard namespace has not been explicitly included
    in our header file. We also `#include <memory>` to gain the definition for `unique_ptr`.
    The remainder of the class is identical to our initial implementation of pImpl
    using an association implemented with a raw pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s understand the extent to which our source code needs to be modified
    from our initial pImpl implementation. Let’s now take a look at the necessary
    modified member functions in our source file, `PersonImpl.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Taking a look at the aforementioned member functions requiring modification,
    we see that it is only the `Person` destructor! Because we are using a unique
    pointer to implement the association to the nested class implementation, we no
    longer need to manage the memory for this resource ourselves. That’s pretty nice!
    With these minor changes, our pImpl pattern now features a `unique_ptr` to designate
    the implementation of the class.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s examine some of the performance issues relating to using the pImpl
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding pImpl pattern trade-offs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Incorporating the pImpl pattern into production code has both benefits and disadvantages.
    Let’s review each so that we can better understand the circumstances that may
    warrant deploying this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The negligible performance issues encompass most of the disadvantages. That
    is, nearly every request made of the target (interface) class will need to be
    delegated to its nested implementation class. The only requests that can be handled
    by the outer class will be those not involving any data members; those circumstances
    will be extraordinarily rare! Another disadvantage includes slightly higher memory
    requirements of instances to accommodate the added pointer as part of the pattern
    implementation. These issues will be paramount in embedded software systems and
    those requiring peak performance, but relatively minor otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Maintenance will be a little more difficult for classes employing the pImpl
    pattern, an unfortunate disadvantage. Each target class is now paired with an
    extra (implementation) class, including a set of forwarding methods to delegate
    requests to the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: A few implementation difficulties may also arise. For example, if any of the
    private members (now in the nested implementation class) need to access any of
    the protected or public methods of the outer (interface) class, we will need to
    include a backlink from the nested class to the outer class to access that member.
    Why? The `this` pointer in the inner class will be of the nested object type.
    Yet the protected and public methods in the outer object will expect a `this`
    pointer to the outer object – even if those public methods will then redelegate
    the request to call a private nested class method for help. This backlink will
    also be required to call public virtual functions of the interface from the scope
    of the inner class (implementation). Keep in mind, however, that we impact performance
    with another added pointer per object and with delegation to call each method
    in the associated object.
  prefs: []
  type: TYPE_NORMAL
- en: There are several advantages of utilizing the pImpl pattern, offering important
    considerations. Of most importance, recompile time during the development and
    maintenance of code decreases significantly. Additionally, the compiled, binary
    interface of a class becomes independent of the underlying implementation of the
    class. Changing the implementation of a class only requires the nested implementation
    class to be recompiled and linked in. Users of the outer class are unaffected.
    As a bonus, the pImpl pattern provides a way to hide the underlying private details
    of a class, which may be useful when distributing class libraries or other proprietary
    code.
  prefs: []
  type: TYPE_NORMAL
- en: An advantage of including a `unique_ptr` in our pImpl implementation is that
    we have guaranteed proper destruction of the associated implementation class.
    We also have the potential to save inadvertent programmer-introduced pointer and
    memory mishaps!
  prefs: []
  type: TYPE_NORMAL
- en: The use of the pImpl pattern is a trade-off. Careful analysis of each class
    and of the application at hand will help determine whether the pImpl pattern is
    appropriate for your design.
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen implementations of the pImpl pattern initially using a raw
    pointer, and then applying a `unique_ptr`. Let us now briefly recap what we have
    learned relating to patterns before moving to the bonus chapter of our book, [*Chapter
    21*](B19087_21.xhtml#_idTextAnchor920), *Making C++ Safer*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have advanced our objective of becoming more indispensable
    C++ programmers by furthering our programming skills with another core design
    pattern. We have explored the pImpl pattern with an initial implementation using
    native C++ pointers and association and then improved our implementation by using
    a unique pointer. By examining the implementation, we easily understand how the
    pImpl pattern reduces compile-time dependencies and can make our code more implementation-dependent.
  prefs: []
  type: TYPE_NORMAL
- en: Making use of core design patterns, such as the pImpl pattern, will help you
    more easily contribute to reusable, maintainable code that is understood by other
    programmers familiar with common design patterns. Your software solutions will
    be based on creative and well-tested design solutions.
  prefs: []
  type: TYPE_NORMAL
- en: We have now completed our final design pattern together, wrapping up a long
    journey of understanding OOP in C++. You now have a multitude of skills, including
    a deep understanding of OOP, extended language features, and core design patterns,
    all of which make you a more valuable programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Though C++ is an intricate language with additional features, supplemental techniques,
    and additional design patterns to discover, you have more than a solid basis and
    level of expertise to easily navigate and embrace any additional language features,
    libraries, and patterns you may wish to acquire. You’ve come a long way; this
    has been an adventurous journey together! I have enjoyed every minute of our quest
    and I hope you have as well.
  prefs: []
  type: TYPE_NORMAL
- en: We began by reviewing basic language syntax and understanding the C++ essentials
    necessary to serve as building blocks for our then-upcoming OOP journey. We then
    embraced C++ as an OOP language, learning not only essential OO concepts but also
    how to implement them with either C++ language features, coding techniques, or
    both. We then extended your skills by adding knowledge of exception handling,
    friends, operator overloading, templates, STL basics, and testing OO classes and
    components. We then ventured into sophisticated programming techniques by embracing
    core design patterns and delving into code by applying each pattern of interest.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these acquired skill segments represents a new tier of C++ knowledge
    and mastery. Each will help you to create more easily maintainable and robust
    code. Your future as a well-versed, skilled OO programmer in C++ awaits. Now,
    let’s move on to our bonus chapter, and then, let’s get programming!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modify the pImpl pattern example in this chapter, which uses a unique pointer
    to additionally introduce unique pointers within the implementation of the nested
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Revise your `Student` class from a previous chapter solution to simply inherit
    from the `Person` class in this chapter that embraces the pImpl pattern. What
    difficulties, if any, do you have? Now, modify your `Student` class to additionally
    utilize the pImpl pattern with a unique pointer. A suggested `Student` class is
    one that includes an association with a `Course`. Now, what difficulties, if any,
    do you have?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What other examples can you imagine that might reasonably incorporate the pImpl
    pattern for relative implementation independence?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Part 5: Considerations for Safer Programming in C++'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this part is to understand what can be done as a programmer to make
    C++ a safer language, which in turn will help make our programs more robust. At
    this point, we will have learned a lot about C++, from language essentials to
    implementing OO designs in C++. We will have added additional skills to our repertoire,
    such as using friends and operator overloading, exception handling, templates,
    and the STL. We will have even looked in depth at a handful of popular design
    patterns. We will know that we can do nearly anything in C++, but we will have
    also seen that having so much power can leave room for cavalier programming and
    grave errors, which can lead to unwieldy code that is difficult to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will review what we have learned throughout the book with
    a keen eye toward understanding how we can work to make our code bulletproof.
    We will work toward a set of core programming guidelines to follow with one goal
    in mind: to make our programs safe!'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will revisit and expand upon our knowledge of smart pointers (unique, shared,
    and weak) as well as introduce a complimentary idiom, RAII. We will review what
    we have seen along the way relating to safety issues with native C++ pointers
    and sum up our safety concerns with a programming guideline: always prefer smart
    pointers in newly created C++ code.'
  prefs: []
  type: TYPE_NORMAL
- en: We will review modern programming features, such as range-based `for` loops
    and for-each style loops to understand how these simple constructs can help us
    avoid common errors. We will revisit `auto` instead of explicit typing to add
    safety to our code. We will revisit using well-tested STL types to ensure our
    code is not error-prone with ad hoc containers. We will revisit how the `const`
    qualifier can add safety to our code in a variety of ways. By reviewing specific
    language features used throughout the book, we will revisit how each of these
    features can add safety to our code. We will also consider thread safety and how
    various topics we have seen throughout the book relate to thread safety.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will discuss core programming guidelines, such as preferring initialization
    over assignment, or using one of `virtual`, `override`, or `final` to specify
    polymorphic operations and their methods. We will understand the importance of
    adopting a programming guideline and see the resources available to support programming
    safely in C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part comprises the following chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 21*](B19087_21.xhtml#_idTextAnchor920), *Making C++ Safer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 5: Considerations for Safer Programming in C++'
  prefs: []
  type: TYPE_NORMAL
