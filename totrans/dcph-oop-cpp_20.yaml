- en: '20'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '20'
- en: Removing Implementation Details Using the pImpl Pattern
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 pImpl 模式移除实现细节
- en: This chapter will wrap up our quest to expand your C++ programming repertoire
    beyond core OOP concepts, with the objective of further empowering you to solve
    recurring types of coding problems, utilizing common design patterns. Incorporating
    design patterns in your coding can not only provide refined solutions but also
    contribute to easier code maintenance and provide for potential code reuse.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将结束我们扩展你的 C++ 编程知识库的旅程，目标是进一步赋予你解决常见编码问题的能力，利用常见的设计模式。在你的编码中融入设计模式不仅可以提供更精细的解决方案，还有助于简化代码维护并提供潜在的代码重用。
- en: The next design pattern that we will learn how to implement effectively in C++
    is the **pImpl pattern**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来将学习如何在 C++ 中有效地实现下一个设计模式——**pImpl 模式**。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Comprehending the pImpl pattern and how it reduces compile-time dependencies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 pImpl 模式及其如何减少编译时依赖
- en: Understanding how to implement the pImpl pattern in C++ using association and
    unique pointers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何在 C++ 中使用关联和唯一指针实现 pImpl 模式
- en: Recognizing performance issues relating to pImpl and necessary trade-offs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别与 pImpl 相关的性能问题以及必要的权衡
- en: By the end of this chapter, you will understand the pImpl pattern and how it
    can be used to separate implementation details from a class interface to reduce
    compiler dependencies. Adding an additional design pattern to your skillset will
    help you become a more valuable programmer.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将理解 pImpl 模式以及如何将其用于将实现细节从类接口中分离出来，以减少编译器依赖。将额外的设计模式添加到你的技能集中将帮助你成为一个更有价值的程序员。
- en: Let’s increase our programming skillset by examining another common design pattern,
    the pImpl pattern.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过检查另一个常见的设计模式——pImpl 模式，来提高我们的编程技能。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter20](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter20).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter20` in a file named `Chp20-Ex1.cpp` under the aforementioned GitHub directory.
    Some programs are in applicable subdirectories as indicated in the examples.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 完整程序示例的在线代码可以在以下 GitHub 网址找到：[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter20](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter20)。每个完整程序示例都可以在
    GitHub 仓库中找到，位于相应章节标题（子目录）下的文件中，文件名对应章节编号，后面跟着一个连字符，然后是当前章节中的示例编号。例如，本章的第一个完整程序可以在上述
    GitHub 目录下的 `Chapter20` 子目录中找到，文件名为 `Chp20-Ex1.cpp`。一些程序位于示例中指示的可应用子目录中。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3CfQxhR](https://bit.ly/3CfQxhR).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的 CiA 视频可以在以下网址查看：[https://bit.ly/3CfQxhR](https://bit.ly/3CfQxhR)。
- en: Understanding the pImpl pattern
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 pImpl 模式
- en: The **pImpl pattern** (**p**ointer to **Impl**ementation idiom) is a structural
    design pattern that separates the implementation of a class from its public interface.
    This pattern was originally known as the **Bridge pattern** by the **Gang of Four**
    (**GofF**) and is also known as the **Cheshire Cat**, **compiler-firewall idiom**,
    **d-pointer**, **opaque pointer**, or **Handle pattern**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**pImpl 模式**（**p**ointer to **Impl**ementation 习语）是一种结构化设计模式，它将类的实现与其公共接口分离。这个模式最初被称为
    **Bridge 模式**，由 **Gang of Four**（**GoF**）提出，也被称为 **Cheshire Cat**、**compiler-firewall
    习语**、**d-pointer**、**opaque pointer** 或 **Handle 模式**。'
- en: The primary purpose of this pattern is to minimize compile-time dependencies.
    The result of reducing compile-time dependencies is that changes in a class definition
    (most notably, the private access region) will not send a wave of timely recompilations
    throughout a developing or deployed application. Instead, the necessary recompiled
    code can be isolated to the *implementation* of the class itself. The other pieces
    of the application that depend on the class definition will no longer be affected
    by recompilation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式的主要目的是最小化编译时依赖。减少编译时依赖的结果是，类定义中的更改（最明显的是私有访问区域）不会在开发或部署的应用程序中引发一系列及时的重新编译。相反，必要的重新编译代码可以隔离到类的*实现*本身。依赖于类定义的应用程序的其他部分将不再受重新编译的影响。
- en: Private members within a class definition can affect a class with respect to
    recompilation. This is because changing the data members can alter the size of
    an instance of that type. Also, private member functions must be matched by signature
    to function calls for overloading resolution as well as potential type conversions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义内部的私有成员可能会影响类的重新编译。这是因为更改数据成员可能会改变该类型实例的大小。此外，私有成员函数必须与函数调用签名匹配，以便进行重载解析以及潜在的类型转换。
- en: The manner in which traditional header (`.h` or `.hpp`) and source code files
    (`.cpp`) specify dependencies trigger recompilation. By removing the class inner
    implementation details from a class header file (and placing these details in
    a source file), we can remove many dependencies. We can change which header files
    are included in other header and source code files, streamlining the dependencies
    and hence the recompilation burden.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 传统头文件（`.h` 或 `.hpp`）和源代码文件（`.cpp`）中指定依赖关系的方式会触发重新编译。通过将类内部实现细节从类头文件中移除（并将这些细节放在源文件中），我们可以消除许多依赖。我们可以更改其他头文件和源代码文件中包含的头文件，简化依赖关系，从而减轻重新编译的负担。
- en: 'The pImpl pattern will compel the following adjustments to a class definition:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: pImpl 模式将强制对类定义进行以下调整：
- en: Private (non-virtual) members will instead be replaced by a pointer to a nested
    class type that includes the former private data members and methods. A forward
    declaration to the nested class will also be necessary.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有（非虚拟）成员将被替换为指向包含以前私有数据成员和方法的嵌套类类型的指针。还需要对嵌套类进行前向声明。
- en: The pointer to the implementation (`pImpl`) will be an association to which
    method calls of the class implementation will be delegated.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现的指针（`pImpl`）将是一个关联，类实现的函数调用将被委派到这个关联上。
- en: The revised class definition will exist in a header file for the class embracing
    this idiom. Any formerly included header files that this header file once depended
    upon will now be moved to instead be included in the source code file for this
    class.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修订后的类定义将存在于采用此习语的类的头文件中。任何以前由该头文件依赖的已包含的头文件现在将移动到源代码文件中，而不是包含在头文件中。
- en: Other classes including the header file of a pImpl class will now not face recompilation
    should the implementation of the class within its private access region be modified.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果修改了类在其私有访问区域内的实现，现在包括 pImpl 类的头文件在内的其他类将不会面临重新编译。
- en: To effectively manage dynamic memory resources of the associated object that
    represents the implementation, we will use a unique pointer (smart pointer).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了有效地管理表示实现的关联对象的动态内存资源，我们将使用唯一指针（智能指针）。
- en: The compilation freedom within the revised class definition takes advantage
    of the fact that pointers only require a forward declaration of the class type
    of the pointer to compile.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 修订后的类定义中的编译自由利用了这样一个事实：指针只需要对指针指向的类类型进行前向声明即可编译。
- en: Let’s move forward to first examine a basic, and then a refined, implementation
    of the pImpl pattern.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，首先考察一个基本的，然后是一个改进的 pImpl 模式的实现。
- en: Implementing the pImpl pattern
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 pImpl 模式
- en: In order to implement the pImpl pattern, we will need to revisit the typical
    header and source file composition. We will then replace the private members in
    a typical class definition with a pointer to the implementation, taking advantage
    of an association. The implementation will be encapsulated within a nested class
    of our target class. Our pImpl pointer will delegate all requests to our associated
    object that provides the inner class details or implementation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现pImpl模式，我们需要重新审视典型的头文件和源文件组成。然后，我们将典型类定义中的私有成员替换为指向实现的指针，利用关联的优势。实现将被封装在我们目标类的嵌套类中。我们的pImpl指针将委托所有请求到提供内部类细节或实现的关联对象。
- en: The inner (nested) class will be referred to as the **implementation class**.
    The original, now outer, class will be referred to as the **target** or **interface
    class**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 内部（嵌套）类将被称为**实现类**。原始的，现在外部的，类将被称为**目标**或**接口类**。
- en: We will start by reviewing the typical (non-pImpl pattern) file composition
    containing class definitions and member function definitions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先回顾包含类定义和成员函数定义的典型（非pImpl模式）文件组成。
- en: Organizing file and class contents to apply the pattern basics
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织文件和类内容以应用模式基础
- en: Let’s first review the organization strategy of the typical C++ class with respect
    to file placement regarding the class definition and member function definitions.
    We will next consider the revised organization strategy of a class utilizing the
    pImpl pattern.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先回顾典型C++类在文件放置方面的组织策略，包括类定义和成员函数定义。接下来，我们将考虑使用pImpl模式的类的修改后的组织策略。
- en: Reviewing typical file and class layout
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回顾典型文件和类布局
- en: Let’s take a look at a typical class definition and how we previously have organized
    a class with respect to source and header files, such as in our discussions in
    [*Chapter 5*](B19087_05.xhtml#_idTextAnchor222), *Exploring Classes in Detail*,
    and in [*Chapter 15*](B19087_15.xhtml#_idTextAnchor655), *Testing Classes and
    Components*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个典型的类定义以及我们之前是如何根据源文件和头文件组织类的，例如在[*第5章*](B19087_05.xhtml#_idTextAnchor222)“详细探索类”和[*第15章*](B19087_15.xhtml#_idTextAnchor655)“测试类和组件”中的讨论。
- en: 'Recall that we organized each class into a header (`.h` or `.hpp`) file containing
    the class definition and inline function definitions, plus a corresponding source
    code (`.cpp`) file containing the non-inline member function definitions. Let’s
    review a familiar sample class definition, `Person`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们将每个类组织到一个包含类定义和内联函数定义的头文件（`.h`或`.hpp`）中，以及一个包含非内联成员函数定义的相应源代码文件（`.cpp`）。让我们回顾一个熟悉的样本类定义，`Person`：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the aforementioned header file (`Person.h`), we have included our class definition
    for `Person` as well as inline function definitions for the class. Any larger
    inline function definitions not appearing within the class definition (indicated
    with the keyword `inline` in the prototype) would also appear in this file, after
    the class definition itself. Notice the use of preprocessor directives to ensure
    that a class definition is only included once per compilation unit.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述头文件（`Person.h`）中，我们包含了`Person`类的类定义以及类的内联函数定义。任何未出现在类定义中（在原型中用关键字`inline`指示）的较大内联函数定义也将出现在此文件中，在类定义之后。注意预处理指令的使用，以确保每个编译单元只包含一次类定义。
- en: 'Let’s next review the contents of the corresponding source code file, `Person.cpp`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来回顾相应的源代码文件的内容，`Person.cpp`：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the previously defined source code file, we define all the non-inline member
    functions for the class, `Person`. Though not all methods are shown, all can be
    found in our GitHub code. Also, if the class definition contains any static data
    members, the definition of the external variables designating the memory for these
    members should be included in the source code file.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前定义的源代码文件中，我们为类`Person`定义了所有非内联成员函数。尽管不是所有方法都显示出来，但所有方法都可以在我们的GitHub代码中找到。此外，如果类定义包含任何静态数据成员，这些成员的内存指定的外部变量定义也应包含在源代码文件中。
- en: Let’s now consider how we can remove the implementation details from the `Person`
    class definition and its corresponding header file, by applying the pImpl pattern.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑如何通过应用pImpl模式，从`Person`类定义及其相应的头文件中移除实现细节。
- en: Applying the pImpl pattern with revised class and file layout
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用pImpl模式并修改类和文件布局
- en: To employ the pImpl pattern, we will reorganize our class definition and its
    respective implementation. We will add a nested class within our existing class
    definition to represent the private members of our original class and the core
    of its implementation. Our outer class will include a pointer of the inner class
    type, serving as an association to our implementation. Our outer class will delegate
    all implementation requests to the inner, associated object. We will restructure
    the placement of classes and source code within the header and source code files.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 pImpl 模式，我们将重新组织我们的类定义及其相应的实现。我们将在现有的类定义内添加一个嵌套类，以表示原始类的私有成员和其实现的核心。我们的外部类将包含一个指向内部类类型的指针，作为对我们实现的关联。我们的外部类将委派所有实现请求到关联的内部对象。我们将重新结构化头文件和源代码文件中类的放置。
- en: 'Let’s take a closer look at our revised implementation for our class to understand
    each new detail required to implement the pImpl pattern. This example, composed
    of a source file `PersonImpl.cpp` and one header file `Person.h`, can be found
    in the same directory as a simple driver to test the pattern in our GitHub repository.
    To make a complete executable, you will need to compile and link together `PersonImp.cpp`
    and `Chp20-Ex1.cpp` (the driver), found in this same directory. Here is the GitHub
    repository URL for the driver:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看我们对类的修订版实现，以了解实现 pImpl 模式所需的所有新细节。这个例子由一个源文件 `PersonImpl.cpp` 和一个头文件
    `Person.h` 组成，可以在我们的 GitHub 仓库中的同一目录下找到，作为测试该模式的简单驱动程序。要制作一个完整的可执行文件，您需要编译并链接同一目录下的
    `PersonImp.cpp` 和 `Chp20-Ex1.cpp`（驱动程序）。以下是驱动程序的 GitHub 仓库 URL：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter20/Chp20-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter20/Chp20-Ex1.cpp)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter20/Chp20-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter20/Chp20-Ex1.cpp)'
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In our aforementioned revised class definition for `Person`, notice that we
    have removed the data members in the private access region. Any non-virtual private
    methods, had they existed, would have also been removed. Instead, we include a
    forward declaration to our nested class with `class PersonImpl;`. We also declare
    a pointer to the implementation using `PersonImpl *pImpl;`, which represents an
    association to the nested class members encapsulating the implementation. In our
    initial implementation, we will use a native (raw) C++ pointer to specify the
    association to the nested class. We will subsequently revise our implementation
    to utilize a *unique pointer*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前提到的针对 `Person` 的修订版类定义中，请注意我们已经移除了私有访问区域中的数据成员。任何非虚私有方法，如果存在的话，也会被移除。相反，我们通过
    `class PersonImpl;` 对嵌套类进行了前置声明。我们还声明了一个指向实现的指针 `PersonImpl *pImpl;`，它代表了对封装实现的嵌套类成员的关联。在我们的初始实现中，我们将使用原生（原始）C++指针来指定对嵌套类的关联。我们将随后修订我们的实现以利用
    *唯一指针*。
- en: Notice that our public interface for `Person` is much as before. All of our
    existing public and protected methods exist as expected, interface-wise. We notice,
    however, that the inline functions (which depend on the implementation of the
    data members) have been replaced with non-inline member function prototypes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的 `Person` 的公共接口与之前几乎相同。我们现有的所有公共和受保护方法在接口上如预期存在。然而，我们注意到，内联函数（依赖于数据成员的实现）已被非内联成员函数原型所取代。
- en: 'Let’s move forward to see the class definition for our nested class, `PersonImpl`,
    as well as the placement of the member functions of `PersonImpl` and `Person`
    in a common source code file, `PersonImpl.cpp`. We will start with the nested
    `PersonImpl` class definition:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，看看我们嵌套类 `PersonImpl` 的类定义，以及 `PersonImpl` 和 `Person` 的成员函数在公共源代码文件 `PersonImpl.cpp`
    中的放置。我们将从嵌套的 `PersonImpl` 类定义开始：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the previously mentioned nested class definition for `PersonImpl`, notice
    that this class looks surprisingly similar to the original class definition for
    `Person`. We have private data members and a full host of member function prototypes,
    even some inline functions written for brevity (which won’t actually be inlined
    because they are virtual). `PersonImpl` represents the implementation for `Person`,
    so it is crucial that this class can access all data and implement each method
    fully. Notice that the scope resolution operator (`::`) in the definition of `class
    Person::PersonImpl` is used to specify that `PersonImpl` is a nested class of
    `Person`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前提到的`PersonImpl`嵌套类定义中，请注意，这个类看起来与原始的`Person`类定义惊人地相似。我们有私有数据成员和一系列完整的成员函数原型，甚至为了简洁而编写的某些内联函数（实际上它们不会内联，因为它们是虚拟的）。`PersonImpl`代表`Person`的实现，因此这个类能够访问所有数据并完全实现每个方法至关重要。请注意，在`class
    Person::PersonImpl`的定义中使用的作用域解析运算符（`::`）用于指定`PersonImpl`是`Person`的嵌套类。
- en: 'Let’s continue by taking a look at the member function definitions for `PersonImpl`,
    which will appear in the same source file `PersonImpl.cpp` as the class definition.
    Though some methods have been abbreviated, their full online code is available
    in our GitHub repository:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续，通过查看`PersonImpl`的成员函数定义来继续，这些定义将出现在与类定义相同的源文件`PersonImpl.cpp`中。尽管一些方法已经缩写，但它们的完整在线代码可以在我们的GitHub仓库中找到：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the aforementioned code, we see the implementation for the overall `Person`
    class using the nested class `PersonImpl`. We see the member function definitions
    for `PersonImpl` and notice that the bodies of these methods are exactly how we
    previously implemented the methods in our original `Person` class without the
    pImpl pattern. Again, we notice the use of the scope resolution operator (`::`)
    to specify the class name for each member function definition, such as `void Person::PersonImpl::Print()
    const`. Here, `Person::PersonImpl` indicates the nested class of `PersonImpl`
    within the `Person` class.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们看到使用嵌套类`PersonImpl`实现的整体`Person`类的实现。我们看到`PersonImpl`的成员函数定义，并注意到这些方法的主体与我们之前在原始`Person`类中（没有使用pImpl模式）实现的方法完全相同。再次，我们注意到使用作用域解析运算符（`::`）来指定每个成员函数定义的类名，例如`void
    Person::PersonImpl::Print() const`。在这里，`Person::PersonImpl`表示`Person`类内部的嵌套类`PersonImpl`。
- en: 'Next, let’s take a moment to review the member function definitions for `Person`,
    our class employing the pImpl pattern. These methods will additionally contribute
    to the `PersonImpl.cpp` source code file and can be found in our GitHub repository:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们花一点时间回顾`Person`类的成员函数定义，我们在这个类中使用了pImpl模式。这些方法还将贡献到`PersonImpl.cpp`源代码文件中，可以在我们的GitHub仓库中找到：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the aforementioned member function definitions for `Person`, we notice that
    all methods delegate the required work to the nested class via the associated
    `pImpl`. In our constructors, we allocate the associated `pImpl` object and initialize
    it appropriately (using the member initialization list of each constructor). Our
    destructor is responsible for deleting the associated object using `delete pImpl;`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前提到的`Person`成员函数定义中，我们注意到所有方法都通过关联的`pImpl`将所需的工作委托给嵌套类。在我们的构造函数中，我们分配关联的`pImpl`对象并适当地初始化它（使用每个构造函数的成员初始化列表）。我们的析构函数负责使用`delete
    pImpl;`删除关联的对象。
- en: Our `Person` copy constructor will set member `pImpl` to the newly allocated
    memory, while invoking the `PersonImpl` copy constructor for the nested object
    creation and initialization, passing `*(p.pImpl)` to the nested object’s copy
    constructor. That is, `p.pImpl` is a pointer, so we dereference the pointer using
    `*` to obtain a referenceable object for the `PersonImpl` copy constructor.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Person`拷贝构造函数将成员`pImpl`设置为新的分配的内存，同时调用嵌套对象的创建和初始化的`PersonImpl`拷贝构造函数，将`*(p.pImpl)`传递给嵌套对象的拷贝构造函数。也就是说，`p.pImpl`是一个指针，所以我们使用`*`解引用指针以获得对`PersonImpl`拷贝构造函数的可引用对象。
- en: We use a similar strategy in our overloaded assignment operator for `Person`.
    That is, there are no data members other than `pImpl` to perform a deep assignment,
    so we merely call the `PersonImpl` assignment operator on associated object `pImpl`,
    again passing in `*(p.pImpl)` as the right-hand value.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Person`的重载赋值运算符中也使用了类似的策略。也就是说，除了`pImpl`之外没有其他数据成员来执行深度赋值，所以我们只是调用关联对象`pImpl`上的`PersonImpl`赋值运算符，再次传入`*(p.pImpl)`作为右侧值。
- en: Finally, let us consider a sample driver to demonstrate our pattern in action.
    Interestingly, our driver will work with either our originally specified non-pattern
    class (source and header files) or with our revised pImpl pattern-specific source
    and header files!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们考虑一个示例驱动程序来展示我们的模式在实际应用中的效果。有趣的是，我们的驱动程序可以与最初指定的非模式类（源文件和头文件）一起工作，也可以与经过修订的pImpl模式特定源文件和头文件一起工作！
- en: Bringing the pattern components together
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将模式组件组合在一起
- en: 'Let’s finally take a look at our `main()` function in our driver source file
    `Chp20-Ex1.cpp` to see how our pattern is orchestrated:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们最后看看我们的驱动程序源文件`Chp20-Ex1.cpp`中的`main()`函数，看看我们的模式是如何编排的：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Reviewing our aforementioned `main()` function, we simply dynamically allocate
    several `Person` instances, call selected `Person` method(s) on the instances
    (`Print()`), and then delete each instance. We have included the `Person.h` header
    file, as expected, to be able to utilize this class. From the Client’s point of
    view, everything looks *as usual* and appears pattern unspecific.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们之前提到的`main()`函数，我们只是动态分配了几个`Person`实例，在实例上调用选定的`Person`方法（`Print()`），然后删除每个实例。我们如预期那样包含了`Person.h`头文件，以便能够使用这个类。从客户端的角度来看，一切看起来*都很正常*，看起来没有使用模式。
- en: Note that we separately compile `PersonImp.cpp` and `Chp20-Ex1.cpp`, linking
    the object files together into an executable. However, due to the pImpl pattern,
    if we change the implementation for `Person`, the change will be encapsulated
    by its implementation in the `PersonImp` nested class. Only `PersonImp.cpp` will
    require recompilation. The Client will not need to recompile the driver, `Chp20-Ex1.cpp`,
    because the changes will not have occurred in the `Person.h` header file (which
    the driver depends on).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们分别编译`PersonImp.cpp`和`Chp20-Ex1.cpp`，将目标文件链接在一起生成可执行文件。然而，由于使用了pImpl模式，如果我们更改`Person`的实现，这种更改将被封装在其`PersonImp`嵌套类中的实现中。只有`PersonImp.cpp`需要重新编译。客户端不需要重新编译驱动程序`Chp20-Ex1.cpp`，因为更改不会发生在`Person.h`头文件中（驱动程序依赖于该头文件）。
- en: 'Let’s take a look at the output for this program:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个程序的输出：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the aforementioned output, we see the expected results of our simple driver.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述输出中，我们看到了我们简单驱动程序的预期结果。
- en: Let’s move forward to consider how we may improve our implementation of the
    pImpl pattern using a unique pointer.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，考虑如何使用唯一指针改进我们的pImpl模式实现。
- en: Improving the pattern with a unique pointer
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用唯一指针改进模式
- en: Our initial implementation using an association with a native C++ pointer relieves
    many compiler dependencies. This is because the compiler only needs to see a forward
    class declaration of the pImpl pointer type in order to compile successfully.
    So far, we have achieved the core goal of using the pImpl pattern – reducing recompilation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初使用与原生C++指针关联的实现减少了编译器的依赖。这是因为编译器只需要看到pImpl指针类型的类前向声明就能成功编译。到目前为止，我们已经实现了使用pImpl模式的核心目标——减少重新编译。
- en: However, there is always criticism of using native or *raw* pointers. We are
    responsible for managing the memory ourselves, including remembering to delete
    the allocated nested class type in our outer class destructor. Memory leaks, memory
    misuse, and memory errors are potential drawbacks for managing memory resources
    ourselves with raw pointers. For that reason, it is customary to implement the
    pImpl pattern using **smart pointers**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用原生或*原始*指针总是存在批评。我们负责自己管理内存，包括记住在外部类析构函数中删除分配的嵌套类类型。使用原始指针自行管理内存资源可能会导致内存泄漏、内存误用和内存错误等潜在缺点。因此，通常使用**智能指针**来实现pImpl模式。
- en: We will continue our quest to implement pImpl by examining a key component often
    used with the pImpl pattern – smart pointers, or more specifically, the `unique_ptr`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续我们的任务，通过检查与pImpl模式经常一起使用的关键组件——智能指针，或者更具体地说，是`unique_ptr`——来实现pImpl。
- en: Let’s start by understanding smart pointer basics.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先理解智能指针的基本知识。
- en: Understanding smart pointers
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解智能指针
- en: To implement the pImpl pattern customarily, we must first understand smart pointers.
    A **smart pointer** is a small wrapper class that encapsulates a raw pointer,
    ensuring that the pointer it contains is automatically deleted when the wrapper
    object goes out of scope. The class implementing the smart pointer can be implemented
    using templates to create a smart pointer for any data type.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现pImpl模式，我们首先必须理解智能指针。**智能指针**是一个小的包装类，它封装了一个原始指针，确保当包装对象超出作用域时，它所包含的指针会自动删除。实现智能指针的类可以使用模板来实现，为任何数据类型创建智能指针。
- en: 'Here is a very simple example of a smart pointer. This example can be found
    on our GitHub:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个非常简单的智能指针示例。这个示例可以在我们的GitHub上找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter20/Chp20-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter20/Chp20-Ex2.cpp)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter20/Chp20-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter20/Chp20-Ex2.cpp)'
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the previously defined, straightforward `SmartPointer` class, we simply encapsulate
    a raw pointer. The key benefit is that the `SmartPointer` destructor will ensure
    that the raw pointer is destructed when the wrapper object is popped off the stack
    (for local instances) or before the program terminates (for static and extern
    instances). Certainly, this class is basic, and we must determine the desired
    behaviors for the copy constructor and the assignment operator. That is, allow
    shallow copies/assignment, require deep copies/assignment, or disallow all copies/assignment.
    Nonetheless, we can now visualize the concept of a smart pointer.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前定义的简单`SmartPointer`类中，我们只是封装了一个原始指针。关键好处是`SmartPointer`的析构函数将确保在包装对象从栈中弹出（对于局部实例）或程序终止之前（对于静态和外部实例）时，原始指针被销毁。当然，这个类是基础的，我们必须确定所需的复制构造函数和赋值运算符的行为。也就是说，允许浅复制/赋值，要求深复制/赋值，或者禁止所有复制/赋值。尽管如此，我们现在可以可视化智能指针的概念。
- en: 'Here is the output for our smart pointer example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们智能指针示例的输出：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The aforementioned output shows that the memory for each object contained within
    a `SmartPointer` is managed for us. We can quite easily see with the `"SmartPtr
    Destructor"` output strings that the destructor for each object is called on our
    behalf when the local objects in `main()` go out of scope and are popped off the
    stack.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如上述输出所示，`SmartPointer`中包含的每个对象的内存都是由我们管理的。我们可以很容易地通过“`SmartPtr Destructor`”输出字符串看到，当`main()`中的局部对象超出作用域并被从栈中弹出时，会代表我们调用每个对象的析构函数。
- en: Understanding unique pointers
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解唯一指针
- en: A `unique_ptr` in the Standard C++ Library, is a type of smart pointer that
    encapsulates exclusive ownership and access to a given heap memory resource. A
    `unique_ptr` cannot be duplicated; the owner of a `unique_ptr` will have sole
    use of that pointer. Owners of unique pointers can choose to move these pointers
    to other resources, but the repercussions are that the original resource will
    no longer contain the `unique_ptr`. We must `#include <memory>` to include the
    definition for `unique_ptr`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 标准C++库中的`unique_ptr`是一种封装了给定堆内存资源独占所有权和访问权的智能指针类型。`unique_ptr`不能被复制；`unique_ptr`的所有者将独占使用该指针。`unique_ptr`的所有者可以选择将这些指针移动到其他资源，但后果是原始资源将不再包含`unique_ptr`。我们必须`#include
    <memory>`来包含`unique_ptr`的定义。
- en: Additional types of smart pointers
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类型的智能指针
- en: Other types of smart pointers are available in the Standard C++ Library, in
    addition to `unique_ptr`, such as `weak_ptr` and `shared_ptr`. These additional
    types of smart pointers will be explored in [*Chapter 21*](B19087_21.xhtml#_idTextAnchor920),
    *Making C++ Safer*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 标准C++库中除了`unique_ptr`之外，还有其他类型的智能指针可用，例如`weak_ptr`和`shared_ptr`。这些额外的智能指针类型将在[*第21章*](B19087_21.xhtml#_idTextAnchor920)
    *《使C++更安全》*中探讨。
- en: 'Modifying our smart pointer program to instead utilize `unique_ptr`, we now
    have the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的智能指针程序修改为使用`unique_ptr`，我们现在有以下内容：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Our output will be similar to the `SmartPointer` example; the difference is
    that no `"SmartPtr Destructor"` call message will be displayed (as we are using
    a `unique_ptr` instead). Notice that because we included `using std::unique_ptr;`,
    we did not need to qualify `unique_ptr` with `std::` in the unique pointer declaration.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的输出将与 `SmartPointer` 示例类似；区别在于不会显示 `"SmartPtr Destructor"` 调用消息（因为我们使用的是 `unique_ptr`）。注意，因为我们包含了
    `using std::unique_ptr;`，所以我们不需要在唯一指针声明中对 `unique_ptr` 进行 `std::` 限定。
- en: With this knowledge, let’s add unique pointers to our pImpl pattern.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些知识，让我们将唯一指针添加到我们的 pImpl 模式中。
- en: Adding unique pointers to the pattern
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向模式中添加唯一指针
- en: 'To implement the pImpl pattern using a `unique_ptr`, we will make minimal changes
    to our previous implementation, starting with our `Person.h` header file. The
    full program example of our pImpl pattern utilizing a `unique_ptr` can be found
    in our GitHub repository and will additionally include a revised file for `PersonImpl.cpp`.
    Here is the URL for the driver, `Chp20-Ex3.cpp`; note the subdirectory, `unique`,
    in our GitHub repository for this complete example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `unique_ptr` 实现pImpl模式，我们将对我们的先前实现进行最小程度的修改，从我们的 `Person.h` 头文件开始。我们使用 `unique_ptr`
    的 pImpl 模式完整程序示例可以在我们的 GitHub 仓库中找到，并将包括对 `PersonImpl.cpp` 的修订文件。以下是驱动程序的 URL，`Chp20-Ex3.cpp`；注意我们
    GitHub 仓库中此完整示例的子目录，`unique`：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter20/unique/Chp20-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter20/unique/Chp20-Ex3.cpp)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter20/unique/Chp20-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter20/unique/Chp20-Ex3.cpp)'
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice, in the revised aforementioned class definition for `Person`, the unique
    pointer declaration of `std::unique_ptr<PersonImpl> pImpl;`. Here, we use the
    `std::` qualifier because the standard namespace has not been explicitly included
    in our header file. We also `#include <memory>` to gain the definition for `unique_ptr`.
    The remainder of the class is identical to our initial implementation of pImpl
    using an association implemented with a raw pointer.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在修改后的 `Person` 类定义中，`std::unique_ptr<PersonImpl> pImpl;` 的唯一指针声明。在这里，我们使用
    `std::` 限定符，因为标准命名空间尚未在我们的头文件中显式包含。我们还 `#include <memory>` 以获取 `unique_ptr` 的定义。类的其余部分与我们的初始
    pImpl 实现相同，该实现使用原始指针实现的关联。
- en: 'Next, let’s understand the extent to which our source code needs to be modified
    from our initial pImpl implementation. Let’s now take a look at the necessary
    modified member functions in our source file, `PersonImpl.cpp`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们了解我们的源代码需要从初始的 pImpl 实现中修改到何种程度。现在，让我们查看源文件 `PersonImpl.cpp` 中必要的修改后的成员函数：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Taking a look at the aforementioned member functions requiring modification,
    we see that it is only the `Person` destructor! Because we are using a unique
    pointer to implement the association to the nested class implementation, we no
    longer need to manage the memory for this resource ourselves. That’s pretty nice!
    With these minor changes, our pImpl pattern now features a `unique_ptr` to designate
    the implementation of the class.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 查看需要修改的上述成员函数，我们发现只有 `Person` 析构函数！因为我们使用唯一指针来实现对嵌套类实现的关联，所以我们不再需要自己管理这个资源的内存。这真是太好了！通过这些小的改动，我们的
    pImpl 模式现在具有一个 `unique_ptr` 来指定类的实现。
- en: Next, let’s examine some of the performance issues relating to using the pImpl
    pattern.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们检查一些与使用 pImpl 模式相关的性能问题。
- en: Understanding pImpl pattern trade-offs
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 pImpl 模式的权衡
- en: Incorporating the pImpl pattern into production code has both benefits and disadvantages.
    Let’s review each so that we can better understand the circumstances that may
    warrant deploying this pattern.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将 pImpl 模式集成到生产代码中既有优点也有缺点。让我们逐一回顾，以便我们更好地理解可能需要部署此模式的情况。
- en: The negligible performance issues encompass most of the disadvantages. That
    is, nearly every request made of the target (interface) class will need to be
    delegated to its nested implementation class. The only requests that can be handled
    by the outer class will be those not involving any data members; those circumstances
    will be extraordinarily rare! Another disadvantage includes slightly higher memory
    requirements of instances to accommodate the added pointer as part of the pattern
    implementation. These issues will be paramount in embedded software systems and
    those requiring peak performance, but relatively minor otherwise.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 可忽略的性能问题涵盖了大多数缺点。也就是说，针对目标（接口）类的几乎所有请求都需要委派给其嵌套的实现类。唯一可以由外部类处理的请求将是不涉及任何数据成员的请求；这些情况将极其罕见！另一个缺点包括实例的内存需求略有增加，以适应模式实现中添加的指针。这些问题在嵌入式软件系统和需要峰值性能的系统中将至关重要，但在其他情况下相对较小。
- en: Maintenance will be a little more difficult for classes employing the pImpl
    pattern, an unfortunate disadvantage. Each target class is now paired with an
    extra (implementation) class, including a set of forwarding methods to delegate
    requests to the implementation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于采用pImpl模式的类，维护将稍微困难一些，这是一个不幸的缺点。每个目标类现在都配有一个额外的（实现）类，包括一组转发方法，用于将请求委派给实现类。
- en: A few implementation difficulties may also arise. For example, if any of the
    private members (now in the nested implementation class) need to access any of
    the protected or public methods of the outer (interface) class, we will need to
    include a backlink from the nested class to the outer class to access that member.
    Why? The `this` pointer in the inner class will be of the nested object type.
    Yet the protected and public methods in the outer object will expect a `this`
    pointer to the outer object – even if those public methods will then redelegate
    the request to call a private nested class method for help. This backlink will
    also be required to call public virtual functions of the interface from the scope
    of the inner class (implementation). Keep in mind, however, that we impact performance
    with another added pointer per object and with delegation to call each method
    in the associated object.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能出现一些实现困难。例如，如果任何私有成员（现在在嵌套实现类中）需要访问外部（接口）类的任何受保护或公共方法，我们需要从嵌套类到外部类包含一个回链以访问该成员。为什么？内部类中的`this`指针将是嵌套对象类型。然而，外部对象中的受保护和公共方法将期望一个指向外部对象的`this`指针——即使这些公共方法随后将请求重新委派以调用私有嵌套类方法以获得帮助。此回链还用于从内部类（实现）的作用域调用接口的公共虚拟函数。然而，请记住，我们通过为每个对象添加另一个指针以及委派调用相关对象中的每个方法来影响性能。
- en: There are several advantages of utilizing the pImpl pattern, offering important
    considerations. Of most importance, recompile time during the development and
    maintenance of code decreases significantly. Additionally, the compiled, binary
    interface of a class becomes independent of the underlying implementation of the
    class. Changing the implementation of a class only requires the nested implementation
    class to be recompiled and linked in. Users of the outer class are unaffected.
    As a bonus, the pImpl pattern provides a way to hide the underlying private details
    of a class, which may be useful when distributing class libraries or other proprietary
    code.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 利用pImpl模式有几个优点，提供了重要的考虑因素。最重要的是，在代码的开发和维护期间，重新编译时间显著减少。此外，类的编译后的二进制接口与类的底层实现无关。仅需要重新编译和链接嵌套的实现类即可更改类的实现。外部类的用户不受影响。作为额外的好处，pImpl模式提供了一种隐藏类底层私有细节的方法，这在分发类库或其他专有代码时可能很有用。
- en: An advantage of including a `unique_ptr` in our pImpl implementation is that
    we have guaranteed proper destruction of the associated implementation class.
    We also have the potential to save inadvertent programmer-introduced pointer and
    memory mishaps!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的pImpl实现中包含`unique_ptr`的一个优点是，我们保证了相关实现类的正确销毁。我们还有潜力避免程序员无意中引入的指针和内存错误！
- en: The use of the pImpl pattern is a trade-off. Careful analysis of each class
    and of the application at hand will help determine whether the pImpl pattern is
    appropriate for your design.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pImpl模式是一种权衡。仔细分析每个类和当前的应用程序将有助于确定pImpl模式是否适合您的设计。
- en: We have now seen implementations of the pImpl pattern initially using a raw
    pointer, and then applying a `unique_ptr`. Let us now briefly recap what we have
    learned relating to patterns before moving to the bonus chapter of our book, [*Chapter
    21*](B19087_21.xhtml#_idTextAnchor920), *Making C++ Safer*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了pImpl模式的实现，最初使用原始指针，然后应用了`unique_ptr`。现在，让我们简要回顾一下与模式相关的学习内容，然后进入我们书籍的附加章节，[*第21章*](B19087_21.xhtml#_idTextAnchor920)，*使C++更安全*。
- en: Summary
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have advanced our objective of becoming more indispensable
    C++ programmers by furthering our programming skills with another core design
    pattern. We have explored the pImpl pattern with an initial implementation using
    native C++ pointers and association and then improved our implementation by using
    a unique pointer. By examining the implementation, we easily understand how the
    pImpl pattern reduces compile-time dependencies and can make our code more implementation-dependent.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过进一步掌握另一个核心设计模式来提高我们的编程技能，从而实现了成为更不可或缺的C++程序员的宏伟目标。我们探讨了pImpl模式，最初使用原生C++指针和关联进行实现，然后通过使用唯一指针来改进我们的实现。通过检查实现，我们很容易理解pImpl模式如何减少编译时依赖，并使我们的代码更依赖于实现。
- en: Making use of core design patterns, such as the pImpl pattern, will help you
    more easily contribute to reusable, maintainable code that is understood by other
    programmers familiar with common design patterns. Your software solutions will
    be based on creative and well-tested design solutions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 利用核心设计模式，如pImpl模式，将帮助你更轻松地贡献可重用、可维护且其他熟悉常见设计模式的程序员可以理解的代码。你的软件解决方案将基于创造性和经过充分测试的设计解决方案。
- en: We have now completed our final design pattern together, wrapping up a long
    journey of understanding OOP in C++. You now have a multitude of skills, including
    a deep understanding of OOP, extended language features, and core design patterns,
    all of which make you a more valuable programmer.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在一起完成了我们的最后一个设计模式，结束了在C++中理解面向对象编程的漫长旅程。你现在拥有了许多技能，包括对面向对象有深入的理解、扩展的语言特性和核心设计模式，所有这些都使你成为一个更有价值的程序员。
- en: Though C++ is an intricate language with additional features, supplemental techniques,
    and additional design patterns to discover, you have more than a solid basis and
    level of expertise to easily navigate and embrace any additional language features,
    libraries, and patterns you may wish to acquire. You’ve come a long way; this
    has been an adventurous journey together! I have enjoyed every minute of our quest
    and I hope you have as well.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管C++是一种复杂的语言，具有额外的功能、补充技术和额外的设计模式需要探索，但你已经拥有了一个坚实的基础和专业知识水平，可以轻松地导航和接受你可能希望获得的任何额外的语言功能、库和模式。你已经走了很长的路；这已经是一次冒险的旅程！我享受了我们这次探索的每一分钟，我希望你也一样。
- en: We began by reviewing basic language syntax and understanding the C++ essentials
    necessary to serve as building blocks for our then-upcoming OOP journey. We then
    embraced C++ as an OOP language, learning not only essential OO concepts but also
    how to implement them with either C++ language features, coding techniques, or
    both. We then extended your skills by adding knowledge of exception handling,
    friends, operator overloading, templates, STL basics, and testing OO classes and
    components. We then ventured into sophisticated programming techniques by embracing
    core design patterns and delving into code by applying each pattern of interest.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先回顾了基本语言语法，并理解了C++的必要要素，这些要素是我们当时即将开始的面向对象编程（OOP）之旅的基石。然后，我们将C++视为一种面向对象的编程语言，不仅学习了必要的面向对象概念，还学习了如何使用C++语言特性、编码技术或两者结合来实现这些概念。接着，我们通过添加异常处理、友元、运算符重载、模板、STL基础以及测试面向对象类和组件的知识来扩展你的技能。然后，我们通过采用核心设计模式和深入应用感兴趣的模式来应用代码，我们冒险进入了更复杂的编程技术。
- en: Each of these acquired skill segments represents a new tier of C++ knowledge
    and mastery. Each will help you to create more easily maintainable and robust
    code. Your future as a well-versed, skilled OO programmer in C++ awaits. Now,
    let’s move on to our bonus chapter, and then, let’s get programming!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些获得的知识技能块代表了C++知识掌握的新层次。每个都将帮助你创建更易于维护和健壮的代码。你作为一个熟练的C++面向对象程序员的未来正在等待。现在，让我们继续我们的附加章节，然后，让我们开始编程！
- en: Questions
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Modify the pImpl pattern example in this chapter, which uses a unique pointer
    to additionally introduce unique pointers within the implementation of the nested
    class.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改本章中使用的唯一指针的pImpl模式示例，在嵌套类的实现中进一步引入唯一指针。
- en: Revise your `Student` class from a previous chapter solution to simply inherit
    from the `Person` class in this chapter that embraces the pImpl pattern. What
    difficulties, if any, do you have? Now, modify your `Student` class to additionally
    utilize the pImpl pattern with a unique pointer. A suggested `Student` class is
    one that includes an association with a `Course`. Now, what difficulties, if any,
    do you have?
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改之前章节中的`Student`类，使其简单地从本章中采用pImpl模式的`Person`类继承。你遇到什么困难吗？现在，修改`Student`类，使其额外利用唯一指针的pImpl模式。一个建议的`Student`类是包含与`Course`关联的类。现在，你遇到什么困难吗？
- en: What other examples can you imagine that might reasonably incorporate the pImpl
    pattern for relative implementation independence?
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能想象出哪些其他示例可以合理地结合pImpl模式以实现相对的实现独立性？
- en: 'Part 5: Considerations for Safer Programming in C++'
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5部分：C++中更安全编程的考虑因素
- en: The goal of this part is to understand what can be done as a programmer to make
    C++ a safer language, which in turn will help make our programs more robust. At
    this point, we will have learned a lot about C++, from language essentials to
    implementing OO designs in C++. We will have added additional skills to our repertoire,
    such as using friends and operator overloading, exception handling, templates,
    and the STL. We will have even looked in depth at a handful of popular design
    patterns. We will know that we can do nearly anything in C++, but we will have
    also seen that having so much power can leave room for cavalier programming and
    grave errors, which can lead to unwieldy code that is difficult to maintain.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分的目标是了解作为程序员我们可以做什么来使C++成为一种更安全的语言，这反过来将有助于使我们的程序更健壮。到目前为止，我们已经对C++有了很多了解，从语言基础到在C++中实现OO设计。我们已经增加了额外的技能，例如使用友元和运算符重载、异常处理、模板和STL。我们甚至深入研究了几个流行的设计模式。我们知道我们几乎可以在C++中做任何事情，但我们也已经看到，拥有如此大的能力可能会留下粗心编程和严重错误的空间，这可能导致难以维护的代码。
- en: 'In this section, we will review what we have learned throughout the book with
    a keen eye toward understanding how we can work to make our code bulletproof.
    We will work toward a set of core programming guidelines to follow with one goal
    in mind: to make our programs safe!'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将以敏锐的目光回顾全书所学内容，了解我们如何努力使我们的代码更加健壮。我们将致力于制定一套核心编程指南，目标只有一个：使我们的程序更安全！
- en: 'We will revisit and expand upon our knowledge of smart pointers (unique, shared,
    and weak) as well as introduce a complimentary idiom, RAII. We will review what
    we have seen along the way relating to safety issues with native C++ pointers
    and sum up our safety concerns with a programming guideline: always prefer smart
    pointers in newly created C++ code.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重新审视并扩展我们对智能指针（唯一、共享和弱引用）的知识，以及介绍一个互补的惯用语，RAII。我们将回顾与原生C++指针相关的安全问题，并总结我们的安全担忧，以编程指南的形式：在新的C++代码中始终优先使用智能指针。
- en: We will review modern programming features, such as range-based `for` loops
    and for-each style loops to understand how these simple constructs can help us
    avoid common errors. We will revisit `auto` instead of explicit typing to add
    safety to our code. We will revisit using well-tested STL types to ensure our
    code is not error-prone with ad hoc containers. We will revisit how the `const`
    qualifier can add safety to our code in a variety of ways. By reviewing specific
    language features used throughout the book, we will revisit how each of these
    features can add safety to our code. We will also consider thread safety and how
    various topics we have seen throughout the book relate to thread safety.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回顾现代编程特性，例如基于范围的`for`循环和for-each风格的循环，以了解这些简单的结构如何帮助我们避免常见错误。我们将重新审视`auto`关键字，而不是显式类型，以增加代码的安全性。我们将重新审视使用经过良好测试的STL类型，以确保我们的代码在使用临时容器时不会出错。我们将重新审视`const`限定符以多种方式增加代码的安全性。通过回顾全书使用的具体语言特性，我们将重新审视每个特性如何增加代码的安全性。我们还将考虑线程安全性以及我们全书所见的各种主题如何与线程安全性相关。
- en: Finally, we will discuss core programming guidelines, such as preferring initialization
    over assignment, or using one of `virtual`, `override`, or `final` to specify
    polymorphic operations and their methods. We will understand the importance of
    adopting a programming guideline and see the resources available to support programming
    safely in C++.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将讨论核心编程指南，例如优先初始化而不是赋值，或者使用`virtual`、`override`或`final`之一来指定多态操作及其方法。我们将理解采用编程指南的重要性，并了解可用于支持在C++中安全编程的资源。
- en: 'This part comprises the following chapter:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 21*](B19087_21.xhtml#_idTextAnchor920), *Making C++ Safer*'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第21章*](B19087_21.xhtml#_idTextAnchor920)，*使C++更安全*'
- en: 'Part 5: Considerations for Safer Programming in C++'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 第5部分：C++更安全编程的考虑因素
