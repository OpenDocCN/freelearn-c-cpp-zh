- en: '20'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '20'
- en: Removing Implementation Details Using the pImpl Pattern
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 pImpl 模式移除实现细节
- en: This chapter will wrap up our quest to expand your C++ programming repertoire
    beyond core OOP concepts, with the objective of further empowering you to solve
    recurring types of coding problems, utilizing common design patterns. Incorporating
    design patterns in your coding can not only provide refined solutions but also
    contribute to easier code maintenance and provide for potential code reuse.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将结束我们扩展你的 C++ 编程知识库的旅程，目标是进一步赋予你解决常见编码问题的能力，利用常见的设计模式。在你的编码中融入设计模式不仅可以提供更精细的解决方案，还有助于简化代码维护并提供潜在的代码重用。
- en: The next design pattern that we will learn how to implement effectively in C++
    is the **pImpl pattern**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来将学习如何在 C++ 中有效地实现下一个设计模式——**pImpl 模式**。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Comprehending the pImpl pattern and how it reduces compile-time dependencies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 pImpl 模式及其如何减少编译时依赖
- en: Understanding how to implement the pImpl pattern in C++ using association and
    unique pointers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何在 C++ 中使用关联和唯一指针实现 pImpl 模式
- en: Recognizing performance issues relating to pImpl and necessary trade-offs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别与 pImpl 相关的性能问题以及必要的权衡
- en: By the end of this chapter, you will understand the pImpl pattern and how it
    can be used to separate implementation details from a class interface to reduce
    compiler dependencies. Adding an additional design pattern to your skillset will
    help you become a more valuable programmer.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将理解 pImpl 模式以及如何将其用于将实现细节从类接口中分离出来，以减少编译器依赖。将额外的设计模式添加到你的技能集中将帮助你成为一个更有价值的程序员。
- en: Let’s increase our programming skillset by examining another common design pattern,
    the pImpl pattern.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过检查另一个常见的设计模式——pImpl 模式，来提高我们的编程技能。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter20](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter20).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter20` in a file named `Chp20-Ex1.cpp` under the aforementioned GitHub directory.
    Some programs are in applicable subdirectories as indicated in the examples.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 完整程序示例的在线代码可以在以下 GitHub 网址找到：[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter20](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter20)。每个完整程序示例都可以在
    GitHub 仓库中找到，位于相应章节标题（子目录）下的文件中，文件名对应章节编号，后面跟着一个连字符，然后是当前章节中的示例编号。例如，本章的第一个完整程序可以在上述
    GitHub 目录下的 `Chapter20` 子目录中找到，文件名为 `Chp20-Ex1.cpp`。一些程序位于示例中指示的可应用子目录中。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3CfQxhR](https://bit.ly/3CfQxhR).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的 CiA 视频可以在以下网址查看：[https://bit.ly/3CfQxhR](https://bit.ly/3CfQxhR)。
- en: Understanding the pImpl pattern
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 pImpl 模式
- en: The **pImpl pattern** (**p**ointer to **Impl**ementation idiom) is a structural
    design pattern that separates the implementation of a class from its public interface.
    This pattern was originally known as the **Bridge pattern** by the **Gang of Four**
    (**GofF**) and is also known as the **Cheshire Cat**, **compiler-firewall idiom**,
    **d-pointer**, **opaque pointer**, or **Handle pattern**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**pImpl 模式**（**p**ointer to **Impl**ementation 习语）是一种结构化设计模式，它将类的实现与其公共接口分离。这个模式最初被称为
    **Bridge 模式**，由 **Gang of Four**（**GoF**）提出，也被称为 **Cheshire Cat**、**compiler-firewall
    习语**、**d-pointer**、**opaque pointer** 或 **Handle 模式**。'
- en: The primary purpose of this pattern is to minimize compile-time dependencies.
    The result of reducing compile-time dependencies is that changes in a class definition
    (most notably, the private access region) will not send a wave of timely recompilations
    throughout a developing or deployed application. Instead, the necessary recompiled
    code can be isolated to the *implementation* of the class itself. The other pieces
    of the application that depend on the class definition will no longer be affected
    by recompilation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Private members within a class definition can affect a class with respect to
    recompilation. This is because changing the data members can alter the size of
    an instance of that type. Also, private member functions must be matched by signature
    to function calls for overloading resolution as well as potential type conversions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The manner in which traditional header (`.h` or `.hpp`) and source code files
    (`.cpp`) specify dependencies trigger recompilation. By removing the class inner
    implementation details from a class header file (and placing these details in
    a source file), we can remove many dependencies. We can change which header files
    are included in other header and source code files, streamlining the dependencies
    and hence the recompilation burden.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'The pImpl pattern will compel the following adjustments to a class definition:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Private (non-virtual) members will instead be replaced by a pointer to a nested
    class type that includes the former private data members and methods. A forward
    declaration to the nested class will also be necessary.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pointer to the implementation (`pImpl`) will be an association to which
    method calls of the class implementation will be delegated.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The revised class definition will exist in a header file for the class embracing
    this idiom. Any formerly included header files that this header file once depended
    upon will now be moved to instead be included in the source code file for this
    class.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other classes including the header file of a pImpl class will now not face recompilation
    should the implementation of the class within its private access region be modified.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To effectively manage dynamic memory resources of the associated object that
    represents the implementation, we will use a unique pointer (smart pointer).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The compilation freedom within the revised class definition takes advantage
    of the fact that pointers only require a forward declaration of the class type
    of the pointer to compile.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move forward to first examine a basic, and then a refined, implementation
    of the pImpl pattern.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the pImpl pattern
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to implement the pImpl pattern, we will need to revisit the typical
    header and source file composition. We will then replace the private members in
    a typical class definition with a pointer to the implementation, taking advantage
    of an association. The implementation will be encapsulated within a nested class
    of our target class. Our pImpl pointer will delegate all requests to our associated
    object that provides the inner class details or implementation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现pImpl模式，我们需要重新审视典型的头文件和源文件组成。然后，我们将典型类定义中的私有成员替换为指向实现的指针，利用关联的优势。实现将被封装在我们目标类的嵌套类中。我们的pImpl指针将委托所有请求到提供内部类细节或实现的关联对象。
- en: The inner (nested) class will be referred to as the **implementation class**.
    The original, now outer, class will be referred to as the **target** or **interface
    class**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 内部（嵌套）类将被称为**实现类**。原始的，现在外部的，类将被称为**目标**或**接口类**。
- en: We will start by reviewing the typical (non-pImpl pattern) file composition
    containing class definitions and member function definitions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先回顾包含类定义和成员函数定义的典型（非pImpl模式）文件组成。
- en: Organizing file and class contents to apply the pattern basics
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织文件和类内容以应用模式基础
- en: Let’s first review the organization strategy of the typical C++ class with respect
    to file placement regarding the class definition and member function definitions.
    We will next consider the revised organization strategy of a class utilizing the
    pImpl pattern.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先回顾典型C++类在文件放置方面的组织策略，包括类定义和成员函数定义。接下来，我们将考虑使用pImpl模式的类的修改后的组织策略。
- en: Reviewing typical file and class layout
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回顾典型文件和类布局
- en: Let’s take a look at a typical class definition and how we previously have organized
    a class with respect to source and header files, such as in our discussions in
    [*Chapter 5*](B19087_05.xhtml#_idTextAnchor222), *Exploring Classes in Detail*,
    and in [*Chapter 15*](B19087_15.xhtml#_idTextAnchor655), *Testing Classes and
    Components*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个典型的类定义以及我们之前是如何根据源文件和头文件组织类的，例如在[*第5章*](B19087_05.xhtml#_idTextAnchor222)“详细探索类”和[*第15章*](B19087_15.xhtml#_idTextAnchor655)“测试类和组件”中的讨论。
- en: 'Recall that we organized each class into a header (`.h` or `.hpp`) file containing
    the class definition and inline function definitions, plus a corresponding source
    code (`.cpp`) file containing the non-inline member function definitions. Let’s
    review a familiar sample class definition, `Person`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们将每个类组织到一个包含类定义和内联函数定义的头文件（`.h`或`.hpp`）中，以及一个包含非内联成员函数定义的相应源代码文件（`.cpp`）。让我们回顾一个熟悉的样本类定义，`Person`：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the aforementioned header file (`Person.h`), we have included our class definition
    for `Person` as well as inline function definitions for the class. Any larger
    inline function definitions not appearing within the class definition (indicated
    with the keyword `inline` in the prototype) would also appear in this file, after
    the class definition itself. Notice the use of preprocessor directives to ensure
    that a class definition is only included once per compilation unit.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述头文件（`Person.h`）中，我们包含了`Person`类的类定义以及类的内联函数定义。任何未出现在类定义中（在原型中用关键字`inline`指示）的较大内联函数定义也将出现在此文件中，在类定义之后。注意预处理指令的使用，以确保每个编译单元只包含一次类定义。
- en: 'Let’s next review the contents of the corresponding source code file, `Person.cpp`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来回顾相应的源代码文件的内容，`Person.cpp`：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the previously defined source code file, we define all the non-inline member
    functions for the class, `Person`. Though not all methods are shown, all can be
    found in our GitHub code. Also, if the class definition contains any static data
    members, the definition of the external variables designating the memory for these
    members should be included in the source code file.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前定义的源代码文件中，我们为类`Person`定义了所有非内联成员函数。尽管不是所有方法都显示出来，但所有方法都可以在我们的GitHub代码中找到。此外，如果类定义包含任何静态数据成员，这些成员的内存指定的外部变量定义也应包含在源代码文件中。
- en: Let’s now consider how we can remove the implementation details from the `Person`
    class definition and its corresponding header file, by applying the pImpl pattern.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑如何通过应用pImpl模式，从`Person`类定义及其相应的头文件中移除实现细节。
- en: Applying the pImpl pattern with revised class and file layout
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用pImpl模式并修改类和文件布局
- en: To employ the pImpl pattern, we will reorganize our class definition and its
    respective implementation. We will add a nested class within our existing class
    definition to represent the private members of our original class and the core
    of its implementation. Our outer class will include a pointer of the inner class
    type, serving as an association to our implementation. Our outer class will delegate
    all implementation requests to the inner, associated object. We will restructure
    the placement of classes and source code within the header and source code files.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at our revised implementation for our class to understand
    each new detail required to implement the pImpl pattern. This example, composed
    of a source file `PersonImpl.cpp` and one header file `Person.h`, can be found
    in the same directory as a simple driver to test the pattern in our GitHub repository.
    To make a complete executable, you will need to compile and link together `PersonImp.cpp`
    and `Chp20-Ex1.cpp` (the driver), found in this same directory. Here is the GitHub
    repository URL for the driver:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter20/Chp20-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter20/Chp20-Ex1.cpp)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In our aforementioned revised class definition for `Person`, notice that we
    have removed the data members in the private access region. Any non-virtual private
    methods, had they existed, would have also been removed. Instead, we include a
    forward declaration to our nested class with `class PersonImpl;`. We also declare
    a pointer to the implementation using `PersonImpl *pImpl;`, which represents an
    association to the nested class members encapsulating the implementation. In our
    initial implementation, we will use a native (raw) C++ pointer to specify the
    association to the nested class. We will subsequently revise our implementation
    to utilize a *unique pointer*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Notice that our public interface for `Person` is much as before. All of our
    existing public and protected methods exist as expected, interface-wise. We notice,
    however, that the inline functions (which depend on the implementation of the
    data members) have been replaced with non-inline member function prototypes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move forward to see the class definition for our nested class, `PersonImpl`,
    as well as the placement of the member functions of `PersonImpl` and `Person`
    in a common source code file, `PersonImpl.cpp`. We will start with the nested
    `PersonImpl` class definition:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the previously mentioned nested class definition for `PersonImpl`, notice
    that this class looks surprisingly similar to the original class definition for
    `Person`. We have private data members and a full host of member function prototypes,
    even some inline functions written for brevity (which won’t actually be inlined
    because they are virtual). `PersonImpl` represents the implementation for `Person`,
    so it is crucial that this class can access all data and implement each method
    fully. Notice that the scope resolution operator (`::`) in the definition of `class
    Person::PersonImpl` is used to specify that `PersonImpl` is a nested class of
    `Person`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s continue by taking a look at the member function definitions for `PersonImpl`,
    which will appear in the same source file `PersonImpl.cpp` as the class definition.
    Though some methods have been abbreviated, their full online code is available
    in our GitHub repository:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the aforementioned code, we see the implementation for the overall `Person`
    class using the nested class `PersonImpl`. We see the member function definitions
    for `PersonImpl` and notice that the bodies of these methods are exactly how we
    previously implemented the methods in our original `Person` class without the
    pImpl pattern. Again, we notice the use of the scope resolution operator (`::`)
    to specify the class name for each member function definition, such as `void Person::PersonImpl::Print()
    const`. Here, `Person::PersonImpl` indicates the nested class of `PersonImpl`
    within the `Person` class.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s take a moment to review the member function definitions for `Person`,
    our class employing the pImpl pattern. These methods will additionally contribute
    to the `PersonImpl.cpp` source code file and can be found in our GitHub repository:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the aforementioned member function definitions for `Person`, we notice that
    all methods delegate the required work to the nested class via the associated
    `pImpl`. In our constructors, we allocate the associated `pImpl` object and initialize
    it appropriately (using the member initialization list of each constructor). Our
    destructor is responsible for deleting the associated object using `delete pImpl;`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Our `Person` copy constructor will set member `pImpl` to the newly allocated
    memory, while invoking the `PersonImpl` copy constructor for the nested object
    creation and initialization, passing `*(p.pImpl)` to the nested object’s copy
    constructor. That is, `p.pImpl` is a pointer, so we dereference the pointer using
    `*` to obtain a referenceable object for the `PersonImpl` copy constructor.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: We use a similar strategy in our overloaded assignment operator for `Person`.
    That is, there are no data members other than `pImpl` to perform a deep assignment,
    so we merely call the `PersonImpl` assignment operator on associated object `pImpl`,
    again passing in `*(p.pImpl)` as the right-hand value.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let us consider a sample driver to demonstrate our pattern in action.
    Interestingly, our driver will work with either our originally specified non-pattern
    class (source and header files) or with our revised pImpl pattern-specific source
    and header files!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们考虑一个示例驱动程序来展示我们的模式在实际应用中的效果。有趣的是，我们的驱动程序可以与最初指定的非模式类（源文件和头文件）一起工作，也可以与经过修订的pImpl模式特定源文件和头文件一起工作！
- en: Bringing the pattern components together
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将模式组件组合在一起
- en: 'Let’s finally take a look at our `main()` function in our driver source file
    `Chp20-Ex1.cpp` to see how our pattern is orchestrated:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们最后看看我们的驱动程序源文件`Chp20-Ex1.cpp`中的`main()`函数，看看我们的模式是如何编排的：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Reviewing our aforementioned `main()` function, we simply dynamically allocate
    several `Person` instances, call selected `Person` method(s) on the instances
    (`Print()`), and then delete each instance. We have included the `Person.h` header
    file, as expected, to be able to utilize this class. From the Client’s point of
    view, everything looks *as usual* and appears pattern unspecific.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们之前提到的`main()`函数，我们只是动态分配了几个`Person`实例，在实例上调用选定的`Person`方法（`Print()`），然后删除每个实例。我们如预期那样包含了`Person.h`头文件，以便能够使用这个类。从客户端的角度来看，一切看起来*都很正常*，看起来没有使用模式。
- en: Note that we separately compile `PersonImp.cpp` and `Chp20-Ex1.cpp`, linking
    the object files together into an executable. However, due to the pImpl pattern,
    if we change the implementation for `Person`, the change will be encapsulated
    by its implementation in the `PersonImp` nested class. Only `PersonImp.cpp` will
    require recompilation. The Client will not need to recompile the driver, `Chp20-Ex1.cpp`,
    because the changes will not have occurred in the `Person.h` header file (which
    the driver depends on).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们分别编译`PersonImp.cpp`和`Chp20-Ex1.cpp`，将目标文件链接在一起生成可执行文件。然而，由于使用了pImpl模式，如果我们更改`Person`的实现，这种更改将被封装在其`PersonImp`嵌套类中的实现中。只有`PersonImp.cpp`需要重新编译。客户端不需要重新编译驱动程序`Chp20-Ex1.cpp`，因为更改不会发生在`Person.h`头文件中（驱动程序依赖于该头文件）。
- en: 'Let’s take a look at the output for this program:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个程序的输出：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the aforementioned output, we see the expected results of our simple driver.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述输出中，我们看到了我们简单驱动程序的预期结果。
- en: Let’s move forward to consider how we may improve our implementation of the
    pImpl pattern using a unique pointer.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，考虑如何使用唯一指针改进我们的pImpl模式实现。
- en: Improving the pattern with a unique pointer
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用唯一指针改进模式
- en: Our initial implementation using an association with a native C++ pointer relieves
    many compiler dependencies. This is because the compiler only needs to see a forward
    class declaration of the pImpl pointer type in order to compile successfully.
    So far, we have achieved the core goal of using the pImpl pattern – reducing recompilation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初使用与原生C++指针关联的实现减少了编译器的依赖。这是因为编译器只需要看到pImpl指针类型的类前向声明就能成功编译。到目前为止，我们已经实现了使用pImpl模式的核心目标——减少重新编译。
- en: However, there is always criticism of using native or *raw* pointers. We are
    responsible for managing the memory ourselves, including remembering to delete
    the allocated nested class type in our outer class destructor. Memory leaks, memory
    misuse, and memory errors are potential drawbacks for managing memory resources
    ourselves with raw pointers. For that reason, it is customary to implement the
    pImpl pattern using **smart pointers**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用原生或*原始*指针总是存在批评。我们负责自己管理内存，包括记住在外部类析构函数中删除分配的嵌套类类型。使用原始指针自行管理内存资源可能会导致内存泄漏、内存误用和内存错误等潜在缺点。因此，通常使用**智能指针**来实现pImpl模式。
- en: We will continue our quest to implement pImpl by examining a key component often
    used with the pImpl pattern – smart pointers, or more specifically, the `unique_ptr`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续我们的任务，通过检查与pImpl模式经常一起使用的关键组件——智能指针，或者更具体地说，是`unique_ptr`——来实现pImpl。
- en: Let’s start by understanding smart pointer basics.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先理解智能指针的基本知识。
- en: Understanding smart pointers
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解智能指针
- en: To implement the pImpl pattern customarily, we must first understand smart pointers.
    A **smart pointer** is a small wrapper class that encapsulates a raw pointer,
    ensuring that the pointer it contains is automatically deleted when the wrapper
    object goes out of scope. The class implementing the smart pointer can be implemented
    using templates to create a smart pointer for any data type.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a very simple example of a smart pointer. This example can be found
    on our GitHub:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter20/Chp20-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter20/Chp20-Ex2.cpp)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the previously defined, straightforward `SmartPointer` class, we simply encapsulate
    a raw pointer. The key benefit is that the `SmartPointer` destructor will ensure
    that the raw pointer is destructed when the wrapper object is popped off the stack
    (for local instances) or before the program terminates (for static and extern
    instances). Certainly, this class is basic, and we must determine the desired
    behaviors for the copy constructor and the assignment operator. That is, allow
    shallow copies/assignment, require deep copies/assignment, or disallow all copies/assignment.
    Nonetheless, we can now visualize the concept of a smart pointer.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output for our smart pointer example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The aforementioned output shows that the memory for each object contained within
    a `SmartPointer` is managed for us. We can quite easily see with the `"SmartPtr
    Destructor"` output strings that the destructor for each object is called on our
    behalf when the local objects in `main()` go out of scope and are popped off the
    stack.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Understanding unique pointers
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `unique_ptr` in the Standard C++ Library, is a type of smart pointer that
    encapsulates exclusive ownership and access to a given heap memory resource. A
    `unique_ptr` cannot be duplicated; the owner of a `unique_ptr` will have sole
    use of that pointer. Owners of unique pointers can choose to move these pointers
    to other resources, but the repercussions are that the original resource will
    no longer contain the `unique_ptr`. We must `#include <memory>` to include the
    definition for `unique_ptr`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Additional types of smart pointers
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Other types of smart pointers are available in the Standard C++ Library, in
    addition to `unique_ptr`, such as `weak_ptr` and `shared_ptr`. These additional
    types of smart pointers will be explored in [*Chapter 21*](B19087_21.xhtml#_idTextAnchor920),
    *Making C++ Safer*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Modifying our smart pointer program to instead utilize `unique_ptr`, we now
    have the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Our output will be similar to the `SmartPointer` example; the difference is
    that no `"SmartPtr Destructor"` call message will be displayed (as we are using
    a `unique_ptr` instead). Notice that because we included `using std::unique_ptr;`,
    we did not need to qualify `unique_ptr` with `std::` in the unique pointer declaration.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, let’s add unique pointers to our pImpl pattern.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Adding unique pointers to the pattern
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To implement the pImpl pattern using a `unique_ptr`, we will make minimal changes
    to our previous implementation, starting with our `Person.h` header file. The
    full program example of our pImpl pattern utilizing a `unique_ptr` can be found
    in our GitHub repository and will additionally include a revised file for `PersonImpl.cpp`.
    Here is the URL for the driver, `Chp20-Ex3.cpp`; note the subdirectory, `unique`,
    in our GitHub repository for this complete example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter20/unique/Chp20-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter20/unique/Chp20-Ex3.cpp)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice, in the revised aforementioned class definition for `Person`, the unique
    pointer declaration of `std::unique_ptr<PersonImpl> pImpl;`. Here, we use the
    `std::` qualifier because the standard namespace has not been explicitly included
    in our header file. We also `#include <memory>` to gain the definition for `unique_ptr`.
    The remainder of the class is identical to our initial implementation of pImpl
    using an association implemented with a raw pointer.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s understand the extent to which our source code needs to be modified
    from our initial pImpl implementation. Let’s now take a look at the necessary
    modified member functions in our source file, `PersonImpl.cpp`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Taking a look at the aforementioned member functions requiring modification,
    we see that it is only the `Person` destructor! Because we are using a unique
    pointer to implement the association to the nested class implementation, we no
    longer need to manage the memory for this resource ourselves. That’s pretty nice!
    With these minor changes, our pImpl pattern now features a `unique_ptr` to designate
    the implementation of the class.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s examine some of the performance issues relating to using the pImpl
    pattern.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Understanding pImpl pattern trade-offs
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Incorporating the pImpl pattern into production code has both benefits and disadvantages.
    Let’s review each so that we can better understand the circumstances that may
    warrant deploying this pattern.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: The negligible performance issues encompass most of the disadvantages. That
    is, nearly every request made of the target (interface) class will need to be
    delegated to its nested implementation class. The only requests that can be handled
    by the outer class will be those not involving any data members; those circumstances
    will be extraordinarily rare! Another disadvantage includes slightly higher memory
    requirements of instances to accommodate the added pointer as part of the pattern
    implementation. These issues will be paramount in embedded software systems and
    those requiring peak performance, but relatively minor otherwise.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Maintenance will be a little more difficult for classes employing the pImpl
    pattern, an unfortunate disadvantage. Each target class is now paired with an
    extra (implementation) class, including a set of forwarding methods to delegate
    requests to the implementation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: A few implementation difficulties may also arise. For example, if any of the
    private members (now in the nested implementation class) need to access any of
    the protected or public methods of the outer (interface) class, we will need to
    include a backlink from the nested class to the outer class to access that member.
    Why? The `this` pointer in the inner class will be of the nested object type.
    Yet the protected and public methods in the outer object will expect a `this`
    pointer to the outer object – even if those public methods will then redelegate
    the request to call a private nested class method for help. This backlink will
    also be required to call public virtual functions of the interface from the scope
    of the inner class (implementation). Keep in mind, however, that we impact performance
    with another added pointer per object and with delegation to call each method
    in the associated object.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: There are several advantages of utilizing the pImpl pattern, offering important
    considerations. Of most importance, recompile time during the development and
    maintenance of code decreases significantly. Additionally, the compiled, binary
    interface of a class becomes independent of the underlying implementation of the
    class. Changing the implementation of a class only requires the nested implementation
    class to be recompiled and linked in. Users of the outer class are unaffected.
    As a bonus, the pImpl pattern provides a way to hide the underlying private details
    of a class, which may be useful when distributing class libraries or other proprietary
    code.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: An advantage of including a `unique_ptr` in our pImpl implementation is that
    we have guaranteed proper destruction of the associated implementation class.
    We also have the potential to save inadvertent programmer-introduced pointer and
    memory mishaps!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: The use of the pImpl pattern is a trade-off. Careful analysis of each class
    and of the application at hand will help determine whether the pImpl pattern is
    appropriate for your design.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen implementations of the pImpl pattern initially using a raw
    pointer, and then applying a `unique_ptr`. Let us now briefly recap what we have
    learned relating to patterns before moving to the bonus chapter of our book, [*Chapter
    21*](B19087_21.xhtml#_idTextAnchor920), *Making C++ Safer*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have advanced our objective of becoming more indispensable
    C++ programmers by furthering our programming skills with another core design
    pattern. We have explored the pImpl pattern with an initial implementation using
    native C++ pointers and association and then improved our implementation by using
    a unique pointer. By examining the implementation, we easily understand how the
    pImpl pattern reduces compile-time dependencies and can make our code more implementation-dependent.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Making use of core design patterns, such as the pImpl pattern, will help you
    more easily contribute to reusable, maintainable code that is understood by other
    programmers familiar with common design patterns. Your software solutions will
    be based on creative and well-tested design solutions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: We have now completed our final design pattern together, wrapping up a long
    journey of understanding OOP in C++. You now have a multitude of skills, including
    a deep understanding of OOP, extended language features, and core design patterns,
    all of which make you a more valuable programmer.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Though C++ is an intricate language with additional features, supplemental techniques,
    and additional design patterns to discover, you have more than a solid basis and
    level of expertise to easily navigate and embrace any additional language features,
    libraries, and patterns you may wish to acquire. You’ve come a long way; this
    has been an adventurous journey together! I have enjoyed every minute of our quest
    and I hope you have as well.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: We began by reviewing basic language syntax and understanding the C++ essentials
    necessary to serve as building blocks for our then-upcoming OOP journey. We then
    embraced C++ as an OOP language, learning not only essential OO concepts but also
    how to implement them with either C++ language features, coding techniques, or
    both. We then extended your skills by adding knowledge of exception handling,
    friends, operator overloading, templates, STL basics, and testing OO classes and
    components. We then ventured into sophisticated programming techniques by embracing
    core design patterns and delving into code by applying each pattern of interest.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Each of these acquired skill segments represents a new tier of C++ knowledge
    and mastery. Each will help you to create more easily maintainable and robust
    code. Your future as a well-versed, skilled OO programmer in C++ awaits. Now,
    let’s move on to our bonus chapter, and then, let’s get programming!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modify the pImpl pattern example in this chapter, which uses a unique pointer
    to additionally introduce unique pointers within the implementation of the nested
    class.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Revise your `Student` class from a previous chapter solution to simply inherit
    from the `Person` class in this chapter that embraces the pImpl pattern. What
    difficulties, if any, do you have? Now, modify your `Student` class to additionally
    utilize the pImpl pattern with a unique pointer. A suggested `Student` class is
    one that includes an association with a `Course`. Now, what difficulties, if any,
    do you have?
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What other examples can you imagine that might reasonably incorporate the pImpl
    pattern for relative implementation independence?
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Part 5: Considerations for Safer Programming in C++'
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this part is to understand what can be done as a programmer to make
    C++ a safer language, which in turn will help make our programs more robust. At
    this point, we will have learned a lot about C++, from language essentials to
    implementing OO designs in C++. We will have added additional skills to our repertoire,
    such as using friends and operator overloading, exception handling, templates,
    and the STL. We will have even looked in depth at a handful of popular design
    patterns. We will know that we can do nearly anything in C++, but we will have
    also seen that having so much power can leave room for cavalier programming and
    grave errors, which can lead to unwieldy code that is difficult to maintain.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will review what we have learned throughout the book with
    a keen eye toward understanding how we can work to make our code bulletproof.
    We will work toward a set of core programming guidelines to follow with one goal
    in mind: to make our programs safe!'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'We will revisit and expand upon our knowledge of smart pointers (unique, shared,
    and weak) as well as introduce a complimentary idiom, RAII. We will review what
    we have seen along the way relating to safety issues with native C++ pointers
    and sum up our safety concerns with a programming guideline: always prefer smart
    pointers in newly created C++ code.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: We will review modern programming features, such as range-based `for` loops
    and for-each style loops to understand how these simple constructs can help us
    avoid common errors. We will revisit `auto` instead of explicit typing to add
    safety to our code. We will revisit using well-tested STL types to ensure our
    code is not error-prone with ad hoc containers. We will revisit how the `const`
    qualifier can add safety to our code in a variety of ways. By reviewing specific
    language features used throughout the book, we will revisit how each of these
    features can add safety to our code. We will also consider thread safety and how
    various topics we have seen throughout the book relate to thread safety.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will discuss core programming guidelines, such as preferring initialization
    over assignment, or using one of `virtual`, `override`, or `final` to specify
    polymorphic operations and their methods. We will understand the importance of
    adopting a programming guideline and see the resources available to support programming
    safely in C++.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'This part comprises the following chapter:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 21*](B19087_21.xhtml#_idTextAnchor920), *Making C++ Safer*'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第21章*](B19087_21.xhtml#_idTextAnchor920)，*使C++更安全*'
- en: 'Part 5: Considerations for Safer Programming in C++'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 第5部分：C++更安全编程的考虑因素
