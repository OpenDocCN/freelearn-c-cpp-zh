- en: '*Chapter 20*: Game Objects and Components'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第20章*：游戏对象和组件'
- en: In this chapter, we will be doing all the coding related to the Entity-Component
    pattern we discussed at the beginning of the previous chapter. This means we will
    code the base `Component` class, which all the other components will be derived
    from. We will also put our new knowledge of smart pointers to good use so that
    we don't have to concern ourselves with keeping track of the memory we allocate
    for these components. We will also code the `GameObject` class in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将编写与上一章开头讨论的实体-组件模式相关的所有编码。这意味着我们将编写基础`Component`类，其他所有组件都将从这个类派生。我们还将充分利用我们对智能指针的新知识，以便我们不必担心跟踪为这些组件分配的内存。我们还将在本章中编写`GameObject`类。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Preparing to code the components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备编写组件
- en: Coding the Component base class
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写组件基类
- en: Coding the collider components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写碰撞器组件
- en: Coding the graphics components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写图形组件
- en: Coding the update components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写更新组件
- en: Coding the GameObject class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写游戏对象类
- en: Let's discuss the components a bit more before we start coding. Please note
    that, in this chapter, I will try and reinforce how the Entity-Component system
    fits together and how all the components compose a game object. I will not be
    explaining each and every line or even block of logic or SFML-related code that
    we have seen many times already. It is up to you to study these details.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码之前，让我们更详细地讨论一下组件。请注意，在本章中，我将尝试加强实体-组件系统如何结合在一起，以及所有组件如何组成一个游戏对象。我不会解释每一行或甚至每一个逻辑块或已经多次见过的SFML相关代码。这些细节需要你自己去研究。
- en: Preparing to code the components
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备编写组件
- en: As you work through this chapter, there will be lots of errors, and some of
    them won't seem logical. For example, you will get errors saying that a class
    doesn't exist when it is one of the classes you have already coded. The reason
    for this is that, when a class has an error in it, other classes can't reliably
    use it without getting errors as well. It is because of the interconnected nature
    of all the classes that we will not get rid of all the errors and have executable
    code again until near the end of the next chapter. It would have been possible
    to add code in smaller chunks to the various classes and the project would have
    been error-free more frequently. Doing things that gradually, however, would have
    meant constantly dipping in and out of classes. When you are building your own
    projects, this is sometimes a good way to do it, but I thought the most instructive
    thing to do for this project would be to help you get it built as quickly as possible.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在你完成本章的过程中，会有很多错误，其中一些可能看起来没有逻辑。例如，你可能会得到错误信息，说某个类不存在，而实际上它正是你已经编写的类之一。原因在于，当一个类中存在错误时，其他类无法可靠地使用它，否则也会出现错误。正因所有类之间相互关联的特性，我们直到下一章的结尾才能消除所有错误，再次获得可执行的代码。本可以分小块向各个类和项目添加代码，这样项目出现错误的频率会更高。然而，逐步进行意味着需要不断在各个类之间切换。当你构建自己的项目时，这有时是一种好的做法，但我认为对于这个项目来说，最有教育意义的事情是帮助你尽可能快地构建它。
- en: Coding the Component base class
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写组件基类
- en: 'Create a new header file in the `Header Files/GameObjects` filter called `Component.h`
    and add the following code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Header Files/GameObjects`过滤器中创建一个新的头文件，命名为`Component.h`，并添加以下代码：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is the base class of every component in every game object. The pure virtual
    functions mean that a component can never be instantiated and must always be inherited
    from first. Functions allow the type and specific type of a component to be accessed.
    Component types include collider, graphics, transform, and update, but more types
    could be added in line with the requirements of the game. Specific types include
    standard graphics, invader update, player update, and more besides.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是每个游戏对象中每个组件的基类。纯虚函数意味着组件不能被实例化，必须首先继承。函数允许访问组件的类型和特定类型。组件类型包括碰撞器、图形、变换和更新，但根据游戏需求还可以添加更多类型。具体类型包括标准图形、入侵者更新、玩家更新等。
- en: There are two functions that allow the component to be enabled and disabled.
    This is useful because a component can then be tested for whether it is currently
    enabled before it is used. For example, you could call the `enabled` function
    to test whether a component's update component was enabled before calling its
    `update` function or that a graphics component is enabled before calling its `draw`
    function.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The `start` function is probably the most interesting function because it has
    a new class type as one of its parameters. The `GameObjectSharer` class will give
    access to all the game objects after they have been instantiated with all their
    components. This will give every component in every game object the opportunity
    to query details and even obtain a pointer to a specific piece of data in another
    game object. As an example, all an invader's update components will need to know
    the location of the player's transform component so that it knows when to fire
    a bullet. Absolutely any part of any object can be accessed in the `start` function.
    The point is that each specific component will decide what they need and there
    is no requirement during the critical game loop to start querying for the details
    of another game object.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: The `GameObject` that the component is contained in is also passed to the `start`
    function so that any component can find out more about itself as well. For example,
    a graphics component needs to know about the transform component so that it knows
    where to draw itself. As a second example, the update components of the invaders
    and the player's ship will need a pointer to their own collider component so that
    they can update its location whenever they move.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: We will see more use cases for the `start` function as we progress.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new source file in the `Source Files/GameObjects` filter called `Component.cpp`
    and add the following code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As the `Component` class can never be instantiated, I have put the preceding
    comments in `Component.cpp` as a reminder.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Coding the collider components
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Space Invaders ++ game will only have one simple type of collider. It will
    be a rectangular box around the object, just like those we had in the Zombie Apocalypse
    and Pong games. However, it is easily conceivable that you might need other types
    of collider; perhaps a circle-shaped collider or a non-encompassing collider such
    as those we used for the head, feet, and sides of Thomas and Bob back in the Thomas
    Was Late game.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, there will be a base `ColliderComponent` class (that inherits
    from `Component`) which will handle the basic functionality of all the colliders,
    as well as `RectColliderComponent`, which will add the specific functionality
    of an all-encompassing rectangle-shaped collider. New collider types can then
    be added as required for the game being developed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: What follows is the base class to the specific collider, `ColliderComponent`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Coding the ColliderComponent class
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new header file in the `Header Files/GameObjects` filter called `ColliderComponent.h`
    and add the following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `ColliderComponent` class inherits from the `Component` class. In the preceding
    code, you can see that the `m_Type` member variable is initialized to `"collider"`
    and that `m_Enabled` is initialized to `false`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: In the `public` section, the code overrides the pure virtual functions of the
    `Component` class. Study them to become familiar with them because they work in
    a very similar way in all the component classes. The `getType` function returns
    `m_Type`. The `disableComponent` function sets `m_Enabled` to `false`. The `enableComponent`
    function sets `m_Enabled` to `true`. The `enabled` function returns the value
    of `m_Enabled`. The `start` function has no code but will be overridden by many
    of the more specific component-based classes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new source file in the `Source Files/GameObjects` filter called `ColliderComponent.cpp`
    and add the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I added the preceding comments to `ColliderComponent.cpp` to remind myself that
    all the functionality is in the header file.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Coding the RectColliderComponent class
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new header file in the `Header Files/GameObjects` filter called `RectColliderComponent.h`
    and add the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `RectColliderComponent` class inherits from the `ColliderComponent` class.
    It has a `m_SpecificType` variable initialized to `"rect"`. It is now possible
    to query any `RectColliderComponent` instance in a vector of generic `Component`
    instances and determine that it has a type of  `"collider"` and a specific type
    of  `"rect"`. All component-based classes will have this functionality because
    of the pure virtual functions of the `Component` class.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: There is also a `FloatRect` instance called `m_Collider` that will store the
    coordinates of this collider.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: In the `public` section, we can view the constructor. Notice that it receives
    a `string`. The value that's passed in will be text that identifies the type of
    game object this `RectColliderComponent` is attached to, such as an invader, a
    bullet, or the player's ship. It will then be possible to determine what type
    of objects have collided with each other.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: There are three more functions before the overridden functions; make a note
    of their names and parameters and then we will discuss them in a moment when we
    code their definitions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `getSpecificType` function definition returns `m_SpecificType`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new source file in the `Source Files/GameObjects` filter called `RectColliderComponent.cpp`
    and add the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the constructor, the passed-in `string` value is assigned to the `m_Tag`
    variable and the `getColliderTag` function makes that value available via the
    instance of the class.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: The `setOrMoveCollider` function positions `m_Collider` at the coordinates passed
    in as arguments.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: The `getColliderRectF` function returns a reference to `m_Collider`. This is
    ideal for carrying out a collision test with another collider using the `intersects`
    function of the `FloatRect` class.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Our colliders are now complete and we can move on to the graphics.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Coding the graphics components
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Space Invaders ++ game will only have one specific type of graphics component.
    It is called `StandardGraphicsComponent`. As with the collider components, we
    will implement a base `GraphicsComponent` class to make it easy to add other graphics-related
    components, should we wish. For example, in the classic arcade version of Space
    Invaders, the invaders flapped their arms up and down with two frames of animation.
    Once you see how `StandardGraphicsComponent` works, you will be able to easily
    code another class (perhaps `AnimatedGraphicsComponent`) that draws itself with
    a different `Sprite` instance every half a second or so. You could also have a
    graphics component that has a shader (perhaps `ShaderGraphicsComponent`) for fast
    and cool effects. There are more possibilities besides these.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Coding the GraphicsComponent class
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new header file in the `Header Files/GameObjects` filter called `GraphicsComponent.h`
    and add the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Most of the preceding code implements the `Component` class's pure virtual functions.
    What's new to the `GraphicsComponent` class is the `draw` function, which has
    two parameters. The first parameter is a reference to the `RenderWindow` instance
    so that the component can draw itself, while the second is a shared smart pointer
    to the `TransformComponent` instance of the `GameObject` so that vital data such
    as position and scale can be accessed each frame of the game.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: What's also new in the `GraphicsComponent` class is the `initializeGraphics`
    function, which also has two parameters. The first is a `string` value that represents
    the file name of the graphics file to be used, while the second is a `Vector2f`
    instance that will represent the size of the object in the game world.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Both preceding functions are pure virtual, which makes the `GraphicsComponent`
    class abstract. Any class that inherits from `GraphicsComponent` will need to
    implement these functions. In the next section, we will see how `StandardGraphicsComponent`
    does so.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new source file in the `Source Files/GameObjects` filter called `GraphicsComponent.cpp`
    and add the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding comment is a reminder that the code is all within the related
    header file.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Coding the StandardGraphicsComponent class
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new header file in the `Header Files/GameObjects` filter called `StandardGraphicsComponent.h`
    and add the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `StandardGraphicsComponent` class has a `Sprite` member. It doesn't need
    a `Texture` instance because that will be obtained each frame from the `BitmapStore`
    class. This class also overrides the required functions from both the `Component`
    and `GraphicsComponent` classes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Let's code the implementation of the two pure virtual functions, `draw` and
    `initializeGraphics`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编码两个纯虚函数`draw`和`initializeGraphics`的实现。
- en: 'Create a new source file in the `Source Files/GameObjects` filter called `StandardGraphicsComponent.cpp`
    and add the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Source Files/GameObjects`筛选器中创建一个新的源文件，命名为`StandardGraphicsComponent.cpp`，并添加以下代码：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the `initializeGraphics` function, the `addBitmap` function of the `BitmapStore`
    class is called and the file path of the image, along with the size of the object
    in the game world, is passed in.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在`initializeGraphics`函数中，调用了`BitmapStore`类的`addBitmap`函数，并将图像的文件路径以及游戏世界中对象的尺寸传递进去。
- en: Next, the `Texture` instance that was just added to the `BitmapStore` class
    is retrieved and set as the image for the `Sprite`. Following on, two functions,
    `getTexture` and `getSize`, are chained together to get the size of the texture.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，检索刚刚添加到`BitmapStore`类的`Texture`实例，并将其设置为`Sprite`的图像。随后，将`getTexture`和`getSize`两个函数串联起来以获取纹理的尺寸。
- en: The next line of code uses the `setScale` function to make the `Sprite` the
    same size as the texture, which in turn was set to the size of this object in
    the game world.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条代码使用`setScale`函数使`Sprite`与纹理大小相同，而纹理的大小被设置为游戏世界中此对象的尺寸。
- en: The `setColor` function then applies a green tint to the `Sprite`. This gives
    it a bit more of a retro feel.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`setColor`函数为`Sprite`应用绿色色调。这给它增添了一丝复古的感觉。
- en: In the `draw` function, the `Sprite` is moved into position using `setPosition`
    and the `getLocation` function of `TransformComponent`. We'll code the `TransformComponent`
    class next.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在`draw`函数中，使用`setPosition`和`TransformComponent`的`getLocation`函数将`Sprite`移动到指定位置。接下来，我们将编码`TransformComponent`类。
- en: The final line of code draws the `Sprite` to `RenderWindow`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行代码将`Sprite`绘制到`RenderWindow`。
- en: Coding the TransformComponent class
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码TransformComponent类
- en: 'Create a new header file in the `Header Files/GameObjects` filter called `TransformComponent.h`
    and add the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Header Files/GameObjects`筛选器中创建一个新的头文件，命名为`TransformComponent.h`，并添加以下代码：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This class has a `Vector2f` to store the position of the object in the game
    world, a `float` to store the height, and another `float` to store the width.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此类有一个`Vector2f`用于存储游戏世界中对象的定位，一个`float`用于存储高度，另一个`float`用于存储宽度。
- en: In the `public` section, there is a constructor we will use to set up the instances
    of this class, as well as two functions, `getLocation` and `getSize`, we'll use
    to share the location and size of the object. We  used these functions already
    when we coded the `StandardGraphicsComponent` class.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在`public`部分，有一个构造函数，我们将使用它来设置此类实例，以及两个函数`getLocation`和`getSize`，我们将使用它们来共享对象的定位和尺寸。我们在编码`StandardGraphicsComponent`类时已经使用了这些函数。
- en: The remaining code in the `TransformComponent.h` file is the implementation
    of the `Component` class.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransformComponent.h`文件中的剩余代码是`Component`类的实现。'
- en: 'Create a new source file in the `Source Files/GameObjects` filter called `TransformComponent.cpp`
    and add the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Source Files/GameObjects`筛选器中创建一个新的源文件，命名为`TransformComponent.cpp`，并添加以下代码：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Implementing the three functions of this class is straightforward. The constructor
    receives a size and location and initializes the appropriate member variables.
    The `getLocation` and `getSize` functions return this data when it is requested.
    Notice that the values are returned by reference, so they will be modifiable by
    the calling code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此类中的三个函数很简单。构造函数接收一个尺寸和一个位置，并初始化相应的成员变量。当请求时，`getLocation`和`getSize`函数返回这些数据。请注意，值是通过引用返回的，因此它们可以被调用代码修改。
- en: Next, we will code all update-related components.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编码所有与更新相关的组件。
- en: Coding update components
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码更新组件
- en: As you might expect by now, we will code an `UpdateComponent` class that will
    inherit from the `Component` class. It will have all the functionality that every
    `UpdateComponent` will need and then we will code classes derived from `UpdateComponent`.
    These will contain functionality specific to individual objects in the game. For
    this game, we will have `BulletUpdateComponent`, `InvaderUpdateComponent`, and
    `PlayerUpdateComponent`. When you work on your own project and you want an object
    in the game that behaves in a specific unique manner, just code a new update-based
    component for it and you'll be good-to-go. Update-based components define behavior.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Coding the UpdateComponent class
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new header file in the `Header Files/GameObjects` filter called `UpdateComponent.h`
    and add the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`UpdateComponent` only brings one piece of functionality: the `update` function.
    This function is pure virtual so it must be implemented by any class that aspires
    to be a usable instance of `UpdateComponent`.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new source file in the `Source Files/GameObjects` filter called `UpdateComponent.cpp`
    and add the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is a helpful comment to remind us that this class has all its code in the
    related header file.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Coding the BulletUpdateComponent class
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new header file in the `Header Files/GameObjects` filter called `BulletUpdateComponent.h`
    and add the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you want to understand the behavior/logic of a bullet, you will need to spend
    some time learning the names and types of the member variables as I won't be explaining
    precisely how a bullet behaves; we have covered these topics many times. I will,
    however, point out that there are variables to cover basics such as movement,
    variables to help randomize the speed of each bullet within a certain range, and
    Booleans that identify whether the bullet belongs to the player or an invader.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: The key thing which you don't yet know but will have to learn here is that each
    `BulletUpdateComponent` instance will hold a shared pointer to the owning game
    object's `TransformComponent` instance and a shared pointer to the owning game
    object's `RectColliderComponent` instance.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Now, look closely at the overridden `start` function. In the `start` function,
    the aforementioned shared pointers are initialized. The code achieves this by
    using the `getComponentByTypeAndSpecificType` function of the owning game object
    (`self`), which is a pointer to the owning game object. We will code the `GameObject`
    class, including this function, in a later section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new source file in the `Source Files/GameObjects` filter called `BulletUpdate.cpp`
    and add the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first two functions are unique to the `BulletUpdateComponent` class; they
    are `spawnForPlayer` and `spawnForInvader`. Both of these functions prepare the
    member variables, transform component and collider component for action. Each
    one does so in a slightly different way. For example, for a player-owned bullet,
    it is prepared to move up the screen from the top of the player's ship, while
    a bullet is prepared for an invader to move down the screen from the underside
    of an invader. The key thing to notice is that all this is achievable via the
    shared pointers to the transform component and the collider component. Also, note
    that the `m_IsSpawned` Boolean is set to true, making this update component's
    `update` function ready to call each frame of the game.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: In the `update` function, the bullet is moved up or down the screen at the appropriate
    speed. It is tested to see if it has disappeared off the top or bottom of the
    screen, and the collider is updated to wrap around the current location so that
    we can test for collisions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: This is the same logic we have seen throughout this book; what's new is the
    shared pointers we are using to communicate with the other components that make
    up this game object.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: The bullets just need to be spawned and tested for collisions; we will see how
    to do that in the next two chapters. Now, we will code the behavior of the invaders.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Coding the InvaderUpdateComponent class
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new header file in the `Header Files/GameObjects` filter called `InvaderUpdateComponent.h`
    and add the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the class declaration, we can see all the features that we need in order
    to code the behavior of an invader. There is a pointer to the transform component
    so that the invader can move, as well as a pointer to the collider component so
    that it can update its location and be collided with:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There are pointers to the player''s transform and collider so that an invader
    can query the position of the player and make decisions about when to shoot bullets:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next, there is a `BulletSpawner` instance, which we will code in the next chapter.
    The `BulletSpawner` class will allow an invader or the player to spawn a bullet.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'What follows is a whole bunch of variables that we will use to control the
    speed, direction, rate of fire, the precision with which the invader aims, and
    the speed of bullets that are fired. Familiarize yourself with them as they will
    be used in fairly in-depth logic in the function definitions:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we can see three new public functions that different parts of the system
    can call to make the invaders move down a little and head in the other direction,
    test the direction of travel, and pass in a pointer to the aforementioned `BulletSpawner`
    class, respectively:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Be sure to study the `start` function where the smart pointers to the invader
    and the player are initialized. Now, we will code the function definitions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new source file in the `Source Files/GameObjects` filter called `InvaderUpdate.cpp`
    and add the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That was a lot of code. Actually, there's no C++ code in there that we haven't
    seen before. It is all just logic to control the behavior of an invader. Let's
    get an overview of what it all does, with parts of the code reprinted for convenience.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the update function
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first `if` and `else` blocks move the invader right or left each frame,
    as appropriate:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, the collider is updated to the new position:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This code tracks how long it''s been since this invader last fired a shot and
    then tests to see if the player is one world unit to the left or right of the
    invader (+ or – for the random accuracy modifier, so that each invader is a little
    bit different):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Inside the preceding `if` test, another test makes sure that the invader has
    waited long enough since the last shot it took. If it has, then a shot is taken.
    A sound is played, a spawn location for the bullet is calculated, the `spawnBullet`
    function of the `BulletSpawner` instance is called, and a new random time to wait
    before another shot can be taken is calculated:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The details of the `BulletSpawner` class will be revealed in the next chapter,
    but as a glimpse into the future, it will be an abstract class with one function
    called `spawnBullet` and will be inherited from by the `GameScreen` class.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the dropDownAndReverse function
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the `dropDownAndReverse` function, the direction is reversed and the vertical
    location is increased by the height of an invader. In addition, the speed of the
    invader is increased relative to how many waves the player has cleared and how
    many invaders remain to be destroyed. The more waves that are cleared and the
    fewer invaders remaining, the faster the invaders will move:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The next function is simple but included for the sake of completeness.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the isMovingRight function
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This code simply provides access to the current direction of travel:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It will be used to test whether to look out for collisions with the left of
    the screen (when moving left) or the right of the screen (when moving right) and
    will allow the collision to trigger a call to the `dropDownAndReverse` function.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the initializeBulletSpawner function
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I have already mentioned that the `BulletSpawner` class is abstract and will
    be implemented by the `GameScreen` class. When the `GameScreen` class'' `initialize`
    function is called, this `initializeBulletSpawner` function will be called on
    each of the invaders. As you can see, the first parameter is a pointer to a `BulletSpawner`
    instance. This gives every `InvaderUpdateComponent` the ability to call the `spawnBullet`
    function:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The rest of the code in the `initializeBulletSpawner` function sets up the random
    values that make each invader behave slightly differently from the others.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Coding the PlayerUpdateComponent class
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new header file in the `Header Files/GameObjects` filter called `PlayerUpdateComponent.h`
    and add the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the `PlayerUpdateComponent` class, we have all the Boolean variables needed
    to keep track of whether the player is holding down a keyboard key, as well as
    functions that can toggle these Boolean values. We haven't seen anything like
    the `m_XExtent` and `M_YExtent float` type variables before and we will explain
    them when we look at their usage in the function definitions.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Note, just like the `BulletUpdateComponent` and the `InvaderUpdateComponent`
    classes, that we have shared pointers to this game object's transform and collider
    components. These shared pointers, as we are coming to expect, are initialized
    in the `start` function.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new source file in the `Source Files/GameObjects` filter called `PlayerUpdate.cpp`
    and add the following code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the first `if` block of the update function, the condition is `sf::Joystick::isConnected(0)`.
    This condition returns true when the player has a gamepad plugged in to a USB
    port. Inside the `if` block, the location of both the horizontal and vertical
    positions of the transform component are altered:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding code divides the target speed by 100 before multiplying it by
    `m_YExtent`. `The m_XExtent` and `m_YExtent` variables will be updated each frame
    to hold values that represent the extent to which the player has moved their gamepad
    thumbstick in a horizontal and vertical direction. The range of values is from
    -100 to 100, and so the preceding code has the effect of moving the transform
    component at full speed in any direction when the thumbstick is positioned at
    any of its full extents or a fraction of that speed when it is partially positioned
    between the center (not moving at all) and its full extent. This means that the
    player will have finer control over the speed of the ship should they opt to use
    a gamepad instead of the keyboard.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: We will see more details about the operation of the gamepad in [*Chapter 22*](B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445),
    *Using Game Objects and Building a Game*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the `update` function responds to the Boolean variables, which represent
    the keyboard keys that the player is holding down or has released.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: After the gamepad and keyboard handling, the collider component is moved into
    the new position and a series of `if` blocks ensures the player ship can't move
    outside of the screen or above the half-way-up point on the screen.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: The next function is the `updateShipTravelWithController` function; when a controller
    is plugged in, it will update the extent to which the thumbstick is moved or at
    rest for each frame.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: The remaining functions update the Boolean values that indicate whether keyboard
    keys are being used to move the ship. Notice that the update component does not
    handle firing a bullet. We could have handled it from here, and some games might
    have a good reason to do so. In this game, it was slightly more direct to handle
    shooting a bullet from the `GameInputHandler` class. The `GameInputHandler` class,
    as we will see in [*Chapter 22*](B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445),
    *Using Game Objects and Building a Game*, will call all the functions that let
    the `PlayerUpdateComponent` class know what is happening with the gamepad and
    keyboard. We coded the basics of keyboard responses in the `GameInputHandler`
    class in the previous chapter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's code the `GameObject` class, which will hold all the various component
    instances.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Coding the GameObject class
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I am going to go through the code in this class in quite a lot of detail because
    it is key to how all the other classes work. I think you will benefit, however,
    from seeing the code in its entirety and studying it first. With this in mind,
    create a new header file in the `Header Files/GameObjects` filter called `GameObject.h`
    and add the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code, be sure to closely examine the variables, types, function
    names, and their parameters.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new source file in the `Source Files/GameObjects` filter called `GameObject.cpp`
    and then study and add the following code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Tip
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to study the preceding code before moving on. The explanations that
    follow assume that you have a basic awareness of variable names and types, as
    well as function names, parameters, and return types.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the GameObject class
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's go through the `GameObject` class one function at a time and reprint the
    code to make it easy to discuss.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the update function
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `update` function is called once for each frame of the game loop for each
    game object. Like most of our other projects, the current frame rate is required.
    Inside the `update` function, a test is done to see if this `GameObject` instance
    is active and has an update component. A game object does not have to have an
    update component, although it is true that all the game objects in this project
    do.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `update` function loops through all the components it has, starting
    from `m_FirstUpdateComponent` through to `m_FirstUpdateComponent + m_NumberUpdateComponents`.
    This code implies that a game object can have multiple update components. This
    is so that you can design game objects with layers of behavior. This layering
    of behavior is discussed further in [*Chapter 22*](B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445),
    *Using Game Objects and Building a Game*. All the game objects in this project
    have just one update component, so you could simplify (and speed up) the logic
    in the `update` function, but I suggest leaving it as it is until you have read
    [*Chapter 22*](B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445), *Using Game Objects
    and Building a Game*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'It is because a component could be one of many types that we create a temporary
    update-related component (`tempUpdate`), cast the component from the vector of
    components to `UpdateComponent`, and call the `update` function. It doesn''t matter
    about the specific derivation of the `UpdateComponent` class; it will have the
    `update` function implemented, so the `UpdateComponent` type is specific enough:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When we get to the `addComponent` function in a later section, we will see how
    we can initialize the various control variables, such as `m_FirstUpdateComponentLocation`
    and `m_NumberOfUpdateComponents`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the draw function
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `draw` function checks whether the game object is active and that it has
    a graphics component. If it does, then a check is done to see if the graphics
    component is enabled. If all these tests succeed, then the `draw` function is
    called:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The structure of the `draw` function implies that not every game object has
    to draw itself. I mentioned in [*Chapter 19*](B14278_19_Final_AG_ePub.xhtml#_idTextAnchor372),
    *Game Programming Design Patterns – Starting the Space Invaders ++ Game*, that
    you might want game objects that can never be seen to act as invisible trigger
    regions (with no graphics component) that respond when the player passes over
    them or game objects that remain invisible temporarily (temporarily disabled but
    with a graphics component). In this project, all game objects have a permanently
    enabled graphics component.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the getGraphicsComponent function
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This function returns a shared pointer to the graphics component:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `getGraphicsComponent` function gives any code that has an instance of the
    contained game object access to the graphics component.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the getTransformComponent function
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This function returns a shared pointer to the transform component:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `getTransformComponent` function gives any code that has an instance of
    the contained game object access to the transform component.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the addComponent function
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `addComponent` function will be used by a factory pattern class we will
    code in the next chapter. The function receives a shared pointer to a `Component`
    instance. The first thing that happens inside the function is that the `Component`
    instance is added to the `m_Components` vector. Next, the component is enabled
    using the `enabled` function.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: What follows is a series of `if` and `else if` statements that deal with each
    possible type of component. When the type of a component is identified, the various
    control variables are initialized to enable the logic in the rest of the class
    to work correctly.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: For example, if an update component is detected, then the `m_HasUpdateComponent`,
    `m_NumberUpdateComponents`, and `m_FirstUpdateComponentLocation` variables are
    initialized.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'As another example, if a collider component is detected along with the `rect`
    specific type, then the `m_HasCollider`, `m_NumberRectColliderComponents`, and
    `m_FirstRectColliderComponent` variables are initialized:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that the `GameObject` class plays no part in configuring or setting up
    the actual components themselves. It is all handled in the factory pattern class
    we will code in the next chapter.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the getter and setter functions
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code is a series of very simple getters and setters:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding getters and setters provide information about a game object, such
    as whether it is active and what its tag is. They also allow you to set the tag
    and tell us whether or not the game object is active.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the start function
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `start` function is an important one. As we saw when we coded all the components,
    the `start` function gives access to any component in any game object the components
    of any other game object. The `start` function is called once all the `GameObject`
    instances have been composed from all their components. In the next chapter, we
    will see how this happens, as well as when the `start` function is called on every
    `GameObject` instance. As we can see, in the `start` function, it loops through
    every component and shares a new class instance, a `GameObjectSharer` instance.
    This `GameObjectSharer` class will be coded in the next chapter and will give
    access to any component from any class. We saw how the invaders need to know where
    the player is and how the `GameObjectSharer` parameter is used when we coded the
    various components. When `start` is called on each component, the `this` pointer
    is also passed in to give each component easy access to its contained `GameObject`
    instance:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Let's move on to the `getComponentByTypeAndSpecificType` function.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the getComponentByTypeAndSpecificType function
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `getComponentByTypeAndSpecificType` function has a nested `for` loop that
    looks for a match of a component type to the first `string` parameter and then
    looks for a match of the specific component type in the second `string` parameter.
    It returns a shared pointer to a base class `Component` instance. This implies
    that the calling code needs to know exactly what derived `Component` type is being
    returned so that it can cast it to the required type. This shouldn''t be a problem
    because, of course, they are requesting both a type and a specific type:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`getComponentByTypeAndSpecificType` 函数有一个嵌套的 `for` 循环，用于查找与第一个 `string` 参数匹配的组件类型，然后查找第二个
    `string` 参数中特定组件类型的匹配项。它返回一个指向基类 `Component` 实例的共享指针。这意味着调用代码需要确切知道返回的是哪种派生 `Component`
    类型，以便将其转换为所需类型。这不应该是一个问题，因为他们当然请求了类型和特定类型：'
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The code in this function is quite slow and is therefore intended for use outside
    of the main game loop. At the end of this function, the code writes an error message
    to the console if `debuggingErrors` has been defined. The reason for this is because,
    if execution reaches this point, it means that no matching component was found,
    and the game will crash. The output to the console should make the error easy
    to find. The cause of the crash would be that the function was called for an invalid
    type or specific type.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数中的代码相当慢，因此它打算在主游戏循环之外使用。在函数的末尾，如果已经定义了 `debuggingErrors`，代码将向控制台写入错误信息。这是因为，如果执行到达这个点，意味着没有找到匹配的组件，游戏将会崩溃。控制台输出的信息应该使得错误易于查找。崩溃的原因可能是函数被调用时使用了无效的类型或特定类型。
- en: Explaining the getEncompassingRectCollider function
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释 `getEncompassingRectCollider` 函数
- en: 'The `getEncompassingRectCollider` function checks whether the game object has
    a collider and, if it has, returns it to the calling code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`getEncompassingRectCollider` 函数检查游戏对象是否有碰撞体，如果有，则将其返回给调用代码：'
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: It is worth noting that, if you extend this project to handle more than one
    type of collider, then this code would need adapting too.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，如果你将此项目扩展以处理多种类型的碰撞体，那么这段代码也需要进行修改。
- en: Explaining the getEncompassingRectColliderTag function
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释 `getEncompassingRectColliderTag` 函数
- en: 'This simple function returns the tag of the collider. This will be useful for
    determining what type of object is being tested for collision:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的函数返回碰撞体的标签。这将有助于确定正在测试碰撞的对象类型：
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We have just a few more functions to discuss.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有几个函数需要讨论。
- en: Explaining the getFirstUpdateComponent function
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释 `getFirstUpdateComponent` 函数
- en: '`getFirstUpdateComponent` uses the `m_FirstUpdateComponent` variable to locate
    the update component and then returns it to the calling code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`getFirstUpdateComponent` 使用 `m_FirstUpdateComponent` 变量来定位更新组件，并将其返回给调用代码：'
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now we're just going to go over a couple of getters, and then we are done.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将简要介绍几个获取器，然后我们就完成了。
- en: Explaining the final getter functions
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释最终的获取器函数
- en: 'These two remaining functions return a Boolean (each) to tell the calling code
    whether the game object has a collider and/or an update component:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个剩余的函数返回一个布尔值（每个），以告知调用代码游戏对象是否有碰撞体和/或更新组件：
- en: '[PRE45]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We have coded the `GameObject` class in full. We can now look at putting it
    (and all the components it will be composed of) to work.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完整地编写了 `GameObject` 类。现在我们可以看看如何使用它（以及它将包含的所有组件）。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we have completed all the code that will draw our game objects
    to the screen, control their behavior, and let them interact with other classes
    through collisions. The most important thing to take away from this chapter is
    not how any of the specific component-based classes work but how flexible the
    Entity-Component system is. If you want a game object that behaves in a certain
    way, create a new update component. If it needs to know about other objects in
    the game, get a pointer to the appropriate component in the `start` function.
    If it needs to be drawn in a fancy manner, perhaps with a shader or an animation,
    code a graphics component that performs the actions in the `draw` function. If
    you need multiple colliders, like we did for Thomas and Bob in the Thomas Was
    Late project, this is no problem: code a new collider-based component.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经完成了所有将游戏对象绘制到屏幕上、控制它们的行为以及通过碰撞让它们与其他类交互的代码。从本章中要吸取的最重要的一点不是任何特定基于组件的类是如何工作的，而是实体-组件系统是多么灵活。如果你想创建一个以某种方式行为的游戏对象，就创建一个新的更新组件。如果它需要了解游戏中的其他对象，可以在`start`函数中获取适当的组件指针。如果它需要以某种花哨的方式绘制，比如使用着色器或动画，就在`draw`函数中编写一个执行这些操作的图形组件。如果你需要多个碰撞器，就像我们在《托马斯迟到了》项目中为托马斯和鲍勃做的，这没有任何问题：编写一个新的基于碰撞器的组件。
- en: In the next chapter, we will code the file input and output system, as well
    as the class that will be the factory that builds all the game objects and composes
    them with components.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将编写文件输入和输出系统，以及将构建所有游戏对象并将它们与组件组合的工厂类。
