- en: Chapter 11. Sensing and Tracking Input from the Camera
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 11 章. 感知和跟踪来自摄像头的输入
- en: In this chapter, we will learn how to receive and process data from input devices
    such as a camera or a Microsoft Kinect sensor.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何接收和处理来自摄像头或微软 Kinect 传感器等输入设备的数据。
- en: 'The following recipes will be covered:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下菜谱将涵盖：
- en: Capturing from the camera
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从摄像头捕获
- en: Tracking an object based on color
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于颜色跟踪对象
- en: Tracking motion using optical flow
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用光流跟踪运动
- en: Object tracking
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象跟踪
- en: Reading QR code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取 QR 码
- en: Building UI navigation and gesture recognition with Kinect
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Kinect 构建 UI 导航和手势识别
- en: Building an augmented reality with Kinect
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Kinect 构建增强现实
- en: Capturing from the camera
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从摄像头捕获
- en: In this recipe we will learn how to capture and display frames from a camera.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何捕获和显示来自摄像头的帧。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Include the necessary files to capture images from a camera and draw them to
    OpenGL textures:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 包含必要的文件以从摄像头捕获图像并将它们绘制到 OpenGL 纹理中：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Also add the following `using` statements:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要添加以下 `using` 语句：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How to do it…
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: We will now capture and draw frames from the camera.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将从摄像头捕获并绘制帧。
- en: 'Declare the following members in your application class:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的应用程序类中声明以下成员：
- en: '[PRE2]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the `setup` method we will initialize `mCamera`:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `setup` 方法中，我们将初始化 `mCamera`：
- en: '[PRE3]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the `update` method, we will check if `mCamera` was successfully initialized.
    Also if there is any new frame available, copy the camera''s image into `mTexture`:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `update` 方法中，我们将检查 `mCamera` 是否已成功初始化。如果还有新的帧可用，将摄像头的图像复制到 `mTexture`：
- en: '[PRE4]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the `draw` method, we will simply clear the background, check if `mTexture`
    has been initialized, and draw it''s image on the screen:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `draw` 方法中，我们将简单地清除背景，检查 `mTexture` 是否已初始化，并将其图像绘制到屏幕上：
- en: '[PRE5]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works…
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `ci::Capture` is a class that wraps around Quicktime on Apple computers,
    AVFoundation on iOS platforms, and Directshow on Windows. Under the hood it uses
    these lower level frameworks to access and capture frames from a webcam.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`ci::Capture` 是一个类，它在苹果电脑上围绕 Quicktime，在 iOS 平台上围绕 AVFoundation，在 Windows 上围绕
    Directshow 进行封装。在底层，它使用这些低级框架来访问和捕获来自网络摄像头的帧。'
- en: Whenever a new frame is found, it's pixels are copied into the `ci::Surface
    method`. In the previous code we check on every `update` method if there is a
    new frame by calling the `ci::Capture::checkNewFrame` method, and update our texture
    with its surface.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每当找到新的帧时，它的像素将被复制到 `ci::Surface` 方法中。在前面的代码中，我们在每个 `update` 方法中通过调用 `ci::Capture::checkNewFrame`
    方法来检查是否有新的帧，并使用其表面更新我们的纹理。
- en: There's more…
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多…
- en: It is also possible to get a list of available capture devices and choose which
    one you wish to start with.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以获取可用捕获设备的列表，并选择你希望开始的设备。
- en: 'To ask for a list of devices and print their information, we could write the
    following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要请求设备列表并打印它们的信息，我们可以编写以下代码：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To initialize `mCapture` using a specific device, you simply pass `ci::Capture::DeviceRef`
    as a third parameter in the constructor.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用特定设备初始化 `mCapture`，你只需在构造函数中将 `ci::Capture::DeviceRef` 作为第三个参数传递。
- en: 'For example, if you wanted to initialize `mCapture` with the first device,
    you should write the following code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想用第一个设备初始化 `mCapture`，你应该编写以下代码：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tracking an object based on color
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于颜色跟踪对象
- en: In this recipe we will show how to track objects with a specified color using
    the OpenCV library.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将展示如何使用 OpenCV 库跟踪指定颜色的对象。
- en: Getting ready
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe we will use OpenCV, so please refer to the *Integrating with
    OpenCV* recipe from [Chapter 3](ch03.html "Chapter 3. Using Image Processing Techniques"),
    *Using Image Processing Techniques*. We will also need InterfaceGl which is covered
    in the *Setting up a GUI for parameter tweaking* recipe from [Chapter 2](ch02.html
    "Chapter 2. Preparing for Development"), *Preparing for Development*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 OpenCV，因此请参阅第 3 章 *与 OpenCV 集成* 的 *菜谱*，*使用图像处理技术*。我们还需要 InterfaceGl，它包含在第
    2 章 *准备开发* 的 *设置 GUI 以调整参数* 菜谱中。
- en: How to do it…
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: We will create an application that tracks an object with a selected color.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个应用程序，该应用程序使用所选颜色跟踪对象。
- en: 'Include the necessary header files:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含必要的头文件：
- en: '[PRE8]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add members to store the original and processed frame:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加成员以存储原始和处理的帧：
- en: '[PRE9]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add members to store the tracked object''s coordinates:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加成员以存储跟踪对象的坐标：
- en: '[PRE10]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add members to store the parameters that will be passed to the tracking algorithms:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加成员以存储将传递给跟踪算法的参数：
- en: '[PRE11]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add members to handle the capturing device and frame texture:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加成员以处理捕获设备和帧纹理：
- en: '[PRE12]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the `setup` method we will set the window dimensions and initialize capturing
    device:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `setup` 方法中，我们将设置窗口尺寸并初始化捕获设备：
- en: '[PRE13]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the `setup` method we have to initialize variables and setup the GUI for
    a preview of the tracked color value:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `setup` 方法中，我们必须初始化变量并设置 GUI 以预览跟踪的颜色值：
- en: '[PRE14]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the `update` method, check if there is any new frame to process and convert
    it to `cv::Mat`, which is necessary for further OpenCV operations:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `update` 方法中，检查是否有任何新帧需要处理并将其转换为 `cv::Mat`，这对于进一步的 OpenCV 操作是必要的：
- en: '[PRE15]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Process the captured frame:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理捕获的帧：
- en: '[PRE16]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Close the `if` statement's body.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 `if` 语句的主体。
- en: '[PRE17]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Implement the method `setTrackingHSV`, which sets color''s values for tracking:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现方法 `setTrackingHSV`，它设置跟踪颜色的值：
- en: '[PRE18]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Implement the `mouseDown` event handler:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现鼠标按下事件处理器：
- en: '[PRE19]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Implement the `draw` method as follows:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式实现 `draw` 方法：
- en: '[PRE20]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works…
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: By preparing the captured frame for processing we are converting it into a **hue,
    saturation, and value** (**HSV**) color space description method, which will be
    very useful in this case. Those are the properties describing the color in the
    HSV color space in a more intuitive way for color tracking. We can set a fixed
    hue value for detection, while saturation and value can vary with in a specified
    range. This can eliminate a noise caused by constantly changing light in the camera
    view. Take a look at the first step of the frame image processing; we are using
    the `cv::inRange` function to get a mask of pixels that fits our tracking color
    range. The range of the tracking colors is calculated from the color value picked
    by clicking inside the window, which is implemented inside the `mouseDown` handler
    and the `setTrackingHSV` method.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过准备捕获帧以进行处理，我们将其转换为 **色调、饱和度和值** （**HSV**） 颜色空间描述方法，这在这种情况下非常有用。这些是描述 HSV 颜色空间中颜色的属性，以更直观的方式用于颜色跟踪。我们可以为检测设置一个固定的色调值，而饱和度和值可以在指定的范围内变化。这可以消除由相机视图中不断变化的光线引起的噪声。看看帧图像处理的第一个步骤；我们使用
    `cv::inRange` 函数来获取适合我们跟踪颜色范围的像素掩码。跟踪颜色的范围是从窗口内部点击选择的颜色值计算得出的，这实现在 `mouseDown`
    处理器和 `setTrackingHSV` 方法中。
- en: As you can see inside `setTrackingHSV`, we are calculating `mColorMin` and `mColorMax`
    by simply widening the range. You may have to adjust these calculations depending
    on your camera noise and lighting conditions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在 `setTrackingHSV` 内部所看到的，我们通过简单地扩大范围来计算 `mColorMin` 和 `mColorMax`。您可能需要根据您的相机噪声和光照条件调整这些计算。
- en: See also
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'HSV on Wikipedia: [http://en.wikipedia.org/wiki/HSL_and_HSV](http://en.wikipedia.org/wiki/HSL_and_HSV)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HSV 在维基百科上的介绍：[http://en.wikipedia.org/wiki/HSL_and_HSV](http://en.wikipedia.org/wiki/HSL_and_HSV)
- en: 'The OpenCV documentation: [http://opencv.willowgarage.com/documentation/cpp/](http://opencv.willowgarage.com/documentation/cpp/)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCV 文档：[http://opencv.willowgarage.com/documentation/cpp/](http://opencv.willowgarage.com/documentation/cpp/)
- en: Tracking motion using optical flow
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用光流跟踪运动
- en: In this recipe we will learn how to track motion in the images produced from
    a webcam using OpenCV using the popular Lucas Kanade optical flow algorithm.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何使用 OpenCV 和流行的 Lucas Kanade 光流算法跟踪来自网络摄像头的图像中的运动。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will need to use OpenCV in this recipe, so please refer to the *Integrating
    with OpenCV* recipe from [Chapter 3](ch03.html "Chapter 3. Using Image Processing
    Techniques"), *Using Image Processing Techniques* and add OpenCV and it''s CinderBlock
    to your project. Include the following files to your source file:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们需要使用 OpenCV，因此请参考第 3 章（[第 3 章。使用图像处理技术](ch03.html "第 3 章。使用图像处理技术")）中的
    *与 OpenCV 集成* 配方，*使用图像处理技术*，并将 OpenCV 和 CinderBlock 添加到您的项目中。将以下文件包含到您的源文件中：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add the following `using` statements:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下 `using` 语句：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How to do it…
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: We will read frames from the camera and track motion.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将读取来自相机的帧并跟踪运动。
- en: 'Declare the `ci::gl::Texture` and `ci::Capture` objects to display and capture
    from a camera. Also, declare a `cv::Mat` object as the previous frame, two `std::vector<cv::Point2f>`
    objects to store the current and previous features, and a `std::vector<uint8_t>`
    object to store the status of each feature:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明 `ci::gl::Texture` 和 `ci::Capture` 对象以显示和从相机捕获。同时，声明一个 `cv::Mat` 对象作为前一个帧，两个
    `std::vector<cv::Point2f>` 对象以存储当前和前一个特征，以及一个 `std::vector<uint8_t>` 对象以存储每个特征的状态：
- en: '[PRE23]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the `setup` method we will initialize `mCamera`:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法中，我们将初始化`mCamera`：
- en: '[PRE24]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the `update` method we need to check if `mCamera` has been correctly initialized
    and whether it has a new frame available:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update`方法中，我们需要检查`mCamera`是否已正确初始化，并且是否有新的帧可用：
- en: '[PRE25]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After those `if` statements we will get a reference to `ci::Surface` of `mCamera`
    and then copy it to our `mTexture` for drawing:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那些`if`语句之后，我们将获取`mCamera`的`ci::Surface`引用，并将其复制到我们的`mTexture`中以进行绘制：
- en: '[PRE26]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now let''s create a `cv::Mat` with the current camera frame. We will also check
    if `mPreviousFrame` contains any initialized data, calculate the good features
    to track, and calculate their motion from the previous camera frame to the current
    frame:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建一个`cv::Mat`，包含当前相机帧。我们还将检查`mPreviousFrame`是否包含任何初始化的数据，计算适合跟踪的良好特征，并计算它们从先前的相机帧到当前帧的运动：
- en: '[PRE27]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now we just need to copy the frame to `mPreviousFrame` and close the initial
    `if` statements:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们只需将帧复制到`mPreviousFrame`并关闭初始的`if`语句：
- en: '[PRE28]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the `draw` method we will begin by clearing the background with black and
    drawing `mTexture`:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`draw`方法中，我们将首先用黑色清除背景，并绘制`mTexture`：
- en: '[PRE29]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we will draw red lines on the features we have tracked, using `mFeatureStatus`
    to draw the features that have been matched:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`mFeatureStatus`在已跟踪的特征上绘制红色线条，以绘制已匹配的特征：
- en: '[PRE30]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, we will draw a line between the previous features and the current
    ones, also using `mFeatureStatus` to draw one of the features that has been matched:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用`mFeatureStatus`绘制一条线，将先前的特征和当前的特征连接起来，以绘制已匹配的一个特征：
- en: '[PRE31]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the following image, the red dots represent good features to track:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下图像中，红色点代表适合跟踪的良好特征：
- en: '![How to do it…](img/8703OS_11_01.jpg)'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做…](img/8703OS_11_01.jpg)'
- en: How it works…
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The optical flow algorithm will make an estimation of how much the tracked point
    has moved from one frame to the other.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 光流算法将对跟踪点从一个帧移动到另一个帧的距离进行估计。
- en: There's more…
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this recipe we are using the `cv::goodFeaturesToTrack` object to calculate
    which features are optimal for tracking, but it is also possible to manually choose
    which points we wish to track. All we have to do is populate `mFeatures` manually
    with whatever points we wish to track and pass it to the `cv::calcOpticalFlowPyrLK`.
    object
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用`cv::goodFeaturesToTrack`对象来计算哪些特征最适合跟踪，但也可以手动选择我们希望跟踪的点。我们只需手动将我们希望跟踪的点填充到`mFeatures`中，并将其传递给`cv::calcOpticalFlowPyrLK`对象。
- en: Object tracking
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象跟踪
- en: In this recipe, we will learn how to track specific planar objects in our webcam
    using OpenCV and it's corresponding CinderBlock.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用OpenCV及其相应的CinderBlock在Webcam中跟踪特定的平面对象。
- en: Getting ready
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need an image depiction of the physical object you wish to track in
    the camera. For this recipe place that image in the `assets` folder and name it
    `object.jpg`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个描述您希望在相机中跟踪的物理对象的图像。对于这个菜谱，请将此图像放置在`assets`文件夹中，并命名为`object.jpg`。
- en: We will use the OpenCV CinderBlock in this recipe, so please refer to the *Integrating
    with OpenCV* recipe from [Chapter 3](ch03.html "Chapter 3. Using Image Processing
    Techniques"), *Using Image Processing Techniques* and add OpenCV and it's CinderBlock
    to your project.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用OpenCV CinderBlock，请参考第3章的*与OpenCV集成*菜谱，*使用图像处理技术*，并将OpenCV及其CinderBlock添加到您的项目中。
- en: 'If you are using a Mac, you will need to compile the OpenCV static libraries
    yourself, because the OpenCV CinderBlock is missing some needed libraries on OSX
    (it will work fine on Windows). You can download the correct version from the
    following link: [http://sourceforge.net/projects/opencvlibrary/files/opencv-unix/2.3/](http://sourceforge.net/projects/opencvlibrary/files/opencv-unix/2.3/).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Mac，您需要自己编译OpenCV静态库，因为OpenCV CinderBlock在OSX上缺少一些必要的库（它将在Windows上正常工作）。您可以从以下链接下载正确的版本：[http://sourceforge.net/projects/opencvlibrary/files/opencv-unix/2.3/](http://sourceforge.net/projects/opencvlibrary/files/opencv-unix/2.3/)。
- en: 'You will need to compile the static libraries yourself using the provided `CMake`
    files. Once your libraries are correctly added to your project, include the following
    files:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要自己使用提供的`CMake`文件编译静态库。一旦您的库正确添加到项目中，请包含以下文件：
- en: '[PRE32]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add the following `using` statements:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下`using`语句：
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How to do it…
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We will track an object in the camera frames based on an image depicting the
    object
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据描述该对象的图像在相机帧中跟踪一个对象
- en: 'Let''s begin by creating a `struct` method to store the necessary objects for
    feature tracking and matching. Add the following code before your application
    class declaration:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先创建一个`struct`方法来存储用于特征跟踪和匹配的必要对象。在你的应用程序类声明之前添加以下代码：
- en: '[PRE34]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In your class declaration add the following member objects:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的类声明中添加以下成员对象：
- en: '[PRE35]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the `setup` method let''s start by initializing the camera:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法中，让我们首先初始化相机：
- en: '[PRE36]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Lets resize `mCorners`, load our object image, and calculate its `image`, `keyPoints`,
    `texture`, and `descriptor`:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们调整`mCorners`的大小，加载我们的物体图像，并计算其`image`、`keyPoints`、`texture`和`descriptor`：
- en: '[PRE37]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the `update` method, we will check if `mCamera` has been initialized and
    whether we have a new frame to process:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update`方法中，我们将检查`mCamera`是否已初始化，并且是否有新的帧需要处理：
- en: '[PRE38]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now let''s get the surface of `mCamera` and initialize `texture` and `image`
    objects of `mCameraInfo`. We will create a `ci::Channel` object from `cameraSurface`
    that converts color surfaces to gray channel surfaces:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们获取`mCamera`的表面并初始化`mCameraInfo`的`texture`和`image`对象。我们将从`cameraSurface`创建一个`ci::Channel`对象，该对象将彩色表面转换为灰度通道表面：
- en: '[PRE39]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s calculate `features` and `descriptor` values of `mCameraInfo`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们计算`mCameraInfo`的`features`和`descriptor`值：
- en: '[PRE40]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now let''s use `mMatcher` to calculate the matches between `mObjectInfo` and
    `mCameraInfo`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用`mMatcher`来计算`mObjectInfo`和`mCameraInfo`之间的匹配：
- en: '[PRE41]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To perform a test to check for false matches, we will calculate the minimum
    distance between matches:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了进行测试以检查错误匹配，我们将计算匹配之间的最小距离：
- en: '[PRE42]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now we will add all the points whose distance is less than `minDist*3.0` to
    `mObjectInfo.goodPoints.clear();`
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将添加所有距离小于`minDist*3.0`的点到`mObjectInfo.goodPoints.clear();`
- en: '[PRE43]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`}` With all our points calculated and matched, we need to calculate the homography
    between the points of `mObjectInfo` and `mCameraInfo`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`}`在我们所有的点都计算并匹配后，我们需要计算`mObjectInfo`和`mCameraInfo`之间的单应性：'
- en: '[PRE44]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s create `vector<cv::Point2f>` with the corners of our object and perform
    a perspective transform to calculate the corners of our object in the camera image:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个`vector<cv::Point2f>`，包含我们物体的角点，并执行透视变换来计算相机图像中物体的角点：
- en: Tip
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Don't forget to close the brackets we opened earlier.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要忘记关闭我们之前打开的括号。
- en: '[PRE45]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s move to the `draw` method and begin by clearing the background and drawing
    the camera and object textures:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们转到`draw`方法，首先清除背景并绘制相机和物体纹理：
- en: '[PRE46]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now let''s iterate over `goodPoints` values in both `mObjectInfo` and `mCameraInfo`
    and draw them:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们遍历`mObjectInfo`和`mCameraInfo`中的`goodPoints`值并绘制它们：
- en: '[PRE47]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now let''s iterate over `mCorners` and draw the corners of the found object:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们遍历`mCorners`并绘制找到的物体的角点：
- en: '[PRE48]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Build and run the application. Grab the physical object you depicted in the
    `object.jpg` image and put it in front of the image. The program will try to track
    that object in the camera image and draw it's corners in the image.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。拿起你在`object.jpg`图像中描述的物理物体，并将其放在图像前面。程序将尝试在相机图像中跟踪该物体，并在图像中绘制其角点。
- en: How it works…
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We are using a **Speeded Up Robust Features** (**SURF**) feature detector and
    descriptor to identify features. In the step 4, we are calculating the features
    and descriptor. We use a `cv::SurfFeatureDetect` object `or` that calculates good
    features to track on our object. The `cv::SurfDescriptorExtractor` object then
    uses these features to create a description of our object. In the step 7, we do
    the same for the camera image.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用**加速鲁棒特征**（**SURF**）特征检测器和描述符来识别特征。在步骤4中，我们计算特征和描述符。我们使用一个`cv::SurfFeatureDetect`对象来计算物体上的良好特征以进行跟踪。然后，`cv::SurfDescriptorExtractor`对象使用这些特征来创建我们物体的描述。在步骤7中，我们对相机图像做同样的处理。
- en: In the step 8, we then use a **Fast Library for Approximate Nearest Neighbor**
    (**FLANN**) called `cv::FlannBasedMatcher`. This matcher takes the description
    from both the camera frame and our object, and calculates matches between them.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤8中，我们使用一个名为`cv::FlannBasedMatcher`的**快速近似最近邻库**（**FLANN**）来执行操作。这个匹配器从相机帧和我们的物体中获取描述，并计算它们之间的匹配。
- en: In steps 9 and 10, we use the minimum distance between matches to eliminate
    the possible false matches. The result is passed into `mObjectInfo.goodPoints`
    and `mCameraInfo.goodPoints`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤9和10中，我们使用匹配之间的最小距离来消除可能的错误匹配。结果传递到`mObjectInfo.goodPoints`和`mCameraInfo.goodPoints`。
- en: In the step 11, we calculate the homography between image and camera. A homography
    is a projection transformation from one space to another using projective geometry.
    We use it in the step 12 to apply a perspective transformation to `mCorners` to
    identify the object corners in the camera image.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 11 中，我们计算图像和摄像头之间的单应性。单应性是使用射影几何从一个空间到另一个空间的投影变换。我们在步骤 12 中使用它来对 `mCorners`
    应用透视变换，以识别摄像头图像中的对象角落。
- en: There's more…
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: 'To learn more about what SURF is and how it works, please refer to the following
    web page: [http://en.wikipedia.org/wiki/SURF](http://en.wikipedia.org/wiki/SURF).'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 SURF 是什么以及它是如何工作的信息，请参考以下网页：[http://en.wikipedia.org/wiki/SURF](http://en.wikipedia.org/wiki/SURF).
- en: To learn more about FLANN, please refer to the web page [http://en.wikipedia.org/wiki/Nearest_neighbor_search](http://en.wikipedia.org/wiki/Nearest_neighbor_search).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 FLANN 的信息，请参考网页 [http://en.wikipedia.org/wiki/Nearest_neighbor_search](http://en.wikipedia.org/wiki/Nearest_neighbor_search).
- en: 'To learn more about homography please refer to the following web page:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于单应性的信息，请参考以下网页：
- en: '[http://en.wikipedia.org/wiki/Homography](http://en.wikipedia.org/wiki/Homography).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://en.wikipedia.org/wiki/Homography](http://en.wikipedia.org/wiki/Homography).'
- en: Reading QR code
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取 QR 码
- en: In this example we will use the ZXing library for QR code reading.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将使用 ZXing 库进行 QR 码读取。
- en: Getting ready
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Please download the Cinder ZXing block from GitHub and unpack it to the `blocks`
    folder: [https://github.com/dawidgorny/Cinder-ZXing](https://github.com/dawidgorny/Cinder-ZXing)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请从 GitHub 下载 Cinder ZXing 模块并将其解压到 `blocks` 文件夹：[https://github.com/dawidgorny/Cinder-ZXing](https://github.com/dawidgorny/Cinder-ZXing)
- en: How to do it…
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We will now create a QR code reader:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个 QR 码读取器：
- en: 'Add a header search path to the build settings of your project:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将头文件搜索路径添加到项目的构建设置中：
- en: '[PRE49]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Add a path from the precompiled ZXing library to the build settings of your
    project: `$(CINDER_PATH)/blocks/zxing/lib/macosx/libzxing.a`. For a debug configuration,
    use `$(CINDER_PATH)/blocks/zxing/lib/macosx/libzxing_d.a`.'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将预编译的 ZXing 库路径添加到项目的构建设置中：`$(CINDER_PATH)/blocks/zxing/lib/macosx/libzxing.a`。对于调试配置，使用
    `$(CINDER_PATH)/blocks/zxing/lib/macosx/libzxing_d.a`。
- en: Add Cinder ZXing block files to your project structure as follows:![How to do
    it…](img/8703OS_11_02.jpg)
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式将 Cinder ZXing 模块文件添加到项目结构中：![如何操作…](img/8703OS_11_02.jpg)
- en: Add the `libiconv.dylib` library to the `Link Binary With Libraries` list:![How
    to do it…](img/8703OS_11_03.jpg)
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `libiconv.dylib` 库添加到 `Link Binary With Libraries` 列表中：![如何操作…](img/8703OS_11_03.jpg)
- en: 'Add the necessary header files:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加必要的头文件：
- en: '[PRE50]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Add the following members to your main application class:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下成员添加到您的应用程序主类中：
- en: '[PRE51]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Inside the `setup` method, set window dimensions and initialize capturing from
    camera:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `setup` 方法中，设置窗口尺寸并从摄像头初始化捕获：
- en: '[PRE52]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Implement the `update` function as follows:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式实现 `update` 函数：
- en: '[PRE53]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Implement the `draw` function as follows:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式实现 `draw` 函数：
- en: '[PRE54]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works…
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: We are using regular ZXing library methods. The `SurfaceBitmapSource` class
    delivered by the Cinder ZXing block provides integration with Cinder `Surface`
    type objects. While the QR code is detected and read, the `mDetected` flag is
    set to `true` and the read data is stored in the `mData` member.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用常规的 ZXing 库方法。由 Cinder ZXing 模块提供的 `SurfaceBitmapSource` 类实现了与 Cinder
    `Surface` 类型对象的集成。当 QR 码被检测并读取时，`mDetected` 标志被设置为 `true`，读取的数据存储在 `mData` 成员中。
- en: '![How it works…](img/8703OS_11_06.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/8703OS_11_06.jpg)'
- en: Building UI navigation and gesture recognition with Kinect
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Kinect 构建 UI 导航和手势识别
- en: In this recipe we will create interactive GUI controlled with a Kinect sensor.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将创建由 Kinect 传感器控制的交互式 GUI。
- en: Tip
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Since the **Kinect for Windows SDK** is available only for Windows, this recipe
    is written for Windows users only.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 **Kinect for Windows SDK** 仅适用于 Windows，因此本食谱仅适用于 Windows 用户。
- en: '![Building UI navigation and gesture recognition with Kinect](img/8703OS_11_04.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Kinect 构建UI导航和手势识别](img/8703OS_11_04.jpg)'
- en: Getting ready
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this example we are using the `InteractiveObject` class that we covered in
    the *Creating an interactive object that responds to the mouse* recipe from [Chapter
    10](ch10.html "Chapter 10. Interacting with the User"), *Interacting with the
    User*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们使用的是我们在第 10 章“与用户交互”中的“创建对鼠标响应的交互对象”食谱中介绍的 `InteractiveObject` 类。
- en: Download and install the Kinect for Windows SDK from [http://www.microsoft.com/en-us/kinectforwindows/](http://www.microsoft.com/en-us/kinectforwindows/).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [http://www.microsoft.com/en-us/kinectforwindows/](http://www.microsoft.com/en-us/kinectforwindows/)
    下载并安装 Kinect for Windows SDK。
- en: Download the KinectSDK CinderBlock from GitHub at [https://github.com/BanTheRewind/Cinder-KinectSdk](https://github.com/BanTheRewind/Cinder-KinectSdk),
    and unpack it to the `blocks` directory.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 从GitHub下载KinectSDK CinderBlock [https://github.com/BanTheRewind/Cinder-KinectSdk](https://github.com/BanTheRewind/Cinder-KinectSdk)，并将其解压到`blocks`目录。
- en: How to do it…
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: We will now create a Cinder application controlled with hand gestures.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建一个通过手势控制的手势Cinder应用程序。
- en: 'Include the necessary header files:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含必要的头文件：
- en: '[PRE55]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Add the Kinect SDK using the following statement:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下语句添加Kinect SDK：
- en: '[PRE56]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Implement the class for a waving hand gesture recognition as follows:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式实现挥手手势识别的类：
- en: '[PRE57]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Implement `NuiInteractiveObject` extending the `InteractiveObject` class:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`NuiInteractiveObject`类，该类扩展了`InteractiveObject`类：
- en: '[PRE58]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Implement the `NuiController` class that manages the active objects:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`NuiController`类，该类管理活动对象：
- en: '[PRE59]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Add the members to you main application class for handling Kinect devices and
    data:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将成员添加到主应用程序类中，用于处理Kinect设备和数据：
- en: '[PRE60]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Add members to store the calculated cursor position:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加成员以存储计算出的光标位置：
- en: '[PRE61]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Add the members that we will use for gesture recognition and user activation:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加我们将用于手势识别和用户激活的成员：
- en: '[PRE62]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Add a member to handle `NuiController`:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个处理`NuiController`的成员：
- en: '[PRE63]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Set window settings by implementing `prepareSettings`:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过实现`prepareSettings`设置窗口设置：
- en: '[PRE64]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In the `setup` method, set the default values for members:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法中，为成员设置默认值：
- en: '[PRE65]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In the `setup` method initialize Kinect and gesture recognition for `10` users:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法中，为`10`个用户初始化Kinect和手势识别：
- en: '[PRE66]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In the `setup` method, initialize the user interface consisting of objects
    of type `NuiInterativeObject`:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法中，初始化由`NuiInterativeObject`类型对象组成用户界面：
- en: '[PRE67]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In the `update` method, we are checking if the Kinect device is capturing,
    getting tracked skeletons, and iterating:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update`方法中，我们正在检查Kinect设备是否正在捕获、获取跟踪骨骼以及迭代：
- en: '[PRE68]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Inside the loop, we are checking if the skeleton is complete and deactivating
    the cursor controls if it is not complete:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环内部，我们正在检查骨骼是否完整，如果不完整，则停用光标控制：
- en: '[PRE69]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Inside the loop check if the skeleton is valid. Notice we are only processing
    10 skeletons. You can modify this number, but remember to provide sufficient number
    of gesture controllers in `mGestureControllers`:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环内部检查骨骼是否有效。注意我们只处理10个骨骼。你可以修改这个数字，但请记住在`mGestureControllers`中提供足够的动作控制器数量：
- en: '[PRE70]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Inside the loop and the `if` statement, check for the completed activation
    gesture. While the skeleton is activated, we are calculating person interaction
    zone:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环和`if`语句内部，检查完成的激活手势。当骨骼被激活时，我们正在计算人机交互区域：
- en: '[PRE71]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Inside the loop and the `if` statement, we are calculating cursor positions
    for active users:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环和`if`语句内部，我们正在计算活动用户的鼠标位置：
- en: '[PRE72]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Close the opened `if` statements and the `for` loop:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭打开的`if`语句和`for`循环：
- en: '[PRE73]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'At the end of the `update` method, update the `NuiController` object:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`update`方法的末尾，更新`NuiController`对象：
- en: '[PRE74]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Implement the `draw` method as follows:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式实现`draw`方法：
- en: '[PRE75]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: How it works…
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The application is tracking users using Kinect SDK. Skeleton data of the active
    user are used to calculate the cursor position by following the guidelines provided
    by Microsoft with Kinect SDK documentation. Activation is invoked by a hand waving
    gesture.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序正在使用Kinect SDK跟踪用户。活动用户的骨骼数据用于根据Microsoft提供的Kinect SDK文档中的指南计算鼠标位置。激活是通过挥手手势触发的。
- en: This is an example of UI responsive to cursor controlled by a user's hand. Elements
    of the grid light up under the cursor and fade out on roll-out.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用户通过手势控制的鼠标控制的UI响应示例。光标下的网格元素会亮起，并在移出时淡出。
- en: Building an augmented reality with Kinect
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kinect构建增强现实
- en: In this recipe we will learn how to combine both Kinect's depth and image frames
    to create augmented reality application.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何结合Kinect的深度和图像帧来创建增强现实应用程序。
- en: Tip
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Since Kinect for Windows SDK is available only for Windows, this recipe is written
    for Windows users only.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Kinect for Windows SDK仅适用于Windows，因此本食谱仅适用于Windows用户。
- en: Getting ready
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Download and install Kinect for Windows SDK from [http://www.microsoft.com/en-us/kinectforwindows/](http://www.microsoft.com/en-us/kinectforwindows/).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 从[http://www.microsoft.com/en-us/kinectforwindows/](http://www.microsoft.com/en-us/kinectforwindows/)下载并安装Kinect
    for Windows SDK。
- en: Download KinectSDK CinderBlock from GitHub at [https://github.com/BanTheRewind/Cinder-KinectSdk](https://github.com/BanTheRewind/Cinder-KinectSdk),
    and unpack it to the `blocks` directory.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 从GitHub下载KinectSDK CinderBlock，网址为[https://github.com/BanTheRewind/Cinder-KinectSdk](https://github.com/BanTheRewind/Cinder-KinectSdk)，并将其解压到`blocks`目录中。
- en: In this example, we are using assets from one of the sample programs delivered
    with the Cinder package. Please copy the `ducky.mshducky.png`, `phong_vert.glsl`,
    and `phong_frag.glsl` files from `cinder_0.8.4_mac/samples/Picking3D/resources/`
    into your `assets` folder.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用Cinder包中提供的示例程序之一中的资源。请将`cinder_0.8.4_mac/samples/Picking3D/resources/`中的`ducky.mshducky.png`、`phong_vert.glsl`和`phong_frag.glsl`文件复制到您的`assets`文件夹中。
- en: How to do it…
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: We will now create an augmented reality application using a sample 3D model.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建一个使用示例3D模型的增强现实应用程序。
- en: 'Include the necessary header files:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含必要的头文件：
- en: '[PRE76]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Add the `using` statement of the Kinect SDK:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加Kinect SDK的`using`语句：
- en: '[PRE77]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Add the members to you main application class for handling Kinect device and
    data:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向主应用程序类中添加用于处理Kinect设备和数据的成员：
- en: '[PRE78]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Add members to store 3D camera scene properties:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向存储3D摄像机场景属性的成员中添加成员：
- en: '[PRE79]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Add members to store calibration settings:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向存储校准设置的成员中添加成员：
- en: '[PRE80]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Add members that will store geometry, texture, and shader program for 3D object:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加将存储几何形状、纹理和着色器程序的3D对象的成员：
- en: '[PRE81]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Inside the `setup` method, set the window dimensions and initial values:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法内部，设置窗口尺寸和初始值：
- en: '[PRE82]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Inside the `setup` method load geometry, texture, and shader program for 3D
    object:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法内部加载3D对象的几何形状、纹理和着色器程序：
- en: '[PRE83]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Inside the `setup` method, initialize the Kinect device and start capturing:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法内部，初始化Kinect设备并开始捕获：
- en: '[PRE84]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'At the end of the `setup` method, create GUI for parameter tweaking:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`方法的末尾，创建用于参数调整的GUI：
- en: '[PRE85]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Implement the `update` method as follows:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式实现`update`方法：
- en: '[PRE86]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Implement the `drawObject` method that will draw our 3D model with the texture
    and shading applied:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现将使用纹理和着色应用来绘制我们的3D模型的`drawObject`方法：
- en: '[PRE87]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Implement the `draw` method as follows:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式实现`draw`方法：
- en: '[PRE88]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The last thing that is missing is the `draw3DScene` method invoked inside the
    `draw` method. Implement the `draw3DScene` method as follows:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后缺少的是在`draw`方法内部调用的`draw3DScene`方法。按如下方式实现`draw3DScene`方法：
- en: '[PRE89]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Implement the `shutdown` method to stop capturing from Kinect on program termination:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现用于在程序终止时停止从Kinect捕获的`shutdown`方法：
- en: '[PRE90]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: How it works…
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The application is tracking users using the Kinect SDK. Skeleton data of the
    users are used to calculate the coordinates of the 3D duck model taken from one
    of the Cinder sample programs. The 3D model is rendered right above the right
    hand of the user when the user's hand is in front of the user. The activation
    distance is calculated using the `mActivationDist` member value.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序正在使用Kinect SDK跟踪用户。用户的骨骼数据用于计算从Cinder示例程序中获取的3D鸭模型的坐标。当用户的手在用户面前时，3D模型将渲染在用户的右手上方。激活距离是通过`mActivationDist`成员值计算得出的。
- en: '![How it works…](img/8703OS_11_05.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/8703OS_11_05.jpg)'
- en: To properly overlay 3D scene onto a video frame, you have to set the camera
    FOV according to the Kinect video camera. To do this, we are using the `Camera
    FOV` property.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确地将3D场景叠加到视频帧上，您必须根据Kinect视频摄像机设置相机FOV。为此，我们使用`Camera FOV`属性。
