- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Desired Test Declaration
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所需测试声明
- en: If we’re going to have a **test-driven development** (**TDD**) process, we need
    tests. This chapter will explain what the tests will do, how we will write them,
    and how we will use them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要有一个**测试驱动开发**（**TDD**）的过程，我们需要测试。本章将解释测试将做什么，我们将如何编写它们，以及我们将如何使用它们。
- en: We’ll be starting from the very beginning and slowly building a full library
    to help manage and run tests, and we’ll be using the test library to help build
    itself. Initially, there will only be a single test. The following chapters will
    add more capabilities and grow the test library.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一开始慢慢构建一个完整的库来帮助管理和运行测试，并且我们将使用测试库来帮助构建自己。最初，将只有一个测试。接下来的章节将添加更多功能并扩展测试库。
- en: Starting with the end goal in mind, we’ll first think about what it will be
    like to create and use a test. Writing tests is a big part of TDD, so it makes
    sense to start thinking about testing even before we have the ability to create
    and run tests.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 从最终目标开始考虑，我们首先会思考创建和使用测试会是什么样的。编写测试是TDD的一个重要部分，所以在我们能够创建和运行测试之前，考虑测试是有意义的。
- en: TDD is a process that will help you design better code and then make changes
    to your code without breaking parts that you’ve already verified to be working
    as expected. In order for this process to work, we need to be able to write tests.
    This chapter will explore what tests can do for us and how we can write them.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: TDD（测试驱动开发）是一个过程，它将帮助你设计更好的代码，然后在不破坏你已验证为按预期工作的部分的情况下修改你的代码。为了使这个过程有效，我们需要能够编写测试。本章将探讨测试能为我们做什么，以及我们如何编写它们。
- en: 'We’ll cover the following main topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要主题：
- en: What do we want tests to do for us?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望测试为我们做什么？
- en: What should a test look like?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试应该是什么样子？
- en: What information does a test need?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试需要哪些信息？
- en: How can we use C++ to write tests?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何使用C++编写测试？
- en: How will the first test be used?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一份测试将如何被使用？
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code in this chapter uses standard C++, which builds on any modern C++
    17 or later compiler and standard library. Future chapters will require C++ 20
    but for now, only C++ 17 is needed. The number refers to the year that the standard
    was approved and finalized, so C++ 17 was released in 2017 and C++ 20 was released
    in 2020\. Each release adds new features and capabilities to the language.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有代码都是基于标准的C++，它构建在任何现代C++ 17或更高版本的编译器和标准库之上。未来的章节将需要C++ 20，但到目前为止，只需要C++
    17。数字指的是标准被批准和最终确定的那一年，因此C++ 17于2017年发布，C++ 20于2020年发布。每次发布都会为语言添加新的功能和能力。
- en: The code we’ll be working with starts with an empty console project with a single
    source file called `main.cpp`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将工作的代码从一个空的控制台项目开始，该项目有一个名为`main.cpp`的单个源文件。
- en: If your development environment gives you a “Hello, world!” project when starting
    a new command line or console project, you can delete the contents of the `main.cpp`
    file because this chapter will start from the very beginning with an empty file.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的开发环境在启动新的命令行或控制台项目时给你一个“Hello, world！”项目，你可以删除`main.cpp`文件的内容，因为本章将从空文件开始从头开始。
- en: 'You can find all the code for this chapter at the following GitHub repository:
    [https://github.com/PacktPublishing/Test-Driven-Development-with-CPP](https://github.com/PacktPublishing/Test-Driven-Development-with-CPP).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下GitHub仓库找到本章的所有代码：[https://github.com/PacktPublishing/Test-Driven-Development-with-CPP](https://github.com/PacktPublishing/Test-Driven-Development-with-CPP)。
- en: What do we want tests to do for us?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们希望测试为我们做什么？
- en: Before we start learning about test-driven development, what it is, and what
    the process involves, let’s step back and think about what we want. Without knowing
    all the details about what a test is, let’s ask ourselves what our tests should
    look like.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始学习测试驱动开发、它是什么以及涉及的过程之前，让我们退一步思考我们想要什么。在不了解测试的所有细节的情况下，让我们问问自己我们的测试应该是什么样子。
- en: I like to relate programming concepts to everyday experiences whenever possible.
    Maybe you have an idea to solve a problem that you have noticed and want to see
    whether your idea will work. If you wanted to test this idea before announcing
    it to the world, how would you do it?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢尽可能地将编程概念与日常经验联系起来。也许你有一个解决问题的想法，你注意到并想看看你的想法是否可行。如果你想在向世界宣布之前测试这个想法，你会怎么做？
- en: You probably won’t be able to test everything to do with your idea at once.
    What would that even mean? There are probably small parts of your idea that you
    can think about initially. These should be easier to test and should help to clarify
    your idea and get you to think of other things to test.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能无法一次性测试你想法的所有方面。这又意味着什么呢？你可能会先考虑你想法的一些小部分。这些部分应该更容易测试，并且有助于阐明你的想法，让你思考其他可以测试的事情。
- en: So, let’s focus on simply testing small parts of the idea, whatever it is. You’d
    want to get everything set up and then start some actions or steps that should
    tell you whether each part works or not. Some of your tests might work well and
    some might cause you to rethink your idea. This is definitely better than jumping
    into the full idea without knowing whether it will work or not.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们专注于简单地测试想法的小部分，无论它是什么。你想要设置好一切，然后开始一些行动或步骤，这些行动或步骤应该告诉你每个部分是否工作。一些测试可能工作得很好，而一些测试可能会让你重新思考你的想法。这肯定比在没有知道它是否可行的情况下跳入整个想法要好。
- en: To put this into a real context, let’s say you have an idea to build a better
    broom. That’s a vague idea that’s hard to envision. However, let’s say that while
    sweeping the floor recently, you noticed your arms getting sore and thought that
    there had to be a better way. Thinking about the actual problem is a good way
    to turn a vague idea into something with a more solid meaning.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这个概念应用到实际情境中，假设你有一个想法要制造一把更好的扫帚。这是一个模糊的想法，难以想象。然而，假设你在最近打扫地板时，注意到你的手臂酸痛，并认为肯定有更好的方法。思考实际问题是一个将模糊想法转化为更有实质性意义的好方法。
- en: Now, you might start thinking about testing broom handles of different shapes,
    different grips, or different sweeping motions. These are the smaller parts of
    the idea that can be tested. You can take each grip or motion and turn it into
    a set of steps or actions that will test that part until you find one that works
    best.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会开始考虑测试不同形状的扫帚柄、不同的握把或不同的扫地动作。这些都是可以测试的想法的小部分。你可以将每个握把或动作转换成一系列步骤或行动，以测试该部分，直到找到最佳的工作方式。
- en: Well, in programming, a set of steps can be a **function**. It doesn’t matter
    what that function does right now. We can think of each test as represented by
    a function. If you can call a function and it gives you the expected result, then
    you can say that the test passed. We’ll build on this idea throughout this book.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，在编程中，一系列步骤可以是一个**函数**。现在这个函数做什么并不重要。我们可以将每个测试想象成一个函数。如果你可以调用一个函数并且它给出了预期的结果，那么你可以说测试通过了。我们将在整本书中基于这个想法进行构建。
- en: Now that we’ve decided to use a function for a test, what should it look like?
    After all, there are lots of ways to write a function.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经决定使用函数来进行测试，它应该是什么样子呢？毕竟，编写函数有很多种方式。
- en: What should a test look like?
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试应该是什么样子？
- en: It should be as simple to write a test as it is to declare and write a function,
    and we should be able to simplify things even further. A normal function can have
    whatever return type you want, a name, a set of parameters, and a body of code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试应该和声明和编写函数一样简单，我们应该能够进一步简化事情。一个普通函数可以有任何你想要的返回类型，一个名称，一组参数，以及一段代码体。
- en: A function is also something that you write so that it can be called by other
    code. This code should know what the function does, what it returns, and what
    arguments need to be passed. We’ll keep things simple for our test functions and
    only worry about the name for now.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也是你编写的东西，以便其他代码可以调用它。这段代码应该知道函数做什么，它返回什么，以及需要传递什么参数。我们将保持测试函数的简单性，现在只关注名称。
- en: We want each test function to have its own name. Otherwise, how would we be
    able to keep track of all the various tests we’ll eventually be writing? As for
    the return type, we haven’t identified an actual need yet, so we’ll use `void`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望每个测试函数都有自己的名称。否则，我们如何能够跟踪我们最终将要编写的所有各种测试呢？至于返回类型，我们还没有确定实际需求，所以我们将使用`void`。
- en: You’ll learn more about this process in [*Chapter 3*](B18567_03.xhtml#_idTextAnchor031),
    *The TDD Process*. When using TDD, don’t get ahead of yourself. Only do what you
    need to do at the time. As with the `void` return type, we’ll also not have any
    parameters.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在[*第三章*](B18567_03.xhtml#_idTextAnchor031)《TDD过程》中了解更多关于这个流程。在使用TDD时，不要急于求成。只做当时需要做的事情。就像`void`返回类型一样，我们也不会有任何参数。
- en: It might seem too simple but this is a good start. So far, a test is nothing
    more than a function, which returns nothing and takes no parameters. It has a
    name to identify it and will include whatever code is needed to run the test.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来太简单了，但这是一个好的开始。到目前为止，测试不过是一个函数，它不返回任何内容，也不接受任何参数。它有一个名称来识别它，并将包含运行测试所需的任何代码。
- en: 'Because we’re going to start using TDD to help design a simple testing library,
    our first test should ensure that we can create a test. This is a simple start,
    which defines a test function and calls it from `main`. All of this is in a single
    file called `main.cpp`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将开始使用TDD来帮助设计一个简单的测试库，我们的第一个测试应该确保我们可以创建一个测试。这是一个简单的开始，它定义了一个测试函数并从`main`中调用它。所有这些都在一个名为`main.cpp`的单个文件中：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You might be thinking that this is not a test, it’s just a function that prints
    its own name, and you’d be right. We’re going to build it up from the very beginning
    in an agile manner using only what we have available. Right now, we don’t have
    a test library to use yet.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，这根本不是测试，而只是一个打印自己名称的函数，你是对的。我们将从头开始，以敏捷的方式构建它，只使用我们目前拥有的资源。现在，我们还没有可用的测试库。
- en: 'Still, this is starting to resemble what we eventually want. We want a test
    to be just like writing a function. If you build and run the project now, the
    output is as expected:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这已经开始类似于我们最终想要的样子了。我们希望测试就像编写一个函数一样。如果你现在构建并运行项目，输出应该是预期的：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This shows the output from running the program. It displays the name of the
    function. The text in the second line actually comes from my development tools
    and shows the program exit code. The exit code is the value returned from `main`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了运行程序时的输出。它显示了函数的名称。第二行的文本实际上来自我的开发工具，显示了程序的退出代码。退出代码是`main`函数返回的值。
- en: This is a start but it can be improved. The next section will look at what information
    a test needs, such as its name.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个开始，但可以改进。下一节将探讨测试需要哪些信息，例如其名称。
- en: What information does a test need?
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试需要哪些信息？
- en: The current test function doesn’t really know its name. We want the test to
    have a name so that it can be identified but does that name really need to be
    the name of the function? It would be better if the name was available as data
    so it could be displayed without hardcoding the name inside the test body.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的测试函数实际上并不知道自己的名称。我们希望测试有一个名称以便于识别，但这个名称真的需要是函数的名称吗？如果这个名称可以作为数据提供，以便在测试体内部不硬编码名称的情况下显示，那就更好了。
- en: Equally, the current test function doesn’t have any idea of success or failure.
    We purposefully ignored the test result until now, but let’s think about it. Is
    it enough for a test function to return the status? Maybe it needs a `bool` return
    type where true would mean success and false would mean the test failed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当前的测试函数对成功或失败没有任何概念。我们故意忽略了测试结果，直到现在，但让我们考虑一下。一个测试函数返回状态是否足够？也许它需要一个`bool`返回类型，其中`true`表示成功，而`false`表示测试失败。
- en: That might be a bit too simplistic. Sure, it would be enough for now, but if
    a test fails, it might be good to know why. A `bool` return type won’t be enough
    later. Instead of designing the entire solution, we just need to figure out what
    to do that will meet the expected needs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能有点过于简单化了。当然，现在可能足够了，但如果测试失败，了解失败的原因可能就很重要了。仅仅返回`bool`类型在以后可能就不够了。我们不需要设计整个解决方案，只需要弄清楚要做什么才能满足预期的需求。
- en: Since we already know that we need some data to hold the test name, what if
    we now add simple `bool` result data in the same place? This would let us keep
    the test function return type as `void`, and it leaves room for a more advanced
    solution later.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道我们需要一些数据来保存测试名称，那么我们现在是否可以在相同的位置添加简单的`bool`结果数据呢？这样我们可以保持测试函数的返回类型为`void`，并为以后更高级的解决方案留出空间。
- en: 'Let’s change the test function into a `operator(``)`, as this code shows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将测试函数改为`operator()`，如下所示：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The biggest problem with this is that we no longer have a simple way to write
    a test as if it was a simple function. By providing `operator ()`, or *function
    call operator*, we created a functor that will let us call the class as if it
    was a function from within the `main` function. However, it’s more code to write.
    It solves the problem of the test name, gives us a simple solution for the result,
    which can be expanded later, and also solves another problem that wasn’t obvious
    before.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的最大问题是，我们不再有简单的方式来编写一个测试，就像它是一个简单的函数一样。通过提供`operator ()`，或者称为*函数调用操作符*，我们创建了一个可以让我们在`main`函数内部将类当作函数来调用的函数对象。然而，这需要编写更多的代码。它解决了测试名称的问题，为我们提供了一个简单的解决方案，这个方案可以稍后扩展，并且还解决了之前不明显的问题。
- en: When we called the test function in `main` before, we had to call it by the
    function name. That’s how functions are called in code, right? This new design
    eliminates that coupling by creating an instance of the `Test` functor called
    `test`. Now, `main` doesn’t care about the test name. It only refers to the instance
    of the functor. The only place in which the name of the test now appears in the
    code is when the functor instance is created.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前在`main`函数中调用测试函数时，我们必须通过函数名来调用它。这是代码中调用函数的方式，对吧？这种新的设计通过创建一个名为`test`的`Test`函数对象的实例来消除这种耦合。现在，`main`不再关心测试名称。它只引用函数对象的实例。测试名称现在在代码中唯一出现的地方是在创建函数对象实例时。
- en: We can fix the problem of all the extra code needed to write a test by using
    a *macro*. Macros are not needed in C++ as they used to be and some people might
    even think that they should be removed from the language entirely. They do have
    a couple of good uses left and *wrapping up code* into a macro is one of them.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用*宏*来解决编写测试时所需的所有额外代码问题。宏在C++中不再像以前那样需要，有些人甚至认为应该从语言中完全移除它们。它们仍然有一些好的用途，将代码*封装*到宏中就是其中之一。
- en: We’ll eventually put the macro definition into a separate header file, which
    will become the test library. What we want to do is wrap up all the functor code
    in the macro but leave the implementation of the actual test function body to
    be written as if everything was a normal function.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终会将宏定义放入一个单独的头文件中，这将成为测试库。我们想要做的是在宏中将所有函数对象代码封装起来，但将实际测试函数体的实现留给像正常函数一样编写。
- en: 'First, we’ll make a simple change to move the implementation of the test function
    body outside of the class definition, like this. The function call operator is
    the method that needs to be moved outside:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将对测试函数体的实现进行简单的修改，将其移出类定义之外，如下所示。需要移出的方法是函数调用操作符：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, the class definition, instance declaration, and first line of the function
    call operator can be turned into a macro. Compare the following code with the
    previous code to see how the `Test` class is turned into the `TEST` macro. By
    itself, this macro would not compile because it leaves the function call operator
    in an unfinished state. That’s exactly what we want because it lets the code use
    the macro like a function signature declaration and finish it up by providing
    the code inside the curly braces:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，类定义、实例声明和函数调用操作符的第一行可以被转换成一个宏。将以下代码与之前的代码进行比较，看看`Test`类是如何被转换成`TEST`宏的。仅凭这个宏本身是无法编译的，因为它将函数调用操作符留在了未完成的状态。这正是我们想要的，因为它允许代码像函数签名声明一样使用宏，并通过提供花括号和方法的实现来完成它：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Because the macro is defined over multiple lines, each line except the last
    needs to end with a backslash. The macro is a little more compact because the
    empty lines have been removed. This is a personal choice and you can leave the
    empty lines if you want. An empty line still needs the backslash though, which
    defeats the purpose of having an empty line.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因为宏定义跨越多行，除了最后一行之外，每一行都需要以反斜杠结尾。由于删除了空行，这个宏变得更加紧凑。这是一个个人选择，如果你想的话可以保留空行。但是，空行仍然需要反斜杠，这违背了保留空行的目的。
- en: The code uses the `TEST` macro with the unfinished function call operator just
    like a function definition, but then it completes the code by providing the curly
    braces and method implementation needed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用`TEST`宏和未完成的函数调用操作符，就像函数定义一样，然后通过提供花括号和方法实现来完成代码。
- en: 'We’re making progress! It might be hard to see it because everything is in
    a single file. Let’s fix that by creating a new file called `Test.h` and moving
    the macro definition to the new file, like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在取得进展！可能很难看到，因为所有内容都在一个文件中。让我们通过创建一个名为 `Test.h` 的新文件并将宏定义移动到新文件来解决这个问题，如下所示：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we can go back to simpler code in `main.cpp`, like this next block of
    code shows. All we need to do is include `Test.h` and we can use the macro:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以回到 `main.cpp` 中的简单代码，如下所示的下一段代码所示。我们只需要包含 `Test.h` 并使用宏：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We now have something that’s beginning to look like the simple function we started
    with, but there’s a lot of code hidden inside the `TEST` macro to make it seem
    simple.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一些开始看起来像我们最初开始时的简单函数，但 `TEST` 宏内部隐藏了大量的代码，使其看起来简单。
- en: In the next section, we’ll fix the need for `main` to call `test()` directly.
    The name of the functor, `test`, is a detail that should not be known outside
    of the macro, and we definitely shouldn’t need to call a test directly to run
    it, no matter what it’s called.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将解决 `main` 直接调用 `test()` 的需求。函数名 `test` 是一个不应该在宏之外知道细节，我们绝对不需要直接调用一个测试来运行它，无论它叫什么名字。
- en: How can we use C++ to write tests?
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们如何使用 C++ 编写测试？
- en: Calling the test directly might not seem like a big problem right now because
    we only have one test. However, as more tests are added, the need to call each
    one from `main` will lead to problems. Do you really want to have to modify the
    `main` function every time you add or remove a test?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 直接调用测试可能现在看起来不是什么大问题，因为我们只有一个测试。然而，随着测试数量的增加，需要从 `main` 中逐个调用每个测试的需求将导致问题。你真的希望每次添加或删除测试时都要修改
    `main` 函数吗？
- en: The C++ language doesn’t have a way to add extra custom information to a function
    or a class that could be used to identify all the tests. So, there is no way to
    look through all the code, find all the tests automatically, and run them.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 语言没有添加额外自定义信息到函数或类的方法，这些信息可以用来识别所有测试。因此，没有方法可以遍历所有代码，自动找到所有测试并运行它们。
- en: One of the tenets of C++ is to avoid adding language features that you might
    not need, especially language features that affect your code without your awareness.
    Other languages might let you do other things, such as adding custom attributes,
    which you can use to identify tests. C++ defines standard attributes, which are
    intended to help the compiler optimize code execution or improve the compilation
    of your code. The standard C++ attributes are not something that we can use to
    identify tests and custom attributes would go against the tenet of unneeded features.
    I like this about C++, even if it means that we have to work a little harder to
    figure out which tests to run.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 的一个原则是避免添加你可能不需要的语言特性，特别是那些在你不知情的情况下影响你代码的语言特性。其他语言可能允许你做其他事情，例如添加自定义属性，你可以使用这些属性来识别测试。C++
    定义了标准属性，这些属性旨在帮助编译器优化代码执行或改进代码的编译。标准的 C++ 属性不是我们可以用来识别测试的东西，而自定义属性将违反无需特性的原则。我喜欢
    C++ 的这一点，即使这意味着我们必须更努力地找出要运行的测试。
- en: All we need to do is let each test identify itself. This is different from writing
    code that would try to find the tests. Finding the tests requires that they be
    marked in some way, such as using an attribute, so that they stand out and this
    isn’t possible in C++. Instead of *finding them*, we can use the constructor of
    each test functor so that they *register themselves*. The constructor for each
    test will add itself to the registry by pushing a pointer to itself onto a collection.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的只是让每个测试能够识别自己。这与编写试图找到测试的代码不同。找到测试需要以某种方式标记它们，例如使用属性，以便它们突出显示，但在 C++ 中这是不可能的。我们不是去*找到它们*，而是可以使用每个测试函数的构造函数，使它们*注册自己*。每个测试的构造函数将通过将指向自己的指针推送到集合中，将自己添加到注册表中。
- en: Once all the tests are registered through addition to a collection, we can go
    through the collection and run them all. We already simplified the tests so that
    they can all be run in the same way.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有测试都通过添加到集合中进行了注册，我们就可以遍历集合并运行它们。我们已经简化了测试，以便它们都可以以相同的方式运行。
- en: There’s just one complication that we need to be careful about. The test instances
    that are created in the `TEST` macro are global variables and can be spread out
    over many different source files. Right now, we have a single test declared in
    a single `main.cpp` source file. We’ll need to make sure that the collection that
    will eventually hold all the registered tests is set up and ready to hold the
    tests before we start trying to add tests to the collection. We’ll use a function
    to help coordinate the setup. This is the `getTests` function, shown in the following
    code. The way `getTests` works is not obvious and is described in more detail
    after the next code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要注意的一个复杂问题是。在 `TEST` 宏中创建的测试实例是全局变量，并且可以分布在许多不同的源文件中。目前，我们在单个 `main.cpp`
    源文件中声明了一个测试。我们需要确保在开始尝试将测试添加到集合之前，将最终包含所有已注册测试的集合设置好并准备好。我们将使用一个函数来帮助协调设置。这是 `getTests`
    函数，如下所示。`getTests` 的工作方式并不明显，将在下一部分代码之后进行更详细的描述。
- en: Now is also a good time to start thinking about a `MereTDD`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在也是开始考虑 `MereTDD` 的好时机。
- en: 'Here is the first part of the `Test.h` file with the new namespace and registration
    code added. We should also update the `include` guard to something more specific,
    such as `MERETDD_TEST_H`, like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Test.h` 文件的第一部分，其中添加了新的命名空间和注册代码。我们还应该更新 `include` 守卫，使其更加具体，例如 `MERETDD_TEST_H`，如下所示：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Inside the namespace, there is a new `TestInterface` class declared with a `run`
    method. I decided to move away from a functor and to this new design because when
    we need to actually run the test later, it looks more intuitive and understandable
    to have a method called `run`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名空间内部，声明了一个新的 `TestInterface` 类，其中包含一个 `run` 方法。我决定放弃使用函数式对象，转而采用这种新设计，因为当我们需要稍后实际运行测试时，有一个名为
    `run` 的方法看起来更直观、更容易理解。
- en: The collection of tests is stored in a *vector* of `TestInterface` *pointers*.
    This is a good place to use raw pointers because there is no ownership implied.
    The collection will not be responsible for deleting these pointers. The vector
    is declared as a *static* variable inside the `getTests` function. This is to
    make sure that the vector is properly initialized, even if it is first accessed
    from another `.cpp` source file compilation unit.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 测试集合存储在一个 `TestInterface` 指针的 *vector* 中。这是一个使用原始指针的好地方，因为没有隐含的所有权。集合将不会负责删除这些指针。向量在
    `getTests` 函数内部声明为 *静态* 变量。这是为了确保向量得到适当的初始化，即使它首先是从另一个 `.cpp` 源文件编译单元访问的。
- en: C++ language makes sure that *global variables* are initialized before `main`
    begins. That means we have code in the `test` instance constructors that get run
    before `main` begins. When we have multiple `.cpp` files later, making sure that
    the collection is initialized first becomes important. If the collection is a
    normal global variable that is accessed directly from another compilation unit,
    then it could be that the collection is not yet ready when the test tries to push
    itself onto the collection. Nevertheless, by going through the `getTests` function,
    we avoid the readiness issue because the compiler will make sure to initialize
    the static vector the *first time that the function is called*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 语言确保在 `main` 开始之前初始化 *全局变量*。这意味着我们在 `test` 实例构造函数中有代码在 `main` 开始之前运行。当我们有多个
    `.cpp` 文件时，确保集合首先初始化变得很重要。如果集合是一个普通的全局变量，并且直接从另一个编译单元访问，那么可能是在测试尝试将自己推送到集合时，集合尚未准备好。尽管如此，通过通过
    `getTests` 函数，我们避免了准备就绪问题，因为编译器将确保在 *函数第一次被调用时* 初始化静态向量。
- en: 'We need to scope references to classes and functions declared inside the namespace
    anytime they are used within the macro. Here is the last part of `Test.h`, with
    changes to the macro to use the namespace:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在宏中使用时，将类和函数的引用限制在命名空间内。以下是 `Test.h` 的最后一部分，其中对宏进行了修改以使用命名空间：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `Test` constructor now registers itself by calling `getTests` and pushing
    back a pointer to itself to the vector it gets. It doesn’t matter which `.cpp`
    file is being compiled now. The collection of tests will be fully initialized
    once `getTests` returns the vector.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Test` 构造函数现在通过调用 `getTests` 并将指向自身的指针推回到它获得的向量中来注册自己。现在编译的是哪个 `.cpp` 文件并不重要。一旦
    `getTests` 返回向量，测试集合将被完全初始化。'
- en: The `TEST` macro remains outside of the namespace because it doesn’t get compiled
    here. It only gets inserted into other code whenever the macro is used. That’s
    why inside the macro, it now needs to qualify `TestInterface` and the `getTests`
    call with the `MereTDD` namespace.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`TEST` 宏仍然位于命名空间之外，因为它在这里不会被编译。它只有在宏被使用时才会被插入到其他代码中。这就是为什么在宏内部，现在需要使用 `MereTDD`
    命名空间来限定 `TestInterface` 和 `getTests` 调用的原因。'
- en: 'Inside `main.cpp`, the only change is how to call the test. We no longer refer
    to the test instance directly and now iterate through all the tests and call `run`
    for each one. This is the reason I decided to use a method called `run` instead
    of the function call operator:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main.cpp` 中，唯一的变化是如何调用测试。我们不再直接引用测试实例，而是遍历所有测试并对每个测试调用 `run`。这就是我决定使用名为 `run`
    的方法而不是函数调用操作符的原因：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can simplify this even more. The code in `main` seems like it needs to know
    too much about how the tests are run. Let’s create a new function called `runTests`
    to hold the `for` loop. We might later need to enhance the `for` loop and this
    seems like it should be internal to the test library. Here is what `main` should
    look like now:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步简化这一点。`main` 中的代码似乎需要了解太多关于测试如何运行的信息。让我们创建一个名为 `runTests` 的新函数来包含 `for`
    循环。我们可能以后需要增强 `for` 循环，这似乎应该是测试库内部的。以下是 `main` 现在应该看起来像什么：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can enable this change by adding the `runTests` function to `Test.h` inside
    the namespace, like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在命名空间内添加 `runTests` 函数来启用此更改，如下所示：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After all these changes, we have a simplified `main` function that just calls
    on the test library to run all the tests. It doesn’t know anything about which
    tests are run or how. Even though we still have a single test, we’re creating
    a solid design that will support multiple tests.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些更改之后，我们有一个简化的 `main` 函数，它只是调用测试库来运行所有测试。它对运行了哪些测试或如何运行一无所知。尽管我们仍然只有一个测试，但我们正在创建一个能够支持多个测试的坚实设计。
- en: The next section explains how you will use tests by looking at the first test.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将解释如何通过查看第一个测试来使用测试。
- en: How will the first test be used?
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首个测试将如何被使用？
- en: So far, we have a single test that outputs its name when run, and this test
    is declared inside of `main.cpp`. This is not how you’ll want to declare your
    tests going forward. I’ve mentioned having multiple `.cpp` files with multiple
    tests in each one. We’re not ready for that yet but we can at least move the single
    test that we have into its own `.cpp` file.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个在运行时输出其名称的单个测试，并且这个测试是在 `main.cpp` 内部声明的。这不是你未来想要声明测试的方式。我提到了拥有多个
    `.cpp` 文件，每个文件中都有多个测试。我们还没有准备好这样做，但我们至少可以将我们拥有的单个测试移动到它自己的 `.cpp` 文件中。
- en: The whole point of declaring multiple tests in multiple `.cpp` files is to help
    organize your tests. Group them into something meaningful. We’ll get to multiple
    tests later. For now, what is the purpose of our single test?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个 `.cpp` 文件中声明多个测试的整个目的是为了帮助你组织测试。将它们组合成有意义的类别。我们稍后会讨论多个测试。现在，我们单次测试的目的是什么？
- en: It is supposed to show that a test can be created. There may be other aspects
    of test creation that we’ll be interested in. So, it might make sense to create
    a `.cpp` file focused on test creation. Inside this `.cpp` file would be all the
    tests relating to *different ways to create tests*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这本应表明可以创建测试。我们可能对测试创建的其他方面也感兴趣。因此，创建一个专注于测试创建的 `.cpp` 文件可能是有意义的。在这个 `.cpp` 文件中，将包含所有与
    *创建测试的不同方式* 相关的测试。
- en: You can organize your tests however you want. If you have a project you are
    working on that has its own set of source files, it might make sense to group
    your tests around the source files. So, you would have a test `.cpp` file with
    many tests inside, which are all designed to test everything related to a `.cpp`
    file from your actual project. This would make sense if your project files were
    already organized well.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按照自己的意愿组织测试。如果你正在处理一个拥有自己源文件集的项目，那么围绕源文件组织测试可能是有意义的。因此，你将会有一个包含许多测试的测试 `.cpp`
    文件，这些测试都是为了测试你实际项目中的 `.cpp` 文件相关的所有内容。如果你的项目文件已经组织得很好，这样做是有意义的。
- en: Or, you might take a more functional approach to organizing your tests. Since
    we only have a single header file called `Test.h` that we need to test, instead
    of also creating a single `.cpp` file to hold all the tests, let’s take a functional
    approach and split the tests based on their purpose.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可能采取一种更函数式的方法来组织你的测试。由于我们只有一个名为 `Test.h` 的头文件需要测试，而不是也创建一个包含所有测试的单个 `.cpp`
    文件，让我们采取一种函数式方法，根据测试的目的来分割测试。
- en: Let’s add a new `.cpp` file to the project called `Creation.cpp` and move the
    single test that we have so far into the new file. At the same time, let’s think
    for a moment about how we will use the test library later on.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在项目中添加一个新的`.cpp`文件，命名为`Creation.cpp`，并将迄今为止的单个测试移动到新文件中。同时，让我们思考一下我们将来如何使用测试库。
- en: What we’re building is not really a library that gets compiled and linked into
    another project. It’s just a single header file called `Test.h`, which other projects
    can include. It’s still a library, just one that gets compiled alongside the other
    project.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建的并不是一个会被编译并链接到其他项目的库。它只是一个名为`Test.h`的单个头文件，其他项目可以包含它。它仍然是一个库，只是它会在其他项目旁边编译。
- en: We can even start treating the tests we have now this way. In the project structure,
    we have `Test.h` and `main.cpp` so far. The `main.cpp` file is similar to that
    of the test project that is intended to test the `Test.h` include file. Let’s
    reorganize the project structure so that both `main.cpp` and the new `Creation.cpp`
    files are in a folder called `tests`. These will form the basis for a testing
    executable that exercises all the tests needed to test `Test.h`. In other words,
    we’re turning the console project that we have into a test project designed to
    test the test library. The test library is not a separate project because it’s
    just a single header file that will be included as part of other projects.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以开始以这种方式处理我们现在的测试。在项目结构中，我们目前有`Test.h`和`main.cpp`。`main.cpp`文件类似于旨在测试`Test.h`包含文件的测试项目。让我们重新组织项目结构，使得`main.cpp`和新的`Creation.cpp`文件都在一个名为`tests`的文件夹中。这些将形成测试可执行文件的基础，该可执行文件将执行所有测试以测试`Test.h`。换句话说，我们正在将我们拥有的控制台项目转变为一个测试项目，该测试项目旨在测试测试库。测试库不是一个独立的项目，因为它只是一个作为其他项目一部分被包含的单个头文件。
- en: Later on, in other projects of your own, you can do the same thing. You’ll have
    your primary project with all its source files. You’ll also have another test
    project in a subfolder called `tests` with its own `main.cpp` and all the test
    files. Your test project will include `Test.h` from the test library but it won’t
    be trying to test the test library as we’re doing here. It will instead be focused
    on testing your own project in the primary project folder. You’ll see how all
    this works once we get the test library to a suitable state so that it can be
    used to create a different project. We’ll be creating a logging library in *Part
    2*, *Logging Library*. The logging library will have a subfolder called `tests`,
    as I just described.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在以后的项目中，你也可以做同样的事情。你将有一个包含所有源文件的主要项目。你还将有一个名为`tests`的子文件夹中的另一个测试项目，其中包含自己的`main.cpp`和所有测试文件。你的测试项目将包含测试库中的`Test.h`，但它不会尝试像我们现在这样测试测试库。它将专注于在主要项目文件夹中测试自己的项目。一旦我们将测试库调整到适合使用以创建不同项目的状态，你将看到这一切是如何工作的。在第二部分，我们将创建一个日志库，名为`Logging
    Library`。日志库将有一个名为`tests`的子文件夹，正如我刚才描述的那样。
- en: 'Turning back to what we have now, let’s reorganize the overall project structure
    for the test library. You can create the `tests` folder and move `main.cpp` into
    it. Make sure to place the new `Creation.cpp` file into the `tests` folder. The
    project structure should look like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们现在的情况，让我们重新组织测试库的整体项目结构。你可以创建一个`tests`文件夹，并将`main.cpp`移动到其中。确保将新的`Creation.cpp`文件放入`tests`文件夹。项目结构应该看起来像这样：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `main.cpp` file can be simplified like this by removing the test and leaving
    only `main`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.cpp`文件可以通过移除测试并仅保留`main`来简化如下：'
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, the new `Creation.cpp` file only contains the single test we have so far,
    like so:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，新的`Creation.cpp`文件只包含迄今为止的单个测试，如下所示：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'However, building the project like so now gives a linker error, because we
    are including `Test.h` in both the `main.cpp` and the `Creation.cpp` compilation
    units. As a result, we have two methods that result in duplicate symbols. In order
    to remove the duplicate symbols, we need to declare both `getTests` and `runTests`
    to be inline, like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在以这种方式构建项目会导致链接错误，因为我们同时在`main.cpp`和`Creation.cpp`编译单元中包含`Test.h`。结果，我们有两个方法会产生重复的符号。为了删除重复的符号，我们需要将`getTests`和`runTests`都声明为内联，如下所示：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, everything builds and runs again and we get the same result as before.
    The output displays the name of the single test we have so far:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一切又重新构建并运行，我们得到了之前相同的结果。输出显示了迄今为止的单个测试名称：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The output remains unchanged from before. We haven’t added any more tests or
    changed what the current test does. We have changed how the tests are registered
    and run, and we have reorganized the project structure.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与之前保持不变。我们没有添加更多测试或更改当前测试的功能。我们改变了测试的注册和运行方式，并对项目结构进行了重组。
- en: Summary
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has introduced the test library, which consists of a single header
    file called `Test.h`. It has also shown us how to create a test project, which
    is a console application that will be used to test the test library.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了测试库，它由一个名为 `Test.h` 的单个头文件组成。它还向我们展示了如何创建一个测试项目，这是一个控制台应用程序，将用于测试测试库。
- en: We have seen how this has evolved from a simple function into a test library
    that knows how to register and run tests. It’s not ready yet. We still have a
    way to go before the test library can be used in a TDD process to help you design
    and test your own projects.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，它如何从简单的函数发展成为一个知道如何注册和运行测试的测试库。它还没有准备好。在测试库可以在TDD过程中使用来帮助您设计和测试自己的项目之前，我们还有很长的路要走。
- en: By seeing how the test library evolves, you’ll come to understand how to use
    it in your own projects. In the next chapter, you’ll understand the challenges
    of adding multiple tests. There’s a reason why we only have a single test so far.
    Enabling multiple tests and reporting the results of the tests is what the next
    chapter will cover.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观察测试库的发展，您将了解如何在您的项目中使用它。在下一章中，您将了解添加多个测试的挑战。我们至今只有一个测试是有原因的。下一章将涵盖启用多个测试和报告测试结果的内容。
