- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Processes, Threads, and Services
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程、线程和服务
- en: Asynchronous programming involves initiating operations without waiting for
    them to complete before moving on to the next task. This non-blocking behavior
    allows for developing highly responsive and efficient applications, capable of
    handling numerous operations simultaneously without unnecessary delays or wasting
    computational resources waiting for tasks to be finished.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程涉及在不等待操作完成的情况下启动操作，然后再进行下一项任务。这种非阻塞行为允许开发出高度响应和高效的应用程序，能够同时处理大量操作，而无需不必要的延迟或浪费计算资源等待任务完成。
- en: Asynchronous programming is very important, especially in the development of
    networked applications, user interfaces, and systems programming. It enables developers
    to create applications that can manage high volumes of requests, perform **Input/Output**
    ( **I/O** ) operations, or execute concurrent tasks efficiently, thereby significantly
    enhancing user experience and application performance.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程非常重要，尤其是在网络应用、用户界面和系统编程的开发中。它使开发者能够创建能够管理大量请求、执行**输入/输出**（**I/O**）操作或高效执行并发任务的应用程序，从而显著提升用户体验和应用性能。
- en: The Linux operating system (in this book, we will focus on development on the
    Linux operating system when the code cannot be platform-independent), with its
    robust process management, native support for threading, and advanced I/O capabilities,
    is an ideal environment for developing high-performance asynchronous applications.
    These systems offer a rich set of features such as powerful APIs for process and
    thread management, non-blocking I/O, and **Inter-Process Communication** ( **IPC**
    ) mechanisms.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Linux操作系统（在本书中，当代码无法实现平台无关性时，我们将专注于Linux操作系统的开发），凭借其强大的进程管理、对线程的原生支持以及高级I/O能力，是开发高性能异步应用的理想环境。这些系统提供了一组丰富的功能，例如强大的进程和线程管理API、非阻塞I/O以及**进程间通信**（**IPC**）机制。
- en: This chapter is an introduction to the fundamental concepts and components essential
    for asynchronous programming within the Linux environment.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是介绍Linux环境中异步编程的基本概念和组件的入门。
- en: 'We will explore the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨以下主题：
- en: Processes in Linux
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux中的进程
- en: Services and daemons
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务和守护进程
- en: Threads and concurrency
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程和并发
- en: By the end of this chapter, you will possess a foundational understanding of
    the asynchronous programming landscape in Linux, setting the stage for deeper
    exploration and practical application in subsequent chapters.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将具备Linux异步编程领域的坚实基础理解，为后续章节的深入探索和实际应用奠定基础。
- en: Processes in Linux
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux中的进程
- en: A process can be defined as an instance of a running program. It includes the
    program’s code, all the threads belonging to this process (which are represented
    by the program counter), the stack (which is an area of memory containing temporary
    data such as function parameters, return addresses, and local variables), the
    heap, for memory allocated dynamically, and its data section containing global
    variables and initialized variables. Each process operates within its own virtual
    address space and is isolated from other processes, ensuring that its operations
    do not interfere directly with those of others.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 进程可以被定义为正在运行的程序的一个实例。它包括程序的代码、属于此进程的所有线程（由程序计数器表示）、堆栈（堆栈是一个包含临时数据如函数参数、返回地址和局部变量的内存区域）、堆（用于动态分配的内存），以及包含全局变量和初始化变量的数据段。每个进程在其自己的虚拟地址空间中运行，并且与其他进程隔离，确保其操作不会直接干扰其他进程。
- en: Process life cycle – creation, execution, and termination
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程生命周期——创建、执行和终止
- en: 'The life cycle of a process can be broken down into three primary stages: creation,
    execution, and termination:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 进程的生命周期可以分为三个主要阶段：创建、执行和终止：
- en: '**Creation** : A new process is created using the **fork()** system call, which
    creates a new process by duplicating an existing one. The parent process is the
    one that calls **fork()** , and the newly created process is the child. This mechanism
    is essential for the execution of new programs within the system and is a precursor
    to executing different tasks concurrently.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建**：使用**fork()**系统调用创建一个新的进程，该调用通过复制现有进程来创建新进程。调用**fork()**的进程是父进程，而新创建的进程是子进程。这种机制对于在系统中执行新程序至关重要，并且是并发执行不同任务的先决条件。'
- en: '**Execution** : After creation, the child process may execute the same code
    as the parent or use the **exec()** family of system calls to load and run a different
    program.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行**：在创建后，子进程可以执行与父进程相同的代码，或者使用**exec()**系列系统调用来加载并运行不同的程序。'
- en: 'If the parent process has more than one thread of execution, only the thread
    calling **fork()** is duplicated in the child process. Consequently, the child
    process contains a single thread: the one that executed the **fork()** system
    call.'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果父进程有多个执行线程，则只有调用**fork()**的线程在子进程中复制。因此，子进程包含一个线程：执行**fork()**系统调用的那个线程。
- en: Since only the thread that called **fork()** is copied to the child, any **Mutual
    Exclusions** ( **mutexes** ), condition variables, or other synchronization primitives
    that were held by other threads at the time of the fork remain in their then-current
    state in the parent but do not carry over to the child. This can lead to complex
    synchronization issues, as mutexes that were locked by other threads (which do
    not exist in the child) might remain in a locked state, potentially causing deadlocks
    if the child tries to unlock or wait on these primitives.
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于只有调用**fork()**的线程被复制到子进程中，因此在**fork()**发生时由其他线程持有的任何**互斥锁**（**mutexes**）、条件变量或其他同步原语将保持在其父进程中的当前状态，但不会传递到子进程中。这可能导致复杂的同步问题，因为被其他线程（在子进程中不存在）锁定的互斥锁可能保持锁定状态，如果子进程尝试解锁或等待这些原语，可能会造成死锁。
- en: At this stage, the process performs its designated operations such as reading
    from or writing to files and communicating with other processes.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个阶段，进程执行其指定的操作，如从文件中读取或写入文件以及与其他进程通信。
- en: '**Termination** : A process terminates either voluntarily, by calling the **exit()**
    system call, or involuntarily, due to receiving a signal from another process
    that causes it to stop. Upon termination, the process returns an exit status to
    its parent process and releases its resources back to the system.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**终止**：进程可以通过调用**exit()**系统调用来自愿终止，或者由于收到来自另一个进程的信号而被迫终止。在终止时，进程向其父进程返回退出状态并将其资源释放回系统。'
- en: The process life cycle is integral to asynchronous operations as it enables
    the concurrent execution of multiple tasks.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 进程生命周期对于异步操作至关重要，因为它使得多个任务可以并发执行。
- en: Each process is uniquely identified by a **Process ID** ( **PID** ), an integer
    that the kernel uses to manage processes. PIDs are used to control and monitor
    processes. Parent processes also use PIDs to communicate with or control the execution
    of child processes, such as waiting for them to terminate or sending signals.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都由一个唯一的**进程ID**（**PID**）标识，这是一个内核用来管理进程的整数。PID用于控制和监控进程。父进程也使用PID与子进程通信或控制其执行，例如等待其终止或发送信号。
- en: Linux provides mechanisms for process control and signaling, allowing processes
    to be managed and communicated with asynchronously. Signals are one of the primary
    means of IPC, enabling processes to interrupt or to be notified of events. For
    example, the **kill** command can send signals to stop a process or to prompt
    it to reload its configuration files.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Linux提供了进程控制和信号机制，允许进程异步地进行管理和通信。信号是IPC的主要手段之一，使得进程能够中断或被通知事件。例如，**kill**命令可以向进程发送信号以停止其运行或提示其重新加载配置文件。
- en: Process scheduling is how the Linux kernel allocates CPU time to processes.
    The scheduler determines which process runs at any given time, based on scheduling
    algorithms and policies that aim to optimize for factors such as responsiveness
    and efficiency. Processes can be in various states, such as running, waiting,
    or stopped, and the scheduler transitions them between these states to manage
    execution efficiently.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 进程调度是Linux内核如何分配CPU时间给进程的方式。调度程序根据旨在优化响应性和效率等因素的调度算法和政策，确定在任何给定时间运行哪个进程。进程可以处于各种状态，如运行、等待或停止，调度程序在它们之间转换状态以有效地管理执行。
- en: Exploring IPC
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索IPC
- en: In the Linux operating system, processes operate in isolation, meaning that
    they cannot directly access the memory space of other processes. This isolated
    nature of processes presents challenges when multiple processes need to communicate
    and synchronize their actions. To address these challenges, the Linux kernel provides
    a versatile set of IPC mechanisms. Each IPC mechanism is tailored to suit different
    scenarios and requirements, enabling developers to build complex, high-performance
    applications that leverage asynchronous processing effectively.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 操作系统中，进程是独立运行的，这意味着它们不能直接访问其他进程的内存空间。当多个进程需要通信和同步它们的行为时，这种进程的隔离性质会带来挑战。为了解决这些挑战，Linux
    内核提供了一套灵活的 IPC 机制。每种 IPC 机制都针对不同的场景和需求进行了定制，使开发者能够构建复杂、高性能的应用程序，并有效地利用异步处理。
- en: Understanding these IPC techniques is crucial for developers aiming to create
    scalable and efficient applications. IPC allows processes to exchange data, share
    resources, and coordinate their activities, facilitating smooth and reliable communication
    between different components of a software system. By utilizing the appropriate
    IPC mechanism, developers can achieve improved throughput, reduced latency, and
    enhanced concurrency in their applications, leading to better performance and
    user experiences.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些 IPC 技术对于旨在创建可扩展和高效应用的开发者至关重要。IPC 允许进程交换数据、共享资源并协调它们的活动，从而促进软件系统不同组件之间顺畅且可靠的通信。通过利用适当的
    IPC 机制，开发者可以在其应用程序中实现提高吞吐量、降低延迟和增强并发性，从而带来更好的性能和用户体验。
- en: In a multitasking environment, where multiple processes run concurrently, IPC
    plays a vital role in enabling the efficient and coordinated execution of tasks.
    For example, consider a web server application that handles multiple concurrent
    requests from clients. The web server process might use IPC to communicate with
    the child processes responsible for processing each request. This approach allows
    the web server to handle multiple requests simultaneously, improving the overall
    performance and scalability of the application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在多任务环境中，当多个进程并发运行时，IPC 在实现任务的高效和协调执行中起着至关重要的作用。例如，考虑一个处理来自客户端的多个并发请求的 Web 服务器应用程序。Web
    服务器进程可能会使用 IPC 与负责处理每个请求的子进程进行通信。这种方法允许 Web 服务器同时处理多个请求，从而提高应用程序的整体性能和可扩展性。
- en: Another common scenario where IPC is essential is in distributed systems or
    microservice architectures. In such environments, multiple independent processes
    or services need to communicate and collaborate to achieve a common goal. IPC
    mechanisms such as message queues and sockets or **Remote Procedure Calls** (
    **RPCs** ) enable these processes to exchange messages, invoke methods on remote
    objects, and synchronize their actions, ensuring seamless and reliable IPC.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: IPC 在分布式系统或微服务架构中也是一个至关重要的场景。在这样的环境中，多个独立的进程或服务需要通信和协作以实现共同的目标。如消息队列、套接字或**远程过程调用**（**RPCs**）等
    IPC 机制使这些进程能够交换消息、在远程对象上调用方法并同步它们的行为，确保 IPC 的无缝和可靠。
- en: By leveraging the IPC mechanisms provided by the Linux kernel, developers can
    design systems where multiple processes can work together harmoniously. This enables
    the creation of complex, high-performance applications that utilize system resources
    efficiently, handle concurrent tasks effectively, and scale to meet increasing
    demands effortlessly.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用 Linux 内核提供的 IPC 机制，开发者可以设计出多个进程能够和谐协作的系统。这使创建复杂、高性能的应用程序成为可能，这些应用程序能够高效地利用系统资源，有效地处理并发任务，并且能够轻松扩展以满足不断增长的需求。
- en: IPC mechanisms in Linux
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux 中的 IPC 机制
- en: Linux supports several IPC mechanisms, each with its unique characteristics
    and use cases.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 支持多种 IPC 机制，每种机制都有其独特的特性和用例。
- en: 'The fundamental IPC mechanisms supported by the Linux operating system include
    shared memory, which is commonly employed for process communication on a single
    server, and sockets, which facilitate inter-server communication. There are other
    mechanisms (which are briefly described here), but shared memory and sockets are
    the most commonly used:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 操作系统支持的 IPC 基本机制包括共享内存，它通常用于单个服务器上的进程通信，以及套接字，它促进了服务器间的通信。还有其他机制（在此简要描述），但共享内存和套接字是最常用的：
- en: '**Pipes and named pipes** : Pipes are one of the simplest forms of IPC, allowing
    for unidirectional communication between processes. A named pipe, or **First-in-First-out**
    ( **FIFO** ), extends this concept by providing a pipe that is accessible via
    a name in the filesystem, allowing unrelated processes to communicate.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管道和命名管道**：管道是IPC中最简单的一种形式，允许进程之间进行单向通信。命名管道，或称为**先进先出**（**FIFO**），通过提供一种可通过文件系统中的名称访问的管道来扩展这一概念，允许无关的进程进行通信。'
- en: '**Signals** : Signals are a form of software interrupt that can be sent to
    a process to notify it of events. While they are not a method for transferring
    data, signals are useful for controlling process behavior and triggering actions
    within processes.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信号**：信号是一种软件中断，可以向进程发送以通知其事件。虽然它们不是传输数据的方法，但信号对于控制进程行为和触发进程内的操作非常有用。'
- en: '**Message queues** : Message queues allow processes to exchange messages in
    a FIFO manner. Unlike pipes, message queues support asynchronous communication,
    whereby messages are stored in a queue and can be retrieved by the receiving process
    at its convenience.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息队列**：消息队列允许进程以先进先出（FIFO）的方式交换消息。与管道不同，消息队列支持异步通信，其中消息被存储在队列中，接收进程可以在方便的时候检索。'
- en: '**Semaphores** : Semaphores are used for synchronization, helping processes
    manage access to shared resources. They prevent race conditions by ensuring that
    only a specified number of processes can access a resource at any given time.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信号量**：信号量用于同步，帮助进程管理对共享资源的访问。它们通过确保在任何给定时间只有指定数量的进程可以访问资源来防止竞争条件。'
- en: '**Shared memory** : Shared memory is a fundamental concept in IPC that enables
    multiple processes to access and manipulate the same segment of physical memory.
    It offers a blazing-fast method for exchanging data between different processes,
    reducing the need for time-consuming data copying operations. This technique is
    particularly advantageous when dealing with large datasets or requiring high-speed
    communication. The mechanism of shared memory involves creating a shared memory
    segment, which is a dedicated portion of physical memory accessible by multiple
    processes. This shared memory segment is treated as a common workspace, allowing
    processes to read, write, and collaboratively modify data. To ensure data integrity
    and prevent conflicts, shared memory requires synchronization mechanisms such
    as semaphores or mutexes. These mechanisms regulate access to the shared memory
    segment, preventing multiple processes from simultaneously modifying the same
    data. This coordination is crucial to maintain data consistency and avoid overwriting
    or corruption.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享内存**：共享内存是IPC中的一个基本概念，它使多个进程能够访问和操作同一物理内存段。它提供了一种快速交换不同进程间数据的方法，减少了耗时数据复制操作的需求。当处理大型数据集或需要高速通信时，这种技术特别有利。共享内存的机制涉及创建一个共享内存段，这是多个进程可访问的物理内存的专用部分。这个共享内存段被视为一个公共工作区，允许进程读取、写入和协作修改数据。为确保数据完整性和防止冲突，共享内存需要同步机制，如信号量或互斥锁。这些机制调节对共享内存段的访问，防止多个进程同时修改相同的数据。这种协调对于维护数据一致性、避免覆盖或损坏至关重要。'
- en: Shared memory is often the preferred IPC mechanism in single-server environments
    where performance is paramount. Its primary advantage lies in its speed. Since
    data is directly shared in physical memory without the need for intermediate copying
    or context switching, it significantly reduces communication overhead and minimizes
    latency.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在性能至关重要的单服务器环境中，共享内存通常是首选的进程间通信（IPC）机制。其主要优势在于其速度。由于数据直接在物理内存中共享，无需中间复制或上下文切换，这显著减少了通信开销并最小化了延迟。
- en: However, shared memory also comes with certain considerations. It requires careful
    management to prevent race conditions and memory leaks. Processes accessing shared
    memory must adhere to well-defined protocols to ensure data integrity and avoid
    deadlocks. Additionally, shared memory is typically implemented as a system-level
    feature, requiring specific operating system support and potentially introducing
    platform-specific dependencies.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，共享内存也带来了一些考虑因素。它需要谨慎管理以防止竞争条件和内存泄漏。访问共享内存的进程必须遵守定义良好的协议，以确保数据完整性和避免死锁。此外，共享内存通常作为系统级功能实现，需要特定的操作系统支持，并可能引入平台特定的依赖。
- en: Despite these considerations, shared memory remains a powerful and widely used
    IPC technique, particularly in applications where speed and performance are critical
    factors.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管有这些考虑，共享内存仍然是一种强大且广泛使用的 IPC 技术，尤其是在速度和性能是关键因素的应用程序中。
- en: '**Sockets** : Sockets are a fundamental mechanism for IPC in operating systems.
    They provide a way for processes to communicate with each other, either within
    the same machine or across networks. Sockets are used to establish and maintain
    connections between processes, and they support both **connection-oriented** and
    **connectionless communication** .'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**套接字**：套接字是操作系统中进行 IPC 的基本机制。它们为进程之间相互通信提供了一种方式，无论是同一台机器内部还是跨网络。套接字用于建立和维护进程之间的连接，并支持
    **面向连接** 和 **无连接通信**。'
- en: Connection-oriented communication is a type of communication in which a reliable
    connection is established between two processes before any data is transferred.
    This type of communication is often used for applications such as file transfer
    and remote login, where it is important to ensure that all data is delivered reliably
    and in the correct order. Connectionless communication is a type of communication
    in which no reliable connection is established between two processes before data
    is transferred. This type of communication is often used for applications such
    as streaming media and real-time gaming, where it is more important to have low
    latency than to guarantee reliable delivery of all data.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 面向连接的通信是一种通信类型，在传输任何数据之前，在两个进程之间建立了一个可靠的连接。这种类型的通信通常用于文件传输和远程登录等应用程序，在这些应用程序中，确保所有数据可靠且按正确顺序交付非常重要。无连接通信是一种通信类型，在传输数据之前，在两个进程之间不建立可靠的连接。这种类型的通信通常用于流媒体和实时游戏等应用程序，在这些应用程序中，低延迟比保证所有数据的可靠交付更重要。
- en: Sockets are the backbone of networked applications. They are used by a wide
    variety of applications, including web browsers, email clients, and file-sharing
    applications. Sockets are also used by many operating system services, such as
    the **Network File System** ( **NFS** ) and the **Domain Name** **System** ( **DNS**
    ).
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 套接字是网络应用程序的骨干。它们被各种应用程序使用，包括网页浏览器、电子邮件客户端和文件共享应用程序。套接字也被许多操作系统服务使用，例如 **网络文件系统**（**NFS**）和
    **域名系统**（**DNS**）。
- en: 'Here are some of the key benefits of using sockets:'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是使用套接字的一些关键好处：
- en: '**Reliability** : Sockets provide a reliable way to communicate between processes,
    even when those processes are located on different machines.'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠性**：套接字提供了一种可靠的方式来在进程之间进行通信，即使这些进程位于不同的机器上。'
- en: '**Scalability** : Sockets can be used to support a large number of concurrent
    connections, making them ideal for applications that need to handle a lot of traffic.'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：套接字可以用来支持大量的并发连接，这使得它们非常适合需要处理大量流量的应用程序。'
- en: '**Flexibility** : Sockets can be used to implement a wide variety of communication
    protocols, making them suitable for a wide range of applications.'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：套接字可以用来实现各种通信协议，这使得它们适用于广泛的用途。'
- en: '**Use in IPC** : Sockets are a powerful tool for IPC. They are used by a wide
    variety of applications and are essential for building scalable, reliable, and
    flexible networked applications.'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在 IPC 中的应用**：套接字是 IPC 的强大工具。它们被广泛的应用程序使用，对于构建可扩展、可靠和灵活的网络应用程序至关重要。'
- en: Microservices-based applications are an example of asynchronous programming
    using different processes communicating between them in an asynchronous way. A
    simple example would be a log processor. Different processes generate log entries
    and send them to another process for further processing such as special formatting,
    deduplication, and statistics. The producers just send the lines of the log without
    waiting for any reply from the process they are sending to the log.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 基于微服务应用程序是异步编程的一个例子，使用不同的进程以异步方式相互通信。一个简单的例子就是一个日志处理器。不同的进程生成日志条目并将它们发送到另一个进程进行进一步处理，例如特殊格式化、去重和统计。生产者只需发送日志行，而不需要等待它们发送到日志的进程的任何回复。
- en: In this section, we saw processes in Linux, their life cycles, and how IPC is
    implemented by the operating system. In the next section, we will introduce a
    special kind of Linux process called **daemons** .
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了 Linux 中的进程、它们的生命周期以及操作系统如何实现进程间通信（IPC）。在下一节中，我们将介绍一种特殊的 Linux 进程，称为
    **守护进程**。
- en: Services and daemons in Linux
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux 中的服务和守护进程
- en: In the realm of Linux operating systems, daemons are a fundamental component
    that runs quietly in the background, silently executing essential tasks without
    the direct involvement of an interactive user. These processes are traditionally
    identified by their names ending with the letter *d* , such as **sshd** for the
    **Secure Shell** ( **SSH** ) daemon and **httpd** for the **web server daemon**
    . They play a vital role in handling system-level tasks crucial for both the operating
    system and the applications running on it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux操作系统领域，守护进程是运行在后台的基本组件，默默地执行关键任务，而不需要交互式用户的直接参与。这些进程传统上以其以字母*d*结尾的名称来识别，例如**sshd**代表**Secure
    Shell**（**SSH**）守护进程和**httpd**代表**Web服务器守护进程**。它们在处理对操作系统及其上运行的应用程序都至关重要的系统级任务中发挥着至关重要的作用。
- en: 'Daemons serve an array of purposes, ranging from file serving, web serving,
    and network communications to logging and monitoring services. They are designed
    to be autonomous and resilient, starting at system boot and running continuously
    until the system is shut down. Unlike regular processes initiated and controlled
    by users, daemons possess distinct characteristics:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 守护进程服务于一系列目的，从文件服务、Web服务和网络通信到日志和监控服务。它们被设计成自主和弹性，在系统启动时启动，并持续运行直到系统关闭。与由用户启动和控制的常规进程不同，守护进程具有独特的特征：
- en: '**Background operation** :'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后台操作**：'
- en: Daemons operate in the background
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 守护进程在后台运行
- en: They lack a controlling terminal for direct user interaction
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们缺乏控制终端以进行直接用户交互
- en: They do not require a user interface or manual intervention to perform their
    tasks
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不需要用户界面或手动干预来执行任务
- en: '**User independence** :'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户独立性**：'
- en: Daemons operate independently of user sessions
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 守护进程独立于用户会话运行
- en: They function autonomously without direct user involvement
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们无需直接用户参与即可自主运行
- en: They wait for system events or specific requests to trigger their actions
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们等待系统事件或特定请求来触发它们的操作
- en: '**Task-oriented focus** :'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面向任务的焦点**：'
- en: Each daemon is tailored to execute a specific task or a set of tasks
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个守护进程都针对执行特定任务或一系列任务而定制
- en: They are designed to handle specific functions or listen for particular events
    or requests
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们被设计来处理特定功能或监听特定事件或请求
- en: This ensures efficient task execution
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这确保了任务执行的效率
- en: 'Creating a daemon process involves more than merely running a process in the
    background. To ensure effective operation as a daemon, developers must consider
    several key steps:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 创建守护进程过程不仅仅是运行一个后台进程。为了确保作为守护进程的有效运行，开发者必须考虑几个关键步骤：
- en: '**Detaching from the terminal** : The **fork()** system call is employed to
    detach the daemon from the terminal. The parent process exits after the fork,
    leaving the child process running in the background.'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**脱离终端**：`fork()`系统调用用于使守护进程脱离终端。在fork之后，父进程退出，留下子进程在后台运行。'
- en: '**Session creation** : The **setsid()** system call creates a new session and
    designates the calling process as the leader of both the session and the process
    group. This step is crucial for complete detachment from the terminal.'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**会话创建**：`setsid()`系统调用创建一个新的会话，并将调用进程指定为会话和进程组的领导者。这一步对于完全脱离终端至关重要。'
- en: '**Working directory change** : To prevent blocking the unmounting of the filesystem,
    daemons typically change their working directory to the root directory.'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**工作目录更改**：为了防止阻止文件系统的卸载，守护进程通常将其工作目录更改为根目录。'
- en: '**File descriptor handling** : Inherited file descriptors are closed by daemons,
    and **stdin** , **stdout** , and **stderr** are often redirected to **/dev/null**
    .'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**文件描述符处理**：守护进程关闭继承的文件描述符，并且通常将**stdin**、**stdout**和**stderr**重定向到**/dev/null**。'
- en: '**Signal handling** : Proper handling of signals, such as **SIGHUP** for configuration
    reloading or **SIGTERM** for graceful shutdown, is essential for effective daemon
    management.'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**信号处理**：正确处理信号，例如用于配置重新加载的**SIGHUP**或用于优雅关闭的**SIGTERM**，对于有效的守护进程管理至关重要。'
- en: Daemons communicate with other processes or daemons through various IPC mechanisms.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 守护进程通过各种IPC机制与其他进程或守护进程进行通信。
- en: 'Daemons are integral to the architecture of many asynchronous systems, providing
    essential services without direct user interaction. Some prominent use cases of
    daemons include the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 守护进程是许多异步系统架构的组成部分，提供基本服务而不需要直接用户交互。以下是一些守护进程的突出用例：
- en: '**Web servers** : Daemons such as **httpd** and nginx serve web pages in response
    to client requests, handling multiple requests concurrently and ensuring seamless
    web browsing.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web服务器**：如**httpd**和nginx之类的守护进程响应客户端请求提供网页服务，处理多个并发请求并确保无缝的网页浏览。'
- en: '**Database servers** : Daemons such as mysqld and postgresql manage database
    services, allowing for asynchronous access and manipulation of databases by various
    applications.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库服务器**：如mysqld和postgresql之类的守护进程管理数据库服务，允许各种应用程序异步访问和操作数据库。'
- en: '**File servers** : Daemons such as **smbd** and **nfsd** provide networked
    file services, enabling asynchronous file sharing and access across different
    systems.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件服务器**：如**smbd**和**nfsd**之类的守护进程提供网络化文件服务，使不同系统之间的异步文件共享和访问成为可能。'
- en: '**Logging and monitoring** : Daemons such as **syslogd** and **snmpd** collect
    and log system events, providing asynchronous monitoring of system health and
    performance.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志和监控**：如**syslogd**和**snmpd**之类的守护进程收集和记录系统事件，提供对系统健康和性能的异步监控。'
- en: In summary, daemons are essential components of Linux systems, silently performing
    critical tasks in the background to ensure smooth system operation and efficient
    application execution. Their autonomous nature and resilience make them indispensable
    for maintaining system stability and providing essential services to users and
    applications.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，守护进程是Linux系统中的关键组件，在后台默默执行关键任务，以确保系统平稳运行和应用程序高效执行。它们的自主性和弹性使它们对于维护系统稳定性和向用户和应用程序提供基本服务至关重要。
- en: We have seen processes and demons, a special type of process. A process can
    have one or more threads of execution. In the next section, we will be introducing
    threads.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了进程和守护进程，这是一种特殊的进程类型。一个进程可以有一个或多个执行线程。在下一节中，我们将介绍线程。
- en: Threads
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程
- en: Processes and threads represent two fundamental ways of executing code concurrently,
    but they differ significantly in their operation and resource management. A process
    is an instance of a running program that owns its private set of resources, including
    memory, file descriptors, and execution context. Processes are isolated from each
    other, providing robust stability across the system since the failure of one process
    generally does not affect others.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 进程和线程代表了两种基本的并发执行代码的方式，但它们在操作和资源管理方面存在显著差异。进程是运行程序的实例，拥有自己的私有资源集合，包括内存、文件描述符和执行上下文。进程之间是隔离的，这为系统提供了强大的稳定性，因为一个进程的失败通常不会影响其他进程。
- en: Threads are a fundamental concept in computer science, representing a lightweight
    and efficient way to execute multiple tasks within a single process. In contrast
    to processes, which are independent entities with their own private memory space
    and resources, threads are closely intertwined with the process they belong to.
    This intimate relationship allows threads to share the same memory space and resources,
    including file descriptors, heap memory, and any other global data structures
    allocated by the process.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是计算机科学中的一个基本概念，代表了在单个进程中执行多个任务的轻量级和高效方式。与拥有自己私有内存空间和资源的独立实体进程不同，线程与其所属的进程紧密相连。这种亲密关系使得线程可以共享相同的内存空间和资源，包括文件描述符、堆内存以及进程分配的任何其他全局数据结构。
- en: One of the key advantages of threads is their ability to communicate and share
    data efficiently. Since all threads within a process share the same memory space,
    they can directly access and modify common variables without the need for complex
    IPC mechanisms. This shared environment enables rapid data exchange and facilitates
    the implementation of concurrent algorithms and data structures.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 线程的一个关键优势是它们能够有效地进行通信和共享数据。由于进程内的所有线程共享相同的内存空间，它们可以直接访问和修改公共变量，而无需复杂的IPC机制。这种共享环境使得数据交换迅速，并促进了并发算法和数据结构的实现。
- en: However, sharing the same memory space also introduces the challenge of managing
    access to shared resources. To prevent data corruption and ensure the integrity
    of shared data, threads must employ synchronization mechanisms such as locks,
    semaphores, or mutexes. These mechanisms enforce rules and protocols for accessing
    shared resources, ensuring that only one thread can access a particular resource
    at any given time.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，共享相同的内存空间也引入了管理对共享资源访问的挑战。为了防止数据损坏并确保共享数据的一致性，线程必须采用同步机制，例如锁、信号量或互斥锁。这些机制强制执行访问共享资源的规则和协议，确保在任何给定时间只有一个线程可以访问特定的资源。
- en: Effective synchronization is crucial in multithreaded programming to avoid race
    conditions, deadlocks, and other concurrency-related issues.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程编程中，有效的同步至关重要，以避免竞争条件、死锁和其他并发相关的问题。
- en: To address these challenges, various synchronization primitives and techniques
    have been developed. These include mutexes, which provide exclusive access to
    a shared resource, semaphores, which allow for controlled access to a limited
    number of resources, and condition variables, which enable threads to wait for
    specific conditions to be met before proceeding.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这些挑战，已经开发出各种同步原语和技术。这些包括互斥锁，它提供对共享资源的独占访问，信号量，它允许对有限数量的资源进行受控访问，以及条件变量，它使线程能够在满足特定条件之前等待。
- en: By carefully managing synchronization and employing appropriate concurrency
    patterns, developers can harness the power of threads to achieve high performance
    and scalability in their applications. Threads are particularly well-suited for
    tasks that can be parallelized, such as image processing, scientific simulations,
    and web servers, where multiple independent computations can be executed concurrently.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仔细管理同步并采用适当的并发模式，开发者可以利用线程的强大功能，在他们的应用程序中实现高性能和可伸缩性。线程特别适合于可以并行化的任务，如图像处理、科学模拟和Web服务器，在这些任务中，可以并发执行多个独立的计算。
- en: Threads, as described previously, are system threads. This means that they are
    created and managed by the kernel. However, there are scenarios, which we will
    explore in depth in [*Chapter 8*](B22219_08.xhtml#_idTextAnchor164) , where we
    will require a multitude of threads. In such cases, the system might not have
    sufficient resources to create numerous system threads. The solution to this problem
    is the use of **user threads** . One approach to implementing user threads is
    through **coroutines** , which have been included in the C++ standard since C++20.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，线程是系统线程。这意味着它们是由内核创建和管理的。然而，存在一些场景，我们将在[*第8章*](B22219_08.xhtml#_idTextAnchor164)中深入探讨，在这些场景中，我们需要大量的线程。在这种情况下，系统可能没有足够的资源来创建大量的系统线程。解决这个问题的方法是使用**用户线程**。实现用户线程的一种方法是通过**协程**，自C++20以来，协程已被纳入C++标准。
- en: Coroutines are a relatively new feature in C++. Coroutines can be defined as
    functions that can be paused and resumed at specific points, allowing for cooperative
    multitasking within a single thread. Unlike standard functions that run from start
    to finish without interruption, coroutines can suspend their execution and yield
    control back to the caller, which can later resume the coroutine from the point
    it was paused.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是C++中相对较新的特性。协程可以被定义为可以在特定点暂停和恢复的函数，允许在单个线程内进行协作式多任务处理。与从开始到结束不间断运行的常规函数不同，协程可以挂起其执行并将控制权交还给调用者，调用者可以在稍后从暂停点恢复协程。
- en: Coroutines are much more lightweight than system threads. This means that they
    can be created and destroyed much more quickly, and that they require less overhead.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 协程比系统线程轻量得多。这意味着它们可以更快地创建和销毁，并且需要更少的开销。
- en: Coroutines are cooperative, which means that they must explicitly yield control
    to the caller in order to switch execution context. This can be a disadvantage
    in some cases, but it can also be an advantage, as it gives the user program more
    control over the execution of coroutines.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是协作式的，这意味着它们必须显式地将控制权交还给调用者，以便切换执行上下文。在某些情况下，这可能是一个缺点，但也可以是一个优点，因为它使用户程序对协程的执行有更多的控制。
- en: Coroutines can be used to create a variety of different concurrency patterns.
    For example, coroutines can be used to implement tasks, which are lightweight
    work units that can be scheduled and run concurrently. Coroutines can also be
    used to implement channels, which are communication channels that can pass data
    between them.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 协程可以用来创建各种不同的并发模式。例如，协程可以用来实现任务，这些是轻量级的工作单元，可以调度和并发运行。协程还可以用来实现通道，这些是可以在它们之间传递数据的通信通道。
- en: Coroutines can be classified into stackful and stackless categories. C++20 coroutines
    are stackless. We will see these concepts in depth in [*Chapter 8*](B22219_08.xhtml#_idTextAnchor164)
    .
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 协程可以分为有栈和无栈两类。C++20的协程是无栈的。我们将在[*第8章*](B22219_08.xhtml#_idTextAnchor164)中深入探讨这些概念。
- en: Overall, coroutines are a powerful tool for creating concurrent programs in
    C++. They are lightweight, cooperative, and can be used to implement a variety
    of different concurrency patterns. They cannot be used to implement parallelism
    entirely because coroutines still need CPU execution context, which can be only
    provided by a thread.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，协程是创建 C++ 中并发程序的有力工具。它们轻量级、协作式，可以用来实现各种不同的并发模式。它们不能完全用于实现并行性，因为协程仍然需要 CPU
    执行上下文，这只能由线程提供。
- en: Thread life cycle
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程生命周期
- en: 'The life cycle of a system thread, often referred to as a lightweight process,
    encompasses the stages from its creation until its termination. Each stage plays
    a crucial role in managing and utilizing threads in a concurrent programming environment:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 系统线程的生命周期，通常被称为轻量级进程，包括从其创建到终止的阶段。每个阶段在管理并发编程环境中的线程方面都发挥着至关重要的作用：
- en: '**Creation** : This phase begins when a new thread is created in the system.
    The creation process involves using the function, which takes several parameters.
    One critical parameter is the thread’s attributes, such as its scheduling policy,
    stack size, and priority. Another essential parameter is the function that the
    thread will execute, known as the start routine. Upon its successful creation,
    the thread is allocated its own stack and other resources.'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建**：此阶段始于在系统中创建新线程时。创建过程涉及使用函数，该函数需要几个参数。一个关键参数是线程的属性，例如其调度策略、堆栈大小和优先级。另一个重要参数是线程将要执行的函数，称为起始例程。成功创建后，线程将分配其自己的堆栈和其他资源。'
- en: '**Execution** : After creation, the thread starts executing its assigned start
    routine. During execution, the thread can perform various tasks independently
    or interact with other threads if necessary. Threads can also create and manage
    their own local variables and data structures, making them self-contained and
    capable of performing specific tasks concurrently.'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**执行**：线程创建后，开始执行其分配的起始例程。在执行过程中，线程可以独立执行各种任务，或者在必要时与其他线程交互。线程还可以创建和管理自己的局部变量和数据结构，使其成为自包含的，能够并行执行特定任务。'
- en: '**Synchronization** : To ensure orderly access to shared resources and prevent
    data corruption, threads employ synchronization mechanisms. Common synchronization
    primitives include locks, semaphores, and barriers. Proper synchronization allows
    threads to coordinate their activities, avoiding race conditions, deadlocks, and
    other issues that can arise in concurrent programming.'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**同步**：为确保有序访问共享资源并防止数据损坏，线程使用同步机制。常见的同步原语包括锁、信号量和屏障。适当的同步允许线程协调其活动，避免竞争条件、死锁和其他在并发编程中可能出现的问题。'
- en: '**Termination** : A thread can terminate in several ways. It can explicitly
    call the function to terminate itself. It can also terminate by returning from
    its start routine. In some cases, a thread can be canceled by another thread using
    the function. Upon termination, the system reclaims the resources allocated to
    the thread, and any pending operations or locks held by the thread are released.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**终止**：线程可以通过多种方式终止。它可以显式调用函数来终止自身。它也可以通过从其起始例程返回来终止。在某些情况下，线程可以通过另一个线程使用函数来取消。终止后，系统回收分配给线程的资源，并释放线程持有的任何挂起操作或锁。'
- en: Understanding the life cycle of a system thread is essential for designing and
    implementing concurrent programs. By carefully managing thread creation, execution,
    synchronization, and termination, developers can create efficient and scalable
    applications that leverage the benefits of concurrency.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 理解系统线程的生命周期对于设计和实现并发程序至关重要。通过仔细管理线程的创建、执行、同步和终止，开发者可以创建高效且可扩展的应用程序，从而利用并发的优势。
- en: Thread scheduling
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程调度
- en: System threads, managed by the operating system kernel’s scheduler, are scheduled
    preemptively. The scheduler decides when to switch execution between threads based
    on factors such as thread priority, allocated time, or mutex blocking. This context
    switch, controlled by the kernel, can incur significant overhead. The high cost
    of context switches, coupled with the resource usage of each thread (such as its
    own stack), makes coroutines a more efficient alternative for some applications
    because we can run more than one coroutine in a single thread.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 系统线程由操作系统内核的调度器管理，是抢占式调度的。调度器根据线程优先级、分配的时间或互斥锁阻塞等因素决定何时在线程之间切换执行。这种由内核控制的上下文切换可能会产生显著的开销。上下文切换的高成本，加上每个线程的资源使用（如其自己的堆栈），使得协程在某些应用程序中成为一种更有效的替代方案，因为我们可以在单个线程中运行多个协程。
- en: Coroutines offer several advantages. First, they reduce the overhead associated
    with context switches. Since context switching on coroutine yield or await is
    handled by the user space code rather than the kernel, the process is more lightweight
    and efficient. This results in significant performance gains, especially in scenarios
    where frequent context switching occurs.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 协程提供了几个优点。首先，它们减少了与上下文切换相关的开销。由于协程的yield或await上的上下文切换由用户空间代码而不是内核处理，因此过程更加轻量级和高效。这导致了显著的性能提升，尤其是在频繁发生上下文切换的场景中。
- en: Coroutines also provide greater control over thread scheduling. Developers can
    define custom scheduling policies based on the specific requirements of their
    application. This flexibility allows for fine-tuned thread management, resource
    utilization optimization, and desired performance characteristics achievement.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 协程还提供了对线程调度的更多控制。开发者可以根据其应用程序的具体要求定义自定义调度策略。这种灵活性允许进行精细的线程管理、资源利用优化以及达到期望的性能特性。
- en: Another important feature of coroutines is that they are generally more lightweight
    compared to system threads. Coroutines don’t maintain their own stack, which is
    a great resource consumption advantage, making them suitable for resource-constrained
    environments.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 协程的另一个重要特性是，与系统线程相比，它们通常更轻量级。协程不维护自己的堆栈，这是一个巨大的资源消耗优势，使它们适合资源受限的环境。
- en: Overall, coroutines offer a more efficient and flexible approach to thread management,
    particularly in situations where frequent context switching is required or where
    fine-grained control over thread scheduling is essential. Threads can access the
    memory process and this memory is shared among all the threads, so we need to
    be careful and control memory access. This control is achieved by different mechanisms
    called synchronization primitives.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，协程提供了一种更高效、更灵活的线程管理方法，尤其是在需要频繁上下文切换或需要精细控制线程调度的情况中。线程可以访问内存进程，并且这种内存被所有线程共享，因此我们需要小心并控制内存访问。这种控制是通过称为同步原语的不同机制实现的。
- en: Synchronization primitives
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步原语
- en: 'Synchronization primitives are essential tools for managing concurrent access
    to shared resources in multithreaded programming. There are several synchronization
    primitives, each with its own specific purpose and characteristics:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 同步原语是管理多线程编程中共享资源并发访问的必要工具。存在几种同步原语，每种都有其特定的用途和特性：
- en: '**Mutexes** : Mutexes are used to enforce exclusive access to critical sections
    of code. A mutex can be locked by a thread, preventing other threads from entering
    the protected section until the mutex is unlocked. Mutexes guarantee that only
    one thread can execute the critical section at any given time, ensuring data integrity
    and preventing race conditions.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互斥锁**：互斥锁用于强制对代码关键部分的独占访问。一个线程可以锁定互斥锁，防止其他线程进入受保护的区域，直到互斥锁被解锁。互斥锁确保在任何给定时间只有一个线程可以执行关键部分，从而确保数据完整性和防止竞态条件。'
- en: '**Semaphores** : Semaphores are more versatile than mutexes and can be used
    for a wider range of synchronization tasks, including signaling between threads.
    A semaphore maintains an integer counter that can be incremented (signaling) or
    decremented (waiting) by threads. Semaphores allow for more complex coordination
    patterns, such as counting semaphores (for resource allocation) and binary semaphores
    (similar to mutexes).'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信号量**：信号量比互斥锁更灵活，可以用于更广泛的同步任务，包括线程之间的信号。信号量维护一个整数计数器，可以被线程递增（信号）或递减（等待）。信号量允许更复杂的协调模式，例如计数信号量（用于资源分配）和二进制信号量（类似于互斥锁）。'
- en: '**Condition variables** : Condition variables are used for thread synchronization
    based on specific conditions. Threads can block (wait on) a condition variable
    until a particular condition becomes true. Other threads can signal the condition
    variable, causing waiting threads to wake up and continue execution. Condition
    variables are often used in conjunction with mutexes to achieve more fine-grained
    synchronization and avoid busy waiting.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**条件变量**：条件变量用于基于特定条件的线程同步。线程可以阻塞（在条件变量上等待）直到特定条件变为真。其他线程可以通知条件变量，导致等待的线程唤醒并继续执行。条件变量通常与互斥锁结合使用，以实现更细粒度的同步并避免忙等待。'
- en: '**Additional synchronization primitives** : In addition to the core synchronization
    primitives discussed previously, there are several other synchronization mechanisms:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**其他同步原语**：除了之前讨论的核心同步原语之外，还有几种其他同步机制：'
- en: '**Barriers** : Barriers allow a group of threads to synchronize their execution,
    ensuring that all threads reach a certain point before proceeding further'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屏障**：屏障允许一组线程同步它们的执行，确保在进一步执行之前所有线程都达到某个点'
- en: '**Read-write locks** : Read-write locks provide a way to control concurrent
    access to shared data, allowing multiple readers but only a single writer at a
    time'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读写锁**：读写锁提供了一种控制对共享数据并发访问的方法，允许多个读者但一次只有一个写者'
- en: '**Spinlocks** : Spinlocks are a type of mutex that involves busy waiting, continuously
    checking a memory location until it becomes available'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自旋锁**：自旋锁是一种互斥锁，它涉及忙等待，持续检查一个内存位置，直到它变得可用'
- en: In *Chapters 4* and *5* , we will see the synchronization primitives implemented
    in the C++ **Standard Template Library** ( **STL** ) in depth and examples of
    how to use them.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4章和第5章中，我们将深入探讨C++ **标准模板库**（**STL**）中实现的同步原语及其使用示例。
- en: Choosing the right synchronization primitive
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择合适的同步原语
- en: 'The choice of the appropriate synchronization primitive depends on the specific
    requirements of the application and the nature of the shared resources being accessed.
    Here are some general guidelines:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 选择适当的同步原语取决于应用程序的具体要求和访问的共享资源的性质。以下是一些一般性指南：
- en: '**Mutexes** : Use mutexes when exclusive access to a critical section is required
    to ensure data integrity and prevent race conditions'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互斥锁**：当需要独占访问临界区以确保数据完整性和防止竞态条件时，请使用互斥锁'
- en: '**Semaphores** : Use semaphores when more complex coordination patterns are
    needed, such as resource allocation or signaling between threads'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信号量**：当需要更复杂的协调模式时，例如资源分配或线程间的信号，请使用信号量'
- en: '**Condition variables** : Use condition variables when threads need to wait
    for a specific condition to become true before proceeding'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**条件变量**：当线程需要在继续之前等待特定条件变为真时，请使用条件变量'
- en: Effective use of synchronization primitives is crucial for developing safe and
    efficient multithreaded programs. By understanding the purpose and characteristics
    of different synchronization mechanisms, developers can choose the most suitable
    primitives for their specific needs and achieve reliable and predictable concurrent
    execution.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有效使用同步原语对于开发安全且高效的并发程序至关重要。通过了解不同同步机制的目的和特性，开发者可以选择最适合其特定需求的原语，并实现可靠和可预测的并发执行。
- en: Common problems when using multiple threads
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多个线程时常见的问题
- en: Threading introduces several challenges that must be managed to ensure application
    correctness and performance. These challenges arise from the inherent concurrency
    and non-deterministic nature of multithreaded programming.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 线程引入了几个挑战，必须管理这些挑战以确保应用程序的正确性和性能。这些挑战源于多线程编程固有的并发性和非确定性。
- en: '**Race conditions** occur when multiple threads access and modify shared data
    concurrently. The outcome of a race condition depends on the non-deterministic
    sequencing of threads’ operations, which can lead to unpredictable and inconsistent
    results. For example, consider two threads that are updating a shared counter.
    If the threads increment the counter concurrently, the final value may be incorrect
    due to a race condition.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**竞态条件**发生在多个线程并发访问和修改共享数据时。竞态条件的结局取决于线程操作的不可确定顺序，这可能导致不可预测和不一致的结果。例如，考虑两个更新共享计数器的线程。如果线程并发地增加计数器，最终值可能会由于竞态条件而不正确。'
- en: '**Deadlocks** occur when two or more threads wait indefinitely for resources
    held by each other. This creates a cycle of dependencies that cannot be resolved,
    causing the threads to become permanently blocked. For instance, consider two
    threads that are waiting for each other to release locks on shared resources.
    If neither thread releases the lock it holds, a deadlock occurs.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**死锁**发生在两个或更多线程无限期地等待彼此持有的资源时。这会形成一个无法解决的依赖循环，导致线程永久性地被阻塞。例如，考虑两个正在等待对方释放共享资源锁的线程。如果两个线程都不释放它们持有的锁，就会发生死锁。'
- en: '**Starvation** occurs when a thread is perpetually denied access to resources
    it needs to make progress. This can happen when other threads continuously acquire
    and hold resources, leaving the starved thread unable to execute.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**饥饿**发生在线程始终无法访问它需要以取得进展的资源时。这可能会发生在其他线程持续获取并持有资源的情况下，使得饥饿的线程无法执行。'
- en: '**Livelocks** are like deadlocks, but instead of being permanently blocked,
    the threads remain active and repeatedly try to acquire resources, only without
    making any progress.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活锁**就像死锁一样，但线程不是永久性地被阻塞，而是保持活跃状态并反复尝试获取资源，只是没有任何进展。'
- en: 'Several techniques can be used to manage the challenges of threading, including
    the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用几种技术来管理线程的挑战，包括以下内容：
- en: '**Synchronization mechanisms** : As described previously, synchronization primitives
    such as locks and mutexes can be used to control access to shared data and ensure
    that only one thread can access the data at a time.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步机制**：如前所述，同步原语，如锁和互斥量，可以用来控制对共享数据的访问，并确保一次只有一个线程可以访问数据。'
- en: '**Deadlock prevention and detection** : Deadlock prevention algorithms can
    be used to avoid deadlocks, while deadlock detection algorithms can be used to
    identify and resolve deadlocks when they occur.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**死锁预防和检测**：死锁预防算法可以用来避免死锁，而死锁检测算法可以用来在发生死锁时识别和解决死锁。'
- en: '**Thread scheduling** : Thread scheduling algorithms can be used to determine
    which thread should run at any given time, as well as which can help to prevent
    starvation and improve application performance. We will see the different solutions
    to multithreading issues in much more detail.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程调度**：线程调度算法可以用来确定在任何给定时间应该运行哪个线程，以及哪些可以帮助防止饥饿并提高应用程序性能。我们将更详细地了解多线程问题的不同解决方案。'
- en: Strategies for effective thread management
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**有效线程管理策略**'
- en: 'There are different ways to handle threads to avoid multithreading issues.
    The following are some of the most common ways to handle threads:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的方法来处理线程以避免多线程问题。以下是一些处理线程的最常见方法：
- en: '**Minimize shared state** : Designing threads to operate on private data as
    much as possible significantly reduces the need for synchronization. By allocating
    memory for thread-specific data using thread-local storage, the need for global
    variables is eliminated, further reducing the potential for data contention. Careful
    management of shared data access through synchronization primitives is essential
    to ensure data integrity. This approach enhances the efficiency and correctness
    of multithreaded applications by minimizing the need for synchronization and ensuring
    that shared data is accessed in a controlled and consistent manner.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小化共享状态**：尽可能设计线程在私有数据上操作，这可以显著减少同步的需求。通过使用线程局部存储为线程特定的数据分配内存，可以消除全局变量的需求，进一步减少数据竞争的可能性。通过同步原语仔细管理共享数据访问对于确保数据完整性至关重要。这种方法通过最小化同步需求并确保共享数据以受控和一致的方式访问，提高了多线程应用程序的效率和正确性。'
- en: '**Lock hierarchy** : Establishing a well-defined lock hierarchy is crucial
    for preventing deadlocks in multithreaded programming. A lock hierarchy dictates
    the order in which locks are acquired and released, ensuring a consistent locking
    pattern across threads. By acquiring locks in a hierarchical manner, from the
    coarsest to the finest granularity, the possibility of deadlocks is significantly
    reduced.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**锁层次结构**：在多线程编程中，建立良好的锁层次结构对于防止死锁至关重要。锁层次结构规定了锁获取和释放的顺序，确保线程之间有一个一致的锁定模式。通过以层次化的方式获取锁，从最粗粒度到最细粒度，可以显著减少死锁的可能性。'
- en: The coarsest level of granularity refers to locks that control access to a large
    portion of the shared resource, while the finest granularity locks are used for
    specific, fine-grained parts of the resource. By acquiring the coarse-grained
    lock first, threads can gain exclusive access to a larger section of the resource,
    reducing the likelihood of conflicts with other threads attempting to access the
    same resource. Once the coarse-grained lock is acquired, finer-grained locks can
    be obtained to control access to specific parts of the resource, providing more
    granular control and reducing the waiting time for other threads.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 粗粒度级别指的是控制对共享资源大部分访问的锁，而细粒度锁用于资源的特定、细粒度部分。通过首先获取粗粒度锁，线程可以获取对资源较大部分的独占访问，从而降低与其他线程尝试访问同一资源发生冲突的可能性。一旦获取了粗粒度锁，就可以获取细粒度锁来控制对资源特定部分的访问，提供更细粒度的控制并减少其他线程的等待时间。
- en: 'In some cases, lock-free data structures can be employed to eliminate the need
    for locks altogether. Lock-free data structures are designed to provide concurrent
    access to shared resources without explicit locks. Instead, they rely on atomic
    operations and non-blocking algorithms to ensure data integrity and consistency.
    By utilizing lock-free data structures, the overhead associated with lock acquisition
    and release is eliminated, resulting in improved performance and scalability in
    multithreaded applications:'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在某些情况下，可以使用无锁数据结构来完全消除对锁的需求。无锁数据结构旨在提供对共享资源的并发访问，而不需要显式的锁。相反，它们依赖于原子操作和非阻塞算法来确保数据完整性和一致性。通过利用无锁数据结构，消除了与锁获取和释放相关的开销，从而在多线程应用程序中提高了性能和可伸缩性：
- en: '**Timeouts** : To prevent threads from waiting indefinitely when trying to
    acquire a lock, it is important to set timeouts for lock acquisition. This ensures
    that if a thread cannot acquire the lock within the specified timeout period,
    it will automatically give up and try again later. This helps prevent deadlocks
    and ensures that no thread is left waiting indefinitely.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超时**：为了防止线程在尝试获取锁时无限期等待，为锁获取设置超时非常重要。这确保了如果线程在指定的超时期间无法获取锁，它将自动放弃并稍后再次尝试。这有助于防止死锁并确保没有线程被无限期地留下等待。'
- en: '**Thread pools** : Managing a pool of reusable threads is a key technique for
    optimizing the performance of multithreaded applications. By creating and destroying
    threads dynamically, the overhead of thread creation and termination can be reduced
    significantly. The size of the thread pool should be tuned based on the application’s
    workload and resource constraints. A too-small pool may result in tasks waiting
    for available threads, while a too-large pool may waste resources. Work queues
    are used to manage tasks and assign them to available threads in the pool. Tasks
    are added to the queue and processed by the threads in a FIFO order. This ensures
    fairness and prevents the starvation of tasks. The use of work queues also allows
    for load balancing, as tasks can be distributed evenly across the available threads.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程池**：管理一组可重用线程是优化多线程应用程序性能的关键技术。通过动态创建和销毁线程，可以显著减少线程创建和终止的开销。线程池的大小应根据应用程序的工作负载和资源约束进行调整。池太小可能导致任务等待可用的线程，而池太大可能浪费资源。工作队列用于管理任务并将它们分配给池中的可用线程。任务被添加到队列中，并由线程按FIFO顺序处理。这确保了公平性并防止了任务的饥饿。使用工作队列还可以实现负载均衡，因为任务可以均匀地分配到可用的线程中。'
- en: '**Synchronization primitives** : Understand the different types of synchronization
    primitives, such as mutexes, semaphores, and condition variables. Choose the appropriate
    primitive based on the synchronization requirements of the specific scenario.
    Use synchronization primitives correctly to avoid race conditions and deadlocks.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步原语**：理解不同类型的同步原语，例如互斥锁、信号量和条件变量。根据特定场景的同步需求选择合适的原语。正确使用同步原语以避免竞态条件和死锁。'
- en: '**Testing and debugging** : Test multi-threaded applications thoroughly to
    identify and fix threading issues. Use tools such as thread sanitizers and profilers
    to detect data races and performance bottlenecks. Employ debugging techniques
    such as step-by-step execution and thread dumps to analyze and resolve threading
    problems. We will see testing and debugging in *Chapters 11* and *12* .'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试与调试**：彻底测试多线程应用程序，以识别和修复线程问题。使用线程清理器和性能分析器等工具来检测数据竞争和性能瓶颈。采用逐步执行和线程转储等调试技术来分析和解决线程问题。我们将在第11章和第12章中看到测试和调试。'
- en: '**Scalability and performance considerations** : Design thread-safe data structures
    and algorithms to ensure scalability and performance. Balance the number of threads
    with the available resources to avoid over-subscription. Monitor system metrics
    such as CPU utilization and thread contention to identify potential performance
    bottlenecks.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性和性能考虑**：设计线程安全的数据结构和算法，以确保可扩展性和性能。平衡线程数量与可用资源，以避免过度订阅。监控系统指标，如CPU利用率和线程竞争，以识别潜在的性能瓶颈。'
- en: '**Communication and collaboration** : Foster collaboration among developers
    working on multi-threaded code to ensure consistency and correctness. Establish
    coding guidelines and best practices for thread management to maintain code quality
    and readability. Regularly review and update the threading strategy as the application
    evolves.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**沟通与协作**：促进在多线程代码上工作的开发者之间的协作，以确保一致性和正确性。建立线程管理的编码规范和最佳实践，以维护代码质量和可读性。随着应用程序的发展，定期审查和更新线程策略。'
- en: Threading is a powerful tool that can be used to improve the performance and
    scalability of applications. However, it is important to understand the challenges
    of threading and to use appropriate techniques to manage these challenges. By
    doing so, developers can create multithreaded applications that are correct, efficient,
    and reliable.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是一种强大的工具，可以用来提高应用程序的性能和可扩展性。然而，了解线程的挑战并使用适当的技巧来管理这些挑战是非常重要的。通过这样做，开发者可以创建正确、高效和可靠的多线程应用程序。
- en: Summary
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the concept of processes in operating systems.
    Processes are fundamental entities that execute programs and manage resources
    on the computer. We delved into the process life cycle, examining the various
    stages a process goes through from creation to termination. Additionally, we discussed
    IPC, which is crucial for processes to interact and exchange information with
    each other.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了操作系统中的进程概念。进程是执行程序并管理计算机资源的根本实体。我们深入研究了进程生命周期，检查了进程从创建到终止所经历的各个阶段。此外，我们还讨论了进程间通信（IPC），这对于进程之间相互交互和交换信息至关重要。
- en: Furthermore, we introduced daemons in the context of Linux operating systems.
    Daemons are special types of processes that run in the background as services
    and perform specific tasks such as managing system resources, handling network
    connections, or providing other essential services to the system. We also explored
    the concepts of system and user threads, which are lightweight processes that
    share the same address space as the parent process. We discussed the advantages
    of multithreaded applications, including improved performance and responsiveness,
    as well as the challenges associated with managing and synchronizing multiple
    threads within a single process.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们在Linux操作系统的背景下介绍了守护进程。守护进程是作为服务在后台运行的特定类型的进程，执行诸如管理系统资源、处理网络连接或为系统提供其他基本服务等特定任务。我们还探讨了系统和用户线程的概念，它们是与父进程共享相同地址空间的轻量级进程。我们讨论了多线程应用程序的优势，包括改进的性能和响应性，以及管理并同步单个进程内多个线程的挑战。
- en: Knowing the different issues created by multithreading is fundamental to understanding
    how to fix them. In the next chapter, we will see how to create threads, and then
    in [*Chapter 4*](B22219_04.xhtml#_idTextAnchor074) and [*Chapter 5*](B22219_05.xhtml#_idTextAnchor097)
    , we will study the different synchronization primitives the standard C++ offers
    and their different applications in depth.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '了解由多线程引起的不同问题是理解如何修复它们的基础。在下一章中，我们将看到如何创建线程，然后在[*第4章*](B22219_04.xhtml#_idTextAnchor074)和[*第5章*](B22219_05.xhtml#_idTextAnchor097)中，我们将深入研究标准C++提供的不同同步原语及其不同应用。 '
- en: Further reading
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[Butenhof, 1997] David R. Butenhof, *Programming with POSIX Threads* , Addison
    Wesley, 1997.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Butenhof, 1997] David R. Butenhof, *《POSIX线程编程》* , Addison Wesley, 1997。'
- en: '[Kerrisk, 2010] Michael Kerrisk, *The Linux Programming Interface* , No Starch
    Press, 2010.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Kerrisk, 2010] Michael Kerrisk, *《Linux编程接口》* , No Starch Press, 2010.'
- en: '[Stallings, 2018] William Stallings, *Operating Systems Internals and Design
    Principles* , Ninth Edition, Pearson Education 2018.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Stallings, 2018] William Stallings, *《操作系统内部机制与设计原则》* , 第九版，Pearson Education
    2018.'
- en: '[Williams, 2019] Anthony Williams, *C++ Concurrency in Action* , Second Edition,
    Manning 2019.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Williams, 2019] Anthony Williams, *《C++并发实战》* , 第二版，Manning 2019.'
- en: 'Part 2: Advanced Thread Management and Synchronization Techniques'
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：高级线程管理和同步技术
- en: In this part, we build upon the foundational knowledge of parallel programming
    and dive deeper into advanced techniques for managing threads and synchronizing
    concurrent operations. We will explore essential concepts such as thread creation
    and management, exception handling across threads, and efficient thread coordination,
    acquiring a solid understanding of key synchronization primitives, including mutexes,
    semaphores, condition variables, and atomic operations. All this knowledge will
    equip us with the tools needed to implement both lock-based and lock-free multithreaded
    solutions, offering a glimpse into high-performance concurrent systems, and providing
    the skills necessary to avoid common pitfalls such as race conditions, deadlocks,
    and livelocks when managing multithreaded systems.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们基于并行编程的基础知识，深入探讨管理线程和同步并发操作的高级技术。我们将探讨诸如线程创建和管理、线程间的异常处理以及高效的线程协调等基本概念，从而对包括互斥锁、信号量、条件变量和原子操作在内的关键同步原语有一个扎实的理解。所有这些知识将使我们具备实现基于锁和无锁多线程解决方案的工具，为高性能并发系统提供一瞥，并提供在管理多线程系统时避免常见陷阱（如竞态条件、死锁和活锁）所需的技能。
- en: 'This part has the following chapters:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 3*](B22219_03.xhtml#_idTextAnchor051) , *How to Create and Manage
    Threads in C++*'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第3章*](B22219_03.xhtml#_idTextAnchor051) , *如何在C++中创建和管理线程* '
- en: '[*Chapter 4*](B22219_04.xhtml#_idTextAnchor074) , *Thread Synchronization with
    Locks*'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第4章*](B22219_04.xhtml#_idTextAnchor074) , *使用锁进行线程同步*'
- en: '[*Chapter 5*](B22219_05.xhtml#_idTextAnchor097) , *Atomic Operations*'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B22219_05.xhtml#_idTextAnchor097) , *原子操作*'
