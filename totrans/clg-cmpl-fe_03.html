<html><head></head><body>
<div><div><h1 data-number="1.2" class="calibre5">2</h1>
<h1 id="sigil_toc_id_25" class="calibre5"><a id="x1-330002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Clang Architecture</h1>
<p class="hidden">In this chapter, we will examine the internal architecture of Clang and its relationship with other LLVM components. We will begin with an overview of the overall compiler architecture, with a specific focus on the clang driver. As the backbone of the compiler, the driver runs all compilation phases and controls their execution. Finally, we will concentrate on the <a id="dx1-33001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>frontend portion of the Clang compiler, which includes lexical and semantic analysis, and produces an <strong class="calibre12">Abstract Syntax Tree (AST</strong> <a id="dx1-33002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>) as its primary output. The AST <a id="dx1-33003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>forms the foundation for most Clang tools, and we will examine it more closely in the next chapters.</p>
<p class="hidden">The following topics will be covered in this chapter:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15">Compiler overview</p></li>
<li class="calibre14"><p class="calibre15">Clang driver overview, including an explanation of the compilation phases and their execution</p></li>
<li class="calibre14"><p class="calibre15">Clang frontend overview covering the preprocessing step, parsing, and semantic analysis</p></li>
</ul>
<p class="hidden"><a id="x1-33004r55" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>

<h2 data-number="1.2.1" id="sigil_toc_id_26" class="likechapterhead">2.1  <a id="x1-340001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Technical requirements</h2>
<p class="hidden">The source code for this chapter is located in the <code class="calibre13">chapter2 </code>folder of the book’s GitHub repository: <a href="https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter2" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter2</a>. <a id="x1-34001r57" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


<h2 data-number="1.2.2" id="sigil_toc_id_27" class="likechapterhead">2.2  <a id="x1-350002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Getting started with compilers</h2>
<p class="hidden">Despite the fact that compilers are used to translate programs from one form to another, they can also be considered large software systems that use various algorithms and data structures. The knowledge obtained by studying compilers can be <a id="dx1-35001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>used to design other scalable software systems as well. On the other hand, compilers are also a subject of active scientific research, and there are many unexplored areas and topics to investigate.</p>
<p class="hidden">You can find some basic information about the internal structure of a compiler here. We will keep it as basic as possible so the information applies to any compiler, not just Clang. We will briefly cover all phases of compilation, which will help to understand Clang’s position in the overall compiler architecture. <a id="x1-35002r37" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>

<h3 data-number="1.2.2.1" id="sigil_toc_id_28" class="likesectionhead">2.2.1  <a id="x1-360001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Exploring the compiler workflow</h3>
<p class="hidden">The primary function of a compiler is to convert a program written in a specific programming language (such as C/C++ or FORTRAN) into a format that <a id="dx1-36001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>can be executed on a target platform. This process involves the use of a compiler, which takes the source file and any compilation flags, and produces a build artifact, such as an executable or object file, as shown in <a href="#Figure2.1" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 2.1</a>.</p>
<div><img src="img/Figure2.1_B19722.png" alt="Figure 2.1: Compiler workflow " class="calibre23"/>
</div>
<p class="hidden"><strong class="calibre12">Figure 2.1</strong>: Compiler workflow </p>
<p class="hidden">The term ”target platform” can have a broad meaning. It can refer to machine code that is executed on the same host, as is typically the case. But it can also refer to cross-compilation, where the compiler generates code for a different computer architecture than the host. For example, code for a mobile application or embedded application running on ARM can be generated using an Intel machine as the host. Additionally, the target platform is not limited to machine code only. For example, some early C++ compilers (such as ”cc”) would produce pure C code as output. This was done because, at the time, C was the most widely used and well-established programming language, and the C compiler was the most reliable way to generate machine code. This approach allowed early C++ programs to be run on a wide range of platforms since most systems already had a C compiler available. The produced C code could then be compiled into machine code using any popular C Compiler such as GCC or LCC.</p>
<div><img src="img/Figure2.2_B19722.png" alt="Figure 2.2: Typical compiler workflow: source program is passed via different stages: frontend, middle-end, and backend " class="calibre24"/>
</div>
<p class="hidden"><strong class="calibre12">Figure 2.2</strong>: Typical compiler workflow: source program is passed via different stages: frontend, middle-end, and backend </p>
<p class="hidden">We are going to focus on <a id="dx1-36006" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>compilers that produce binary code, and a typical compiler workflow for such a compiler is shown in <a href="#Figure2.2" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 2.2</a>. The stages of compilation can be described as follows:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15">Frontend: The frontend does lexical analysis and parsing, which includes both syntax analysis and semantic analysis. The syntax analysis assumes that your program is well-organized according to the language grammar rules. The semantic analysis performs checks on the program’s meaning and rejects invalid programs, such as those that use wrong types.</p></li>
<li class="calibre14"><p class="calibre15">Middle-end: The middle-end performs various optimizations on the intermediate representation (IR) code (LLVM-IR for Clang).</p></li>
<li class="calibre14"><p class="calibre15">Backend: The Backend of a compiler takes the optimized or transformed IR and generates machine code or assembly code that can be executed by the target platform.</p></li>
</ul>
<p class="hidden">The source program is transformed into different forms as it passes through the various stages. For example, the frontend produces IR code, which is then optimized by the middle-end, and finally converted into native code by the backend (see <a href="#Figure2.3" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 2.3</a>).</p>
<div><img src="img/Figure2.3_B19722.png" alt="Figure 2.3: Source code transformation by compiler " class="calibre25"/>
</div>
<p class="hidden"><strong class="calibre12">Figure 2.3</strong>: Source code transformation by compiler </p>
<p class="hidden">Input data consists of <strong class="calibre12">Source code </strong>and <strong class="calibre12">Compile options</strong>. The source code is transformed by the <strong class="calibre12">Frontend </strong>into <strong class="calibre12">IR</strong>. The <strong class="calibre12">Middle-end </strong>does different optimizations on <strong class="calibre12">IR </strong>and passes the final (optimized) result to the <strong class="calibre12">Backend</strong>. The <strong class="calibre12">Backend </strong>generates the <strong class="calibre12">Target code</strong>. The <strong class="calibre12">Frontend</strong>, <strong class="calibre12">Middle-end</strong>, and <strong class="calibre12">Backend </strong>use <strong class="calibre12">Compile options </strong>as settings for the code transformations. Let’s look into the compiler <a id="dx1-36009" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>frontend as the first component of the compiler’s workflow. <a id="x1-36010r59" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


<h3 data-number="1.2.2.2" id="sigil_toc_id_29" class="likesectionhead">2.2.2  <a id="x1-370002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Frontend</h3>
<p class="hidden">The primary goal for the frontend is to <a id="dx1-37001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>convert a given source code to intermediate form. It’s worth mentioning that the frontend also transforms the source code into various forms before it produces the IR. The frontend will be our primary focus in the book, so we will examine its components. The first component of the frontend is the Lexer <a id="dx1-37002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>(see <a href="#Figure2.4" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 2.4</a>). It converts the source code into a set of tokens, which are used to create a special data structure called the abstract syntax tree (AST <a id="dx1-37003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>). The final component, the code generator (Codegen), traverses the AST <a id="dx1-37004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>and generates the IR from it.</p>
<div><img src="img/Figure2.4_B19722.png" alt="Figure 2.4: Compiler frontend " class="calibre26"/>
</div>
<p class="hidden"><strong class="calibre12">Figure 2.4</strong>: Compiler frontend </p>
<p class="hidden">The source code is transformed into a set of tokens (<strong class="calibre12">Toks</strong>) by the <strong class="calibre12">Lexer</strong> <a id="dx1-37010" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>. The <strong class="calibre12">Parser</strong> <a id="dx1-37011" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> takes the tokens and creates an <strong class="calibre12">Abstract Syntax Tree </strong>(<strong class="calibre12">AST</strong> <a id="dx1-37012" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>) that we will explore in details later in <a href="B19722_03.xhtml#x1-530003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Chapter</em><em class="calibre11"> 3</em></a><em class="calibre11">, Clang AST</em>. The <strong class="calibre12">Codegen</strong> generates <strong class="calibre12">IR </strong>from the <strong class="calibre12">AST</strong> <a id="dx1-37013" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>.</p>
<p class="hidden">We will use a simple C/C++ program <a id="dx1-37014" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>that calculates the maximum of two numbers to demonstrate the workings of the frontend. The code for the program is as follows:</p>
<pre class="source-code">                                                                     

                                                                     
1 int max(int a, int b) { 
 
2   if (a &gt; b) 
 

3     return a; 
 
4   return b; 
 
5 }</pre>
<p class="hidden"><a id="x1-37021r5" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-37022" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.5</strong>: Test program for compiler frontend investigations </p>
<p class="hidden">The first component of the frontend is the lexer. Let’s examine it.</p>

<h4 data-number="1.2.2.2.1" class="sigil_not_in_toc"><a id="x1-380002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Lexer</h4>
<p class="hidden">The frontend process starts with the Lexer <a id="dx1-38001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>, which converts the <a id="dx1-38002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>input source into a stream of tokens. In our example program (see <a href="#x1-37021r5" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 2.5</a>), the first token is the keyword <code class="calibre13">int </code>, which represents the integer type. This is followed by the identifier <code class="calibre13">max </code>for the <a id="dx1-38003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>function name. The next token is the left parenthesis <code class="calibre13">( </code>, and so on (see <a href="#Figure2.6" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 2.6</a>).</p>
<div><img src="img/Figure2.6_B19722.png" alt="Figure 2.6: Lexer : the program source is converted into a stream of tokens " class="calibre27"/>
</div>
<p class="hidden"><a id="Figure2.6" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/><strong class="calibre12">Figure 2.6</strong>: Lexer <a id="dx1-38007" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>: the program source is converted into a stream of tokens </p>


<h4 data-number="1.2.2.2.2" class="sigil_not_in_toc"><a id="x1-390002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Parser</h4>
<p class="hidden">The Parser <a id="dx1-39001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>is the next component following the Lexer <a id="dx1-39002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>. The primary output produced by the Parser <a id="dx1-39003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>is called an <strong class="calibre12">abstract syntax tree (AST)</strong>. This tree represents <a id="dx1-39004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>the abstract syntactic structure of the source code written in a programming language. The Parser <a id="dx1-39005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>generates the AST by <a id="dx1-39006" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>taking the stream of tokens produced by the Lexer <a id="dx1-39007" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>as input <a id="dx1-39008" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>and organizing them into a tree-like structure. Each node in the tree represents a construct in the source code, such as a statement or expression, and the edges between nodes represent the relationships between these constructs.</p>
<div><div><img src="img/Figure2.7_B19722.png" alt="Figure 2.7: The AST for our example program, which calculates a maximum of two numbers " class="calibre28"/>
</div>
<p class="hidden"><strong class="calibre12">Figure 2.7</strong>: The AST for our example program, which calculates a maximum of two numbers </p>
</div>
<p class="hidden">The AST for our example program is shown in <a href="#Figure2.7" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 2.7</a>. As you can see, our function (<code class="calibre13">max </code>) has two parameters (<code class="calibre13">a </code>and <code class="calibre13">b </code>) and a body. The body is marked as a compound statement in <a href="#Figure2.7" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 2.7</a>, see also <a href="#x1-50023r38" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 2.40</a>, where we provide a definition for a compound statement from the C++ standard. The compound statement consists of <a id="dx1-39011" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>other statements, such as <code class="calibre13">return </code>and <code class="calibre13">if </code>. The <code class="calibre13">a </code>and <code class="calibre13">b </code>variables are used in the <a id="dx1-39012" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>bodies of these statements. You may also be interested in the real AST generated by Clang <a id="dx1-39013" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>for the compound statement, the result of which is shown in <a href="#Figure2.8" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 2.8</a>.</p>
<div><div><img src="img/file3.png" alt="Figure 2.8: The AST for the compound statement generated by Clang . The tree generated by the clang -cc1 -ast-view &lt;...&gt; command " class="calibre29"/>
</div>
<p class="hidden"><a id="Figure2.8" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/><strong class="calibre12">Figure 2.8</strong>:  The AST for the compound statement generated by Clang <a id="dx1-39017" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>. The tree generated by the <code class="calibre13">clang -cc1 -ast-view &lt;...&gt; </code>command </p>
</div>
<p class="hidden">The Parser <a id="dx1-39018" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>performs two activities:</p>
<ol class="calibre6">
<li class="calibre7"><div><p class="calibre15">Syntax analysis: the Parser <a id="dx1-39021" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/><a id="dx1-39022" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>constructs the AST <a id="dx1-39023" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>by analyzing the <a id="dx1-39024" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>syntax of the program.</p>
</div></li>
<li class="calibre7"><div><p class="calibre15">Semantic analysis: the <a id="dx1-39027" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Parser <a id="dx1-39028" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>analyzes the <a id="dx1-39029" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>program semantically.</p>
</div></li>
</ol>
<p class="hidden">One of the jobs of the parser is to produce an error message if the parsing fails in either of the syntax or semantic analysis phases. If no error occurs, then we get a parse tree (or an AST) for the syntax analysis and a semantically verified parse tree in the case of semantic analysis. We can get a sense of this by considering what types of errors are detected by syntax analysis and which ones are detected by semantic analysis.</p>
<p class="hidden">Syntax analysis assumes that <a id="dx1-39030" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>the program should be correct in <a id="dx1-39031" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>terms of the grammar specified for the language. For example, the following program is invalid in terms of syntax because a semicolon is missing from the last return statement:</p>
<pre class="source-code">1 int max(int a, int b) { 
 
2   if (a &gt; b) 
 

3     return a; 
 
4   return b // missing ; 
 
5 }</pre>
<p class="hidden"><a id="x1-39038r9" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-39039" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.9</strong>: Listing of program code with a syntax error </p>
<p class="hidden">Clang <a id="dx1-39040" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>produces the following output for the program:</p>
<pre id="verbatim-21" class="console">max_invalid_syntax.cpp:4:11: error: expected ’;’ after return statement
  return b // missing ;
          ^
          ;</pre>
<p class="hidden"><a id="x1-39041r10" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-39042" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.10</strong>: Compiler output for a program with a syntax error </p>
<p class="hidden">On the other hand, a program can be syntactically correct but make no sense. The Parser <a id="dx1-39043" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>should detect a semantic error in such cases. For instance, the following program has a semantic error related to the wrongly used type for the return value:</p>
<pre class="source-code">1 int max(int a, int b) { 
 
2   if (a &gt; b) 
 

3     return a; 
 
4   return &amp;b; // invalid return type 
 
5 }</pre>
<p class="hidden"><a id="x1-39050r11" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-39051" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.11</strong>: Listing of program code with a semantic error </p>
<p class="hidden">Clang <a id="dx1-39052" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>generates the following output for the program:</p>
<pre id="verbatim-22" class="console">max_invalid_sema.cpp:4:10: error: cannot initialize return object of type \
’int’ with an rvalue of type ’int *’
  return &amp;b; // invalid return type
         ^~</pre>
<p class="hidden"><a id="x1-39053r12" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-39054" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.12</strong>: Compiler output for a program with a semantic error </p>
<p class="hidden">AST is mainly constructed as a result of syntax analysis, but for certain languages, such as C++, semantic analysis is also crucial for constructing the AST, particularly for C++ template instantiation.</p>
<p class="hidden">During syntax analysis, the compiler verifies that the template declaration adheres to the language’s grammar and syntax rules, including the proper use of keywords such as ”template” and ”typename,” as well as the formation of the template parameters and body.</p>
<p class="hidden">Semantic analysis, on the other hand, involves the compiler performing template instantiation, which generates the AST for specific <a id="dx1-39055" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>instances of the template. It’s worth <a id="dx1-39056" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>noting that the semantic analysis of templates can be quite complex, as the compiler must perform tasks such as type checking, name resolution, and more for each template instantiation. Additionally, the instantiation process can be recursive and lead to a significant amount of code duplication, known as code bloat. To combat this, C++ compilers employ techniques such as template instantiation caching to minimize the amount of redundant code generated.</p>


<h4 data-number="1.2.2.2.3" class="sigil_not_in_toc"><a id="x1-400002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>The codegen</h4>
<p class="hidden">The codegen (it’s worth mentioning that we also have another Codegen component as a part of Backend that generate the target code) or code generator, which is the <a id="dx1-40001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>final component of the compiler’s frontend, has the primary goal of generating the <strong class="calibre12">Intermediate Representation (IR)</strong>. For this purpose, the compiler traverses the AST generated by the parser and converts it into <a id="dx1-40002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>other source code that is called the Intermediate Representation or IR. The IR is a language-independent representation, allowing the same middle-end component to be used for different frontends (FORTRAN vs C++). Another reason for using an Intermediate Representation (IR) is that if we have a new architecture available tomorrow, we can generate the target code specific to that architecture. Since the source <a id="dx1-40003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>language remains unchanged, all the steps leading up to the IR will remain the same. The IR provides this flexibility.</p>
<p class="hidden">The use of IRs in compilers is a concept that has been around for several decades. The idea of using an intermediate representation to represent the source code of a program during compilation has evolved over time, and the exact date when IR was first introduced in compilers is not clear.</p>
<p class="hidden">However, it is known that the first compilers in the 1950s and 1960s did not use IRs and instead translated source code directly into machine code. By the 1960s and 1970s, researchers had begun experimenting with using IRs in compilers to improve the efficiency and flexibility of the compilation process.</p>
<p class="hidden">One of the first widely used IRs was three-address code, which was used in the mid-1960s in IBM/360’s FORTRAN compiler. Other early examples of IRs include the <strong class="calibre12">register transfer language (RTL) </strong>and the <strong class="calibre12">static single</strong> <strong class="calibre12">assignment (SSA) </strong>form, which were introduced in the 1970s and 1980s respectively.</p>
<p class="hidden">Today, the use of IRs in compilers is a standard practice, and many compilers use multiple IRs throughout the compilation process. This allows for more powerful optimization and code generation techniques to be applied. <a id="x1-40004r58" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>




<h2 data-number="1.2.3" id="sigil_toc_id_30" class="likechapterhead">2.3  <a id="x1-410003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Clang driver overview</h2>
<p class="hidden">When discussing compilers, we typically refer to a command-line utility that initiates and manages the compilation process. For example, to use the GNU Compiler Collection, one must call <code class="calibre13">gcc </code>to start the compilation process. Similarly, to compile a C++ program using Clang, one must call <code class="calibre13">clang </code>as the compiler. The program that controls <a id="dx1-41001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>the compilation process is known as the driver. The driver coordinates different stages of compilation and connects them together. In the book, we will be focusing on LLVM and using Clang as the driver for the compilation process.</p>
<p class="hidden">It may be confusing for readers that the same word, ”Clang,” is used to refer to both the compiler frontend and the compilation driver. In contrast, with other compilers, where the driver and C++ compiler can be separate executables, ”Clang” is a single executable that functions as both the driver and the compiler frontend. To use Clang <a id="dx1-41002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>as the compiler frontend only, the special option <code class="calibre13">-cc1</code> must be passed to it. <a id="x1-41003r63" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>

<h3 data-number="1.2.3.1" id="sigil_toc_id_31" class="likesectionhead">2.3.1  <a id="x1-420001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Example program</h3>
<p class="hidden">We will use the simple “Hello world!” example program <a id="dx1-42001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>for our experiments with the Clang driver. The main source file is called <code class="calibre13">hello.cpp </code>. The file implements a trivial C++ program that prints “Hello world!” to the standard output:</p>
<pre class="source-code">1 #include &lt;iostream&gt; 
 
2  
 
3 int main() { 
 

4   std::cout &lt;&lt; "Hello world!" &lt;&lt; std::endl; 
 

5   return 0; 
 
6 }</pre>
<p class="hidden"><a id="x1-42009r13" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-42010" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.13</strong>: Example program: hello.cpp </p>
<p class="hidden">You can compile the source with the following:</p>
<pre id="verbatim-23" class="console">$ &lt;...&gt;/llvm-project/install/bin/clang hello.cpp -o /tmp/hello -lstdc++</pre>
<p class="hidden"><a id="x1-42011r14" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-42012" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.14</strong>: Compilation for <code class="calibre13">hello.cpp</code> </p>
<p class="hidden">As you can see, we used the <code class="calibre13">clang </code>executable as the <a id="dx1-42013" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>compiler and specified the <code class="calibre13">-lstdc++ </code>library option because we used the <code class="calibre13">&lt;</code><code class="calibre13">iostream</code><code class="calibre13">&gt;</code> header from the standard C++ library. We also specified the output for the executable (<code class="calibre13">/tmp/hello </code>) with the <code class="calibre13">-o </code>option. <a id="x1-42014r80" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


<h3 data-number="1.2.3.2" id="sigil_toc_id_32" class="likesectionhead">2.3.2  <a id="x1-430002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Compilation phases</h3>
<p class="hidden">We used two inputs for our example program. The first one is our source code and the second one is a shared library for the standard C++ library. The Clang driver should combine the inputs together, pass them via different <a id="dx1-43001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>phases of the compilation process, and finally, provide the executable file on the target platform.</p>
<p class="hidden">Clang <a id="dx1-43002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>uses the same typical compiler workflow as shown in <a href="#Figure2.2" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 2.2</a>. You can ask Clang <a id="dx1-43003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>to show the phases using the <code class="calibre13">-ccc-print-phases </code>additional argument:</p>
<pre id="verbatim-24" class="console">$ &lt;...&gt;/llvm-project/install/bin/clang hello.cpp -o /tmp/hello -lstdc++ \
                                       -ccc-print-phases</pre>
<p class="hidden"><a id="x1-43004r15" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-43005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.15</strong>: Command to print compilation phases for hello.cpp </p>
<p class="hidden">The output for the command is the following:</p>
<pre id="verbatim-25" class="console">              +- 0: input, "hello.cpp", c++
         +- 1: preprocessor, {0}, c++-cpp-output
      +- 2: compiler, {1}, ir
   +- 3: backend, {2}, assembler
+- 4: assembler, {3}, object
|- 5: input, "1%dM", object
6 : linker, {4, 5}, image</pre>
<p class="hidden"><a id="x1-43006r16" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-43007" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.16</strong>: Compilation phases for hello.cpp </p>
<p class="hidden">We can visualize the output as shown in <a href="#Figure2.17" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 2.17</a>.</p>
<div><div><img src="img/Figure2.17_B19722.png" alt="Figure 2.17: Clang driver phases" class="calibre30"/>
</div>
<p class="hidden"><strong class="calibre12">Figure 2.17</strong>: Clang driver phases </p>
</div>
<p class="hidden">As we can see in <a href="#Figure2.17" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 2.17</a>, the driver receives an input file, <code class="calibre13">hello.cpp </code>, which is a C++ file. The file is <a id="dx1-43008" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>processed by the preprocessor and we obtain the preprocessor output (marked as <code class="calibre13">c++-cpp-output </code>). The result is compiled into IR form by the compiler, and then the backend converts it into assembly form. This form is later transformed into an object file. The final object file is combined with another object (<code class="calibre13">libstdc++ </code>) to produce the final binary (<code class="calibre13">image</code> ). <a id="x1-43009r84" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


<h3 data-number="1.2.3.3" id="sigil_toc_id_33" class="likesectionhead">2.3.3  <a id="x1-440003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Tool execution</h3>
<p class="hidden">The phases are combined into <a id="dx1-44001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>several tool executions. The Clang driver invokes different programs to produce the final executable. Specifically, for our example, it calls the <code class="calibre13">clang </code>compiler and the <code class="calibre13">ld </code>linker. Both programs require additional arguments that are set up by the driver.</p>
<p class="hidden">For instance, our example program (<code class="calibre13">hello.cpp </code>) includes the following header:</p>
<pre id="listing-11" class="source-code">1#include &lt;iostream&gt; 
 
2 ...</pre>
<p class="hidden"><a id="x1-44004r17" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-44005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.18</strong>: iostream header at hello.cpp </p>
<p class="hidden">We did not specify any additional arguments (such as search paths, for example, <code class="calibre13">-I </code>) when we invoked the compilation. However, different architectures and operating systems might have different paths for locating headers.</p>
<p class="hidden">On Fedora 39, the header is located in the <code class="calibre13">/usr/include/c++/13/iostream</code> folder. We can examine a detailed description of the <a id="dx1-44006" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>process executed by the driver and the arguments used with the <code class="calibre13">-###</code> option:</p>
<pre id="verbatim-26" class="console">$ &lt;...&gt;/llvm-project/install/bin/clang hello.cpp -o /tmp/hello -lstdc++ -###</pre>
<p class="hidden"><a id="x1-44007r18" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-44008" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.19</strong>: Command to print tools execution for hello.cpp </p>
<p class="hidden">The output for this command is quite extensive, and certain parts have been omitted here. Please refer to <a href="#x1-44025r19" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 2.20</a>.</p>
<pre id="listing-12" class="source-code">1clang version 18.1.0rc (https://github.com/llvm/llvm-project.git ...) 
 

2  "&lt;...&gt;/llvm-project/install/bin/clang-18" 
 

3    "-cc1" ... \ 
 
4    "-internal-isystem" \ 
 

5    "/usr/include/c++/13" ... \ 
 
6    "-internal-isystem" \ 
 

7    "/usr/include/c++/13/x86_64-redhat-linux" ... \ 
 

8    "-internal-isystem" ... \ 
 
9    "&lt;...&gt;/llvm-project/install/lib/clang/18/include" ... \ 
 

10    "-internal-externc-isystem" \ 
 
11    "/usr/include" ... \ 
 

12    "-o" "/tmp/hello-XXX.o" "-x" "c++" "hello.cpp" 
 

13  ".../bin/ld" ... \ 
 
14    "-o" "/tmp/hello" ... \ 
 

15    "/tmp/hello-XXX.o" \ 
 
16    "-lstdc++" ...</pre>
<p class="hidden"><a id="x1-44025r19" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-44026" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.20</strong>: Clang driver tool execution. The host system is Fedora 39. </p>
<p class="hidden">As we can see in <a href="#x1-44025r19" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 2.20</a>, the driver <a id="dx1-44027" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>initiates two processes: <code class="calibre13">clang-18 </code>with the <code class="calibre13">-cc1 </code>flag (see <em class="calibre11">Lines 2-12</em>) and the linker <code class="calibre13">ld </code>(see <em class="calibre11">Lines 13-16</em>). The Clang compiler implicitly receives several search paths, as seen in <em class="calibre11">Lines 5, 7, 9, and 11</em>. These paths are necessary for the inclusion of the <code class="calibre13">iostream </code>header in the test program.</p>
<p class="hidden">The output of the first executable (<code class="calibre13">/tmp/hello-XXX.o </code>) serves as input for the second one (see <em class="calibre11">Lines 12 and 15</em>). The arguments <code class="calibre13">-lstdc++ </code>and <code class="calibre13">-o /tmp/hello</code> are set for the linker, while the first argument (hello.cpp) is provided for the compiler invocation (first executable).</p>
<div><div><img src="img/Figure2.21_B19722.png" alt="Figure 2.21: Clang driver tool execution. The Clang driver runs two executables: the clang executable with the -cc1 flag and the linker - ld executable " class="calibre31"/>
</div>
<p class="hidden"><strong class="calibre12">Figure 2.21</strong>: Clang driver tool execution. The Clang driver runs two executables: the clang executable with the -cc1 flag and the linker - ld executable </p>
</div>
<p class="hidden">The process can be visualized as shown in <a href="#Figure2.21" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 2.21</a>, where we can <a id="dx1-44030" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>see that two executables are executed as part of the compilation process. The first one is <code class="calibre13">clang-18 </code>with a special flag (<code class="calibre13">-cc1 </code>). The second one is the linker: <code class="calibre13">ld</code> . <a id="x1-44031r87" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


<h3 data-number="1.2.3.4" id="sigil_toc_id_34" class="likesectionhead">2.3.4  <a id="x1-450004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Combining it all together</h3>
<p class="hidden">We can summarize the knowledge we have acquired so far using <a href="#Figure2.22" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 2.22</a>. The figure illustrates two different processes started by the Clang driver. The first one is <code class="calibre13">clang -cc1 </code>(compiler), and the second one is <code class="calibre13">ld </code>(linker). The compiler process is the <a id="dx1-45001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>same executable as the Clang driver (<code class="calibre13">clang </code>), but it is run with a special argument: <code class="calibre13">-cc1 </code>. The compiler produces an object file that is then processed by the linker (<code class="calibre13">ld </code>) to generate the final binary.</p>
<div><div><img src="img/Figure2.22_B19722.png" alt="Figure 2.22: Clang driver: The driver got the input file hello.cpp, which is a C++ file. It starts two processes: clang and ld. The first one does real compilation and starts the integrated assembler. The last one is the linker (ld) that produces the final binary (image) from the result received from the compiler and the external library (libstdc++)" class="calibre32"/>
</div>
<p class="hidden"><strong class="calibre12">Figure 2.22</strong>: Clang driver: The driver got the input file hello.cpp, which is a C++ file. It starts two processes: clang and ld. The first one does real compilation and starts the integrated assembler. The last one is the linker (ld) that produces the final binary (image) from the result received from the compiler and the external library (libstdc++) </p>
</div>
<p class="hidden">In <a href="#Figure2.22" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 2.22</a>, we can observe similar components of the compiler mentioned earlier (see <a href="#x1-350002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 2.2</em></a><em class="calibre11">, Getting started with compilers</em>). However, the main difference is that the <strong class="calibre12">preprocessor </strong>(part of the lexer) is shown separately, while the frontend and middle-end are combined into the <strong class="calibre12">compiler</strong>. Additionally, the figure depicts an <strong class="calibre12">assembler </strong>that is executed by the driver to generate the object code. It is important to note that the assembler can be integrated, as shown in <a href="#Figure2.22" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 2.22</a>, or it may require a separate process to be executed.</p>

<p class="hidden">Important note</p>

<p class="hidden">Here is an example of specifying an external assembler using the <code class="calibre13">-c </code>(compile only) and <code class="calibre13">-o </code>(output file) options, along with the appropriate flags for your platform:</p>
<pre id="verbatim-27" class="console">$&lt;...&gt;/llvm-project/install/bin/clang -c hello.cpp \
                                      -o /tmp/hello.o
as -o /tmp/hello.o /tmp/hello.s</pre>

<p class="hidden"><a id="x1-45002r92" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


<h3 data-number="1.2.3.5" id="sigil_toc_id_35" class="likesectionhead">2.3.5  <a id="x1-460005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Debugging Clang</h3>
<p class="hidden">We’re going to step through a <a id="dx1-46001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>debugging session for our compilation process, illustrated in <a href="#x1-42011r14" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 2.14</a>.</p>

<p class="hidden">Important note</p>

<p class="hidden">We will use the LLDB <a id="dx1-46002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>build created previously in <a href="B19722_01.xhtml#x1-290003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 1.3.3</em></a><em class="calibre11">,</em> <em class="calibre11">The LLVM debugger, its build, and usage</em> for this and other debug sessions throughout the book. You can also use the LLDB <a id="dx1-46003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>that comes as part of your host system.</p>

<p class="hidden">Our chosen point of interest, or breakpoint, is the <code class="calibre13">clang::ParseAST </code>function. In a typical debug session, which resembles the one outlined in <a href="B19722_01.xhtml#listing-7" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 1.11</a>, you would feed command-line arguments following the <code class="calibre13">"- -" </code>symbol. The command should look like this:</p>
<pre id="verbatim-28" class="console">$ lldb &lt;...&gt;/llvm-project/install/bin/clang -- hello.cpp -o /tmp/hello \
                                               -lstdc++</pre>
<p class="hidden"><a id="x1-46004r21" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-46005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.23</strong>: Running debugger for hello.cpp file compilation </p>
<p class="hidden">In this case, <code class="calibre13">&lt;...&gt; </code>represents the directory path used to clone the LLVM project.</p>
<p class="hidden">Unfortunately, this approach doesn’t work with the Clang compiler:</p>
<pre id="listing-13" class="source-code">1$ lldb &lt;...&gt;/llvm-project/install/bin/clang -- hello.cpp -o /tmp/hello.o -lstdc++ 
 

2 ... 
 
3 (lldb) b clang::ParseAST 
 
4 ... 
 
5 (lldb) r 
 

6 ... 
 
72  locations added to breakpoint 1 
 
8 ... 
 

9 Process 247135 stopped and restarted: thread 1 received signal: SIGCHLD 
 

10 Process 247135 stopped and restarted: thread 1 received signal: SIGCHLD 
 

11 Process 247135 exited with status = 0 (0x00000000) 
 

12 (lldb)</pre>
<p class="hidden"><a id="x1-46018r22" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-46019" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.24</strong>: Debugger session with failed interruption </p>
<p class="hidden">As we can see from <em class="calibre11">Line 7</em>, the breakpoint was set but the process finished successfully (<em class="calibre11">Line 11</em>) without any interruptions. In other words, our breakpoint didn’t trigger in this instance.</p>
<p class="hidden">Understanding the internals of the Clang <a id="dx1-46020" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>driver can help us identify the problem at hand. As mentioned earlier, the <code class="calibre13">clang </code>executable acts as a driver in this context, running two separate processes (refer to <a href="#Figure2.21" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 2.21</a>). Therefore, if we wish to debug the compiler, we need to run it using the <code class="calibre13">-cc1</code> option.</p>

<p class="hidden">Important note</p>

<p class="hidden">It’s worth mentioning a certain optimization implemented in Clang in 2019 [<a href="B19722_Bib.xhtml#Xllvm_D69825" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">22</a>]. When using the <code class="calibre13">-c </code>option, the Clang driver doesn’t spawn a new process for the compiler:</p>
<pre id="verbatim-29" class="console">$ &lt;...&gt;/llvm-project/install/bin/clang -c hello.cpp  \
                                       -o /tmp/hello.o \
                                       -###
clang version 18.1.0rc ...
InstalledDir: &lt;...&gt;/llvm-project/install/bin
 (in-process)
 "&lt;...&gt;/llvm-project/install/bin/clang-18" "-cc1"..."hello.cpp"
 ...</pre>
<p class="hidden">As shown above, the Clang driver does not spawn a new process and instead calls the ”cc1” tool within the same process. This feature not only improves the compiler’s performance but can also be leveraged for Clang debugging.</p>

<p class="hidden">Upon using the <code class="calibre13">-cc1 </code>option and excluding the <code class="calibre13">-lstdc++ </code>option (which is specific to the second process, the ld linker), the debugger will generate the following output:</p>
<pre id="listing-14" class="source-code">1$ lldb &lt;...&gt;/llvm-project/install/bin/clang -- -cc1 hello.cpp -o /tmp/hello.o 
 

2 ... 
 
3 (lldb) b clang::ParseAST 
 
4 ... 
 
5 (lldb) r 
 

6 ... 
 
72  locations added to breakpoint 1 
 

8 Process 249890 stopped 
 
9 * thread #1, name = ’clang’, stop reason = breakpoint 1.1 
 

10     frame #0: ... at ParseAST.cpp:117:3 
 
11    114 
 

12    115  void clang::ParseAST(Sema &amp;S, bool PrintStats, bool SkipFunctionBodies) { 
 

13    116    // Collect global stats on Decls/Stmts (until we have a module streamer). 
 

14 -&gt; 117    if (PrintStats) { 
 
15    118      Decl::EnableStatistics(); 
 

16    119      Stmt::EnableStatistics(); 
 

17    120    } 
 
18 (lldb) c 
 
19 Process 249890 resuming 
 

20 hello.cpp:1:10: fatal error: ’iostream’ file not found 
 

21 #include &lt;iostream&gt; 
 
22          ^~~~~~~~~~ 
 

231  error generated. 
 
24 Process 249890 exited with status = 1 (0x00000001) 
 

25 (lldb)</pre>
<p class="hidden"><a id="x1-46046r23" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-46047" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.25</strong>: Debugger session with missing search paths </p>
<p class="hidden">Thus, we can see that we were able to successfully <a id="dx1-46048" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>set the breakpoint, but the process ended with an error (see <em class="calibre11">Lines 20-24</em>). This error arose because we omitted certain search paths, which are typically appended implicitly by the Clang driver, necessary to find all the includes required for successful compilation.</p>
<p class="hidden">We can successfully execute the process if we explicitly include all necessary arguments in the compiler invocation. Here’s how to do that:</p>
<pre id="verbatim-30" class="console">lldb &lt;...&gt;/llvm-project/install/bin/clang -- -cc1                    \
     -internal-isystem /usr/include/c++/13                           \
     -internal-isystem /usr/include/c++/13/x86_64-redhat-linux       \
     -internal-isystem &lt;...&gt;/llvm-project/install/lib/clang/18/include \
     -internal-externc-isystem /usr/include                          \
     hello.cpp                                                       \
     -o /tmp/hello.o</pre>
<p class="hidden"><a id="x1-46049r24" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-46050" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.26</strong>: Running the debugger with specified search paths. Host system is Fedora 39 </p>
<p class="hidden">Then we can set the breakpoint for <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">ParseAST</code> and run the debugger. The execution will complete without errors, as shown below:</p>
<pre id="listing-15" class="source-code">1(lldb) b clang::ParseAST 
 
2 ... 
 
3 (lldb) r 
 

4 ... 
 
52  locations added to breakpoint 1 
 

6 Process 251736 stopped 
 
7 * thread #1, name = ’clang’, stop reason = breakpoint 1.1 
 

8    frame #0: 0x00007fffe803eae0 ... at ParseAST.cpp:117:3 
 

9    114 
 
10    115  void clang::ParseAST(Sema &amp;S, bool PrintStats, bool SkipFunctionBodies) { 
 

11    116    // Collect global stats on Decls/Stmts (until we have a module streamer). 
 

12 -&gt; 117    if (PrintStats) { 
 
13    118     Decl::EnableStatistics(); 
 

14    119     Stmt::EnableStatistics(); 
 

15    120    } 
 
16 (lldb) c 
 
17 Process 251736 resuming 
 

18 Process 251736 exited with status = 0 (0x00000000) 
 

19 (lldb)</pre>
<p class="hidden"><a id="x1-46070r25" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-46071" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.27</strong>: Successful debugger session for compiler </p>
<p class="hidden">In conclusion, we have successfully <a id="dx1-46072" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>demonstrated the debugging of a Clang compiler invocation. The techniques presented can be effectively employed for exploring the internals of a compiler and addressing compiler-related bugs. <a id="x1-46073r79" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>



<h2 data-number="1.2.4" id="sigil_toc_id_36" class="likechapterhead">2.4  <a id="x1-470004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Clang frontend overview</h2>
<p class="hidden">It’s evident that the Clang compiler toolchain conforms to the pattern widely described in various compiler books [<a href="B19722_Bib.xhtml#XAho2006Compilers" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">1</a>, <a href="B19722_Bib.xhtml#Xbook_engineering_a_compiler" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">18</a>]. However, Clang’s frontend part <a id="dx1-47001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>diverges significantly from a typical compiler frontend. The primary reason for this distinction is the complexity of the C++ language. Some features, such as macros, can modify the source code itself, while others, such as typedef, can influence the kind of token. Clang can also generate output in a variety of formats. For instance, the following command generates an aesthetically pleasing HTML view of the program shown in <a href="#x1-37021r5" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Figure 2.5</em></a>:</p>
<pre id="verbatim-31" class="console">$ &lt;...&gt;/llvm-project/install/bin/clang -cc1 -emit-html max.cpp</pre>
<p class="hidden">Take note that we pass the argument to emit the HTML form of the source program to the Clang frontend, specified with the <code class="calibre13">-cc1 </code>option. Alternatively, you can pass an option to the frontend via the <code class="calibre13">-Xclang </code>option, which requires an additional argument representing the option itself, for example:</p>
<pre id="verbatim-32" class="console">$ &lt;...&gt;/llvm-project/install/bin/clang -Xclang -emit-html max.cpp \
                                       -fsyntax-only</pre>
<p class="hidden">You may notice that, in the preceding command, we utilized the <code class="calibre13">-fsyntax-only</code> option, instructing Clang to only execute the preprocessor, parser, and semantic analysis stages.</p>
<p class="hidden">Accordingly, we can instruct the Clang frontend to perform different actions and produce varying types of output based on the provided compilation options. The base class for these actions is termed <code class="calibre13">FrontendAction </code>. <a id="x1-47002r93" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>

<h3 data-number="1.2.4.1" id="sigil_toc_id_37" class="likesectionhead">2.4.1  <a id="x1-480001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Frontend action</h3>
<p class="hidden">The Clang frontend is capable of executing only one <a id="dx1-48001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>frontend action at a time. A frontend action is a specific task or process that the frontend performs based on the provided compiler option. The following is a list of some possible frontend actions (the table only includes a subset of the available frontend actions):</p>
<div><div><table id="TBL-2" class="tabular">
<tbody class="calibre19">
<tr class="odd">
<td class="calibre20"><hr class="calibre21"/>
</td>
<td class="calibre20"><hr class="calibre21"/>
</td>
<td class="calibre20"><hr class="calibre21"/>
</td>
</tr>
<tr id="TBL-2-1-" class="even">
<td id="TBL-2-1-1" class="td">FrontendAction</td>
<td id="TBL-2-1-2" class="td">Compiler option</td>
<td id="TBL-2-1-3" class="td">Description</td>
</tr>
<tr class="odd">
<td class="calibre20"><hr class="calibre21"/>
</td>
<td class="calibre20"><hr class="calibre21"/>
</td>
<td class="calibre20"><hr class="calibre21"/>
</td>
</tr>
<tr id="TBL-2-2-" class="even">
<td id="TBL-2-2-1" class="td">EmitObjAction</td>
<td id="TBL-2-2-2" class="td"><code class="calibre22">-emit-obj </code>(default)</td>
<td id="TBL-2-2-3" class="td">Compile to an object file</td>
</tr>
<tr class="odd">
<td class="calibre20"><hr class="calibre21"/>
</td>
<td class="calibre20"><hr class="calibre21"/>
</td>
<td class="calibre20"><hr class="calibre21"/>
</td>
</tr>
<tr id="TBL-2-3-" class="even">
<td id="TBL-2-3-1" class="td">EmitBCAction</td>
<td id="TBL-2-3-2" class="td"><code class="calibre22">-emit-llvm-bc </code></td>
<td id="TBL-2-3-3" class="td">Compile to LLVM bytecode</td>
</tr>
<tr class="odd">
<td class="calibre20"><hr class="calibre21"/>
</td>
<td class="calibre20"><hr class="calibre21"/>
</td>
<td class="calibre20"><hr class="calibre21"/>
</td>
</tr>
<tr id="TBL-2-4-" class="even">
<td id="TBL-2-4-1" class="td">EmitLLVMAction</td>
<td id="TBL-2-4-2" class="td"><code class="calibre22">-emit-llvm </code></td>
<td id="TBL-2-4-3" class="td">Compile to LLVM readable form</td>
</tr>
<tr class="odd">
<td class="calibre20"><hr class="calibre21"/>
</td>
<td class="calibre20"><hr class="calibre21"/>
</td>
<td class="calibre20"><hr class="calibre21"/>
</td>
</tr>
<tr id="TBL-2-5-" class="even">
<td id="TBL-2-5-1" class="td">ASTPrintAction</td>
<td id="TBL-2-5-2" class="td"><code class="calibre22">-ast-print </code></td>
<td id="TBL-2-5-3" class="td">Build ASTs and then pretty-print them.</td>
</tr>
<tr class="odd">
<td class="calibre20"><hr class="calibre21"/>
</td>
<td class="calibre20"><hr class="calibre21"/>
</td>
<td class="calibre20"><hr class="calibre21"/>
</td>
</tr>
<tr id="TBL-2-6-" class="even">
<td id="TBL-2-6-1" class="td">HTMLPrintAction</td>
<td id="TBL-2-6-2" class="td"><code class="calibre22">-emit-html </code></td>
<td id="TBL-2-6-3" class="td">Prints the program source in HTML form</td>
</tr>
<tr class="odd">
<td class="calibre20"><hr class="calibre21"/>
</td>
<td class="calibre20"><hr class="calibre21"/>
</td>
<td class="calibre20"><hr class="calibre21"/>
</td>
</tr>
<tr id="TBL-2-7-" class="even">
<td id="TBL-2-7-1" class="td">DumpTokensAction</td>
<td id="TBL-2-7-2" class="td"><code class="calibre22">-dump-tokens </code></td>
<td id="TBL-2-7-3" class="td">Prints preprocessor tokens</td>
</tr>
<tr class="odd">
<td class="calibre20"><hr class="calibre21"/>
</td>
<td class="calibre20"><hr class="calibre21"/>
</td>
<td class="calibre20"><hr class="calibre21"/>
</td>
</tr>
<tr id="TBL-2-8-" class="even">
<td id="TBL-2-8-1" class="td"/>
<td class="calibre20"/>
<td class="calibre20"/>
</tr>
</tbody>
</table>
</div>
<a id="x1-48002r1" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-48003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>
<p class="hidden"><strong class="calibre12">Table 2.1: </strong>Frontend actions </p>
</div>
<div><div><img src="img/Figure2.28_B19722.png" alt="Figure 2.28: Clang frontend components " class="calibre33"/>
</div>
<p class="hidden"><strong class="calibre12">Figure 2.28</strong>: Clang frontend components </p>
</div>
<p class="hidden">The diagram shown in <a href="#Figure2.28" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 2.28</a> illustrates the basic <a id="dx1-48007" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>frontend architecture, which is similar to the architecture shown in <a href="#Figure2.4" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 2.4</a>. However, there are notable differences specific to Clang.</p>
<p class="hidden">One significant change is the naming of the lexer. In Clang, the lexer is referred to as the preprocessor. This naming convention reflects the fact that the lexer implementation is encapsulated within the <code class="calibre13">Preprocessor</code> class. This alteration was inspired by the unique aspects of the C/C++ language, which includes special types of tokens (macros) that require specialized preprocessing.</p>
<p class="hidden">Another noteworthy deviation is found in the parser component. While conventional compilers typically perform both syntax and semantic analysis within the parser, Clang distributes these tasks across different components. The <code class="calibre13">Parser</code> component focuses solely on syntax analysis, while the <code class="calibre13">Sema</code> component handles semantic analysis.</p>
<p class="hidden">Furthermore, Clang offers the ability to produce output in different forms or formats. For example, the <code class="calibre13">CodeGenAction</code> class serves as the base class for various code generation actions, such as <code class="calibre13">EmitObjAction</code> or <code class="calibre13">EmitLLVMAction</code>.</p>
<p class="hidden">We will use the code for the <code class="calibre13">max </code>function from <a href="#x1-37021r5" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 2.5</a> for our future exploration of the Clang frontend’s internals:</p>
<pre class="source-code">1 int max(int a, int b) { 
 
2   if (a &gt; b) 
 

3     return a; 
 
4   return b; 
 
5 }</pre>
<p class="hidden"><a id="x1-48014r27" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-48015" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.29</strong>: Source code for max function: max.cpp </p>
<p class="hidden">By utilizing the <code class="calibre13">-cc1 </code>option, we can directly <a id="dx1-48016" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>invoke the Clang frontend, bypassing the driver. This approach allows us to examine and analyze the inner workings of the Clang frontend in greater detail. <a id="x1-48017r100" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


<h3 data-number="1.2.4.2" id="sigil_toc_id_38" class="likesectionhead">2.4.2  <a id="x1-490002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Preprocessor</h3>
<p class="hidden">The first part is the Lexer <a id="dx1-49001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>, which is called the <a id="dx1-49002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>preprocessor in Clang. Its primary goal is to convert the input program into a stream of tokens. You can print the token stream using the <code class="calibre13">-dump-tokens </code>options as follows:</p>
<pre id="verbatim-33" class="console">$ &lt;...&gt;/llvm-project/install/bin/clang -cc1 -dump-tokens max.cpp</pre>
<p class="hidden">The output of the command is as shown:</p>
<pre id="verbatim-34" class="console">int ’int’        [StartOfLine]  Loc=&lt;max.cpp:1:1&gt;
identifier ’max’         [LeadingSpace] Loc=&lt;max.cpp:1:5&gt;
l_paren ’(’             Loc=&lt;max.cpp:1:8&gt;
int ’int’               Loc=&lt;max.cpp:1:9&gt;
identifier ’a’   [LeadingSpace] Loc=&lt;max.cpp:1:13&gt;
comma ’,’               Loc=&lt;max.cpp:1:14&gt;
int ’int’        [LeadingSpace] Loc=&lt;max.cpp:1:16&gt;
identifier ’b’   [LeadingSpace] Loc=&lt;max.cpp:1:20&gt;
r_paren ’)’             Loc=&lt;max.cpp:1:21&gt;
l_brace ’{’      [LeadingSpace] Loc=&lt;max.cpp:1:23&gt;
if ’if’  [StartOfLine] [LeadingSpace]   Loc=&lt;max.cpp:2:3&gt;
l_paren ’(’      [LeadingSpace] Loc=&lt;max.cpp:2:6&gt;
identifier ’a’          Loc=&lt;max.cpp:2:7&gt;
greater ’&gt;’      [LeadingSpace] Loc=&lt;max.cpp:2:9&gt;
identifier ’b’   [LeadingSpace] Loc=&lt;max.cpp:2:11&gt;
r_paren ’)’             Loc=&lt;max.cpp:2:12&gt;
return ’return’  [StartOfLine] [LeadingSpace]   Loc=&lt;max.cpp:3:5&gt;
identifier ’a’   [LeadingSpace] Loc=&lt;max.cpp:3:12&gt;
semi ’;’                Loc=&lt;max.cpp:3:13&gt;
return ’return’  [StartOfLine] [LeadingSpace]   Loc=&lt;max.cpp:4:3&gt;
identifier ’b’   [LeadingSpace] Loc=&lt;max.cpp:4:10&gt;</pre>
<pre id="verbatim-35" class="console">semi ’;’                Loc=&lt;max.cpp:4:11&gt;
r_brace ’}’      [StartOfLine]  Loc=&lt;max.cpp:5:1&gt;
eof ’’          Loc=&lt;max.cpp:5:2&gt;</pre>
<p class="hidden"><a id="x1-49003r28" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-49004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.30</strong>: Clang dump token output </p>
<p class="hidden">As we can see, there are different types of tokens, such as language keywords (e.g., <code class="calibre13">int</code>, <code class="calibre13">return</code>), identifiers (e.g., <code class="calibre13">max</code>, <code class="calibre13">a</code>, <code class="calibre13">b</code>, etc.), and special symbols (e.g., semicolon, comma, etc.). The tokens for our small program are called <strong class="calibre12">normal</strong> <strong class="calibre12">tokens</strong>, which <a id="dx1-49005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>are returned by the lexer.</p>
<p class="hidden">In addition to normal tokens, Clang <a id="dx1-49006" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>has an <a id="dx1-49007" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>additional type of token called <strong class="calibre12">annotation tokens</strong>. The primary difference is that these <a id="dx1-49008" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>tokens also store additional semantic<br class="calibre3"/>
information. For instance, a sequence of normal tokens can be replaced by the parser with a single annotation token that contains information about the type or C++ scope. The primary reason for using such tokens is performance, as it allows for the prevention of reparsing when the parser needs to backtrack.</p>
<p class="hidden">Since annotation tokens are used in the internal implementation of the parser, it would be good to consider an example of their usage with LLDB. Suppose we have the following C++ code:</p>
<pre class="source-code">1 namespace clangbook { 
 

2 template &lt;typename T&gt; class A {}; 
 

3 } // namespace clangbook 
 
4 clangbook::A&lt;int&gt; a;</pre>
<p class="hidden"><a id="x1-49014r29" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-49015" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.31</strong>: Source code that uses annotation tokens, annotation.cpp </p>
<p class="hidden">The last line of the code declares the <a id="dx1-49016" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>variable <code class="calibre13">a </code>with the following type:<br class="calibre3"/>
<code class="calibre13">clangbook</code><code class="calibre13">::</code><code class="calibre13">A</code><code class="calibre13">&lt;</code><code class="calibre13">int</code><code class="calibre13">&gt;</code>. The type is represented as an annotation token, as shown in the following LLDB session:</p>
<pre id="listing-16" class="source-code">1$ lldb &lt;...&gt;/llvm-project/install/bin/clang -- -cc1 annotation.cpp 
 

2 ... 
 
3 (lldb) b clang::Parser::ConsumeAnnotationToken 
 

4 ... 
 
5 (lldb) r 
 
6 ... 
 
7    608    } 
 
8    609 
 

9    610    SourceLocation ConsumeAnnotationToken() { 
 

10 -&gt; 611      assert(Tok.isAnnotation() &amp;&amp; "wrong consume method"); 
 

11    612      SourceLocation Loc = Tok.getLocation(); 
 

12    613      PrevTokLocation = Tok.getAnnotationEndLoc(); 
 

13    614      PP.Lex(Tok); 
 
14 (lldb) p Tok.getAnnotationRange().printToString(PP.getSourceManager()) 
 

15 (std::string) "&lt;annotation.cpp:4:1, col:17&gt;"</pre>
<p class="hidden"><a id="x1-49032r30" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-49033" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.32</strong>: LLDB session for annotation.cpp </p>
<p class="hidden">As we can see, Clang consumes an annotation token from <em class="calibre11">Line 4 </em>of the program shown in <a href="#x1-49014r29" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 2.31</a>. The token is located between columns 1 and 7. See <a href="#x1-49032r30" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 2.32</a>. This corresponds to the following text used as the token: <code class="calibre13">clangbook</code><code class="calibre13">::</code><code class="calibre13">A</code><code class="calibre13">&lt;</code><code class="calibre13">int</code><code class="calibre13">&gt;</code>. The token consists of other tokens, such as ’clangbook’, ’::’, and so on. Combining all the tokens into one will significantly simplify the parsing and boost the overall parsing performance.</p>
<div><div><img src="img/Figure2.33_B19722.png" alt="Figure 2.33: Preprocessor (clang lexer) class internals " class="calibre34"/>
</div>
<p class="hidden"><strong class="calibre12">Figure 2.33</strong>: Preprocessor (clang lexer) class internals </p>
</div>
<p class="hidden">C/C++ language has some specifics <a id="dx1-49036" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>that influence the internal implementation of the <code class="calibre13">Preprocessor</code> class. The first one is about macros. The <code class="calibre13">Preprocessor</code> class has two different helper classes to retrieve tokens:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15">The <code class="calibre13">Lexer</code> class is used to convert a text buffer into a stream of tokens.</p></li>
<li class="calibre14"><p class="calibre15">The <code class="calibre13">TokenLexer</code> class is used to retrieve tokens from macro expansions.</p></li>
</ul>
<p class="hidden">It should be noted that only one of these helpers can be active at a time.</p>
<p class="hidden">Another specific aspect of C/C++ is the <code class="calibre13">#</code><code class="calibre13">include</code> directive (which is also applicable to the import directive). In this case, we need to maintain a stack of includes, where each include can have its own <code class="calibre13">TokenLexer</code> or <code class="calibre13">Lexer</code>, depending on whether there is a macro expansion within it. As a result, the <code class="calibre13">Preprocessor</code> class keeps a stack of lexers (<code class="calibre13">IncludeMacroStack</code> class) for each <code class="calibre13">#</code><code class="calibre13">include</code> directive, as shown in <a href="#Figure2.33" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 2.33</a>. <a id="x1-49037r105" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


<h3 data-number="1.2.4.3" id="sigil_toc_id_39" class="likesectionhead">2.4.3  <a id="x1-500003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Parser and sema</h3>
<p class="hidden">The parser and sema are crucial <a id="dx1-50001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>components of the Clang <a id="dx1-50002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>compiler frontend. They handle the syntax and semantic analysis of the source code, producing an AST <a id="dx1-50003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>as output. This tree can be visualized for our test program using the following command:</p>
<pre id="verbatim-36" class="console">$ &lt;...&gt;/llvm-project/install/bin/clang -cc1 -ast-dump max.cpp</pre>
<p class="hidden">The output of this command is shown here:</p>
<pre id="verbatim-37" class="console">TranslationUnitDecl 0xa9cb38 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt;
|-TypedefDecl 0xa9d3a8 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt;
implicit __int128_t ’__int128’
| ‘-BuiltinType 0xa9d100 ’__int128’
...
‘-FunctionDecl 0xae6a98 &lt;max.cpp:1:1, line:5:1&gt; line:1:5 max
’int (int, int)’
  |-ParmVarDecl 0xae6930 &lt;col:9, col:13&gt; col:13 used a ’int’
  |-ParmVarDecl 0xae69b0 &lt;col:16, col:20&gt; col:20 used b ’int’
  ‘-CompoundStmt 0xae6cd8 &lt;col:23, line:5:1&gt;
    |-IfStmt 0xae6c70 &lt;line:2:3, line:3:12&gt;
    | |-BinaryOperator 0xae6c08 &lt;line:2:7, col:11&gt; ’bool’ ’&gt;’
    | | |-ImplicitCastExpr 0xae6bd8 &lt;col:7&gt; ’int’ &lt;LValueToRValue&gt;
    | | | ‘-DeclRefExpr 0xae6b98 &lt;col:7&gt; ’int’ lvalue ParmVar 0xae6930
            ’a’ ’int’
    | | ‘-ImplicitCastExpr 0xae6bf0 &lt;col:11&gt; ’int’ &lt;LValueToRValue&gt;
    | |   ‘-DeclRefExpr 0xae6bb8 &lt;col:11&gt; ’int’ lvalue ParmVar 0xae69b0
            ’b’ ’int’
    | ‘-ReturnStmt 0xae6c60 &lt;line:3:5, col:12&gt;
    |   ‘-ImplicitCastExpr 0xae6c48 &lt;col:12&gt; ’int’ &lt;LValueToRValue&gt;
    |     ‘-DeclRefExpr 0xae6c28 &lt;col:12&gt; ’int’ lvalue ParmVar 0xae6930
            ’a’ ’int’
    ‘-ReturnStmt 0xae6cc8 &lt;line:4:3, col:10&gt;
      ‘-ImplicitCastExpr 0xae6cb0 &lt;col:10&gt; ’int’ &lt;LValueToRValue&gt;</pre>
<pre id="verbatim-38" class="console">        ‘-DeclRefExpr 0xae6c90 &lt;col:10&gt; ’int’ lvalue ParmVar 0xae69b0
            ’b’ ’int’</pre>
<p class="hidden"><a id="x1-50004r32" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-50005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.34</strong>: Clang AST dump output </p>
<p class="hidden">Clang utilizes a hand-written recursive-descent parser [<a href="B19722_Bib.xhtml#Xllvm_clangfeatures" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">10</a>]. This parser can be considered simple, and this simplicity was one key reason for its selection. Additionally, the complex rules specified for the C/C++ languages necessitated an ad hoc <a id="dx1-50006" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>parser with easily adaptable rules.</p>
<p class="hidden">Let’s explore how this works with our example. Parsing begins with a top-level declaration known as a <code class="calibre13">TranslationUnitDecl</code>, representing a single translation unit. The C++ standard defines a translation unit as follows [<a href="B19722_Bib.xhtml#Xstandard_cpp20" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">21</a>, lex.separate]:</p>
<p class="hidden">A source file together with all the headers (16.5.1.2) and source files included (15.3) via the preprocessing directive #include, less any source lines skipped by any of the conditional inclusion (15.2) preprocessing directives, is called a translation unit.</p>
<p class="hidden">The parser first recognizes that the initial tokens from the source code correspond to a function definition, as defined in the C++ standard [<a href="B19722_Bib.xhtml#Xstandard_cpp20" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">21</a>, dcl.fct.def.general]:</p>
<pre id="verbatim-39" class="console">function-definition :
        ... declarator ... function-body
        ...</pre>
<p class="hidden"><a id="x1-50007r33" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-50008" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.35</strong>: Function definition for C++ standard </p>
<p class="hidden">The corresponding code follows:</p>
<pre id="listing-17" class="source-code">1int max(...) { 
 
2   ... 
 
3 }</pre>
<p class="hidden"><a id="x1-50012r34" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-50013" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.36</strong>: Part of the example code corresponding to function definition from C++ standard </p>
<p class="hidden">The function definition necessitates a declarator <a id="dx1-50014" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>and function body. We’ll start with the declarator, defined in the C++ standard as [<a href="B19722_Bib.xhtml#Xstandard_cpp20" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">21</a>, dcl.decl.general]:</p>
<pre id="verbatim-40" class="console">declarator:
        ...
        ... parameters-and-qualifiers ...
...
parameters-and-qualifiers:
        ( parameter-declaration-clause ) ...
...
parameter-declaration-clause:
        parameter-declaration-list ...
parameter-declaration-list:
        parameter-declaration
        parameter-declaration-list , parameter-declaration</pre>
<p class="hidden"><a id="x1-50015r35" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-50016" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.37</strong>: Declarator definition for C++ standard </p>
<p class="hidden">In other words, the declarator specifies a list of parameter declarations within brackets. The corresponding piece of code from the source is as follows:</p>
<pre id="listing-18" class="source-code">1... (int a, int b) 
 
2   ...</pre>
<p class="hidden"><a id="x1-50019r36" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-50020" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.38</strong>: Part of the example code corresponding to declarator from C++ standard </p>
<p class="hidden">The function definition, as stated above, also requires a function body. The C++ standard specifies the function body as follows: [<a href="B19722_Bib.xhtml#Xstandard_cpp20" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">21</a>, dcl.fct.def.general]</p>
<pre id="verbatim-41" class="console">function-body:
       ... compound-statement
       ...</pre>
<p class="hidden"><a id="x1-50021r37" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-50022" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.39</strong>: Function body definition for C++ standard </p>
<p class="hidden">Thus the function body consists of a compound statement, which is defined as follows in the C++ standard [<a href="B19722_Bib.xhtml#Xstandard_cpp20" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">21</a>, stmt.block]:</p>
<pre id="verbatim-42" class="console">compound-statement:
       { statement-seq ... }
statement-seq:
       statement
       statement-seq statement</pre>
<p class="hidden"><a id="x1-50023r38" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-50024" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.40</strong>: Compound statement definition for C++ standard </p>
<p class="hidden">Therefore, it describes a sequence of statements enclosed within <code class="calibre13">{...</code> brackets.</p>
<p class="hidden">Our program has two <a id="dx1-50025" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>types of statements: the conditional (<code class="calibre13">if </code>) statement and the <code class="calibre13">return </code>statement. These are represented in the C++ grammar definition as follows [<a href="B19722_Bib.xhtml#Xstandard_cpp20" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">21</a>, stmt.pre]:</p>
<pre id="verbatim-43" class="console">statement:
        ...
        selection-statement
        ...
        jump-statement
        ...</pre>
<p class="hidden"><a id="x1-50026r39" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-50027" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.41</strong>: Statement definition for C++ standard </p>
<p class="hidden">In this context, the <code class="calibre13">selection </code>statement corresponds to the <code class="calibre13">if</code> condition in our program, while the <code class="calibre13">jump </code>statement corresponds to the <code class="calibre13">return</code> operator.</p>
<p class="hidden">Let’s examine the <code class="calibre13">jum </code>statement in more detail [<a href="B19722_Bib.xhtml#Xstandard_cpp20" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">21</a>, stmt.jump.general]:</p>
<pre id="verbatim-44" class="console">jump-statement:
        ...
        return expr-or-braced-init-list;
        ...</pre>
<p class="hidden"><a id="x1-50028r40" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-50029" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.42</strong>: jump statement definition for C++ standard </p>
<p class="hidden">where <code class="calibre13">expr-or-braced-init-list </code>is defined as [<a href="B19722_Bib.xhtml#Xstandard_cpp20" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">21</a>, dcl.init.general]:</p>
<pre id="verbatim-45" class="console">expr-or-braced-init-list:
        expression
        ...</pre>
<p class="hidden"><a id="x1-50030r41" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-50031" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.43</strong>: Return expression definition for C++ standard </p>
<p class="hidden">In this context, the <code class="calibre13">return</code> keyword is followed by an expression and a semicolon. In our case, there’s an implicit cast expression that automatically converts the variable into the required type (<code class="calibre13">int </code>).</p>
<p class="hidden">It can be enlightening to <a id="dx1-50032" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>examine the parser’s operation through the LLDB <a id="dx1-50033" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>debugger:</p>
<pre id="verbatim-46" class="console">$ lldb &lt;...&gt;/llvm-project/install/bin/clang -- -cc1 max.cpp</pre>
<p class="hidden">The debugger session output is shown in <a href="#x1-50054r42" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 2.44</a>. As you can see, on <em class="calibre11">Line 1</em>, we’ve set a breakpoint for the parsing of return statements. Our program has two return statements. We bypass the first call (line 4) and halt at the second method invocation (<em class="calibre11">Line 9</em>). The backtrace (from the ’bt’ command at <em class="calibre11">Line 13</em>) displays the call stack for the parsing process. This stack mirrors the parsing blocks we described earlier, adhering to the C++ grammar detailed in [<a href="B19722_Bib.xhtml#Xstandard_cpp20" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">21</a>, lex.separate].</p>
<pre id="listing-19" class="source-code">1(lldb) b clang::Parser::ParseReturnStatement 
 

2 (lldb) r 
 
3 ... 
 
4 (lldb) c 
 
5 ... 
 
6 * thread #1, name = ’clang’, stop reason = breakpoint 1.1 
 

7    frame #0: ... clang::Parser::ParseReturnStatement(...) ... 
 

8    2421 StmtResult Parser::ParseReturnStatement() { 
 

9 -&gt; 2422   assert((Tok.is(tok::kw_return) || Tok.is(tok::kw_co_return)) &amp;&amp; 
 

10    2423         "Not a return stmt!"); 
 

11    2424   bool IsCoreturn = Tok.is(tok::kw_co_return); 
 

12    2425   SourceLocation ReturnLoc = ConsumeToken();  // eat the ’return’. 
 

13 (lldb) bt 
 
14   * frame #0: ... clang::Parser::ParseReturnStatement( ... 
 

15    ... 
 
16    frame #2: ... clang::Parser::ParseStatementOrDeclaration( ... 
 

17    frame #3: ... clang::Parser::ParseCompoundStatementBody( ... 
 

18    frame #4: ... clang::Parser::ParseFunctionStatementBody( ... 
 

19    frame #5: ... clang::Parser::ParseFunctionDefinition( ... 
 

20    ...</pre>
<p class="hidden"><a id="x1-50054r42" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-50055" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.44</strong>: Second return statement parsing at max.cpp example program </p>
<p class="hidden">The parsing results in the generation of AST. We can also inspect the process of AST creation using the debugger. To do this, we need to <a id="dx1-50056" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>set a corresponding breakpoint at the <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">ReturnStmt</code><code class="calibre13">::</code><code class="calibre13">Create</code> method:</p>
<pre id="listing-20" class="source-code">1$ lldb &lt;...&gt;/llvm-project/install/bin/clang -- -cc1 max.cpp 
 

2 ... 
 
3 (lldb) b clang::ReturnStmt::Create 
 
4 (lldb) r 
 
5 ... 
 

6 (lldb) c 
 
7 ... 
 
8 * thread #1, name = ’clang’, stop reason = breakpoint 1.1 
 

9    frame #0: ... clang::ReturnStmt::Create(...) at Stmt.cpp:1205:8 
 

10    1202 
 
11    1203 ReturnStmt *ReturnStmt::Create(const ASTContext &amp;Ctx, SourceLocation RL, 
 

12    1204                              Expr *E, const VarDecl *NRVOCandidate) { 
 

13 -&gt; 1205   bool HasNRVOCandidate = NRVOCandidate != nullptr; 
 

14    1206   ... 
 
15    1207   ... 
 
16    1208   return new (Mem) ReturnStmt(RL, E, NRVOCandidate); 
 

17 (lldb) bt 
 
18 * thread #1, name = ’clang’, stop reason = breakpoint 1.1 
 

19   * frame #0: ... clang::ReturnStmt::Create( ... 
 

20    frame #1: ... clang::Sema::BuildReturnStmt( ... 
 

21    frame #2: ... clang::Sema::ActOnReturnStmt( ... 
 

22    frame #3: ... clang::Parser::ParseReturnStatement( ... 
 

23    frame #4: ... clang::Parser::ParseStatementOrDeclarationAfterAttributes( ... 
 

24    ...</pre>
<p class="hidden"><a id="x1-50081r43" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-50082" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.45</strong>: Breakpoint at clang::ReturnStmt::Create </p>
<p class="hidden">As can be seen, the AST node for the return statement is created by the Sema component.</p>
<p class="hidden">The beginning of the return statement <a id="dx1-50083" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>parser can be located in frame 4:</p>
<pre id="listing-21" class="source-code">1(lldb) f 4 
 
2 frame #4: ... clang::Parser::ParseStatementOrDeclarationAfterAttributes( ... 
 

3    323     SemiError = "break"; 
 
4    324     break; 
 

5    325    case tok::kw_return:             // C99 6.8.6.4: return-statement 
 

6 -&gt; 326     Res = ParseReturnStatement(); 
 

7    327     SemiError = "return"; 
 
8    328     break; 
 

9    329    case tok::kw_co_return:           // C++ Coroutines: ... 
 

10 (lldb)</pre>
<p class="hidden"><a id="x1-50094r44" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-50095" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 2.46</strong>: Return statement parsing at debugger </p>
<p class="hidden">As we can observe, there is a reference to the C99 standard [<a href="B19722_Bib.xhtml#Xstandard_c99" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">25</a>] for the corresponding statement. The standard [<a href="B19722_Bib.xhtml#Xstandard_c99" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">25</a>] provides a detailed description of the statement and the process for handling it.</p>
<p class="hidden">The code assumes that the current token is of type <code class="calibre13">tok</code><code class="calibre13">::</code><code class="calibre13">kw_return</code>, and in this case, the parser invokes the relevant <code class="calibre13">clang</code><code class="calibre13">::</code><code class="calibre13">Parser</code><code class="calibre13">::</code><code class="calibre13">ParseReturnStatement</code> method.</p>
<p class="hidden">While the process of AST node creation can vary across different C++ constructs, it generally follows the pattern displayed in <a href="#Figure2.47" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 2.47</a>.</p>
<div><div><img src="img/Figure2.47_B19722.png" alt="Figure 2.47: C++ parsing in Clang frontend " class="calibre35"/>
</div>
<p class="hidden"><strong class="calibre12">Figure 2.47</strong>: C++ parsing in Clang frontend </p>
</div>
<p class="hidden">In <a href="#Figure2.47" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 2.47</a>, the square boxes represent the corresponding classes, and the function calls are represented as edges with the called function shown as the edge label. As can be seen, the <code class="calibre13">Parser</code> invokes the <code class="calibre13">Preprocessor</code><code class="calibre13">::</code><code class="calibre13">Lex</code> method to retrieve a token from the lexer. It then calls a method corresponding to the token, for example, <code class="calibre13">Parser</code><code class="calibre13">:</code><code class="calibre13">ParseXXX</code> for the token <code class="calibre13">XXX</code>. This method then calls <code class="calibre13">Sema</code><code class="calibre13">::</code><code class="calibre13">ActOnXXX</code>, which creates the corresponding object using <code class="calibre13">XXX</code><code class="calibre13">::</code><code class="calibre13">Create</code>. The process is then repeated with a new token.</p>
<p class="hidden">With this, we have now fully explored how the <a id="dx1-50098" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>typical compiler frontend flow is implemented in Clang. We can see how the lexer component (the preprocessor) works in tandem with the parser (which comprises the parser and sema components) to produce the primary data structure for future code generation: the Abstract Syntax Tree (AST). The AST is not only essential for code generation but also for code analysis and modification. Clang provides easy access to the AST, thereby enabling the development of a diverse range of compiler tools. <a id="x1-50099r99" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>



<h2 data-number="1.2.5" id="sigil_toc_id_40" class="likechapterhead">2.5  <a id="x1-510005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Summary</h2>
<p class="hidden">In this chapter, we have acquired a basic understanding of compiler architecture and delved into the various stages of the compilation process, with a focus on the Clang driver. We have explored the internals of the Clang frontend, studying the Preprocessor that transforms a program into a set of tokens, and the Parser, which interacts with a component called ’Sema’. Together, these elements perform syntax and semantic analysis.</p>
<p class="hidden">The upcoming chapter will center on the Clang Abstract Syntax Tree (AST)—the primary data structure employed in various Clang tools. We will discuss its construction and the methods for traversing it. <a id="x1-51001r126" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


<h2 data-number="1.2.6" id="sigil_toc_id_41" class="likechapterhead">2.6  <a id="x1-520006" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Further reading</h2>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15">Working Draft, Standard for Programming Language C++: <a href="https://eel.is/c++draft/" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">https://eel.is/c++draft/</a></p></li>
<li class="calibre14"><p class="calibre15">“Clang” CFE Internals Manual: <a href="https://clang.llvm.org/docs/InternalsManual.html" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">https://clang.llvm.org/docs/InternalsManual.html</a></p></li>
<li class="calibre14"><p class="calibre15">Keith Cooper and Linda Torczon: Engineering A Compiler, 2012 [<a href="B19722_Bib.xhtml#Xbook_engineering_a_compiler" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">18</a>]</p></li>
</ul>
<p class="hidden"><a id="x1-52001r56" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


</div>
</div>
</body></html>