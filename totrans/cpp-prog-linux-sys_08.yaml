- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Clocks, Timers, and Signals in Linux
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will commence by exploring the various timers available
    in the Linux environment. Subsequently, we will delve into the significance of
    the clock epoch and delve into the concept of UNIX time. Following this, we will
    unveil the methodology for employing POSIX in Linux to precisely measure time
    intervals. Transitioning further, we will uncover the realm of `std::chrono` and
    examine the capabilities that C++ offers for effective time-related operations.
    Our journey then progresses to a comprehensive examination of duration, timepoints,
    and clocks as delineated within the `std::chrono` framework. Venturing onward,
    we will acquaint ourselves with the diverse array of clocks at our disposal within
    `std::chrono`. As we navigate our path, we will take our initial steps into harnessing
    the calendar functionalities provided by `std::chrono`. In the final leg of our
    exploration, we will become familiar with time zones and refine our expertise
    in executing seamless time conversions using the powerful tools of `std::chrono`.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Exploring timers in Linux
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling time in C++
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using clocks, timers, and ratios
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using calendar and time zone capabilities
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let’s get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All examples in this chapter have been tested in an environment with the following
    configuration:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Linux Mint 21 Cinnamon edition.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GCC 13.2 with compiler flags: `-std=c++20`.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A stable internet connection.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please make sure your environment is at least this recent. For all the examples,
    you can alternatively use [https://godbolt.org/](https://godbolt.org/).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All code examples in this chapter are available for download from [https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%208](https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%208).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling time in Linux
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Timing is an essential aspect of any computer system, and Linux is no exception.
    In Linux, there are different types of timers available, each designed to handle
    specific tasks and requirements.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: These timers can be used to measure the execution time of programs, schedule
    tasks, trigger events, and more. In this section, we’ll explore the different
    types of timers available in Linux and how to use them effectively.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the different kinds of timers used in the Linux system:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '**System timers**: The Linux kernel uses system timers to keep track of the
    time and schedule various tasks. System timers are used to measure the system
    uptime, delay, and timeouts. The most important system timer in Linux is the *Jiffies*
    timer, which increments by 1 with every tick of the system clock. The Jiffies
    timer is used to track the time elapsed since the system booted up, and it is
    frequently used by various kernel modules and drivers.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/dev/rtc` device file or the `hwclock` command-line tool. The RTC is used
    to synchronize the system time during startup and to maintain an accurate timestamp
    for system events.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High-Resolution Timers (HRTs)**: HRTs provide nanosecond-level resolution,
    which makes them suitable for real-time applications that require precise timing.
    HRTs can be used to measure the execution time of a code segment, schedule events
    with high accuracy, or drive high-speed hardware.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timer_create()`, `timer_settime()`, and `timer_delete()` system calls.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timer queues**: Timer queues are a mechanism provided by the Linux kernel
    to schedule events and timeouts. Timer queues are implemented as a priority queue
    of events, where each event is associated with a timer. Timer queues can be used
    to schedule periodic tasks, implement timeouts, or trigger events at specific
    intervals. Timer queues are used extensively in various kernel modules and device
    drivers.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But speaking about timers, we first need to understand what time means in computer
    systems. Let’s have a look.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Linux epoch
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In computing, an *epoch* refers to a specific point in time used as a reference
    for measuring time in a particular system or context. It serves as a starting
    point from which other time values are calculated or represented. In other words,
    this is the time from when the computer measures the system time.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: The epoch is often defined as a specific point in time, typically represented
    as the number of seconds or milliseconds, or other time intervals even smaller
    than a millisecond elapsed since a particular epoch time. The choice of epoch
    varies depending on the system and context. For example, in UNIX-like systems,
    which Linux is, the epoch is defined as *January 1, 1970, at 00:00:00 UTC* (Coordinated
    Universal Time). This epoch time is often referred to as the *UNIX epoch* or *UNIX
    time*. The time values in UNIX-based systems are typically represented as the
    number of seconds elapsed since the UNIX epoch.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Now, having a better understanding of the UNIX epoch, let’s have a look at some
    examples of how to use these timers in practice.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Using timers in Linux
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we already know about the different types of timers available in Linux,
    let’s explore how to use them in our applications. We will look at an example
    that starts a POSIX timer and waits until it is signaled:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, we define a lambda handler that will be called whenever the
    timer expires. Inside the handler, we print a message indicating that the timer
    has expired and set the exit condition of the busy loop.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: We set up the signal handler using the `sigaction` function. Then, we configure
    the timer using the `it_interval` and `it_value` members of the `itimerval` structure.
    After configuring the timer, we start it by calling the `setitimer` POSIX function
    with the `ITIMER_REAL` option, which sets a real-time timer that sends `SIGALRM`
    signals when it expires. We enter a loop to keep the program running indefinitely.
    The `sleep(1)` call inside the loop ensures that the program does not exit immediately
    and allows the timer to trigger.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the program is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Another common task in software development is measuring the execution time
    of a code segment. It can also be achieved by using the POSIX time capabilities.
    To measure the execution time of a code segment, we can use an HRT in POSIX.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'To use an HRT in POSIX, we will use the `clock_gettime()` function along with
    the `CLOCK_MONOTONIC` clock ID. Here’s an example demonstrating the usage of HRTs
    in POSIX:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, we declare two `timespec` structures, `start` and `end`, to
    hold the start and end timestamps of the timer. We use the `clock_gettime()` function
    to obtain the current time with a high-resolution clock.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'We call `clock_gettime()` twice: once at the beginning of the task (to record
    the start time) and once at the end (to record the end time). The `CLOCK_MONOTONIC`
    clock ID is used, which represents a monotonic clock unaffected by system time
    adjustments.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: After capturing the start and end timestamps, we calculate the elapsed time
    by subtracting the respective second and nanosecond components of the timestamps.
    The result is then printed as the elapsed time in seconds.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'The example output in our test lab is as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Keep in mind that in your environment, the result could be different.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Note that this example demonstrates one way to measure execution time using
    a timer. Depending on your requirements, you can choose different timer mechanisms.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: POSIX timer characteristics
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at some of the characteristics that POSIX timers have:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '**Powerful and flexible**: POSIX timers provide a rich set of features, including
    different timer types (for example, interval timers and one-shot timers), various
    clock sources, and precise control over timer behavior'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Low-level control**: POSIX timers offer fine-grained control over timer settings,
    such as signal handling and timer expiration behavior'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Legacy support**: POSIX timers are part of the POSIX API and have been available
    on UNIX-like systems for a long time, making them suitable if you need to maintain
    compatibility with legacy code or specific POSIX requirements'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Platform-specific**: POSIX timers are not available on all platforms, so
    if portability is a concern, it is better to switch to a more suitable choice'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But what better alternative do we have in C++? We will see in the next section.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Handling time in C++
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While POSIX timers have their own merits, in C++ there are libraries that provide
    higher-level and more portable solutions for timing and time-related operations.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'One good example of such a library is `std::chrono`. This is a C++ library
    that provides a set of utilities for working with time-related operations and
    measurements. It is part of the Standard Library and is included in the `<chrono>`
    header. The `std::chrono` library provides a flexible and type-safe mechanism
    for representing and manipulating time durations, time points, clocks, and time-related
    operations. By using `std::chrono`, you will benefit from the standardization,
    type safety, flexibility, and integration that comes with the C++ Standard Library.
    Some of the advantages of `std::chrono` compared to the traditional POSIX approach
    are as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '`std::chrono` is part of the C++ Standard Library, making it a cross-platform
    solution that works consistently across different operating systems and compilers.
    POSIX, on the other hand, is specific to UNIX-like systems and may not be available
    or behave consistently on all platforms.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::chrono` provides type-safe representations of time durations and points
    in time. It offers a rich set of duration and clock types that can be used together
    seamlessly, enabling safer and more expressive code. POSIX timers, while powerful,
    often rely on low-level types, such as the `timespec` struct, which can be error-prone
    and require manual conversions.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::chrono` offers a flexible and expressive interface for time-related operations.
    It provides convenient ways to perform arithmetic operations on durations, convert
    between different time units, and format time values. POSIX timers, while suitable
    for specific timing requirements, lack the high-level abstractions and utilities
    provided by `std::chrono`.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::chrono` seamlessly integrates with other parts of the C++ Standard Library.
    It can be used in conjunction with algorithms, containers, and concurrency facilities,
    allowing for more cohesive and efficient code. POSIX timers, being a lower-level
    interface, may require additional work to integrate with other C++ Standard Library
    components.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::chrono` benefits from the advancements and features introduced in modern
    C++. It supports features such as user-defined literals, lambda functions, and
    type deduction, making it easier to write concise and expressive code. POSIX timers,
    being part of the POSIX API, may not fully leverage the modern C++ language features.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `<chrono>` library provides a comprehensive set of features for working
    with time-related operations, such as measuring time durations, representing points
    in time, and performing various time calculations and conversions. Here are some
    key components and features of `std::chrono`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '`<chrono>` defines several clock types that represent different sources of
    time and different epochs. `std::chrono::system_clock` represents the system-wide
    RTC, which is adjustable. `std::chrono::steady_clock` represents a steady monotonic
    clock unaffected by system time adjustments, and `std::chrono::high_resolution_clock`
    represents a clock with the highest available resolution (if supported by the
    system).'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::chrono::duration` template class represents a time interval, that is,
    a specified period of time The duration is the tick count using a specific unit
    of time; for example, a duration of five hours is five ticks of the unit *hour*.
    Different types of durations can be defined, from years to nanoseconds. Example
    durations include `std::chrono::seconds`, `std::chrono::milliseconds`, and `std::chrono::months`.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::chrono::time_point` template class is parameterized by a clock and duration
    type.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::chrono` allows for conversions between durations and time points, as
    well as arithmetic operations involving durations. It provides functions such
    as `std::chrono::duration_cast` to convert between different durations and `std::chrono::time_point_cast`
    to convert between different time points.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::chrono` provides utilities for querying the current time, such as `std::chrono::system_clock::now()`,
    which returns the current system time point.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::chrono` provides user-defined, time-related literals in the `std::literals::chrono_literals`
    namespace. They allow you to create `std::chrono::duration` objects using literals
    with time units. This makes the code more readable and convenient when dealing
    with time-related computations.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::chrono` provides calendar capabilities, such as working with days, months,
    and years. It also provides notation for leap years and leap seconds.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::chrono` provides information about different time zones across the globe
    depending on the geographical location.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using `std::chrono`, you can perform accurate and portable time measurements,
    handle timeouts, calculate time differences, and work with time-related operations
    in a type-safe manner.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a link to the `<chrono>` header in the C++ reference documentation:
    [https://en.cppreference.com/w/cpp/header/chrono](https://en.cppreference.com/w/cpp/header/chrono).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how to use `std::chrono` to measure the execution time
    of a code snippet:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, `std::chrono::steady_clock` is used to measure the
    execution time of the same function as from the previous example (see marker `{2}`).
    The `start` and `end` variables represent the *timepoints* taken before and after
    the code execution using the `now()` static function of `steady_clock` (see markers
    `{1}` and `{3}`). `std::chrono::duration_cast` is used to convert the calculated
    duration between the time points in milliseconds (see marker `{4}`).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the program should be similar to this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, the `std::chrono::duration` class has a `count()` method, which
    returns the number of units in a specific duration; see marker `{5}`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: But let’s get deeper into how this really works.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Using clocks, timers, and ratios
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before getting into more examples with clocks and timers, we first have to get
    a better understanding of how the chrono library defines a *duration*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in the previous example, a duration is the distance between two points
    of time, called *timepoints*. In our previous example, these were the `start`
    and `end` timepoints.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Timepoint and duration](img/Figure_8.1_B20833.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Timepoint and duration
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'The duration itself is a combination of the count of ticks and a fraction that
    represents the time in seconds from one tick to the next. The fraction is represented
    by the `std::ratio` class. Here are some examples:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding example, we have defined the duration of six minutes in several
    ways. In the `six_minutes_1` variable, we have specified this duration as a value
    of 360 seconds. The same duration can also be represented as 1/10 of an hour –
    the `six_minutes_2` variable. The last two durations – `six_minutes_3` and `six_minutes_4`
    – represent the same duration of six minutes but using the `std::chrono` predefined
    duration types and literals. Here is the output of the preceding code block:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, `std::duration` also provides pretty formatting capabilities
    so that once the duration is passed to a string or stream operator, it will add
    the corresponding suffix so we can see the duration type.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: In order to ensure that the preceding durations really correspond to six minutes,
    we have tested them against `static_assert`, which would fail the program if they
    don’t match.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a link to the `std::duration` class in the C++ reference documentation:
    [https://en.cppreference.com/w/cpp/chrono/duration](https://en.cppreference.com/w/cpp/chrono/duration).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go back to our previous example, slightly change it, and have a closer
    look at a `timepoint` object:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, we again construct a `timepoint` object, `start`, in which we
    get the time at the moment of its instantiation from the `steady_clock` instance
    of the Linux system; see marker `{1}`. The `std::chrono::time_point` class stores
    a `std::chrono::duration` value, which actually indicates the time interval from
    the start of the clock’s epoch. In order to allow getting that value, the `std::chrono::duration`
    class exposes a method that returns the duration, `time_since_epoch()`, in nanoseconds;
    see marker `{2}`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the result of the preceding code executed in our test environment.
    Please keep in mind that if you execute this code, the result could be different:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Having a time duration in nanoseconds could be inconvenient in some use cases,
    such as our example of calculating the time it takes for a code block to execute.
    However converting a duration from a higher-precision type into a lower-precision
    type results in a loss of precision. Therefore, if we need to see the duration
    in minutes then in nanoseconds, we can’t just do this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is because the preceding code won’t compile. The reason behind this is
    that the `time_since_epoch()` method returns the duration with a precision of
    nanoseconds. If we store that data in minutes, we will certainly lose precision.
    In order to be sure that this won’t be done by mistake, the compiler stops us.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'But how can we intentionally convert duration values from one precision into
    another? As we saw in the first example, we can use the `std::chrono::duration_cast`
    function provided by the library. It enables us to make conversions from a duration
    type with higher precision to a duration type with lower precision. Let’s rework
    the preceding example and see how this works:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see in marker `{1}`, we again get the duration in nanoseconds from
    the clock’s epoch. In marker `{2}`, we initialize another duration variable but
    this time in minutes. In order to do so, we use `std::chrono::duration_cast<minutes>`,
    which converts the value from the source resolution into the destination one and
    truncates it down to the closest integer value. In our test environment, the result
    of the preceding code block is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can see that the measured duration in nanoseconds is equivalent to about
    586.78 minutes but it is truncated down to 586 minutes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we could also need to round up rather than just truncate down values.
    Fortunately, the `chrono` library gives us this capability with the `std::chrono::round`
    method, which does exactly this. Here is an example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this example, we define two duration variables, `dur_sec_1` and `dur_sec_2`.
    `dur_sec_1` is initialized to 55 seconds (see marker `{1}`) and `dur_sec_2` is
    initialized to 65 seconds (see marker `{2}`). Then, using the `std::chrono::round`
    function, we initialize another two duration variables but this time with a resolution
    of minutes (see markers `{3}` and `{4}`). Both duration variables are rounded
    to one minute:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `chrono` library also supplies methods for `ceil` and `floor` durations.
    All of them can be found in the official documentation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'The documentation for `round`, `floor`, and `ceil` methods for duration values
    can be found at these links: [https://en.cppreference.com/w/cpp/chrono/duration/round](https://en.cppreference.com/w/cpp/chrono/duration/round),
    https://en.cppreference.com/w/cpp/chrono/duration/floor, and [https://en.cppreference.com/w/cpp/chrono/duration/ceil](https://en.cppreference.com/w/cpp/chrono/duration/ceil).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Since we have a better understanding of time operations, let’s have a closer
    look at the different types of clocks that `std::chrono` provides for us.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: More about clocks in C++20
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already used `std::chrono::steady_clock` in our previous examples. This is
    just one of the predefined clocks in the C++ `chrono` library that you can use.
    `std::chrono::steady_clock`, as its name suggests, is a clock that is steady.
    This means that it is a monotonic clock in which time only moves forward, and
    its timepoint values are always increasing. It is suitable for use when we want
    to measure intervals of time. Its epoch can vary.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Another frequently used clock is `std::chrono::system_clock`. In Linux, it
    represents the time measured by the system. This means that it is not guaranteed
    to be monotonic, and it can be adjusted at any moment. In Linux, its epoch matches
    the UNIX epoch. Let’s see an example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding example prints the Linux system clock epoch, which corresponds
    to the UNIX epoch – `00:00:00: UTC` on `1` `January 1970`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Keep in mind that `std::chrono::system_clock` doesn’t take into account *leap
    seconds*, which can be added or subtracted from the measured time. In general,
    a leap second is a one-second adjustment of UTC, which can occur twice per year
    to reflect the accuracy of the Earth’s rotation around the Sun.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: More information about leap seconds can be found at [https://en.wikipedia.org/wiki/Leap_second](https://en.wikipedia.org/wiki/Leap_second).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: C++20 introduces several more predefined clocks. Some of them are `std::chrono::utc_clock`,
    which measures UTC, and `std::chrono::tai_clock`, which measures **International
    Atomic** **Time** (**TAI**).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'More information about UTC and TAI can be found here: [https://en.wikipedia.org/wiki/Coordinated_Universal_Time](https://en.wikipedia.org/wiki/Coordinated_Universal_Time)
    and [https://en.wikipedia.org/wiki/International_Atomic_Time](https://en.wikipedia.org/wiki/International_Atomic_Time).'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'A key difference between the TAI and UTC clocks is that the UTC clock is guaranteed
    to take into account the leap-second corrections made since the clock epoch, but
    the TAI clock doesn’t take them into account. Let’s see an example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding example, we get the current time from both clocks – `utc`
    and `tai`. Here is the result:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, regardless of whether both clocks are invoked at the same time,
    they show different times. And their difference is *exactly 37 seconds*. This
    difference comes from the leap-second adjustments made since they were introduced
    back in 1972.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '`std::chrono::utc_clock` applies leap-second adjustments. By using chrono’s
    UTC clock, these leap-second adjustments will be done automatically for you, and
    you don’t need to take any special action. Therefore, the chrono library provides
    a method to convert between clock types – `std::chrono::clock_cast`, which converts
    `std::chrono::time_point` values from one clock into another. Let’s see another
    example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, the `time_point tai` object generated by chrono’s TAI clock
    is converted into a time point from the UTC clock. The result is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we expected, the TAI clock is 37 seconds ahead of the UTC one. Therefore,
    UTC cannot be used to properly measure time differences as a leap second might
    be added or removed.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find all the predefined clocks in the C++ chrono library here: [https://en.cppreference.com/w/cpp/chrono#Clocks](https://en.cppreference.com/w/cpp/chrono#Clocks).'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Now, since we have a good understanding of timing and clocks, let’s see what
    capabilities the C++ chrono library provides for calendars and time zones.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Using calendar and time zone capabilities
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++20 introduces brand-new support for calendar and time zone operations to
    the standard. When we talk about calendar operations, this means operations in
    days, months, and years. They, together with the time zone notion, allow conversions
    of time between different time zones taking into account time zone adjustments
    such as daylight saving time.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define a date and print it with the help of the `chrono` library:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see, the `std::chrono` namespace provides `year`, `month`, and `day`
    classes, which make it easy to work with dates. The benefit of these classes is
    that they provide strict type and boundary checks, some operators for summation
    and subtraction, and formatting capabilities. The result of the preceding code
    is as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you can see, passing the `Month` variable to `operator<<` applies formatting
    so that the value of the month is printed as `Aug`. Also, these classes provide
    validation and boundary checks on the applied values:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding example, we have applied an invalid month and day of the month.
    The result is as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, `month` and `day` values are validated, and when they are passed
    to `operator<<`, it prints that these values are not valid.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'The `year` class represents a year in the proleptic Gregorian calendar, which
    enables us to ask whether the year is a leap year or not:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this example, we first get the current system time – `now` – and then we
    convert it into an object of the `year_month_day` type. This object represents
    a convenient field-based timepoint. It holds `year`, `month`, and `day` objects
    and allows direct access to them. It also supports instantiation from `std::chrono::sys_days`,
    which effectively is a timepoint of the system clock in days. Therefore, we pass
    the `now` timepoint and create the `today` object. Then, we get the `year` object
    – `thisYear` – and it checks whether this is a leap year or not using the `is_leap()`
    method of the `year` class:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As expected, 2023 is not a leap year.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'The `chrono` library heavily utilizes `operator/` for date creation. C++20
    provides about 40 overloads of the parameters of this operator. Let’s see an example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, we create a `year_month_day` object by passing the newly introduced
    *chrono literals* for months, days, and years together with `operator/`. chrono
    provides convenient literals for the creation of days; you just have to append
    `d` to the day value. The same is the case for years, you have to append `y` and
    you construct a `year` object. For months, the chrono library defines named constants
    for all months of the year.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a link to a list of the month constants in the chrono library:
    [https://en.cppreference.com/w/cpp/chrono/month](https://en.cppreference.com/w/cpp/chrono/month).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: During the instantiation of the `year_month_day` object, we pass date values
    using `operator/`. As is visible from the preceding example, chrono supports many
    combinations of day, month, and year values. All of them can be found in the standard
    documentation.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a link to the documentation on all overloads of `operator/`
    for date management: [https://en.cppreference.com/w/cpp/chrono/operator_slash](https://en.cppreference.com/w/cpp/chrono/operator_slash).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'All the used overloads in our example are supposed to create valid `year_month_date`
    objects. Let’s see the output:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As we can see, we have successfully created three separate valid dates with
    the help of chrono literals and `operator/`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Working with time zones in C++
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The C++20 `chrono` library provides capabilities for working with time zones.
    It integrates the IANA time zone database, which contains information about the
    local time in many geographical locations around the globe.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'Find more information about the IANA time zone database here: [https://www.iana.org/time-zones](https://www.iana.org/time-zones).'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `chrono`, you can get a copy of the IANA database and browse it for a
    specific geographical location:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As we can see from the example, in the `std::chrono` namespace, there is a method
    – `get_tzdb()` – that returns a reference to the IANA database. In the database,
    you can find information about its version and also get a sorted list of all available
    `std::chrono::time_zone` objects.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'The `std::chrono::time_zone` class stores information about transitions between
    time zones for its specific geographic area and name. The output from the preceding
    example is as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, once we have all available time zones, let’s try to find a specific one
    based on a geographical location and see what the time is there:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In this example, we again get the list of the available time zones and try
    to find the time zone for the city of `Sofia`. Then, we use the full name of the
    found time zone to create another object that uses a specific geographical location
    and the value of the system time – `std::chrono::zoned_time`. This class represents
    a logical pair between a time zone and a point in time. We also create another
    `zoned_time zt_2` object but for the city of `London`, which represents the same
    time point as `zt_1` but in another geographical location. The result of the preceding
    code is as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们再次获取可用的时区列表，并尝试找到城市`索非亚`的时区。然后，我们使用找到的时区的全名创建另一个对象，该对象使用特定的地理位置和系统时间值——`std::chrono::zoned_time`。这个类代表了一个时区和时间点之间的逻辑对。我们还创建了另一个`zoned_time
    zt_2`对象，但针对的是城市`伦敦`，它代表与`zt_1`相同的时间点，但位于另一个地理位置。上述代码的结果如下：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, both objects display a valid time but with respect to their
    geographical locations. This is how we can safely get the current time in a specific
    geographical location where daylight saving time is also considered.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这两个对象都显示了一个有效的时间，但相对于它们的地理位置而言。这就是我们如何安全地获取特定地理位置的当前时间，同时考虑夏令时的情况。
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the different timers available within the Linux
    environment. Subsequently, we gained an understanding of the significance behind
    the clock epoch and the concept of UNIX time. Following this, we delved into the
    practical implementation of POSIX in Linux for accurate time measurement. Additionally,
    we investigated the realm of `std::chrono` and examined the array of capabilities
    that C++ affords for effective time-related operations. Our exploration then took
    us on a detailed journey through duration, timepoints, and clocks as they are
    defined within the `std::chrono` framework. Moving forward, we acquainted ourselves
    with the various clock types at our disposal within `std::chrono`. As our journey
    continued, we initiated our exploration into the calendar capabilities presented
    by `std::chrono`. Finally, we developed familiarity with time zones and honed
    our proficiency in executing seamless time conversions utilizing the tools offered
    by `std::chrono`. Now, we are ready for the next chapter, where we will go deeper
    into the specifics of the C++ memory model.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Linux环境中可用的不同计时器。随后，我们了解了时钟纪元和UNIX时间概念的重要性。接着，我们深入研究了Linux中POSIX的实际实现，以实现准确的时间测量。此外，我们还研究了`std::chrono`领域，并检查了C++为有效的时间相关操作提供的各种功能。我们的探索随后带我们详细了解了`std::chrono`框架中定义的持续时间、时间点和时钟。向前推进，我们熟悉了`std::chrono`中可用的各种时钟类型。随着我们的旅程继续，我们开始探索`std::chrono`提供的日历功能。最后，我们熟悉了时区，并提高了使用`std::chrono`提供的工具执行无缝时间转换的熟练度。现在，我们已准备好进入下一章，我们将更深入地探讨C++内存模型的细节。
