- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Using Clocks, Timers, and Signals in Linux
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Linux 中使用时钟、定时器和信号
- en: In this chapter, we will commence by exploring the various timers available
    in the Linux environment. Subsequently, we will delve into the significance of
    the clock epoch and delve into the concept of UNIX time. Following this, we will
    unveil the methodology for employing POSIX in Linux to precisely measure time
    intervals. Transitioning further, we will uncover the realm of `std::chrono` and
    examine the capabilities that C++ offers for effective time-related operations.
    Our journey then progresses to a comprehensive examination of duration, timepoints,
    and clocks as delineated within the `std::chrono` framework. Venturing onward,
    we will acquaint ourselves with the diverse array of clocks at our disposal within
    `std::chrono`. As we navigate our path, we will take our initial steps into harnessing
    the calendar functionalities provided by `std::chrono`. In the final leg of our
    exploration, we will become familiar with time zones and refine our expertise
    in executing seamless time conversions using the powerful tools of `std::chrono`.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先探索 Linux 环境中可用的各种定时器。随后，我们将深入研究时钟纪元的重要性，并探讨 UNIX 时间的概念。接着，我们将揭示在 Linux
    中使用 POSIX 精确测量时间间隔的方法。进一步地，我们将揭示 `std::chrono` 的领域，并检查 C++ 为有效的时间相关操作提供的功能。我们的旅程随后进展到对
    `std::chrono` 框架中定义的持续时间、时间点和时钟的全面审查。继续前进，我们将熟悉 `std::chrono` 中可用的各种时钟。在我们导航的过程中，我们将迈出第一步，利用
    `std::chrono` 提供的日历功能。在探索的最后阶段，我们将熟悉时区，并利用 `std::chrono` 的强大工具执行无缝的时间转换。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Exploring timers in Linux
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Linux 中的定时器
- en: Handling time in C++
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C++ 中处理时间
- en: Using clocks, timers, and ratios
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用时钟、定时器和比率
- en: Using calendar and time zone capabilities
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用日历和时区功能
- en: So, let’s get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All examples in this chapter have been tested in an environment with the following
    configuration:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有示例都在以下配置的环境中进行了测试：
- en: Linux Mint 21 Cinnamon edition.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux Mint 21 Cinnamon 版本。
- en: 'GCC 13.2 with compiler flags: `-std=c++20`.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCC 13.2，编译器标志：`-std=c++20`。
- en: A stable internet connection.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稳定的互联网连接。
- en: Please make sure your environment is at least this recent. For all the examples,
    you can alternatively use [https://godbolt.org/](https://godbolt.org/).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请确保您的环境至少是这个版本。对于所有示例，您还可以使用 [https://godbolt.org/](https://godbolt.org/)。
- en: All code examples in this chapter are available for download from [https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%208](https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%208).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的所有代码示例都可以从 [https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%208](https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%208)
    下载。
- en: Handling time in Linux
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Linux 中处理时间
- en: Timing is an essential aspect of any computer system, and Linux is no exception.
    In Linux, there are different types of timers available, each designed to handle
    specific tasks and requirements.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 时间是任何计算机系统的一个基本方面，Linux 也不例外。在 Linux 中，有不同类型的定时器可供使用，每个定时器都设计用于处理特定的任务和需求。
- en: These timers can be used to measure the execution time of programs, schedule
    tasks, trigger events, and more. In this section, we’ll explore the different
    types of timers available in Linux and how to use them effectively.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定时器可以用来测量程序的执行时间、安排任务、触发事件等等。在本节中，我们将探讨 Linux 中可用的不同类型的定时器以及如何有效地使用它们。
- en: 'Here are the different kinds of timers used in the Linux system:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了 Linux 系统中使用的不同类型的定时器：
- en: '**System timers**: The Linux kernel uses system timers to keep track of the
    time and schedule various tasks. System timers are used to measure the system
    uptime, delay, and timeouts. The most important system timer in Linux is the *Jiffies*
    timer, which increments by 1 with every tick of the system clock. The Jiffies
    timer is used to track the time elapsed since the system booted up, and it is
    frequently used by various kernel modules and drivers.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统定时器**：Linux 内核使用系统定时器来跟踪时间和安排各种任务。系统定时器用于测量系统运行时间、延迟和超时。Linux 中最重要的系统定时器是
    *Jiffies* 定时器，它在系统时钟的每次滴答中增加 1。Jiffies 定时器用于跟踪自系统启动以来经过的时间，并且它经常被各种内核模块和驱动程序使用。'
- en: '`/dev/rtc` device file or the `hwclock` command-line tool. The RTC is used
    to synchronize the system time during startup and to maintain an accurate timestamp
    for system events.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dev/rtc` 设备文件或 `hwclock` 命令行工具。RTC 用于在启动时同步系统时间，并维护系统事件的准确时间戳。'
- en: '**High-Resolution Timers (HRTs)**: HRTs provide nanosecond-level resolution,
    which makes them suitable for real-time applications that require precise timing.
    HRTs can be used to measure the execution time of a code segment, schedule events
    with high accuracy, or drive high-speed hardware.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高分辨率计时器（HRTs）**：HRTs 提供纳秒级分辨率，这使得它们适合需要精确计时的实时应用程序。HRTs 可用于测量代码段的执行时间、以高精度安排事件或驱动高速硬件。'
- en: '`timer_create()`, `timer_settime()`, and `timer_delete()` system calls.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timer_create()`、`timer_settime()` 和 `timer_delete()` 系统调用。'
- en: '**Timer queues**: Timer queues are a mechanism provided by the Linux kernel
    to schedule events and timeouts. Timer queues are implemented as a priority queue
    of events, where each event is associated with a timer. Timer queues can be used
    to schedule periodic tasks, implement timeouts, or trigger events at specific
    intervals. Timer queues are used extensively in various kernel modules and device
    drivers.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计时器队列**：计时器队列是 Linux 内核提供的一种调度事件和超时的机制。计时器队列作为事件优先队列实现，其中每个事件都与一个计时器相关联。计时器队列可用于安排周期性任务、实现超时或在特定间隔触发事件。计时器队列在各个内核模块和设备驱动程序中被广泛使用。'
- en: But speaking about timers, we first need to understand what time means in computer
    systems. Let’s have a look.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 但说到计时器，我们首先需要了解在计算机系统中时间意味着什么。让我们看看。
- en: Linux epoch
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux 基准点
- en: In computing, an *epoch* refers to a specific point in time used as a reference
    for measuring time in a particular system or context. It serves as a starting
    point from which other time values are calculated or represented. In other words,
    this is the time from when the computer measures the system time.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，*基准点* 指的是在特定系统或上下文中用作测量时间的参考的具体时间点。它作为其他时间值计算或表示的起点。换句话说，这是计算机测量系统时间的时间起点。
- en: The epoch is often defined as a specific point in time, typically represented
    as the number of seconds or milliseconds, or other time intervals even smaller
    than a millisecond elapsed since a particular epoch time. The choice of epoch
    varies depending on the system and context. For example, in UNIX-like systems,
    which Linux is, the epoch is defined as *January 1, 1970, at 00:00:00 UTC* (Coordinated
    Universal Time). This epoch time is often referred to as the *UNIX epoch* or *UNIX
    time*. The time values in UNIX-based systems are typically represented as the
    number of seconds elapsed since the UNIX epoch.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 基准点通常定义为特定的时间点，通常表示为自特定基准时间点以来经过的秒数、毫秒数或其他小于毫秒的时间间隔。基准点的选择取决于系统和上下文。例如，在 Linux
    类似系统中，Linux 就是这样的系统，基准点被定义为 *1970 年 1 月 1 日 00:00:00 UTC*（协调世界时）。这个基准时间通常被称为 *UNIX
    基准点* 或 *UNIX 时间*。基于 UNIX 的系统中的时间值通常表示为自 UNIX 基准点以来经过的秒数。
- en: Now, having a better understanding of the UNIX epoch, let’s have a look at some
    examples of how to use these timers in practice.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经更好地理解了 UNIX 基准点，让我们看看如何在实践中使用这些计时器的例子。
- en: Using timers in Linux
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Linux 中使用计时器
- en: 'Since we already know about the different types of timers available in Linux,
    let’s explore how to use them in our applications. We will look at an example
    that starts a POSIX timer and waits until it is signaled:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了 Linux 中可用的不同类型的计时器，让我们探索如何在我们的应用程序中使用它们。我们将查看一个启动 POSIX 计时器并等待其被信号的通知的例子：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, we define a lambda handler that will be called whenever the
    timer expires. Inside the handler, we print a message indicating that the timer
    has expired and set the exit condition of the busy loop.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了一个 lambda 处理器，该处理器将在计时器到期时被调用。在处理器内部，我们打印一条消息，表明计时器已到期，并设置繁忙循环的退出条件。
- en: We set up the signal handler using the `sigaction` function. Then, we configure
    the timer using the `it_interval` and `it_value` members of the `itimerval` structure.
    After configuring the timer, we start it by calling the `setitimer` POSIX function
    with the `ITIMER_REAL` option, which sets a real-time timer that sends `SIGALRM`
    signals when it expires. We enter a loop to keep the program running indefinitely.
    The `sleep(1)` call inside the loop ensures that the program does not exit immediately
    and allows the timer to trigger.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`sigaction`函数设置信号处理程序。然后，我们使用`it_interval`和`it_value`成员配置计时器。配置计时器后，我们通过调用带有`ITIMER_REAL`选项的`setitimer`
    POSIX函数来启动它，该选项设置一个实时计时器，在到期时发送`SIGALRM`信号。我们进入一个循环以无限期地运行程序。循环中的`sleep(1)`调用确保程序不会立即退出，并允许计时器触发。
- en: 'The output of the program is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Another common task in software development is measuring the execution time
    of a code segment. It can also be achieved by using the POSIX time capabilities.
    To measure the execution time of a code segment, we can use an HRT in POSIX.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，另一个常见的任务是测量代码段的执行时间。这也可以通过使用POSIX时间功能来实现。要测量代码段的执行时间，我们可以在POSIX中使用高分辨率计时器（HRT）。
- en: 'To use an HRT in POSIX, we will use the `clock_gettime()` function along with
    the `CLOCK_MONOTONIC` clock ID. Here’s an example demonstrating the usage of HRTs
    in POSIX:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要在POSIX中使用HRT，我们将使用`clock_gettime()`函数以及`CLOCK_MONOTONIC`时钟ID。以下是一个演示在POSIX中使用HRT的示例：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, we declare two `timespec` structures, `start` and `end`, to
    hold the start and end timestamps of the timer. We use the `clock_gettime()` function
    to obtain the current time with a high-resolution clock.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们声明了两个`timespec`结构，`start`和`end`，以保存计时器的开始和结束时间戳。我们使用`clock_gettime()`函数使用高分辨率时钟获取当前时间。
- en: 'We call `clock_gettime()` twice: once at the beginning of the task (to record
    the start time) and once at the end (to record the end time). The `CLOCK_MONOTONIC`
    clock ID is used, which represents a monotonic clock unaffected by system time
    adjustments.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`clock_gettime()`两次：一次在任务开始时（记录开始时间）和一次在结束时（记录结束时间）。使用`CLOCK_MONOTONIC`时钟ID，它代表一个不受系统时间调整影响的单调时钟。
- en: After capturing the start and end timestamps, we calculate the elapsed time
    by subtracting the respective second and nanosecond components of the timestamps.
    The result is then printed as the elapsed time in seconds.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在捕获开始和结束时间戳后，我们通过减去时间戳的相应秒和纳秒组件来计算经过的时间。然后将结果打印为经过的时间（以秒为单位）。
- en: 'The example output in our test lab is as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试实验室中的示例输出如下：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Keep in mind that in your environment, the result could be different.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在您的环境中，结果可能会有所不同。
- en: Note that this example demonstrates one way to measure execution time using
    a timer. Depending on your requirements, you can choose different timer mechanisms.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个例子演示了使用计时器测量执行时间的一种方法。根据您的需求，您可以选择不同的计时器机制。
- en: POSIX timer characteristics
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: POSIX计时器特性
- en: 'Let’s look at some of the characteristics that POSIX timers have:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看POSIX计时器的一些特性：
- en: '**Powerful and flexible**: POSIX timers provide a rich set of features, including
    different timer types (for example, interval timers and one-shot timers), various
    clock sources, and precise control over timer behavior'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强大且灵活**：POSIX计时器提供了一组丰富的功能，包括不同的计时器类型（例如，间隔计时器和一次性计时器）、各种时钟源以及精确控制计时器行为。'
- en: '**Low-level control**: POSIX timers offer fine-grained control over timer settings,
    such as signal handling and timer expiration behavior'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低级控制**：POSIX计时器提供了对计时器设置的精细控制，例如信号处理和计时器到期行为。'
- en: '**Legacy support**: POSIX timers are part of the POSIX API and have been available
    on UNIX-like systems for a long time, making them suitable if you need to maintain
    compatibility with legacy code or specific POSIX requirements'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向后兼容性支持**：POSIX计时器是POSIX API的一部分，在类UNIX系统上已经可用很长时间了，这使得它们在需要与旧代码或特定POSIX要求保持兼容性时非常合适。'
- en: '**Platform-specific**: POSIX timers are not available on all platforms, so
    if portability is a concern, it is better to switch to a more suitable choice'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台特定**：POSIX计时器并非在所有平台上都可用，因此如果可移植性是一个问题，最好切换到更合适的选择。'
- en: But what better alternative do we have in C++? We will see in the next section.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 但在C++中我们有什么更好的替代方案呢？我们将在下一节中看到。
- en: Handling time in C++
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++中的时间处理
- en: While POSIX timers have their own merits, in C++ there are libraries that provide
    higher-level and more portable solutions for timing and time-related operations.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 POSIX 计时器有其优点，但在 C++ 中存在提供更高层次和更便携的定时和时间相关操作解决方案的库。
- en: 'One good example of such a library is `std::chrono`. This is a C++ library
    that provides a set of utilities for working with time-related operations and
    measurements. It is part of the Standard Library and is included in the `<chrono>`
    header. The `std::chrono` library provides a flexible and type-safe mechanism
    for representing and manipulating time durations, time points, clocks, and time-related
    operations. By using `std::chrono`, you will benefit from the standardization,
    type safety, flexibility, and integration that comes with the C++ Standard Library.
    Some of the advantages of `std::chrono` compared to the traditional POSIX approach
    are as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的库的一个好例子是 `std::chrono`。这是一个提供与时间相关操作和测量的一组实用工具的 C++ 库。它是标准库的一部分，包含在 `<chrono>`
    头文件中。`std::chrono` 库提供了一种灵活且类型安全的机制来表示和操作时间间隔、时间点、时钟以及与时间相关的操作。通过使用 `std::chrono`，您将受益于
    C++ 标准库带来的标准化、类型安全、灵活性和集成。与传统的 POSIX 方法相比，`std::chrono` 的一些优势如下：
- en: '`std::chrono` is part of the C++ Standard Library, making it a cross-platform
    solution that works consistently across different operating systems and compilers.
    POSIX, on the other hand, is specific to UNIX-like systems and may not be available
    or behave consistently on all platforms.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::chrono` 是 C++ 标准库的一部分，使其成为一个跨平台解决方案，可以在不同的操作系统和编译器上保持一致性。另一方面，POSIX 是特定于类
    UNIX 系统的，可能在所有平台上不可用或表现不一致。'
- en: '`std::chrono` provides type-safe representations of time durations and points
    in time. It offers a rich set of duration and clock types that can be used together
    seamlessly, enabling safer and more expressive code. POSIX timers, while powerful,
    often rely on low-level types, such as the `timespec` struct, which can be error-prone
    and require manual conversions.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::chrono` 提供了类型安全的时间间隔和时间点的表示。它提供了一套丰富的持续时间时钟类型，可以无缝地一起使用，从而实现更安全、更具表现力的代码。POSIX
    计时器虽然功能强大，但通常依赖于低级类型，如 `timespec` 结构体，这可能导致错误并需要手动转换。'
- en: '`std::chrono` offers a flexible and expressive interface for time-related operations.
    It provides convenient ways to perform arithmetic operations on durations, convert
    between different time units, and format time values. POSIX timers, while suitable
    for specific timing requirements, lack the high-level abstractions and utilities
    provided by `std::chrono`.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::chrono` 为时间相关操作提供了一个灵活且具有表现力的接口。它提供了方便的方式来对持续时间执行算术运算、在不同时间单位之间进行转换以及格式化时间值。POSIX
    计时器虽然适用于特定的定时要求，但缺乏 `std::chrono` 提供的高级抽象和实用工具。'
- en: '`std::chrono` seamlessly integrates with other parts of the C++ Standard Library.
    It can be used in conjunction with algorithms, containers, and concurrency facilities,
    allowing for more cohesive and efficient code. POSIX timers, being a lower-level
    interface, may require additional work to integrate with other C++ Standard Library
    components.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::chrono` 与 C++ 标准库的其他部分无缝集成。它可以与算法、容器和并发设施一起使用，从而实现更紧密和高效的代码。POSIX 计时器作为一个低级接口，可能需要额外的工作才能与其他
    C++ 标准库组件集成。'
- en: '`std::chrono` benefits from the advancements and features introduced in modern
    C++. It supports features such as user-defined literals, lambda functions, and
    type deduction, making it easier to write concise and expressive code. POSIX timers,
    being part of the POSIX API, may not fully leverage the modern C++ language features.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::chrono` 得益于现代 C++ 中引入的进步和特性。它支持用户定义文字、lambda 函数和类型推导等特性，使得编写简洁和具有表现力的代码变得更加容易。POSIX
    计时器作为 POSIX API 的一部分，可能无法充分利用现代 C++ 语言特性。'
- en: 'The `<chrono>` library provides a comprehensive set of features for working
    with time-related operations, such as measuring time durations, representing points
    in time, and performing various time calculations and conversions. Here are some
    key components and features of `std::chrono`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`<chrono>` 库为处理与时间相关的操作提供了一套全面的特性，例如测量时间间隔、表示时间点以及执行各种时间计算和转换。以下是 `std::chrono`
    的关键组件和特性：'
- en: '`<chrono>` defines several clock types that represent different sources of
    time and different epochs. `std::chrono::system_clock` represents the system-wide
    RTC, which is adjustable. `std::chrono::steady_clock` represents a steady monotonic
    clock unaffected by system time adjustments, and `std::chrono::high_resolution_clock`
    represents a clock with the highest available resolution (if supported by the
    system).'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<chrono>` 定义了几个时钟类型，它们代表不同的时间来源和不同的纪元。`std::chrono::system_clock` 代表可调整的全局
    RTC，`std::chrono::steady_clock` 代表不受系统时间调整影响的一致单调时钟，`std::chrono::high_resolution_clock`
    代表具有最高可用分辨率的时钟（如果系统支持）。'
- en: '`std::chrono::duration` template class represents a time interval, that is,
    a specified period of time The duration is the tick count using a specific unit
    of time; for example, a duration of five hours is five ticks of the unit *hour*.
    Different types of durations can be defined, from years to nanoseconds. Example
    durations include `std::chrono::seconds`, `std::chrono::milliseconds`, and `std::chrono::months`.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::chrono::duration` 模板类表示一个时间间隔，即指定的时间段。持续时间是使用特定时间单位计数的滴答数；例如，五个小时是五个单位的
    *小时* 滴答。可以定义不同类型的持续时间，从年到纳秒。示例持续时间包括 `std::chrono::seconds`、`std::chrono::milliseconds`
    和 `std::chrono::months`。'
- en: '`std::chrono::time_point` template class is parameterized by a clock and duration
    type.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::chrono::time_point` 模板类由一个时钟和持续时间类型参数化。'
- en: '`std::chrono` allows for conversions between durations and time points, as
    well as arithmetic operations involving durations. It provides functions such
    as `std::chrono::duration_cast` to convert between different durations and `std::chrono::time_point_cast`
    to convert between different time points.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::chrono` 允许在持续时间和时间点之间进行转换，以及涉及持续时间的算术运算。它提供了将不同持续时间之间进行转换的函数，如 `std::chrono::duration_cast`，以及将不同时间点之间进行转换的函数
    `std::chrono::time_point_cast`。'
- en: '`std::chrono` provides utilities for querying the current time, such as `std::chrono::system_clock::now()`,
    which returns the current system time point.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::chrono` 提供了查询当前时间的实用工具，例如 `std::chrono::system_clock::now()`，它返回当前的系统时间点。'
- en: '`std::chrono` provides user-defined, time-related literals in the `std::literals::chrono_literals`
    namespace. They allow you to create `std::chrono::duration` objects using literals
    with time units. This makes the code more readable and convenient when dealing
    with time-related computations.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::chrono` 在 `std::literals::chrono_literals` 命名空间中提供用户定义的时间相关字面量。它们允许您使用带时间单位的字面量创建
    `std::chrono::duration` 对象。这使得处理与时间相关的计算时代码更易于阅读和方便。'
- en: '`std::chrono` provides calendar capabilities, such as working with days, months,
    and years. It also provides notation for leap years and leap seconds.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::chrono` 提供了日历功能，例如处理天、月和年。它还提供了闰年和闰秒的表示法。'
- en: '`std::chrono` provides information about different time zones across the globe
    depending on the geographical location.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::chrono` 根据地理位置提供关于全球不同时区的信息。'
- en: By using `std::chrono`, you can perform accurate and portable time measurements,
    handle timeouts, calculate time differences, and work with time-related operations
    in a type-safe manner.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `std::chrono`，您可以执行精确且可移植的时间测量，处理超时，计算时间差，并以类型安全的方式处理与时间相关的操作。
- en: Important note
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The following is a link to the `<chrono>` header in the C++ reference documentation:
    [https://en.cppreference.com/w/cpp/header/chrono](https://en.cppreference.com/w/cpp/header/chrono).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个指向 C++ 参考文档中 `<chrono>` 头文件的链接：[https://en.cppreference.com/w/cpp/header/chrono](https://en.cppreference.com/w/cpp/header/chrono)。
- en: 'Here’s an example of how to use `std::chrono` to measure the execution time
    of a code snippet:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个如何使用 `std::chrono` 来测量代码片段执行时间的示例：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, `std::chrono::steady_clock` is used to measure the
    execution time of the same function as from the previous example (see marker `{2}`).
    The `start` and `end` variables represent the *timepoints* taken before and after
    the code execution using the `now()` static function of `steady_clock` (see markers
    `{1}` and `{3}`). `std::chrono::duration_cast` is used to convert the calculated
    duration between the time points in milliseconds (see marker `{4}`).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，使用 `std::chrono::steady_clock` 来测量与上一个示例中相同函数的执行时间（参见标记 `{2}`）。`start`
    和 `end` 变量代表使用 `steady_clock` 的 `now()` 静态函数在代码执行前后获取的 *时间点*（参见标记 `{1}` 和 `{3}`）。`std::chrono::duration_cast`
    用于将时间点之间的计算持续时间转换为毫秒（参见标记 `{4}`）。
- en: 'The output of the program should be similar to this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出应类似于以下内容：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, the `std::chrono::duration` class has a `count()` method, which
    returns the number of units in a specific duration; see marker `{5}`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`std::chrono::duration`类有一个`count()`方法，它返回特定持续时间中的单位数；参见标记 `{5}`。
- en: But let’s get deeper into how this really works.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们更深入地了解它是如何真正工作的。
- en: Using clocks, timers, and ratios
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用时钟、计时器和比率
- en: Before getting into more examples with clocks and timers, we first have to get
    a better understanding of how the chrono library defines a *duration*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入更多关于时钟和计时器的例子之前，我们首先需要更好地理解chrono库是如何定义*持续时间*的。
- en: As we saw in the previous example, a duration is the distance between two points
    of time, called *timepoints*. In our previous example, these were the `start`
    and `end` timepoints.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的例子中所见，持续时间是两个时间点之间的距离，称为*时间点*。在我们的前一个例子中，这些是`start`和`end`时间点。
- en: '![Figure 8.1 – Timepoint and duration](img/Figure_8.1_B20833.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 时间点和持续时间](img/Figure_8.1_B20833.jpg)'
- en: Figure 8.1 – Timepoint and duration
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 时间点和持续时间
- en: 'The duration itself is a combination of the count of ticks and a fraction that
    represents the time in seconds from one tick to the next. The fraction is represented
    by the `std::ratio` class. Here are some examples:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 持续时间本身是滴答计数和表示从一个滴答到下一个滴答的秒数的分数的组合。这个分数由`std::ratio`类表示。以下是一些示例：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding example, we have defined the duration of six minutes in several
    ways. In the `six_minutes_1` variable, we have specified this duration as a value
    of 360 seconds. The same duration can also be represented as 1/10 of an hour –
    the `six_minutes_2` variable. The last two durations – `six_minutes_3` and `six_minutes_4`
    – represent the same duration of six minutes but using the `std::chrono` predefined
    duration types and literals. Here is the output of the preceding code block:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们以几种方式定义了六分钟的持续时间。在`six_minutes_1`变量中，我们指定了这个持续时间为360秒。相同的持续时间也可以表示为1/10小时
    – `six_minutes_2`变量。最后两个持续时间 – `six_minutes_3`和`six_minutes_4` – 使用`std::chrono`预定义的持续时间类型和字面量表示相同的六分钟持续时间。以下是前面代码块的输出：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, `std::duration` also provides pretty formatting capabilities
    so that once the duration is passed to a string or stream operator, it will add
    the corresponding suffix so we can see the duration type.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`std::duration`还提供了相当强大的格式化功能，因此一旦持续时间传递给字符串或流操作符，它将添加相应的后缀，这样我们就可以看到持续时间类型。
- en: In order to ensure that the preceding durations really correspond to six minutes,
    we have tested them against `static_assert`, which would fail the program if they
    don’t match.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保前面的持续时间确实对应六分钟，我们已经用`static_assert`测试了它们，如果不匹配，程序将失败。
- en: Important note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The following is a link to the `std::duration` class in the C++ reference documentation:
    [https://en.cppreference.com/w/cpp/chrono/duration](https://en.cppreference.com/w/cpp/chrono/duration).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个链接到C++参考文档中的`std::duration`类：[https://en.cppreference.com/w/cpp/chrono/duration](https://en.cppreference.com/w/cpp/chrono/duration)。
- en: 'Let’s go back to our previous example, slightly change it, and have a closer
    look at a `timepoint` object:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们之前的一个例子，稍作修改，并更仔细地看看一个`timepoint`对象：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, we again construct a `timepoint` object, `start`, in which we
    get the time at the moment of its instantiation from the `steady_clock` instance
    of the Linux system; see marker `{1}`. The `std::chrono::time_point` class stores
    a `std::chrono::duration` value, which actually indicates the time interval from
    the start of the clock’s epoch. In order to allow getting that value, the `std::chrono::duration`
    class exposes a method that returns the duration, `time_since_epoch()`, in nanoseconds;
    see marker `{2}`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们再次构造了一个`timepoint`对象`start`，在这个对象中，我们从Linux系统的`steady_clock`实例中获取其实例化时刻的时间；参见标记
    `{1}`。`std::chrono::time_point`类存储一个`std::chrono::duration`值，这个值实际上表示从时钟纪元开始的时间间隔。为了允许获取这个值，`std::chrono::duration`类公开了一个返回持续时间的`time_since_epoch()`方法，单位为纳秒；参见标记
    `{2}`。
- en: 'Here is the result of the preceding code executed in our test environment.
    Please keep in mind that if you execute this code, the result could be different:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前面代码在我们测试环境中执行的结果。请注意，如果你执行此代码，结果可能会有所不同：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Having a time duration in nanoseconds could be inconvenient in some use cases,
    such as our example of calculating the time it takes for a code block to execute.
    However converting a duration from a higher-precision type into a lower-precision
    type results in a loss of precision. Therefore, if we need to see the duration
    in minutes then in nanoseconds, we can’t just do this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些用例中，如我们计算代码块执行时间的例子，以纳秒为单位的时间持续时间可能不方便。然而，将持续时间从高精度类型转换为低精度类型会导致精度损失。因此，如果我们需要以分钟和纳秒为单位查看持续时间，我们不能只是这样做：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is because the preceding code won’t compile. The reason behind this is
    that the `time_since_epoch()` method returns the duration with a precision of
    nanoseconds. If we store that data in minutes, we will certainly lose precision.
    In order to be sure that this won’t be done by mistake, the compiler stops us.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为前面的代码无法编译。背后的原因是`time_since_epoch()`方法返回的持续时间具有纳秒的精度。如果我们把数据存储在分钟里，我们肯定会失去精度。为了确保这不是一个错误，编译器阻止了我们。
- en: 'But how can we intentionally convert duration values from one precision into
    another? As we saw in the first example, we can use the `std::chrono::duration_cast`
    function provided by the library. It enables us to make conversions from a duration
    type with higher precision to a duration type with lower precision. Let’s rework
    the preceding example and see how this works:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何有意地将持续时间值从一种精度转换为另一种精度呢？正如我们在第一个例子中所看到的，我们可以使用库提供的`std::chrono::duration_cast`函数。它使我们能够将具有更高精度的持续时间类型转换为具有更低精度的持续时间类型。让我们重新处理前面的例子，看看它是如何工作的：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see in marker `{1}`, we again get the duration in nanoseconds from
    the clock’s epoch. In marker `{2}`, we initialize another duration variable but
    this time in minutes. In order to do so, we use `std::chrono::duration_cast<minutes>`,
    which converts the value from the source resolution into the destination one and
    truncates it down to the closest integer value. In our test environment, the result
    of the preceding code block is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在标记 `{1}`中所见，我们再次从时钟的纪元得到纳秒的持续时间。在标记 `{2}`中，我们初始化另一个持续时间变量，但这次是以分钟为单位。为了做到这一点，我们使用`std::chrono::duration_cast<minutes>`，它将源分辨率转换为目标分辨率，并将其截断到最接近的整数值。在我们的测试环境中，前面代码块的结果如下：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can see that the measured duration in nanoseconds is equivalent to about
    586.78 minutes but it is truncated down to 586 minutes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，以纳秒为单位的测量持续时间相当于大约586.78分钟，但它被截断到586分钟。
- en: 'Of course, we could also need to round up rather than just truncate down values.
    Fortunately, the `chrono` library gives us this capability with the `std::chrono::round`
    method, which does exactly this. Here is an example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可能需要向上舍入而不是简单地向下截断值。幸运的是，`chrono`库通过`std::chrono::round`方法提供了这种能力，它正好做到了这一点。以下是一个例子：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this example, we define two duration variables, `dur_sec_1` and `dur_sec_2`.
    `dur_sec_1` is initialized to 55 seconds (see marker `{1}`) and `dur_sec_2` is
    initialized to 65 seconds (see marker `{2}`). Then, using the `std::chrono::round`
    function, we initialize another two duration variables but this time with a resolution
    of minutes (see markers `{3}` and `{4}`). Both duration variables are rounded
    to one minute:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了两个持续时间变量，`dur_sec_1`和`dur_sec_2`。`dur_sec_1`被初始化为55秒（见标记 `{1}`），而`dur_sec_2`被初始化为65秒（见标记
    `{2}`）。然后，使用`std::chrono::round`函数，我们初始化另外两个持续时间变量，但这次以分钟为分辨率（见标记 `{3}`和 `{4}`）。这两个持续时间变量都被四舍五入到一分钟：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `chrono` library also supplies methods for `ceil` and `floor` durations.
    All of them can be found in the official documentation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`chrono`库还提供了`ceil`和`floor`持续时间的方法。所有这些都可以在官方文档中找到。'
- en: Important note
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The documentation for `round`, `floor`, and `ceil` methods for duration values
    can be found at these links: [https://en.cppreference.com/w/cpp/chrono/duration/round](https://en.cppreference.com/w/cpp/chrono/duration/round),
    https://en.cppreference.com/w/cpp/chrono/duration/floor, and [https://en.cppreference.com/w/cpp/chrono/duration/ceil](https://en.cppreference.com/w/cpp/chrono/duration/ceil).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`round`、`floor`和`ceil`方法对于持续时间值的文档可以在以下链接中找到：[https://en.cppreference.com/w/cpp/chrono/duration/round](https://en.cppreference.com/w/cpp/chrono/duration/round)，https://en.cppreference.com/w/cpp/chrono/duration/floor，以及[https://en.cppreference.com/w/cpp/chrono/duration/ceil](https://en.cppreference.com/w/cpp/chrono/duration/ceil)。'
- en: Since we have a better understanding of time operations, let’s have a closer
    look at the different types of clocks that `std::chrono` provides for us.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们对时间操作有了更好的理解，让我们更仔细地看看`std::chrono`为我们提供的不同类型的时钟。
- en: More about clocks in C++20
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于 C++20 中的时钟的更多信息
- en: We already used `std::chrono::steady_clock` in our previous examples. This is
    just one of the predefined clocks in the C++ `chrono` library that you can use.
    `std::chrono::steady_clock`, as its name suggests, is a clock that is steady.
    This means that it is a monotonic clock in which time only moves forward, and
    its timepoint values are always increasing. It is suitable for use when we want
    to measure intervals of time. Its epoch can vary.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的例子中使用了 `std::chrono::steady_clock`。这只是 C++ `chrono` 库中可用的预定义时钟之一。正如其名称所暗示的，`std::chrono::steady_clock`
    是一个稳定的时钟。这意味着它是一个单调时钟，其中时间只向前移动，并且其时间点值总是增加。当我们想要测量时间间隔时，它很适用。它的纪元可以变化。
- en: 'Another frequently used clock is `std::chrono::system_clock`. In Linux, it
    represents the time measured by the system. This means that it is not guaranteed
    to be monotonic, and it can be adjusted at any moment. In Linux, its epoch matches
    the UNIX epoch. Let’s see an example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常用的时钟是 `std::chrono::system_clock`。在 Linux 中，它代表系统测量的时间。这意味着它不保证是单调的，并且可以在任何时候进行调整。在
    Linux 中，它的纪元与 UNIX 纪元相匹配。让我们看一个例子：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding example prints the Linux system clock epoch, which corresponds
    to the UNIX epoch – `00:00:00: UTC` on `1` `January 1970`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '前面的例子打印了 Linux 系统时钟纪元，它对应于 UNIX 纪元——`1970`年`1`月`1`日的`00:00:00: UTC`：'
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Keep in mind that `std::chrono::system_clock` doesn’t take into account *leap
    seconds*, which can be added or subtracted from the measured time. In general,
    a leap second is a one-second adjustment of UTC, which can occur twice per year
    to reflect the accuracy of the Earth’s rotation around the Sun.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`std::chrono::system_clock` 并不考虑 *闰秒*，这些秒可以从测量时间中添加或减去。一般来说，闰秒是对协调世界时（UTC）的一次一秒调整，每年可能发生两次，以反映地球绕太阳旋转的精度。
- en: Important note
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: More information about leap seconds can be found at [https://en.wikipedia.org/wiki/Leap_second](https://en.wikipedia.org/wiki/Leap_second).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 关于闰秒的更多信息，请参阅此处：[https://en.wikipedia.org/wiki/Leap_second](https://en.wikipedia.org/wiki/Leap_second)。
- en: C++20 introduces several more predefined clocks. Some of them are `std::chrono::utc_clock`,
    which measures UTC, and `std::chrono::tai_clock`, which measures **International
    Atomic** **Time** (**TAI**).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: C++20 引入了几种更多的预定义时钟。其中一些是 `std::chrono::utc_clock`，它测量 UTC，以及 `std::chrono::tai_clock`，它测量**国际原子时**（**TAI**）。
- en: Important note
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'More information about UTC and TAI can be found here: [https://en.wikipedia.org/wiki/Coordinated_Universal_Time](https://en.wikipedia.org/wiki/Coordinated_Universal_Time)
    and [https://en.wikipedia.org/wiki/International_Atomic_Time](https://en.wikipedia.org/wiki/International_Atomic_Time).'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 UTC 和 TAI 的更多信息，请参阅此处：[https://en.wikipedia.org/wiki/Coordinated_Universal_Time](https://en.wikipedia.org/wiki/Coordinated_Universal_Time)
    和 [https://en.wikipedia.org/wiki/International_Atomic_Time](https://en.wikipedia.org/wiki/International_Atomic_Time)。
- en: 'A key difference between the TAI and UTC clocks is that the UTC clock is guaranteed
    to take into account the leap-second corrections made since the clock epoch, but
    the TAI clock doesn’t take them into account. Let’s see an example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: TAI 时钟和 UTC 时钟之间的一个关键区别是，UTC 时钟保证会考虑自时钟纪元以来进行的闰秒修正，但 TAI 时钟不考虑这些修正。让我们看一个例子：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding example, we get the current time from both clocks – `utc`
    and `tai`. Here is the result:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们从两个时钟——`utc` 和 `tai`——获取了当前时间。以下是结果：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, regardless of whether both clocks are invoked at the same time,
    they show different times. And their difference is *exactly 37 seconds*. This
    difference comes from the leap-second adjustments made since they were introduced
    back in 1972.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，无论两个时钟是否同时调用，它们显示的时间都不同。并且它们的差异正好是 *37 秒*。这种差异来自自 1972 年引入以来进行的闰秒调整。
- en: '`std::chrono::utc_clock` applies leap-second adjustments. By using chrono’s
    UTC clock, these leap-second adjustments will be done automatically for you, and
    you don’t need to take any special action. Therefore, the chrono library provides
    a method to convert between clock types – `std::chrono::clock_cast`, which converts
    `std::chrono::time_point` values from one clock into another. Let’s see another
    example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::chrono::utc_clock` 应用闰秒调整。通过使用 chrono 的 UTC 时钟，这些闰秒调整将自动为您完成，您不需要采取任何特殊行动。因此，chrono
    库提供了一个在时钟类型之间进行转换的方法——`std::chrono::clock_cast`，它可以将 `std::chrono::time_point`
    值从一个时钟转换为另一个时钟。让我们再看一个例子：'
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, the `time_point tai` object generated by chrono’s TAI clock
    is converted into a time point from the UTC clock. The result is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，由chrono的TAI时钟生成的`time_point tai`对象被转换为UTC时钟的时间点。结果如下：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we expected, the TAI clock is 37 seconds ahead of the UTC one. Therefore,
    UTC cannot be used to properly measure time differences as a leap second might
    be added or removed.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所预期，TAI时钟比UTC时钟快37秒。因此，UTC不能正确地测量时间差，因为可能会添加或删除闰秒。
- en: Important note
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'You can find all the predefined clocks in the C++ chrono library here: [https://en.cppreference.com/w/cpp/chrono#Clocks](https://en.cppreference.com/w/cpp/chrono#Clocks).'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在C++ chrono库中找到所有预定义的时钟：[https://en.cppreference.com/w/cpp/chrono#Clocks](https://en.cppreference.com/w/cpp/chrono#Clocks)。
- en: Now, since we have a good understanding of timing and clocks, let’s see what
    capabilities the C++ chrono library provides for calendars and time zones.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于我们已经对时间和时钟有了很好的理解，让我们看看C++ chrono库为日历和时间区域提供了哪些功能。
- en: Using calendar and time zone capabilities
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用日历和时间区域功能
- en: C++20 introduces brand-new support for calendar and time zone operations to
    the standard. When we talk about calendar operations, this means operations in
    days, months, and years. They, together with the time zone notion, allow conversions
    of time between different time zones taking into account time zone adjustments
    such as daylight saving time.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: C++20向标准引入了对日历和时间区域操作的新支持。当我们谈论日历操作时，这意味着在日、月和年中的操作。它们与时间区域概念一起，允许在不同时区之间进行时间转换，同时考虑时区调整，如夏令时。
- en: 'Let’s define a date and print it with the help of the `chrono` library:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个日期并使用`chrono`库打印它：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see, the `std::chrono` namespace provides `year`, `month`, and `day`
    classes, which make it easy to work with dates. The benefit of these classes is
    that they provide strict type and boundary checks, some operators for summation
    and subtraction, and formatting capabilities. The result of the preceding code
    is as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`std::chrono`命名空间提供了`year`、`month`和`day`类，这使得处理日期变得容易。这些类的优点是它们提供了严格的类型和边界检查，一些用于加法和减法的运算符，以及格式化功能。前面代码的结果如下：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you can see, passing the `Month` variable to `operator<<` applies formatting
    so that the value of the month is printed as `Aug`. Also, these classes provide
    validation and boundary checks on the applied values:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，将`Month`变量传递给`operator<<`会应用格式化，以便月份的值打印为`Aug`。此外，这些类提供了对应用值的验证和边界检查：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding example, we have applied an invalid month and day of the month.
    The result is as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们应用了一个无效的月份和月份中的日期。结果如下：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, `month` and `day` values are validated, and when they are passed
    to `operator<<`, it prints that these values are not valid.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`month`和`day`值已通过验证，当它们传递给`operator<<`时，它会打印出这些值无效。
- en: 'The `year` class represents a year in the proleptic Gregorian calendar, which
    enables us to ask whether the year is a leap year or not:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`year`类表示公历中的一个年份，这使得我们可以询问该年份是否为闰年：'
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this example, we first get the current system time – `now` – and then we
    convert it into an object of the `year_month_day` type. This object represents
    a convenient field-based timepoint. It holds `year`, `month`, and `day` objects
    and allows direct access to them. It also supports instantiation from `std::chrono::sys_days`,
    which effectively is a timepoint of the system clock in days. Therefore, we pass
    the `now` timepoint and create the `today` object. Then, we get the `year` object
    – `thisYear` – and it checks whether this is a leap year or not using the `is_leap()`
    method of the `year` class:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先获取当前系统时间`now`，然后将其转换为`year_month_day`类型的对象。该对象表示一个方便的基于字段的时点。它包含`year`、`month`和`day`对象，并允许直接访问它们。它还支持从`std::chrono::sys_days`实例化，这实际上是一个系统时钟的时点。因此，我们传递`now`时点并创建`today`对象。然后，我们获取`year`对象`thisYear`，并使用`year`类的`is_leap()`方法检查它是否是闰年：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As expected, 2023 is not a leap year.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，2023年不是闰年。
- en: 'The `chrono` library heavily utilizes `operator/` for date creation. C++20
    provides about 40 overloads of the parameters of this operator. Let’s see an example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`chrono`库在日期创建中大量使用`operator/`。C++20为该运算符的参数提供了大约40个重载。让我们看一个例子：'
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, we create a `year_month_day` object by passing the newly introduced
    *chrono literals* for months, days, and years together with `operator/`. chrono
    provides convenient literals for the creation of days; you just have to append
    `d` to the day value. The same is the case for years, you have to append `y` and
    you construct a `year` object. For months, the chrono library defines named constants
    for all months of the year.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们通过传递新引入的 *chrono 文字面量*（月份、日期和年份）以及 `operator/` 来创建 `year_month_day` 对象。chrono
    为创建日期提供了方便的文字面量；您只需在日期值后附加 `d`。对于年份也是如此，您需要附加 `y` 并构建一个 `year` 对象。对于月份，chrono
    库为每年的所有月份定义了命名常量。
- en: Important note
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The following is a link to a list of the month constants in the chrono library:
    [https://en.cppreference.com/w/cpp/chrono/month](https://en.cppreference.com/w/cpp/chrono/month).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个链接，列出了 chrono 库中的月份常量：[https://en.cppreference.com/w/cpp/chrono/month](https://en.cppreference.com/w/cpp/chrono/month)。
- en: During the instantiation of the `year_month_day` object, we pass date values
    using `operator/`. As is visible from the preceding example, chrono supports many
    combinations of day, month, and year values. All of them can be found in the standard
    documentation.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化 `year_month_day` 对象时，我们使用 `operator/` 来传递日期值。从前面的示例中可以看出，chrono 支持许多日期、月份和年份值的组合。所有这些都可以在标准文档中找到。
- en: Important note
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The following is a link to the documentation on all overloads of `operator/`
    for date management: [https://en.cppreference.com/w/cpp/chrono/operator_slash](https://en.cppreference.com/w/cpp/chrono/operator_slash).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个链接，列出了日期管理中 `operator/` 的所有重载：[https://en.cppreference.com/w/cpp/chrono/operator_slash](https://en.cppreference.com/w/cpp/chrono/operator_slash)。
- en: 'All the used overloads in our example are supposed to create valid `year_month_date`
    objects. Let’s see the output:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例中使用的所有重载都旨在创建有效的 `year_month_date` 对象。让我们看看输出结果：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As we can see, we have successfully created three separate valid dates with
    the help of chrono literals and `operator/`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们已成功使用 chrono 文字面量和 `operator/` 创建了三个不同的有效日期。
- en: Working with time zones in C++
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 C++ 中处理时区
- en: The C++20 `chrono` library provides capabilities for working with time zones.
    It integrates the IANA time zone database, which contains information about the
    local time in many geographical locations around the globe.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: C++20 的 `chrono` 库提供了处理时区的能力。它集成了 IANA 时区数据库，该数据库包含全球许多地理位置的本地时间信息。
- en: Important note
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Find more information about the IANA time zone database here: [https://www.iana.org/time-zones](https://www.iana.org/time-zones).'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在此处查找有关 IANA 时区数据库的更多信息：[https://www.iana.org/time-zones](https://www.iana.org/time-zones)。
- en: 'Using `chrono`, you can get a copy of the IANA database and browse it for a
    specific geographical location:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `chrono`，您可以获取 IANA 数据库的副本，并浏览特定地理位置的信息：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As we can see from the example, in the `std::chrono` namespace, there is a method
    – `get_tzdb()` – that returns a reference to the IANA database. In the database,
    you can find information about its version and also get a sorted list of all available
    `std::chrono::time_zone` objects.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 从示例中我们可以看出，在 `std::chrono` 命名空间中有一个方法——`get_tzdb()`，它返回对 IANA 数据库的引用。在数据库中，您可以找到有关其版本的信息，还可以获取所有可用的
    `std::chrono::time_zone` 对象的排序列表。
- en: 'The `std::chrono::time_zone` class stores information about transitions between
    time zones for its specific geographic area and name. The output from the preceding
    example is as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::chrono::time_zone` 类存储有关特定地理区域和名称之间时区转换的信息。前一个示例的输出如下：'
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, once we have all available time zones, let’s try to find a specific one
    based on a geographical location and see what the time is there:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦我们有了所有可用的时间区，让我们尝试根据地理位置找到一个特定的时间区，并看看那里的时间是什么：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In this example, we again get the list of the available time zones and try
    to find the time zone for the city of `Sofia`. Then, we use the full name of the
    found time zone to create another object that uses a specific geographical location
    and the value of the system time – `std::chrono::zoned_time`. This class represents
    a logical pair between a time zone and a point in time. We also create another
    `zoned_time zt_2` object but for the city of `London`, which represents the same
    time point as `zt_1` but in another geographical location. The result of the preceding
    code is as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们再次获取可用的时区列表，并尝试找到城市`索非亚`的时区。然后，我们使用找到的时区的全名创建另一个对象，该对象使用特定的地理位置和系统时间值——`std::chrono::zoned_time`。这个类代表了一个时区和时间点之间的逻辑对。我们还创建了另一个`zoned_time
    zt_2`对象，但针对的是城市`伦敦`，它代表与`zt_1`相同的时间点，但位于另一个地理位置。上述代码的结果如下：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, both objects display a valid time but with respect to their
    geographical locations. This is how we can safely get the current time in a specific
    geographical location where daylight saving time is also considered.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这两个对象都显示了一个有效的时间，但相对于它们的地理位置而言。这就是我们如何安全地获取特定地理位置的当前时间，同时考虑夏令时的情况。
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the different timers available within the Linux
    environment. Subsequently, we gained an understanding of the significance behind
    the clock epoch and the concept of UNIX time. Following this, we delved into the
    practical implementation of POSIX in Linux for accurate time measurement. Additionally,
    we investigated the realm of `std::chrono` and examined the array of capabilities
    that C++ affords for effective time-related operations. Our exploration then took
    us on a detailed journey through duration, timepoints, and clocks as they are
    defined within the `std::chrono` framework. Moving forward, we acquainted ourselves
    with the various clock types at our disposal within `std::chrono`. As our journey
    continued, we initiated our exploration into the calendar capabilities presented
    by `std::chrono`. Finally, we developed familiarity with time zones and honed
    our proficiency in executing seamless time conversions utilizing the tools offered
    by `std::chrono`. Now, we are ready for the next chapter, where we will go deeper
    into the specifics of the C++ memory model.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Linux环境中可用的不同计时器。随后，我们了解了时钟纪元和UNIX时间概念的重要性。接着，我们深入研究了Linux中POSIX的实际实现，以实现准确的时间测量。此外，我们还研究了`std::chrono`领域，并检查了C++为有效的时间相关操作提供的各种功能。我们的探索随后带我们详细了解了`std::chrono`框架中定义的持续时间、时间点和时钟。向前推进，我们熟悉了`std::chrono`中可用的各种时钟类型。随着我们的旅程继续，我们开始探索`std::chrono`提供的日历功能。最后，我们熟悉了时区，并提高了使用`std::chrono`提供的工具执行无缝时间转换的熟练度。现在，我们已准备好进入下一章，我们将更深入地探讨C++内存模型的细节。
