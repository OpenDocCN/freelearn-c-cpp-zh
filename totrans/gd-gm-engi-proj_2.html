<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Coin Dash</h1>
                
            
            
                
<p class="calibre2">This first project will guide you through making your first Godot Engine project. You will learn how the Godot editor works, how to structure a project, and how to build a small 2D game.</p>
<p>Why 2D? In a nutshell, 3D games are much more complex than 2D ones, while many of the underlying game engine features you'll need to know are the same. You should stick to 2D until you have a good understanding of Godot's game development process. At that point, the jump to 3D will be much easier. You'll get an introduction to 3D in this book's fifth and final project.</p>
<p class="calibre2">Important—don't skip this chapter, even if you aren't a complete newcomer to game development. While you may already understand many of the underlying concepts, this project will introduce a number of fundamental Godot features and design paradigms that you'll need to know going forward. You'll build on these concepts as you develop more complex projects.</p>
<p class="calibre2">The game in this chapter is called <strong class="calibre4">Coin Dash</strong>. Your character must move around the screen, collecting as many coins as possible while racing against the clock. When you're finished, the game will look like this:</p>
<div><img src="img/00015.jpeg" class="calibre33"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Project setup</h1>
                
            
            
                
<p class="calibre2">Launch Godot and create a new project, making sure to use the <kbd class="calibre12">Create Folder</kbd> button to ensure that this project's files will be kept separate from other projects. You can download a Zip file of the art and sounds (collectively known as <em class="calibre17">assets</em>) for the game here, <a href="https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases" class="calibre9">https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases</a>.</p>
<p class="calibre2">Unzip this file in your new project folder.</p>
<p class="calibre2">In this project, you will make three independent scenes: <kbd class="calibre12">Player</kbd>, <kbd class="calibre12">Coin</kbd>, and <kbd class="calibre12">HUD</kbd>, which will all be combined into the game's <kbd class="calibre12">Main</kbd> scene. In a larger project, it might be useful to make separate folders to hold each scene's assets and scripts, but for this relatively small game, you can save your scenes and scripts in the root folder, which is referred to as <kbd class="calibre12">res://</kbd> (<strong class="calibre4">res</strong> is short for <strong class="calibre4">resource</strong>). All resources in your project will be located relative to the <kbd class="calibre12">res://</kbd> folder. You can see your project folders in the FileSystem dock in the upper-left corner:</p>
<div><img src="img/00016.jpeg" class="calibre34"/></div>
<p class="calibre2">For example, the images for the coin would be located in <kbd class="calibre12">res://assets/coin/</kbd>.</p>
<p class="calibre2">This game will use portrait mode, so you need to adjust the size of the game window. Click on the Project menu and select Project Settings, as shown in the following screenshot:</p>
<div><img src="img/00017.jpeg" class="calibre35"/></div>
<p class="calibre2">Look for the Display/Window section and set Width to <kbd class="calibre12">480</kbd> and Height to <kbd class="calibre12">720</kbd>. Also in this section, set the Stretch/Mode to <kbd class="calibre12">2D</kbd> and the Aspect to <kbd class="calibre12">keep</kbd>. This will ensure that if the user resizes the game window, everything will scale appropriately and not become stretched or deformed. If you like, you can also uncheck the box for Resizable, to prevent the window from being resized entirely.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Vectors and 2D coordinate systems</h1>
                
            
            
                
<p class="calibre2">Note: This section is a very brief overview of 2D coordinate systems and does not delve very deeply into vector math. It is intended as a high-level overview of how such topics apply to game development in Godot. Vector math is an essential tool in game development, so if you need a broader understanding of the topic, see Khan Academy's Linear Algebra series (<a href="https://www.khanacademy.org/math/linear-algebra" class="calibre9">https://www.khanacademy.org/math/linear-algebra</a>).</p>
<p class="calibre2">When working in 2D, you'll be using Cartesian coordinates to identify locations in space. A particular position in 2D space is written as a pair of values, such as <kbd class="calibre12">(4,3)</kbd>, representing the position along the <em class="calibre17">x</em> and <em class="calibre17">y</em> axes, respectively. Any position in the 2D plane can be described in this way.</p>
<p class="calibre2">In 2D space, Godot follows the common computer graphics practice of orienting the <em class="calibre17">x</em> axis to the right, and the <em class="calibre17">y </em>axis down:</p>
<div><img src="img/00018.jpeg" class="calibre36"/></div>
<p>If you're new to computer graphics or game development, it might seem odd that the positive y axis points downwards instead of upwards, as you likely learned in math class. However, this orientation is very common in computer graphics applications.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Vectors</h1>
                
            
            
                
<p class="calibre2">You can also think of the position <kbd class="calibre12">(4, 3)</kbd> as an <em class="calibre17">offset</em> from the <kbd class="calibre12">(0, 0)</kbd> point, or <em class="calibre17">origin</em>. Imagine an arrow pointing from the origin to the point:</p>
<div><img src="img/00019.jpeg" class="calibre37"/></div>
<p class="calibre2">This arrow is a <em class="calibre17">vector</em>. It represents a great deal of useful information including the point's location, <em class="calibre17">(4, 3)</em>, its length, <em class="calibre17">m,</em> and its angle from the <em class="calibre17">x</em>-axis, <em class="calibre17">θ</em>. Altogether, this is a <em class="calibre17">position vector</em>, in other words, it describes a position in space. Vectors can also represent movement, acceleration, or any other quantity that has an <em class="calibre17">x</em> and a <em class="calibre17">y</em> component.</p>
<p class="calibre2">In Godot, vectors (<kbd class="calibre12">Vector2</kbd> for 2D or <kbd class="calibre12">Vector3</kbd> for 3D) are widely used, and you'll use them in the course of building the projects in this book.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Pixel rendering</h1>
                
            
            
                
<p class="calibre2">Vector coordinates in Godot are <em class="calibre17">floating point </em>numbers, not <em class="calibre17">integers</em>. This means a <kbd class="calibre12">Vector2</kbd> could have a fractional value, such as <kbd class="calibre12">(1.5, 1.5)</kbd>. Since objects can't be drawn at half pixels, this can cause visual problems for pixel art games where you want to ensure that all the pixels of the textures are drawn.</p>
<p class="calibre2">To address this, open Project <em class="calibre17">|</em> Project Settings and find the Rendering<em class="calibre17">/</em>Quality section in the sidebar and enable Use Pixel Snap, as shown in the following screenshot:</p>
<div><img src="img/00020.jpeg" class="calibre38"/></div>
<p class="calibre2">If you're using 2D pixel art in your game, it's a good idea to always enable this setting when you start your project. This setting has no effect in 3D games.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Part 1 – Player scene</h1>
                
            
            
                
<p class="calibre2">The first scene you'll make defines the Player object. One of the benefits of creating a separate player scene is that you can test it independently, even before you've created the other parts of the game. This separation of game objects will become more and more helpful as your projects grow in size and complexity. Keeping individual game objects separate from each other makes them easier to troubleshoot, modify, and even replace entirely without affecting other parts of the game. It also makes your player reusable—you can drop the player scene into an entirely different game and it will work just the same.</p>
<p class="calibre2">The player scene will display your character and its animations, respond to user input by moving the character accordingly, and detect collisions with other objects in the game.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Creating the scene</h1>
                
            
            
                
<p class="calibre2">Start by clicking the Add/Create a New Node button and selecting an <kbd class="calibre12">Area2D</kbd>. Then, click on its name and change it to <kbd class="calibre12">Player</kbd>. Click Scene | Save Scene to save the scene. This is the scene's <em class="calibre17">root</em> or top-level node. You'll add more functionality to the <kbd class="calibre12">Player</kbd> by adding children to this node:</p>
<div><img src="img/00021.gif" class="calibre39"/></div>
<p class="calibre2">Before adding any children, it's a good idea to make sure you don't accidentally move or resize them by clicking on them. Select the <kbd class="calibre12">Player</kbd> node and click the icon next to the lock: </p>
<div><img src="img/00022.jpeg" class="calibre40"/></div>
<p class="calibre2">The tooltip will say Make sure the object's children are not selectable, as shown in the preceding screenshot.</p>
<p>It's a good idea to always do this when creating a new scene. If a body's collision shape or sprite becomes offset or scaled, it can cause unexpected errors and be difficult to fix. With this option, the node and all of its children will always move together.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Sprite animation</h1>
                
            
            
                
<p class="calibre2">With <kbd class="calibre12">Area2D</kbd>, you can detect when other objects overlap or run into the player, but <kbd class="calibre12">Area2D</kbd> doesn't have an appearance on its own, so click on the <kbd class="calibre12">Player</kbd> node and add an <kbd class="calibre12">AnimatedSprite</kbd> node as a child. The <kbd class="calibre12">AnimatedSprite</kbd> will handle the appearance and animations for your player. Note that there is a warning symbol next to the node. An <kbd class="calibre12">AnimatedSprite</kbd> requires a <kbd class="calibre12">SpriteFrames</kbd> resource, which contains the animation(s) it can display. To create one, find the Frame<em class="calibre17">s</em> property in the Inspector and click &lt;null&gt; | New SpriteFrames:</p>
<div><img src="img/00023.jpeg" class="calibre41"/></div>
<p class="calibre2">Next, in the same location, click &lt;SpriteFrames&gt; to open the SpriteFrames panel:</p>
<div><img src="img/00024.gif" class="calibre42"/></div>
<p class="calibre2">On the left is a list of animations. Click the default one and rename it to <kbd class="calibre12">run</kbd>. Then, click the <strong class="calibre4">Add</strong> button and create a second animation named <kbd class="calibre12">idle</kbd> and a third named <kbd class="calibre12">hurt</kbd>.</p>
<p class="calibre2">In the FileSystem dock on the left, find the <kbd class="calibre12">run</kbd>, <kbd class="calibre12">idle</kbd>, and <kbd class="calibre12">hurt</kbd> player images and drag them into the corresponding animations:</p>
<div><img src="img/00025.jpeg" class="calibre43"/></div>
<p class="calibre2">Each animation has a default speed setting of 5 frames per second. This is a little too slow, so click on each of the animations and set the Speed (FPS) setting to 8. In the Inspector, check On next to the Playing property and choose an Animation to see the animations in action:</p>
<div><img src="img/00026.jpeg" class="calibre44"/></div>
<p class="calibre2">Later, you'll write code to select between these animations, depending on what the player is doing. But first, you need to finish setting up the player's nodes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Collision shape</h1>
                
            
            
                
<p class="calibre2">When using <kbd class="calibre12">Area2D</kbd>, or one of the other collision objects in Godot, it needs to have a shape defined, or it can't detect collisions. A collision shape defines the region that the object occupies and is used to detect overlaps and/or collisions. Shapes are defined by <kbd class="calibre12">Shape2D</kbd>, and include rectangles, circles, polygons, and other types of shapes.</p>
<p class="calibre2">For convenience, when you need to add a shape to an area or physics body, you can add a <kbd class="calibre12">CollisionShape2D</kbd> as a child. You then select the type of shape you want and you can edit its size in the editor. </p>
<p class="calibre2">Add a <kbd class="calibre12">CollisionShape2D</kbd> as a child of <kbd class="calibre12">Player</kbd> (make sure you don't add it as a child of the <kbd class="calibre12">AnimatedSprite</kbd>). This will allow you to determine the player's <em class="calibre17">hitbox</em>, or the bounds of its collision area. In the Inspector, next to Shape, click &lt;null&gt; and choose New RectangleShape2D. Adjust the shape's size to cover the sprite:</p>
<div><img src="img/00027.jpeg" class="calibre45"/></div>
<p>Be careful not to scale the shape's outline! Only use the size handles (red) to adjust the shape! Collisions will not work properly with a scaled collision shape.</p>
<p class="calibre2">You may have noticed that the collision shape is not centered on the sprite. That is because the sprites themselves are not centered vertically. We can fix this by adding a small offset to the <kbd class="calibre12">AnimatedSprite</kbd>. Click on the node and look for the Offset property in the Inspector. Set it to <kbd class="calibre12">(0, -5)</kbd>.</p>
<p class="calibre2">When you're finished, your <kbd class="calibre12">Player</kbd> scene should look like this:</p>
<div><img src="img/00028.jpeg" class="calibre46"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Scripting the Player</h1>
                
            
            
                
<p class="calibre2">Now, you're ready to add a script. Scripts allow you to add additional functionality that isn't provided by the built-in nodes. Click the <kbd class="calibre12">Player</kbd> node and click the <strong class="calibre4">Add Script</strong> button:</p>
<div><img src="img/00029.jpeg" class="calibre47"/></div>
<p class="calibre2">In the Script Settings window, you can leave the default settings as they are. If you've remembered to save the scene (see the preceding screenshot), the script will automatically be named to match the scene's name. Click Create and you'll be taken to the script window. Your script will contain some default comments and hints. You can remove the comments (lines starting with <kbd class="calibre12">#</kbd>). Refer to the following code snippet:</p>
<pre class="calibre18">extends Area2D<br class="title-page-name"/><br class="title-page-name"/># class member variables go here, for example:<br class="title-page-name"/># var a = 2<br class="title-page-name"/># var b = "textvar"<br class="title-page-name"/><br class="title-page-name"/>func _ready():<br class="title-page-name"/> # Called every time the node is added to the scene.<br class="title-page-name"/> # Initialization here<br class="title-page-name"/> pass<br class="title-page-name"/><br class="title-page-name"/>#func _process(delta):<br class="title-page-name"/># # Called every frame. Delta is time since last frame.<br class="title-page-name"/># # Update game logic here.<br class="title-page-name"/># pass</pre>
<p class="calibre2">The first line of every script will describe what type of node it is attached to. Next, you'll define your class variables:</p>
<pre class="calibre18">extends Area2D<br class="title-page-name"/><br class="title-page-name"/>export (int) var speed<br class="title-page-name"/>var velocity = Vector2()<br class="title-page-name"/>var screensize = Vector2(480, 720)</pre>
<p class="calibre2">Using the <kbd class="calibre12">export</kbd> keyword on the <kbd class="calibre12">speed</kbd> variable allows you to set its value in the Inspector, as well as letting the Inspector know what type of data the variable should contain. This can be very handy for values that you want to be able to adjust, just like you adjust a node's built-in properties. Click on the <strong class="calibre4"><kbd class="calibre12">Player</kbd></strong> node and set the Speed property to 350, as shown in the following screenshot:</p>
<div><img src="img/00030.jpeg" class="calibre48"/></div>
<p class="calibre2"><kbd class="calibre12">velocity</kbd> will contain the character's current movement speed and direction, and <kbd class="calibre12">screensize</kbd> will be used to set the limits of the player's movement. Later, the game's main scene will set this variable, but for now you will set it manually so you can test.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Moving the Player</h1>
                
            
            
                
<p class="calibre2">Next, you'll use the <kbd class="calibre12">_process()</kbd> function to define what the player will do. The <kbd class="calibre12">_process()</kbd> function is called on every frame, so you'll use it to update elements of your game that you expect to be changing often. You need the player to do three things:</p>
<ul class="calibre10">
<li class="calibre11">Check for keyboard input</li>
<li class="calibre11">Move in the given direction</li>
<li class="calibre11">Play the appropriate animation</li>
</ul>
<p class="calibre2">First, you need to check the inputs. For this game, you have four directional inputs to check (the four arrow keys). Input actions are defined in the project settings under the Input Map tab. In this tab, you can define custom events and assign different keys, mouse actions, or other inputs to them. By default, Godot has events assigned to the keyboard arrows, so you can use them for this project.</p>
<p class="calibre2">You can detect whether an input is pressed using <kbd class="calibre12">Input.is_action_pressed()</kbd>, which returns <kbd class="calibre12">true</kbd> if the key is held down and <kbd class="calibre12">false</kbd> if it is not. Combining the states of all four buttons will give you the resultant direction of movement. For example, if you hold <kbd class="calibre12">right</kbd> and <kbd class="calibre12">down</kbd> at the same time, the resulting velocity vector will be <kbd class="calibre12">(1, 1)</kbd>. In this case, since we’re adding a horizontal and a vertical movement together, the player would move <em class="calibre17">faster</em> than if they just moved horizontally.</p>
<p class="calibre2">You can prevent that by <em class="calibre17">normalizing</em> the velocity, which means setting its length to <strong class="calibre4">1</strong>, then multiplying it by the desired speed:</p>
<pre class="calibre18">func get_input():<br class="title-page-name"/>    velocity = Vector2()<br class="title-page-name"/>    if Input.is_action_pressed("ui_left"):<br class="title-page-name"/>        velocity.x -= 1<br class="title-page-name"/>    if Input.is_action_pressed("ui_right"):<br class="title-page-name"/>        velocity.x += 1<br class="title-page-name"/>    if Input.is_action_pressed("ui_up"):<br class="title-page-name"/>        velocity.y -= 1<br class="title-page-name"/>    if Input.is_action_pressed("ui_down"):<br class="title-page-name"/>        velocity.y += 1<br class="title-page-name"/>    if velocity.length() &gt; 0:<br class="title-page-name"/>        velocity = velocity.normalized() * speed</pre>
<p class="calibre2">By grouping all of this code together in a <kbd class="calibre12">get_input()</kbd> function, you make it easier to change things later. For example, you could decide to change to an analog joystick or other type of controller. Call this function from <kbd class="calibre12">_process()</kbd> and then change the player's <kbd class="calibre12">position</kbd> by the resulting <kbd class="calibre12">velocity</kbd>. To prevent the player from leaving the screen, you can use the <kbd class="calibre12">clamp()</kbd> function to limit the position to a minimum and maximum value:</p>
<pre class="calibre18">func _process(delta):<br class="title-page-name"/>    get_input()<br class="title-page-name"/>    <br class="title-page-name"/>    position += velocity * delta<br class="title-page-name"/>    position.x = clamp(position.x, 0, screensize.x)<br class="title-page-name"/>    position.y = clamp(position.y, 0, screensize.y)</pre>
<p class="calibre2">Click Play the Edited Scene (<em class="calibre17">F6</em>) and confirm that you can move the player around the screen in all directions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">About delta</h1>
                
            
            
                
<p class="calibre2">The <kbd class="calibre12">_process()</kbd> function includes a parameter called <kbd class="calibre12">delta</kbd> that is then multiplied by the velocity. What is <kbd class="calibre12">delta</kbd>?</p>
<p class="calibre2">The game engine attempts to run at a consistent 60 frames per second. However, this can change due to computer slowdowns, either in Godot or from the computer itself. If the frame rate is not consistent, then it will affect the movement of your game objects. For example, consider an object set to move <kbd class="calibre12">10</kbd> pixels every frame. If everything is running smoothly, this will translate to moving <kbd class="calibre12">600</kbd> pixels in one second. However, if some of those frames take longer, then there may only have been 50 frames in that second, so the object only moved <kbd class="calibre12">500</kbd> pixels.</p>
<p class="calibre2">Godot, like most game engines and frameworks, solves this by passing you <kbd class="calibre12">delta</kbd>, which is the elapsed time since the previous frame. Most of the time, this will be around <kbd class="calibre12">0.016</kbd> s (or around 16 milliseconds). If you then take your desired speed (<kbd class="calibre12">600</kbd> px/s) and multiply by delta, you will get a movement of exactly <kbd class="calibre12">10</kbd>. If, however, the <kbd class="calibre12">delta</kbd> increased to <kbd class="calibre12">0.3</kbd>, then the object will be moved <kbd class="calibre12">18</kbd> pixels. Overall, the movement speed remains consistent and independent of the frame rate.</p>
<p class="calibre2">As a side benefit, you can express your movement in units of px/s rather than px/frame, which is easier to visualize.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Choosing animations</h1>
                
            
            
                
<p class="calibre2">Now that the player can move, you need to change which animation the <kbd class="calibre12">AnimatedSprite</kbd> is playing based on whether it is moving or standing still. The art for the <kbd class="calibre12">run</kbd> animation faces to the right, which means it should be flipped horizontally (using the Flip H property) for movement to the left. Add this to the end of your <kbd class="calibre12">_process()</kbd> function:</p>
<pre class="calibre18">    if velocity.length() &gt; 0:<br class="title-page-name"/>        $AnimatedSprite.animation = "run"<br class="title-page-name"/>        $AnimatedSprite.flip_h = velocity.x &lt; 0<br class="title-page-name"/>    else:<br class="title-page-name"/>        $AnimatedSprite.animation = "idle"</pre>
<p class="calibre2">Note that this code takes a little shortcut. <kbd class="calibre12">flip_h</kbd> is a Boolean property, which means it can be <kbd class="calibre12">true</kbd> or <kbd class="calibre12">false</kbd>. A Boolean value is also the result of a comparison like <kbd class="calibre12">&lt;</kbd>. Because of this, we can set the property equal to the result of the comparison. This one line is equivalent to writing it out like this:</p>
<pre class="calibre18">if velocity.x &lt; 0:<br class="title-page-name"/>    $AnimatedSprite.flip_h = true<br class="title-page-name"/>else:<br class="title-page-name"/>    $AnimatedSprite.flip_h = false     </pre>
<p class="calibre2">Play the scene again and check that the animations are correct in each case. Make sure Playing is set to On in the <kbd class="calibre12">AnimatedSprite</kbd> so that the animations will play.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Starting and Ending the Player's Movement</h1>
                
            
            
                
<p class="calibre2">When the game starts, the main scene will need to inform the player that the game has begun. Add the <kbd class="calibre12">start()</kbd> function as follows, which the main scene will use to set the player's starting animation and position:</p>
<pre class="calibre18">func start(pos):<br class="title-page-name"/>    set_process(true)<br class="title-page-name"/>    position = pos<br class="title-page-name"/>    $AnimatedSprite.animation = "idle"</pre>
<p class="calibre2">The <kbd class="calibre12">die()</kbd> function will be called when the player hits an obstacle or runs out of time:</p>
<pre class="calibre18">func die():<br class="title-page-name"/>    $AnimatedSprite.animation = "hurt"<br class="title-page-name"/>    set_process(false)</pre>
<p class="calibre2">Setting <kbd class="calibre12">set_process(false)</kbd> causes the <kbd class="calibre12">_process()</kbd> function to no longer be called for this node. That way, when the player has died, they can't still be moved by key input.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Preparing for collisions</h1>
                
            
            
                
<p class="calibre2">The player should detect when it hits a coin or an obstacle, but you haven't made them do so yet. That's OK, because you can use Godot's <em class="calibre17">signal</em> functionality to make it work. Signals are a way for nodes to send out messages that other nodes can detect and react to. Many nodes have built-in signals to alert you when a body collides, for example, or when a button is pressed. You can also define custom signals for your own purposes.</p>
<p class="calibre2">Signals are used by <em class="calibre17">connecting</em> them to the node(s) that you want to listen and respond to. This connection can be made in the Inspector or in the code. Later in the project, you'll learn how to connect signals in both ways.</p>
<p class="calibre2">Add the following to the top of the script (after <kbd class="calibre12">extends Area2D</kbd>):</p>
<pre class="calibre18">signal pickup<br class="title-page-name"/>signal hurt</pre>
<p class="calibre2">These define custom signals that your player will <em class="calibre17">emit</em> (send out) when they touch a coin or an obstacle. The touches will be detected by the <kbd class="calibre12">Area2D</kbd> itself. Select the <kbd class="calibre12">Player</kbd> node and click the Node tab next to the Inspector to see the list of signals the player can emit:</p>
<div><img src="img/00031.jpeg" class="calibre49"/></div>
<p class="calibre2">Note your custom signals are there as well. Since the other objects will also be <kbd class="calibre12">Area2D</kbd> nodes, you want the <kbd class="calibre12">area_entered()</kbd> signal. Select it and click Connect. Click Connect on the Connecting Signal window—you don't need to change any of those settings. Godot will automatically create a new function called <kbd class="calibre12">_on_Player_area_entered()</kbd> in your script.</p>
<p>When connecting a signal, instead of having Godot create a function for you, you can also give the name of an existing function that you want to link the signal to. Toggle the Make Function switch to Off if you don't want Godot to create the function for you.</p>
<p class="calibre2">Add the following code to this new function:</p>
<pre class="calibre18">func _on_Player_area_entered( area ):<br class="title-page-name"/>    if area.is_in_group("coins"):<br class="title-page-name"/>        area.pickup()<br class="title-page-name"/>        emit_signal("pickup")<br class="title-page-name"/>    if area.is_in_group("obstacles"):<br class="title-page-name"/>        emit_signal("hurt")<br class="title-page-name"/>        die()</pre>
<p class="calibre2">When another <kbd class="calibre12">Area2D</kbd> is detected, it will be passed in to the function (using the <kbd class="calibre12">area</kbd> variable). The coin object will have a <kbd class="calibre12">pickup()</kbd> function that defines the coin's behavior when picked up (playing an animation or sound, for example). When you create the coins and obstacles, you'll assign them to the appropriate <em class="calibre17">group</em> so they can be detected.</p>
<p class="calibre2">To summarize, here is the complete player script so far:</p>
<pre class="calibre18">extends Area2D<br class="title-page-name"/><br class="title-page-name"/>signal pickup<br class="title-page-name"/>signal hurt<br class="title-page-name"/><br class="title-page-name"/>export (int) var speed<br class="title-page-name"/>var velocity = Vector2()<br class="title-page-name"/>var screensize = Vector2(480, 720)<br class="title-page-name"/><br class="title-page-name"/>func get_input():<br class="title-page-name"/>    velocity = Vector2()<br class="title-page-name"/>    if Input.is_action_pressed("ui_left"):<br class="title-page-name"/>        velocity.x -= 1<br class="title-page-name"/>    if Input.is_action_pressed("ui_right"):<br class="title-page-name"/>        velocity.x += 1<br class="title-page-name"/>    if Input.is_action_pressed("ui_up"):<br class="title-page-name"/>        velocity.y -= 1<br class="title-page-name"/>    if Input.is_action_pressed("ui_down"):<br class="title-page-name"/>        velocity.y += 1<br class="title-page-name"/>    if velocity.length() &gt; 0:<br class="title-page-name"/>        velocity = velocity.normalized() * speed<br class="title-page-name"/><br class="title-page-name"/>func _process(delta):<br class="title-page-name"/>    get_input()<br class="title-page-name"/>    position += velocity * delta<br class="title-page-name"/>    position.x = clamp(position.x, 0, screensize.x)<br class="title-page-name"/>    position.y = clamp(position.y, 0, screensize.y)<br class="title-page-name"/><br class="title-page-name"/>    if velocity.length() &gt; 0:<br class="title-page-name"/>        $AnimatedSprite.animation = "run"<br class="title-page-name"/>        $AnimatedSprite.flip_h = velocity.x &lt; 0<br class="title-page-name"/>    else:<br class="title-page-name"/>        $AnimatedSprite.animation = "idle"<br class="title-page-name"/><br class="title-page-name"/>func start(pos):<br class="title-page-name"/>    set_process(true)<br class="title-page-name"/>    position = pos<br class="title-page-name"/>    $AnimatedSprite.animation = "idle"<br class="title-page-name"/><br class="title-page-name"/>func die():<br class="title-page-name"/>    $AnimatedSprite.animation = "hurt"<br class="title-page-name"/>    set_process(false)<br class="title-page-name"/><br class="title-page-name"/>func _on_Player_area_entered( area ):<br class="title-page-name"/>    if area.is_in_group("coins"):<br class="title-page-name"/>        area.pickup()<br class="title-page-name"/>        emit_signal("pickup")<br class="title-page-name"/>    if area.is_in_group("obstacles"):<br class="title-page-name"/>        emit_signal("hurt")<br class="title-page-name"/>        die()</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Part 2 – Coin scene</h1>
                
            
            
                
<p class="calibre2">In this part, you'll make the coins for the player to collect. This will be a separate scene describing all of the properties and behavior of a single coin. Once saved, the main scene will load the coin scene and create multiple <em class="calibre17">instances</em> (that is, copies) of it. </p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Node setup</h1>
                
            
            
                
<p class="calibre2">Click Scene | New Scene and add the following nodes. Don't forget to set the children to not be selected, like you did with the <kbd class="calibre12">Player</kbd> scene:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">Area2D</kbd> (named <kbd class="calibre12">Coin</kbd>)</li>
<li class="calibre11"><kbd class="calibre12">AnimatedSprite</kbd></li>
<li class="calibre11"><kbd class="calibre12">CollisionShape2D</kbd></li>
</ul>
<p class="calibre2">Make sure to save the scene once you've added the nodes.</p>
<p class="calibre2">Set up the <kbd class="calibre12">AnimatedSprite</kbd> like you did in the Player scene. This time, you only have one animation: a shine/sparkle effect that makes the coin look less flat and boring. Add all the frames and set the Speed (FPS) to <kbd class="calibre12">12</kbd>. The images are a little too large, so set the Scale of <kbd class="calibre12">AnimatedSprite</kbd> to (<kbd class="calibre12">0.5</kbd>, <kbd class="calibre12">0.5</kbd>). In the <kbd class="calibre12">CollisionShape2D</kbd>, use a <kbd class="calibre12">CircleShape2D</kbd> and size it to cover the coin image. Don't forget: never use the scale handles when sizing a collision shape. The circle shape has a single handle that adjusts the circle's radius.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Using groups</h1>
                
            
            
                
<p class="calibre2">Groups provide a tagging system for nodes, allowing you to identify similar nodes. A node can belong to any number of groups. You need to ensure that all coins will be in a group called <kbd class="calibre12">coins</kbd> for the player script to react correctly to touching the coin. Select the <kbd class="calibre12">Coin</kbd> node and click the Node tab (the same tab where you found the signals) and choose Groups. Type <kbd class="calibre12">coins</kbd> in the box and click Add, as shown in the following screenshot:</p>
<div><img src="img/00032.jpeg" class="calibre50"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Script</h1>
                
            
            
                
<p class="calibre2">Next, add a script to the <kbd class="calibre12">Coin</kbd> node. If you choose Empty in the Template setting, Godot will create an empty script without any comments or suggestions. The code for the coin's script is much shorter than the code for the player's:</p>
<pre class="calibre18">extends Area2D<br class="title-page-name"/><br class="title-page-name"/>func pickup():<br class="title-page-name"/>    queue_free()</pre>
<p class="calibre2">The <kbd class="calibre12">pickup()</kbd> function is called by the player script and tells the coin what to do when it's been collected. <kbd class="calibre12">queue_free()</kbd> is Godot's node removal method. It safely removes the node from the tree and deletes it from memory along with all of its children. Later, you'll add a visual effect here, but for now the coin disappearing is good enough.</p>
<div><kbd class="calibre51">queue_free()</kbd> doesn't delete the object immediately, but rather adds it to a queue to be deleted at the end of the current frame. This is safer than immediately deleting the node, because other code running in the game may still need the node to exist. By waiting until the end of the frame, Godot can be sure that all code that may access the node has completed and the node can be removed safely.</div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Part 3 – Main scene</h1>
                
            
            
                
<p class="calibre2">The <kbd class="calibre12">Main</kbd> scene is what ties all the pieces of the game together. It will manage the player, the coins, the timer, and the other pieces of the game. </p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Node setup</h1>
                
            
            
                
<p class="calibre2">Create a new scene and add a node named <kbd class="calibre12">Main</kbd>. To add the player to the scene, click the Instance button and select your saved <kbd class="calibre12">Player.tscn</kbd>:</p>
<div><img src="img/00033.gif" class="calibre52"/></div>
<p class="calibre2">Now, add the following nodes as children of <strong class="calibre4"><kbd class="calibre12">Main</kbd></strong>, naming them as follows:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">TextureRect</kbd> (named <kbd class="calibre12">Background</kbd>)—for the background image</li>
<li class="calibre11"><kbd class="calibre12">Node</kbd> (named <kbd class="calibre12">CoinContainer</kbd>)—to hold all the coins</li>
<li class="calibre11"><kbd class="calibre12">Position2D</kbd> (named <kbd class="calibre12">PlayerStart</kbd>)—to mark the starting position of the <kbd class="calibre12">Player</kbd></li>
<li class="calibre11"><kbd class="calibre12">Timer</kbd> (named <kbd class="calibre12">GameTimer</kbd>)—to track the time limit</li>
</ul>
<p class="calibre2">Make sure <kbd class="calibre12">Background</kbd> is the first child node. Nodes are drawn in the order shown, so the background will be <em class="calibre17">behind</em> the player in this case. Add an image to the <kbd class="calibre12">Background</kbd> node by dragging the <kbd class="calibre12">grass.png</kbd> image from the <kbd class="calibre12">assets</kbd> folder into the Texture property. Change the Stretch Mode to Tile and then click Layout | Full Rect to size the frame to the size of the screen, as shown in the following screenshot:</p>
<div><img src="img/00034.jpeg" class="calibre53"/></div>
<p class="calibre2">Set the Position of the <kbd class="calibre12">PlayerStart</kbd> node to (<kbd class="calibre12">240</kbd>, <kbd class="calibre12">350</kbd>).</p>
<p class="calibre2">Your scene layout should look like this:</p>
<div><img src="img/00035.jpeg" class="calibre54"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Main script</h1>
                
            
            
                
<p class="calibre2">Add a script to the <kbd class="calibre12">Main</kbd> node (use the Empty template) and add the following variables:</p>
<pre class="calibre18">extends Node<br class="title-page-name"/><br class="title-page-name"/>export (PackedScene) var Coin<br class="title-page-name"/>export (int) var playtime<br class="title-page-name"/><br class="title-page-name"/>var level<br class="title-page-name"/>var score<br class="title-page-name"/>var time_left<br class="title-page-name"/>var screensize<br class="title-page-name"/>var playing = false</pre>
<p class="calibre2">The <kbd class="calibre12">Coin</kbd> and <kbd class="calibre12">Playtime</kbd> properties will now appear in the Inspector when you click on <kbd class="calibre12">Main</kbd>. Drag <kbd class="calibre12">Coin.tscn</kbd> from the FileSystem panel and drop it in the <kbd class="calibre12">Coin</kbd> property. Set <kbd class="calibre12">Playtime</kbd> to <kbd class="calibre12">30</kbd> (this is the amount of time the game will last). The remaining variables will be used later in the code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Initializing</h1>
                
            
            
                
<p class="calibre2">Next, add the <kbd class="calibre12">_ready()</kbd> function:</p>
<pre class="calibre18">func _ready():<br class="title-page-name"/>    randomize()<br class="title-page-name"/>    screensize = get_viewport().get_visible_rect().size<br class="title-page-name"/>    $Player.screensize = screensize<br class="title-page-name"/>    $Player.hide()</pre>
<p class="calibre2">In GDScript, you can use <kbd class="calibre12">$</kbd> to refer to a particular node by name. This allows you to find the size of the screen and assign it to the player's <kbd class="calibre12">screensize</kbd> variable. <kbd class="calibre12">hide()</kbd> makes the player start out invisible (you'll make them appear when the game actually starts).</p>
<p class="calibre2">In the <kbd class="calibre12">$</kbd> notation, the node name is relative to the node running the script. For example, <kbd class="calibre12">$Node1/Node2</kbd> would refer to a node (<kbd class="calibre12">Node2</kbd>) that is the child of <kbd class="calibre12">Node1</kbd>, which itself is a child of the currently running script. Godot's autocomplete will suggest node names from the tree as you type. Note that if the node's name contains spaces, you must put quote marks around it, for example, <kbd class="calibre12">$"My Node"</kbd>.</p>
<p>You must use <kbd class="calibre51">randomize()</kbd> if you want your sequence of "random" numbers to be different every time you run the scene. Technically speaking, this selects a random <em class="calibre55">seed</em> for the random number generator.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Starting a new game</h1>
                
            
            
                
<p class="calibre2">Next, the <kbd class="calibre12">new_game()</kbd> function will initialize everything for a new game:</p>
<pre class="calibre18">func new_game():<br class="title-page-name"/>    playing = true<br class="title-page-name"/>    level = 1<br class="title-page-name"/>    score = 0<br class="title-page-name"/>    time_left = playtime<br class="title-page-name"/>    $Player.start($PlayerStart.position)<br class="title-page-name"/>    $Player.show()<br class="title-page-name"/>    $GameTimer.start()<br class="title-page-name"/>    spawn_coins()</pre>
<p class="calibre2">In addition to setting the variables to their starting values, this function calls the Player's <kbd class="calibre12">start()</kbd> function to ensure it moves to the proper starting location. The game timer is started, which will count down the remaining time in the game.</p>
<p class="calibre2">You also need a function that will create a number of coins based on the current level:</p>
<pre class="calibre18">func spawn_coins():<br class="title-page-name"/>    for i in range(4 + level):<br class="title-page-name"/>        var c = Coin.instance()<br class="title-page-name"/>        $CoinContainer.add_child(c)<br class="title-page-name"/>        c.screensize = screensize<br class="title-page-name"/>        c.position = Vector2(rand_range(0, screensize.x),<br class="title-page-name"/>        rand_range(0, screensize.y))</pre>
<p class="calibre2">In this function, you create a number of <em class="calibre17">instances</em> of the <kbd class="calibre12">Coin</kbd> object (in code this time, rather than by clicking the Instance a Scene button), and add it as a child of the <kbd class="calibre12">CoinContainer</kbd>. Whenever you instance a new node, it must be added to the tree using <kbd class="calibre12">add_child()</kbd>. Finally, you pick a random location for the coin to appear in. You'll call this function at the start of every level, generating more coins each time.</p>
<p class="calibre2">Eventually, you'll want <kbd class="calibre12">new_game()</kbd> to be called when the player clicks the start button. For now, to test if everything is working, add <kbd class="calibre12">new_game()</kbd> to the end of your <kbd class="calibre12">_ready()</kbd> function and click Play the Project (<em class="calibre17">F5</em>). When you are prompted to choose a main scene, choose <kbd class="calibre12">Main.tscn</kbd>. Now, whenever you play the project, the <kbd class="calibre12">Main</kbd> scene will be started.</p>
<p class="calibre2">At this point, you should see your player and five coins appear on the screen. When the player touches a coin, it disappears.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Checking for remaining coins</h1>
                
            
            
                
<p class="calibre2">The main script needs to detect whether the player has picked up all of the coins. Since the coins are all children of <kbd class="calibre12">CoinCointainer</kbd>, you can use <kbd class="calibre12">get_child_count()</kbd> on this node to find out how many coins remain. Put this in the <kbd class="calibre12">_process()</kbd> function so that it will be checked every frame:</p>
<pre class="calibre18">func _process(delta):<br class="title-page-name"/>    if playing and $CoinContainer.get_child_count() == 0:<br class="title-page-name"/>        level += 1<br class="title-page-name"/>        time_left += 5<br class="title-page-name"/>        spawn_coins()</pre>
<p class="calibre2">If no more coins remain, then the player advances to the next level.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Part 4 – User Interface</h1>
                
            
            
                
<p class="calibre2">The final piece your game needs is a <strong class="calibre4">user interface</strong> (<strong class="calibre4">UI</strong>). This is an interface to display information that the player needs to see during gameplay. In games, this is also referred to as a <strong class="calibre4">Heads-Up Display</strong> (<strong class="calibre4">HUD</strong>), because the information appears as an overlay on top of the game view. You'll also use this scene to display a start button.</p>
<p class="calibre2">The HUD will display the following information:</p>
<ul class="calibre10">
<li class="calibre11">Score</li>
<li class="calibre11">Time remaining</li>
<li class="calibre11">A message, such as Game Over</li>
<li class="calibre11">A start button</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Node setup</h1>
                
            
            
                
<p class="calibre2">Create a new scene and add a <kbd class="calibre12">CanvasLayer</kbd> node named <kbd class="calibre12">HUD</kbd>. A <kbd class="calibre12">CanvasLayer</kbd> node allows you to draw your UI elements on a layer above the rest of the game, so that the information it displays doesn't get covered up by any game elements like the player or the coins.</p>
<p class="calibre2">Godot provides a wide variety of UI elements that may be used to create anything from indicators such as health bars to complex interfaces such as inventories. In fact, the Godot editor that you are using to make this game is built in Godot using these elements. The basic nodes for UI elements are extended from <kbd class="calibre12">Control</kbd>, and appear with green icons in the node list. To create your UI, you'll use various <kbd class="calibre12">Control</kbd> nodes to position, format, and display information. Here is what the <kbd class="calibre12">HUD</kbd> will look like when complete:</p>
<div><img src="img/00036.jpeg" class="calibre56"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Anchors and margins</h1>
                
            
            
                
<p class="calibre2">Control nodes have a position and size, but they also have properties called <strong class="calibre4">anchors</strong> and <strong class="calibre4">margins</strong>. Anchors define the origin, or the reference point, for the edges of the node, relative to the parent container. Margins represent the distance from the control node's edge to its corresponding anchor. Margins update automatically when you move or resize a control node. </p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Message label</h1>
                
            
            
                
<p class="calibre2">Add a <kbd class="calibre12">Label</kbd> node to the scene and change its name to <kbd class="calibre12">MessageLabel</kbd><strong class="calibre4">.</strong> This label will display the game's title, as well as Game Over when the game ends. This label should be centered on the game screen. You could drag it with the mouse, but to place UI elements precisely, you should use the Anchor properties.</p>
<p class="calibre2">Select View | Show Helpers to display pins that will help you see the anchor positions, then click on the Layout menu and select HCenter Wide:</p>
<div><img src="img/00037.jpeg" class="calibre57"/></div>
<p class="calibre2">The <kbd class="calibre12">MessageLabel</kbd> now spans the width of the screen and is centered vertically. The Text property in the Inspector sets what text the label displays. Set it to Coin Dash! and set Align and Valign to Center.</p>
<p class="calibre2">The default font for <kbd class="calibre12">Label</kbd> nodes is very small, so the next step is to assign a custom font. Scroll down to the Custom Fonts section in the Inspector and select New DynamicFont, as shown in the following screenshot:</p>
<div><img src="img/00038.jpeg" class="calibre58"/></div>
<p class="calibre2">Now, click on DynamicFont and you can adjust the font settings. From the FileSystem dock, drag the <kbd class="calibre12">Kenney Bold.ttf</kbd> font and drop it in the Font Data<em class="calibre17"> </em>property. Set Size<em class="calibre17"> </em>to <strong class="calibre4"><kbd class="calibre12">48</kbd></strong>, as shown in the following screenshot:</p>
<div><img src="img/00039.jpeg" class="calibre59"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Score and time display</h1>
                
            
            
                
<p class="calibre2">The top of the <kbd class="calibre12">HUD</kbd> will display the player's score and the time remaining on the clock. Both of these will be <kbd class="calibre12">Label</kbd> nodes, arranged at opposite sides of the game screen. Rather than position them separately, you'll use a <kbd class="calibre12">Container</kbd> node to manage their positions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Containers</h1>
                
            
            
                
<p class="calibre2">UI containers automatically arrange the positions of their child <kbd class="calibre12">Control</kbd> nodes (including other <kbd class="calibre12">Containers</kbd>). You can use them to add padding around elements, center them, or arrange elements in rows or columns. Each type of <kbd class="calibre12">Container</kbd> has special properties that control how they arrange their children. You can see these properties in the Custom Constants section of the Inspector.</p>
<p>Remember that containers <em class="calibre55">automatically</em> arrange their children. If you move or resize a Control that's inside a <kbd class="calibre51">Container</kbd> node, you'll find it snaps back to its original position. You can manually arrange controls <em class="calibre55">or</em> arrange them with a container, but not both.</p>
<p class="calibre2">To manage the score and time labels, add a <strong class="calibre4"><kbd class="calibre12">MarginContainer</kbd></strong> node to the <strong class="calibre4"><kbd class="calibre12">HUD</kbd>.</strong> Use the Layout menu to set the anchors to Top Wide. In the Custom Constants section, set Margin Right, Margin Top, and Margin Left to <kbd class="calibre12">10</kbd>. This will add some padding so that the text isn't against the edge of the screen.</p>
<p class="calibre2">Since the score and time labels will use the same font settings as the <kbd class="calibre12">MessageLabel</kbd>, it will save time if you duplicate it. Click on <kbd class="calibre12">MessageLabel</kbd> and press <em class="calibre17">Ctrl</em> + <em class="calibre17">D</em> (<em class="calibre17">Cmd</em> + <em class="calibre17">D</em> on macOS) twice to create two duplicate labels. Drag them both and drop them on the <kbd class="calibre12">MarginContainer</kbd> to make them its children. Name one <kbd class="calibre12">ScoreLabel</kbd> and the other <kbd class="calibre12">TimeLabel</kbd> and set the Text property to <kbd class="calibre12">0</kbd> for both. Set Align to Left for <kbd class="calibre12">ScoreLabel</kbd> and Right for <strong class="calibre4"><kbd class="calibre12">TimeLabel</kbd>.</strong></p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Updating UI via GDScript</h1>
                
            
            
                
<p class="calibre2">Add a script to the <kbd class="calibre12">HUD</kbd> node. This script will update the UI elements when their properties need to change, updating the score text whenever a coin is collected, for example. Refer to the following code:</p>
<pre class="calibre18">extends CanvasLayer<br class="title-page-name"/><br class="title-page-name"/>signal start_game<br class="title-page-name"/><br class="title-page-name"/>func update_score(value):<br class="title-page-name"/>    $MarginContainer/ScoreLabel.text = str(value)<br class="title-page-name"/> <br class="title-page-name"/>func update_timer(value):<br class="title-page-name"/>    $MarginContainer/TimeLabel.txt = str(value)</pre>
<p class="calibre2">The <kbd class="calibre12">Main</kbd> scene's script will call these functions to update the display whenever there is a change in value. For the <kbd class="calibre12">MessageLabel</kbd>, you also need a timer to make it disappear after a brief period. Add a <kbd class="calibre12">Timer</kbd> node and change its name to <kbd class="calibre12">MessageTimer</kbd><strong class="calibre4">. </strong>In the Inspector, set its Wait Time to <kbd class="calibre12">2</kbd> seconds and check the box to set One Shot to On. This ensures that, when started, the timer will only run once, rather than repeating. Add the following code:</p>
<pre class="calibre18">func show_message(text):<br class="title-page-name"/>    $MessageLabel.text = text<br class="title-page-name"/>    $MessageLabel.show()<br class="title-page-name"/>    $MessageTimer.start()</pre>
<p class="calibre2">In this function, you display the message and start the timer. To hide the message, connect the <kbd class="calibre12">timeout()</kbd> signal of <kbd class="calibre12">MessageTimer</kbd> and add this:</p>
<pre class="calibre18">func _on_MessageTimer_timeout():<br class="title-page-name"/>    $MessageLabel.hide()</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Using buttons</h1>
                
            
            
                
<p class="calibre2">Add a <kbd class="calibre12">Button</kbd> node and change its name to <kbd class="calibre12">StartButton</kbd><strong class="calibre4">. </strong>This button will be displayed before the game starts, and when clicked, it will hide itself and send a signal to the <kbd class="calibre12">Main</kbd> scene to start the game. Set the Text property to Start and change the custom font like you did with the <strong class="calibre4"><kbd class="calibre12">MessageLabel</kbd>.</strong> In the Layout menu, choose Center Bottom. This will put the button at the very bottom of the screen, so move it up a little bit either by pressing the <em class="calibre17">Up</em> arrow key or by editing the margins and setting Top to <kbd class="calibre12">-150</kbd> and Bottom to <kbd class="calibre12">-50</kbd>. </p>
<p class="calibre2">When a button is clicked, a signal is sent out. In the Node tab for the <kbd class="calibre12">StartButton</kbd>, connect the <kbd class="calibre12">pressed()</kbd> signal:</p>
<pre class="calibre18">func _on_StartButton_pressed():<br class="title-page-name"/>    $StartButton.hide()<br class="title-page-name"/>    $MessageLabel.hide()<br class="title-page-name"/>    emit_signal("start_game")</pre>
<p class="calibre2">The <kbd class="calibre12">HUD</kbd> emits the <kbd class="calibre12">start_game</kbd> signal to notify <kbd class="calibre12">Main</kbd> that it's time to start a new game.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Game over</h1>
                
            
            
                
<p class="calibre2">The final task for your UI is to react to the game ending:</p>
<pre class="calibre18">func show_game_over():<br class="title-page-name"/>    show_message("Game Over")<br class="title-page-name"/>    yield($MessageTimer, "timeout")<br class="title-page-name"/>    $StartButton.show()<br class="title-page-name"/>    $MessageLabel.text = "Coin Dash!"<br class="title-page-name"/>    $MessageLabel.show()</pre>
<p class="calibre2">In this function, you need the Game Over message to be displayed for two seconds and then disappear, which is what <kbd class="calibre12">show_message()</kbd> does. However, you also want to show the start button once the message has disappeared. The <kbd class="calibre12">yield()</kbd> function pauses execution of the function until the given node (<kbd class="calibre12">MessageTimer</kbd>) emits a given signal (<kbd class="calibre12">timeout</kbd>). Once the signal is received, the function continues, returning you to the initial state so that you can play again.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Adding the HUD to Main</h1>
                
            
            
                
<p class="calibre2">Now, you need to set up the communication between the <kbd class="calibre12">Main</kbd> scene and the <kbd class="calibre12">HUD</kbd>. Add an instance of the <kbd class="calibre12">HUD</kbd> scene to the <kbd class="calibre12">Main</kbd> scene. In the <kbd class="calibre12">Main</kbd> scene, connect the <kbd class="calibre12">timeout()</kbd> signal of <kbd class="calibre12">GameTimer</kbd> and add the following:</p>
<pre class="calibre18">func _on_GameTimer_timeout():<br class="title-page-name"/>    time_left -= 1<br class="title-page-name"/>    $HUD.update_timer(time_left)<br class="title-page-name"/>    if time_left &lt;= 0:<br class="title-page-name"/>        game_over()</pre>
<p class="calibre2">Every time the <kbd class="calibre12">GameTimer</kbd> times out (every second), the remaining time is reduced. <br class="calibre6"/>
Next, connect the <kbd class="calibre12">pickup()</kbd> and <kbd class="calibre12">hurt()</kbd> signals of the <kbd class="calibre12">Player</kbd>:</p>
<pre class="calibre18">func _on_Player_pickup():<br class="title-page-name"/>    score += 1<br class="title-page-name"/>    $HUD.update_score(score)<br class="title-page-name"/><br class="title-page-name"/>func _on_Player_hurt():<br class="title-page-name"/>    game_over()</pre>
<p class="calibre2">Several things need to happen when the game ends, so add the following function:</p>
<pre class="calibre18">func game_over():<br class="title-page-name"/>    playing = false<br class="title-page-name"/>    $GameTimer.stop()<br class="title-page-name"/>    for coin in $CoinContainer.get_children():<br class="title-page-name"/>        coin.queue_free()<br class="title-page-name"/>    $HUD.show_game_over()<br class="title-page-name"/>    $Player.die()</pre>
<p class="calibre2">This function halts the game, and also loops through the coins and removes any that are remaining, as well as calling the HUD's <kbd class="calibre12">show_game_over()</kbd> function.</p>
<p class="calibre2">Finally, the <kbd class="calibre12">StartButton</kbd> needs to activate the <kbd class="calibre12">new_game()</kbd> function. Click on the <kbd class="calibre12">HUD</kbd> instance and select its <kbd class="calibre12">new_game()</kbd> signal. In the signal connection dialog, click Make Function to Off and in the Method In Node field, type <kbd class="calibre12">new_game</kbd>. This will connect the signal to the existing function rather than creating a new one. Take a look at the following screenshot:</p>
<div><img src="img/00040.jpeg" class="calibre60"/></div>
<p class="calibre2">Remove <kbd class="calibre12">new_game()</kbd> from the <kbd class="calibre12">_ready()</kbd> function and add these two lines to the <kbd class="calibre12">new_game()</kbd> function:</p>
<pre class="calibre18">$HUD.update_score(score)<br class="title-page-name"/>$HUD.update_timer(time_left)</pre>
<p class="calibre2">Now, you can play the game! Confirm that all the parts are working as intended: the score, the countdown, the game ending and restarting, and so on. If you find a piece that's not working, go back and check the step where you created it, as well as the step(s) where it was connected to the rest of the game.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Part 5 – Finishing up</h1>
                
            
            
                
<p class="calibre2">You have created a working game, but it still could be made to feel a little more exciting. Game developers use the term <em class="calibre17">juice</em> to describe the things that make the game feel good to play. Juice can include things like sound, visual effects, or any other addition that adds to the player's enjoyment, without necessarily changing the nature of the gameplay.</p>
<p class="calibre2">In this section, you'll add some small <em class="calibre17">juicy</em> features to finish up the game.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Visual effects</h1>
                
            
            
                
<p class="calibre2">When you pick up the coins, they just disappear, which is not very appealing. Adding a visual effect will make it much more satisfying to collect lots of coins.</p>
<p class="calibre2">Start by adding a <kbd class="calibre12">Tween</kbd> node to the <kbd class="calibre12">Coin</kbd> scene.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">What is a tween?</h1>
                
            
            
                
<p class="calibre2">A <strong class="calibre4">tween</strong> is a way to interpolate (change gradually) some value over time (from a start value to an end value) using a particular function. For example, you might choose a function that steadily changes the value or one that starts slow but ramps up in speed. Tweening is also sometimes referred to as <em class="calibre17">easing</em>.</p>
<p class="calibre2">When using a <kbd class="calibre12">Tween</kbd> node in Godot, you can assign it to alter one or more properties of a node. In this case, you're going to increase the <kbd class="calibre12">Scale</kbd> of the coin and also cause it to fade out using the Modulate property.</p>
<p class="calibre2">Add this line to the <kbd class="calibre12">_ready()</kbd> function of <kbd class="calibre12">Coin</kbd>:</p>
<pre class="calibre18">$Tween.interpolate_property($AnimatedSprite, 'scale',<br class="title-page-name"/>                            $AnimatedSprite.scale,<br class="title-page-name"/>                            $AnimatedSprite.scale * 3, 0.3,<br class="title-page-name"/>                            Tween.TRANS_QUAD,<br class="title-page-name"/>                            Tween.EASE_IN_OUT)</pre>
<p class="calibre2">The <kbd class="calibre12">interpolate_property()</kbd> function causes the <kbd class="calibre12">Tween</kbd> to change a node's property. There are seven parameters:</p>
<ul class="calibre10">
<li class="calibre11">The node to affect</li>
<li class="calibre11">The property to alter</li>
<li class="calibre11">The property's starting value</li>
<li class="calibre11">The property's ending value</li>
<li class="calibre11">The duration (in seconds)</li>
<li class="calibre11">The function to use</li>
<li class="calibre11">The direction</li>
</ul>
<p class="calibre2">The tween should start playing when the player picks up the coin. Replace <kbd class="calibre12">queue_free()</kbd> in the <kbd class="calibre12">pickup()</kbd> function:</p>
<pre class="calibre18">func pickup():<br class="title-page-name"/>    monitoring = false<br class="title-page-name"/>    $Tween.start() </pre>
<p class="calibre2">Setting <kbd class="calibre12">monitoring</kbd> to <kbd class="calibre12">false</kbd> ensures that the <kbd class="calibre12">area_enter()</kbd> signal won't be emitted if the player touches the coin during the tween animation.</p>
<p class="calibre2">Finally, the coin should be deleted when the animation finishes, so connect the <kbd class="calibre12">Tween</kbd> node's <kbd class="calibre12">tween_completed()</kbd> signal:</p>
<pre class="calibre18">func _on_Tween_tween_completed(object, key):<br class="title-page-name"/>    queue_free()</pre>
<p class="calibre2">Now, when you run the game, you should see the coins growing larger when they're picked up. This is good, but tweens are even more effective when applied to multiple properties at once. You can add another <kbd class="calibre12">interpolate_property()</kbd>, this time to change the sprite's opacity. This is done by altering the <kbd class="calibre12">modulate</kbd> property, which is a <kbd class="calibre12">Color</kbd> object, and changing its alpha channel from <kbd class="calibre12">1</kbd> (opaque) to <kbd class="calibre12">0</kbd> (transparent). Refer to the following code:</p>
<pre class="calibre18">$Tween.interpolate_property($AnimatedSprite, 'modulate', <br class="title-page-name"/>                            Color(1, 1, 1, 1),<br class="title-page-name"/>                            Color(1, 1, 1, 0), 0.3,<br class="title-page-name"/>                            Tween.TRANS_QUAD,<br class="title-page-name"/>                            Tween.EASE_IN_OUT)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Sound</h1>
                
            
            
                
<p class="calibre2">Sound is one of the most important but often neglected pieces of game design. Good sound design can add a huge amount of juice to your game for a very small amount of effort. Sounds can give the player feedback, connect them emotionally to the characters, or even be a part of the gameplay.</p>
<p class="calibre2">For this game, you're going to add three sound effects. In the <kbd class="calibre12">Main</kbd> scene, add three <kbd class="calibre12">AudioStreamPlayer</kbd> nodes and name them <kbd class="calibre12">CoinSound</kbd>, <kbd class="calibre12">LevelSound</kbd>, and <kbd class="calibre12">EndSound</kbd>. Drag each sound from the <kbd class="calibre12">audio</kbd> folder (you can find it under <kbd class="calibre12">assets</kbd> in the FileSystem dock) into the corresponding Stream property of each node.</p>
<p class="calibre2">To play a sound, you call the <kbd class="calibre12">play()</kbd> function on it. Add <kbd class="calibre12">$CoinSound.play()</kbd> to the <kbd class="calibre12">_on_Player_pickup()</kbd> function, <kbd class="calibre12">$EndSound.play()</kbd> to the <kbd class="calibre12">game_over()</kbd> function, and <kbd class="calibre12">$LevelSound.play()</kbd> to the <kbd class="calibre12">spawn_coins()</kbd> function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Powerups</h1>
                
            
            
                
<p class="calibre2">There are many possibilities for objects that give the player a small advantage or powerup. In this section, you'll add a powerup item that gives the player a small time bonus when collected. It will appear occasionally for a short time, then disappear.</p>
<p class="calibre2">The new scene will be very similar to the <kbd class="calibre12">Coin</kbd> scene you already created, so click on your <kbd class="calibre12">Coin</kbd> scene and choose Scene | Save Scene As and save it as <kbd class="calibre12">Powerup.tscn</kbd>. Change the name of the root node to Powerup and remove the script by clicking the clear script button: <img src="img/00041.jpeg" class="calibre61"/>. You should also disconnect the <kbd class="calibre12">area_entered</kbd> signal (you'll reconnect it later). In the Groups tab, remove the coins group by clicking the delete button (it looks like a trash can) and adding it to a new group called <kbd class="calibre12">powerups</kbd> instead.</p>
<p class="calibre2">In the <kbd class="calibre12">AnimatedSprite</kbd>, change the images from the coin to the powerup, which you can find in the <kbd class="calibre12">res://assets/pow/</kbd> folder.</p>
<p class="calibre2">Click to add a new script and copy the code from the <kbd class="calibre12">Coin.gd</kbd> script. Change the name of <kbd class="calibre12">_on_Coin_area_entered</kbd> to <kbd class="calibre12">_on_Powerup_area_entered</kbd> and connect the <kbd class="calibre12">area_entered</kbd> signal to it again. Remember, this function name will automatically be chosen by the signal connect window.</p>
<p class="calibre2">Next, add a <kbd class="calibre12">Timer</kbd> node named <kbd class="calibre12">Lifetime</kbd>. This will limit the amount of time the object remains on the screen. Set its Wait Time to <kbd class="calibre12">2</kbd> and both One Shot and Autostart to <kbd class="calibre12">On</kbd>. Connect its timeout signal so that it can be removed at the end of the time period:</p>
<pre class="calibre18">func _on_Lifetime_timeout():<br class="title-page-name"/>    queue_free()</pre>
<p class="calibre2">Now, go to your Main scene and add another <kbd class="calibre12">Timer</kbd> node called <kbd class="calibre12">PowerupTimer</kbd>. Set its One Shot property to On. There is also a <kbd class="calibre12">Powerup.wav</kbd> sound in the <kbd class="calibre12">audio</kbd> folder you can add with another <kbd class="calibre12">AudioStreamPlayer</kbd>.</p>
<p class="calibre2">Connect the <kbd class="calibre12">timeout</kbd> signal and add the following code to spawn a <kbd class="calibre12">Powerup</kbd>:</p>
<pre class="calibre18">func _on_PowerupTimer_timeout():<br class="title-page-name"/>    var p = Powerup.instance()<br class="title-page-name"/>    add_child(p)<br class="title-page-name"/>    p.screensize = screensize<br class="title-page-name"/>    p.position = Vector2(rand_range(0, screensize.x),<br class="title-page-name"/>                         rand_range(0, screensize.y))</pre>
<p class="calibre2">The <kbd class="calibre12">Powerup</kbd> scene needs to be linked by adding a variable, then dragging the scene into the property in the Inspector, as you did earlier with the <kbd class="calibre12">Coin</kbd> scene:</p>
<pre class="calibre18">export (PackedScene) var Powerup</pre>
<p class="calibre2">The powerups should appear unpredictably, so the wait time of the <kbd class="calibre12">PowerupTimer</kbd> needs to be set whenever you begin a new level. Add this to the <kbd class="calibre12">_process()</kbd> function after the new coins are spawned with <kbd class="calibre12">spawn_coins()</kbd>:</p>
<pre class="calibre18">$PowerupTimer.wait_time = rand_range(5, 10)<br class="title-page-name"/>$PowerupTimer.start()</pre>
<p class="calibre2">Now that you will have powerups appearing, the last step is to give the player some bonus time when one is collected. Currently, the player script assumes anything it runs into is either a coin or an obstacle. Change the code in <kbd class="calibre12">Player.gd</kbd> to check for what kind of object has been hit:</p>
<pre class="calibre18">func _on_Player_area_entered( area ):<br class="title-page-name"/>    if area.is_in_group("coins"):<br class="title-page-name"/>        area.pickup()<br class="title-page-name"/>        emit_signal("pickup", "coin")<br class="title-page-name"/>    if area.is_in_group("powerups"):<br class="title-page-name"/>        area.pickup()<br class="title-page-name"/>        emit_signal("pickup", "powerup")<br class="title-page-name"/>    if area.is_in_group("obstacles"):<br class="title-page-name"/>        emit_signal("hurt")<br class="title-page-name"/>        die()</pre>
<p class="calibre2">Note that now you're emitting the pickup signal with an additional argument naming the type of object. The corresponding function in <kbd class="calibre12">Main.gd</kbd> can now be changed to accept that argument and use the <kbd class="calibre12">match</kbd> statement to decide what action to take:</p>
<pre class="calibre18">func _on_Player_pickup(type):<br class="title-page-name"/>    match type:<br class="title-page-name"/>        "coin":<br class="title-page-name"/>            score += 1<br class="title-page-name"/>            $CoinSound.play()<br class="title-page-name"/>            $HUD.update_score(score)<br class="title-page-name"/>        "powerup":<br class="title-page-name"/>            time_left += 5<br class="title-page-name"/>            $PowerupSound.play()<br class="title-page-name"/>            $HUD.update_timer(time_left)</pre>
<p class="calibre2">The <kbd class="calibre12">match</kbd> statement is a useful alternative to <kbd class="calibre12">if</kbd> statements, especially when you have a large number of possible values to test.</p>
<p class="calibre2">Try running the game and collecting the powerup. Make sure the sound plays and the timer increases by five seconds.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Coin animation</h1>
                
            
            
                
<p class="calibre2">When you created the <kbd class="calibre12">Coin</kbd> scene, you added an <kbd class="calibre12">AnimatedSprite</kbd>, but it isn't playing yet. The coin animation displays a <em class="calibre17">shimmer</em> effect traveling across the face of the coin. If all the coins display this at the same time, it will look too regular, so each coin needs a small random delay in its animation.</p>
<p class="calibre2">First, click on the <kbd class="calibre12">AnimatedSprite</kbd> and then on the <em class="calibre17">Frames</em> resource. Make sure Loop is set to Off and that Speed is set to <kbd class="calibre12">12</kbd>.</p>
<p class="calibre2">Add a <kbd class="calibre12">Timer</kbd> node to the <kbd class="calibre12">Coin</kbd> scene, and add this code to <kbd class="calibre12">_ready()</kbd>:</p>
<pre class="calibre18">$Timer.wait_time = rand_range(3, 8)<br class="title-page-name"/>$Timer.start()</pre>
<p class="calibre2">Now, connect the <kbd class="calibre12">timeout()</kbd> signal from the <kbd class="calibre12">Timer</kbd> and add this:</p>
<pre class="calibre18">func _on_Timer_timeout():<br class="title-page-name"/>    $AnimatedSprite.frame = 0<br class="title-page-name"/>    $AnimatedSprite.play()</pre>
<p class="calibre2">Try running the game and watching for the coins to animate. It's a nice visual effect for a very small amount of effort. You'll notice a lot of effects like this in professional games. Though very subtle, the visual appeal makes for a much more pleasing experience.</p>
<p class="calibre2">The preceding <kbd class="calibre12">Powerup</kbd> object has a similar animation that you can add in the same manner.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Obstacles</h1>
                
            
            
                
<p class="calibre2">Finally, the game can be made a bit more challenging by introducing an obstacle that the player must avoid. Touching the obstacle will end the game.</p>
<p class="calibre2">Create a new scene for the cactus and add the following nodes:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">Area2D</kbd> (named <kbd class="calibre12">Cactus</kbd>)</li>
<li class="calibre11"><kbd class="calibre12">Sprite</kbd></li>
<li class="calibre11"><kbd class="calibre12">CollisionShape2D</kbd></li>
</ul>
<p class="calibre2">Drag the cactus texture from the FileSystem dock to the Texture property of the <kbd class="calibre12">Sprite</kbd>. Add a <kbd class="calibre12">RectangleShape2D</kbd> to the collision shape and size it so that it covers the image. Remember when you added <kbd class="calibre12">if area.is_in_group("obstacles")</kbd> to the player script? Add the <kbd class="calibre12">Cactus</kbd> body to the <kbd class="calibre12">obstacles</kbd> group using the Node tab (next to Inspector).</p>
<p class="calibre2">Now, add a <kbd class="calibre12">Cactus</kbd> instance to the <kbd class="calibre12">Main</kbd> scene and move it to a location in the upper half of the screen (away from where the player spawns). Play the game and see what happens when you run into the cactus.</p>
<p class="calibre2">You may have spotted a problem: coins can spawn behind the cactus, making them impossible to pick up. When the coin is placed, it needs to move if it detects that it's overlapping the obstacle. Connect the coin's <kbd class="calibre12">area_entered()</kbd> signal and add the following:</p>
<pre class="calibre18">func _on_Coin_area_entered( area ):<br class="title-page-name"/>    if area.is_in_group("obstacles"):<br class="title-page-name"/>        position = Vector2(rand_range(0, screensize.x), rand_range(0, screensize.y))</pre>
<p class="calibre2">If you've added the preceding <kbd class="calibre12">Powerup</kbd> object, you'll need to do the same for its <kbd class="calibre12">area_entered</kbd> signal.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre2">In this chapter, you learned the basics of Godot Engine by creating a basic 2D game. You set up the project and created multiple scenes, worked with sprites and animations, captured user input, used <em class="calibre17">signals</em> to communicate with events, and created a UI using <strong class="calibre4">Control</strong> nodes. The things you learned here are important skills that you'll use in any Godot project.</p>
<p class="calibre2">Before moving on to the next chapter, look through the project. Do you understand what each node is doing? Are there any bits of code that you don't understand? If so, go back and review that section of the chapter. </p>
<p class="calibre2">Also, feel free to experiment with the game and change things around. One of the best ways to get a good feel for what different parts of the game are doing is to change them and see what happens.</p>
<p class="calibre2">In the next chapter, you'll explore more of Godot's features and learn how to use more node types by building a more complex game.</p>


            

            
        
    </body></html>