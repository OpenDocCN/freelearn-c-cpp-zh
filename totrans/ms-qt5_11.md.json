["```cpp\n#include <QtGlobal> \n\nclass SoundEvent \n{ \n\npublic: \n    SoundEvent(qint64 timestamp = 0, int soundId = 0); \n    ~SoundEvent(); \n\n    qint64 timestamp; \n    int soundId; \n}; \n\n```", "```cpp\n#include <QObject> \n#include <QVector> \n#include <QElapsedTimer> \n\n#include \"SoundEvent.h\" \n\nclass Track : public QObject \n{ \n    Q_OBJECT \npublic: \n    enum class State { \n        STOPPED, \n        PLAYING, \n        RECORDING, \n    }; \n\n    explicit Track(QObject *parent = 0); \n    ~Track(); \n\nprivate: \n    qint64 mDuration; \n       std::vector<std::unique_ptr<SoundEvent>> mSoundEvents; \n    QElapsedTimer mTimer; \n    State mState; \n    State mPreviousState; \n}; \n\n```", "```cpp\nclass Track : public QObject \n{ \n    Q_OBJECT \npublic: \n    ... \n    qint64 duration() const; \n    State state() const; \n    State previousState() const; \n    quint64 elapsedTime() const; \n    const std::vector<std::unique_ptr<SoundEvent>>& soundEvents() const; \n\nsignals: \n    void stateChanged(State state); \n\npublic slots: \n    void play(); \n    void record(); \n    void stop(); \n    void addSoundEvent(int soundEventId); \n\nprivate: \n    void clear(); \n    void setState(State state); \n\nprivate: \n    ... \n}; \n\n```", "```cpp\nvoid Track::play() \n{ \n    setState(State::PLAYING); \n    mTimer.start(); \n} \n\n```", "```cpp\nvoid Track::record() \n{ \n    clearSoundEvents(); \n    setState(State::RECORDING); \n    mTimer.start(); \n} \n\n```", "```cpp\nvoid Track::stop() \n{ \n    if (mState == State::RECORDING) { \n        mDuration = mTimer.elapsed(); \n    } \n    setState(State::STOPPED); \n} \n\n```", "```cpp\nvoid Track::setState(Track::State state) \n{ \n    mPreviousState = mState; \n    mState = state; \n    emit stateChanged(mState); \n} \n\n```", "```cpp\nvoid Track::addSoundEvent(int soundEventId) \n{ \n    if (mState != State::RECORDING) { \n        return; \n    } \n    mSoundEvents.push_back(make_unique<SoundEvent>( \n                               mTimer.elapsed(), \n                               soundEventId)); \n} \n\n```", "```cpp\nvoid Track::clear() \n{ \n    mSoundEvents.clear(); \n    mDuration = 0; \n} \n\n```", "```cpp\n#include <QObject> \n#include <QAtomicInteger> \n\nclass Track; \n\nclass PlaybackWorker : public QObject \n{ \n    Q_OBJECT \npublic: \n    explicit PlaybackWorker(const Track& track, QObject *parent = 0); \n\nsignals: \n    void playSound(int soundId); \n    void trackFinished(); \n\npublic slots: \n    void play(); \n    void stop(); \n\nprivate: \n    const Track& mTrack; \n    QAtomicInteger<bool> mIsPlaying; \n}; \n\n```", "```cpp\nvoid PlaybackWorker::play() \n{ \n    mIsPlaying.store(true); \n    QElapsedTimer timer; \n    size_t soundEventIndex = 0; \n    const auto& soundEvents = mTrack.soundEvents(); \n\n    timer.start(); \n    while(timer.elapsed() <= mTrack.duration() \n          && mIsPlaying.load()) { \n        if (soundEventIndex < soundEvents.size()) { \n            const auto& soundEvent =   \n                                  soundEvents.at(soundEventIndex); \n\n            if (timer.elapsed() >= soundEvent->timestamp) { \n                emit playSound(soundEvent->soundId); \n                soundEventIndex++; \n            } \n        } \n        QThread::msleep(1); \n    } \n\n    if (soundEventIndex >= soundEvents.size()) { \n        emit trackFinished(); \n    } \n} \n\n```", "```cpp\nQVariant variant(21); \n\nint answer = variant.toInt() * 2; \n\nqDebug() << \"what is the meaning of the universe,  \n             life and everything?\" \n         << answer; \n\n```", "```cpp\nunion Sound \n{ \n    int duration; \n    char code; \n}; \n\nSound s = 10; \nqDebug() << \"Sound duration:\" << s.duration; \n// output= Sound duration: 10 \n\ns.code = 'K'; \nqDebug() << \"Sound code:\" << s.code; \n// output= Sound code: K \n\n```", "```cpp\nunion Data \n{ \n    char c; \n    uchar uc; \n    short s; \n    signed char sc; \n    ushort us; \n    ... \n    qulonglong ull; \n    QObject *o; \n    void *ptr; \n    PrivateShared *shared; \n} data; \n\n```", "```cpp\nclass SoundEvent \n{ \n    ... \n}; \nQ_DECLARE_METATYPE(SoundEvent); \n\n```", "```cpp\nSoundEvent soundEvent(4365, 0); \nQVariant stored; \nstored.setValue(soundEvent); \n\nSoundEvent newEvent = stored.value<SoundEvent>(); \nqDebug() << newEvent.timestamp; \n\n```", "```cpp\n{ \n    \"timestamp\": 4365, \n    \"soundId\": 0 \n} \n\n```", "```cpp\n#include <QVariant> \n\nclass Serializable { \npublic: \n    virtual ~Serializable() {} \n    virtual QVariant toVariant() const = 0; \n    virtual void fromVariant(const QVariant& variant) = 0; \n}; \n\n```", "```cpp\n#include \"Serializable.h\" \n\nclass SoundEvent : public Serializable \n{ \n    SoundEvent(qint64 timestamp = 0, int soundId = 0); \n    ~SoundEvent(); \n\n    QVariant toVariant() const override; \n    void fromVariant(const QVariant& variant) override; \n\n    ... \n}; \n\n```", "```cpp\nQVariant SoundEvent::toVariant() const \n{ \n    QVariantMap map; \n    map.insert(\"timestamp\", timestamp); \n    map.insert(\"soundId\", soundId); \n    return map; \n} \n\nvoid SoundEvent::fromVariant(const QVariant& variant) \n{ \n    QVariantMap map = variant.toMap(); \n    timestamp = map.value(\"timestamp\").toLongLong(); \n    soundId = map.value(\"soundId\").toInt(); \n} \n\n```", "```cpp\nQVariant Track::toVariant() const \n{ \n    QVariantMap map; \n    map.insert(\"duration\", mDuration); \n\n    QVariantList list; \n    for (const auto& soundEvent : mSoundEvents) { \n        list.append(soundEvent->toVariant()); \n    } \n    map.insert(\"soundEvents\", list); \n\n    return map; \n} \n\n```", "```cpp\nvoid Track::fromVariant(const QVariant& variant) \n{ \n    QVariantMap map = variant.toMap(); \n    mDuration = map.value(\"duration\").toLongLong(); \n\n    QVariantList list = map.value(\"soundEvents\").toList(); \n    for(const QVariant& data : list) { \n        auto soundEvent = make_unique<SoundEvent>(); \n        soundEvent->fromVariant(data); \n        mSoundEvents.push_back(move(soundEvent)); \n    } \n} \n\n```", "```cpp\n#include <QString> \n\n#include \"Serializable.h\" \n\nclass Serializer \n{ \npublic: \n    virtual ~Serializer() {} \n\n    virtual void save(const Serializable& serializable, \n        const QString& filepath,  \n        const QString& rootName = \"\") = 0; \n    virtual void load(Serializable& serializable,  \n        const QString& filepath) = 0; \n}; \n\n```", "```cpp\n#include \"Serializer.h\" \n\nclass JsonSerializer : public Serializer \n{ \npublic: \n    JsonSerializer(); \n\n    void save(const Serializable& serializable,  \n        const QString& filepath, \n        const QString& rootName) override; \n    void load(Serializable& serializable, \n        const QString& filepath) override; \n}; \n\n```", "```cpp\nvoid JsonSerializer::save(const Serializable& serializable, \n    const QString& filepath, const QString& /*rootName*/) \n{ \n    QJsonDocument doc =     \n        QJsonDocument::fromVariant(serializable.toVariant()); \n    QFile file(filepath); \n    file.open(QFile::WriteOnly); \n    file.write(doc.toJson()); \n    file.close(); \n} \n\n```", "```cpp\nvoid JsonSerializer::load(Serializable& serializable, \n    const QString& filepath) \n{ \n    QFile file(filepath); \n    file.open(QFile::ReadOnly); \n    QJsonDocument doc = QJsonDocument::fromJson(file.readAll()); \n    file.close(); \n    serializable.fromVariant(doc.toVariant()); \n} \n\n```", "```cpp\n{ \n    \"duration\": 6205, \n    \"soundEvents\": [ \n        { \n            \"soundId\": 0, \n            \"timestamp\": 2689 \n        }, \n        { \n            \"soundId\": 2, \n            \"timestamp\": 2690 \n        }, \n        { \n            \"soundId\": 2, \n            \"timestamp\": 3067 \n        } \n    ] \n} \n\n```", "```cpp\n<[name]> type=\"[type]\">[data]</[name]> \n\n```", "```cpp\n<soundId type=\"int\">2</soundId> \n\n```", "```cpp\n#include <QXmlStreamWriter> \n#include <QXmlStreamReader> \n\n#include \"Serializer.h\" \n\nclass XmlSerializer : public Serializer \n{ \npublic: \n    XmlSerializer(); \n\n    void save(const Serializable& serializable,  \n        const QString& filepath,  \n        const QString& rootName) override; \n}; \n\n```", "```cpp\nvoid XmlSerializer::save(const Serializable& serializable, const QString& filepath, const QString& rootName) \n{ \n    QFile file(filepath); \n    file.open(QFile::WriteOnly); \n    QXmlStreamWriter stream(&file); \n    stream.setAutoFormatting(true); \n    stream.writeStartDocument(); \n    writeVariantToStream(rootName, serializable.toVariant(), \n        stream); \n    stream.writeEndDocument(); \n    file.close(); \n} \n\n```", "```cpp\n//XmlSerializer.h \nprivate: \n    void writeVariantToStream(const QString& nodeName, \n        const QVariant& variant, QXmlStreamWriter& stream); \n\n//XmlSerializer.cpp \nvoid XmlSerializer::writeVariantToStream(const QString& nodeName, \n    const QVariant& variant, QXmlStreamWriter& stream) \n{ \n    stream.writeStartElement(nodeName); \n    stream.writeAttribute(\"type\", variant.typeName()); \n\n    switch (variant.type()) { \n        case QMetaType::QVariantList: \n            writeVariantListToStream(variant, stream); \n            break; \n        case QMetaType::QVariantMap: \n            writeVariantMapToStream(variant, stream); \n            break; \n        default: \n            writeVariantValueToStream(variant, stream); \n            break; \n    } \n\n    stream.writeEndElement(); \n} \n\n```", "```cpp\n        //XmlSerializer.h \n        void writeVariantValueToStream(const QVariant& variant, \n            QXmlStreamWriter& stream); \n\n        //XmlSerializer.cpp \n        void XmlSerializer::writeVariantValueToStream( \n            const QVariant& variant, QXmlStreamWriter& stream) \n        { \n            stream.writeCharacters(variant.toString()); \n        } \n\n        ```", "```cpp\n//XmlSerializer.h \nprivate: \n    void writeVariantListToStream(const QVariant& variant, \n        QXmlStreamWriter& stream); \n\n//XmlSerializer.cpp \nvoid XmlSerializer::writeVariantListToStream( \n    const QVariant& variant, QXmlStreamWriter& stream) \n{ \n    QVariantList list = variant.toList(); \n\n    for(const QVariant& element : list) { \n        writeVariantToStream(\"item\", element, stream); \n    } \n} \n\n```", "```cpp\n//XmlSerializer.h \nprivate: \n    void writeVariantMapToStream(const QVariant& variant, \n        QXmlStreamWriter& stream); \n\n//XmlSerializer.cpp \nvoid XmlSerializer::writeVariantMapToStream( \n    const QVariant& variant, QXmlStreamWriter& stream) \n{ \n    QVariantMap map = variant.toMap(); \n    QMapIterator<QString, QVariant> i(map); \n\n    while (i.hasNext()) { \n        i.next(); \n        writeVariantToStream(i.key(), i.value(), stream); \n    } \n} \n\n```", "```cpp\n//XmlSerializer.h \npublic: \n    void load(Serializable& serializable,  \n        const QString& filepath) override; \n\n//XmlSerializer.cpp \nvoid XmlSerializer::load(Serializable& serializable, \n    const QString& filepath) \n{ \n    QFile file(filepath); \n    file.open(QFile::ReadOnly); \n    QXmlStreamReader stream(&file); \n    stream.readNextStartElement(); \n    serializable.fromVariant(readVariantFromStream(stream)); \n} \n\n```", "```cpp\n//XmlSerializer.h \nprivate: \n    QVariant readVariantFromStream(QXmlStreamReader& stream); \n\n//XmlSerializer.cpp \nQVariant XmlSerializer::readVariantFromStream(QXmlStreamReader& stream) \n{ \n    QXmlStreamAttributes attributes = stream.attributes(); \n    QString typeString = attributes.value(\"type\").toString(); \n\n    QVariant variant; \n    switch (QVariant::nameToType( \n            typeString.toStdString().c_str())) { \n        case QMetaType::QVariantList: \n            variant = readVariantListFromStream(stream); \n            break; \n        case QMetaType::QVariantMap: \n            variant = readVariantMapFromStream(stream); \n            break; \n        default: \n            variant = readVariantValueFromStream(stream); \n            break; \n    } \n\n    return variant; \n} \n\n```", "```cpp\n//XmlSerializer.h \nprivate: \n    QVariant readVariantValueFromStream(QXmlStreamReader& stream); \n\n//XmlSerializer.cpp \nQVariant XmlSerializer::readVariantValueFromStream( \n    QXmlStreamReader& stream) \n{ \n    QXmlStreamAttributes attributes = stream.attributes(); \n    QString typeString = attributes.value(\"type\").toString(); \n    QString dataString = stream.readElementText(); \n\n    QVariant variant(dataString); \n    variant.convert(QVariant::nameToType( \n        typeString.toStdString().c_str())); \n    return variant; \n} \n\n```", "```cpp\n//XmlSerializer.h \nprivate: \n    QVariant readVariantListFromStream(QXmlStreamReader& stream); \n\n//XmlSerializer.cpp \nQVariant XmlSerializer::readVariantListFromStream(QXmlStreamReader& stream) \n{ \n    QVariantList list; \n    while(stream.readNextStartElement()) { \n        list.append(readVariantFromStream(stream)); \n    } \n    return list; \n} \n\n```", "```cpp\n//XmlSerializer.h \nprivate: \n    QVariant readVariantMapFromStream(QXmlStreamReader& stream); \n\n//XmlSerializer.cpp \nQVariant XmlSerializer::readVariantMapFromStream( \n    QXmlStreamReader& stream) \n{ \n    QVariantMap map; \n    while(stream.readNextStartElement()) { \n        map.insert(stream.name().toString(), \n                   readVariantFromStream(stream)); \n    } \n    return map; \n} \n\n```", "```cpp\n<?xml version=\"1.0\" encoding=\"UTF-8\"?> \n<track type=\"QVariantMap\"> \n    <duration type=\"qlonglong\">6205</duration> \n    <soundEvents type=\"QVariantList\"> \n        <item type=\"QVariantMap\"> \n            <soundId type=\"int\">0</soundId> \n            <timestamp type=\"qlonglong\">2689</timestamp> \n        </item> \n        <item type=\"QVariantMap\"> \n            <soundId type=\"int\">2</soundId> \n            <timestamp type=\"qlonglong\">2690</timestamp> \n        </item> \n        <item type=\"QVariantMap\"> \n            <soundId type=\"int\">2</soundId> \n            <timestamp type=\"qlonglong\">3067</timestamp> \n        </item> \n    </soundEvents> \n</track> \n\n```", "```cpp\nvoid BinarySerializer::save(const Serializable& serializable, \n    const QString& filepath, const QString& /*rootName*/) \n{ \n    QFile file(filepath); \n    file.open(QFile::WriteOnly); \n    QDataStream dataStream(&file); \n    dataStream << serializable.toVariant(); \n    file.close(); \n} \n\n```", "```cpp\nvoid BinarySerializer::load(Serializable& serializable, const QString& filepath) \n{ \n    QFile file(filepath); \n    file.open(QFile::ReadOnly); \n    QDataStream dataStream(&file); \n    QVariant variant; \n    dataStream >> variant; \n    serializable.fromVariant(variant); \n    file.close(); \n} \n\n```", "```cpp\nQT       += core gui multimedia \n\n```", "```cpp\nQUrl urlKick(\"qrc:/sounds/kick.wav\"); \nQUrl urlBetterKick = QUrl::fromLocalFile(\"/home/better-kick.wav\"); \n\nQSoundEffect soundEffect; \nQSoundEffect.setSource(urlBetterKick); \n\n```", "```cpp\nsoundEffect.setVolume(1.0f); \nsoundEffect.play(); \n\n```", "```cpp\n//SoundEffectWidget.h \nclass SoundEffectWidget : public QWidget \n{ \n... \npublic slots: \n    void triggerPlayButton(); \n    ... \n\nprivate: \n    QPushButton* mPlayButton; \n    ... \n}; \n\n//SoundEffectWidget.cpp \nvoid SoundEffectWidget::triggerPlayButton() \n{ \n   mPlayButton->animateClick(); \n} \n\n```", "```cpp\n//SoundEffectWidget.h \nclass SoundEffectWidget : public QWidget \n{ \n... \npublic: \n    Qt::Key triggerKey() const; \n    void setTriggerKey(const Qt::Key& triggerKey); \n}; \n\n//SoundEffectWidget.cpp \nQt::Key SoundEffectWidget::triggerKey() const \n{ \n    return mTriggerKey; \n} \n\nvoid SoundEffectWidget::setTriggerKey(const Qt::Key& triggerKey) \n{ \n    mTriggerKey = triggerKey; \n} \n\n```", "```cpp\nui->kickWidget->setTriggerKey(Qt::Key_H); \nui->snareWidget->setTriggerKey(Qt::Key_J); \nui->hihatWidget->setTriggerKey(Qt::Key_K); \nui->crashWidget->setTriggerKey(Qt::Key_L); \n\n```", "```cpp\ninstallEventFilter(this); \n\n```", "```cpp\nclass MainWindow : public QMainWindow \n{ \n    Q_OBJECT \npublic: \n    ... \n    bool eventFilter(QObject* watched, QEvent* event) override; \n\nprivate: \n    QVector<SoundEffectWidget*> mSoundEffectWidgets; \n    ... \n}; \n\n```", "```cpp\nbool MainWindow::eventFilter(QObject* watched, QEvent* event) \n{ \n    if (event->type() == QEvent::KeyPress) { \n        QKeyEvent* keyEvent = static_cast<QKeyEvent*>(event); \n        for(SoundEffectWidget* widget : mSoundEffectWidgets) { \n            if (keyEvent->key() == widget->triggerKey()) { \n                widget->triggerPlayButton(); \n                return true; \n            } \n        } \n    } \n    return QObject::eventFilter(watched, event); \n} \n\n```", "```cpp\nclass MainWindow : public QMainWindow \n{ \n... \nprivate slots: \n    void playSoundEffect(int soundId); \n    void clearPlayback(); \n    void stopPlayback(); \n    ... \n\nprivate: \n    void startPlayback(); \n    ... \n\nprivate: \n    PlaybackWorker* mPlaybackWorker; \n    QThread* mPlaybackThread; \n    ... \n}; \n\n```", "```cpp\nvoid MainWindow::startPlayback() \n{ \n    clearPlayback(); \n\n    mPlaybackThread = new QThread(); \n\n    mPlaybackWorker = new PlaybackWorker(mTrack); \n    mPlaybackWorker->moveToThread(mPlaybackThread); \n\n    connect(mPlaybackThread, &QThread::started, \n            mPlaybackWorker, &PlaybackWorker::play); \n    connect(mPlaybackThread, &QThread::finished, \n            mPlaybackWorker, &QObject::deleteLater); \n\n    connect(mPlaybackWorker, &PlaybackWorker::playSound, \n            this, &MainWindow::playSoundEffect); \n\n    connect(mPlaybackWorker, &PlaybackWorker::trackFinished, \n            &mTrack, &Track::stop); \n\n    mPlaybackThread->start(QThread::HighPriority); \n} \n\n```", "```cpp\nvoid MainWindow::stopPlayback() \n{ \n    mPlaybackWorker->stop(); \n    clearPlayback(); \n} \n\n```", "```cpp\nvoid MainWindow::clearPlayback() \n{ \n    if (mPlaybackThread) { \n        mPlaybackThread->quit(); \n        mPlaybackThread->wait(1000); \n        mPlaybackThread = nullptr; \n        mPlaybackWorker = nullptr; \n    } \n} \n\n```", "```cpp\nvoid MainWindow::playSoundEffect(int soundId) \n{ \n   mSoundEffectWidgets[soundId]->triggerPlayButton(); \n} \n\n```", "```cpp\nvoid SoundEffectWidget::play() \n{ \n    mSoundEffect.play(); \n    emit soundPlayed(mId); \n} \n\n```", "```cpp\nsetAcceptDrops(true); \n\n```", "```cpp\n//SoundEffectWidget.h \nclass SoundEffectWidget : public QWidget \n{ \n... \nprotected: \n    void dragEnterEvent(QDragEnterEvent* event) override; \n... \n}; \n\n//SoundEffectWidget.cpp \nvoid SoundEffectWidget::dragEnterEvent(QDragEnterEvent* event) \n{ \n    if (event->mimeData()->hasFormat(\"text/uri-list\")) { \n        event->acceptProposedAction(); \n    } \n} \n\n```", "```cpp\n//SoundEffectWidget.h \nclass SoundEffectWidget : public QWidget \n{ \n... \nprotected: \n    void dropEvent(QDropEvent* event) override; \n... \n}; \n\n//SoundEffectWidget.cpp \nvoid SoundEffectWidget::dropEvent(QDropEvent* event) \n{ \n    const QMimeData* mimeData = event->mimeData(); \n    if (!mimeData->hasUrls()) { \n        return; \n    } \n    const QUrl url = mimeData->urls().first(); \n    QMimeType mime = QMimeDatabase().mimeTypeForUrl(url); \n    if (mime.inherits(\"audio/wav\")) { \n        loadSound(url); \n    } \n} \n\n```"]