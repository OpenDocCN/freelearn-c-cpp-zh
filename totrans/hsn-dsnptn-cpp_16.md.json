["```cpp\n// Example 01\nclass Unit {\n  public:\n  Unit(double strength, double armor) :\n    strength_(strength), armor_(armor) {}\n  virtual bool hit(Unit& target) {\n    return attack() > target.defense();\n  }\n  virtual double attack() = 0;\n  virtual double defense() = 0;\n  protected:\n  double strength_;\n  double armor_;\n};\n```", "```cpp\n// Example 01\nclass Knight : public Unit {\n  public:\n  using Unit::Unit;\n  double attack() { return strength_ + sword_bonus_; }\n  double defense() { return armor_ + plate_bonus_; }\n  protected:\n  static constexpr double sword_bonus_ = 2;\n  static constexpr double plate_bonus_ = 3;\n};\n```", "```cpp\n// Example 01\nclass Ogre : public Unit {\n  public:\n  using Unit::Unit;\n  double attack() { return strength_ + club_penalty_; }\n  double defense() { return armor_ + leather_penalty_; }\n  protected:\n  static constexpr double club_penalty_ = -1;\n  static constexpr double leather_penalty_ = -1;\n};\n```", "```cpp\nKnight k(10, 5);\nOgre o(12, 2);\nk.hit(o); // Yes!\n```", "```cpp\n// Example 01\nclass VeteranUnit : public Unit {\n  public:\n  VeteranUnit(Unit& unit,\n              double strength_bonus,\n              double armor_bonus) :\n    Unit(strength_bonus, armor_bonus), unit_(unit) {}\n  double attack() { return unit_.attack() + strength_; }\n  double defense() { return unit_.defense() + armor_; }\n  private:\n  Unit& unit_;\n};\n```", "```cpp\n// Example 01\nKnight k(10, 5);\nOgre o(12, 2);\nVeteranUnit vk(k, 7, 2);\nVeteranUnit vo(o, 1, 9);\nvk.hit(vo); // Another hit!\n```", "```cpp\nVeteranUnit vvo(vo, 1, 9);\nvk.hit(vvo); // Miss!\n```", "```cpp\n// Example 02\nclass Knight : public Unit {\n  public:\n  Knight(double strength, double armor) :\n  Unit(strength, armor), charge_bonus_(0) {}\n  double attack() {\n    double res = strength_ + sword_bonus_ + charge_bonus_;\n    charge_bonus_ = 0;\n    return res;\n  }\n  double defense() { return armor_ + plate_bonus_; }\n  void charge() { charge_bonus_ = 1; }\n  protected:\n  double charge_bonus_;\n  static constexpr double sword_bonus_ = 2;\n  static constexpr double plate_bonus_ = 3;\n};\n```", "```cpp\nKnight k(10, 5);\nOgre o(12, 2);\nk.charge();\nk.hit(o);\n```", "```cpp\nVeteranUnit vk(k, 7, 2);\nvk.charge(); // Does not compile!\n```", "```cpp\n// Example 03\ntemplate <typename U>\nclass VeteranUnit : public U {\n  public:\n  VeteranUnit(U&& unit,\n              double strength_bonus,\n              double armor_bonus) :\n    U(unit), strength_bonus_(strength_bonus),\n    armor_bonus_(armor_bonus) {}\n  double attack() { return U::attack() + strength_bonus_; }\n  double defense() { return U::defense() + armor_bonus_; }\n  private:\n  double strength_bonus_;\n  double armor_bonus_;\n};\n```", "```cpp\n// Example 03\nKnight k(10, 5);\nOgre o(12, 2);\nk.hit(o); // Hit!\nVeteranUnit<Knight> vk(std::move(k), 7, 2);\nVeteranUnit<Ogre> vo(std::move(o), 1, 9);\nvk.hit(vo); // Hit!\nVeteranUnit<VeteranUnit<Ogre>> vvo(std::move(vo), 1, 9);\nvk.hit(vvo); // Miss...\nvk.charge(); // Compiles now, vk is a Knight too\nvk.hit(vvo); // Hit with the charge bonus!\n```", "```cpp\nVeteranUnit<Knight> vk(k, 7, 2); // Does not compile\n```", "```cpp\nusing Unit_ptr = std::unique_ptr<Unit>;\nusing Knight_ptr = std::unique_ptr<Knight>;\n```", "```cpp\nKnight_ptr k(new Knight(10, 5));\nUnit_ptr u(std::move(k)); // Now k is null\n```", "```cpp\n// Example 04\ntemplate <typename To, typename From>\nstd::unique_ptr<To> move_cast(std::unique_ptr<From>& p) {\n return std::unique_ptr<To>(static_cast<To*>(p.release()));\n}\n```", "```cpp\n// Example 04\ntemplate <typename To, typename From>\nstd::unique_ptr<To> move_cast(std::unique_ptr<From>& p) {\n#ifndef NDEBUG\n auto p1 =\n   std::unique_ptr<To>(dynamic_cast<To*>(p.release()));\n assert(p1);\n return p1;\n#else\n return std::unique_ptr<To>(static_cast<To*>(p.release()));\n#endif\n}\n```", "```cpp\n// Example 04\ntemplate <typename U> class VeteranUnit : public U {\n  public:\n  template <typename P>\n  VeteranUnit(P&& p,\n              double strength_bonus,\n              double armor_bonus) :\n    U(std::move(*move_cast<U>(p))),\n    strength_bonus_(strength_bonus),\n    armor_bonus_(armor_bonus) {}\n  double attack() { return U::attack() + strength_bonus_; }\n  double defense() { return U::defense() + armor_bonus_; }\n  private:\n  double strength_bonus_;\n  double armor_bonus_;\n};\n```", "```cpp\n// Example 04\nKnight_ptr k(new Knight(10, 5));\n  // Knight_ptr so we can call charge()\nUnit_ptr o(new Ogre(12, 2));\n  // Could be Orge_ptr if we needed one\nKnight_ptr vk(new VeteranUnit<Knight>(k, 7, 2));\nUnit_ptr vo(new VeteranUnit<Ogre>(o, 1, 9));\nUnit_ptr vvo(new VeteranUnit<VeteranUnit<Ogre>>(vo, 1, 9));\nvk->hit(*vvo); // Miss\nvk->charge(); // Works because vk is Knight_ptr\nvk->hit(*vvo); // Hit\n```", "```cpp\n// Example 05\ntemplate <typename U> class DebugDecorator : public U {\n  public:\n  using U::U;\n  template <typename P> DebugDecorator(P&& p) :\n    U(std::move(*move_cast<U>(p))) {}\n  double attack() {\n    double res = U::attack();\n    cout << \"Attack: \" << res << endl;\n    return res;\n  }\n  double defense() {\n    double res = U::defense();\n    cout << \"Defense: \" << res << endl;\n    return res;\n  }\n};\n```", "```cpp\n// Example 06\ntemplate <typename U> class VeteranUnit : public U {\n  ...\n};\ntemplate <typename U> class DebugDecorator : public U {\n  using U::U;\n  public:\n  template <typename P>\n  DebugDecorator(std::unique_ptr<P>& p) :\n    U(std::move(*move_cast<U>(p))) {}\n  double attack() override {\n    double res = U::attack();\n    cout << \"Attack: \" << res << endl;\n    return res;\n  }\n  double defense() override {\n    double res = U::defense();\n    cout << \"Defense: \" << res << endl;\n    return res;\n  }\n  using ptr = std::unique_ptr<DebugDecorator>;\n  template <typename... Args>\n  static ptr construct(Args&&... args) { return\n    ptr{new DebugDecorator(std::forward<Args>(args)...)};\n  }\n};\n```", "```cpp\ntemplate <typename U> class DebugDecorator : public U {\n  double attack() {\n    cout << \"Attack: \" << U::attack() << endl;\n    return U::attack();\n  }\n};\n```", "```cpp\n// Example 07\ntemplate <typename Callable> class DebugDecorator {\n  public:\n  template <typename F>\n  DebugDecorator(F&& f, const char* s) :\n    c_(std::forward<F>(f)), s_(s) {}\n  template <typename ... Args>\n  auto operator()(Args&& ... args) const {\n    cout << \"Invoking \" << s_ << endl;\n    auto res = c_(std::forward<Args>(args) ...);\n    cout << \"Result: \" << res << endl;\n    return res;\n  }\n  private:\n  Callable c_;\n  const std::string s_;\n};\n```", "```cpp\n// Example 07\ntemplate <typename Callable>\n  auto decorate_debug(Callable&& c, const char* s) {\n  return DebugDecorator<Callable>(\n    std::forward<Callable>(c), s);\n}\n```", "```cpp\n// Example 07\nint g(int i, int j) { return i - j; } // Some function\nauto g1 = decorate_debug(g, \"g()\"); // Decorated function\ng1(5, 2); // Prints \"Invoking g()\" and \"Result: 3\"\n```", "```cpp\n// Example 07\nstruct S {\n  double operator()() const {\n    return double(rand() + 1)/double(rand() + 1);\n  }\n};\nS s; // Callable\nauto s1 =\n  decorate_debug(s, \"rand/rand\"); // Decorated callable\ns1(); s1(); // Prints the result, twice\n```", "```cpp\n// Example 07\nauto f2 = decorate_debug(\n  [](int i, int j) { return i + j; }, \"i+j\");\nf2(5, 3); // Prints \"Invoking i+j\" and \"Result: 8\"\n```", "```cpp\ntemplate <typename Callable> class DebugDecorator {\n  public:\n  DebugDecorator(const Callable& c, const char* s) :\n    c_(c), s_(s) {}\n  ...\n  private:\n  const Callable& c_;\n  const std::string s_;\n};\n```", "```cpp\nauto f2 = decorate_debug(\n  [](int i, int j) { return i + j; }, \"i+j\");\n```", "```cpp\nauto incr = decorate_debug([](int& x) { ++x; }, \"++x\");\nint i;\nincr(i); // Does not compile\n```", "```cpp\n// Example 08\ntemplate <typename Callable> class DebugDecorator {\n  public:\n  ...\n  template <typename... Args>\n  auto operator()(Args&&... args) const {\n    cout << \"Invoking \" << s_ << endl;\n    using r_t = decltype(c_(std::forward<Args>(args)...));\n    if constexpr (!std::is_same_v<res_t, void>) {\n      auto res = c_(std::forward<Args>(args)...);\n      cout << \"Result: \" << res << endl;\n      return res;\n    } else {\n      c_(std::forward<Args>(args)...);\n    }\n  }\n    private:\n    Callable c_;\n    const std::string s_;\n};\n```", "```cpp\n// Example 08a\ntemplate <typename Callable> class DebugDecorator {\n  public:\n  ...\n  template <typename... Args>\n  auto operator()(Args&&... args) const {\n    cout << \"Invoking \" << s_ << endl;\n    using r_t = decltype(c_(std::forward<Args>(args)...));\n    return this->call_impl(std::is_same<res_t, void>{},\n                           std::forward<Args>(args)...);\n    }\n    private:\n    Callable c_;\n    const std::string s_;\n    template <typename... Args>\n    auto call_impl(std::false_type, Args&&... args) const {\n      auto res = c_(std::forward<Args>(args)...);\n      cout << \"Result: \" << res << endl;\n      return res;\n    }\n    template <typename... Args>\n    void call_impl(std::true_type, Args&&... args) const {\n      c_(std::forward<Args>(args)...);\n  }\n};\n```", "```cpp\ntemplate <typename U> class VeteranUnit : public U { ... };\ntemplate <typename U> class DebugDecorator : public U { ...\n};\nUnit_ptr o(new DebugDecorator<Ogre>(12, 2));\nUnit_ptr vo(new DebugDecorator<VeteranUnit<Ogre>>(o, 1, 9));\n```", "```cpp\n// Example 10\ntemplate <typename Callable> class LockDecorator {\n  public:\n  template <typename F>\n  LockDecorator(F&& f, std::mutex& m) :\n    c_(std::forward<F>(f)), m_(m) {}\n  template <typename ... Args>\n  auto operator()(Args&& ... args) const {\n    std::lock_guard<std::mutex> l(m_);\n    return c_(std::forward<Args>(args) ...);\n  }\n  private:\n  Callable c_;\n  std::mutex& m_;\n};\ntemplate <typename Callable>\nauto decorate_lock(Callable&& c, std::mutex& m) {\n  return\n    LockDecorator<Callable>(std::forward<Callable>(c), m);\n}\n```", "```cpp\nstd::mutex m;\nauto safe_f = decorate_lock([](int x) {\n  return unsafe_f(x); }, m\n);\n```", "```cpp\nauto safe_f = decorate_debug(\n  decorate_lock(\n    [](int x) { return unsafe_f(x); },\n    m\n  ),\n  \"f(x)\");\n```", "```cpp\n// Example 11\ntemplate <typename T> class locking_queue {\n  using mutex = std::mutex;\n  using lock_guard = std::lock_guard<mutex>;\n  using value_type = typename std::queue<T>::value_type;\n  void push(const value_type& value) {\n    lock_guard l(m_);\n    q_.push(value);\n  }\n  void push(value_type&& value) {\n    lock_guard l(m_);\n    q_.push(value);\n  }\n  private:\n  std::queue<T> q_;\n  mutex m_;\n};\n```", "```cpp\nlocking_queue<int> q;\nq.push(5);\n... sometime later in the program ...\nif (!q.empty()) {\n  int i = q.front();\n  q.pop();\n}\n```", "```cpp\n// Example 11\ntemplate <typename T> class locking_queue {\n  ... the push() is unchanged ...\n  bool pop(value_type& value) {\n    lock_guard l(m_);\n    if (q_.empty()) return false;\n    value = std::move(q_.front());\n    q_.pop();\n    return true;\n  }\n  private:\n  std::queue<T> q_;\n  mutex m_;\n};\n```", "```cpp\n// Example 12\ntemplate <typename T> class locking_queue {\n  ... the push() is unchanged ...\n  std::optional<value_type> pop() {\n    lock_guard l(m_);\n    if (q_.empty()) return std::nullopt;\n    value_type value = std::move(q_.front());\n    q_.pop();\n    return { value };\n  }\n};\n```", "```cpp\n// Example 13\nstruct much_less {\n  template <typename T>\n  bool operator()(T x, T y) {\n    return x < y && std::abs(x - y) > tolerance);\n  }\n  static constexpr double tolerance = 0.2;\n};\n```", "```cpp\nstd::vector<double> v;\nstd::sort(v.begin(), v.end(), much_less());\n```", "```cpp\n// Example 13\ntemplate<typename RandomIt>\n  void sort_much_less(RandomIt first, RandomIt last) {\n  std::sort(first, last, much_less());\n}\n```", "```cpp\n// Example 13\nstd::vector<double> v;\nsort_much_less(v.begin(), v.end());\n```", "```cpp\n// Example 14\ntemplate<typename Container> void sort_much_less(Container&\n   c) {\nstd::sort(c.begin(), c.end(), much_less());\n}\n```", "```cpp\n// Example 14\nstd::vector<double> v;\nsort_much_less(v);\n```", "```cpp\n// Example 15\nauto sort_much_less = [](auto first, auto last) {\n  return std::sort(first, last, much_less());\n};\n```", "```cpp\n// Example 15a\nauto sort_much_less = [](auto first, auto last) {\n  return std::sort(first, last,\n    [](auto x, auto y) {\n      static constexpr double tolerance = 0.2;\n      return x < y && std::abs(x - y) > tolerance;\n    }); };\n```", "```cpp\n// Example 16\nauto sort_much_less = [](auto& container) {\n  return std::sort(container.begin(), container.end(),\n                   much_less());\n};\n```", "```cpp\n// Example 17\nusing namespace std::placeholders; // For _1, _2 etc\nint f3(int i, int j, int k) { return i + j + k; }\nauto f2 = std::bind(f3, _1, _2, 42);\nauto f1 = std::bind(f3, 5, _1, 7);\nf2(2, 6);     // Returns 50\nf1(3);     // Returns 15\n```", "```cpp\n// Example 17\n...\nauto f1 = std::bind(f3, 5, _1, 7);\nauto f0 = std::bind(f1, 3);\nf1(3);    // Returns 15\nf0();         // Also returns 15\n```", "```cpp\n// Example 17\nint (*p3)(int, int, int) = f3;    // OK\nint (*p1)(int) = f1;            // Does not compile\n```", "```cpp\nauto l1 = [](int i) { return f3(5, i, 7); }\nint (*p1)(int) = l1;            // OK\n```", "```cpp\nauto sort_much_less = std::bind(std::sort, _1, _2, much_less()); // No!\n```", "```cpp\ntemplate<typename RandomIt>\nvoid sort_much_less(RandomIt first, RandomIt last) {\n  auto f = std::bind(std::sort<RandomIt, much_less>,\n                     _1, _2, much_less());\n  f(first, last, much_less());\n}\n```", "```cpp\nconst std::time_t now = std::time(nullptr);\nconst tm local_tm = *localtime(&now);\ncout << local_tm.tm_mon + 1 << \"/\" <<\n        local_tm.tm_mday << \"/\" <<\n        local_tm.tm_year + 1900;\n```", "```cpp\n// Example 18\nclass USA_Date {\n  public:\n  explicit USA_Date(std::time_t t) : t_(t) {}\n  friend std::ostream& operator<<(std::ostream& out,\n                                  const USA_Date& d) {\n    const tm local_tm = *localtime(&d.t_);\n    out << local_tm.tm_mon + 1 << \"/\" <<\n           local_tm.tm_mday << \"/\" <<\n           local_tm.tm_year + 1900;\n    return out;\n  }\n  private:\n  const std::time_t t_;\n};\n```", "```cpp\n// Example 19\ntemplate <size_t F> class Date {\n  public:\n  explicit Date(std::time_t t) : t_(t) {}\n  friend std::ostream& operator<<(std::ostream& out,\n                                  const Date& d) {\n    const tm local_tm = *localtime(&d.t_);\n    const int t[3] = { local_tm.tm_mday,\n                       local_tm.tm_mon + 1,\n                       local_tm.tm_year + 1900 };\n    constexpr size_t i1 = F/100;\n    constexpr size_t i2 = (F - i1*100)/10;\n    constexpr size_t i3 = F - i1*100 - i2*10;\n    static_assert(i1 >= 0 && i1 <= 2 && ..., \"Bad format\");\n    out << t[i1] << \"/\" << t[i2] << \"/\" << t[i3];\n    return out;\n  }\n  private:\n  const std::time_t t_;\n};\nusing USA_Date = Date<102>;\nusing European_Date = Date<12>;\nusing ISO_Date = Date<210>;\n```", "```cpp\n// Chapter 15, Example 08\ntemplate <typename T,\n          template <typename> class DeletionPolicy =\n                                    DeleteByOperator>\nclass SmartPtr {\n  public:\n  explicit SmartPtr(T* p = nullptr,\n    const DeletionPolicy<T>& del_policy =\n                             DeletionPolicy<T>())\n  : p_(p), deletion_policy_(deletion_policy)\n  {}\n  ~SmartPtr() {\n    deletion_policy_(p_);\n  }\n  ... pointer interface ...\n  private:\n  T* p_;\n  DeletionPolicy<T> deletion_policy_;\n};\n```", "```cpp\ntemplate <typename T> struct DeleteByOperator {\n  void operator()(T* p) const {\n    delete p;\n  }\n};\n```", "```cpp\ntemplate <typename T> struct DeleteHeap {\n  explicit DeleteHeap(MyHeap& heap) : heap_(heap) {}\n  void operator()(T* p) const {\n    p->~T();\n    heap_.deallocate(p);\n  }\n  private:\n  MyHeap& heap_;\n};\n```", "```cpp\nMyHeap H;\nSmartPtr<int, DeleteHeap<int>> p(new int, H);\n```", "```cpp\n// Example 20\ntemplate <typename T, typename Heap> struct DeleteHeap {\n  explicit DeleteHeap(Heap& heap) : heap_(heap) {}\n  void operator()(T* p) const {\n    p->~T();\n    heap_.deallocate(p);\n  }\n  private:\n  Heap& heap_;\n};\n```", "```cpp\nSmartPtr<int, DeletelHeap> p; // Does not compile\n```", "```cpp\n// Example 20\ntemplate <typename T>\nstruct DeleteMyHeap : public DeleteHeap<T, MyHeap> {\n  using DeleteHeap<T, MyHeap>::DeleteHeap;\n};\n```", "```cpp\n// Example 21\ntemplate <typename T>\nusing DeleteMyHeap = DeleteHeap<T, MyHeap>;\n```", "```cpp\n// Example 22\ntemplate <template <typename> class Container, typename T>\nstd::ostream& operator<<(std::ostream& out,\n                         const Container<T>& c) {\n  bool first = true;\n  for (auto x : c) {\n  if (!first) out << \", \";\n    first = false;\n    out << x;\n  }\n  return out;\n}\n```", "```cpp\n// Example 22\ntemplate <typename T> class Buffer {\n  public:\n  explicit Buffer(size_t N) : N_(N), buffer_(new T[N_]) {}\n  ~Buffer() { delete [] buffer_; }\n  T* begin() const { return buffer_; }\n  T* end() const { return buffer_ + N_; }\n  ...\n  private:\n  const size_t N_;\n  T* const buffer_;\n};\nBuffer<int> buffer(10);\n... fill the buffer ...\ncout << buffer; // Prints all elements of the buffer\n```", "```cpp\nstd::vector<int> v;\n... add some values to v ...\ncout << v;\n```", "```cpp\ntemplate <typename T> using vector1 = std::vector<T>;\nvector1<int> v;\n...\ncout << v; // Does not compile either\n```", "```cpp\n// Example 22\ntemplate <typename T>\nstruct vector1 : public std::vector<T> {\n  using std::vector<T>::vector;\n};\nvector1<int> v;\n...\ncout << v;\n```", "```cpp\n// Example 23\ntemplate <typename T,\n  template <typename, typename...> class Container,\n  typename... Args>\nstd::ostream& operator<<(std::ostream& out,\n                         const Container<T, Args...>& c) {\n  ...\n}\n```", "```cpp\n// Example 23\ntemplate <typename T,\n  template <typename, size_t> class Container, size_t N>\nstd::ostream& operator<<(std::ostream& out,\n                         const Container<T, N>& c) {\n  ...\n}\n```", "```cpp\n// Example 24\ntemplate <typename T> class Value {\n  public:\n  using basic_type = T;\n  using value_type = Value;\n  explicit Value() : val_(T()) {}\n  explicit Value(T v) : val_(v) {}\n  Value(const Value&) = default;\n  Value& operator=(const Value&) = default;\n  Value& operator=(basic_type rhs) {\n    val_ = rhs;\n    return *this;\n  }\n  protected:\n  T val_ {};\n};\n```", "```cpp\n// Example 24\ntemplate <typename T> class Value {\n  public:\n  friend std::ostream& operator<<(std::ostream& out,\n                                  Value x) {\n    out << x.val_;\n    return out;\n  }\n  friend std::istream& operator>>(std::istream& in,\n                                  Value& x) {\n    in >> x.val_;\n    return in;\n  }\n  ...\n};\n```", "```cpp\n// Example 24\nusing V = Value<int>;\nV i, j(5), k(3);\ni = j;\nstd::cout << i;     // Prints 5\n```", "```cpp\n// Example 24\ntemplate <typename V> class Comparable : public V {\n  public:\n  using V::V;\n  using V::operator=;\n  using value_type = typename V::value_type;\n  using basic_type = typename value_type::basic_type;\n  Comparable(value_type v) : V(v) {}\n  friend bool operator==(Comparable lhs, Comparable rhs) {\n    return lhs.val_ == rhs.val_;\n  }\n  friend bool operator==(Comparable lhs, basic_type rhs) {\n    return lhs.val_ == rhs;\n  }\n  friend bool operator==(basic_type lhs, Comparable rhs) {\n    return lhs == rhs.val_;\n  }\n  ... same for the operator!= ...\n};\n```", "```cpp\nusing V = Comparable<Value<int>>;\nV i(3), j(5);\ni == j; // False\ni == 3; // True\n5 == j; // Also true\n```", "```cpp\n// Example 24\ntemplate <typename V> class Ordered : public V {\n  public:\n  using V::V;\n  using V::operator=;\n  using value_type = typename V::value_type;\n  using basic_type = typename value_type::basic_type;\n  Ordered(value_type v) : V(v) {}\n  friend bool operator<(Ordered lhs, Ordered rhs) {\n    return lhs.val_ < rhs.val_;\n  }\n  friend bool operator<(basic_type lhs, Ordered rhs) {\n    return lhs < rhs.val_;\n  }\n  friend bool operator<(Ordered lhs, basic_type rhs) {\n    return lhs.val_ < rhs;\n  }\n  ... same for the other operators ...\n};\n```", "```cpp\nusing V = Ordered<Comparable<Value<int>>>;\n// Or Comparable<Ordered<...>\nV i(3), j(5);\ni == j; // False\ni <= 3; // True\n```", "```cpp\n// Example 24\ntemplate <typename V> class Addable : public V {\n  public:\n  using V::V;\n  using V::operator=;\n  using value_type = typename V::value_type;\n  using basic_type = typename value_type::basic_type;\n  Addable(value_type v) : V(v) {}\n  friend Addable operator+(Addable lhs, Addable rhs) {\n    return Addable(lhs.val_ + rhs.val_);\n  }\n  friend Addable operator+(Addable lhs, basic_type rhs) {\n    return Addable(lhs.val_ + rhs);\n  }\n  friend Addable operator+(basic_type lhs, Addable rhs) {\n    return Addable(lhs + rhs.val_);\n  }\n  ... same for the operator- ...\n};\n```", "```cpp\nusing V = Addable<Value<int>>;\nV i(5), j(3), k(7);\nk = i + j; // 8\n```", "```cpp\nusing V = Addable<Ordered<Value<int>>>;\nV i(5), j(3), k(7);\nif (k - 1 < i + j) { ... yes it is ... }\n```", "```cpp\nusing V = Ordered<Addable<Value<int>>>;\nV i(5), j(3), k(7);\nif (k - 1 < i + j) { ... }\n```", "```cpp\ntemplate <typename V, typename FV> class Ordered : ...\n```", "```cpp\nusing V = Ordered<Addable<Value<int>>>;\n```", "```cpp\ntemplate <typename V, typename FV = void> class Ordered;\ntemplate <typename V> class Ordered<V, void>;\n```", "```cpp\ntemplate <typename V, typename FV = void>\nclass Ordered : public ... some base class ... {\n  public:\n  template <typename FV1> using rebind = Ordered<V, FV1>;\n};\n```", "```cpp\n// Example 25\ntemplate <typename V, typename FV = void>\nclass Ordered : public V::template rebind<FV> { ... };\n```", "```cpp\n// Example 25\ntemplate <typename V> class Ordered<V, void> :\n  public V::template rebind<Ordered<V>> { ... };\n```", "```cpp\n// Example 25\ntemplate <typename V, typename FV = void>\nclass Ordered : public V::template rebind<FV> {\n  using base_t = typename V::template rebind<FV>;\n  public:\n  using base_t::base_t;\n  using base_t::operator=;\n  template <typename FV1> using rebind = Ordered<V, FV1>;\n  using value_type = typename base_t::value_type;\n  using basic_type = typename value_type::basic_type;\n  explicit Ordered(value_type v) : base_t(v) {}\n  friend bool operator<(FV lhs, FV rhs) {\n    return lhs.val_ < rhs.val_;\n  }\n  ... the rest of the operators ...\n};\n```", "```cpp\n// Example 25\ntemplate <typename V> class Ordered<V, void>\n  : public V::template rebind<Ordered<V>> {\n  using base_t = typename V::template rebind<Ordered>;\n  public:\n  using base_t::base_t;\n  using base_t::operator=;\n  template <typename FV1> using rebind = Ordered<V, FV1>;\n  using value_type = typename base_t::value_type;\n  using basic_type = typename value_type::basic_type;\n  explicit Ordered(value_type v) : base_t(v) {}\n  friend bool operator<(Ordered lhs, Ordered rhs) {\n    return lhs.val_ < rhs.val_;\n  }\n  ... the rest of the operators ...\n};\n```", "```cpp\n// Example 25\ntemplate <typename V, typename FV = void> class Addable :\n  public V::template rebind<FV> {\n  friend FV operator+(FV lhs, FV rhs) {\n    return FV(lhs.val_ + rhs.val_);\n  }\n  ...\n};\n```", "```cpp\n// Example 25\ntemplate <typename V> class Addable<V, void> :\n  public V::template rebind<FV> {\n  friend Addable operator+(Addable lhs,Addable rhs) {\n    return Addable(lhs.val_ + rhs.val_);\n  }\n  ...\n};\n```", "```cpp\n// Example 25\nusing V = Comparable<Ordered<Addable<Value<int>>>>;\n// Addable<Ordered<Comparable<Value<int>>>> also OK\nV i, j(5), k(3);\ni = j; j = 1;\ni == j;         // OK – Comparable\ni > j;        // OK – Ordered\ni + j == 7 – k;    // OK – Comparable and Addable\ni*j;             // Not Multipliable – does not compile\n```", "```cpp\n// Example 25\ntemplate <typename V, typename FV = void>\nclass ImplicitFrom : public V::template rebind<FV> {\n  ...\n  explicit ImplicitFrom(value_type v) : base_t(v) {}\n  ImplicitFrom(basic_type rhs) : base_t(rhs) {}\n};\ntemplate <typename V> class ImplicitFrom<V, void> :\n  public V::template rebind<ImplicitFrom<V>> {\n  ...\n  explicit ImplicitFrom(value_type v) : base_t(v) {}\n  ImplicitFrom(basic_type rhs) : base_t(rhs) {}\n};\n```", "```cpp\nusing V = ImplicitFrom<Ordered<Addable<Value<int>>>>;\nvoid f(V v);\nf(3);\n```", "```cpp\n// Example 25\ntemplate <typename V, typename FV = void>\nclass ImplicitTo : public V::template rebind<FV> {\n  ...\n  explicit ImplicitTo(value_type v) : base_t(v) {}\n  operator basic_type(){ return this->val_; }\n  operator const basic_type() const { return this->val_; }\n};\ntemplate <typename V> class ImplicitTo<V, void> :\n  public V::template rebind<ImplicitTo<V>> {\n  ...\n  explicit ImplicitTo(value_type v) : base_t(v) {}\n  operator basic_type(){ return this->val_; }\n  operator const basic_type() const { return this->val_; }\n};\n```", "```cpp\nusing V = ImplicitTo<Ordered<Addable<Value<int>>>>;\nvoid f(int i);\nV i(3);\nf(i);\n```", "```cpp\ntemplate <typename T, typename AdditionPolicy,\n                      typename ComparisonPolicy,\n                      typename OrderPolicy,\n                      typename AssignmentPolicy, ... >\nclass Value { ... };\n```", "```cpp\ntemplate <\n  typename T,    // The base type (like int)\n  typename V>    // The derived class\nstruct Incrementable {\n  V operator++() {\n    V& v = static_cast<V&>(*this);\n    ++v.val_;     // The value inside the derived class\n    return v;\n  }\n};\n```", "```cpp\n// Example 26\ntemplate <typename T,\n          template <typename, typename> class ... Policies>\nclass Value :\n  public Policies<T, Value<T, Policies ... >> ...\n{ ... };\n```", "```cpp\n// Example 26\ntemplate <typename T,\n          template <typename, typename> class ... Policies>\nclass Value :\n  public Policies<T, Value<T, Policies ... >> ...\n{\n  public:\n  using base_type = T;\n  explicit Value() = default;\n  explicit Value(T v) : val_(v) {}\n  Value(const Value& rhs) : val_(rhs.val_) {}\n  Value& operator=(Value rhs) {\n    val_ = rhs.val_;\n    return *this;\n  }\n  Value& operator=(T rhs) { val_ = rhs; return *this; }\n  friend std::ostream&\n  operator<<(std::ostream& out, Value x) {\n    out << x.val_; return out;\n  }\n  friend std::istream&\n    operator>>(std::istream& in, Value& x) {\n    in >> x.val_; return in;\n  }\n  private:\n  T val_ {};\n};\n```", "```cpp\n// Example 26\ntemplate <typename T,\n          template <typename, typename> class ... Policies>\nclass Value :\n  public Policies<T, Value<T, Policies ... >> ...\n{\n  public:\n  ...\n  T get() const { return val_; }\n  T& get() { return val_; }\n  private:\n  T val_ {};\n};\n```", "```cpp\n// Example 26\nusing V = Value<int, Addable, Incrementable>;\nV v1(0), v2(1);\nv1++; // Incrementable - OK\nV v3(v1 + v2); // Addable - OK\nv3 *= 2; // No multiplication policies - won't compile\n```", "```cpp\n// Example 26\ntemplate <typename T, typename V> struct Incrementable {\n  V operator++() {\n    V& v = static_cast<V&>(*this);\n    ++(v.get());\n    return v;\n  }\n  V operator++(int) {\n    V& v = static_cast<V&>(*this);\n    return V(v.get()++);\n  }\n};\n```", "```cpp\n// Example 26\ntemplate <typename T, typename V> struct Incrementable {\n  V& operator+=(V val) {\n    V& v = static_cast<V&>(*this);\n    v.get() += val.get();\n    return v;\n  }\n  V& operator+=(T val) {\n    V& v = static_cast<V&>(*this);\n    v.get() += val;\n    return v;\n  }\n};\n```", "```cpp\n// Example 26\ntemplate <typename T, typename V> struct ComparableSelf {\n  friend bool operator==(V lhs, V rhs) {\n    return lhs.get() == rhs.get();\n  }\n  friend bool operator!=(V lhs, V rhs) {\n    return lhs.get() != rhs.get();\n  }\n};\n```", "```cpp\ntemplate <typename T, typename V> struct ComparableValue {\n  friend bool operator==(V lhs, T rhs) {\n    return lhs.get() == rhs;\n  }\n  friend bool operator==(T lhs, V rhs) {\n    return lhs == rhs.get();\n  }\n  friend bool operator!=(V lhs, T rhs) {\n    return lhs.get() != rhs;\n  }\n  friend bool operator!=(T lhs, V rhs) {\n    return lhs != rhs.get();\n  }\n};\n```", "```cpp\n// Example 26\ntemplate <typename T, typename V>\nstruct Comparable : public ComparableSelf<T, V>,\n                    public ComparableValue<T, V> {};\n```", "```cpp\n// Example 26\ntemplate <typename T, typename V> struct Addable {\n  friend V operator+(V lhs, V rhs) {\n    return V(lhs.get() + rhs.get());\n  }\n  friend V operator+(V lhs, T rhs) {\n    return V(lhs.get() + rhs);\n  }\n  friend V operator+(T lhs, V rhs) {\n    return V(lhs + rhs.get());\n  }\n};\n```", "```cpp\n// Example 26\ntemplate <typename T, typename V>\nstruct ExplicitConvertible {\n  explicit operator T() {\n    return static_cast<V*>(this)->get();\n  }\n  explicit operator const T() const {\n    return static_cast<const V*>(this)->get();\n  }\n};\n```", "```cpp\ntemplate <typename T, typename V> struct Addable {\n  constexpr bool adding_enabled = true;\n};\n```"]