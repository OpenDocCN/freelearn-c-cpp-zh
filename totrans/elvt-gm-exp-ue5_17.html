<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer542">
<h1 class="chapter-number" id="_idParaDest-350"><a id="_idTextAnchor386"/>17</h1>
<h1 id="_idParaDest-351"><a id="_idTextAnchor387"/>Using Remote Procedure Calls</h1>
<p>In the previous chapter, we covered some critical multiplayer concepts, including the server-client architecture, connections and ownership, roles, and variable replication. We also learned how to make 2D Blend Spaces and use the <strong class="source-inline">Transform (Modify) Bone</strong> node to modify bones at runtime. We used that knowledge to create a basic first-person shooter character that walks, jumps, and looks around. </p>
<p>In this chapter, we’re going to <a id="_idIndexMarker1478"/>cover <strong class="bold">remote procedure calls</strong> (<strong class="bold">RPCs</strong>), which is another important multiplayer concept that allows the server to execute functions on the clients and vice versa. So far, we’ve learned about variable replication as a form of communication between the server and the clients. However, to have proper communication, this isn’t enough. This is because the server may need to execute specific logic on the clients that doesn’t involve updating the value of a variable. The client also needs a way to tell its intentions to the server so that the server can validate the action and let the other clients know about it. This will ensure that the multiplayer world is synchronized between all of the connected clients. We’ll also cover how to use enumerations and expose them to the editor, as well as array index wrapping, which allows you to iterate an array in both directions and loop around when you go beyond its limits.</p>
<p>In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li>Understanding remote procedure calls</li>
<li>Exposing enumerations to the editor</li>
<li>Using array index wrapping</li>
</ul>
<p>By the end of this chapter, you’ll understand how RPCs work to make the server and the clients execute logic on one another. You’ll also be able to expose enumerations to the editor and use array index wrapping to cycle through arrays in both directions.</p>
<h1 id="_idParaDest-352"><a id="_idTextAnchor388"/>Technical requirements</h1>
<p>For this chapter, you will need the following technical requirements:</p>
<ul>
<li>Unreal Engine 5 installed</li>
<li>Visual Studio 2019 installed</li>
</ul>
<p>The project for this chapter can be found in the <strong class="source-inline">Chapter17</strong> folder of the code bundle for this book, which can be downloaded here: <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition</a>.</p>
<p>In the next section, we will look at RPCs.</p>
<h1 id="_idParaDest-353"><a id="_idTextAnchor389"/>Understanding remote procedure calls</h1>
<p>We covered variable replication in <a href="B18531_16.xhtml#_idTextAnchor345"><em class="italic">Chapter 16</em></a>, <em class="italic">Getting Started with Multiplayer Basics</em>, and, while a <a id="_idIndexMarker1479"/>very useful feature, it is a bit limited in terms of allowing custom code to be executed in remote game instances (client-to-server or server-to-client) for two main reasons:</p>
<ul>
<li>The first reason is that variable replication is strictly a form of server-to-client communication, so there isn’t a way for a client to use variable replication to tell the server to execute some custom logic by changing the value of a variable. </li>
<li>The second reason is that variable replication, as the name suggests, is driven by the values of variables, so even if variable replication allowed client-to-server communication, it would require you to change the value of a variable on the client to trigger a <strong class="source-inline">RepNotify</strong> function on the server to run the custom logic, which is not very practical. </li>
</ul>
<p>To solve this problem, Unreal Engine supports RPCs, which work just like normal functions that can be defined and called. However, instead of executing them locally, they will be executed on a remote game instance, without being tied to a variable. To be able to use RPCs, make sure you are defining them in an actor that has a valid connection and replication turned on.</p>
<p>There are three types of RPCs, and each one serves a different purpose:</p>
<ul>
<li>Server RPC</li>
<li>Multicast RPC</li>
<li>Client RPC</li>
</ul>
<p>Let’s look at these three types in detail and explain when to use them.</p>
<h2 id="_idParaDest-354"><a id="_idTextAnchor390"/>Server RPC</h2>
<p>You use a<a id="_idIndexMarker1480"/> Server RPC every time you want the server to run a function on the actor that has defined the RPC. There are two main reasons <a id="_idIndexMarker1481"/>why you would want to do this: </p>
<ul>
<li>The first reason is security. When making multiplayer games, especially competitive ones, you always have to assume that the client will try to cheat. The way to make sure there is no cheating is by forcing the client to go through the server to execute the functions that are critical to gameplay. </li>
<li>The second reason is synchronicity. Since the critical gameplay logic is only executed on the server, the important variables are only going to be changed there, which will automatically trigger the variable replication logic to update the clients whenever they are changed.</li>
</ul>
<p>An<a id="_idIndexMarker1482"/> example of this would be when a client’s character tries to fire a weapon. Since there’s always the possibility that the client may try to cheat, you can’t just execute the fire weapon logic locally. The correct way of doing this is by having the client call a Server RPC that tells the server to validate the <strong class="source-inline">Fire</strong> action by making sure the character has enough ammo, has the weapon equipped, and so on. If everything checks out, then it will deduct the ammo variable, and finally, it will execute a Multicast RPC (covered shortly) that will tell all of the clients to play the fire animation on that character.</p>
<h3>Declaration</h3>
<p>To <a id="_idIndexMarker1483"/>declare a Server RPC, you can use the <strong class="source-inline">Server</strong> specifier on the <strong class="source-inline">UFUNCTION</strong> macro. Have a look at the following example:</p>
<pre class="source-code">
UFUNCTION(Server, Reliable, WithValidation)
void ServerRPCFunction(int32 IntegerParameter, float FloatParameter, AActor* ActorParameter); </pre>
<p>In the preceding code snippet, the <strong class="source-inline">Server</strong> specifier is used on the <strong class="source-inline">UFUNCTION</strong> macro to state that the function is a Server RPC. You can have parameters on a Server RPC just like a normal function, but with some caveats that will be explained later in this topic, as well as the purpose of the <strong class="source-inline">Reliable</strong> and <strong class="source-inline">WithValidation</strong> specifiers.</p>
<h3>Execution</h3>
<p>To execute <a id="_idIndexMarker1484"/>a Server RPC, you call it from a client on the actor instance that defined it. Take a look at the following example:</p>
<pre class="source-code">
void ARPCTest::CallMyOwnServerRPC(int32 IntegerParameter)
{
  ServerMyOwnRPC(IntegerParameter);
}</pre>
<p>The preceding code snippet implements the <strong class="source-inline">CallMyOwnServerRPC</strong> function, which calls the <strong class="source-inline">ServerMyOwnRPC</strong> RPC function, defined in its own <strong class="source-inline">ARPCTest</strong> class, with an integer parameter. This will execute the implementation of the <strong class="source-inline">ServerMyOwnRPC</strong> function on the server version of that actor’s instance. We can also call a Server RPC from another actor’s instance, like so:</p>
<pre class="source-code">
void ARPCTest::CallServerRPCOfAnotherActor(AAnotherActor* OtherActor)
{
  if(OtherActor != nullptr)
  {
    OtherActor-&gt;ServerAnotherActorRPC();
  }
}</pre>
<p>The preceding code snippet implements the <strong class="source-inline">CallServerRPCOfAnotherActor</strong> function, which <a id="_idIndexMarker1485"/>calls the <strong class="source-inline">ServerAnotherActorRPC</strong> RPC function, defined in <strong class="source-inline">AAnotherActor</strong>, on the <strong class="source-inline">OtherActor</strong> instance, so long as it’s valid. This will execute the implementation of the <strong class="source-inline">ServerAnotherActorRPC</strong> function on the server version of the <strong class="source-inline">OtherActor</strong> instance.</p>
<h2 id="_idParaDest-355"><a id="_idTextAnchor391"/>Multicast RPC</h2>
<p>You<a id="_idIndexMarker1486"/> use a Multicast RPC when you want the server to<a id="_idIndexMarker1487"/> instruct all of the clients to run a function on the actor that has defined the RPC. </p>
<p>An example <a id="_idIndexMarker1488"/>of this is when a client’s character tries to fire a weapon. After the client calls the Server RPC to ask permission to fire the weapon and the server has validated the request (the ammo has been deducted and the line trace/projectile was processed), we need to do a Multicast RPC so that all of the instances of that specific character play the fire animation.</p>
<h3>Declaration</h3>
<p>To declare a<a id="_idIndexMarker1489"/> Multicast RPC, you need to use the <strong class="source-inline">NetMulticast</strong> specifier on the <strong class="source-inline">UFUNCTION</strong> macro. Have a look at the following example:</p>
<pre class="source-code">
UFUNCTION(NetMulticast, Unreliable)
void MulticastRPCFunction(int32 IntegerParameter, float 
FloatParameter, AActor* ActorParameter); </pre>
<p>In the preceding code snippet, the <strong class="source-inline">NetMulticast</strong> specifier is used on the <strong class="source-inline">UFUNCTION</strong> macro to say that the function is a Multicast RPC. You can have parameters on a Multicast RPC just like a normal function, but with the same caveats as the Server RPC. The <strong class="source-inline">Unreliable</strong> specifier will be explained later in this topic.</p>
<h3>Execution</h3>
<p>To<a id="_idIndexMarker1490"/> execute a Multicast RPC, you must call it from the server on the actor instance that defined it. Take a look at the following example:</p>
<pre class="source-code">
void ARPCTest::CallMyOwnMulticastRPC(int32 IntegerParameter)
{
  MulticastMyOwnRPC(IntegerParameter);
}</pre>
<p>The <a id="_idIndexMarker1491"/>preceding code snippet implements the <strong class="source-inline">CallMyOwnMulticastRPC</strong> function, which calls the <strong class="source-inline">MulticastMyOwnRPC</strong> RPC function, defined in its own <strong class="source-inline">ARPCTest</strong> class, with an integer parameter. This will execute the implementation of the <strong class="source-inline">MulticastMyOwnRPC</strong> function on all of the clients’ versions of that actor’s instance. We can also call a Multicast RPC from another actor’s instance, like so:</p>
<pre class="source-code">
void ARPCTest::CallMulticastRPCOfAnotherActor(AAnotherActor* 
OtherActor)
{
  if(OtherActor != nullptr)
  {
    OtherActor-&gt;MulticastAnotherActorRPC();
  }
}</pre>
<p>The preceding code snippet implements the <strong class="source-inline">CallMulticastRPCOfAnotherActor</strong> function, which calls the <strong class="source-inline">MulticastAnotherActorRPC</strong> RPC function, defined in <strong class="source-inline">AAnotherActor</strong>, on the <strong class="source-inline">OtherActor</strong> instance, so long as it’s valid. This will execute the implementation of the <strong class="source-inline">MulticastAnotherActorRPC</strong> function on all of the clients’ versions of the <strong class="source-inline">OtherActor</strong> instance.</p>
<h2 id="_idParaDest-356"><a id="_idTextAnchor392"/>Client RPC</h2>
<p>You use a <a id="_idIndexMarker1492"/>Client RPC <a id="_idIndexMarker1493"/>when you want the server to instruct only the owning client to run a function on the actor that has defined the RPC. To set the owning client, you need to call <strong class="source-inline">SetOwner</strong> on the server and set it with the client’s player controller.</p>
<p>An example of this <a id="_idIndexMarker1494"/>would be when a character is hit by a projectile and plays a pain sound that only that client will hear. By calling a Client RPC from the server, the sound will only be played on the owning client and not on the other clients.</p>
<h3>Declaration</h3>
<p>To<a id="_idIndexMarker1495"/> declare a Client RPC, you need to use the <strong class="source-inline">Client</strong> specifier on the <strong class="source-inline">UFUNCTION</strong> macro. Have a look at the following example:</p>
<pre class="source-code">
UFUNCTION(Client, Unreliable)
void ClientRPCFunction(int32 IntegerParameter, float FloatParameter, Aactor* ActorParameter); </pre>
<p>In the preceding code snippet, the <strong class="source-inline">Client</strong> specifier is being used on the <strong class="source-inline">UFUNCTION</strong> macro to say that the function is a Client RPC. You can have parameters on a Client RPC just like a normal function, but with the same caveats as the Server RPC and the Multicast RPC. The <strong class="source-inline">Unreliable</strong> specifier will be explained later in this topic.</p>
<h3>Execution</h3>
<p>To <a id="_idIndexMarker1496"/>execute a Client RPC, you must call it from the server on the actor instance that defined it. Take a look at the following example:</p>
<pre class="source-code">
void ARPCTest::CallMyOwnClientRPC(int32 IntegerParameter)
{
  ClientMyOwnRPC(IntegerParameter);
}</pre>
<p>The preceding code snippet implements the <strong class="source-inline">CallMyOwnClientRPC</strong> function, which calls the <strong class="source-inline">ClientMyOwnRPC</strong> RPC function, defined in its own <strong class="source-inline">ARPCTest</strong> class, with an integer parameter. This will execute the implementation of the <strong class="source-inline">ClientMyOwnRPC</strong> function on the owning client’s version of that actor’s instance. We can also call a Client RPC from another actor’s instance, like so:</p>
<pre class="source-code">
void ARPCTest::CallClientRPCOfAnotherActor(AAnotherActor* OtherActor)
{
  if(OtherActor != nullptr)
  {
    OtherActor-&gt;ClientAnotherActorRPC();
  }
}</pre>
<p>The <a id="_idIndexMarker1497"/>preceding code snippet implements the <strong class="source-inline">CallClientRPCOfAnotherActor</strong> function, which calls the <strong class="source-inline">ClientAnotherActorRPC</strong> RPC function, defined in <strong class="source-inline">AAnotherActor</strong>, on the <strong class="source-inline">OtherActor</strong> instance, so long as it’s valid. This will execute the implementation of the <strong class="source-inline">ClientAnotherActorRPC</strong> function on the owning client’s version of the <strong class="source-inline">OtherActor</strong> instance.</p>
<h2 id="_idParaDest-357"><a id="_idTextAnchor393"/>Important considerations when using RPCs</h2>
<p>RPCs are very <a id="_idIndexMarker1498"/>useful, but there are a couple of things that you need to take into consideration when using them.</p>
<h3>Implementation</h3>
<p>The implementation <a id="_idIndexMarker1499"/>of an RPC differs slightly from that of a typical function. Instead of implementing the function as you normally do, you should only implement the <strong class="source-inline">_Implementation</strong> version of it, even though you didn’t declare it in the header file. Have a look at the following examples.</p>
<p><strong class="bold">Server RPC</strong>:</p>
<pre class="source-code">
void ARPCTest::ServerRPCTest_Implementation(int32 IntegerParameter, float FloatParameter, AActor* ActorParameter)
{
}</pre>
<p>In the preceding code <a id="_idIndexMarker1500"/>snippet, we implemented the <strong class="source-inline">_Implementation</strong> version of the <strong class="source-inline">ServerRPCTest</strong> function, which uses three parameters.</p>
<p><strong class="bold">Multicast RPC</strong>:</p>
<pre class="source-code">
void ARPCTest::MulticastRPCTest_Implementation(int32 IntegerParameter, float FloatParameter, AActor* ActorParameter)
{
}</pre>
<p>In the preceding code snippet, we implemented the <strong class="source-inline">_Implementation</strong> version of the <strong class="source-inline">MulticastRPCTest</strong> function, which uses three parameters.</p>
<p><strong class="bold">Client RPC</strong>:</p>
<pre class="source-code">
void ARPCTest::ClientRPCTest_Implementation(int32 IntegerParameter, float FloatParameter, AActor* ActorParameter)
{
}</pre>
<p>In the preceding code snippet, we implemented the <strong class="source-inline">_Implementation</strong> version of the <strong class="source-inline">ClientRPCTest</strong> function, which uses three parameters.</p>
<p>As you can see from the previous examples, independent of the type of the RPC you are implementing, you should only implement the <strong class="source-inline">_Implementation</strong> version of the function and not the normal one, as demonstrated in the following code snippet:</p>
<pre class="source-code">
void ARPCTest::ServerRPCFunction(int32 IntegerParameter, float FloatParameter, AActor* ActorParameter)
{
}</pre>
<p>In the preceding code, we’re defining the normal implementation of <strong class="source-inline">ServerRPCFunction</strong>. If you implement the RPC like this, you’ll get an error saying that it was already implemented. The reason for this is that when you declare the RPC function in the header file, Unreal Engine will automatically create the normal implementation<a id="_idIndexMarker1501"/> internally, which once called, will execute the logic to send the RPC request through the network and when it reaches the remote computer it will call the <strong class="source-inline">_Implementation</strong> version there. Since you cannot have two implementations of the same function, it will throw a compilation error. To fix this, just make sure that you only implement the <strong class="source-inline">_Implementation</strong> version of the RPC.</p>
<p>Next, we will look at name prefixes.</p>
<h3>Name prefixes</h3>
<p>In Unreal Engine, it’s good practice to prefix RPCs with their corresponding types. Have a look at the following examples:</p>
<ul>
<li>A <strong class="bold">Server RPC</strong> called <strong class="source-inline">RPCFunction</strong> should be named <strong class="source-inline">ServerRPCFunction</strong></li>
<li>A <strong class="bold">Multicast RPC</strong> called <strong class="source-inline">RPCFunction</strong> should be named <strong class="source-inline">MulticastRPCFunction</strong></li>
<li>A <strong class="bold">Client RPC </strong>called <strong class="source-inline">RPCFunction</strong> should be named <strong class="source-inline">ClientRPCFunction</strong></li>
</ul>
<h3>Return value</h3>
<p>Since the execution<a id="_idIndexMarker1502"/> of RPCs is typically executed on different machines asynchronously, you can’t have a return value, so it always needs to be void.</p>
<h3>Overriding</h3>
<p>You can override <a id="_idIndexMarker1503"/>the implementation of an RPC to expand or bypass the parent’s functionality by declaring and implementing the <strong class="source-inline">_Implementation</strong> function in the child class without the <strong class="source-inline">UFUNCTION</strong> macro. Let’s look at an example.</p>
<p>The following is the declaration of the parent class:</p>
<pre class="source-code">
UFUNCTION(Server, Reliable)
void ServerRPCTest(int32 IntegerParameter); </pre>
<p>In the preceding code snippet, we have the declaration of the <strong class="source-inline">ServerRPCTest</strong> function in the parent class, which uses one integer parameter.</p>
<p>If we want to <a id="_idIndexMarker1504"/>override the function on the child class, we would need to use the following declaration:</p>
<pre class="source-code">
virtual void ServerRPCTest_Implementation(int32 IntegerParameter) override;</pre>
<p>In the preceding code snippet, we have overridden the declaration of the <strong class="source-inline">ServerRPCTest_Implementation</strong> function in the child class header file. The implementation of the function is just like any other override, with the possibility of calling <strong class="source-inline">Super::ServerRPCTest_Implementation</strong> if you still want to execute the parent functionality.</p>
<h3>Valid connection</h3>
<p>For an <a id="_idIndexMarker1505"/>actor to be able to execute its RPCs, they need to have a valid connection. If you try to call an RPC on an actor that doesn’t have a valid connection, then nothing will happen on the remote instance. You must make sure that the actor is either a player controller, is being possessed by one (if applicable), or that its owning actor has a valid connection.</p>
<h3>Supported parameter types</h3>
<p>When using <a id="_idIndexMarker1506"/>RPCs, you can add parameters just like any other function. At the time of writing, most common types are supported (such as <strong class="source-inline">bool</strong>, <strong class="source-inline">int32</strong>, <strong class="source-inline">float</strong>, <strong class="source-inline">FText</strong>, <strong class="source-inline">FString</strong>, <strong class="source-inline">FName</strong>,  <strong class="source-inline">TArray</strong>, and so on), but not all of them, such as <strong class="source-inline">TSet</strong> and <strong class="source-inline">TMap</strong>. Among the types that are supported, the ones that you have to pay more attention to are the pointers to any <strong class="source-inline">UObject</strong> class or subclass, especially actors.</p>
<p>If you create an RPC with an actor parameter, then that actor also needs to exist on the remote game instance; otherwise, it will have a value of <strong class="source-inline">nullptr</strong>. Another important thing to take into account is that the instance name of each version of the actor can be different. This means that if you call an RPC with an actor parameter, then the instance name of the actor <a id="_idIndexMarker1507"/>when calling the RPC might be different than the one when executing the RPC on the remote instance. Here is an example to help you understand this:</p>
<div>
<div class="IMG---Figure" id="_idContainer530">
<img alt="Figure 17.1 – Displaying the name of the character instances in three clients " height="447" src="image/Figure_17.01_B18531.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.1 – Displaying the name of the character instances in three clients</p>
<p>In the preceding example, you can see three clients running (one of them is a listen server) and each window is displaying the name of all of the character instances. If you look at the <strong class="bold">Client 1</strong> window, its controlled character instance is called <strong class="source-inline">BP_ThirdPersonCharacter_C_0</strong>, but on the <strong class="bold">Server</strong> window, that equivalent character is called <strong class="source-inline">BP_ThirdPersonCharacter_C_1</strong>. This means that if <strong class="bold">Client 1</strong> calls a Server RPC and passes its <strong class="source-inline">BP_ThirdPersonCharacter_C_0</strong> as an argument, then when the RPC is executed on the server, the parameter will be <strong class="source-inline">BP_ThirdPersonCharacter_C_1</strong>, which is the instance name of the equivalent character in that game instance.</p>
<h3>Executing RPCs on the target machine</h3>
<p>You can<a id="_idIndexMarker1508"/> call RPCs directly on their target machine and they will still execute. In other words, you can call a Server RPC on the server and it will execute, as well as a Multicast/Client RPC on the client, but in the latter case, it will only execute the logic on the client that called the RPC. Either way, in these cases, you can call the <strong class="source-inline">_Implementation</strong> version directly instead, to execute the logic faster.</p>
<p>The reason for this is that the <strong class="source-inline">_Implementation</strong> version just holds the logic to execute and doesn’t have the overhead of creating and sending the RPC request through the network that the regular call has. </p>
<p>Have a look at the following example of an actor that has authority on the server:</p>
<pre class="source-code">
void ARPCTest::CallServerRPC(int32 IntegerParameter)
{
  if(HasAuthority())
  {
    ServerRPCFunction_Implementation(IntegerParameter);
  }
  else ServerRPCFunction(IntegerParameter);
}</pre>
<p>In the preceding <a id="_idIndexMarker1509"/>example, you have the <strong class="source-inline">CallServerRPC</strong> function, which calls <strong class="source-inline">ServerRPCFunction</strong> in two different ways. If the actor is already on the server, then it calls <strong class="source-inline">ServerRPCFunction_Implementation</strong>, which will skip the overhead, as mentioned previously. </p>
<p>If the actor is not on the server, then it executes the regular call by using <strong class="source-inline">ServerRPCFunction</strong>, which adds the required overhead for creating and sending the RPC request through the network.</p>
<h3>Validation </h3>
<p>When you <a id="_idIndexMarker1510"/>define an RPC, you have the option of using an additional function to check whether there are any invalid inputs before the RPC is called. This is used to avoid processing the RPC if the inputs are invalid due to cheating or for some other reason. </p>
<p>To use validation, you need to add the <strong class="source-inline">WithValidation</strong> specifier to the <strong class="source-inline">UFUNCTION</strong> macro. When you use that specifier, you will be forced to implement the <strong class="source-inline">_Validate</strong> version of the function, which will return a Boolean stating whether the RPC can be executed. </p>
<p>Have a look at the following example:</p>
<pre class="source-code">
UFUNCTION(Server, Reliable, WithValidation)
void ServerSetHealth(float NewHealth);</pre>
<p>In the preceding code snippet, we’ve declared a validated Server RPC called <strong class="source-inline">ServerSetHealth</strong>, which<a id="_idIndexMarker1511"/> takes a float parameter for the new value of <strong class="source-inline">Health</strong>. Take a look at its implementation:</p>
<pre class="source-code">
bool ARPCTest::ServerSetHealth_Validate(float NewHealth)
{
  return NewHealth &gt;= 0.0f &amp;&amp; NewHealth &lt;= MaxHealth;
}
void ARPCTest::ServerSetHealth_Implementation(float NewHealth)
{
  Health = NewHealth;
}</pre>
<p>In the preceding code snippet, we implemented the <strong class="source-inline">_Validate</strong> function, which will check whether the new health is within 0 and the maximum value of the health. If a client tries to hack and call <strong class="source-inline">ServerSetHealth</strong> with <strong class="source-inline">200</strong> and <strong class="source-inline">MaxHealth</strong> is <strong class="source-inline">100</strong>, then the RPC won’t be called, which prevents the client from changing the health with values outside a certain range. If the <strong class="source-inline">_Validate</strong> function returns <strong class="source-inline">true</strong>, the <strong class="source-inline">_Implementation</strong> function is called as usual, which sets <strong class="source-inline">Health</strong> with the value of <strong class="source-inline">NewHealth</strong>.</p>
<h3>Reliability</h3>
<p>When you <a id="_idIndexMarker1512"/>declare an RPC, you are required to either use the <strong class="source-inline">Reliable</strong> or <strong class="source-inline">Unreliable</strong> specifier in the <strong class="source-inline">UFUNCTION</strong> macro. Here’s a quick overview of what they do:</p>
<ul>
<li><strong class="source-inline">Reliable</strong>: This is used when you want to make sure the RPC is executed, by repeating the request until the remote machine confirms its reception. This should only be used for RPCs that are very important, such as executing critical gameplay logic. Here is an example of how to use it:<p class="source-code">UFUNCTION(Server, Reliable)</p><p class="source-code">void ServerReliableRPCFunction(int32 IntegerParameter); </p></li>
<li><strong class="source-inline">Unreliable</strong>: This is used when you don’t care whether the RPC is executed due to bad network conditions, such as playing a sound or spawning a particle effect. This <a id="_idIndexMarker1513"/>should only be used for RPCs that aren’t very important or are called very frequently to update values since it wouldn’t matter if a couple didn’t get through. Here is an example of how to use it:<p class="source-code">UFUNCTION(Server, Unreliable)</p><p class="source-code">void ServerUnreliableRPCFunction(int32 IntegerParameter);</p></li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">For more <a id="_idIndexMarker1514"/>information on RPCs, please visit <a href="https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/RPCs/index.xhtml">https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/RPCs/index.xhtml</a>.</p>
<p>In the following exercise, you will learn how to implement the different types of RPCs.</p>
<h2 id="_idParaDest-358"><a id="_idTextAnchor394"/>Exercise 17.01 – Using remote procedure calls</h2>
<p>In this exercise, we’re going to create a <strong class="bold">C++</strong> project that uses the <strong class="bold">Third Person</strong> template and we’re going to<a id="_idIndexMarker1515"/> expand it in the following way:</p>
<ul>
<li>Add a new <strong class="source-inline">Ammo</strong> integer variable that defaults to <strong class="source-inline">5</strong> and replicates to all of the clients.</li>
<li>Add a fire animation that plays a fire sound and also create a <strong class="bold">Fire Anim Montage</strong> that is played when the server tells the client that the request to fire was valid.</li>
<li>Add a <strong class="bold">No Ammo Sound</strong> that will play when the server tells the client that they didn’t have sufficient ammo.</li>
<li>Every time the player presses the left mouse button, the client will perform a reliable and validated Server RPC that will check whether the character has sufficient ammo. If it does, it will subtract <strong class="source-inline">1</strong> from the <strong class="source-inline">Ammo</strong> variable and call an unreliable Multicast RPC that plays the fire animation in every client. If it doesn’t have ammo, then it will execute an unreliable Client RPC that will play <strong class="source-inline">No Ammo Sound</strong> that will only be heard by the owning client.</li>
<li>Schedule a timer that will prevent the client from spamming the fire button for <strong class="source-inline">1.5s</strong> after playing the fire animation.</li>
</ul>
<p>Follow these steps to complete this exercise:</p>
<ol>
<li>Create a new <strong class="bold">Third Person</strong> template project using <strong class="bold">C++</strong> called <strong class="source-inline">RPC</strong> and save it to a location of your liking.</li>
<li>Once the project has been created, it should open the editor as well as the Visual Studio solution.</li>
<li>Close the editor and go back to Visual Studio.</li>
<li>Open <strong class="source-inline">RPCCharacter.h</strong> and declare the protected <strong class="source-inline">FireTimer</strong> variable, which will be used to prevent the client from spamming the <strong class="source-inline">Fire</strong> action:<p class="source-code">FTimerHandle FireTimer;</p></li>
<li>Declare<a id="_idIndexMarker1516"/> the protected replicated <strong class="source-inline">Ammo</strong> variable, which starts with <strong class="source-inline">5</strong> shots:<p class="source-code">UPROPERTY(Replicated)</p><p class="source-code">int32 Ammo = 5;</p></li>
<li>Next, declare the protected animation montage variable that will be played when the character fires:<p class="source-code">UPROPERTY(EditDefaultsOnly, Category = "RPC Character")</p><p class="source-code">UAnimMontage* FireAnimMontage;</p></li>
<li>Declare the protected sound variable that will be played when the character has no ammo:<p class="source-code">UPROPERTY(EditDefaultsOnly, Category = "RPC Character")</p><p class="source-code">USoundBase* NoAmmoSound;</p></li>
<li>Override the <strong class="source-inline">Tick</strong> function:<p class="source-code">virtual void Tick(float DeltaSeconds) override;</p></li>
<li>Declare the reliable and validated Server RPC for firing:<p class="source-code">UFUNCTION(Server, Reliable, WithValidation, Category = "RPC Character")</p><p class="source-code">void ServerFire();</p></li>
<li>Declare the unreliable Multicast RPC that will play the fire animation on all of the clients:<p class="source-code">UFUNCTION(NetMulticast, Unreliable, Category = "RPC Character")</p><p class="source-code">void MulticastFire();</p></li>
<li>Declare the unreliable Client RPC that will play a sound only in the owning client:<p class="source-code">UFUNCTION(Client, Unreliable, Category = "RPC Character")</p><p class="source-code">void ClientPlaySound2D(USoundBase* Sound);</p></li>
<li>Now, open<a id="_idIndexMarker1517"/> the <strong class="source-inline">RPCCharacter.cpp</strong> file and include <strong class="source-inline">GameplayStatics.h</strong> for the PlaySound2D function and the UnrealNetwork.h so we can use the <strong class="source-inline">DOREPLIFETIME_CONDITION</strong> macro: <p class="source-code">#include "Kismet/GameplayStatics.h""</p><p class="source-code">#include "Net/UnrealNetwork.h"</p></li>
<li>At the end of the constructor, enable the <strong class="source-inline">Tick</strong> function:<p class="source-code">PrimaryActorTick.bCanEverTick = true;</p></li>
<li>Implement the <strong class="source-inline">GetLifetimeReplicatedProps</strong> function so that the <strong class="source-inline">Ammo</strong> variable will replicate to all of the clients:<p class="source-code">void ARPCCharacter::GetLifetimeReplicatedProps(TArray&lt; </p><p class="source-code">  FLifetimeProperty &gt;&amp; OutLifetimeProps) const</p><p class="source-code">{</p><p class="source-code">  Super::GetLifetimeReplicatedProps(OutLifetimeProps);</p><p class="source-code">  DOREPLIFETIME(ARPCCharacter, Ammo);</p><p class="source-code">}</p></li>
<li>Next, implement the <strong class="source-inline">Tick</strong> function, which displays the value of the <strong class="source-inline">Ammo</strong> variable:<p class="source-code">void ARPCCharacter::Tick(float DeltaSeconds)</p><p class="source-code">{</p><p class="source-code">  Super::Tick(DeltaSeconds);</p><p class="source-code">  const FString AmmoString = </p><p class="source-code">  FString::Printf(TEXT("Ammo = %d"), Ammo);</p><p class="source-code">  DrawDebugString(GetWorld(), GetActorLocation(), </p><p class="source-code">  AmmoString, nullptr, FColor::White, 0.0f, true);</p><p class="source-code">}</p></li>
<li>At the<a id="_idIndexMarker1518"/> end of the <strong class="source-inline">SetupPlayerInputController</strong> function, bind the <strong class="source-inline">Fire</strong> action to the <strong class="source-inline">ServerFire</strong> function:<p class="source-code">PlayerInputComponent-&gt;BindAction("Fire", IE_Pressed, this, &amp;ARPCCharacter::ServerFire);</p></li>
<li>Implement the fire Server RPC validation function:<p class="source-code">bool ARPCCharacter::ServerFire_Validate()</p><p class="source-code">{</p><p class="source-code">  return true;</p><p class="source-code">}</p></li>
<li>Implement the fire Server RPC implementation function:<p class="source-code">void ARPCCharacter::ServerFire_Implementation()</p><p class="source-code">{</p><p class="source-code">  </p><p class="source-code">}</p></li>
<li>Now, add the logic to abort the function if the fire timer is still active since we fired the last shot:<p class="source-code">if (GetWorldTimerManager().IsTimerActive(FireTimer))</p><p class="source-code">{</p><p class="source-code">  return;</p><p class="source-code">}</p></li>
<li>Check whether the character has ammo. If it doesn’t, then play <strong class="source-inline">NoAmmoSound</strong> only in the client that controls the character and abort the function:<p class="source-code">if (Ammo == 0)</p><p class="source-code">{</p><p class="source-code">  ClientPlaySound2D(NoAmmoSound);</p><p class="source-code">  return;</p><p class="source-code">}</p></li>
<li>Deduct<a id="_idIndexMarker1519"/> the ammo and schedule the <strong class="source-inline">FireTimer</strong> variable to prevent this function from being spammed while playing the fire animation:<p class="source-code">Ammo--;</p><p class="source-code">GetWorldTimerManager().SetTimer(FireTimer, 1.5f, false);</p></li>
<li>Call the fire Multicast RPC to make all the clients play the fire animation:<p class="source-code">MulticastFire();</p></li>
<li>Implement the fire Multicast RPC, which will play the fire animation montage:<p class="source-code">void ARPCCharacter::MulticastFire_Implementation()</p><p class="source-code">{</p><p class="source-code">  if (FireAnimMontage != nullptr)</p><p class="source-code">  {</p><p class="source-code">    PlayAnimMontage(FireAnimMontage);</p><p class="source-code">  }</p><p class="source-code">}</p></li>
<li>Implement the Client RPC that plays a 2D sound:<p class="source-code">void ARPCCharacter::ClientPlaySound2D_Implementation(USoundBase* Sound)</p><p class="source-code">{</p><p class="source-code">  UGameplayStatics::PlaySound2D(GetWorld(), Sound);</p><p class="source-code">}</p></li>
</ol>
<p>Finally, you can launch the project in the editor.</p>
<ol>
<li value="25">Compile <a id="_idIndexMarker1520"/>the code and wait for the editor to fully load.</li>
<li>Go to <strong class="bold">Project Settings</strong>, go to <strong class="bold">Engine</strong>, then <strong class="bold">Input</strong>, and add the <strong class="bold">Fire</strong> action binding:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer531">
<img alt="Figure 17.2 – Adding the new Fire action binding " height="112" src="image/Figure_17.02_B18531.jpg" width="534"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.2 – Adding the new Fire action binding</p>
<ol>
<li value="27">Close <strong class="bold">Project Settings</strong>.</li>
<li>In the <strong class="bold">Content Browser</strong> area, go to the <strong class="source-inline">Content</strong> folder, create a new folder called <strong class="source-inline">Audio</strong>, and open it.</li>
<li>Click the <strong class="bold">Import</strong> button go to the <strong class="source-inline">Exercise17.01\Assets</strong> folder, and import <strong class="source-inline">NoA</strong><strong class="source-inline">mmo.wav</strong> and <strong class="source-inline">Fire.wav</strong>.</li>
<li>Save both files.</li>
<li>Go to the <strong class="source-inline">Content\Characters\Mannequins\Animations</strong> folder.</li>
<li>Click the <strong class="bold">Import</strong> button, go to the <strong class="source-inline">Exercise17.01\Assets</strong> folder, and import the <strong class="source-inline">ThirdPersonFire.fbx</strong> file. Make sure it’s using the <strong class="source-inline">SK_Mannequin</strong> skeleton and click <strong class="bold">Import</strong>.</li>
<li>Open <a id="_idIndexMarker1521"/>the new animation and put a <strong class="source-inline">Play Sound</strong> anim notify at <strong class="source-inline">0.3</strong> seconds using the <strong class="source-inline">Fire</strong> sound.</li>
<li>On the <strong class="bold">Details</strong> panel, find the <strong class="bold">Enable Root Motion</strong> option and set it to <strong class="bold">true</strong>. This will prevent the character from moving when playing the animation.</li>
<li>Save and close <strong class="source-inline">ThirdPersonFire</strong>.</li>
<li><em class="italic">Right-click</em> on <strong class="source-inline">ThirdPersonFire</strong> and pick <strong class="bold">Create</strong> | <strong class="bold">Create AnimMontage</strong>.</li>
<li>The <strong class="source-inline">Animations</strong> folder should look like this:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer532">
<img alt="Figure 17.3 – The Animations folder for the Mannequin " height="230" src="image/Figure_17.03_B18531.jpg" width="777"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.3 – The Animations folder for the Mannequin</p>
<ol>
<li value="38">Open <strong class="source-inline">ABP_Manny</strong> and go to <strong class="source-inline">AnimGraph</strong>.</li>
<li>Find the <strong class="source-inline">Control Rig</strong> node and set <strong class="source-inline">Alpha</strong> to <strong class="source-inline">0.0</strong> to disable the automatic feet adjustment. You should get the following output: </li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer533">
<img alt="Figure 17.4 – Disabling the feet adjustment " height="268" src="image/Figure_17.04_B18531.jpg" width="944"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.4 – Disabling the feet adjustment</p>
<ol>
<li value="40">Save<a id="_idIndexMarker1522"/> and close <strong class="source-inline">ABP_Manny</strong>.</li>
<li>Open <strong class="source-inline">SK_Mannequin</strong> in the <strong class="source-inline">Content\Characters\Mannequins\Meshes</strong> folder and retarget (as shown in <em class="italic">Exercise 16.04</em>) the <strong class="source-inline">root</strong> and <strong class="source-inline">pelvis</strong> bones so that they use <strong class="source-inline">Animation</strong>. The remaining bones should use <strong class="source-inline">Skeleton</strong>.</li>
<li>Save and close <strong class="source-inline">SK_Mannequin</strong>.</li>
<li>Go to <strong class="source-inline">Content\ThirdPerson\Blueprints</strong> and open the <strong class="source-inline">BP_T</strong><strong class="source-inline">hirdPersonCharacter</strong> blueprint.</li>
<li>In <strong class="source-inline">Class Defaults</strong>, set <strong class="source-inline">No Ammo Sound</strong> to use <strong class="source-inline">NoAmmo</strong>, and set <strong class="source-inline">Fire Anim Montage</strong> to use <strong class="source-inline">ThirdPersonFire_Montage</strong>.</li>
<li>Save and close <strong class="source-inline">BP_ThirdPersonCharacter</strong>.</li>
<li>Go to <strong class="bold">Multiplayer Options</strong> and set <strong class="bold">Net Mode</strong> to <strong class="bold">Play As Listen Server</strong> and <strong class="bold">Number of Players</strong> to <strong class="source-inline">2</strong>.</li>
<li>Set the window size to <strong class="source-inline">800x600</strong> and play using <strong class="bold">New Editor Window (PIE)</strong>.</li>
</ol>
<p>You should get the following output:</p>
<div>
<div class="IMG---Figure" id="_idContainer534">
<img alt="Figure 17.5 – The result of this exercise " height="640" src="image/Figure_17.05_B18531.jpg" width="1610"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.5 – The result of this exercise</p>
<p>By completing<a id="_idIndexMarker1523"/> this exercise, you can play on each client. Every time you press the left mouse button, the character of the client will play the <strong class="bold">Fire Anim montage</strong>, which all clients will be able to see, and its ammo will reduce by <strong class="source-inline">1</strong>. If you try to fire when the ammo is <strong class="source-inline">0</strong>, that client will hear <strong class="source-inline">No Ammo Sound</strong> and won’t do the fire animation, because the server didn’t call the Multicast RPC. If you try to spam the fire button, you’ll notice that it will only trigger a new fire once the animation has finished.</p>
<p>In this section, you learned how to use all of the different types of RPCs and their caveats. In the next section, we will look at enumerations and how to expose them to the editor.</p>
<h1 id="_idParaDest-359"><a id="_idTextAnchor395"/>Exposing enumerations to the editor</h1>
<p>An <a id="_idIndexMarker1524"/>enumeration is a user-defined data type that holds a list of integer constants, where each item has a human-friendly name assigned by you, which makes the code easier to read. As an example, if we wanted to represent the different states that a character can be in, we could use an integer variable where <strong class="source-inline">0</strong> means it’s idle, <strong class="source-inline">1</strong> means it’s walking, and so on. The problem with this approach is that when you<a id="_idIndexMarker1525"/> see code such as <strong class="source-inline">if(State == 0)</strong>, it’s hard to remember what <strong class="source-inline">0</strong> means unless you are using some type of documentation or comments to help you. To fix this problem, you should use enumerations, where you can write code such as <strong class="source-inline">if(State == EState::Idle)</strong>, which is much more explicit and easier to understand.</p>
<p>In C++, you have two types of enums – the older raw enums and the new enum classes, which were introduced in C++11. If you want to use the new enum classes in the editor, your first instinct might be to do it in the typical way, which is by declaring a variable or a function that uses the enumeration with <strong class="source-inline">UPROPERTY</strong> or <strong class="source-inline">UFUNCTION</strong>, respectively. </p>
<p>The problem is, if you try to do that, you’ll get a compilation error. Take a look at the following<a id="_idIndexMarker1526"/> example:</p>
<pre class="source-code">
enum class ETestEnum : uint8
{
  EnumValue1,
  EnumValue2,
  EnumValue3
};</pre>
<p>In the preceding code snippet, we’ve declared an enum class called <strong class="source-inline">ETestEnum</strong> that has three possible values – <strong class="source-inline">EnumValue1</strong>, <strong class="source-inline">EnumValue2</strong>, and <strong class="source-inline">EnumValue3</strong>.</p>
<p>After that, try either of the following examples inside a class:</p>
<pre class="source-code">
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Test")
ETestEnum TestEnum;
UFUNCTION(BlueprintCallable, Category = "Test")
void SetTestEnum(ETestEnum NewTestEnum) { TestEnum = NewTestEnum; }</pre>
<p>In the <a id="_idIndexMarker1527"/>preceding code snippet, we declared a <strong class="source-inline">UPROPERTY</strong> variable and a <strong class="source-inline">UFUNCTION</strong> function that uses the <strong class="source-inline">ETestEnum</strong> enumeration. If you try to compile, you’ll get the following compilation error:</p>
<pre class="source-code">
<strong class="bold">error : Unrecognized type 'ETestEnum' - type must be a UCLASS, USTRUCT or UENUM</strong></pre>
<p class="callout-heading">Note</p>
<p class="callout">In Unreal Engine, it’s good practice to prefix the name of an enumeration with the letter <strong class="source-inline">E</strong>. For example, you could have <strong class="source-inline">EWeaponType</strong> and <strong class="source-inline">EAmmoType</strong>.</p>
<p>This error happens because when you try to expose a class, struct, or enumeration to the editor with the <strong class="source-inline">UPROPERTY</strong> or <strong class="source-inline">UFUNCTION</strong> macro, you need to add it to the Unreal Engine Reflection System by using the <strong class="source-inline">UCLASS</strong>, <strong class="source-inline">USTRUCT</strong>, and <strong class="source-inline">UENUM</strong> macros, respectively.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can learn<a id="_idIndexMarker1528"/> more about the Unreal Engine Reflection System at  <a href="https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection">https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection</a>.</p>
<p>With that knowledge in mind, it is simple to fix the previous error. Just do the following:</p>
<pre class="source-code">
UENUM()
enum class ETestEnum : uint8
{
  EnumValue1,
  EnumValue2,
  EnumValue3
};</pre>
<p>In the next section, we will look at the <strong class="source-inline">TEnumAsByte</strong> type.</p>
<h2 id="_idParaDest-360"><a id="_idTextAnchor396"/>TEnumAsByte</h2>
<p>If you <a id="_idIndexMarker1529"/>want to expose a variable to the engine that uses a raw enum, then you need to use the <strong class="source-inline">TEnumAsByte</strong> type. If you declare a <strong class="source-inline">UPROPERTY</strong> variable using a raw enum (not enum classes), you’ll get a compilation error. </p>
<p>Have a look at the following example:</p>
<pre class="source-code">
UENUM()
enum ETestRawEnum
{
  EnumValue1,
  EnumValue2,
  EnumValue3
};</pre>
<p>Let’s say you declare a <strong class="source-inline">UPROPERTY</strong> variable using <strong class="source-inline">ETestRawEnum</strong>, like so:</p>
<pre class="source-code">
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Test")
ETestRawEnum TestRawEnum;</pre>
<p>You’ll get the following compilation error:</p>
<pre class="source-code">
<strong class="bold">error : You cannot use the raw enum name as a type for member variables, instead use TEnumAsByte or a C++11 enum class with an explicit underlying type.</strong></pre>
<p>To fix this error, you need to surround the enum type of the variable, which in this case is <strong class="source-inline">ETestRawEnum</strong>, with <strong class="source-inline">TEnumAsByte&lt;&gt;</strong>, like so:</p>
<pre class="source-code">
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Test")
TEnumAsByte&lt;ETestRawEnum&gt; TestRawEnum;</pre>
<p>In the next section, we will look at the <strong class="source-inline">UMETA</strong> macro.</p>
<h2 id="_idParaDest-361"><a id="_idTextAnchor397"/>UMETA</h2>
<p>When <a id="_idIndexMarker1530"/>you use the <strong class="source-inline">UENUM</strong> macro to add an enumeration to the Unreal Engine Reflection System, you can use the <strong class="source-inline">UMETA</strong> macro on each value of the enum. The <strong class="source-inline">UMETA</strong> macro, just like with other macros, such as <strong class="source-inline">UPROPERTY</strong> or <strong class="source-inline">UFUNCTION</strong>, can use specifiers that will inform Unreal Engine of how to handle that value. Let’s look at the most commonly used <strong class="source-inline">UMETA</strong> specifiers.</p>
<h3>DisplayName</h3>
<p>This<a id="_idIndexMarker1531"/> specifier allows you to define a new name that is easier to read for the enum value when it’s displayed in the editor. </p>
<p>Take a look at the following example:</p>
<pre class="source-code">
UENUM()
enum class ETestEnum : uint8
{
  EnumValue1 UMETA(DisplayName = "My First Option"),
  EnumValue2 UMETA(DisplayName = "My Second Option"),
  EnumValue3 UMETA(DisplayName = "My Third Option")
};</pre>
<p>Let’s declare the following variable:</p>
<pre class="source-code">
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Test")
ETestEnum TestEnum;</pre>
<p>When you open the editor and look at the <strong class="source-inline">TestEnum</strong> variable, you will see a dropdown where <strong class="source-inline">EnumValue1</strong>, <strong class="source-inline">EnumValue2</strong>, and <strong class="source-inline">EnumValue3</strong> have been replaced with <strong class="source-inline">My First Option</strong>, <strong class="source-inline">My Second Option</strong>, and <strong class="source-inline">My Third Option</strong>, respectively.</p>
<h3>Hidden</h3>
<p>This specifier allows you to hide a specific enum value from the dropdown. This is typically <a id="_idIndexMarker1532"/>used when there is an enum value that you only want to be able to use in C++ and not in the editor. </p>
<p>Take a look at the following example:</p>
<pre class="source-code">
UENUM()
enum class ETestEnum : uint8
{
  EnumValue1 UMETA(DisplayName = "My First Option"),
  EnumValue2 UMETA(Hidden),
  EnumValue3 UMETA(DisplayName = "My Third Option")
};</pre>
<p>Let’s declare the following variable:</p>
<pre class="source-code">
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Test")
ETestEnum TestEnum;</pre>
<p>When you open the editor and look at the <strong class="source-inline">TestEnum</strong> variable, you will see a dropdown. You should notice that <strong class="source-inline">My Second Option</strong> doesn’t appear in the dropdown and therefore can’t be selected.</p>
<p class="callout-heading">Note</p>
<p class="callout">For more<a id="_idIndexMarker1533"/> information on all of the UMETA specifiers, visit <a href="https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Metadata/#enummetadataspecifiers">https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Metadata/#enummetadataspecifiers</a>.</p>
<p>In the next section, we will look at the <strong class="source-inline">BlueprintType</strong> specifier for the <strong class="source-inline">UENUM</strong> macro.</p>
<h2 id="_idParaDest-362"><a id="_idTextAnchor398"/>BlueprintType</h2>
<p>This <strong class="source-inline">UENUM</strong> specifier <a id="_idIndexMarker1534"/>will expose the enumeration to blueprints. This means that there will be an entry for that enumeration in the dropdown that is used when making new variables or inputs/outputs for a function, as shown in the following example:</p>
<div>
<div class="IMG---Figure" id="_idContainer535">
<img alt="Figure 17.6 – Setting a variable to use the ETestEnum variable type " height="188" src="image/Figure_17.06_B18531.jpg" width="526"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.6 – Setting a variable to use the ETestEnum variable type</p>
<p>It will also create additional functions that you can call on the enumeration in the editor, as shown in the following example:</p>
<div>
<div class="IMG---Figure" id="_idContainer536">
<img alt="Figure 17.7 – List of additional functions available when using BlueprintType " height="251" src="image/Figure_17.07_B18531.jpg" width="708"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.7 – List of additional functions available when using BlueprintType</p>
<h3>MAX</h3>
<p>When <a id="_idIndexMarker1535"/>using enumerations, it’s common to want to know how many values it has. In Unreal Engine, the standard way of doing this is by adding <strong class="source-inline">MAX</strong> as the last value, which will be automatically hidden in the editor. </p>
<p>Take a look at the following example:</p>
<pre class="source-code">
UENUM()
enum class ETestEnum : uint8
{
  EnumValue1,
  EnumValue2,
  EnumValue3,
  MAX
};</pre>
<p>If you want to know <a id="_idIndexMarker1536"/>how many values <strong class="source-inline">ETestEnum</strong> has in C++, you just need to do the following:</p>
<pre class="source-code">
const int32 MaxCount = static_cast&lt;int32&gt;(ETestEnum::MAX);</pre>
<p>This works because enumerations in C++ are internally stored as numbers, where the first value is <strong class="source-inline">0</strong>, the second is <strong class="source-inline">1</strong>, and so on. This means that so long as <strong class="source-inline">MAX</strong> is the last value, it will always have the total number of values in the enumeration. An important thing to take into consideration is that for <strong class="source-inline">MAX</strong> to give you the correct value, you cannot change the internal numbering order of the enumeration, like so:</p>
<pre class="source-code">
UENUM()
enum class ETestEnum : uint8
{
  EnumValue1 = 4,
  EnumValue2 = 78,
  EnumValue3 = 100,
  MAX
};</pre>
<p>In this case, <strong class="source-inline">MAX</strong> will be <strong class="source-inline">101</strong> because it will use the number immediately next to the previous value, which is <strong class="source-inline">EnumValue3 = 100</strong>.</p>
<p>Using <strong class="source-inline">MAX</strong> is only meant to be used in C++ and not in the editor because the <strong class="source-inline">MAX</strong> value is hidden in blueprints, as mentioned previously. To get the number of entries of an enumeration in blueprints, you should use the <strong class="source-inline">BlueprintType</strong> specifier in the <strong class="source-inline">UENUM</strong> macro to expose some useful functions on the context menu. After that, you just need to type<a id="_idIndexMarker1537"/> the name of your enumeration in the context menu. If you select the <strong class="bold">Get number of entries in ETestEnum</strong> option, you will have a function that returns the number of entries of that enumeration.</p>
<p>In the next exercise, you will be using C++ enumerations in the editor.</p>
<h2 id="_idParaDest-363"><a id="_idTextAnchor399"/>Exercise 17.02 – Using C++ enumerations in the editor</h2>
<p>In this<a id="_idIndexMarker1538"/> exercise, we’re going to create a new <strong class="bold">C++</strong> project that uses the <strong class="bold">Third Person</strong> template. We’re going to add the following:</p>
<ul>
<li>An enumeration called <strong class="source-inline">EWeaponType</strong> that contains <strong class="bold">three</strong> weapons – a pistol, a shotgun, and a rocket launcher.</li>
<li>An enumeration called <strong class="source-inline">EAmmoType</strong> that contains <strong class="bold">3</strong> ammo types – bullets, shells, and rockets.</li>
<li>A variable called <strong class="source-inline">Weapon</strong> that uses <strong class="source-inline">EWeaponType</strong> to tell the type of the current weapon.</li>
<li>An integer array variable called <strong class="source-inline">Ammo</strong> that holds the amount of ammo for each type, which is initialized with a value of <strong class="source-inline">10</strong>.</li>
<li>When the player presses the <strong class="source-inline">1</strong>, <strong class="source-inline">2</strong>, or <strong class="source-inline">3</strong> key, the <strong class="source-inline">Weapon</strong> variable will be set to <strong class="source-inline">Pistol</strong>, <strong class="source-inline">Shotgun</strong>, or <strong class="source-inline">Rocket Launcher</strong>, respectively.</li>
<li>When the player presses the left mouse button, the ammo for the current weapon will be consumed.</li>
<li>With every <strong class="source-inline">Tick</strong> function call, the character will display the current weapon type and the equivalent ammo type and amount.</li>
</ul>
<p>Follow these steps to complete this exercise:</p>
<ol>
<li value="1">Create a new <strong class="bold">Third Person</strong> template project using <strong class="bold">C++</strong> called <strong class="source-inline">Enumerations</strong> and save it to a location of your liking. </li>
</ol>
<p>Once the project has been created, it should open the editor as well as the Visual Studio solution.</p>
<ol>
<li value="2">Close<a id="_idIndexMarker1539"/> the editor and go back to Visual Studio.</li>
<li>Open the <strong class="source-inline">Enumerations.h</strong> file.</li>
<li>Create a macro called <strong class="source-inline">ENUM_TO_INT32</strong> that will convert an enumeration into an <strong class="source-inline">int32</strong> data type:<p class="source-code">#define ENUM_TO_INT32(Value) static_cast&lt;int32&gt;(Value)</p></li>
<li>Create a macro called <strong class="source-inline">ENUM_TO_FSTRING</strong> that will get the display name for a value of an <strong class="source-inline">enum</strong> data type and convert it into an <strong class="source-inline">FString</strong> datatype:<p class="source-code">#define ENUM_TO_FSTRING(Enum, Value) FindObject&lt;UEnum&gt;(ANY_PACKAGE, TEXT(Enum), true)-&gt;GetDisplayNameTextByIndex(ENUM_TO_INT32(Value)).ToString()</p></li>
<li>Declare the <strong class="source-inline">EWeaponType</strong> and <strong class="source-inline">EammoType</strong> enumerations:<p class="source-code">UENUM(BlueprintType)</p><p class="source-code">enum class EWeaponType : uint8</p><p class="source-code">{</p><p class="source-code">  Pistol UMETA(Display Name = "Glock 19"),</p><p class="source-code">  Shotgun UMETA(Display Name = "Winchester M1897"),</p><p class="source-code">  RocketLauncher UMETA(Display Name = "RPG"),    </p><p class="source-code">  MAX</p><p class="source-code">};</p><p class="source-code">UENUM(BlueprintType)</p><p class="source-code">enum class EAmmoType : uint8</p><p class="source-code">{</p><p class="source-code">  Bullets UMETA(DisplayName = "9mm Bullets"),</p><p class="source-code">  Shells UMETA(Display Name = "12 Gauge Shotgun </p><p class="source-code">  Shells"),</p><p class="source-code">  Rockets UMETA(Display Name = "RPG Rockets"),</p><p class="source-code">  MAX</p><p class="source-code">};</p></li>
<li>Open the <strong class="source-inline">EnumerationsCharacter.h</strong> file and add the <strong class="source-inline">Enumerations.h</strong> header before <strong class="source-inline">EnumerationsCharacter.generated.h</strong>:<p class="source-code">#include "Enumerations.h"</p></li>
<li>Declare <a id="_idIndexMarker1540"/>the protected <strong class="source-inline">Weapon</strong> variable that holds the weapon type of the selected weapon:<p class="source-code">UPROPERTY(BlueprintReadOnly, Category = "Enumerations Character")</p><p class="source-code">EWeaponType Weapon;</p></li>
<li>Declare the protected <strong class="source-inline">Ammo</strong> array that holds the amount of ammo for each type:<p class="source-code">UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Enumerations Character")</p><p class="source-code">TArray&lt;int32&gt; Ammo;</p></li>
<li>Declare the protected overrides for the <strong class="source-inline">Begin Play</strong> and <strong class="source-inline">Tick</strong> functions:<p class="source-code">virtual void BeginPlay() override;</p><p class="source-code">virtual void Tick(float DeltaSeconds) override;</p></li>
<li>Declare the protected input functions:<p class="source-code">void Pistol();</p><p class="source-code">void Shotgun();</p><p class="source-code">void RocketLauncher();</p><p class="source-code">void Fire();</p></li>
<li>Open the <strong class="source-inline">EnumerationsCharacter.cpp</strong> file and bind the new action bindings at<a id="_idIndexMarker1541"/> the end of the <strong class="source-inline">SetupPlayerInputController</strong> function, as shown in the following code snippet:<p class="source-code">PlayerInputComponent-&gt;BindAction("Pistol", IE_Pressed, this, &amp;AEnumerationsCharacter::Pistol);</p><p class="source-code">PlayerInputComponent-&gt;BindAction("Shotgun", IE_Pressed, this, &amp;AEnumerationsCharacter::Shotgun);</p><p class="source-code">PlayerInputComponent-&gt;BindAction("Rocket Launcher", IE_Pressed, this, &amp;AEnumerationsCharacter::RocketLauncher);</p><p class="source-code">PlayerInputComponent-&gt;BindAction("Fire", IE_Pressed, this, &amp;AEnumerationsCharacter::Fire);</p></li>
<li>Next, implement the override for <strong class="source-inline">BeginPlay</strong> that executes the parent logic, but also initializes the size of the <strong class="source-inline">Ammo</strong> array with the number of entries in the <strong class="source-inline">EAmmoType</strong> enumeration. Each position in the array will also be initialized with a value of <strong class="source-inline">10</strong>:<p class="source-code">void AEnumerationsCharacter::BeginPlay()</p><p class="source-code">{</p><p class="source-code">  Super::BeginPlay();</p><p class="source-code">  constexpr int32 AmmoTypeCount = </p><p class="source-code">  ENUM_TO_INT32(EAmmoType::MAX);</p><p class="source-code">  Ammo.Init(10, AmmoTypeCount);</p><p class="source-code">}</p></li>
<li>Implement the override for <strong class="source-inline">Tick</strong>:<p class="source-code">void AEnumerationsCharacter::Tick(float DeltaSeconds)</p><p class="source-code">{</p><p class="source-code">  Super::Tick(DeltaSeconds);</p><p class="source-code">}</p></li>
<li>Convert <a id="_idIndexMarker1542"/>the <strong class="source-inline">Weapon</strong> variable into <strong class="source-inline">int32</strong> and the <strong class="source-inline">Weapon</strong> variable into an <strong class="source-inline">FString</strong>:<p class="source-code">const int32 WeaponIndex = ENUM_TO_INT32(Weapon);</p><p class="source-code">const FString WeaponString = ENUM_TO_FSTRING("EWeaponType", Weapon);</p></li>
<li>Convert the ammo type into an <strong class="source-inline">FString</strong> and get the ammo count for the current weapon:<p class="source-code">const FString AmmoTypeString = ENUM_TO_FSTRING("EAmmoType", Weapon);</p><p class="source-code">const int32 AmmoCount = Ammo[WeaponIndex];</p></li>
</ol>
<p>We are using <strong class="source-inline">Weapon</strong> to get the ammo type string because the entries in <strong class="source-inline">EAmmoType</strong> match the type of ammo of the equivalent <strong class="source-inline">EWeaponType</strong>. In other words, <strong class="source-inline">Pistol = 0</strong> uses <strong class="source-inline">Bullets = 0</strong>, <strong class="source-inline">Shotgun = 1</strong> uses <strong class="source-inline">Shells = 1</strong>, and <strong class="source-inline">RocketLauncher = 2</strong> uses <strong class="source-inline">Rockets = 2</strong>, so it’s a 1-to-1 mapping that we can use in our favor.</p>
<ol>
<li value="17">Display the name of the current weapon in the character’s location and its corresponding ammo type and ammo count, as shown in the following code snippet:<p class="source-code">const FString String = FString::Printf(TEXT("Weapon = %s\nAmmo Type = %s\nAmmo Count = %d"), *WeaponString, *AmmoTypeString, AmmoCount);</p><p class="source-code">DrawDebugString(GetWorld(), GetActorLocation(), String, nullptr, FColor::White, 0.0f, true);</p></li>
<li>Implement the equip input functions that set the <strong class="source-inline">Weapon</strong> variable with the corresponding value:<p class="source-code">void AEnumerationsCharacter::Pistol()</p><p class="source-code">{</p><p class="source-code">  Weapon = EWeaponType::Pistol;</p><p class="source-code">}</p><p class="source-code">void AEnumerationsCharacter::Shotgun()</p><p class="source-code">{</p><p class="source-code">  Weapon = EWeaponType::Shotgun;</p><p class="source-code">}</p><p class="source-code">void AEnumerationsCharacter::RocketLauncher()</p><p class="source-code">{</p><p class="source-code">  Weapon = EWeaponType::RocketLauncher;</p><p class="source-code">}</p></li>
<li>Implement<a id="_idIndexMarker1543"/> the fire input function that will use the weapon index to get the corresponding ammo type count and subtract <strong class="source-inline">1</strong>, so long as the resulting value is greater than or equal to 0:<p class="source-code">void AEnumerationsCharacter::Fire()</p><p class="source-code">{</p><p class="source-code">  const int32 WeaponIndex = ENUM_TO_INT32(Weapon);</p><p class="source-code">  const int32 NewRawAmmoCount = Ammo[WeaponIndex] - 1;</p><p class="source-code">  const int32 NewAmmoCount = </p><p class="source-code">  FMath::Max(NewRawAmmoCount, 0);</p><p class="source-code">  Ammo[WeaponIndex] = NewAmmoCount;</p><p class="source-code">}</p></li>
<li>Compile the code and run the editor.</li>
<li>Go to <strong class="bold">Project Settings</strong>, go to <strong class="bold">Engine</strong>, then <strong class="bold">Input</strong>, and add the new action bindings:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer537">
<img alt="Figure 17.8 – Adding the Pistol, Shotgun, Rocket Launcher, and Fire bindings " height="221" src="image/Figure_17.08_B18531.jpg" width="630"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.8 – Adding the Pistol, Shotgun, Rocket Launcher, and Fire bindings</p>
<ol>
<li value="22">Close <strong class="bold">Project Settings</strong>.</li>
<li>Make sure<a id="_idIndexMarker1544"/> the <strong class="bold">Net Mode</strong> option is set to <strong class="bold">Play Standalone</strong> and that <strong class="bold">Number of Players</strong> is set to <strong class="source-inline">1</strong>. Click on <strong class="bold">New Editor Window (PIE)</strong>; you should get the following result:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer538">
<img alt="Figure 17.9 – The result of this exercise " height="760" src="image/Figure_17.09_B18531.jpg" width="1286"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.9 – The result of this exercise</p>
<p>By completing this exercise, you can use the <strong class="bold">1</strong>, <strong class="bold">2</strong>, and <strong class="bold">3</strong> keys to select the current weapon. You’ll notice that every tick will display the type of the current weapon and its corresponding <a id="_idIndexMarker1545"/>ammo type and ammo count. If you press the left mouse button, this will deduct the ammo count for the current weapon, but it will never go below <strong class="source-inline">0</strong>.</p>
<p>In this section, you learned how to expose enumerations to the editor so that you can use them in blueprints. In the next section, we will look at array index wrapping, which allows you to iterate an array beyond its limits and wrap it back around from the other side.</p>
<h1 id="_idParaDest-364"><a id="_idTextAnchor400"/>Using array index wrapping</h1>
<p>Sometimes, when<a id="_idIndexMarker1546"/> you use arrays to store information, you may want to iterate it in both directions and be able to wrap the index so that it doesn’t go beyond the index limit and crash the game. An example of this is the previous/next weapon logic in shooter games, where you have an array of weapons and you want to be able to cycle through them in a particular direction, and when you reach the first or the last index, you want to loop back around to the last and first index, respectively. The typical way of doing this would be as follows:</p>
<pre class="source-code">
AWeapon * APlayer::GetPreviousWeapon()
{
  if(WeaponIndex - 1 &lt; 0)
  {
    WeaponIndex = Weapons.Num() - 1;
  }
  else
  {
    WeaponIndex--;
  }
  return Weapons[WeaponIndex];
}
AWeapon * APlayer::GetNextWeapon()
{
  if(WeaponIndex + 1 &gt; Weapons.Num() - 1)
  {
    WeaponIndex = 0;
  }
  else
  {
    WeaponIndex++;
  }
  return Weapons[WeaponIndex];
}</pre>
<p>In the <a id="_idIndexMarker1547"/>preceding code, we set the <strong class="source-inline">WeaponIndex</strong> variable (declared as a member of the class) to loop back if the new weapon index is outside the limits of the weapons array, which can happen in two cases. The first case is when the player has the last weapon of the inventory equipped and we want the next weapon. In this case, it should go back to the first weapon. </p>
<p>The second case is when the player has the first weapon of the inventory equipped and we want the previous weapon. In this case, it should go to the last weapon. </p>
<p>While the example code works, it’s still quite a lot of code to solve such a trivial problem. To improve this code, there is a mathematical operation that will help you handle these two cases automatically in just one function. It’s called the modulo (represented in C++ by the <strong class="source-inline">%</strong> operator), which gives you the remainder of a division between two numbers. </p>
<p>So, how do we use the modulo to wrap the index of an array? Let’s rewrite the previous example <a id="_idIndexMarker1548"/>using the modulo operator:</p>
<pre class="source-code">
AWeapon * APlayer::GetNewWeapon(int32 Direction)
{
  const int32 WeaponCount = Weapons.Num();
  const int32 NewRawIndex = WeaponIndex + Direction;
  const in32 NewWrappedIndex = NewIndex % WeaponCount;
  WeaponIndex = (NewClampedIndex + WeaponCount) % 
  WeaponCount;
  return Weapons[WeaponIndex];
}</pre>
<p>This is the new version, and you can tell right away that it’s a bit harder to understand, but it’s more functional and compact. If you don’t use the variables to store the intermediate values of each operation, you can probably make the entire function in one or two lines of code.</p>
<p>Let’s break down the preceding code snippet:</p>
<ul>
<li><strong class="source-inline">const int WeaponCount = Weapons.Num()</strong>: We need to know the size of the array to determine the index where it should go back to<strong class="source-inline"> 0</strong>. In other words, if<strong class="source-inline"> WeaponCount = 4</strong>, then the array has the <strong class="source-inline">0</strong>, <strong class="source-inline">1</strong>, <strong class="source-inline">2</strong>, and <strong class="source-inline">3</strong> indexes, which tells us that index <strong class="source-inline">4</strong> is the cutoff index where it should go back to <strong class="source-inline">0</strong>.</li>
<li><strong class="source-inline">const int32 NewRawIndex = WeaponIndex + Direction</strong>: This is the new raw index that doesn’t care about the limits of the array. The <strong class="source-inline">Direction </strong>variable is used to indicate the offset we want to add to the current index of the array. This is either <strong class="source-inline">-1</strong> if we want the previous index or<strong class="source-inline"> 1 </strong>if we want the next index.</li>
<li><strong class="source-inline">const int32 NewWrappedIndex = NewRawIndex % WeaponCount</strong>: This will make sure that<strong class="source-inline"> NewWrappedIndex</strong> is within the <strong class="source-inline">0</strong> to <strong class="source-inline">WeaponCount - 1 </strong>interval and wrap around if needed, due to the modulo properties. So, if <strong class="source-inline">NewRawIndex</strong> is <strong class="source-inline">4</strong>, then<strong class="source-inline"> NewWrappedIndex</strong> will become <strong class="source-inline">0</strong>, because there is no remainder from the division of <strong class="source-inline">4 / 4</strong>.</li>
</ul>
<p>If <strong class="source-inline">Direction</strong> is always <strong class="source-inline">1</strong>, meaning we only want the next index, then the value of <strong class="source-inline">NewWrappedIndex</strong> is enough for what we need. If we also want to use <strong class="source-inline">Direction</strong> with <strong class="source-inline">-1</strong>, then we’ll have <a id="_idIndexMarker1549"/>a problem, because the modulo operation won’t wrap the index correctly for negative indexes. So, if <strong class="source-inline">WeaponIndex</strong> is <strong class="source-inline">0</strong> and <strong class="source-inline">Direction</strong> is <strong class="source-inline">-1</strong>, then <strong class="source-inline">NewWrappedIndex</strong> will be <strong class="source-inline">-1</strong>, which is not correct. To fix this limitation, we need to do some additional calculations:</p>
<ul>
<li><strong class="source-inline">WeaponIndex = (NewWrappedIndex + WeaponCount) % WeaponCount</strong>: This will add<strong class="source-inline"> WeaponCount</strong> to <strong class="source-inline">NewWrappedIndex </strong>to make it positive and apply the modulo again to get the correct wrapped index, which fixes the problem.</li>
<li><strong class="source-inline">return Weapons[WeaponIndex]</strong>: This returns the weapon in the calculated<strong class="source-inline"> WeaponIndex </strong>index position.</li>
</ul>
<p>Let’s take a look at a practical example to help you visualize how all this works.</p>
<p>Weapons:</p>
<ul>
<li><strong class="source-inline">[0] Knife</strong></li>
<li><strong class="source-inline">[1] Pistol</strong></li>
<li><strong class="source-inline">[2] Shotgun</strong></li>
<li><strong class="source-inline">[3] Rocket Launcher</strong></li>
</ul>
<p><strong class="source-inline">WeaponCount = Weapons.Num()</strong>, so it has a value of <strong class="source-inline">4</strong>.</p>
<p>Let’s assume that <strong class="source-inline">WeaponIndex = 3</strong> and <strong class="source-inline">Direction = 1</strong>.</p>
<p>Here, we would have the following:</p>
<ul>
<li><strong class="source-inline">NewRawIndex = WeaponIndex + Direction</strong>, so <strong class="source-inline">3 + 1 = 4</strong></li>
<li><strong class="source-inline">NewWrappedIndex = NewRawIndex % WeaponCount</strong>, so<strong class="source-inline"> 4 % 4 = 0</strong></li>
<li><strong class="source-inline">WeaponIndex = (NewWrappedIndex + WeaponCount) % WeaponCount, so (0 + 4) % 4 = 0</strong></li>
</ul>
<p>In this example, the<a id="_idIndexMarker1550"/> starting value for <strong class="source-inline">WeaponIndex</strong> is <strong class="source-inline">3</strong>, which is <strong class="source-inline">Rocket Launcher</strong>, and we want the next weapon because <strong class="source-inline">Direction</strong> is set to <strong class="source-inline">1</strong>. Performing the calculations, <strong class="source-inline">WeaponIndex</strong> will now be <strong class="source-inline">0</strong>, which is <strong class="source-inline">Knife</strong>. This is the desired behavior because we have four weapons, so we circled back to the first index. In this case, since <strong class="source-inline">NewRawIndex</strong> is positive, we could’ve just used <strong class="source-inline">NewWrappedIndex</strong> without doing the extra calculations.</p>
<p>Let’s debug it again using different values.</p>
<p>Let’s assume that <strong class="source-inline">WeaponIndex = 0</strong> and <strong class="source-inline">Direction = -1</strong>:</p>
<ul>
<li><strong class="source-inline">NewRawIndex = WeaponIndex + Direction</strong>, so<strong class="source-inline"> 0 + -1 = -1</strong></li>
<li><strong class="source-inline">NewWrappedIndex = NewIndex % WeaponCount</strong>, so<strong class="source-inline"> -1 % 4 = -1</strong></li>
<li><strong class="source-inline">WeaponIndex = (NewWrappedIndex + WeaponCount) % WeaponCount</strong>, so<strong class="source-inline"> (-1 + 4) % 4 = 3</strong></li>
</ul>
<p>In this example, the starting value for <strong class="source-inline">WeaponIndex</strong> is <strong class="source-inline">0</strong>, which is <strong class="source-inline">Knife</strong>, and we want the previous weapon because <strong class="source-inline">Direction</strong> is set to -<strong class="source-inline">1</strong>. Doing the calculations, <strong class="source-inline">WeaponIndex</strong> will now be <strong class="source-inline">3</strong>, which is <strong class="source-inline">Rocket Launcher</strong>. This is the desired behavior because we have four weapons, so we circled back to the last index. In this case, since <strong class="source-inline">NewRawIndex</strong> is negative, we can’t just use <strong class="source-inline">NewWrappedIndex</strong>; we need to do the extra calculation to get the correct value.</p>
<p>In the next exercise, you’re going to use the knowledge you’ve acquired to cycle between an enumeration of weapons in both directions.</p>
<h2 id="_idParaDest-365"><a id="_idTextAnchor401"/>Exercise 17.03 – Using array index wrapping to cycle between an enumeration</h2>
<p>In this <a id="_idIndexMarker1551"/>exercise, we’re going to use the project from <em class="italic">Exercise 17.02 – Using C++ enumerations in the editor</em>, and add two new action mappings for cycling the weapons. <strong class="source-inline">Mouse Wheel Up</strong> will go to the previous weapon type, while <strong class="source-inline">Mouse Wheel Down</strong> will go to the next weapon type.</p>
<p>Follow these steps to complete this exercise:</p>
<ol>
<li value="1">First, open the Visual Studio project from <em class="italic">Exercise 17.02 – Using C++ enumerations in the editor</em>.</li>
</ol>
<p>Next, you will be updating <strong class="source-inline">Enumerations.h</strong> and adding a macro that will handle the array index wrapping in a very convenient way.</p>
<ol>
<li value="2">Open <strong class="source-inline">Enumerations.h</strong> and add the <strong class="source-inline">GET_WRAPPED_ARRAY_INDEX</strong> macro. This will apply the modulo formula that we covered previously:<p class="source-code">#define GET_WRAPPED_ARRAY_INDEX(Index, Count) (Index % Count + Count) % Count</p></li>
<li>Open <strong class="source-inline">EnumerationsCharacter.h</strong> and declare the new input functions for the weapon cycling:<p class="source-code">void PreviousWeapon();</p><p class="source-code">void NextWeapon();</p></li>
<li>Declare the <strong class="source-inline">CycleWeapons</strong> function, as shown in the following code snippet:<p class="source-code">void CycleWeapons(int32 Direction);</p></li>
<li>Open <strong class="source-inline">EnumerationsCharacter.cpp</strong> and bind the new action bindings in the <strong class="source-inline">SetupPlayerInputController</strong> function:<p class="source-code">PlayerInputComponent-&gt;BindAction("Previous Weapon", IE_Pressed, this, &amp;AEnumerationsCharacter::PreviousWeapon);</p><p class="source-code">PlayerInputComponent-&gt;BindAction("Next Weapon", IE_Pressed, this, &amp;AEnumerationsCharacter::NextWeapon);</p></li>
<li>Now, implement <a id="_idIndexMarker1552"/>the new input functions, as shown in the following code snippet:<p class="source-code">void AEnumerationsCharacter::PreviousWeapon()</p><p class="source-code">{</p><p class="source-code">  CycleWeapons(-1);</p><p class="source-code">}</p><p class="source-code">void AEnumerationsCharacter::NextWeapon()</p><p class="source-code">{</p><p class="source-code">  CycleWeapons(1);</p><p class="source-code">}</p></li>
</ol>
<p>In the preceding code snippet, we defined the functions that handle the action mappings for <strong class="source-inline">Previous Weapon</strong> and <strong class="source-inline">Next Weapon</strong>. Each function uses the <strong class="source-inline">CycleWeapons</strong> function, with a direction of <strong class="source-inline">-1</strong> for the previous weapon and <strong class="source-inline">1</strong> for the next weapon.</p>
<ol>
<li value="7">Implement the <strong class="source-inline">CycleWeapons</strong> function, which does the array index wrapping using the <strong class="source-inline">Direction</strong> parameter based on the current weapon index:<p class="source-code">void AEnumerationsCharacter::CycleWeapons(int32 Direction)</p><p class="source-code">{</p><p class="source-code">  const int32 WeaponIndex = ENUM_TO_INT32(Weapon);</p><p class="source-code">  const int32 AmmoCount = Ammo.Num();</p><p class="source-code">  const int32 NextRawWeaponIndex = WeaponIndex + </p><p class="source-code">  Direction;</p><p class="source-code">  const int32 NextWeaponIndex = </p><p class="source-code">  GET_WRAPPED_ARRAY_INDEX(NextRawWeaponIndex , </p><p class="source-code">  AmmoCount);</p><p class="source-code">  Weapon = static_cast&lt;EWeaponType&gt;(NextWeaponIndex);</p><p class="source-code">}</p></li>
<li>Compile<a id="_idIndexMarker1553"/> the code and run the editor.</li>
<li>Go to <strong class="bold">Project Settings</strong>, go to <strong class="bold">Engine</strong>, then <strong class="bold">Input</strong>, and add the new action bindings:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer539">
<img alt="Figure 17.10 – Adding the Previous Weapon and Next Weapon bindings " height="383" src="image/Figure_17.10_B18531.jpg" width="578"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.10 – Adding the Previous Weapon and Next Weapon bindings</p>
<ol>
<li value="10">Close <strong class="bold">Project Settings</strong>.</li>
<li>Make sure that the <strong class="bold">Net Mode</strong> option is set to <strong class="bold">Play Standalone</strong> and that <strong class="bold">Number of Players</strong> is set to <strong class="source-inline">1</strong>. Click on <strong class="bold">New Editor Window (PIE)</strong>; you should get the following result:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer540">
<img alt="Figure 17.11 – The result of this exercise " height="760" src="image/Figure_17.11_B18531.jpg" width="1286"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.11 – The result of this exercise</p>
<p>By <a id="_idIndexMarker1554"/>completing this exercise, you can use the mouse wheel to cycle between the weapons. If you select the rocket launcher and use the mouse wheel down to go to the next weapon, it will go back to the pistol. If you use the mouse wheel down to go to the previous weapon with the pistol selected, it will go back to the rocket launcher.</p>
<p>In the next activity, you will be adding the concept of weapons and ammo to the multiplayer FPS project we started in <a href="B18531_16.xhtml#_idTextAnchor345"><em class="italic">Chapter 16</em></a>, <em class="italic">Getting Started with Multiplayer Basics</em>.</p>
<h1 id="_idParaDest-366"><a id="_idTextAnchor402"/>Activity 17.01 – Adding weapons and ammo to the multiplayer FPS game</h1>
<p>In this activity, you’ll <a id="_idIndexMarker1555"/>add the concept of weapons and ammo to the multiplayer FPS project that we started in the previous chapter. You will <a id="_idIndexMarker1556"/>need to use the different types of RPCs covered in this chapter to complete this activity.</p>
<p>Follow these steps to complete this activity:</p>
<ol>
<li value="1">Open the <strong class="source-inline">MultiplayerFPS</strong> project from <em class="italic">Activity 16.01 – Creating a character for the multiplayer FPS project</em>.</li>
<li>Create an <strong class="source-inline">AnimMontage</strong> slot called <strong class="source-inline">Upper Body</strong>.</li>
<li>Import the animations (<strong class="source-inline">Pistol_Fire.fbx</strong>, <strong class="source-inline">MachineGun_Fire.fbx</strong>, and <strong class="source-inline">Railgun_Fire.fbx</strong>) from the <strong class="source-inline">Activity17.01\Assets</strong> folder into <strong class="source-inline">Content\Player\Animations</strong>.</li>
<li>Create<a id="_idIndexMarker1557"/> an <strong class="source-inline">AnimMontage</strong> for <strong class="source-inline">Pistol_Fire</strong>, <strong class="source-inline">MachineGun_Fire</strong>, and <strong class="source-inline">Railgun_Fire</strong>, and <a id="_idIndexMarker1558"/>make sure they have the following configurations:<ul><li><strong class="bold">Pistol_Fire_Montage</strong>: A <strong class="source-inline">Blend In</strong> time of <strong class="source-inline">0.01</strong> and a <strong class="source-inline">Blend Out</strong> time of <strong class="source-inline">0.1</strong>. Make sure it uses the <strong class="source-inline">Upper Body</strong> slot.</li><li><strong class="bold">MachineGun_Fire_Montage</strong>: A <strong class="source-inline">Blend In</strong> time of <strong class="source-inline">0.01</strong> and a <strong class="source-inline">Blend Out</strong> time of <strong class="source-inline">0.1</strong>. Make sure it uses the <strong class="source-inline">Upper Body</strong> slot.</li><li><strong class="bold">Railgun_Fire_Montage</strong>: Make sure it uses the <strong class="source-inline">Upper Body</strong> slot.</li></ul></li>
<li>Import <strong class="source-inline">SK_Weapon.fbx </strong>(with Material Import Method set to Create New Materials), <strong class="source-inline">NoAmmo.wav</strong>, <strong class="source-inline">WeaponChange.wav</strong>, and <strong class="source-inline">Hit.wav</strong> from the <strong class="source-inline">Activity17.01\Assets</strong> folder into <strong class="source-inline">Content\Weapons</strong>.</li>
<li>Import <strong class="source-inline">Pistol_Fire_Sound.wav</strong> from <strong class="source-inline">Activity17.01\Assets</strong> into <strong class="source-inline">Content\Weapons\Pistol</strong> and use it on <strong class="source-inline">Play Sound</strong> in the <strong class="source-inline">Pistol_Fire</strong> animation.</li>
<li>Create a simple green-colored material instance from <strong class="source-inline">M_FPGun</strong> called <strong class="source-inline">MI_Pistol</strong> and place it on <strong class="source-inline">Content\Weapons\Pistol</strong>.</li>
<li>Import <strong class="source-inline">MachineGun_Fire_Sound.wav</strong> from <strong class="source-inline">Activity17.01\Assets</strong> into <strong class="source-inline">Content\Weapons\MachineGun</strong> and use it on <strong class="source-inline">Play Sound</strong> in the <strong class="source-inline">MachineGun_Fire</strong> animation.</li>
<li>Create a simple red-colored material instance from <strong class="source-inline">M_FPGun</strong> called <strong class="source-inline">MI_MachineGun</strong> and place it on <strong class="source-inline">Content\Weapons\MachineGun</strong>.</li>
<li>Import <strong class="source-inline">Railgun_Fire_Sound.wav</strong> from <strong class="source-inline">Activity17.01\Assets</strong> into <strong class="source-inline">Content\Weapons\Railgun</strong> and use it on <strong class="source-inline">Play Sound</strong> in the <strong class="source-inline">Railgun_Fire</strong> animation.</li>
<li>Create a <a id="_idIndexMarker1559"/>simple white-colored material instance from <strong class="source-inline">M_FPGun</strong> called <strong class="source-inline">MI_Railgun</strong> and place it on <strong class="source-inline">Content\Weapons\Railgun</strong>.</li>
<li>Edit <a id="_idIndexMarker1560"/>the <strong class="source-inline">SK_Mannequin_Skeleton</strong> and create a socket called <strong class="source-inline">GripPoint</strong> from <strong class="source-inline">hand_r</strong> with <strong class="source-inline">Relative Location</strong> set to <strong class="source-inline">(X=-10.403845,Y=6.0,Z=-3.124871)</strong> and <strong class="source-inline">Relative Rotation</strong> set to <strong class="source-inline">(X=0.0,Y=0.0,Z=90.0)</strong>.</li>
<li>Add the following input actions to <strong class="source-inline">Content\Player\Inputs</strong>, using the knowledge you acquired in <a href="B18531_04.xhtml#_idTextAnchor099"><em class="italic">Chapter 4</em></a>, <em class="italic">Getting Started with Player Input</em>:<ul><li><strong class="bold">IA_Fire (Digital)</strong>:<em class="italic"> Left Mouse Button</em></li><li><strong class="bold">IA_Pistol (Digital)</strong>: <em class="italic">1</em></li><li><strong class="bold">IA_MachineGun (Digital)</strong>:<em class="italic"> 2</em></li><li><strong class="bold">IA_Railgun (Digital)</strong>:<em class="italic"> 3</em></li><li><strong class="bold">IA_PreviousWeapon (Digital)</strong>:<em class="italic"> Mouse Wheel Up</em></li><li><strong class="bold">IA_NextWeapon (Digital)</strong>: <em class="italic">Mouse Wheel Down</em></li></ul></li>
<li>Add the new input actions to <strong class="source-inline">IMC_Player</strong>.</li>
<li>In <strong class="source-inline">MultiplayerFPS.h</strong>, create the <strong class="source-inline">ENUM_TO_INT32(Enum)</strong> macro, which casts an enumeration to <strong class="source-inline">int32</strong>, and the <strong class="source-inline">GET_WRAPPED_ARRAY_INDEX(Index, Count)</strong> macro, which uses array indexing wrapping to make sure the index is within the limits of the array.</li>
<li>Create a header file called <strong class="source-inline">EnumTypes.h</strong> that holds the following enumerations:</li>
</ol>
<p><strong class="bold">EWeaponType</strong>: <strong class="source-inline">Pistol</strong>, <strong class="source-inline">MachineGun</strong>, <strong class="source-inline">Railgun</strong>, <strong class="source-inline">MAX</strong></p>
<p><strong class="bold">EWeaponFireMode</strong>: <strong class="source-inline">Single</strong>, <strong class="source-inline">Automatic</strong></p>
<p><strong class="bold">EAmmoType</strong>: <strong class="source-inline">PistolBullets</strong>, <strong class="source-inline">MachineGunBullets</strong>, <strong class="source-inline">Slugs</strong>, <strong class="source-inline">MAX</strong></p>
<ol>
<li value="17">Create<a id="_idIndexMarker1561"/> a C++ class called <strong class="source-inline">Weapon</strong> that derives from the <strong class="source-inline">Actor</strong> class and has a skeletal mesh component called <strong class="source-inline">Mesh</strong> as the root component. </li>
</ol>
<p>In terms <a id="_idIndexMarker1562"/>of variables, it stores the name, the weapon type, the ammo type, the fire mode, how far the hitscan goes, how much damage the hitscan does when it hits, the fire rate, the animation montage to use when firing, and the sound to play when it has no ammo. In terms of functionality, it needs to be able to start the fire (and also stop the fire, because of the automatic fire mode), which checks whether the player can fire. If it can, then it plays the fire animation in all of the clients and shoots a line trace in the camera position and direction with the supplied length to damage the actor it hits. If it doesn’t have ammo, it will play a sound only on the owning client.</p>
<ol>
<li value="18">Edit <strong class="source-inline">FPSCharacter</strong> so that it supports the new input actions for <strong class="source-inline">Fire</strong>, <strong class="source-inline">Pistol</strong>, <strong class="source-inline">Machine Gun</strong>,  <strong class="source-inline">Railgun</strong>, <strong class="source-inline">Previous Weapon</strong>, and <strong class="source-inline">Next Weapon</strong>. In terms of variables, it needs to store the amount of ammo for each type, the currently equipped weapon, all of the weapons classes and spawned instances, the sound to play when it hits another player, and the sound when it changes weapons. In terms of functions, it needs to be able to equip/cycle/add weapons, manage ammo (add, remove, and get), handle when the character is damaged, play an anim montage on all of the clients, and play a sound on the owning client.</li>
<li>Create <strong class="source-inline">BP_Pistol</strong> from <strong class="source-inline">AWeapon</strong>, place it on <strong class="source-inline">Content\Weapons\Pistol</strong>, and configure it with the following values:<ul><li><strong class="bold">Skeletal Mesh</strong>: <strong class="source-inline">Content\Weapons\SK_Weapon</strong></li><li><strong class="bold">Material</strong>: <strong class="source-inline">Content\Weapons\Pistol\MI_Pistol</strong></li><li><strong class="bold">Name</strong>: <strong class="source-inline">Pistol Mk I</strong></li><li><strong class="bold">Weapon Type</strong>: <strong class="source-inline">Pistol</strong></li><li><strong class="bold">Ammo Type</strong>: <strong class="source-inline">Pistol Bullets</strong></li><li><strong class="bold">Fire Mode</strong>: <strong class="source-inline">Automatic</strong></li><li><strong class="bold">Hit Scan Range</strong>: <strong class="source-inline">9999.9</strong>, <strong class="bold">Hit Scan Damage</strong>: <strong class="source-inline">5.0</strong>, <strong class="bold">Fire Rate</strong>: <strong class="source-inline">0.5</strong></li><li><strong class="bold">Fire Anim Montage</strong>: <strong class="source-inline">Content\Player\Animations\Pistol_Fire_Montage</strong></li><li><strong class="bold">NoAmmoSound</strong>: <strong class="source-inline">Content\Weapons\NoAmmo</strong></li></ul></li>
<li>Create <strong class="source-inline">BP_MachineGun</strong> from <strong class="source-inline">Aweapon</strong>, place it on <strong class="source-inline">Content\Weapons\MachineGun</strong>, and <a id="_idIndexMarker1563"/>configure<a id="_idIndexMarker1564"/> it with the following values:<ul><li><strong class="bold">Skeletal Mesh</strong>: <strong class="source-inline">Content\Weapons\SK_Weapon</strong></li><li><strong class="bold">Material</strong>: <strong class="source-inline">Content\Weapons\MachineGun\MI_MachineGun</strong></li><li><strong class="bold">Name</strong>: <strong class="source-inline">Machine Gun Mk I</strong></li><li><strong class="bold">Weapon Type</strong>: <strong class="source-inline">Machine Gun</strong></li><li><strong class="bold">Ammo Type</strong>: <strong class="source-inline">Machine Gun Bullets</strong></li><li><strong class="bold">Fire Mode</strong>: <strong class="source-inline">Automatic</strong></li><li><strong class="bold">Hit Scan Range</strong>: <strong class="source-inline">9999.9</strong>, <strong class="bold">Hit Scan Damage</strong>: <strong class="source-inline">5.0</strong>, <strong class="bold">Fire Rate</strong>: <strong class="source-inline">0.1</strong></li><li><strong class="bold">Fire Anim Montage</strong>: <strong class="source-inline">Content\Player\Animations\MachineGun_Fire_Montage</strong></li><li><strong class="bold">NoAmmoSound</strong>: <strong class="source-inline">Content\Weapons\NoAmmo</strong></li></ul></li>
<li>Create <strong class="source-inline">BP_Railgun</strong> from <strong class="source-inline">Aweapon</strong>, place it on <strong class="source-inline">Content\Weapons\Railgun</strong>, and configure it with the following values:<ul><li><strong class="bold">Skeletal Mesh</strong>: <strong class="source-inline">Content\Weapons\SK_Weapon</strong></li><li><strong class="bold">Material</strong>: <strong class="source-inline">Content\Weapons\Railgun\MI_Railgun</strong></li><li><strong class="bold">Name</strong>: <strong class="source-inline">Railgun Mk I</strong></li><li><strong class="bold">Weapon Type</strong>: <strong class="source-inline">Railgun</strong></li><li><strong class="bold">AmmoType</strong>: <strong class="source-inline">Slugs</strong></li><li><strong class="bold">Fire Mode</strong>: <strong class="source-inline">Single</strong></li><li><strong class="bold">Hit Scan Range</strong>: <strong class="source-inline">9999.9</strong>, <strong class="bold">Hit Scan Damage</strong>: <strong class="source-inline">100.0</strong>, <strong class="bold">Fire Rate</strong>: <strong class="source-inline">1.5</strong></li><li><strong class="bold">Fire Anim Montage</strong>: <strong class="source-inline">Content\Player\Animations\Railgun_Fire_Montage</strong></li><li><strong class="bold">No Ammo Sound</strong>: <strong class="source-inline">Content\Weapons\NoAmmo</strong></li></ul></li>
<li>Configure <strong class="source-inline">BP_Player</strong> with<a id="_idIndexMarker1565"/> the <a id="_idIndexMarker1566"/>following values:<ul><li><strong class="bold">Weapon Classes</strong> (<strong class="bold">Index 0</strong>: <strong class="source-inline">BP_Pistol</strong>, <strong class="bold">Index 1</strong>: <strong class="source-inline">BP_MachineGun</strong>, <strong class="bold">Index 2</strong>: <strong class="source-inline">BP_Railgun</strong>)</li><li><strong class="bold">Hit Sound</strong>: <strong class="source-inline">Content\Weapons\Hit</strong></li><li><strong class="bold">Weapon Change Sound</strong>: <strong class="source-inline">Content\Weapons\WeaponChange</strong></li><li><strong class="bold">Fire Input Action</strong>: <strong class="source-inline">Content\Player\Inputs\IA_Fire</strong></li><li><strong class="bold">Pistol Input Action</strong>: <strong class="source-inline">Content\Player\Inputs\IA_Pistol</strong></li><li><strong class="bold">Machine Gun Input Action</strong>: <strong class="source-inline">Content\Player\Inputs\IA_MachineGun</strong></li><li><strong class="bold">Railgun Input Action</strong>: <strong class="source-inline">Content\Player\Inputs\IA_Railgun</strong></li><li><strong class="bold">Previous Weapon Input Action</strong>: <strong class="source-inline">Content\Player\Inputs\IA_Previous</strong></li><li><strong class="bold">Next Weapon Input Action</strong>: <strong class="source-inline">Content\Player\Inputs\IA_NextWeapon</strong></li></ul></li>
<li>Make the mesh component block the visibility channel so that it can be hit by the hitscans of the weapons.</li>
<li>Edit <strong class="source-inline">ABP_Player</strong> so that it uses a <em class="italic">Layered blend Per bone</em> node, with <strong class="source-inline">Mesh Space Rotation Blend</strong> enabled, on the <strong class="source-inline">spine_01</strong> bone so that the upper body animations use the <strong class="source-inline">Upper Body</strong> slot.</li>
<li>Edit <strong class="source-inline">WBP_HUD</strong> so <a id="_idIndexMarker1567"/>that it displays <a id="_idIndexMarker1568"/>a white dot crosshair in the middle of the screen, the current weapon, and the ammo count under the <strong class="source-inline">Health</strong> and <strong class="source-inline">Armor</strong> indicators.</li>
</ol>
<p><strong class="bold">Expected output</strong>:</p>
<p>The result should be a project where each client will have weapons with ammo and will be able to use them to fire at and damage other players. You will also be able to select weapons by using the <em class="italic">1</em>, <em class="italic">2</em>, and <em class="italic">3</em> keys and by using the mouse wheel up and down to select the previous and next weapon, respectively:</p>
<div>
<div class="IMG---Figure" id="_idContainer541">
<img alt="Figure 17.12 – The expected result of this activity " height="640" src="image/Figure_17.12_B18531.jpg" width="1612"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.12 – The expected result of this activity</p>
<p class="callout-heading">Note</p>
<p class="callout">The solution to this activity can be found on GitHub here: <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions</a>.</p>
<p>By completing this activity, you should have a good idea of how RPCs, enumerations, and array index wrapping work.</p>
<h1 id="_idParaDest-367"><a id="_idTextAnchor403"/>Summary</h1>
<p>In this chapter, you learned how to use RPCs to allow the server and the clients to execute logic on one another. You also learned how enumerations work in Unreal Engine by using the <strong class="source-inline">UENUM</strong> macro and how to use array index wrapping, which helps you iterate an array in both directions and loops around when you go beyond its index limits.</p>
<p>By completing this chapter’s activity, you learned how to develop a basic playable game where players can shoot each other and switch between their weapons.</p>
<p>In the next chapter, we’ll learn where the instances of the most common gameplay framework classes exist in multiplayer, as well as learn about the <strong class="source-inline">Player State</strong> and <strong class="source-inline">Game State</strong> classes. We’ll also cover some new concepts in the game mode that are used in multiplayer matches, as well as some useful general-purpose, built-in functionality.</p>
</div>
</div></body></html>