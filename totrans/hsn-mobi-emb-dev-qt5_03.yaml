- en: Fluid UI with Qt Quick
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: My television uses Qt. My phone uses Qt. I could buy a car that uses Qt. I can
    fly on a plane that uses Qt on its infotainment center. All these things use Qt
    Quick as their UI. Why? Because it provides faster development—no waiting around
    for compiling—and the syntax is easy to use, but complex enough to customize it
    beyond your imagination.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Quick started out being developed in the Brisbane development office of Trolltech
    as one developer's research project. One of my jobs was to put a demo app of an
    early version of it onto a Nokia N800 tablet, which I had customized to run Qtopia
    instead of Nokia's Maemo interface. This was before Nokia purchased the Trolltech
    company. In my opinion, it was going to become the next generation of Qtopia,
    which had been renamed Qt Extended. Qtopia, by 2006, had been sold on millions
    of phone handsets, including 11 models of phones and 30 various handheld devices. Some
    parts of Qtopia were melded into Qt itself – my favorites, Qt Sensors, and Qt
    Bearer Management, are examples of these. This new XML-like framework became QML
    and Qt Quick.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Quick is a really exciting technology and it seems to be taking over the
    world. It is used in laptops, mobile phones such as the Jolla Sailfish, and medical
    devices, among others things.
  prefs: []
  type: TYPE_NORMAL
- en: It allows rapid development, fluid transformations, animations, and special
    effects. Qt Quick allows developers to design customized animated **User Interfaces**
    (**UI**). Along with the related Qt Quick Controls 2 and Qt Charts APIs, anyone
    can create snazzy mobile and embedded apps.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will design and construct an animated UI. We will also cover
    basic components, such as `Item`, `Rectangle`, and more advanced elements, such
    as `GraphicsView`. We will look at positioning items with anchors, states, animations,
    and transitions, and we will also cover traditional features, such as buttons,
    sliders, and scrollbars. Advanced components showing data in charts, such as BarChart
    and PieChart, will be shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning Qt Quick basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced QML elements in Qt Quick Controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elements for displaying data—Qt Data Visualization and Qt Charts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic animation with Qt Quick
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qt Quick basics – anything goes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Qt Quick is unreal. You should be aware that, at its core, it has only a few
    fundamental building blocks, called components. You will undoubtedly be using
    these components quite often:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Item`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Rectangle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Text`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Image`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TextInput`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MouseArea`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although there are probably hundreds of components and types, these items are
    the most important. There are also several classes of elements for text, positioning,
    states, animation, transitions, and transformations. Views, paths, and data handling
    all have their own elements.
  prefs: []
  type: TYPE_NORMAL
- en: With those building blocks, you can create fantastic UIs that are alive with
    animations.
  prefs: []
  type: TYPE_NORMAL
- en: The language to write Qt Quick applications is quite easy to pick up. Let's
    get started.
  prefs: []
  type: TYPE_NORMAL
- en: QML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Qt Modeling Language** (**QML**) is the declarative programming language
    that Qt Quick uses. Closely aligned with JavaScript, it is the centerpiece language
    for Qt Quick. You can use JavaScript functions within a QML document, and Qt Quick
    will run it.'
  prefs: []
  type: TYPE_NORMAL
- en: We use Qt Quick 2 for this book, as Qt Quick 1.0 is depreciated.
  prefs: []
  type: TYPE_NORMAL
- en: All QML documents need to have one or more `import` statements.
  prefs: []
  type: TYPE_NORMAL
- en: This is about the same as C and C++'s `#include` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most basic QML will have at least one import statement, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `.12` corresponds with Qt's minor version, which is the lowest version the
    application will support.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using properties or components that were added in a certain Qt version, you
    will need to specify that version.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Quick applications are built with building blocks known as elements, or components.
    Some basic types are `Rectangle`, `Item`, and `Text`.
  prefs: []
  type: TYPE_NORMAL
- en: Input interaction is supported through `MouseArea` and other items, such as
    `Flickable.`
  prefs: []
  type: TYPE_NORMAL
- en: One way to start developing a Qt Quick app is by using the Qt Quick app wizard
    in Qt Creator. You can also grab your favorite text editor and start coding away!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go though some of the following concepts that are important to be aware
    of as terms that make up the QML language:'
  prefs: []
  type: TYPE_NORMAL
- en: Components, types, and elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signal connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Components, also known as types or elements, are objects of code and can contain
    both UI and non-UI aspects.
  prefs: []
  type: TYPE_NORMAL
- en: 'A UI component example would be the `Text` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Component properties can be bound to variables, other properties, and values.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dynamic binding is a way to set a property value, which can either be a hardcoded
    static value, or be bound to other dynamic property values. Here, we bind the
    `Text` component''s `id` property to `textLabel`. We can then refer it to this
    element just by using its `id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A component can have none, one, or a few signals that can be utilized.
  prefs: []
  type: TYPE_NORMAL
- en: Signal connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways signals can be handled. The easiest way is by prepending `on`
    and then capitalizing the first letter of the particular signal. For example,
    a `MouseArea` has a signal named `clicked`, which can be connected by declaring
    `onClicked`, and then binding this to a function with curly brackets, `{ }`, or
    even a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `Connections` type to target some other component''s signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The model-view paradigm is not dead with Qt Quick. There are a few elements
    that can show data model views.
  prefs: []
  type: TYPE_NORMAL
- en: Model-view programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt Quick's views are based on a model, which can be defined either with the
    `model` property or as a list of elements within the component. The view is controlled
    by a delegate, which is any UI element capable of showing the data.
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to properties of the model data in the delegate.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s declare a `ListModel`, and fill it with two sets of data.
    `Component` is a generic object that can be declared, and here, I use it to contain
    a `Text` component that will function as the delegate. The model''s data with
    the ID of `carModel` can be referred to in the delegate. Here, there is a binding
    to the `text` property of the `Text` element:'
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found on the Git repository under the `Chapter02-1b` directory,
    in the `cp2` branch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use this model and its delegate in different views. Qt Quick has
    a few different views to choose from:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GridView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PathView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TreeView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at how we can use each of these.
  prefs: []
  type: TYPE_NORMAL
- en: GridView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `GridView` type shows model data in a grid, much like a `GridLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The grid''s layout can be contained with the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`flow`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GridView.FlowLeftToRight`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GridView.FlowTopToBottom`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layoutDirection`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Qt.LeftToRight`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Qt.RightToLeft`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`verticalLayoutDirection`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GridView.TopToBottom`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GridView.BottomToTop`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `flow` property contains the way the data is presented so it becomes wrapped
    to the next line or column when it is appropriate. It controls the way it overflows
    to the next line or column.
  prefs: []
  type: TYPE_NORMAL
- en: The icon for the following example came from [https://icons8.com](https://icons8.com).
  prefs: []
  type: TYPE_NORMAL
- en: '`FlowLeftToRight` means the flow is horizontal. Here''s a pictorial representation
    for `FlowLeftToRight`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/487b0a67-225c-4e49-bd0c-39ac5c91d0fc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For `FlowTopToBottom`, the flow is vertical; here''s a representation of `FlowTopToBottom`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a15cb40a-8dd7-44bb-ab31-55010d39c798.png)'
  prefs: []
  type: TYPE_IMG
- en: When this example gets built and run, you can resize the window by grabbing
    the corner with the mouse. You will get a better idea of how the flow works.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `layoutDirection` property indicates which direction the data will be laid
    out. In the following case, this is `RightToLeft`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50f2bd00-e771-4d1d-98ad-58e9f28575d5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `verticalLayoutDirection` also indicates which direction the data is laid
    out, except this will be vertical. Here''s the `GridView.BottomToTop` representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e34592be-d6ca-4bf0-9537-52fc184cb427.png)'
  prefs: []
  type: TYPE_IMG
- en: ListView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The QML `Listview` is a type of `Flickable` element, meaning that the user can
    swipe or flick left or right to progress through the difference views. `ListView`
    looks different from the `QListView` desktop, as the items are presented in their
    own page, which is accessible by flicking left or right.
  prefs: []
  type: TYPE_NORMAL
- en: 'The layout is handled by these properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`orientation`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Qt.horizontal`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Qt.vertical `'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layoutDirection`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Qt.LeftToRight`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Qt.RightToLeft`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`verticalLayoutDirection`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListView.TopToBottom`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListView.BottonToTop`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: PathView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`PathView` shows model data in a `Path`. Its delegate is a view for displaying
    the model data. It could be a simple drawn line, or an image with text. This can
    produce a flowing wheel type of data presentation. A `Path` can be constructed
    by one or more of the following `path` segments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PathAngleArc`: An arc with radii and center'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PathArc`: An arc with radius'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PathCurve`: A path through a set of points'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PathCubic`: A path on Bézier curve'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PathLine`: A straight line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PathQuad`: A quadratic Bézier curve'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, we use `PathArc` to display a wheel-like item model, using our `carModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found on the Git repository under the `Chapter02-1c` directory,
    in the `cp2` branch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6b1ded4-1eae-4839-ab66-7217df3d6ff3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are a couple of special `path` segments that augment and change attributes
    of the `path`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PathAttribute`: Allows an attribute to be specified at certain points along
    a path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PathMove`: Moves a path to a new position'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TreeView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`TreeView` is perhaps the most recognizable of these views. It looks very similar
    to the desktop variety. It displays a tree structure of its model data. `TreeView`
    has headers, called `TableViewColumn`, which you can use to add a title as well
    as to specify its width. Further customization can be made using `headerDelegate`,
    `itemDelegate`, and `rowDelegate`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sorting is not implemented by default, but can be controlled by a few properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sortIndicatorColumn`: `Int`, indicating the column to be sorted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sortIndicatorVisible`: `Bool` is used to enable sorting'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sortIndicatorOrder`: `Enum` either `Qt.AscendingOrder` or `Qt.DescendingOrder`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gestures and touch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Touch gestures can be an innovative way to interact with your application.
    To use the `QtGesture` class in Qt, you will need to implement the handlers in
    C++ by overriding the `QGestureEvent` class and handling the built-in `Qt::GestureType`.
    In this way, the following gestures can be handled:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Qt::TapGesture`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Qt::TapAndHoldGesture`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Qt::PanGesture`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Qt::PinchGesture`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Qt::SwipeGesture`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Qt::CustomGesture`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Qt::CustomGesture` flag is a special one that can be used to invent your
    own custom gestures.
  prefs: []
  type: TYPE_NORMAL
- en: There is one built-in gesture item in Qt Quick— `PinchArea`.
  prefs: []
  type: TYPE_NORMAL
- en: PinchArea
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`PinchArea` handles pinch gestures, which are commonly used on mobile phones
    to zoom in on an image from within Qt Quick, so you can use simple QML to implement
    it for any `Item`-based element.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `onPinchFinished`, `onPinchStarted`, and `onPinchUpdated` signals,
    or set the `pinch.target` property to the target item to handle the pinch gesture.
  prefs: []
  type: TYPE_NORMAL
- en: MultiPointTouchArea
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `MultiPointTouchArea` is not a gesture, but rather a way to track multiple
    points of contact of the touchscreen. Not all touchscreens support multi-touch.
    Mobile phones usually support multi-touch, and some embedded devices do as well.
  prefs: []
  type: TYPE_NORMAL
- en: To use multi-point touchscreens in QML, there is the `MultiPointTouchArea` component,
    which works a bit like `MouseArea`. It can operate alongside `MouseArea` by setting
    its `mouseEnabled` property to `true`**.** This makes the `MultiPointTouchArea` component
    ignore events from the mouse and only respond to touch events.
  prefs: []
  type: TYPE_NORMAL
- en: Each `MultiPointTouchArea` takes an array of `TouchPoints`. Note the use of
    square brackets, `[ ]`—this denotes that it is an array. You can define one or
    more of these to handle a certain number of `TouchPoints` or fingers. Here, we
    define and handle only three `TouchPoints`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try this on a non-touchscreen, only one green dot will track the touch
    point:'
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found on the Git repository under the `Chapter02-2a` directory,
    in the `cp2` branch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see this when you run it on a non-touchscreen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12f55c55-7461-43af-afd1-543b80a5696c.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice the `PropertyAnimation`? We'll get to that soon; keep reading.
  prefs: []
  type: TYPE_NORMAL
- en: Positioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the myriad of different mobile phones and embedded device sizes currently
    available, the dynamic positioning of elements becomes more important. You may
    not necessarily want things placed randomly on the screen. If you have a great-looking
    layout on a high-DPI iPhone, it may look completely different on a small Android
    device, with images covering half of the screen. Automatic layouts in QML are
    called positioners.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile and embedded devices come with a variety of screen sizes. We can better
    target the size variance by using dynamic layouts.
  prefs: []
  type: TYPE_NORMAL
- en: Layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the positioning elements that arrange the layout of the different
    items that you may want to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Grid`: Positions items in a grid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Column`: Positions items vertically'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Row`: Positions items horizontally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Flow`: Positions items side by side with wrapping'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, there are also the following items:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GridLayout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ColumnLayout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RowLayout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StackLayout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between the `Grid` and the `GridLayout` elements are that the
    layouts are more dynamic in terms of resizing. Layouts have attached properties,
    so you can easily specify aspects of the layout, such as `minimumWidth`, the number
    of columns, or the number of rows. The item can be made to fill itself to the
    grid or fixed width.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use *rigid* layouts which are more like tables. Let's look at using
    layouts that are slight less dynamic and use static sizing.
  prefs: []
  type: TYPE_NORMAL
- en: Rigid layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I use the word *rigid* because they are less dynamic than all the layout items.
    The cell sizes are fixed and based on a percentage of the space where they are
    contained. They cannot span across rows or columns to fill the next column or
    row. Take this code, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'It has no layouts at all, and, when you run it, all the elements get squished
    together on top of one another:'
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found on the Git repository under the `Chapter02-3` directory,
    in the `cp2` branch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the following screenshot, all of the elements are bunched
    up on top of each other without positioning:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0464a11d-5686-4af5-9f0a-75419a45019b.png)'
  prefs: []
  type: TYPE_IMG
- en: This was probably not what the design team had dreamed up. Unless, of course,
    they did, and then wanted to use a `PropertyAnimation` value to animate the elements
    moving to their proper layout positions.
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens when we add a `Column` QML element? Examine the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found on the Git repository under the `Chapter02-3a` directory,
    in the `cp2` branch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When you build this example, the layout looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/299cad9c-5b13-4d19-bfc4-651581471b0c.png)'
  prefs: []
  type: TYPE_IMG
- en: That's more like what the designer's mock-ups look like! (I know; cheap designers.)
  prefs: []
  type: TYPE_NORMAL
- en: '`Flow` is another layout item we can use.'
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found on the Git repository under the `Chapter02-3b`directory,
    in the `cp2` branch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, from our preceding code, change `Column` to `Flow`, add some anchor items,
    and build, then run on a simulator to get a feel for how the `Flow` item works
    on a small screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/897f3421-5af1-49b5-8b05-eab237eb16a7.png)'
  prefs: []
  type: TYPE_IMG
- en: The `Flow` type will wrap its contents around if needed, and, indeed, it has
    wrapped here on the last `Text` element. If this were to be re-oriented to the
    landscape orientation or on a tablet, there would be no need to wrap, and all
    of these elements would be on one row at the top.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instead of using a `Grid` element to lay out items, there is also `GridLayout`,
    which can be used to customize the layout. In terms of targeting mobile and embedded
    devices that come with different screen sizes and device orientations, it is probably
    better to use `GridLayout`, `RowLayout`, and `ColumnLayout`. Using these, you
    will gain the ability to use its attached properties. Here is a list of attached
    properties you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Layout.alignment`  | A `Qt.Alignment` value specifying alignment of item
    within the cell |'
  prefs: []
  type: TYPE_TB
- en: '| `Layout.bottomMargin`  | Bottom margin of space |'
  prefs: []
  type: TYPE_TB
- en: '| `Layout.column`  | Specifies column position |'
  prefs: []
  type: TYPE_TB
- en: '| `Layout.columnSpan`  | How many columns to spreads out to |'
  prefs: []
  type: TYPE_TB
- en: '| `Layout.fillHeight`  | If `true`, item fills to the height |'
  prefs: []
  type: TYPE_TB
- en: '| `Layout.fillWidth` | If `true`, item fills to the width |'
  prefs: []
  type: TYPE_TB
- en: '| `Layout.leftMargin` | Left margin of space |'
  prefs: []
  type: TYPE_TB
- en: '| `Layout.margins ` | All margins of space |'
  prefs: []
  type: TYPE_TB
- en: '| `Layout.maximumHeight ` | Maximum height of item |'
  prefs: []
  type: TYPE_TB
- en: '| `Layout.maximumWidth ` | Maximum width of item |'
  prefs: []
  type: TYPE_TB
- en: '| `Layout.minimumHeight` | Minimum height of item |'
  prefs: []
  type: TYPE_TB
- en: '| `Layout.minimumWidth` | Minimum width of item |'
  prefs: []
  type: TYPE_TB
- en: '| `Layout.preferredHeight` | Preferred height of item |'
  prefs: []
  type: TYPE_TB
- en: '| `Layout.preferredWidth` | Preferred width of item |'
  prefs: []
  type: TYPE_TB
- en: '| `Layout.rightMargin`  | Right margin of space |'
  prefs: []
  type: TYPE_TB
- en: '| `Layout.row` | Specifies row position |'
  prefs: []
  type: TYPE_TB
- en: '| `Layout.rowSpan`  | How many rows to spread out to |'
  prefs: []
  type: TYPE_TB
- en: '| `Layout.topMargin`  | Top margin of space |'
  prefs: []
  type: TYPE_TB
- en: 'In this code, we use `GridLayout` to position the three `Text` items. The first
    `Text` item will span, or fill, two rows so that the second `Text` will be in
    the second row:'
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found on the Git repository under the `Chapter02-3c` directory,
    in the `cp2` branch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Positioning is a way to get dynamically changing applications and allow them
    to work on various devices without having to change the code. `GridLayout` works
    much like a layout, but with expanded capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at how we can dynamically position these components using
    `Anchors`.
  prefs: []
  type: TYPE_NORMAL
- en: Anchors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Anchors` are related to positioning, and are a way to position elements relative
    to each other. They are a way to dynamically position UI elements and layouts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'They use the following points of contact:'
  prefs: []
  type: TYPE_NORMAL
- en: '`left`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`right`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`top`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bottom`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`horizontalCenter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`verticalCenter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take, for example, two images; you can put them together like a puzzle by specifying
    anchor positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This will position the left side of `image2` at the right side of `image1`.
    If you were to add `anchors.top: parent.top` to `image1`, both of these items
    would then be positioned relative to the top of the parent position. If the parent
    was a top-level item, they would be placed at the top of the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: Anchors are a way to achieve columns, rows, and grids of components that are
    relative to some other component. You can anchor items diagonally and anchor them
    apart from each other, among other things.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `anchor` property of `Rectangle`, called `fill`, is a special
    term meaning top, bottom, left, and right, and is bound to its parent. This means
    that it will fill itself to the size of its parent.
  prefs: []
  type: TYPE_NORMAL
- en: Using `anchors.top` indicates an anchor point for the top of the element, meaning
    that it will be bound to the parent component's top position. For example, a `Text` component
    will sit above of the `Rectangle` component.
  prefs: []
  type: TYPE_NORMAL
- en: To get a component such as `Text` to be centered horizontally, we use the `anchor.horizontal` property
    and bind it with the `parent.horizontalCenter` positional property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we anchor the `Text` label to the top center of the `Rectangle` label,
    itself anchored to `fill` its parent, which is the `Window`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The source code can be found on the Git repository under the `Chapter02` directory,
    in the `cp2` branch.
  prefs: []
  type: TYPE_NORMAL
- en: The `Window` component was provided by the Qt Quick app wizard and is not visible
    by default, so the wizard set the `visible` property to `true` as we need see
    it. We will use `Window` as the parent for the `Rectangle` component. Our `Rectangle` component
    will provide an area for our `Text` component, which is a simple label type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each component has its own properties to fiddle with. By fiddling, I mean binding.
    For instance, the `color: "purple"` line is binding the color referenced as `"purple"` to
    the `color` property of the `Text` element. These bindings do not have to be static;
    they can be dynamically changed, and the property''s value that they are bound
    to changes as well. This value binding will persist until the property is written
    with another value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The background of this application is boring. How about we add a gradient there?
    Under the closing bracket for the `Text` component, but still within the `Rectangle`, add
    this gradient. `GradientStop` is a way to specify a color at a certain point in
    the gradient. The `position` property is a percent fraction point from zero to
    one, corresponding to where the color should start. The gradient will fill in
    the gap in between:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The source code can be found on the Git repository under the `Chapter02-1` directory,
    in the `cp2` branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the gradient starts with the green color at the top, smoothly
    blends to purple, then yellow, and finishes at black:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4eb99784-f4a0-4648-b9b0-eb9410b832c1.png)'
  prefs: []
  type: TYPE_IMG
- en: Easy peasy, lemon squeezy!
  prefs: []
  type: TYPE_NORMAL
- en: Layouts and anchors are important to be able to control the UIs. They provide
    an easy way to deal with differences in display size and orientation changes on
    hundreds of different devices with different screen sizes. You could have a QML
    file work on all displays, although it is recommended to use different layouts
    for extremely different devices. An application could work fine on a tablet, or
    even a phone, but try to place it on a watch or other embedded device, and you
    will run into trouble accessing many details that your users can use.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Quick has many building blocks to create useful applications on any device.
    What happens when you don't want to create all the UI elements yourself? That
    is where Qt Quick Controls come into play.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Quick Controls 2 button, button, who's got the button?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a while in the life of Qt Quick, there were only basic components, such
    as `Rectangle` and `Text`. Developers had to create their own implementations
    of buttons, dials, and just about every common UI item. As it matured, it also
    grew elements such as `Window` and even `Sensor` elements. There were always rumblings
    about having a set of common UI elements available. Eventually, common UI elements
    were released.
  prefs: []
  type: TYPE_NORMAL
- en: Spotlight on Qt Quick Controls. No more having to create your own buttons and
    other components, yay! And developers rejoiced!
  prefs: []
  type: TYPE_NORMAL
- en: Then, they found a better way to do things and released Qt Quick Controls 2!
  prefs: []
  type: TYPE_NORMAL
- en: Qt Quick Controls comes in two versions, Qt Quick Controls and Qt Quick Controls
    2\. Qt Quick Controls (the original one) has been depreciated by Qt Quick Controls
    2\. Any new use of these components should use Qt Quick Controls 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access all kinds of common UI elements, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Buttons`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Containers`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Input`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Menu`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Radio buttons`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Progress bar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Popups`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's examine a simple Qt Quick Controls 2 example.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `ApplicationWindow` has attached `menuBar`, `header`, and `footer` properties
    that you can use to add whatever you need to them. Since an `ApplicationWindow`
    is not visible by default, we almost always need to add `visible: true`.'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will add a traditional menu with `TextField` in the header.
  prefs: []
  type: TYPE_NORMAL
- en: 'The menu has an `onTriggered` signal, which is used here to run the `open()`
    function of `MessageDialog`:'
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found on the Git repository under the `Chapter02-4` directory,
    in the `cp2` branch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what our code would result in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/550a8d92-202c-4a7d-a8f6-93b153a008c9.png)'
  prefs: []
  type: TYPE_IMG
- en: Oooooh – fancy!
  prefs: []
  type: TYPE_NORMAL
- en: Qt Quick Controls 2 has different styles to choose from – `Default`, `Fusion`,
    `Imagine`, `Material`, and `Universal`. This can be set in the C++ backend as `QQuickStyle::setStyle("Fusion");`. I
    presume you do have a C++ backend, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'Views that can come in handy on mobile and embedded devices are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ScrollView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StackView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SwipeView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These can be helpful on small screens, as they provide a way to easily view
    and access several pages without too much hassle. A `Drawer` element is also handy
    and can provide a way to implement a menu or a toolbar that sticks to the side.
  prefs: []
  type: TYPE_NORMAL
- en: Buttons are awesome, and Qt Quick Controls 2 has buttons. It even has the `RoundButton`
    component, as well as icons for the buttons! Before Qt Quick Controls, we had
    to roll these up ourselves. At the same time, it is nice that we can implement
    these things to do what we need with little effort. And now with even less effort!
  prefs: []
  type: TYPE_NORMAL
- en: Let's put some of these to the test and expand upon our last example.
  prefs: []
  type: TYPE_NORMAL
- en: 'I like `SwipeView`, so let''s use that, with two `Page` elements as children
    of `SwipeView`:'
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found on the Git repository under the `Chapter02-5` directory,
    in the `cp2` branch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: I think that a `PageIndicator` at the bottom to indicate which page we are on
    gives the user some visual feedback for navigation. We tie in `PageIndicator` by
    binding the `count` of `SwipeView` and `currentIndex` properties to its properties
    of the same name. How convenient!
  prefs: []
  type: TYPE_NORMAL
- en: Instead of `PageIndicator`, we could just as easily use `TabBar`.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can customize the look and feel of just about every Qt Quick Control 2
    component. You can override different properties of the controls, such as `background`.
    In the previous example code, we customized the `Page` header. Here, we override
    the background to a button, add our own `Rectangle`, color it, give it a border
    with a contrasting color, and make it rounded at the ends by using the `radius`
    property. Here''s how it would work:'
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found on the Git repository under the `Chapter02-5` directory,
    in the `cp2` branch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/bc0f81cf-6c19-4d18-acee-a3c87f2f2b67.png)'
  prefs: []
  type: TYPE_IMG
- en: Customizing is easy with Qt Quick. It was built with customizing in mind. The
    ways are endless. Nearly all the Qt Quick Controls 2 elements have visual elements
    that can be customized including most of the background and content items, although
    not all.
  prefs: []
  type: TYPE_NORMAL
- en: These controls seem to be best on a desktop, but they can be customized to work
    well on mobile and embedded devices. The `ScrollBar` property of `ScrollView` can
    be made larger in width on touchscreens.
  prefs: []
  type: TYPE_NORMAL
- en: Show your data – Qt Data Visualization and Qt Charts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt Quick has a convenient way to show data of all kinds. The two modules, Qt
    Data Visualization and Qt Charts, can both supply integral UI elements. They are
    similar, except Qt Data Visualization displays data in 3D.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Charts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt Charts shows 2D graphs and uses the Graphics View framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'It adds the following chart types:'
  prefs: []
  type: TYPE_NORMAL
- en: Area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Box-and-whiskers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Candlestick
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line: a simple line chart'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pie: pie slices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Polar: a circular line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Scatter: a collection of points'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spline: a line chart with curved points'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example from Qt shows a few different charts that are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/386351c0-be88-4103-830c-265c626aafb0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Each graph or chart has at least one axis and can have the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: Bar axis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Category
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Date-time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logarithmic value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qt Charts requires a `QApplication` instance. If you use the Qt Creator wizard
    to create your app, it uses a `QGuiApplication` instance by default. You will
    need to replace the `QGuiApplication` instance in `main.cpp` to `QApplication`,
    and also change the `includes` file.
  prefs: []
  type: TYPE_NORMAL
- en: You can use grid lines, shades, and tick marks on the axis, which can also be
    shown in these charts.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how to create a simple BarChart.
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found on the Git repository under the `Chapter02-6` directory,
    in the `cp2` branch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'See how nice the charts look? Have a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8376dc5b-21cf-4c0d-a654-25cde7f49cda.png)'
  prefs: []
  type: TYPE_IMG
- en: Qt Data Visualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt Data Visualization is similar to Qt Charts but presents data in 3D form.
    It can be downloaded through Qt Creator's Maintenance Tool app. It is available
    for use with Qt Widget and Qt Quick. We will be working with the Qt Quick version.
    It uses OpenGL to present 3D graphs of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are targeting mobile phones and embedded devices, we talk about using
    OpenGL ES2\. There are some features of Qt Data Visualization that do not work
    with OpenGl ES2, which is what you will find on mobile phones:'
  prefs: []
  type: TYPE_NORMAL
- en: Antialiasing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flat shading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shadows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Volumetric objects that use 3D textures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's try using a `Bars3D` with data from the total amount of rain in certain
    Australian cities used in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: I set the theme to `Theme3D.ThemeQt`, which is a green-based theme. Add a few
    customizations such as font size to be able to see the content better on small
    mobile displays.
  prefs: []
  type: TYPE_NORMAL
- en: '`Bar3DSeries` will manage the visual elements such as labels for rows, columns,
    and the data, which here is the total rain amount for that year. `ItemModelBarDataProxy`
    is the proxy for displaying the data. The model data here is a `ListModel` containing
    `ListElements` of cities rainfall data for the previous three years. We will use
    the same data from the previous Qt Charts example so you can compare the differences
    in the way the bar charts display their data:'
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found on the Git repository under the `Chapter02-7` directory,
    in the `cp2` branch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run this on a touchscreen device, and then move the chart around in
    3D!:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70a2d639-c4f5-470f-bdd7-58ebf20a5806.png)'
  prefs: []
  type: TYPE_IMG
- en: You can grab the graph and spin it around to see the data from different perspectives.
    You can zoom in and back out, as well.
  prefs: []
  type: TYPE_NORMAL
- en: The `QtDataVisualization` module also has scatter and surface graphs that show
    data in 3D.
  prefs: []
  type: TYPE_NORMAL
- en: Animate it!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is where it gets gloriously complicated. There are various types of animations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ParallelAnimation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SmoothedAnimation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PauseAnimation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SequentialAnimation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, `PropertyAction` and `ScriptAction` can be used. A `PropertyAction` is
    a change to any property that happens without an animation. We learned about `ScriptAction` in
    the last section on *States*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also animation types that operate on various values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AnchorAnimation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ColorAnimation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NumberAnimation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OpacityAnimator`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PathAnimation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ParentAnimation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PropertyAnimation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RotationAnimation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SpringAnimation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Vector3DAnimation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Behavior` can be used to specify an animation for a property change.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how some of these can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Transitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Transitions and states are explicitly tied together. A `Transition` animation
    happens when a `State` change occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `State` change can handle different kinds of changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AnchorChanges`: Changes to anchor layouts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ParentChanges`: Changes to parenting (as in reparenting)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PropertyChanges`: Changes to the target''s properties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can even run JavaScript on `State` changes using `StateChangeScript` and
    `ScriptAction`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define different `states`, an element has a `states` array of `State` elements
    that can be defined. We will add a `PropertyChanges`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Target properties can be just about anything—`opacity`, `position`, `color`,
    `width`, or `height`. If an element has a changeable property, the chances are
    that you can animate it in a `State` change.
  prefs: []
  type: TYPE_NORMAL
- en: 'As I mentioned before, to run a script in a `State` change, you can define
    a `StateChangeScript` in the `State` element that you want it to run in. Here,
    we simply output some logging text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Just imagine the possibilities! We haven't even presented animations! We will
    go there next.
  prefs: []
  type: TYPE_NORMAL
- en: Animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animation can spice up your apps in wonderful ways. Qt Quick makes it almost
    trivial to animate different aspects of your application. At the same time, it
    allows you to customize them into unique and more complicated animations.
  prefs: []
  type: TYPE_NORMAL
- en: PropertyAnimation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`PropertyAnimation` animates an item''s changeable property. Typically, this
    is x or y color, or it can be some other property of any item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `Behavior` specifier implies that when the `activeFocus` is on `myItem`,
    the `color` will change to `green`.
  prefs: []
  type: TYPE_NORMAL
- en: NumberAnimation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`NumberAnimation` derives from `PropertyAnimation`, but only works on properties
    that have a `qreal` changeable value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This will move the `myOtherItem` element's `y` position to 65 over a 250-microsecond
    period of time.
  prefs: []
  type: TYPE_NORMAL
- en: Some of these animation elements control how other animations are played, including `SequentialAnimation` and `ParallelAnimation`.
  prefs: []
  type: TYPE_NORMAL
- en: SequentialAnimation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`SequentialAnimation` is an animation that runs other animation types consecutively, one
    after the other, like a numbered procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In this instance, the animation that would play first is `ColorAnimation`,
    and, once that is finished, it would play `NumberAnimation`. Move the `myOtherItem` element''s
    `x` property to position `35`, and then move its `y` property to position `65`,
    in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f45daa0e-b695-4a4d-a3a2-42e541872458.png)'
  prefs: []
  type: TYPE_IMG
- en: You can use either `on <property>` or `properties` to target a property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also available is the `when` keyword, which denotes when something can take
    place. It can be used with any property if it evaluates to `true` or `false`,
    such as `when: y > 50`. You could use it, for example, on the `running` property.'
  prefs: []
  type: TYPE_NORMAL
- en: ParallelAnimation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ParallelAnimation` plays all its defined animations at the same time, asynchronously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: These are the same animations, but this would perform them at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is interesting to note that this animation would move `myOtherItem` to position
    `35` and `65` directly from where the current position is, as if it were one step:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5dd76d12-c152-4558-bd01-f58932a46035.png)'
  prefs: []
  type: TYPE_IMG
- en: SpringAnimation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`SpringAnimation` animates items with a spring-like motion. It has two properties
    to pay attention to—`spring` and `damping`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring`: A `qreal` value that controls how energetic the bounce is'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`damping`:How quickly the bouncing stops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mass`:Adds a weight to the bounce, so it acts as if there is gravity and weight'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`velocity`:Specifies the maximum velocity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`modulus`: The value at which a value will wrap around to zero'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`epsilon`: Amount of rounding to zero'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source code can be found on the Git repository under the `Chapter02-8` directory,
    in the `cp2` branch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a red square follows the finger or mouse cursor around, bouncing
    up and down as it goes. When the user clicks on the app, the red square will move
    to position `35` and `65`. A `spring` value of `10` makes it very bouncy, but
    the `mass` of `10` on the `y` axis will cause it to bounce like it has more weight.
    The lower the `damping` value is, the more quickly it will come to rest. Here,
    the `damping` value is much greater on the `x` axis, so it will tend to keep bouncing
    up and down more than side to side.
  prefs: []
  type: TYPE_NORMAL
- en: Easing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I should mention easing at this point. Every Qt Quick animation has an `easing` property.
    Easing is a way to specify the speed at which the animation progresses. The default
    `easing` value is `Easing.Linear`. There are 40 different `easing` properties,
    which are probably better seen running in an example than seen here demonstrated
    with graphs.
  prefs: []
  type: TYPE_NORMAL
- en: You can see a demonstration of this at my GitHub web server by the magic of
    Qt for WebAssembly at
  prefs: []
  type: TYPE_NORMAL
- en: '[https://lpotter.github.io/easing/easing.html](https://lpotter.github.io/easing/easing.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Qt for WebAssembly brings Qt apps to the web. Firefox has the fastest WebAssembly
    implementation at the time of writing this book. We will discuss Qt for WebAssembly
    in [Chapter 14](04b4eb0e-2f09-4205-9d2f-ac17ff6a958d.xhtml), *Universal Platform
    for Mobiles and Embedded Devices*.
  prefs: []
  type: TYPE_NORMAL
- en: SceneGraph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scene Graph is based on OpenGL for Qt Quick. On mobile and embedded devices,
    it is usually OpenGL ES2\. As I mentioned before, Scene Graph caters to manage
    a sizable number of graphics. OpenGL is a huge subject worthy of its own book—in
    fact, tons of books—about OpenGL ES2 programming. I won't go into too much detail
    about it here, but will just mention that OpenGL is available for mobile phones
    and embedded devices, depending on the hardware.
  prefs: []
  type: TYPE_NORMAL
- en: If you are planning to use Scene Graph, most of the heavy lifting will be done
    in C++. You should already be familiar with how to use C++ and QML together, as
    well as OpenGL ES2\. If not, Qt has great documentation on it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt Quick is ready-made for using on mobile and embedded devices. From the simple
    building blocks of basic Qt Quick items to 3D data charts, you can write complicated
    animated applications using various data sets and presentations in QML.
  prefs: []
  type: TYPE_NORMAL
- en: You should now be able to use basic components such as `Rectangle` or `Text`
    to create Qt Quick applications that use dynamic variable bindings and signals.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered how to use `anchors` to position the components visually and
    will be able to accept changing orientations and various screen sizes of target
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: You are now able to use more conventional-looking components such as ready-made
    `Button`, `Menu` and `ProgressBar` instances, as well as more advanced graphical
    elements such as `PieChart` and `BarChart`.
  prefs: []
  type: TYPE_NORMAL
- en: We also examined using different animation methods available in Qt Quick, such
    as `ProperyAnimation` and `NumberAnimation`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about using particles and special graphical
    effects.
  prefs: []
  type: TYPE_NORMAL
