- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Architectural Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构模式
- en: Starting an embedded project from scratch means progressively stepping towards
    the final solution by going through all the research and development phases and
    considering the synergy among all the parts involved.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从零开始启动嵌入式项目意味着通过经历所有研究和开发阶段，并考虑所有参与部分的协同作用，逐步走向最终解决方案。
- en: Software development needs to evolve accordingly throughout these phases. In
    order to get the best results without excessive overhead, there are a few best
    practices to follow and tools to discover.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发需要在这些阶段中相应地发展。为了在不产生过多开销的情况下获得最佳结果，有一些最佳实践要遵循，以及一些工具要发现。
- en: This chapter describes a possible approach toward configuration-management tools
    and design patterns, based on real-life experiences. Describing this approach
    may help you to understand the dynamics of working in a team focused on producing
    an embedded device or solution.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了一种基于实际经验的可能的方法，用于配置管理工具和设计模式。描述这种方法可能有助于您理解在一个专注于生产嵌入式设备或解决方案的团队中工作的动态。
- en: 'We will discuss the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论以下主题：
- en: Configuration management
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置管理
- en: Source code organization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码组织
- en: The life cycle of an embedded project
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入式项目的生命周期
- en: Security considerations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全考虑
- en: By the end of the chapter, you will gain an overview of the architectural patterns
    useful for designing the system based on the specifications and the platform limits.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解基于规范和平台限制设计系统时有用的架构模式概述。
- en: Configuration management
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置管理
- en: When working as a team, coordination and synchronization can be optimized to
    improve efficiency. Tracking and controlling the development life cycle smoothens
    the development flow, cutting downtime and costs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为团队工作时，协调和同步可以优化以提高效率。跟踪和控制开发生命周期可以平滑开发流程，减少停机时间和成本。
- en: 'The most important tools known to help manage the software life cycle are the
    following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 已知的最重要工具，用于帮助管理软件生命周期如下：
- en: Revision control
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本控制
- en: Issue tracking
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题跟踪
- en: Code reviews
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码审查
- en: Continuous integration
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成
- en: Different options exist for the four categories. The source code is synchronized
    among developers through a revision control system. **Issue tracking systems**
    (**ITSs**) usually consist of web platforms that keep track of the activities
    and known bugs of the system. Code reviews can be encouraged with specific web-based
    tools and enforced through rules on the revision control systems.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于四个类别，存在不同的选项。源代码通过版本控制系统在开发者之间同步。**问题跟踪系统（ITSs**）通常由跟踪系统活动和已知错误的网络平台组成。可以通过特定的基于网络的工具鼓励代码审查，并通过版本控制系统的规则强制执行。
- en: Continuous integration tools ensure that build and test execution tasks are
    scheduled to automatically execute, periodically or upon changes in the code,
    collecting test results and notifying the developers about regressions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成工具确保构建和测试执行任务被安排为自动执行，定期或在代码更改时执行，收集测试结果，并通知开发者关于回归的情况。
- en: Revision control
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本控制
- en: No matter whether you are working alone or in a large development team, properly
    keeping track of the development progress is extremely important. **Revision control**
    tools allow developers to roll back failed experiments at any time with the press
    of a button, and visiting its history gives a clear view of how the project is
    evolving at any time.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是单独工作还是在大型开发团队中，正确跟踪开发进度都极其重要。**版本控制**工具允许开发者通过按按钮随时回滚失败的实验，并查看其历史记录，以清晰地了解项目在任何时候是如何演变的。
- en: A **revision control system**, also known as a **version control system**, or
    **VCS**, encourages cooperation by making merge operations easier. The most updated
    official version is referred to as a **trunk**, **master**, or **main** branch,
    depending on the VCS in use. VCSs offer, among other things, fine-grained access
    control and authorship attribution down to a single commit.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**版本控制系统**，也称为**版本控制系统**或**VCS**，通过简化合并操作来鼓励合作。最更新的官方版本被称为**主干**、**主**或**主要**分支，具体取决于所使用的VCS。VCSs提供，包括其他事物，细粒度的访问控制和作者归属，直至单个提交。'
- en: One of the most modern and widely used open source VCSs is Git. Originally created
    as the VCS for the Linux kernel, Git offers a range of features but, most importantly,
    provides a flexible mechanism to allow switching among different versions and
    feature branches quickly and reliably and facilitates the integration of conflicting
    modifications in the code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最现代和最广泛使用的开源 VCS 之一是 Git。最初作为 Linux 内核的 VCS 而创建，Git 提供了一系列功能，但最重要的是，它提供了一个灵活的机制，允许快速且可靠地在不同版本和功能分支之间切换，并促进了代码中冲突修改的集成。
- en: Note
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Git terminology is used in this book when describing specific activities related
    to the VCS.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述与版本控制系统（VCS）相关的特定活动时，本书使用了 Git 术语。
- en: 'A **commit** is a VCS action that results in a new version of the repository.
    The repository keeps track of the sequence of commits and the changes introduced
    in each version in a hierarchical structure:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**提交**是版本控制系统中的一个操作，它会导致仓库出现新版本。仓库按照分层结构跟踪提交序列和每个版本中引入的更改：'
- en: '**Branch**: A linear sequence of commits is a branch.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分支**：提交的线性序列称为分支。'
- en: '**HEAD**: The latest version in a branch is called HEAD.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HEAD**：分支中的最新版本称为 HEAD。'
- en: '**master**: Git refers to the main development branch as a master. The master
    branch is the main focus of the development. Bug fixes and minor changes may be
    committed directly to the master.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**master**：Git 将主开发分支称为 master。master 分支是开发的主要焦点。错误修复和较小更改可以直接提交到 master。'
- en: '**Feature branches**: These are created for self-contained tasks in progressing
    and ongoing experiments, which will eventually be merged into the master. When
    not abused, feature branches are a perfect fit when working in a smaller sub-team
    on a task and can simplify the code review process, allowing developers to work
    simultaneously on separate branches, and concentrate the validation of completed
    tasks as single **merge** requests.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能分支**：这些分支用于进行独立任务，在持续进行的实验中，最终将被合并到主分支。在不被滥用的情况下，功能分支非常适合在较小的子团队中处理任务，可以简化代码审查过程，允许开发者同时在不同的分支上工作，并将完成的任务的验证集中为单个
    **合并** 请求。'
- en: A **merge operation** consists of joining together two versions from two different
    branches that may have diverged and present conflict in the code throughout the
    development. Some merges are trivial and are automatically resolved by the VCS,
    while others may require manual fixing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**合并操作**是指将两个不同分支上的两个版本合并在一起，这两个分支在开发过程中可能已经分叉，并在代码中存在冲突。一些合并是微不足道的，可以由版本控制系统自动解决，而其他合并可能需要手动修复。'
- en: Using meaningful and verbose commit messages improves the readability of the
    history of the repository and can help to track regressions later on. **Tags**
    can be used to track intermediate versions that are released and distributed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用有意义的详细提交信息可以提高仓库历史的可读性，并有助于跟踪后续的回归。**标签**可以用于跟踪已发布和分发的中间版本。
- en: Tracking activities
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪活动
- en: Keeping track of activities and tasks can be simplified by using ITS. Some tools
    can be directly linked to the revision control system so that tasks can be linked
    to specific commits in the repository and vice versa. This is, in general, a good
    idea, as it is possible to have a good overview of what has been changed to accomplish
    a specific task.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ITS 可以简化跟踪活动和任务。一些工具可以直接链接到版本控制系统，以便将任务链接到仓库中的特定提交，反之亦然。这通常是一个好主意，因为可以很好地了解为了完成特定任务而进行的更改。
- en: At first, tasking out the specifications into short activities facilitates the
    approach to development. Ideally, tasks are as small as possible and may be grouped
    by category. Later on, priorities can be set based on intermediate goals and taking
    into account the availability of the final hardware. Tasks created should be grouped
    into intermediate milestones, which some tools refer to as blueprints, so that
    the overall progress towards an intermediate deliverable can be measured based
    on the progress made on single tasks.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将规范分解为简短的活动有助于开发方法。理想情况下，任务尽可能小，可以按类别分组。随后，可以根据中间目标和考虑最终硬件的可用性来设置优先级。创建的任务应分组到中间里程碑中，一些工具将其称为蓝图，这样就可以根据单个任务所取得的进展来衡量向中间交付成果的整体进度。
- en: ITS can be used to track actual issues in the project. A **bug report** should
    be extensive enough for other developers to understand the symptoms and reproduce
    the behavior that proves that there is a defect in the code. Ideally, final users
    and early adopters should be able to add new issues to the tracking system, so
    the tracking system can be used to track all communication with the development
    team. Community-based open source projects should provide a publicly accessible
    ITS interface to users.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ITS 可以用于跟踪项目中的实际问题。**错误报告**应该足够详细，以便其他开发者能够理解症状并重现行为，从而证明代码中存在缺陷。理想情况下，最终用户和早期采用者应该能够向跟踪系统添加新问题，以便跟踪系统可以用于跟踪与开发团队的全部沟通。基于社区的开放源代码项目应向用户提供公开可访问的
    ITS 接口。
- en: Bug-fixing activities generally get a higher priority than development tasks,
    except in a few cases, for instance, when the bug is the effect of a temporary
    approximation done by an intermediate prototype, which is expected to be fixed
    in the next iteration. When a bug affects the behavior of the system, which was
    proven to work beforehand, it must be marked as a regression. This is important
    because regressions can usually be handled differently than normal bugs, as it
    is possible to track them down to a single commit using revision control tools.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 修复错误的活动通常比开发任务具有更高的优先级，除非在少数情况下，例如，当错误是中间原型临时近似的结果，预计将在下一次迭代中修复。当一个错误影响了之前证明可以正常工作的系统行为时，它必须被标记为回归。这很重要，因为回归通常可以与普通错误不同处理，因为可以使用版本控制工具将它们追溯到单个提交。
- en: '**Repository control** platforms provide several tools, including source code
    history browsing and the issue-tracking features described earlier. GitLab is
    a free and open source implementation of such repository control platforms, which
    can be installed to run as a self-hosted solution. Community projects are often
    hosted on social coding platforms, such as GitHub, which aim to facilitate contributions
    to open source and free software projects.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**仓库控制**平台提供多种工具，包括源代码历史浏览和之前描述的问题跟踪功能。GitLab 是此类仓库控制平台的免费开源实现，可以安装并作为自托管解决方案运行。社区项目通常托管在社交编码平台，如
    GitHub，这些平台旨在促进对开源和免费软件项目的贡献。'
- en: Code reviews
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码审查
- en: Often integrated into ITS tools, **code reviews** facilitate team cooperation
    by encouraging the critical analysis of the changes proposed to the code base,
    which can be useful to detect potential issues before the proposed changes make
    it to the master branch. Depending on the project requirements, code reviews may
    be recommended, or even enforced by the team, to increase the quality of the code
    and early detection of defects by human inspection.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通常集成到 ITS 工具中，**代码审查**通过鼓励对代码库中提出的更改进行批判性分析来促进团队合作，这有助于在提议的更改进入主分支之前检测潜在问题。根据项目要求，代码审查可能被推荐，甚至由团队强制执行，以提高代码质量并通过人工检查早期发现缺陷。
- en: When properly integrated with the VCS, it is possible to set a threshold of
    mandatory positive reviews from other members of the team before the commit is
    considered for merging. It is possible to mandate the review of every single commit
    in the master branch, using tools such as **Gerrit**, integrated with the VCS.
    Depending on the size of the contribution, this mechanism can introduce some unnecessary
    overhead, so, in most cases, it may be more appropriate to group the changes introduced
    by a branch altogether to facilitate the review when the branch is proposed for
    merging into the master. Mechanisms based on merge requests give the reviewers
    an overview of the changes introduced during the entire development of the modification
    proposed. In the case of open source projects that accept external contributions,
    code reviews are a necessary step to validate the changes coming from less trusted
    contributors, or in general, from outside the team of maintainers. Code reviews
    are the most powerful tool to prevent malicious code that may be disguised and
    could not be detected by automatic test and code analysis utilities.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当与版本控制系统（VCS）正确集成时，可以在提交被认为可以合并之前，设置来自团队成员的强制正面审查的阈值。可以使用与VCS集成的工具，如**Gerrit**，强制要求对主分支上的每个提交进行审查。根据贡献的大小，这种机制可能会引入一些不必要的开销，因此，在大多数情况下，将分支引入主分支时，将分支引入主分支引入的更改分组在一起可能更合适，以方便审查。基于合并请求的机制使审查者可以概述整个修改开发过程中引入的更改。在接受外部贡献的开源项目中，代码审查是验证来自不太受信任的贡献者或通常来自维护者团队外部的更改的必要步骤。代码审查是防止可能被伪装且无法通过自动测试和代码分析工具检测到的恶意代码的最强大工具。
- en: Continuous integration
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续集成
- en: 'As previously mentioned, the test-driven approach is crucial in an embedded
    environment. Automating tests is the best way to promptly detect regressions,
    and defects in general, while the development is ongoing. Using an automation
    server, such as **Jenkins**, it is possible to plan several actions, or *jobs*,
    to run responsively (such as at every commit), periodically (such as every Tuesday
    at 1 a.m.), or manually, upon user requests. Here are a few examples of jobs that
    can be automated to improve the efficiency of an embedded project:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在嵌入式环境中，测试驱动的方法至关重要。在开发过程中自动化测试是及时检测回归和缺陷的最佳方式。使用自动化服务器，例如**Jenkins**，可以计划执行多个动作，或称**作业**，以响应式（例如每次提交时）、定期（例如每周二凌晨1点）或手动（根据用户请求）执行。以下是一些可以自动化的作业示例，以提高嵌入式项目的效率：
- en: Unit tests on the development machine
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发机器上的单元测试
- en: System validation tests
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统验证测试
- en: Functional tests on a simulated environment
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟环境中的功能测试
- en: Functional tests on a physical target platform
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理目标平台上的功能测试
- en: Stability tests
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稳定性测试
- en: Static code analysis
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态代码分析
- en: Generating documentation
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成文档
- en: Tagging, versioning, and packaging
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签、版本控制和打包
- en: The desired level of quality must be decided during design, and test cases must
    be coded accordingly. Unit test code coverage can be measured using `gcov` upon
    each test execution. Some projects intended for life-critical applications may
    require a very high percentage of coverage for unit tests, but writing a complete
    set of tests for a complex system has a great impact on the total programming
    effort and may increase the cost of the development significantly, so researching
    the right balance between efficiency and quality is advisable in most cases.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 必须在设计阶段决定所需的质量水平，并据此编写测试用例。可以使用`gcov`在每次测试执行后测量单元测试代码覆盖率。一些针对生命关键应用的项目可能需要单元测试有非常高的覆盖率，但为复杂系统编写完整的测试集会对总编程工作产生重大影响，并可能显著增加开发成本，因此，在大多数情况下，研究效率和质量的正确平衡是可取的。
- en: A different approach has to be taken with functional tests. All the functionalities
    implemented on the target should be tested, and tests prepared in advance should
    be used to define performance indicators and acceptance thresholds. Functional
    tests should be run in an environment that is as close as possible to the real
    use case scenario in all those cases where it is impossible to recreate the full
    use case on the target system and its surroundings.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于功能测试，需要采取不同的方法。在目标上实现的所有功能都应该进行测试，并且应该使用预先准备好的测试来定义性能指标和验收阈值。在无法在目标系统和其周围环境中重新创建完整用例的所有情况下，功能测试应该在尽可能接近真实使用场景的环境中运行。
- en: Source code organization
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码组织
- en: The code base should contain all the source code, third-party libraries, data,
    scripts, and automation needed to build the final image. It is a good idea to
    keep self-contained libraries in separate directories so that they can be easily
    updated to newer versions by replacing the subdirectory. Makefiles and other scripts
    can be placed in the project’s root directory.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 代码库应包含构建最终映像所需的所有源代码、第三方库、数据、脚本和自动化。将自包含库保存在单独的目录中是一个好主意，这样它们就可以通过替换子目录轻松更新到新版本。Makefiles和其他脚本可以放置在项目的根目录中。
- en: Application code should be short and synthetic and access the modules abstracting
    the macro functionalities. Functional modules should describe a process while
    hiding the details of the underlying implementation, such as reading data from
    a sensor after it has been properly sampled and processed. Aiming for small, self-contained,
    and adequately abstracted modules also makes the components of the architecture
    easier to test. Keeping the majority of the logic for the application components
    separated from their hardware-specific implementation improves portability across
    different platforms and allows us to change the peripherals and the interfaces
    used on the target even during the development phase. Abstracting too much, though,
    impacts costs, in terms of development effort and resources needed, so the right
    balance should be researched.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序代码应简短、综合，并访问抽象宏观功能的模块。功能模块应描述一个过程，同时隐藏底层实现的细节，例如在适当采样和处理后从传感器读取数据。追求小型、自包含且充分抽象的模块也使得架构的组件更容易进行测试。将应用程序组件的大多数逻辑与其硬件特定实现分离，提高了跨不同平台的可移植性，并允许我们在开发阶段更改目标上的外设和接口。然而，过度抽象会影响成本，包括开发努力和所需资源，因此应研究正确的平衡点。
- en: Hardware abstraction
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 硬件抽象
- en: General-purpose prototyping platforms are built and distributed by silicon manufacturers
    to evaluate microcontrollers and peripherals, so part of the software development
    may often be performed on these devices even before the design of the final product
    begins.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通用原型平台由硅制造商构建和分发，用于评估微控制器和外设，因此软件开发的部分工作可能经常在这些设备上进行，甚至在最终产品的设计开始之前。
- en: The software that can be run on the evaluation board is usually distributed
    as a reference implementation, in the form of source code or proprietary precompiled
    libraries. These libraries can be configured and adapted for the final target,
    to be used as reference hardware abstraction from the beginning, and their settings
    updated to match changes in the hardware configuration.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 可在评估板上运行的软件通常以源代码或专有预编译库的形式作为参考实现分发。这些库可以根据最终目标进行配置和调整，从开始就用作参考硬件抽象，并更新其设置以匹配硬件配置的变化。
- en: On our reference target, support for the hardware components of a generic Cortex-M
    microcontroller is provided in the form of a library called **Cortex Microcontroller
    Software Interface Standard** (**CMSIS**), distributed by ARM as a reference implementation.
    Silicon manufacturers derive their specific hardware abstractions by extending
    CMSIS. An application linked to a target-specific hardware abstraction can access
    peripherals through its specific API calls and core MCU functionalities through
    CMSIS.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的参考目标上，对通用Cortex-M微控制器的硬件组件支持以**Cortex Microcontroller Software Interface
    Standard**（CMSIS）库的形式提供，由ARM作为参考实现分发。硅制造商通过扩展CMSIS来获取其特定的硬件抽象。与特定硬件抽象链接的应用程序可以通过其特定的API调用访问外设，并通过CMSIS访问核心MCU功能。
- en: For code to be portable across different MCUs in the same family, drivers may
    require an additional level of abstraction on top of the vendor-specific API calls.
    If the HAL implements multiple targets, it can provide the same API to access
    generic features across multiple platforms, hiding the hardware-specific implementation
    under the hood.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要使代码在不同系列的MCU之间可移植，驱动程序可能需要在供应商特定API调用之上提供额外的抽象级别。如果HAL实现多个目标，它可以提供相同的API来访问多个平台上的通用功能，在幕后隐藏硬件特定实现。
- en: The goal of CMSIS and other free software alternatives, such as **libopencm3**
    and **unicore-mx**, is to group all the generic Cortex-M abstractions and the
    vendor-specific code for the most common Cortex-M silicon manufacturers while
    masking the difference among platform-specific calls when controlling the system
    and the peripherals.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: CMSIS和其他免费软件替代品，如**libopencm3**和**unicore-mx**的目标是将所有通用的Cortex-M抽象和最常见的Cortex-M硅制造商的特定代码分组，同时在控制系统和外围设备时掩盖平台特定调用之间的差异。
- en: Regardless of the hardware abstraction, some of the code required at the earliest
    stage of the boot is very specific to each target the software is intended to
    run on. Each platform has its own specific address space segmentation, interrupt
    vector, and configuration register displacement. This means that while working
    on code that is supposed to be portable among different platforms, makefiles and
    scripts automating the build must be configurable to link using the correct startup
    code and linker configurations.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是硬件抽象，还是在引导的最早阶段所需的某些代码都非常特定于软件打算运行的每个目标。每个平台都有自己的特定地址空间分段、中断向量以及配置寄存器偏移。这意味着，在编写旨在在不同平台之间通用的代码时，自动化构建的makefile和脚本必须可配置，以便使用正确的启动代码和链接器配置进行链接。
- en: The examples contained in this book do not depend on any specific hardware abstraction,
    as they aim to introduce the control of the system components by directly interacting
    with the system registers and implementing platform-specific device drivers while
    focusing on the interaction with the hardware component.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的示例不依赖于任何特定的硬件抽象，因为它们旨在通过直接与系统寄存器交互来控制系统组件，同时专注于与硬件组件的交互，并实现平台特定的设备驱动程序。
- en: Middleware
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中间件
- en: Some of the features may already have a well-known solution that has been previously
    implemented by a single developer, a community, or an enterprise. Solutions may
    be generic, perhaps designed for a different platform, or even come from outside
    the embedded world.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一些功能可能已经有一个已知的解决方案，该解决方案之前由单个开发者、社区或企业实现。解决方案可能是通用的，也许是为不同的平台设计的，甚至可能来自嵌入式世界之外。
- en: In any case, it is always worth looking for libraries for any data transformation,
    protocol implementation, or subsystem model that might already have been coded
    and is waiting to be integrated into our project.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，寻找任何可能已经编码并等待集成到我们项目中的数据转换库、协议实现或子系统模型总是值得的。
- en: 'Several open source libraries and software components are ready to be included
    in embedded projects, allowing us to implement a broader set of functionalities.
    Integrating components from open source projects is particularly useful for delivering
    standard functionalities. There is a vast choice of well-established open source
    implementations designed for embedded devices that can be easily integrated into
    embedded projects, including the following examples:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 几个开源库和软件组件已经准备好被包含到嵌入式项目中，使我们能够实现更广泛的功能集。从开源项目中集成组件对于提供标准功能特别有用。有大量经过验证的开源实现，专为嵌入式设备设计，可以轻松集成到嵌入式项目中，以下是一些示例：
- en: Real-time operating systems
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时操作系统
- en: Cryptography libraries
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码学库
- en: TCP/IP, 6LoWPAN, and other network protocols
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP/IP、6LoWPAN和其他网络协议
- en: '**Transport Layer Security** (**TLS**) libraries'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传输层安全性**（**TLS**）库'
- en: Filesystems
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统
- en: IoT message queue protocols
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物联网消息队列协议
- en: Parsers
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析器
- en: Some components from these categories are described in more detail later in
    this book.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 本书后面将更详细地描述这些类别中的一些组件。
- en: Basing the software upon an operating system allows us to manage memory areas
    and thread execution. In this case, threads execute independently from each other,
    and it is even possible to implement memory separation among threads and between
    running threads and the kernel. This approach is advisable when the complexity
    of the design increases or when there are well-known blocking points in the modules
    that cannot be redesigned. Other libraries usually require multithreading support
    if an operating system is used, which can be enabled at compile time.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件基础上使用操作系统允许我们管理内存区域和线程执行。在这种情况下，线程独立于彼此执行，甚至可以在线程之间以及运行中的线程和内核之间实现内存分离。当设计复杂性增加或模块中存在无法重新设计的已知阻塞点时，这种方法是可取的。如果使用操作系统，其他库通常需要多线程支持，这可以在编译时启用。
- en: The decision of integrating third-party libraries must be evaluated by measuring
    the resources needed, in terms of code size and memory used, to perform specific
    tasks on the target platform. As the whole firmware is distributed as a single
    executable file, all the licenses of the components must be compatible, and the
    integration must not violate the license terms of any of its single components.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 集成第三方库的决定必须通过测量在目标平台上执行特定任务所需的资源（以代码大小和使用的内存来衡量）来评估。由于整个固件作为单个可执行文件分发，所有组件的许可证必须兼容，并且集成不得违反任何单个组件的许可证条款。
- en: Application code
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用代码
- en: The role of the application code is to coordinate, from the highest layer in
    the project design, all the modules involved, and orchestrate the heuristics of
    the system. A clean main module that is well-designed allows us to keep a clear
    view of all the macroscopic blocks of the system, how they are related to each
    other, and the execution timing of the various components.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 应用代码的作用是从项目设计的最高层协调所有涉及的模块，并编排系统的启发式策略。一个设计良好的干净主模块使我们能够清晰地看到系统的所有宏观模块，它们之间的关系以及各个组件的执行时间。
- en: Bare-metal applications are built around a main endless loop function, which
    is in charge of distributing the CPU time among the entry points of the underlying
    libraries and drivers. The execution happens sequentially, so the code cannot
    be suspended except by interrupt handlers. For this reason, all the functions
    and library calls invoked from the main loop are supposed to return as fast as
    possible because stall points hidden inside other modules may compromise the system’s
    reactivity, or even block them forever, with the risk of never returning to the
    main loop. Ideally, in a bare-metal system, every component is designed to interact
    with the main loop using the event-driven paradigm, with the main loop constantly
    waiting for events and mechanisms to register callbacks to wake up the application
    on specific events.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 裸机应用程序围绕一个主无限循环函数构建，该函数负责在底层库和驱动程序的入口点之间分配 CPU 时间。执行是顺序发生的，因此代码只能由中断处理程序挂起。因此，从主循环中调用的所有函数和库调用都应该尽可能快地返回，因为隐藏在其他模块中的停滞点可能会损害系统的反应性，甚至永远阻塞它们，从而永远无法返回主循环。理想情况下，在裸机系统中，每个组件都设计为使用事件驱动范式与主循环交互，主循环不断等待事件和机制注册回调，以在特定事件上唤醒应用程序。
- en: The advantage of the bare-metal, single-thread approach is that synchronization
    among threads is not needed, all the memory is accessible by any function in the
    code, and it is not necessary to implement complex mechanisms, such as context
    and execution model switches. Some basic synchronization mechanisms, however,
    could still be required when interrupts are on and the flow of execution can be
    interrupted by external events at any point to execute a specific handler.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 裸机、单线程方法的优点是线程之间不需要同步，所有内存都可以被代码中的任何函数访问，并且不需要实现复杂机制，如上下文和执行模型切换。然而，当中断发生且执行流程在任何时刻都可能被外部事件中断以执行特定处理程序时，可能仍然需要一些基本的同步机制。
- en: If multiple tasks are meant to run on top of an operating system, each task
    should be confined as much as possible within its own module and explicitly export
    its start function and public variables as global symbols. In this case, tasks
    can sleep and call blocking functions, which should implement the OS-specific
    blocking mechanisms.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个任务需要在操作系统上运行，每个任务应尽可能限制在其自己的模块内，并明确导出其启动函数和公共变量作为全局符号。在这种情况下，任务可以休眠并调用阻塞函数，这些函数应实现特定于操作系统的阻塞机制。
- en: Thanks to the flexibility of the Cortex-M CPU, there are different degrees of
    threads and process separation that can be activated on the system.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Cortex-M CPU 的灵活性，系统上可以激活不同级别的线程和进程分离。
- en: The CPU offers multiple tools to facilitate the development of multithreading
    systems with separation among tasks, multiple execution modes, kernel-specific
    registers, privilege separation, and memory-segmentation techniques. These options
    allow architects to define complex systems, more oriented to general-purpose applications,
    which offer privilege separation and memory segmentation among processes, but
    also smaller, simpler, more straightforward systems, which do not need these as
    they are generally designed for a single purpose.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: CPU提供了多个工具来促进具有任务分离、多种执行模式、内核特定寄存器、特权分离和内存分段技术的多线程系统开发。这些选项允许架构师定义更复杂、更倾向于通用应用的系统，这些系统在进程之间提供特权分离和内存分段，但也允许定义更小、更简单、更直接的系统，这些系统不需要这些功能，因为它们通常是为单一目的设计的。
- en: Selecting an executing model that is based on non-privileged threads results
    in a much more complex implementation of the context changes in the system, and
    may impact the latency of the real-time operations, which is why bare-metal, single-threaded
    solutions are still preferred for most real-time applications.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 选择基于非特权线程的执行模型会导致系统上下文变化实现变得更加复杂，并可能影响实时操作的延迟，这就是为什么裸机、单线程解决方案对于大多数实时应用仍然更受欢迎。
- en: Security considerations
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全考虑
- en: One of the most important aspects to consider when designing a new system is
    security. Depending on the characteristics of the system, the requirements, and
    the evaluation of the risks, different countermeasures may be appropriate. Security-enhancing
    features are often a mix of hardware and software efforts to provide specific
    protections against known attacks.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计新系统时考虑的最重要方面之一是安全性。根据系统的特性、要求和风险评估，可能需要不同的对策。增强安全性的功能通常是硬件和软件努力的结合，以提供针对已知攻击的特定保护。
- en: Vulnerability management
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 漏洞管理
- en: Software components keep evolving as new features are introduced, and defects
    are fixed along the way. Some of the defects that are discovered and fixed in
    a later version may impact the security of the system running outdated software
    if proper action is not taken promptly. Once vulnerabilities in third-party components
    are fully disclosed to the public, it is no longer a good choice to keep running
    outdated code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 软件组件会随着新功能的引入和缺陷的修复而不断进化。在后续版本中发现的某些缺陷，如果没有及时采取适当行动，可能会影响运行过时软件的系统的安全性。一旦第三方组件中的漏洞完全向公众披露，继续运行过时代码就不再是一个好的选择。
- en: Older versions with known defects running on public networks have an increased
    possibility of becoming the attack surface for attempts to damage the system,
    take control of the software execution, or steal important data. The best response
    is prepared very early during the design of the system and consists of planning
    remote updates using procedures that fit the specific use case, security requirements,
    and safety levels.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在公共网络上运行的已知缺陷的旧版本有更大的可能性成为系统受损、软件执行控制或重要数据被盗攻击的攻击面。最好的应对策略是在系统设计初期就准备，包括使用适合特定用例、安全要求和安全级别的程序来规划远程更新。
- en: When using third-party libraries, it is appropriate to follow the development
    of their latest versions and fully understand the impact of the defects that are
    fixed, especially when those are marked as security issues.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用第三方库时，跟踪其最新版本的开发并充分理解已修复缺陷的影响是合适的，尤其是当这些缺陷被标记为安全问题的时候。
- en: Software cryptography
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件加密
- en: '**Cryptography** algorithms should be used when appropriate, for example, to
    encrypt data stored locally or in transit between two systems, authenticate a
    remote actor on the network, or verify that data has not been altered and comes
    from a trusted source.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**加密**算法在适当的时候应该被使用，例如，用于加密存储在本地或在两个系统之间传输的数据，验证网络上的远程参与者，或验证数据未被篡改且来自可信源。'
- en: Good cryptography is always based on open, transparent standards so that the
    security of the system depends solely on the security of the keys, according to
    the Kerckhoff principle formulated by the Dutch cryptographer Auguste Kerckhoff
    in the 19th century, rather than on secret mechanisms, with the (false) hope that
    its implementation will never be disclosed or reverse engineered. Although this
    last statement should be obvious to whoever has some confidence with the concept
    of information security, in the past many embedded systems have adopted *security
    by obscurity*, as a bad practice of taking shortcuts in the attempt to circumvent
    the restrictions posed by the lack of appropriate resources to run well-established
    cryptography primitives on older hardware architectures.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的密码学始终基于开放、透明的标准，因此系统的安全性完全取决于密钥的安全性，这是荷兰密码学家奥古斯特·凯克霍夫在19世纪提出的凯克霍夫原则，而不是依赖于秘密机制，寄希望于其实现永远不会被披露或逆向工程。（尽管对于对信息安全概念有一定信心的人来说，这个最后声明应该是显而易见的，但在过去，许多嵌入式系统都采用了*隐蔽性安全*，这是一种在缺乏适当资源运行成熟的密码学原语的老式硬件架构上走捷径的坏习惯。）
- en: 'Nowadays, embedded cryptography libraries exist, capable of running the same
    latest standard algorithms used in PCs and servers in microcontroller-based systems,
    which meanwhile are becoming more powerful and fit for running the (often CPU-hungry)
    cryptography math primitives. A complete cryptography library offers a ready-to-use
    implementation of, typically, three families of algorithms:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，嵌入式密码库存在，能够在基于微控制器的系统中运行与PC和服务器上使用的相同最新标准算法，同时它们也在变得更加强大，适合运行（通常是CPU密集型）的密码学数学原语。一个完整的密码库通常提供三种算法家族的现成实现：
- en: '**Asymmetric cryptography** (RSA, ECC) is based on a pair of keys, private
    and public, associated with each other. Besides one-way encryption, these algorithms
    provide other mechanisms, such as authenticating a signature and deriving secondary
    keys starting from two key pairs, for example, to use as a shared secret by both
    endpoints communicating over an untrusted medium.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非对称密码学**（RSA，ECC）基于一对密钥，私钥和公钥，它们相互关联。除了单向加密外，这些算法还提供其他机制，例如验证签名和从两个密钥对中派生二级密钥，例如，用作通过不受信任的介质通信的两个端点之间的共享秘密。'
- en: '**Symmetric cryptography** (AES, ChaCha20) is mostly adopted for bidirectional
    encryption using the same pre-shared secret key in both directions.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对称密码学**（AES，ChaCha20）主要用于双向加密，在两个方向上使用相同的预共享秘密密钥。'
- en: '**Hash algorithms** (SHA) provide an injective digest calculation and are often
    used to verify that data has not been altered.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**哈希算法**（SHA）提供了一种注入式摘要计算，通常用于验证数据是否被更改。'
- en: A complete set of algorithms, optimized for embedded systems, is provided by
    wolfCrypt, the cryptography engine distributed as part of wolfSSL, a professionally
    maintained open source library that also includes transport layer security protocols,
    which will be further explained in [*Chapter 9*](B18730_09.xhtml#_idTextAnchor311),
    *Distributed Systems and* *IoT Architecture*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: wolfCrypt提供了针对嵌入式系统优化的算法完整集，它是作为wolfSSL的一部分分发的密码引擎，wolfSSL是一个由专业人士维护的开源库，它还包括传输层安全性协议，这些将在[*第9章*](B18730_09.xhtml#_idTextAnchor311)中进一步解释，*分布式系统和*
    *物联网架构*。
- en: Hardware cryptography
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 硬件密码学
- en: Taking security aspects under consideration from the very beginning of the design
    process is important to prematurely identify software and hardware components
    needed to implement the correct mechanisms. Simply adding a cryptography library
    does not guarantee an increased level of security in the system unless all the
    requirements are fulfilled, which often implies some participation from specific
    hardware components.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计过程的初期就考虑安全性方面非常重要，以便提前确定实现正确机制所需的软件和硬件组件。仅仅添加一个密码库并不能保证系统安全性的提高，除非所有要求都得到满足，这通常意味着需要特定硬件组件的参与。
- en: Some algorithms require random values with high entropy, which is often hard
    to obtain on microcontrollers without the help of specific hardware, such as **True
    Random Number** **Generators** (**TRNGs**).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一些算法需要具有高熵的随机值，在没有特定硬件帮助的情况下，在微控制器上通常很难获得，例如**真随机数生成器**（**TRNGs**）。
- en: Other public-key-based cryptography requires trust anchor storage, which means
    a memory location that cannot be modified at runtime by an attacker, and usually
    relies on some non-volatile memory features that may be present on the flash memory
    controller. Finally, to store secret keys, hardware assistance can be needed to
    provide a secure vault that can only be accessed by privileged code or, in some
    cases, is never accessible from software and is only allowed to be used in combination
    with hardware cryptography engines that are coupled with secure storage.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 其他基于公钥的加密需要信任锚存储，这意味着一个在运行时不能被攻击者修改的内存位置，通常依赖于可能存在于闪存控制器上的某些非易失性内存特性。最后，为了存储密钥，可能需要硬件辅助来提供一个只能由特权代码访问的安全保险库，在某些情况下，它从软件中永远无法访问，并且仅允许与安全存储耦合的硬件加密引擎一起使用。
- en: Running untrusted code
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行不受信任的代码
- en: As embedded systems become more complex and the code memory increases, it is
    not unusual to see software components from multiple sources integrated into a
    single firmware image. Some systems may even provide a software development kit
    that runs custom code provided by the user.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 随着嵌入式系统的复杂性和代码内存的增加，看到来自多个来源的软件组件集成到一个单一的固件映像中并不罕见。一些系统甚至提供软件开发套件，可以运行用户提供的自定义代码。
- en: Others may have an interface that allows you to execute code from a remote location.
    In all these cases, it would be appropriate to consider separation mechanisms
    to prevent accidental (or intentional) access to memory areas or peripherals that
    should not be reachable by actors with lower capabilities.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可能有一个接口允许您从远程位置执行代码。在这些所有情况下，考虑分离机制以防止意外（或故意）访问那些不应被低能力演员访问的内存区域或外围设备是合适的。
- en: Most microcontrollers provide two levels of execution privileges, and on some
    platforms, it is possible to divide the addressable memory space according to
    those privileges through context switching in the OS. Newer generations of microcontrollers
    provide TEEs to strictly enforce memory boundaries based on the execution level
    of the current stage.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数微控制器提供两个执行权限级别，在某些平台上，可以通过在操作系统中的上下文切换来根据这些权限划分可寻址的内存空间。新一代微控制器提供基于当前阶段执行级别的内存边界严格强制执行的TEE（信任执行环境）。
- en: The life cycle of an embedded project
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入式项目的生命周期
- en: Modern development frameworks suggest splitting the work into smaller action
    points and marking milestones through the project development while producing
    intermediate working deliverables. Each deliverable focuses on giving a prototype
    of the entire system, with the missing features temporarily replaced using dummy
    code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现代开发框架建议将工作分解成更小的动作点，并在项目开发过程中通过产生中间工作交付成果来标记里程碑。每个交付成果都专注于提供一个整个系统的原型，缺失的功能暂时使用占位代码来替代。
- en: These recommendations seem particularly effective for embedded projects. In
    an environment where every error could be fatal to the entire system, working
    on small action points, one at a time, is an efficient way to promptly identify
    defects and regressions while working on the code base, provided that a **Continuous
    Integration** (**CI**) mechanism is in place from the early stages of the development.
    Intermediate milestones should be as frequent as possible, and for this reason,
    it is advisable to create a prototype of the final system as soon as possible
    in the development phase. This has to be taken into account when actions are identified,
    prioritized, and distributed to the team.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些推荐对于嵌入式项目似乎特别有效。在一个每个错误都可能使整个系统陷入致命状态的环境中，一次只处理一个小动作点，是一种高效的方法，可以在代码库中及时识别缺陷和回归，前提是在开发的早期阶段就建立了**持续集成**（**CI**）机制。中间里程碑应尽可能频繁，因此，在开发阶段尽快创建最终系统的原型是明智的。在识别、优先排序和分配行动给团队时，必须考虑到这一点。
- en: Once the steps to reach the goal are defined, we need to find the optimal sequence
    to produce working prototypes for the intermediate milestones. The dependencies
    among the development actions are taken into account to sort the priorities for
    the assignments of the work.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了达到目标所需的步骤，我们需要找到产生中间里程碑的工作原型的最佳顺序。在分配工作之前，考虑到开发动作之间的依赖关系，对工作优先级进行排序。
- en: A progressive understanding of the system behavior and hardware constraints
    may change the view on the system’s architecture while it is under development,
    as unexpected issues are faced. Changing specifications as a reaction to measurements
    and evaluations performed on the intermediate prototype may require a major code
    rework. Throwing away consistent parts of the project to replace them with a new,
    improved design is often beneficial for the quality of the project and may result
    in improved productivity in the later stages. This process, known as **refactoring**,
    must not be seen as a development overhead whenever it is aimed at improving the
    design and behavior of the system.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对系统行为和硬件约束的逐步理解可能会在开发过程中改变对系统架构的看法，因为会遇到意外问题。对中间原型进行的测量和评估作为反应而更改规范可能需要大量代码重构。丢弃项目中的连贯部分并用新的、改进的设计替换通常有利于项目的质量，并可能在后期阶段提高生产力。这个过程，称为**重构**，不应被视为开发开销，只要它是旨在改进系统设计和行为。
- en: Finally, the process of creating system software includes defining a clear API
    for the applications to interact with the system in the desired way. Embedded
    systems provide specific APIs to access system resources most of the time; however,
    some operating systems and libraries may provide POSIX-like interfaces to access
    functionalities. In any case, the API is the entry point for the system interfaces
    and must be designed for usability and well documented.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，创建系统软件的过程包括为应用程序定义一个清晰的API，以便以期望的方式与系统交互。嵌入式系统通常提供特定的API来访问系统资源；然而，某些操作系统和库可能提供POSIX-like接口以访问功能。在任何情况下，API都是系统接口的入口点，必须设计得易于使用并且有良好的文档记录。
- en: Defining project steps
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义项目步骤
- en: When analyzing specifications, defining the required steps, and assigning priorities,
    several factors may have to be taken into account. Consider designing an air quality
    monitor device with a PM10 air quality serial sensor, which collects the hourly
    measurements into the internal flash, then transmits all the statistics daily
    to a gateway using a wireless transceiver. The target system is a custom board
    based on Cortex-M MCU, which is adequately sized to run the final software. The
    final hardware design will not be available until some real-life measurements
    are done on the transceiver transmitting data to the gateway.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析规范、定义所需步骤和分配优先级时，可能需要考虑几个因素。考虑设计一个带有PM10空气质量串行传感器的空气质量监测设备，该设备每小时收集测量数据到内部闪存，然后使用无线收发器每天将所有统计数据发送到网关。目标系统是基于Cortex-M
    MCU的定制板，其尺寸足够运行最终软件。最终硬件设计将在对发送数据到网关的收发器进行一些实际测量后才能获得。
- en: 'The list of steps to be performed to reach the final goal resulting from these
    specifications may look as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这些规范最终目标所需的步骤列表可能如下所示：
- en: Boot a minimal system on the target (empty main loop).
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目标设备上启动最小系统（空主循环）。
- en: Set up serial port `0` for logging.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置串行端口`0`以进行日志记录。
- en: Set up serial port `1` for the communication to the sensor.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置串行端口`1`以与传感器通信。
- en: Set up a timer.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个定时器。
- en: Write the PM10 sensor driver.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写PM10传感器驱动程序。
- en: Create an application that wakes up every hour and reads from the sensor.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个每小时唤醒并从传感器读取的应用程序。
- en: Write a flash submodule to store/restore measurements.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个闪存子模块以存储/恢复测量数据。
- en: Set up an SPI port to communicate to the radio chip.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置SPI端口以与无线电芯片通信。
- en: Write the radio driver.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写无线电驱动程序。
- en: Implement a protocol to communicate with the gateway.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个与网关通信的协议。
- en: Every 24 measurements, the application sends daily measurements to the gateway.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每24次测量后，应用程序将每日测量数据发送到网关。
- en: Note
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Some of the steps may depend on others, so there are constraints on the order
    of execution. Some of these dependencies can be removed by using simulators or
    emulators.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一些步骤可能依赖于其他步骤，因此存在执行顺序的约束。通过使用模拟器或仿真器，可以消除一些这些依赖关系。
- en: For example, we might want to implement the communication protocol without having
    a working radio only if there is a way to test the protocol against the agent
    running on the gateway by using a simulated radio channel on the gateway itself.
    Keeping the modules self-contained and with a minimal set of API calls exposed
    to the outside makes it easier to detach the single modules to run and test them
    on different architectures, and under a controlled environment, before integrating
    them into the target system.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能希望在只有一种方法可以通过网关上的模拟无线电信道测试协议与网关上运行的代理进行测试的情况下，才实现通信协议，而不需要有一个工作的无线电。保持模块自包含，并且对外仅暴露最小API调用集，使得将单个模块分离出来在不同的架构和受控环境中运行和测试变得更加容易，然后再将其集成到目标系统中。
- en: Prototyping
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原型设计
- en: 'As it is part of the specifications, we know that we should prioritize the
    activities related to the radio communication to allow the hardware team to progress
    on the design, so in this case, the first prototype must do the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是规格的一部分，我们知道我们应该优先处理与无线电通信相关的活动，以便硬件团队能够在设计上取得进展，因此在这种情况下，第一个原型必须执行以下操作：
- en: Boot a minimal system on the target (empty main loop).
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目标设备上启动最小系统（空主循环）。
- en: Set up serial port `0` for logging.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置串行端口`0`进行日志记录。
- en: Set up an SPI port to communicate to the radio chip.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置SPI端口以与无线电芯片通信。
- en: Write the radio driver.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写无线电驱动程序。
- en: Set up the timer.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置定时器。
- en: Write the main application to test the radio channel (sending raw packets at
    regular intervals).
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写主应用程序以测试无线电信道（定期发送原始数据包）。
- en: This first prototype will already start to look like the final device, even
    if it does not yet know how to communicate with the sensor. Some test cases can
    already be implemented to run on a mock gateway, checking that messages are received
    and valid.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个原型已经会开始看起来像最终设备，即使它还不知道如何与传感器通信。一些测试用例可以已经实现，在模拟网关上运行，以检查消息是否被接收且有效。
- en: Moving ahead to the next prototype definition, we can start to add a few additional
    features. Real sensor readings are not necessary to progress on the protocol with
    the gateway, as it is possible to use made-up, *synthetic* test values that reproduce
    a specific behavior instead. This allows us to progress on other tasks when the
    real hardware is not available.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行下一个原型定义时，我们可以开始添加一些额外的功能。在与网关进行协议进展时，并不需要真实的传感器读数，因为可以使用虚构的、*合成*的测试值来重现特定的行为。这使我们能够在真实硬件不可用的情况下，继续进行其他任务。
- en: Whether the development team is adopting pure agile software development or
    is working with a different methodology, fast prototyping in an embedded development
    environment allows responding faster to the uncertainties on the path, which often
    depend on the behavior of the hardware and the actions that need to be taken in
    the software.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是开发团队采用纯敏捷软件开发方法还是使用不同的方法，在嵌入式开发环境中快速原型设计允许更快地应对路径上的不确定性，这些不确定性通常取决于硬件的行为和软件中需要采取的操作。
- en: Providing workable intermediate deliverables is a common practice in embedded
    development teams, which directly derives from agile methodologies. Agile software
    development foresees the delivery of working software regularly and within short
    intervals of time. Like in the preceding example, an intermediate prototype does
    not have to implement all the logic of the final software image but instead must
    be used to prove concepts, make measurements, or provide examples on top of a
    reduced part of the system.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式开发团队中，提供可行的中间交付成果是一种常见做法，这直接源于敏捷方法。敏捷软件开发预计在短时间内定期交付可工作的软件。就像先前的例子一样，中间原型不必实现最终软件图像的所有逻辑，而是必须用于证明概念、进行测量或在系统的较小部分上提供示例。
- en: Refactoring
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构
- en: Too often considered a drastic remedy for a failure, refactoring is actually
    a healthy practice that improves the software while the system takes its final
    shape, and the support for software components and peripherals evolves over time.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 重构通常被认为是对失败的激进补救措施，但实际上它是一种健康的实践，在系统最终成形和软件组件及外围设备支持随时间演变的同时，可以改进软件。
- en: Refactoring works better if all the tests are up and running on the old code.
    Unit tests should be adapted to the new function signatures while redesigning
    the module internals. On the other hand, existing functional tests for the module
    being refactored should not change if the API of the module stays unchanged and
    will provide continuous feedback about the status and the accuracy of the process
    as long as the interface toward other modules remains the same.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有测试都在旧代码上运行，重构工作会更好。在重新设计模块内部结构的同时，单元测试应该适应新的函数签名。另一方面，如果模块的 API 保持不变，正在重构的模块的现有功能测试不应改变，并且只要与其他模块的接口保持相同，它将提供关于过程状态和准确性的持续反馈。
- en: Smaller portions of the code base are exponentially easier to refactor than
    larger ones, which gives us yet another reason to keep each module small and dedicated
    to a specific function on the system. Progressing through intermediate deliverable
    prototypes implies constant alterations in the application code, which should
    require less effort when the subsystems are designed to be independent of each
    other and from the application code itself.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 相比于较大的代码库，较小的代码库更容易进行重构，这又给我们一个理由保持每个模块较小且专注于系统上的特定功能。通过中间交付的原型进行进展意味着对应用程序代码的不断修改，当子系统被设计为相互独立以及与应用程序代码本身独立时，这应该需要更少的努力。
- en: API and documentation
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API 和文档
- en: We all know that a book should not be judged by its cover. However, a system
    can often be judged by its API, which may reveal many aspects of the internal
    implementation and the design choices of the system architects. A clear, readable,
    and easy-to-understand API is one of the most important features of an embedded
    system. Application developers expect to understand how to access functionalities
    quickly and to use the system in the most efficient way possible. The API represents
    the *contract* between the system and the applications, and for this reason, it
    must be designed beforehand and modified as little as possible, if at all, while
    the development moves towards the final delivery.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道一本书不应该仅凭封面来判断。然而，一个系统通常可以通过其 API 来判断，这可能揭示系统内部实现和系统架构师的设计选择。一个清晰、易读且易于理解的
    API 是嵌入式系统最重要的特性之一。应用开发者期望能够快速理解如何访问功能，并以最有效的方式使用系统。API 代表了系统与应用程序之间的*合同*，因此，它必须在开发之前设计，并且在最终交付过程中尽可能少地修改，如果需要修改的话。
- en: Some interfaces in the API may describe complex subsystems and abstract more
    elaborate characteristics, so it is always a good idea to provide adequate documentation
    to help application developers move around and exploit all the system capabilities.
    There are different ways to provide documentation along with the code, either
    distributing user manuals in the repository as separate files or including the
    explanation of the different interfaces directly in the code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: API 中的一些接口可能描述了复杂的子系统并抽象出更详细的特点，因此始终提供足够的文档以帮助应用开发者熟悉并利用所有系统功能是一个好主意。提供文档的方式有很多，可以是将用户手册作为单独的文件分发到仓库中，或者直接在代码中包含不同接口的解释。
- en: The amount of comments in the code is not an indicator of quality. Comments
    tend to *age* whenever the code they refer to gets modified because of the possibility
    that the developer forgets to update the comment to match the new behavior in
    the code. Moreover, not all code needs to be commented; good habits, such as keeping
    functions short and low in complexity or using expressive symbol names, would
    make code comments redundant in most cases, as the code can explain itself.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的注释数量并不是质量的指标。每当代码被修改时，注释往往会*过时*，因为开发者可能会忘记更新注释以匹配代码中的新行为。此外，并非所有代码都需要注释；良好的习惯，如保持函数简短且复杂度低或使用表达性符号名称，在大多数情况下会使代码注释变得多余，因为代码可以自我解释。
- en: There are exceptions for lines of code that contain complex calculations, bit
    shifting, elaborate conditions, or side effects that are not easy to spot when
    reading the code for the first time. Some portions of code may also require a
    description at the beginning, for example, those functions with multiple return
    values and specific error handling. Switch/case statements not containing the
    break instruction between two cases must always have a comment to indicate that
    the fall-through is intended and not a mistake.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于包含复杂计算、位移动、详细条件或初次阅读代码时不易察觉的副作用等代码行，存在例外。某些代码部分可能还需要在开头进行描述，例如，具有多个返回值和特定错误处理的函数。在两个案例之间不包含break指令的switch/case语句必须始终有注释来表明这是有意为之，而不是错误。
- en: They should also possibly explain why some actions are grouped between two or
    more cases. Adding superfluous comments that do not provide any valuable explanation
    of the code only contributes to making the code harder to read.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 他们还可能需要解释为什么某些操作被分组在两个或多个案例之间。添加没有提供任何有价值代码解释的冗余注释只会使代码更难以阅读。
- en: On the other hand, describing the behavior of a module with a separate editor
    and tools requires dedication, as all the documentation must be updated every
    time there are significant changes in the code, and the developers are asked to
    switch the focus away from the actual code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用单独的编辑器和工具来描述模块的行为需要投入精力，因为每次代码发生重大变化时，所有文档都必须更新，并且开发者被要求将注意力从实际代码上转移开。
- en: Usually, the important part to document is the description of the contract mentioned
    previously, enumerating and explaining the functions and the variables that the
    applications and the other components involved can access at runtime. Since these
    declarations can be grouped within header files, it is possible to describe the
    entire contract by adding extended comments on top of the declaration of each
    exported symbol.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，需要记录的重要部分是之前提到的合同的描述，列举并解释应用程序和其他相关组件在运行时可以访问的函数和变量。由于这些声明可以包含在头文件中，因此可以通过在每个导出符号的声明上方添加扩展注释来描述整个合同。
- en: Software tools exist that convert these comments into formatted documentation.
    A popular example is **Doxygen**, a free and open source document-generation tool
    that parses comments matching a specific syntax in the whole code base to produce
    hypertexts, structured PDF manuals, and many other formats. If the documentation
    is in the code base, updating and keeping track of its results is easier and less
    invasive for the developers’ workflow. Integrating the generation of the documentation
    on the automation server can provide a freshly generated copy of the manuals for
    all the APIs at every commit on the master branch.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 存在将注释转换为格式化文档的软件工具。一个流行的例子是**Doxygen**，这是一个免费的开源文档生成工具，它解析整个代码库中匹配特定语法的注释，以生成超文本、结构化PDF手册和其他多种格式。如果文档在代码库中，更新和跟踪其结果对开发者的工作流程来说更容易且侵入性更小。在自动化服务器上集成文档生成可以提供在主分支每次提交时所有API的全新生成的手册副本。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The methodologies that have been proposed are meant as an example of reference
    patterns used to design and manage the development of embedded projects. While
    it is possible that some of the patterns described may not apply to all projects,
    the goal of this chapter is to encourage embedded architects to look for improvements
    in the process that may result in a more efficient and less expensive software
    life cycle. Finally, we analyzed the possibility of increasing security by adding
    appropriate processes and components when required by the use case.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 提出的方法论旨在作为参考模式的一个示例，用于设计和管理嵌入式项目的发展。虽然可能有些描述的模式并不适用于所有项目，但本章的目标是鼓励嵌入式架构师寻找可能使软件生命周期更高效、成本更低的流程改进。最后，我们分析了在需要时通过添加适当的过程和组件来提高安全性的可能性。
- en: In the next chapter, we shall analyze what happens at boot time inside the embedded
    system, and how to prepare a bootable application using a simple, bare-metal,
    main-loop approach.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将分析嵌入式系统启动时发生的事情，以及如何使用简单、裸机、主循环方法准备可启动的应用程序。
