- en: Finalizing Our VR Game and Next Steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Server 17* has come a long way from the idea we conceived at the beginning
    of [Chapter 1](926e8e71-f556-43b2-b4f8-47dc017c7a38.xhtml), *Introducing VR Technology
    in Unreal Engine 4*. From our initial designs and discussions with users, we have
    created a game prototype with flexible systems that puts player fun and comfort
    first. In [Chapter 5](7c6f9794-be36-40be-9cd0-f6d0e09171bd.xhtml), *Creating Optimized
    Game Art for VR in UE4*, we discussed the limitations of game art in VR and some
    best practices that can be used to build the visuals that this game demands. So,
    where do we go from here? It''s time to test!'
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a working prototype, it is time to test with our users and see
    whether some of our design ideas are right. Only the players can tell us whether
    we are on the right track. No design is ever perfect right out of production,
    and our game will often undergo several rounds of testing and redesign before
    we hit a version that is a winner. This is why we must test, and test often.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The importance of game testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting test data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing for distribution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of game testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The testing phase is an essential part of the HCD process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/283c3665-5297-4094-8f65-dd28f18ca202.png)'
  prefs: []
  type: TYPE_IMG
- en: Testing is the fifth step of the HCD process
  prefs: []
  type: TYPE_NORMAL
- en: In this phase, the goal is to gain real and meaningful feedback from our players
    with the hopes of going over our design and improving it based on this feedback.
    This phase is the most important part of the process, since there is no way of
    knowing whether our game is fun without getting it in the hands of the players.
    This is also the phase where many first-time developers struggle. Many creators
    feel very connected to their work and view criticism of it—even constructive criticism—as
    criticism of them or their abilities. It is important that we separate ourselves
    from our work so that we can accept ideas that will improve the project. Approach
    all feedback with an open mind and understand that, ultimately, we get to decide
    which feedback we use and which we ignore. The goal is always to make the product
    better.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting testing data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The data for testing can be collected in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Usability testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Card sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expert review
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are several methods that we can use to collect feedback on our game. These
    methods are all designed to gather specific data from the players that can be
    used to improve all aspects of the game, from user interfaces to level designs.
    Some of them are high tech and utilize advanced methods of recording the player,
    such as eye movement-tracking tests. Others are very low tech and might involve
    having the players sort cards with certain keywords on them into categories or
    simply having the player try the game while you and your colleagues record the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: Usability testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first method that many of us are the most familiar with is usability testing.
    Usability testing involves bringing testers to your location and having them test
    your design while you and others observe and record the results. Observing the
    test is similar to recording notes during an interview. Pay attention to what
    the user says, but also to their body language and what they do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example: Let''s say you have created a puzzle game that takes place
    in a labyrinth. You give ten players that fit your target demographic a chance
    to try the game during the alpha stage. During testing, nearly every player decides
    to try to jump a barrier that was placed in the level. When asked about it afterward,
    four players express frustration that they couldn''t get over the barrier, since
    they thought it might be a shortcut. Nearly all thought that the barrier looked
    like something they should have been able to pass. How could we use this information
    to improve the game? One option might be to change the look of the barrier to
    something more impassible—maybe a wall instead of a fence. This would certainly
    solve the problem, but it doesn''t really take advantage of what we have learned.
    We could build a secret reward into the area. We could adjust the barrier a bit
    to make it passable to a determined player and hide a reward on the other side.
    We could also play to the player''s expectations by adding a shortcut just past
    the barrier if they can get past it. Finally, we always have the option to ignore
    this particular piece of player feedback if we felt that the change was unnecessary.
    Which would you choose?'
  prefs: []
  type: TYPE_NORMAL
- en: Card sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another method that was designed to gather player data is card sorting, which
    can be useful for understanding player perceptions of key features or decided
    what the focus of a game should be. This method comes to us from the world of
    psychological testing and is designed to help us understand user expectations
    and their understanding of your idea. Card sorting involves writing 50–60 keywords
    or ideas on some note cards and asking players to sort them into categories or
    rank them based on their importance. These could be game features such as leveling,
    weapon modification, or multiplayer. They could also be more abstract ideas such
    as what is an acceptable game time or how important is player comfort to the experience.
  prefs: []
  type: TYPE_NORMAL
- en: There are two types of card-sorting activities. Open-card sorting asks the player
    to organize the cards into categories and then name those categories in a way
    that accurately describes what is in them, while closed-card sorting is a method
    where players sort the cards into predefined categories to show you their knowledge
    of the content. Both methods have their benefits. The first allows you to test
    how players perceive your ideas. The second allows you to label the ideas and
    test your labeling, with real users.
  prefs: []
  type: TYPE_NORMAL
- en: Expert review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final method I would like to discuss is expert review. This involves sending
    your game to an expert and gathering their opinions. In games, this may mean having
    several different experts try your product and give you feedback on specific features.
    This would include having a level designer test your game and give you feedback
    on the levels, or a UX designer giving you feedback on your interfaces and interaction
    systems. This method allows you to gain professional insight into areas where
    your team's design expertise might be weak, as often members of small teams wear
    multiple hats and are asked to take on tasks they know little about. However,
    it is important to note that this is not a substitute for having players test
    our game, since player feedback is always the most important type of insight we
    can get.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for distribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, we have gathered player data, reworked the design, and tested again. We
    might have been through this part of the design cycle several times already, but
    now our game is perfect and ready for release to the masses. So, it is time to
    cook and package a release version of the application. This process has several
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Adjust our Project Settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch the ProjectLauncher.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up a Custom Launch Profile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the game build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our journey to release starts by adjusting some Packaging settings in our Project
    Settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf45b14f-5730-4388-88bf-5c4bb1a90ab0.png)'
  prefs: []
  type: TYPE_IMG
- en: Project Settings, showing the Blueprint Nativization option
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s turn on Blueprint Nativization. This option converts our existing blueprints
    into C++ code, which will give us a bump in performance:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the Blueprint Nativization option in the Packaging section of the Project
    Settings menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the dropdown menu and choose the Inclusive option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, choose the Windows option in the Platforms section of the menu along the
    left-hand side. Here, you can use your custom splash screen or a custom icon for
    your game. This is definitely something we should do before our game is released.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to head over to the ProjectLauncher:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3395114-e6e7-4ae6-8cc4-e3cfc6a61597.png)'
  prefs: []
  type: TYPE_IMG
- en: The Project Launcher window
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, we can choose one of the default profiles for our launch preferences
    or we can create our own. Though the WindowsNoEditor option will likely work for
    us, let''s try creating our own custom profile down at the bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: Toward the bottom of the launcher, click the + button to create a custom launch
    profile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top of the window, double-click on the New Profile 0 name and name this
    profile `VRQuickStart`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on the words Enter a description here and provide a description
    for this profile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the project section, we can specify that we would like to use this profile
    for a specific project. Leave this on the default option for now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Head to the Cook section and use the dropdown menu to choose the By the book
    option. Cooking our content removes any content that is not used and prepares
    our files for the specified platform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under Cooked Platforms, make sure that the checkbox for WindowsNoEditor is selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under Cooked Cultures, make sure that any cultures you would like to localize
    for are selected. I have chosen en-US.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For Cooked Maps, choose the prototype map you created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Deploy section of the menu, make sure that your computer is selected.
    Under Variant, choose the WindowsNoEditor option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, click the Back option to head back to the Project Launcher.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With our profile set up, it is finally time to launch our custom profile and
    allow Unreal to prepare our game for distribution! Click the Launch button for
    our custom profile and watch our game go through the process. Since there isn't
    much to our game beyond a prototype right now, the whole process will only take
    a few minutes. As we move to having a more complete game with art, multiple levels,
    and a greater degree of custom code, this process will take longer. Once it is
    complete, it is time to enjoy our demo!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations! We now have a packaged and complete game prototype! So, where
    do we go from here? With what we have learned throughout the chapters of this
    book, the future of our game seems vast and infinite. For some of you, you may
    want to continue with some of the themes that we have created with *Server 17. *For
    others, the goal might be to take the systems that we have designed and build
    and start a new game. Each system we programmed in [Chapter 3](ec4818ac-6582-4488-ba15-e48ef829466f.xhtml), *Exploring
    Riveting Gameplay in Virtual Reality*, and [Chapter 4](29fcf580-f5fc-48d4-a315-2975e97705c2.xhtml), *User
    Interface and User Experience inside VR*, were designed to be generic and flexible,
    allowing the reader to take them in any direction that they wished. I can see
    the same systems that I interpreted as perfect for a hacking puzzle game reimagined
    for use in a shooter game, vehicle experience, or even a cartoon cooking game.
    Once you have settled on a design, build your gameplay and test with the players
    you have chosen to build for. Refine your idea, build some amazing looking art,
    and release it into the wild.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, it is up to you to decide what becomes of this prototype. Yet, whatever
    you decide to do, never stop creating. We become good at what we spend our time
    doing. If you want to expand your skills in game design, never stop making games.
  prefs: []
  type: TYPE_NORMAL
