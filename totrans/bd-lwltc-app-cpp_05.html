<html><head></head><body>
<div id="_idContainer038">
<h1 class="chapter-number" id="_idParaDest-127"><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-128"><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.2.1">Designing Our Trading Ecosystem</span></h1>
<p><span class="koboSpan" id="kobo.3.1">The previous chapter jumped into some hands-on, low-latency development in C++, where we built some basic building blocks to be used throughout the rest of this book. </span><span class="koboSpan" id="kobo.3.2">Now we are ready to start designing our electronic trading ecosystem, which will be our main project for the rest of this book, where we will learn about low-latency application development principles in practice. </span><span class="koboSpan" id="kobo.3.3">First, we will discuss the high-level design and architecture of the different low-latency components or applications that we will be building for the end-to-end electronic trading ecosystem. </span><span class="koboSpan" id="kobo.3.4">We will also design the abstractions, components, and interactions between them, which we will implement in the rest of </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">the book.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Understanding the layout of the electronic </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">trading ecosystem</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Designing the C++ matching engine in a </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">trading exchange</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Understanding how an exchange publishes information </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">to participants</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Building a market participant’s interface to </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">the exchange</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Designing a framework for low-latency C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">trading algorithms</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.17.1">Let us kick off this chapter by describing the high-level topology of the electronic trading ecosystem we will design and build in the rest of this book. </span><span class="koboSpan" id="kobo.17.2">We will briefly introduce the different components in the next section and then have a much more detailed discussion in the rest of this chapter. </span><span class="koboSpan" id="kobo.17.3">One thing to keep in mind is that the electronic trading ecosystem we will be building in this book is a simplified version of what is found in practice. </span><span class="koboSpan" id="kobo.17.4">Not only is it a simplified version but it is also a subset of all the components you would need in practice to build and run a full electronic trading ecosystem. </span><span class="koboSpan" id="kobo.17.5">The components we will build in this book were chosen because they are the most latency-sensitive components, and we try to keep our focus on low-latency application development. </span><span class="koboSpan" id="kobo.17.6">We would like to mention that, in practice, you will find components such as historical data capture at the exchange and client ends, connections to clearing brokers, backend systems for transaction processing, accounting and reconciliation at both the exchange and trading client’s ends, backtesting frameworks (testing against historical data), and </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">many others.</span></span></p>
<h1 id="_idParaDest-129"><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.19.1">Understanding the layout of the electronic trading ecosystem</span></h1>
<p><span class="koboSpan" id="kobo.20.1">First, we start by providing the higher-level layout of the electronic trading ecosystem we will be building in the rest of this book. </span><span class="koboSpan" id="kobo.20.2">Before we get into the details, we start with the disclaimer that </span><a id="_idIndexMarker724"/><span class="koboSpan" id="kobo.21.1">this is a simplified design of what happens in practice in electronic trading markets. </span><span class="koboSpan" id="kobo.21.2">Simplification was necessary to limit the scope to what can be covered in this book; however, it is still an accurate but simplified representation of what you will find in practice. </span><span class="koboSpan" id="kobo.21.3">The other thing to note is that the goal here is to understand the design and implementation of low-latency applications, so we ask you to focus more on the application of C++ and computer science principles that we apply and less on the details of the trading </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">ecosystem itself.</span></span></p>
<p><span class="koboSpan" id="kobo.23.1">Now, let us kick off this introduction by defining and explaining the overall topology of the electronic trading ecosystem and the </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">components involved.</span></span></p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.25.1">Defining the topology of the electronic trading ecosystem</span></h2>
<p><span class="koboSpan" id="kobo.26.1">Let us first provide </span><a id="_idIndexMarker725"/><span class="koboSpan" id="kobo.27.1">a bird’s eye view of the system with the diagram </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">presented here:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<span class="koboSpan" id="kobo.29.1"><img alt="Figure 5.1 – Topology of a ﻿simple electronic trading ecosystem" src="image/B19434_05_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.30.1">Figure 5.1 – Topology of a simple electronic trading ecosystem</span></p>
<p><span class="koboSpan" id="kobo.31.1">The major components, as laid out in the preceding diagram, are the following, split at a high level depending </span><a id="_idIndexMarker726"/><span class="koboSpan" id="kobo.32.1">on whether it belongs on the exchange side or the trading </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">client/market-participant side.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">These are the </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">exchange components:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.36.1">Matching </span><a id="_idIndexMarker727"/><span class="koboSpan" id="kobo.37.1">engine at the electronic </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">trading exchange</span></span></li>
<li><span class="koboSpan" id="kobo.39.1">Order gateway server and protocol encoder and decoder at the </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">trading exchange</span></span></li>
<li><span class="koboSpan" id="kobo.41.1">Market data encoder and publisher at </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">the exchange</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.43.1">These are </span><a id="_idIndexMarker728"/><span class="koboSpan" id="kobo.44.1">the trading </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">client components:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.46.1">Market data consumer and decoder for a market participant interested in this </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">market data</span></span></li>
<li><span class="koboSpan" id="kobo.48.1">Order gateway encoder and decoder client in the market </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">participant’s system</span></span></li>
<li><span class="koboSpan" id="kobo.50.1">Trading engine inside</span><a id="_idIndexMarker729"/><span class="koboSpan" id="kobo.51.1"> the </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">participant’s system</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.53.1">We will quickly introduce </span><a id="_idIndexMarker730"/><span class="koboSpan" id="kobo.54.1">each one of these components in the next section and then discuss them in detail in the rest of </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">this chapter.</span></span></p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.56.1">Introducing the components of the electronic trading ecosystem</span></h2>
<p><span class="koboSpan" id="kobo.57.1">Here, we will quickly introduce the different components that make up the electronic trading ecosystem. </span><span class="koboSpan" id="kobo.57.2">One thing to keep in mind is that each one of these components in a competitive </span><a id="_idIndexMarker731"/><span class="koboSpan" id="kobo.58.1">ecosystem needs to be designed such that they can process events and data with the lowest latencies possible. </span><span class="koboSpan" id="kobo.58.2">Also note that during periods of heightened volatility, these systems must be able to keep up with and react to large bursts in </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">market activity.</span></span></p>
<h3><span class="koboSpan" id="kobo.60.1">Introducing the market data publisher</span></h3>
<p><span class="koboSpan" id="kobo.61.1">The market data publisher at the trading exchange is responsible for communicating every change to </span><a id="_idIndexMarker732"/><span class="koboSpan" id="kobo.62.1">the limit order </span><a id="_idIndexMarker733"/><span class="koboSpan" id="kobo.63.1">book maintained by the matching engine to the market participants. </span><span class="koboSpan" id="kobo.63.2">Compared to the order gateway, the difference here is that the market data publisher publishes public data meant for all participants, and it typically hides details of which order belongs to which participant to maintain fairness. </span><span class="koboSpan" id="kobo.63.3">Another difference is that the order gateway infrastructure only communicates order updates to the market participants whose orders were impacted by the change and not to all market participants. </span><span class="koboSpan" id="kobo.63.4">The market data publisher can use TCP or UDP to publish market data, but given the large volume of market data updates, UDP multicast is the preferred network-level protocol. </span><span class="koboSpan" id="kobo.63.5">The market data publisher is also responsible for converting the internal matching engine format into the market data format before publishing </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">the updates.</span></span></p>
<h3><span class="koboSpan" id="kobo.65.1">Introducing the matching engine</span></h3>
<p><span class="koboSpan" id="kobo.66.1">The matching engine at the electronic trading exchange is the most critical piece of the trading exchange. </span><span class="koboSpan" id="kobo.66.2">It is responsible for handling requests from market participants for their orders and </span><a id="_idIndexMarker734"/><span class="koboSpan" id="kobo.67.1">upd</span><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.68.1">ating the limit order book that it maintains. </span><span class="koboSpan" id="kobo.68.2">These requests are generated when the clients want to add a </span><a id="_idIndexMarker735"/><span class="koboSpan" id="kobo.69.1">new order, replace an existing order, cancel an existing order, and so on. </span><span class="koboSpan" id="kobo.69.2">The limit order book is a collection of all orders sent by all participants aggregated into a central single book consisting of bids (buy orders) and asks (sell orders). </span><span class="koboSpan" id="kobo.69.3">The matching engine is also responsible for performing matches between orders that cross in price (i.e., matching buy orders with sell orders when the buy price is higher than or equal to the sell price). </span><span class="koboSpan" id="kobo.69.4">During special market states such as </span><strong class="bold"><span class="koboSpan" id="kobo.70.1">PreOpen</span></strong><span class="koboSpan" id="kobo.71.1"> (right before the market opens), </span><strong class="bold"><span class="koboSpan" id="kobo.72.1">Auction</span></strong><span class="koboSpan" id="kobo.73.1">/</span><strong class="bold"><span class="koboSpan" id="kobo.74.1">Opening</span></strong><span class="koboSpan" id="kobo.75.1"> (right at the moment at which the market opens), </span><strong class="bold"><span class="koboSpan" id="kobo.76.1">PreOpenNoCancel</span></strong><span class="koboSpan" id="kobo.77.1"> (orders can be entered but not canceled), and so on, the rules are slightly different, but we will not worry about those rules or implement them to keep the focus on low-latency </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">application development.</span></span></p>
<h3><span class="koboSpan" id="kobo.79.1">Introducing the order gateway server at the exchange</span></h3>
<p><span class="koboSpan" id="kobo.80.1">The order gateway server at the exchange is responsible for accepting connections from market </span><a id="_idIndexMarker736"/><span class="koboSpan" id="kobo.81.1">participants so that they can send requests for orders and receive notifications when </span><a id="_idIndexMarker737"/><span class="koboSpan" id="kobo.82.1">there are updates to their respective orders. </span><span class="koboSpan" id="kobo.82.2">The order gateway server is also responsible for translating messages between the matching engine format and the order gateway messaging protocol. </span><span class="koboSpan" id="kobo.82.3">The network protocol used for the order gateway server is always TCP to enforce in-order delivery of messages </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">and reliability.</span></span></p>
<h3><span class="koboSpan" id="kobo.84.1">Introducing the market data consumer at the market participant level</span></h3>
<p><span class="koboSpan" id="kobo.85.1">The market data consumer is the complement of the exchange market data publisher component </span><a id="_idIndexMarker738"/><span class="koboSpan" id="kobo.86.1">on the market participants’ side. </span><span class="koboSpan" id="kobo.86.2">This component is responsible for </span><a id="_idIndexMarker739"/><span class="koboSpan" id="kobo.87.1">subscribing to the UDP stream or the TCP server set up by the market data publisher, consuming the market data updates, and decoding the market data protocol into an internal format used by the rest of the </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">trading engine.</span></span></p>
<h3><span class="koboSpan" id="kobo.89.1">Introducing the order gateway encoder and decoder client</span></h3>
<p><span class="koboSpan" id="kobo.90.1">The order </span><a id="_idIndexMarker740"/><span class="koboSpan" id="kobo.91.1">gateway client component is the complement of the exchange order gateway server </span><a id="_idIndexMarker741"/><span class="koboSpan" id="kobo.92.1">on the market participants’ side. </span><span class="koboSpan" id="kobo.92.2">The responsibility of this component is to establish and maintain TCP connections with the exchange’s order gateway infrastructure. </span><span class="koboSpan" id="kobo.92.3">It is also responsible for encoding strategy order requests in the correct exchange order messaging protocol and decoding exchange responses into an internal format that the trading </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">engine uses.</span></span></p>
<h3><span class="koboSpan" id="kobo.94.1">Introducing the trading engine in the market participants’ systems</span></h3>
<p><span class="koboSpan" id="kobo.95.1">The trading engine is the brain of a market participant’s trading system. </span><span class="koboSpan" id="kobo.95.2">This is where intelligence </span><a id="_idIndexMarker742"/><span class="koboSpan" id="kobo.96.1">resides, and where the trading decisions are made. </span><span class="koboSpan" id="kobo.96.2">This component is </span><a id="_idIndexMarker743"/><span class="koboSpan" id="kobo.97.1">responsible for consuming the normalized market data updates from the market data consumer component. </span><span class="koboSpan" id="kobo.97.2">It will usually also build the complete limit order book to reflect the state of the market or, at the very least, a simplified variant of the order book, depending on the requirements of the trading strategies. </span><span class="koboSpan" id="kobo.97.3">It usually also builds analytics on top of the liquidity and prices from the order book and makes automated trading decisions. </span><span class="koboSpan" id="kobo.97.4">This component uses the order gateway client component to communicate with the </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">trading exchange.</span></span></p>
<p><span class="koboSpan" id="kobo.99.1">Now that we have introduced the major components involved in our electronic trading ecosystem, we will look at these components in greater detail. </span><span class="koboSpan" id="kobo.99.2">First, we will start with the matching engine, which resides in the electronic trading </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">exchange system.</span></span></p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.101.1">Designing the C++ matching engine in a trading exchange</span></h1>
<p><span class="koboSpan" id="kobo.102.1">In this section, we </span><a id="_idIndexMarker744"/><span class="koboSpan" id="kobo.103.1">will discuss the matching engine component inside the electronic trading exchange system introduced in the previous section. </span><span class="koboSpan" id="kobo.103.2">The first thing we will do is understand what purpose the matching engine serves and why it </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">is needed.</span></span></p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.105.1">Understanding the purpose of the matching engine</span></h2>
<p><span class="koboSpan" id="kobo.106.1">In the electronic trading ecosystem consisting of a single trading exchange, generally, there is a single </span><a id="_idIndexMarker745"/><span class="koboSpan" id="kobo.107.1">exchange that is responsible for accepting and managing orders from numerous market participants. </span><span class="koboSpan" id="kobo.107.2">The matching engine in this case accepts different kinds of orders that the participants are allowed to send for any given trading instrument. </span><span class="koboSpan" id="kobo.107.3">An </span><strong class="bold"><span class="koboSpan" id="kobo.108.1">order</span></strong><span class="koboSpan" id="kobo.109.1"> is simply a request sent by any market participant to the </span><a id="_idIndexMarker746"/><span class="koboSpan" id="kobo.110.1">trading exchange to convey their interest in buying or selling a tradeable product. </span><span class="koboSpan" id="kobo.110.2">Every time a new order is received by the matching engine from the order gateway server infrastructure, it checks to see whether this new order crosses an existing order with an opposite side to see whether a trade occurs. </span><span class="koboSpan" id="kobo.110.3">For this book’s purposes, we will assume the market participants only send </span><strong class="bold"><span class="koboSpan" id="kobo.111.1">limit orders</span></strong><span class="koboSpan" id="kobo.112.1"> and specify the side of the </span><a id="_idIndexMarker747"/><span class="koboSpan" id="kobo.113.1">order, quantity, and price. </span><span class="koboSpan" id="kobo.113.2">Limit orders are orders that can only execute at a price that is at, or better than, the price specified by the </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">market participant.</span></span></p>
<p><span class="koboSpan" id="kobo.115.1">It should be obvious by now that the matching engine performs the most critical task of performing matches between orders from different market participants and does so correctly and fairly. </span><span class="koboSpan" id="kobo.115.2">By fairness, we mean that the orders that reach the exchange first are processed first, and this </span><strong class="bold"><span class="koboSpan" id="kobo.116.1">first in, first out</span></strong><span class="koboSpan" id="kobo.117.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.118.1">FIFO</span></strong><span class="koboSpan" id="kobo.119.1">) ordering is handled in the order gateway </span><a id="_idIndexMarker748"/><span class="koboSpan" id="kobo.120.1">infrastructure, which we will discuss shortly. </span><span class="koboSpan" id="kobo.120.2">Orders that do not match immediately rest in the book and are referred to as </span><strong class="bold"><span class="koboSpan" id="kobo.121.1">passive orders</span></strong><span class="koboSpan" id="kobo.122.1">. </span><span class="koboSpan" id="kobo.122.2">These orders are eligible </span><a id="_idIndexMarker749"/><span class="koboSpan" id="kobo.123.1">for matching when new orders come in with prices that </span><a id="_idIndexMarker750"/><span class="koboSpan" id="kobo.124.1">cross the passive orders. </span><span class="koboSpan" id="kobo.124.2">Such orders that cross the prices on passive orders are known as </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.125.1">aggressive orders</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.127.1">The matching engine arranges all the passive orders sent by all market participants into a data structure that is aptly named the </span><strong class="bold"><span class="koboSpan" id="kobo.128.1">order book</span></strong><span class="koboSpan" id="kobo.129.1">. </span><span class="koboSpan" id="kobo.129.2">The details of this order book will be the topic of our </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">next discussion.</span></span></p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.131.1">Understanding the exchange order book</span></h2>
<p><span class="koboSpan" id="kobo.132.1">The limit order book contains all the passive limit orders across all market participants for a single trading </span><a id="_idIndexMarker751"/><span class="koboSpan" id="kobo.133.1">instrument. </span><span class="koboSpan" id="kobo.133.2">These are typically arranged from the highest buy price to the lowest buy price for passive buy orders, and from the lowest sell price to the highest sell price for passive sell orders. </span><span class="koboSpan" id="kobo.133.3">This ordering is intuitive and natural because passive buy orders are matched from highest to lowest buy prices and passive sell orders are matched from lowest to highest sell prices. </span><span class="koboSpan" id="kobo.133.4">For orders that have the same side and the same price, they are arranged in FIFO order based on when they were sent. </span><span class="koboSpan" id="kobo.133.5">Note that FIFO is just one ordering criterion; modern electronic trading markets have different types of matching algorithms, such as </span><strong class="bold"><span class="koboSpan" id="kobo.134.1">Pro Rata</span></strong><span class="koboSpan" id="kobo.135.1"> and some mix of FIFO and Pro Rata. </span><span class="koboSpan" id="kobo.135.2">Pro Rata is simply </span><a id="_idIndexMarker752"/><span class="koboSpan" id="kobo.136.1">a matching algorithm where larger orders get larger fills from aggressive orders regardless of where they are in the FIFO queue. </span><span class="koboSpan" id="kobo.136.2">For our matching engine, we will only implement the FIFO </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">matching algorithm.</span></span></p>
<p><span class="koboSpan" id="kobo.138.1">To fully understand how the order book works, we will look at a few scenarios that happen in the </span><a id="_idIndexMarker753"/><span class="koboSpan" id="kobo.139.1">market and how they impact the order book. </span><span class="koboSpan" id="kobo.139.2">Let us first establish the starting state of the order book. </span><span class="koboSpan" id="kobo.139.3">Let us assume there are orders belonging to three different market participants – clients A, B, and C on the buy and </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">sell sides.</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-2">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.141.1">Client A OrderId 1 BUY 20 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">10.90</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.143.1">Client B OrderId 5 SELL 10 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">11.00</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.145.1">Client A OrderId 2 BUY 10 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">10.80</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.147.1">Client C OrderId 6 Sell 5 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">11.00</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.149.1">Client B OrderId 3 BUY 5 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">10.80</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.151.1">Client B OrderId 7 SELL 5 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">11.10</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.153.1">Client C OrderId 4 BUY 100 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">10.70</span></span></p>
</td>
<td class="No-Table-Style"/>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.155.1">Table 5.1 – Initial state of the limit order book consisting of some orders</span></p>
<p><span class="koboSpan" id="kobo.156.1">Here, client A has 2 passive buy orders of quantities of 20 and 10 at prices of 10.90 and 10.80, respectively. </span><span class="koboSpan" id="kobo.156.2">Client B has a buy order of a quantity of 5 at 10.80, and 2 sell orders of quantities of 10 and 5 at prices of 11.00 and 11.10, respectively. </span><span class="koboSpan" id="kobo.156.3">Client C has 2 passive orders – a buy of a quantity of 5 at 10.80 and a sell of a quantity of 5 at 11.00, respectively. </span><span class="koboSpan" id="kobo.156.4">Now, let us assume client A sends a new buy order of a quantity of 10 at the price of 10.90 and client B sends a new sell order of a quantity of 10 at the price of 11.20. </span><span class="koboSpan" id="kobo.156.5">The updated order book is shown in the following table and the new orders are highlighted. </span><span class="koboSpan" id="kobo.156.6">Due to the FIFO ordering, the new buy order of </span><em class="italic"><span class="koboSpan" id="kobo.157.1">OrderId=8</span></em><span class="koboSpan" id="kobo.158.1"> is behind the buy order of </span><em class="italic"><span class="koboSpan" id="kobo.159.1">OrderId=1</span></em><span class="koboSpan" id="kobo.160.1"> at the </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">same price.</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table002-1">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.162.1">Client A OrderId 1 BUY 20 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">10.90</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.164.1">Client B OrderId 5 SELL 10 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">11.00</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.166.1">Client A OrderId 8 BUY 10 @ </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.167.1">10.90</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.168.1">Client C OrderId 6 Sell 5 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">11.00</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.170.1">Client A OrderId 2 BUY 10 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">10.80</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.172.1">Client B OrderId 7 SELL 5 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">11.10</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.174.1">Client B OrderId 3 BUY 5 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">10.80</span></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.176.1">Client B OrderId 9 SELL 10 @ </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.177.1">11.20</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.178.1">Client C OrderId 4 BUY 100 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">10.70</span></span></p>
</td>
<td class="No-Table-Style"/>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.180.1">Table 5.2 – Updated order book with newly added orders</span></p>
<p><span class="koboSpan" id="kobo.181.1">Now let us assume that client A modifies the order with </span><em class="italic"><span class="koboSpan" id="kobo.182.1">OrderId=2</span></em><span class="koboSpan" id="kobo.183.1"> to go from a quantity of 10 to a quantity of 20. </span><span class="koboSpan" id="kobo.183.2">When an order’s quantity is increased in such a manner, the order loses priority in the FIFO ordering and goes to the back of the queue at that price level. </span><span class="koboSpan" id="kobo.183.3">Let us also assume that client B modifies the order of </span><em class="italic"><span class="koboSpan" id="kobo.184.1">OrderId=5</span></em><span class="koboSpan" id="kobo.185.1"> to reduce the order’s quantity from 10 to 1. </span><span class="koboSpan" id="kobo.185.2">Note that per the rules of the market, when an order’s quantity is </span><a id="_idIndexMarker754"/><span class="koboSpan" id="kobo.186.1">reduced, it does not lose its priority in the queue and still stays where it is. </span><span class="koboSpan" id="kobo.186.2">The updated order book is shown next, and the orders that are impacted </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">are highlighted:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table003-1">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.188.1">Client A OrderId 1 BUY 20 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">10.90</span></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.190.1">Client B OrderId 5 SELL 1 @ </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.191.1">11.00</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.192.1">Client A OrderId 8 BUY 10 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">10.90</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.194.1">Client C OrderId 6 Sell 5 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">11.00</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.196.1">Client A OrderId 3 BUY 5 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">10.80</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.198.1">Client B OrderId 7 SELL 5 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">11.10</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.200.1">Client B OrderId 2 BUY 20 @ </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.201.1">10.80</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.202.1">Client B OrderId 9 SELL 10 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">11.20</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.204.1">Client C OrderId 4 BUY 100 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">10.70</span></span></p>
</td>
<td class="No-Table-Style"/>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.206.1">Table 5.3 – State of the order book after the modification of an order</span></p>
<p><span class="koboSpan" id="kobo.207.1">Finally, let us assume that client A modifies the buy order with </span><em class="italic"><span class="koboSpan" id="kobo.208.1">OrderId=4</span></em><span class="koboSpan" id="kobo.209.1"> from a price of 10.70 to a price of 10.90 with no changes to quantity. </span><span class="koboSpan" id="kobo.209.2">The impact of this order action is equivalent to canceling the order and sending a new order at the new price. </span><span class="koboSpan" id="kobo.209.3">Let us also assume that client B decides that they no longer want the sell order of </span><em class="italic"><span class="koboSpan" id="kobo.210.1">OrderId=9</span></em><span class="koboSpan" id="kobo.211.1"> and sends a cancel for it. </span><span class="koboSpan" id="kobo.211.2">The updated order book due to these two actions is shown next, with the modified order highlighted and the canceled order removed from the </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">order book:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table004">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.213.1">Client A OrderId 1 BUY 20 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">10.90</span></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.215.1">Client B OrderId 5 SELL 1 @ </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.216.1">11.00</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.217.1">Client A OrderId 8 BUY 10 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">10.90</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.219.1">Client C OrderId 6 Sell 5 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">11.00</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.221.1">Client C OrderId 4 BUY 100 @ </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.222.1">10.90</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.223.1">Client B OrderId 7 SELL 5 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">11.10</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.225.1">Client A OrderId 3 BUY 5 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">10.80</span></span></p>
</td>
<td class="No-Table-Style"/>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.227.1">Client B OrderId 2 BUY 20 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">10.80</span></span></p>
</td>
<td class="No-Table-Style"/>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.229.1">Table 5.4 – Limit order book state after the modification and cancellation actions</span></p>
<p><span class="koboSpan" id="kobo.230.1">So far in the scenarios we discussed, there has not been a trade because the order activity has been such </span><a id="_idIndexMarker755"/><span class="koboSpan" id="kobo.231.1">that all buy orders have prices lower than all sell orders. </span><span class="koboSpan" id="kobo.231.2">Let us further this discussion in the next section and see what happens when there is an aggressive order that can cross the buy or sell order prices and what </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">that does.</span></span></p>
<p><span class="koboSpan" id="kobo.233.1">Two things to note here as far as order modification is concerned are </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.235.1">When orders are modified to reduce the quantity, the priority or position of the order in the queue does </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">not change</span></span></li>
<li><span class="koboSpan" id="kobo.237.1">When orders are modified to increase the quantity or the price of the order is modified, it has the equivalent effect of canceling the order and sending the order with the new price and quantity values (i.e., a new priority will be assigned </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">to it)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.239.1">In the next section, we will look at the next big task that a matching engine needs to perform – matching participant orders that cross </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">each other.</span></span></p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.241.1">Matching participant orders</span></h2>
<p><span class="koboSpan" id="kobo.242.1">In this section, we will understand what happens when a market participant modifies an existing order or </span><a id="_idIndexMarker756"/><span class="koboSpan" id="kobo.243.1">sends a new order in such a way that the price on this order will cause a match against an existing passive order on the other side. </span><span class="koboSpan" id="kobo.243.2">In such a scenario, the matching engine matches this aggressive order against passive orders in order from most aggressive to least aggressive price. </span><span class="koboSpan" id="kobo.243.3">This means passive bids are matched from highest to lowest buy prices, and passive asks are matched from lowest to highest sell prices. </span><span class="koboSpan" id="kobo.243.4">In cases where the passive orders are not fully matched because the aggressive order has a smaller quantity than the passive liquidity available on the other side, then the remaining liquidity on the passive orders stays in the book. </span><span class="koboSpan" id="kobo.243.5">In cases where the aggressive order is not fully matched because the passive liquidity available on the other side is less than the quantity on the aggressive order, then the remaining quantity on the aggressive order rests in the book as a </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">passive order.</span></span></p>
<p><span class="koboSpan" id="kobo.245.1">Let us understand the different cases of matching participant orders and let us assume the state of the order book is where we left it in the last section, as </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">shown here:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table005">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.247.1">Client A OrderId 1 BUY 20 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">10.90</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.249.1">Client B OrderId 5 SELL 1 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">11.00</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.251.1">Client A OrderId 8 BUY 10 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">10.90</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.253.1">Client C OrderId 6 Sell 5 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">11.00</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.255.1">Client C OrderId 4 BUY 100 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">10.90</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.257.1">Client B OrderId 7 SELL 5 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">11.10</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.259.1">Client A OrderId 3 BUY 5 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">10.80</span></span></p>
</td>
<td class="No-Table-Style"/>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.261.1">Client B OrderId 2 BUY 20 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">10.80</span></span></p>
</td>
<td class="No-Table-Style"/>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.263.1">Table 5.5 – Starting state of the order book before any order matches</span></p>
<p><span class="koboSpan" id="kobo.264.1">Now, let us assume client C sends a sell order of a quantity of 50 at a sell price of 10.90. </span><span class="koboSpan" id="kobo.264.2">This will cause the sell order to match against the buy orders with </span><em class="italic"><span class="koboSpan" id="kobo.265.1">OrderId=1</span></em><span class="koboSpan" id="kobo.266.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.267.1">OrderId=8</span></em><span class="koboSpan" id="kobo.268.1">, which </span><a id="_idIndexMarker757"/><span class="koboSpan" id="kobo.269.1">are fully matched, and </span><em class="italic"><span class="koboSpan" id="kobo.270.1">OrderId=4</span></em><span class="koboSpan" id="kobo.271.1">, which is partially matched for a quantity of 20 and has the remaining quantity of 80. </span><span class="koboSpan" id="kobo.271.2">The orders that are fully matched are removed from the order book and the partially-matched order is modified to the new remaining quantity. </span><span class="koboSpan" id="kobo.271.3">The updated order book after this matching transaction is </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">shown here:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table006">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.273.1">Client C OrderId 4 BUY 80 @ </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.274.1">10.90</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.275.1">Client B OrderId 5 SELL 1 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">11.00</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.277.1">Client A OrderId 3 BUY 5 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">10.80</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.279.1">Client C OrderId 6 Sell 5 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">11.00</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.281.1">Client B OrderId 2 BUY 20 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">10.80</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.283.1">Client B OrderId 7 SELL 5 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">11.10</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.285.1">Table 5.6 – Order book reflecting the impact of the aggressive order and partial executions</span></p>
<p><span class="koboSpan" id="kobo.286.1">Now, let us assume client A sends a buy order of a quantity of 10 at a buy price of 11.00. </span><span class="koboSpan" id="kobo.286.2">This fully matches the sell orders with </span><em class="italic"><span class="koboSpan" id="kobo.287.1">OrderId=5</span></em><span class="koboSpan" id="kobo.288.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.289.1">OrderId=6</span></em><span class="koboSpan" id="kobo.290.1">, and the remaining unmatched quantity on the aggressive buy order rests in the book as a passive bid order. </span><span class="koboSpan" id="kobo.290.2">The updated order book after this matching transaction is </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">shown here:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table007">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.292.1">Client A OrderId 9 BUY 4 @ </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.293.1">11.00</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.294.1">Client B OrderId 7 SELL 5 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">11.10</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.296.1">Client C OrderId 4 BUY 80 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">10.90</span></span></p>
</td>
<td class="No-Table-Style"/>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.298.1">Client A OrderId 3 BUY 5 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">10.80</span></span></p>
</td>
<td class="No-Table-Style"/>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.300.1">Client B OrderId 2 BUY 20 @ </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">10.80</span></span></p>
</td>
<td class="No-Table-Style"/>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.302.1">Table 5.7 – Order book after full execution and resting quantity from the aggressor</span></p>
<p><span class="koboSpan" id="kobo.303.1">Now that we </span><a id="_idIndexMarker758"/><span class="koboSpan" id="kobo.304.1">understand a lot of the common interactions that we will encounter in the matching engine and how those are handled, as well as how they interact with the limit order book, we can design the matching engine we will build in </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">this book.</span></span></p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.306.1">Designing our matching engine</span></h2>
<p><span class="koboSpan" id="kobo.307.1">We will spend the rest of this book implementing each one of the C++ electronic trading ecosystem </span><a id="_idIndexMarker759"/><span class="koboSpan" id="kobo.308.1">components we discussed in this chapter. </span><span class="koboSpan" id="kobo.308.2">However, before we get started on the next chapter, it is important to understand the architecture of these components to make the implementation details easier and clearer later on. </span><span class="koboSpan" id="kobo.308.3">We present only the matching engine component from </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.309.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.310.1">.1</span></em><span class="koboSpan" id="kobo.311.1"> here so we can discuss the design of our matching engine in a little </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">more detail:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer030">
<span class="koboSpan" id="kobo.313.1"><img alt="Figure 5.2 – Design of our matching engine component" src="image/B19434_05_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.314.1">Figure 5.2 – Design of our matching engine component</span></p>
<p><span class="koboSpan" id="kobo.315.1">We present a </span><a id="_idIndexMarker760"/><span class="koboSpan" id="kobo.316.1">few more details in this diagram compared to </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.317.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.318.1">.1</span></em><span class="koboSpan" id="kobo.319.1"> by discussing the major design choices for the matching </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">engine next.</span></span></p>
<h3><span class="koboSpan" id="kobo.321.1">Threading model</span></h3>
<p><span class="koboSpan" id="kobo.322.1">In our system, the matching engine, the market data publisher, and the order gateway server will be independent threads. </span><span class="koboSpan" id="kobo.322.2">This is intentional so that each one of these components can </span><a id="_idIndexMarker761"/><span class="koboSpan" id="kobo.323.1">operate independently, and during periods of bursts in market activity, the entire system can achieve maximum throughput. </span><span class="koboSpan" id="kobo.323.2">Also, there are other tasks that each component needs to perform – for example, the order gateway server must maintain connectivity with all market participants, even when the matching engine is busy. </span><span class="koboSpan" id="kobo.323.3">Similarly, let us assume the market data publisher is busy sending out market data on the network; we do not want the matching engine or the order gateway server to slow down. </span><span class="koboSpan" id="kobo.323.4">We already saw how to create threads, set affinity on them, and assign tasks for them to do in the previous chapter, </span><em class="italic"><span class="koboSpan" id="kobo.324.1">Building the C++ Building Blocks for Low-Latency Applications</span></em><span class="koboSpan" id="kobo.325.1">, in the </span><em class="italic"><span class="koboSpan" id="kobo.326.1">C++ threading for multi-threaded low-latency </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.327.1">applications</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.328.1"> section.</span></span></p>
<h3><span class="koboSpan" id="kobo.329.1">Communication between threads</span></h3>
<p><span class="koboSpan" id="kobo.330.1">Another important </span><a id="_idIndexMarker762"/><span class="koboSpan" id="kobo.331.1">thing to discuss here is the communication between the matching engine and the order gateway server infrastructure. </span><span class="koboSpan" id="kobo.331.2">The order gateway server serializes the order requests coming in from the market participants and forwards them to the matching engine for processing. </span><span class="koboSpan" id="kobo.331.3">The matching engine needs to generate a response for order requests and send them back to the order gateway server. </span><span class="koboSpan" id="kobo.331.4">Additionally, it also needs to inform the order gateway server about executions that happen on the participant’s orders so that they can be informed about the trades. </span><span class="koboSpan" id="kobo.331.5">So, it needs a bi-directional queue, or one queue from the order gateway server to the matching engine and another queue from the matching engine to the order </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">gateway server.</span></span></p>
<p><span class="koboSpan" id="kobo.333.1">Another communication channel is when the matching engine generates and sends market data updates to </span><a id="_idIndexMarker763"/><span class="koboSpan" id="kobo.334.1">reflect the updated state of the limit order book for the public market data </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">publisher component.</span></span></p>
<p><span class="koboSpan" id="kobo.336.1">Finally, since the matching engine, the order gateway server, and the market data publisher are all different threads, here we find a perfect case for a lock-free queue. </span><span class="koboSpan" id="kobo.336.2">We will use the lock-free FIFO queue we created in the previous chapter in the </span><em class="italic"><span class="koboSpan" id="kobo.337.1">Transferring data using lock-free </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.338.1">queues</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.339.1"> section.</span></span></p>
<h3><span class="koboSpan" id="kobo.340.1">Limit order book</span></h3>
<p><span class="koboSpan" id="kobo.341.1">Finally, for</span><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.342.1"> the limit order book, we will use a couple of different data structures to implement it efficiently. </span><span class="koboSpan" id="kobo.342.2">Without diving into specific implementation details (which we will look at in the next chapter), we need to maintain the bids and asks in the correct sorted order on both sides to </span><a id="_idIndexMarker764"/><span class="koboSpan" id="kobo.343.1">facilitate efficient matching when aggressive orders come in. </span><span class="koboSpan" id="kobo.343.2">We need to be able to efficiently insert and remove orders from the price levels to support operations such as adding, modifying, and deleting orders based on client requests. </span><span class="koboSpan" id="kobo.343.3">One other particularly important consideration here is that the data structures we use and the order objects themselves must avoid dynamic memory allocations and copy as little data around as possible. </span><span class="koboSpan" id="kobo.343.4">We will make heavy use of the memory pool we created in the previous chapter in the </span><em class="italic"><span class="koboSpan" id="kobo.344.1">Designing C++ memory pools to avoid dynamic memory </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.345.1">allocations</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.346.1"> section.</span></span></p>
<h1 id="_idParaDest-137"><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.347.1">Understanding how an exchange publishes information to participants</span></h1>
<p><span class="koboSpan" id="kobo.348.1">The previous section was dedicated to discussing the details of the matching engine, and in that discussion, we assumed that the matching engine receives market participants’ order requests from the order gateway server infrastructure. </span><span class="koboSpan" id="kobo.348.2">We also implicitly assumed that the matching engine would communicate changes to the limit order book it maintains to all the market participants listening to the market data feed. </span><span class="koboSpan" id="kobo.348.3">In this section, we will discuss the market data publisher and the order gateway server components that the matching engine relies on to communicate with the </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">market participants.</span></span></p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.350.1">Communicating market events through markets data</span></h2>
<p><span class="koboSpan" id="kobo.351.1">Let us discuss the market data publisher component first. </span><span class="koboSpan" id="kobo.351.2">This component is responsible for converting the </span><a id="_idIndexMarker765"/><span class="koboSpan" id="kobo.352.1">updates to the limit order book maintained by the matching engine. </span><span class="koboSpan" id="kobo.352.2">We mentioned before that the market data network level protocol can be TCP or UDP but generally, the preferred protocol in practice is UDP, and that is the protocol we will be using in our market data publisher </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.354.1">In simple terms, the market data protocol represents the format of the messages that the market data publisher publishes over the UDP (or in some cases TCP) protocol. </span><strong class="bold"><span class="koboSpan" id="kobo.355.1">FIX Adapted for STreaming</span></strong><span class="koboSpan" id="kobo.356.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.357.1">FAST</span></strong><span class="koboSpan" id="kobo.358.1">) is the most well-known and popular messaging format for </span><a id="_idIndexMarker766"/><span class="koboSpan" id="kobo.359.1">market data that is currently used by a lot of </span><a id="_idIndexMarker767"/><span class="koboSpan" id="kobo.360.1">electronic trading </span><a id="_idIndexMarker768"/><span class="koboSpan" id="kobo.361.1">exchanges. </span><span class="koboSpan" id="kobo.361.2">There are other protocols, such as </span><strong class="bold"><span class="koboSpan" id="kobo.362.1">ITCH</span></strong><span class="koboSpan" id="kobo.363.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.364.1">PITCH</span></strong><span class="koboSpan" id="kobo.365.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.366.1">Enhanced Order Book Interface</span></strong><span class="koboSpan" id="kobo.367.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.368.1">EOBI</span></strong><span class="koboSpan" id="kobo.369.1">), </span><strong class="bold"><span class="koboSpan" id="kobo.370.1">Simple Binary Encoding</span></strong><span class="koboSpan" id="kobo.371.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.372.1">SBE</span></strong><span class="koboSpan" id="kobo.373.1">), and </span><a id="_idIndexMarker769"/><span class="koboSpan" id="kobo.374.1">many others, but for the purposes </span><a id="_idIndexMarker770"/><span class="koboSpan" id="kobo.375.1">of this book, we will create a simple custom binary protocol such as EOBI or SBE that we </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">will use.</span></span></p>
<p><span class="koboSpan" id="kobo.377.1">Since FIX is the most common protocol used in financial applications, we will present a few details here. </span><span class="koboSpan" id="kobo.377.2">FIX data is organized as a set of </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">TAG</span></strong><span class="koboSpan" id="kobo.379.1">=</span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">VALUE</span></strong><span class="koboSpan" id="kobo.381.1"> style fields. </span><span class="koboSpan" id="kobo.381.2">It will be easier to understand this with a simple example, so for a hypothetical market data update, you might receive the following collection of fields to convey all the data for that update. </span><span class="koboSpan" id="kobo.381.3">This hypothetical market data update corresponds to a new buy order of a quantity of 1,000 being added for the Apple company stock (stock symbol AAPL and numeric security ID 68475) at a price </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">of 175.16.</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table008">
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.383.1">TAG</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.384.1">FIX NAME</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.385.1">VALUE</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.386.1">DESCRIPTION</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.387.1">268</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.388.1">NoMDEntries</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.389.1">1</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.390.1">Number of market </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">data updates</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.392.1">279</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.393.1">MDUpdateAction</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.394.1">0 (New)</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.395.1">Type of market </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">data update</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.397.1">269</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.398.1">MDEntryType</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.399.1">0 (Bid)</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.400.1">Type of market </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">data entry</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.402.1">48</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.403.1">SecurityID</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.404.1">68475 (AAPL)</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.405.1">Integer identifier for the </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">trading product</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.407.1">270</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.408.1">MDEntryPx</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.409.1">175.16</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.410.1">Price of this market </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">data update</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.412.1">271</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.413.1">MDEntrySize</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.414.1">1000</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.415.1">Quantity of this market </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">data update</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.417.1">...</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.418.1">...</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.419.1">...</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.420.1">...</span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.421.1">Table 5.8 – An example of a FIX message corresponding to a hypothetical market data update</span></p>
<p><span class="koboSpan" id="kobo.422.1">The different </span><a id="_idIndexMarker771"/><span class="koboSpan" id="kobo.423.1">kinds of messages that make up the market data protocol are roughly categorized into the </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">following categories:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer031">
<span class="koboSpan" id="kobo.425.1"><img alt="Figure 5.3 – Different market updates that an exchange sends out" src="image/B19434_05_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.426.1">Figure 5.3 – Different market updates that an exchange sends out</span></p>
<p><span class="koboSpan" id="kobo.427.1">Let us discuss </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">these next.</span></span></p>
<h3><span class="koboSpan" id="kobo.429.1">Market state changes</span></h3>
<p><span class="koboSpan" id="kobo.430.1">These messages </span><a id="_idIndexMarker772"/><span class="koboSpan" id="kobo.431.1">notify the market participants about changes in the market and/or matching engine state. </span><span class="koboSpan" id="kobo.431.2">Typically, markets go through states such as </span><strong class="bold"><span class="koboSpan" id="kobo.432.1">Closed</span></strong><span class="koboSpan" id="kobo.433.1"> for trading, </span><strong class="bold"><span class="koboSpan" id="kobo.434.1">Pre-open</span></strong><span class="koboSpan" id="kobo.435.1"> (market state before regular trading sessions), </span><strong class="bold"><span class="koboSpan" id="kobo.436.1">Opening</span></strong><span class="koboSpan" id="kobo.437.1"> (when markets transition from the Pre-open to Trading states), and </span><strong class="bold"><span class="koboSpan" id="kobo.438.1">Trading</span></strong><span class="koboSpan" id="kobo.439.1"> (regular </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">trading session).</span></span></p>
<h3><span class="koboSpan" id="kobo.441.1">Instrument updates</span></h3>
<p><span class="koboSpan" id="kobo.442.1">The exchange uses instrument update messages to inform market participants about the different instruments </span><a id="_idIndexMarker773"/><span class="koboSpan" id="kobo.443.1">available for trading. </span><span class="koboSpan" id="kobo.443.2">Some exchanges support special types of instruments that the market participants can create on the fly, and these messages are used to inform participants about changes to such instruments. </span><span class="koboSpan" id="kobo.443.3">Usually, these messages are used to inform participants about instrument </span><a id="_idIndexMarker774"/><span class="koboSpan" id="kobo.444.1">metadata such as minimum price increments, tick size value, and more. </span><span class="koboSpan" id="kobo.444.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.445.1">minimum price increment</span></strong><span class="koboSpan" id="kobo.446.1"> is the minimum price difference in order prices. </span><span class="koboSpan" id="kobo.446.2">In the examples we have seen so far, we assumed the minimum price increment to be 0.10 (i.e., valid prices are multiples of 0.10). </span><span class="koboSpan" id="kobo.446.3">The </span><strong class="bold"><span class="koboSpan" id="kobo.447.1">tick size value</span></strong><span class="koboSpan" id="kobo.448.1"> is the amount of money made or lost when we buy and sell at prices that are apart by a single minimum price increment. </span><span class="koboSpan" id="kobo.448.2">Very often, for products such as stocks, </span><strong class="bold"><span class="koboSpan" id="kobo.449.1">Exchange Traded Fund</span></strong><span class="koboSpan" id="kobo.450.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.451.1">ETF</span></strong><span class="koboSpan" id="kobo.452.1">s), and so on, the tick size multiplier is just 1, meaning the profit or loss is simply the sell price minus the buy price for a pair of trades. </span><span class="koboSpan" id="kobo.452.2">ETFs are securities that trade at the exchange and are an investment option which consists of a </span><a id="_idIndexMarker775"/><span class="koboSpan" id="kobo.453.1">basket of securities, i.e., by investing in an ETF, you invest in a bunch of assets that make up that ETF. </span><span class="koboSpan" id="kobo.453.2">But for some leveraged products such as futures, options, and so on, this tick size multiplier can be something other than 1, and the final profit or loss is computed </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">as follows:</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">((sell-price – buy-price) / min-price-increment) * trade-qty * </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">tick-size</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.458.1">Order updates</span></h3>
<p><span class="koboSpan" id="kobo.459.1">The market data publisher uses order update messages to communicate changes to the orders in the limit </span><a id="_idIndexMarker776"/><span class="koboSpan" id="kobo.460.1">order book maintained by the matching engine – specifically, updates to the order book similar to what we discussed in the </span><em class="italic"><span class="koboSpan" id="kobo.461.1">Understanding the exchange order book</span></em><span class="koboSpan" id="kobo.462.1"> subsection in the </span><em class="italic"><span class="koboSpan" id="kobo.463.1">Designing the C++ matching engine in a trading exchange</span></em><span class="koboSpan" id="kobo.464.1"> section. </span><span class="koboSpan" id="kobo.464.2">Generally, the different kinds of order updates messages are </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.466.1">Order Add</span></strong><span class="koboSpan" id="kobo.467.1"> – This is used by the exchange to notify the participants that a new passive order </span><a id="_idIndexMarker777"/><span class="koboSpan" id="kobo.468.1">was added to the limit order book. </span><span class="koboSpan" id="kobo.468.2">Typical attributes here are </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">instrument-id</span></strong><span class="koboSpan" id="kobo.470.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">order-id</span></strong><span class="koboSpan" id="kobo.472.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">price</span></strong><span class="koboSpan" id="kobo.474.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">side</span></strong><span class="koboSpan" id="kobo.476.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">quantity</span></strong><span class="koboSpan" id="kobo.478.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">priority</span></strong><span class="koboSpan" id="kobo.480.1">. </span><span class="koboSpan" id="kobo.480.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">priority</span></strong><span class="koboSpan" id="kobo.482.1"> field here is used to specify the position of the order in the FIFO queue of orders at </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">that price.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.484.1">Order Modify</span></strong><span class="koboSpan" id="kobo.485.1"> – This is used by the exchange to let the participants know that a passive order </span><a id="_idIndexMarker778"/><span class="koboSpan" id="kobo.486.1">was modified in price or quantity or both. </span><span class="koboSpan" id="kobo.486.2">This message has similar fields as an Order Add message. </span><span class="koboSpan" id="kobo.486.3">As mentioned before, in most cases (except when the order quantity is reduced), a new order priority value will be assigned for Order </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">Modify events.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.488.1">Order Delete</span></strong><span class="koboSpan" id="kobo.489.1"> – This </span><a id="_idIndexMarker779"/><span class="koboSpan" id="kobo.490.1">message is used to notify the market participants that a passive order was deleted from the order book. </span><span class="koboSpan" id="kobo.490.2">The important attributes here are </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">instrument-id</span></strong><span class="koboSpan" id="kobo.492.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">order-id</span></strong><span class="koboSpan" id="kobo.494.1"> to specify the order being deleted from the </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">order book.</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.496.1">Trade messages</span></h3>
<p><span class="koboSpan" id="kobo.497.1">Trade messages are used by the exchange to notify the market participants that a match happened in the market. </span><span class="koboSpan" id="kobo.497.2">Generally, the attributes here are </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">instrument-id</span></strong><span class="koboSpan" id="kobo.499.1">, side of the aggressive </span><a id="_idIndexMarker780"/><span class="koboSpan" id="kobo.500.1">order, execution price of the trade, and the traded quantity. </span><span class="koboSpan" id="kobo.500.2">Generally, </span><a id="_idIndexMarker781"/><span class="koboSpan" id="kobo.501.1">when trades happen, the exchange also publishes as many Order Delete, Order Modify, and Order Add messages as needed to communicate information about which orders were fully and/or partially executed and need to be removed from the book or modified to reflect the new state of the </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">order book.</span></span></p>
<h3><span class="koboSpan" id="kobo.503.1">Market statistics</span></h3>
<p><span class="koboSpan" id="kobo.504.1">These are optional messages that some exchanges publish to communicate different types of statistics about </span><a id="_idIndexMarker782"/><span class="koboSpan" id="kobo.505.1">trading instruments. </span><span class="koboSpan" id="kobo.505.2">These statistics can be information about traded volume for an instrument, open interest for the instrument, the highest, lowest, opening, and closing prices for the instrument, and </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.507.1">We covered a lot of details about the market data messaging types and the information they try to convey. </span><span class="koboSpan" id="kobo.507.2">Now we are ready to design the market data publisher we will build in our electronic trading </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">exchange next.</span></span></p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.509.1">Designing the market data publisher</span></h2>
<p><span class="koboSpan" id="kobo.510.1">Let us discuss a </span><a id="_idIndexMarker783"/><span class="koboSpan" id="kobo.511.1">few design details for the market data publisher we will implement in our electronic exchange. </span><span class="koboSpan" id="kobo.511.2">We present only the market data publisher from </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.512.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.513.1">.1</span></em><span class="koboSpan" id="kobo.514.1"> here so we can discuss the design in </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">greater detail.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer032">
<span class="koboSpan" id="kobo.516.1"><img alt="Figure 5.4 – Design of our market data publisher infrastructure" src="image/B19434_05_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.517.1">Figure 5.4 – Design of our market data publisher infrastructure</span></p>
<p><span class="koboSpan" id="kobo.518.1">There are two main components of the market data publisher infrastructure. </span><span class="koboSpan" id="kobo.518.2">Both use the socket utilities we </span><a id="_idIndexMarker784"/><span class="koboSpan" id="kobo.519.1">built in the previous chapter in the </span><em class="italic"><span class="koboSpan" id="kobo.520.1">C++ network programming using sockets</span></em><span class="koboSpan" id="kobo.521.1"> section to put the market data on the wire. </span><span class="koboSpan" id="kobo.521.2">This is in addition to the threading library we built, which will be used to create, launch, and run the market data </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">publisher thread.</span></span></p>
<h3><span class="koboSpan" id="kobo.523.1">Market data protocol encoder</span></h3>
<p><span class="koboSpan" id="kobo.524.1">The market data protocol encoder component inside the market data publisher infrastructure is </span><a id="_idIndexMarker785"/><span class="koboSpan" id="kobo.525.1">responsible for encoding </span><a id="_idIndexMarker786"/><span class="koboSpan" id="kobo.526.1">the market data updates published by the matching engine. </span><span class="koboSpan" id="kobo.526.2">The market data encoder consumes market data updates that reflect changes to the order book and converts them into the public market data messaging format with some additional information. </span><span class="koboSpan" id="kobo.526.3">This component also publishes the incremental market data updates to the UDP multicast stream configured for incremental streams. </span><span class="koboSpan" id="kobo.526.4">Remember that the incremental stream only contains market updates that can be used to update the order book, assuming the participant had an accurate view of the limit order book prior to the incremental update. </span><span class="koboSpan" id="kobo.526.5">The encoded market data updates are also published to the snapshot synthesizer component, which we will discuss in more detail in the </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">next section.</span></span></p>
<p><span class="koboSpan" id="kobo.528.1">The market data stream is generally very high volume in terms of network traffic and experiences large bursts in activity, especially during periods of high volatility in the market. </span><span class="koboSpan" id="kobo.528.2">Since the TCP protocol adds extra bandwidth due to acknowledgments of message receipts and retransmissions of lost data, typically, UDP is the network protocol of choice for market data. </span><span class="koboSpan" id="kobo.528.3">Multicast streaming over UDP is also preferred since the market data can be disseminated on the multicast streams once and all interested subscribers can subscribe to that stream instead of having a one-to-one connection with each market data consumer over TCP. </span><span class="koboSpan" id="kobo.528.4">This design is not without some drawbacks, namely the possibility of market data consumers dropping UDP packets due to network congestion, slow hardware or software, and so on. </span><span class="koboSpan" id="kobo.528.5">When that happens, the order book that the trading </span><a id="_idIndexMarker787"/><span class="koboSpan" id="kobo.529.1">client is maintaining is incorrect </span><a id="_idIndexMarker788"/><span class="koboSpan" id="kobo.530.1">since they might have lost an update corresponding to a new order being added, an order being modified or canceled, and so on. </span><span class="koboSpan" id="kobo.530.2">This is the problem that the snapshot multicast streams solve, which we will explore with examples in subsequent chapters as we implement our market data consumers, but we will briefly introduce the snapshot synthesizer component in the </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">next section.</span></span></p>
<h3><span class="koboSpan" id="kobo.532.1">Snapshot synthesizer</span></h3>
<p><span class="koboSpan" id="kobo.533.1">The snapshot synthesizer consumes the encoded market date updates published by the market data protocol encoder, synthesizes the latest snapshot of the limit order book, and publishes the </span><a id="_idIndexMarker789"/><span class="koboSpan" id="kobo.534.1">snapshot periodically to </span><a id="_idIndexMarker790"/><span class="koboSpan" id="kobo.535.1">the snapshot multicast stream. </span><span class="koboSpan" id="kobo.535.2">The important point here is that the snapshot synthesis does not interfere with the incremental stream publishing so that incremental updates to the order book can be published as quickly as possible. </span><span class="koboSpan" id="kobo.535.3">It is a separate thread of execution, and the sole responsibility here is to generate an accurate snapshot of the order book based on the incremental updates. </span><span class="koboSpan" id="kobo.535.4">This component also adds the correct sequence information on the snapshot updates to facilitate synchronization at the client’s end before publishing it on the snapshot UDP multicast stream. </span><span class="koboSpan" id="kobo.535.5">What this means is that in the snapshot messages it sends out, it will provide the last sequence number from the incremental stream that was used to synthesize this snapshot message. </span><span class="koboSpan" id="kobo.535.6">This is important because the downstream market data consumer clients can use this sequence number of the last update in the incremental stream to perform successful synchronization/catch-up. </span><span class="koboSpan" id="kobo.535.7">This will become very clear when we build our market data publisher and market data consumer components because we will cover all the details with examples then. </span><span class="koboSpan" id="kobo.535.8">Another thing to understand is that the low-latency criteria that apply to the other components in our system do not apply here since this is a delayed and sub-sampled stream of information anyway. </span><span class="koboSpan" id="kobo.535.9">Additionally, packet drops are expected to be extremely rare on the client’s end and the snapshot synchronization process is slow on the client’s end, so trying to make this component super low latency is unnecessary. </span><span class="koboSpan" id="kobo.535.10">For our snapshot synthesizer component, we will also use the UDP protocol to keep it simple, but in practice, this is often a combination of TCP and UDP protocols. </span><span class="koboSpan" id="kobo.535.11">For low-latency market participants, packet drops on the UDP stream are expected to be rare because typically, the network connection to the exchange and switches along the way have a large bandwidth capacity and low switching latencies. </span><span class="koboSpan" id="kobo.535.12">Additionally, the participants invest resources into procuring and installing super-fast servers, building low-latency market data consumer software, and using special </span><strong class="bold"><span class="koboSpan" id="kobo.536.1">Network Interface Cards</span></strong><span class="koboSpan" id="kobo.537.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.538.1">NICs</span></strong><span class="koboSpan" id="kobo.539.1">) to handle large </span><a id="_idIndexMarker791"/><span class="koboSpan" id="kobo.540.1">volumes of </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">market data.</span></span></p>
<p><span class="koboSpan" id="kobo.542.1">This concludes our </span><a id="_idIndexMarker792"/><span class="koboSpan" id="kobo.543.1">high-level design of the </span><a id="_idIndexMarker793"/><span class="koboSpan" id="kobo.544.1">market data publisher infrastructure we will build in this book. </span><span class="koboSpan" id="kobo.544.2">Next, we need to discuss the other channel that the exchange uses to notify market participants about responses to their order requests as well as when their orders get executed – the order </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">gateway interface.</span></span></p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.546.1">Notifying market participants through the order gateway interfaces</span></h2>
<p><span class="koboSpan" id="kobo.547.1">We discussed that the market data consumer is used by the electronic trading exchange to disseminate </span><a id="_idIndexMarker794"/><span class="koboSpan" id="kobo.548.1">public information about changes to the order book and matches happening for the different trading instruments available at the exchange. </span><span class="koboSpan" id="kobo.548.2">The point here is that this is public market data that is available to everyone that has access to and is subscribed to the market data stream. </span><span class="koboSpan" id="kobo.548.3">This section will discuss the other interface that the exchange uses to communicate with market participants about updates for their orders – the order </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">gateway interface.</span></span></p>
<p><span class="koboSpan" id="kobo.550.1">There are a few key differences between the information provided by the public market data feed and the information provided by the order </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">gateway infrastructure.</span></span></p>
<h3><span class="koboSpan" id="kobo.552.1">Understanding the difference in network protocols</span></h3>
<p><span class="koboSpan" id="kobo.553.1">We mentioned </span><a id="_idIndexMarker795"/><span class="koboSpan" id="kobo.554.1">this before but we will reiterate here that typically, market </span><a id="_idIndexMarker796"/><span class="koboSpan" id="kobo.555.1">data publishers use the UDP protocol at the network level, and the order gateway infrastructure uses the TCP protocol at the network level in their connections with market participants. </span><span class="koboSpan" id="kobo.555.2">This is because the data published by market data publishers is very voluminous and needs to be published as quickly as possible, hence the choice of UDP over TCP. </span><span class="koboSpan" id="kobo.555.3">There are generally additional synchronization mechanisms available on the market data publisher to deal with rare packet drops over UDP. </span><span class="koboSpan" id="kobo.555.4">The order gateway infrastructure relies on TCP because it needs a reliable method of communicating with the clients, and </span><a id="_idIndexMarker797"/><span class="koboSpan" id="kobo.556.1">packet drops here are difficult to handle gracefully </span><a id="_idIndexMarker798"/><span class="koboSpan" id="kobo.557.1">without TCP. </span><span class="koboSpan" id="kobo.557.2">Intuitively, it should be clear that it would be a major headache if clients were not sure that their orders reached the exchange or if clients weren’t sure they received immediate notifications when their orders are updated </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">or matched.</span></span></p>
<h3><span class="koboSpan" id="kobo.559.1">Differentiating between public and private information</span></h3>
<p><span class="koboSpan" id="kobo.560.1">Perhaps the biggest difference between the market data publisher and the order gateway infrastructure is that the market data publisher publishes public information while hiding some </span><a id="_idIndexMarker799"/><span class="koboSpan" id="kobo.561.1">sensitive information, such </span><a id="_idIndexMarker800"/><span class="koboSpan" id="kobo.562.1">as which client an order belongs to or which clients participated in a matching transaction. </span><span class="koboSpan" id="kobo.562.2">This information is also published for all market participants and is meant to be used to construct the limit order book to reflect the state of a trading instrument. </span><span class="koboSpan" id="kobo.562.3">The order gateway server, on the other hand, only publishes order update notifications to the clients who own the orders that are being updated. </span><span class="koboSpan" id="kobo.562.4">Another way to think about this is that to receive and process public market data, a participant does not need to have any orders in the order book. </span><span class="koboSpan" id="kobo.562.5">But to receive private order gateway notifications the participant must have orders in the book, otherwise, there is nothing for the exchange to notify the client </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">privately about.</span></span></p>
<h3><span class="koboSpan" id="kobo.564.1">Sending order requests for participants’ orders</span></h3>
<p><span class="koboSpan" id="kobo.565.1">Another major difference that should be obvious by now is that the order gateway component </span><a id="_idIndexMarker801"/><span class="koboSpan" id="kobo.566.1">sending facilitates a bi-directional communication channel. </span><span class="koboSpan" id="kobo.566.2">What this means is that clients can send order requests to the exchange such as new orders, modify orders, cancel orders, and so on. </span><span class="koboSpan" id="kobo.566.3">On the other hand, as we discussed, the exchange uses the order gateway infrastructure to send private notifications for market participants’ orders. </span><span class="koboSpan" id="kobo.566.4">The market data publisher infrastructure does not generally service any client requests (i.e., the communication path is from the exchange to market data </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">subscribers only).</span></span></p>
<p><span class="koboSpan" id="kobo.568.1">The final </span><a id="_idIndexMarker802"/><span class="koboSpan" id="kobo.569.1">sending component we need to design on the side of the electronic trading exchange is the order gateway infrastructure we just discussed; let us do that in the </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">next section.</span></span></p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.571.1">Designing the order gateway server</span></h2>
<p><span class="koboSpan" id="kobo.572.1">Let us discuss a </span><a id="_idIndexMarker803"/><span class="koboSpan" id="kobo.573.1">few design details for the order gateway server we will implement in our electronic exchange. </span><span class="koboSpan" id="kobo.573.2">We present only the order gateway server infrastructure from </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.574.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.575.1">.1</span></em><span class="koboSpan" id="kobo.576.1"> here so we can discuss the design of our order gateway server in a little </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">more detail.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer033">
<span class="koboSpan" id="kobo.578.1"><img alt="Figure 5.5 – Design of our order gateway server infrastructure" src="image/B19434_05_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.579.1">Figure 5.5 – Design of our order gateway server infrastructure</span></p>
<p><span class="koboSpan" id="kobo.580.1">We present a few more details in this diagram compared to </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.581.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.582.1">.1</span></em><span class="koboSpan" id="kobo.583.1"> and break down some details about the subcomponents for the order gateway </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">server infrastructure.</span></span></p>
<h3><span class="koboSpan" id="kobo.585.1">TCP connection server/manager</span></h3>
<p><span class="koboSpan" id="kobo.586.1">The first component inside the order gateway infrastructure is the TCP connection manager. </span><span class="koboSpan" id="kobo.586.2">This </span><a id="_idIndexMarker804"/><span class="koboSpan" id="kobo.587.1">component is responsible for setting up a TCP server that listens to and accepts incoming TCP connections from market participants’ order gateway clients. </span><span class="koboSpan" id="kobo.587.2">It is also responsible for detecting clients who disconnect and removing them from the list of active connections. </span><span class="koboSpan" id="kobo.587.3">Finally, this component needs to forward order responses from the </span><a id="_idIndexMarker805"/><span class="koboSpan" id="kobo.588.1">matching engine to the correct client for which the response is meant. </span><span class="koboSpan" id="kobo.588.2">We will use the socket utilities, TCP socket, and TCP server functionality we implemented in the </span><em class="italic"><span class="koboSpan" id="kobo.589.1">C++ network programming using sockets</span></em><span class="koboSpan" id="kobo.590.1"> section in the previous chapter, </span><em class="italic"><span class="koboSpan" id="kobo.591.1">Building the C++ Building Blocks for </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.592.1">Low-Latency Applications</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.594.1">FIFO sequencer</span></h3>
<p><span class="koboSpan" id="kobo.595.1">Another important task this component needs to do is maintain fairness when processing requests from market participants. </span><span class="koboSpan" id="kobo.595.2">As mentioned previously, to maintain fairness, client </span><a id="_idIndexMarker806"/><span class="koboSpan" id="kobo.596.1">responses must be processed in the exact order they were received at the exchange infrastructure. </span><span class="koboSpan" id="kobo.596.2">So, the FIFO sequencer must ensure that it forwards client requests to the matching engine across the different client connections that the TCP connection manager maintains in the order in which they </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">are received.</span></span></p>
<h3><span class="koboSpan" id="kobo.598.1">Exchange messaging protocol decoder and encoder</span></h3>
<p><span class="koboSpan" id="kobo.599.1">The encoder-decoder component is responsible for translating between the exchange messaging </span><a id="_idIndexMarker807"/><span class="koboSpan" id="kobo.600.1">protocol and whatever internal structures the matching engine expects client requests in and publishes client responses in. </span><span class="koboSpan" id="kobo.600.2">Depending on the complexity of the exchange protocol, this can be as straightforward as packaging and extracting the correct fields into and from a packed binary structure. </span><span class="koboSpan" id="kobo.600.3">If the exchange messaging format is more complicated, then there will be additional encoding and decoding steps involved. </span><span class="koboSpan" id="kobo.600.4">For this book’s purposes, we will have a simple exchange order messaging protocol that uses packed binary structures and has additional information on top of the format the exchange matching </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">engine uses.</span></span></p>
<p><span class="koboSpan" id="kobo.602.1">This concludes our discussion of the electronic trading exchange, and now we can move on to building the client-side infrastructure for a market participant that wishes to trade on </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">this exchange.</span></span></p>
<h1 id="_idParaDest-142"><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.604.1">Building a market participant’s interface to the exchange</span></h1>
<p><span class="koboSpan" id="kobo.605.1">We will now discuss the </span><a id="_idIndexMarker808"/><span class="koboSpan" id="kobo.606.1">purpose and design of the components in the market participants’ systems. </span><span class="koboSpan" id="kobo.606.2">Specifically, we will start by discussing the market data consumer in the client’s trading system, which subscribes to, consumes, and decodes the public market data published by the exchange. </span><span class="koboSpan" id="kobo.606.3">We will also discuss the order gateway client infrastructure in the client’s trading system, which connects to the exchange order gateway server. </span><span class="koboSpan" id="kobo.606.4">The order gateway client is also responsible for sending order requests to the exchange and receiving and decoding responses for the </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">client’s orders.</span></span></p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.608.1">Understanding the market data consumer infrastructure</span></h2>
<p><span class="koboSpan" id="kobo.609.1">The market data consumer component in a market participant’s trading system is the direct complement </span><a id="_idIndexMarker809"/><span class="koboSpan" id="kobo.610.1">of the market data publisher component in the electronic trading exchange. </span><span class="koboSpan" id="kobo.610.2">It is responsible for subscribing to and consuming the multicast network traffic that the exchange publishes, decoding and normalizing the market data it reads from the exchange protocol to an internal format, and implementing packet drop-related </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">synchronization mechanisms.</span></span></p>
<h3><span class="koboSpan" id="kobo.612.1">Subscribing to and consuming UDP multicast traffic</span></h3>
<p><span class="koboSpan" id="kobo.613.1">The first and most obvious task is to subscribe to the multicast stream that the exchange is publishing </span><a id="_idIndexMarker810"/><span class="koboSpan" id="kobo.614.1">market data on. </span><span class="koboSpan" id="kobo.614.2">Typically, in the interest of load balancing, the exchange groups different </span><a id="_idIndexMarker811"/><span class="koboSpan" id="kobo.615.1">trading instruments on different multicast stream addresses. </span><span class="koboSpan" id="kobo.615.2">This lets clients choose a subset of all the data that the exchange is publishing, depending on the trading instrument and products that the client is interested in. </span><span class="koboSpan" id="kobo.615.3">Typically, this involves the clients joining the correct multicast streams, the addresses of which are public information available from </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">the exchange.</span></span></p>
<h3><span class="koboSpan" id="kobo.617.1">Decoding and normalizing from exchange protocol</span></h3>
<p><span class="koboSpan" id="kobo.618.1">The next </span><a id="_idIndexMarker812"/><span class="koboSpan" id="kobo.619.1">thing the market data consumer needs to do is convert from the exchange market data protocol into an internal format that the rest of the components in the participant’s </span><a id="_idIndexMarker813"/><span class="koboSpan" id="kobo.620.1">system use. </span><span class="koboSpan" id="kobo.620.2">Depending on the exchange market data protocol, this part of the component can vary in complexity and performance latencies. </span><span class="koboSpan" id="kobo.620.3">The fastest protocols are the ones where minimal decoding is required, such as EOBI and SBE, which are just binary-packed structures. </span><span class="koboSpan" id="kobo.620.4">What this means is that the market data format is such that decoding the stream just involves reinterpreting the byte stream as the binary-packed structure we expect to find in the stream and is as fast as it gets. </span><span class="koboSpan" id="kobo.620.5">More complicated protocols such as FAST generally take longer to decode </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">and normalize.</span></span></p>
<h3><span class="koboSpan" id="kobo.622.1">Synchronizing on startup and packet drops</span></h3>
<p><span class="koboSpan" id="kobo.623.1">Remember that we discussed that usually exchanges prefer UDP to be the network protocol to </span><a id="_idIndexMarker814"/><span class="koboSpan" id="kobo.624.1">deliver market data to the participants. </span><span class="koboSpan" id="kobo.624.2">While this speeds up the delivery of data to clients and achieves higher throughput, this also leaves us open to packet drops and out-of-order delivery due to the unreliable nature of UDP. </span><span class="koboSpan" id="kobo.624.3">To make sure that market participants see market data packets in the correct order, as well as detect packet drops when they occur, typically, there are packet-level and instrument-level sequence numbers that the participants </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">should check.</span></span></p>
<p><span class="koboSpan" id="kobo.626.1">Another thing that needs to be designed, both on the exchange market data publisher and the participants’ market data consumers, is a mechanism to recover from such packet drops. </span><span class="koboSpan" id="kobo.626.2">This same mechanism is also used by participants who join the market data stream after the markets are already open or if the participants need to restart their market data consumer components for any reason. </span><span class="koboSpan" id="kobo.626.3">In all such cases, the market data consumers in the client’s trading system needs to perform some synchronization to get the current and complete state of the limit </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">order book.</span></span></p>
<p><span class="koboSpan" id="kobo.628.1">The commonly used design to achieve this synchronization is explained in this section. </span><span class="koboSpan" id="kobo.628.2">Usually, the exchange market data streams are broken down into two major groups – </span><strong class="bold"><span class="koboSpan" id="kobo.629.1">snapshot streams</span></strong><span class="koboSpan" id="kobo.630.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.631.1">incremental streams</span></strong><span class="koboSpan" id="kobo.632.1">. </span><span class="koboSpan" id="kobo.632.2">We will explain the reason for having these two streams and how they help market participants handle cases of packet </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">drops next.</span></span></p>
<h4><span class="koboSpan" id="kobo.634.1">Incremental market data streams</span></h4>
<p><span class="koboSpan" id="kobo.635.1">The incremental market data stream assumes that the market participant already has the correct view of the limit order book maintained by the matching engine, and this stream only publishes </span><a id="_idIndexMarker815"/><span class="koboSpan" id="kobo.636.1">incremental updates to the previous state </span><a id="_idIndexMarker816"/><span class="koboSpan" id="kobo.637.1">of the order book. </span><span class="koboSpan" id="kobo.637.2">This means that this stream is much lower in bandwidth requirements since it publishes only incremental updates to the book. </span><span class="koboSpan" id="kobo.637.3">Typically, under normal operating conditions, it is expected that market participants only be subscribed to the incremental streams to maintain the correct state of the </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">order book.</span></span></p>
<p><span class="koboSpan" id="kobo.639.1">If the client drops a packet from this stream, then the state of the order book that they maintain might be inconsistent with what the matching engine has. </span><span class="koboSpan" id="kobo.639.2">The mechanism to handle this failure is to clear or reset the order book that the participant maintains. </span><span class="koboSpan" id="kobo.639.3">Then it needs to subscribe to the snapshot stream, which contains data for the full state of the entire order book (instead of only incremental updates) to synchronize to the correct state of the book once again. </span><span class="koboSpan" id="kobo.639.4">The protocol here is to clear the book, start queuing up incremental updates received from the incremental stream and wait to build the full state of the </span><a id="_idIndexMarker817"/><span class="koboSpan" id="kobo.640.1">order book, and then apply the incremental </span><a id="_idIndexMarker818"/><span class="koboSpan" id="kobo.641.1">updates to that full order book to finish the synchronization. </span><span class="koboSpan" id="kobo.641.2">Now, let us understand a few more details of what is published by the exchange on the snapshot market </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">data streams.</span></span></p>
<h4><span class="koboSpan" id="kobo.643.1">Snapshot market data streams</span></h4>
<p><span class="koboSpan" id="kobo.644.1">As we mentioned before, the snapshot market data stream contains data that can be used to build the full order book from a completely empty state. </span><span class="koboSpan" id="kobo.644.2">Usually, this stream just contains a </span><a id="_idIndexMarker819"/><span class="koboSpan" id="kobo.645.1">thorough list of </span><em class="italic"><span class="koboSpan" id="kobo.646.1">Order Add</span></em><span class="koboSpan" id="kobo.647.1"> messages </span><a id="_idIndexMarker820"/><span class="koboSpan" id="kobo.648.1">corresponding to every single passive order that exists in the order book. </span><span class="koboSpan" id="kobo.648.2">The exchange usually throttles how often this list is updated and published, meaning it might only send out a stream of snapshot messages every couple of seconds or so. </span><span class="koboSpan" id="kobo.648.3">This is because, since this stream contains information about all the orders in the order book for every single trading instrument, it can become quite bandwidth-heavy. </span><span class="koboSpan" id="kobo.648.4">Additionally, since packet drops are an exceedingly rare occurrence and participants do not mind waiting a few seconds when they first start up to grab the correct state of the order book, the throttling does not usually have a large </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">negative impact.</span></span></p>
<p><span class="koboSpan" id="kobo.650.1">This concludes the discussion of the market data protocols and the synchronization process, so now we can design the market data consumer that we </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">will implement.</span></span></p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.652.1">Designing the market data consumer</span></h2>
<p><span class="koboSpan" id="kobo.653.1">Let us discuss a </span><a id="_idIndexMarker821"/><span class="koboSpan" id="kobo.654.1">few design details for the market data consumer we will implement in our market participant’s trading system. </span><span class="koboSpan" id="kobo.654.2">We present only the market data consumer from </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.655.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.656.1">.1</span></em><span class="koboSpan" id="kobo.657.1"> here so we can discuss the design in </span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">greater detail.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer034">
<span class="koboSpan" id="kobo.659.1"><img alt="Figure 5.6 – Design of our market data consumer infrastructure" src="image/B19434_05_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.660.1">Figure 5.6 – Design of our market data consumer infrastructure</span></p>
<p><span class="koboSpan" id="kobo.661.1">Let us discuss the two primary subcomponents when it comes to the design of the market data </span><a id="_idIndexMarker822"/><span class="koboSpan" id="kobo.662.1">consumer infrastructure in a market participant’s trading system. </span><span class="koboSpan" id="kobo.662.2">Both use the socket utilities we built in the previous chapter in the </span><em class="italic"><span class="koboSpan" id="kobo.663.1">C++ network programming using sockets</span></em><span class="koboSpan" id="kobo.664.1"> section to subscribe to and consume the market data from </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">the network.</span></span></p>
<h3><span class="koboSpan" id="kobo.666.1">Snapshot and incremental stream synchronizer</span></h3>
<p><span class="koboSpan" id="kobo.667.1">The market data consumer needs to have a subcomponent that can be used to subscribe to </span><a id="_idIndexMarker823"/><span class="koboSpan" id="kobo.668.1">the snapshot </span><a id="_idIndexMarker824"/><span class="koboSpan" id="kobo.669.1">stream in addition to being subscribed to the incremental stream. </span><span class="koboSpan" id="kobo.669.2">Remember that we explained that when a market participant’s system first starts up or needs to restart in the middle of the day or drops a market data packet from the incremental stream, it does not have the correct view of the limit order book. </span><span class="koboSpan" id="kobo.669.3">In such a scenario, the correct recovery/synchronization procedure is to clear the limit order book, subscribe to the snapshot stream, and wait till a full snapshot of the order book is received. </span><span class="koboSpan" id="kobo.669.4">Additionally, the updates that continue to come in over the incremental market data stream need to be queued up. </span><span class="koboSpan" id="kobo.669.5">Once the full snapshot is received and all incremental updates starting from the sequence number of the last update in the snapshot are also queued up and available, we are done. </span><span class="koboSpan" id="kobo.669.6">At this point, the limit order book is reconstructed from the snapshot stream, and all queued-up incremental updates are applied to this book to synchronize/catch up with the exchange. </span><span class="koboSpan" id="kobo.669.7">At this point, the consumer can stop consuming data from the snapshot stream and leave the snapshot stream, and only consume data from the incremental stream. </span><span class="koboSpan" id="kobo.669.8">The component in the market data consumer infrastructure responsible for this synchronization mechanism is what we will refer to as the snapshot and incremental stream </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">synchronization subcomponent.</span></span></p>
<h3><span class="koboSpan" id="kobo.671.1">Market data protocol decoder</span></h3>
<p><span class="koboSpan" id="kobo.672.1">The other subcomponent is responsible for decoding the stream of data coming in from the snapshot and/or the incremental market data streams. </span><span class="koboSpan" id="kobo.672.2">This component translates the data from the </span><a id="_idIndexMarker825"/><span class="koboSpan" id="kobo.673.1">exchange feed format to the internal format of the trading strategy framework. </span><span class="koboSpan" id="kobo.673.2">This is usually a subset of the fields that the exchange provides and is often normalized across different trading exchanges to make the trading strategy framework independent of exchange-specific details. </span><span class="koboSpan" id="kobo.673.3">For our market data consumer infrastructure, we will keep this component quite simple since we will be using a packed binary structure, but as mentioned before, in practice, this can be a much more complicated format such </span><span class="No-Break"><span class="koboSpan" id="kobo.674.1">as FAST.</span></span></p>
<p><span class="koboSpan" id="kobo.675.1">We discussed the details and design of how a market participant’s system consumes the public market data feed from the exchange. </span><span class="koboSpan" id="kobo.675.2">We can move on to the order gateway client infrastructure, which the participant uses to send order requests and receive responses and </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">execution notifications.</span></span></p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.677.1">Understanding the order gateway client infrastructure</span></h2>
<p><span class="koboSpan" id="kobo.678.1">The order gateway client infrastructure in the market participant’s trading system is a TCP client that </span><a id="_idIndexMarker826"/><span class="koboSpan" id="kobo.679.1">connects to the exchange’s order gateway server. </span><span class="koboSpan" id="kobo.679.2">The other task that this component performs is receiving updates from the exchange on this TCP connection, decoding the messages received from the exchange order messaging protocol into a normalized internal format for use by the rest of the system. </span><span class="koboSpan" id="kobo.679.3">Finally, the order gateway client component is also responsible for taking the order actions requested by the trading framework and encoding them in the order messaging format that the exchange understands and sending it through to </span><span class="No-Break"><span class="koboSpan" id="kobo.680.1">the exchange.</span></span></p>
<p><span class="koboSpan" id="kobo.681.1">The important thing to remember here is that the order gateway client must always maintain a reliable TCP connection to the exchange. </span><span class="koboSpan" id="kobo.681.2">This is to make sure that the exchange does not miss any order request from the client and that the client does not miss any updates to its orders from the exchange. </span><span class="koboSpan" id="kobo.681.3">In addition to the reliability mechanisms implemented by the TCP networking protocol itself, there usually exists an application-level reliability mechanism implemented by the exchange and the participants. </span><span class="koboSpan" id="kobo.681.4">This application-level reliability mechanism usually consists of strictly incrementing sequence numbers on the messages sent from exchange to client and from client to </span><a id="_idIndexMarker827"/><span class="koboSpan" id="kobo.682.1">exchange. </span><span class="koboSpan" id="kobo.682.2">Additionally, there can be heart-beating mechanisms in place, which are simply messages sent from exchange to client and client to exchange to check whether a connection is still active during periods of </span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">low activity.</span></span></p>
<p><span class="koboSpan" id="kobo.684.1">Additionally, there are mechanisms to authenticate and identify clients when they first connect, and this is usually implemented as a handshake mechanism with user identification and password, and so on. </span><span class="koboSpan" id="kobo.684.2">There can be additional administrative messages, such as the logon authentication message, and it depends on the exchange and can have a wide range of purposes. </span><span class="koboSpan" id="kobo.684.3">For this book’s purposes, we will limit the scope to not focus on these administrative messages since they do not matter to our low </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">latency goals.</span></span></p>
<p><span class="koboSpan" id="kobo.686.1">Next, let us design our order gateway </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">client infrastructure.</span></span></p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.688.1">Designing the order gateway client infrastructure</span></h2>
<p><span class="koboSpan" id="kobo.689.1">Let us discuss a few </span><a id="_idIndexMarker828"/><span class="koboSpan" id="kobo.690.1">design details for the market data publisher we will implement in our market participant’s trading system. </span><span class="koboSpan" id="kobo.690.2">We present only the order gateway client from </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.691.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.692.1">.1</span></em><span class="koboSpan" id="kobo.693.1"> here so we can discuss the design in </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">greater detail.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer035">
<span class="koboSpan" id="kobo.695.1"><img alt="Figure 5.7 – Design of our order gateway client infrastructure" src="image/B19434_05_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.696.1">Figure 5.7 – Design of our order gateway client infrastructure</span></p>
<p><span class="koboSpan" id="kobo.697.1">There are two </span><a id="_idIndexMarker829"/><span class="koboSpan" id="kobo.698.1">simple components that make up the order gateway client inside the market participant’s </span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">trading system.</span></span></p>
<h3><span class="koboSpan" id="kobo.700.1">TCP connection manager</span></h3>
<p><span class="koboSpan" id="kobo.701.1">The order gateway client in a market participant’s trading system oversees connecting to the exchange </span><a id="_idIndexMarker830"/><span class="koboSpan" id="kobo.702.1">order gateway server and managing that connection. </span><span class="koboSpan" id="kobo.702.2">In practice, a single participant will have multiple connections to the exchange for load balancing, redundancy, and latency reasons. </span><span class="koboSpan" id="kobo.702.3">But in the electronic trading ecosystem that we will be building, we will design it such that an order gateway client creates a single connection to the exchange order gateway server. </span><span class="koboSpan" id="kobo.702.4">We will use the TCP socket client library we built in the previous chapter under the </span><em class="italic"><span class="koboSpan" id="kobo.703.1">C++ network programming using </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.704.1">sockets</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.705.1"> section.</span></span></p>
<h3><span class="koboSpan" id="kobo.706.1">Order gateway protocol encoder and decoder</span></h3>
<p><span class="koboSpan" id="kobo.707.1">The order messaging format encoder and decoder translate order requests from the internal format that </span><a id="_idIndexMarker831"/><span class="koboSpan" id="kobo.708.1">the trading strategy uses to the exchange format and translate order responses and execution notifications from the exchange to an internal format for the strategy framework. </span><span class="koboSpan" id="kobo.708.2">This component can vary in complexity depending on the exchange format, but for our trading system, we will keep the encoding and decoding complexity low by using a </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">binary-packed structure.</span></span></p>
<p><span class="koboSpan" id="kobo.710.1">Next, we move </span><a id="_idIndexMarker832"/><span class="koboSpan" id="kobo.711.1">away from our discussion of the order gateway infrastructure and on to the most complex (and most interesting) component of the participant’s system – the trading </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">strategy framework.</span></span></p>
<h1 id="_idParaDest-147"><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.713.1">Designing a framework for low-latency C++ trading algorithms</span></h1>
<p><span class="koboSpan" id="kobo.714.1">Now that we have discussed the market data consumer and order gateway client components on the market participants’ trading systems, the last component we need to discuss is the </span><a id="_idIndexMarker833"/><span class="koboSpan" id="kobo.715.1">framework that makes trading decisions. </span><span class="koboSpan" id="kobo.715.2">This component is one of the most important components in a trading system since this is where intelligence lies. </span><span class="koboSpan" id="kobo.715.3">By intelligence, we mean the system that processes normalized market data updates, builds a view into the market conditions, and computes trading analytics to find trading opportunities and execute trades. </span><span class="koboSpan" id="kobo.715.4">Obviously, this component relies on the market data consumer to receive decoded and normalized market data updates and uses the order gateway client component to send order requests to and receive order responses from the exchange in a decoded and </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">normalized format.</span></span></p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.717.1">Building the order book</span></h2>
<p><span class="koboSpan" id="kobo.718.1">The market participant needs to construct the limit order book based on the market data that the </span><a id="_idIndexMarker834"/><span class="koboSpan" id="kobo.719.1">exchange publishes. </span><span class="koboSpan" id="kobo.719.2">Note that it is not strictly necessary that the client must build the entire order book, especially if the trading strategies do not require information that is that granular. </span><span class="koboSpan" id="kobo.719.3">For this book’s purposes, we will build a full order book in our trading framework, but we just wanted to point out that it is not strictly necessary in all cases. </span><span class="koboSpan" id="kobo.719.4">A simple example of such a case would be strategies that only care about knowing the prices and/or quantity of the most aggressively priced orders – that is, the highest bid price </span><a id="_idIndexMarker835"/><span class="koboSpan" id="kobo.720.1">and lowest offer price (known as </span><strong class="bold"><span class="koboSpan" id="kobo.721.1">Top Of Book</span></strong><span class="koboSpan" id="kobo.722.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.723.1">TOB</span></strong><span class="koboSpan" id="kobo.724.1">) or </span><strong class="bold"><span class="koboSpan" id="kobo.725.1">Best Bid and Offer</span></strong><span class="koboSpan" id="kobo.726.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.727.1">BBO</span></strong><span class="koboSpan" id="kobo.728.1">)). </span><span class="koboSpan" id="kobo.728.2">Another </span><a id="_idIndexMarker836"/><span class="koboSpan" id="kobo.729.1">example would be strategies that only rely on trade prices to make decisions and do not require a view into the full </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">order book.</span></span></p>
<p><span class="koboSpan" id="kobo.731.1">One thing to reiterate here is that the order book that the client builds is slightly different from the one that the exchange maintains because the client does not usually know which order belongs to which market participant. </span><span class="koboSpan" id="kobo.731.2">Additionally, depending on the exchange, a few more pieces of information might be hidden from the market participants, such as which orders are icebergs, which new orders are stop orders, self-match-prevention considerations, and so on. </span><strong class="bold"><span class="koboSpan" id="kobo.732.1">Iceberg orders</span></strong><span class="koboSpan" id="kobo.733.1"> are orders that have a larger hidden quantity </span><a id="_idIndexMarker837"/><span class="koboSpan" id="kobo.734.1">than what is displayed in the public market data. </span><strong class="bold"><span class="koboSpan" id="kobo.735.1">Stop orders</span></strong><span class="koboSpan" id="kobo.736.1"> are orders that lie dormant </span><a id="_idIndexMarker838"/><span class="koboSpan" id="kobo.737.1">and then become active when a specific price trades. </span><strong class="bold"><span class="koboSpan" id="kobo.738.1">Self-match prevention</span></strong><span class="koboSpan" id="kobo.739.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.740.1">SMP</span></strong><span class="koboSpan" id="kobo.741.1">) is a constraint that prevents a client from </span><a id="_idIndexMarker839"/><span class="koboSpan" id="kobo.742.1">trading against themselves, which some exchanges choose to enforce in the matching engine. </span><span class="koboSpan" id="kobo.742.2">For the purposes of this book, we will </span><a id="_idIndexMarker840"/><span class="koboSpan" id="kobo.743.1">ignore and not implement such special functionality. </span><span class="koboSpan" id="kobo.743.2">Another thing to understand is that the book that the trading participants have is a slightly delayed version of the order book that the matching engine has. </span><span class="koboSpan" id="kobo.743.3">This is because there is some latency between the matching engine updating its order book to the trading client getting the market updates corresponding to the changes and updating </span><span class="No-Break"><span class="koboSpan" id="kobo.744.1">their book.</span></span></p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.745.1">Building a feature engine</span></h2>
<p><span class="koboSpan" id="kobo.746.1">Sophisticated trading strategies need to build additional intelligence over just the order book. </span><span class="koboSpan" id="kobo.746.2">These trading strategies need to implement various trading signals and intelligence </span><a id="_idIndexMarker841"/><span class="koboSpan" id="kobo.747.1">on top of the prices, liquidity, trade transactions, and order book published by the exchange. </span><span class="koboSpan" id="kobo.747.2">The idea here is to build intelligence, which can be a combination of technical analysis style indicators, statistical predictive signals and models, and market microstructure-related statistical edges. </span><span class="koboSpan" id="kobo.747.3">A detailed discussion of various kinds of trading signals and predictive analysis is outside the scope of this book, but there are plenty of texts dedicated to this topic. </span><span class="koboSpan" id="kobo.747.4">There are many different terms used in practice for such predictive edges – trading signals, indicators, features, and so on. </span><span class="koboSpan" id="kobo.747.5">The component inside the trading system that constructs and wires together a collection of such predictive signals is often </span><a id="_idIndexMarker842"/><span class="koboSpan" id="kobo.748.1">referred to as a feature/signal/indicator engine. </span><span class="koboSpan" id="kobo.748.2">In this book, we will build a minimal feature engine for our trading strategies, but we reiterate here that feature engines can get quite sophisticated and complicated depending on the </span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">strategy’s complexity.</span></span></p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.750.1">Developing the execution logic</span></h2>
<p><span class="koboSpan" id="kobo.751.1">After building the order book and deriving some trading signals from the current state of the market, if the trading strategies find an opportunity, they still need to execute their orders at the </span><a id="_idIndexMarker843"/><span class="koboSpan" id="kobo.752.1">exchange. </span><span class="koboSpan" id="kobo.752.2">This is achieved by sending new orders, modifying existing orders to either move them to a more aggressive or less aggressive price, and/or canceling existing orders to avoid getting filled on them. </span><span class="koboSpan" id="kobo.752.3">The subcomponent in the trading infras</span><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.753.1">tructure responsible for sending, modifying, and canceling orders – basically, managing a strategy’s orders at the exchange – is called the execution system. </span><span class="koboSpan" id="kobo.753.2">For the execution systems, the ability to react quickly to market data and order responses coming from the exchange and send out order requests as quickly as possible is extremely important. </span><span class="koboSpan" id="kobo.753.3">A large part of a high-frequency trading system’s profitability and sustainability depends on achieving the lowest possible latencies in the </span><span class="No-Break"><span class="koboSpan" id="kobo.754.1">execution systems.</span></span></p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.755.1">Understanding the risk management systems</span></h2>
<p><span class="koboSpan" id="kobo.756.1">The risk management </span><a id="_idIndexMarker844"/><span class="koboSpan" id="kobo.757.1">system is an important piece of the trading strategy infrastructure. </span><span class="koboSpan" id="kobo.757.2">Technically </span><a id="_idIndexMarker845"/><span class="koboSpan" id="kobo.758.1">speaking, in practice, there are multiple layers of risk management systems in a modern electronic trading ecosystem. </span><span class="koboSpan" id="kobo.758.2">In practice, there are risk management systems in the client’s trading strategy framework, order gateway clients in the market participant’s system, and backend systems at the clearing broker’s end. </span><span class="koboSpan" id="kobo.758.3">For this book’s purposes, we will only implement a minimal risk management system in the trading strategy framework. </span><span class="koboSpan" id="kobo.758.4">Risk management systems try to manage the different forms of risk, as depicted in the </span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer036">
<span class="koboSpan" id="kobo.760.1"><img alt="Figure 5.8 – Different risk metrics in an automated risk management system" src="image/B19434_05_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.761.1">Figure 5.8 – Different risk metrics in an automated risk management system</span></p>
<p><span class="koboSpan" id="kobo.762.1">Let us discuss </span><a id="_idIndexMarker846"/><span class="koboSpan" id="kobo.763.1">these risk measures in more </span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">detail next.</span></span></p>
<h3><span class="koboSpan" id="kobo.765.1">Risk based on order quantities</span></h3>
<p><span class="koboSpan" id="kobo.766.1">One measure that a lot of trading systems care about is the maximum possible quantity that the algorithm is </span><a id="_idIndexMarker847"/><span class="koboSpan" id="kobo.767.1">allowed to send for a single order. </span><span class="koboSpan" id="kobo.767.2">This is mostly to prevent bugs and user errors in the system where the algorithm ends up accidentally sending an order much larger than expected. </span><span class="koboSpan" id="kobo.767.3">These types of errors in practice are referred to as </span><strong class="bold"><span class="koboSpan" id="kobo.768.1">Fat Finger</span></strong><span class="koboSpan" id="kobo.769.1"> errors, to refer to what would happen if a user </span><a id="_idIndexMarker848"/><span class="koboSpan" id="kobo.770.1">accidentally pressed more keys </span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">than intended.</span></span></p>
<h3><span class="koboSpan" id="kobo.772.1">Risk based on firm positions</span></h3>
<p><span class="koboSpan" id="kobo.773.1">An obvious measure of risk is the position that a strategy has in a certain trading instrument. </span><span class="koboSpan" id="kobo.773.2">The size of the position directly dictates how much money is lost if the market prices change a certain amount. </span><span class="koboSpan" id="kobo.773.3">This is why the realized position that a strategy or a firm has in a certain trading instrument is an extremely important one and is closely monitored to make sure it falls within agreed-upon limits. </span><span class="koboSpan" id="kobo.773.4">Note that realized position is the position that the strategy currently holds, and this ignores additional orders that the strategy might have, which might increase or decrease the position </span><span class="No-Break"><span class="koboSpan" id="kobo.774.1">on execution.</span></span></p>
<h3><span class="koboSpan" id="kobo.775.1">Risk based on worst-case position</span></h3>
<p><span class="koboSpan" id="kobo.776.1">Note that in the last section, we mentioned that realized position metrics ignore how many additional live orders exist in the market. </span><span class="koboSpan" id="kobo.776.2">The worst-case scenario position metric tracks what the position would be considering the live orders on the side that would increase the realized position along with the actual realized position. </span><span class="koboSpan" id="kobo.776.3">This means if the strategy or firm is long (position from buying an instrument), then it will also check how much additional unexecuted buy quantity the strategy has in the market to compute the absolute worst-case position. </span><span class="koboSpan" id="kobo.776.4">This is important because some strategies might never build up to large positions but might always have a lot of active orders in the market. </span><span class="koboSpan" id="kobo.776.5">The perfect example of such a strategy is a market-making strategy, which we will see later in this book, but the point here is that it is important to think about worst-case scenarios when it comes to </span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">risk management.</span></span></p>
<h3><span class="koboSpan" id="kobo.778.1">Risk to manage realized and unrealized loss</span></h3>
<p><span class="koboSpan" id="kobo.779.1">This is what most people think of when they think of risk in the context of electronic trading. </span><span class="koboSpan" id="kobo.779.2">This risk metric tracks and imposes limits on how much money a strategy or firm has lost. </span><span class="koboSpan" id="kobo.779.3">If that </span><a id="_idIndexMarker849"/><span class="koboSpan" id="kobo.780.1">value crosses a certain threshold, then depending on how much the firm has in its brokerage account, how much collateral they have, and so on, there can be consequences for the firm. </span><span class="koboSpan" id="kobo.780.2">Not only is it important to track the realized losses for a strategy when the strategy opens and closes positions but it is also important to track the open positions against the </span><span class="No-Break"><span class="koboSpan" id="kobo.781.1">market prices.</span></span></p>
<p><span class="koboSpan" id="kobo.782.1">To understand this, let us explain the following scenario: a strategy buys a certain quantity of an instrument and then sells the same amount of quantity back at a lower price where the strategy has a realized loss and no open position. </span><span class="koboSpan" id="kobo.782.2">Now, let us say the strategy buys some amount of the trading instrument, and then after the purchase where the strategy has a long position, the price of the instrument in the market moves lower. </span><span class="koboSpan" id="kobo.782.3">Here, this strategy not only has the realized loss it is carrying from the previous set of trades but now it also has an unrealized loss on this most recently opened long position. </span><span class="koboSpan" id="kobo.782.4">The risk management system needs to compute realized and unrealized losses in near real time to get an accurate view of the </span><span class="No-Break"><span class="koboSpan" id="kobo.783.1">actual risk.</span></span></p>
<h3><span class="koboSpan" id="kobo.784.1">Risk based on traded volumes</span></h3>
<p><span class="koboSpan" id="kobo.785.1">This measure is not necessarily a risk; a stra</span><a id="_idTextAnchor162"/><span class="koboSpan" id="kobo.786.1">tegy that trades a lot of volume on a certain day or in general is not a problem in itself. </span><span class="koboSpan" id="kobo.786.2">This risk metric seeks mostly to prevent runaway algorithms from overtrading in the market in cases of software or configuration bugs or just unexpected market conditions. </span><span class="koboSpan" id="kobo.786.3">This can be implemented in many ways, but the simplest implementation would be to have a cap on how much volume a strategy is allowed to trade for a trading instrument before it automatically stops sending any new orders or trading further. </span><span class="koboSpan" id="kobo.786.4">Usually, at this point, an external human operator needs to make sure that the algorithm behavior is as expected and then resume the trading strategy or </span><span class="No-Break"><span class="koboSpan" id="kobo.787.1">stop it.</span></span></p>
<h3><span class="koboSpan" id="kobo.788.1">Risk to manage rate of orders, trades, and losses</span></h3>
<p><span class="koboSpan" id="kobo.789.1">The risk metrics we will discuss in this subsection fall into the </span><strong class="bold"><span class="koboSpan" id="kobo.790.1">rate-based</span></strong><span class="koboSpan" id="kobo.791.1"> risk management category. </span><span class="koboSpan" id="kobo.791.2">What we mean by rate-based is that the risk is computed for sliding windows of time to make sure that the strategy does not send too many orders in each window, does not trade too much in each time window, does not lose too much money in each window, and so on. </span><span class="koboSpan" id="kobo.791.3">Again, these metrics are to prevent trading strategy behavior that is </span><a id="_idIndexMarker850"/><span class="koboSpan" id="kobo.792.1">unexpected or resembles an out-of-control or runaway algorithm. </span><span class="koboSpan" id="kobo.792.2">These are implemented by either resetting the counters for the underlying metric (number of orders or number of trades or traded volume or loss) at the end of the time-period window or using a rolling counter of these metrics. </span><span class="koboSpan" id="kobo.792.3">These risk metrics also implicitly prevent the trading strategy from behaving unexpectedly during periods of super-heightened volatility or flash </span><span class="No-Break"><span class="koboSpan" id="kobo.793.1">crash-style scenarios.</span></span></p>
<p><span class="koboSpan" id="kobo.794.1">Finally, we will design the last major component in our electronic </span><span class="No-Break"><span class="koboSpan" id="kobo.795.1">trading ecosystem.</span></span></p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor163"/><span class="koboSpan" id="kobo.796.1">Designing our trading strategy framework</span></h2>
<p><span class="koboSpan" id="kobo.797.1">Let us discuss a few </span><a id="_idIndexMarker851"/><span class="koboSpan" id="kobo.798.1">design details for the trading strategy framework we will implement in our participant’s trading system. </span><span class="koboSpan" id="kobo.798.2">We present only the trading strategy framework from </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.799.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.800.1">.1</span></em><span class="koboSpan" id="kobo.801.1"> here so we can discuss the design in </span><span class="No-Break"><span class="koboSpan" id="kobo.802.1">greater detail.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer037">
<span class="koboSpan" id="kobo.803.1"><img alt="Figure 5.9 – Design of our trading strategy framework" src="image/B19434_05_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.804.1">Figure 5.9 – Design of our trading strategy framework</span></p>
<p><span class="koboSpan" id="kobo.805.1">Now we will discuss the design of the major subcomponents in the trading strategy framework we </span><a id="_idIndexMarker852"/><span class="koboSpan" id="kobo.806.1">will build in this book. </span><span class="koboSpan" id="kobo.806.2">Note that we use the terms </span><strong class="bold"><span class="koboSpan" id="kobo.807.1">trading strategy framework</span></strong><span class="koboSpan" id="kobo.808.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.809.1">trading engine</span></strong><span class="koboSpan" id="kobo.810.1"> interchangeably and they mean the same thing in the context of this book – a collection of components to house and run automated </span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">trading algorithms.</span></span></p>
<h3><a id="_idTextAnchor164"/><span class="koboSpan" id="kobo.812.1">Limit order book</span></h3>
<p><span class="koboSpan" id="kobo.813.1">The limit order book in the trading strategy framework is similar to the one that the exchange matching </span><a id="_idIndexMarker853"/><span class="koboSpan" id="kobo.814.1">engine builds. </span><span class="koboSpan" id="kobo.814.2">Obviously, the goal here is not to perform matching between orders but instead to build, maintain, and </span><a id="_idIndexMarker854"/><span class="koboSpan" id="kobo.815.1">update the limit order book from the market data updates consumed by the market data consumer via the lock-free queue. </span><span class="koboSpan" id="kobo.815.2">The requirement to support efficient insertion, modification, and deletion of orders into this book still applies here. </span><span class="koboSpan" id="kobo.815.3">The other goal here is to also make this order book accessible for use cases that the feature engine and trading strategy components require. </span><span class="koboSpan" id="kobo.815.4">There can be various use cases; one example is being able to synthesize a BBO or TOB quickly and efficiently for components that only need the best prices and quantities. </span><span class="koboSpan" id="kobo.815.5">Another example would be the ability to track the strategy’s own orders in the limit order book to find where they are in the FIFO queue at a price level. </span><span class="koboSpan" id="kobo.815.6">Yet another example would be the ability to detect executions on a strategy’s orders from the public market data feed, which can be a big boost during times when the private order feed is lagging behind the public market data feed. </span><span class="koboSpan" id="kobo.815.7">Implementing these details in the trading strategies we build in this book is out of the scope of what we can cover. </span><span class="koboSpan" id="kobo.815.8">But in practice, these details are extremely important since the advantage one gains from detecting executions from both the order responses and market data can be tens, hundreds, or even </span><a id="_idIndexMarker855"/><span class="koboSpan" id="kobo.816.1">thousands of microseconds in latency. </span><span class="koboSpan" id="kobo.816.2">Here, we </span><a id="_idIndexMarker856"/><span class="koboSpan" id="kobo.817.1">will use the lock-free queue that we built in the </span><em class="italic"><span class="koboSpan" id="kobo.818.1">Transferring data using lock-free queues</span></em><span class="koboSpan" id="kobo.819.1"> section and the memory pool we built in the </span><em class="italic"><span class="koboSpan" id="kobo.820.1">Designing C++ memory pools to avoid dynamic memory allocations</span></em><span class="koboSpan" id="kobo.821.1"> section in the previous chapter, </span><em class="italic"><span class="koboSpan" id="kobo.822.1">Building the C++ Building Blocks for </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.823.1">Low-Latency Applications</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.824.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.825.1">Feature engine</span></h3>
<p><span class="koboSpan" id="kobo.826.1">We mentioned before that we will be building a minimal feature engine in this book. </span><span class="koboSpan" id="kobo.826.2">Our feature engine will only support a single feature computed from the data available from our order </span><a id="_idIndexMarker857"/><span class="koboSpan" id="kobo.827.1">book, and this single feature will be used </span><a id="_idIndexMarker858"/><span class="koboSpan" id="kobo.828.1">to drive our trading strategies. </span><span class="koboSpan" id="kobo.828.2">This feature will be updated when there are substantial changes to the order book in terms of price or liquidity and as trades occur in the market. </span><span class="koboSpan" id="kobo.828.3">When the feature is updated, the trading strategy can use the new feature value to re-evaluate its position, live orders, and so on to make a </span><span class="No-Break"><span class="koboSpan" id="kobo.829.1">trading decision.</span></span></p>
<h3><span class="koboSpan" id="kobo.830.1">Trading strategy</span></h3>
<p><span class="koboSpan" id="kobo.831.1">The trading strategy is the component that finally makes the trading decisions based on a multitude of factors. </span><span class="koboSpan" id="kobo.831.2">The trading decisions depend on the trading algorithm itself, the feature values from </span><a id="_idIndexMarker859"/><span class="koboSpan" id="kobo.832.1">the feature engine, the </span><a id="_idIndexMarker860"/><span class="koboSpan" id="kobo.833.1">state of the order book, the prices and FIFO position of the strategy’s orders in the order book, risk evaluations from the risk manager, the state of the live orders from the order manager, and so on. </span><span class="koboSpan" id="kobo.833.2">This is where most of the complexity of the trading strategy framework resides because it needs to handle a lot of different conditions and execute the orders safely and profitably. </span><span class="koboSpan" id="kobo.833.3">In this book, we will build two </span><a id="_idIndexMarker861"/><span class="koboSpan" id="kobo.834.1">distinct kinds of basic trading algorithms – </span><strong class="bold"><span class="koboSpan" id="kobo.835.1">market-making</span></strong><span class="koboSpan" id="kobo.836.1">, also known as </span><strong class="bold"><span class="koboSpan" id="kobo.837.1">liquidity-providing strategies</span></strong><span class="koboSpan" id="kobo.838.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.839.1">taking strategies</span></strong><span class="koboSpan" id="kobo.840.1">, also known as </span><strong class="bold"><span class="koboSpan" id="kobo.841.1">liquidity-removing strategies</span></strong><span class="koboSpan" id="kobo.842.1">. </span><span class="koboSpan" id="kobo.842.2">Market-making strategies have </span><a id="_idIndexMarker862"/><span class="koboSpan" id="kobo.843.1">passive orders in the book and rely on other market participants crossing the spread to trade against us. </span><span class="koboSpan" id="kobo.843.2">Liquidity-taking strategies are the strategies that cross the spread and send aggressive orders to take out </span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">passive liquidity.</span></span></p>
<h3><span class="koboSpan" id="kobo.845.1">Order manager</span></h3>
<p><span class="koboSpan" id="kobo.846.1">The order manager component is an abstraction that hides the lower-level details of sending order requests, managing the states of active orders, handling </span><strong class="bold"><span class="koboSpan" id="kobo.847.1">in-flight conditions</span></strong><span class="koboSpan" id="kobo.848.1"> (we will explain this shortly) for these orders, handling responses from the exchange, handling </span><a id="_idIndexMarker863"/><span class="koboSpan" id="kobo.849.1">scenarios around partial and full </span><a id="_idIndexMarker864"/><span class="koboSpan" id="kobo.850.1">executions of orders, and managing positions. </span><span class="koboSpan" id="kobo.850.2">The order manager also builds and maintains a couple of different data structures to track the state of the strategy’s orders. </span><span class="koboSpan" id="kobo.850.3">In some sense, the order manager is like the limit order book, except it manages a tiny subset of the orders that belong to </span><span class="No-Break"><span class="koboSpan" id="kobo.851.1">the strategy.</span></span></p>
<p><span class="koboSpan" id="kobo.852.1">On the other hand, there is some additional complexity in the order management since there are some cases where order requests are in-flight from the market participant to the exchange and some events happen in the exchange matching engine at the same time. </span><span class="koboSpan" id="kobo.852.2">An example of an in-flight condition would be the scenario where the client tries to cancel an active order and sends a cancel request to the exchange. </span><span class="koboSpan" id="kobo.852.3">But while this cancel request is in-flight to the exchange, the matching engine at the exchange executes the order because an aggressor that would match this order shows up. </span><span class="koboSpan" id="kobo.852.4">Then, by the time the cancel request finally reaches the matching engine, the order is already executed and removed from the limit order book at the exchange, resulting in a cancel reject for this request. </span><span class="koboSpan" id="kobo.852.5">The order manager needs to be able to handle all different scenarios like this one accurately </span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">and efficiently.</span></span></p>
<p><span class="koboSpan" id="kobo.854.1">In this book, we will build an order manager that can be used to manage passive and aggressive orders and can handle all these </span><span class="No-Break"><span class="koboSpan" id="kobo.855.1">different conditions.</span></span></p>
<h3><span class="koboSpan" id="kobo.856.1">Risk manager</span></h3>
<p><span class="koboSpan" id="kobo.857.1">The risk manager tracks the different risk metrics we described in the previous section, </span><em class="italic"><span class="koboSpan" id="kobo.858.1">Understanding the risk management systems</span></em><span class="koboSpan" id="kobo.859.1">. </span><span class="koboSpan" id="kobo.859.2">Additionally, the risk manager needs to notify the </span><a id="_idIndexMarker865"/><span class="koboSpan" id="kobo.860.1">trading strategy about events where </span><a id="_idIndexMarker866"/><span class="koboSpan" id="kobo.861.1">risk limits are breached so that the trading strategy can reduce risk and/or shut down safely. </span><span class="koboSpan" id="kobo.861.2">In our trading infrastructure, we will implement a few basic risk metrics, such as position, total loss, and messaging rates for </span><span class="No-Break"><span class="koboSpan" id="kobo.862.1">order requests.</span></span></p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor165"/><span class="koboSpan" id="kobo.863.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.864.1">This concludes our discussion of the details and design of the major components in our electronic trading ecosystem. </span><span class="koboSpan" id="kobo.864.2">Let us summarize the concepts, components, and interactions we discussed, as well as the design of the components that build the electronic trading ecosystem we </span><span class="No-Break"><span class="koboSpan" id="kobo.865.1">will build.</span></span></p>
<p><span class="koboSpan" id="kobo.866.1">We started off by presenting the topology of the electronic trading ecosystem. </span><span class="koboSpan" id="kobo.866.2">This consists of the electronic trading exchange and many market participants that want to trade on that exchange. </span><span class="koboSpan" id="kobo.866.3">The electronic trading exchange infrastructure itself consists of three major components at a high level – the matching engine, the market data publisher, and the order gateway server infrastructure. </span><span class="koboSpan" id="kobo.866.4">From a market participant’s perspective, the major components are the market data subscriber and consumer, the trading strategy framework with all its subcomponents, and the order gateway </span><span class="No-Break"><span class="koboSpan" id="kobo.867.1">client infrastructure.</span></span></p>
<p><span class="koboSpan" id="kobo.868.1">Next, we performed a deep dive into the exchange matching engine details. </span><span class="koboSpan" id="kobo.868.2">We explained the responsibilities of this component and how it builds, maintains, and updates the limit order book and matches participant orders that cross against each other. </span><span class="koboSpan" id="kobo.868.3">We concluded that section by designing our simplified matching engine component and its subcomponents, which we will implement in the </span><span class="No-Break"><span class="koboSpan" id="kobo.869.1">next chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.870.1">The next topics of discussion were the market data publisher and the order gateway server infrastructure at the exchange. </span><span class="koboSpan" id="kobo.870.2">We described in great detail the different messages that the market data feed is composed of, the market data feed protocol, as well as designing the components inside the market data publisher. </span><span class="koboSpan" id="kobo.870.3">We also discussed the order gateway server, which the exchange hosts as an endpoint for the market participants to connect to, forward order requests, and receive order responses and notifications for their orders getting executed by the matching engine. </span><span class="koboSpan" id="kobo.870.4">We presented the design of the order gateway server with all its subcomponents, which we will implement in later chapters of </span><span class="No-Break"><span class="koboSpan" id="kobo.871.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.872.1">The section following that took a look at the market participants’ trading systems. </span><span class="koboSpan" id="kobo.872.2">First, we discussed the details for the market data consumer and the order gateway client infrastructure, which the participants use to consume the public market data feed from the exchange and connect to and communicate with the exchange. </span><span class="koboSpan" id="kobo.872.3">We also presented and discussed the design of the market data consumer we will build, as well as how it synchronizes and decodes the exchange market data feed. </span><span class="koboSpan" id="kobo.872.4">Finally, we designed the order gateway client infrastructure, which the trading system will use to connect to and communicate with the exchange’s order gateway </span><span class="No-Break"><span class="koboSpan" id="kobo.873.1">server infrastructure.</span></span></p>
<p><span class="koboSpan" id="kobo.874.1">The final section of this chapter was dedicated to describing and designing the framework for trading strategies. </span><span class="koboSpan" id="kobo.874.2">We described the major components we will need to build this framework – the order book, the feature engine, the execution logic framework, and the risk management subcomponent. </span><span class="koboSpan" id="kobo.874.3">Finally, we laid out the design of the trading infrastructure we will build so that you can understand the higher-level design of this component before we dive into the lower-level details in </span><span class="No-Break"><span class="koboSpan" id="kobo.875.1">subsequent chapters.</span></span></p>
<p><span class="koboSpan" id="kobo.876.1">The next chapter jumps into the implementation details of the matching engine framework we designed in this chapter. </span><span class="koboSpan" id="kobo.876.2">Note that we will reuse a lot of the basic building blocks we built in the previous chapter moving forward as we implement our electronic trading ecosystem. </span><span class="koboSpan" id="kobo.876.3">The motivation for building the basic building blocks will become clearer as we implement the rest of the system, starting in the </span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">next chapter.</span></span></p>
</div>
</body></html>