<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-213"><a id="_idTextAnchor562"/>12</h1>
<h1 id="_idParaDest-214"><a id="_idTextAnchor563"/>Friend Factory</h1>
<p>In this chapter, we are going to talk about making friends. We mean C++ friends here, not friends of C++ (you find those in your local C++ users group). In C++, friends of classes are functions or other classes that are granted special access to the class. In that way, they are not so different from your friends. But C++ can just manufacture friends as needed, on demand!</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>How do friend functions work in C++ and what do they do?</li>
<li>When should you use friend functions versus class member functions?</li>
<li>How to combine friends and templates</li>
<li>How to generate friend functions from templates<a id="_idTextAnchor564"/></li>
</ul>
<h1 id="_idParaDest-215"><a id="_idTextAnchor565"/>Technical requirements</h1>
<p>The example code for this chapter can be found at the following GitHub link: https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter12.<a id="_idTextAnchor566"/></p>
<h1 id="_idParaDest-216"><a id="_idTextAnchor567"/>Friends in C++</h1>
<p>Let’s start by<a id="_idIndexMarker663"/> reviewing the way in which C++ grants friendship to classes, and the effects of this action, as well as when and <a id="_idIndexMarker664"/>for what reasons the friendship should be used (“my code does not compile until I add <code>friend</code> everywhere” is not a valid reason, but an indication of a poorly designed interface - redesign your classes instead<a id="_idTextAnchor568"/>)<a id="_idTextAnchor569"/>.</p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor570"/>How to grant friendship in C++</h2>
<p>A <em class="italic">friend</em> is a C++ concept that applies to classes and <a id="_idIndexMarker665"/>affects the access to class members (<em class="italic">access</em> is what <code>public</code> and <code>private</code> control). Usually, public member functions and data members are accessible to anyone, and private ones are only accessible to other member functions of the class itself. The following code does not compile because the data member <code>C:x_</code> is private:</p>
<pre class="source-code">
// Example 01
class C {
  int x_;
  public:
  C(int x) : x_(x) {}
};
C increase(C c, int dx) {
  return C(c.x_ + dx);     // Does not compile
}</pre>
<p>The easiest way to solve this particular problem is to make <code>increase()</code> a member function, but let’s stay with this version for a moment. The other option is to relax access and make <code>C::x_</code> public. That is a bad idea because it exposes <code>x_</code> - not just to <code>increase()</code>, but to any other code out there that wants to directly modify an object of type <code>C</code>. What we need is to make <code>x_</code> public, or at least accessible, to <code>increase()</code> and to nobody else. This is done with a friend declaration:</p>
<pre class="source-code">
// Example 02
class C {
  int x_;
  public:
  C(int x) : x_(x) {}
  friend C increase(C c, int dx);
};
C increase(C c, int dx) {
  return C(c.x_ + dx);    // Now it compiles
}</pre>
<p>The friend declaration does nothing more than give the specified function the same access as the class member functions get. There is also a form of friend declaration that grants friendship not<a id="_idIndexMarker666"/> to a function, but to a class; this is just a way to grant friendship to all member functions of that cl<a id="_idTextAnchor571"/>a<a id="_idTextAnchor572"/>ss.</p>
<h2 id="_idParaDest-218"><a id="_idTextAnchor573"/>Friends versus member functions</h2>
<p>We do have to come back<a id="_idIndexMarker667"/> to the question, why not just make <code>increase()</code> a member function of the <code>C</code> class? In the example given in the preceding section, there’s<a id="_idIndexMarker668"/> no reason to, really - <code>increase()</code> is clearly meant to be a part of the public interface of the <code>C</code> class since it’s one of the operations <code>C</code> supports. It needs special access to do its work, so it should be a member function. There are, however, cases where member functions come with limitations, or even cannot be used at all.</p>
<p>Let us consider an addition operator for the same <code>C</code> class - it’s what is needed to make an expression such as <code>c1 + c2</code> compile if both variables are of type <code>C</code>. The addition, or <code>operator+()</code>, can be declared as a member function:</p>
<pre class="source-code">
// Example 03
class C {
  int x_;
  public:
  C(int x) : x_(x) {}
  C operator+(const C&amp; rhs) const {
    return C(x_ + rhs.x_);
  }
};
...
C x(1), y(2);
C z = x + y;</pre>
<p>This code compiles<a id="_idIndexMarker669"/> and does exactly what we want; there does not seem<a id="_idIndexMarker670"/> to be anything obviously wrong with it. That’s because there isn’t - so far. But we can add more than just objects of type <code>C</code>:</p>
<pre class="source-code">
// Example 03
C x(1);
C z = x + 2;</pre>
<p>This also compiles, and points to a subtle detail in the declaration of the <code>C</code> class - we did not make the <code>C(int)</code> constructor explicit. This constructor now introduces an implicit conversion from int to <code>C</code>, and that is how the expression <code>x + 2</code> compiles - first, <code>2</code> is converted into a temporary object, <code>C(2)</code>, using the constructor we provided, and second the member function, <code>x.operator+(const C&amp;)</code>, is called - the right-hand side is the temporary object we just created. The temporary object itself is deleted right after the expression is evaluated. The implicit conversion from integers is rather broad and might have been an oversight. Let’s assume that it wasn’t and that we really want the expression such as <code>x + 2</code> to compile. What’s not to like, then? Again, nothing so far. The objectionable feature of our design is what comes next:</p>
<pre class="source-code">
// Example 03
C x(1);
C z = 2 + x; // Does NOT compile</pre>
<p>If <code>x + 2</code> compiles, you would reasonably expect <code>2 + x</code> to compile and give the same result (there are areas of math where the addition is not commutative, but let’s stick with the arithmetic here). The reason it does not compile is that the compiler cannot get to <code>operator+()</code> in the <code>C</code> class from here, and no other <code>operator+()</code> is available for these arguments. The <code>x + y</code> expression, when used with member function operators, is just syntactic sugar for the equivalent, if verbose, call to <code>x.operator+(y)</code>. The same is true for any other binary operator such as multiplication or comparison.</p>
<p>The point is, the member function operator is invoked on the first argument of the expression (so technically, <code>x + y</code> and <code>y + x</code> are not identical; the member function is called on different objects, but the implementation is such that both give the same result). In our case, the member function would have to be invoked on the number <code>2</code>, which is an integer and has no member functions at all. So, how did the expression <code>x + 2</code> compile? Quite simple, really: <code>x +</code> by itself implies <code>x.operator+()</code>, and the argument is whatever comes after <code>+</code>. In our case, it’s <code>2</code>. So, either <code>x.operator+(2)</code> compiles, or it does not, but in either case, the search for <code>operator+</code> to the call is over. The implicit conversion from <code>int</code> in our <code>C</code> class makes this call compile. So, why doesn’t the <a id="_idIndexMarker671"/>compiler attempt a conversion on the first argument? The answer is, it never does because it has no guidance on what to convert it into - there may be any number of other types that have the <code>operator+()</code> member function, and some <a id="_idIndexMarker672"/>of them may accept the <code>C</code> class as their argument, or something <code>C</code> can be converted to. The compiler does not attempt to explore the almost infinite number of such possible conversions.</p>
<p>If we want to use plus in expressions where the first type may be a built-in type or any other type that does not have or cannot have a member function of <code>operator+()</code>, then we have to use a non-member function. No problem; we know how to write those:</p>
<pre class="source-code">
C operator+(const C&amp; lhs, const C&amp; rhs) {
  return C(lhs.x_ + rhs.x_);
}</pre>
<p>But now we have lost access to the private data member <code>C::x_</code>, so our non-member <code>operator+()</code> does not compile either. We have seen the solution to that problem in the previous section - we need to make it a friend:</p>
<pre class="source-code">
// Example 04
class C {
  int x_;
  public:
  C(int x) : x_(x) {}
  friend C operator+(const C&amp; lhs, const C&amp; rhs);
};
C operator+(const C&amp; lhs, const C&amp; rhs) {
  return C(lhs.x_ + rhs.x_);
}
...
C x(1), y(2);
C z1 = x + y;
C z2 = x + 2;
C z3 = 1 + y;</pre>
<p>Now, everything compiles and works as intended - the non-member function <code>operator+()</code> is simply<a id="_idIndexMarker673"/> a non-member function with two arguments of type <code>const C&amp;</code>. The rules for it are the same as for any other such function.</p>
<p>We can avoid typing the <a id="_idIndexMarker674"/>declaration of the <code>operator+()</code> twice if we define its body <em class="italic">in situ</em> (immediately following the declaration, inside the class):</p>
<pre class="source-code">
// Example 05
class C {
  int x_;
  public:
  C(int x) : x_(x) {}
  friend C operator+(const C&amp; lhs, const C&amp; rhs) {
    return C(lhs.x_ + rhs.x_);
  }
};</pre>
<p>The latter example is subtly different from the previous one, but usually, you won’t be able to see the difference, so it is simply a matter of style - moving the body of the function into the object makes the object itself longer, but defining the function outside of the class is more typing (as well as a possible divergence between the friend declaration and the actual function, if the code is ever changed). We will explain the intricacies of in situ friend declarations in the next section.</p>
<p>Either way, the friend <a id="_idIndexMarker675"/>function is really a part of the class public interface, but, for technical reasons, we prefer a non-member function in this case. There is even a case when the non-member function is the only choice. Consider the C++ input/output operators, such as the<a id="_idIndexMarker676"/> inserter, or <code>operator&lt;&lt;()</code>, which are used to write objects out into a stream (for example, <code>std::cout</code>). We want to be able to print an object of type <code>C</code> like so:</p>
<pre class="source-code">
C c1(5);
std::cout &lt;&lt; c1;</pre>
<p>There is no standard <code>operator&lt;&lt;()</code> for our type C, so we have to declare our own. The inserter is a binary operator, just like plus (it has parameters on either side), so, were it a member function, it would have to be one on the left-hand side object. Look at the preceding statement - the left-hand side object in the <code>std::cout &lt;&lt; c1</code> expression is not our object, <code>c1</code>, but the standard out stream, <code>std::cout</code>. That’s the object we would have to add a member function to, but we cannot - <code>std::cout</code> is declared somewhere in the C++ standard library headers, and there is no way to extend its interface, at least not in a direct manner. Member functions on the <code>C</code> class can be declared by us, but this does not help - only the member functions of the left-hand side object are considered. The only alternative is a non-member function. The first argument has to be <code>std::ostream&amp;</code>:</p>
<pre class="source-code">
// Example 06
class C {
  ...
  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out,
                                  const C&amp; c);
};
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const C&amp; c) {
  out &lt;&lt; c.x_;
  return out;
}</pre>
<p>This function has to be declared as a friend since it also needs access to the private data of the <code>C</code> class. It can also be defined <em class="italic">in situ</em>:</p>
<pre class="source-code">
// Example 07
class C {
  int x_;
  public:
  C(int x) : x_(x) {}
  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out,
                                  const C&amp; c) {
    out &lt;&lt; c.x_;
    return out;
  }
};</pre>
<p>By convention, the<a id="_idIndexMarker677"/> return value is the same stream object, so the inserter operators can be chained:</p>
<pre class="source-code">
C c1(5), c2(7);
std::cout &lt;&lt; c1 &lt;&lt; c2;</pre>
<p>The way the last statement<a id="_idIndexMarker678"/> is interpreted is <code>(std::cout &lt;&lt; c1) &lt;&lt; c2</code>, which boils down to <code>operator&lt;&lt;(operator&lt;&lt;(std::cout, c1), c2)</code>. The outer <code>operator&lt;&lt;()</code> is called on the return value of the inner <code>operator&lt;&lt;()</code>, which is the same: <code>std::cout</code>. Again, the inserter is part of the public interface of the <code>C</code> class - it makes the objects of type <code>C</code> printable. However, it has to be a non-member function.</p>
<p>The introduction to the use of <code>friend</code> in C++ glossed over several subtle details that are occasionally<a id="_idIndexMarker679"/> important, so let us spend some time to elucidate them.</p>
<h2 id="_idParaDest-219"><a id="_idTextAnchor574"/>Subtle details of friendship</h2>
<p>First, let us talk <a id="_idIndexMarker680"/>about the effect of declaring a <code>friend</code> function without defining it (i.e., without the in situ implementation):</p>
<pre class="source-code">
// Example 08
class C {
  friend C operator+(const C&amp; lhs, const C&amp; rhs);
  ...
};
C operator+(const C&amp; lhs, const C&amp; rhs) { … }</pre>
<p>By the way, it makes no difference whatsoever whether you put the <code>friend</code> declaration into the public or private part of the class. But about the <code>friend</code> declaration itself: which function did we grant access to? This is the first mention of an <code>operator+()</code> with this signature in our program (its definition must come later, after class <code>C</code> itself was declared). Turns out that the <code>friend</code> statement does double duty: it also acts as a forward declaration for the function.</p>
<p>Of course, there is no rule that prevents us from forward-declaring the same function ourselves:</p>
<pre class="source-code">
// Example 09
class C;
C operator+(const C&amp; lhs, const C&amp; rhs);
class C {
  friend C operator+(const C&amp; lhs, const C&amp; rhs);
  ...
};
C operator+(const C&amp; lhs, const C&amp; rhs) { … }</pre>
<p>There is no need to use a separate forward declaration just to use <code>friend</code>, but it may be necessary for other reasons if we want to use <code>operator+()</code> earlier in our program.</p>
<p>Note that the compiler does not warn you if the <code>friend</code> forward declaration does not match the function definition, or if the <code>friend</code> statement does not match the forward declaration. If the function signature in the <code>friend</code> statement differs from the actual function, you will have granted friendship to some other function that is forward-declared but not defined anywhere. It is highly likely that you will get a syntax error compiling the real function because it now has no special access to the class and can’t access its private members. But the error message won’t say anything about a mismatch between the <code>friend</code> statement and the function definition. You just have to know that if you granted friendship to a function and the compiler doesn’t see it, there is a discrepancy <a id="_idIndexMarker681"/>between the function signature in the <code>friend</code> statement and the one in the function definition.</p>
<p>Of course, if the <code>friend</code> statement also defines the function instead of just declaring it, then it is not acting as a forward declaration at all. But in this case, there is another subtlety, namely, in which scope is the new function defined? Consider that if you declare a static function inside a class, that function exists in the scope of the class itself. If we have a class <code>C</code> with a static function <code>f()</code>, the proper name of this function outside of the class is <code>C::f</code>:</p>
<pre class="source-code">
class C {
  static void f(const C&amp; c);
  ...
};
C c;
C::f(c);    // Must be called as C::f() not f()</pre>
<p>It is easy to see that the same does not apply to the <code>friend</code> functions:</p>
<pre class="source-code">
class C {
  friend void f(const C&amp; c);
  ...
};
C c;
C::f(c);    // Does not compile – not a member</pre>
<p>This makes sense, considering that we already saw that the <code>friend</code> statement without a definition forward-declared a function that is defined outside of the class. So, if the <code>friend</code> declaration forward-declared a function in the scope containing the class (in our case, the global scope, but could have been a <code>namespace</code>), then the <code>friend</code> statement with an in situ definition must define a function in the same scope, i.e., it injects a function into the outer scope of the class. Right? Yes, but not entirely.</p>
<p>In practice, odds are <a id="_idIndexMarker682"/>good that you would never notice the “not entirely” part, and everything behaves as if the function was simply injected into the containing scope. It takes a rather contrived example to demonstrate what really happens:</p>
<pre class="source-code">
// Example 10
class C {
  static int n_;
  int x_;
  public:
  C(int x) : x_(x) {}
  friend int f(int i) { return i + C::n_; }
  friend int g(const C&amp; c) { return c.x_ + C::n_; }
};
int C::n_ = 42;
...
C c(1);
f(0);        // Does not comppile - no ADL
g(c);        // Compiles fine</pre>
<p>Here we have two <code>friend</code> functions, <code>f()</code> and <code>g()</code>, both are defined at the point of declaration. The function <code>g()</code> behaves as if it was declared in the global scope (or the scope containing the class <code>C</code>, if we used a <code>namespace</code>). But a call to <code>f()</code> in the same scope does not compile, and the error message is going to be “function f is not declared in this scope” or something to that effect. The wording of compiler error messages varies widely, but that is the gist of the error: the call to <code>f()</code> did not find a function to call. The only difference between the functions <code>f()</code> and <code>g()</code> is their arguments; that turns out to be key.</p>
<p>To understand this, we have to know how the compiler looks up a function name when you write a function call such as <code>f(0)</code>. First of all, this is a non-member function, so the compiler looks only for those (it could also be a functor – a class with <code>operator()</code>, but that is not important right now since we don’t have any). Second, the compiler searches the current <a id="_idIndexMarker683"/>scope, the one where the call is made, and all containing scopes such as nested function bodies, classes, and namespaces) all the way to the global scope. But this is not the end of it: the compiler also looks at the arguments of the<a id="_idIndexMarker684"/> function and searches the scope (or scopes) where each of these argument types is declared. This step is called the <strong class="bold">argument-dependent lookup</strong> (<strong class="bold">ADL</strong>), also known as the <strong class="bold">Koenig lookup</strong> after Andrew<a id="_idIndexMarker685"/> Koenig (who denies inventing it). After all these lookups are done and the compiler finds every function with the matching name in one of the scopes we just listed, the compiler does the overload resolution on all the functions it found (i.e., there is no priority given to any particular scope).</p>
<p>So, what does this have to do with the <code>friend</code> functions? Only this: according to the standard, a function defined by the <code>friend</code> statement is injected into the scope containing the class, but <em class="italic">it can be found only by the </em><em class="italic">argument-dependent lookup</em>.</p>
<p>This explains the behavior we just saw: both the functions <code>f()</code> and <code>g()</code> are injected into the global scope since that is the scope containing class <code>C</code>. Function <code>g()</code> has an argument of type <code>const C&amp;</code>, so it is found by the ADL in the scope containing the class <code>C</code>. Function <code>f()</code> has an argument of type <code>int</code>, and the built-in types are not considered to be declared in any scope, they “just are.” Since no ADL can be performed and the functions defined as friends are only found by ADL, function <code>f()</code> cannot be found at all.</p>
<p>Note that this situation is very fragile. For example, if we forward-declare the same function, it can be found in the scope where it is forward-declared and does not need the ADL:</p>
<pre class="source-code">
// Example 11
int f(int i);    // Forward declaration
class C {
  ...
  friend int f(int i) { return i + C::n_; }
};
f(0);        // No problem</pre>
<p>The same happens if the <code>friend</code> statement only declared the function, to be defined later:</p>
<pre class="source-code">
// Example 12
class C {
  ...
  friend int f(int i);    // Forward declaration
};
int f(int i) { return i + C::n_; }
f(0);        // No problem</pre>
<p>Why don’t we see this as a problem more often? Because most of the time, functions declared as friends inside classes have at least one argument of the type related to the class itself (such as a<a id="_idIndexMarker686"/> pointer or a reference). Both <code>operator+()</code> and <code>operator&lt;&lt;()</code> we have seen earlier fall into that category. After all, the only reason to declare a function as a friend is so it can access private members of the class, but the function would not need this access if it did not operate on an object of the class type. As a non-member function, how would it get access to such an object if not through its arguments? Of course, there are ways, but these situations rarely happen in practice.</p>
<p>Yet another subtle and potentially dangerous case happens when a program defines its own <code>operator new</code>. This is not illegal, class-specific memory allocation operators are often necessary. But declaring one is not that simple. There are two common uses of a custom <code>operator new</code>: the first one is where the operator is defined for the class that is being allocated, usually inside the class itself. These are called class-specific operators, and they aren’t the subject of our interest now. We need to explain the second common case, where the custom <code>operator new</code> is defined to allocate memory using a specific allocator class. This is how it is usually done:</p>
<pre class="source-code">
// Example 13
class Alloc {
  void* alloc(size_t s);    // Allocates memory
  void dealloc(void* p);     // Releases memory
  friend void* operator new (size_t s, Alloc* a);
  friend void operator delete(void* p, Alloc* a);
};
void* operator new (size_t s, Alloc* a) {
  return a-&gt;alloc(s);
}
void operator delete(void* p, Alloc* a) {
  a-&gt;dealloc(p);
}
class C { ... };
Alloc a;
C* c = new (&amp;a) C;</pre>
<p>There are several <a id="_idIndexMarker687"/>details to note: first, our allocator class <code>Alloc</code> has an overload for <code>operator new</code>: the first argument of every <code>operator new</code> is mandatory and must be the size of the allocation (the compiler fills that in). The second argument (and the third, etc, if necessary) are arbitrary; in our case, it’s the pointer to the allocator class that is going to provide memory for this allocation. The <code>operator new</code> itself is a function in the global scope, and it is declared as a friend of class <code>Alloc</code>. If you are wondering how you can call the matching <code>operator delete</code> that we also declared, the answer is you cannot; this operator is used only by the compiler itself in case the allocation by <code>operator new</code> succeeded but the constructor of the new object throws an exception. The compiler will use <code>operator delete</code> with the arguments matching those of <code>operator new</code>. But this is not how you will delete this object when its lifetime is over: there is no way to add extra arguments to a <code>delete</code> expression, so you’ll have to call the destructor yourself and then explicitly return the memory to the allocator.</p>
<p>This works exactly as intended. The compiler looks for the best match for the call to <code>operator new(size_t, Alloc*)</code> and finds our custom <code>operator new</code> in the global scope as intended.</p>
<p>Now, you may decide to <a id="_idIndexMarker688"/>move the body of the operator into the <code>friend</code> statement to save some typing as well as avoid the possibility of the <code>friend</code> declaration and the actual <code>operator new</code> definition ever getting out of sync. This is done with only a minor change:</p>
<pre class="source-code">
// Example 14
class Alloc {
  void* alloc(size_t s);    // Allocates memory
  void dealloc(void* p);     // Releases memory
  friend void* operator new (size_t s, Alloc* a) {
    return a-&gt;alloc(s);
  }
  friend void operator delete(void* p, Alloc* a) {
    a-&gt;dealloc(p);
  }
};
class C { ... };
Alloc a;
C* c = new (&amp;a) C;</pre>
<p>This program will almost certainly compile. It will work correctly on some compilers and produce horrible memory corruption on others. Unfortunately, those other compilers are correct. This is what is going on: the <em class="italic">new expression</em> (which is the standard name for the syntax “<code>new</code> … some-type”) has special rules for looking up the matching <code>operator new</code>. Specifically, the lookup is done in the scope of the class that is being constructed (class <code>C</code> in our case) and in the global scope (these rules are defined in the section <code>[expr.new]</code> of the standard). Note that there is no lookup in the scope of the arguments to <code>operator new</code> itself, i.e., no argument-dependent lookup. Since the function defined in situ by the <code>friend</code> statement can be found only by the argument-dependent lookup, it is not found at all. But how does the program compile then? This happens because of another overload for <code>operator new</code>, the so-called <em class="italic">placement new</em>. This overload has the form:</p>
<pre class="source-code">
void* new(size_t size, void* addr) { return addr; }</pre>
<p>It is declared in the standard header <code>&lt;new&gt;</code>, which is included by so many other headers that your program is very likely to include it even if you did not do so explicitly.</p>
<p>The intent for the placement new is to construct an object in memory that was allocated earlier (we used this to construct objects in the space reserved inside a class when we studied type erasure in the eponymous chapter earlier). But it is also a possible match to our call of operator <code>new(size_t, Alloc*)</code> because <code>Alloc*</code> can be implicitly converted to <code>void*</code>. Our own overload, which does not require this conversion, would <a id="_idIndexMarker689"/>be a better match, but, unfortunately, when defined in situ, it is not found by the lookup. The result is that the object of type <code>C</code> is constructed in the memory already occupied by the allocator object itself, corrupting the latter object in the process.</p>
<p>You can test your compilers using our examples: when defined outside of the class, the custom <code>operator new</code> should be invoked and the program should work as intended. But when defined by the <code>friend</code> statement, only the placement new should be found (some compilers will also issue a warning about overwriting an already constructed object).</p>
<p>So far, our classes are just regular classes, not templates, and our non-member functions have declared friends that were just regular non-template functions. Now, let’s consider what, if anything, needs to change if th<a id="_idTextAnchor575"/>e<a id="_idTextAnchor576"/> class becomes a template.</p>
<h1 id="_idParaDest-220"><a id="_idTextAnchor577"/>Friends and templates</h1>
<p>Both classes and<a id="_idIndexMarker690"/> functions in C++ can be templates, and we can have several different combinations - a class template can grant friendship to a non-template function if its parameter types don’t depend on the template parameters; this is not a particularly interesting case, and certainly does not solve any of the problems we’re dealing with now. When the friend function needs to operate on the template parameter types, making the rig<a id="_idTextAnchor578"/>h<a id="_idTextAnchor579"/>t friends becomes trickier.</p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor580"/>Friends of template classes</h2>
<p>Let’s start by<a id="_idIndexMarker691"/> making our <code>C</code> class into a template:</p>
<pre class="source-code">
template &lt;typename T&gt; class C {
  T x_;
  public:
  C(T x) : x_(x) {}
};</pre>
<p>We still want to add objects of type <code>C</code> and print them out. We have already considered reasons why the former is better accomplished with a non-member function, and the latter cannot be done in any other way. These reasons remain valid for class templates as well.</p>
<p>No problem - we can declare template functions to go with our template classes and do the work that the non-template functions used to do in the previous section. Let’s start with <code>operator+()</code>:</p>
<pre class="source-code">
template &lt;typename T&gt;
C&lt;T&gt; operator+(const C&lt;T&gt;&amp; lhs, const C&lt;T&gt;&amp; rhs) {
  return C&lt;T&gt;(lhs.x_ + rhs.x_);
}</pre>
<p>This is the same function that we saw previously, only made into a template that can accept any instantiation of the class template <code>C</code>. Note that we parameterized this template on the type <code>T</code>, that is, the template parameter of <code>C</code>. We could, of course, simply declare the following:</p>
<pre class="source-code">
template &lt;typename C&gt;
C operator+(const C&amp; lhs, const C&amp; rhs) { // NEVER do this!
  return C&lt;T&gt;(lhs.x_ + rhs.x_);
}</pre>
<p>However, this introduces - into the global scope no less - an <code>operator+()</code> that claims to accept two arguments of any type. Of course, it really only handles types that have an <code>x_</code> data member. So, what are we going to do when we have a template class, <code>D</code>, that is also addable but has a <code>y_</code> data member instead?</p>
<p>The earlier version of the template is at least restricted to all possible instantiations of the class template <code>C</code>. Of course, it suffers from the same problem as our very first attempt at a non-member function - it does not have access to the private data member <code>C&lt;T&gt;::x_</code>. No problem - this chapter is about friends, after all. But friends to what? The entire class<a id="_idIndexMarker692"/> template, <code>C</code>, is going to have a friend declaration, just one for all <code>T</code> types, and that has to work for every instantiation of the template function <code>operator+()</code>. It appears that we have to grant friendship to the entire function template:</p>
<pre class="source-code">
// Example 15
template &lt;typename T&gt; class C {
  T x_;
  public:
  C(T x) : x_(x) {}
  template &lt;typename U&gt;
  friend C&lt;U&gt; operator+(const C&lt;U&gt;&amp; lhs, const C&lt;U&gt;&amp; rhs);
};
template &lt;typename T&gt;
C&lt;T&gt; operator+(const C&lt;T&gt;&amp; lhs, const C&lt;T&gt;&amp; rhs) {
  return C&lt;T&gt;(lhs.x_ + rhs.x_);
}</pre>
<p>Note the correct syntax - the keyword <code>friend</code> appears after the template and its parameters but before the return type of the function. Also, note that we had to rename the template parameter of the nested friend declaration - the <code>T</code> identifier is already used for the class template parameter. Similarly, we could rename the template parameter <code>T</code> in the definition of the function itself, but we don’t have to - just like in function declarations and definitions, the parameter is just a name; it is only meaningful within each declaration - two declarations for the same function can use different names for the same parameter. What we can do instead is move the function body inline, into the class:</p>
<pre class="source-code">
// Example 16
template &lt;typename T&gt; class C {
  int x_;
  public:
  C(int x) : x_(x) {}
  template &lt;typename U&gt;
  friend C&lt;U&gt; operator+(const C&lt;U&gt;&amp; lhs, const C&lt;U&gt;&amp; rhs) {
    return C&lt;U&gt;(lhs.x_ + rhs.x_);
  }
};</pre>
<p>You might point out that <a id="_idIndexMarker693"/>we have blown a rather wide hole in the encapsulation of the template class <code>C</code> – by granting friendship of any instantiation of <code>C&lt;T&gt;</code> to the entire template function, we have, for example, made the <code>operator+(const C&amp;&lt;double&gt;, const C&amp;&lt;double&gt;)</code> instantiation a friend of <code>C&lt;int&gt;</code>. This is clearly not necessary, although it may not be immediately obvious where the harm is in that (an example that shows actual harm would be rather convoluted, as necessary). But this misses a much more serious problem with our design, which becomes apparent as soon as we start using it to add something. It works, up to a point:</p>
<pre class="source-code">
C&lt;int&gt; x(1), y(2);
C&lt;int&gt; z = x + y; // So far so good...</pre>
<p>But only up to a point:</p>
<pre class="source-code">
C&lt;int&gt; x(1), y(2);
C&lt;int&gt; z1 = x + 2; // This does not compile!
C&lt;int&gt; z2 = 1 + 2; // Neither does this!</pre>
<p>But was this not the very reason to use a non-member function? What happened to our implicit conversions? This used to work! The answer is in the details - it used to work, but for a non-template function, <code>operator+()</code>. The conversion rules for a template function are very different. The exact technical details can be gleaned from the standard, with great diligence and effort, but this is the gist of it - when considering non-member, non-template functions, the compiler will look for all functions with the given name (<code>operator+</code>, in our case), then check if they accept the right number of parameters (possibly considering default arguments), then check if, for each such function, for each of its parameters, a conversion from the supplied argument to the specified parameter type exists (the rules on which conversions, exactly, are considered, and again fairly complex, but let’s say that both user-given implicit conversions and built-in conversions such as non-const to <code>const</code> are considered). If this process yields only one function, that function is called (otherwise the compiler either selects the <em class="italic">best</em> overload or complains that several candidates are equally possible and the call is ambiguous).</p>
<p>For template functions, this process would again yield an almost unlimited number of candidates - every template function with the name <code>operator+()</code> would have to be instantiated on every known type just to check if enough type conversions are available to make it <a id="_idIndexMarker694"/>work. Instead, a much simpler process is attempted - in addition to all non-template functions described in the previous paragraph (in our case, none), the compiler also considers instantiations of template functions with the given name (again, <code>operator+</code>) and the types of all parameters equal to the types of the function arguments at the call site (so-called trivial conversions, such as adding <code>const</code>, are allowed).</p>
<p>In our case, the argument types in the <code>x + 2</code> expression are <code>C&lt;int&gt;</code> and <code>int</code>, respectively. The compiler looks for an instantiation of the template function, <code>operator+</code>, that accepts two arguments of this type, and the user-given conversions are not considered. There is no such function, of course, and so the call to <code>operator+()</code> cannot be resolved.</p>
<p>The root of the problem is that we really want the user-given conversions to be used by the compiler automatically, but this is not going to happen as long as we are trying to instantiate a template function. We could declare a non-template function for <code>operator+(const C&lt;int&gt;&amp;, const C&lt;int&gt;&amp;)</code>, but, with a <code>C</code> template class, we would have to declare one for every <code>T</code> type that the <code>C<a id="_idTextAnchor581"/></code> <a id="_idTextAnchor582"/>class might be instantiated on.</p>
<h1 id="_idParaDest-222"><a id="_idTextAnchor583"/>The template friend factory</h1>
<p>What we need is to <a id="_idIndexMarker695"/>automatically generate a non-template function for every <code>T</code> type that’s used to instantiate the class template <code>C</code>. Of course, it is impossible to generate all of these functions in advance - there is a nearly unlimited number of <code>T</code> types that could, in theory, be used with the template class <code>C</code>. Fortunately, we do not need to generate <code>operator+()</code> for every one of such types - we only need them for the types that were actually used w<a id="_idTextAnchor584"/>i<a id="_idTextAnchor585"/>th this template in our program.</p>
<h2 id="_idParaDest-223"><a id="_idTextAnchor586"/>Generating friends on demand</h2>
<p>The pattern that we are about to <a id="_idIndexMarker696"/>see is a very old one, and was introduced by John Barton and Lee Nackman in 1994 for a completely different purpose - they used it to work around certain limitations of the compilers that existed at the time. The inventors proposed the name <em class="italic">Restricted Template Expansion</em>, which was never widely used. Years later, Dan Sacks coined the name <em class="italic">Friends Factory</em>, but the <a id="_idIndexMarker697"/>pattern is also sometimes referred to simply as the <em class="italic">Barton-Nackman trick</em>.</p>
<p>The pattern looks very simple and very similar to the code we wrote earlier throughout this chapter:</p>
<pre class="source-code">
// Example 17
template &lt;typename T&gt; class C {
  int x_;
  public:
  C(int x) : x_(x) {}
  friend C operator+(const C&amp; lhs, const C&amp; rhs) {
    return C(lhs.x_ + rhs.x_);
  }
};</pre>
<p>We are taking advantage of a very specific C++ feature, and so the code must be written precisely. A non-template friend function is defined inside the class template. This function must be defined inline; it cannot be declared a friend and then defined later, except as an explicit template instantiation - we could have declared the friend function inside the class and then defined <code>operator+&lt;const C&lt;int&gt;&gt;&amp;, const C&lt;int&gt;&amp;)</code>, which would work for <code>C&lt;int&gt;</code> but not <code>C&lt;double&gt;</code> (since we do not know what types the callers may instantiate later, this is not very useful). It may have the parameters of the <code>T</code> type, the template parameter, the <code>C&lt;T&gt;</code> type (which, inside the class template, can be referred to as simply <code>C</code>), and any other type that is either fixed or depends only on the template parameters, but it may not be a template itself. Every instantiation of the <code>C</code> class template, with any combination of template parameter types, generates exactly one non-template, non-member function with the specified name. Note that the generated functions are non-template functions; they are regular functions, and the usual conversion rules apply to them. We are now back to the non-template <code>operator+()</code>, and all conversions work exactly the way we want them to:</p>
<pre class="source-code">
C&lt;int&gt; x(1), y(2);
C&lt;int&gt; z1 = x + y; // This works
C&lt;int&gt; z2 = x + 2; // and this too
C&lt;int&gt; z3 = 1 + 2; // so does this</pre>
<p>This is it - this is the whole pattern. There are a few details we must note. First of all, the keyword <code>friend</code> cannot be <a id="_idIndexMarker698"/>omitted. A class cannot normally generate a non-member function, except for declaring a friend. Even if the function does not need access to any private data, in order to automatically generate non-template functions from instantiations of class templates, these functions have to be declared friends (static non-member functions can be generated in a similar manner, but the binary operators cannot be static functions - the standard explicitly forbids it). Second, the generated function is placed in the scope containing the class but must be found by the argument-dependent lookup, as we learned earlier in this chapter. For example, let’s define the inserter operator for our <code>C</code> template class, but not before wrapping the entire class in a namespace:</p>
<pre class="source-code">
// Example 18
namespace NS {
template &lt;typename T&gt; class C {
  int x_;
  public:
  C(int x) : x_(x) {}
  friend C operator+(const C&amp; lhs, const C&amp; rhs) {
    return C(lhs.x_ + rhs.x_);
  }
  friend std::ostream&amp;
  operator&lt;&lt;(std::ostream&amp; out, const C&amp; c) {
    out &lt;&lt; c.x_;
    return out;
  }
};
} // namespace NS</pre>
<p>We can now both add and print the objects of the <code>C</code> type:</p>
<pre class="source-code">
NS::C&lt;int&gt; x(1), y(2);
std::cout &lt;&lt; (x + y) &lt;&lt; std::endl;</pre>
<p>Note that, even though the <code>C</code> class template is now in the namespace <code>NS</code>, and has to be used as such (<code>NS::C&lt;int&gt;</code>), we did not <a id="_idIndexMarker699"/>need to do anything special to invoke either <code>operator+()</code> or <code>operator&lt;&lt;()</code>. This does not mean that they were generated in the global scope. No, they are still in the namespace <code>NS</code>, but what we see is the argument-dependent lookup in action - when looking for a function named <code>operator+()</code>, for example, the compiler considers the candidates in the current scope (that is, the global scope, and there aren’t any), as well as the scope<a id="_idIndexMarker700"/> in which the arguments to the function are defined. In our case, at least one of the arguments to <code>operator+()</code> is of type <code>NS::C&lt;int&gt;</code>, which automatically brings all functions declared in the <code>NS</code> namespace into play. The friend factory generates its functions in the scope containing the class template, which is, of course, also the <code>NS</code> namespace. Thus, the lookup finds the definition, and both the <code>+</code> and <code>&lt;&lt;</code> operations are resolved exactly the way we would want<a id="_idIndexMarker701"/> them to be. Rest assured that this is by design and is no accident; the argument lookup rules are fine-tuned to produce this desired and expected result.</p>
<p>It is easy to prove that, even though friend functions are generated in the scope containing the class (in our case namespace <code>NS</code>), they can only be found by the argument-dependent lookup. A straightforward attempt to find the function without using an argument-dependent lookup will fail:</p>
<pre class="source-code">
auto p = &amp;NS::<a id="_idTextAnchor587"/>C&lt;int&gt;::operator+; // Does not compile</pre>
<p>There is also a connection between the friend factory pattern and o<a id="_idTextAnchor588"/>ne of the patterns we studied earlier.</p>
<h1 id="_idParaDest-224"><a id="_idTextAnchor589"/>The friend factory and the Curiously Recurring Template Pattern</h1>
<p>The friend factory is a<a id="_idIndexMarker702"/> pattern that synthesizes a non-template, non-member function from every instantiation of a class template - every time the template is instantiated on a new type, a new function is generated. For its parameters, this function can use any types we can declare in that instantiation of the class template. Usually, this is the class itself, but it can be any type the template knows about.</p>
<p>In this manner, the friend factory can be employed together with the <code>operator!=()</code> can be implemented through <code>operator==()</code>:</p>
<pre class="source-code">
// Example 19
template &lt;typename D&gt; class B {
  public:
  friend bool operator!=(const D&amp; lhs, const D&amp; rhs) {
    return !(lhs == rhs);
  }
};
template &lt;typename T&gt; class C : public B&lt;C&lt;T&gt;&gt; {
  T x_;
  public:
  C(T x) : x_(x) {}
  friend bool operator==(const C&amp; lhs, const C&amp; rhs) {
    return lhs.x_ == rhs.x_;
  }
};</pre>
<p>Here, the derived class <code>C</code> uses the friend factory pattern to generate a non-template function for the binary <code>operator==()</code> directly from the instantiation of the class template. It also<a id="_idIndexMarker704"/> inherits from the base class <code>B</code>, which triggers<a id="_idIndexMarker705"/> an instantiation of that template as well, which in turn generates a non-template function for <code>operator!=()</code> for every type for which we have generated <code>operator==()</code>.</p>
<p>The second use of CRTP is to convert member functions to non-member functions. For example, the binary <code>operator+()</code> is sometimes implemented in terms of <code>operator+=()</code>, which is always a member<a id="_idIndexMarker706"/> function (it acts on its first operand). To implement the binary <code>operator+()</code>, someone has to take care of the conversions to that object’s type, and then <code>operator+=()</code> can be called. These conversions are provided by the binary operators<a id="_idIndexMarker707"/> that are generated by the common CRTP base class when using the friend factory. Similarly, the inserter operator can be generated if we establish the convention that our classes have a <code>print()</code> member function:</p>
<pre class="source-code">
// Example 20
template &lt;typename D&gt; class B {
  public:
  friend D operator+(const D&amp; lhs, const D&amp; rhs) {
    D res(lhs);
    res += rhs; // Convert += to +
    return res;
  }
  friend std::ostream&amp;
  operator&lt;&lt;(std::ostream&amp; out, const D&amp; d) {
    d.print(out);
    return out;
  }
};
template &lt;typename T&gt; class C : public B&lt;C&lt;T&gt;&gt; {
  T x_;
  public:
  C(T x) : x_(x) {}
  C operator+=(const C&amp; incr) {
    x_ += incr.x_;
    return *this;
  }
  void print(std::ostream&amp; out) const {
    out &lt;&lt; x_;
  }
};</pre>
<p>In this fashion, CRTP can<a id="_idIndexMarker708"/> be used to add boilerplate interfaces while delegating<a id="_idIndexMarker709"/> the implementation to the derived classes. It is, after a<a id="_idTextAnchor590"/>l<a id="_idTextAnchor591"/>l, a static (compile-time) delegation pattern.</p>
<h1 id="_idParaDest-225"><a id="_idTextAnchor592"/>Summary</h1>
<p>In this chapter, we have learned about a very C++-specific pattern that was originally introduced as a workaround for the buggy early C++ compilers but found new use years later. The friend factory is used to generate non-template functions from instantiations of class templates. As non-template functions, these generated friends have much more flexible rules with regard to argument conversions compared to template functions. We have also learned how the argument-dependent lookup, type conversions, and the friend factory work together to deliver a result that looks very natural, by a process that is far from intuitive.</p>
<p>The next chapter describes a totally different kind of Factory - a C++ pattern that’s based on the classic Factory pattern and addresses a certain asymmetry in the language - all member functions, even destru<a id="_idTextAnchor593"/>c<a id="_idTextAnchor594"/>tors, can be virtual, except the constructors.</p>
<h1 id="_idParaDest-226"><a id="_idTextAnchor595"/>Questions</h1>
<ol>
<li>What is the effect of declaring a function as a <em class="italic">friend</em>?</li>
<li>What is the difference between granting friendship to a function versus a function template?</li>
<li>Why are binary operators usually implemented as non-member functions?</li>
<li>Why is the inserter operator always implemented as a non-member function?</li>
<li>What is the main difference between argument conversions for template and non-template functions?</li>
<li>How can we make the act of instantiating the template also generate a unique non-template, non-member function?</li>
</ol>
</div>
</body></html>