<html><head></head><body>
<div id="_idContainer028">
<h1 class="chapter-number" id="_idParaDest-213"><a id="_idTextAnchor562"/><span class="koboSpan" id="kobo.1.1">12</span></h1>
<h1 id="_idParaDest-214"><a id="_idTextAnchor563"/><span class="koboSpan" id="kobo.2.1">Friend Factory</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we are going to talk about making friends. </span><span class="koboSpan" id="kobo.3.2">We mean C++ friends here, not friends of C++ (you find those in your local C++ users group). </span><span class="koboSpan" id="kobo.3.3">In C++, friends of classes are functions or other classes that are granted special access to the class. </span><span class="koboSpan" id="kobo.3.4">In that way, they are not so different from your friends. </span><span class="koboSpan" id="kobo.3.5">But C++ can just manufacture friends as needed, </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">on demand!</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">The following topics will be covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">How do friend functions work in C++ and what do </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">they do?</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">When should you use friend functions versus class </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">member functions?</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">How to combine friends </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">and templates</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">How to generate friend functions </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">from templates</span></span><a id="_idTextAnchor564"/></li>
</ul>
<h1 id="_idParaDest-215"><a id="_idTextAnchor565"/><span class="koboSpan" id="kobo.15.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.16.1">The example code for this chapter can be found at the following GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">link: </span></span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter12</span></span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">.</span></span><a id="_idTextAnchor566"/></p>
<h1 id="_idParaDest-216"><a id="_idTextAnchor567"/><span class="koboSpan" id="kobo.20.1">Friends in C++</span></h1>
<p><span class="koboSpan" id="kobo.21.1">Let’s start by</span><a id="_idIndexMarker663"/><span class="koboSpan" id="kobo.22.1"> reviewing the way in which C++ grants friendship to classes, and the effects of this action, as well as when and </span><a id="_idIndexMarker664"/><span class="koboSpan" id="kobo.23.1">for what reasons the friendship should be used (“my code does not compile until I add </span><strong class="source-inline"><span class="koboSpan" id="kobo.24.1">friend</span></strong><span class="koboSpan" id="kobo.25.1"> everywhere” is not a valid reason, but an indication of a poorly designed interface - redesign your </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">classes instead</span><a id="_idTextAnchor568"/><span class="koboSpan" id="kobo.27.1">)</span><a id="_idTextAnchor569"/><span class="koboSpan" id="kobo.28.1">.</span></span></p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor570"/><span class="koboSpan" id="kobo.29.1">How to grant friendship in C++</span></h2>
<p><span class="koboSpan" id="kobo.30.1">A </span><em class="italic"><span class="koboSpan" id="kobo.31.1">friend</span></em><span class="koboSpan" id="kobo.32.1"> is a C++ concept that applies to classes and </span><a id="_idIndexMarker665"/><span class="koboSpan" id="kobo.33.1">affects the access to class members (</span><em class="italic"><span class="koboSpan" id="kobo.34.1">access</span></em><span class="koboSpan" id="kobo.35.1"> is what </span><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">public</span></strong><span class="koboSpan" id="kobo.37.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">private</span></strong><span class="koboSpan" id="kobo.39.1"> control). </span><span class="koboSpan" id="kobo.39.2">Usually, public member functions and data members are accessible to anyone, and private ones are only accessible to other member functions of the class itself. </span><span class="koboSpan" id="kobo.39.3">The following code does not compile because the data member </span><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">C:x_</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.41.1">is private:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.42.1">
// Example 01
class C {
  int x_;
  public:
  C(int x) : x_(x) {}
};
C increase(C c, int dx) {
  return C(c.x_ + dx);     // Does not compile
}</span></pre>
<p><span class="koboSpan" id="kobo.43.1">The easiest way to solve this particular problem is to make </span><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">increase()</span></strong><span class="koboSpan" id="kobo.45.1"> a member function, but let’s stay with this version for a moment. </span><span class="koboSpan" id="kobo.45.2">The other option is to relax access and make </span><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">C::x_</span></strong><span class="koboSpan" id="kobo.47.1"> public. </span><span class="koboSpan" id="kobo.47.2">That is a bad idea because it exposes </span><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">x_</span></strong><span class="koboSpan" id="kobo.49.1"> - not just to </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">increase()</span></strong><span class="koboSpan" id="kobo.51.1">, but to any other code out there that wants to directly modify an object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">C</span></strong><span class="koboSpan" id="kobo.53.1">. </span><span class="koboSpan" id="kobo.53.2">What we need is to make </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">x_</span></strong><span class="koboSpan" id="kobo.55.1"> public, or at least accessible, to </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">increase()</span></strong><span class="koboSpan" id="kobo.57.1"> and to nobody else. </span><span class="koboSpan" id="kobo.57.2">This is done with a </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">friend declaration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.59.1">
// Example 02
class C {
  int x_;
  public:
  C(int x) : x_(x) {}
  friend C increase(C c, int dx);
};
C increase(C c, int dx) {
  return C(c.x_ + dx);    // Now it compiles
}</span></pre>
<p><span class="koboSpan" id="kobo.60.1">The friend declaration does nothing more than give the specified function the same access as the class member functions get. </span><span class="koboSpan" id="kobo.60.2">There is also a form of friend declaration that grants friendship not</span><a id="_idIndexMarker666"/><span class="koboSpan" id="kobo.61.1"> to a function, but to a class; this is just a way to grant friendship to all member functions of </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">that cl</span><a id="_idTextAnchor571"/><span class="koboSpan" id="kobo.63.1">a</span><a id="_idTextAnchor572"/><span class="koboSpan" id="kobo.64.1">ss.</span></span></p>
<h2 id="_idParaDest-218"><a id="_idTextAnchor573"/><span class="koboSpan" id="kobo.65.1">Friends versus member functions</span></h2>
<p><span class="koboSpan" id="kobo.66.1">We do have to come back</span><a id="_idIndexMarker667"/><span class="koboSpan" id="kobo.67.1"> to the question, why not just make </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">increase()</span></strong><span class="koboSpan" id="kobo.69.1"> a member function of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">C</span></strong><span class="koboSpan" id="kobo.71.1"> class? </span><span class="koboSpan" id="kobo.71.2">In the example given in the preceding section, there’s</span><a id="_idIndexMarker668"/><span class="koboSpan" id="kobo.72.1"> no reason to, really - </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">increase()</span></strong><span class="koboSpan" id="kobo.74.1"> is clearly meant to be a part of the public interface of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">C</span></strong><span class="koboSpan" id="kobo.76.1"> class since it’s one of the operations </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">C</span></strong><span class="koboSpan" id="kobo.78.1"> supports. </span><span class="koboSpan" id="kobo.78.2">It needs special access to do its work, so it should be a member function. </span><span class="koboSpan" id="kobo.78.3">There are, however, cases where member functions come with limitations, or even cannot be used </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">at all.</span></span></p>
<p><span class="koboSpan" id="kobo.80.1">Let us consider an addition operator for the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">C</span></strong><span class="koboSpan" id="kobo.82.1"> class - it’s what is needed to make an expression such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">c1 + c2</span></strong><span class="koboSpan" id="kobo.84.1"> compile if both variables are of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">C</span></strong><span class="koboSpan" id="kobo.86.1">. </span><span class="koboSpan" id="kobo.86.2">The addition, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">operator+()</span></strong><span class="koboSpan" id="kobo.88.1">, can be declared as a </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">member function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.90.1">
// Example 03
class C {
  int x_;
  public:
  C(int x) : x_(x) {}
  C operator+(const C&amp; rhs) const {
    return C(x_ + rhs.x_);
  }
};
...
</span><span class="koboSpan" id="kobo.90.2">C x(1), y(2);
C z = x + y;</span></pre>
<p><span class="koboSpan" id="kobo.91.1">This code compiles</span><a id="_idIndexMarker669"/><span class="koboSpan" id="kobo.92.1"> and does exactly what we want; there does not seem</span><a id="_idIndexMarker670"/><span class="koboSpan" id="kobo.93.1"> to be anything obviously wrong with it. </span><span class="koboSpan" id="kobo.93.2">That’s because there isn’t - so far. </span><span class="koboSpan" id="kobo.93.3">But we can add more than just objects of </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">type </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">C</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.97.1">
// Example 03
C x(1);
C z = x + 2;</span></pre>
<p><span class="koboSpan" id="kobo.98.1">This also compiles, and points to a subtle detail in the declaration of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">C</span></strong><span class="koboSpan" id="kobo.100.1"> class - we did not make the </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">C(int)</span></strong><span class="koboSpan" id="kobo.102.1"> constructor explicit. </span><span class="koboSpan" id="kobo.102.2">This constructor now introduces an implicit conversion from int to </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">C</span></strong><span class="koboSpan" id="kobo.104.1">, and that is how the expression </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">x + 2</span></strong><span class="koboSpan" id="kobo.106.1"> compiles - first, </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">2</span></strong><span class="koboSpan" id="kobo.108.1"> is converted into a temporary object, </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">C(2)</span></strong><span class="koboSpan" id="kobo.110.1">, using the constructor we provided, and second the member function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">x.operator+(const C&amp;)</span></strong><span class="koboSpan" id="kobo.112.1">, is called - the right-hand side is the temporary object we just created. </span><span class="koboSpan" id="kobo.112.2">The temporary object itself is deleted right after the expression is evaluated. </span><span class="koboSpan" id="kobo.112.3">The implicit conversion from integers is rather broad and might have been an oversight. </span><span class="koboSpan" id="kobo.112.4">Let’s assume that it wasn’t and that we really want the expression such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">x + 2</span></strong><span class="koboSpan" id="kobo.114.1"> to compile. </span><span class="koboSpan" id="kobo.114.2">What’s not to like, then? </span><span class="koboSpan" id="kobo.114.3">Again, nothing so far. </span><span class="koboSpan" id="kobo.114.4">The objectionable feature of our design is what </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">comes next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.116.1">
// Example 03
C x(1);
C z = 2 + x; // Does NOT compile</span></pre>
<p><span class="koboSpan" id="kobo.117.1">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">x + 2</span></strong><span class="koboSpan" id="kobo.119.1"> compiles, you would reasonably expect </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">2 + x</span></strong><span class="koboSpan" id="kobo.121.1"> to compile and give the same result (there are areas of math where the addition is not commutative, but let’s stick with the arithmetic here). </span><span class="koboSpan" id="kobo.121.2">The reason it does not compile is that the compiler cannot get to </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">operator+()</span></strong><span class="koboSpan" id="kobo.123.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">C</span></strong><span class="koboSpan" id="kobo.125.1"> class from here, and no other </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">operator+()</span></strong><span class="koboSpan" id="kobo.127.1"> is available for these arguments. </span><span class="koboSpan" id="kobo.127.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">x + y</span></strong><span class="koboSpan" id="kobo.129.1"> expression, when used with member function operators, is just syntactic sugar for the equivalent, if verbose, call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">x.operator+(y)</span></strong><span class="koboSpan" id="kobo.131.1">. </span><span class="koboSpan" id="kobo.131.2">The same is true for any other binary operator such as multiplication </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">or comparison.</span></span></p>
<p><span class="koboSpan" id="kobo.133.1">The point is, the member function operator is invoked on the first argument of the expression (so technically, </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">x + y</span></strong><span class="koboSpan" id="kobo.135.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">y + x</span></strong><span class="koboSpan" id="kobo.137.1"> are not identical; the member function is called on different objects, but the implementation is such that both give the same result). </span><span class="koboSpan" id="kobo.137.2">In our case, the member function would have to be invoked on the number </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">2</span></strong><span class="koboSpan" id="kobo.139.1">, which is an integer and has no member functions at all. </span><span class="koboSpan" id="kobo.139.2">So, how did the expression </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">x + 2</span></strong><span class="koboSpan" id="kobo.141.1"> compile? </span><span class="koboSpan" id="kobo.141.2">Quite simple, really: </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">x +</span></strong><span class="koboSpan" id="kobo.143.1"> by itself implies </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">x.operator+()</span></strong><span class="koboSpan" id="kobo.145.1">, and the argument is whatever comes after </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">+</span></strong><span class="koboSpan" id="kobo.147.1">. </span><span class="koboSpan" id="kobo.147.2">In our case, it’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">2</span></strong><span class="koboSpan" id="kobo.149.1">. </span><span class="koboSpan" id="kobo.149.2">So, either </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">x.operator+(2)</span></strong><span class="koboSpan" id="kobo.151.1"> compiles, or it does not, but in either case, the search for </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">operator+</span></strong><span class="koboSpan" id="kobo.153.1"> to the call is over. </span><span class="koboSpan" id="kobo.153.2">The implicit conversion from </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">int</span></strong><span class="koboSpan" id="kobo.155.1"> in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">C</span></strong><span class="koboSpan" id="kobo.157.1"> class makes this call compile. </span><span class="koboSpan" id="kobo.157.2">So, why doesn’t the </span><a id="_idIndexMarker671"/><span class="koboSpan" id="kobo.158.1">compiler attempt a conversion on the first argument? </span><span class="koboSpan" id="kobo.158.2">The answer is, it never does because it has no guidance on what to convert it into - there may be any number of other types that have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">operator+()</span></strong><span class="koboSpan" id="kobo.160.1"> member function, and some </span><a id="_idIndexMarker672"/><span class="koboSpan" id="kobo.161.1">of them may accept the </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">C</span></strong><span class="koboSpan" id="kobo.163.1"> class as their argument, or something </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">C</span></strong><span class="koboSpan" id="kobo.165.1"> can be converted to. </span><span class="koboSpan" id="kobo.165.2">The compiler does not attempt to explore the almost infinite number of such </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">possible conversions.</span></span></p>
<p><span class="koboSpan" id="kobo.167.1">If we want to use plus in expressions where the first type may be a built-in type or any other type that does not have or cannot have a member function of </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">operator+()</span></strong><span class="koboSpan" id="kobo.169.1">, then we have to use a non-member function. </span><span class="koboSpan" id="kobo.169.2">No problem; we know how to </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">write those:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.171.1">
C operator+(const C&amp; lhs, const C&amp; rhs) {
  return C(lhs.x_ + rhs.x_);
}</span></pre>
<p><span class="koboSpan" id="kobo.172.1">But now we have lost access to the private data member </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">C::x_</span></strong><span class="koboSpan" id="kobo.174.1">, so our non-member </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">operator+()</span></strong><span class="koboSpan" id="kobo.176.1"> does not compile either. </span><span class="koboSpan" id="kobo.176.2">We have seen the solution to that problem in the previous section - we need to make it </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">a friend:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.178.1">
// Example 04
class C {
  int x_;
  public:
  C(int x) : x_(x) {}
  friend C operator+(const C&amp; lhs, const C&amp; rhs);
};
C operator+(const C&amp; lhs, const C&amp; rhs) {
  return C(lhs.x_ + rhs.x_);
}
...
</span><span class="koboSpan" id="kobo.178.2">C x(1), y(2);
C z1 = x + y;
C z2 = x + 2;
C z3 = 1 + y;</span></pre>
<p><span class="koboSpan" id="kobo.179.1">Now, everything compiles and works as intended - the non-member function </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">operator+()</span></strong><span class="koboSpan" id="kobo.181.1"> is simply</span><a id="_idIndexMarker673"/><span class="koboSpan" id="kobo.182.1"> a non-member function with two arguments of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">const C&amp;</span></strong><span class="koboSpan" id="kobo.184.1">. </span><span class="koboSpan" id="kobo.184.2">The rules for it are the same as for any other </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">such function.</span></span></p>
<p><span class="koboSpan" id="kobo.186.1">We can avoid typing the </span><a id="_idIndexMarker674"/><span class="koboSpan" id="kobo.187.1">declaration of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">operator+()</span></strong><span class="koboSpan" id="kobo.189.1"> twice if we define its body </span><em class="italic"><span class="koboSpan" id="kobo.190.1">in situ</span></em><span class="koboSpan" id="kobo.191.1"> (immediately following the declaration, inside </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">the class):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.193.1">
// Example 05
class C {
  int x_;
  public:
  C(int x) : x_(x) {}
  friend C operator+(const C&amp; lhs, const C&amp; rhs) {
    return C(lhs.x_ + rhs.x_);
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.194.1">The latter example is subtly different from the previous one, but usually, you won’t be able to see the difference, so it is simply a matter of style - moving the body of the function into the object makes the object itself longer, but defining the function outside of the class is more typing (as well as a possible divergence between the friend declaration and the actual function, if the code is ever changed). </span><span class="koboSpan" id="kobo.194.2">We will explain the intricacies of in situ friend declarations in the </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">next section.</span></span></p>
<p><span class="koboSpan" id="kobo.196.1">Either way, the friend </span><a id="_idIndexMarker675"/><span class="koboSpan" id="kobo.197.1">function is really a part of the class public interface, but, for technical reasons, we prefer a non-member function in this case. </span><span class="koboSpan" id="kobo.197.2">There is even a case when the non-member function is the only choice. </span><span class="koboSpan" id="kobo.197.3">Consider the C++ input/output operators, such as the</span><a id="_idIndexMarker676"/><span class="koboSpan" id="kobo.198.1"> inserter, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">operator&lt;&lt;()</span></strong><span class="koboSpan" id="kobo.200.1">, which are used to write objects out into a stream (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">std::cout</span></strong><span class="koboSpan" id="kobo.202.1">). </span><span class="koboSpan" id="kobo.202.2">We want to be able to print an object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">C</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.204.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.205.1">
C c1(5);
std::cout &lt;&lt; c1;</span></pre>
<p><span class="koboSpan" id="kobo.206.1">There is no standard </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">operator&lt;&lt;()</span></strong><span class="koboSpan" id="kobo.208.1"> for our type C, so we have to declare our own. </span><span class="koboSpan" id="kobo.208.2">The inserter is a binary operator, just like plus (it has parameters on either side), so, were it a member function, it would have to be one on the left-hand side object. </span><span class="koboSpan" id="kobo.208.3">Look at the preceding statement - the left-hand side object in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">std::cout &lt;&lt; c1</span></strong><span class="koboSpan" id="kobo.210.1"> expression is not our object, </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">c1</span></strong><span class="koboSpan" id="kobo.212.1">, but the standard out stream, </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">std::cout</span></strong><span class="koboSpan" id="kobo.214.1">. </span><span class="koboSpan" id="kobo.214.2">That’s the object we would have to add a member function to, but we cannot - </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">std::cout</span></strong><span class="koboSpan" id="kobo.216.1"> is declared somewhere in the C++ standard library headers, and there is no way to extend its interface, at least not in a direct manner. </span><span class="koboSpan" id="kobo.216.2">Member functions on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">C</span></strong><span class="koboSpan" id="kobo.218.1"> class can be declared by us, but this does not help - only the member functions of the left-hand side object are considered. </span><span class="koboSpan" id="kobo.218.2">The only alternative is a non-member function. </span><span class="koboSpan" id="kobo.218.3">The first argument has to </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">be </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">std::ostream&amp;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.222.1">
// Example 06
class C {
  ...
</span><span class="koboSpan" id="kobo.222.2">  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out,
                                  const C&amp; c);
};
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const C&amp; c) {
  out &lt;&lt; c.x_;
  return out;
}</span></pre>
<p><span class="koboSpan" id="kobo.223.1">This function has to be declared as a friend since it also needs access to the private data of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">C</span></strong><span class="koboSpan" id="kobo.225.1"> class. </span><span class="koboSpan" id="kobo.225.2">It can also be defined </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.226.1">in situ</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.228.1">
// Example 07
class C {
  int x_;
  public:
  C(int x) : x_(x) {}
  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out,
                                  const C&amp; c) {
    out &lt;&lt; c.x_;
    return out;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.229.1">By convention, the</span><a id="_idIndexMarker677"/><span class="koboSpan" id="kobo.230.1"> return value is the same stream object, so the inserter operators can </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">be chained:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.232.1">
C c1(5), c2(7);
std::cout &lt;&lt; c1 &lt;&lt; c2;</span></pre>
<p><span class="koboSpan" id="kobo.233.1">The way the last statement</span><a id="_idIndexMarker678"/><span class="koboSpan" id="kobo.234.1"> is interpreted is </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">(std::cout &lt;&lt; c1) &lt;&lt; c2</span></strong><span class="koboSpan" id="kobo.236.1">, which boils down to </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">operator&lt;&lt;(operator&lt;&lt;(std::cout, c1), c2)</span></strong><span class="koboSpan" id="kobo.238.1">. </span><span class="koboSpan" id="kobo.238.2">The outer </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">operator&lt;&lt;()</span></strong><span class="koboSpan" id="kobo.240.1"> is called on the return value of the inner </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">operator&lt;&lt;()</span></strong><span class="koboSpan" id="kobo.242.1">, which is the same: </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">std::cout</span></strong><span class="koboSpan" id="kobo.244.1">. </span><span class="koboSpan" id="kobo.244.2">Again, the inserter is part of the public interface of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">C</span></strong><span class="koboSpan" id="kobo.246.1"> class - it makes the objects of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">C</span></strong><span class="koboSpan" id="kobo.248.1"> printable. </span><span class="koboSpan" id="kobo.248.2">However, it has to be a </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">non-member function.</span></span></p>
<p><span class="koboSpan" id="kobo.250.1">The introduction to the use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">friend</span></strong><span class="koboSpan" id="kobo.252.1"> in C++ glossed over several subtle details that are occasionally</span><a id="_idIndexMarker679"/><span class="koboSpan" id="kobo.253.1"> important, so let us spend some time to </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">elucidate them.</span></span></p>
<h2 id="_idParaDest-219"><a id="_idTextAnchor574"/><span class="koboSpan" id="kobo.255.1">Subtle details of friendship</span></h2>
<p><span class="koboSpan" id="kobo.256.1">First, let us talk </span><a id="_idIndexMarker680"/><span class="koboSpan" id="kobo.257.1">about the effect of declaring a </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">friend</span></strong><span class="koboSpan" id="kobo.259.1"> function without defining it (i.e., without the in </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">situ implementation):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.261.1">
// Example 08
class C {
  friend C operator+(const C&amp; lhs, const C&amp; rhs);
  ...
</span><span class="koboSpan" id="kobo.261.2">};
C operator+(const C&amp; lhs, const C&amp; rhs) { … }</span></pre>
<p><span class="koboSpan" id="kobo.262.1">By the way, it makes no difference whatsoever whether you put the </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">friend</span></strong><span class="koboSpan" id="kobo.264.1"> declaration into the public or private part of the class. </span><span class="koboSpan" id="kobo.264.2">But about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">friend</span></strong><span class="koboSpan" id="kobo.266.1"> declaration itself: which function did we grant access to? </span><span class="koboSpan" id="kobo.266.2">This is the first mention of an </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">operator+()</span></strong><span class="koboSpan" id="kobo.268.1"> with this signature in our program (its definition must come later, after class </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">C</span></strong><span class="koboSpan" id="kobo.270.1"> itself was declared). </span><span class="koboSpan" id="kobo.270.2">Turns out that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">friend</span></strong><span class="koboSpan" id="kobo.272.1"> statement does double duty: it also acts as a forward declaration for </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">the function.</span></span></p>
<p><span class="koboSpan" id="kobo.274.1">Of course, there is no rule that prevents us from forward-declaring the same </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">function ourselves:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.276.1">
// Example 09
class C;
C operator+(const C&amp; lhs, const C&amp; rhs);
class C {
  friend C operator+(const C&amp; lhs, const C&amp; rhs);
  ...
</span><span class="koboSpan" id="kobo.276.2">};
C operator+(const C&amp; lhs, const C&amp; rhs) { … }</span></pre>
<p><span class="koboSpan" id="kobo.277.1">There is no need to use a separate forward declaration just to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">friend</span></strong><span class="koboSpan" id="kobo.279.1">, but it may be necessary for other reasons if we want to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">operator+()</span></strong><span class="koboSpan" id="kobo.281.1"> earlier in </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">our program.</span></span></p>
<p><span class="koboSpan" id="kobo.283.1">Note that the compiler does not warn you if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">friend</span></strong><span class="koboSpan" id="kobo.285.1"> forward declaration does not match the function definition, or if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">friend</span></strong><span class="koboSpan" id="kobo.287.1"> statement does not match the forward declaration. </span><span class="koboSpan" id="kobo.287.2">If the function signature in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">friend</span></strong><span class="koboSpan" id="kobo.289.1"> statement differs from the actual function, you will have granted friendship to some other function that is forward-declared but not defined anywhere. </span><span class="koboSpan" id="kobo.289.2">It is highly likely that you will get a syntax error compiling the real function because it now has no special access to the class and can’t access its private members. </span><span class="koboSpan" id="kobo.289.3">But the error message won’t say anything about a mismatch between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">friend</span></strong><span class="koboSpan" id="kobo.291.1"> statement and the function definition. </span><span class="koboSpan" id="kobo.291.2">You just have to know that if you granted friendship to a function and the compiler doesn’t see it, there is a discrepancy </span><a id="_idIndexMarker681"/><span class="koboSpan" id="kobo.292.1">between the function signature in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">friend</span></strong><span class="koboSpan" id="kobo.294.1"> statement and the one in the </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">function definition.</span></span></p>
<p><span class="koboSpan" id="kobo.296.1">Of course, if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">friend</span></strong><span class="koboSpan" id="kobo.298.1"> statement also defines the function instead of just declaring it, then it is not acting as a forward declaration at all. </span><span class="koboSpan" id="kobo.298.2">But in this case, there is another subtlety, namely, in which scope is the new function defined? </span><span class="koboSpan" id="kobo.298.3">Consider that if you declare a static function inside a class, that function exists in the scope of the class itself. </span><span class="koboSpan" id="kobo.298.4">If we have a class </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">C</span></strong><span class="koboSpan" id="kobo.300.1"> with a static function </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">f()</span></strong><span class="koboSpan" id="kobo.302.1">, the proper name of this function outside of the class </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">C::f</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.306.1">
class C {
  static void f(const C&amp; c);
  ...
</span><span class="koboSpan" id="kobo.306.2">};
C c;
C::f(c);    // Must be called as C::f() not f()</span></pre>
<p><span class="koboSpan" id="kobo.307.1">It is easy to see that the same does not apply to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">friend</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.309.1"> functions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.310.1">
class C {
  friend void f(const C&amp; c);
  ...
</span><span class="koboSpan" id="kobo.310.2">};
C c;
C::f(c);    // Does not compile – not a member</span></pre>
<p><span class="koboSpan" id="kobo.311.1">This makes sense, considering that we already saw that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">friend</span></strong><span class="koboSpan" id="kobo.313.1"> statement without a definition forward-declared a function that is defined outside of the class. </span><span class="koboSpan" id="kobo.313.2">So, if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">friend</span></strong><span class="koboSpan" id="kobo.315.1"> declaration forward-declared a function in the scope containing the class (in our case, the global scope, but could have been a </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">namespace</span></strong><span class="koboSpan" id="kobo.317.1">), then the </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">friend</span></strong><span class="koboSpan" id="kobo.319.1"> statement with an in situ definition must define a function in the same scope, i.e., it injects a function into the outer scope of the class. </span><span class="koboSpan" id="kobo.319.2">Right? </span><span class="koboSpan" id="kobo.319.3">Yes, but </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">not entirely.</span></span></p>
<p><span class="koboSpan" id="kobo.321.1">In practice, odds are </span><a id="_idIndexMarker682"/><span class="koboSpan" id="kobo.322.1">good that you would never notice the “not entirely” part, and everything behaves as if the function was simply injected into the containing scope. </span><span class="koboSpan" id="kobo.322.2">It takes a rather contrived example to demonstrate what </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">really happens:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.324.1">
// Example 10
class C {
  static int n_;
  int x_;
  public:
  C(int x) : x_(x) {}
  friend int f(int i) { return i + C::n_; }
  friend int g(const C&amp; c) { return c.x_ + C::n_; }
};
int C::n_ = 42;
...
</span><span class="koboSpan" id="kobo.324.2">C c(1);
f(0);        // Does not comppile - no ADL
g(c);        // Compiles fine</span></pre>
<p><span class="koboSpan" id="kobo.325.1">Here we have two </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">friend</span></strong><span class="koboSpan" id="kobo.327.1"> functions, </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">f()</span></strong><span class="koboSpan" id="kobo.329.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">g()</span></strong><span class="koboSpan" id="kobo.331.1">, both are defined at the point of declaration. </span><span class="koboSpan" id="kobo.331.2">The function </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">g()</span></strong><span class="koboSpan" id="kobo.333.1"> behaves as if it was declared in the global scope (or the scope containing the class </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">C</span></strong><span class="koboSpan" id="kobo.335.1">, if we used a </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">namespace</span></strong><span class="koboSpan" id="kobo.337.1">). </span><span class="koboSpan" id="kobo.337.2">But a call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">f()</span></strong><span class="koboSpan" id="kobo.339.1"> in the same scope does not compile, and the error message is going to be “function f is not declared in this scope” or something to that effect. </span><span class="koboSpan" id="kobo.339.2">The wording of compiler error messages varies widely, but that is the gist of the error: the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">f()</span></strong><span class="koboSpan" id="kobo.341.1"> did not find a function to call. </span><span class="koboSpan" id="kobo.341.2">The only difference between the functions </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">f()</span></strong><span class="koboSpan" id="kobo.343.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">g()</span></strong><span class="koboSpan" id="kobo.345.1"> is their arguments; that turns out to </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">be key.</span></span></p>
<p><span class="koboSpan" id="kobo.347.1">To understand this, we have to know how the compiler looks up a function name when you write a function call such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">f(0)</span></strong><span class="koboSpan" id="kobo.349.1">. </span><span class="koboSpan" id="kobo.349.2">First of all, this is a non-member function, so the compiler looks only for those (it could also be a functor – a class with </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">operator()</span></strong><span class="koboSpan" id="kobo.351.1">, but that is not important right now since we don’t have any). </span><span class="koboSpan" id="kobo.351.2">Second, the compiler searches the current </span><a id="_idIndexMarker683"/><span class="koboSpan" id="kobo.352.1">scope, the one where the call is made, and all containing scopes such as nested function bodies, classes, and namespaces) all the way to the global scope. </span><span class="koboSpan" id="kobo.352.2">But this is not the end of it: the compiler also looks at the arguments of the</span><a id="_idIndexMarker684"/><span class="koboSpan" id="kobo.353.1"> function and searches the scope (or scopes) where each of these argument types is declared. </span><span class="koboSpan" id="kobo.353.2">This step is called the </span><strong class="bold"><span class="koboSpan" id="kobo.354.1">argument-dependent lookup</span></strong><span class="koboSpan" id="kobo.355.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.356.1">ADL</span></strong><span class="koboSpan" id="kobo.357.1">), also known as the </span><strong class="bold"><span class="koboSpan" id="kobo.358.1">Koenig lookup</span></strong><span class="koboSpan" id="kobo.359.1"> after Andrew</span><a id="_idIndexMarker685"/><span class="koboSpan" id="kobo.360.1"> Koenig (who denies inventing it). </span><span class="koboSpan" id="kobo.360.2">After all these lookups are done and the compiler finds every function with the matching name in one of the scopes we just listed, the compiler does the overload resolution on all the functions it found (i.e., there is no priority given to any </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">particular scope).</span></span></p>
<p><span class="koboSpan" id="kobo.362.1">So, what does this have to do with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">friend</span></strong><span class="koboSpan" id="kobo.364.1"> functions? </span><span class="koboSpan" id="kobo.364.2">Only this: according to the standard, a function defined by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">friend</span></strong><span class="koboSpan" id="kobo.366.1"> statement is injected into the scope containing the class, but </span><em class="italic"><span class="koboSpan" id="kobo.367.1">it can be found only by the </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.368.1">argument-dependent lookup</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.370.1">This explains the behavior we just saw: both the functions </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">f()</span></strong><span class="koboSpan" id="kobo.372.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">g()</span></strong><span class="koboSpan" id="kobo.374.1"> are injected into the global scope since that is the scope containing class </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">C</span></strong><span class="koboSpan" id="kobo.376.1">. </span><span class="koboSpan" id="kobo.376.2">Function </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">g()</span></strong><span class="koboSpan" id="kobo.378.1"> has an argument of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">const C&amp;</span></strong><span class="koboSpan" id="kobo.380.1">, so it is found by the ADL in the scope containing the class </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">C</span></strong><span class="koboSpan" id="kobo.382.1">. </span><span class="koboSpan" id="kobo.382.2">Function </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">f()</span></strong><span class="koboSpan" id="kobo.384.1"> has an argument of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">int</span></strong><span class="koboSpan" id="kobo.386.1">, and the built-in types are not considered to be declared in any scope, they “just are.” </span><span class="koboSpan" id="kobo.386.2">Since no ADL can be performed and the functions defined as friends are only found by ADL, function </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">f()</span></strong><span class="koboSpan" id="kobo.388.1"> cannot be found </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">at all.</span></span></p>
<p><span class="koboSpan" id="kobo.390.1">Note that this situation is very fragile. </span><span class="koboSpan" id="kobo.390.2">For example, if we forward-declare the same function, it can be found in the scope where it is forward-declared and does not need </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">the ADL:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.392.1">
// Example 11
int f(int i);    // Forward declaration
class C {
  ...
</span><span class="koboSpan" id="kobo.392.2">  friend int f(int i) { return i + C::n_; }
};
f(0);        // No problem</span></pre>
<p><span class="koboSpan" id="kobo.393.1">The same happens if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">friend</span></strong><span class="koboSpan" id="kobo.395.1"> statement only declared the function, to be </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">defined later:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.397.1">
// Example 12
class C {
  ...
</span><span class="koboSpan" id="kobo.397.2">  friend int f(int i);    // Forward declaration
};
int f(int i) { return i + C::n_; }
f(0);        // No problem</span></pre>
<p><span class="koboSpan" id="kobo.398.1">Why don’t we see this as a problem more often? </span><span class="koboSpan" id="kobo.398.2">Because most of the time, functions declared as friends inside classes have at least one argument of the type related to the class itself (such as a</span><a id="_idIndexMarker686"/><span class="koboSpan" id="kobo.399.1"> pointer or a reference). </span><span class="koboSpan" id="kobo.399.2">Both </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">operator+()</span></strong><span class="koboSpan" id="kobo.401.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">operator&lt;&lt;()</span></strong><span class="koboSpan" id="kobo.403.1"> we have seen earlier fall into that category. </span><span class="koboSpan" id="kobo.403.2">After all, the only reason to declare a function as a friend is so it can access private members of the class, but the function would not need this access if it did not operate on an object of the class type. </span><span class="koboSpan" id="kobo.403.3">As a non-member function, how would it get access to such an object if not through its arguments? </span><span class="koboSpan" id="kobo.403.4">Of course, there are ways, but these situations rarely happen </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">in practice.</span></span></p>
<p><span class="koboSpan" id="kobo.405.1">Yet another subtle and potentially dangerous case happens when a program defines its own </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">operator new</span></strong><span class="koboSpan" id="kobo.407.1">. </span><span class="koboSpan" id="kobo.407.2">This is not illegal, class-specific memory allocation operators are often necessary. </span><span class="koboSpan" id="kobo.407.3">But declaring one is not that simple. </span><span class="koboSpan" id="kobo.407.4">There are two common uses of a custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">operator new</span></strong><span class="koboSpan" id="kobo.409.1">: the first one is where the operator is defined for the class that is being allocated, usually inside the class itself. </span><span class="koboSpan" id="kobo.409.2">These are called class-specific operators, and they aren’t the subject of our interest now. </span><span class="koboSpan" id="kobo.409.3">We need to explain the second common case, where the custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">operator new</span></strong><span class="koboSpan" id="kobo.411.1"> is defined to allocate memory using a specific allocator class. </span><span class="koboSpan" id="kobo.411.2">This is how it is </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">usually done:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.413.1">
// Example 13
class Alloc {
  void* alloc(size_t s);    // Allocates memory
  void dealloc(void* p);     // Releases memory
  friend void* operator new (size_t s, Alloc* a);
  friend void operator delete(void* p, Alloc* a);
};
void* operator new (size_t s, Alloc* a) {
  return a-&gt;alloc(s);
}
void operator delete(void* p, Alloc* a) {
  a-&gt;dealloc(p);
}
class C { ... </span><span class="koboSpan" id="kobo.413.2">};
Alloc a;
C* c = new (&amp;a) C;</span></pre>
<p><span class="koboSpan" id="kobo.414.1">There are several </span><a id="_idIndexMarker687"/><span class="koboSpan" id="kobo.415.1">details to note: first, our allocator class </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">Alloc</span></strong><span class="koboSpan" id="kobo.417.1"> has an overload for </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">operator new</span></strong><span class="koboSpan" id="kobo.419.1">: the first argument of every </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">operator new</span></strong><span class="koboSpan" id="kobo.421.1"> is mandatory and must be the size of the allocation (the compiler fills that in). </span><span class="koboSpan" id="kobo.421.2">The second argument (and the third, etc, if necessary) are arbitrary; in our case, it’s the pointer to the allocator class that is going to provide memory for this allocation. </span><span class="koboSpan" id="kobo.421.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">operator new</span></strong><span class="koboSpan" id="kobo.423.1"> itself is a function in the global scope, and it is declared as a friend of class </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">Alloc</span></strong><span class="koboSpan" id="kobo.425.1">. </span><span class="koboSpan" id="kobo.425.2">If you are wondering how you can call the matching </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">operator delete</span></strong><span class="koboSpan" id="kobo.427.1"> that we also declared, the answer is you cannot; this operator is used only by the compiler itself in case the allocation by </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">operator new</span></strong><span class="koboSpan" id="kobo.429.1"> succeeded but the constructor of the new object throws an exception. </span><span class="koboSpan" id="kobo.429.2">The compiler will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">operator delete</span></strong><span class="koboSpan" id="kobo.431.1"> with the arguments matching those of </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">operator new</span></strong><span class="koboSpan" id="kobo.433.1">. </span><span class="koboSpan" id="kobo.433.2">But this is not how you will delete this object when its lifetime is over: there is no way to add extra arguments to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">delete</span></strong><span class="koboSpan" id="kobo.435.1"> expression, so you’ll have to call the destructor yourself and then explicitly return the memory to </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">the allocator.</span></span></p>
<p><span class="koboSpan" id="kobo.437.1">This works exactly as intended. </span><span class="koboSpan" id="kobo.437.2">The compiler looks for the best match for the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">operator new(size_t, Alloc*)</span></strong><span class="koboSpan" id="kobo.439.1"> and finds our custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">operator new</span></strong><span class="koboSpan" id="kobo.441.1"> in the global scope </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">as intended.</span></span></p>
<p><span class="koboSpan" id="kobo.443.1">Now, you may decide to </span><a id="_idIndexMarker688"/><span class="koboSpan" id="kobo.444.1">move the body of the operator into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">friend</span></strong><span class="koboSpan" id="kobo.446.1"> statement to save some typing as well as avoid the possibility of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">friend</span></strong><span class="koboSpan" id="kobo.448.1"> declaration and the actual </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">operator new</span></strong><span class="koboSpan" id="kobo.450.1"> definition ever getting out of sync. </span><span class="koboSpan" id="kobo.450.2">This is done with only a </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">minor change:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.452.1">
// Example 14
class Alloc {
  void* alloc(size_t s);    // Allocates memory
  void dealloc(void* p);     // Releases memory
  friend void* operator new (size_t s, Alloc* a) {
    return a-&gt;alloc(s);
  }
  friend void operator delete(void* p, Alloc* a) {
    a-&gt;dealloc(p);
  }
};
class C { ... </span><span class="koboSpan" id="kobo.452.2">};
Alloc a;
C* c = new (&amp;a) C;</span></pre>
<p><span class="koboSpan" id="kobo.453.1">This program will almost certainly compile. </span><span class="koboSpan" id="kobo.453.2">It will work correctly on some compilers and produce horrible memory corruption on others. </span><span class="koboSpan" id="kobo.453.3">Unfortunately, those other compilers are correct. </span><span class="koboSpan" id="kobo.453.4">This is what is going on: the </span><em class="italic"><span class="koboSpan" id="kobo.454.1">new expression</span></em><span class="koboSpan" id="kobo.455.1"> (which is the standard name for the syntax “</span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">new</span></strong><span class="koboSpan" id="kobo.457.1"> … some-type”) has special rules for looking up the matching </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">operator new</span></strong><span class="koboSpan" id="kobo.459.1">. </span><span class="koboSpan" id="kobo.459.2">Specifically, the lookup is done in the scope of the class that is being constructed (class </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">C</span></strong><span class="koboSpan" id="kobo.461.1"> in our case) and in the global scope (these rules are defined in the section </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">[expr.new]</span></strong><span class="koboSpan" id="kobo.463.1"> of the standard). </span><span class="koboSpan" id="kobo.463.2">Note that there is no lookup in the scope of the arguments to </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">operator new</span></strong><span class="koboSpan" id="kobo.465.1"> itself, i.e., no argument-dependent lookup. </span><span class="koboSpan" id="kobo.465.2">Since the function defined in situ by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">friend</span></strong><span class="koboSpan" id="kobo.467.1"> statement can be found only by the argument-dependent lookup, it is not found at all. </span><span class="koboSpan" id="kobo.467.2">But how does the program compile then? </span><span class="koboSpan" id="kobo.467.3">This happens because of another overload for </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">operator new</span></strong><span class="koboSpan" id="kobo.469.1">, the so-called </span><em class="italic"><span class="koboSpan" id="kobo.470.1">placement new</span></em><span class="koboSpan" id="kobo.471.1">. </span><span class="koboSpan" id="kobo.471.2">This overload has </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">the form:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.473.1">
void* new(size_t size, void* addr) { return addr; }</span></pre>
<p><span class="koboSpan" id="kobo.474.1">It is declared in the standard header </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">&lt;new&gt;</span></strong><span class="koboSpan" id="kobo.476.1">, which is included by so many other headers that your program is very likely to include it even if you did not do </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">so explicitly.</span></span></p>
<p><span class="koboSpan" id="kobo.478.1">The intent for the placement new is to construct an object in memory that was allocated earlier (we used this to construct objects in the space reserved inside a class when we studied type erasure in the eponymous chapter earlier). </span><span class="koboSpan" id="kobo.478.2">But it is also a possible match to our call of operator </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">new(size_t, Alloc*)</span></strong><span class="koboSpan" id="kobo.480.1"> because </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">Alloc*</span></strong><span class="koboSpan" id="kobo.482.1"> can be implicitly converted to </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">void*</span></strong><span class="koboSpan" id="kobo.484.1">. </span><span class="koboSpan" id="kobo.484.2">Our own overload, which does not require this conversion, would </span><a id="_idIndexMarker689"/><span class="koboSpan" id="kobo.485.1">be a better match, but, unfortunately, when defined in situ, it is not found by the lookup. </span><span class="koboSpan" id="kobo.485.2">The result is that the object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">C</span></strong><span class="koboSpan" id="kobo.487.1"> is constructed in the memory already occupied by the allocator object itself, corrupting the latter object in </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">the process.</span></span></p>
<p><span class="koboSpan" id="kobo.489.1">You can test your compilers using our examples: when defined outside of the class, the custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">operator new</span></strong><span class="koboSpan" id="kobo.491.1"> should be invoked and the program should work as intended. </span><span class="koboSpan" id="kobo.491.2">But when defined by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">friend</span></strong><span class="koboSpan" id="kobo.493.1"> statement, only the placement new should be found (some compilers will also issue a warning about overwriting an already </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">constructed object).</span></span></p>
<p><span class="koboSpan" id="kobo.495.1">So far, our classes are just regular classes, not templates, and our non-member functions have declared friends that were just regular non-template functions. </span><span class="koboSpan" id="kobo.495.2">Now, let’s consider what, if anything, needs to change if th</span><a id="_idTextAnchor575"/><span class="koboSpan" id="kobo.496.1">e</span><a id="_idTextAnchor576"/><span class="koboSpan" id="kobo.497.1"> class becomes </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">a template.</span></span></p>
<h1 id="_idParaDest-220"><a id="_idTextAnchor577"/><span class="koboSpan" id="kobo.499.1">Friends and templates</span></h1>
<p><span class="koboSpan" id="kobo.500.1">Both classes and</span><a id="_idIndexMarker690"/><span class="koboSpan" id="kobo.501.1"> functions in C++ can be templates, and we can have several different combinations - a class template can grant friendship to a non-template function if its parameter types don’t depend on the template parameters; this is not a particularly interesting case, and certainly does not solve any of the problems we’re dealing with now. </span><span class="koboSpan" id="kobo.501.2">When the friend function needs to operate on the template parameter types, making the rig</span><a id="_idTextAnchor578"/><span class="koboSpan" id="kobo.502.1">h</span><a id="_idTextAnchor579"/><span class="koboSpan" id="kobo.503.1">t friends </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">becomes trickier.</span></span></p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor580"/><span class="koboSpan" id="kobo.505.1">Friends of template classes</span></h2>
<p><span class="koboSpan" id="kobo.506.1">Let’s start by</span><a id="_idIndexMarker691"/><span class="koboSpan" id="kobo.507.1"> making our </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">C</span></strong><span class="koboSpan" id="kobo.509.1"> class into </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">a template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.511.1">
template &lt;typename T&gt; class C {
  T x_;
  public:
  C(T x) : x_(x) {}
};</span></pre>
<p><span class="koboSpan" id="kobo.512.1">We still want to add objects of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">C</span></strong><span class="koboSpan" id="kobo.514.1"> and print them out. </span><span class="koboSpan" id="kobo.514.2">We have already considered reasons why the former is better accomplished with a non-member function, and the latter cannot be done in any other way. </span><span class="koboSpan" id="kobo.514.3">These reasons remain valid for class templates </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.516.1">No problem - we can declare template functions to go with our template classes and do the work that the non-template functions used to do in the previous section. </span><span class="koboSpan" id="kobo.516.2">Let’s start </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">operator+()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.520.1">
template &lt;typename T&gt;
C&lt;T&gt; operator+(const C&lt;T&gt;&amp; lhs, const C&lt;T&gt;&amp; rhs) {
  return C&lt;T&gt;(lhs.x_ + rhs.x_);
}</span></pre>
<p><span class="koboSpan" id="kobo.521.1">This is the same function that we saw previously, only made into a template that can accept any instantiation of the class template </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">C</span></strong><span class="koboSpan" id="kobo.523.1">. </span><span class="koboSpan" id="kobo.523.2">Note that we parameterized this template on the type </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">T</span></strong><span class="koboSpan" id="kobo.525.1">, that is, the template parameter of </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">C</span></strong><span class="koboSpan" id="kobo.527.1">. </span><span class="koboSpan" id="kobo.527.2">We could, of course, simply declare </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.529.1">
template &lt;typename C&gt;
C operator+(const C&amp; lhs, const C&amp; rhs) { // NEVER do this!
</span><span class="koboSpan" id="kobo.529.2">  return C&lt;T&gt;(lhs.x_ + rhs.x_);
}</span></pre>
<p><span class="koboSpan" id="kobo.530.1">However, this introduces - into the global scope no less - an </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">operator+()</span></strong><span class="koboSpan" id="kobo.532.1"> that claims to accept two arguments of any type. </span><span class="koboSpan" id="kobo.532.2">Of course, it really only handles types that have an </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">x_</span></strong><span class="koboSpan" id="kobo.534.1"> data member. </span><span class="koboSpan" id="kobo.534.2">So, what are we going to do when we have a template class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">D</span></strong><span class="koboSpan" id="kobo.536.1">, that is also addable but has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">y_</span></strong><span class="koboSpan" id="kobo.538.1"> data </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">member instead?</span></span></p>
<p><span class="koboSpan" id="kobo.540.1">The earlier version of the template is at least restricted to all possible instantiations of the class template </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">C</span></strong><span class="koboSpan" id="kobo.542.1">. </span><span class="koboSpan" id="kobo.542.2">Of course, it suffers from the same problem as our very first attempt at a non-member function - it does not have access to the private data member </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">C&lt;T&gt;::x_</span></strong><span class="koboSpan" id="kobo.544.1">. </span><span class="koboSpan" id="kobo.544.2">No problem - this chapter is about friends, after all. </span><span class="koboSpan" id="kobo.544.3">But friends to what? </span><span class="koboSpan" id="kobo.544.4">The entire class</span><a id="_idIndexMarker692"/><span class="koboSpan" id="kobo.545.1"> template, </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">C</span></strong><span class="koboSpan" id="kobo.547.1">, is going to have a friend declaration, just one for all </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">T</span></strong><span class="koboSpan" id="kobo.549.1"> types, and that has to work for every instantiation of the template function </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">operator+()</span></strong><span class="koboSpan" id="kobo.551.1">. </span><span class="koboSpan" id="kobo.551.2">It appears that we have to grant friendship to the entire </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">function template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.553.1">
// Example 15
template &lt;typename T&gt; class C {
  T x_;
  public:
  C(T x) : x_(x) {}
  template &lt;typename U&gt;
  friend C&lt;U&gt; operator+(const C&lt;U&gt;&amp; lhs, const C&lt;U&gt;&amp; rhs);
};
template &lt;typename T&gt;
C&lt;T&gt; operator+(const C&lt;T&gt;&amp; lhs, const C&lt;T&gt;&amp; rhs) {
  return C&lt;T&gt;(lhs.x_ + rhs.x_);
}</span></pre>
<p><span class="koboSpan" id="kobo.554.1">Note the correct syntax - the keyword </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">friend</span></strong><span class="koboSpan" id="kobo.556.1"> appears after the template and its parameters but before the return type of the function. </span><span class="koboSpan" id="kobo.556.2">Also, note that we had to rename the template parameter of the nested friend declaration - the </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">T</span></strong><span class="koboSpan" id="kobo.558.1"> identifier is already used for the class template parameter. </span><span class="koboSpan" id="kobo.558.2">Similarly, we could rename the template parameter </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">T</span></strong><span class="koboSpan" id="kobo.560.1"> in the definition of the function itself, but we don’t have to - just like in function declarations and definitions, the parameter is just a name; it is only meaningful within each declaration - two declarations for the same function can use different names for the same parameter. </span><span class="koboSpan" id="kobo.560.2">What we can do instead is move the function body inline, into </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">the class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.562.1">
// Example 16
template &lt;typename T&gt; class C {
  int x_;
  public:
  C(int x) : x_(x) {}
  template &lt;typename U&gt;
  friend C&lt;U&gt; operator+(const C&lt;U&gt;&amp; lhs, const C&lt;U&gt;&amp; rhs) {
    return C&lt;U&gt;(lhs.x_ + rhs.x_);
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.563.1">You might point out that </span><a id="_idIndexMarker693"/><span class="koboSpan" id="kobo.564.1">we have blown a rather wide hole in the encapsulation of the template class </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">C</span></strong><span class="koboSpan" id="kobo.566.1"> – by granting friendship of any instantiation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">C&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.568.1"> to the entire template function, we have, for example, made the </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">operator+(const C&amp;&lt;double&gt;, const C&amp;&lt;double&gt;)</span></strong><span class="koboSpan" id="kobo.570.1"> instantiation a friend of </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">C&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.572.1">. </span><span class="koboSpan" id="kobo.572.2">This is clearly not necessary, although it may not be immediately obvious where the harm is in that (an example that shows actual harm would be rather convoluted, as necessary). </span><span class="koboSpan" id="kobo.572.3">But this misses a much more serious problem with our design, which becomes apparent as soon as we start using it to add something. </span><span class="koboSpan" id="kobo.572.4">It works, up to </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">a point:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.574.1">
C&lt;int&gt; x(1), y(2);
C&lt;int&gt; z = x + y; // So far so good...</span></pre>
<p><span class="koboSpan" id="kobo.575.1">But only up to </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">a point:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.577.1">
C&lt;int&gt; x(1), y(2);
C&lt;int&gt; z1 = x + 2; // This does not compile!
</span><span class="koboSpan" id="kobo.577.2">C&lt;int&gt; z2 = 1 + 2; // Neither does this!</span></pre>
<p><span class="koboSpan" id="kobo.578.1">But was this not the very reason to use a non-member function? </span><span class="koboSpan" id="kobo.578.2">What happened to our implicit conversions? </span><span class="koboSpan" id="kobo.578.3">This used to work! </span><span class="koboSpan" id="kobo.578.4">The answer is in the details - it used to work, but for a non-template function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">operator+()</span></strong><span class="koboSpan" id="kobo.580.1">. </span><span class="koboSpan" id="kobo.580.2">The conversion rules for a template function are very different. </span><span class="koboSpan" id="kobo.580.3">The exact technical details can be gleaned from the standard, with great diligence and effort, but this is the gist of it - when considering non-member, non-template functions, the compiler will look for all functions with the given name (</span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">operator+</span></strong><span class="koboSpan" id="kobo.582.1">, in our case), then check if they accept the right number of parameters (possibly considering default arguments), then check if, for each such function, for each of its parameters, a conversion from the supplied argument to the specified parameter type exists (the rules on which conversions, exactly, are considered, and again fairly complex, but let’s say that both user-given implicit conversions and built-in conversions such as non-const to </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">const</span></strong><span class="koboSpan" id="kobo.584.1"> are considered). </span><span class="koboSpan" id="kobo.584.2">If this process yields only one function, that function is called (otherwise the compiler either selects the </span><em class="italic"><span class="koboSpan" id="kobo.585.1">best</span></em><span class="koboSpan" id="kobo.586.1"> overload or complains that several candidates are equally possible and the call </span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">is ambiguous).</span></span></p>
<p><span class="koboSpan" id="kobo.588.1">For template functions, this process would again yield an almost unlimited number of candidates - every template function with the name </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">operator+()</span></strong><span class="koboSpan" id="kobo.590.1"> would have to be instantiated on every known type just to check if enough type conversions are available to make it </span><a id="_idIndexMarker694"/><span class="koboSpan" id="kobo.591.1">work. </span><span class="koboSpan" id="kobo.591.2">Instead, a much simpler process is attempted - in addition to all non-template functions described in the previous paragraph (in our case, none), the compiler also considers instantiations of template functions with the given name (again, </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">operator+</span></strong><span class="koboSpan" id="kobo.593.1">) and the types of all parameters equal to the types of the function arguments at the call site (so-called trivial conversions, such as adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">const</span></strong><span class="koboSpan" id="kobo.595.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">are allowed).</span></span></p>
<p><span class="koboSpan" id="kobo.597.1">In our case, the argument types in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">x + 2</span></strong><span class="koboSpan" id="kobo.599.1"> expression are </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">C&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.601.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">int</span></strong><span class="koboSpan" id="kobo.603.1">, respectively. </span><span class="koboSpan" id="kobo.603.2">The compiler looks for an instantiation of the template function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">operator+</span></strong><span class="koboSpan" id="kobo.605.1">, that accepts two arguments of this type, and the user-given conversions are not considered. </span><span class="koboSpan" id="kobo.605.2">There is no such function, of course, and so the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">operator+()</span></strong><span class="koboSpan" id="kobo.607.1"> cannot </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">be resolved.</span></span></p>
<p><span class="koboSpan" id="kobo.609.1">The root of the problem is that we really want the user-given conversions to be used by the compiler automatically, but this is not going to happen as long as we are trying to instantiate a template function. </span><span class="koboSpan" id="kobo.609.2">We could declare a non-template function for </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">operator+(const C&lt;int&gt;&amp;, const C&lt;int&gt;&amp;)</span></strong><span class="koboSpan" id="kobo.611.1">, but, with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">C</span></strong><span class="koboSpan" id="kobo.613.1"> template class, we would have to declare one for every </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">T</span></strong><span class="koboSpan" id="kobo.615.1"> type that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">C</span><a id="_idTextAnchor581"/></strong> <a id="_idTextAnchor582"/><span class="koboSpan" id="kobo.617.1">class might be </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">instantiated on.</span></span></p>
<h1 id="_idParaDest-222"><a id="_idTextAnchor583"/><span class="koboSpan" id="kobo.619.1">The template friend factory</span></h1>
<p><span class="koboSpan" id="kobo.620.1">What we need is to </span><a id="_idIndexMarker695"/><span class="koboSpan" id="kobo.621.1">automatically generate a non-template function for every </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">T</span></strong><span class="koboSpan" id="kobo.623.1"> type that’s used to instantiate the class template </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">C</span></strong><span class="koboSpan" id="kobo.625.1">. </span><span class="koboSpan" id="kobo.625.2">Of course, it is impossible to generate all of these functions in advance - there is a nearly unlimited number of </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">T</span></strong><span class="koboSpan" id="kobo.627.1"> types that could, in theory, be used with the template class </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">C</span></strong><span class="koboSpan" id="kobo.629.1">. </span><span class="koboSpan" id="kobo.629.2">Fortunately, we do not need to generate </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">operator+()</span></strong><span class="koboSpan" id="kobo.631.1"> for every one of such types - we only need them for the types that were actually used w</span><a id="_idTextAnchor584"/><span class="koboSpan" id="kobo.632.1">i</span><a id="_idTextAnchor585"/><span class="koboSpan" id="kobo.633.1">th this template in </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">our program.</span></span></p>
<h2 id="_idParaDest-223"><a id="_idTextAnchor586"/><span class="koboSpan" id="kobo.635.1">Generating friends on demand</span></h2>
<p><span class="koboSpan" id="kobo.636.1">The pattern that we are about to </span><a id="_idIndexMarker696"/><span class="koboSpan" id="kobo.637.1">see is a very old one, and was introduced by John Barton and Lee Nackman in 1994 for a completely different purpose - they used it to work around certain limitations of the compilers that existed at the time. </span><span class="koboSpan" id="kobo.637.2">The inventors proposed the name </span><em class="italic"><span class="koboSpan" id="kobo.638.1">Restricted Template Expansion</span></em><span class="koboSpan" id="kobo.639.1">, which was never widely used. </span><span class="koboSpan" id="kobo.639.2">Years later, Dan Sacks coined the name </span><em class="italic"><span class="koboSpan" id="kobo.640.1">Friends Factory</span></em><span class="koboSpan" id="kobo.641.1">, but the </span><a id="_idIndexMarker697"/><span class="koboSpan" id="kobo.642.1">pattern is also sometimes referred to simply as the </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.643.1">Barton-Nackman trick</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.645.1">The pattern looks very simple and very similar to the code we wrote earlier throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">this chapter:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.647.1">
// Example 17
template &lt;typename T&gt; class C {
  int x_;
  public:
  C(int x) : x_(x) {}
  friend C operator+(const C&amp; lhs, const C&amp; rhs) {
    return C(lhs.x_ + rhs.x_);
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.648.1">We are taking advantage of a very specific C++ feature, and so the code must be written precisely. </span><span class="koboSpan" id="kobo.648.2">A non-template friend function is defined inside the class template. </span><span class="koboSpan" id="kobo.648.3">This function must be defined inline; it cannot be declared a friend and then defined later, except as an explicit template instantiation - we could have declared the friend function inside the class and then defined </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">operator+&lt;const C&lt;int&gt;&gt;&amp;, const C&lt;int&gt;&amp;)</span></strong><span class="koboSpan" id="kobo.650.1">, which would work for </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">C&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.652.1"> but not </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">C&lt;double&gt;</span></strong><span class="koboSpan" id="kobo.654.1"> (since we do not know what types the callers may instantiate later, this is not very useful). </span><span class="koboSpan" id="kobo.654.2">It may have the parameters of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">T</span></strong><span class="koboSpan" id="kobo.656.1"> type, the template parameter, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">C&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.658.1"> type (which, inside the class template, can be referred to as simply </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">C</span></strong><span class="koboSpan" id="kobo.660.1">), and any other type that is either fixed or depends only on the template parameters, but it may not be a template itself. </span><span class="koboSpan" id="kobo.660.2">Every instantiation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">C</span></strong><span class="koboSpan" id="kobo.662.1"> class template, with any combination of template parameter types, generates exactly one non-template, non-member function with the specified name. </span><span class="koboSpan" id="kobo.662.2">Note that the generated functions are non-template functions; they are regular functions, and the usual conversion rules apply to them. </span><span class="koboSpan" id="kobo.662.3">We are now back to the non-template </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">operator+()</span></strong><span class="koboSpan" id="kobo.664.1">, and all conversions work exactly the way we want </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">them to:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.666.1">
C&lt;int&gt; x(1), y(2);
C&lt;int&gt; z1 = x + y; // This works
C&lt;int&gt; z2 = x + 2; // and this too
C&lt;int&gt; z3 = 1 + 2; // so does this</span></pre>
<p><span class="koboSpan" id="kobo.667.1">This is it - this is the whole pattern. </span><span class="koboSpan" id="kobo.667.2">There are a few details we must note. </span><span class="koboSpan" id="kobo.667.3">First of all, the keyword </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">friend</span></strong><span class="koboSpan" id="kobo.669.1"> cannot be </span><a id="_idIndexMarker698"/><span class="koboSpan" id="kobo.670.1">omitted. </span><span class="koboSpan" id="kobo.670.2">A class cannot normally generate a non-member function, except for declaring a friend. </span><span class="koboSpan" id="kobo.670.3">Even if the function does not need access to any private data, in order to automatically generate non-template functions from instantiations of class templates, these functions have to be declared friends (static non-member functions can be generated in a similar manner, but the binary operators cannot be static functions - the standard explicitly forbids it). </span><span class="koboSpan" id="kobo.670.4">Second, the generated function is placed in the scope containing the class but must be found by the argument-dependent lookup, as we learned earlier in this chapter. </span><span class="koboSpan" id="kobo.670.5">For example, let’s define the inserter operator for our </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">C</span></strong><span class="koboSpan" id="kobo.672.1"> template class, but not before wrapping the entire class in </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">a namespace:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.674.1">
// Example 18
namespace NS {
template &lt;typename T&gt; class C {
  int x_;
  public:
  C(int x) : x_(x) {}
  friend C operator+(const C&amp; lhs, const C&amp; rhs) {
    return C(lhs.x_ + rhs.x_);
  }
  friend std::ostream&amp;
  operator&lt;&lt;(std::ostream&amp; out, const C&amp; c) {
    out &lt;&lt; c.x_;
    return out;
  }
};
} // namespace NS</span></pre>
<p><span class="koboSpan" id="kobo.675.1">We can now both add and print the objects of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">C</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.677.1"> type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.678.1">
NS::C&lt;int&gt; x(1), y(2);
std::cout &lt;&lt; (x + y) &lt;&lt; std::endl;</span></pre>
<p><span class="koboSpan" id="kobo.679.1">Note that, even though the </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">C</span></strong><span class="koboSpan" id="kobo.681.1"> class template is now in the namespace </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">NS</span></strong><span class="koboSpan" id="kobo.683.1">, and has to be used as such (</span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">NS::C&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.685.1">), we did not </span><a id="_idIndexMarker699"/><span class="koboSpan" id="kobo.686.1">need to do anything special to invoke either </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">operator+()</span></strong><span class="koboSpan" id="kobo.688.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">operator&lt;&lt;()</span></strong><span class="koboSpan" id="kobo.690.1">. </span><span class="koboSpan" id="kobo.690.2">This does not mean that they were generated in the global scope. </span><span class="koboSpan" id="kobo.690.3">No, they are still in the namespace </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">NS</span></strong><span class="koboSpan" id="kobo.692.1">, but what we see is the argument-dependent lookup in action - when looking for a function named </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">operator+()</span></strong><span class="koboSpan" id="kobo.694.1">, for example, the compiler considers the candidates in the current scope (that is, the global scope, and there aren’t any), as well as the scope</span><a id="_idIndexMarker700"/><span class="koboSpan" id="kobo.695.1"> in which the arguments to the function are defined. </span><span class="koboSpan" id="kobo.695.2">In our case, at least one of the arguments to </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">operator+()</span></strong><span class="koboSpan" id="kobo.697.1"> is of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">NS::C&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.699.1">, which automatically brings all functions declared in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">NS</span></strong><span class="koboSpan" id="kobo.701.1"> namespace into play. </span><span class="koboSpan" id="kobo.701.2">The friend factory generates its functions in the scope containing the class template, which is, of course, also the </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">NS</span></strong><span class="koboSpan" id="kobo.703.1"> namespace. </span><span class="koboSpan" id="kobo.703.2">Thus, the lookup finds the definition, and both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">+</span></strong><span class="koboSpan" id="kobo.705.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">&lt;&lt;</span></strong><span class="koboSpan" id="kobo.707.1"> operations are resolved exactly the way we would want</span><a id="_idIndexMarker701"/><span class="koboSpan" id="kobo.708.1"> them to be. </span><span class="koboSpan" id="kobo.708.2">Rest assured that this is by design and is no accident; the argument lookup rules are fine-tuned to produce this desired and </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">expected result.</span></span></p>
<p><span class="koboSpan" id="kobo.710.1">It is easy to prove that, even though friend functions are generated in the scope containing the class (in our case namespace </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">NS</span></strong><span class="koboSpan" id="kobo.712.1">), they can only be found by the argument-dependent lookup. </span><span class="koboSpan" id="kobo.712.2">A straightforward attempt to find the function without using an argument-dependent lookup </span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">will fail:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.714.1">
auto p = &amp;NS::</span><a id="_idTextAnchor587"/><span class="koboSpan" id="kobo.715.1">C&lt;int&gt;::operator+; // Does not compile</span></pre>
<p><span class="koboSpan" id="kobo.716.1">There is also a connection between the friend factory pattern and o</span><a id="_idTextAnchor588"/><span class="koboSpan" id="kobo.717.1">ne of the patterns we </span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">studied earlier.</span></span></p>
<h1 id="_idParaDest-224"><a id="_idTextAnchor589"/><span class="koboSpan" id="kobo.719.1">The friend factory and the Curiously Recurring Template Pattern</span></h1>
<p><span class="koboSpan" id="kobo.720.1">The friend factory is a</span><a id="_idIndexMarker702"/><span class="koboSpan" id="kobo.721.1"> pattern that synthesizes a non-template, non-member function from every instantiation of a class template - every time the template is instantiated on a new type, a new function is generated. </span><span class="koboSpan" id="kobo.721.2">For its parameters, this function can use any types we can declare in that instantiation of the class template. </span><span class="koboSpan" id="kobo.721.3">Usually, this is the class itself, but it can be any type the template </span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">knows about.</span></span></p>
<p><span class="koboSpan" id="kobo.723.1">In this manner, the friend factory can be employed together with the </span><strong class="bold"><span class="koboSpan" id="kobo.724.1">Curiously Recurring Template Pattern</span></strong><span class="koboSpan" id="kobo.725.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.726.1">CRTP</span></strong><span class="koboSpan" id="kobo.727.1">) that </span><a id="_idIndexMarker703"/><span class="koboSpan" id="kobo.728.1">we studied in </span><a href="B19262_08.xhtml#_idTextAnchor360"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.729.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.730.1">, </span><em class="italic"><span class="koboSpan" id="kobo.731.1">The Curiously Recurring Template Pattern</span></em><span class="koboSpan" id="kobo.732.1">. </span><span class="koboSpan" id="kobo.732.2">Recall that the main idea of the CRTP is that a class inherits from an instantiation of a base class template that is parameterized by the derived class type. </span><span class="koboSpan" id="kobo.732.3">Consider what we have here - a template for a base class that is automatically instantiated with every class derived from it, and it knows what that type is. </span><span class="koboSpan" id="kobo.732.4">This seems like an ideal place to put a friend factory. </span><span class="koboSpan" id="kobo.732.5">Of course, the operators generated by the base class have to not only know what the type of the object is that they operate on but also what to do with it (for example, how to print it). </span><span class="koboSpan" id="kobo.732.6">Sometimes, the necessary data actually resides in the base class, and then the base class can provide complete implementations. </span><span class="koboSpan" id="kobo.732.7">But it is rare that the derived class adds so little to the base class. </span><span class="koboSpan" id="kobo.732.8">The more common use of CRTP, together with the friend factory, is to implement some operators in a standard way through some other functionality. </span><span class="koboSpan" id="kobo.732.9">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">operator!=()</span></strong><span class="koboSpan" id="kobo.734.1"> can be implemented </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">through </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">operator==()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.737.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.738.1">
// Example 19
template &lt;typename D&gt; class B {
  public:
  friend bool operator!=(const D&amp; lhs, const D&amp; rhs) {
    return !(lhs == rhs);
  }
};
template &lt;typename T&gt; class C : public B&lt;C&lt;T&gt;&gt; {
  T x_;
  public:
  C(T x) : x_(x) {}
  friend bool operator==(const C&amp; lhs, const C&amp; rhs) {
    return lhs.x_ == rhs.x_;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.739.1">Here, the derived class </span><strong class="source-inline"><span class="koboSpan" id="kobo.740.1">C</span></strong><span class="koboSpan" id="kobo.741.1"> uses the friend factory pattern to generate a non-template function for the binary </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">operator==()</span></strong><span class="koboSpan" id="kobo.743.1"> directly from the instantiation of the class template. </span><span class="koboSpan" id="kobo.743.2">It also</span><a id="_idIndexMarker704"/><span class="koboSpan" id="kobo.744.1"> inherits from the base class </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">B</span></strong><span class="koboSpan" id="kobo.746.1">, which triggers</span><a id="_idIndexMarker705"/><span class="koboSpan" id="kobo.747.1"> an instantiation of that template as well, which in turn generates a non-template function for </span><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">operator!=()</span></strong><span class="koboSpan" id="kobo.749.1"> for every type for which we have </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">generated </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">operator==()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.752.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.753.1">The second use of CRTP is to convert member functions to non-member functions. </span><span class="koboSpan" id="kobo.753.2">For example, the binary </span><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">operator+()</span></strong><span class="koboSpan" id="kobo.755.1"> is sometimes implemented in terms of </span><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">operator+=()</span></strong><span class="koboSpan" id="kobo.757.1">, which is always a member</span><a id="_idIndexMarker706"/><span class="koboSpan" id="kobo.758.1"> function (it acts on its first operand). </span><span class="koboSpan" id="kobo.758.2">To implement the binary </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">operator+()</span></strong><span class="koboSpan" id="kobo.760.1">, someone has to take care of the conversions to that object’s type, and then </span><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">operator+=()</span></strong><span class="koboSpan" id="kobo.762.1"> can be called. </span><span class="koboSpan" id="kobo.762.2">These conversions are provided by the binary operators</span><a id="_idIndexMarker707"/><span class="koboSpan" id="kobo.763.1"> that are generated by the common CRTP base class when using the friend factory. </span><span class="koboSpan" id="kobo.763.2">Similarly, the inserter operator can be generated if we establish the convention that our classes have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">print()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.765.1">member function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.766.1">
// Example 20
template &lt;typename D&gt; class B {
  public:
  friend D operator+(const D&amp; lhs, const D&amp; rhs) {
    D res(lhs);
    res += rhs; // Convert += to +
    return res;
  }
  friend std::ostream&amp;
  operator&lt;&lt;(std::ostream&amp; out, const D&amp; d) {
    d.print(out);
    return out;
  }
};
template &lt;typename T&gt; class C : public B&lt;C&lt;T&gt;&gt; {
  T x_;
  public:
  C(T x) : x_(x) {}
  C operator+=(const C&amp; incr) {
    x_ += incr.x_;
    return *this;
  }
  void print(std::ostream&amp; out) const {
    out &lt;&lt; x_;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.767.1">In this fashion, CRTP can</span><a id="_idIndexMarker708"/><span class="koboSpan" id="kobo.768.1"> be used to add boilerplate interfaces while delegating</span><a id="_idIndexMarker709"/><span class="koboSpan" id="kobo.769.1"> the implementation to the derived classes. </span><span class="koboSpan" id="kobo.769.2">It is, after a</span><a id="_idTextAnchor590"/><span class="koboSpan" id="kobo.770.1">l</span><a id="_idTextAnchor591"/><span class="koboSpan" id="kobo.771.1">l, a static (compile-time) </span><span class="No-Break"><span class="koboSpan" id="kobo.772.1">delegation pattern.</span></span></p>
<h1 id="_idParaDest-225"><a id="_idTextAnchor592"/><span class="koboSpan" id="kobo.773.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.774.1">In this chapter, we have learned about a very C++-specific pattern that was originally introduced as a workaround for the buggy early C++ compilers but found new use years later. </span><span class="koboSpan" id="kobo.774.2">The friend factory is used to generate non-template functions from instantiations of class templates. </span><span class="koboSpan" id="kobo.774.3">As non-template functions, these generated friends have much more flexible rules with regard to argument conversions compared to template functions. </span><span class="koboSpan" id="kobo.774.4">We have also learned how the argument-dependent lookup, type conversions, and the friend factory work together to deliver a result that looks very natural, by a process that is far </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">from intuitive.</span></span></p>
<p><span class="koboSpan" id="kobo.776.1">The next chapter describes a totally different kind of Factory - a C++ pattern that’s based on the classic Factory pattern and addresses a certain asymmetry in the language - all member functions, even destru</span><a id="_idTextAnchor593"/><span class="koboSpan" id="kobo.777.1">c</span><a id="_idTextAnchor594"/><span class="koboSpan" id="kobo.778.1">tors, can be virtual, except </span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">the constructors.</span></span></p>
<h1 id="_idParaDest-226"><a id="_idTextAnchor595"/><span class="koboSpan" id="kobo.780.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.781.1">What is the effect of declaring a function as </span><span class="No-Break"><span class="koboSpan" id="kobo.782.1">a </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.783.1">friend</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.784.1">?</span></span></li>
<li><span class="koboSpan" id="kobo.785.1">What is the difference between granting friendship to a function versus a </span><span class="No-Break"><span class="koboSpan" id="kobo.786.1">function template?</span></span></li>
<li><span class="koboSpan" id="kobo.787.1">Why are binary operators usually implemented as </span><span class="No-Break"><span class="koboSpan" id="kobo.788.1">non-member functions?</span></span></li>
<li><span class="koboSpan" id="kobo.789.1">Why is the inserter operator always implemented as a </span><span class="No-Break"><span class="koboSpan" id="kobo.790.1">non-member function?</span></span></li>
<li><span class="koboSpan" id="kobo.791.1">What is the main difference between argument conversions for template and </span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">non-template functions?</span></span></li>
<li><span class="koboSpan" id="kobo.793.1">How can we make the act of instantiating the template also generate a unique non-template, </span><span class="No-Break"><span class="koboSpan" id="kobo.794.1">non-member function?</span></span></li>
</ol>
</div>
</body></html>