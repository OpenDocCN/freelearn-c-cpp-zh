- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Target Description
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LLVM has a very flexible architecture. You can also add a new target backend
    to it. The core of a backend is the target description, from which most of the
    code is generated. In this chapter, you will learn how to add support for a historical
    CPU.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Setting the stage for a new backend* introduces you to the M88k CPU architecture
    and shows you where to find the required information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Adding the new architecture to the Triple class* teaches you how to make LLVM
    aware of a new CPU architecture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Extending the ELF file format definition in LLVM* shows you how to add support
    for the M88k-specific relocations to the libraries and tools that handle ELF object
    files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating the target description* applies your knowledge of the TableGen language
    to model the register file and instructions in the target description'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Adding the M88k backend to LLVM* explains the minimal infrastructure required
    for an LLVM backend'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Implementing an assembler parser* shows you how to develop the assembler'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating the disassembler* teaches you how to create the disassembler'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will know how to add a new backend to LLVM. You
    will acquire the knowledge to develop the register file definition and instruction
    definition in the target description, and you will know how to create the assembler
    and disassembler from that description.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the stage for a new backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether commercially needed to support a new CPU or only a hobby project to
    add support for some old architecture, adding a new backend to LLVM is a major
    task. This and the following two chapters outline what you need to develop for
    a new backend. We will add a backend for the Motorola M88k architecture, which
    is a RISC architecture from the 1980s.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about this Motorola architecture on Wikipedia at [https://en.wikipedia.org/wiki/Motorola_88000](https://en.wikipedia.org/wiki/Motorola_88000).
    The most important information about this architecture is still available on the
    internet. You can find the CPU manuals with the instruction set and timing information
    at [http://www.bitsavers.org/components/motorola/88000/](http://www.bitsavers.org/components/motorola/88000/),
    and the System V ABI M88k Processor supplement with the definitions of the ELF
    format and the calling convention at [https://archive.org/details/bitsavers_attunixSysa0138776555SystemVRelease488000ABI1990_8011463](https://archive.org/details/bitsavers_attunixSysa0138776555SystemVRelease488000ABI1990_8011463).
  prefs: []
  type: TYPE_NORMAL
- en: OpenBSD, available at [https://www.openbsd.org/](https://www.openbsd.org/),
    still supports the LUNA-88k system. On the OpenBSD system, it is easy to create
    a GCC cross-compiler for M88k. And with GXemul, available at [http://gavare.se/gxemul/](http://gavare.se/gxemul/),
    we get an emulator capable of running certain OpenBSD releases for the M88k architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The M88k architecture is long out of production, but we found enough information
    and tools to make it an interesting goal to add an LLVM backend for it. We will
    begin with a very basic task of extending the `Triple` class.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the new architecture to the Triple class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An instance of the `Triple` class represents the target platform LLVM is producing
    code for. To support a new architecture, the first task is to extend the `Triple`
    class. In the `llvm/include/llvm/TargetParser/Triple.h` file, add a member to
    the `ArchType` enumeration along with a new predicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `llvm/lib/TargetParser/Triple.cpp` file, there are many methods
    that use the `ArchType` enumeration. You need to extend all of them; for example,
    in the `getArchTypeName()` method, you need to add a new `case` statement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Most times, the compiler will warn you if you forget to handle the new `m88k`
    enumeration member in one of the functions. Next, we will expand the **Executable
    and Linkable** **Format** (**ELF**).
  prefs: []
  type: TYPE_NORMAL
- en: Extending the ELF file format definition in LLVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ELF file format is one of the binary object file formats LLVM supports.
    ELF itself is defined for many CPU architectures, and there is also a definition
    for the M88k architecture. All we need to do is to add the definition of the relocations
    and some flags. The relocations are given in [*Chapter 4*](B19561_04.xhtml#_idTextAnchor068),
    *Basics of IR Code Generation*, of the *System V ABI M88k Processor* supplement
    book (see link within the *Setting the stage for a new backend* section at the
    beginning of the chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to type the following code into the `llvm/include/llvm/BinaryFormat/ELFRelocs/M88k.def`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also add the following flags into the `llvm/include/llvm/BinaryFormat/ELF.h`
    file, along with the definition of the relocations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code can be added anywhere in the file, but it is best to keep the file
    structured and insert it before the code for the MIPS architecture.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We also need to expand some other methods. In the `llvm/include/llvm/Object/ELFObjectFile.h`
    file are some methods that translate between enumeration members and strings.
    For example, we must add a new `case` statement to the `getFileFormatName()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, we extend the `getArch()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we use the relocation definitions in the `llvm/lib/Object/ELF.cpp`
    file, in the `getELFRelocationTypeName()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To complete the support, you can valso extend the `llvm/lib/ObjectYAML/ELFYAML.cpp`
    file. This file is used by the `yaml2obj` and `obj2yaml` tools, which create an
    ELF file based on a YAML description, and vice versa. The first addition needs
    to be done in the `ScalarEnumerationTraits<ELFYAML::ELF_EM>::enumeration()` method,
    which lists all the values for the ELF architectures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Likewise, in the `ScalarEnumerationTraits<ELFYAML::ELF_REL>::enumeration()`
    method, you need to include the definitions of the relocations again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this point, we have completed the support of the m88k architecture in the
    ELF file format. You can use the `llvm-readobj` tool to inspect an ELF object
    file, for example, created by a cross-compiler on OpenBSD. Likewise, you can create
    an ELF object file for the m88k architecture with the `yaml2obj` tool.
  prefs: []
  type: TYPE_NORMAL
- en: Is adding support for an object file format mandatory?
  prefs: []
  type: TYPE_NORMAL
- en: Integrating support for an architecture into the ELF file format implementation
    requires only a couple of lines of code. If the architecture for which you are
    creating an LLVM backend uses the ELF format, then you should take this route.
    On the other hand, adding support for a completely new binary file format is a
    complicated task. If this is required, then an often-used approach is to only
    output assembler files and use an external assembler to create object files.
  prefs: []
  type: TYPE_NORMAL
- en: With these additions, the LLVM implementation of the ELF file format now supports
    the M88k architecture. In the next section, we create the target description for
    the M88k architecture, which describes the instructions, the registers, and many
    more details of the architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the target description
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `llvm/include/llvm/Target/Target.td` file, which can be found online at
    [https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/Target/Target.td](https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/Target/Target.td).
    This file is heavily commented on and is a useful source of information about
    the use of the definitions.
  prefs: []
  type: TYPE_NORMAL
- en: In an ideal world, we would generate the whole backend from the target description.
    This goal has not yet been reached, and therefore, we will need to extend the
    generated code later. Because of its size, the target description is split into
    several files. The top-level file will be `M88k.td`, inside the `llvm/lib/Target/M88k`
    directory, which also includes the other files. Let’s have a look at some files,
    beginning with the register definition.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the register definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A CPU architecture usually defines a set of registers. The characteristics of
    these registers can vary. Some architectures allow access to sub-registers. For
    example, the x86 architecture has special register names to access only a part
    of a register value. Other architectures do not implement this. In addition to
    general-purpose, floating-point, and vector registers, an architecture may have
    special registers for status codes or configuration of floating-point operations.
    We need to define all this information for LLVM. The register definitions are
    stored in the `M88kRegisterInfo.td` file, also found within the `llvm/lib/Target/M88k`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The M88k architecture defines general-purpose registers, extended registers
    for floating-point operations, and control registers. To keep the example small,
    we only define the general-purpose registers. We begin by defining a super-class
    for the registers. A register has a name and an encoding. The name is used in
    the textual representation of an instruction. Similarly, the encoding is used
    as part of the binary representation of an instruction. The architecture defines
    32 registers and the encoding for registers therefore uses 5 bits, so we limit
    the field holding the encoding. We also define that all the generated C++ code
    should live in the `M88k` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can define all 32 general-purpose registers. The `r0` register is
    special because it always returns the constant `0` when read, so we set the `isConstant`
    flag to `true` for that register:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For the register allocator, the single registers need to be grouped into register
    classes. The sequence order of the registers defines the allocation order. The
    register allocator also needs other information about the registers such as, for
    example, the value types, which can be stored in a register, the spill size of
    a register in bits, and the required alignment in memory. Instead of using the
    `RegisterClass` base class directly, we create a new `M88kRegisterClass` class.
    This allows us to change the parameter list to our needs. It also avoids the repetition
    of the C++ namespace name used for the generated code, which is the first argument
    for the `RegisterClass` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, we define a class for register operands. Operands describe the
    input and output of an instruction. They are used during assembling and disassembling
    of an instruction, and also in the patterns used by the instruction selection
    phase. Using our own class, we can give the generated function used to decode
    a register operand a name that conforms to the LLVM coding guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on these definitions, we now define the general-purpose registers. Please
    note that a general-purpose register of the m88k architecture is 32-bits wide
    and can hold integer and floating-point values. To avoid writing all register
    names, we use the `sequence` generator, which generates a list of strings based
    on the template string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, we define the register operand. The `r0` register is special because
    it contains the constant `0`. This fact can be used by the global instruction
    selection framework, and therefore, we attach this information to the register
    operand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There is an extension to the m88k architecture that defines an extended register
    file for floating-point values only. You would define those registers in the same
    way as the general-purpose registers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general-purpose registers are also used in pairs, mainly for 64-bit floating
    point operations, and we need to model them. We use the `sub_hi` and `sub_lo`
    sub-register indices to describe the high 32 bits and the low 32 bits. We also
    need to set the C++ namespace for the generated code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The register pairs are then defined using the `RegisterTuples` class. The class
    takes a list of sub-register indices as the first argument and a list of registers
    as the second argument. We only need even/odd numbered pairs, and we achieve this
    with the optional fourth parameter of sequence, which is the stride to use when
    generating the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the register pairs, we define a register class and a register operand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Please note that we set the `copycost` parameter to `2` because we need two
    instructions instead of one to copy a register pair to another register pair.
  prefs: []
  type: TYPE_NORMAL
- en: This finishes our definition of the registers. In the next section, we will
    define the instruction formats.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the instruction formats and the instruction information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An instruction is defined using the TableGen `Instruction` class. Defining an
    instruction is a complex task because we have to consider many details. An instruction
    has a textual representation used by the assembler and the disassembler. It has
    a name, for example, `and`, and it may have operands. The assembler transforms
    the textual representation into a binary format, therefore, we must define the
    layout of that format. For instruction selection, we need to attach a pattern
    to the instruction. To manage this complexity, we define a class hierarchy. The
    base classes will describe the various instruction formats and are stored in the
    `M88kIntrFormats.td` file. The instructions themselves and other definitions required
    for the instruction selection are stored in the `M88kInstrInfo.td` file.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin with defining a class for the instructions of the m88k architecture
    called `M88kInst`. We derive this class from the predefined `Instruction` class.
    Our new class has a couple of parameters. The `outs` and `ins` parameters describe
    the output and input operands as a list, using the special `dag` type. The textual
    representation of the instruction is split into the mnemonic given in the `asm`
    parameter, and the operands. Last, the `pattern` parameter can hold a pattern
    used for instruction selection.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to define two new fields:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Inst` field is used to hold the bit pattern of the instruction. Because
    the size of an instruction depends on the platform, this field cannot be predefined.
    All instructions of the m88k architecture are 32-bit wide, and so this field has
    the `bits<32>` type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other field is called `SoftFail` and has the same type as `Inst`. It holds
    a bit mask used with an instruction for which the actual encoding can differ from
    the bits in the `Inst` field and still be valid. The only platform that requires
    this is ARM, so we can simply set this field to `0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The other fields are defined in the superclass, and we only set the value.
    Simple computations are possible in the TableGen language, and we use this when
    we create the value for the `AsmString` field, which holds the full assembler
    representation. If the `operands` operand string is empty, then the `AsmString`
    field will just have the value of the `asm` parameter, otherwise, it will be the
    concatenation of both strings, with a space between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'For the instruction encoding, the manufacturer usually groups instructions
    together, and the instructions of one group have a similar encoding. We can use
    those groups to systematically create classes defining the instruction formats.
    For example, all logical operations of the m88k architecture encode the destination
    register in the bits from 21 to 25 and the first source register in the bits from
    16 to 20\. Please note the implementation pattern here: we declare the `rd` and
    `rs1` fields for the values, and we assign those values to the correct bit positions
    of the `Inst` field, which we defined previously in the superclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several groups of logical operations based on this format. One of
    them is the group of instructions using three registers, which is called **triadic
    addressing mode** in the manual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Let’s examine the functionality provided by this class in more detail. The `func`
    parameter specifies the operation. As a special feature, the second operand can
    be complemented before the operation, which is indicated by setting the `1`. The
    mnemonic is given in the `asm` parameter, and an instruction selection pattern
    can be passed.
  prefs: []
  type: TYPE_NORMAL
- en: With initializing the superclass, we can give more information. The full assembler
    text template for the `and` instruction is `and $rd, $rs1, $rs2`. The operand
    string is fixed for all instructions of this group, so we can define it here.
    The mnemonic is given by the user of this class, but we can concatenate the `.c`
    suffix here, which denotes that the second operand should be complemented first.
    And last, we can define the output and input operands. These operands are expressed
    as `(``outs GPROpnd:$rd)`.
  prefs: []
  type: TYPE_NORMAL
- en: The `outs` operation denotes this dag as the output operand list. The only argument,
    `GPROpnd:$rd`, consists of a type and a name. It connects several pieces we have
    already seen. The type is `GPROnd`, which is the name of the register operand
    we have defined in the previous section. The name `$rd` refers to the destination
    register. We used this name in the operand string earlier, and also as a field
    name in the `F_L` superclass. The input operands are defined similarly. The rest
    of the class initializes the other bits of the `Inst` field. Please take the time
    and check that all 32 bits are indeed now assigned.
  prefs: []
  type: TYPE_NORMAL
- en: 'We put the final instruction definition in the `M88kInstrInfo.td` file. Since
    we have two variants of each logical instruction, we use a multiclass to define
    both instructions at once. We also define here the pattern for the instruction
    selection as a directed acyclic graph. The operation in the pattern is `set`,
    and the first argument is the destination register. The second argument is a nested
    graph, which is the actual pattern. Once again, the name of the operation is the
    first `OpNode` element. LLVM has many predefined operations, which you find in
    the `llvm/include/llvm/Target/TargetSelectionDAG.td` file ([https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/Target/TargetSelectionDAG.td](https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/Target/TargetSelectionDAG.td)).
    For example, there is the `and` operation, which denotes a bitwise AND operation.
    The arguments are the two source registers, `$rs1` and `$rs2`.You read this pattern
    roughly as follows: if the input to the instruction selection contains an OpNode
    operation using two registers, then assign the result of this operation to the
    `$rd` register and generate this instruction. Utilizing the graph structure, you
    can define more complex patterns. For example, the second pattern integrates the
    complement into the pattern using the `not` operand.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A small detail to point out is that the logical operations are commutative.
    This can be helpful for the instruction selection, so we set the `isCommutable`
    flag to `1` for those instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we define the records for the instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter is the bit pattern for the function, the second is the mnemonic,
    and the third parameter is the dag operation used in the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: To fully understand the class hierarchy, revisit the class definitions. The
    guiding design principle is to avoid the repetition of information. For example,
    the `0b01000` function bit pattern is used exactly once. Without the `Logic` multiclass
    you would need to type this bit pattern twice and repeat the patterns several
    times, which is error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: Please also note that it is good to establish a naming scheme for the instructions.
    For example, the record for the `and` instruction is named `ANDrr`, while the
    variant with the complemented register is named `ANDrrc`. Those names end up in
    the generated C++ source code, and using a naming scheme helps to understand to
    which assembler instruction the name refers.
  prefs: []
  type: TYPE_NORMAL
- en: Up to now, we modeled the register file of the m88k architecture and defined
    a couple of instructions. In the next section, we will create the top-level file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the top-level file for the target description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we created the `M88kRegisterInfo.td`, `M88kInstrFormats.td`, and `M88kInstrInfo.td`
    files. The target description is a single file, called `M88k.td`. This file includes
    the LLVM definitions first, and the files that we have implemented follow afterwards.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We will extend this `include` section later when we add more backend functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The top-level file also defines some global instances. The first record named
    `M88kInstrInfo` holds the information about all instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We call the assembler class `M88kAsmParser`. To enable TableGen to identify
    hardcoded registers, we specify that register names are prefixed with a percent
    sign, and we need to define an assembler parser variant to specify this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And last, we need to define the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We now have defined enough of the target so that we can code the first utility.
    In the next section, we add the M88k backend to LLVM.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the M88k backend to LLVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have not yet discussed where to place the target description files. Each
    backend in LLVM has a subdirectory in `llvm/lib/Target`. We create the `M88k`
    directory here and copy the target description files into it.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, just adding the TableGen files is not enough. LLVM uses a registry
    to look up instances of a target implementation, and it expects certain global
    functions to register those instances. And since some parts are generated, we
    can already provide an implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'All information about a target, like the target triple and factory function
    for the target machine, assembler, disassembler, and so on, are stored in an instance
    of the `Target` class. Each target holds a static instance of this class, and
    this instance is registered in the central registry:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation is in the `M88kTargetInfo.cpp` file in the `TargetInfo`
    subdirectory in our target. The single instance of the `Target` class is held
    inside the `getTheM88kTarget()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'LLVM requires that each target provides a `LLVMInitialize<Target Name>TargetInfo()`
    function to register the target instance. That function must have a C linkage
    because it is also used in the LLVM C API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need to create an `M88kTargetInfo.h` header file in the same directory,
    which just contains a single declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And last, we add a `CMakeLists.txt` file for building:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we partially populate the target instance with the information used at
    the **machine-code** (**MC**) level. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation is in the `M88kMCTargetDesc.cpp` file in the `MCTargetDesc`
    subdirectory. TableGen turns the target description we created in the previous
    section into C++ source code fragments. Here, we include the parts for the register
    information, the instruction information, and the sub-target information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The target registry expects a factory method for each of the classes here.
    Let’s begin with the instruction information. We allocate an instance of the `MCInstrInfo`
    class, and call the `InitM88kMCInstrInfo()` generated function to populate the
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we allocate an object of the `MCRegisterInfo` class and call a generated
    function to populate it. The additional `M88k::R1` parameter value tells LLVM
    that the `r1` register holds the return address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And last, we need a factory method for the sub-target information. This method
    takes a target triple, a CPU name, and a feature string as parameters, and forwards
    them to the generated method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Having the factory methods defined, we can now register them. Similar to the
    target registration, LLVM expects a global function called `LLVMInitialize<Target
    Name>TargetMC()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `M88kMCTargetDesc.h` header file just makes some generated code available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The implementation is almost done. To prevent a linker error, we need to provide
    another function, which registers a factory method for an object of the `TargetMachine`
    class. This class is required for code generation, and we implement it in [*Chapter
    12*](B19561_12.xhtml#_idTextAnchor193)*, Instruction Selection*, up next. Here,
    we just define an empty function in the `M88kTargetMachine.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This concludes our first implementation. However, LLVM does not yet know about
    our new backend. To integrate it, open the `llvm/CMakeLists.txt` file, locate
    the section defining all the experimental targets, and add the M88k target to
    the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming the LLVM source code with our new backend is in the directory, you
    can configure the build by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'After building LLVM, you can verify that the tools already know about our new
    target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The journey to get to this point was difficult, so take a moment to celebrate!
  prefs: []
  type: TYPE_NORMAL
- en: Fixing a possible compile error
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a small oversight in LLVM 17.0.2, which causes a compile error. In
    one place in the code, the TableGen emitter for the sub-target information uses
    the removed value `llvm::None` instead of `std:: nullopt`, causing an error while
    compiling `M88kMCTargetDesc.cpp`. The easiest way to fix this problem is to cherry-pick
    the fix from the LLVM 18 development branch: `git cherry-pick -``x a587f429`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we implement the assembler parser, which will give us the
    first working LLVM tool.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the assembler parser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The assembler parser is easy to implement, since LLVM provides a framework for
    it, and large parts are generated from the target description.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ParseInstruction()` method in our class is called when the framework detects
    that an instruction needs to be parsed. That method parses in input via the provided
    lexer and constructs a so-called operand vector. An operand can be a token such
    as an instruction mnemonic, a register name, or an immediate, or it can be category-specific
    to the target. For example, two operands are constructed from the `jmp %r2` input:
    a token operand for the mnemonic, and a register operand.'
  prefs: []
  type: TYPE_NORMAL
- en: Then a generated matcher tries to match the operand vector against the instructions.
    If a match is found, then an instance of the `MCInst` class is created, which
    holds the parsed instruction. Otherwise, an error message is emitted. The advantage
    of this approach is that it automatically derives the matcher from the target
    description, without needing to handle all syntactical quirks.
  prefs: []
  type: TYPE_NORMAL
- en: However, we need to add a couple more support classes to make the assembler
    parser work. These additional classes are all stored in the `MCTargetDesc` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the MCAsmInfo support class for the M88k Target
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Within this section, we explore implementing the first required class for the
    configuration of the assembler parser: the `MCAsmInfo` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to set some customization parameters for the assembler parser. The
    `MCAsmInfo` base class ([https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/MC/MCAsmInfo.h](https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/MC/MCAsmInfo.h))
    contains the common parameters. In addition, a subclass is created for each supported
    object file format; for example, the `MCAsmInfoELF` class ([https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/MC/MCAsmInfoELF.h](https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/MC/MCAsmInfoELF.h)).
    The reasoning behind it is that the system assemblers on systems using the same
    object file format share common characteristics because they must support similar
    features. Our target operating system is OpenBSD, and it uses the ELF file format,
    so we derive our own `M88kMCAsmInfo` class from the `MCAsmInfoELF` class. The
    declaration in the `M88kMCAsmInfo.h` file is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The implementation in the `M88kMCAsmInfo.cpp` file only sets a couple of default
    values. Two crucial settings at present are the system using big-endian mode and
    employing the `|` symbol for comments. The other settings are for code generation
    later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we have completed the implementation for the `MCAsmInfo` class. The next
    class we will learn to implement helps us create a binary representation of the
    instructions within LLVM.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the MCCodeEmitter support class for the M88k Target
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Internally in LLVM, an instruction is represented by an instance of the `MCInst`
    class. An instruction can be emitted as an assembler text or in binary into an
    object file. The `M88kMCCodeEmitter` class creates the binary representation of
    an instruction, while the `M88kInstPrinter` class emits the textual representation
    of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will implement the `M88kMCCodeEmitter` class, which is stored in
    the `M88kMCCodeEmitter.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the class is generated by TableGen. Therefore, we only need to add
    some boilerplate code. Note that there is no corresponding header file; the prototype
    of the factory function will be added to the `M88kMCTargetDesc.h` file. It begins
    with setting up a statistic counter for the number of emitted instructions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `M88kMCCodeEmitter` class lives in an anonymous namespace. We only need
    to implement the `encodeInstruction()` method, which is declared in the base class,
    and the `getMachineOpValue()` helper method. The other `getBinaryCodeForInstr()`
    method is generated by TableGen from the target description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `encodeInstruction()` method just looks up the binary representation of
    the instruction, increments the statistic counter, and writes the bytes out in
    big-endian format. Remember that the instructions have a fixed size of 4 bytes,
    therefore we use the `uint32_t` type on the endian stream:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The task of the `getMachineOpValue()` method is to return the binary representation
    of operands. In the target description, we defined the bit ranges where the registers
    used are stored in an instruction. Here, we compute the value, which is stored
    in these places. The method is called from the generated code. We only support
    two cases. For a register, the encoding of the register, which we defined in the
    target description, is returned. For an immediate, the immediate value is returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And last, we include the generated file and create a factory method for the
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implementing the instruction printer support class for the M88k Target
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `M88kInstPrinter` class has a similar structure to the `M88kMCCodeEmitter`
    class. As mentioned previously, the `InstPrinter` class is responsible for emitting
    the textual representation of LLVM instructions. Most of the class is generated
    by TableGen, but we have to add support for printing the operands. The class is
    declared in the `M88kInstPrinter.h` header file. The implementation is in the
    `M88kInstPrinter.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin with the header file. After including the required header files
    and declaring the `llvm` namespace, two forward references are declared to reduce
    the number of required includes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Besides the constructor, we only need to implement the `printOperand()` and
    `printInst()` methods. The other methods are generated by TableGen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The implementation lives in the `M88kInstPrint.cpp` file. After including the
    required header file and using the `llvm` namespace, the file with the generated
    C++ fragments is included:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `printOperand()` method checks the type of the operand and emits either
    a register name or an immediate. The register name is looked up with the `getRegisterName()`
    generated method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `printInst()` method only calls the `printInstruction()` generated method
    to print the instruction, and after that, the `printAnnotation()` method to print
    possible annotations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implementing M88k-specific target descriptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the `M88kMCTargetDesc.cpp` file, we need to make a couple of additions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need a new factory method for the `MCInstPrinter` class and the `MCAsmInfo`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, within the `LLVMInitializeM88kTargetMC()` function, we need to add
    the registration of the factory methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we have implemented all required support classes, and we can finally add
    the assembler parser.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the M88k assembler parser class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is only an `M88kAsmParser.cpp` implementation file in the `AsmParser`
    directory. The `M88kOperand` class represents a parsed operand and is used by
    the generated source code and our assembler parser implementation in class `M88kAssembler`.
    Both classes are in an anonymous namespace, only the factory method is globally
    visible. Let’s take a look at the `M88kOperand` class first:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An operand can be a token, a register, or an immediate. We define the `OperandKind`
    enumeration to distinguish between these cases. The current kind is stored in
    the `Kind` member. We also store the start and the end location of the operand,
    which is needed to print the error message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To store the value, we define a union. The token is stored as a `StringRef`
    and the register is identified by its number. The immediate is represented by
    the `MCExpr` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The constructor initializes all fields but the union. Furthermore, we define
    methods to return the value of the start and the end locations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For each operand type, we must define four methods. For a register, the methods
    are `isReg()` to check whether the operand is a register, `getReg()` to return
    the value, `createReg()` to create a register operand, and `addRegOperands()`
    to add an operant to an instruction. The latter function is called by the generated
    source code when an instruction is constructed. The methods for the token and
    the immediate are similar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And last, the superclass defines an abstract `print()` virtual method that
    we need to implement. This is only used for debugging purposes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we declare the `M88kAsmParser` class. The anonymous name space will end
    after the declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the beginning of the class we include the generated fragment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we define the required fields. We need a reference to the actual parser,
    which is of the `MCAsmParser` class, and a reference to the sub-target information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To implement the assembler, we override a couple of methods defined in the
    `MCTargetAsmParser` superclass. The `MatchAndEmitInstruction()` method tries to
    match an instruction and emits the instruction represented by an instance of the
    `MCInst` class. Parsing an instruction is done in the `ParseInstruction()` method,
    while the `parseRegister()` and `tryParseRegister()` methods are responsible for
    parsing the register. The other methods are required internally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The constructor is defined inline. It mostly initializes all fields. This finishes
    the class declaration, after which the anonymous namespace ends:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we include the generated parts of the assembler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ParseInstruction()` method is called whenever an instruction is expected.
    It must be able to parse all syntactical forms of an instruction. Currently, we
    only have instructions that take three operands, which are separated by a comma,
    so the parsing is simple. Be aware that the return value is `true` in case of
    an error!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An operand can be a register or an immediate. We generalize a bit and parse
    an expression instead of just an integer. This helps later when adding address
    modes. When successful, the parsed operand is added to the `Operands` list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `parseRegister()` method tries to parse a register. First, it checks for
    a percent sign `%`. If this is followed by an identifier which matches a register
    name, then we successfully parsed a register, and return the register number in
    the `RegNo` parameter. However, if we cannot identify a register, then we may
    need to undo the lexing if the `RestoreOnFailure` parameter is `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `parseRegister()` and `tryparseRegister()` overridden methods are just
    wrappers around the previously defined method. The latter method also translates
    the boolean return value into an enumeration member of the `OperandMatchResultTy`
    enumeration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, the `MatchAndEmitInstruction()` method drives the parsing. Most of
    the method is dedicated to emitting error messages. To identify the instruction,
    the `MatchInstructionImpl()` generated method is called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And like some other classes, the assembler parser has its own factory method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This finishes the implementation of the assembler parser. After building LLVM,
    we can use the **llvm-mc** machine code playground tool to assemble an instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of the vertical bar `|` as the comments sign. This is the value
    we configured in the `M88kMCAsmInfo` class.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging the assembler matcher
  prefs: []
  type: TYPE_NORMAL
- en: To debug the assembler matcher, you specify the `--debug-only=asm-matcher` command-line
    option. This helps with understanding why a parsed instruction fails to match
    the instructions defined in the target description.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will add a disassembler feature to the llvm-mc tool.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the disassembler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implementing the disassembler is optional. However, the implementation does
    not require too much effort, and generating the disassembler table may catch encoding
    errors that are not checked by the other generators. The disassembler lives in
    the `M88kDisassembler.cpp` file, found in the `Disassembler` subdirectory:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin the implementation by defining a debug type and the `DecodeStatus`
    type. Both are required for the generated code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `M88kDisassmbler` class lives in an anonymous namespace. We only need to
    implement the `getInstruction()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need to provide a factory method, which will be registered in the target
    registry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `decodeGPRRegisterClass()` function turns a register number into the register
    enum member generated by TableGen. This is the inverse operation of the `M88kInstPrinter::
    getMachineOpValue()` method. Note that we specified the name of this function
    in the `DecoderMethod` field in the `M88kRegisterOperand` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we include the generated disassembler tables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And finally, we decode the instruction. For this, we need to take the next
    four bytes of the `Bytes` array, create the instruction encoding from them, and
    call the `decodeInstruction()` generated function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That is all that needs to be done for the disassembler. After compiling LLVM,
    you can test the functionality again with the `llvm-mc` tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Moreover, we can now use the `llvm-objdump` tool to disassemble ELF files. However,
    for it to be really useful, we would need to add all instructions to the target
    description.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to create a LLVM target description, and you
    developed a simple backend target that supports the assembling and disassembling
    of instructions for LLVM. You first collected the required documentation and made
    LLVM aware of the new architecture by enhancing the `Triple` class. The documentation
    also includes the relocation definition for the ELF file format, and you added
    the support for them to LLVM.
  prefs: []
  type: TYPE_NORMAL
- en: You then learned about the register definition and the instruction definition
    in the target description and used the generated C++ source code to implement
    an instruction assembler and disassembler.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will add code generation to the backend.
  prefs: []
  type: TYPE_NORMAL
