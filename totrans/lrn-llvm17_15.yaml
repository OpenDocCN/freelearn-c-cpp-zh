- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: The Target Description
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目标描述
- en: LLVM has a very flexible architecture. You can also add a new target backend
    to it. The core of a backend is the target description, from which most of the
    code is generated. In this chapter, you will learn how to add support for a historical
    CPU.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 具有非常灵活的架构。您也可以向其中添加新的目标后端。后端的核心是目标描述，大部分代码都是从那里生成的。在本章中，您将学习如何添加对历史 CPU
    的支持。
- en: 'In this chapter, you will cover the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将涵盖以下内容：
- en: '*Setting the stage for a new backend* introduces you to the M88k CPU architecture
    and shows you where to find the required information'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为新后端做准备* 介绍了 M88k CPU 架构，并展示了如何找到所需信息'
- en: '*Adding the new architecture to the Triple class* teaches you how to make LLVM
    aware of a new CPU architecture'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将新架构添加到 Triple 类中* 教您如何让 LLVM 识别新的 CPU 架构'
- en: '*Extending the ELF file format definition in LLVM* shows you how to add support
    for the M88k-specific relocations to the libraries and tools that handle ELF object
    files'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 LLVM 中扩展 ELF 文件格式定义* 展示了如何向处理 ELF 对象文件的库和工具添加对 M88k 特定重定位的支持'
- en: '*Creating the target description* applies your knowledge of the TableGen language
    to model the register file and instructions in the target description'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建目标描述* 将您对 TableGen 语言的了解应用于在目标描述中建模寄存器文件和指令'
- en: '*Adding the M88k backend to LLVM* explains the minimal infrastructure required
    for an LLVM backend'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将 M88k 后端添加到 LLVM* 解释了为 LLVM 后端所需的最低基础设施'
- en: '*Implementing an assembler parser* shows you how to develop the assembler'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现汇编器解析器* 展示了如何开发汇编器'
- en: '*Creating the disassembler* teaches you how to create the disassembler'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建反汇编器* 教您如何创建反汇编器'
- en: By the end of the chapter, you will know how to add a new backend to LLVM. You
    will acquire the knowledge to develop the register file definition and instruction
    definition in the target description, and you will know how to create the assembler
    and disassembler from that description.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解如何将新后端添加到 LLVM。您将获得开发目标描述中的寄存器文件定义和指令定义的知识，并且您将知道如何从该描述中创建汇编器和反汇编器。
- en: Setting the stage for a new backend
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为新后端做准备
- en: Whether commercially needed to support a new CPU or only a hobby project to
    add support for some old architecture, adding a new backend to LLVM is a major
    task. This and the following two chapters outline what you need to develop for
    a new backend. We will add a backend for the Motorola M88k architecture, which
    is a RISC architecture from the 1980s.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是否需要商业上支持新的 CPU，还是仅仅作为一个爱好项目来添加对某些旧架构的支持，将新后端添加到 LLVM 都是一项重大任务。本节和接下来的两章概述了您需要为新后端开发的内容。我们将添加一个用于摩托罗拉
    M88k 架构的后端，这是一个 80 年代的 RISC 架构。
- en: References
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: You can read more about this Motorola architecture on Wikipedia at [https://en.wikipedia.org/wiki/Motorola_88000](https://en.wikipedia.org/wiki/Motorola_88000).
    The most important information about this architecture is still available on the
    internet. You can find the CPU manuals with the instruction set and timing information
    at [http://www.bitsavers.org/components/motorola/88000/](http://www.bitsavers.org/components/motorola/88000/),
    and the System V ABI M88k Processor supplement with the definitions of the ELF
    format and the calling convention at [https://archive.org/details/bitsavers_attunixSysa0138776555SystemVRelease488000ABI1990_8011463](https://archive.org/details/bitsavers_attunixSysa0138776555SystemVRelease488000ABI1990_8011463).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在维基百科上了解更多关于这种摩托罗拉架构的信息：[https://en.wikipedia.org/wiki/Motorola_88000](https://en.wikipedia.org/wiki/Motorola_88000)。关于该架构的最重要信息仍然可以在互联网上找到。您可以在
    [http://www.bitsavers.org/components/motorola/88000/](http://www.bitsavers.org/components/motorola/88000/)
    找到 CPU 手册以及指令集和时序信息，在 [https://archive.org/details/bitsavers_attunixSysa0138776555SystemVRelease488000ABI1990_8011463](https://archive.org/details/bitsavers_attunixSysa0138776555SystemVRelease488000ABI1990_8011463)
    可以找到 System V ABI M88k 处理器补充，其中包含了 ELF 格式和调用约定的定义。
- en: OpenBSD, available at [https://www.openbsd.org/](https://www.openbsd.org/),
    still supports the LUNA-88k system. On the OpenBSD system, it is easy to create
    a GCC cross-compiler for M88k. And with GXemul, available at [http://gavare.se/gxemul/](http://gavare.se/gxemul/),
    we get an emulator capable of running certain OpenBSD releases for the M88k architecture.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD，可在 [https://www.openbsd.org/](https://www.openbsd.org/) 获取，仍然支持 LUNA-88k
    系统。在 OpenBSD 系统上，创建 M88k 的 GCC 跨编译器很容易。而且，使用可在 [http://gavare.se/gxemul/](http://gavare.se/gxemul/)
    获取的 GXemul，我们可以得到一个能够运行某些 OpenBSD 版本的 M88k 架构的仿真器。
- en: The M88k architecture is long out of production, but we found enough information
    and tools to make it an interesting goal to add an LLVM backend for it. We will
    begin with a very basic task of extending the `Triple` class.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: M88k 架构已经很久没有生产了，但我们找到了足够的信息和工具，使其成为添加 LLVM 后端的一个有趣目标。我们将从扩展 `Triple` 类的非常基础的任务开始。
- en: Adding the new architecture to the Triple class
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将新的架构添加到 Triple 类
- en: 'An instance of the `Triple` class represents the target platform LLVM is producing
    code for. To support a new architecture, the first task is to extend the `Triple`
    class. In the `llvm/include/llvm/TargetParser/Triple.h` file, add a member to
    the `ArchType` enumeration along with a new predicate:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`Triple` 类的实例表示 LLVM 为其生成代码的目标平台。为了支持新的架构，第一个任务是扩展 `Triple` 类。在 `llvm/include/llvm/TargetParser/Triple.h`
    文件中，向 `ArchType` 枚举添加一个成员以及一个新的谓词：'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Inside the `llvm/lib/TargetParser/Triple.cpp` file, there are many methods
    that use the `ArchType` enumeration. You need to extend all of them; for example,
    in the `getArchTypeName()` method, you need to add a new `case` statement as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `llvm/lib/TargetParser/Triple.cpp` 文件内部，有许多使用 `ArchType` 枚举的方法。你需要扩展它们所有；例如，在
    `getArchTypeName()` 方法中，你需要添加一个新的 `case` 语句，如下所示：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Most times, the compiler will warn you if you forget to handle the new `m88k`
    enumeration member in one of the functions. Next, we will expand the **Executable
    and Linkable** **Format** (**ELF**).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，编译器会警告你如果在某个函数中忘记处理新的 `m88k` 枚举成员。接下来，我们将扩展 **可执行和链接** **格式** (**ELF**)。
- en: Extending the ELF file format definition in LLVM
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展 LLVM 中的 ELF 文件格式定义
- en: 'The ELF file format is one of the binary object file formats LLVM supports.
    ELF itself is defined for many CPU architectures, and there is also a definition
    for the M88k architecture. All we need to do is to add the definition of the relocations
    and some flags. The relocations are given in [*Chapter 4*](B19561_04.xhtml#_idTextAnchor068),
    *Basics of IR Code Generation*, of the *System V ABI M88k Processor* supplement
    book (see link within the *Setting the stage for a new backend* section at the
    beginning of the chapter):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ELF 文件格式是 LLVM 支持的几种二进制对象文件格式之一。ELF 本身是为许多 CPU 架构定义的，也有 M88k 架构的定义。我们只需要添加重定位的定义和一些标志。重定位在
    *系统 V ABI M88k 处理器* 补充书的 *IR 代码生成基础* 章节中给出（见章节开头 *为新的后端设置舞台* 部分的链接）：[*第 4 章*](B19561_04.xhtml#_idTextAnchor068)
- en: 'We need to type the following code into the `llvm/include/llvm/BinaryFormat/ELFRelocs/M88k.def`
    file:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在 `llvm/include/llvm/BinaryFormat/ELFRelocs/M88k.def` 文件中输入以下代码：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We also add the following flags into the `llvm/include/llvm/BinaryFormat/ELF.h`
    file, along with the definition of the relocations:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还在 `llvm/include/llvm/BinaryFormat/ELF.h` 文件中添加了以下标志，以及重定位的定义：
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The code can be added anywhere in the file, but it is best to keep the file
    structured and insert it before the code for the MIPS architecture.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码可以添加到文件的任何位置，但最好是保持文件结构，并在 MIPS 架构的代码之前插入它。
- en: 'We also need to expand some other methods. In the `llvm/include/llvm/Object/ELFObjectFile.h`
    file are some methods that translate between enumeration members and strings.
    For example, we must add a new `case` statement to the `getFileFormatName()` method:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要扩展一些其他方法。在 `llvm/include/llvm/Object/ELFObjectFile.h` 文件中，有一些方法在枚举成员和字符串之间进行转换。例如，我们必须向
    `getFileFormatName()` 方法添加一个新的 `case` 语句：
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Similarly, we extend the `getArch()` method:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们扩展 `getArch()` 方法：
- en: '[PRE5]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Lastly, we use the relocation definitions in the `llvm/lib/Object/ELF.cpp`
    file, in the `getELFRelocationTypeName()` method:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在 `llvm/lib/Object/ELF.cpp` 文件中的 `getELFRelocationTypeName()` 方法使用重定位定义：
- en: '[PRE6]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To complete the support, you can valso extend the `llvm/lib/ObjectYAML/ELFYAML.cpp`
    file. This file is used by the `yaml2obj` and `obj2yaml` tools, which create an
    ELF file based on a YAML description, and vice versa. The first addition needs
    to be done in the `ScalarEnumerationTraits<ELFYAML::ELF_EM>::enumeration()` method,
    which lists all the values for the ELF architectures:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成支持，你也可以扩展 `llvm/lib/ObjectYAML/ELFYAML.cpp` 文件。此文件由 `yaml2obj` 和 `obj2yaml`
    工具使用，它们根据 YAML 描述创建 ELF 文件，反之亦然。第一个添加需要在 `ScalarEnumerationTraits<ELFYAML::ELF_EM>::enumeration()`
    方法中完成，该方法列出 ELF 架构的所有值：
- en: '[PRE7]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Likewise, in the `ScalarEnumerationTraits<ELFYAML::ELF_REL>::enumeration()`
    method, you need to include the definitions of the relocations again:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，在 `ScalarEnumerationTraits<ELFYAML::ELF_REL>::enumeration()` 方法中，你需要再次包含重定位的定义：
- en: '[PRE8]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: At this point, we have completed the support of the m88k architecture in the
    ELF file format. You can use the `llvm-readobj` tool to inspect an ELF object
    file, for example, created by a cross-compiler on OpenBSD. Likewise, you can create
    an ELF object file for the m88k architecture with the `yaml2obj` tool.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经完成了对 ELF 文件格式中 m88k 架构的支持。您可以使用 `llvm-readobj` 工具来检查 ELF 对象文件，例如，由
    OpenBSD 上的交叉编译器创建的文件。同样，您可以使用 `yaml2obj` 工具为 m88k 架构创建 ELF 对象文件。
- en: Is adding support for an object file format mandatory?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 添加对对象文件格式的支持是强制性的吗？
- en: Integrating support for an architecture into the ELF file format implementation
    requires only a couple of lines of code. If the architecture for which you are
    creating an LLVM backend uses the ELF format, then you should take this route.
    On the other hand, adding support for a completely new binary file format is a
    complicated task. If this is required, then an often-used approach is to only
    output assembler files and use an external assembler to create object files.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将对架构的支持集成到 ELF 文件格式实现中只需要几行代码。如果您正在创建的 LLVM 后端使用的架构是 ELF 格式，那么您应该选择这条路径。另一方面，添加对完全新的二进制文件格式的支持是一个复杂的过程。如果这是必需的，那么常用的方法是将汇编文件输出，并使用外部汇编器创建对象文件。
- en: With these additions, the LLVM implementation of the ELF file format now supports
    the M88k architecture. In the next section, we create the target description for
    the M88k architecture, which describes the instructions, the registers, and many
    more details of the architecture.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些添加，LLVM 对 ELF 文件格式的实现现在支持了 M88k 架构。在下一节中，我们将为 M88k 架构创建目标描述，它描述了指令、寄存器以及许多关于架构的细节。
- en: Creating the target description
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建目标描述
- en: The `llvm/include/llvm/Target/Target.td` file, which can be found online at
    [https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/Target/Target.td](https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/Target/Target.td).
    This file is heavily commented on and is a useful source of information about
    the use of the definitions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`llvm/include/llvm/Target/Target.td` 文件，可以在 [https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/Target/Target.td](https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/Target/Target.td)
    上找到。这个文件注释很多，是关于定义使用的有用信息来源。'
- en: In an ideal world, we would generate the whole backend from the target description.
    This goal has not yet been reached, and therefore, we will need to extend the
    generated code later. Because of its size, the target description is split into
    several files. The top-level file will be `M88k.td`, inside the `llvm/lib/Target/M88k`
    directory, which also includes the other files. Let’s have a look at some files,
    beginning with the register definition.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的世界里，我们会从目标描述中生成整个后端。这个目标尚未实现，因此，我们以后还需要扩展生成的代码。由于文件大小，目标描述被拆分成了几个文件。顶层文件将是
    `M88k.td`，位于 `llvm/lib/Target/M88k` 目录中，该目录还包括其他文件。让我们看看一些文件，从寄存器定义开始。
- en: Adding the register definition
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加寄存器定义
- en: A CPU architecture usually defines a set of registers. The characteristics of
    these registers can vary. Some architectures allow access to sub-registers. For
    example, the x86 architecture has special register names to access only a part
    of a register value. Other architectures do not implement this. In addition to
    general-purpose, floating-point, and vector registers, an architecture may have
    special registers for status codes or configuration of floating-point operations.
    We need to define all this information for LLVM. The register definitions are
    stored in the `M88kRegisterInfo.td` file, also found within the `llvm/lib/Target/M88k`
    directory.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 架构通常定义一组寄存器。这些寄存器的特性可能不同。一些架构允许访问子寄存器。例如，x86 架构有特殊的寄存器名称来访问寄存器值的一部分。其他架构不实现这一点。除了通用、浮点数和向量寄存器外，架构还可能有用于状态代码或浮点操作配置的特殊寄存器。我们需要为
    LLVM 定义所有这些信息。寄存器定义存储在 `M88kRegisterInfo.td` 文件中，也可以在 `llvm/lib/Target/M88k` 目录中找到。
- en: 'The M88k architecture defines general-purpose registers, extended registers
    for floating-point operations, and control registers. To keep the example small,
    we only define the general-purpose registers. We begin by defining a super-class
    for the registers. A register has a name and an encoding. The name is used in
    the textual representation of an instruction. Similarly, the encoding is used
    as part of the binary representation of an instruction. The architecture defines
    32 registers and the encoding for registers therefore uses 5 bits, so we limit
    the field holding the encoding. We also define that all the generated C++ code
    should live in the `M88k` namespace:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: M88k架构定义了通用寄存器、用于浮点操作的扩展寄存器和控制寄存器。为了使示例保持简洁，我们只定义通用寄存器。我们首先定义寄存器的超类。寄存器有一个名称和一个编码。名称用于指令的文本表示。同样，编码用作指令二进制表示的一部分。该架构定义了32个寄存器，因此寄存器的编码使用5位，所以我们限制了包含编码的字段。我们还定义了所有生成的C++代码都应该位于`M88k`命名空间中：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we can define all 32 general-purpose registers. The `r0` register is
    special because it always returns the constant `0` when read, so we set the `isConstant`
    flag to `true` for that register:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以定义所有32个通用寄存器。`r0`寄存器是特殊的，因为它在读取时总是返回常数`0`，因此我们将该寄存器的`isConstant`标志设置为`true`：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For the register allocator, the single registers need to be grouped into register
    classes. The sequence order of the registers defines the allocation order. The
    register allocator also needs other information about the registers such as, for
    example, the value types, which can be stored in a register, the spill size of
    a register in bits, and the required alignment in memory. Instead of using the
    `RegisterClass` base class directly, we create a new `M88kRegisterClass` class.
    This allows us to change the parameter list to our needs. It also avoids the repetition
    of the C++ namespace name used for the generated code, which is the first argument
    for the `RegisterClass` class:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于寄存器分配器，单个寄存器需要被分组到寄存器类中。寄存器的顺序定义了分配顺序。寄存器分配器还需要其他关于寄存器的信息，例如，例如，可以存储在寄存器中的值类型、寄存器的位溢出大小以及内存中所需的对齐方式。我们不是直接使用`RegisterClass`基类，而是创建了一个新的`M88kRegisterClass`类。这允许我们根据需要更改参数列表。它还避免了重复使用生成代码中使用的C++命名空间名称，这是`RegisterClass`类的第一个参数：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In addition, we define a class for register operands. Operands describe the
    input and output of an instruction. They are used during assembling and disassembling
    of an instruction, and also in the patterns used by the instruction selection
    phase. Using our own class, we can give the generated function used to decode
    a register operand a name that conforms to the LLVM coding guidelines:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们定义了一个用于寄存器操作数的类。操作数描述了指令的输入和输出。它们在指令的汇编和反汇编过程中以及指令选择阶段使用的模式中都被使用。使用我们自己的类，我们可以给用于解码寄存器操作数的生成函数一个符合LLVM编码指南的名称：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Based on these definitions, we now define the general-purpose registers. Please
    note that a general-purpose register of the m88k architecture is 32-bits wide
    and can hold integer and floating-point values. To avoid writing all register
    names, we use the `sequence` generator, which generates a list of strings based
    on the template string:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些定义，我们现在定义通用寄存器。请注意，m88k架构的通用寄存器是32位宽的，可以存储整数和浮点值。为了避免编写所有寄存器名称，我们使用`sequence`生成器，它根据模板字符串生成字符串列表：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Likewise, we define the register operand. The `r0` register is special because
    it contains the constant `0`. This fact can be used by the global instruction
    selection framework, and therefore, we attach this information to the register
    operand:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们定义了寄存器操作数。`r0`寄存器是特殊的，因为它包含常数`0`。这个事实可以被全局指令选择框架使用，因此我们将此信息附加到寄存器操作数上：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There is an extension to the m88k architecture that defines an extended register
    file for floating-point values only. You would define those registers in the same
    way as the general-purpose registers.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: m88k架构有一个扩展，它定义了一个仅用于浮点值的扩展寄存器文件。您将按照与通用寄存器相同的方式定义这些寄存器。
- en: 'The general-purpose registers are also used in pairs, mainly for 64-bit floating
    point operations, and we need to model them. We use the `sub_hi` and `sub_lo`
    sub-register indices to describe the high 32 bits and the low 32 bits. We also
    need to set the C++ namespace for the generated code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通用寄存器也成对使用，主要用于64位浮点运算，我们需要对它们进行建模。我们使用`sub_hi`和`sub_lo`子寄存器索引来描述高32位和低32位。我们还需要设置生成的代码的C++命名空间：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The register pairs are then defined using the `RegisterTuples` class. The class
    takes a list of sub-register indices as the first argument and a list of registers
    as the second argument. We only need even/odd numbered pairs, and we achieve this
    with the optional fourth parameter of sequence, which is the stride to use when
    generating the sequence:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用`RegisterTuples`类定义寄存器对。该类将子寄存器索引列表作为第一个参数，将寄存器列表作为第二个参数。我们只需要偶数/奇数对，我们通过序列的可选第四个参数（生成序列时使用的步长）来实现这一点：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To use the register pairs, we define a register class and a register operand:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用寄存器对，我们定义了一个寄存器类和一个寄存器操作数：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Please note that we set the `copycost` parameter to `2` because we need two
    instructions instead of one to copy a register pair to another register pair.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将`copycost`参数设置为`2`，因为我们需要两个指令而不是一个来复制寄存器对到另一个寄存器对。
- en: This finishes our definition of the registers. In the next section, we will
    define the instruction formats.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对寄存器的定义。在下一节中，我们将定义指令格式。
- en: Defining the instruction formats and the instruction information
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义指令格式和指令信息
- en: An instruction is defined using the TableGen `Instruction` class. Defining an
    instruction is a complex task because we have to consider many details. An instruction
    has a textual representation used by the assembler and the disassembler. It has
    a name, for example, `and`, and it may have operands. The assembler transforms
    the textual representation into a binary format, therefore, we must define the
    layout of that format. For instruction selection, we need to attach a pattern
    to the instruction. To manage this complexity, we define a class hierarchy. The
    base classes will describe the various instruction formats and are stored in the
    `M88kIntrFormats.td` file. The instructions themselves and other definitions required
    for the instruction selection are stored in the `M88kInstrInfo.td` file.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 指令使用TableGen的`Instruction`类定义。定义一个指令是一个复杂任务，因为我们必须考虑许多细节。指令有一个文本表示，用于汇编器和反汇编器。它有一个名称，例如`and`，并且它可能有操作数。汇编器将文本表示转换为二进制格式，因此我们必须定义该格式的布局。为了指令选择，我们需要将一个模式附加到指令上。为了管理这种复杂性，我们定义了一个类层次结构。基类将描述各种指令格式，并存储在`M88kIntrFormats.td`文件中。指令本身和其他用于指令选择的定义存储在`M88kInstrInfo.td`文件中。
- en: Let’s begin with defining a class for the instructions of the m88k architecture
    called `M88kInst`. We derive this class from the predefined `Instruction` class.
    Our new class has a couple of parameters. The `outs` and `ins` parameters describe
    the output and input operands as a list, using the special `dag` type. The textual
    representation of the instruction is split into the mnemonic given in the `asm`
    parameter, and the operands. Last, the `pattern` parameter can hold a pattern
    used for instruction selection.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义一个名为`M88kInst`的m88k架构指令类开始。我们从这个预定义的`Instruction`类中派生这个类。我们的新类有几个参数。`outs`和`ins`参数描述了输出和输入操作数，作为一个使用特殊`dag`类型的列表。指令的文本表示被分为`asm`参数中给出的助记符和操作数。最后，`pattern`参数可以存储用于指令选择的模式。
- en: 'We also need to define two new fields:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要定义两个新字段：
- en: The `Inst` field is used to hold the bit pattern of the instruction. Because
    the size of an instruction depends on the platform, this field cannot be predefined.
    All instructions of the m88k architecture are 32-bit wide, and so this field has
    the `bits<32>` type.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Inst`字段用于存储指令的位模式。由于指令的大小取决于平台，因此该字段不能预先定义。m88k架构的所有指令都是32位宽，因此该字段具有`bits<32>`类型。'
- en: The other field is called `SoftFail` and has the same type as `Inst`. It holds
    a bit mask used with an instruction for which the actual encoding can differ from
    the bits in the `Inst` field and still be valid. The only platform that requires
    this is ARM, so we can simply set this field to `0`.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个字段称为`SoftFail`，其类型与`Inst`相同。它包含一个位掩码，用于与指令一起使用，其实际编码可以与`Inst`字段中的位不同，但仍有效。唯一需要这个的平台是ARM，因此我们可以简单地将此字段设置为`0`。
- en: 'The other fields are defined in the superclass, and we only set the value.
    Simple computations are possible in the TableGen language, and we use this when
    we create the value for the `AsmString` field, which holds the full assembler
    representation. If the `operands` operand string is empty, then the `AsmString`
    field will just have the value of the `asm` parameter, otherwise, it will be the
    concatenation of both strings, with a space between them:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 其他字段在超类中定义，我们只需设置值。TableGen 语言中可以进行简单的计算，我们使用它来创建 `AsmString` 字段的值，该字段持有完整的汇编表示。如果
    `operands` 操作数字符串为空，则 `AsmString` 字段将只包含 `asm` 参数的值；否则，它将是两个字符串的连接，它们之间有一个空格：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For the instruction encoding, the manufacturer usually groups instructions
    together, and the instructions of one group have a similar encoding. We can use
    those groups to systematically create classes defining the instruction formats.
    For example, all logical operations of the m88k architecture encode the destination
    register in the bits from 21 to 25 and the first source register in the bits from
    16 to 20\. Please note the implementation pattern here: we declare the `rd` and
    `rs1` fields for the values, and we assign those values to the correct bit positions
    of the `Inst` field, which we defined previously in the superclass:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于指令编码，制造商通常将指令分组，同一组中的指令具有相似的编码。我们可以使用这些组来系统地创建定义指令格式的类。例如，m88k 架构的所有逻辑操作将目标寄存器编码在位
    21 到 25，第一个源寄存器编码在位 16 到 20。请注意这里的实现模式：我们声明 `rd` 和 `rs1` 字段用于值，并将这些值分配给 `Inst`
    字段中正确的位位置，这是我们之前在超类中定义的：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There are several groups of logical operations based on this format. One of
    them is the group of instructions using three registers, which is called **triadic
    addressing mode** in the manual:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这种格式的逻辑操作有几组。其中之一是使用三个寄存器的指令组，在手册中称为 **三地址模式**：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Let’s examine the functionality provided by this class in more detail. The `func`
    parameter specifies the operation. As a special feature, the second operand can
    be complemented before the operation, which is indicated by setting the `1`. The
    mnemonic is given in the `asm` parameter, and an instruction selection pattern
    can be passed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地检查这个类提供的功能。`func` 参数指定操作。作为一个特殊功能，第二个操作数可以在操作之前取补码，这通过设置 `1` 来指示。助记符在
    `asm` 参数中给出，并且可以传递一个指令选择模式。
- en: With initializing the superclass, we can give more information. The full assembler
    text template for the `and` instruction is `and $rd, $rs1, $rs2`. The operand
    string is fixed for all instructions of this group, so we can define it here.
    The mnemonic is given by the user of this class, but we can concatenate the `.c`
    suffix here, which denotes that the second operand should be complemented first.
    And last, we can define the output and input operands. These operands are expressed
    as `(``outs GPROpnd:$rd)`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过初始化超类，我们可以提供更多信息。`and` 指令的完整汇编文本模板是 `and $rd, $rs1, $rs2`。这个操作数字符串对于这个组的所有指令都是固定的，因此我们可以在这里定义它。助记符由这个类的用户给出，但我们可以在这里附加
    `.c` 后缀，表示第二个操作数应该首先取补码。最后，我们可以定义输出和输入操作数。这些操作数表示为 `(``outs GPROpnd:$rd)`。
- en: The `outs` operation denotes this dag as the output operand list. The only argument,
    `GPROpnd:$rd`, consists of a type and a name. It connects several pieces we have
    already seen. The type is `GPROnd`, which is the name of the register operand
    we have defined in the previous section. The name `$rd` refers to the destination
    register. We used this name in the operand string earlier, and also as a field
    name in the `F_L` superclass. The input operands are defined similarly. The rest
    of the class initializes the other bits of the `Inst` field. Please take the time
    and check that all 32 bits are indeed now assigned.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`outs` 操作符表示这个有向图（dag）为输出操作数列表。唯一的参数 `GPROpnd:$rd` 包含一个类型和一个名称。它连接了我们之前已经看到的一些部分。类型是
    `GPROnd`，这是我们在上一节中定义的寄存器操作数的名称。名称 `$rd` 指的是目标寄存器。我们之前在操作数字符串中使用过这个名称，也在 `F_L`
    超类中作为字段名称。输入操作数以类似的方式定义。类的其余部分初始化 `Inst` 字段的其余位。请花点时间检查一下，现在是否确实已经分配了所有 32 位。'
- en: 'We put the final instruction definition in the `M88kInstrInfo.td` file. Since
    we have two variants of each logical instruction, we use a multiclass to define
    both instructions at once. We also define here the pattern for the instruction
    selection as a directed acyclic graph. The operation in the pattern is `set`,
    and the first argument is the destination register. The second argument is a nested
    graph, which is the actual pattern. Once again, the name of the operation is the
    first `OpNode` element. LLVM has many predefined operations, which you find in
    the `llvm/include/llvm/Target/TargetSelectionDAG.td` file ([https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/Target/TargetSelectionDAG.td](https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/Target/TargetSelectionDAG.td)).
    For example, there is the `and` operation, which denotes a bitwise AND operation.
    The arguments are the two source registers, `$rs1` and `$rs2`.You read this pattern
    roughly as follows: if the input to the instruction selection contains an OpNode
    operation using two registers, then assign the result of this operation to the
    `$rd` register and generate this instruction. Utilizing the graph structure, you
    can define more complex patterns. For example, the second pattern integrates the
    complement into the pattern using the `not` operand.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将最终的指令定义放在`M88kInstrInfo.td`文件中。由于我们为每个逻辑指令有两个变体，我们使用多类同时定义这两个指令。我们还在这里定义了指令选择的模式，作为一个有向无环图。模式中的操作是`set`，第一个参数是目标寄存器。第二个参数是一个嵌套图，这是实际的模式。再次强调，操作名称是第一个`OpNode`元素。LLVM有许多预定义的操作，你可以在`llvm/include/llvm/Target/TargetSelectionDAG.td`文件中找到它们（[https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/Target/TargetSelectionDAG.td](https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/Target/TargetSelectionDAG.td)）。例如，有`and`操作，表示位与操作。参数是两个源寄存器，`$rs1`和`$rs2`。你可以大致这样阅读这个模式：如果指令选择的输入包含使用两个寄存器的OpNode操作，则将这个操作的结果分配给`$rd`寄存器并生成这个指令。利用图结构，你可以定义更复杂的模式。例如，第二个模式使用`not`操作数将补码集成到模式中。
- en: 'A small detail to point out is that the logical operations are commutative.
    This can be helpful for the instruction selection, so we set the `isCommutable`
    flag to `1` for those instructions:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 需要指出的小细节是逻辑运算具有交换律。这有助于指令选择，因此我们将这些指令的`isCommutable`标志设置为`1`：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And finally, we define the records for the instructions:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了指令的记录：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first parameter is the bit pattern for the function, the second is the mnemonic,
    and the third parameter is the dag operation used in the pattern.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是功能的位模式，第二个参数是助记符，第三个参数是模式中使用的dag操作。
- en: To fully understand the class hierarchy, revisit the class definitions. The
    guiding design principle is to avoid the repetition of information. For example,
    the `0b01000` function bit pattern is used exactly once. Without the `Logic` multiclass
    you would need to type this bit pattern twice and repeat the patterns several
    times, which is error-prone.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全理解类层次结构，请重新查看类定义。指导设计原则是避免信息重复。例如，`0b01000`功能位模式只使用了一次。如果没有`Logic`多类，你需要输入这个位模式两次，并多次重复模式，这容易出错。
- en: Please also note that it is good to establish a naming scheme for the instructions.
    For example, the record for the `and` instruction is named `ANDrr`, while the
    variant with the complemented register is named `ANDrrc`. Those names end up in
    the generated C++ source code, and using a naming scheme helps to understand to
    which assembler instruction the name refers.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为指令建立命名方案是很好的做法。例如，`and`指令的记录命名为`ANDrr`，而带有补码寄存器的变体命名为`ANDrrc`。这些名称最终会出现在生成的C++源代码中，使用命名方案有助于理解名称指的是哪个汇编指令。
- en: Up to now, we modeled the register file of the m88k architecture and defined
    a couple of instructions. In the next section, we will create the top-level file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经对m88k架构的寄存器文件进行了建模，并定义了一些指令。在下一节中，我们将创建顶层文件。
- en: Creating the top-level file for the target description
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为目标描述创建顶层文件
- en: 'So far, we created the `M88kRegisterInfo.td`, `M88kInstrFormats.td`, and `M88kInstrInfo.td`
    files. The target description is a single file, called `M88k.td`. This file includes
    the LLVM definitions first, and the files that we have implemented follow afterwards.:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了`M88kRegisterInfo.td`、`M88kInstrFormats.td`和`M88kInstrInfo.td`文件。目标描述是一个单独的文件，称为`M88k.td`。该文件首先包含LLVM定义，然后是我们已实现的文件：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We will extend this `include` section later when we add more backend functionality.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在添加更多后端功能时扩展这个 `include` 部分。
- en: 'The top-level file also defines some global instances. The first record named
    `M88kInstrInfo` holds the information about all instructions:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 顶层文件还定义了一些全局实例。第一个名为 `M88kInstrInfo` 的记录包含了所有指令的信息：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We call the assembler class `M88kAsmParser`. To enable TableGen to identify
    hardcoded registers, we specify that register names are prefixed with a percent
    sign, and we need to define an assembler parser variant to specify this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将汇编器类命名为 `M88kAsmParser`。为了使 TableGen 能够识别硬编码的寄存器，我们指定寄存器名称以百分号开头，并且需要定义一个汇编器解析器变体来指定这一点：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And last, we need to define the target:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要定义目标：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We now have defined enough of the target so that we can code the first utility.
    In the next section, we add the M88k backend to LLVM.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了足够的目标信息，可以编写第一个实用工具。在下一节中，我们将添加 M88k 后端到 LLVM。
- en: Adding the M88k backend to LLVM
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 M88k 后端添加到 LLVM
- en: We have not yet discussed where to place the target description files. Each
    backend in LLVM has a subdirectory in `llvm/lib/Target`. We create the `M88k`
    directory here and copy the target description files into it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未讨论目标描述文件放置的位置。LLVM 中的每个后端都在 `llvm/lib/Target` 下的一个子目录中。我们在这里创建 `M88k` 目录，并将目标描述文件复制到其中。
- en: Of course, just adding the TableGen files is not enough. LLVM uses a registry
    to look up instances of a target implementation, and it expects certain global
    functions to register those instances. And since some parts are generated, we
    can already provide an implementation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仅仅添加 TableGen 文件是不够的。LLVM 使用一个注册表来查找目标实现的实例，并期望某些全局函数注册这些实例。由于某些部分是生成的，我们已提供实现。
- en: 'All information about a target, like the target triple and factory function
    for the target machine, assembler, disassembler, and so on, are stored in an instance
    of the `Target` class. Each target holds a static instance of this class, and
    this instance is registered in the central registry:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 关于每个目标的所有信息，如目标三元组、目标机器的工厂函数、汇编器、反汇编器等，都存储在 `Target` 类的一个实例中。每个目标都持有该类的静态实例，并且该实例在中央注册表中注册：
- en: 'The implementation is in the `M88kTargetInfo.cpp` file in the `TargetInfo`
    subdirectory in our target. The single instance of the `Target` class is held
    inside the `getTheM88kTarget()` function:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现在我们目标中的 `TargetInfo` 子目录下的 `M88kTargetInfo.cpp` 文件中。`Target` 类的单个实例被保留在 `getTheM88kTarget()`
    函数中：
- en: '[PRE27]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'LLVM requires that each target provides a `LLVMInitialize<Target Name>TargetInfo()`
    function to register the target instance. That function must have a C linkage
    because it is also used in the LLVM C API:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LLVM 要求每个目标提供一个 `LLVMInitialize<Target Name>TargetInfo()` 函数来注册目标实例。该函数必须具有
    C 链接，因为它也用于 LLVM C API：
- en: '[PRE28]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We also need to create an `M88kTargetInfo.h` header file in the same directory,
    which just contains a single declaration:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要在同一个目录中创建一个 `M88kTargetInfo.h` 头文件，它只包含一个声明：
- en: '[PRE29]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And last, we add a `CMakeLists.txt` file for building:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加一个 `CMakeLists.txt` 文件用于构建：
- en: '[PRE30]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we partially populate the target instance with the information used at
    the **machine-code** (**MC**) level. Let’s get started:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在目标实例中部分填充了在**机器代码**（**MC**）级别使用的相关信息。让我们开始吧：
- en: 'The implementation is in the `M88kMCTargetDesc.cpp` file in the `MCTargetDesc`
    subdirectory. TableGen turns the target description we created in the previous
    section into C++ source code fragments. Here, we include the parts for the register
    information, the instruction information, and the sub-target information:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现在我们目标中的 `MCTargetDesc` 子目录下的 `M88kMCTargetDesc.cpp` 文件中。TableGen 将我们在上一节中创建的目标描述转换为
    C++ 源代码片段。在这里，我们包含了寄存器信息、指令信息和子目标信息的部分：
- en: '[PRE31]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The target registry expects a factory method for each of the classes here.
    Let’s begin with the instruction information. We allocate an instance of the `MCInstrInfo`
    class, and call the `InitM88kMCInstrInfo()` generated function to populate the
    object:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标注册表期望为这里的每个类提供一个工厂方法。让我们从指令信息开始。我们分配一个 `MCInstrInfo` 类的实例，并调用生成的 `InitM88kMCInstrInfo()`
    函数来填充对象：
- en: '[PRE32]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, we allocate an object of the `MCRegisterInfo` class and call a generated
    function to populate it. The additional `M88k::R1` parameter value tells LLVM
    that the `r1` register holds the return address:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们分配一个 `MCRegisterInfo` 类的对象，并调用一个生成的函数来填充它。额外的 `M88k::R1` 参数值告诉 LLVM，`r1`
    寄存器持有返回地址：
- en: '[PRE33]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And last, we need a factory method for the sub-target information. This method
    takes a target triple, a CPU name, and a feature string as parameters, and forwards
    them to the generated method:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要一个子目标信息的工厂方法。该方法接受一个目标三元组、一个 CPU 名称和一个特性字符串作为参数，并将它们转发到生成的函数：
- en: '[PRE34]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Having the factory methods defined, we can now register them. Similar to the
    target registration, LLVM expects a global function called `LLVMInitialize<Target
    Name>TargetMC()`:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义了工厂方法之后，我们现在可以注册它们。类似于目标注册，LLVM 预期一个全局函数名为 `LLVMInitialize<Target Name>TargetMC()`：
- en: '[PRE35]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `M88kMCTargetDesc.h` header file just makes some generated code available:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`M88kMCTargetDesc.h` 头文件只是使一些生成的代码可用：'
- en: '[PRE36]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The implementation is almost done. To prevent a linker error, we need to provide
    another function, which registers a factory method for an object of the `TargetMachine`
    class. This class is required for code generation, and we implement it in [*Chapter
    12*](B19561_12.xhtml#_idTextAnchor193)*, Instruction Selection*, up next. Here,
    we just define an empty function in the `M88kTargetMachine.cpp` file:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 实现几乎完成。为了防止链接器错误，我们需要提供另一个函数，该函数注册一个 `TargetMachine` 类对象的工厂方法。这个类对于代码生成是必需的，我们在
    [*第 12 章*](B19561_12.xhtml#_idTextAnchor193) *指令选择* 中实现它，接下来。在这里，我们只是在 `M88kTargetMachine.cpp`
    文件中定义了一个空函数：
- en: '[PRE37]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This concludes our first implementation. However, LLVM does not yet know about
    our new backend. To integrate it, open the `llvm/CMakeLists.txt` file, locate
    the section defining all the experimental targets, and add the M88k target to
    the list:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们第一次实现的结束。然而，LLVM 还不知道我们的新后端。要集成它，打开 `llvm/CMakeLists.txt` 文件，找到定义所有实验性目标的章节，并将
    M88k 目标添加到列表中：
- en: '[PRE38]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Assuming the LLVM source code with our new backend is in the directory, you
    can configure the build by typing the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的新后端源代码在目录中，你可以通过输入以下内容来配置构建：
- en: '[PRE39]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'After building LLVM, you can verify that the tools already know about our new
    target:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建 LLVM 之后，你可以验证工具已经知道我们的新目标：
- en: '[PRE40]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The journey to get to this point was difficult, so take a moment to celebrate!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 到达这个阶段的过程很艰难，所以花点时间庆祝一下吧！
- en: Fixing a possible compile error
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 修复可能的编译错误
- en: 'There is a small oversight in LLVM 17.0.2, which causes a compile error. In
    one place in the code, the TableGen emitter for the sub-target information uses
    the removed value `llvm::None` instead of `std:: nullopt`, causing an error while
    compiling `M88kMCTargetDesc.cpp`. The easiest way to fix this problem is to cherry-pick
    the fix from the LLVM 18 development branch: `git cherry-pick -``x a587f429`.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 LLVM 17.0.2 中存在一个小疏忽，导致编译错误。在代码的一个地方，子目标信息的 TableGen 发射器使用了已删除的值 `llvm::None`
    而不是 `std::nullopt`，导致在编译 `M88kMCTargetDesc.cpp` 时出错。修复此问题的最简单方法是 cherry-pick 从
    LLVM 18 开发分支的修复：`git cherry-pick -x a587f429`。
- en: In the next section, we implement the assembler parser, which will give us the
    first working LLVM tool.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们实现汇编器解析器，这将给我们第一个工作的 LLVM 工具。
- en: Implementing the assembler parser
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现汇编器解析器
- en: The assembler parser is easy to implement, since LLVM provides a framework for
    it, and large parts are generated from the target description.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编器解析器很容易实现，因为 LLVM 为此提供了一个框架，大部分代码都是从目标描述中生成的。
- en: 'The `ParseInstruction()` method in our class is called when the framework detects
    that an instruction needs to be parsed. That method parses in input via the provided
    lexer and constructs a so-called operand vector. An operand can be a token such
    as an instruction mnemonic, a register name, or an immediate, or it can be category-specific
    to the target. For example, two operands are constructed from the `jmp %r2` input:
    a token operand for the mnemonic, and a register operand.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们类中的 `ParseInstruction()` 方法在框架检测到需要解析指令时被调用。该方法通过提供的词法分析器解析输入，并构建一个所谓的操作数向量。操作数可以是一个指令助记符、寄存器名称或立即数，或者它可以是针对目标特定的类别。例如，从
    `jmp %r2` 输入中构建了两个操作数：一个用于助记符的标记操作数和一个寄存器操作数。
- en: Then a generated matcher tries to match the operand vector against the instructions.
    If a match is found, then an instance of the `MCInst` class is created, which
    holds the parsed instruction. Otherwise, an error message is emitted. The advantage
    of this approach is that it automatically derives the matcher from the target
    description, without needing to handle all syntactical quirks.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一个生成的匹配器尝试将操作数向量与指令进行匹配。如果找到匹配项，则创建 `MCInst` 类的一个实例，该实例包含解析后的指令。否则，会发出错误消息。这种方法的优势是它自动从目标描述中推导出匹配器，而无需处理所有语法上的怪癖。
- en: However, we need to add a couple more support classes to make the assembler
    parser work. These additional classes are all stored in the `MCTargetDesc` directory.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们需要添加几个额外的支持类来使汇编解析器工作。这些额外的类都存储在`MCTargetDesc`目录中。
- en: Implementing the MCAsmInfo support class for the M88k Target
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现M88k目标的MCAsmInfo支持类
- en: 'Within this section, we explore implementing the first required class for the
    configuration of the assembler parser: the `MCAsmInfo` class:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨实现汇编解析器配置的第一个必需类：`MCAsmInfo`类：
- en: 'We need to set some customization parameters for the assembler parser. The
    `MCAsmInfo` base class ([https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/MC/MCAsmInfo.h](https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/MC/MCAsmInfo.h))
    contains the common parameters. In addition, a subclass is created for each supported
    object file format; for example, the `MCAsmInfoELF` class ([https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/MC/MCAsmInfoELF.h](https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/MC/MCAsmInfoELF.h)).
    The reasoning behind it is that the system assemblers on systems using the same
    object file format share common characteristics because they must support similar
    features. Our target operating system is OpenBSD, and it uses the ELF file format,
    so we derive our own `M88kMCAsmInfo` class from the `MCAsmInfoELF` class. The
    declaration in the `M88kMCAsmInfo.h` file is as follows:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为汇编解析器设置一些定制参数。`MCAsmInfo`基类([https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/MC/MCAsmInfo.h](https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/MC/MCAsmInfo.h))包含了通用参数。此外，为每个支持的文件格式创建了一个子类；例如，`MCAsmInfoELF`类([https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/MC/MCAsmInfoELF.h](https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/MC/MCAsmInfoELF.h))。这样做的原因是，使用相同文件格式的系统汇编器具有共同的特征，因为它们必须支持类似的功能。我们的目标操作系统是OpenBSD，它使用ELF文件格式，因此我们从`MCAsmInfoELF`类派生出自定义的`M88kMCAsmInfo`类。`M88kMCAsmInfo.h`文件中的声明如下：
- en: '[PRE41]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The implementation in the `M88kMCAsmInfo.cpp` file only sets a couple of default
    values. Two crucial settings at present are the system using big-endian mode and
    employing the `|` symbol for comments. The other settings are for code generation
    later:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`M88kMCAsmInfo.cpp`文件中的实现仅设置了一些默认值。目前有两个关键设置：使用大端模式以及使用`|`符号作为注释。其他设置用于后续的代码生成：'
- en: '[PRE42]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now we have completed the implementation for the `MCAsmInfo` class. The next
    class we will learn to implement helps us create a binary representation of the
    instructions within LLVM.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了`MCAsmInfo`类的实现。接下来我们将学习实现下一个类，这个类帮助我们创建LLVM中指令的二进制表示。
- en: Implementing the MCCodeEmitter support class for the M88k Target
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现M88k目标的MCCodeEmitter支持类
- en: Internally in LLVM, an instruction is represented by an instance of the `MCInst`
    class. An instruction can be emitted as an assembler text or in binary into an
    object file. The `M88kMCCodeEmitter` class creates the binary representation of
    an instruction, while the `M88kInstPrinter` class emits the textual representation
    of it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在LLVM内部，指令通过`MCInst`类的实例来表示。指令可以被输出为汇编文本或二进制形式到目标文件中。`M88kMCCodeEmitter`类创建指令的二进制表示，而`M88kInstPrinter`类则输出其文本表示。
- en: 'First, we will implement the `M88kMCCodeEmitter` class, which is stored in
    the `M88kMCCodeEmitter.cpp` file:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将实现`M88kMCCodeEmitter`类，该类存储在`M88kMCCodeEmitter.cpp`文件中：
- en: 'Most of the class is generated by TableGen. Therefore, we only need to add
    some boilerplate code. Note that there is no corresponding header file; the prototype
    of the factory function will be added to the `M88kMCTargetDesc.h` file. It begins
    with setting up a statistic counter for the number of emitted instructions:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数类都是由TableGen生成的。因此，我们只需要添加一些样板代码。请注意，没有相应的头文件；工厂函数的原型将被添加到`M88kMCTargetDesc.h`文件中。它从设置输出指令数量的统计计数器开始：
- en: '[PRE43]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `M88kMCCodeEmitter` class lives in an anonymous namespace. We only need
    to implement the `encodeInstruction()` method, which is declared in the base class,
    and the `getMachineOpValue()` helper method. The other `getBinaryCodeForInstr()`
    method is generated by TableGen from the target description:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`M88kMCCodeEmitter`类位于匿名命名空间中。我们只需要实现基类中声明的`encodeInstruction()`方法以及`getMachineOpValue()`辅助方法。其他`getBinaryCodeForInstr()`方法由TableGen从目标描述中生成：'
- en: '[PRE44]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `encodeInstruction()` method just looks up the binary representation of
    the instruction, increments the statistic counter, and writes the bytes out in
    big-endian format. Remember that the instructions have a fixed size of 4 bytes,
    therefore we use the `uint32_t` type on the endian stream:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`encodeInstruction()` 方法仅查找指令的二进制表示，增加统计计数器，并以大端格式写入字节。记住，指令具有固定的 4 字节大小，因此我们在端序流上使用
    `uint32_t` 类型：'
- en: '[PRE45]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The task of the `getMachineOpValue()` method is to return the binary representation
    of operands. In the target description, we defined the bit ranges where the registers
    used are stored in an instruction. Here, we compute the value, which is stored
    in these places. The method is called from the generated code. We only support
    two cases. For a register, the encoding of the register, which we defined in the
    target description, is returned. For an immediate, the immediate value is returned:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getMachineOpValue()` 方法的任务是返回操作数的二进制表示。在目标描述中，我们定义了寄存器在指令中存储的位范围。在这里，我们计算存储在这些位置的值。该方法由生成的代码调用。我们只支持两种情况。对于寄存器，返回我们在目标描述中定义的寄存器编码。对于立即数，返回立即数值：'
- en: '[PRE46]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'And last, we include the generated file and create a factory method for the
    class:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们包含生成的文件并为该类创建一个工厂方法：
- en: '[PRE47]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Implementing the instruction printer support class for the M88k Target
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为 M88k 目标实现指令打印支持类
- en: 'The `M88kInstPrinter` class has a similar structure to the `M88kMCCodeEmitter`
    class. As mentioned previously, the `InstPrinter` class is responsible for emitting
    the textual representation of LLVM instructions. Most of the class is generated
    by TableGen, but we have to add support for printing the operands. The class is
    declared in the `M88kInstPrinter.h` header file. The implementation is in the
    `M88kInstPrinter.cpp` file:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`M88kInstPrinter` 类的结构与 `M88kMCCodeEmitter` 类类似。如前所述，`InstPrinter` 类负责输出 LLVM
    指令的文本表示。类的大部分是由 TableGen 生成的，但我们必须添加打印操作数的支持。类在 `M88kInstPrinter.h` 头文件中声明。实现位于
    `M88kInstPrinter.cpp` 文件中：'
- en: 'Let’s begin with the header file. After including the required header files
    and declaring the `llvm` namespace, two forward references are declared to reduce
    the number of required includes:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从头文件开始。在包含所需的头文件并声明 `llvm` 命名空间之后，声明了两个前向引用以减少所需的包含数量：
- en: '[PRE48]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Besides the constructor, we only need to implement the `printOperand()` and
    `printInst()` methods. The other methods are generated by TableGen:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了构造函数之外，我们只需要实现 `printOperand()` 和 `printInst()` 方法。其他方法由 TableGen 生成：
- en: '[PRE49]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The implementation lives in the `M88kInstPrint.cpp` file. After including the
    required header file and using the `llvm` namespace, the file with the generated
    C++ fragments is included:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现位于 `M88kInstPrint.cpp` 文件中。在包含所需的头文件并使用 `llvm` 命名空间之后，包含生成了 C++ 片段的文件：
- en: '[PRE50]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `printOperand()` method checks the type of the operand and emits either
    a register name or an immediate. The register name is looked up with the `getRegisterName()`
    generated method:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`printOperand()` 方法检查操作数的类型，并输出一个寄存器名称或一个立即数。寄存器名称是通过 `getRegisterName()` 生成的函数查找的：'
- en: '[PRE51]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `printInst()` method only calls the `printInstruction()` generated method
    to print the instruction, and after that, the `printAnnotation()` method to print
    possible annotations:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`printInst()` 方法仅调用生成的 `printInstruction()` 方法来打印指令，然后调用 `printAnnotation()`
    方法来打印可能的注释：'
- en: '[PRE52]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Implementing M88k-specific target descriptions
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现 M88k 特定的目标描述
- en: 'In the `M88kMCTargetDesc.cpp` file, we need to make a couple of additions:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `M88kMCTargetDesc.cpp` 文件中，我们需要做一些添加：
- en: 'First, we need a new factory method for the `MCInstPrinter` class and the `MCAsmInfo`
    class:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要为 `MCInstPrinter` 类和 `MCAsmInfo` 类创建一个新的工厂方法：
- en: '[PRE53]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, within the `LLVMInitializeM88kTargetMC()` function, we need to add
    the registration of the factory methods:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `LLVMInitializeM88kTargetMC()` 函数中，我们需要添加工厂方法的注册：
- en: '[PRE54]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now we have implemented all required support classes, and we can finally add
    the assembler parser.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了所有必需的支持类，我们最终可以添加汇编解析器。
- en: Creating the M88k assembler parser class
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 M88k 汇编解析器类
- en: 'There is only an `M88kAsmParser.cpp` implementation file in the `AsmParser`
    directory. The `M88kOperand` class represents a parsed operand and is used by
    the generated source code and our assembler parser implementation in class `M88kAssembler`.
    Both classes are in an anonymous namespace, only the factory method is globally
    visible. Let’s take a look at the `M88kOperand` class first:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AsmParser`目录中只有一个`M88kAsmParser.cpp`实现文件。`M88kOperand`类表示一个解析后的操作数，并由生成的源代码和我们的汇编器解析器实现中的`M88kAssembler`类使用。这两个类都在匿名命名空间中，只有工厂方法是全局可见的。让我们首先看看`M88kOperand`类：
- en: 'An operand can be a token, a register, or an immediate. We define the `OperandKind`
    enumeration to distinguish between these cases. The current kind is stored in
    the `Kind` member. We also store the start and the end location of the operand,
    which is needed to print the error message:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作数可以是标记、寄存器或立即数。我们定义了`OperandKind`枚举来区分这些情况。当前类型存储在`Kind`成员中。我们还存储操作数的起始和结束位置，这对于打印错误信息是必需的：
- en: '[PRE55]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To store the value, we define a union. The token is stored as a `StringRef`
    and the register is identified by its number. The immediate is represented by
    the `MCExpr` class:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了存储值，我们定义了一个联合。标记存储为`StringRef`，寄存器通过其编号来标识。立即数由`MCExpr`类表示：
- en: '[PRE56]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The constructor initializes all fields but the union. Furthermore, we define
    methods to return the value of the start and the end locations:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数初始化所有字段，除了联合。此外，我们定义了返回起始和结束位置值的方法：
- en: '[PRE57]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'For each operand type, we must define four methods. For a register, the methods
    are `isReg()` to check whether the operand is a register, `getReg()` to return
    the value, `createReg()` to create a register operand, and `addRegOperands()`
    to add an operant to an instruction. The latter function is called by the generated
    source code when an instruction is constructed. The methods for the token and
    the immediate are similar:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每种操作数类型，我们必须定义四个方法。对于寄存器，方法包括`isReg()`来检查操作数是否为寄存器，`getReg()`来返回值，`createReg()`来创建寄存器操作数，以及`addRegOperands()`来将操作数添加到指令中。后一个函数在构建指令时由生成的源代码调用。标记和立即数的方法类似：
- en: '[PRE58]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'And last, the superclass defines an abstract `print()` virtual method that
    we need to implement. This is only used for debugging purposes:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，超类定义了一个抽象的`print()`虚方法，我们需要实现它。这仅用于调试目的：
- en: '[PRE59]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Next, we declare the `M88kAsmParser` class. The anonymous name space will end
    after the declaration:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明`M88kAsmParser`类。在声明之后，匿名命名空间将结束：
- en: 'At the beginning of the class we include the generated fragment:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的开头，我们包含生成的片段：
- en: '[PRE60]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Next, we define the required fields. We need a reference to the actual parser,
    which is of the `MCAsmParser` class, and a reference to the sub-target information:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义所需的字段。我们需要对实际解析器的引用，它属于`MCAsmParser`类，以及一个对子目标信息的引用：
- en: '[PRE61]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To implement the assembler, we override a couple of methods defined in the
    `MCTargetAsmParser` superclass. The `MatchAndEmitInstruction()` method tries to
    match an instruction and emits the instruction represented by an instance of the
    `MCInst` class. Parsing an instruction is done in the `ParseInstruction()` method,
    while the `parseRegister()` and `tryParseRegister()` methods are responsible for
    parsing the register. The other methods are required internally:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了实现汇编器，我们覆盖了`MCTargetAsmParser`超类中定义的一些方法。`MatchAndEmitInstruction()`方法尝试匹配一个指令并发出由`MCInst`类实例表示的指令。解析指令是在`ParseInstruction()`方法中完成的，而`parseRegister()`和`tryParseRegister()`方法负责解析寄存器。其他方法内部需要：
- en: '[PRE62]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The constructor is defined inline. It mostly initializes all fields. This finishes
    the class declaration, after which the anonymous namespace ends:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数是内联定义的。它主要初始化所有字段。这完成了类的声明，之后匿名命名空间结束：
- en: '[PRE63]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now we include the generated parts of the assembler:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们包含汇编器生成的部分：
- en: '[PRE64]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The `ParseInstruction()` method is called whenever an instruction is expected.
    It must be able to parse all syntactical forms of an instruction. Currently, we
    only have instructions that take three operands, which are separated by a comma,
    so the parsing is simple. Be aware that the return value is `true` in case of
    an error!
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当期望指令时，会调用`ParseInstruction()`方法。它必须能够解析指令的所有语法形式。目前，我们只有接受三个操作数的指令，这些操作数由逗号分隔，因此解析很简单。请注意，在出现错误的情况下，返回值是`true`！
- en: '[PRE65]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'An operand can be a register or an immediate. We generalize a bit and parse
    an expression instead of just an integer. This helps later when adding address
    modes. When successful, the parsed operand is added to the `Operands` list:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作数可以是寄存器或立即数。我们稍微泛化一下，解析一个表达式而不是仅仅一个整数。这有助于以后添加地址模式。如果解析成功，解析的操作数将被添加到 `Operands`
    列表中：
- en: '[PRE66]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `parseRegister()` method tries to parse a register. First, it checks for
    a percent sign `%`. If this is followed by an identifier which matches a register
    name, then we successfully parsed a register, and return the register number in
    the `RegNo` parameter. However, if we cannot identify a register, then we may
    need to undo the lexing if the `RestoreOnFailure` parameter is `true`:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`parseRegister()` 方法尝试解析一个寄存器。首先，它检查是否存在百分号 `%`。如果其后跟一个与寄存器名称匹配的标识符，那么我们成功解析了一个寄存器，并在
    `RegNo` 参数中返回寄存器编号。然而，如果我们无法识别寄存器，那么如果 `RestoreOnFailure` 参数为 `true`，我们可能需要撤销词法分析：'
- en: '[PRE67]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `parseRegister()` and `tryparseRegister()` overridden methods are just
    wrappers around the previously defined method. The latter method also translates
    the boolean return value into an enumeration member of the `OperandMatchResultTy`
    enumeration:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖的 `parseRegister()` 和 `tryparseRegister()` 方法只是对先前定义的方法的包装。后者方法还将布尔返回值转换为
    `OperandMatchResultTy` 枚举的枚举成员：
- en: '[PRE68]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Finally, the `MatchAndEmitInstruction()` method drives the parsing. Most of
    the method is dedicated to emitting error messages. To identify the instruction,
    the `MatchInstructionImpl()` generated method is called:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`MatchAndEmitInstruction()` 方法驱动解析。该方法的大部分内容都是用于发出错误信息。为了识别指令，调用生成的 `MatchInstructionImpl()`
    方法：
- en: '[PRE69]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'And like some other classes, the assembler parser has its own factory method:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并且像一些其他类一样，汇编器解析器有自己的工厂方法：
- en: '[PRE70]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This finishes the implementation of the assembler parser. After building LLVM,
    we can use the **llvm-mc** machine code playground tool to assemble an instruction:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了汇编器解析器的实现。在构建 LLVM 之后，我们可以使用 **llvm-mc** 机器代码游乐场工具来汇编一条指令：
- en: '[PRE71]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note the use of the vertical bar `|` as the comments sign. This is the value
    we configured in the `M88kMCAsmInfo` class.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用垂直线 `|` 作为注释符号。这是我们配置在 `M88kMCAsmInfo` 类中的值。
- en: Debugging the assembler matcher
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 调试汇编器匹配器
- en: To debug the assembler matcher, you specify the `--debug-only=asm-matcher` command-line
    option. This helps with understanding why a parsed instruction fails to match
    the instructions defined in the target description.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要调试汇编器匹配器，你指定 `--debug-only=asm-matcher` 命令行选项。这有助于理解为什么解析的指令无法匹配目标描述中定义的指令。
- en: In the next section, we will add a disassembler feature to the llvm-mc tool.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将向 llvm-mc 工具添加反汇编器功能。
- en: Creating the disassembler
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建反汇编器
- en: 'Implementing the disassembler is optional. However, the implementation does
    not require too much effort, and generating the disassembler table may catch encoding
    errors that are not checked by the other generators. The disassembler lives in
    the `M88kDisassembler.cpp` file, found in the `Disassembler` subdirectory:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 实现反汇编器是可选的。然而，实现不需要太多的努力，并且生成反汇编器表可能会捕获其他生成器未检查的编码错误。反汇编器位于 `Disassembler` 子目录中的
    `M88kDisassembler.cpp` 文件中：
- en: 'We begin the implementation by defining a debug type and the `DecodeStatus`
    type. Both are required for the generated code:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们开始实现的过程是定义一个调试类型和 `DecodeStatus` 类型。这两个都是生成代码所必需的：
- en: '[PRE72]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The `M88kDisassmbler` class lives in an anonymous namespace. We only need to
    implement the `getInstruction()` method:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`M88kDisassmbler` 类位于一个匿名命名空间中。我们只需要实现 `getInstruction()` 方法：'
- en: '[PRE73]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We also need to provide a factory method, which will be registered in the target
    registry:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要提供一个工厂方法，它将被注册在目标注册表中：
- en: '[PRE74]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The `decodeGPRRegisterClass()` function turns a register number into the register
    enum member generated by TableGen. This is the inverse operation of the `M88kInstPrinter::
    getMachineOpValue()` method. Note that we specified the name of this function
    in the `DecoderMethod` field in the `M88kRegisterOperand` class:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`decodeGPRRegisterClass()` 函数将寄存器编号转换为 TableGen 生成的寄存器枚举成员。这是 `M88kInstPrinter::
    getMachineOpValue()` 方法的逆操作。注意我们在 `M88kRegisterOperand` 类的 `DecoderMethod` 字段中指定了这个函数的名称：'
- en: '[PRE75]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Then we include the generated disassembler tables:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们包含生成的反汇编器表：
- en: '[PRE76]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'And finally, we decode the instruction. For this, we need to take the next
    four bytes of the `Bytes` array, create the instruction encoding from them, and
    call the `decodeInstruction()` generated function:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们解码指令。为此，我们需要从 `Bytes` 数组的下一个四个字节开始，从这些字节中创建指令编码，并调用生成的 `decodeInstruction()`
    函数：
- en: '[PRE77]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'That is all that needs to be done for the disassembler. After compiling LLVM,
    you can test the functionality again with the `llvm-mc` tool:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 对于反汇编器来说，以上就是需要完成的所有工作。在编译 LLVM 之后，你可以使用 `llvm-mc` 工具再次测试其功能：
- en: '[PRE78]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Moreover, we can now use the `llvm-objdump` tool to disassemble ELF files. However,
    for it to be really useful, we would need to add all instructions to the target
    description.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们现在可以使用 `llvm-objdump` 工具来反汇编 ELF 文件。然而，为了使其真正有用，我们需要将所有指令添加到目标描述中。
- en: Summary
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to create a LLVM target description, and you
    developed a simple backend target that supports the assembling and disassembling
    of instructions for LLVM. You first collected the required documentation and made
    LLVM aware of the new architecture by enhancing the `Triple` class. The documentation
    also includes the relocation definition for the ELF file format, and you added
    the support for them to LLVM.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何创建一个 LLVM 目标描述，并且开发了一个简单的后端目标，该目标支持为 LLVM 指令进行汇编和反汇编。你首先收集了所需的文档，并通过增强
    `Triple` 类使 LLVM 意识到新的架构。文档还包括 ELF 文件格式的重定位定义，并且你为 LLVM 添加了对这些定义的支持。
- en: You then learned about the register definition and the instruction definition
    in the target description and used the generated C++ source code to implement
    an instruction assembler and disassembler.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你学习了目标描述中的寄存器定义和指令定义，并使用生成的 C++ 源代码实现了指令汇编器和反汇编器。
- en: In the next chapter, we will add code generation to the backend.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将向后端添加代码生成功能。
