<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Escape the Maze</h1>
                </header>
            
            <article>
                
<p class="calibre2">In the previous chapter, you learned how Godot's node system works, allowing you to build a complex scene out of smaller building blocks, each providing different functionalities for your game's objects. This process will continue as you move up to larger and more complex projects. However, sometimes you'll find yourself duplicating the same nodes and/or code in more than one different object, and this project will introduce some techniques for reducing the amount of repeated code. </p>
<p class="calibre2">In this chapter, you'll build a game called <strong class="calibre4">Escape the Maze</strong>. In this game, you will be trying to navigate a maze to find the exit while avoiding the roaming enemies:</p>
<div class="cdpaligncenter1"><img class="alignnone1" src="assets/f19f1bec-1b9d-4259-911a-fa948896fd3b.png"/></div>
<p class="calibre2">You will learn about the following key topics in this project:</p>
<ul class="calibre10">
<li class="calibre11">Inheritance</li>
<li class="calibre11">Grid-based movement</li>
<li class="calibre11">Spritesheet animation</li>
<li class="calibre11"><span>Using TileMaps for level design</span></li>
<li class="calibre11">Transitioning between scenes</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Project setup</h1>
                </header>
            
            <article>
                
<p class="calibre2">Create a new project and download the project assets from <a href="https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases" class="calibre9">https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases</a>.</p>
<p class="calibre2">As you've seen previously, Godot, by default, includes a number of input actions mapped to various keyboard inputs. For example, you used <kbd class="calibre12">ui_left</kbd> and <kbd class="calibre12">ui_right</kbd> for arrow key movement in the first project. Often, however, you need a different input from the defaults provided, or you'd like to customize the actions' names. You might also wish to add actions for mouse or gamepad inputs. You can do this in the <span class="calibre5">Project Settings</span> window.</p>
<p class="calibre2">Click on the <span class="calibre5">Input Map</span> tab and add four new input actions (<span class="calibre5">left</span>, <span class="calibre5">right</span>, <span class="calibre5">up</span>, and <span class="calibre5">down</span>) by typing the names into the <span class="calibre5">Action:</span> box and clicking <span class="calibre5">Add</span>. Then, for each new action, click the <span class="calibre5">+</span> button to add a <span class="calibre5">Key</span> action and choose the corresponding arrow key. You can also add WASD controls, if you wish:</p>
<div class="cdpaligncenter1"><img src="assets/964a2860-a805-4591-b4cc-dff6c68e5e4d.png" class="calibre59"/></div>
<p class="calibre2">This game will have a variety of objects on the screen. Some of them should detect collisions (the player against the walls, for example), while others should ignore one another (like the enemies versus coins). You can solve this by setting the objects' physics layer and physics layer mask properties. To make these layers easier to work with, Godot allows you to give the game's physics layers custom names.</p>
<p class="calibre2">Click on the <span class="calibre5">General</span> tab and find the <span class="calibre5">Layer Names</span>/<span class="calibre5">2D Physics</span> section. Name the first four layers as follows:</p>
<div class="cdpaligncenter1"><img src="assets/eac9f379-4f8b-470d-b102-b7a00d134781.png" class="calibre60"/></div>
<p class="calibre2">You'll see how the collision layer system works with the various objects in the game later in the project.</p>
<p class="calibre2">Next, in the <span class="calibre5">Display</span>/<span class="calibre5">Window</span> section, set the <span class="calibre5">Mode</span> to <span class="calibre5">viewport</span> and the <span class="calibre5">Aspect</span> to <span class="calibre5">keep</span>. This will enable you to resize the game window while keeping the display's proportions unchanged. Refer to the following screenshot:</p>
<div class="cdpaligncenter1"><img src="assets/7343da03-609c-48c0-8503-74454e3b6cef.png" class="calibre61"/></div>
<p class="calibre2">Finally, in the <span class="calibre5">Rendering</span>/<span class="calibre5">Quality</span> section, set <span class="calibre5">Use Pixel Snap</span> to <span class="calibre5">On</span>. This setting is useful, especially for pixel art-styled games, as it ensures that all objects are drawn at whole-number pixel values. Note that this does not affect movement, physics, or other properties; it only applies to the rendering of objects. Refer to the following screenshot:</p>
<div class="cdpaligncenter1"><img src="assets/e5baf2f7-a74a-4f1e-965b-73961d090e31.png" class="calibre62"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Project organization</h1>
                </header>
            
            <article>
                
<p class="calibre2">As your projects become larger and more involved, you'll find that saving all of your scenes and scripts in the same folder becomes unwieldy. </p>
<p class="calibre2">A common response to this by Godot beginners is to make a <kbd class="calibre12">scenes</kbd> folder and a <kbd class="calibre12">scripts</kbd> folder, and to save each type of file in the respective folder. This isn't very effective. Soon, you find yourself hunting through the <kbd class="calibre12">scripts</kbd> folder, looking for the script you need because it's jumbled up with all the other scripts of your game.</p>
<p class="calibre2">A more logical organization is to create a folder for each type of object. A <kbd class="calibre12">player</kbd> folder, for example, will hold the player's scene file, script(s), and any other resources that it needs. Organizing your project in this way is much more scalable and can be extended even further if you have a very large number of objects. For example, refer to the following screenshot:</p>
<div class="cdpaligncenter1"><img src="assets/e165e4c5-5204-48bf-bc61-d13f624945c1.png" class="calibre63"/></div>
<p class="calibre2">Throughout this project, the examples will assume that each new scene type is being saved in a folder of that type, along with its script. The <kbd class="calibre12">Player.tscn</kbd> and <kbd class="calibre12">Player.gd</kbd> files, for example, will be saved in a <kbd class="calibre12">player</kbd> folder.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Inheritance</h1>
                </header>
            
            <article>
                
<p class="calibre2">In <strong class="calibre4">Object-Oriented Programming</strong> (<strong class="calibre4">OOP</strong>), inheritance is a powerful tool. Put briefly, you can define a class that <em class="calibre17">inherits</em> from another class. An object created using the first class will contain all of the methods and member variables of the master class as well as its own.</p>
<p class="calibre2">Godot is strongly object-oriented, and this gives you the opportunity to use inheritance not just with objects (scripts) but also with scenes, allowing you a great deal of flexibility when designing your game's architecture. It also removes the need to duplicate code—if two objects need to share a set of methods and variables, for example, you can create a common script and let both objects inherit from it. If you make a change to that code, it will apply to both objects.</p>
<p class="calibre2">In this project, the player's character will be controlled by key events, while the mobs will wander around the maze randomly. However, both types of character need to have a number of properties and functions in common:</p>
<ul class="calibre10">
<li class="calibre11">A spritesheet containing the four directional movement animations</li>
<li class="calibre11">An <kbd class="calibre12">AnimationPlayer</kbd> to play the movement animations</li>
<li class="calibre11">Grid-based movement (the character can only move one full <em class="calibre20">tile</em> at a time)</li>
<li class="calibre11">Collision detection (the character can't move through walls)</li>
</ul>
<p class="calibre2">By using inheritance, you can create a generic <kbd class="calibre12">Character</kbd> scene containing the nodes that all characters need. The player and mob scenes can inherit the shared nodes from that scene. Similarly, the actual movement code (though not the controls) will be identical between player and mob, so they can both inherit from the same script to handle movement.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Character scene</h1>
                </header>
            
            <article>
                
<p class="calibre2">Start creating the <kbd class="calibre12">Character</kbd> scene by adding an <kbd class="calibre12">Area2D</kbd> and naming it <kbd class="calibre12">Character</kbd>. <kbd class="calibre12">Area2D</kbd> is a good choice for this type of character because its main function will be to detect overlaps—when it moves onto an item or enemy, for example.</p>
<p class="calibre2">Add the following children:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">Sprite</kbd></li>
<li class="calibre11"><kbd class="calibre12">CollisionShape2D</kbd></li>
<li class="calibre11"><kbd class="calibre12">Tween</kbd> (named <kbd class="calibre12">MoveTween</kbd>)</li>
<li class="calibre11"><kbd class="calibre12">AnimationPlayer</kbd></li>
</ul>
<p class="calibre2">Leave the <kbd class="calibre12">Sprite</kbd> without a texture, but in the <span class="calibre5">Inspector</span>, under the <span class="calibre5">Animation</span> section of the <kbd class="calibre12">Sprite</kbd>, set its <span class="calibre5">Vframes</span> and <span class="calibre5">Hframes</span> properties to <kbd class="calibre12">4</kbd> and <kbd class="calibre12">5</kbd>, respectively. This tells Godot to slice the texture into a 5 x 4 grid of individual images.</p>
<p class="calibre2">The spritesheets you'll use for the player and the enemy are arranged in exactly this pattern, with each row containing the animation frames for a single direction of movement:</p>
<div class="cdpaligncenter1"><img class="alignnone2" src="assets/c554daf6-fbfe-46b2-a55a-a5093674c110.png"/></div>
<p class="calibre2">When a spritesheet has been sliced using the <span class="calibre5">Vframes</span> and <span class="calibre5">Hframes</span> properties, you can use the <span class="calibre5">Frame</span> property to set which individual frame to use. In the preceding player sheet, the left-facing animation would use frames 5 through 9 (counting from frame 0 in the upper-left corner). You'll use an <kbd class="calibre12">AnimationPlayer</kbd> to change the <span class="calibre5">Fram</span><span class="calibre5">e</span> property below. Refer to the following screenshot:</p>
<div class="cdpaligncenter1"><img src="assets/f663cd4f-8aca-4a47-910a-bb09fb1b5791.png" class="calibre24"/></div>
<p class="calibre2">Next, create a new <kbd class="calibre12">RectangleShape2D</kbd> in the collision shape's Shape. Click on the new <span class="calibre5">&lt;RectangleShape2D&gt;</span> and set its <span class="calibre5">Extents</span> property in the <span class="calibre5">Inspector</span> to <kbd class="calibre12">(16, 16)</kbd>. Note that <span class="calibre5">Extents</span> measures the distance from the center in each direction, so this results in a collision shape that is 32 by 32 pixels.</p>
<div class="packt_infobox">Because all the characters are drawn to the same scale, we can be confident that the same sized collision shape will work for all characters. If this isn’t the case with the art you’re using, you can skip setting the collision shape here and configure it later for the individual inherited scenes.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Animations</h1>
                </header>
            
            <article>
                
<p class="calibre2">Create four new animations in the <kbd class="calibre12">AnimationPlayer</kbd> node. Name them to match the four directions you used in the input actions (<span class="calibre5">left</span>, <span class="calibre5">right</span>, <span class="calibre5">up</span>, and <span class="calibre5">down</span>). It's important that the spelling matches here: the names of the input actions must have the same spelling and capitalization as the animation names. If you are inconsistent in naming, it will make things much more difficult when you get to the scripting stage. Take a look at the following screenshot:</p>
<div class="cdpaligncenter1"><img src="assets/ce46a833-f716-440f-965b-d9b467889a3f.png" class="calibre24"/></div>
<p class="calibre2"><span class="calibre5">For each animation, set the </span><span class="calibre5">Length</span><span class="calibre5"> to </span><kbd class="calibre12">1</kbd><span class="calibre5"> and the </span><span class="calibre5">Step</span><span class="calibre5"> to </span><kbd class="calibre12">0.2</kbd><span class="calibre5">. These properties are located at the bottom of the <span class="calibre5">Animation</span> panel:</span></p>
<div class="cdpaligncenter1"><img src="assets/fb366165-9935-422a-9104-3e26b79339ca.png" class="calibre64"/></div>
<p class="calibre2">Starting with the <span class="calibre5">down</span> animation, click on the <kbd class="calibre12">Sprite</kbd> node and set its <span class="calibre5">Frame</span> property to <kbd class="calibre12">0</kbd>. Click the key icon next to the <span class="calibre5">Frame</span> property and confirm that you want to add a new track for the <span class="calibre5">Frame</span> property:</p>
<div class="cdpaligncenter1"><img src="assets/86edd2e7-02ab-4584-9de5-0fb163306411.png" class="calibre65"/></div>
<p class="calibre2">The <span class="calibre5">Frame</span> property will automatically be incremented by one and the animation track will be advanced by one step (0.2 seconds). Click the key again until you've reached frame 4. You should now have five keyframes on the animation track. If you drag the bar back and forth, you'll see the <span class="calibre5">Frame</span> property change as you reach each keyframe:</p>
<div class="cdpaligncenter1"><img src="assets/b444d4c1-bc7a-4f7c-a53d-ee51fa9c8108.png" class="calibre66"/></div>
<p class="calibre2">If, for some reason, you find that the frames aren't correct, you can delete any of the keyframes by clicking on the dot and pressing <em class="calibre17">Delete</em> on your keyboard, or right-clicking on the dot and choosing <span class="calibre5">Remove Selection</span>. Remember, whatever value you set <span class="calibre5">Frame</span> to, that will be the value of the keyframe when you press the <span class="calibre5">Add Keyframe</span> button. You can also click and drag keyframes to change their order in the timeline.</p>
<p class="calibre2">Repeat the process for the other animations, using the following table to guide you on which keyframes to use for each direction:</p>
<table border="1" class="calibre67">
<tbody class="calibre68">
<tr class="calibre69">
<td class="calibre70"><strong class="calibre1">Animation</strong></td>
<td class="calibre70"><strong class="calibre1">Frames</strong></td>
</tr>
<tr class="calibre69">
<td class="calibre70">Down</td>
<td class="calibre70"><kbd class="calibre12">0, 1, 2, 3, 4</kbd></td>
</tr>
<tr class="calibre69">
<td class="calibre70">Left</td>
<td class="calibre70"><kbd class="calibre12">5, 6, 7, 8, 9</kbd></td>
</tr>
<tr class="calibre69">
<td class="calibre70">Right</td>
<td class="calibre70"><kbd class="calibre12">10, 11, 12, 13, 14</kbd></td>
</tr>
<tr class="calibre69">
<td class="calibre70">Up</td>
<td class="calibre70"><kbd class="calibre12">15, 16, 17, 18, 19</kbd></td>
</tr>
</tbody>
</table>
<p class="calibre2"> </p>
<p class="calibre2">As long as the spritesheet for a character follows the same 5 x 4 arrangement, this <kbd class="calibre12">AnimationPlayer</kbd> configuration will work, and you won't need to create separate animations for each character. In larger projects, it can be a huge time-saver to create all your spritesheet animations while following a common pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Collision detection</h1>
                </header>
            
            <article>
                
<p class="calibre2">Because the characters are moving on a grid, they need to either move the full distance to the next tile or not at all. This means that, before moving, the character needs to check to see if the move is possible. One way to test if an adjacent square has anything in it is by using a <em class="calibre17">raycast</em>. <strong class="calibre4">Raycasting</strong> means extending a ray from the character's position to a given destination. If the ray encounters any object along the way, it will report that contact. By adding four rays to the character, it can <em class="calibre17">look</em> at the squares around it to see if they are unoccupied.</p>
<p class="calibre2">Add four <kbd class="calibre12">RayCast2D</kbd> nodes and set their names and <strong class="calibre4">Cast To</strong> properties as follows:</p>
<table border="1" class="calibre67">
<tbody class="calibre68">
<tr class="calibre69">
<td class="calibre70"><strong class="calibre1">Name</strong></td>
<td class="calibre70"><strong class="calibre1">Cast To</strong></td>
</tr>
<tr class="calibre69">
<td class="calibre70">RayCastRight</td>
<td class="calibre70"><kbd class="calibre12">(64, 0)</kbd></td>
</tr>
<tr class="calibre69">
<td class="calibre70">RayCastLeft</td>
<td class="calibre70"><kbd class="calibre12">(-64, 0)</kbd></td>
</tr>
<tr class="calibre69">
<td class="calibre70">RayCastDown</td>
<td class="calibre70"><kbd class="calibre12">(0, 64)</kbd></td>
</tr>
<tr class="calibre69">
<td class="calibre70">RayCastUp</td>
<td class="calibre70"><kbd class="calibre12">(0, -64)</kbd></td>
</tr>
</tbody>
</table>
<p class="calibre2">Make sure to set the <span class="calibre5">Enabled</span> property on each one (<kbd class="calibre12">RayCast2D</kbd> options are disabled by default). Your final node setup should look like this:</p>
<div class="cdpaligncenter1"><img src="assets/bd237305-31ae-4e68-9b68-42f20a77f562.png" class="calibre71"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Character script</h1>
                </header>
            
            <article>
                
<p class="calibre2">Now, add a script to the <kbd class="calibre12">Character</kbd> node (make sure you've saved the scene first, and the script will automatically be named <kbd class="calibre12">Character.gd</kbd>). First, define the class variables:</p>
<pre class="calibre18">extends Area2D<br class="title-page-name"/><br class="title-page-name"/>export (int) var speed<br class="title-page-name"/><br class="title-page-name"/>var tile_size = 64<br class="title-page-name"/>var can_move = true<br class="title-page-name"/>var facing = 'right'<br class="title-page-name"/>var moves = {'right': Vector2(1, 0),<br class="title-page-name"/>             'left': Vector2(-1, 0),<br class="title-page-name"/>             'up': Vector2(0, -1),<br class="title-page-name"/>             'down': Vector2(0, 1)}<br class="title-page-name"/>onready var raycasts = {'right': $RayCastRight,<br class="title-page-name"/>                        'left': $RayCastLeft,<br class="title-page-name"/>                        'up': $RayCastUp,<br class="title-page-name"/>                        'down': $RayCastDown}</pre>
<p class="calibre2"><kbd class="calibre12">speed</kbd> will control the movement and animation speed of the character, allowing you to customize the movement speed. As you learned in <a href="fee8a22d-c169-454d-be5e-cf6c0bc78ddb.xhtml" class="calibre9">Chapter 1</a>, <em class="calibre17">Introduction</em>, using <kbd class="calibre12">export</kbd> allows you to set the value of a variable via the Inspector. Save the script and set the <span class="calibre5">Speed</span> property to <kbd class="calibre12">3</kbd> in the Inspector.</p>
<p class="calibre2"><kbd class="calibre12">can_move</kbd> is a flag that will track whether the character is allowed to move during the current frame. It will be set to <kbd class="calibre12">false</kbd> while the movement is underway, preventing a second movement from being started before the previous one has finished. <kbd class="calibre12">facing</kbd> is a string denoting the current direction of movement (again, spelled and capitalized exactly like the input actions you created at the beginning of the project). The <kbd class="calibre12">moves</kbd> dictionary contains vectors describing the four directions, while the <kbd class="calibre12">raycasts</kbd> dictionary contains references to the four raycast nodes. Note that both dictionaries' keys match the input action names.</p>
<div class="packt_infobox"><span>When referencing another node during variable declaration, you must use </span><kbd class="calibre13">onready</kbd><span> to ensure that the variable isn't set before the referenced node is ready. You can think of it as a shortcut to writing the code in the <kbd class="calibre13">_ready()</kbd> function. This line:<br class="title-page-name"/>
<kbd class="calibre13">onready var sprite = $Sprite</kbd><br class="title-page-name"/>
Is equivalent to writing this:<br class="title-page-name"/>
<kbd class="calibre13">var sprite</kbd><br class="title-page-name"/>
<kbd class="calibre13">func _ready():</kbd><br class="title-page-name"/>
<kbd class="calibre13">    sprite = $Sprite</kbd></span></div>
<p class="calibre2">The following is the code that will execute a movement from one square to another:</p>
<pre class="calibre18">func move(dir):<br class="title-page-name"/>    $AnimationPlayer.playback_speed = speed<br class="title-page-name"/>    facing = dir<br class="title-page-name"/>    if raycasts[facing].is_colliding():<br class="title-page-name"/>        return<br class="title-page-name"/>    <br class="title-page-name"/>    can_move = false<br class="title-page-name"/>    $AnimationPlayer.play(facing)<br class="title-page-name"/>    $MoveTween.interpolate_property(self, "position", position,<br class="title-page-name"/>                position + moves[facing] * tile_size,<br class="title-page-name"/>                1.0 / speed, Tween.TRANS_SINE, Tween.EASE_IN_OUT)<br class="title-page-name"/>    $MoveTween.start()<br class="title-page-name"/>    return true</pre>
<p class="calibre2"><kbd class="calibre12">move()</kbd> takes a direction as an argument. If the <kbd class="calibre12">RayCast2D</kbd> for the given direction detects a collision, the move is canceled and the function returns without executing further (note that the return value will be <kbd class="calibre12">null</kbd>). Otherwise, it changes <kbd class="calibre12">facing</kbd> to the new direction, disables additional movement with <kbd class="calibre12">can_move</kbd>, and starts playing the matching animation. To actually perform the movement, the <kbd class="calibre12">Tween</kbd> node interpolates the <kbd class="calibre12">position</kbd> property from its current value to its current value plus a tile-sized movement in the given direction. The duration (<kbd class="calibre12">1.0 / speed</kbd> seconds) is set to match the length of the animation.</p>
<p class="calibre2">Using the <kbd class="calibre12">Tween.TRANS_SINE</kbd> transition type results in a pleasing, smooth movement that accelerates up and then down to the final position. Feel free to try other transition types here to alter the movement style.</p>
<p class="calibre2">Finally, to enable movement again, you need to reset <kbd class="calibre12">can_move</kbd> when the movement has finished. Connect the <kbd class="calibre12">tween_completed</kbd> signal from <kbd class="calibre12">MoveTween</kbd> and add the following:</p>
<pre class="calibre18">func _on_MoveTween_tween_completed( object, key ):<br class="title-page-name"/>    can_move = true</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Player scene</h1>
                </header>
            
            <article>
                
<p class="calibre2">The player scene needs to contain all the same nodes we gave to <kbd class="calibre12">Character</kbd>. This is where you'll take advantage of the power of inheritance.</p>
<p class="calibre2">Start by making a new scene. However, instead of making a new empty scene, click on <span class="calibre5">Scene</span> | <span class="calibre5">New Inherited</span> <span class="calibre5">Scene</span> in the menu. In the <span class="calibre5">Open Base Scene</span> window, select <kbd class="calibre12">res://character/Character.tscn</kbd>, as shown in the following screenshot:</p>
<div class="cdpaligncenter1"><img src="assets/e68733c2-c456-4970-9e21-17f83ce9e7b0.png" class="calibre72"/></div>
<p class="calibre2">Rename the root node of this new scene from <kbd class="calibre12">Character</kbd> to <kbd class="calibre12">Player</kbd> and save the new scene. Note that all the <kbd class="calibre12">Character</kbd> nodes are also present. If you make a change to <kbd class="calibre12">Character.tscn</kbd> and save it, the changes will also take effect in the <kbd class="calibre12">Player</kbd> scene.</p>
<p class="calibre2">Now, you need to set the Player's physics layers, so find the <span class="calibre5">Collision</span> section in the <span class="calibre5">Inspector</span> and set the <span class="calibre5">Layer</span> and <span class="calibre5">Mask</span> properties. <span class="calibre5">Layer</span> should be set to <span class="calibre5">player</span> only, while <span class="calibre5">Mask</span> should show <span class="calibre5">walls</span>, <span class="calibre5">enemies</span>, and <span class="calibre5">items</span>. Refer to the following screenshot:</p>
<div class="cdpaligncenter1"><img class="alignnone3" src="assets/c545783f-9bd2-45e5-b68e-899493a4baba.png"/></div>
<p class="calibre2">The collision layers system is a powerful tool that allows you to customize which objects can detect each other. The <span class="calibre5">Layer</span> property places the object in one or more collision layers, while the <span class="calibre5">Mask</span> property defines what layers the object can <em class="calibre17">see</em>. If another object is not in one of its mask layers, it will not be detected or collided with.</p>
<p class="calibre2">The only other node that needs to be changed is the <kbd class="calibre12">Sprite</kbd>, where you need to set the texture. Drag the player spritesheet from the <kbd class="calibre12">res://assets</kbd> folder and drop it in the <span class="calibre5">Texture</span> property of the <kbd class="calibre12">Sprite</kbd>. Go ahead and test out the animations in the <kbd class="calibre12">AnimationPlayer</kbd> and make sure they're showing the correct directions. If you find a problem with any of the animations, make sure you fix it in the <kbd class="calibre12">Character</kbd> scene, and it will automatically be fixed in the <kbd class="calibre12">Player</kbd> scene as well:</p>
<div class="cdpaligncenter1"><img src="assets/353109fb-1fb2-4d8b-a357-5a3b9f997b9f.png" class="calibre73"/></div>
<p class="calibre2">Add a <kbd class="calibre12">Camera</kbd> node as a child of <kbd class="calibre12">Player</kbd> and check its <span class="calibre5">Current</span> property to <span class="calibre5">On</span>. Godot will automatically render whatever the current camera sees in the game window. This will allow you to make maps of any size, and the camera will scroll the map as the player walks around on it. Note that when you add the camera, a purplish box appears, which is centered on the player. This represents the camera's visible region, and because it's a child of the player, it follows the player's movement. If you look at the camera's properties in the <span class="calibre5">Inspector</span>, you'll see four <span class="calibre5">Limit</span> properties. These are used to stop the camera from scrolling past a certain point; the edge of your map, for example. Try adjusting them and see how the box stops following the <kbd class="calibre12">Player</kbd> as you drag it around the screen (make sure you're moving the <kbd class="calibre12">Player</kbd> node itself and not one of its children). Later, the limits will be set automatically by the level itself so that the camera won't scroll "outside" the level.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Player script</h1>
                </header>
            
            <article>
                
<p class="calibre2">The player's script also needs to extend the character's. Remove the attached script (<kbd class="calibre12">Character.gd</kbd>) by selecting the <kbd class="calibre12">Player</kbd> node and clicking the <span class="calibre5">Clear script</span> button:</p>
<div class="cdpaligncenter1"><img class="alignnone4" src="assets/e7c51b12-110b-41a5-95f9-ff99ec221486.png"/></div>
<p class="calibre2">Now, click the button again to attach a new script. In the <span class="calibre5">Attach Node Script</span> dialog, click the folder icon next to the <span class="calibre5">Inherits</span> option and select <kbd class="calibre12">Character.gd</kbd>:</p>
<div class="cdpaligncenter1"><img src="assets/b4f9da4b-625b-4d06-ac50-7489945e1433.png" class="calibre74"/></div>
<p class="calibre2">Here is the player script (note that it <kbd class="calibre12">extends</kbd> the character script):</p>
<pre class="calibre18"><br class="title-page-name"/>extends "res://character/Character.gd"<br class="title-page-name"/><br class="title-page-name"/>signal moved<br class="title-page-name"/><br class="title-page-name"/>func _process(delta):<br class="title-page-name"/>    if can_move:<br class="title-page-name"/>        for dir in moves.keys():<br class="title-page-name"/>            if Input.is_action_pressed(dir):<br class="title-page-name"/>                if move(dir):<br class="title-page-name"/>                    emit_signal('moved')</pre>
<p class="calibre2">Because it inherits all the behavior from <kbd class="calibre12">Character.gd</kbd>, the player will also have the <kbd class="calibre12">move()</kbd> function. You just need to extend it with code to call <kbd class="calibre12">move()</kbd> based on the input events. As you've seen before, you can use the <kbd class="calibre12">process()</kbd> function to check the input state each frame. However, only if <kbd class="calibre12">can_move</kbd> allows it do you actually check the inputs and call <kbd class="calibre12">move()</kbd>.</p>
<p class="calibre2"><span class="calibre5">Because you used the names <kbd class="calibre12">up</kbd>, <kbd class="calibre12">down</kbd>, <kbd class="calibre12">left</kbd>, and <kbd class="calibre12">right</kbd> for the input actions as well as the keys to the </span><kbd class="calibre12">moves</kbd><span class="calibre5"> and </span><kbd class="calibre12">raycasts</kbd><span class="calibre5"> dictionaries, you can loop through those keys and check each one as an input as well.</span></p>
<p class="calibre2">Recall that <kbd class="calibre12">move()</kbd> returns <kbd class="calibre12">true</kbd> if it succeeds. If it does, the player emits the <kbd class="calibre12">moved</kbd> signal, which you'll be able to use later with the enemies.</p>
<p class="calibre2">Run the scene and try moving the player character around the screen.</p>
<p class="calibre2">The player doesn't have a level to walk around on yet, but you can go ahead and add the code the player will need later. <span class="calibre5">As the player moves around the level, it will encounter various objects and needs to respond to them. By using signals, you can add the code for this before you've even created the level. A</span>dd three more signals to the script:</p>
<pre class="calibre18">signal dead<br class="title-page-name"/>signal grabbed_key<br class="title-page-name"/>signal win</pre>
<p class="calibre2">Then, connect the <kbd class="calibre12">area_entered</kbd> signal of the <kbd class="calibre12">Player</kbd> and add this code:</p>
<pre class="calibre18">func _on_Player_area_entered( area ):<br class="title-page-name"/>    if area.is_in_group('enemies'):<br class="title-page-name"/>        emit_signal('dead')<br class="title-page-name"/>    if area.has_method('pickup'):<br class="title-page-name"/>        area.pickup()<br class="title-page-name"/>    if area.type == 'key_red':<br class="title-page-name"/>        emit_signal('grabbed_key')<br class="title-page-name"/>    if area.type == 'star':<br class="title-page-name"/>        emit_signal('win')</pre>
<p class="calibre2">Whenever the player encounters another <kbd class="calibre12">Area2D</kbd>, this function will run. If the object is an enemy, the player loses the game. Note the use of <kbd class="calibre12">has_method()</kbd>. This allows you to identify collectible objects by checking whether they have a <kbd class="calibre12">pickup()</kbd> method and only call the method if it exists.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enemy scene</h1>
                </header>
            
            <article>
                
<p class="calibre2">Hopefully, you're seeing how inheritance works by now. You'll create the <kbd class="calibre12">Enemy</kbd> scene using the same procedure. Make a new scene inheriting from <kbd class="calibre12">Character.tscn</kbd> and name it <kbd class="calibre12">Enemy</kbd>. Drag the mob spritesheet, <kbd class="calibre12">res://assets/slime.png</kbd>, to the <kbd class="calibre12">Sprite</kbd>'s <span class="calibre5">Texture</span>.</p>
<p class="calibre2"><span class="calibre5">In the <span class="calibre5">Collision</span> section of the <span class="calibre5">Inspector</span>, set the </span><span class="calibre5">Layer</span><span class="calibre5"> and </span><span class="calibre5">Mask</span><span class="calibre5"> properties. </span><span class="calibre5">Layer</span><span class="calibre5"> should be set to <span class="calibre5">enemies</span>, while </span><span class="calibre5">Mask</span><span class="calibre5"> should show <span class="calibre5">walls</span> and <span class="calibre5">player</span>.</span></p>
<p class="calibre2">As you did with the <kbd class="calibre12">Player</kbd>, remove the existing script and attach a new script inheriting from <kbd class="calibre12">Character.gd</kbd>:</p>
<pre class="calibre18">extends "res://character/Character.gd"<br class="title-page-name"/><br class="title-page-name"/>func _ready():<br class="title-page-name"/>    can_move = false<br class="title-page-name"/>    facing = moves.keys()[randi() % 4]<br class="title-page-name"/>    yield(get_tree().create_timer(0.5), 'timeout')<br class="title-page-name"/>    can_move = true<br class="title-page-name"/><br class="title-page-name"/>func _process(delta):<br class="title-page-name"/>    if can_move:<br class="title-page-name"/>         if not move(facing) or randi() % 10 &gt; 5:<br class="title-page-name"/>             facing = moves.keys()[randi() % 4] </pre>
<p class="calibre2">The code in the <kbd class="calibre12">_ready()</kbd> function serves an important purpose: because the enemies are added to the tree <em class="calibre17">below</em> the <kbd class="calibre12">TileMap</kbd> nodes, they'll be processed first. You don't want the enemies to start moving before the walls have been processed, or they could step onto a wall tile and get stuck. You need to have a small delay before they start, which also serves to give the player a moment to prepare. To do this, rather than add a <kbd class="calibre12">Timer</kbd> node to the scene, you can use the <kbd class="calibre12">create_timer()</kbd> function of the <kbd class="calibre12">SceneTree</kbd> to make a one-off timer, yielding execution until its timeout signal fires.</p>
<div class="packt_infobox">GDScript's <kbd class="calibre13">yield()</kbd> function provides a way to <em class="calibre20">pause</em> execution of a function until a later time, while allowing the rest of the game to continue running. When passed an object and a named signal, execution will resume when that object emits the given signal.</div>
<p class="calibre2">Every frame, the enemy will move if it is able to. If it runs into a wall (that is, when <kbd class="calibre12">move()</kbd> returns <kbd class="calibre12">null</kbd>), or sometimes just randomly, it changes direction. The result will be an unpredictable (and hard to dodge!) enemy movement. Remember that you can adjust the <kbd class="calibre12">Player</kbd> and <kbd class="calibre12">Enemy</kbd> speeds independently in their scenes, or change <kbd class="calibre12">speed</kbd> in the <kbd class="calibre12">Character</kbd> scene and it will affect them both.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Optional – turn-based movement</h1>
                </header>
            
            <article>
                
<p class="calibre2"><span class="calibre5">For a different style of game, you could put the <kbd class="calibre12">_process()</kbd> movement code in a function called </span><kbd class="calibre12">_on_Player_moved()</kbd><span class="calibre5"> instead, and connect it to the player's </span><kbd class="calibre12">moved</kbd><span class="calibre5"> signal. This would make the enemies move only when the player does, giving the game more of a strategic feel, rather than one of fast-paced action.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the level</h1>
                </header>
            
            <article>
                
<p class="calibre2">In this section, you'll create the map where all the action will take place. As the name implies, you'll probably want to make a maze-like level with lots of twists and turns.</p>
<p class="calibre2">Here is a sample level:</p>
<div class="cdpaligncenter1"><img src="assets/c117363c-b5a1-45ae-b904-03e606451613.png" class="calibre75"/></div>
<p class="calibre2">The player's goal is to reach the star. Locked doors can only be opened by picking up the key. The green dots mark the spawn locations of enemies, while the red dot marks the player's start location. The coins are extra items that can be picked up along the way for bonus points. Note that the entire level is larger than the display window. The <kbd class="calibre12">Camera</kbd> will scroll the map as the player moves around it.</p>
<p class="calibre2"><span class="calibre5">You'll use the <kbd class="calibre12">TileMap</kbd> node to create the map. There are several benefits to using a <kbd class="calibre12">TileMap</kbd> for your level design. First, they make it possible to draw the level's layout by <em class="calibre17">painting</em> the tiles onto a grid, which is much faster than placing individual <kbd class="calibre12">Sprite</kbd> nodes one by one. Secondly, they allow for much larger levels because they are optimized for drawing large numbers of tiles efficiently by batching them together and only drawing the <em class="calibre17">chunks</em> of the map that are visible at a given time. Finally, you can add collision shapes to individual tiles and the entire map will act as a single collider, simplifying your collision code.</span></p>
<p class="calibre2">Once you've completed this section, you'll be able to create as many of these maps as you wish. You can put them in order to give a progression from level to level.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Items</h1>
                </header>
            
            <article>
                
<p class="calibre2">First, create a new scene for the collectable objects that the player can pick up. These items will be spawned by the map when the game is run. Here is the scene tree:</p>
<div class="cdpaligncenter1"><img src="assets/6eeb8abf-8472-45e4-8bf4-d233da503d40.png" class="calibre76"/></div>
<p class="calibre2">Leave the <kbd class="calibre12">Sprite</kbd> <span class="calibre5">Texture</span> blank. Since you're using this object for multiple items, the texture can be set in the item's script when it's created.</p>
<p class="calibre2">Set the <kbd class="calibre12">Pickup</kbd> <span class="calibre5">Collision Layer</span> to <span class="calibre5">items</span> and its <span class="calibre5">Mask</span> to <span class="calibre5">player</span>. You don't want the enemies collecting the coins before you get there (although that might make for a fun variation on the game where you race to get as many coins as you can before the bad guys gobble them up).</p>
<p class="calibre2">Give the <kbd class="calibre12">CollisionShape2D</kbd> node a rectangle shape and set its extents to <kbd class="calibre12">(32, 32)</kbd> (strictly speaking, you can use any shape, as the player will move all the way onto the tile and completely overlap the item anyway).</p>
<p class="calibre2">Here is the script for the <kbd class="calibre12">Pickup</kbd>:</p>
<pre class="calibre18">extends Area2D<br class="title-page-name"/><br class="title-page-name"/>var textures = {'coin': 'res://assets/coin.png',<br class="title-page-name"/>                'key_red': 'res://assets/keyRed.png',<br class="title-page-name"/>                'star': 'res://assets/star.png'}<br class="title-page-name"/>var type<br class="title-page-name"/><br class="title-page-name"/>func _ready():<br class="title-page-name"/>    $Tween.interpolate_property($Sprite, 'scale', Vector2(1, 1),<br class="title-page-name"/>        Vector2(3, 3), 0.5, Tween.TRANS_QUAD, Tween.EASE_IN_OUT)<br class="title-page-name"/>    $Tween.interpolate_property($Sprite, 'modulate',<br class="title-page-name"/>        Color(1, 1, 1, 1), Color(1, 1, 1, 0), 0.5,<br class="title-page-name"/>        Tween.TRANS_QUAD, Tween.EASE_IN_OUT)<br class="title-page-name"/><br class="title-page-name"/>func init(_type, pos):<br class="title-page-name"/>    $Sprite.texture = load(textures[_type])<br class="title-page-name"/>    type = _type<br class="title-page-name"/>    position = pos<br class="title-page-name"/><br class="title-page-name"/>func pickup():<br class="title-page-name"/>    $CollisionShape2D.disabled = true<br class="title-page-name"/>    $Tween.start()</pre>
<p class="calibre2">The <kbd class="calibre12">type</kbd> variable will be set when the item is created and used to determine what texture the object should use. Using <kbd class="calibre12">_type</kbd> as the variable name in the function argument lets you use the name without conflicting with <kbd class="calibre12">type</kbd>, which is already in use.</p>
<div class="packt_infobox">Some programming languages use the notion of <em class="calibre20">private</em> functions or variables<span>, meaning they are only used locally. </span>The <kbd class="calibre13">_</kbd> naming convention in GDScript is used to visually designate variables or functions that should be regarded as private. Note that they aren't actually any different from any other name; it is merely a visual indication for the programmer. </div>
<p class="calibre2">The pickup effect using <kbd class="calibre12">Tween</kbd> is similar to the one you used for the coins in Coin Dash—animating the scale and opacity of <kbd class="calibre12">Sprite</kbd>. Connect the <kbd class="calibre12">tween_completed</kbd> signal of <kbd class="calibre12">Tween</kbd> so that the item can be deleted when the effect has finished:</p>
<pre class="calibre18">func _on_Tween_tween_completed( object, key ):<br class="title-page-name"/>     queue_free()</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TileSets</h1>
                </header>
            
            <article>
                
<p class="calibre2">In order to draw a map using a <kbd class="calibre12">TileMap</kbd>, it must have a <kbd class="calibre12">TileSet</kbd> assigned to it. The <kbd class="calibre12">TileSet</kbd> contains all of the individual tile textures, along with any collision shapes they may have.</p>
<p class="calibre2">Depending on how many tiles you have, it can be time-consuming to create a <kbd class="calibre12">TileSet</kbd>, especially the first time. For that reason, there is a pre-generated <kbd class="calibre12">TileSet</kbd> included in the <kbd class="calibre12">assets</kbd> folder titled <kbd class="calibre12">tileset.tres</kbd>. Feel free to use that instead, but please don't skip the following section. It contains useful information to help you understand how the <kbd class="calibre12">TileSet</kbd> works.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a TileSet</h1>
                </header>
            
            <article>
                
<p class="calibre2">A <kbd class="calibre12">TileSet</kbd> in Godot is a type of <kbd class="calibre12">Resource</kbd>. Examples of other resources include Textures, Animations, and Fonts. They are containers that hold a certain type of data, and are typically saved as <kbd class="calibre12">.tres</kbd> files.</p>
<div class="packt_infobox">By default, Godot saves files in text-based formats, indicated by the <kbd class="calibre13">t</kbd> in <kbd class="calibre13">.tscn</kbd> or <kbd class="calibre13">.tres</kbd>, for example. Text-based files are preferred over binary formats because they are human-readable. They are also more friendly for <strong class="calibre1">Version Control Systems</strong> (<strong class="calibre1">VCS</strong>), which allow you to track file changes over the course of building your project.</div>
<p class="calibre2">To make a <kbd class="calibre12">TileSet</kbd>, you create a scene with a set of <kbd class="calibre12">Sprite</kbd> nodes containing the textures from your art assets. You can then add collisions and other properties to those <kbd class="calibre12">Sprite</kbd> tiles. Once you've created all the tiles, you export the scene as a <kbd class="calibre12">TileSet</kbd> resource, which can then be loaded by the <kbd class="calibre12">TileMap</kbd> node.</p>
<p class="calibre2">Here is a screenshot of the <kbd class="calibre12">TileSetMaker.tscn</kbd> scene, containing the tiles you'll be using to build this game's levels:</p>
<div class="cdpaligncenter1"><img src="assets/ba1919a2-d973-434c-86d0-589edea1136f.png" class="calibre77"/></div>
<p class="calibre2">Start by adding a <kbd class="calibre12">Sprite</kbd> node and setting its texture to <kbd class="calibre12">res://assets/sokoban_tilesheet.png</kbd>. To select a single tile, set the <span class="calibre5">Region</span>/<span class="calibre5">Enabled</span> property to <span class="calibre5">On</span> and click <span class="calibre5">Texture Region</span> at the bottom of the editor window to open the panel. Set <span class="calibre5">Snap Mode</span> to <span class="calibre5">Grid Snap</span> and the <span class="calibre5">Step</span> to <span class="calibre5">64px</span> in both <em class="calibre17">x</em> and <em class="calibre17">y</em>. Now, when you click and drag in the texture, it will only allow you to select 64 x 64 sections of the texture:</p>
<div class="cdpaligncenter1"><img src="assets/e905b5a6-0c92-4a2e-93bb-56a74a93acf4.png" class="calibre78"/></div>
<p class="calibre2">Give the <span class="calibre5">Sprite</span> an appropriate name (<kbd class="calibre12">crate_brown</kbd> or <kbd class="calibre12">wall_red</kbd>, for example)—this name will appear as the tile's name in the <kbd class="calibre12">TileSet</kbd>. Add a <kbd class="calibre12">StaticBody2D</kbd> as a child, and then add a <kbd class="calibre12">CollisionPolygon2D</kbd> to that. It is important that the collision polygon be sized properly so that it aligns with the tiles placed next to it. The easiest way to do this is to turn on grid snapping in the editor window.</p>
<p class="calibre2">Click the <span class="calibre5">Use Snap</span> button (it looks like a magnet) and then open the snap menu by clicking on the three dots next to it:</p>
<div class="cdpaligncenter1"><img class="alignnone5" src="assets/0dc8a750-5a5f-450f-9710-b9450f76b81f.png"/></div>
<p class="calibre2">Choose <span class="calibre5">Configure Snap...</span> and set the <span class="calibre5">Grid Step</span> to <kbd class="calibre12">64</kbd> by <kbd class="calibre12">64</kbd>:</p>
<div class="cdpaligncenter1"><img src="assets/72111e1d-9cf7-4acd-af66-9f222b0fe6ad.png" class="calibre79"/></div>
<p class="calibre2">Now, with the <kbd class="calibre12">CollisionPolygon2D</kbd> selected, you can click in the four corners of the tile one by one to create a closed square (it will appear as a reddish orange):</p>
<div class="cdpaligncenter1"><img src="assets/00ff3738-828c-4c56-85fa-f1144725b12c.png" class="calibre80"/></div>
<p class="calibre2">This tile is now complete. You can duplicate it (<em class="calibre17">Ctrl</em> + <em class="calibre17">D</em>) and make another, and you only need to change the texture region. Note that collision bodies are only needed on the wall tiles. The ground and item tiles should not have them.</p>
<p class="calibre2">When you've created all your tiles, click <span class="calibre5">Scene</span> | <span class="calibre5">Convert To</span> | <span class="calibre5">TileSet</span> and save it with an appropriate name, such as <kbd class="calibre12">tileset.tres</kbd>. If you come back and edit the scene again, you'll need to redo the conversion. Pay special attention to the <span class="calibre5">Merge With Existing</span> option. If this is set to <span class="calibre5">On</span>, the current scene's tiles will be <em class="calibre17">merged</em> with the ones already in the <kbd class="calibre12">tileset</kbd> file. Sometimes, this can result in changes to the tile indices and change your map in unwanted ways. Take a look at the following screenshot:</p>
<div class="cdpaligncenter1"><img src="assets/a4557842-ba93-481f-85d8-44b394ef4c12.png" class="calibre81"/></div>
<div class="packt_infobox"><kbd class="calibre13">tres</kbd> stands for text resource and is the most common format Godot stores its resource files in. Compare this with <kbd class="calibre13">tscn</kbd>, which is the text scene storage format.</div>
<p class="calibre2">Your <kbd class="calibre12">TileSet</kbd> resource is ready to use!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TileMaps</h1>
                </header>
            
            <article>
                
<p class="calibre2">Now, let's make a new scene for the game level. The level will be a self-contained scene, and will include the map and the player, and will handle spawning any items and enemies in the level. For the root, use a <kbd class="calibre12">Node2D</kbd> and name it <kbd class="calibre12">Level1</kbd> (later, you can duplicate this node setup to create more levels).</p>
<div class="packt_infobox">You can open the<span> </span><kbd class="calibre13">Level1.tscn</kbd><span> file from the assets folder to see the completed level scene from this section, although you're encouraged to create your own levels.</span></div>
<p class="calibre2">When using <kbd class="calibre12">TileMap</kbd>, you will often want more than one tile object to appear in a given location. You might want to place a tree, for example, but also have a ground tile appear below it. This can be done by using <kbd class="calibre12">TileMap</kbd> as many times as you like to create layers of data. For your level, you'll make three layers to display the ground, which the player can walk on; the walls, which are obstacles; and the collectible items, which are markers for spawning items like coins, keys, and enemies.</p>
<p class="calibre2">Add a <kbd class="calibre12">TileMap</kbd> and name it <kbd class="calibre12">Ground</kbd>. Drag the <kbd class="calibre12">tileset.tres</kbd> into the <span class="calibre5">Tile Set</span> property and you'll see the tiles appear, ready to be used, on the right-hand side of the editor window:</p>
<div class="cdpaligncenter1"><img src="assets/3e9968ea-dac8-403b-99f2-42079abefcaa.png" class="calibre82"/></div>
<p class="calibre2">It's very easy to accidentally click and drag in the editor window and move your whole tile map. To prevent this, make sure you select the <kbd class="calibre12">Ground</kbd> node and click the Lock button: <img class="inline-image" src="assets/5bba63ac-fb9b-4de8-9756-28e82114e973.png"/>.</p>
<p class="calibre2">Duplicate this <kbd class="calibre12">TileMap</kbd> twice and name the new <kbd class="calibre12">TileMap</kbd> nodes <kbd class="calibre12">Walls</kbd> and <kbd class="calibre12">Items</kbd>. Remember that Godot draws objects in the order listed in the node tree, from top to bottom, so <kbd class="calibre12">Ground</kbd> should be at the top, with <kbd class="calibre12">Walls</kbd> and <kbd class="calibre12">Items</kbd> underneath it.</p>
<p class="calibre2">As you're drawing your level, be careful to note which layer you're drawing on! You should only place the item markers on the Items layer, for example, because that's where the code is going to look for objects to create. Don't place any other objects there, though, because the layer itself will be invisible during gameplay.</p>
<p class="calibre2"><span class="calibre5">Finally, add an instance of the </span><kbd class="calibre12">Player</kbd><span class="calibre5"> scene. Make sure the </span><kbd class="calibre12">Player</kbd><span class="calibre5"> node is below the three </span><kbd class="calibre12">TileMap</kbd><span class="calibre5"> nodes, so it will be drawn on top. The final scene tree should look like this:</span></p>
<div class="cdpaligncenter1"><img src="assets/e33b94ec-0d0d-4b3a-8ab1-2fb6f83c0cb6.png" class="calibre24"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Level script</h1>
                </header>
            
            <article>
                
<p class="calibre2">Now that the level is complete, attach a script to create the level behavior. This script will first scan the <kbd class="calibre12">Items</kbd> map to spawn any enemies and collectibles. It will also serve to monitor for events that occur during gameplay, such as picking up a key or running into an enemy:</p>
<pre class="calibre18">extends Node2D<br class="title-page-name"/><br class="title-page-name"/>export (PackedScene) var Enemy<br class="title-page-name"/>export (PackedScene) var Pickup<br class="title-page-name"/><br class="title-page-name"/>onready var items = $Items<br class="title-page-name"/>var doors = []</pre>
<p class="calibre2">The first two variables contain references to the scenes that will need to be instanced from the <kbd class="calibre12">Items</kbd> map. Since that particular map node will be referenced frequently, you can cache the <kbd class="calibre12">$Items</kbd> lookup in a variable to save some time. Finally, an array called <kbd class="calibre12">doors</kbd> will contain the door location(s) found on the map.</p>
<p class="calibre2">Save the script and dr<span class="calibre5">ag the <kbd class="calibre12">Enemy.tscn</kbd> and <kbd class="calibre12">Pickup.tscn</kbd> files into their respective properties in the Inspector.</span></p>
<p class="calibre2">Now, add the following code for <kbd class="calibre12">_ready()</kbd>:</p>
<pre class="calibre18">func _ready():<br class="title-page-name"/>    randomize()<br class="title-page-name"/>    $Items.hide()<br class="title-page-name"/>    set_camera_limits()<br class="title-page-name"/>    var door_id = $Walls.tile_set.find_tile_by_name('door_red')<br class="title-page-name"/>    for cell in $Walls.get_used_cells_by_id(door_id):<br class="title-page-name"/>        doors.append(cell)<br class="title-page-name"/>    spawn_items()<br class="title-page-name"/>    $Player.connect('dead', self, 'game_over')<br class="title-page-name"/>    $Player.connect('grabbed_key', self, '_on_Player_grabbed_key')<br class="title-page-name"/>    $Player.connect('win', self, '_on_Player_win')</pre>
<p class="calibre2"><span class="calibre5">The function starts by ensuring that the </span><kbd class="calibre12">Items</kbd><span class="calibre5"> tilemap is hidden. You don't want the player to see those tiles; they exist so the script can detect where to spawn items.</span></p>
<p class="calibre2">Next, the camera limits must be set, ensuring that it can't scroll past the edges of the map. You'll create a function to handle that (see the following code).</p>
<p class="calibre2">When the player finds a key, the door(s) need to be opened, so the next part searches the <kbd class="calibre12">Walls</kbd> map for any <kbd class="calibre12">door_red</kbd> tiles and stores them in an array. Note that you must first find the tile's <kbd class="calibre12">id</kbd> from the <kbd class="calibre12">TileSet</kbd>, because the cells of the <kbd class="calibre12">TileMap</kbd> only contain ID numbers that refer to the tile set.</p>
<p class="calibre2"><span class="calibre5">More on the </span><kbd class="calibre12">spawn_items()</kbd><span class="calibre5"> function follows.</span></p>
<p class="calibre2"><span class="calibre5">Finally, the <kbd class="calibre12">Player</kbd> signals are all connected to functions that will process their results.</span></p>
<p class="calibre2"><span class="calibre5">Here's how to set the camera limits to match the size of the map:</span></p>
<pre class="calibre18">func set_camera_limits():<br class="title-page-name"/>    var map_size = $Ground.get_used_rect()<br class="title-page-name"/>    var cell_size = $Ground.cell_size<br class="title-page-name"/>    $Player/Camera2D.limit_left = map_size.position.x * cell_size.x<br class="title-page-name"/>    $Player/Camera2D.limit_top = map_size.position.y * cell_size.y<br class="title-page-name"/>    $Player/Camera2D.limit_right = map_size.end.x * cell_size.x<br class="title-page-name"/>    $Player/Camera2D.limit_bottom = map_size.end.y * cell_size.y</pre>
<p class="calibre2"><kbd class="calibre12">get_used_rect()</kbd> returns a <kbd class="calibre12">Vector2</kbd> containing the size of the <kbd class="calibre12">Ground</kbd> layer in cells. Multiplying this by the <kbd class="calibre12">cell_size</kbd> gives the total map size in pixels, which is used to set the four limit values on the <kbd class="calibre12">Camera</kbd> node. Setting these limits ensures you won't see any <em class="calibre17">dead</em> space outside the map when you move near the edge.</p>
<p class="calibre2">Now, add the <kbd class="calibre12">spawn_items()</kbd> function:</p>
<pre class="calibre18">func spawn_items():<br class="title-page-name"/>    for cell in items.get_used_cells():<br class="title-page-name"/>        var id = items.get_cellv(cell)<br class="title-page-name"/>        var type = items.tile_set.tile_get_name(id)<br class="title-page-name"/>        var pos = items.map_to_world(cell) + items.cell_size/2<br class="title-page-name"/>        match type:<br class="title-page-name"/>            'slime_spawn':<br class="title-page-name"/>                var s = Enemy.instance()<br class="title-page-name"/>                s.position = pos<br class="title-page-name"/>                s.tile_size = items.cell_size<br class="title-page-name"/>                add_child(s)<br class="title-page-name"/>            'player_spawn':<br class="title-page-name"/>                $Player.position = pos<br class="title-page-name"/>                $Player.tile_size = items.cell_size<br class="title-page-name"/>            'coin', 'key_red', 'star':<br class="title-page-name"/>                var p = Pickup.instance()<br class="title-page-name"/>                p.init(type, pos)<br class="title-page-name"/>                add_child(p)</pre>
<p class="calibre2">This function looks for the tiles in the <kbd class="calibre12">Items</kbd> layer, returned by <kbd class="calibre12">get_used_cells()</kbd>. Each cell has an <kbd class="calibre12">id</kbd> that maps to a name in the <kbd class="calibre12">TileSet</kbd> (the names that were assigned to each tile when the <kbd class="calibre12">TileSet</kbd> was made). If you made your own tile set, make sure you use the names that match your tiles in this function. The names used in the preceding code match the tile set that was included in the asset download.</p>
<p class="calibre2"><kbd class="calibre12">map_to_world()</kbd> converts the tile map position to pixel coordinates. This gives you the upper-left corner of the tile, so then you must add one half-size tile to find the center of the tile. Then, depending on what tile was found, the matching item object is instanced.</p>
<p class="calibre2">Finally, add the three functions for the player signals:</p>
<pre class="calibre18">func game_over():<br class="title-page-name"/>    pass<br class="title-page-name"/> <br class="title-page-name"/>func _on_Player_win():<br class="title-page-name"/>    pass<br class="title-page-name"/> </pre>
<pre class="calibre18">func _on_Player_grabbed_key():<br class="title-page-name"/>    for cell in doors:<br class="title-page-name"/>        $Walls.set_cellv(cell, -1)</pre>
<p class="calibre2">The player signals<span class="calibre5"> </span><kbd class="calibre12">dead</kbd><span class="calibre5"> </span>and<span class="calibre5"> </span><kbd class="calibre12">win</kbd><span class="calibre5"> </span>should end the game and go to a <span class="calibre5">Game Over</span> screen (which you haven't created yet). Since you can't write the code for those functions yet, use<span class="calibre5"> </span><kbd class="calibre12">pass</kbd><span class="calibre5"> </span>for the time being. The key pickup signal should remove any door tiles (by setting their tile index to <kbd class="calibre12">-1</kbd>, which means an empty tile).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding more levels</h1>
                </header>
            
            <article>
                
<p class="calibre2">If you want to make another level, you just need to duplicate this scene tree and attach the same script to it. The easiest way to do this is to use <span class="calibre5">Scene</span> | <span class="calibre5">Save As</span> and save the level as <kbd class="calibre12">Level2.tscn</kbd>. Then, you can use some of the existing tiles or draw a whole new level layout.</p>
<p class="calibre2">Feel free to do this with as many levels as you like, making sure to save them all in the <kbd class="calibre12">levels</kbd> folder. In the next section, you'll see how to link them together so that each level will lead to the next. Don't worry if you number them incorrectly; you'll be able to put them in whatever order you like.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Game flow</h1>
                </header>
            
            <article>
                
<p class="calibre2">Now that you have the basic building blocks completed, you need to tie everything together. In this section, you'll create:</p>
<ul class="calibre10">
<li class="calibre11">The Start and Game Over screens</li>
<li class="calibre11">A global script to manage persistent data</li>
</ul>
<p class="calibre2">The basic flow of the game follows the following chart:</p>
<div class="cdpaligncenter1"><img src="assets/d4459717-b5aa-4fb8-b372-a0162b345aa2.png" class="calibre83"/></div>
<p class="calibre2">The player is sent to the end screen whenever he/she dies, or when they reach and complete the last level. After a brief time, the end screen returns the player to the start screen so that a new game can be played.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Start and end screens</h1>
                </header>
            
            <article>
                
<p class="calibre2">You need two scenes for this part: a start or title screen that shows before the game (and lets the player start the game), and a game over screen to notify the player that the game has ended. </p>
<p class="calibre2">Make a new scene and add a <kbd class="calibre12">Control</kbd> node named <kbd class="calibre12">StartScreen</kbd>. Add a <span class="calibre5">Label</span> as a child and add <kbd class="calibre12">res://assets/Unique.ttf</kbd> as a new <kbd class="calibre12">DynamicFont</kbd> with a font size of <kbd class="calibre12">64</kbd>. Set the <span class="calibre5">Align</span> and <span class="calibre5">Valign</span> properties to <span class="calibre5">Center</span> and the <span class="calibre5">Text</span> to <kbd class="calibre12">Escape the Maze!</kbd>. In the <span class="calibre5">Layout</span> menu, select <span class="calibre5">Full Rect</span>. Now, duplicate this node and set the second label's <span class="calibre5">Text</span> to <span class="calibre5">Press &lt;space&gt;</span>.</p>
<p class="calibre2">For this demonstration, the <kbd class="calibre12">StartScreen</kbd> is being kept very plain. Once you have it working, feel free to add decorations, or even an <kbd class="calibre12">AnimationPlayer</kbd> to make a player Sprite run across the screen.</p>
<p class="calibre2">Choose <span class="calibre5">Scene</span> | <span class="calibre5">Save As</span> to save another copy of this scene and name it <kbd class="calibre12">EndScreen</kbd>. Delete the second <kbd class="calibre12">Label</kbd> (the one that says <span class="calibre5">Press &lt;space&gt;</span>) and add a <kbd class="calibre12">Timer</kbd> node. Set the <span class="calibre5">Autostart</span> property to <span class="calibre5">On</span>, <span class="calibre5">One Shot</span> to <span class="calibre5">On</span>, and <span class="calibre5">Wait Time</span> to <kbd class="calibre12">3</kbd>.</p>
<p class="calibre2">The <kbd class="calibre12">Timer</kbd> will send the game back to the <kbd class="calibre12">StartScreen</kbd> after it expires.</p>
<p class="calibre2">However, before you can connect these other scenes together, you need to understand how to work with persistent data and <em class="calibre17">Autoloads</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Globals</h1>
                </header>
            
            <article>
                
<p class="calibre2">It is a very common scenario in game development that you have some data that needs to persist across multiple scenes. Data that is part of a scene is lost when the scene is switched, so persistent data must reside somewhere outside the current scene.</p>
<p class="calibre2">Godot solves this problem with the use of AutoLoads. These are scripts or nodes that are automatically loaded in every scene. Because Godot does not support global variables, an autoload acts like a <em class="calibre17">Singleton.</em> This is a node (with attached script) that is automatically loaded in <em class="calibre17">every</em> scene. Common uses for AutoLoads include storing global data (score, player data, and so on), handling scene switching functions, or any other functions that need to be independent of the currently running scene.</p>
<div class="packt_infobox"><strong class="calibre1">Singleton</strong> is a well-known pattern in programming which describes a class that only allows for a single instance of itself, and provides direct access to its member variables and functions. In game development, it is often used for persistent data that needs to be accessible by various parts of the game.</div>
<p class="calibre2">When deciding if you need a singleton, ask yourself whether the object or data needs to <em class="calibre17">always</em> exist and if there will always be <em class="calibre17">only one</em> instance of that object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Global script</h1>
                </header>
            
            <article>
                
<p class="calibre2">First, make a new script by clicking <span class="calibre5">File</span> | <span class="calibre5">New</span> in the <span class="calibre5">Script</span> window. Make sure it inherits from <kbd class="calibre12">Node</kbd> (this is the default), and in the <kbd class="calibre12">Path</kbd> field, set the name to <kbd class="calibre12">Global.gd</kbd>. Click <span class="calibre5">Create</span> and add the following code to the new script:</p>
<pre class="calibre18">extends Node<br class="title-page-name"/><br class="title-page-name"/>var levels = ['res://levels/Level1.tscn',<br class="title-page-name"/>              'res://levels/Level2.tscn']<br class="title-page-name"/>var current_level<br class="title-page-name"/><br class="title-page-name"/>var start_screen = 'res://ui/StartScreen.tscn'<br class="title-page-name"/>var end_screen = 'res://ui/EndScreen.tscn'<br class="title-page-name"/><br class="title-page-name"/>func new_game():<br class="title-page-name"/>    current_level = -1<br class="title-page-name"/>    next_level()<br class="title-page-name"/><br class="title-page-name"/>func game_over():<br class="title-page-name"/>    get_tree().change_scene(end_screen)<br class="title-page-name"/><br class="title-page-name"/>func next_level():<br class="title-page-name"/>    current_level += 1<br class="title-page-name"/>    if current_level &gt;= Global.levels.size():<br class="title-page-name"/>        # no more levels to load :(<br class="title-page-name"/>        game_over()<br class="title-page-name"/>    else:<br class="title-page-name"/>        get_tree().change_scene(levels[current_level])</pre>
<p class="calibre2">This script provides a number of functions you'll need.</p>
<p class="calibre2">Most of the work is done by the <kbd class="calibre12">change_scene()</kbd> method of the <kbd class="calibre12">SceneTree</kbd>. The <kbd class="calibre12">SceneTree</kbd> represents the foundation of the currently running scene. When a scene is loaded or a new node is added, it becomes a member of the <kbd class="calibre12">SceneTree</kbd>. <kbd class="calibre12">change_scene()</kbd> replaces the current scene with a given one. </p>
<p class="calibre2">The <kbd class="calibre12">next_level()</kbd> function progresses through the list of levels you've made, which are listed in the <kbd class="calibre12">levels</kbd> array. If you reach the end of the list, the game ends.</p>
<p class="calibre2"><span class="calibre5">To add this script as an autoload, o</span>pen <span class="calibre5">Project Settings</span> and click on the <span class="calibre5">AutoLoad</span> tab. Click the <span class="calibre5">..</span> button next to <span class="calibre5">Path</span> and select your <kbd class="calibre12">Global.gd</kbd> script. The node <span class="calibre5">Name</span> will automatically be set to <span class="calibre5">Global</span> (this is the name you'll use to reference the node in your scripts, as shown in the following screenshot):</p>
<div class="cdpaligncenter1"><img src="assets/7d0b0839-4dd0-4f1c-9c6c-113677a7192c.png" class="calibre84"/></div>
<p class="calibre2">Now, you can access any of the global script's properties by using its name in any script across your whole game, for example, <kbd class="calibre12">Global.current_level</kbd>.</p>
<p class="calibre2">Attach the following script to the <kbd class="calibre12">StartScreen</kbd>:</p>
<pre class="calibre18">extends Control<br class="title-page-name"/><br class="title-page-name"/>func _input(event):<br class="title-page-name"/>    if event.is_action_pressed('ui_select'):<br class="title-page-name"/>        Global.new_game()</pre>
<p class="calibre2">This script waits for the spacebar to be pressed and then calls the <kbd class="calibre12">new_game()</kbd> function of <kbd class="calibre12">Global</kbd>.</p>
<p class="calibre2">Add this one to <kbd class="calibre12">EndScreen</kbd>:</p>
<pre class="calibre18">extends Control<br class="title-page-name"/><br class="title-page-name"/>func _on_Timer_timeout():<br class="title-page-name"/>    get_tree().change_scene(Global.start_screen)</pre>
<p class="calibre2">You'll also need to connect the <kbd class="calibre12">timeout</kbd> signal of <kbd class="calibre12">Timer</kbd>. To do this, you have to create the script first, then the <kbd class="calibre12">Connect</kbd> button will create the new function for you.</p>
<p class="calibre2">In the <kbd class="calibre12">Level.gd</kbd> script, you can now fill in the remaining two functions:</p>
<pre class="calibre18">func _on_Player_win():<br class="title-page-name"/>    Global.next_level()<br class="title-page-name"/> <br class="title-page-name"/>func game_over():<br class="title-page-name"/>    Global.game_over()</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Score</h1>
                </header>
            
            <article>
                
<p class="calibre2">The global singleton is a great place to keep the player's score so that it will be persistent from level to level. Start by adding a <kbd class="calibre12">var score</kbd> variable at the top of the file, and then in <kbd class="calibre12">new_game()</kbd>, add <kbd class="calibre12">score = 0</kbd>.</p>
<p class="calibre2">Now, you need to add a point whenever a coin is collected. Go to <kbd class="calibre12">Pickup.gd</kbd> and add <kbd class="calibre12">signal coin_pickup</kbd> at the top. You can emit this signal in the <kbd class="calibre12">pickup()</kbd> function:</p>
<pre class="calibre18">func pickup():<br class="title-page-name"/>    match type:<br class="title-page-name"/>        'coin':<br class="title-page-name"/>            emit_signal('coin_pickup', 1)<br class="title-page-name"/>    $CollisionShape2D.disabled = true<br class="title-page-name"/>    $Tween.start()</pre>
<p class="calibre2">The value of <kbd class="calibre12">1</kbd> is included here in case you want to later change the number of points that coins are worth, or add other objects that add different point amounts. This signal will be used to update the display, so now you can create the <kbd class="calibre12">HUD</kbd>. </p>
<p class="calibre2">Make a new scene with a <kbd class="calibre12">CanvasLayer</kbd> named <kbd class="calibre12">HUD</kbd> and save the scene. Add a <kbd class="calibre12">MarginContainer</kbd> node as a child, and under that, a <kbd class="calibre12">Label</kbd> named <kbd class="calibre12">ScoreLabel</kbd>.</p>
<p class="calibre2">Set the <kbd class="calibre12">MarginContainer</kbd> <span class="calibre5">Layout</span> to <span class="calibre5">Top Wide</span> and its four margin properties (found under <span class="calibre5">Custom Constants</span>) all to <kbd class="calibre12">20</kbd>. Add the same <span class="calibre5">Custom Font</span> properties you used before for the start and end screens, then attach a script:</p>
<pre class="calibre18">extends CanvasLayer<br class="title-page-name"/><br class="title-page-name"/>func _ready():<br class="title-page-name"/>    $MarginContainer/ScoreLabel.text = str(Global.score)<br class="title-page-name"/><br class="title-page-name"/>func update_score(value):<br class="title-page-name"/>    Global.score += value<br class="title-page-name"/>    $MarginContainer/ScoreLabel.text = str(Global.score)</pre>
<p class="calibre2">Add an instance of the <kbd class="calibre12">HUD</kbd> to the <kbd class="calibre12">Level</kbd> scene. Remember from the previous project that the <kbd class="calibre12">CanvasLayer</kbd> node will remain on top of the rest of the game. It will also ignore any camera movement, so the display will remain fixed in place as the player moves around the level.</p>
<p class="calibre2">Finally, in the <kbd class="calibre12">Level.gd</kbd> script, when you spawn a new collectible object, connect the signal to the <kbd class="calibre12">HUD</kbd> function:</p>
<pre class="calibre18">    'coin', 'key_red', 'star':<br class="title-page-name"/>        var p = Pickup.instance()<br class="title-page-name"/>        p.init(type, pos)<br class="title-page-name"/>        add_child(p)<br class="title-page-name"/>        p.connect('coin_pickup', $HUD, 'update_score')</pre>
<p class="calibre2">Run the game and collect a few coins to confirm that the score is updating.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Saving the High Score</h1>
                </header>
            
            <article>
                
<p class="calibre2">Many games require you to save some kind of information between play sessions. This is information that you want to remain available, even when the application itself has quit. Examples include saved games, user-created content, or downloadable resource packs. For this game, you'll save a High Score value that will persist across game sessions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reading and writing files</h1>
                </header>
            
            <article>
                
<p class="calibre2">As you've seen before, Godot keeps all resources stored as files in the project folder. From code, these are accessible under the <kbd class="calibre12">res://</kbd> folder path. For example, <kbd class="calibre12">res://project.godot</kbd> will always point to the current project's configuration file, no matter where on your computer the project is actually stored.</p>
<p class="calibre2">However, the <kbd class="calibre12">res://</kbd> filesystem is set as read-only for safety when the project is run. It is also read-only when the project is exported. Any data that needs to be retained by the user is placed in the <kbd class="calibre12">user://</kbd> file path. Where this folder physically exists will vary depending on what platform the game is running on.</p>
<div class="packt_infobox">You can find the current platform's user-writable data folder using <kbd class="calibre13"><span>OS.get_user_data_dir()</span></kbd>. Add a <kbd class="calibre13">print()</kbd> statement to the <kbd class="calibre13">ready()</kbd> function of one of your scripts to see what the location is on your system.</div>
<p class="calibre2">Reading and writing to files is accomplished using a <kbd class="calibre12">File</kbd> object. This object is used to open the file in read and/or write mode, and can also be used to test for a file's existence.</p>
<p class="calibre2">Add the following code to <kbd class="calibre12">Global.gd</kbd>:</p>
<pre class="calibre18">var highscore = 0<br class="title-page-name"/>var score_file = "user://highscore.txt"<br class="title-page-name"/><br class="title-page-name"/>func setup():<br class="title-page-name"/>    var f = File.new()<br class="title-page-name"/>    if f.file_exists(score_file):<br class="title-page-name"/>        f.open(score_file, File.READ)<br class="title-page-name"/>        var content = f.get_as_text()<br class="title-page-name"/>        highscore = int(content)<br class="title-page-name"/>        f.close()</pre>
<p class="calibre2">You first need to test whether the file exists. If it does, you can read the value, which is being stored as human-readable text, and assign it to the <kbd class="calibre12">highscore</kbd> variable. Binary data can also be stored in files, if needed, but text will allow you to look at the file yourself and check that everything is working.</p>
<p class="calibre2">Add the following code to check if the player has beat the previous high score:</p>
<pre class="calibre18">func game_over():<br class="title-page-name"/>    if score &gt; highscore:<br class="title-page-name"/>        highscore = score<br class="title-page-name"/>        save_score()<br class="title-page-name"/>    get_tree().change_scene(end_screen)<br class="title-page-name"/><br class="title-page-name"/>func save_score():<br class="title-page-name"/>    var f = File.new()<br class="title-page-name"/>    f.open(score_file, File.WRITE)<br class="title-page-name"/>    f.store_string(str(highscore))<br class="title-page-name"/>    f.close()</pre>
<p class="calibre2">The <kbd class="calibre12">save_score()</kbd> function opens the file to write the new value. Note that if the file doesn't exist, opening in <kbd class="calibre12">WRITE</kbd> mode will automatically create it.</p>
<p class="calibre2">Next, you need to call the <kbd class="calibre12">setup()</kbd> function when the game starts, so add this to <kbd class="calibre12">Global.gd</kbd>:</p>
<pre class="calibre18">func _ready():<br class="title-page-name"/>    setup()</pre>
<p class="calibre2">Finally, to display the high score, add another <kbd class="calibre12">Label</kbd> node to the <kbd class="calibre12">StartScreen</kbd> scene (you can duplicate one of the existing ones). Arrange it below the other Labels (or in whatever order you like) and name it <kbd class="calibre12">ScoreNotice</kbd>. Add the following to the script:</p>
<pre class="calibre18">func _ready():<br class="title-page-name"/>    $ScoreNotice.text = "High Score: " + str(Global.highscore)</pre>
<p class="calibre2">Run the game and check that your high score is increasing (when you beat it) and persisting when you quit and start the game again.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Finishing touches</h1>
                </header>
            
            <article>
                
<p class="calibre2">Now that the main functionality of the game is complete, you can add a few more features to polish it up a little bit.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Death animation</h1>
                </header>
            
            <article>
                
<p class="calibre2">When the enemy hits the player, you can add a small animation rather than just ending the game. The effect will spin the character around while shrinking its scale property.</p>
<p class="calibre2">Start by selecting the <kbd class="calibre12">AnimationPlayer</kbd> node of the <kbd class="calibre12">Player</kbd> and clicking the <span class="calibre5">New Animation</span> button: <img src="assets/43736d1e-91f9-4bab-9b99-30f52c2b3ae9.png" class="calibre85"/>. Name the new animation <kbd class="calibre12">die</kbd>.</p>
<p class="calibre2">In this animation, you'll be animating the Sprite's <span class="calibre5">Rotation Degrees</span> and <span class="calibre5">Scale</span> properties. Find the <span class="calibre5">Rotation Degrees</span> property in the <span class="calibre5">Inspector</span> and click the key, <img src="assets/7c017716-79c1-4a44-ad13-8312736b4175.png" class="calibre85"/>, <span class="calibre5">to add a track. Move the scrubber to the end of the animation, change <span class="calibre5">Rotation Degrees</span> to <span class="calibre5">360</span>, and click the key again. Try playing the animation to see the character spin.</span></p>
<div class="packt_tip">Keep in mind that while degrees are typically used for Inspector properties, when writing code most Godot functions expect angles to be measured in <em class="calibre20">radians</em>.</div>
<p class="calibre2">Now, do the same thing with the <em class="calibre17">Scale</em> property. Add a keyframe (at the beginning!) for <kbd class="calibre12">(1, 1)</kbd> and then another at the end with the scale set to <kbd class="calibre12">(0.2, 0.2)</kbd>. Try playing the animation again to see the results.</p>
<p class="calibre2">The new animation needs to be triggered when the player hits an enemy. Add the following code to the player's <kbd class="calibre12">_on_Player_area_entered()</kbd> function:</p>
<pre class="calibre18">if area.is_in_group('enemies'):<br class="title-page-name"/>    area.hide()<br class="title-page-name"/>    set_process(false)<br class="title-page-name"/>    $CollisionShape2D.disabled = true<br class="title-page-name"/>    $AnimationPlayer.play("die")<br class="title-page-name"/>    yield($AnimationPlayer, 'animation_finished')<br class="title-page-name"/>    emit_signal('dead')</pre>
<p class="calibre2">The added code takes care of a few things that need to happen. First, hiding the enemy that was hit makes sure that it doesn't cover the player and prevent you from seeing our new animation. Next, you use <kbd class="calibre12">set_process(false)</kbd> to stop the <kbd class="calibre12">_process()</kbd> function from running so that the player can't keep moving during the animation. You also need to disable the player's collision detection so that it doesn't detect another enemy if it happens to wander by.</p>
<p class="calibre2">After starting the <kbd class="calibre12">die</kbd> animation, you need to let it finish before emitting the <kbd class="calibre12">dead</kbd> signal, so <kbd class="calibre12">yield</kbd> is used to wait for the signal from <kbd class="calibre12">AnimationPlayer</kbd>.</p>
<p class="calibre2">Try running the game and getting hit by an enemy to see the animation. If everything works fine, you'll notice something wrong on the next playthrough: the player is tiny! The animation ends with the Sprite's <span class="calibre5">Scale</span> set to <kbd class="calibre12">(0.2, 0.2)</kbd> and nothing is setting it back to normal size. Add the following to the Player's script so that the scale will always start at the right value:</p>
<pre class="calibre18">func _ready():<br class="title-page-name"/>    $Sprite.scale = Vector2(1, 1)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sound effects</h1>
                </header>
            
            <article>
                
<p class="calibre2">There are six sound effects in the <kbd class="calibre12">res://assets/audio</kbd> folder for you to use in the game. These audio files are in OGG format. By default, Godot sets OGG files to loop when imported. Select the OGG files in the <span class="calibre5">FileSystem</span> tab (you can use <em class="calibre17">Shift</em> + Click to select multiple files) and click the <span class="calibre5">Import</span> tab on the right-hand side of the editor window. Uncheck <span class="calibre5">Loop</span> and click the <span class="calibre5">Reimport</span> button:</p>
<div class="cdpaligncenter1"><img src="assets/cd3adef3-f21b-4fec-b70a-b88ca4926069.png" class="calibre86"/></div>
<p class="calibre2">First, add the pickup sounds for the items. Add two <kbd class="calibre12">AudioStreamPlayer</kbd> nodes to the <kbd class="calibre12">Pickup</kbd> scene and name them <kbd class="calibre12">KeyPickup</kbd> and <kbd class="calibre12">CoinPickup</kbd>. Drag the corresponding audio file into the <span class="calibre5">Stream</span> property of each node.</p>
<p class="calibre2">You can also adjust the sound's volume via its <span class="calibre5">Volume Db</span> property, as shown in the following screenshot:</p>
<div class="cdpaligncenter1"><img src="assets/a84abf45-bf1d-4dcd-9ebc-fbc9d34376c2.png" class="calibre87"/></div>
<p class="calibre2">Add the following code to the beginning of the <kbd class="calibre12">pickup()</kbd> function:</p>
<pre class="calibre18">match type:<br class="title-page-name"/>    'coin':<br class="title-page-name"/>        emit_signal('coin_pickup', 1)<br class="title-page-name"/>        $CoinPickup.play()<br class="title-page-name"/>    'key_red':<br class="title-page-name"/>        $KeyPickup.play()</pre>
<p class="calibre2">The other sound effects will be added to the <kbd class="calibre12">Player</kbd> scene. Add three of the <kbd class="calibre12">AudioStreamPlayer</kbd> and name them <kbd class="calibre12">Win</kbd>, <kbd class="calibre12">Lose</kbd>, and <kbd class="calibre12">Footsteps</kbd>, adding the matching sound file to each node's <span class="calibre5">Stream</span>. Update the <kbd class="calibre12">_on_Player_area_entered()</kbd> function as follows:</p>
<pre class="calibre18">    if area.type == 'star':<br class="title-page-name"/>        $Win.play()<br class="title-page-name"/>        $CollisionShape2D.disabled = true<br class="title-page-name"/>        yield($Win, "finished")<br class="title-page-name"/>        emit_signal('win')</pre>
<p class="calibre2">You need to disable the collision and <kbd class="calibre12">yield</kbd> for the sound to finish, or else it would be instantly terminated by the next level loading. This way, the player has time to hear the sound before moving on.</p>
<p class="calibre2">To play the footsteps, add <kbd class="calibre12">$Footsteps.play()</kbd> after <kbd class="calibre12">if move(dir):</kbd> in the <kbd class="calibre12">_process()</kbd> function. Note: you may want to reduce the sound of the footsteps so that they don't overwhelm everything; they should be subtle background sounds. In the <kbd class="calibre12">Footsteps</kbd> node, set the <span class="calibre5">Volume Db</span> property to <kbd class="calibre12">-30</kbd>.</p>
<p class="calibre2">Finally, to play the <kbd class="calibre12">Lose</kbd> sound, add it to the enemy collision code here:</p>
<pre class="calibre18"><br class="title-page-name"/>if area.is_in_group('enemies'):<br class="title-page-name"/>    area.hide()<br class="title-page-name"/>    $CollisionShape2D.disabled = true<br class="title-page-name"/>    set_process(false)<br class="title-page-name"/>    $Lose.play()<br class="title-page-name"/>    $AnimationPlayer.play("die")<br class="title-page-name"/>    yield($Lose, 'finished')<br class="title-page-name"/>    emit_signal('dead')</pre>
<p class="calibre2">Note that you need to change the yield function. Since the sound is slightly longer than the animation, it will get cut off if you end it on the animation's completion. Alternatively, you could adjust the duration of the animation to match the length of the sound.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="calibre2">In this project, you have learned how to take advantage of Godot's inheritance system to organize and share code between different objects in your game. This is a very powerful tool that you should keep in mind whenever you start building a new game. If you start making multiple objects that repeat the same properties and/or code, you should probably stop and think about what you're doing. Ask yourself: <em class="calibre17">can I use inheritance here to share what these objects have in common?</em> In a bigger game with many more objects, this can save you a large amount of time.</p>
<p class="calibre2">You saw how the <kbd class="calibre12">TileMap</kbd> node works and how it allows you to quickly design maps and spawn new objects. They have many uses across many game genres. As you'll see later in this book, TileMaps are also ideal for designing platform game levels as well.</p>
<p class="calibre2">You were also introduced to the <em class="calibre17">AutoLoad</em> feature, which allows you to create a global script that contains persistent data used across multiple scenes. You also learned how to implement grid-based movement and used the <kbd class="calibre12">AnimationPlayer</kbd> to work with spritesheet animations.</p>
<p class="calibre2">In the next chapter, you'll learn about Godot's powerful physics body: the <kbd class="calibre12">RigidBody2D</kbd>. You'll use it to create a game in a classic genre: the space shooter.</p>


            </article>

            
        </section>
    </body></html>