- en: Managing Strings
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理字符串
- en: Strings are nothing but arrays that store characters. Since strings are character
    arrays, they utilize less memory and lead to efficient object code, making programs
    run faster. Just like numerical arrays, strings are zero-based, that is, the first
    character is stored at index location 0\. In C, strings are terminated by a null
    character, `\0`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串不过是存储字符的数组。由于字符串是字符数组，它们占用的内存较少，导致代码更高效，使程序运行更快。就像数值数组一样，字符串也是零基的，也就是说，第一个字符存储在索引位置0。在C语言中，字符串由一个空字符`\0`终止。
- en: The recipes in this chapter will enhance your understanding of strings and will
    acquaint you with string manipulation. Strings play a major role in almost all
    applications. You will learn how to search strings (which is a very common task),
    replace a string with another string, search for a string that contains a specific
    pattern, and more.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的菜谱将增强您对字符串的理解，并使您熟悉字符串操作。字符串在几乎所有应用程序中都发挥着重要作用。您将学习如何搜索字符串（这是一个非常常见的任务），用另一个字符串替换字符串，搜索包含特定模式的字符串，等等。
- en: 'In this chapter, you will learn how to create the following recipes using strings:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用字符串创建以下菜谱：
- en: Determining whether the string is a palindrome
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 判断字符串是否是回文
- en: Finding the occurrence of the first repetitive character in a string
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找字符串中第一个重复字符的出现
- en: Displaying the count of each character in a string
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示字符串中每个字符的计数
- en: Counting the vowels and consonants in a string
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算字符串中的元音和辅音数量
- en: Converting the vowels in a sentence to uppercase
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将句子中的元音字母转换为大写
- en: Determining whether the string is a palindrome
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 判断字符串是否是回文
- en: A palindrome is a string that reads the same regardless of whether it is in
    a forward or backwards order. For example, the word <q>radar</q> is a palindrome
    because it reads the same way forwards and backwards.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 回文是一种无论正向还是反向阅读都相同的字符串。例如，单词“radar”是回文，因为它正向和反向阅读都相同。
- en: How to do it…
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Define two 80-character strings called `str` and `rev`(assuming your string
    will not exceed 79 characters). Your string can be of any length, but remember
    that the last position in the string is fixed for the null character `\0`:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个名为`str`和`rev`的80字符字符串（假设您的字符串不会超过79个字符）。您的字符串可以是任何长度，但请记住，字符串的最后一个位置是用于空字符`\0`的固定位置：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Enter characters that will be assigned to the `str` string:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入将被分配给`str`字符串的字符：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Compute the length of the string using the `strlen` function and assign this
    to the `n` variable:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`strlen`函数计算字符串的长度，并将其赋值给`n`变量：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Execute a `for` loop in reverse order to access the characters in the `str` string
    in reverse order, and then assign them to the `rev` string:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`for`循环以逆序执行，以逆序访问`str`字符串中的字符，然后将它们赋值给`rev`字符串：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Compare the two strings, `str` and `rev`, using `strcmp`:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`strcmp`比较两个字符串，`str`和`rev`：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If `str` and `rev` are the same, then the string is a palindrome.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`str`和`rev`相同，则该字符串是回文。
- en: In C, the functionality of specific built-in functions is specified in the respective
    libraries, also known as header files. So, while writing C programs, whenever
    built-in functions are used, we need to use their respective header files in the
    program at the top. The header files usually have the extension `.h`. In the following
    program, I am using a built-in function called `strlen`, which finds out the length
    of a string. Therefore, I need to use its library, `string.h`, in the program.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，特定内置函数的功能在相应的库中指定，也称为头文件。因此，在编写C程序时，每当使用内置函数时，我们都需要在程序顶部使用它们各自的头文件。头文件通常具有`.h`扩展名。在以下程序中，我使用了一个名为`strlen`的内置函数，该函数用于找出字符串的长度。因此，我需要在程序中使用其库，即`string.h`。
- en: 'The `palindrome.c` program for finding out whether the specified string is
    a palindrome is as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 用于找出指定字符串是否为回文的`palindrome.c`程序如下：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以便更好地理解。
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To ensure that a string is a palindrome, we first need to ensure that the original
    string and its reverse form are of the same length.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保字符串是回文，我们首先需要确保原始字符串及其逆序形式长度相同。
- en: 'Let''s suppose that the original string is `sanjay` and it is assigned to a
    string variable, `str`. The string is a character array, where each character
    is stored individually as an array element and the last element in the string
    array is a null character. The null character is represented as `\0` and is always
    the last element in a string variable in C, as shown in the following diagram:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 假设原始字符串是`sanjay`，并将其分配给字符串变量`str`。该字符串是一个字符数组，其中每个字符都作为数组元素单独存储，字符串数组中的最后一个元素是空字符。空字符表示为`\0`，在C语言中，它总是字符串变量的最后一个元素，如下面的图所示：
- en: '![](img/2aaf2b32-6c6a-4fa7-83b5-fe74e54f4f1f.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2aaf2b32-6c6a-4fa7-83b5-fe74e54f4f1f.png)'
- en: Figure 2.1
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1
- en: As you can see, the string uses zero-based indexing, that is, the first character
    is placed at index location **str[0]**, followed by the second character at **str[1]**,
    and so on. In regards to the last element, the null character is at **str[6]**.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，字符串使用基于零的索引，即第一个字符位于索引位置**str[0]**，其次是**str[1]**，依此类推。至于最后一个元素，空字符位于**str[6]**。
- en: Using the `strlen` library function, we will compute the length of the entered
    string and assign it to the `n` variable. By executing the `for` loop in reverse
    order, each of the characters of the `str` string is accessed in reverse order, that
    is, from `n-1` to `0`, and assigned to the `rev` string.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`strlen`库函数，我们将计算输入字符串的长度并将其赋值给`n`变量。通过以相反的顺序执行`for`循环，`str`字符串的每个字符都将以相反的顺序访问，即从`n-1`到`0`，并赋值给`rev`字符串。
- en: 'Finally, a null character, `\0`, is added to the `rev` string to make it a
    complete string. Therefore, `rev` will contain the characters of the `str` string,
    but in reverse order:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，向`rev`字符串添加一个空字符`\0`以使其成为一个完整的字符串。因此，`rev`将包含`str`字符串中的字符，但顺序相反：
- en: '![](img/a7a0a89b-9dc0-4206-b0ec-f5453f69dc8f.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a7a0a89b-9dc0-4206-b0ec-f5453f69dc8f.png)'
- en: Figure 2.2
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2
- en: Next, we will run the `strcmp` function. If the function returns `0`, it means
    that the content in the `str` and `rev` strings is exactly the same, which means
    that `str` is a palindrome. If the `strcmp` function returns a value other than
    `0`, it means that the two strings are not the same; hence, `str` is not a palindrome.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将运行`strcmp`函数。如果函数返回`0`，则表示`str`和`rev`字符串中的内容完全相同，这意味着`str`是一个回文。如果`strcmp`函数返回除`0`以外的值，则表示两个字符串不相同；因此，`str`不是一个回文。
- en: 'Let''s use GCC to compile the `palindrome.c` program, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC编译`palindrome.c`程序，如下所示：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let''s run the generated executable file, `palindrome.exe`, to see the
    output of the program:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行生成的可执行文件`palindrome.exe`以查看程序的输出：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, suppose that `str` is assigned another character string, `sanas`. To ensure
    that the word in `str` is a palindrome, we will again reverse the character order
    in the string.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设`str`被分配了另一个字符字符串`sanas`。为了确保`str`中的单词是一个回文，我们将再次在字符串中反转字符顺序。
- en: 'So, once more, we will compute the length of `str`, execute a `for` loop in
    reverse order, and access and assign each character in `str` to `rev`. The null
    character `\0` will be assigned to the last location in `rev`, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，再次计算`str`的长度，以相反的顺序执行`for`循环，并将`str`中的每个字符访问并赋值给`rev`。空字符`\0`将被赋值给`rev`中的最后一个位置，如下所示：
- en: '![](img/37238779-7e1d-4444-b977-10afa6261665.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/37238779-7e1d-4444-b977-10afa6261665.png)'
- en: Figure 2.3
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3
- en: Finally, we will invoke the `strcmp` function again and supply both strings.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将再次调用`strcmp`函数并传递两个字符串。
- en: 'After compiling, let''s run the program again with the new string:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，让我们用新的字符串再次运行程序：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Voilà! We have successfully identified whether our character strings are palindromes.
    Now, let's move on to the next recipe!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功识别出我们的字符字符串是否是回文。现在，让我们继续下一个菜谱！
- en: Finding the occurrence of the first repetitive character in a string
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在字符串中查找第一个重复字符的出现
- en: In this recipe, you will learn how to create a program that displays the first
    character to be repeated in a string. For example, if you enter the string `racecar`,
    the program should give the output as The first repetitive character in the string
    racecar is c. The program should display No character is repeated in the string
    if a string with no repetitive characters is entered.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何创建一个显示字符串中第一个重复字符的程序。例如，如果你输入字符串`racecar`，程序应该输出“The first repetitive
    character in the string racecar is c.”。如果输入没有重复字符的字符串，程序应显示“No character is repeated
    in the string”。
- en: How to do it…
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Define two strings called `str1` and `str2`. Your strings can be of any length,
    but the last position in the string is fixed for the null character `\0`:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个名为`str1`和`str2`的字符串。您的字符串可以是任何长度，但字符串的最后一个位置是固定的，用于空字符`\0`：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Enter characters to be assigned to `str1`. The characters will be assigned
    to the respective index locations of the string, beginning with `str1[0]`:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入要分配给`str1`的字符。这些字符将被分配到字符串的相应索引位置，从`str1[0]`开始：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Compute the length of `str1` using the `strlen` library function. Here, the
    first character of `str1` is assigned to `str2`:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`strlen`库函数计算`str1`的长度。在这里，`str1`的第一个字符被分配给`str2`：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Use a `for` loop to access all of the characters of `str1` one by one and pass
    them to the `ifexists` function to check whether that character already exists
    in `str2`. If the character is found in `str2`, this means it is the first repetitive
    character of the string, and so it is displayed on the screen:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`for`循环逐个访问`str1`中的所有字符，并将它们传递给`ifexists`函数以检查该字符是否已存在于`str2`中。如果字符在`str2`中找到，这意味着它是字符串的第一个重复字符，因此将在屏幕上显示：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the character of `str1` does not exist in `str2`, then it is simply added
    to `str2`:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`str1`中的字符不在`str2`中，则直接将其添加到`str2`中：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `repetitive.c` program for finding the occurrence of the first repetitive
    character in a string is as follows::'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找字符串中第一个重复字符的`repetitive.c`程序如下所示：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's assume that we have defined a string, **str1**, of some length, and have entered
    the following characters—`racecar`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经定义了一个长度为某个值的字符串**str1**，并输入了以下字符——`racecar`。
- en: 'Each of the characters of the string `racecar` will be assigned to the respective
    index locations of **str1**, that is, **r** will be assigned to **str1[0]**, **a** will
    be assigned to **str1[1]**, and so on. Because every string in C is terminated
    by a null character, **\0**, the last index location of **str1** will have the
    null character **\0**, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串`racecar`中的每个字符都将被分配到**str1**的相应索引位置，即**r**将被分配给**str1[0]**，**a**将被分配给**str1[1]**，依此类推。因为C语言中的每个字符串都以空字符**\0**结束，所以**str1**的最后一个索引位置将包含空字符**\0**，如下所示：
- en: '![](img/a53be31c-4dc7-401f-a4c8-c813a97bd512.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a53be31c-4dc7-401f-a4c8-c813a97bd512.png)'
- en: Figure 2.4
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4
- en: 'Using the library function `strlen`, the length of **str1** is computed and
    a `for` loop is used to access all of the characters of **str1**, one by one,
    except for the first character. The first character is already assigned to **str2**,
    as shown in the following diagram:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用库函数`strlen`计算**str1**的长度，并使用`for`循环逐个访问**str1**中的所有字符，除了第一个字符。第一个字符已经分配给**str2**，如下所示：
- en: '![](img/8677c107-a788-444e-8609-403e58801f13.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8677c107-a788-444e-8609-403e58801f13.png)'
- en: Figure 2.5
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5
- en: Each character that is accessed from **str1** is passed through the `ifexists`
    function. The `ifexists` function will check whether the supplied character already
    exists in **str2** and will return a Boolean value accordingly. The function returns
    `1`, that is, `true`, if the supplied character is found in **str2**. The function
    returns `0`, that is, `false`, if the supplied character is not found in **str2**.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从**str1**访问的每个字符都会通过`ifexists`函数。`ifexists`函数将检查提供的字符是否已存在于**str2**中，并相应地返回布尔值。如果提供的字符在**str2**中找到，函数返回`1`，即`true`。如果提供的字符在**str2**中未找到，函数返回`0`，即`false`。
- en: If `ifexists` returns `1`, this means that the character is found in **str2**,
    and hence, the first repetitive character of the string is displayed on the screen.
    If the `ifexists` function returns `0`, this means that the character does not
    exist in **str2**, so it is simply added to **str2** instead.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`ifexists`返回`1`，这意味着字符在**str2**中找到，因此，字符串的第一个重复字符将显示在屏幕上。如果`ifexists`函数返回`0`，这意味着字符不在**str2**中，因此简单地将其添加到**str2**中。
- en: 'Since the first character is already assigned, the second character of **str1** is
    picked up and checked to see if it already exists in **str2**. Because the second
    character of **str1** does not exist in **str2**, it is added to the latter string,
    as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于第一个字符已经被分配，因此**str1**的第二个字符被拾取并检查是否已存在于**str2**中。因为**str1**的第二个字符不在**str2**中，所以它被添加到后面的字符串中，如下所示：
- en: '![](img/140272d2-e83c-4bbd-a4e9-44b5bb766832.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/140272d2-e83c-4bbd-a4e9-44b5bb766832.png)'
- en: Figure 2.6
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6
- en: The procedure is repeated until all of the characters of **str1** are accessed.
    If all the characters of **str1** are accessed and none of them are found to exist
    in **str2**, this means that all of the characters in **str1** are unique and
    none of them are repeated.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程会重复进行，直到访问到**str1**中的所有字符。如果访问到**str1**中的所有字符，并且它们都没有在**str2**中找到，这意味着**str1**中的所有字符都是唯一的，没有重复。
- en: 'The following diagram shows strings **str1** and **str2** after accessing the
    first four characters of **str1**. You can see that the four characters are added
    to **str2**, since none of them already exist in **str2**:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了访问**str1**的前四个字符后的字符串**str1**和**str2**。你可以看到这四个字符被添加到**str2**中，因为它们都不存在于**str2**中：
- en: '![](img/fca13334-d7d4-4cd5-9d2e-831a2edc7094.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fca13334-d7d4-4cd5-9d2e-831a2edc7094.png)'
- en: Figure 2.7
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/fca13334-d7d4-4cd5-9d2e-831a2edc7094.png)'
- en: 'The next character to be accessed from **str1** is **c**. Before adding it
    to **str2**, it is compared with all the existing characters of **str2** to determine
    if it already exists there. Because the **c** character already exists in **str2**,
    it is not added to **str2** and is declared as the first repeating character in **str1**,
    as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个要从**str1**中访问的字符是**c**。在将其添加到**str2**之前，它将与**str2**中所有现有的字符进行比较，以确定它是否已经存在那里。因为**c**字符已经存在于**str2**中，所以它不会被添加到**str2**中，并声明为**str1**中的第一个重复字符，如下所示：
- en: '![](img/21e48650-c9e3-4b3f-9b5f-942f97dc5147.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/21e48650-c9e3-4b3f-9b5f-942f97dc5147.png)'
- en: Figure 2.8
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8
- en: 'Let''s use GCC to compile the `repetitive.c` program, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC编译`repetitive.c`程序，如下所示：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s run the generated executable file, `repetitive.exe`, to see the output
    of the program:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行生成的可执行文件`repetitive.exe`，以查看程序的输出：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s run the program again:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行程序：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Voilà! We've successfully found the first repeating character in a string.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功找到了字符串中的第一个重复字符。
- en: Now, let's move on to the next recipe!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个菜谱！
- en: Displaying the count of each character in a string
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示字符串中每个字符的计数
- en: In this recipe, you will learn how to create a program that displays the count
    of each character in a string in a tabular form.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何创建一个程序，该程序以表格形式显示字符串中每个字符的计数。
- en: How to do it…
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Create a string called `str`. The last element in the string will be a null
    character, `\0`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`str`的字符串。字符串的最后一个元素将是一个空字符，`\0`。
- en: 'Define another string called `chr` of matching length, to store the characters
    of `str`:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义另一个与`str`长度匹配的字符串`chr`，用于存储`str`中的字符：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Prompt the user to enter a string. The entered string will be assigned to the
    `str` string:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提示用户输入一个字符串。输入的字符串将被分配给`str`字符串：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Compute the length of the string array, `str`, using `strlen`:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`strlen`计算字符串数组`str`的长度：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Define an integer array called `count` to display the number of times the characters
    have occurred in `str`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `count` 的整数数组，用于显示字符在 `str` 中出现的次数：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Execute `chr[0]=str[0]` to assign the first character of `str` to `chr` at index
    location `chr[0]`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`chr[0]=str[0]`将`str`的第一个字符分配给`chr`的索引位置`chr[0]`。
- en: 'The count of the character that''s assigned in the `chr[0]` location is represented
    by assigning `1` at the `count[0]` index location:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配在`chr[0]`位置的字符的计数通过在`count[0]`索引位置分配`1`来表示：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run a `for` loop to access each character in `str`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行一个`for`循环以访问`str`中的每个字符：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run the `ifexists` function to find out whether the character of `str` exists
    in the `chr` string or not. If the character does not exist in the `chr` string,
    it is added to the `chr` string at the next index location and the respective
    index location in the `count` array is set to `1`:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`ifexists`函数以确定`str`中的字符是否存在于`chr`字符串中。如果字符不在`chr`字符串中，它将被添加到`chr`字符串的下一个索引位置，并且相应的索引位置在`count`数组中被设置为`1`：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If the character exists in the `chr` string, the value in the respective index
    location in the `count` array is incremented by `1` in the `ifexists` function.
    The `p` and `q` arrays in the following snippet represent the `chr` and `count`
    arrays, respectively, since the `chr` and `count` arrays are passed and assigned
    to the `p` and `q` parameters in the `ifexists` function:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果字符存在于`chr`字符串中，`ifexists`函数中将相应索引位置的`count`数组值增加`1`。以下片段中的`p`和`q`数组分别代表`chr`和`count`数组，因为`chr`和`count`数组在`ifexists`函数中传递并分配给`p`和`q`参数：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `countofeach.c` program for counting each character in a string is as follows::'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 用于计算字符串中每个字符的`countofeach.c`程序如下所示：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's assume that the two string variables you have defined, `str` and `chr`,
    are of the size `80` (you can always increase the size of the strings if you wish).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您定义的两个字符串变量，`str` 和 `chr`，大小为 `80`（如果您愿意，您可以始终增加字符串的大小）。
- en: 'We will assign the character string `racecar` to the **str** string. Each of
    the characters will be assigned to the respective index locations of **str**,
    that is, **r** will be assigned to index location **str[0]**, **a** will be assigned
    to **str[1]**, and so on. As always, the last element in the string will be a
    null character, as shown in the following diagram:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将字符串 `racecar` 赋值给 **str** 字符串。每个字符都将被分配到 **str** 的相应索引位置，即 **r** 将被分配到索引位置
    **str[0]**，**a** 将被分配到 **str[1]**，以此类推。一如既往，字符串的最后一个元素将是一个空字符，如下面的图所示：
- en: '![](img/f1b5fcb8-68e7-4ec3-b85d-b03b2de4f5d4.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1b5fcb8-68e7-4ec3-b85d-b03b2de4f5d4.png)'
- en: Figure 2.9
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9
- en: Using the `strlen` function,  we will first compute the length of the string.
    Then, we will use the string array **chr** for storing characters of the **str** array
    individually at each index location. We will execute a `for` loop beginning from `1` until
    the end of the string to access each character of the string.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `strlen` 函数，我们首先计算字符串的长度。然后，我们将使用字符串数组 **chr** 在每个索引位置单独存储 **str** 数组中的字符。我们将从
    `1` 开始执行一个循环，直到字符串的末尾，以访问字符串中的每个字符。
- en: 'The integer array we defined earlier, that is, **count**, will represent the
    number of times the characters from **str** have occurred, which is represented
    by the index locations in the **chr** array. That is, if **r** is at index location **chr[0]**,
    then **count[0]** will contain an integer value (1, in this case) to represent
    the number of times the **r** character has occurred in the **str** string so
    far:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前定义的整数数组，即 **count**，将表示 **str** 中字符出现的次数，这由 **chr** 数组中的索引位置表示。也就是说，如果 **r**
    在索引位置 **chr[0]**，那么 **count[0]** 将包含一个整数值（在这种情况下为 1），以表示到目前为止在 **str** 字符串中 **r**
    字符出现的次数：
- en: '![](img/a4dbe424-fd90-4f6b-8531-8bd791acd604.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a4dbe424-fd90-4f6b-8531-8bd791acd604.png)'
- en: Figure 2.10
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10
- en: 'One of the following actions will be applied to every character that''s accessed
    from the string:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下操作之一将应用于从字符串中访问的每个字符：
- en: If the character exists in the **chr** array, the value in the respective index
    location in the **count** array is incremented by 1\. For example, if the character
    of the string is found at the **chr[2]** index location, then the value in the
    **count[2]** index location is incremented by 1.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果字符存在于 **chr** 数组中，则 **count** 数组中相应索引位置上的值增加 1。例如，如果字符串中的字符在 **chr[2]** 索引位置找到，那么
    **count[2]** 索引位置上的值增加 1。
- en: If the character does not exist in the **chr** array, it is added to the **chr**
    array at the next index location, and the respective index location is found when
    the count array is set to **1**. For example, if the character **a** is not found
    in the **chr** array, it is added to the **chr** array at the next available index
    location. If the character **a** is added at the **chr[1]** location, then a value
    of **1** is assigned at the **count[1]** index location to indicate that the character
    shown in **chr[1]** has appeared once up until now.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果字符不在 **chr** 数组中，它将被添加到 **chr** 数组的下一个索引位置，并且当计数数组设置为 **1** 时找到相应的索引位置。例如，如果字符
    **a** 在 **chr** 数组中没有找到，它将被添加到下一个可用的索引位置。如果字符 **a** 被添加到 **chr[1]** 位置，那么在 **count[1]**
    索引位置将分配一个值 **1**，以指示到目前为止在 **chr[1]** 中显示的字符出现了一次。
- en: When the `for` loop completes, that is when all of the characters in the string
    are accessed. The `chr` array will have individual characters of the string and
    the `count` array will have the count, or the number of times the characters represented
    by the `chr` array have occurred in the string. All of the elements in the `chr`
    and `count` arrays are displayed on the screen.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `for` 循环完成后，即当访问了字符串中的所有字符时。`chr` 数组将包含字符串的各个字符，而 `count` 数组将包含计数，即 `chr`
    数组表示的字符在字符串中出现的次数。`chr` 和 `count` 数组中的所有元素都将在屏幕上显示。
- en: 'Let''s use GCC to compile the `countofeach.c` program, as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GCC 编译 `countofeach.c` 程序，如下所示：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s run the generated executable file, `countofeach.exe`, to see the output
    of the program:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行生成的可执行文件，`countofeach.exe`，以查看程序的输出：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s try another character string to test the results:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试另一个字符串来测试结果：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Voilà! We've successfully displayed the count of each character in a string.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功显示了字符串中每个字符的计数。
- en: Now, let's move on to the next recipe!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个菜谱！
- en: Counting vowels and consonants in a sentence
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算句子中的元音和辅音
- en: 'In this recipe, you will learn how to count the number of vowels and consonants
    in an entered sentence. The vowels are *a*, *e*, *i*, *o*, and *u*, and the rest
    of the letters are consonants. We will use ASCII values to identify the letters
    and their casing:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何计算输入句子中的元音和辅音数量。元音是*a*、*e*、*i*、*o*和*u*，其余的字母都是辅音。我们将使用ASCII值来识别字母及其大小写：
- en: '![](img/a98a0004-673a-4c79-9588-eecdfc52c99a.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a98a0004-673a-4c79-9588-eecdfc52c99a.png)'
- en: Figure 2.11
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11
- en: The blank spaces, numbers, special characters, and symbols will simply be ignored.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 空格、数字、特殊字符和符号将被简单地忽略。
- en: How to do it…
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a string array called `str` to input your sentence. As usual, the last
    character will be a null character:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`str`的字符串数组来输入你的句子。像往常一样，最后一个字符将是空字符：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Define two variables, `ctrV` and `ctrC`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个变量，`ctrV`和`ctrC`：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Prompt the user to enter a sentence of your choice:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提示用户输入一个你选择的句子：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Execute the `gets` function to accept the sentence with blank spaces between
    the words:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`gets`函数以接受单词之间有空格的句子：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Initialize `ctrV` and `ctrC` to `0`. The `ctrV` variable will count the number
    of vowels in the sentence, while the `ctrC` variable will count the number of
    consonants in the sentence:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ctrV`和`ctrC`初始化为`0`。`ctrV`变量将计算句子中的元音数量，而`ctrC`变量将计算句子中的辅音数量：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Execute a `while` loop to access each letter of the sentence one, by one until the
    null character in the sentence is reached.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行一个`while`循环来逐个访问句子的每个字母，直到达到句子中的空字符。
- en: Execute an `if` block to check whether the letters are uppercase or lowercase,
    using ASCII values. This also confirms that the accessed character is not a white
    space, special character or symbol, or number.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行一个`if`块来检查字母是否为大写或小写，使用ASCII值。这也确认了访问的字符不是空白字符、特殊字符或符号，或数字。
- en: 'Once that''s done, execute a nested `if` block to check whether the letter
    is a lowercase or uppercase vowel, and wait for the `while` loop to terminate:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这个操作后，执行一个嵌套的`if`块来检查字母是否为小写或大写元音，并等待`while`循环结束：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `countvowelsandcons.c` program for counting vowels and consonants in a
    string is as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 用于在字符串中计算元音和辅音的`countvowelsandcons.c`程序如下：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码以更好地理解它。
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We are assuming that you will not enter a sentence longer than 255 characters,
    so we have defined our string variable accordingly. When prompted, enter a sentence
    that will be assigned to the `str` variable. Because a sentence may have blank
    spaces between the words, we will execute the `gets` function to accept the sentence.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设你不会输入超过255个字符的句子，所以我们相应地定义了我们的字符串变量。当提示时，输入一个将被分配给`str`变量的句子。因为句子中可能有单词之间的空格，所以我们将执行`gets`函数来接受句子。
- en: The two variables that we've defined, that is, `ctrV` and `ctrC`, are initialized
    to `0`. Because the last character in a string is always a null character, `\0`,
    a `while` loop is executed, which will access each character of the sentence one
    by one until the null character in the sentence is reached.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的两个变量，即`ctrV`和`ctrC`，被初始化为`0`。因为字符串的最后一个字符总是空字符`\0`，所以执行一个`while`循环，它会逐个访问句子的每个字符，直到达到句子中的空字符。
- en: Every accessed letter from the sentence is checked to confirm that it is either
    an uppercase or lowercase character. That is, their ASCII values are compared,
    and if the ASCII value of the accessed character is a lowercase or uppercase character,
    only then it will execute the nested `if` block. Otherwise, the next character
    from the sentence will be accessed.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 从句子中访问的每个字母都会被检查以确认它是一个大写或小写字符。也就是说，它们的ASCII值会被比较，如果访问的字符的ASCII值是大写或小写字符，那么它将执行嵌套的`if`块。否则，将访问句子中的下一个字符。
- en: Once you have ensured that the accessed character is not a blank space, any
    special character or symbol, or a numerical value, then an `if` block will be
    executed, which checks whether the accessed character is a lowercase or uppercase
    vowel. If the accessed character is a vowel, then the value of the `ctrV` variable
    is incremented by `1`. If the accessed character is not a vowel, then it is confirmed
    that it is a consonant, and so the value of the `ctrC` variable is incremented
    by `1`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确保访问的字符不是空白字符，任何特殊字符或符号，或数值，那么将执行一个`if`块，该块检查访问的字符是否为小写或大写元音。如果访问的字符是元音，则`ctrV`变量的值增加`1`。如果访问的字符不是元音，则确认它是辅音，因此`ctrC`变量的值增加`1`。
- en: Once all of the characters of the sentence have been accessed, that is, when
    the null character of the sentence is reached, the `while` loop terminates and
    the number of vowels and consonants stored in the `ctrV` and `ctrC` variables
    is displayed on the screen.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦访问了句子的所有字符，即当达到句子的空字符时，`while`循环终止，并在屏幕上显示存储在`ctrV`和`ctrC`变量中的元音和辅音的数量。
- en: 'Let''s use GCC to compile the `countvowelsandcons.c` program, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC编译`countvowelsandcons.c`程序，如下所示：
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s run the generated executable file, `countvowelsandcons.exe`, to see
    the output of the program:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行生成的可执行文件`countvowelsandcons.exe`以查看程序的输出：
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Voilà! We've successfully counted all of the vowels and consonants in our sentence.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功统计了我们句子中的所有元音和辅音。
- en: Now, let's move on to the next recipe!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个菜谱！
- en: Converting the vowels in a sentence to uppercase
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将句子中的元音转换为大写
- en: In this recipe, you will learn how to convert all of the lowercase vowels in
    a sentence to uppercase. The remaining characters in the sentence, including consonants,
    numbers, special symbols, and special characters, are simply ignored and will
    be left as they are.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何将句子中的所有小写元音转换为大写。句子中的其余字符，包括辅音、数字、特殊符号和特殊字符，将被简单地忽略，并保持原样。
- en: 'Converting the casing of any letter is done by simply changing the ASCII value
    of that character, using the following formulas:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地改变该字符的ASCII值来转换任何字母的大小写，使用以下公式：
- en: Subtract 32 from the ASCII value of a lowercase character to convert it to uppercase
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从小写字符的ASCII值中减去`32`以将其转换为大写
- en: Add 32 to the ASCII value of an uppercase character to convert it to lowercase
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`32`加到一个大写字符的ASCII值上以将其转换为小写
- en: 'The following diagram shows the ASCII values of the uppercase and lowercase
    vowels:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了大小写元音的ASCII值：
- en: '![](img/4737831d-0d45-4114-aa3a-fe442796d4da.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4737831d-0d45-4114-aa3a-fe442796d4da.png)'
- en: Figure 2.12
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12
- en: The ASCII value of the uppercase letters is lower than that of lowercase letters,
    and the difference between the values is 32.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 大写字母的ASCII值低于小写字母的ASCII值，两者之间的差值为`32`。
- en: How to do it…
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Create a string called `str` to input your sentence. As usual, the last character
    will be a null character:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`str`的字符串来输入你的句子。像往常一样，最后一个字符将是空字符：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Enter a sentence of your choice:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入你选择的句子：
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Execute the `gets` function to accept the sentence with blank spaces between
    the words, and initialize the `i` variable to `0`, since each character of the
    sentence will be accessed through `i`:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`gets`函数以接受单词之间有空格的句子，并将`i`变量初始化为`0`，因为句子的每个字符将通过`i`访问：
- en: '[PRE41]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Execute a `while` loop to access each letter of the sentence one by one, until the
    null character in the sentence is reached:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行一个`while`循环逐个访问句子的每个字母，直到达到句子的空字符：
- en: '[PRE42]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Check each letter to verify whether it is a lowercase vowel. If the accessed
    character is a lowercase vowel, then the value `32` is subtracted from the ASCII
    value of that vowel to convert it to uppercase:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查每个字母以验证它是否为小写元音。如果访问的字符是小写元音，则从该元音的ASCII值中减去`32`以将其转换为大写：
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When all of the letters of the sentence have been accessed, then simply display
    the entire sentence.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当访问了句子的所有字母后，只需显示整个句子。
- en: 'The `convertvowels.c` program for converting the lowercase vowels in a sentence
    to uppercase is as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将句子中的小写元音转换为大写的`convertvowels.c`程序如下：
- en: '[PRE44]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码以更好地理解它。
- en: How it works...
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Again, we will assume that you will not enter a sentence longer than 255 characters.
    Therefore, we have defined our string array, `str` , to be of the size 255\. When
    prompted, enter a sentence to assign to the `str` array. Because a sentence may
    have blank spaces between the words, instead of `scanf`, we will use the `gets`
    function to accept the sentence.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将假设你不会输入超过255个字符的句子。因此，我们定义我们的字符串数组，`str`，大小为255。当提示输入时，输入一个要分配给`str`数组的句子。因为一个句子中的单词之间可能有空格，所以我们不会使用`scanf`，而是使用`gets`函数来接受句子。
- en: To access each character of the sentence, we will execute a `while` loop that
    will run until the null character is reached in the sentence. After each character
    of the sentence, it is checked whether it is a lowercase vowel. If it is not a
    lowercase vowel, the character is ignored and the next character in the sentence
    is picked up for comparison.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问句子中的每个字符，我们将执行一个`while`循环，该循环将一直运行，直到在句子中遇到空字符。在句子的每个字符之后，都会检查它是否是小写元音。如果不是小写元音，则忽略该字符，并选择句子中的下一个字符进行比较。
- en: If the character that's accessed is a lowercase vowel, then a value of `32`
    is subtracted from the ASCII value of the character to convert it to uppercase.
    Remember that the difference in the ASCII values of lowercase and uppercase letters
    is `32`. That is, the ASCII value of lowercase `a` is `97` and that of uppercase
    `A` is `65`. So, if you subtract `32` from `97`, which is the ASCII value of lowercase
    `a`, the new ASCII value will become `65`, which is the ASCII value of uppercase `A`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果访问的字符是小写元音，则从字符的ASCII值中减去`32`以将其转换为大写。记住，小写和大写字母的ASCII值之差是`32`。也就是说，小写字母`a`的ASCII值是`97`，而大写字母`A`的ASCII值是`65`。所以，如果你从`97`（小写字母`a`的ASCII值）中减去`32`，新的ASCII值将变为`65`，这是大写字母`A`的ASCII值。
- en: The procedure of converting a lowercase vowel to an uppercase vowel is to first
    find the vowel in a sentence by using an `if` statement, and then subtract the
    value `32` from its ASCII value to convert it to uppercase.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 将小写元音转换为大写元音的步骤是首先使用`if`语句在句子中找到元音，然后从其ASCII值中减去`32`以将其转换为大写。
- en: Once all of the characters of the string are accessed and all of the lowercase
    vowels of the sentence are converted to uppercase, the entire sentence is displayed
    using the `puts` function.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦访问了字符串的所有字符，并且句子中的所有小写元音都转换为大写，整个句子将使用`puts`函数显示。
- en: 'Let''s use GCC to compile the `convertvowels.c` program, as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC编译`convertvowels.c`程序，如下所示：
- en: '[PRE45]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s run the generated executable file, `convertvowels.exe`, to see the output
    of the program:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行生成的可执行文件`convertvowels.exe`，以查看程序的输出：
- en: '[PRE46]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Voilà! We've successfully converted the lowercase vowels in a sentence to uppercase.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功地将句子中的小写元音转换为大写。
