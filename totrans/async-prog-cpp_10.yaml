- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coroutines with Boost.Cobalt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapters introduced C++20 coroutines and the Boost.Asio library,
    which is the foundation for writing asynchronous **input/output** ( **I/O** )
    operations using Boost. In this chapter, we will explore Boost.Cobalt, a high-level
    abstraction based on Boost.Asio that simplifies asynchronous programming with
    coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: Boost.Cobalt allows you to write clear, maintainable asynchronous code while
    avoiding the complexities of manually implementing coroutines in C++ (as covered
    in [*Chapter 8*](B22219_08.xhtml#_idTextAnchor164) ). Boost.Cobalt is fully compatible
    with Boost.Asio, allowing you to seamlessly combine both libraries in your projects.
    By using Boost.Cobalt, you can focus on building your application without worrying
    about the low-level details of coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following Boost.Cobalt topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Boost.Cobalt library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boost.Cobalt generators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boost.Cobalt tasks and promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boost.Cobalt channels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boost.Cobalt synchronization functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To build and execute the code examples from this chapter, a compiler that supports
    C++20 is required. We have used both Clang **18** and GCC **14.2** .
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you use Boost version 1.84 or newer and that your Boost library was
    compiled with C++20 support. At the time of writing this book, Cobalt support
    is rather fresh in Boost and not all precompiled distributions may provide this
    component. The situation will generally improve by the time of reading this book.
    If, for any reason, the Boost library in your system does not meet these requirements,
    you have to build it from its source. Compiling with an earlier version, such
    as C++17, won’t include Boost.Cobalt since it relies heavily on C++20 coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the complete code in the following GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP](https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP)'
  prefs: []
  type: TYPE_NORMAL
- en: The examples for this chapter are located under the **Chapter_10** folder.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Boost.Cobalt library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We introduced how C++20 supports coroutines in [*Chapter 8*](B22219_08.xhtml#_idTextAnchor164)
    . It was made obvious that writing coroutines is not an easy task due to two main
    reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing coroutines in C++ requires a certain amount of code to make the coroutine
    work but is not related to the functionality we want to implement. For example,
    the coroutine we wrote to generate the Fibonacci sequence was quite simple, but
    we had to implement the wrapper type, the promise, and all the functions required
    for it to be usable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The development of plain C++20 coroutines requires a good knowledge of the low-level
    aspects of how coroutines are implemented in C++, how the compiler transforms
    our code to implement all the mechanisms necessary to keep the coroutine state,
    and details about how the functions we must implement are called and when.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous programming is difficult enough without all those many details.
    It would be much better if we could focus on our program and be isolated from
    the lower-level concepts and code. We saw how C++23 introduced **std::generator**
    precisely to achieve this. Let us write just the generator code, and let the C++
    Standard Library and compiler take care of the rest. It is expected that this
    coroutine support will improve in the next C++ version.
  prefs: []
  type: TYPE_NORMAL
- en: Boost.Cobalt, one of the libraries included in the Boost C++ libraries, allows
    us to do just that – avoid the coroutines details. Boost.Cobalt was introduced
    in Boost 1.84 and requires C++20 because it relies on the language coroutines
    features. It is based on Boost.Asio, and we can use both libraries in our programs.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of Boost.Cobalt is to allow us to write simple single-threaded asynchronous
    code using coroutines – applications that can do multiple things simultaneously
    in a single thread. Of course, by simultaneously, we mean concurrently, not in
    parallel, because there is only one thread. By using Boost.Asio multithreading
    features, we can execute coroutines in different threads, but in this chapter,
    we will focus on single-threaded applications.
  prefs: []
  type: TYPE_NORMAL
- en: Eager and lazy coroutines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we introduce the coroutine types implemented by Boost.Cobalt, we need
    to define the two kinds of coroutines:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Eager coroutines** : An eager coroutine begins execution as soon as it is
    called. This means that the coroutine logic starts running immediately, and it
    progresses through its sequence until it hits a suspension point (such as **co_await**
    or **co_yield** ). The creation of the coroutine effectively starts its processing,
    and any side effects in its body will execute right away.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eager coroutines are beneficial when you want the coroutine to initiate its
    work immediately upon being created, such as starting asynchronous network operations
    or preparing data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Lazy coroutines** : A lazy coroutine defers its execution until is explicitly
    awaited or used. The coroutine object can be created without any of its body running
    until the caller decides to interact with it (usually by awaiting it with **co_await**
    ).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy coroutines are useful when you want to set up a coroutine but delay its
    execution until a certain condition is met or when you need to coordinate its
    execution with other tasks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After defining eager and lazy coroutines we will describe the different types
    of coroutines implemented in Boost.Cobalt.
  prefs: []
  type: TYPE_NORMAL
- en: Boost.Cobalt coroutine types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Boost.Cobalt implements four types of coroutines. We will introduce them in
    this section, and then see some examples later in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Promise** : This is the main coroutine type in Boost.Cobalt. It is used to
    implement asynchronous operations that return a single value (calling **co_return**
    ). It is an eager coroutine. It supports **co_await** , allowing asynchronous
    suspension and continuation. For example, a promise can be used to execute a network
    call that, when complete, will return its result without blocking other operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Task** : Task is the lazy version of the promise. It will not begin execution
    until is explicitly awaited. It provides more flexibility in controlling when
    and how a coroutine runs. When awaited, the task starts execution, allowing for
    delayed processing of asynchronous operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generator** : In Boost.Cobalt, a generator is the only type of coroutine
    that can yield values. Each value is yielded individually using **co_yield.**
    Its functionality is like **std::generator** in C++23 but it allows waiting with
    **co_await** ( **std::generator** doesn’t).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Detached** : This is an eager coroutine that can use **co_await** but not
    **co_return** values. It cannot be resumed and usually is not awaited.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we introduced Boost.Cobalt. We defined what eager and lazy coroutines
    are and then we defined the four main types of coroutines in the library.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will dive into one of the most important topics related
    to Boost.Cobalt – generators. We will also implement a few simple examples of
    generators.
  prefs: []
  type: TYPE_NORMAL
- en: Boost.Cobalt generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in [*Chapter 8*](B22219_08.xhtml#_idTextAnchor164) , **generator
    coroutines** are specialized coroutines designed to yield values incrementally.
    After each value is yielded, the coroutine suspends itself until the caller requests
    the next value. In Boost.Cobalt, generators work in the same way. They are the
    only coroutine type that can yield values. This makes generators essential when
    you need a coroutine to produce multiple values over time.
  prefs: []
  type: TYPE_NORMAL
- en: One key characteristic of Boost.Cobalt generators is that they are eager by
    default, meaning they start execution immediately after being called. Additionally,
    these generators are asynchronous, allowing them to use **co_await** , an important
    difference from **std::generator** introduced in C++23, which is lazy and doesn’t
    support **co_await** .
  prefs: []
  type: TYPE_NORMAL
- en: Looking at a basic example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s begin with the simplest Boost.Cobalt program. This example is not that
    of a generator, but we will explain some important details with its help:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we observe the following:'
  prefs: []
  type: TYPE_NORMAL
- en: To use Boost.Cobalt, the **<boost/cobalt.hpp>** header file must be included.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You also must link the Boost.Cobalt library to your application. We supply
    a **CMakeLists.txt** file to do just that, not only for Boost.Cobalt but for all
    the required Boost libraries. To link Boost.Cobalt explicitly (that is, not all
    the required Boost libraries), just add the following line to your **CMakeLists.txt**
    file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use of the **co_main** function. Instead of the usual **main** function, Boost.Cobalt
    introduces a coroutine-based entry point called **co_main** . This function can
    use coroutine-specific keywords such as **co_return** . Boost.Cobalt implements
    the required **main** function internally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using **co_main** will let you implement the **main** function (entry point)
    of your program as a coroutine, thus being able to call **co_await** and **co_return**
    . Remember from [*Chapter 8*](B22219_08.xhtml#_idTextAnchor164) that the **main**
    function cannot be a coroutine.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you cannot change your current **main** function, it is possible to use
    Boost.Cobalt. You just need to call a function, which will be the top-level function
    of your asynchronous code using Boost.Cobalt, from **main** . In fact, this is
    what Boost.Cobalt is doing: it implements a **main** function, which is the entry
    point of the program, and that (hidden to you) **main** function calls **co_main**
    .'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The easiest way to use your own **main** function would be something like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The example simply prints a greeting message and then returns 0 calling **co_await**
    . In all future examples, we will follow this pattern: including the **<boost/cobalt.hpp>**
    header file and using **co_main** instead of **main** .'
  prefs: []
  type: TYPE_NORMAL
- en: Boost.Cobalt simple generators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Armed with the knowledge from our previous basic example, we will implement
    a very simple generator coroutine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows a simple generator that yields an integer value (using
    **co_yield** ) and returns another one ( using **co_return** ).
  prefs: []
  type: TYPE_NORMAL
- en: '**cobalt::generator** is a **struct** template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The two parameter types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Yield** : The generated object type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Push** : The input parameter type (defaults to **void** )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **co_main** function prints both numbers after getting them using **co_await**
    (the caller waits for the values to be available). We have introduced some delays
    to simulate the processing a generator must do to generate the numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our second generator will yield the square of an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, **square_generator** yields the square of the **x** parameter.
    This shows how we can *push* values to a Boost.Cobalt generator. In Boost.Cobalt,
    pushing values to a generator means passing parameters (in the preceding example,
    the passed parameters are integers).
  prefs: []
  type: TYPE_NORMAL
- en: 'The generator in this example, though correct, can be confusing. Take a look
    at the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates the generator object with **10** as the initial value. Then, look
    at the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will print the square of **10** and will push **4** to the generator. As
    you can see, the printed values are not the squares of the values passed to the
    generator. This is because the generator is initialized with one value (in this
    example, **10** ), and it generates the squared value when the caller calls **co_await**
    to pass another value. The generator will yield **100** when receiving the new
    value, **4** , then it will yield **16** when receiving the value of **12** ,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We said that Boost.Cobalt generators are eager, but it is possible to make
    them wait ( **co_await** ) as soon as they start executing. The following example
    shows how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is very similar to the previous example, but there are some differences:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We create the generator without any parameter being passed to it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Take a look at the first line of the generator’s code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This makes the generator wait for the first pushed integer. This behaves as
    a lazy generator (in fact, it starts executing immediately because the generator
    is eager, but the first thing it does is wait for an integer).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The yielded values are what we would expect from the code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will print **100** instead of the square of the previously pushed integer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s summarize here what the example does: the **co_main** function calls
    the **square_generator** coroutine to generate the square of an integer value.
    The generator coroutine suspends itself at the beginning waiting for the first
    integer and it suspends itself after yielding each square. The example is easy
    on purpose, just to illustrate how to write a generator using Boost.Cobalt.'
  prefs: []
  type: TYPE_NORMAL
- en: An important feature of the preceding program is that it runs in a single thread.
    This means that **co_main** and the generator coroutine run one after another.
  prefs: []
  type: TYPE_NORMAL
- en: A Fibonacci sequence generator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will implement a Fibonacci sequence generator like the one
    we implemented in [*Chapter 8*](B22219_08.xhtml#_idTextAnchor164) . This will
    let us see how much easier is writing generator coroutines with Boost.Cobalt than
    with pure C++20 without using any coroutines library.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have written two versions of the generator. The first one calculates an
    arbitrary term of the Fibonacci sequence. We push the term we want to generate,
    and we get it. This generator uses a lambda as a Fibonacci calculator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we see that this generator is very similar to the one
    we implemented in the previous section to calculate the square of a number. At
    the beginning of the coroutine, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This line of code suspends the coroutine to wait for the first input value.
  prefs: []
  type: TYPE_NORMAL
- en: 'And then we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This generates the requested Fibonacci sequence term and suspends itself until
    the next term is requested. While the requested term is not equal to **-1** ,
    we can go on requesting more values until pushing **-1** terminates the coroutine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next version of the Fibonacci generator will yield an infinite number of
    terms as they are requested. By *infinite* we mean *potentially infinite* . Think
    about this generator as always ready to yield one more Fibonacci sequence number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is easy to understand: the coroutine yields a value and
    suspends itself until another one is requested and the coroutine calculates the
    new value and yields it and suspends itself again in an infinite loop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we can see the advantage of a coroutine: we can generate the
    terms of the Fibonacci sequence, one after another, whenever we need them. We
    don’t need to keep any state to generate the next term because the state is kept
    in the coroutine.'
  prefs: []
  type: TYPE_NORMAL
- en: Also note that even if the function executes an infinite loop, because it is
    a coroutine, it suspends and resumes again and again, avoiding blocking the current
    thread.
  prefs: []
  type: TYPE_NORMAL
- en: Boost.Cobalt tasks and promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already seen in this chapter, Boost.Cobalt promises are eager coroutines
    that return one value and Boost.Cobalt tasks are the lazy version of promises.
  prefs: []
  type: TYPE_NORMAL
- en: We can see them as just functions that don’t yield multiple values like generators
    do. We can call a promise repeatedly to get more than one value, but the state
    won’t be kept between calls (as in generators). Basically, a promise is a coroutine
    that can use **co_await** (it can use **co_return** too).
  prefs: []
  type: TYPE_NORMAL
- en: Different use cases of promises would be a socket listener to receive network
    packets, process them, make queries to a database, and then generate some results
    from the data. In general, their functionality requires asynchronously waiting
    for some result and then performing some processing on that result (or maybe just
    returning it to the caller).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first example is a simple promise that generates one random number (this
    can be done with a generator too):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have written three coroutines:'
  prefs: []
  type: TYPE_NORMAL
- en: '**co_main** : Remember that in Boost.Cobalt, **co_main** is a coroutine and
    it calls **co_return** to return a value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**random()** : This coroutine returns a random number to the caller. It calls
    **random()** with **co_await** to generate the random number. It asynchronously
    waits for the random number to be generated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**random_number()** : This coroutine generates a uniformly distributed random
    number between two values, **min** and **max** , and returns it to the caller.
    **random_number()** is also a promise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following coroutine returns a **std::vector<int>** of random numbers. **co_await
    random_number()** is called in a loop to generate a vector of **n** random numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function returns a promise of **std::vector<int>** . To access
    the vector, we need to call **get()** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The previous code prints the elements of the **v** vector. To access the vector,
    we need to call **v.get()** .
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to implement a second example to illustrate how the execution
    of promises and tasks differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have implemented two coroutines: a promise and a task.
    As we have already said, the promise is eager and it starts executing as soon
    as it’s called. The task is lazy and it’s suspended after being called.'
  prefs: []
  type: TYPE_NORMAL
- en: When we run the program, it prints all the messages, which let us know exactly
    how the coroutines execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the first three lines of **co_main()** are executed, the printed output
    is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: From these messages, we know that the promise has been executed until the call
    to **co_return** .
  prefs: []
  type: TYPE_NORMAL
- en: 'After the next three lines of **co_main()** are executed, the printed output
    has these new messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see that the task has not been executed. It is a lazy coroutine and,
    for this reason, it just suspends immediately after being called and no messages
    are printed by this coroutine just yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Three more lines of **co_main()** are executed, and these are the new messages
    in the program’s output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The call to **co_await** on the promise gives us its result (in this case, set
    to **1** ) and its execution ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we call **co_await** on the task, and it then executes and returns
    its value (which, in this case, is set to **2** ). The output is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This example shows how tasks are lazy and start suspended and only resume executing
    when the caller calls **co_await** on them.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have seen that, as in the case of generators, it is much
    easier to write promise and task coroutines using Boost.Cobalt than just using
    plain C++. We don’t need to write all the support code that C++ requires to implement
    coroutines. We have also seen the main difference between tasks and promises.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will study an example of a channel, a communication
    mechanism between two coroutines in a producer/consumer model.
  prefs: []
  type: TYPE_NORMAL
- en: Boost.Cobalt channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Boost.Cobalt, channels provide a way for coroutines to communicate asynchronously,
    allowing data transfer between a producer and a consumer coroutine in a safe and
    efficient manner. They are inspired by Golang channels and allow communication
    through message passing, promoting a *share-memory-by-communicating* paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **channel** is a mechanism through which values are asynchronously passed
    from one coroutine (the producer) to another (the consumer). This communication
    is non-blocking, which means that coroutines can suspend their execution when
    they wait for data to be available on the channel or when they write data to a
    channel that has limited capacity. Let’s clarify this: both reading and writing
    operations may be blocking, depending on the buffer size if, by *blocking* , we
    mean coroutines are suspended, but on the other hand, from the point of view of
    threads, these operations don’t block the thread.'
  prefs: []
  type: TYPE_NORMAL
- en: If the buffer size is zero, a read and a write will need to occur at the same
    time and act as a rendezvous (synchronous communication). If the channel size
    is bigger than zero and the buffer is not full, the write operation will not suspend
    the coroutine. Likewise, if the buffer is not empty, the read operation will not
    suspend.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to Golang channels, Boost.Cobalt channels are strongly typed. A channel
    is defined for a specific type, and only that type can be sent through it. For
    example, a channel of the **int** type ( **boost::cobalt::channel<int>** ) can
    only transmit integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now see an example of a channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we create a size **0** channel and two coroutines: the **producer**
    promise and **co_main()** , which acts as the consumer. The producer writes integers
    to the channel and the consumer reads them back and prints them squared.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We added **std::this_thread::sleep** to delay the program execution and, hence,
    be able to see what happens as the program runs. Let’s see an excerpt of the example’s
    output to see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Both the consumer and the producer wait for the next action to happen. The producer
    will always wait for the consumer to request the next item. This is basically
    how generators work, and it is a very common pattern in asynchronous code using
    coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: 'The consumer executes the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the producer writes the next number to the channel and waits for the
    next request. This is done in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You can see in the fourth line of the previous output excerpt how the producer
    goes back to waiting for the next request.
  prefs: []
  type: TYPE_NORMAL
- en: Boost.Cobalt channels make writing this kind of asynchronous code very clean
    and easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: The example shows both coroutines communicating through a channel.
  prefs: []
  type: TYPE_NORMAL
- en: That wraps up this section. The next one will introduce synchronization functions
    – mechanisms to wait for more than one coroutine.
  prefs: []
  type: TYPE_NORMAL
- en: Boost.Cobalt synchronization functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we implemented coroutines, and, in every case in which we called
    **co_await** , we did it for just one coroutine. This means we waited for the
    result of only one coroutine. Boost.Cobalt has mechanisms that allow us to wait
    on more than one coroutine. These mechanisms are called **synchronization functions**
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four synchronization functions implemented in Boost.Cobalt:'
  prefs: []
  type: TYPE_NORMAL
- en: '**race** : The **race** function waits for one coroutine out of a set to complete,
    but it does so in a pseudo-random manner. This mechanism helps avoid starvation
    of coroutines, ensuring that one coroutine doesn’t dominate the execution flow
    over others. When you have multiple asynchronous operations and you want the first
    to finish to determine the flow, **race** will allow any coroutine that becomes
    ready to proceed in a non-deterministic order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you have multiple tasks (tasks in the generic sense, not Boost.Cobalt tasks)
    and are interested in completing one first, without preference as to which one,
    but want to prevent one coroutine from always winning in situations where readiness
    is simultaneous, you will use **race** .
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**join** : The **join** function waits for all the coroutines in a given set
    to complete and return their results as values. If any of the coroutines throws
    an exception, **join** will propagate the exception to the caller. It’s a way
    to gather results from multiple asynchronous operations that must all finish before
    proceeding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will use **join** when you need the result of multiple asynchronous operations
    together and want to throw an error if any of them fail.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**gather** : The **gather** function, like **join** , waits for a set of coroutines
    to complete, but it handles exceptions differently. Instead of throwing an exception
    immediately when one of the coroutines fails, **gather** captures each coroutine’s
    result individually. This means that you can inspect the outcome (success or failure)
    of each coroutine independently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you need all asynchronous operations to complete but you want to capture
    all results and exceptions individually to handle them separately, you will use
    **gather** .
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**left_race** : The **left_race** function is like **race** but with deterministic
    behavior. It evaluates the coroutines from left to right and waits for the first
    coroutine to become ready. This can be useful when the order of coroutine completion
    matters, and you want to ensure a predictable outcome based on the order in which
    they were provided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you have multiple potential results and need to favor the first available
    coroutine in the order provided, making the behavior more predictable than **race**
    , you will use **left_race** .
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this section, we will explore examples of both **join** and **gather** functions.
    As we have seen, both functions wait for a set of coroutines to finish. The difference
    between them is that **join** throws an exception if any of the coroutines throw
    an exception, and **gather** always returns the results for all the awaited coroutines.
    In the case of the **gather** function, the result for each coroutine will either
    be an error (absent value) or a value. **join** returns a tuple of values or throws
    an exception; **gather** returns a tuple of optional values that have no value
    in the event of an exception (the optional variables are not initialized).
  prefs: []
  type: TYPE_NORMAL
- en: The full code for the following example is in the GitHub repo. We will focus
    here on the main sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have defined a simple function to simulate data processing, which is just
    a delay. The function throws an exception if we pass a delay bigger than 5,000
    milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The function is a Boost.Cobalt promise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the next section of the code, we will wait for three instances of this
    promise to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code calls **join** to wait for the completion of three coroutines
    and then prints the time they took. As you can see, the result is a tuple, and
    to make the code as simple as possible, we just call **std::get<i>(result)** for
    each element. In this case, all the processing times are inside the valid range
    and no exception is thrown, so we can get the result for all the executed coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: 'If an exception is thrown, then we won’t get any value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will throw an exception because the second coroutine receives
    a processing time outside of the valid range. It will print an error message.
  prefs: []
  type: TYPE_NORMAL
- en: When calling the **join** function, we want all the coroutines to be considered
    as part of processing and, in the event of an exception, the full processing fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need to get all the results for each coroutine, we will use the **gather**
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We have put the code inside a **try-catch** block but no exception is thrown.
    The **gather** function returns a tuple of optional values, and we need to check
    whether each coroutine returned a value or not (the optional has a value or not).
  prefs: []
  type: TYPE_NORMAL
- en: We use **gather** when we want the coroutines to return a value if they are
    executed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: These examples of **join** and **gather** functions conclude our introduction
    to the Boost.Cobalt synchronization functions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to implement coroutines using the Boost.Cobalt library.
    It was added to Boost only recently, and there is not much information about it.
    It simplifies the development of asynchronous code with coroutines, avoiding writing
    the low-level code necessary for C++20 coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: We studied the main library concepts and developed some simple examples to understand
    them.
  prefs: []
  type: TYPE_NORMAL
- en: With Boost.Cobalt, writing asynchronous code using coroutines is simplified.
    All the low-level details of writing coroutines in C++ are implemented by the
    library and we can focus just on the functionality we want to implement in our
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to debug asynchronous code.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Boost.Cobalt reference: *Boost.Cobalt reference* *guide* ( [https://www.boost.org/doc/libs/1_86_0/libs/cobalt/doc/html/index.html#overview](https://www.boost.org/doc/libs/1_86_0/libs/cobalt/doc/html/index.html#overview)
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A YouTube video on Boost.Cobalt: *Using coroutines with* *Boost.Cobalt* ( [https://www.youtube.com/watch?v=yElSdUqEvME](https://www.youtube.com/watch?v=yElSdUqEvME)
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 5: Debugging, Testing, and Performance Optimization in Asynchronous Programming'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final part, we focus on the essential practices of debugging, testing,
    and optimizing the performance of multithreaded and asynchronous programs. We
    will begin by using logging and advanced debugging tools and techniques, including
    reverse debugging and code sanitizers, to identify and resolve subtle bugs in
    asynchronous applications, such as crashes, deadlocks, race conditions, memory
    leaks, and thread safety issues, followed by testing strategies tailored for asynchronous
    code using the GoogleTest framework. Finally, we will dive into performance optimization,
    understanding key concepts such as cache sharing, false sharing, and how to mitigate
    performance bottlenecks. Mastering these techniques will provide us with a comprehensive
    toolkit for identifying, diagnosing, and improving the quality and performance
    of asynchronous applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B22219_11.xhtml#_idTextAnchor228) , *Logging and Debugging Asynchronous
    Software*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B22219_12.xhtml#_idTextAnchor243) , *Sanitizing and Testing
    Asynchronous Software*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B22219_13.xhtml#_idTextAnchor267) , *Improving Asynchronous
    Software Performance*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
