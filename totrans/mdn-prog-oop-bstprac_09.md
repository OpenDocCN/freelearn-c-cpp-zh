# *第七章*

# 架构

## 引言

“软件架构师”这个术语最近变得有些声名狼藉，可能是因为开发者与那些通过 PowerPoint-Driven Development 进行沟通的**架构宇航员**——[`www.joelonsoftware.com/items/2005/10/21.html`](http://www.joelonsoftware.com/items/2005/10/21.html)合作的结果。西蒙·布朗（Simon Brown）写了一本名为**《软件开发者的软件架构》**的书——[`leanpub.com/software-architecture-for-developers`](https://leanpub.com/software-architecture-for-developers)；您可以查看这本书，以获得对软件架构师职责的全面讨论。本章的重点是思考问题作为代码和作为支持代码的架构之间的增量差异。它还涉及到在设计应用程序时需要考虑的一些事情，何时考虑它们，以及如何将这些考虑的结果传达给团队中的其他人。

## 非功能性需求至关重要

我几乎可以说，一个应用程序架构成功的主要指标是它是否支持客户描述的非功能性需求。任何人只要足够有耐心和固执，都可以随意将功能粘合在一起，直到所有必需的功能都出现。然而，以结合客户侧（NFRs）和开发侧（适应性、可读性等）所需属性的方式使它具有连贯性，这正是软件架构的艺术所在。

那么，这些非功能性需求是什么？通常说，这些是关于软件的“-ility”声明。需要稍微眯起眼睛才能接受这一点，但大体上是正确的：

+   **性能**：这算是什么“-ility”？是速度性？速度性？还是速度性？无论如何，重要的是要理解“性能”的含义，因为它有许多不同的方面。它可能指的是软件在资源受限或大数据集下的行为。如果我们谈论“速度”，那可能是关于处理请求的速率，或者处理单个请求的时间（根据哪个更重要，以墙时或时钟周期来衡量）。它可能是平均值，或者在峰值条件下。如果是平均值，是在多长时间内测量的？它是**均值**还是另一个平均值？或许是**中位数**？

    *我在一个项目中处理过性能需求，描述如下：完成某些操作所需的时间和内存应在软件前一个版本的 105%以内。这是容易衡量的，软件是否成功是明确的。*

+   **兼容性**：软件需要在哪些操作系统上运行？哪些版本？它将与其他哪些软件组件进行通信？是否有选择特定语言、环境或第三方组件的理由？

+   **可靠性**：当出现问题时会发生什么？是失败、恢复还是某种受限的操作模式？可以接受多长时间的中断，在多长时间内？或者可能有关于同时受影响的用户数量的限制？

+   **法律或监管要求**：这些可以是要求不做什么（例如，不要将客户数据提供给第三方）或强制软件必须做什么（例如，记录任何数据请求）的规定。

+   **安全性**：这是一个非常广泛的话题，以至于许多书籍都涉及，包括我自己的其中一本。现在，我确信安全专家会对我将安全性与其他 NFRs（非功能性需求）归为一类而感到恼火，但这就是它的本质。对于大多数软件来说，安全性不是客户想要的特定功能，而是他们希望功能以何种方式交付的特性。请注意，虽然安全性与合规性等其他要求没有直接关系，但它可以是确保其他要求在面临颠覆时仍然得到满足的前提条件。

+   **可用性**：这可以涵盖广泛的需求：易用性，显然；但也包括应该支持哪些（人类）语言、可访问性、设计美学等等。我提到了可用性，但由谁来使用它？当然是使用它的人；但还有其他人需要考虑吗？谁将部署、安装、测试、配置和支持软件？这些人有什么可用性需求？

+   **适应性**：软件支持的执行环境或（人类）系统中最可能发生的变化有哪些？当然，现在没有必要支持这些事物，但一个能够使这些更改更容易进行（当然，现在不会造成不可接受的成本）的架构可能是有益的。

有这样一个列表，我们可以给出一个不那么模糊的非功能性需求的定义：它们是产品需要在其中提供其功能性的*约束*——不是它所做的事情，而是它必须以何种方式完成这些事情。

正因如此，一个成功的架构*必须*支持满足非功能性需求。如果软件不保持在其操作的限制范围内，客户可能根本无法使用它；在这种情况下，软件将是一个失败。为了支持这些需求，软件架构需要提供一个连贯的、高级的结构，开发者可以在其中构建应用程序的功能。架构应该清楚地说明每个功能应该如何适应，以及每个组件实施中受到的限制。换句话说，架构应该指导开发者，使得功能的明显实现方式符合 NFRs。理想情况下，每当开发者有类似“我在哪里添加这个？”或“我应该如何进行这个更改？”的问题时，架构师（甚至架构）应该已经有了答案。

### 我应该在什么时候考虑 NFRs？

上述讨论可能让你觉得你需要在构建任何功能之前就确定架构，因为功能实现必须受到架构的限制。这在很大程度上是正确的，尽管你经常会发现，应用程序功能的需求会反馈到架构决策中。

我认为这种迭代最好通过一系列逐级提高保真度的原型来处理。（“保真度”在这里指的是原型的技术准确性和功能完整性；毕竟，这些是为了架构评估。我说的不是原型的 UI 测试适用性，这是一个**完全独立的问题**——[`dl.acm.org/citation.cfm?id=223514`](http://dl.acm.org/citation.cfm?id=223514)。）架构大致定义，一些功能大致实现；任何确定的问题都得到解决，设计略有改进。这个过程一直持续到一切稳定下来，这时产品就准备好发货了。

在*第十三章，团队合作*中有一个关于项目方法的讨论。那些读过它或类似讨论的人会意识到，这听起来与**螺旋软件开发模型**有些相似——[`dl.acm.org/citation.cfm?doid=12944.12948`](http://dl.acm.org/citation.cfm?doid=12944.12948)，1986 年由波伊姆提出。这个提议与我在实践中分阶段原型化的不同之处在于每个迭代的长度：几天或几周，而不是波伊姆考虑的几个月到几年。

相信“先做出来再扔掉”这一理念的人此时可能已经从地板上抬起惊愕的嘴巴。这个理念的问题实际上在于如何真正地扔掉那个“扔掉的”东西。你*打算*扔掉第一个版本，但不知为何它竟然留了下来并最终投入了生产。你不妨从一开始就接受这种情况的发生，并编写一个尚未准备好*但将来会准备好*的原型，同时提供帮助团队理解原型与生产就绪之间差距的文档。

### 低保真原型中的性能

测量应用程序性能的工具是开发者可用的一些最强大的工具之一。时间分析器、内存管理器、网络数据包检查器等工具都有助于你发现应用程序的性能特征。但在它尚未编写出来时，你该如何做呢？

你编写具有预期性能特征的模拟。例如，如果你估计一个通过网络请求的操作大约需要 0.1±0.01 秒来完成，大约使用 4 MB 的堆内存，你可以编写一个模拟，分配大约 4 MB 的内存然后休眠适当的时间。应用程序的架构一次能支持多少这样的请求？完成任何单个操作的延迟是否可接受？记住在测试时考虑**正常和饱和情况**——[`queue.acm.org/detail.cfm?id=2413037`](http://queue.acm.org/detail.cfm?id=2413037)。

这种模拟形式对许多开发者来说并不陌生。正如模拟对象是为了在集成两个模块时测试*功能*而设计的模拟，这些模拟是性能的等效物。

### 低保真原型中的安全

将安全模型适配到现有架构可能会非常棘手。在数据流设计时未考虑这些方面的情况下，找到所有需要访问控制（这是面向方面编程的关键用例；可以在应用程序代码的“连接点”插入访问控制）或应该检查不同滥用情况的数据点是很困难的。对于关键的安全问题，包括访问控制和数据保护，最好从一开始就在设计中融入它们。

这并不一定意味着完全完善他们的实现；这只是意味着确保即使是早期原型也具备（即使是原型性的）保护能力。例如，在一个我参与的项目中，我们知道该应用程序需要加密写入磁盘的文档。该应用的早期版本使用**凯撒密码**[`en.wikipedia.org/wiki/Caesar_cipher`](http://en.wikipedia.org/wiki/Caesar_cipher)来执行此操作——远非密码学上安全，但足以显示哪些文件受到保护，以及是否有其他途径写入。你可以想象通过确保即使占位符功能也不能被未经授权的人使用，为授权执行相同的操作。

### 低保真原型中的可靠性

你可以通过注入这些故障并观察发生了什么来轻松地探索架构对故障的反应。在本章的*性能*部分，我谈到了拥有一个模拟真实网络请求内存和时间需求的占位符网络模块。同样，你可以安排它时不时地失败，并观察系统其他部分如何应对这种故障。一些公司甚至在生产中注入随机故障**[`github.com/Netflix/SimianArmy/wiki`](https://github.com/Netflix/SimianArmy/wiki**)，以确保他们的系统能够应对。

## 适当推迟；必要时承诺

与逐步精炼的原型一起工作意味着架构会迭代地更加完整；因此，某些决策会变得更加“固定”和难以更改。记住之前提出的概念：架构应该始终准备好回答开发者的疑问。这意味着开发者首先工作的东西应该是首先解决的问题。但这是一种同义反复的陈述，因为你可能能够安排开发工作以跟踪架构的变化。

从最具风险的事情开始是最好的。它们可能是产品探索性的方面，这些方面与团队之前所做的工作不相似，它们可能是与其他软件或其他组织接口的部分，或者它们可能是可能产生最高成本的部分。这些是应用中最有可能发生变化的部分，变化将非常昂贵。首先处理这些问题意味着在项目早期，在计划和成本变得过于固定之前，会有很高的变化率，而不是在项目结束时，当人们对何时一切准备就绪有期望。此外，在编写大量代码之前做出的更改意味着需要重写的代码更少。

这里存在一个期望管理问题。在探索性和实验性工作中，你必须能够说服客户、经理以及任何询问的人，对于“需要多长时间？”的回答是“我不知道；我们还没有确定”以及到目前为止所取得的任何进展都是虚假的。它可能看起来你取得了很大的进展，但其中大部分将是模拟代码，实际上并没有做它看起来要做的事情。在我领导的两个独立项目中，我们遇到了麻烦，因为某个利益相关者基于看到原型而对项目的进展做出了假设。这不是他们的错；这是我的责任，要提供关于项目状况的现实评估，让他们可以根据这个评估来判断如何继续进行。

## 证明你的决策是合理的

因此，你已经选择了将在应用程序的某个特定方面使用的技术。这是因为它将以最少的努力满足客户的需求，还是因为它是你自从参加那个会议以来就想使用的最新潮的东西？

当有人问为什么团队使用特定的语言、框架或模式时，仅仅耸耸肩，并说“适合这项工作的正确工具”并不是一个令人满意的答案。是什么让这个工具成为适合这项工作的正确工具？它是否满足了一些其他替代方案不具备的要求，比如兼容性？它是否比替代方案更便宜？（记住，成本是整体计算的：如果它显著减少了工作量并降低了引入错误的可能性，那么商业工具可能比免费工具更便宜。）

你需要说服其他人，你选择的解决方案适合当前的任务。在提升你的修辞技巧（这确实很有用——第十三章“团队合作”中有一个关于谈判的部分，以及一个关于批判性思考的整章）之前，首先要确保它确实是一个适合这项工作的工具。考虑人们可能会有哪些不同的考虑因素：

+   客户：这项技术能否让你构建出满足所有要求的东西？你或其他人能否随着我们的需求变化而调整解决方案？我们负担得起吗？它与我们的现有环境兼容吗？

+   开发者：我已经知道这些了吗，还是我需要去学习？学习这个技术会有趣吗？使用这项技术是否符合我的职业规划？

+   管理层：这是否具有成本效益？这真的是这个项目的最佳解决方案，还是只是你一直想学习的东西？**总线因素**[`en.wikipedia.org/wiki/Bus_factor`](http://en.wikipedia.org/wiki/Bus_factor)会是什么？我们能向其他客户销售这个吗？我们能从供应商那里购买支持吗？它是否与公司的能力和目标相匹配？

如果你能够诚实地回答这些问题，并且你选择的技术仍然看起来是最好的答案，那么，我并不会说你不需要你的说服力和谈判技巧——只是说你会更容易地运用它们。

但请记住，谈判就像是一种需要两个人的探戈。在《我们生活的隐喻》——[`theliterarylink.com/metaphors.html`](http://theliterarylink.com/metaphors.html)中，拉科夫和约翰逊提出，我们思考论点的方式受到我们使用战斗隐喻的影响。好吧，用巧妙收集的修辞手法击败对手在学校辩论社团中是可以的，但我们都需要记住，我们在软件领域是通过*构建最好的东西*来取得胜利的，而不是通过压倒性的反对意见。在压力之下，尤其是要放下自我，接受批评作为共同构建更好事物的手段可能会很困难。但这样做很重要：回顾一下人们提出的不同担忧，想想我可能忘记添加的其他担忧，并意识到你对项目最佳看法的看法只覆盖了故事的一部分。

## 何时修复和何时更换

作为软件架构师，你经常需要证明的一个特定决定是是否继续使用一些现有的代码，或者是否将其丢弃并用其他东西替换。好吧，你很少需要证明保留现有东西的决定；你经常需要证明替换它的合理性。

这本应是如此。虽然想象着抛开所有遗留的垃圾并开始一个新的绿色实施项目可能会让人感到满足——甚至让人感到平静——但避免这样做有很好的理由。现有的代码可能看起来有缺陷且难以理解，但你的团队已经对它有了现成的经验，并且可能知道问题和限制在哪里。对于尚未存在的替代品来说，情况并非如此，它可能会带来自己的困难和缺陷。

现在重要的是要认识到，这个论点与沉没成本谬误不同。那将是争论你不应该丢弃现有的代码，因为它已经花费了时间和资源；我在说的是，你应该仔细考虑开发新事物的成本是否真的低于继续使用现有事物的成本。

在许多情况下可能并非如此。这里有一个问题：你的替代实现将有多少个错误？这些错误是什么？修复这些错误需要多长时间？如果你能预测这一点，你可能不会留下这些问题，你也可以预测修复现有实现中的错误需要多长时间，并比较两者。然而，经验告诉我们，预测一项开发工作的质量是非常困难的。因此，存在一种可能性，即虽然你的新实现可能会修复原始版本中的一些错误（因为你在开发它时意识到了这些问题），但它可能会引入新的问题，包括回归问题，即早期版本的工作效果比其替代品更好。你必须将这种风险纳入你的决策中。

当替代品不是你打算内部构建的东西，而是一个你可以使用的开源或商业模块时，这种情况的经济学发生了重大转变。在这种情况下，获取软件的成本将是众所周知的，并且可以通过检查错误数据库或询问社区或供应商来调查其适用性。集成成本以及你将负责解决问题的程度（以及如果你不解决这些问题将产生的成本）是剩余需要考虑的成本。

关于重写的另一个想法：虽然它们对开发者来说可能不是明显的优势，但它们肯定不是对客户的益处。我见过许多应用程序，其中新版本被吹捧为“完全重写”，正如 GitHub 的 Danny Greg 所说，这不是一件好事。如果软件的新版本是一个完全重写，那么对我来说作为客户，它与上一个版本唯一共享的是名称和图标。

在重写版本中，我依赖的前版本中的某些东西可能不会像以前那样工作，或者根本无法工作。这对我来说是一个评估竞争产品的绝佳机会。

你面对的是一个已知且被充分理解的代码模块，存在一些已知问题。使用它是免费的，但你可能需要花一些时间修复一些问题，以便将其扩展以适应你的新项目。另一种选择是花一些时间构建做相同工作但具有未知问题集合的东西。尽管你的团队可能没有同样的经验，但它可能更符合你团队对良好设计代码的看法……这个月。在两者之间做出选择，以及我的代码是负债而不是资产的原则，我得出结论，我宁愿选择我认识的恶魔，而不是不认识的恶魔。

## 知道何时吹毛求疵，何时放手

一个优秀开发者的一个属性是能够分析问题的细节。开发者擅长这一点，因为计算机要求这样做；计算机在推理方面真的很差，所以你必须预测可能发生的每一个小情况，无论多么罕见，并告诉计算机如何处理它们。不幸的是，如果这个属性做得太过分，就会使程序员变成**糟糕的交谈者**——[`tirania.org/blog/archive/2011/Feb-17.html`](http://tirania.org/blog/archive/2011/Feb-17.html)，在所有其他领域，包括其他软件创建领域。

当你或其他人正在为软件系统设计架构时，把它看作是对解决方案**形状**的低保真提案，而不是实际的解决方案。对于“这如何解决 X？”的问题，几乎可以肯定的是“它解决不了——这是一个早期阶段的原型”，所以甚至问这个问题都没有意义。你可以通过将解决方案构建到所提出的架构中来证明答案：如果它有效，你就创建了一个功能；如果它不起作用，你就发现了一些重要的事情。但通常，你会先认为某件事不会起作用，然后发现它实际上是可以的。

同样，“你为什么这样做？”这样的问题并没有什么用。如果那样做的人没有认为那样做是个好主意，他们就不会那样做。许多开发者不喜欢阅读其他程序员的代码，我认为这是因为**开发者没有被教会如何有效地批判性地分析代码**——[`blog.securemacprogramming.com/2012/12/can-code-be-readable/`](http://blog.securemacprogramming.com/2012/12/can-code-be-readable/)。如果你不能将“那是什么？”转化为关于所提解决方案的具体问题，就别问了。

这并不是说批评是坏的或不想要的。当然，它是受欢迎的——建筑将受益于多个人输入。但反馈必须与建筑本身处于相同的**抽象级别**。

换句话说，反馈必须以对解决方案施加的约束以及它们是否可以在提供所需功能的同时得到满足为条件。像“我看不到`frobulator`接口的错误如何进入审计组件”这样的问题是好的。像“在持续饱和下这是如何退化的？”这样的问题是好的。像“如果我们使用这个模式，那么数据库插件可以很容易地互换”这样的建议是受欢迎的。像“这毫无用处——它不能处理当你打开命名管道时文件系统报告递归链接问题”这样的评论可以推迟。

## 支持，而不是控制

根据架构服务于在非功能性要求的约束内支持应用程序功能的定义，我们可以用类似的话来描述架构师的角色。

### 软件架构师做什么？

软件架构师的存在是为了识别影响软件产品技术实现的潜在风险，并解决这些风险。最好是，在他们停止或阻碍产品开发之前。

这可能意味着进行测试以调查提议解决方案的可行性或属性。这可能意味着向开发者和客户或经理传教，以避免这些人打断开发工作。这可能意味着给初级开发者提供关于某种技术的教程——或者让这位开发者辅导团队其他成员关于他/她擅长的东西。

### 软件架构师不做的事情

软件架构师不会对与他们合作的开发者进行微观管理。架构师不会通过备忘录和 UML 图来统治。架构师不会对没有经验的事情进行预测。也许有些令人困惑，软件架构师的职责与它所命名的职业相差甚远。如果你想找到与土木工程相关的类比，所有的开发者都像是建筑师。如果你想看到软件与建造者的对应，那是由编译器和 IDE 完成的工作。

架构师不会在没有必要的情况下做出决定。他们也不会忽视或轻视来自非架构师人士的建议。

### 简而言之

软件架构师的存在是为了让开发者更容易地进行开发。
