<html><head></head><body>
		<div id="_idContainer031">
			<h1 id="_idParaDest-530" class="chapter-number"><a id="_idTextAnchor530"/>13</h1>
			<h1 id="_idParaDest-531"><a id="_idTextAnchor531"/>Numeric and Range -Based Operations</h1>
			<p>In this chapter, you will uncover the potential of the powerful numeric and sorting operations of the C++<strong class="bold"> Standard Template Library</strong> (<strong class="bold">STL</strong>). These functions breathe life into sequences, making tasks such as accumulation, transformation, and querying using sorted ranges a breeze. Readers will gain insights into elementary and advanced numeric operations and discover the utility of working with sorted collections. When paired with best practices, this chapter ensures developers have a robust toolset to optimize, parallelize, and handle numeric data <span class="No-Break">with finesse.</span></p>
			<p>This chapter will cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Basic <span class="No-Break">numeric operations</span></li>
				<li>Advanced <span class="No-Break">numeric operations</span></li>
				<li>Operations on <span class="No-Break">sorted ranges</span></li>
				<li><span class="No-Break">Best practices</span></li>
			</ul>
			<h1 id="_idParaDest-532"><a id="_idTextAnchor532"/>Technical requirements</h1>
			<p>The code in this chapter can be found <span class="No-Break">on GitHub:</span></p>
			<p><a href="https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL"><span class="No-Break">https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL</span></a></p>
			<h1 id="_idParaDest-533"><a id="_idTextAnchor533"/>Basic numeric operations</h1>
			<p>Unearthing<a id="_idIndexMarker805"/> the power of the C++ STL’s numeric functions is a refreshing experience. In this section, we’ll dive deep into the foundational numeric operations. By mastering these, you’ll unlock the capability to generate sequences, compute comprehensive summaries, and efficiently execute sophisticated operations on contiguous elements. So, buckle up, and let’s <span class="No-Break">get started!</span></p>
			<h2 id="_idParaDest-534"><a id="_idTextAnchor534"/>Generating sequences with std::iota</h2>
			<p>The<a id="_idIndexMarker806"/> first treasure we’re going to unearth is <strong class="source-inline">std::iota</strong>. It’s a simple yet powerful tool in the numeric operations chest. <strong class="source-inline">std::iota</strong> fills a range with a sequence of consecutive values. Starting <a id="_idIndexMarker807"/>from an initial value, it assigns increasing values to subsequent elements in the range. Here, you can see that <strong class="source-inline">std::itoa</strong> fills a vector with five consecutive integers, starting <span class="No-Break">with 1:</span></p>
			<pre class="source-code">
std::vector&lt;int&gt; vec(5);
std::iota(vec.begin(), vec.end(), 1);
// vec now holds: {1, 2, 3, 4, 5}</pre>			<p>This function is a boon when you want a container to hold many contiguous sequences of numbers without manually inputting each one. Consider a scenario where you want a <strong class="source-inline">std::vector</strong> to hold timesteps for a <span class="No-Break">constructive simulation:</span></p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
int main() {
  const int numTimeSteps = 100;
  std::vector&lt;double&gt; timeSteps(numTimeSteps);
  // Generate a sequence of time steps using std::iota
  double timeStep = 0.01; // Time step size
  std::iota(timeSteps.begin(), timeSteps.end(), 0);
  // Scale the time steps to represent actual time
  for (double &amp;t : timeSteps) { t *= timeStep; }
  // Now, timeSteps contains a sequence of time points for
  // simulation
  // Simulate a simple system over time (e.g., particle
  // movement)
  for (const double t : timeSteps) {
    // Simulate the system's behavior at time t
    // ...
    std::cout &lt;&lt; "Time: " &lt;&lt; t &lt;&lt; std::endl;
  }
  return 0;
}</pre>			<p>Here <a id="_idIndexMarker808"/>is the <span class="No-Break">example output:</span></p>
			<pre class="console">
Time:0
Time: 0.01
Time: 0.02
Time: 0.03
Time: 0.04
Time: 0.05
...</pre>			<p>In this example, <strong class="source-inline">std::iota</strong> is used to generate a sequence of time steps, which can be used to model the behavior of a system over time. While this is a simplified example, in real-world applications, you can use <strong class="source-inline">std::iota</strong> as a foundation for more complex simulations <a id="_idIndexMarker809"/>and modeling scenarios, such as physics simulations, financial modeling, or <span class="No-Break">scientific research.</span></p>
			<p><strong class="source-inline">std::iota</strong> helps<a id="_idIndexMarker810"/> create a time series or discrete event timeline, which can be a fundamental component in various computational simulations and modeling tasks. Its value becomes more apparent when integrated into larger, more complex systems where time sequencing or indexing <span class="No-Break">is crucial.</span></p>
			<h2 id="_idParaDest-535"><a id="_idTextAnchor535"/>Summing elements with std::accumulate</h2>
			<p>Say you <a id="_idIndexMarker811"/>have a sequence<a id="_idIndexMarker812"/> of numbers and wish to find their sum (or maybe a product). Enter <strong class="source-inline">std::accumulate</strong>. This algorithm is primarily used to compute the sum over a range of elements. Let’s look at the following simple example <span class="No-Break">in action:</span></p>
			<pre class="source-code">
std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};
int sum = std::accumulate(vec.begin(), vec.end(), 0);
// sum will be 15</pre>			<p>It is primarily used to compute the sum of a range of elements, but its power doesn’t stop there. With its flexible design, <strong class="source-inline">std::accumulate</strong> can also be employed for other operations, such as finding products or concatenating strings. By providing a custom binary operation, its applications are broadened significantly. Here is a simple example of how <strong class="source-inline">std::accumulate</strong> can be used <span class="No-Break">with strings:</span></p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;std::string&gt; words = {"Hello", ", ", "world",
                                    "!"};
  std::string concatenated = std::accumulate(
      words.begin(), words.end(), std::string(""),
      [](const std::string &amp;x, const std::string &amp;y) {
        return x + y;
      });
  std::cout &lt;&lt; "Concatenated string: " &lt;&lt; concatenated
            &lt;&lt; std::endl;
  return 0;
}</pre>			<p>Here is the <a id="_idIndexMarker813"/><span class="No-Break">example output:</span></p>
			<pre class="console">
Concatenated string: Hello, world!</pre>			<p>With<a id="_idIndexMarker814"/> some creativity, <strong class="source-inline">std::accumulate</strong> can become a versatile tool in your <span class="No-Break">algorithmic toolbox.</span></p>
			<h2 id="_idParaDest-536"><a id="_idTextAnchor536"/>Adjacent elements and their interactions with std::adjacent_difference</h2>
			<p>Sometimes, we’re<a id="_idIndexMarker815"/> interested in individual elements and pairs of adjacent elements. The<a id="_idIndexMarker816"/> STL has got your back here <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">std::adjacent_difference</strong></span><span class="No-Break">.</span></p>
			<p><strong class="source-inline">std::adjacent_difference</strong> calculates the difference between an element and its predecessor and stores it in another sequence. This operation is beneficial in tasks such as computing <span class="No-Break">discrete derivatives.</span></p>
			<p>The following code demonstrates the usage <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">std::adjacent_difference</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
std::vector&lt;int&gt; vec = {2, 4, 6, 8, 10};
std::vector&lt;int&gt; result(5);
std::adjacent_difference(vec.begin(), vec.end(), result.begin());
// result holds: {2, 2, 2, 2, 2}</pre>			<p>Not just for differences, you can pass custom binary operations to <strong class="source-inline">std::adjacent_difference</strong> to achieve varied results, such as ratios. Let’s look at the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;double&gt; values = {8.0, 16.0, 64.0, 256.0,
                                4096.0};
  // Create a vector to store the calculated ratios
  std::vector&lt;double&gt; ratios(values.size());
  // Write a lambda to use in adjacent_difference
  auto lambda = [](double x, double y) {
    if (x == 0.0) {
      // Handle division by zero for the first element
      return 0.0;
    } else {
      // Calculate the ratio between y and x
      return y / x;
    }
  };
  // Calculate the ratios between consecutive elements
  std::adjacent_difference(values.begin(), values.end(),
                           ratios.begin(), lambda);
  // The first element in the ratios vector is 0.0 because
  //there's no previous element
  // Print the calculated ratios for the remaining elements
  std::cout &lt;&lt; "Ratios between consecutive elements:\n";
  for (size_t i = 1; i &lt; ratios.size(); ++i) {
    std::cout &lt;&lt; "Ratio " &lt;&lt; i &lt;&lt; ": " &lt;&lt; ratios[i]
              &lt;&lt; "\n";
  }
  return 0;
}</pre>			<p>Here is the <span class="No-Break">example </span><span class="No-Break"><a id="_idIndexMarker817"/></span><span class="No-Break">output:</span></p>
			<pre class="console">
Ratios between consecutive elements:
Ratio 1: 0.5
Ratio 2: 0.25
Ratio 3: 0.25
Ratio 4: 0.0625</pre>			<h2 id="_idParaDest-537"><a id="_idTextAnchor537"/>Inner products with std::inner_product</h2>
			<p>This function is a <a id="_idIndexMarker818"/>marvel for those who’ve dabbled in linear algebra. <strong class="source-inline">std::inner_product</strong> calculates the dot product of two ranges. As you might recall, the dot product is <a id="_idIndexMarker819"/>the sum of the products of corresponding pairs from two sequences. Let’s look at how to compute the dot product of <span class="No-Break">two vectors:</span></p>
			<pre class="source-code">
std::vector&lt;int&gt; vec1 = {1, 2, 3};
std::vector&lt;int&gt; vec2 = {4, 5, 6};
int product = std::inner_product(vec1.begin(), vec1.end(),
                                 vec2.begin(), 0);
// product will be 32 (because 1*4 + 2*5 + 3*6 = 32)</pre>			<p><strong class="source-inline">std::inner_product</strong> isn’t just limited to integers or plain multiplication. Custom binary operations can be tailored to work on different types <span class="No-Break">and operations.</span></p>
			<p>Here are some real-world examples to demonstrate that <strong class="source-inline">std::inner_product</strong> can work with custom binary operations tailored to different types and operations beyond just integers and <span class="No-Break">plain multiplication:</span></p>
			<ul>
				<li><strong class="bold">Calculating weighted average</strong>: You can use <strong class="source-inline">std::inner_product</strong> to calculate the weighted average of elements in two containers, where one container holds values, and the other container holds the corresponding weights. The custom binary operation would perform the element-wise multiplication of the values and weights and then sum them up to find the <span class="No-Break">weighted average.</span></li>
				<li><strong class="bold">Financial portfolio valuation</strong>: Suppose you have a financial portfolio with different assets, each having a price and quantity. You can use <strong class="source-inline">std::inner_product</strong> with a custom binary operation to calculate the portfolio’s total value by multiplying the asset prices by their respective quantities and summing <span class="No-Break">them up.</span></li>
				<li><strong class="bold">Vector dot product</strong>: In a 3D graphics application, you might need to calculate the dot <a id="_idIndexMarker820"/>product of two 3D vectors, which involves multiplying their corresponding components and summing the results. <strong class="source-inline">std::inner_product</strong> can be used with a custom binary operation for <span class="No-Break">this purpose.</span></li>
				<li><strong class="bold">Matrix multiplication</strong>: In linear algebra, matrix multiplication involves multiplying <a id="_idIndexMarker821"/>the rows and columns of two matrices and summing the results to obtain a new matrix. <strong class="source-inline">std::inner_product</strong> can be adapted with a custom binary operation to perform matrix <span class="No-Break">multiplication efficiently.</span></li>
				<li><strong class="bold">Complex number operations</strong>: You can use <strong class="source-inline">std::inner_product</strong> to perform complex number operations, such as calculating the inner product of two complex vectors or finding the sum of the squares of complex numbers. The custom binary operation would be tailored to complex <span class="No-Break">number arithmetic.</span></li>
				<li><strong class="bold">String concatenation</strong>: If you have a vector of strings and want to concatenate them into a single string, you can use <strong class="source-inline">std::inner_product</strong> with a custom binary operation that concatenates strings. This allows you to join a collection of <span class="No-Break">strings efficiently.</span></li>
				<li><strong class="bold">Color blending in image processing</strong>: In image processing, color blending operations involve combining pixel values from two images using a specific blending formula. <strong class="source-inline">std::inner_product</strong> can be adapted with a custom binary operation to perform color blending based on the <span class="No-Break">desired algorithm.</span></li>
			</ul>
			<p>These examples<a id="_idIndexMarker822"/> illustrate that <strong class="source-inline">std::inner_product</strong> is a versatile algorithm that can be customized for various types and operations. This makes it useful in many real-world applications<a id="_idIndexMarker823"/> beyond simple <span class="No-Break">integer multiplication.</span></p>
			<p>In this section, we have seen that the basic numeric operations provided by the C++ STL pave the way for the efficient computation, generation, and manipulation of sequences. They transform how developers approach problems, allowing for swift and effective solutions. As we’ve seen, these algorithms are versatile and, with a pinch of creativity, can be adapted to a myriad <span class="No-Break">of tasks.</span></p>
			<p>With these tools in your utility belt, you’re now equipped to generate sequences, compute quick summaries, and perform intricate operations on <span class="No-Break">consecutive elements.</span></p>
			<h1 id="_idParaDest-538"><a id="_idTextAnchor538"/>Advanced numeric operations</h1>
			<p>In order to take <a id="_idIndexMarker824"/>our journey with the numeric operations of the C++ STL a step further, let’s look at the advanced numerical procedures that elevate data handling and make parallelism and concurrency allies in the pursuit <span class="No-Break">of performance.</span></p>
			<p>Remember our discussion about generating sequences and computing summaries? Well, imagine supercharging these operations to process enormous volumes of data efficiently by harnessing the power of multiple processors. This is precisely where advanced numeric operations shine. Parallel algorithms, introduced in C++17, provide the means to achieve this, ensuring our computations are both swift and efficient, even in <span class="No-Break">concurrent environments.</span></p>
			<p>When dealing with vast datasets, sequential processing often doesn’t cut it. Take the example of summing up a large vector of numbers. Doing it in a straight line gets the job done but might not be the quickest. However, the operation can be sped up significantly by splitting the data and working on chunks concurrently. This is the essence of parallel algorithms, and functions such as <strong class="source-inline">std::reduce</strong> exemplify this. Instead of sequentially accumulating values, <strong class="source-inline">std::reduce</strong> can accumulate subtotals in parallel and then combine them, offering a significant boost in performance for <span class="No-Break">large datasets.</span></p>
			<p>To see this in <a id="_idIndexMarker825"/>action, let’s calculate the sum of all numbers in a large vector <span class="No-Break">in parallel:</span></p>
			<pre class="source-code">
#include &lt;execution&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
int main() {
  // Create a large vector of numbers
  const int dataSize = 1000000;
  std::vector&lt;int&gt; numbers(dataSize);
  // Initialize the vector with some values (e.g., 1 to
  // dataSize)
  std::iota(numbers.begin(), numbers.end(), 1);
  // Calculate the sum of the numbers in parallel
  int parallelSum = std::reduce(
      std::execution::par, numbers.begin(), numbers.end());
  std::cout &lt;&lt; "Parallel Sum: " &lt;&lt; parallelSum
            &lt;&lt; std::endl;
  return 0;
}</pre>			<p>Here is the <span class="No-Break">example output:</span></p>
			<pre class="console">
Parallel Sum: 1784293664</pre>			<p>Diving into parallel operations requires a nuanced approach. While the promise of speed is tempting, one must be cautious. Parallelism introduces challenges such as ensuring thread safety and managing data races. Thankfully, the STL offers a remedy through execution policies. By specifying an execution policy, such as <strong class="source-inline">std::execution::par</strong>, when invoking an algorithm, we can direct it to run in parallel. Additionally, there’s <strong class="source-inline">std::execution::par_unseq</strong> for parallel and vectorized execution, ensuring even <span class="No-Break">greater throughput.</span></p>
			<p>Speaking of <a id="_idIndexMarker826"/>transformation, let’s look into <strong class="source-inline">std::transform_reduce</strong>. This is a fusion of <strong class="source-inline">std::transform</strong> and <strong class="source-inline">std::reduce</strong>. It applies a transformation function to each range element and reduces the results into a single value, which can be parallelized. For instance, if we had a vector of numbers and wanted to square each element and then sum up the squared values, <strong class="source-inline">std::transform_reduce</strong> would be our go-to, especially when dealing with a substantial amount <span class="No-Break">of data.</span></p>
			<p>Let’s see how we can use <strong class="source-inline">std::transform_reduce</strong> to square each element of a vector and then sum up the <span class="No-Break">squared values:</span></p>
			<pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;execution&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
int main() {
  const long int dataSize = 1000;
  std::vector&lt;long int&gt; numbers(dataSize);
  std::iota(numbers.begin(), numbers.end(), 1);
  // Use std::transform_reduce to square each element and
  // sum them up in parallel
  long int parallelSumOfSquares = std::transform_reduce(
      std::execution::par, numbers.begin(), numbers.end(),
      0, // Initial value for the accumulation
      std::plus&lt;long int&gt;(),
      [](long int x) { return x * x; });
  std::cout &lt;&lt; "Parallel Sum of Squares:"
            &lt;&lt; parallelSumOfSquares &lt;&lt; "\n";
  return 0;
}</pre>			<p>Here is the <span class="No-Break">example output:</span></p>
			<pre class="console">
Parallel Sum of Squares: 333833500</pre>			<p>Another <a id="_idIndexMarker827"/>feather in the cap of advanced operations is the <strong class="source-inline">std::inclusive_scan</strong> and <strong class="source-inline">std::exclusive_scan</strong> duo. These are powerful tools for generating prefix sums. <strong class="source-inline">std::inclusive_scan</strong> includes the i<span class="superscript">th</span> input element in the i<span class="superscript">th</span> sum, whereas <strong class="source-inline">std::exclusive_scan</strong> doesn’t. Like their fellow advanced numeric operations, they, too, can be supercharged with parallel execution for <span class="No-Break">heightened performance.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">A <strong class="bold">prefix sum</strong>, also<a id="_idIndexMarker828"/> known as a <strong class="bold">scan</strong> operation, is a computational operation that<a id="_idIndexMarker829"/> generates an output array or sequence from an input array or sequence by calculating the cumulative sum of elements up to a specific position. In other words, for each element at index <strong class="source-inline">i</strong> in the input sequence, the corresponding element in the output sequence contains the sum of all elements from index <strong class="source-inline">0</strong> to <strong class="source-inline">i</strong> in the <span class="No-Break">input sequence.</span></p>
			<p>Parallel operations can be resource-intensive. It’s essential to ensure that the hardware can handle the parallelism and that the amount of data is large enough to justify the overhead of concurrent execution. Additionally, always be vigilant about potential pitfalls such as <a id="_idIndexMarker830"/>data races or deadlocks. The key is constantly weighing the pros and cons, analyzing the specific requirements, and choosing the most <span class="No-Break">suitable approach.</span></p>
			<h1 id="_idParaDest-539"><a id="_idTextAnchor539"/>Operations on sorted ranges</h1>
			<p>The allure<a id="_idIndexMarker831"/> of sorting isn’t just about placing elements for the sake of neatness. Instead, it is about the power it grants us in subsequent operations—streamlined navigation, efficient querying, and enhanced manipulation <a id="_idIndexMarker832"/>capabilities. For C++ developers, understanding operations on sorted ranges is like acquiring a new set of superpowers. Armed with the C++ STL’s tools for these sorted sequences, the world of efficient algorithmic operations becomes an open field, ready <span class="No-Break">for exploration.</span></p>
			<p>So, what’s the big deal about having sorted ranges? Consider the difference between looking for a book in a disordered pile versus finding it on a neatly organized shelf. When the data are sorted, algorithms can take shortcuts, such as dividing and conquering, leading to logarithmic rather than <span class="No-Break">linear-time complexities.</span></p>
			<p>A primary technique leveraged for sorted <a id="_idIndexMarker833"/>ranges is <strong class="bold">binary search</strong>. In C++, <strong class="source-inline">std::lower_bound</strong> and <strong class="source-inline">std::upper_bound</strong> are your go-to functions for this purpose. The former finds the first position where a value should be inserted to maintain the order, while the latter identifies the last suitable spot. Together, they can determine the range of entries equivalent to a given value. If you’ve ever marveled at the rapidity with which some applications return search results, binary search techniques such as these are often <span class="No-Break">to thank.</span></p>
			<p>Continuing on the topic of queries, <strong class="source-inline">std::equal_range</strong> steps in as a combination of the aforementioned functions, returning both the lower and upper bounds of a value in a sorted range; if you just need a straightforward check, <strong class="source-inline">std::binary_search</strong> tells you if an element exists in the sorted range. These tools simplify querying, making it both swift <span class="No-Break">and precise.</span></p>
			<p>However, operations on sorted ranges aren’t confined to searches. Set operations, reminiscent of our elementary math lessons, come alive with sorted data. If you’ve two sorted sequences and wish to determine their common elements, <strong class="source-inline">std::set_intersection</strong> is the tool for the job. For those elements that belong to one sequence but not to the other, turn to <strong class="source-inline">std::set_difference</strong>. If you’re in the mood to combine the elements of two sequences while maintaining the sort order, <strong class="source-inline">std::set_union</strong> stands ready. Last but not least, for finding elements unique to each sequence, <strong class="source-inline">std::set_symmetric_difference</strong> serves <span class="No-Break">the purpose.</span></p>
			<p>Imagine the <a id="_idIndexMarker834"/>power that these operations grant. Comparing two large datasets to find commonalities or differences is a frequent requirement in many applications, from databases to data analytics. By working on sorted ranges, these operations become feasible <span class="No-Break">and efficient.</span></p>
			<p>Sorted operations <a id="_idIndexMarker835"/>presume, quite reasonably, that the data is sorted. If this invariant isn’t maintained, the results can be unpredictable. So, ensuring the sort order is paramount before diving into these operations. Thankfully, with functions such as <strong class="source-inline">std::is_sorted</strong>, one can verify the sorted nature of a range before <span class="No-Break">venturing further.</span></p>
			<p>Let’s pull all of these concepts together into a quick example of how they can <span class="No-Break">be used:</span></p>
			<pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; d = {10, 20, 30, 40, 50,
                        60, 70, 80, 90};
  int tgt = 40;
  auto lb = std::lower_bound(d.begin(), d.end(), tgt);
  auto ub = std::upper_bound(d.begin(), d.end(), tgt);
  bool exists =
      std::binary_search(d.begin(), d.end(), tgt);
  std::vector&lt;int&gt; set1 = {10, 20, 30, 40, 50};
  std::vector&lt;int&gt; set2 = {30, 40, 50, 60, 70};
  std::vector&lt;int&gt; intersection(
      std::min(set1.size(), set2.size()));
  auto it = std::set_intersection(set1.begin(), set1.end(),
                                  set2.begin(), set2.end(),
                                  intersection.begin());
  std::vector&lt;int&gt; difference(
      std::max(set1.size(), set2.size()));
  auto diffEnd = std::set_difference(
      set1.begin(), set1.end(), set2.begin(), set2.end(),
      difference.begin());
  bool isSorted = std::is_sorted(d.begin(), d.end());
  std::cout &lt;&lt; "Lower Bound:"
            &lt;&lt; std::distance(d.begin(), lb) &lt;&lt; "\n";
  std::cout &lt;&lt; "Upper Bound:"
            &lt;&lt; std::distance(d.begin(), ub) &lt;&lt; "\n";
  std::cout &lt;&lt; "Exists: " &lt;&lt; exists &lt;&lt; "\n";
  std::cout &lt;&lt; "Intersection: ";
  for (auto i = intersection.begin(); i != it; ++i)
    std::cout &lt;&lt; *i &lt;&lt; " ";
  std::cout &lt;&lt; "\n";
  std::cout &lt;&lt; "Difference: ";
  for (auto i = difference.begin(); i != diffEnd; ++i)
    std::cout &lt;&lt; *i &lt;&lt; " ";
  std::cout &lt;&lt; "\n";
  std::cout &lt;&lt; "Is Sorted: " &lt;&lt; isSorted &lt;&lt; "\n";
  return 0;
}</pre>			<p>Here is the <span class="No-Break">example output:</span></p>
			<pre class="console">
Lower Bound: 3
Upper Bound: 4
Exists: 1
Intersection: 30 40 50
Difference: 10 20
Is Sorted: 1</pre>			<p>It is<a id="_idIndexMarker836"/> evident from these <a id="_idIndexMarker837"/>examples that operations on sorted ranges unlock a realm of possibilities. They exemplify the blend of mathematical theory and practical coding, creating a robust framework for developers to navigate, query, and manipulate data with unparalleled efficiency. As we move forward, we’ll explore the best practices associated with numeric and range-based operations, ensuring that as we harness their power, we do so with precision, efficiency, and finesse. The journey of discovery and <span class="No-Break">mastery continues!</span></p>
			<h1 id="_idParaDest-540"><a id="_idTextAnchor540"/>Best practices</h1>
			<p>The following best practices are associated with numeric and <span class="No-Break">range-based operations:</span></p>
			<ul>
				<li><strong class="bold">Selecting the most suitable algorithm based on data attributes</strong>: Effectively<a id="_idIndexMarker838"/> using the numeric and range-based <a id="_idIndexMarker839"/>operations from the C++ STL requires more than just knowing their functionalities; it’s crucial to discern when and where to employ them to ensure optimal performance and data preservation. Different datasets exhibit varying properties such as size, distribution, and repetition frequency. These properties can influence the performance of certain operations. For example, <strong class="source-inline">std::stable_sort</strong> may prove more efficient than other sorting methods for a nearly sorted dataset. Thus, understanding your dataset’s characteristics is pivotal when deciding <span class="No-Break">appropriate operations.</span></li>
				<li><strong class="bold">Maintaining data integrity in sorted operations</strong>: Preserving data integrity is paramount, especially in processes that rely on sorted datasets. Many range-based operations, such as binary searches and set operations, presuppose the data range is already sorted. Implementing these operations without this assurance might lead to unreliable outcomes or errors. It’s a misconception to assume that once data is sorted, it remains sorted indefinitely. Simple modifications can alter the dataset’s order. Hence, verifying the order with <strong class="source-inline">std::is_sorted</strong> before proceeding with sorted operations <span class="No-Break">is recommended.</span></li>
				<li><strong class="bold">Using parallel algorithms judiciously</strong>: With the growing emphasis on concurrency, parallel algorithms present an attractive option to boost performance. The C++ STL provides parallel versions of many standard algorithms. While these algorithms capitalize on multiple CPU cores to deliver faster results, they can also introduce challenges, especially regarding thread safety. A primary concern in concurrent programming is a shared mutable state. Issues arise when multiple threads attempt to simultaneously modify the same data. To use parallel algorithms safely, it’s critical that threads either work on distinct data sections or employ synchronization tools, such as mutexes, to manage simultaneous <span class="No-Break">data modifications.</span><p class="list-inset">Furthermore, parallelism isn’t always the answer. The overhead from managing multiple<a id="_idIndexMarker840"/> threads can sometimes negate the benefits <a id="_idIndexMarker841"/>of parallel execution, especially for small datasets or straightforward tasks. To determine the effectiveness of parallelism in a given scenario, it’s beneficial to profile your code in both sequential and parallel configurations. This assessment aids in choosing the most <span class="No-Break">efficient method.</span></p></li>
			</ul>
			<p>In this section, we’ve explored how to choose the right algorithms in the C++ STL based on data properties, emphasizing the importance of dataset characteristics such as size and distribution. Selecting an appropriate algorithm, such as <strong class="source-inline">std::stable_sort</strong>, for nearly sorted data is crucial for optimal performance. We also highlighted the necessity of maintaining data order for sorted operations, using tools such as <strong class="source-inline">std::is_sorted</strong> to ensure data integrity. Parallel algorithms were discussed, focusing on their benefits and complexities, such as thread safety. The key takeaway is that parallelism, while powerful, requires careful consideration, especially regarding dataset size and <span class="No-Break">task complexity.</span></p>
			<h1 id="_idParaDest-541"><a id="_idTextAnchor541"/>Summary</h1>
			<p>In this chapter, we have immersed ourselves in the versatile world of algorithms provided by the C++ STL that handle numeric sequences and operate on sorted ranges. We started with basic numeric operations, such as generating sequences with <strong class="source-inline">std::iota</strong>, summing elements with accumulate, and exploring the interactions of adjacent elements with <strong class="source-inline">std::adjacent_difference</strong>. The chapter explored more complex tasks, such as computing inner products <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">std::inner_product</strong></span><span class="No-Break">.</span></p>
			<p>These operations are essential in data handling and analysis within STL containers, facilitating tasks from simple accumulations to complex transformations. The information presented is crucial for developers, as it enhances efficiency and efficacy when performing numerical computations and prepares them for high-performance scenarios, especially when dealing with <span class="No-Break">large datasets.</span></p>
			<p>The chapter also covered advanced numeric operations, which are particularly beneficial in parallel computing environments. We learned how to employ parallel algorithms for data transformation and summarization, ensuring high performance in concurrent environments. Operations on sorted ranges were explored, illustrating the efficiency of binary search techniques and the functionality of set operations, which are significantly optimized by the data’s <span class="No-Break">sorted nature.</span></p>
			<p>In the next chapter, we will venture into ranges, representing a more contemporary approach to sequences in C++. We will explore why there has been a shift toward range-based operations, understand the essence and power of these modern STL components, and explore their composability for sorting and searching algorithms. This upcoming chapter will empower readers with the knowledge to embrace the full potential of the modern STL, making informed decisions on when and how to apply these new tools in their C++ <span class="No-Break">programming endeavors.</span></p>
		</div>
	</body></html>