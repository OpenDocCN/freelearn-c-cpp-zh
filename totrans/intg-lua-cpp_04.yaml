- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Mapping Lua Types to C++
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Lua类型映射到C++
- en: In the previous chapter, we learned how to call a Lua function with a single
    string argument that returns one string value. In this chapter, we will learn
    how to call a Lua function with any type and any number of arguments and support
    multiple return values. To do this, we need to find a convenient way to map Lua
    types to C++ types. Then, we will build upon this type system to improve our Lua
    executor step by step. During this process, you will continue to deepen your understanding
    of the Lua stack and learn how to use some of the modern C++ features to integrate
    Lua.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何调用一个接受单个字符串参数并返回一个字符串值的Lua函数。在本章中，我们将学习如何调用接受任何类型和任何数量的参数的Lua函数，并支持多个返回值。为此，我们需要找到一个方便的方法将Lua类型映射到C++类型。然后，我们将在此基础上逐步改进我们的Lua执行器。在这个过程中，您将继续深化对Lua栈的理解，并学习如何使用一些现代C++特性来集成Lua。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Mapping Lua types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射Lua类型
- en: Supporting different argument types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持不同的参数类型
- en: Supporting a variable number of arguments
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持可变数量的参数
- en: Supporting multiple return values
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持多个返回值
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter is more C++ coding intensive. To better follow this chapter, please
    make sure you understand the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章更注重C++编码。为了更好地理解本章，请确保您理解以下内容：
- en: You are familiar with the modern C++ standards. We will start to use features
    from **C++11** and **C++17**. If you have only used **C++03**, please take a while
    to study the new C++ features on your own when you encounter them in this chapter.
    As a heads-up, we will use **enum class**, **std::variant**, **std::visit**, and
    **std::initializer_list**.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您熟悉现代C++标准。我们将开始使用**C++11**和**C++17**中的特性。如果您只使用过**C++03**，请在遇到本章中的新C++特性时，花些时间自己学习。作为提醒，我们将使用**enum
    class**、**std::variant**、**std::visit**和**std::initializer_list**。
- en: 'You can access the source code for this chapter here: [https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter04](https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter04).'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在此处找到本章的源代码：[https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter04](https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter04)。
- en: You can understand and execute the code in the `begin` folder from the preceding
    GitHub link. The `begin` folder has some necessary solutions from the last chapter’s
    questions integrated and acts as the starting point for this chapter. We will
    add new features implemented in this chapter to it.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以从前面的GitHub链接中的`begin`文件夹中理解并执行代码。`begin`文件夹整合了上一章问题的必要解决方案，并作为本章的起点。我们将向其中添加本章实现的新功能。
- en: Mapping Lua types
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射Lua类型
- en: In *Chapter 2*, *Lua Fundamentals*, we learned about the Lua types. They are
    different from C++ types. To use them in C++, we need to do some mapping. In *Chapter
    3*, *How to Call Lua from C++*, we mapped the Lua string to the C++ `std::string`.
    It is mapped by hardcoding it in our Lua executor.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在**第2章**，**Lua基础**中，我们学习了Lua类型。它们与C++类型不同。要在C++中使用它们，我们需要进行一些映射。在**第3章**，**如何从C++调用Lua**中，我们将Lua字符串映射到C++的`std::string`。这是通过在我们的Lua执行器中硬编码来实现的。
- en: What if we want to support all possible Lua types, both in the function arguments
    and in function return values? What if we want to call Lua functions with different
    numbers of arguments? It is not feasible to create a C++ function for each argument
    type and argument count combination. That way, our Lua executor would be plagued
    with hundreds of functions just to call Lua functions!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在函数参数和函数返回值中支持所有可能的Lua类型怎么办？如果我们想以不同的参数数量调用Lua函数怎么办？为每种参数类型和参数数量组合创建一个C++函数是不可行的。那样的话，我们的Lua执行器将受到数百个函数的困扰，只是为了调用Lua函数！
- en: Fortunately, C++ is powerful with its **object-oriented programming** and its
    **generic programming**. These two paradigms lead to two different ways in which
    you can solve problems in C++.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，C++在**面向对象编程**和**泛型编程**方面非常强大。这两个范例导致了两种不同的方式，您可以在C++中解决问题。
- en: Exploring different mapping options
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索不同的映射选项
- en: As said, C++ supports object-oriented programming and generic programming. We
    can design a type system with either of them.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，C++支持面向对象编程和泛型编程。我们可以使用其中任何一个来设计类型系统。
- en: Using object-oriented types
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用面向对象类型
- en: This approach is probably easier to understand. It has been supported since
    the birth of C++. We can define an abstract base class that represents all possible
    types, then inherit it and implement a concrete class for each type.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可能更容易理解。它自C++诞生以来就得到了支持。我们可以定义一个表示所有可能类型的抽象基类，然后继承它并为每种类型实现一个具体类。
- en: Besides C++, most programming languages support this method. If you or your
    team work with multiple programming languages, this method might cause less concept
    switching in work.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了C++，大多数编程语言都支持这种方法。如果你或你的团队使用多种编程语言，这种方法可能会在工作时减少概念切换。
- en: But this approach is also more verbose. You will have other considerations as
    well. For example, after the mappings are defined, you would want to prevent creating
    new types that do not exist in Lua. You would have to make base class constructors
    private and declare a few friends.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种方法也更冗长。你还需要考虑其他因素。例如，在映射定义之后，你可能会想要防止创建Lua中不存在的类型。你必须将基类构造函数设为私有，并声明几个朋友。
- en: Using generic types
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用泛型类型
- en: 'This approach depends on a new C++17 feature: *std::variant*. You can define
    and map a simple C++ class for each Lua type without inheritance. Then you create
    a union type with `std::variant`, saying that this union type may be and can only
    be from the pre-defined Lua mappings.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法依赖于一个新的C++17特性：*std::variant*。你可以为每个Lua类型定义并映射一个简单的C++类，而不需要继承。然后你使用`std::variant`创建一个联合类型，表示这个联合类型可能并且只能是从预定义的Lua映射中来的。
- en: This will result in less code. The less code, the less chance that something
    will go wrong. Modern programming tends to adopt new paradigms, besides the vanilla
    object-oriented methodology.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致代码更少。代码越少，出错的机会就越小。现代编程倾向于采用新的范式，而不仅仅是传统的面向对象方法。
- en: The drawback of this approach is that not all organizations adopt the new C++
    standards that fast, which in turn makes them less widely understood.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，并非所有组织都能如此迅速地采用新的C++标准，这反过来又使得它们理解起来不那么广泛。
- en: In this chapter, we will implement that approach. After going through this chapter,
    if you prefer, you can implement object-oriented types on your own. But before
    we move on, let us look at the `Makefile` used for this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现这种方法。在完成本章后，如果你愿意，你可以自己实现面向对象类型。但在我们继续之前，让我们看看用于本章的`Makefile`。
- en: Introducing some new Makefile tricks
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍一些新的Makefile技巧
- en: 'Before diving into the details, let us go through the `Makefile`. You can find
    a copy in the `begin` folder in the GitHub repository, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入细节之前，让我们看一下`Makefile`。你可以在GitHub仓库中的`begin`文件夹中找到一个副本，如下所示：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There are only four differences compared to the `Makefile` used in *Chapter
    3*:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与*第3章*中使用的`Makefile`相比，只有四个不同之处：
- en: In `CXXFLAGS`, we require the compiler to compile our code as C++17 by adding
    `-std=c++17`. Without this, it will use the default standard, which may be an
    older C++ version.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`CXXFLAGS`中，我们要求编译器通过添加`-std=c++17`将我们的代码编译为C++17。如果没有这个，它将使用默认的标准，这可能是较旧的C++版本。
- en: A new variable, `ALL_O`, defines all the object files that will be produced.
    Each C++ source file will be compiled into an object file. Remember to add a new
    object file here when you add a new source file. Otherwise, without the object
    file produced, the linker cannot find the symbols that should have been in the
    missing object file, and you will get linker errors.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新变量`ALL_O`定义了将生成的所有目标文件。每个C++源文件将被编译成一个目标文件。记住，当你添加新的源文件时，在这里添加一个新的目标文件。否则，如果没有生成目标文件，链接器将找不到应该在缺失的目标文件中存在的符号，你将得到链接器错误。
- en: The `project` target now depends on all object files. `Make` is smart enough
    to compile the object files from the source files for you automatically by using
    the corresponding source file as a dependency for the object file.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在的`project`目标依赖于所有目标文件。`Make`足够智能，可以自动为你编译源文件中的目标文件，使用相应的源文件作为目标文件的一个依赖项。
- en: 'The `all` target has an extra dependency: the `clean` target. This always cleans
    the project and rebuilds it. When you write an object file target manually, you
    can make it depend on multiple header files. When `Make` does this for you, it
    cannot tell which header files need to be depended on. So, this is a trick for
    small projects for study purposes. For more formal projects, you should consider
    supporting compiling everything correctly without cleaning it first.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`all` 目标有一个额外的依赖项：`clean` 目标。这总是清理项目并重新构建它。当你手动编写目标文件时，你可以让它依赖于多个头文件。当 `Make`
    为你这样做时，它无法告诉你哪些头文件需要依赖。所以，这是一个用于学习目的的小项目的技巧。对于更正式的项目，你应该考虑在不先清理的情况下正确编译所有内容。'
- en: If you struggle to understand this `Makefile`, please check the explanation
    in *Chapter 1* and *Chapter 3*. Better yet, you can research more online. If you
    have no urgent need to learn about the `Makefile`, it is also perfectly fine just
    to use it as it is, and be comfortable with it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你难以理解这个 `Makefile`，请查看 *第 1 章* 和 *第 3 章* 中的解释。更好的是，你可以在网上进行更多研究。如果你没有紧急需要学习关于
    `Makefile` 的知识，仅仅使用它，并对其感到舒适，也是完全可以的。
- en: Remember
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 记住
- en: The `Makefile` examples used in this book favor simplicity, rather than production
    flexibility.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用的 `Makefile` 示例更倾向于简单性，而不是生产灵活性。
- en: We have distracted ourselves a bit from C++ by explaining some new `Makefile`
    mechanisms. This will be the last time we go through a `Makefile` in this book.
    In the following chapters, please refer to the GitHub source code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过解释一些新的 `Makefile` 机制，稍微分散了对 C++ 的注意力。这将是本书中最后一次介绍 `Makefile`。在接下来的章节中，请参考
    GitHub 源代码。
- en: The explanation was necessary, in case you get cryptic errors from the C++ compiler
    and linker. Now we can go back to our focus. We will define some simple C++ structures
    that map to Lua types. After this, we can use `std::variant` to declare a union
    type. Having a union type will enable us to pass a value of any type to our C++
    functions. Now, let us define the Lua types in C++.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 解释是必要的，以防你从 C++ 编译器和链接器中得到难以理解的错误。现在我们可以回到我们的重点。我们将定义一些简单的 C++ 结构，这些结构映射到 Lua
    类型。之后，我们可以使用 `std::variant` 来声明一个联合类型。拥有联合类型将使我们能够将任何类型的值传递给我们的 C++ 函数。现在，让我们在
    C++ 中定义 Lua 类型。
- en: Defining Lua types in C++
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义 Lua 类型
- en: The first order of business is how we can define a Lua type in C++. We want
    a clear definition of Lua types, so things such as `std::string` are no longer
    unique enough.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一项任务是我们在 C++ 中如何定义一个 Lua 类型。我们希望 Lua 类型有一个清晰的定义，因此像 `std::string` 这样的类型就不再足够独特了。
- en: 'Since C++11, we have *enum class* support. We can limit our Lua types with
    an enum class in C++ as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 自 C++11 以来，我们有了 *enum class* 的支持。我们可以在 C++ 中使用枚举类来限制 Lua 类型，如下所示：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For now, we only support the Lua basic types that can map to simple C++ types.
    You can put this declaration in a file named `LuaType.hpp` and include it in `LuaExecutor.h`
    as shown here:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只支持可以映射到简单 C++ 类型的 Lua 基本类型。你可以将这个声明放在一个名为 `LuaType.hpp` 的文件中，并像下面这样将其包含在
    `LuaExecutor.h` 中：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We call it `*.hpp` because we will put the type implementations in the header
    file directly and inline all the functions. This is partly because the implementation
    classes will be simple, and partly because this is a book, and limiting the number
    of lines of code is important. You can separate the code into a header file and
    a source file or name this header file with implementations `LuaType.h`. This
    depends on convention, as per each company or organization, and there are many
    ways to do something in C++.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称它为 `*.hpp` 因为我们将直接在头文件中放置类型实现并内联所有函数。这部分的理由是因为实现类将是简单的，部分是因为这是一本书，限制代码行数很重要。你可以将代码分离到头文件和源文件中，或者将包含实现的头文件命名为
    `LuaType.h`。这取决于惯例，每个公司或组织都有自己的惯例，C++ 中有许多实现某种方式的方法。
- en: Implementing Lua types in C++
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 C++ 中实现 Lua 类型
- en: 'As explained, we will use simple classes without inheritance. Each class will
    have two fields: a `type` field of `LuaType` we just defined, and a `value` field
    for the actual data storage in C++.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如解释的那样，我们将使用没有继承的简单类。每个类将有两个字段：一个 `type` 字段，它是我们刚刚定义的 `LuaType`，以及一个 `value`
    字段，用于在 C++ 中实际数据存储。
- en: 'In `LuaType.hpp`, implement four structures. In C++, a structure is the same
    as a class, but with public access to its members by default. We use structures
    conventionally when we want to define data. First, implement `LuaType::nil`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LuaType.hpp` 中实现四个结构。在 C++ 中，结构与类相同，但默认情况下其成员对公共访问。当我们想要定义数据时，我们通常使用结构。首先，实现
    `LuaType::nil`：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We choose to use `nullptr` to represent a Lua nil value. Its type is `std::nullptr_t`.
    We also make the constructor private and provide a static function to create new
    objects.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择使用 `nullptr` 来表示 Lua 的 nil 值。它的类型是 `std::nullptr_t`。我们还将其构造函数设为私有，并提供了一个静态函数来创建新对象。
- en: Design patterns
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式
- en: Here, we used a design pattern – the static factory method with a private constructor.
    In our implementation, this will prevent creating objects on the heap with `new`.
    The C++ structures for Lua types do not provide copy constructors either. This
    is a design choice – you either fully support passing it around and assigning
    to it or limit its usage. In this book, we limit its usage purely when interacting
    with the Lua executor on the C++ stack. If you have another layer above the Lua
    executor, you need to convert the structures to C++ basic types or your own type.
    This helps with abstraction.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了一个设计模式——私有构造函数的静态工厂方法。在我们的实现中，这将防止使用 `new` 在堆上创建对象。Lua 类型的 C++ 结构也不提供拷贝构造函数。这是一个设计选择——你可以完全支持传递和赋值，或者限制其使用。在这本书中，我们仅在其与
    C++ 栈上的 Lua 执行器交互时限制其使用。如果你在 Lua 执行器之上还有其他层，你需要将结构转换为 C++ 基本类型或你自己的类型。这有助于抽象。
- en: 'Similarly, implement `LuaType::boolean`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，实现 `LuaType::boolean`：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The static `make` function accepts a `boolean` value to create an instance.
    In the private constructor, we use a member initializer list to initialize the
    `value` member variable.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 静态的 `make` 函数接受一个 `boolean` 值来创建一个实例。在私有构造函数中，我们使用成员初始化列表来初始化 `value` 成员变量。
- en: 'For `LuaType::number`, we choose to use the C++ double type to store the value:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `LuaType::number`，我们选择使用 C++ double 类型来存储值：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Lua itself does not distinguish between an integer and a float in the basic
    *number* type, but if you need to, you can create two C++ types for integers and
    floats separately. To do this, you can use the Lua `lua_isinteger` library function
    to check whether the number is an integer. If it is not, it is a double. In this
    book, we only implement mappings for the basic Lua types. In a gaming system,
    you might want to enforce using the float type. In an embedded system, you might
    want to enforce using the integer type. Or, you can support using both in a project.
    This is easy to achieve by referencing the implementation for `LuaNumber`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 本身在其基本 *number* 类型中不区分整数和浮点数，但如果你需要，你可以为整数和浮点数分别创建两个 C++ 类型。为此，你可以使用 Lua
    的 `lua_isinteger` 库函数来检查数字是否为整数。如果不是，它就是一个 double。在这本书中，我们只实现了基本 Lua 类型的映射。在一个游戏系统中，你可能想强制使用浮点类型。在一个嵌入式系统中，你可能想强制使用整数类型。或者，你可以在项目中支持使用两者。通过引用
    `LuaNumber` 的实现，这很容易实现。
- en: Linking knowledge
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 知识链接
- en: In Lua code, you can use the `math.type` library function to check whether a
    number is an integer or a float.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Lua 代码中，你可以使用 `math.type` 库函数来检查一个数字是整数还是浮点数。
- en: 'And finally, for `LuaType::string`, we use `std::string` to store the value:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于 `LuaType::string`，我们使用 `std::string` 来存储值：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This concludes our type implementations. Next is where all the magic happens.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们的类型实现。接下来就是所有魔法发生的地方。
- en: Implementing a union type
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现联合类型
- en: 'We have defined a `LuaType` enum class to identify Lua types, and structures
    to represent Lua values of different types. When we want to pass a Lua value around,
    we need a type to represent them all. Without using a common base class, we can
    use `std::variant`. It is a template class taking a list of types as its parameters.
    Then it can safely represent any of these types in code. To see it in action,
    add the following to `LuaType.hpp`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个 `LuaType` 枚举类来标识 Lua 类型，以及结构来表示不同类型的 Lua 值。当我们想要传递 Lua 值时，我们需要一个类型来表示它们。不使用公共基类，我们可以使用
    `std::variant`。它是一个模板类，接受一系列类型作为其参数。然后它可以安全地在代码中表示这些类型中的任何一种。要看到它的实际应用，请将以下内容添加到
    `LuaType.hpp`：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `using` keyword creates a type alias, `LuaValue`. It can represent any of
    the four specified types in the template parameters.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`using` 关键字创建了一个类型别名，`LuaValue`。它可以代表模板参数中指定的四种类型中的任何一种。'
- en: Working with the union type
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与联合类型一起工作
- en: 'If you have not used `std::variant` before, you may have wondered how can we
    tell which actual type it is holding. If you pass a value of `LuaValue` around,
    you cannot access the `type` or the `value` field directly. This is because there
    is no common base class. At compile time, the compiler does not know what fields
    are supported by simply looking at the `std::variant` variable. To do this, we
    need a small twist. C++17 also provides `std::visit` to help with this. Let us
    implement a helper function to get the `LuaType` from a `LuaValue`. In `LuaType.hpp`,
    add the code as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前没有使用过 `std::variant`，您可能想知道我们如何判断它实际持有的类型。如果您传递 `LuaValue` 的值，您无法直接访问 `type`
    或 `value` 字段。这是因为没有公共基类。在编译时，编译器无法仅通过查看 `std::variant` 变量来确定支持哪些字段。为此，我们需要一个小技巧。C++17
    也提供了 `std::visit` 来帮助解决这个问题。让我们实现一个辅助函数来从 `LuaValue` 获取 `LuaType`。在 `LuaType.hpp`
    中添加以下代码：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This function is an `the call site more efficient. Moreover, it needs to be
    an inline function because we are implementing it in the header file directly.
    Without the **inline**` **keyword, the function may get included in different
    source files with the same symbol, which leads to link errors.**
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使调用站点更高效。此外，它需要是一个内联函数，因为我们直接在头文件中实现它。如果没有使用 `**inline**` 关键字，函数可能会被包含在不同的源文件中，具有相同的符号，从而导致链接错误。
- en: '**`std::visit` takes two arguments. The first is a C++ `std::visit` makes the
    type information available. If you have never come across this concept or usage
    before, it may take some time to digest. You can consider this callable a **lambda**.
    If you have used lambda from other programming languages, such as Java, Kotlin,
    Swift, or Python, the C++ one is very similar. In other programming languages,
    more often than not, the lambda is the last parameter, which is called a **trailing
    lambda** and in some cases is easier to read. The best way to learn about C++
    lambda is to use it and try to feel comfortable with it until you have fully mastered
    it.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**`std::visit` 接受两个参数。第一个是一个 C++ `std::visit` 使得类型信息可用。如果您之前从未遇到过这个概念或用法，可能需要一些时间来消化。您可以将这个可调用项视为
    **lambda**。如果您在其他编程语言中使用过 lambda，例如 Java、Kotlin、Swift 或 Python，C++ 的 lambda 非常相似。在其他编程语言中，lambda
    通常作为最后一个参数，称为 **尾随 lambda**，在某些情况下更容易阅读。了解 C++ lambda 的最佳方式是使用它，并尝试在完全掌握之前使其变得舒适。'
- en: 'With this, let us implement another helper function to get the string representation
    of each type. In `LuaTypp.hpp`, add the following function:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们实现另一个辅助函数来获取每种类型的字符串表示。在 `LuaTypp.hpp` 中添加以下函数：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will help us to test our implementations in the rest of this chapter by
    getting what is stored in a `LuaValue`. You can use `std::get` to get a specific
    type from a `std::variant` union.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这将帮助我们通过获取存储在 `LuaValue` 中的内容来测试本章其余部分的实现。您可以使用 `std::get` 从 `std::variant`
    联合中获取特定类型。
- en: We have talked about `std::variant`, `std::visit`, and `std::get`, but not enough
    to be a C++ expert in this area. Before moving on, feel free to research more
    on them.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了 `std::variant`、`std::visit` 和 `std::get`，但不足以成为该领域的 C++ 专家。在继续之前，请随意对这些内容进行更多研究。
- en: Next, let us use the Lua mapping we have implemented to make calling Lua functions
    more flexible. First, we will get rid of the hardcoded `std::string` used for
    the `call` function in our Lua executor.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用我们已实现的 Lua 映射来使调用 Lua 函数更加灵活。首先，我们将移除 Lua 执行器中 `call` 函数使用的硬编码的 `std::string`。
- en: Supporting different argument types
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持不同的参数类型
- en: 'In the last chapter, we implemented our C++ function to call a Lua function
    as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们实现了以下方式调用 Lua 函数的 C++ 函数：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Our goal in this step is to make it more general and we want the following
    instead:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，我们的目标是使其更通用，我们希望以下内容：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In fact, go ahead and change this in `LuaExecutor.h`. To make it work, we will
    implement helper functions to push onto and pop from the Lua stack, with our `LuaValue`
    C++ type instead of `std::string`. Let us work on pushing onto the stack first.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，请先在 `LuaExecutor.h` 中进行此更改。为了使其工作，我们将实现辅助函数来将 `LuaValue` C++ 类型推送到和从 Lua
    栈中弹出，而不是 `std::string`。让我们首先处理推送到栈上的操作。
- en: Pushing onto the stack
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推送到栈上
- en: 'In the previous call function, we pushed the `param` argument of the `std::string`
    type onto the Lua stack with the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的调用函数中，我们将 `std::string` 类型的 `param` 参数以以下方式推送到 Lua 栈中：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To support more Lua types, we can implement a `pushValue` method that takes
    `LuaValue` as an argument and calls different `lua_pushX` Lua library functions
    based on the `type` field of `LuaValue`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持更多的 Lua 类型，我们可以实现一个接受 `LuaValue` 作为参数的 `pushValue` 方法，并根据 `LuaValue` 的 `type`
    字段调用不同的 `lua_pushX` Lua 库函数。
- en: 'In `LuaExecutor.h`, add the declaration as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LuaExecutor.h` 中，添加以下声明：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And in `LuaExecutor.cc`, implement the `pushValue` function:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LuaExecutor.cc` 中，实现 `pushValue` 函数：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Our implementation only uses one `switch` statement on `LuaType`. We implemented
    `getLuaType` in `LuaType.hpp` earlier in this chapter. In each `case`, we use
    `std::get` to get the typed value from the `LuaValue` type union. Next, we will
    look at the popping part.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现只在 `LuaType` 上使用一个 `switch` 语句。我们之前在本章中实现了 `getLuaType` 函数，位于 `LuaType.hpp`
    中。在每一个 `case` 中，我们使用 `std::get` 从 `LuaValue` 类型联合中获取类型值。接下来，我们将查看弹出部分。
- en: Popping from the stack
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从栈中弹出
- en: Popping from the Lua stack is a reverse operation of the pushing part. We will
    get the value from the Lua stack and use the Lua `lua_type` library function to
    check its Lua type, and then create a C++ `LuaValue` object with a matching `LuaType`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Lua 栈中弹出是推送部分的逆操作。我们将从 Lua 栈中获取值，并使用 Lua `lua_type` 库函数来检查其 Lua 类型，然后创建一个具有匹配
    `LuaType` 的 C++ `LuaValue` 对象。
- en: 'To make things more modular, we will create two functions:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更加模块化，我们将创建两个函数：
- en: '`getValue` to convert a Lua stack position to a `LuaValue`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getValue` 将 Lua 栈位置转换为 `LuaValue`'
- en: '`popValue` to pop and return the top of the stack'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`popValue` 用于弹出并返回栈顶元素'
- en: 'Add the following declarations to `LuaExecutor.h`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下声明添加到 `LuaExecutor.h` 中：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In `LuaExecutor.cc`, let us first implement `getValue`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LuaExecutor.cc` 中，让我们首先实现 `getValue`：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The code is quite straightforward. First, we check the Lua type of a requested
    stack location, and then we return a `LuaValue` accordingly. For the unsupported
    Lua types, for example, table and function, we just return `LuaNil` for now. With
    this, we can implement `popValue` as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 代码相当直接。首先，我们检查请求的栈位置的 Lua 类型，然后相应地返回一个 `LuaValue`。对于不支持的 Lua 类型，例如表和函数，我们目前只返回
    `LuaNil`。有了这个，我们可以如下实现 `popValue`：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We first call `getValue` with `-1` as the stack location to get the top of the
    stack. Then we pop the top of the stack.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用 `-1` 作为栈位置调用 `getValue` 来获取栈顶元素。然后我们弹出栈顶元素。
- en: With the stack operations implemented, we can now implement the new `call` function
    by putting the stack operations together.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了栈操作之后，我们现在可以通过组合栈操作来实现新的 `call` 函数。
- en: Putting it together
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将其组合起来
- en: 'Take a moment to read the old `call` function implementation again. It is shown
    as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间再次阅读旧的 `call` 函数实现。如下所示：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To implement our new `call` function, not much needs to be changed. We only
    need to replace the two lines of code doing stack operations with the new helper
    functions we have just implemented. Write the new call function in `LuaExecutor.cc`
    as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现我们的新 `call` 函数，不需要做太多更改。我们只需要将执行栈操作的代码行替换为我们刚刚实现的新的辅助函数。在 `LuaExecutor.cc`
    中编写新的 `call` 函数如下：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have replaced the lines working with `std::string` with new lines working
    with `LuaValue`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将处理 `std::string` 的行替换为处理 `LuaValue` 的新行。
- en: 'Since we have a dedicated `getValue` function and `popValue` to covert a raw
    Lua value to a `LuaValue`, we can take the chance to make `popString` use them
    as well. Rewrite it as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有一个专门的 `getValue` 函数和 `popValue` 函数来将原始 Lua 值转换为 `LuaValue`，我们可以利用这个机会让
    `popString` 也使用它们。重写如下：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we have gotten rid of the use of Lua library functions in `popString`.
    It is a good practice to limit the dependency on a third-party library to only
    a few functions. Another way to think about this is, in a class, internally, there
    can be low-level functions and high-level functions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经去掉了在 `popString` 中使用 Lua 库函数。限制对第三方库的依赖仅限于少数几个函数是一种良好的实践。另一种思考方式是，在一个类中，内部可以有低级函数和高级函数。
- en: Next, let us test our improved Lua executor.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们测试我们改进的 Lua 执行器。
- en: Testing it out
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试一下
- en: 'Because we have used C++17 features to implement `LuaValue`, we will write
    the test code in modern C++ as well. Write `main.cpp` as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了 C++17 特性来实现 `LuaValue`，因此我们将使用现代 C++ 编写测试代码。编写 `main.cpp` 如下：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this test code, we first use `std::unique_ptr` to hold our Lua executor
    and its listener, and then load the Lua script with the `greetings` Lua function.
    This Lua function is from the last chapter. The real actions are calling the Lua
    function twice: first with `LuaString`, then with `LuaNumber`.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在此测试代码中，我们首先使用 `std::unique_ptr` 来持有我们的 Lua 执行器和其监听器，然后使用 `greetings` Lua 函数加载
    Lua 脚本。这个 Lua 函数来自上一章。实际操作是调用 Lua 函数两次：首先使用 `LuaString`，然后使用 `LuaNumber`。
- en: 'Compile and run the test code. If you have done everything correctly, you should
    see the following output:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行测试代码。如果你一切都做对了，你应该看到以下输出：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you see compiler or linker errors, do not feel discouraged. It is common
    to see a few cryptic error messages when building new C++ code, especially when
    applying new knowledge. Trace the errors and try to correct them. You can also
    compare with the code in GitHub if you need to.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到编译器或链接器错误，不要感到气馁。在构建新的 C++ 代码时，看到一些难以理解的错误信息是很常见的，尤其是在应用新知识时。追踪错误并尝试纠正它们。如果你需要，也可以与
    GitHub 上的代码进行比较。
- en: Note
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We have learned a lot so far. Our improved Lua executor can call Lua functions
    with a more flexible argument, although it is still only accepting one argument.
    By now, you should be comfortable and confident in using a common C++ type to
    represent different Lua types. Take a break and reflect, before moving on to further
    improve our Lua executor to call Lua functions with a variable number of arguments.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学到了很多。我们改进的 Lua 执行器可以以更灵活的方式调用 Lua 函数，尽管它仍然只接受一个参数。现在，你应该对使用常见的 C++
    类型来表示不同的 Lua 类型感到舒适和自信。在继续进一步改进我们的 Lua 执行器以调用接受可变数量参数的 Lua 函数之前，先休息一下并反思。
- en: Now, let us continue to improve our Lua executor.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续改进我们的 Lua 执行器。
- en: Supporting a variable number of arguments
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持可变数量的参数
- en: 'The Lua `function` supports a variable number of arguments. Let us implement
    one in `script.lua`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 的 `function` 支持可变数量的参数。让我们在 `script.lua` 中实现一个：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will return a greeting message and include all arguments in the message.
    The three dots (`...`) indicate that the function takes a variable number of arguments.
    We can iterate through the arguments with `ipairs`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个问候消息，并将所有参数包含在消息中。三个点（`...`）表示该函数接受可变数量的参数。我们可以使用 `ipairs` 遍历参数。
- en: How can we support this in C++? For the stack operations, we only need to push
    more values. The main decision is how we should declare the Lua executor `call`
    function to accept a variable number of arguments.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在 C++ 中支持这一点？对于堆栈操作，我们只需要推送更多的值。主要决定是如何声明 Lua 执行器 `call` 函数以接受可变数量的参数。
- en: Implementing the C++ function
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 C++ 函数
- en: Since C++11, we can use a **variadic function template** to pass a **parameter
    pack**. A parameter pack is a list of arguments of any size.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 自 C++11 以来，我们可以使用 **可变参数函数模板** 来传递 **参数包**。参数包是任意大小的参数列表。
- en: 'In `LuaExecutor.h`, change the `call` function declaration to the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LuaExecutor.h` 中，将 `call` 函数声明更改为以下内容：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`typename... Ts` defines a template parameter pack, and the function takes
    it as the `params` argument.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`typename... Ts` 定义了一个模板参数包，函数将其作为 `params` 参数接受。'
- en: 'Now, let us implement it. Delete the `call` implementation in `LuaExecutor.cc`.
    Since we are now using templates, we need to put the implementation in the header
    file. In `LuaExecutor.h`, add the code as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来实现它。删除 `LuaExecutor.cc` 中的 `call` 实现文件。由于我们现在正在使用模板，我们需要将实现放在头文件中。在 `LuaExecutor.h`
    中添加以下代码：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This implementation can be broken down into four steps, separated by empty
    lines in code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现可以分为四个步骤，代码中通过空行分隔：
- en: It gets the Lua function to call. This has not changed.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它获取要调用的 Lua 函数。这没有变化。
- en: It pushes the C++ function arguments. Here, we choose to make a `std::initializer_list`
    from the parameter pack and loop through it.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它推送 C++ 函数参数。在这里，我们选择从参数包中创建一个 `std::initializer_list` 并遍历它。
- en: It calls the Lua function. We use `sizeof...(params)` to get the size of the
    parameter pack and tell Lua we are sending that many arguments.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它调用 Lua 函数。我们使用 `sizeof...(params)` 获取参数包的大小，并告诉 Lua 我们将发送这么多参数。
- en: It gets the return value from the Lua function and returns it.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它从 Lua 函数中获取返回值并将其返回。
- en: There is more than one way to accomplish *step 2*. You can use a lambda to unpack
    the parameter pack, and there are even different options to write this lambda.
    When, in due course, **C++20** gets adopted, you will have even more options.
    Those are, however, outside the scope of this book. Here, we choose to use a more
    conventional way to implement, so that it is easier to understand by more people.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 完成第 2 步有不止一种方法。你可以使用 lambda 来解包参数包，甚至有不同选项来编写这个 lambda。当 **C++20** 逐渐被采用时，你将拥有更多选项。然而，这些选项超出了本书的范围。在这里，我们选择使用更传统的方式来实现，这样更多的人更容易理解。
- en: Next, let us test whether our implementation works.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们测试我们的实现是否有效。
- en: Testing it out
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试它
- en: 'In `main.cpp`, replace the lines that call `lua->call` and print the result
    as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main.cpp` 中，替换调用 `lua->call` 并打印结果的行，如下所示：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the test code, we have passed two strings to the Lua `greetings` function.
    Since we support a variable number of arguments, you can pass as many arguments
    as you want, zero included. You should see an output similar to `Hello` `C++,
    Lua,`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试代码中，我们向 Lua 的 `greetings` 函数传递了两个字符串。由于我们支持可变数量的参数，你可以传递任意数量的参数，包括零。你应该看到类似
    `Hello` `C++, Lua,` 的输出。
- en: Some more words on our mechanism
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于我们机制的更多说明
- en: 'By now, we have implemented in our Lua executor a general function to call
    any Lua functions, and with any number of arguments. Please take a moment to ponder
    on the following points, which will deepen your understanding:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在 Lua 执行器中实现了一个通用的函数来调用任何 Lua 函数，并且可以接受任意数量的参数。请花点时间思考以下要点，这将加深你的理解：
- en: '*The Lua function being called does not need to be declared as accepting a
    variable number of arguments, while our C++ function is.* When calling a Lua function
    from C++, you always need to tell the Lua library how many arguments have been
    pushed onto the stack.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*被调用的 Lua 函数不需要声明为接受可变数量的参数，而我们的 C++ 函数则需要这样做。* 当从 C++ 调用 Lua 函数时，你总是需要告诉 Lua
    库已经推送到栈上的参数数量。'
- en: '*The Lua function does not need to return a value.* You can try to comment
    out the return statement in the `greetings` function. The C++ side will get a
    `LuaNil`, because the Lua library guarantees to push the requested number of return
    values onto the stack, using nil when the Lua function does not return enough
    values.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Lua 函数不需要返回值。* 你可以尝试注释掉 `greetings` 函数中的返回语句。C++ 方面将得到一个 `LuaNil`，因为 Lua 库保证将请求的返回值数量推送到栈上，当
    Lua 函数没有返回足够值时使用 nil。'
- en: '*The Lua function can return more than one value.* We will only get the first
    value, and the Lua library will discard the rest, because when calling the Lua
    function, we requested only one return value.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Lua 函数可以返回多个值。* 我们只会得到第一个值，Lua 库将丢弃其余的，因为当我们调用 Lua 函数时，我们只请求一个返回值。'
- en: Our current implementation already supports most of the use cases for calling
    plain Lua functions, except for the last point mentioned above. Next, we will
    support multiple return values to complete the Lua function call mechanism.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的实现已经支持了调用普通 Lua 函数的大部分用例，除了上面提到的最后一点。接下来，我们将支持多个返回值以完成 Lua 函数调用机制。
- en: Supporting multiple return values
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持多个返回值
- en: 'To work on retrieving multiple return values, let us first make a Lua function
    that actually does that. In `script.lua`, add the following function:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理获取多个返回值，让我们首先创建一个实际上执行这一操作的 Lua 函数。在 `script.lua` 中添加以下函数：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will get every argument and print out its type. We first put them in a
    table, then we unpack the table so that each table entry is returned as a separate
    value.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取每个参数并打印出其类型。我们首先将它们放入一个表中，然后解包这个表，使得每个表条目作为一个单独的值返回。
- en: Now, we have some decisions to make. We are happy with the current `call` function
    except for its return value. However, we cannot overload a function in C++ for
    a different return type. We need to create another function that returns a list
    of values.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一些决定要做。我们对当前的 `call` 函数很满意，除了它的返回值。然而，在 C++ 中，我们不能为不同的返回类型重载一个函数。我们需要创建另一个返回值列表的函数。
- en: 'How can we get multiple return values from Lua? Compared with `call`, there
    are two differences that we need to tackle:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何从 Lua 获取多个返回值？与 `call` 相比，有两个差异需要我们解决：
- en: How can we tell the Lua library that we are expecting a variable number of return
    values, instead of a fixed number?
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何告诉 Lua 库我们期望一个可变数量的返回值，而不是一个固定数量的？
- en: How can we get this variable number of return values in C++?
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何在 C++ 中获取这个可变数量的返回值？
- en: 'To tackle the first problem, while calling the Lua library `lua_pcall` function,
    we can specify a magic number for the number of expected return values: `LUA_MULTRET`.
    This means that we will take whatever the Lua function returns, without the library
    discarding extra return values or padding with nil. This magic number is the only
    special case to specify the number of return values. It is internally defined
    as `-1` in `lua.h`.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决第一个问题，在调用 Lua 库的 `lua_pcall` 函数时，我们可以指定一个表示预期返回值数量的魔法数字：`LUA_MULTRET`。这意味着我们将接受
    Lua 函数返回的任何内容，而库不会丢弃额外的返回值或用 `nil` 填充。这个魔法数字是唯一需要指定返回值数量的特殊情况。它在 `lua.h` 中内部定义为
    `-1`。
- en: To tackle the second problem, we only need to count how many elements there
    are in the Lua stack before calling the Lua function, and how many elements there
    are after calling the Lua function. This is because the Lua library pushes all
    return values onto the stack, so the new elements in the stack are the return
    values. We have implemented `popValue` to pop the top of the stack. We need another
    function to pop more than one value from the stack.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决第二个问题，我们只需要在调用 Lua 函数前后计算 Lua 栈中的元素数量。这是因为 Lua 库将所有返回值推入栈中，所以栈中的新元素就是返回值。我们已经实现了
    `popValue` 来弹出栈顶元素。我们需要另一个函数来从栈中弹出多个值。
- en: With the two problems solved, let us start to implement.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 解决了这两个问题后，让我们开始实施。
- en: Implementing the C++ function
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 C++ 函数
- en: 'In `LuaExecutor.h`, add the following declarations:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LuaExecutor.h` 中添加以下声明：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We added another function to call Lua functions. We call it `vcall` because
    it returns a `std::vector`. We also added a `popValues` helper function to pop
    the top `n` elements from the Lua stack.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了另一个函数来调用 Lua 函数。我们称它为 `vcall`，因为它返回一个 `std::vector`。我们还添加了一个 `popValues`
    辅助函数，用于从 Lua 栈中弹出顶部 `n` 个元素。
- en: 'First, let us implement `vcall` in `LuaExecutor.h`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在 `LuaExecutor.h` 中实现 `vcall`：
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We now have five steps, which are explained as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有五个步骤，具体说明如下：
- en: Record the stack size before doing anything else with `lua_gettop`.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `lua_gettop` 记录栈大小。
- en: Get the Lua function onto the stack with `lua_getglobal`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `lua_getglobal` 将 Lua 函数推入栈中。
- en: Push all the arguments onto the stack with `pushValue`.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `pushValue` 将所有参数推入栈中。
- en: Call the Lua function with `pcall` and pass `LUA_MULTRET` to indicate that we
    will take all the return values from the Lua function. The Lua library will guarantee
    to pop all elements you pushed in *step 2* and *step 3*.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `pcall` 调用 Lua 函数，并传递 `LUA_MULTRET` 以指示我们将从 Lua 函数中获取所有返回值。Lua 库将保证弹出你在 *步骤
    2* 和 *步骤 3* 中推入的所有元素。
- en: Pop all the return values from the stack and return them with `popValues`. We
    check the stack size again. The new stack size minus the original stack size stored
    in `stackSz` is the number of values returned.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `popValues` 弹出所有返回值并将它们返回。我们再次检查栈大小。新栈大小减去存储在 `stackSz` 中的原始栈大小就是返回值的数量。
- en: 'Next, we will implement the final piece, the helper function, to pop all return
    values from the Lua stack. In `LuaExecutor.cc`, add the following code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现最后一部分，即辅助函数，用于从 Lua 栈中弹出所有返回值。在 `LuaExecutor.cc` 中添加以下代码：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Lua pushes the first return value onto the stack, then the second, and so on.
    So, the top of the stack needs to be stored at the end of the vector. Here, we
    read the return values in sequence, starting from the middle of the stack and
    moving toward the top of the stack. `-i` is the `ith` position counting from the
    top of the stack.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 将第一个返回值推入栈中，然后是第二个，依此类推。因此，栈顶需要存储在向量的末尾。在这里，我们按顺序读取返回值，从栈的中间开始，向栈顶移动。`-i`
    是从栈顶开始计算的 `ith` 位置。
- en: Next, let’s test this out.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们测试一下。
- en: Testing it out
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试
- en: 'In `main.cpp`, change the test code as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main.cpp` 中，按照以下方式更改测试代码：
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We are passing a list of different types of `LuaValue` (`LuaString`, `LuaNumber`,
    `LuaBoolean` and `LuaNil`) to our new function. This will output the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向新函数传递了不同类型的 `LuaValue` 列表（`LuaString`、`LuaNumber`、`LuaBoolean` 和 `LuaNil`）。这将输出以下内容：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Have you observed anything unusual? We have passed five arguments but only got
    four return values! `LuaNil` is not printed out. Why? This is because, in `dump_params`,
    we used `table.unpack` to return multiple values. Lua’s `table.unpack` will stop
    when it sees a nil value. If you move `LuaNil::make()` to the middle of the list,
    you will miss more return values. This is expected. This is a Lua thing. Similar
    to a C++ `char*` string, it will end when it first sees a `NULL` character.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你观察到任何异常情况吗？我们传递了五个参数，但只得到了四个返回值！`LuaNil` 没有打印出来。为什么？这是因为，在 `dump_params` 中，我们使用了
    `table.unpack` 来返回多个值。Lua 的 `table.unpack` 会停止在它看到 nil 值时。如果你将 `LuaNil::make()`
    移到列表的中间，你会错过更多的返回值。这是预期的。这是 Lua 的事情。类似于 C++ 的 `char*` 字符串，它会在第一次看到 `NULL` 字符时结束。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we first explored how to map Lua types to C++ types, with the
    goal of ease of use in C++ function calls. Then, we learned about a general way
    to call any Lua functions.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先探讨了如何将 Lua 类型映射到 C++ 类型，目的是在 C++ 函数调用中易于使用。然后，我们了解了一种调用任何 Lua 函数的通用方法。
- en: This chapter progressed step by step. You continued to improve the Lua executor.
    Each step produced a milestone. This, in turn, was based on the work from the
    last chapter. Going through the following exercises will also give you a chance
    to recap what you have learned with hands-on coding. We will continue the book
    with this methodology.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '本章逐步推进。你继续改进 Lua 执行器。每一步都产生了一个里程碑。这反过来又基于上一章的工作。通过以下练习，你也将有机会通过实际编码回顾你所学的知识。我们将继续使用这种方法继续本书。 '
- en: In the next chapter, we will learn how to integrate Lua tables.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何集成 Lua 表。
- en: Exercises
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Implement `LuaType::function` and `LuaFunction` to cover the Lua function type.
    Do not worry about the value field in `LuaFunction`. You can use `nullptr`. To
    test it, you need to call a Lua function that returns another function, and in
    C++, print out that the return value is a function.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `LuaType::function` 和 `LuaFunction` 以涵盖 Lua 函数类型。无需担心 `LuaFunction` 中的值字段。你可以使用
    `nullptr`。为了测试它，你需要调用一个返回另一个函数的 Lua 函数，并在 C++ 中打印出返回值是一个函数。
- en: Implement `LuaType::table` and `LuaTable` to cover the Lua table type. Follow
    the same instructions as for the previous question.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `LuaType::table` 和 `LuaTable` 以涵盖 Lua 表类型。遵循与上一个问题相同的说明。
- en: In the last chapter, we implemented `getGlobalString` and `setGlobal` to work
    with Lua global values. Rewrite those two methods to support more types. You can
    use the new names `getGlobal` and `setGlobal`, and use `LuaValue`.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一章中，我们实现了 `getGlobalString` 和 `setGlobal` 以与 Lua 全局值一起工作。重写这两个方法以支持更多类型。你可以使用新的名称
    `getGlobal` 和 `setGlobal`，并使用 `LuaValue`。
- en: Implement a private `dumpStack` debug function. This function will dump the
    current Lua stack. You only need to support the currently supported types in `LuaValue`.
    Insert a call to this function in different places in `LuaExecutor`. This will
    deepen your understanding of the Lua stack.**
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个私有的 `dumpStack` 调试函数。此函数将输出当前 Lua 栈。你只需要支持 `LuaValue` 中当前支持的类型。在 `LuaExecutor`
    的不同位置插入对该函数的调用。这将加深你对 Lua 栈的理解。**
