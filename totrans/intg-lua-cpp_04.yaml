- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mapping Lua Types to C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to call a Lua function with a single
    string argument that returns one string value. In this chapter, we will learn
    how to call a Lua function with any type and any number of arguments and support
    multiple return values. To do this, we need to find a convenient way to map Lua
    types to C++ types. Then, we will build upon this type system to improve our Lua
    executor step by step. During this process, you will continue to deepen your understanding
    of the Lua stack and learn how to use some of the modern C++ features to integrate
    Lua.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Mapping Lua types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting different argument types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting a variable number of arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting multiple return values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter is more C++ coding intensive. To better follow this chapter, please
    make sure you understand the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You are familiar with the modern C++ standards. We will start to use features
    from **C++11** and **C++17**. If you have only used **C++03**, please take a while
    to study the new C++ features on your own when you encounter them in this chapter.
    As a heads-up, we will use **enum class**, **std::variant**, **std::visit**, and
    **std::initializer_list**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can access the source code for this chapter here: [https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter04](https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter04).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can understand and execute the code in the `begin` folder from the preceding
    GitHub link. The `begin` folder has some necessary solutions from the last chapterâ€™s
    questions integrated and acts as the starting point for this chapter. We will
    add new features implemented in this chapter to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping Lua types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 2*, *Lua Fundamentals*, we learned about the Lua types. They are
    different from C++ types. To use them in C++, we need to do some mapping. In *Chapter
    3*, *How to Call Lua from C++*, we mapped the Lua string to the C++ `std::string`.
    It is mapped by hardcoding it in our Lua executor.
  prefs: []
  type: TYPE_NORMAL
- en: What if we want to support all possible Lua types, both in the function arguments
    and in function return values? What if we want to call Lua functions with different
    numbers of arguments? It is not feasible to create a C++ function for each argument
    type and argument count combination. That way, our Lua executor would be plagued
    with hundreds of functions just to call Lua functions!
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, C++ is powerful with its **object-oriented programming** and its
    **generic programming**. These two paradigms lead to two different ways in which
    you can solve problems in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring different mapping options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As said, C++ supports object-oriented programming and generic programming. We
    can design a type system with either of them.
  prefs: []
  type: TYPE_NORMAL
- en: Using object-oriented types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This approach is probably easier to understand. It has been supported since
    the birth of C++. We can define an abstract base class that represents all possible
    types, then inherit it and implement a concrete class for each type.
  prefs: []
  type: TYPE_NORMAL
- en: Besides C++, most programming languages support this method. If you or your
    team work with multiple programming languages, this method might cause less concept
    switching in work.
  prefs: []
  type: TYPE_NORMAL
- en: But this approach is also more verbose. You will have other considerations as
    well. For example, after the mappings are defined, you would want to prevent creating
    new types that do not exist in Lua. You would have to make base class constructors
    private and declare a few friends.
  prefs: []
  type: TYPE_NORMAL
- en: Using generic types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This approach depends on a new C++17 feature: *std::variant*. You can define
    and map a simple C++ class for each Lua type without inheritance. Then you create
    a union type with `std::variant`, saying that this union type may be and can only
    be from the pre-defined Lua mappings.'
  prefs: []
  type: TYPE_NORMAL
- en: This will result in less code. The less code, the less chance that something
    will go wrong. Modern programming tends to adopt new paradigms, besides the vanilla
    object-oriented methodology.
  prefs: []
  type: TYPE_NORMAL
- en: The drawback of this approach is that not all organizations adopt the new C++
    standards that fast, which in turn makes them less widely understood.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will implement that approach. After going through this chapter,
    if you prefer, you can implement object-oriented types on your own. But before
    we move on, let us look at the `Makefile` used for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing some new Makefile tricks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before diving into the details, let us go through the `Makefile`. You can find
    a copy in the `begin` folder in the GitHub repository, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There are only four differences compared to the `Makefile` used in *Chapter
    3*:'
  prefs: []
  type: TYPE_NORMAL
- en: In `CXXFLAGS`, we require the compiler to compile our code as C++17 by adding
    `-std=c++17`. Without this, it will use the default standard, which may be an
    older C++ version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new variable, `ALL_O`, defines all the object files that will be produced.
    Each C++ source file will be compiled into an object file. Remember to add a new
    object file here when you add a new source file. Otherwise, without the object
    file produced, the linker cannot find the symbols that should have been in the
    missing object file, and you will get linker errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `project` target now depends on all object files. `Make` is smart enough
    to compile the object files from the source files for you automatically by using
    the corresponding source file as a dependency for the object file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `all` target has an extra dependency: the `clean` target. This always cleans
    the project and rebuilds it. When you write an object file target manually, you
    can make it depend on multiple header files. When `Make` does this for you, it
    cannot tell which header files need to be depended on. So, this is a trick for
    small projects for study purposes. For more formal projects, you should consider
    supporting compiling everything correctly without cleaning it first.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you struggle to understand this `Makefile`, please check the explanation
    in *Chapter 1* and *Chapter 3*. Better yet, you can research more online. If you
    have no urgent need to learn about the `Makefile`, it is also perfectly fine just
    to use it as it is, and be comfortable with it.
  prefs: []
  type: TYPE_NORMAL
- en: Remember
  prefs: []
  type: TYPE_NORMAL
- en: The `Makefile` examples used in this book favor simplicity, rather than production
    flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: We have distracted ourselves a bit from C++ by explaining some new `Makefile`
    mechanisms. This will be the last time we go through a `Makefile` in this book.
    In the following chapters, please refer to the GitHub source code.
  prefs: []
  type: TYPE_NORMAL
- en: The explanation was necessary, in case you get cryptic errors from the C++ compiler
    and linker. Now we can go back to our focus. We will define some simple C++ structures
    that map to Lua types. After this, we can use `std::variant` to declare a union
    type. Having a union type will enable us to pass a value of any type to our C++
    functions. Now, let us define the Lua types in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Lua types in C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first order of business is how we can define a Lua type in C++. We want
    a clear definition of Lua types, so things such as `std::string` are no longer
    unique enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since C++11, we have *enum class* support. We can limit our Lua types with
    an enum class in C++ as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For now, we only support the Lua basic types that can map to simple C++ types.
    You can put this declaration in a file named `LuaType.hpp` and include it in `LuaExecutor.h`
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We call it `*.hpp` because we will put the type implementations in the header
    file directly and inline all the functions. This is partly because the implementation
    classes will be simple, and partly because this is a book, and limiting the number
    of lines of code is important. You can separate the code into a header file and
    a source file or name this header file with implementations `LuaType.h`. This
    depends on convention, as per each company or organization, and there are many
    ways to do something in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Lua types in C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As explained, we will use simple classes without inheritance. Each class will
    have two fields: a `type` field of `LuaType` we just defined, and a `value` field
    for the actual data storage in C++.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `LuaType.hpp`, implement four structures. In C++, a structure is the same
    as a class, but with public access to its members by default. We use structures
    conventionally when we want to define data. First, implement `LuaType::nil`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We choose to use `nullptr` to represent a Lua nil value. Its type is `std::nullptr_t`.
    We also make the constructor private and provide a static function to create new
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns
  prefs: []
  type: TYPE_NORMAL
- en: Here, we used a design pattern â€“ the static factory method with a private constructor.
    In our implementation, this will prevent creating objects on the heap with `new`.
    The C++ structures for Lua types do not provide copy constructors either. This
    is a design choice â€“ you either fully support passing it around and assigning
    to it or limit its usage. In this book, we limit its usage purely when interacting
    with the Lua executor on the C++ stack. If you have another layer above the Lua
    executor, you need to convert the structures to C++ basic types or your own type.
    This helps with abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, implement `LuaType::boolean`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The static `make` function accepts a `boolean` value to create an instance.
    In the private constructor, we use a member initializer list to initialize the
    `value` member variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `LuaType::number`, we choose to use the C++ double type to store the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Lua itself does not distinguish between an integer and a float in the basic
    *number* type, but if you need to, you can create two C++ types for integers and
    floats separately. To do this, you can use the Lua `lua_isinteger` library function
    to check whether the number is an integer. If it is not, it is a double. In this
    book, we only implement mappings for the basic Lua types. In a gaming system,
    you might want to enforce using the float type. In an embedded system, you might
    want to enforce using the integer type. Or, you can support using both in a project.
    This is easy to achieve by referencing the implementation for `LuaNumber`.
  prefs: []
  type: TYPE_NORMAL
- en: Linking knowledge
  prefs: []
  type: TYPE_NORMAL
- en: In Lua code, you can use the `math.type` library function to check whether a
    number is an integer or a float.
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, for `LuaType::string`, we use `std::string` to store the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This concludes our type implementations. Next is where all the magic happens.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a union type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have defined a `LuaType` enum class to identify Lua types, and structures
    to represent Lua values of different types. When we want to pass a Lua value around,
    we need a type to represent them all. Without using a common base class, we can
    use `std::variant`. It is a template class taking a list of types as its parameters.
    Then it can safely represent any of these types in code. To see it in action,
    add the following to `LuaType.hpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `using` keyword creates a type alias, `LuaValue`. It can represent any of
    the four specified types in the template parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the union type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have not used `std::variant` before, you may have wondered how can we
    tell which actual type it is holding. If you pass a value of `LuaValue` around,
    you cannot access the `type` or the `value` field directly. This is because there
    is no common base class. At compile time, the compiler does not know what fields
    are supported by simply looking at the `std::variant` variable. To do this, we
    need a small twist. C++17 also provides `std::visit` to help with this. Let us
    implement a helper function to get the `LuaType` from a `LuaValue`. In `LuaType.hpp`,
    add the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This function is an `the call site more efficient. Moreover, it needs to be
    an inline function because we are implementing it in the header file directly.
    Without the **inline**` **keyword, the function may get included in different
    source files with the same symbol, which leads to link errors.**
  prefs: []
  type: TYPE_NORMAL
- en: '**`std::visit` takes two arguments. The first is a C++ `std::visit` makes the
    type information available. If you have never come across this concept or usage
    before, it may take some time to digest. You can consider this callable a **lambda**.
    If you have used lambda from other programming languages, such as Java, Kotlin,
    Swift, or Python, the C++ one is very similar. In other programming languages,
    more often than not, the lambda is the last parameter, which is called a **trailing
    lambda** and in some cases is easier to read. The best way to learn about C++
    lambda is to use it and try to feel comfortable with it until you have fully mastered
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, let us implement another helper function to get the string representation
    of each type. In `LuaTypp.hpp`, add the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will help us to test our implementations in the rest of this chapter by
    getting what is stored in a `LuaValue`. You can use `std::get` to get a specific
    type from a `std::variant` union.
  prefs: []
  type: TYPE_NORMAL
- en: We have talked about `std::variant`, `std::visit`, and `std::get`, but not enough
    to be a C++ expert in this area. Before moving on, feel free to research more
    on them.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us use the Lua mapping we have implemented to make calling Lua functions
    more flexible. First, we will get rid of the hardcoded `std::string` used for
    the `call` function in our Lua executor.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting different argument types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last chapter, we implemented our C++ function to call a Lua function
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Our goal in this step is to make it more general and we want the following
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In fact, go ahead and change this in `LuaExecutor.h`. To make it work, we will
    implement helper functions to push onto and pop from the Lua stack, with our `LuaValue`
    C++ type instead of `std::string`. Let us work on pushing onto the stack first.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing onto the stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous call function, we pushed the `param` argument of the `std::string`
    type onto the Lua stack with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To support more Lua types, we can implement a `pushValue` method that takes
    `LuaValue` as an argument and calls different `lua_pushX` Lua library functions
    based on the `type` field of `LuaValue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `LuaExecutor.h`, add the declaration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And in `LuaExecutor.cc`, implement the `pushValue` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Our implementation only uses one `switch` statement on `LuaType`. We implemented
    `getLuaType` in `LuaType.hpp` earlier in this chapter. In each `case`, we use
    `std::get` to get the typed value from the `LuaValue` type union. Next, we will
    look at the popping part.
  prefs: []
  type: TYPE_NORMAL
- en: Popping from the stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Popping from the Lua stack is a reverse operation of the pushing part. We will
    get the value from the Lua stack and use the Lua `lua_type` library function to
    check its Lua type, and then create a C++ `LuaValue` object with a matching `LuaType`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things more modular, we will create two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getValue` to convert a Lua stack position to a `LuaValue`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`popValue` to pop and return the top of the stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add the following declarations to `LuaExecutor.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In `LuaExecutor.cc`, let us first implement `getValue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is quite straightforward. First, we check the Lua type of a requested
    stack location, and then we return a `LuaValue` accordingly. For the unsupported
    Lua types, for example, table and function, we just return `LuaNil` for now. With
    this, we can implement `popValue` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We first call `getValue` with `-1` as the stack location to get the top of the
    stack. Then we pop the top of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: With the stack operations implemented, we can now implement the new `call` function
    by putting the stack operations together.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Take a moment to read the old `call` function implementation again. It is shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement our new `call` function, not much needs to be changed. We only
    need to replace the two lines of code doing stack operations with the new helper
    functions we have just implemented. Write the new call function in `LuaExecutor.cc`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We have replaced the lines working with `std::string` with new lines working
    with `LuaValue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have a dedicated `getValue` function and `popValue` to covert a raw
    Lua value to a `LuaValue`, we can take the chance to make `popString` use them
    as well. Rewrite it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have gotten rid of the use of Lua library functions in `popString`.
    It is a good practice to limit the dependency on a third-party library to only
    a few functions. Another way to think about this is, in a class, internally, there
    can be low-level functions and high-level functions.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us test our improved Lua executor.
  prefs: []
  type: TYPE_NORMAL
- en: Testing it out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because we have used C++17 features to implement `LuaValue`, we will write
    the test code in modern C++ as well. Write `main.cpp` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In this test code, we first use `std::unique_ptr` to hold our Lua executor
    and its listener, and then load the Lua script with the `greetings` Lua function.
    This Lua function is from the last chapter. The real actions are calling the Lua
    function twice: first with `LuaString`, then with `LuaNumber`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile and run the test code. If you have done everything correctly, you should
    see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If you see compiler or linker errors, do not feel discouraged. It is common
    to see a few cryptic error messages when building new C++ code, especially when
    applying new knowledge. Trace the errors and try to correct them. You can also
    compare with the code in GitHub if you need to.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We have learned a lot so far. Our improved Lua executor can call Lua functions
    with a more flexible argument, although it is still only accepting one argument.
    By now, you should be comfortable and confident in using a common C++ type to
    represent different Lua types. Take a break and reflect, before moving on to further
    improve our Lua executor to call Lua functions with a variable number of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us continue to improve our Lua executor.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting a variable number of arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Lua `function` supports a variable number of arguments. Let us implement
    one in `script.lua`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This will return a greeting message and include all arguments in the message.
    The three dots (`...`) indicate that the function takes a variable number of arguments.
    We can iterate through the arguments with `ipairs`.
  prefs: []
  type: TYPE_NORMAL
- en: How can we support this in C++? For the stack operations, we only need to push
    more values. The main decision is how we should declare the Lua executor `call`
    function to accept a variable number of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the C++ function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since C++11, we can use a **variadic function template** to pass a **parameter
    pack**. A parameter pack is a list of arguments of any size.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `LuaExecutor.h`, change the `call` function declaration to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`typename... Ts` defines a template parameter pack, and the function takes
    it as the `params` argument.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us implement it. Delete the `call` implementation in `LuaExecutor.cc`.
    Since we are now using templates, we need to put the implementation in the header
    file. In `LuaExecutor.h`, add the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This implementation can be broken down into four steps, separated by empty
    lines in code:'
  prefs: []
  type: TYPE_NORMAL
- en: It gets the Lua function to call. This has not changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It pushes the C++ function arguments. Here, we choose to make a `std::initializer_list`
    from the parameter pack and loop through it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It calls the Lua function. We use `sizeof...(params)` to get the size of the
    parameter pack and tell Lua we are sending that many arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It gets the return value from the Lua function and returns it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is more than one way to accomplish *step 2*. You can use a lambda to unpack
    the parameter pack, and there are even different options to write this lambda.
    When, in due course, **C++20** gets adopted, you will have even more options.
    Those are, however, outside the scope of this book. Here, we choose to use a more
    conventional way to implement, so that it is easier to understand by more people.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us test whether our implementation works.
  prefs: []
  type: TYPE_NORMAL
- en: Testing it out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `main.cpp`, replace the lines that call `lua->call` and print the result
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the test code, we have passed two strings to the Lua `greetings` function.
    Since we support a variable number of arguments, you can pass as many arguments
    as you want, zero included. You should see an output similar to `Hello` `C++,
    Lua,`.
  prefs: []
  type: TYPE_NORMAL
- en: Some more words on our mechanism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By now, we have implemented in our Lua executor a general function to call
    any Lua functions, and with any number of arguments. Please take a moment to ponder
    on the following points, which will deepen your understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The Lua function being called does not need to be declared as accepting a
    variable number of arguments, while our C++ function is.* When calling a Lua function
    from C++, you always need to tell the Lua library how many arguments have been
    pushed onto the stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Lua function does not need to return a value.* You can try to comment
    out the return statement in the `greetings` function. The C++ side will get a
    `LuaNil`, because the Lua library guarantees to push the requested number of return
    values onto the stack, using nil when the Lua function does not return enough
    values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Lua function can return more than one value.* We will only get the first
    value, and the Lua library will discard the rest, because when calling the Lua
    function, we requested only one return value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our current implementation already supports most of the use cases for calling
    plain Lua functions, except for the last point mentioned above. Next, we will
    support multiple return values to complete the Lua function call mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting multiple return values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To work on retrieving multiple return values, let us first make a Lua function
    that actually does that. In `script.lua`, add the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will get every argument and print out its type. We first put them in a
    table, then we unpack the table so that each table entry is returned as a separate
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have some decisions to make. We are happy with the current `call` function
    except for its return value. However, we cannot overload a function in C++ for
    a different return type. We need to create another function that returns a list
    of values.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we get multiple return values from Lua? Compared with `call`, there
    are two differences that we need to tackle:'
  prefs: []
  type: TYPE_NORMAL
- en: How can we tell the Lua library that we are expecting a variable number of return
    values, instead of a fixed number?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we get this variable number of return values in C++?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To tackle the first problem, while calling the Lua library `lua_pcall` function,
    we can specify a magic number for the number of expected return values: `LUA_MULTRET`.
    This means that we will take whatever the Lua function returns, without the library
    discarding extra return values or padding with nil. This magic number is the only
    special case to specify the number of return values. It is internally defined
    as `-1` in `lua.h`.'
  prefs: []
  type: TYPE_NORMAL
- en: To tackle the second problem, we only need to count how many elements there
    are in the Lua stack before calling the Lua function, and how many elements there
    are after calling the Lua function. This is because the Lua library pushes all
    return values onto the stack, so the new elements in the stack are the return
    values. We have implemented `popValue` to pop the top of the stack. We need another
    function to pop more than one value from the stack.
  prefs: []
  type: TYPE_NORMAL
- en: With the two problems solved, let us start to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the C++ function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `LuaExecutor.h`, add the following declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We added another function to call Lua functions. We call it `vcall` because
    it returns a `std::vector`. We also added a `popValues` helper function to pop
    the top `n` elements from the Lua stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let us implement `vcall` in `LuaExecutor.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have five steps, which are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Record the stack size before doing anything else with `lua_gettop`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the Lua function onto the stack with `lua_getglobal`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push all the arguments onto the stack with `pushValue`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the Lua function with `pcall` and pass `LUA_MULTRET` to indicate that we
    will take all the return values from the Lua function. The Lua library will guarantee
    to pop all elements you pushed in *step 2* and *step 3*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pop all the return values from the stack and return them with `popValues`. We
    check the stack size again. The new stack size minus the original stack size stored
    in `stackSz` is the number of values returned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will implement the final piece, the helper function, to pop all return
    values from the Lua stack. In `LuaExecutor.cc`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Lua pushes the first return value onto the stack, then the second, and so on.
    So, the top of the stack needs to be stored at the end of the vector. Here, we
    read the return values in sequence, starting from the middle of the stack and
    moving toward the top of the stack. `-i` is the `ith` position counting from the
    top of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Next, letâ€™s test this out.
  prefs: []
  type: TYPE_NORMAL
- en: Testing it out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `main.cpp`, change the test code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We are passing a list of different types of `LuaValue` (`LuaString`, `LuaNumber`,
    `LuaBoolean` and `LuaNil`) to our new function. This will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Have you observed anything unusual? We have passed five arguments but only got
    four return values! `LuaNil` is not printed out. Why? This is because, in `dump_params`,
    we used `table.unpack` to return multiple values. Luaâ€™s `table.unpack` will stop
    when it sees a nil value. If you move `LuaNil::make()` to the middle of the list,
    you will miss more return values. This is expected. This is a Lua thing. Similar
    to a C++ `char*` string, it will end when it first sees a `NULL` character.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we first explored how to map Lua types to C++ types, with the
    goal of ease of use in C++ function calls. Then, we learned about a general way
    to call any Lua functions.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter progressed step by step. You continued to improve the Lua executor.
    Each step produced a milestone. This, in turn, was based on the work from the
    last chapter. Going through the following exercises will also give you a chance
    to recap what you have learned with hands-on coding. We will continue the book
    with this methodology.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to integrate Lua tables.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implement `LuaType::function` and `LuaFunction` to cover the Lua function type.
    Do not worry about the value field in `LuaFunction`. You can use `nullptr`. To
    test it, you need to call a Lua function that returns another function, and in
    C++, print out that the return value is a function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement `LuaType::table` and `LuaTable` to cover the Lua table type. Follow
    the same instructions as for the previous question.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the last chapter, we implemented `getGlobalString` and `setGlobal` to work
    with Lua global values. Rewrite those two methods to support more types. You can
    use the new names `getGlobal` and `setGlobal`, and use `LuaValue`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a private `dumpStack` debug function. This function will dump the
    current Lua stack. You only need to support the currently supported types in `LuaValue`.
    Insert a call to this function in different places in `LuaExecutor`. This will
    deepen your understanding of the Lua stack.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
