["```cpp\ntemplate <class T>\n   class Vector {\n      T *elems;\n      T *end_elems;\n      T *end_storage;\n      // ...\n```", "```cpp\ntemplate <class T>\n   class Vector {\n      T *elems;\n      std:size_t nelems; // number of elements\n      std::size_t cap; // capacity\n      // ...\n```", "```cpp\n#include <cstddef>\n#include <algorithm>\n#include <utility>\n#include <initializer_list>\n#include <iterator>\n#include <type_traits>\ntemplate <class T>\n   class Vector {\n   public:\n      using value_type = T;\n      using size_type = std::size_t;\n      using pointer = T*;\n      using const_pointer = const T*;\n      using reference = T&;\n      using const_reference = const T&;\n   private:\n      pointer elems{};\n      size_type nelems{},\n                cap{};\n      // ...\n```", "```cpp\n   // ...\n   public:\n      size_type size() const { return nelems; }\n      size_type capacity() const { return cap; }\n      bool empty() const { return size() == 0; }\n   private:\n      bool full() const { return size() == capacity(); }\n   // ...\n```", "```cpp\n      // ...\n   public:\n      using iterator = pointer;\n      using const_iterator = const_pointer;\n      iterator begin() { return elems; }\n      const_iterator begin() const { return elems; }\n      iterator end() { return begin() + size(); }\n      const_iterator end() const {\n         return begin() + size();\n      }\n      // for users' convenience\n      const_iterator cend() const { return end(); }\n      const_iterator cbegin() const { return begin(); }\n      // ...\n```", "```cpp\n      // alternative approach (requires C++23)\n      template <class S>\n         auto begin(this S && self) { return self.elems; }\n      template <class S>\n         auto end(this S && self) {\n            return self.begin() + self.size();\n         }\n```", "```cpp\n      // ...\n      Vector() = default;\n      Vector(size_type n, const_reference init)\n         : elems{ new value_type[n] },\n           nelems{ n }, cap{ n } {\n         try {\n            std::fill(begin(), end(), init);\n         } catch(...) {\n            delete [] elems;\n            throw;\n         }\n      }\n      // ...\n```", "```cpp\n      // ...\n      Vector(const Vector &other)\n         : elems{ new value_type[other.size()] },\n           nelems{ other.size() }, cap{ other.size() } {\n         try {\n            std::copy(other.begin(), other.end(), begin());\n         } catch(...) {\n            delete [] elems;\n            throw;\n         }\n      }\n      // ...\n      Vector(Vector &&other) noexcept\n         : elems{ std::exchange(other.elems, nullptr) },\n           nelems{ std::exchange(other.nelems, 0) },\n           cap{ std::exchange(other.cap, 0) } {\n      }\n      // ...\n```", "```cpp\n      // ...\n      Vector(std::initializer_list<T> src)\n         : elems{ new value_type[src.size()] },\n           nelems {src.size() }, cap{ src.size() } {\n         try {\n            std::copy(src.begin(), src.end(), begin());\n         } catch(...) {\n            delete [] elems;\n            throw;\n         }\n      }\n      // ...\n      ~Vector() {\n         delete [] elems;\n      }\n```", "```cpp\n      // ...\n      void swap(Vector &other) noexcept {\n         using std::swap;\n         swap(elems, other.elems);\n         swap(nelems, other.nelems);\n         swap(cap, other.cap);\n      }\n      Vector& operator=(const Vector &other) {\n         Vector{ other }.swap(*this);\n         return *this;\n      }\n      Vector& operator=(Vector &&other) {\n         Vector{ std::move(other) }.swap(*this);\n         return *this;\n      }\n      // ...\n```", "```cpp\n      // ...\n      reference operator[](size_type n) {\n         return elems[n];\n      }\n      const_reference operator[](size_type n) const {\n         return elems[n];\n      }\n      // precondition: !empty()\n      reference front() { return (*this)[0]; }\n      const_reference front() const { return (*this)[0]; }\n      reference back() { return (*this)[size() - 1]; }\n      const_reference back() const {\n         return (*this)[size() - 1];\n      }\n      // ...\n```", "```cpp\n      // alternative approach, (requires C++23)\n      // ...\n      template <class S>\n         decltype(auto) operator[](this S && self,\n                                   size_type n) {\n            return self.elems[n];\n         }\n      // precondition: !empty()\n      template <class S>\n         decltype(auto) front(this S &&self) {\n            return self[0];\n         }\n      template <class S>\n         decltype(auto) back(this S &&self) {\n            return self[self.size()-1];\n         }\n      // ...\n```", "```cpp\n      // ...\n      bool operator==(const Vector &other) const {\n         return size() == other.size() &&\n                std::equal(begin(), end(), other.begin());\n      }\n      // can be omitted since C++20 (synthesized by\n      // the compiler through operator==())\n      bool operator!=(const Vector &other) const {\n         return !(*this == other);\n      }\n      // ...\n```", "```cpp\n      // ...\n      void push_back(const_reference val) {\n         if(full())\n            grow();\n         elems[size()] = val;\n         ++nelems;\n      }\n      void push_back(T &&val) {\n         if(full())\n            grow();\n         elems[size()] = std::move(val);\n         ++nelems;\n      }\n   template <class ... Args>\n      reference emplace_back(Args &&...args) {\n         if (full())\n            grow();\n         elems[size()] =\n            value_type(std::forward<Args>(args)...);\n         ++nelems;\n         return back();\n      }\n   private:\n      void grow() {\n         resize(capacity()? capacity() * 2 : 16);\n      }\n   // ...\n```", "```cpp\nelems[size()] = // the object to insert\n++nelems;\n```", "```cpp\nelems[nelems++] = // the object to insert\n```", "```cpp\n  // ...\n  public:\n     void resize(size_type new_cap) {\n        if (new_cap <= capacity()) return;\n        auto p = new T[new_cap];\n        if constexpr(std::is_nothrow_move_assignable_v<T>){\n           std::move(begin(), end(), p);\n        } else try {\n           std::copy(begin(), end(), p);\n        } catch (...) {\n           delete[] p;\n           throw;\n        }\n        delete[] elems;\n        elems = p;\n        cap = new_cap;\n     }\n     // ...\n```", "```cpp\n   template <class It>\n   iterator insert(const_iterator pos, It first, It last) {\n      iterator pos_ = const_cast<iterator>(pos);\n      // deliberate usage of unsigned integrals\n      const std::size_t remaining = capacity() - size();\n      const std::size_t n = std::distance(first, last);\n      if (remaining < n) {\n         auto index = std::distance(begin(), pos_);\n         resize(capacity() + n - remaining);\n         pos_ = std::next(begin(), index);\n      }\n      std::copy_backward(pos_, end(), end() + n);\n      std::copy(first, last, pos_);\n      nelems += n;\n      return pos_;\n   }\n```", "```cpp\n   iterator erase(const_iterator pos) {\n      iterator pos_ = const_cast<iterator>(pos);\n      if (pos_ == end()) return pos_;\n      std::copy(std::next(pos_), end(), pos_);\n      *std::prev(end()) = {};\n      --nelems;\n      return pos_;\n   }\n```", "```cpp\n#include <cstddef>\n#include <algorithm>\n#include <utility>\n#include <iterator>\n#include <initializer_list>\n#include <concepts>\ntemplate <class T>\nclass ForwardList {\npublic:\n   using value_type = T;\n   using size_type = std::size_t;\n   using pointer = T*;\n   using const_pointer = const T*;\n   using reference = T&;\n   using const_reference = const T&;\n   // ...\n```", "```cpp\n   // ...\nprivate:\n   struct Node {\n      value_type value;\n      Node *next = nullptr;\n      Node(const_reference value) : value { value } {\n      }\n      Node(value_type &&value)\n         : value { std::move(value) } {\n      }\n   };\n   Node *head {};\n   size_type nelems {};\n   // ...\n```", "```cpp\n   // ...\npublic:\n   size_type size() const { return nelems; }\n   bool empty() const { return !head; }\n   // ...\n```", "```cpp\n   // ...\nprivate:\n   template <class U> class Iterator {\n   public:\n      using value_type =\n         typename ForwardList<T>::value_type;\n      using pointer = typename ForwardList<T>::pointer;\n      using reference = typename ForwardList<T>::reference;\n      using difference_type = std::ptrdiff_t;\n      using iterator_category =\n         std::forward_iterator_tag;\n      friend class ForwardList<T>;\n   private:\n      Node *cur {};\n   public:\n      Iterator() = default;\n      Iterator(Node *p) : cur { p } {\n      }\n      Iterator& operator++() {\n         cur = cur->next;\n         return *this;\n      }\n      Iterator operator++(int) {\n         auto temp = *this;\n         operator++();\n         return temp;\n      }\n      bool operator==(const Iterator &other) const {\n         return cur == other.cur;\n      }\n      // not needed since C++20\n      bool operator!=(const Iterator &other) const {\n         return !(*this == other);\n      }\n      U& operator*() { return cur->value; }\n      const U& operator*() const { return cur->value; }\n      U* operator->() { return cur->value; }\n      const U* operator->() const { return cur->value; }\n   };\npublic:\n   using iterator = Iterator<T>;\n   using const_iterator = Iterator<const T>;\n   // ...\n```", "```cpp\n   // ...\n   iterator begin() { return { head }; }\n   const_iterator begin() const { return { head }; }\n   const_iterator cbegin() const { return begin(); }\n   iterator end() { return {}; }\n   const_iterator end() const { return {}; }\n   const_iterator cend() const { return end(); }\n   // ...\n```", "```cpp\n   // ...\n   void clear() noexcept {\n      for(auto p = head; p; ) {\n         auto q = p->next;\n         delete p;\n         p = q;\n      }\n      nelems = 0;\n   }\n   ~ForwardList() {\n      clear();\n   }\n   // ...\n```", "```cpp\n   // ...\n   ForwardList() = default;\n   template <std::input_iterator It>\n      ForwardList(It b, It e) {\n         if(b == e) return;\n         try {\n            head = new Node{ *b };\n            auto q = head;\n            ++nelems;\n            for(++b; b != e; ++b) {\n               q->next = new Node{ *b };\n               q = q->next;\n               ++nelems;\n            }\n         } catch (...) {\n            clear();\n            throw;\n         }\n      }\n   ForwardList(const ForwardList& other)\n      : ForwardList(other.begin(), other.end()) {\n   }\n   ForwardList(std::initializer_list<T> other)\n      : ForwardList(other.begin(), other.end()) {\n   }\n   ForwardList(ForwardList&& other) noexcept\n      : head{ std::exchange(other.head, nullptr) },\n        nelems{ std::exchange(other.nelems, 0) } {\n   }\n   // ...\n```", "```cpp\n   // ...\n   void swap(ForwardList& other) noexcept {\n      using std::swap;\n      swap(head, other.head);\n      swap(nelems, other.nelems);\n   }\n   ForwardList& operator=(const ForwardList& other) {\n      ForwardList{ other }.swap(*this);\n      return *this;\n   }\n   ForwardList& operator=(ForwardList&& other) {\n      ForwardList{ std::move(other) }.swap(*this);\n      return *this;\n   }\n   // ...\n```", "```cpp\n   // ...\n   // precondition: !empty()\n   reference front() { return head->value; }\n   const_reference front() const { return head->value; }\n   bool operator==(const ForwardList &other) const {\n      return size() == other.size() &&\n             std::equal(begin(), end(), other.begin());\n   }\n   // can be omitted since C++20\n   bool operator!=(const ForwardList &other) const {\n      return !(*this == other);\n   }\n   void push_front(const_reference val) {\n      auto p = new Node{ val };\n      p->next = head;\n      head = p;\n      ++nelems;\n   }\n   void push_front(T&& val) {\n      auto p = new Node{ std::move(val) };\n      p->next = head;\n      head = p;\n      ++nelems;\n   }\n   // ...\n```", "```cpp\n   // ...\n   iterator insert_after\n      (iterator pos, const_reference value) {\n      auto p = new Node{ value };\n      p->next = pos.cur->next;\n      pos.cur->next = p;\n      ++nelems;\n      return { p };\n   }\n   // ...\n```", "```cpp\n   // ...\n   iterator erase_after(iterator pos) {\n      if (pos == end() || std::next(pos) == end())\n         return end();\n      auto p = pos.cur->next->next;\n      delete pos.cur->next;\n      pos.cur->next = p;\n      return { p->next };\n   }\n};\n```", "```cpp\n   // ...\n   Vector(size_type n, const_reference init)\n      : elems{ new value_type[n] }, nelems{ n }, cap{ n } {\n      try {\n         std::fill(begin(), end(), init);\n      } catch(...) {\n         delete [] elems;\n         throw;\n      }\n   }\n   // ...\n```", "```cpp\n   // ...\n   Vector(size_type n, const_reference init)\n      // A\n      : elems{ static_cast<pointer>(\n           std::malloc(n * sizeof(value_type)\n        ) }, nelems{ n }, cap{ n } {\n      // B\n      auto p = begin(); // note: we know p is a T*\n      try {\n      // C\n         for(; p != end(); ++p)\n            new(static_cast<void*>(p)) value_type{ init };\n      } catch(...) {\n      // D\n         for(auto q = begin(); q != p; ++q)\n            q->~value_type();\n         std::free(elems);\n         throw;\n      }\n   }\n   // ...\n```", "```cpp\n   // ...\n   Vector(size_type n, const_reference init)\n      : elems{ static_cast<pointer>(\n           std:malloc(n * sizeof(value_type))\n        ) }, nelems{ n }, cap{ n } {\n      try {\n         std::uninitialized_fill(begin(), end(), init);\n      } catch(...) {\n         std::free(elems);\n         throw;\n      }\n   }\n   // ...\n```", "```cpp\n   // ...\n   Vector(const Vector& other)\n      : elems{ static_cast<pointer>(\n           std::malloc(n * sizeof(value_type))\n        ) },\n        nelems{ other.size() }, cap{ other.size() } {\n      try {\n         std::uninitialized_copy(\n            other.begin(), other.end(), begin()\n         );\n      } catch (...) {\n         std::free(elems);\n         throw;\n      }\n   }\n   // ...\n```", "```cpp\n   // ...\n   ~Vector() {\n      std::destroy(begin(), end());\n      std::free(elems);\n   }\n   // ...\n```", "```cpp\n   // ...\n   void push_back(const_reference val) {\n      if (full())\n         grow();\n      std::construct_at(end(), val);\n      ++nelems;\n   }\n   void push_back(T&& val) {\n      if (full())\n         grow();\n      std::construct_at(end(), std::move(val));\n      ++nelems;\n   }\n   template <class ... Args>\n      reference emplace_back(Args &&...args) {\n         if (full())\n            grow();\n         std::construct_at(\n            end(), std::forward<Args>(args)...\n         );\n         ++nelems;\n         return back();\n      }\n```", "```cpp\n   // ...\nprivate:\n   void grow() {\n      reserve(capacity()? capacity() * 2 : 16);\n   }\npublic:\n   void reserve(size_type new_cap) {\n      if(new_cap <= capacity()) return;\n      auto p = static_cast<pointer>(\n         std::malloc(new_cap * sizeof(T))\n      );\n      if constexpr(std::is_nothrow_move_assignable_v<T>) {\n         std::uninitialized_move(begin(), end(), p);\n      } else try {\n         std::uninitialized_copy(begin(), end(), p);\n      } catch (...) {\n         std::free(p);\n         throw;\n      }\n      std::destroy(begin(), end());\n      std::free(elems);\n      elems = p;\n      cap = new_cap;\n   }\n   // ...\n```", "```cpp\n   // ...\n   void resize(size_type new_cap) {\n      if(new_cap <= capacity()) return;\n      auto p = static_cast<pointer>(\n         std::malloc(new_cap * sizeof(T))\n      );\n      if constexpr(std::is_nothrow_move_assignable_v<T>) {\n         std::uninitialized_move(begin(), end(), p);\n      } else try {\n         std::uninitialized_copy(begin(), end(), p);\n      } catch (...) {\n         std::free(p);\n         throw;\n      }\n      std::uninitialized_fill(\n         p + size(), p + capacity(), value_type{}\n      );\n      std::destroy(begin(), end());\n      std::free(elems);\n      elems = p;\n      nelems = new_cap;\n      cap = new_cap;\n   }\n   // ...\n```", "```cpp\n   // ...\n   template <class It>\n   iterator insert(const_iterator pos, It first, It last) {\n      iterator pos_ = const_cast<iterator>(pos);\n      const auto remaining = capacity() - size();\n      const auto n = std::distance(first, last);\n      // we use cmp_less() here as remaining is an unsigned\n      // integral but n is a signed integral\n      if (std::cmp_less(remaining, n)) {\n         auto index = std::distance(begin(), pos_);\n         reserve(capacity() + n - remaining);\n         pos_ = std::next(begin(), index);\n      }\n      // objects to displace (move or copy) from the\n      // [begin(),end()) sequence into raw memory\n      const auto nb_to_uninit_displace =\n         std::min<std::ptrdiff_t>(n, end() - pos_);\n      auto where_to_uninit_displace =\n         end() + n - nb_to_uninit_displace;\n      if constexpr(std::is_nothrow_move_constructible_v<T>)\n         std::uninitialized_move(\n            end() - nb_to_uninit_displace, end(),\n            where_to_uninit_displace\n         );\n      else\n         std::uninitialized_copy(\n            end() - nb_to_uninit_displace, end(),\n            where_to_uninit_displace\n         );\n      // objects from [first,last) to insert into raw\n      // memory (note: there might be none)\n      const auto nb_to_uninit_insert =\n         std::max<std::ptrdiff_t>(\n            0, n - nb_to_uninit_displace\n         );\n      auto where_to_uninit_insert = end();\n      std::uninitialized_copy(\n         last - nb_to_uninit_insert, last,\n         where_to_uninit_insert\n      );\n      // objects to displace (copy or move) from the\n      // [pos,end()) sequence into that space (note:\n      // there might be none)\n      const auto nb_to_backward_displace =\n         std::max<std::ptrdiff_t>(\n            0, end() - pos_ - nb_to_uninit_displace\n         );\n       // note : end of destination\n      auto where_to_backward_displace = end();\n      if constexpr (std::is_nothrow_move_assignable_v<T>)\n         std::move_backward(\n            pos_, pos_ + nb_to_backward_displace,\n            where_to_backward_displace\n         );\n      else\n         std::copy_backward(\n            pos_, pos_ + nb_to_backward_displace,\n            where_to_backward_displace\n         );\n      // objects to copy from [first,last) to pos\n      std::copy(\n         first, first + n - nb_to_uninit_insert, pos\n      );\n      nelems += n;\n      return pos_;\n   }\n```", "```cpp\n   iterator erase(const_iterator pos) {\n      iterator pos_ = const_cast<iterator>(pos);\n      if (pos_ == end()) return pos_;\n      std::copy(std::next(pos_), end(), pos_);\n      std::destroy_at(std::prev(end()));\n      --nelems;\n      return pos_;\n   }\n```", "```cpp\n// ...\nint main() {\n   Vector<const int> v;\n   for(int n : { 2, 3, 5, 7, 11 })\n      v.push_back(n);\n}\n```", "```cpp\n      std::free(elems); // illegal if elems points to const\n```", "```cpp\n      using type = std::remove_const_t<value_type>*;\n      std::free(std::copy() or std::copy_backward() algorithms will not work on const objects or objects with const data members. You can make it work by replacing assignment with destruction followed by construction, but your code will be less exception-safe if the construction fails just after the destruction of the object that had to be replaced.\nOf course, casting away `const`-ness leads us into tricky territory as we are bordering the frightening lands of undefined behavior. Standard library implementors can, of course, do what they want, having the ears of the compiler implementors, but we mere mortals do not share this privilege and, for that reason, must tread carefully.\nA similar situation arises with composite objects that have data members of some reference type: you cannot make a container of references as references are not objects, but you sure can make a container of objects with reference-type data members. The problem, of course, is making sense of what happens when an object with a reference data member is being replaced.\nLet’s take a simpler example than `Vector<T>` to explain this situation. Suppose we have the following class, made to hold a reference to some object of type `T`:\n\n```", "```cpp\n\n As is, this class is simple enough and seems easy to reason about. Now, suppose we have the following client code:\n\n```", "```cpp\n\n Replacing an `X<int>` object through assignment is incorrect as having a reference data member deletes your assignment operator, at least by default (the default meaning would be ambiguous: should the reference be rebound to something else, or should the referred-to object be assigned to?).\nOne way to get around this problem is to destroy the original object and construct a new object in its place. In our example, since we ensured (through `static_assert`) that `T` was trivially destructible, we just constructed a new object where the previous one stood (ending the previous object’s lifetime). The bits are then all mapped properly to the new object... except that the compiler might not follow our reasoning.\nIn practice, compilers track the lifetime of objects the best they can, but we placed ourselves in a situation where the original `X<int>` object has never been explicitly destroyed. For that reason, this original `X<int>` object could still be considered to be there by the compiler, but the bits of the original object have been replaced by the new object placed at that specific address through very manual means. There might be a discrepancy between what the bits say and what the compiler understands from the source code, because (to be honest) we have been playing dirty tricks with the explicit construction of an object at a specific address that happens to have been occupied by another object.\nAccessing `value()` through `p` will definitely give you `-3` as it’s obvious that `p` points to an `X<int>` object that holds a reference to `m`, and `m` has the value `-3` at that point. Accessing `value()` through `h` is undefined behavior (will the resulting code give you what the bits say or what the compiler thinks that code is saying?).\nThis sort of evil-seeming situation, where the code logic as understood by the compiler might not match the bits, happens with objects with `const` data members, objects with reference data members, and some `union` types crafted in weird ways, but these are the tools we use for the low-level manipulation of objects, and that can be found underneath `std::optional<T>`, `std::vector<T>`, and others. It’s our fault, in the end, for using these weird types, but it’s part of life.\nWhen the bits do not necessarily align with what the compiler can understand, we have `std::launder()`. Use this cautiously: it’s an optimization barrier that states “just look at the bits, compiler; forget what you know about source code when looking at this pointed-to object.” Of course, this is a very dangerous tool and should be used with a lot of care, but sometimes it’s just what is needed.\nSummary\nWhew, this was a long chapter! We implemented a naïve `vector`-like container, then a naïve `forward_list`-like container, and then took another look at the `vector`-like container (we will return to the `forward_list`-like container in the next two chapters) to show how tighter control over memory can lead to more efficient containers.\nOur implementations in this chapter were “manual,” in the sense that we did the memory management by hand. That involved writing a lot of code, something we will reconsider in [*Chapter 13*](B21071_13.xhtml#_idTextAnchor187). In [*Chapter 14*](B21071_14.xhtml#_idTextAnchor199), we will examine how allocators interact with containers, and will use this opportunity to revisit our `forward_list`-like container as there will be interesting aspects to examine as we continue our adventure through memory management in C++.\n\n```"]