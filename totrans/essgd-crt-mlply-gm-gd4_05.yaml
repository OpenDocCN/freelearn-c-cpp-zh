- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Making an Online Quiz Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will dive into the fascinating realm of creating an online
    quiz game using the powerful Network API offered by Godot Engine 4.0\. We will
    explore how to leverage Godot Engine’s Network API to create an engaging and interactive
    quiz game that can be played with friends or strangers online. We will cover the
    fundamental concepts of online multiplayer game development, including client-server
    architecture, game synchronization, and player interactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we won’t go through the game design aspects of this type of game: scoring,
    managing incentives, balancing, and so on; instead, we are going to focus on the
    engineering side of the equation: how to sync answers, prevent players from answering
    when another player has already answered, update question data for both players,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: We will start by setting up the server side of the quiz game, including creating
    a dedicated server that can handle incoming connections and answers from multiple
    clients. We will then move on to designing the gameplay’s core functionalities,
    including handling player input, and managing answers and quiz questions, while
    also handling communication between the clients and the server.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we will learn how to use Godot Engine’s **RPCs** to
    manage connections, handle data synchronization, and implement real-time multiplayer
    gameplay mechanics. We will also cover topics such as managing the game state.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the online quiz game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a lobby for the quiz game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing online turns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turning local mechanics into remote gameplay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will have a solid understanding of how to create
    an online quiz game using Godot Engine 4.0’s Network API. You will have learned
    the key concepts and techniques to make online asynchronous games, including server-side
    setup, client-side implementation, and network communication. The following screenshot
    showcases the end result of our online quiz game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – The online quiz gameplay screen displaying a question and its
    options](img/Figure_05.01_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – The online quiz gameplay screen displaying a question and its options
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to discuss the components of the quiz game
    so that we can pinpoint where we, as network engineers, have to implement the
    necessary features to turn the local multiplayer version of the game into an online
    multiplayer one.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the online quiz game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome, network engineer! Our studio needs you to turn our quiz game into an
    online multiplayer experience! We have already gone through various challenges
    to create a captivating quiz game. Now, it’s time to take it to the next level
    by adding online multiplayer functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine players from around the world competing against each other in real time,
    testing their knowledge and skills. In this chapter, you’ll dive into the world
    of networking in game development and learn how to implement multiplayer features
    using GDScript. So, let’s get started and make our quiz game an unforgettable
    multiplayer experience!
  prefs: []
  type: TYPE_NORMAL
- en: One of the key features of our online multiplayer quiz game is the dynamic loading
    of questions from a JSON database. Each question in the database contains all
    the necessary data, such as the question itself and four alternatives for players
    to choose from. Only one of the alternatives is the correct answer, and this information
    is stored in the database as well, ensuring fair and consistent gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: To provide a simple and intuitive user interface, our game features four buttons,
    each representing an answer to the question displayed on the screen. A panel with
    a label displays game messages, including the current question that players must
    answer to score in the round. The game’s interface is designed to provide a seamless
    experience for players as they navigate through the questions and answers.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – The quiz screen displaying the round’s question and available
    answers](img/Figure_05.02_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – The quiz screen displaying the round’s question and available answers
  prefs: []
  type: TYPE_NORMAL
- en: As players correctly answer questions, they progress through the rounds. When
    a player wins a round, the game updates the question and answer options, ensuring
    that players are constantly challenged with new questions. The game continues
    until there are no more questions left to answer, making for an engaging and competitive
    multiplayer experience.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – The quiz screen displaying the round winner](img/Figure_5.03_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – The quiz screen displaying the round winner
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will delve into the lobby of our quiz game. We will
    explore how to create a seamless multiplayer lobby system, allowing players to
    join games and compete in a fun and engaging multiplayer environment.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a lobby for the quiz game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the upcoming section, we will be delving into the process of setting up a
    lobby for our quiz game. The `QuizLobby` scene serves as the hub for players to
    interact and prepare for the game.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – The login screen displaying the username and password fields
    and the players in the match](img/Figure_5.04_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – The login screen displaying the username and password fields and
    the players in the match
  prefs: []
  type: TYPE_NORMAL
- en: The process of authenticating players is similar to what we have done in previous
    chapters, utilizing data submitted by players and matching it against `FakeDatabase`.
    This ensures that only registered players with valid credentials are allowed to
    access the lobby.
  prefs: []
  type: TYPE_NORMAL
- en: Once a player successfully logs in, their name will appear for other players,
    providing visibility of the players currently present in the lobby. You can optionally
    add the previous chat to this scene as well to allow players to interact before
    the match starts. This will create a sense of community and allow players to connect
    and interact with each other while waiting for the game to start.
  prefs: []
  type: TYPE_NORMAL
- en: The `QuizLobby` scene is similar to our previous lobbies. So, in this section,
    we are going to focus on the core features it adds on top of the lobby we created
    in [*chapter 3*](B18527_03.xhtml#_idTextAnchor065), *Making a Lobby to Gather*
    *Players Together*.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will create and understand the additional features
    in this new lobby iteration. For that, open the script at `res://05.quiz-online/QuizLobby.gd`
    and move on to the `add_logged_player()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying new players
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the new features we will have in this updated lobby is the ability to
    see all the players who joined the current match. To implement that, let’s take
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `add_logged_player()` method, set the `logged_players_label.text`
    property to `player_name`; this function receives an argument. The resulting text
    should append the `player_name` below the current content. For that, we concatenate
    the string with a placeholder string that skips a line and formats the placeholder
    as `player_name`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, move on to the `start_game()` method and add the `"authority"`
    and `"call_local"` options to the `@``rpc` annotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, inside the function, let’s tell the SceneTree to change the current scene
    to `quiz_screen_scene`, which is a variable that points to `QuizScreenClient.tscn`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, on the `_on_StartButton_pressed()` callback, we will make a direct
    RPC to the multiplayer authority’s `start_game()` method without calling it locally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In game development, ensuring fair gameplay and providing an enjoyable experience
    for players are critical aspects of creating a successful game. This involves
    implementing various features and functionalities that make the game engaging
    and dynamic. One such feature is adding a player to the match when they join the
    game. This can be achieved by creating a panel that displays the names of all
    the players currently participating in the game.
  prefs: []
  type: TYPE_NORMAL
- en: In a multiplayer game, communication between the server and clients is crucial.
    It’s essential to ensure that only authorized entities can perform specific actions.
    This ensures that the game’s mechanics and flow are consistent and reliable for
    all players.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, once all the players are in the game, and the match is about to begin,
    the next step is to move them and the server to the next game screen. This screen
    will display all the necessary information about the game, such as the objective,
    rules, and game mechanics.
  prefs: []
  type: TYPE_NORMAL
- en: This ensures that all the players are on the same page and know what to expect
    from the game. Overall, implementing these features ensures that the game runs
    smoothly and that the players have a positive gaming experience.
  prefs: []
  type: TYPE_NORMAL
- en: With that, every time a player joins the match, their name will be added to
    the `start_game()` method, only the multiplayer authority can make a remote call
    to it, right? We are about to see something new in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: On the server side, we will have a different implementation of this method.
    In the upcoming section, we will see how the match actually starts and why we
    move all players and the server to the next game screen.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the match
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This implementation works that way to prevent one player from calling the `start_game()`
    method on the other players, or on itself, without other players also starting
    the game. The idea is that the player who presses the **Start** button will ask
    the multiplayer authority to start the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'In turn, the multiplayer authority, which is the server in this case, will
    tell every player to also start the match. It does that by calling the `start_game()`
    method on each player. Let’s see how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the script at `res://05.online-quiz/QuizServer.gd` and find the `start_game()`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `@rpc` annotation line, add the `"any_peer"` and the `"call_remote"`
    options. This will allow any peer on the network to make a remote call to this
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, tell the SceneTree to change to `quiz_screen_scene_path` using the `get_tree().change_scene_to_file()`
    method. This will tell the server to also update its context to the one in the
    `QuizScreenServer` scene. This will be necessary for the actual game to run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, and most importantly, make an RPC call to other peers’ `start_game`
    method, so everyone in the network moves on to their respective `QuizScreenClient`
    scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The lobby system is a vital component of any online multiplayer game, as it
    serves as the gateway for players to connect and prepare for the match. In our
    quiz game, we have successfully implemented the lobby system using Godot’s built-in
    **Remote Procedure Call** (**RPC**) functionality. This feature allows us to establish
    a reliable two-way communication channel between the client and server, ensuring
    that all players are in sync.
  prefs: []
  type: TYPE_NORMAL
- en: With the lobby system in place, players can join the match and their names will
    be added to the `start_game()` method can only be called by the multiplayer authority,
    preventing unauthorized calls and ensuring the integrity of the game. The server-side
    implementation of this method will be different, and we will explore this in the
    upcoming section.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to add more features to the lobby system, you can create a countdown
    timer similar to the ones found in games such as *Warcraft III: Reign of Chaos*.
    This feature adds excitement and anticipation to the match and can help players
    prepare mentally for the upcoming game. However, for our quiz game, we are ready
    to move on to the next step.'
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have the lobby part of our quiz game ready to gather some players
    together and set them up, ready to start the match. We saw how to use the options
    that Godot provides for the `@rpc` annotation to create a two-sided communication
    that we can use to sync players and move them all together to the actual game.
  prefs: []
  type: TYPE_NORMAL
- en: The lobby system is a crucial part of any online multiplayer game, and we have
    successfully implemented it in our quiz game using Godot’s built-in RPC functionality.
    The system allows players to join the match and sync their data with the server,
    ensuring that the game is fair and consistent. While we can add more features
    to the lobby system, such as a countdown timer, we are now ready to move on to
    the next stage of development.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to create a mechanism to disable players’
    actions when another player has already selected the correct answer. With that,
    you can even create a *turn-based* mechanism if you want, which is what we are
    going to do in [*Chapter 6*](B18527_06.xhtml#_idTextAnchor131), *Building an Online*
    *Checkers Game*.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing online turns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When designing a quiz game, it’s important to ensure that players can only provide
    one answer to a given question. This can be especially challenging when creating
    a multiplayer game, as multiple players may attempt to answer the question at
    the same time.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent this, it’s necessary to implement a system that disables players’
    ability to answer the question once a valid answer has been provided by another
    player.
  prefs: []
  type: TYPE_NORMAL
- en: One common approach to implementing this system is to disable the buttons representing
    the potential answers once a player has provided a response. This can be accomplished
    using code that identifies which button was pressed and compares it to the correct
    answer stored in the game’s database. Once an answer has been identified, the
    code can disable the buttons and prevent other players from answering the question.
  prefs: []
  type: TYPE_NORMAL
- en: To further improve the player experience, it’s also common to include a brief
    pause after an answer has been provided. During this time, players can review
    the questions and answers, and the game can display feedback on whether the answer
    was correct or not. This can help to build tension and excitement in the game,
    while also giving players a chance to reflect on their performance and improve
    their skills.
  prefs: []
  type: TYPE_NORMAL
- en: We need to prevent players’ from answering the same question after another player
    already answered it. To do that, we can disable the buttons that represent answers
    once a valid response is provided. And for a better experience, we can add a brief
    pause before changing to the next question.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to understand how we can prevent players’ actions,
    ultimately creating a pseudo-turn-based mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s understand how to achieve that pseudo-turn-based mechanism:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `res://05.online-quiz/QuizScreenServer.gd` script and let’s implement
    its main methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First of all, let’s add `"any_peer"` to the `answered()` method’s `@rpc` annotation.
    This will allow any player to trigger the behavior we are about to describe when
    they answer a question correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `answered()` method, we will tell `quiz_panel` to update the round’s
    winner, making an RPC to the `"update_winner"` method and passing the player’s
    name, which is stored in the database. This will update every peer’s `QuizPanel`
    about the round’s winner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we start a local timer that should wait for enough time to allow players
    to digest the round’s winner. We also make an RPC on `wait_label` so everyone’s
    `WaitLabel` displays the correct waiting time as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let’s do the same thing on the `missed()` method. But we will make an RPC
    to `"``player_missed"` instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, `QuizScreenServer` handles both game states when a player wins or
    loses the round. Using RPCs, we can update all peers about what’s happening in
    the game and set them ready for the next round. But we haven’t seen how this actually
    works yet. Coming next, let’s see what happens in `QuizPanel` when we call the
    `update_winner()` and `player_missed()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Updating players about the round
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a multiplayer quiz game, it’s crucial to keep all players in sync with the
    game state, especially when someone has already answered a question correctly.
    The `QuizScreenServer` Main node is responsible for updating the game state and
    informing all the connected players about what just happened in the current round.
    To achieve this, the `QuizScreenServer` Main node makes an RPC to all the peers’
    QuizPanels. The `QuizPanel` node on each player’s side will update the game state
    locally and prevent any further interaction until the next round begins.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of these methods ensures that all players are on the same
    page, and there are no discrepancies in the game state between players. With this
    approach, we can provide a fair and consistent gaming experience for all the players
    in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `res://05.online-quiz/QuizPanel.gd` file and let’s implement the `update_winner()`
    and `player_missed()` methods, together with their auxiliary methods as well,
    such as `lock_answers()` and `unlock_answers()`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the `update_winner()` method and add the `"call_local"` option to its
    `@rpc` annotation. We do that because when we make this RPC on the server, it
    should also update its own `QuizPanel` node as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, inside the `update_winner()` method, update the `question_label.text`
    property to display a message with `winner_name`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we will make a call to the `lock_answers()` method. This will make
    players wait for the next round, as we’ll see soon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can do the exact same thing in the `player_missed()` method. But here, we’ll
    display a different message, communicating that the player missed the answer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, we have our user interface updating the players about their peers’
    actions. If a player answered right, they will know it, if a player answered wrong,
    they will know it. Now is the time to get them ready for the next round. Let’s
    look at the `lock_answers()` and `unlock_answers()` methods.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `lock_answers()` method, we are going to run through all `AnswerButtons`,
    which are children of the `Answers` node, and disable them. This way, players
    won’t be able to interact with these buttons anymore, preventing them from answering
    the question:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We do the opposite in the `unlock_answers()` method, toggling off the disabled
    property on each `AnswerButton` node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will prevent and allow player interactions with the available answers to
    the current question. We can use this same approach to create an actual turn-based
    system where players take turns trying to answer one question at a time. Here’s
    a challenge for you, our network engineer. As an exercise, implement a turn-based
    system using the knowledge you just acquired. You have everything necessary at
    your disposal.
  prefs: []
  type: TYPE_NORMAL
- en: A turn-based system is a way of structuring gameplay where each player takes
    a turn to make their move, before passing control to the next player. This is
    in contrast to real-time gameplay, where all players are acting at the same time.
    Turn-based systems are often used in strategy games, where players need to carefully
    plan their moves.
  prefs: []
  type: TYPE_NORMAL
- en: To implement a turn-based system in your quiz game, you will need to modify
    the existing code to add a new layer of logic. One approach would be to create
    a queue of players, with each player taking their turn in order. When it’s a player’s
    turn, they are allowed to answer the question, while the other players are locked
    out. Once they have answered, their turn is over, and the next player in the queue
    takes their turn.
  prefs: []
  type: TYPE_NORMAL
- en: To create this system, you could turn `lock_answer()` and `unlock_answer()`
    into RPC methods and use the `rpc_id()` method to directly lock or unlock the
    players’ answer options based on whether they are the current active player.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll understand how we can take the fundamental mechanics
    of a quiz game and make them work in an online context. It’s going to be the core
    of this chapter as we will see how we evaluate whether the player answered the
    question correctly and how we load new questions, ensuring that all peers are
    looking at the same question.
  prefs: []
  type: TYPE_NORMAL
- en: Turning local mechanics into remote gameplay
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we can manage players’ interactions and communicate the game state
    to players, it’s time to implement the core features of a quiz. Coming up, we
    are going to implement the questions and answers. For that, we are going to use
    a questions database where we store them with their possible answers and the correct
    answer index.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will see how we load and deserialize these questions into `QuizPanel`.
    On top of that, we’ll also understand how we make use of RPCs to keep everyone
    in sync. And of course, we will also implement the logic behind both when players
    choose the correct and the incorrect answer.
  prefs: []
  type: TYPE_NORMAL
- en: When a player chooses an answer, we need to compare it with the correct answer
    index, and if it’s correct, we should notify `QuizScreenServer` about the correct
    answer. We’ll also need to make use of RPCs to keep everyone in sync regarding
    the current question and answer status.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, we need to implement the logic behind what happens when a player chooses
    the incorrect answer. We can use the same locking mechanism that we used previously
    to prevent players from answering if someone has already provided a valid answer.
    Once we handle the incorrect answer, we need to notify `QuizScreenServer` about
    the incorrect answer and move on to the next round.
  prefs: []
  type: TYPE_NORMAL
- en: By implementing all of these features, we can create a robust and engaging quiz
    game that can be played by multiple players simultaneously. By using the database
    to load questions, we can make the game dynamic and varied. And by using RPCs
    and locking mechanisms, we can ensure that the game runs smoothly and that everyone
    is on the same page.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the questions database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, let’s start by taking a look at our questions database. Open
    the file at `res://05.online-quiz/QuizQuestions.json`. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we represent each question as a *key* that is also a dictionary.
    Each question has three keys as well: `"text"`, `"alternatives"`, and `"correct_answer_index"`.
    The `"text"` key is the actual question statement, `"alternatives"` is an array
    of possible answers that we will turn into `AnswerButtons`, and `"correct_answer_index"`
    is the index in the `"alternatives"` array of the correct answer.'
  prefs: []
  type: TYPE_NORMAL
- en: Knowing that, you can go ahead and create some questions on your own. Keep in
    mind that, by default, we have four `AnswerButtons`, so try to provide four values
    in the `"alternatives"` key. Otherwise, you’d need to implement an `AnswerButtons`
    factory to dynamically create them based on how many answers we load from the
    question.
  prefs: []
  type: TYPE_NORMAL
- en: Loading and updating questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let’s understand how this process works under the hood of `QuizPanel`.
    Open the script at `res://05.online-quiz/QuizPanel.gd` and find the `update_question()`
    method. The first thing you’ll notice is that it has an `@``rpc` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because we design it in such a way that it’s the server who calls it
    and tells it which question to load. We will see that in a moment, but for now,
    let’s implement this method’s logic:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a variable called `question` and set it equal to the result of calling
    the `pop_at()` method on `available_questions` with the `new_question_index` argument
    passed in. With that, we’ll remove the current question from the list of available
    questions and store it so we can use it moving on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether the question is not equal to null. Since the `pop_at()` method
    returns `null` when it can’t find a value in the index provided, we check that
    to know if there are still questions that we didn’t use yet, in other words, if
    `available_questions` is empty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the question we got is not null, set the `question_label.text` property
    to the `''text''` property of the question dictionary stored in the questions
    array. This is how we display the question’s statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a variable called `correct_answer` and set its value to the `''correct_answer_index''`
    property of the question dictionary stored in the questions array. Doing that,
    we keep the correct answer stored so we can compare it when players answer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Loop through the numbers `0` through `3`, inclusive, using the `range()` function
    and the `for` loop. For each iteration, create a variable called `alternative`
    and set it equal to `i`, which is the current element of the `''alternatives''`
    array stored in the question dictionary. Set the text of the current child node
    of the `answer_container` node to `alternative`. With that, we display the alternative’s
    text on its respective `AnswerButton`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After loading the question and its answers, let’s call the `unlock_answers()`
    function. This basically starts the current round, allowing players to interact
    with `QuizPanel` again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If `question` is `null`, meaning we don’t have any questions left to play the
    quiz, we need to loop through each child node of the `answer_container` node using
    the `for` loop. For each iteration, we’ll set the text of the `question_label`
    node to `''No` `more questions''`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we reached the end of our quiz match, we can call the `lock_answers()`
    function to prevent any further interactions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After these steps, the `update_question()` method should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: With that, we have our main quiz mechanism set up. We can pick one of the questions
    we have in our database and display it to our players. You can check the `_ready()`
    callback to understand how we load the questions in memory and assign them to
    the `available_questions` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned before, we are going to focus on the essentials here. Talking
    about the essentials, we are still missing one mechanic, which is how we validate
    the answers, right? Find the `evaluate_answer()` method and let’s implement that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `evaluate_answer()` method, create a variable called `is_answer_correct`
    and set it equal to the comparison between the `answer_index` and `correct_answer`
    variables. This will check whether the given answer index matches the index of
    the correct answer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Emit a signal called `answered` with the `is_answer_correct` variable as an
    argument. This signal will be used by other parts of the quiz to tell whether
    the player’s answer was correct or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the end, our `evaluate_answer()` method is quite simple and does just what
    we need to know whether the player answered the current question correctly:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You may have noticed that the `evaluate_answer()` method isn’t an RPC function,
    right? It essentially emits a signal that tells us whether the player’s answer
    was correct or not. So how does the server manage that?
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming section, we will understand how this information is passed around
    between the client and the server implementations of our quiz.
  prefs: []
  type: TYPE_NORMAL
- en: Sending players’ answers to the server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let’s understand the final piece of our mechanics and how it behaves in
    a multiplayer network. In the previous section, we ended up with an evaluation
    of the player’s answer that led to the emission of the `answered` signal.
  prefs: []
  type: TYPE_NORMAL
- en: The `answered` signal needs to be handled in a specific way to ensure that all
    players are kept in sync and that the game state is consistent across all peers.
    When a player submits their answer, the `answered` signal is emitted, and the
    server updates all peers about it through an RPC call.
  prefs: []
  type: TYPE_NORMAL
- en: The `answered` signal and its associated methods are crucial for maintaining
    the integrity of the game state across all players in a multiplayer network. Without
    them, players might see different game states and have different experiences,
    which would make the game less enjoyable and potentially unfair.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will understand how this signal propagates through the network
    and updates all peers about the players’ answers.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `res://05.online-quiz/QuizScreenClient.gd` script and you will notice
    that, right at the beginning, we have a callback to the `QuizPanel.answered` signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement this callback:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the method’s body, use an `if` statement to check whether `is_answer_correct`
    is true:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If `is_answer_correct` is `true`, make an RPC call to the answered method on
    the server using the `rpc_id()` method. With that, the server will update all
    peers about the round winner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If `is_answer_correct` is `false`, make an RPC call to the missed method on
    the server using the `rpc_id()` method. Finally, if the player chose the wrong
    answer, the server updates all peers about it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The whole `_on_quiz_panel_answered()` implementation should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: With that, the client implementation will notify the server about the players’
    interactions. In turn, the server will update the game state and tell all peers
    to also update their game states to match the server’s. After that, we have the
    missing network pieces in place and our online quiz game is ready. Feel free to
    test it out and experiment with more questions!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to create an online quiz game using the Godot Engine
    4.0 Network API. We covered the fundamental concepts of online multiplayer game
    development, including client-server architecture, game synchronization, and player
    interactions. Using the quiz game, we saw how to feature dynamic loading of questions
    from a JSON database, and how to display the current players in a quiz match.
    We created a mechanism to prevent players from answering questions when another
    player has already provided one, creating a pseudo-turn-based mechanism. Finally,
    we saw how to manage players’ interactions and communicate the game state to players
    and how to implement the logic behind both correct and incorrect answers, loading
    new questions one round after another until there are no more questions to display.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter’s projects, we will dive deeper into implementing a turn-based
    mechanism for our online quiz game. As we saw in this chapter, we can use a similar
    approach to what we did with the pseudo-turn-based mechanism, but with some modifications
    to make it a true turn-based system.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we will explore how to pass information about players’ turns,
    such as who is currently taking their turn, what happened during the opponent’s
    turn, and more. We will also learn how to set up win and lose conditions and update
    peers about them, which will be essential for creating a sense of accomplishment
    and challenge in our game.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the next chapter, you will have a deeper understanding of the
    game development process, including how to create engaging online multiplayer
    game mechanics and implement them using the Godot Engine 4.0 Network API. See
    you there!
  prefs: []
  type: TYPE_NORMAL
