- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Making an Online Quiz Game
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作在线问答游戏
- en: In this chapter, we will dive into the fascinating realm of creating an online
    quiz game using the powerful Network API offered by Godot Engine 4.0\. We will
    explore how to leverage Godot Engine’s Network API to create an engaging and interactive
    quiz game that can be played with friends or strangers online. We will cover the
    fundamental concepts of online multiplayer game development, including client-server
    architecture, game synchronization, and player interactions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨使用 Godot 引擎 4.0 提供的强大网络 API 创建在线问答游戏的迷人领域。我们将探讨如何利用 Godot 引擎的网络
    API 创建一个引人入胜且互动性强的问答游戏，可以与朋友或在线陌生人一起玩。我们将涵盖在线多人游戏开发的基本概念，包括客户端-服务器架构、游戏同步和玩家交互。
- en: 'Here, we won’t go through the game design aspects of this type of game: scoring,
    managing incentives, balancing, and so on; instead, we are going to focus on the
    engineering side of the equation: how to sync answers, prevent players from answering
    when another player has already answered, update question data for both players,
    and so on.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不会深入探讨这类游戏的游戏设计方面：计分、管理激励措施、平衡等等；相反，我们将专注于方程的工程方面：如何同步答案，防止玩家在另一位玩家已经回答时回答，更新双方的问题数据等等。
- en: We will start by setting up the server side of the quiz game, including creating
    a dedicated server that can handle incoming connections and answers from multiple
    clients. We will then move on to designing the gameplay’s core functionalities,
    including handling player input, and managing answers and quiz questions, while
    also handling communication between the clients and the server.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先设置问答游戏的服务器端，包括创建一个可以处理多个客户端传入连接和答案的专用服务器。然后，我们将转向设计游戏的核心功能，包括处理玩家输入、管理答案和问答问题，同时处理客户端和服务器之间的通信。
- en: Throughout this chapter, we will learn how to use Godot Engine’s **RPCs** to
    manage connections, handle data synchronization, and implement real-time multiplayer
    gameplay mechanics. We will also cover topics such as managing the game state.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用 Godot 引擎的 **RPCs** 来管理连接，处理数据同步，并实现实时多人游戏机制。我们还将涵盖管理游戏状态等主题。
- en: 'We will cover the following topics in the chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introducing the online quiz game
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍在线问答游戏
- en: Setting up a lobby for the quiz game
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为问答游戏设置大厅
- en: Implementing online turns
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现在线回合
- en: Turning local mechanics into remote gameplay
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将本地机制转变为远程游戏
- en: 'By the end of this chapter, you will have a solid understanding of how to create
    an online quiz game using Godot Engine 4.0’s Network API. You will have learned
    the key concepts and techniques to make online asynchronous games, including server-side
    setup, client-side implementation, and network communication. The following screenshot
    showcases the end result of our online quiz game:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将牢固地理解如何使用 Godot 引擎 4.0 的网络 API 创建在线问答游戏。你将学习到制作在线异步游戏的关键概念和技术，包括服务器端设置、客户端实现和网络通信。以下截图展示了我们的在线问答游戏的最终结果：
- en: '![Figure 5.1 – The online quiz gameplay screen displaying a question and its
    options](img/Figure_05.01_B18527.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 显示问题和选项的在线问答游戏玩法屏幕](img/Figure_05.01_B18527.jpg)'
- en: Figure 5.1 – The online quiz gameplay screen displaying a question and its options
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 显示问题和选项的在线问答游戏玩法屏幕
- en: In the next section, we are going to discuss the components of the quiz game
    so that we can pinpoint where we, as network engineers, have to implement the
    necessary features to turn the local multiplayer version of the game into an online
    multiplayer one.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论问答游戏的组件，以便我们可以确定作为网络工程师，我们必须在何处实现将游戏的本地多人版本转变为在线多人版本所需的必要功能。
- en: Introducing the online quiz game
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍在线问答游戏
- en: Welcome, network engineer! Our studio needs you to turn our quiz game into an
    online multiplayer experience! We have already gone through various challenges
    to create a captivating quiz game. Now, it’s time to take it to the next level
    by adding online multiplayer functionality.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎网络工程师！我们的工作室需要你将我们的问答游戏转变为在线多人游戏体验！我们已经经历了各种挑战来创建一个吸引人的问答游戏。现在，是时候通过添加在线多人功能将其提升到下一个层次了。
- en: Imagine players from around the world competing against each other in real time,
    testing their knowledge and skills. In this chapter, you’ll dive into the world
    of networking in game development and learn how to implement multiplayer features
    using GDScript. So, let’s get started and make our quiz game an unforgettable
    multiplayer experience!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下来自世界各地的玩家在实时中进行竞争，测试他们的知识和技能。在本章中，你将深入了解游戏开发中的网络世界，并学习如何使用 GDScript 实现多人游戏功能。那么，让我们开始，让我们的测验游戏成为难忘的多人游戏体验！
- en: One of the key features of our online multiplayer quiz game is the dynamic loading
    of questions from a JSON database. Each question in the database contains all
    the necessary data, such as the question itself and four alternatives for players
    to choose from. Only one of the alternatives is the correct answer, and this information
    is stored in the database as well, ensuring fair and consistent gameplay.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在线多人测验游戏的一个关键特性是从 JSON 数据库动态加载问题。数据库中的每个问题都包含所有必要的数据，例如问题本身和四个供玩家选择的备选答案。只有一个备选答案是正确的，并且这个信息也存储在数据库中，以确保游戏的公平性和一致性。
- en: To provide a simple and intuitive user interface, our game features four buttons,
    each representing an answer to the question displayed on the screen. A panel with
    a label displays game messages, including the current question that players must
    answer to score in the round. The game’s interface is designed to provide a seamless
    experience for players as they navigate through the questions and answers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一个简单直观的用户界面，我们的游戏提供了四个按钮，每个按钮代表屏幕上显示的问题的一个答案。一个带有标签的面板显示游戏信息，包括玩家必须回答以在回合中获得分数的当前问题。游戏界面设计用于为玩家在浏览问题和答案时提供无缝体验。
- en: '![Figure 5.2 – The quiz screen displaying the round’s question and available
    answers](img/Figure_05.02_B18527.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 显示本回合问题和可用答案的测验界面](img/Figure_05.02_B18527.jpg)'
- en: Figure 5.2 – The quiz screen displaying the round’s question and available answers
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 显示本回合问题和可用答案的测验界面
- en: As players correctly answer questions, they progress through the rounds. When
    a player wins a round, the game updates the question and answer options, ensuring
    that players are constantly challenged with new questions. The game continues
    until there are no more questions left to answer, making for an engaging and competitive
    multiplayer experience.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 随着玩家正确回答问题，他们可以进入下一轮。当玩家赢得一轮时，游戏会更新问题和答案选项，确保玩家始终面临新的问题挑战。游戏将继续进行，直到没有更多问题可以回答，从而为玩家提供引人入胜且具有竞争力的多人游戏体验。
- en: '![Figure 5.3 – The quiz screen displaying the round winner](img/Figure_5.03_B18527.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 显示本回合获胜者的测验界面](img/Figure_05.03_B18527.jpg)'
- en: Figure 5.3 – The quiz screen displaying the round winner
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 显示本回合获胜者的测验界面
- en: In the next section, we will delve into the lobby of our quiz game. We will
    explore how to create a seamless multiplayer lobby system, allowing players to
    join games and compete in a fun and engaging multiplayer environment.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入探讨我们的测验游戏的大厅。我们将探讨如何创建一个无缝的多人大厅系统，允许玩家加入游戏并在一个有趣且引人入胜的多人环境中竞争。
- en: Setting up a lobby for the quiz game
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置测验游戏的大厅
- en: In the upcoming section, we will be delving into the process of setting up a
    lobby for our quiz game. The `QuizLobby` scene serves as the hub for players to
    interact and prepare for the game.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入探讨为我们的测验游戏设置大厅的过程。`QuizLobby` 场景是玩家互动和为游戏做准备的中心。
- en: '![Figure 5.4 – The login screen displaying the username and password fields
    and the players in the match](img/Figure_5.04_B18527.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 显示用户名和密码字段以及比赛中玩家的登录界面](img/Figure_5.04_B18527.jpg)'
- en: Figure 5.4 – The login screen displaying the username and password fields and
    the players in the match
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 显示用户名和密码字段以及比赛中玩家的登录界面
- en: The process of authenticating players is similar to what we have done in previous
    chapters, utilizing data submitted by players and matching it against `FakeDatabase`.
    This ensures that only registered players with valid credentials are allowed to
    access the lobby.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 确认玩家的过程与我们之前章节中做的方法类似，利用玩家提交的数据与 `FakeDatabase` 进行匹配。这确保只有拥有有效凭证的注册玩家才能访问大厅。
- en: Once a player successfully logs in, their name will appear for other players,
    providing visibility of the players currently present in the lobby. You can optionally
    add the previous chat to this scene as well to allow players to interact before
    the match starts. This will create a sense of community and allow players to connect
    and interact with each other while waiting for the game to start.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦玩家成功登录，他们的名字将出现在其他玩家面前，为当前大厅中的玩家提供可见性。你可以选择将之前的聊天也添加到这个场景中，以便玩家在比赛开始前进行互动。这将营造社区感，并允许玩家在等待游戏开始时相互连接和互动。
- en: The `QuizLobby` scene is similar to our previous lobbies. So, in this section,
    we are going to focus on the core features it adds on top of the lobby we created
    in [*chapter 3*](B18527_03.xhtml#_idTextAnchor065), *Making a Lobby to Gather*
    *Players Together*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`QuizLobby` 场景与我们的前一个大厅相似。因此，在本节中，我们将重点介绍它在大厅（[第3章](B18527_03.xhtml#_idTextAnchor065)，“制作大厅以聚集玩家”）基础上增加的核心功能。'
- en: In the following section, we will create and understand the additional features
    in this new lobby iteration. For that, open the script at `res://05.quiz-online/QuizLobby.gd`
    and move on to the `add_logged_player()` method.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将创建并理解这个新大厅迭代中的附加功能。为此，打开 `res://05.quiz-online/QuizLobby.gd` 脚本，并转到
    `add_logged_player()` 方法。
- en: Displaying new players
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示新玩家
- en: 'One of the new features we will have in this updated lobby is the ability to
    see all the players who joined the current match. To implement that, let’s take
    the following steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次更新的大厅中，我们将拥有的新功能之一是查看加入当前比赛的所有玩家的能力。为了实现这一点，让我们采取以下步骤：
- en: 'Inside the `add_logged_player()` method, set the `logged_players_label.text`
    property to `player_name`; this function receives an argument. The resulting text
    should append the `player_name` below the current content. For that, we concatenate
    the string with a placeholder string that skips a line and formats the placeholder
    as `player_name`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `add_logged_player()` 方法内部，将 `logged_players_label.text` 属性设置为 `player_name`；此函数接收一个参数。生成的文本应在当前内容下方追加
    `player_name`，为此，我们将字符串与一个跳行占位符字符串连接，并将占位符格式化为 `player_name`：
- en: '[PRE0]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After that, move on to the `start_game()` method and add the `"authority"`
    and `"call_local"` options to the `@``rpc` annotation:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，转到 `start_game()` 方法，并在 `@rpc` 注解中添加 `"authority"` 和 `"call_local"` 选项：
- en: '[PRE1]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, inside the function, let’s tell the SceneTree to change the current scene
    to `quiz_screen_scene`, which is a variable that points to `QuizScreenClient.tscn`:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在函数内部，让我们告诉 SceneTree 将当前场景更改为 `quiz_screen_scene`，这是一个指向 `QuizScreenClient.tscn`
    的变量：
- en: '[PRE2]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, on the `_on_StartButton_pressed()` callback, we will make a direct
    RPC to the multiplayer authority’s `start_game()` method without calling it locally:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `_on_StartButton_pressed()` 回调中，我们将直接调用多玩家权限的 `start_game()` 方法，而无需在本地调用：
- en: '[PRE3]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In game development, ensuring fair gameplay and providing an enjoyable experience
    for players are critical aspects of creating a successful game. This involves
    implementing various features and functionalities that make the game engaging
    and dynamic. One such feature is adding a player to the match when they join the
    game. This can be achieved by creating a panel that displays the names of all
    the players currently participating in the game.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，确保公平的游戏玩法并为玩家提供愉快的体验是创建成功游戏的关键方面。这涉及到实现各种功能和特性，使游戏引人入胜且动态。其中一项功能是在玩家加入游戏时将玩家添加到比赛中。这可以通过创建一个面板来实现，该面板显示当前参与游戏的玩家名单。
- en: In a multiplayer game, communication between the server and clients is crucial.
    It’s essential to ensure that only authorized entities can perform specific actions.
    This ensures that the game’s mechanics and flow are consistent and reliable for
    all players.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在多人游戏中，服务器和客户端之间的通信至关重要。确保只有授权实体可以执行特定操作是至关重要的。这确保了游戏机制和流程对所有玩家都是一致和可靠的。
- en: Finally, once all the players are in the game, and the match is about to begin,
    the next step is to move them and the server to the next game screen. This screen
    will display all the necessary information about the game, such as the objective,
    rules, and game mechanics.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦所有玩家都进入游戏，比赛即将开始，下一步是将他们和服务器移动到下一个游戏屏幕。这个屏幕将显示有关游戏的所有必要信息，例如目标、规则和游戏机制。
- en: This ensures that all the players are on the same page and know what to expect
    from the game. Overall, implementing these features ensures that the game runs
    smoothly and that the players have a positive gaming experience.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了所有玩家都在同一页面上，并知道他们可以期待游戏中的什么。总的来说，实现这些功能确保游戏运行顺畅，玩家拥有积极的游戏体验。
- en: With that, every time a player joins the match, their name will be added to
    the `start_game()` method, only the multiplayer authority can make a remote call
    to it, right? We are about to see something new in a moment.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，每次有玩家加入比赛时，他们的名字都会被添加到`start_game()`方法中，只有多人游戏权限者可以远程调用它，对吧？我们很快就会看到一些新东西。
- en: On the server side, we will have a different implementation of this method.
    In the upcoming section, we will see how the match actually starts and why we
    move all players and the server to the next game screen.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，我们将对此方法有不同的实现。在下一节中，我们将看到比赛是如何实际开始的，以及为什么我们将所有玩家和服务器移动到下一个游戏屏幕。
- en: Starting the match
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始比赛
- en: This implementation works that way to prevent one player from calling the `start_game()`
    method on the other players, or on itself, without other players also starting
    the game. The idea is that the player who presses the **Start** button will ask
    the multiplayer authority to start the game.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现方式是为了防止一个玩家在没有其他玩家也开始游戏的情况下，对其他玩家或自己调用`start_game()`方法。想法是，按下**开始**按钮的玩家将请求多人游戏权限者开始游戏。
- en: 'In turn, the multiplayer authority, which is the server in this case, will
    tell every player to also start the match. It does that by calling the `start_game()`
    method on each player. Let’s see how this is done:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来，多人游戏权限者，在本例中是服务器，将告诉每个玩家也开始比赛。它是通过在每个玩家上调用`start_game()`方法来做到这一点的。让我们看看这是如何完成的：
- en: Open the script at `res://05.online-quiz/QuizServer.gd` and find the `start_game()`
    method.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`res://05.online-quiz/QuizServer.gd`脚本并找到`start_game()`方法。
- en: 'In the `@rpc` annotation line, add the `"any_peer"` and the `"call_remote"`
    options. This will allow any peer on the network to make a remote call to this
    method:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`@rpc`注解行中，添加`"any_peer"`和`"call_remote"`选项。这将允许网络上的任何节点对该方法进行远程调用：
- en: '[PRE4]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, tell the SceneTree to change to `quiz_screen_scene_path` using the `get_tree().change_scene_to_file()`
    method. This will tell the server to also update its context to the one in the
    `QuizScreenServer` scene. This will be necessary for the actual game to run:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，告诉SceneTree使用`get_tree().change_scene_to_file()`方法切换到`quiz_screen_scene_path`。这将通知服务器也更新其上下文到`QuizScreenServer`场景中的那个。这对于实际游戏的运行是必要的：
- en: '[PRE5]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, and most importantly, make an RPC call to other peers’ `start_game`
    method, so everyone in the network moves on to their respective `QuizScreenClient`
    scene:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，也是最重要的，向其他节点的`start_game`方法发起RPC调用，这样网络上的每个人都会移动到各自的`QuizScreenClient`场景：
- en: '[PRE6]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The lobby system is a vital component of any online multiplayer game, as it
    serves as the gateway for players to connect and prepare for the match. In our
    quiz game, we have successfully implemented the lobby system using Godot’s built-in
    **Remote Procedure Call** (**RPC**) functionality. This feature allows us to establish
    a reliable two-way communication channel between the client and server, ensuring
    that all players are in sync.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 大厅系统是任何在线多人游戏的关键组成部分，因为它作为玩家连接和准备比赛的入口。在我们的问答游戏中，我们已经成功使用Godot内置的**远程过程调用**（**RPC**）功能实现了大厅系统。此功能使我们能够在客户端和服务器之间建立可靠的双向通信通道，确保所有玩家保持同步。
- en: With the lobby system in place, players can join the match and their names will
    be added to the `start_game()` method can only be called by the multiplayer authority,
    preventing unauthorized calls and ensuring the integrity of the game. The server-side
    implementation of this method will be different, and we will explore this in the
    upcoming section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置了大厅系统后，玩家可以加入比赛，他们的名字将被添加到`start_game()`方法中，只有多人游戏权限者可以调用此方法，以防止未经授权的调用并确保游戏的完整性。此方法的客户端实现将不同，我们将在下一节中探讨这一点。
- en: 'If you want to add more features to the lobby system, you can create a countdown
    timer similar to the ones found in games such as *Warcraft III: Reign of Chaos*.
    This feature adds excitement and anticipation to the match and can help players
    prepare mentally for the upcoming game. However, for our quiz game, we are ready
    to move on to the next step.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在大厅系统中添加更多功能，你可以创建一个类似于在*魔兽争霸III：混乱之治*中找到的倒计时计时器。这个功能增加了比赛的兴奋和期待感，并有助于玩家为即将到来的比赛做好心理准备。然而，对于我们的问答游戏，我们已经准备好进入下一步。
- en: With that, we have the lobby part of our quiz game ready to gather some players
    together and set them up, ready to start the match. We saw how to use the options
    that Godot provides for the `@rpc` annotation to create a two-sided communication
    that we can use to sync players and move them all together to the actual game.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们的问答游戏的大厅部分已经准备好，可以聚集一些玩家并为他们设置，以便开始比赛。我们看到了如何使用Godot提供的`@rpc`注解选项来创建双向通信，我们可以使用它来同步玩家并将他们全部移动到实际游戏中。
- en: The lobby system is a crucial part of any online multiplayer game, and we have
    successfully implemented it in our quiz game using Godot’s built-in RPC functionality.
    The system allows players to join the match and sync their data with the server,
    ensuring that the game is fair and consistent. While we can add more features
    to the lobby system, such as a countdown timer, we are now ready to move on to
    the next stage of development.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 大厅系统是任何在线多人游戏的关键部分，我们已经成功地使用Godot内置的RPC功能在我们的问答游戏中实现了它。该系统允许玩家加入比赛并与其数据同步到服务器，确保游戏公平且一致。虽然我们可以在大厅系统中添加更多功能，例如倒计时计时器，但我们现在准备进入开发下一个阶段。
- en: In the next section, we are going to create a mechanism to disable players’
    actions when another player has already selected the correct answer. With that,
    you can even create a *turn-based* mechanism if you want, which is what we are
    going to do in [*Chapter 6*](B18527_06.xhtml#_idTextAnchor131), *Building an Online*
    *Checkers Game*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将创建一个机制来禁用其他玩家已经选择了正确答案时玩家的动作。有了这个机制，你甚至可以创建一个*回合制*机制，这正是我们将在[*第6章*](B18527_06.xhtml#_idTextAnchor131)中做的，*构建在线*
    *国际象棋游戏*。
- en: Implementing online turns
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现在线回合
- en: When designing a quiz game, it’s important to ensure that players can only provide
    one answer to a given question. This can be especially challenging when creating
    a multiplayer game, as multiple players may attempt to answer the question at
    the same time.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计问答游戏时，确保玩家只能对一个给定问题提供一个答案非常重要。当创建多人游戏时，这可能特别具有挑战性，因为多个玩家可能会同时尝试回答问题。
- en: To prevent this, it’s necessary to implement a system that disables players’
    ability to answer the question once a valid answer has been provided by another
    player.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况，有必要实现一个系统，一旦其他玩家提供了有效答案，就禁用玩家回答问题的能力。
- en: One common approach to implementing this system is to disable the buttons representing
    the potential answers once a player has provided a response. This can be accomplished
    using code that identifies which button was pressed and compares it to the correct
    answer stored in the game’s database. Once an answer has been identified, the
    code can disable the buttons and prevent other players from answering the question.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这个系统的一个常见方法是在玩家提供回应后禁用代表潜在答案的按钮。这可以通过识别哪个按钮被按下并将其与游戏数据库中存储的正确答案进行比较的代码来完成。一旦确定了答案，代码就可以禁用按钮并防止其他玩家回答问题。
- en: To further improve the player experience, it’s also common to include a brief
    pause after an answer has been provided. During this time, players can review
    the questions and answers, and the game can display feedback on whether the answer
    was correct or not. This can help to build tension and excitement in the game,
    while also giving players a chance to reflect on their performance and improve
    their skills.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步提高玩家的体验，在提供答案后通常也会包含一个短暂的暂停。在这段时间里，玩家可以回顾问题和答案，游戏可以显示关于答案是否正确的反馈。这有助于在游戏中建立紧张和兴奋的气氛，同时也给玩家一个反思自己表现并提高技能的机会。
- en: We need to prevent players’ from answering the same question after another player
    already answered it. To do that, we can disable the buttons that represent answers
    once a valid response is provided. And for a better experience, we can add a brief
    pause before changing to the next question.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要防止玩家在另一位玩家已经回答过同一问题后再次回答。为此，我们可以在提供有效响应后禁用代表答案的按钮。为了更好的体验，我们可以在切换到下一个问题之前添加一个短暂的暂停。
- en: In this section, we are going to understand how we can prevent players’ actions,
    ultimately creating a pseudo-turn-based mechanism.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何防止玩家的动作，最终创建一个伪回合制机制。
- en: 'Let’s understand how to achieve that pseudo-turn-based mechanism:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解如何实现这种伪回合制机制：
- en: Open the `res://05.online-quiz/QuizScreenServer.gd` script and let’s implement
    its main methods.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `res://05.online-quiz/QuizScreenServer.gd` 脚本，并实现其主方法。
- en: First of all, let’s add `"any_peer"` to the `answered()` method’s `@rpc` annotation.
    This will allow any player to trigger the behavior we are about to describe when
    they answer a question correctly.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们将 `"any_peer"` 添加到 `answered()` 方法的 `@rpc` 注解中。这将允许任何玩家在正确回答问题时触发我们即将描述的行为。
- en: 'Inside the `answered()` method, we will tell `quiz_panel` to update the round’s
    winner, making an RPC to the `"update_winner"` method and passing the player’s
    name, which is stored in the database. This will update every peer’s `QuizPanel`
    about the round’s winner:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `answered()` 方法内部，我们将告诉 `quiz_panel` 更新本回合的获胜者，通过调用 `"update_winner"` 方法并传递存储在数据库中的玩家姓名来执行
    RPC。这将更新每个对等方的 `QuizPanel`，告知本回合的获胜者：
- en: '[PRE7]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, we start a local timer that should wait for enough time to allow players
    to digest the round’s winner. We also make an RPC on `wait_label` so everyone’s
    `WaitLabel` displays the correct waiting time as well:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们启动一个本地计时器，等待足够的时间让玩家消化本回合的获胜者。我们还对 `wait_label` 进行 RPC 调用，以确保每个人的 `WaitLabel`
    显示正确的等待时间：
- en: '[PRE8]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now let’s do the same thing on the `missed()` method. But we will make an RPC
    to `"``player_missed"` instead:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在 `missed()` 方法上做同样的事情。但我们将对 `"player_missed"` 进行 RPC 调用：
- en: '[PRE9]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With that, `QuizScreenServer` handles both game states when a player wins or
    loses the round. Using RPCs, we can update all peers about what’s happening in
    the game and set them ready for the next round. But we haven’t seen how this actually
    works yet. Coming next, let’s see what happens in `QuizPanel` when we call the
    `update_winner()` and `player_missed()` methods.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，`QuizScreenServer` 处理玩家在赢得或输掉回合时的游戏状态。使用 RPC，我们可以更新所有对等方关于游戏中的发生情况，并使他们为下一回合做好准备。但我们还没有看到这是如何实际工作的。接下来，让我们看看在调用
    `update_winner()` 和 `player_missed()` 方法时 `QuizPanel` 发生了什么。
- en: Updating players about the round
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新玩家关于本回合的信息
- en: In a multiplayer quiz game, it’s crucial to keep all players in sync with the
    game state, especially when someone has already answered a question correctly.
    The `QuizScreenServer` Main node is responsible for updating the game state and
    informing all the connected players about what just happened in the current round.
    To achieve this, the `QuizScreenServer` Main node makes an RPC to all the peers’
    QuizPanels. The `QuizPanel` node on each player’s side will update the game state
    locally and prevent any further interaction until the next round begins.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在多人问答游戏中，保持所有玩家与游戏状态同步至关重要，尤其是在有人已经正确回答了问题的情况下。`QuizScreenServer` 主节点负责更新游戏状态，并通知所有连接的玩家关于当前回合中刚刚发生的事情。为此，`QuizScreenServer`
    主节点会对所有对等方的 `QuizPanels` 进行 RPC 调用。每个玩家侧的 `QuizPanel` 节点将本地更新游戏状态，并防止在下一回合开始前进行任何进一步交互。
- en: The implementation of these methods ensures that all players are on the same
    page, and there are no discrepancies in the game state between players. With this
    approach, we can provide a fair and consistent gaming experience for all the players
    in the game.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法的实现确保所有玩家处于同一页面，玩家之间的游戏状态没有差异。采用这种方法，我们可以为游戏中的所有玩家提供公平和一致的游戏体验。
- en: 'Open the `res://05.online-quiz/QuizPanel.gd` file and let’s implement the `update_winner()`
    and `player_missed()` methods, together with their auxiliary methods as well,
    such as `lock_answers()` and `unlock_answers()`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `res://05.online-quiz/QuizPanel.gd` 文件，并实现 `update_winner()` 和 `player_missed()`
    方法，以及它们的辅助方法，例如 `lock_answers()` 和 `unlock_answers()`：
- en: 'Find the `update_winner()` method and add the `"call_local"` option to its
    `@rpc` annotation. We do that because when we make this RPC on the server, it
    should also update its own `QuizPanel` node as well:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到`update_winner()`方法，并为其`@rpc`注解添加`"call_local"`选项。我们这样做是因为当我们在这个服务器上执行这个RPC时，它也应该更新自己的`QuizPanel`节点：
- en: '[PRE10]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, inside the `update_winner()` method, update the `question_label.text`
    property to display a message with `winner_name`:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`update_winner()`方法内部，更新`question_label.text`属性以显示包含`winner_name`的消息：
- en: '[PRE11]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we will make a call to the `lock_answers()` method. This will make
    players wait for the next round, as we’ll see soon:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将调用`lock_answers()`方法。这将使玩家等待下一轮，正如我们很快就会看到的：
- en: '[PRE12]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can do the exact same thing in the `player_missed()` method. But here, we’ll
    display a different message, communicating that the player missed the answer:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在`player_missed()`方法中做完全相同的事情。但在这里，我们将显示不同的消息，传达玩家错过了答案：
- en: '[PRE13]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With that, we have our user interface updating the players about their peers’
    actions. If a player answered right, they will know it, if a player answered wrong,
    they will know it. Now is the time to get them ready for the next round. Let’s
    look at the `lock_answers()` and `unlock_answers()` methods.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，我们的用户界面正在更新玩家关于他们同伴行动的信息。如果一个玩家回答正确，他们会知道；如果一个玩家回答错误，他们也会知道。现在是让他们为下一轮做好准备的时候了。让我们看看`lock_answers()`和`unlock_answers()`方法。
- en: 'In the `lock_answers()` method, we are going to run through all `AnswerButtons`,
    which are children of the `Answers` node, and disable them. This way, players
    won’t be able to interact with these buttons anymore, preventing them from answering
    the question:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`lock_answers()`方法中，我们将遍历所有`AnswerButtons`，它们是`Answers`节点的子节点，并将它们禁用。这样，玩家就无法再与这些按钮交互，从而防止他们回答问题：
- en: '[PRE14]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We do the opposite in the `unlock_answers()` method, toggling off the disabled
    property on each `AnswerButton` node:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`unlock_answers()`方法中，我们做的是相反的操作，关闭每个`AnswerButton`节点上的禁用属性：
- en: '[PRE15]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will prevent and allow player interactions with the available answers to
    the current question. We can use this same approach to create an actual turn-based
    system where players take turns trying to answer one question at a time. Here’s
    a challenge for you, our network engineer. As an exercise, implement a turn-based
    system using the knowledge you just acquired. You have everything necessary at
    your disposal.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这将阻止并允许玩家与当前问题的可用答案进行交互。我们可以使用相同的方法创建一个实际的轮流制系统，其中玩家轮流尝试一次回答一个问题。这里有一个挑战给你，我们的网络工程师。作为一个练习，使用你刚刚获得的知识实现一个轮流制系统。你拥有所有必要的资源。
- en: A turn-based system is a way of structuring gameplay where each player takes
    a turn to make their move, before passing control to the next player. This is
    in contrast to real-time gameplay, where all players are acting at the same time.
    Turn-based systems are often used in strategy games, where players need to carefully
    plan their moves.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 轮流制系统是一种构建游戏玩法的方式，其中每个玩家轮流进行移动，然后传递控制权给下一个玩家。这与实时游戏玩法形成对比，在实时游戏玩法中，所有玩家同时行动。轮流制系统通常用于策略游戏，在这些游戏中，玩家需要仔细规划他们的移动。
- en: To implement a turn-based system in your quiz game, you will need to modify
    the existing code to add a new layer of logic. One approach would be to create
    a queue of players, with each player taking their turn in order. When it’s a player’s
    turn, they are allowed to answer the question, while the other players are locked
    out. Once they have answered, their turn is over, and the next player in the queue
    takes their turn.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的问答游戏中实现轮流制系统，你需要修改现有的代码以添加一个新的逻辑层。一种方法是为玩家创建一个队列，每个玩家按顺序轮流。当轮到玩家时，他们可以回答问题，而其他玩家则被锁定。一旦他们回答完毕，他们的回合就结束了，队列中的下一个玩家接着进行他们的回合。
- en: To create this system, you could turn `lock_answer()` and `unlock_answer()`
    into RPC methods and use the `rpc_id()` method to directly lock or unlock the
    players’ answer options based on whether they are the current active player.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这个系统，你可以将`lock_answer()`和`unlock_answer()`转换为RPC方法，并使用`rpc_id()`方法直接根据玩家是否是当前活动玩家来锁定或解锁玩家的答案选项。
- en: In the next section, we’ll understand how we can take the fundamental mechanics
    of a quiz game and make them work in an online context. It’s going to be the core
    of this chapter as we will see how we evaluate whether the player answered the
    question correctly and how we load new questions, ensuring that all peers are
    looking at the same question.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解如何将问答游戏的基本机制应用于在线环境。这将是本章的核心内容，我们将看到我们如何评估玩家是否正确回答了问题，以及我们如何加载新问题，确保所有玩家都在查看相同的问题。
- en: Turning local mechanics into remote gameplay
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将本地机制转化为远程游戏
- en: Now that we can manage players’ interactions and communicate the game state
    to players, it’s time to implement the core features of a quiz. Coming up, we
    are going to implement the questions and answers. For that, we are going to use
    a questions database where we store them with their possible answers and the correct
    answer index.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够管理玩家的交互并向玩家传达游戏状态，是时候实现问答的核心功能了。接下来，我们将实现问题和答案。为此，我们将使用一个问题数据库，在其中我们将它们与可能的答案和正确答案索引一起存储。
- en: Here, we will see how we load and deserialize these questions into `QuizPanel`.
    On top of that, we’ll also understand how we make use of RPCs to keep everyone
    in sync. And of course, we will also implement the logic behind both when players
    choose the correct and the incorrect answer.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将看到我们如何加载和反序列化这些问题到`QuizPanel`中。除此之外，我们还将了解我们如何利用RPC来保持所有人的同步。当然，我们还将实现当玩家选择正确和错误答案时的逻辑。
- en: When a player chooses an answer, we need to compare it with the correct answer
    index, and if it’s correct, we should notify `QuizScreenServer` about the correct
    answer. We’ll also need to make use of RPCs to keep everyone in sync regarding
    the current question and answer status.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家选择一个答案时，我们需要将其与正确答案索引进行比较，如果正确，我们应该通知`QuizScreenServer`关于正确答案。我们还将需要使用RPC来保持所有人关于当前问题和答案状态的同步。
- en: Moreover, we need to implement the logic behind what happens when a player chooses
    the incorrect answer. We can use the same locking mechanism that we used previously
    to prevent players from answering if someone has already provided a valid answer.
    Once we handle the incorrect answer, we need to notify `QuizScreenServer` about
    the incorrect answer and move on to the next round.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要实现当玩家选择错误答案时背后的逻辑。我们可以使用之前使用的相同锁定机制来防止玩家在有人已经提供了有效答案时回答。一旦我们处理了错误答案，我们需要通知`QuizScreenServer`关于错误答案，并进入下一轮。
- en: By implementing all of these features, we can create a robust and engaging quiz
    game that can be played by multiple players simultaneously. By using the database
    to load questions, we can make the game dynamic and varied. And by using RPCs
    and locking mechanisms, we can ensure that the game runs smoothly and that everyone
    is on the same page.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现所有这些功能，我们可以创建一个健壮且引人入胜的多人同时可玩的问答游戏。通过使用数据库来加载问题，我们可以使游戏动态多变。并且通过使用RPC和锁定机制，我们可以确保游戏运行顺畅，并且每个人都处于同一页面上。
- en: Understanding the questions database
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解问题数据库
- en: 'First of all, let’s start by taking a look at our questions database. Open
    the file at `res://05.online-quiz/QuizQuestions.json`. It looks like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们先看看我们的问题数据库。打开文件`res://05.online-quiz/QuizQuestions.json`。它看起来是这样的：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Notice that we represent each question as a *key* that is also a dictionary.
    Each question has three keys as well: `"text"`, `"alternatives"`, and `"correct_answer_index"`.
    The `"text"` key is the actual question statement, `"alternatives"` is an array
    of possible answers that we will turn into `AnswerButtons`, and `"correct_answer_index"`
    is the index in the `"alternatives"` array of the correct answer.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们代表每个问题作为一个既是*键*也是字典。每个问题有三个键：`"text"`、`"alternatives"`和`"correct_answer_index"`。`"text"`键是实际的问题陈述，`"alternatives"`是一个可能的答案数组，我们将将其转换为`AnswerButtons`，而`"correct_answer_index"`是`"alternatives"`数组中正确答案的索引。
- en: Knowing that, you can go ahead and create some questions on your own. Keep in
    mind that, by default, we have four `AnswerButtons`, so try to provide four values
    in the `"alternatives"` key. Otherwise, you’d need to implement an `AnswerButtons`
    factory to dynamically create them based on how many answers we load from the
    question.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这一点后，你可以自行创建一些问题。请注意，默认情况下，我们有四个`AnswerButtons`，所以在`"alternatives"`键中尝试提供四个值。否则，你需要实现一个`AnswerButtons`工厂，根据我们从问题中加载的答案数量动态创建它们。
- en: Loading and updating questions
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载和更新问题
- en: Now, let’s understand how this process works under the hood of `QuizPanel`.
    Open the script at `res://05.online-quiz/QuizPanel.gd` and find the `update_question()`
    method. The first thing you’ll notice is that it has an `@``rpc` annotation.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解在`QuizPanel`内部是如何实现这个过程的。打开位于`res://05.online-quiz/QuizPanel.gd`的脚本，并找到`update_question()`方法。你首先会注意到它有一个`@rpc`注解。
- en: 'This is because we design it in such a way that it’s the server who calls it
    and tells it which question to load. We will see that in a moment, but for now,
    let’s implement this method’s logic:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们设计得这样，是服务器调用它并告诉它加载哪个问题。我们将在稍后看到这一点，但现在，让我们实现这个方法的逻辑：
- en: 'Create a variable called `question` and set it equal to the result of calling
    the `pop_at()` method on `available_questions` with the `new_question_index` argument
    passed in. With that, we’ll remove the current question from the list of available
    questions and store it so we can use it moving on:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`question`的变量，并将其设置为对`available_questions`调用`pop_at()`方法的结果，传入`new_question_index`参数。这样，我们将从可用问题列表中删除当前问题并将其存储起来以便继续使用：
- en: '[PRE17]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Check whether the question is not equal to null. Since the `pop_at()` method
    returns `null` when it can’t find a value in the index provided, we check that
    to know if there are still questions that we didn’t use yet, in other words, if
    `available_questions` is empty:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查问题是否不等于`null`。由于`pop_at()`方法在提供的索引中找不到值时返回`null`，我们检查这一点以了解是否还有我们没有使用的问题，换句话说，如果`available_questions`为空：
- en: '[PRE18]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If the question we got is not null, set the `question_label.text` property
    to the `''text''` property of the question dictionary stored in the questions
    array. This is how we display the question’s statement:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们得到的问题不是`null`，将`question_label.text`属性设置为存储在`questions`数组中的问题字典的`'text'`属性。这就是我们显示问题陈述的方式：
- en: '[PRE19]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a variable called `correct_answer` and set its value to the `''correct_answer_index''`
    property of the question dictionary stored in the questions array. Doing that,
    we keep the correct answer stored so we can compare it when players answer:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`correct_answer`的变量，并将其值设置为存储在`questions`数组中的问题字典的`'correct_answer_index'`属性。这样做，我们可以保留正确的答案以便在玩家回答时进行比较：
- en: '[PRE20]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Loop through the numbers `0` through `3`, inclusive, using the `range()` function
    and the `for` loop. For each iteration, create a variable called `alternative`
    and set it equal to `i`, which is the current element of the `''alternatives''`
    array stored in the question dictionary. Set the text of the current child node
    of the `answer_container` node to `alternative`. With that, we display the alternative’s
    text on its respective `AnswerButton`:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`range()`函数和`for`循环遍历数字`0`到`3`（包含），对于每次迭代，创建一个名为`alternative`的变量，并将其设置为`i`，即存储在问题字典中的`'alternatives'`数组中的当前元素。将`answer_container`节点的当前子节点的文本设置为`alternative`。这样，我们就在各自的`AnswerButton`上显示了备选答案的文本：
- en: '[PRE21]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After loading the question and its answers, let’s call the `unlock_answers()`
    function. This basically starts the current round, allowing players to interact
    with `QuizPanel` again:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在加载问题和其答案后，让我们调用`unlock_answers()`函数。这基本上开始了当前回合，允许玩家再次与`QuizPanel`交互：
- en: '[PRE22]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If `question` is `null`, meaning we don’t have any questions left to play the
    quiz, we need to loop through each child node of the `answer_container` node using
    the `for` loop. For each iteration, we’ll set the text of the `question_label`
    node to `''No` `more questions''`:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`question`是`null`，意味着我们没有剩余的问题可以玩测验，我们需要使用`for`循环遍历`answer_container`节点的每个子节点。对于每次迭代，我们将`question_label`节点的文本设置为`'No
    more questions'`：
- en: '[PRE23]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Since we reached the end of our quiz match, we can call the `lock_answers()`
    function to prevent any further interactions:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已经到达了我们的测验比赛的终点，我们可以调用`lock_answers()`函数来防止任何进一步的交互：
- en: '[PRE24]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After these steps, the `update_question()` method should look like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些步骤之后，`update_question()`方法应该看起来像这样：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With that, we have our main quiz mechanism set up. We can pick one of the questions
    we have in our database and display it to our players. You can check the `_ready()`
    callback to understand how we load the questions in memory and assign them to
    the `available_questions` variable.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经设置了主要的测验机制。我们可以从我们的数据库中选择一个问题并显示给我们的玩家。你可以检查`_ready()`回调来了解我们如何将问题加载到内存中并将它们分配给`available_questions`变量。
- en: 'As mentioned before, we are going to focus on the essentials here. Talking
    about the essentials, we are still missing one mechanic, which is how we validate
    the answers, right? Find the `evaluate_answer()` method and let’s implement that:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将在这里关注重点。说到重点，我们仍然缺少一个机制，那就是我们如何验证答案，对吧？找到 `evaluate_answer()` 方法，让我们来实现它：
- en: 'Inside the `evaluate_answer()` method, create a variable called `is_answer_correct`
    and set it equal to the comparison between the `answer_index` and `correct_answer`
    variables. This will check whether the given answer index matches the index of
    the correct answer:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `evaluate_answer()` 方法的内部，创建一个名为 `is_answer_correct` 的变量，并将其设置为 `answer_index`
    和 `correct_answer` 变量的比较。这将检查给定的答案索引是否与正确答案的索引匹配：
- en: '[PRE26]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Emit a signal called `answered` with the `is_answer_correct` variable as an
    argument. This signal will be used by other parts of the quiz to tell whether
    the player’s answer was correct or not:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发射一个名为 `answered` 的信号，其参数为 `is_answer_correct` 变量。这个信号将被测验的其他部分用来告知玩家的答案是否正确：
- en: '[PRE27]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the end, our `evaluate_answer()` method is quite simple and does just what
    we need to know whether the player answered the current question correctly:'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们的 `evaluate_answer()` 方法相当简单，只做我们需要知道玩家是否正确回答当前问题的事情：
- en: '[PRE28]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You may have noticed that the `evaluate_answer()` method isn’t an RPC function,
    right? It essentially emits a signal that tells us whether the player’s answer
    was correct or not. So how does the server manage that?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到 `evaluate_answer()` 方法不是一个 RPC 函数，对吧？它本质上发射一个信号，告诉我们玩家的答案是否正确。那么服务器是如何管理这个的呢？
- en: In the upcoming section, we will understand how this information is passed around
    between the client and the server implementations of our quiz.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将了解这些信息是如何在我们测验的客户端和服务器实现之间传递的。
- en: Sending players’ answers to the server
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将玩家的答案发送到服务器
- en: Now, let’s understand the final piece of our mechanics and how it behaves in
    a multiplayer network. In the previous section, we ended up with an evaluation
    of the player’s answer that led to the emission of the `answered` signal.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解我们机制的最后一块以及它在多人网络中的行为。在前一节中，我们最终得到了对玩家答案的评估，这导致了 `answered` 信号的发射。
- en: The `answered` signal needs to be handled in a specific way to ensure that all
    players are kept in sync and that the game state is consistent across all peers.
    When a player submits their answer, the `answered` signal is emitted, and the
    server updates all peers about it through an RPC call.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`answered` 信号需要以特定的方式处理，以确保所有玩家保持同步，并且所有对等方的游戏状态保持一致。当玩家提交答案时，会发射 `answered`
    信号，并通过 RPC 调用服务器更新所有对等方关于这一点。'
- en: The `answered` signal and its associated methods are crucial for maintaining
    the integrity of the game state across all players in a multiplayer network. Without
    them, players might see different game states and have different experiences,
    which would make the game less enjoyable and potentially unfair.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`answered` 信号及其相关方法对于维护多人网络中所有玩家游戏状态的一致性至关重要。没有它们，玩家可能会看到不同的游戏状态，并拥有不同的体验，这会使游戏变得不那么有趣，甚至可能不公平。'
- en: In this section, we will understand how this signal propagates through the network
    and updates all peers about the players’ answers.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解这个信号是如何在网络中传播并更新所有对等方关于玩家答案的。
- en: Open the `res://05.online-quiz/QuizScreenClient.gd` script and you will notice
    that, right at the beginning, we have a callback to the `QuizPanel.answered` signal.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `res://05.online-quiz/QuizScreenClient.gd` 脚本，你将注意到，在最开始，我们有一个对 `QuizPanel.answered`
    信号的回调。
- en: 'Let’s implement this callback:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来实现这个回调：
- en: 'Inside the method’s body, use an `if` statement to check whether `is_answer_correct`
    is true:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在方法体内，使用 `if` 语句检查 `is_answer_correct` 是否为真：
- en: '[PRE29]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If `is_answer_correct` is `true`, make an RPC call to the answered method on
    the server using the `rpc_id()` method. With that, the server will update all
    peers about the round winner:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `is_answer_correct` 是 `true`，则使用 `rpc_id()` 方法调用服务器上的 `answered` 方法。有了这个，服务器将更新所有对等方关于本回合胜者的信息：
- en: '[PRE30]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If `is_answer_correct` is `false`, make an RPC call to the missed method on
    the server using the `rpc_id()` method. Finally, if the player chose the wrong
    answer, the server updates all peers about it:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `is_answer_correct` 是 `false`，则使用 `rpc_id()` 方法调用服务器上的错过方法。最后，如果玩家选择了错误的答案，服务器将更新所有对等方关于这一点：
- en: '[PRE31]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The whole `_on_quiz_panel_answered()` implementation should look like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`_on_quiz_panel_answered()` 的整个实现应该看起来像这样：'
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With that, the client implementation will notify the server about the players’
    interactions. In turn, the server will update the game state and tell all peers
    to also update their game states to match the server’s. After that, we have the
    missing network pieces in place and our online quiz game is ready. Feel free to
    test it out and experiment with more questions!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，客户端实现将通知服务器有关玩家交互的信息。反过来，服务器将更新游戏状态，并告诉所有同伴也更新他们的游戏状态以匹配服务器的状态。之后，我们就位了缺失的网络组件，我们的在线问答游戏已经准备就绪。请随意测试并尝试更多问题！
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how to create an online quiz game using the Godot Engine
    4.0 Network API. We covered the fundamental concepts of online multiplayer game
    development, including client-server architecture, game synchronization, and player
    interactions. Using the quiz game, we saw how to feature dynamic loading of questions
    from a JSON database, and how to display the current players in a quiz match.
    We created a mechanism to prevent players from answering questions when another
    player has already provided one, creating a pseudo-turn-based mechanism. Finally,
    we saw how to manage players’ interactions and communicate the game state to players
    and how to implement the logic behind both correct and incorrect answers, loading
    new questions one round after another until there are no more questions to display.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用 Godot Engine 4.0 网络API创建在线问答游戏。我们涵盖了在线多人游戏开发的基本概念，包括客户端-服务器架构、游戏同步和玩家交互。通过问答游戏，我们看到了如何从
    JSON 数据库动态加载问题，以及如何在问答比赛中显示当前玩家。我们创建了一个机制，防止玩家在另一位玩家已经回答问题后回答，从而创建了一个伪回合制机制。最后，我们看到了如何管理玩家交互，将游戏状态传达给玩家，以及如何实现正确和错误答案背后的逻辑，一轮接一轮地加载新问题，直到没有更多问题可以显示。
- en: In the next chapter’s projects, we will dive deeper into implementing a turn-based
    mechanism for our online quiz game. As we saw in this chapter, we can use a similar
    approach to what we did with the pseudo-turn-based mechanism, but with some modifications
    to make it a true turn-based system.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章的项目中，我们将更深入地实现我们的在线问答游戏的回合制机制。正如我们在本章中看到的，我们可以使用与伪回合制机制类似的方法，但进行一些修改以使其成为一个真正的回合制系统。
- en: Additionally, we will explore how to pass information about players’ turns,
    such as who is currently taking their turn, what happened during the opponent’s
    turn, and more. We will also learn how to set up win and lose conditions and update
    peers about them, which will be essential for creating a sense of accomplishment
    and challenge in our game.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将探讨如何传递有关玩家回合的信息，例如谁正在轮到他们，对手回合期间发生了什么，以及更多内容。我们还将学习如何设置胜负条件并更新同伴们关于这些条件的信息，这对于在我们的游戏中营造成就感与挑战感至关重要。
- en: By the end of the next chapter, you will have a deeper understanding of the
    game development process, including how to create engaging online multiplayer
    game mechanics and implement them using the Godot Engine 4.0 Network API. See
    you there!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 到下一章结束时，你将更深入地了解游戏开发过程，包括如何创建引人入胜的在线多人游戏机制，并使用 Godot Engine 4.0 网络API实现它们。那里见！
