- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strengthening Firmware – Practical C++ Error Handling Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To ensure the proper functioning of firmware, we must handle errors from vendor-specific
    code, libraries that we are using in a project, and our own code. Error codes
    are standard error-handling mechanisms in C, and they are also used in C++. However,
    C++ provides us with other tools, most notably exceptions that are often avoided
    in embedded projects due to the large binary footprint and non-determinism. Still,
    we will discuss exceptions in C++ in this chapter to show their benefits in the
    error-handling process.
  prefs: []
  type: TYPE_NORMAL
- en: Besides exceptions, C++ offers more options for error handling that will also
    be discussed in this chapter. The goal of this chapter is to understand potential
    issues with error codes and see how to mitigate them in C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Error codes and asserts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std:: optional` and `std::expected`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get the most out of this chapter, I strongly recommend using Compiler Explorer
    ([https://godbolt.org/](https://godbolt.org/)) as you read through the examples.
    Select GCC as your compiler and target x86 architecture. This will allow you to
    see standard output (stdio) results and better observe the code’s behavior. As
    we are using modern C++ features make sure to select C++23 standard, by adding
    `-std=c++23` in compiler options box.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler Explorer makes it easy to try out the code, tweak it, and immediately
    see how it affects the output and generated assembly. The examples are available
    at GitHub ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter07](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter07)).
  prefs: []
  type: TYPE_NORMAL
- en: Error codes and asserts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Error codes** are a common way of reporting and handling errors in C. They
    are also still used in C++. A function that fails reports an error through enumerated
    codes that are checked by a caller and handled appropriately. Let us analyze how
    error codes work from both the caller and the callee perspective.'
  prefs: []
  type: TYPE_NORMAL
- en: A function that returns an error must have a list of errors that are exposed
    to callers. This list is maintained through a software life cycle, and it can
    be subject to changes. Enumerated error codes can be added, removed, or modified.
    A caller must be aware of the error codes that the callee is returning, and it
    needs to handle them. Or, if it doesn’t know how to handle an error, it should
    propagate it further within a call stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s observe a simple example of a function that returns an error and analyze
    the implications this has for the code using this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the `h` function returns an error of `enum class
    error`. The `g` function calls the `h` function and executes the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Checks if `h` returned an error that is different from `error::Ok`. This indicates
    that the `h` function didn’t perform its task and there is an error that should
    be handled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `h` returned an error, checks whether it is `error::Error1`. In this case,
    `g` knows how to handle this error and it handles it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `h` returned `error::Error2`, `g` is not capable of handling it, and it forwards
    it up the call stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Returns `error::Ok` to indicate up the call stack that everything went fine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Function `g` is called by `f`, and `f` also needs to be aware of errors defined
    in `enum class error`. It should handle them or pass them up the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Error codes rely on design contracts. The caller must check if the callee returned
    an error, and if it did, it needs to handle it or pass it up the call stack. Now,
    we can identify several potential problems with this simple approach:'
  prefs: []
  type: TYPE_NORMAL
- en: We cannot enforce error handling by a caller. It can just discard the return
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The caller can forget to handle some of the error cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The caller can forget to pass the error up the call stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are serious design flaws that put an extra burden on code development.
    There is no escape hatch in case we forget to handle an error somewhere. The program
    stays in an unknown state and this potentially leads to unwanted behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can address the first concern using the `nodiscard` attribute. It can be
    used with a function declaration or enumeration declaration. In our case, we can
    use it with an `enum class` `error` declaration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When a function returning the `enum class` error is called, and the return
    value is discarded, the compiler is encouraged to raise a warning. If we call
    the `g` or `h` function from our example, GCC will raise a warning similar to
    this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If we set up the compiler to treat all warnings as errors, this would break
    the compilation process and force us to use the return value in code. Even though
    the `nodiscard` attribute is useful and should be used for similar use cases,
    it is not a complete solution to our problem. It will enforce usage of the return
    value, but the caller may still fail to check the error code for all possible
    cases and address it properly.
  prefs: []
  type: TYPE_NORMAL
- en: Almost every application has some types of errors that are unrecoverable and
    the only thing it makes sense to do is to log them, display them to a user (if
    possible), and terminate the program, as there is no sense in proceeding with
    such a program state. For these types of errors, we can use a global error handler,
    as they are too important to be left open in the wild and potentially not handled
    by a caller.
  prefs: []
  type: TYPE_NORMAL
- en: Global error handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Global error handlers** can be implemented as free functions. They are used
    system-wide to address errors that are unrecoverable and when it is necessary
    to stop the execution of firmware due to the severity of an error.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at an example of firmware using an accelerometer. If there
    are any issues in I²C communication with the accelerometer, it doesn’t make sense
    to proceed further with code execution – the firmware will display a message to
    the user and terminate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have an `accelerometer` class with the `get_data`
    method, which uses the `i2c_read` function from the vendor-specific HAL in C (let
    us pretend this is the case).
  prefs: []
  type: TYPE_NORMAL
- en: The `i2c_read` function returns the number of read bytes. In our example, the
    return value is stubbed to `0` so we can simulate the erroneous behavior of the
    accelerometer (or the I²C bus). In case `i2c_read` returns a number different
    from the requested number of bytes, `get_data` will call `error::handler`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We implemented an error handler using a tag-dispatching mechanism. We are overloading
    the `error::handler` function with so-called tags, or empty types. In our example,
    we have two tags, `i2c_failed` and `spi_failed`, and two overloaded error handlers.
    Tag dispatching has a couple of advantages over defining error codes with `enum`:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to overload error handlers for every tag that is used in code. Error
    handlers are implemented individually for every error type. This adds to the readability
    of code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In case we make a call to an error handler that is not overloaded, the compilation
    will fail, forcing us to implement it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our example, the error handler will print a message using the `printf` function
    and make a call to the `exit` function, effectively terminating the program. In
    real-world situations, how we handle errors depends on the application. For example,
    for a medical device, if critical operations become unsafe after an error, we
    would first attempt to recover from the error.
  prefs: []
  type: TYPE_NORMAL
- en: If recovery failed, the system would enter a critical error state, alert medical
    personnel, and gracefully terminate the treatment operation.
  prefs: []
  type: TYPE_NORMAL
- en: An error on the I²C bus or, more generally, failed communication with external
    devices must be handled appropriately through robust error-handling mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, there are conditions that indicate programming mistakes –
    situations that should never occur if the code is correct. These include violations
    of preconditions, such as input parameters being out of expected boundaries due
    to logic errors in the code. Proceeding under such circumstances could lead to
    undefined behavior or system instability. To detect these programming errors during
    development, we use asserts.
  prefs: []
  type: TYPE_NORMAL
- en: Asserts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Asserts are primarily used during development to detect programming mistakes
    by verifying that certain conditions hold true at specific points in the code.
    They help identify logical errors and incorrect assumptions by halting execution
    when an unexpected condition occurs. A macro assert is defined in `<cassert>`
    in the standard library. It is used to check a logical expression, and in case
    the logical expression is false, it prints diagnostic information and calls `std::abort`,
    effectively terminating the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand asserts, and how to use them, let us take a look at the
    following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have defined the `option` enum class with `uint8_t`
    as an underlying type. We will use it to allow users to select an option over
    a network interface and we want to make sure that the conversion from `uint8_t`
    to the `option` enum is always correct. The `uint8_to_option` function will assert
    if the received `uint8_t` argument is not smaller than `option::Last`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example, we called `uint8_to_option` with argument `3`, which is not
    smaller than `option::Last`, meaning that the assert macro will print the following
    diagnostic information and make a call to `std::abort` to terminate the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this is quite a lengthy debug statement. Let’s take a look at the `assert`
    macro definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We see that the expression is cast to a `bool` type and that the ternary operator
    does nothing if the expression is true, or it makes a call to the `__assert_fail`
    function if the expression is false. The `assert` macro passes the expression
    as a string literal, the filename as a string literal, the line number, and also
    a function name as a string literal. All these string literals must be stored
    in the binary, taking up precious memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Asserts can be disabled by defining the `NDEBUG` macro before including `<cassert>`
    as in the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can also define `NDEBUG` using the build system. The `assert` macro will
    do nothing if `NDEBUG` is defined before `<cassert>` is included. This option
    is left to be used in case we want to disable asserts, as they are most commonly
    used in debug builds, and disabled in production builds. They should be disabled
    before the safety-critical software validation.
  prefs: []
  type: TYPE_NORMAL
- en: The `assert` macro, as implemented in the standard library, is not suitable
    for embedded systems as it includes the filename, function name, and `assert`
    expression as string literals, which end up stored in the flash of the embedded
    target. Moreover, asserts are mostly intended to be used during debugging, and
    they are often disabled in production builds. Still, there is a benefit of asserts
    enabled in production builds, as they can provide valuable insights for postmortem
    debugging if they are implemented to log data when the expression is evaluated
    as `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will examine an alternative approach to logging information using asserts.
    As we have already concluded, the default assert macro implementation is not well
    suited for embedded targets, even though it contains useful information for debugging:
    filename, function name, and line number. Instead of a lengthy string describing
    an exact location of the assert macro line in our code, we can simply log a program
    counter and use the map file and `addr2line` tool to convert the address to the
    exact line. We can see a simple macro definition and a helper function to implement
    this in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have defined a macro named `light_assert` that, instead of `__assert_failed`,
    calling `log_pc_and_halt`. It is passing the return value from `hal::get_pc` as
    an argument to `log_pc_and_halt`. To see this code in action, you can take a look
    at the example in the `Chapter07/error_handling` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The project for this chapter is configured so that you can configure it to
    use different main C++ files and configure which one is going to be used with
    CMake. Let us start our Docker container using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This should get us in the Docker terminal. Run `ls –l` to make sure that the
    `Cpp-in-Embedded-Systems` repo is cloned. If not, clone it using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Start Visual Studio Code, attach it to the running container, and open `Chapter07/error_handling
    project` as described in [*Chapter 4*](Chapter_04.xhtml) and run the following
    commands in the Visual Studio Code terminal, or run them directly in the container
    terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding commands will build the firmware using the `app/src/main_assert.cpp`
    file and run it in Renode simulator. You should see similar output to this in
    the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the assert evaluated expression to false and printed out the
    `0x08000F74` program counter value. We can convert this value to the line from
    a source file using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are able to get the exact line of the source of the assert
    using this approach and by logging just 4 bytes of data (address). In this implementation,
    `log_pc_and_halt` just print the address. In production implementations, we can
    store the address in non-volatile memory and use it for postmortem debugging.
  prefs: []
  type: TYPE_NORMAL
- en: The `hal::get_pc()` function is declared with an `inline` specifier. We use
    `inline` as a hint to the compiler to insert instructions from a function directly
    to a call site, that is, not to make a function call. The compiler doesn’t necessarily
    need to comply with our intentions, and that can be observed by building this
    example using the `O0` optimization level.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise for you!
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise, edit `CMAKE_C_FLAGS_DEBUG` and `CMAKE_CXX_FLAGS_DEBUG` in `CMakeLists.txt`,
    and instead of `Og`, use `O0`. Build and run the program and run the `addr2line`
    utility on the output. To mitigate this concern, you can define a macro to be
    used instead of the `hal::get_pc()` function.
  prefs: []
  type: TYPE_NORMAL
- en: We use asserts to catch programming errors – situations that should never occur
    if the code is correct. They are often employed to validate internal assumptions
    and invariants within critical functions. The primary purpose of asserts is for
    debugging; they help developers find and fix bugs during the development phase.
    However, as we’ve seen, customized asserts can also provide valuable insights
    into production builds for postmortem analysis. While asserts are useful for detecting
    programming mistakes during development, they are not a substitute for proper
    error handling in production code. Error codes can be cumbersome because they
    require manual propagation of errors up the call stack. C++ offers exceptions
    as a solution to these problems, providing a structured way to handle errors without
    cluttering the code with error-checking logic.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will go over C++ exceptions to better understand the benefits they
    offer from the error-handling aspect.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Exceptions in C++ are error-handling mechanisms that are based on the principle
    of throwing and catching objects of an arbitrary type. All exceptions that are
    thrown from the standard library derive from the `std::exception` class defined
    in the `<exception>` header. We put code that may throw an exception in the `try`
    block, and we define the type of exception we want to catch in the `catch` clause,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we have defined `std::array arr`, an array of integers
    with four members. In the `try` block, we are trying to access an element with
    index `5`, which is clearly out of the defined range, and the `at` method will
    throw the `std::out_of_range` exception. In order to run this example, go to the
    `Chapter07/error_handling` folder, make sure that the `build` folder is deleted,
    and run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You should see `Array out of range!` printed in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Now, while building the example, you may have noticed that the size of the binary
    is a whooping 88 KB. What happened?
  prefs: []
  type: TYPE_NORMAL
- en: In order to enable exceptions, besides using the `-fexceptions` compiler flag,
    we also had to disable the nano specs that we used in previous examples. Nano
    specs define the usage of the C standard `newlib-nano` library and size-optimized
    `libstdc++` and `libsupc++` libraries. These are built without exception support
    and if we use them, any attempt at throwing exceptions will result in `std::abort`
    being called instead. By disabling nano specs, we are using an unoptimized C++
    standard library, which results in the 88 KB binary size. A size-optimized standard
    C++ library can be built from sources with enabled exceptions, which would help
    reduce the binary footprint.
  prefs: []
  type: TYPE_NORMAL
- en: 'If an exception is not caught, `std::terminate_handler` will be called. We
    can replace the default handler using the `std::set_terminate` function as in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we provided a lambda as a terminate handler. As an
    exercise, try to access the array from the previous example with an index that
    is out of range, but out of a `try` block. This should trigger the terminate handler
    and make a call to the lambda we passed to the `std::set_terminate` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exceptions are propagated up the call stack. Let us go through the following
    example to demonstrate exception propagation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example is based on a ring buffer from previous chapters that
    uses `std::array` as an underlying container. In the `push` method, it doesn’t
    check the write index, meaning that the array’s `at` method will throw an exception
    if we call the `push` method more than `N` times. An exception is thrown in the
    `push` method, where there is no `try-catch` block, and it gets caught only in
    the `main` function in the `catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the preceding example in the Renode simulator using the following
    instructions. Start Visual Studio Code, attach it to the running container, open
    `Chapter07/error_handling project` as described in [*Chapter 4*](Chapter_04.xhtml),
    and run the following commands in the Visual Studio Code terminal, or run them
    directly in the container terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Exception propagation is useful for the type of errors that we don’t want to
    propagate between the software layers manually using error codes. However, the
    problem with exceptions is that they are not visible from function declarations
    as is the case with error codes. We need to rely on good documentation to know
    which function throws an error and where those errors are handled.
  prefs: []
  type: TYPE_NORMAL
- en: There is a saying that exceptions are used for exceptional errors that are very
    rare. But what are exceptional errors? That depends on the library, application,
    and use case. It is hard to generalize. A failed read to the accelerometer may
    be a recoverable error that is solved by resetting it. We can throw an exception
    on a failed I²C bus communication, and the upper layer that catches this error
    may decide to try resetting the accelerometer.
  prefs: []
  type: TYPE_NORMAL
- en: Failing to control boost voltage regulator output by DAC may also be recoverable,
    but we may want to terminate the program as we are implementing a medical device
    and that may be the best action possible to prevent any damage to a user. In this
    case, we want to react as fast as possible and exception propagation and stack
    unwinding are probably not desirable so we will rely on a global handler or asserts
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions come with a price, both in flash and RAM memory consumption, and
    the execution time can’t always be guaranteed, which is a problem if we are working
    with hard real-time systems. But they also solve the problem of error propagation
    and enforce error handling. If there is not a `catch` clause for a specific type,
    `std::terminate_handler` will be called, and the program will not continue with
    the execution.
  prefs: []
  type: TYPE_NORMAL
- en: Error codes and exceptions can co-exist, and they often do. Embedded C++ projects
    often use C libraries, or legacy C++ code, which often uses error codes. We can
    benefit from exceptions by using them for very rare errors, adding additional
    robustness to our firmware. Still, the decision of whether to use them is influenced
    by available memory resources and the type of project we are working on.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will cover the C++ `std::optional` and `std::expected` template classes,
    which are used as return types from functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'std:: optional and std::expected'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++17 introduced `std::optional`, a template class that either has a value
    or has nothing. This is useful for situations where a function may or may not
    return a value. To better understand it, let’s go through the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have a `sensor` struct with the `get_data` method,
    which returns a value if some conditions are met. Otherwise, it doesn’t return
    it. The sensor is not in an erroneous state, it just doesn’t have data ready yet.
    For this, we are using `std::optional<data>` to declare that the sensor may or
    may not return the `data` struct. We used the `ret_val` bool to simulate data
    being ready at every second call of the `get_data` function.
  prefs: []
  type: TYPE_NORMAL
- en: In the main, we created the `get_data_from_main` lambda, which makes a call
    to the sensor’s `get_data`. The `std::optional<data>` return value is converted
    to a bool in the `if` statement. If it is converted to `true`, it means it holds
    data, else it holds nothing. We access the `data` type by dereferencing the `result`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ 23 introduced `std::expected<T, E>`, a template class that either holds
    an expected object of class `T` or an unexpected object of class `E`. To understand
    this better, let us go through the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have a `ble_light_bulb` struct, a BLE (Bluetooth
    Low Energy) light bulb, with the `get_config` method, which reads some config
    data over the BLE connection from the bulb. This method returns `config`, or an
    `error`. In `main`, we defined the `get_config_from_main` lambda, which calls
    `get_config` on the `ble_light_bulb` object. We use the `has_value` method on
    the expected returned object to check if it holds an expected value. We use `value`
    methods to access the expected value or the `error` method to access the `error`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the preceding example in the Renode simulator using the following
    instructions. Start Visual Studio Code, attach it to the running container, open
    `Chapter07/error_handling project` as described in [*Chapter 4*](Chapter_04.xhtml),
    and run the following commands in the Visual Studio Code terminal, or run them
    directly in the container terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we analyzed different error-handling strategies in C++. We
    went through error codes, global handlers, asserts, exceptions, `std::optional`,
    and `std::expected`. We learned the pros and cons of each and in which situations
    it makes sense to apply them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover templates in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/embeddedsystems](https://packt.link/embeddedsystems)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_code_Discord.png)'
  prefs: []
  type: TYPE_IMG
