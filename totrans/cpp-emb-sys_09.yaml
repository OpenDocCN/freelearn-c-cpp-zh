- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Strengthening Firmware – Practical C++ Error Handling Methods
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加强固件 - 实用的C++错误处理方法
- en: To ensure the proper functioning of firmware, we must handle errors from vendor-specific
    code, libraries that we are using in a project, and our own code. Error codes
    are standard error-handling mechanisms in C, and they are also used in C++. However,
    C++ provides us with other tools, most notably exceptions that are often avoided
    in embedded projects due to the large binary footprint and non-determinism. Still,
    we will discuss exceptions in C++ in this chapter to show their benefits in the
    error-handling process.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保固件正常工作，我们必须处理来自供应商特定代码、项目中使用的库以及我们自己的代码的错误。错误代码是C中的标准错误处理机制，它们也在C++中使用。然而，C++为我们提供了其他工具，最显著的是异常，由于大型二进制足迹和非确定性，这些异常通常在嵌入式项目中被避免。尽管如此，我们将在本章中讨论C++中的异常，以展示它们在错误处理过程中的好处。
- en: Besides exceptions, C++ offers more options for error handling that will also
    be discussed in this chapter. The goal of this chapter is to understand potential
    issues with error codes and see how to mitigate them in C++.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 除了异常之外，C++还提供了更多用于错误处理的选项，这些选项也将在本章中讨论。本章的目标是理解错误代码的潜在问题，并了解如何在C++中减轻这些问题。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Error codes and asserts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误代码和断言
- en: Exceptions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常
- en: '`std:: optional` and `std::expected`'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::optional`和`std::expected`'
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To get the most out of this chapter, I strongly recommend using Compiler Explorer
    ([https://godbolt.org/](https://godbolt.org/)) as you read through the examples.
    Select GCC as your compiler and target x86 architecture. This will allow you to
    see standard output (stdio) results and better observe the code’s behavior. As
    we are using modern C++ features make sure to select C++23 standard, by adding
    `-std=c++23` in compiler options box.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用本章内容，我强烈建议在阅读示例时使用Compiler Explorer（[https://godbolt.org/](https://godbolt.org/)）。选择GCC作为您的编译器，并针对x86架构。这将允许您看到标准输出（stdio）结果，并更好地观察代码的行为。由于我们使用现代C++特性，请确保选择C++23标准，通过在编译器选项框中添加`-std=c++23`。
- en: Compiler Explorer makes it easy to try out the code, tweak it, and immediately
    see how it affects the output and generated assembly. The examples are available
    at GitHub ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter07](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter07)).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Compiler Explorer使得尝试代码、调整代码并立即看到它如何影响输出和生成的汇编变得容易。示例可在GitHub上找到（[https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter07](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter07)）。
- en: Error codes and asserts
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误代码和断言
- en: '**Error codes** are a common way of reporting and handling errors in C. They
    are also still used in C++. A function that fails reports an error through enumerated
    codes that are checked by a caller and handled appropriately. Let us analyze how
    error codes work from both the caller and the callee perspective.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误代码**是C中报告和处理错误的一种常见方式。它们在C++中仍然被使用。一个失败的函数通过枚举代码报告错误，这些代码由调用者检查并适当处理。让我们从调用者和被调用者的角度分析错误代码是如何工作的。'
- en: A function that returns an error must have a list of errors that are exposed
    to callers. This list is maintained through a software life cycle, and it can
    be subject to changes. Enumerated error codes can be added, removed, or modified.
    A caller must be aware of the error codes that the callee is returning, and it
    needs to handle them. Or, if it doesn’t know how to handle an error, it should
    propagate it further within a call stack.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 返回错误的函数必须有一个暴露给调用者的错误列表。这个列表在软件生命周期中维护，并且可能会发生变化。枚举错误代码可以添加、删除或修改。调用者必须知道被调用者返回的错误代码，并且需要处理它们。或者，如果它不知道如何处理错误，它应该将错误进一步传播到调用栈中。
- en: 'Let’s observe a simple example of a function that returns an error and analyze
    the implications this has for the code using this function:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们观察一个返回错误的简单函数示例，并分析这对使用此函数的代码有何影响：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding example, the `h` function returns an error of `enum class
    error`. The `g` function calls the `h` function and executes the following steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`h`函数返回了一个`enum class error`的错误。`g`函数调用`h`函数并执行以下步骤：
- en: Checks if `h` returned an error that is different from `error::Ok`. This indicates
    that the `h` function didn’t perform its task and there is an error that should
    be handled.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`h`是否返回了一个与`error::Ok`不同的错误。这表明`h`函数没有完成其任务，并且存在应该被处理的错误。
- en: If `h` returned an error, checks whether it is `error::Error1`. In this case,
    `g` knows how to handle this error and it handles it.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`h`返回了一个错误，检查它是否是`error::Error1`。在这种情况下，`g`知道如何处理这个错误，并处理它。
- en: If `h` returned `error::Error2`, `g` is not capable of handling it, and it forwards
    it up the call stack.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`h`返回`error::Error2`，`g`无法处理它，并将它向上传递到调用栈。
- en: Returns `error::Ok` to indicate up the call stack that everything went fine.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回`error::Ok`以向上传递到调用栈，表示一切顺利。
- en: Function `g` is called by `f`, and `f` also needs to be aware of errors defined
    in `enum class error`. It should handle them or pass them up the stack.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`g`被`f`调用，而`f`也需要了解`enum class error`中定义的错误。它应该处理它们或将它们向上传递到调用栈。
- en: 'Error codes rely on design contracts. The caller must check if the callee returned
    an error, and if it did, it needs to handle it or pass it up the call stack. Now,
    we can identify several potential problems with this simple approach:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 错误代码依赖于设计契约。调用者必须检查被调用者是否返回了错误，如果是，它需要处理它或将它向上传递到调用栈。现在，我们可以识别出这种简单方法的一些潜在问题：
- en: We cannot enforce error handling by a caller. It can just discard the return
    value.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不能通过调用者强制执行错误处理。它可能只是丢弃返回值。
- en: The caller can forget to handle some of the error cases.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用者可能会忘记处理一些错误情况。
- en: The caller can forget to pass the error up the call stack.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用者可能会忘记将错误向上传递到调用栈。
- en: These are serious design flaws that put an extra burden on code development.
    There is no escape hatch in case we forget to handle an error somewhere. The program
    stays in an unknown state and this potentially leads to unwanted behavior.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是严重的设计缺陷，给代码开发增加了额外的负担。如果我们忘记处理某个错误，就没有逃逸路径。程序将处于未知状态，这可能导致不希望的行为。
- en: 'We can address the first concern using the `nodiscard` attribute. It can be
    used with a function declaration or enumeration declaration. In our case, we can
    use it with an `enum class` `error` declaration as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`nodiscard`属性来解决第一个问题。它可以与函数声明或枚举声明一起使用。在我们的情况下，我们可以用它与`enum class` `error`声明一起使用，如下所示：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When a function returning the `enum class` error is called, and the return
    value is discarded, the compiler is encouraged to raise a warning. If we call
    the `g` or `h` function from our example, GCC will raise a warning similar to
    this one:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用返回`enum class`错误的函数时，如果丢弃返回值，编译器会鼓励发出警告。如果我们从我们的示例中调用`g`或`h`函数，GCC将发出类似于以下警告：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If we set up the compiler to treat all warnings as errors, this would break
    the compilation process and force us to use the return value in code. Even though
    the `nodiscard` attribute is useful and should be used for similar use cases,
    it is not a complete solution to our problem. It will enforce usage of the return
    value, but the caller may still fail to check the error code for all possible
    cases and address it properly.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将编译器设置为将所有警告视为错误，这将破坏编译过程，并迫使我们使用代码中的返回值。尽管`nodiscard`属性很有用并且应该用于类似用例，但它并不是我们问题的完整解决方案。它将强制使用返回值，但调用者仍然可能未能检查所有可能的错误代码并正确处理它们。
- en: Almost every application has some types of errors that are unrecoverable and
    the only thing it makes sense to do is to log them, display them to a user (if
    possible), and terminate the program, as there is no sense in proceeding with
    such a program state. For these types of errors, we can use a global error handler,
    as they are too important to be left open in the wild and potentially not handled
    by a caller.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个应用程序都有一些无法恢复的错误类型，唯一合理的事情是记录它们，向用户显示（如果可能），并终止程序，因为继续这样的程序状态是没有意义的。对于这些类型的错误，我们可以使用全局错误处理器，因为它们太重要了，不能任其处于野生状态且可能不会被调用者处理。
- en: Global error handlers
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局错误处理器
- en: '**Global error handlers** can be implemented as free functions. They are used
    system-wide to address errors that are unrecoverable and when it is necessary
    to stop the execution of firmware due to the severity of an error.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**全局错误处理器**可以实施为自由函数。它们在系统范围内用于处理无法恢复的错误，以及在需要由于错误的严重性而停止固件执行时。'
- en: 'Let’s take a look at an example of firmware using an accelerometer. If there
    are any issues in I²C communication with the accelerometer, it doesn’t make sense
    to proceed further with code execution – the firmware will display a message to
    the user and terminate:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个使用加速度计的固件示例。如果与加速度计的I²C通信出现任何问题，继续代码执行是没有意义的——固件将向用户显示一条消息并终止：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding example, we have an `accelerometer` class with the `get_data`
    method, which uses the `i2c_read` function from the vendor-specific HAL in C (let
    us pretend this is the case).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们有一个`accelerometer`类，它有一个`get_data`方法，该方法使用从供应商特定的HAL中导入的C语言的`i2c_read`函数（让我们假设这是这种情况）。
- en: The `i2c_read` function returns the number of read bytes. In our example, the
    return value is stubbed to `0` so we can simulate the erroneous behavior of the
    accelerometer (or the I²C bus). In case `i2c_read` returns a number different
    from the requested number of bytes, `get_data` will call `error::handler`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`i2c_read`函数返回读取的字节数。在我们的例子中，返回值被模拟为`0`，这样我们就可以模拟加速度计（或I²C总线）的错误行为。如果`i2c_read`返回与请求的字节数不同的数字，`get_data`将调用`error::handler`。'
- en: 'We implemented an error handler using a tag-dispatching mechanism. We are overloading
    the `error::handler` function with so-called tags, or empty types. In our example,
    we have two tags, `i2c_failed` and `spi_failed`, and two overloaded error handlers.
    Tag dispatching has a couple of advantages over defining error codes with `enum`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用标签分派机制实现了一个错误处理器。我们通过所谓的标签或空类型重载了`error::handler`函数。在我们的例子中，我们有两个标签，`i2c_failed`和`spi_failed`，以及两个重载的错误处理器。与使用`enum`定义错误代码相比，标签分派有几个优点：
- en: We need to overload error handlers for every tag that is used in code. Error
    handlers are implemented individually for every error type. This adds to the readability
    of code.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要在代码中使用的每个标签上重载错误处理器。每个错误类型都单独实现错误处理器。这增加了代码的可读性。
- en: In case we make a call to an error handler that is not overloaded, the compilation
    will fail, forcing us to implement it.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们调用了一个未重载的错误处理器，编译将失败，迫使我们实现它。
- en: In our example, the error handler will print a message using the `printf` function
    and make a call to the `exit` function, effectively terminating the program. In
    real-world situations, how we handle errors depends on the application. For example,
    for a medical device, if critical operations become unsafe after an error, we
    would first attempt to recover from the error.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，错误处理器将使用`printf`函数打印一条消息，并调用`exit`函数，从而有效地终止程序。在现实世界的情况下，我们如何处理错误取决于应用程序。例如，对于医疗设备，如果错误后关键操作变得不安全，我们首先尝试从错误中恢复。
- en: If recovery failed, the system would enter a critical error state, alert medical
    personnel, and gracefully terminate the treatment operation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果恢复失败，系统将进入关键错误状态，通知医疗人员，并优雅地终止治疗操作。
- en: An error on the I²C bus or, more generally, failed communication with external
    devices must be handled appropriately through robust error-handling mechanisms.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在I²C总线上发生错误，或者更普遍地说，与外部设备通信失败，必须通过健壮的错误处理机制适当地处理。
- en: On the other hand, there are conditions that indicate programming mistakes –
    situations that should never occur if the code is correct. These include violations
    of preconditions, such as input parameters being out of expected boundaries due
    to logic errors in the code. Proceeding under such circumstances could lead to
    undefined behavior or system instability. To detect these programming errors during
    development, we use asserts.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有一些条件表明存在编程错误——这些是在代码正确的情况下不应发生的情况。这包括违反先决条件，例如由于代码中的逻辑错误，输入参数超出预期边界。在这种情况下继续执行可能导致未定义的行为或系统不稳定。为了在开发期间检测这些编程错误，我们使用断言。
- en: Asserts
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 断言
- en: Asserts are primarily used during development to detect programming mistakes
    by verifying that certain conditions hold true at specific points in the code.
    They help identify logical errors and incorrect assumptions by halting execution
    when an unexpected condition occurs. A macro assert is defined in `<cassert>`
    in the standard library. It is used to check a logical expression, and in case
    the logical expression is false, it prints diagnostic information and calls `std::abort`,
    effectively terminating the program.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 断言主要用于开发期间，通过验证代码中特定点的某些条件是否成立来检测编程错误。当出现意外条件时，它们通过停止执行来帮助识别逻辑错误和错误的假设。标准库中的`<cassert>`定义了一个宏断言。它用于检查逻辑表达式，如果逻辑表达式为假，则打印诊断信息并调用`std::abort`，从而有效地终止程序。
- en: 'To better understand asserts, and how to use them, let us take a look at the
    following code example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解断言以及如何使用它们，让我们看一下以下代码示例：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, we have defined the `option` enum class with `uint8_t`
    as an underlying type. We will use it to allow users to select an option over
    a network interface and we want to make sure that the conversion from `uint8_t`
    to the `option` enum is always correct. The `uint8_to_option` function will assert
    if the received `uint8_t` argument is not smaller than `option::Last`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们已定义了以 `uint8_t` 作为底层类型的 `option` 枚举类。我们将使用它来允许用户通过网络接口选择一个选项，并确保从
    `uint8_t` 到 `option` 枚举的转换始终正确。如果接收到的 `uint8_t` 参数不小于 `option::Last`，则 `uint8_to_option`
    函数将断言。
- en: 'In the example, we called `uint8_to_option` with argument `3`, which is not
    smaller than `option::Last`, meaning that the assert macro will print the following
    diagnostic information and make a call to `std::abort` to terminate the program:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们用参数 `3` 调用了 `uint8_to_option`，这并不小于 `option::Last`，这意味着断言宏将打印以下诊断信息，并通过调用
    `std::abort` 来终止程序：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, this is quite a lengthy debug statement. Let’s take a look at the `assert`
    macro definition:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是一个相当长的调试语句。让我们看看 `assert` 宏的定义：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We see that the expression is cast to a `bool` type and that the ternary operator
    does nothing if the expression is true, or it makes a call to the `__assert_fail`
    function if the expression is false. The `assert` macro passes the expression
    as a string literal, the filename as a string literal, the line number, and also
    a function name as a string literal. All these string literals must be stored
    in the binary, taking up precious memory.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到表达式被转换为 `bool` 类型，如果表达式为真，三元运算符不执行任何操作；如果表达式为假，它将调用 `__assert_fail` 函数。`assert`
    宏将表达式作为字符串字面量传递，将文件名作为字符串字面量传递，传递行号，还将函数名作为字符串字面量传递。所有这些字符串字面量都必须存储在二进制文件中，占用宝贵的内存。
- en: 'Asserts can be disabled by defining the `NDEBUG` macro before including `<cassert>`
    as in the following lines:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 断言可以通过在包含 `<cassert>` 之前定义 `NDEBUG` 宏来禁用，如下所示：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can also define `NDEBUG` using the build system. The `assert` macro will
    do nothing if `NDEBUG` is defined before `<cassert>` is included. This option
    is left to be used in case we want to disable asserts, as they are most commonly
    used in debug builds, and disabled in production builds. They should be disabled
    before the safety-critical software validation.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用构建系统来定义 `NDEBUG`。如果 `<cassert>` 包含之前定义了 `NDEBUG`，则 `assert` 宏将不执行任何操作。这个选项留给我们使用，以防我们想要禁用断言，因为它们最常用于调试构建，而在生产构建中被禁用。它们应该在安全关键软件验证之前被禁用。
- en: The `assert` macro, as implemented in the standard library, is not suitable
    for embedded systems as it includes the filename, function name, and `assert`
    expression as string literals, which end up stored in the flash of the embedded
    target. Moreover, asserts are mostly intended to be used during debugging, and
    they are often disabled in production builds. Still, there is a benefit of asserts
    enabled in production builds, as they can provide valuable insights for postmortem
    debugging if they are implemented to log data when the expression is evaluated
    as `false`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中实现的 `assert` 宏不适合嵌入式系统，因为它包含了文件名、函数名和 `assert` 表达式作为字符串字面量，最终存储在嵌入式目标的闪存中。此外，断言主要用于调试期间，它们通常在生产构建中被禁用。尽管如此，在生产构建中启用断言仍然有一些好处，因为如果它们在表达式评估为
    `false` 时记录数据，它们可以提供宝贵的调试信息。
- en: 'We will examine an alternative approach to logging information using asserts.
    As we have already concluded, the default assert macro implementation is not well
    suited for embedded targets, even though it contains useful information for debugging:
    filename, function name, and line number. Instead of a lengthy string describing
    an exact location of the assert macro line in our code, we can simply log a program
    counter and use the map file and `addr2line` tool to convert the address to the
    exact line. We can see a simple macro definition and a helper function to implement
    this in the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检查使用断言记录信息的替代方法。正如我们已经得出的结论，默认的断言宏实现不适合嵌入式目标，尽管它包含了对调试有用的信息：文件名、函数名和行号。我们不需要一个描述断言宏行在代码中确切位置的冗长字符串，我们可以简单地记录程序计数器，并使用映射文件和
    `addr2line` 工具将地址转换为确切的行。我们可以在以下代码中看到一个简单的宏定义和一个辅助函数来实现这一点：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have defined a macro named `light_assert` that, instead of `__assert_failed`,
    calling `log_pc_and_halt`. It is passing the return value from `hal::get_pc` as
    an argument to `log_pc_and_halt`. To see this code in action, you can take a look
    at the example in the `Chapter07/error_handling` project.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`light_assert`的宏，它不是调用`__assert_failed`，而是调用`log_pc_and_halt`。它将`hal::get_pc`的返回值作为参数传递给`log_pc_and_halt`。要查看此代码的实际效果，你可以查看`Chapter07/error_handling`项目中的示例。
- en: 'The project for this chapter is configured so that you can configure it to
    use different main C++ files and configure which one is going to be used with
    CMake. Let us start our Docker container using the following commands:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目配置允许你配置它使用不同的主C++文件，并使用CMake配置将要使用哪个文件。让我们使用以下命令启动我们的Docker容器：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This should get us in the Docker terminal. Run `ls –l` to make sure that the
    `Cpp-in-Embedded-Systems` repo is cloned. If not, clone it using the following
    command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该让我们进入Docker终端。运行`ls –l`以确保`Cpp-in-Embedded-Systems`仓库已克隆。如果没有，使用以下命令克隆它：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Start Visual Studio Code, attach it to the running container, and open `Chapter07/error_handling
    project` as described in [*Chapter 4*](Chapter_04.xhtml) and run the following
    commands in the Visual Studio Code terminal, or run them directly in the container
    terminal:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Visual Studio Code，将其附加到正在运行的容器，并按照[*第4章*](Chapter_04.xhtml)中所述打开`Chapter07/error_handling项目`，然后在Visual
    Studio Code终端中运行以下命令，或者直接在容器终端中运行它们：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding commands will build the firmware using the `app/src/main_assert.cpp`
    file and run it in Renode simulator. You should see similar output to this in
    the terminal:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将使用`app/src/main_assert.cpp`文件构建固件，并在Renode模拟器中运行它。你应该在终端看到类似的输出：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As we can see, the assert evaluated expression to false and printed out the
    `0x08000F74` program counter value. We can convert this value to the line from
    a source file using the following command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，断言评估表达式为假，并打印出`0x08000F74`程序计数器值。我们可以使用以下命令将此值转换为源文件的行：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will result in the following output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, we are able to get the exact line of the source of the assert
    using this approach and by logging just 4 bytes of data (address). In this implementation,
    `log_pc_and_halt` just print the address. In production implementations, we can
    store the address in non-volatile memory and use it for postmortem debugging.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们能够通过这种方法获取断言源的确切行，并且只需记录4字节的数据（地址）。在这个实现中，`log_pc_and_halt`只是打印出地址。在生产实现中，我们可以将地址存储在非易失性存储器中，并用于事后调试。
- en: The `hal::get_pc()` function is declared with an `inline` specifier. We use
    `inline` as a hint to the compiler to insert instructions from a function directly
    to a call site, that is, not to make a function call. The compiler doesn’t necessarily
    need to comply with our intentions, and that can be observed by building this
    example using the `O0` optimization level.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`hal::get_pc()`函数使用`inline`指定符声明。我们使用`inline`作为对编译器的提示，将函数的指令直接插入到调用点，即不进行函数调用。编译器不一定需要遵守我们的意图，这可以通过使用`O0`优化级别构建此示例来观察到。'
- en: Exercise for you!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 练习题！
- en: As an exercise, edit `CMAKE_C_FLAGS_DEBUG` and `CMAKE_CXX_FLAGS_DEBUG` in `CMakeLists.txt`,
    and instead of `Og`, use `O0`. Build and run the program and run the `addr2line`
    utility on the output. To mitigate this concern, you can define a macro to be
    used instead of the `hal::get_pc()` function.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，编辑`CMakeLists.txt`中的`CMAKE_C_FLAGS_DEBUG`和`CMAKE_CXX_FLAGS_DEBUG`，并将`Og`替换为`O0`。构建并运行程序，然后在输出上运行`addr2line`实用程序。为了减轻这一担忧，你可以定义一个宏来替代`hal::get_pc()`函数。
- en: We use asserts to catch programming errors – situations that should never occur
    if the code is correct. They are often employed to validate internal assumptions
    and invariants within critical functions. The primary purpose of asserts is for
    debugging; they help developers find and fix bugs during the development phase.
    However, as we’ve seen, customized asserts can also provide valuable insights
    into production builds for postmortem analysis. While asserts are useful for detecting
    programming mistakes during development, they are not a substitute for proper
    error handling in production code. Error codes can be cumbersome because they
    require manual propagation of errors up the call stack. C++ offers exceptions
    as a solution to these problems, providing a structured way to handle errors without
    cluttering the code with error-checking logic.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用断言来捕获编程错误——如果代码正确，这些情况永远不会发生。它们通常用于验证关键函数内部的内部假设和不变性。断言的主要目的是用于调试；它们帮助开发者在开发阶段找到并修复错误。然而，正如我们所看到的，定制的断言也可以在生产构建中提供宝贵的洞察力，用于事后分析。虽然断言在开发过程中用于检测编程错误很有用，但它们不能替代生产代码中的正确错误处理。错误代码可能很繁琐，因为它们需要手动将错误传播到调用栈。C++提供了异常作为这些问题的解决方案，提供了一种结构化的方式来处理错误，而不会在代码中添加错误检查逻辑。
- en: Next, we will go over C++ exceptions to better understand the benefits they
    offer from the error-handling aspect.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入了解 C++ 异常，以更好地理解它们从错误处理角度提供的优势。
- en: Exceptions
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常
- en: 'Exceptions in C++ are error-handling mechanisms that are based on the principle
    of throwing and catching objects of an arbitrary type. All exceptions that are
    thrown from the standard library derive from the `std::exception` class defined
    in the `<exception>` header. We put code that may throw an exception in the `try`
    block, and we define the type of exception we want to catch in the `catch` clause,
    as shown in the following example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的异常是基于抛出和捕获任意类型对象的原理的错误处理机制。从标准库中抛出的所有异常都源自于在 `<exception>` 头文件中定义的 `std::exception`
    类。我们将可能抛出异常的代码放在 `try` 块中，并在 `catch` 子句中定义我们想要捕获的异常类型，如下面的示例所示：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding example, we have defined `std::array arr`, an array of integers
    with four members. In the `try` block, we are trying to access an element with
    index `5`, which is clearly out of the defined range, and the `at` method will
    throw the `std::out_of_range` exception. In order to run this example, go to the
    `Chapter07/error_handling` folder, make sure that the `build` folder is deleted,
    and run the following commands:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们定义了 `std::array arr`，一个包含四个成员的整数数组。在 `try` 块中，我们尝试访问索引为 `5` 的元素，这显然超出了定义的范围，`at`
    方法将抛出 `std::out_of_range` 异常。为了运行此示例，请转到 `Chapter07/error_handling` 文件夹，确保已删除
    `build` 文件夹，并运行以下命令：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You should see `Array out of range!` printed in the terminal.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在终端中看到打印出 `Array out of range!`。
- en: Now, while building the example, you may have noticed that the size of the binary
    is a whooping 88 KB. What happened?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在构建示例时，你可能已经注意到二进制文件的大小达到了惊人的 88 KB。发生了什么？
- en: In order to enable exceptions, besides using the `-fexceptions` compiler flag,
    we also had to disable the nano specs that we used in previous examples. Nano
    specs define the usage of the C standard `newlib-nano` library and size-optimized
    `libstdc++` and `libsupc++` libraries. These are built without exception support
    and if we use them, any attempt at throwing exceptions will result in `std::abort`
    being called instead. By disabling nano specs, we are using an unoptimized C++
    standard library, which results in the 88 KB binary size. A size-optimized standard
    C++ library can be built from sources with enabled exceptions, which would help
    reduce the binary footprint.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用异常，除了使用 `-fexceptions` 编译器标志外，我们还必须禁用之前示例中使用的 nano 规范。Nano 规范定义了 C 标准库 `newlib-nano`
    的使用以及大小优化的 `libstdc++` 和 `libsupc++` 库。这些库在没有异常支持的情况下构建，如果我们使用它们，任何尝试抛出异常都将导致调用
    `std::abort`。通过禁用 nano 规范，我们使用了一个未优化的 C++ 标准库，这导致了 88 KB 的二进制文件大小。可以从带有异常支持的源构建大小优化的标准
    C++ 库，这将有助于减少二进制文件的大小。
- en: 'If an exception is not caught, `std::terminate_handler` will be called. We
    can replace the default handler using the `std::set_terminate` function as in
    the following example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有捕获到异常，将调用 `std::terminate_handler`。我们可以使用 `std::set_terminate` 函数替换默认的处理程序，如下面的示例所示：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding example, we provided a lambda as a terminate handler. As an
    exercise, try to access the array from the previous example with an index that
    is out of range, but out of a `try` block. This should trigger the terminate handler
    and make a call to the lambda we passed to the `std::set_terminate` function.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，我们提供了一个lambda作为终止处理程序。作为一个练习，尝试使用超出范围的索引访问前一个示例中的数组，但不在`try`块中。这应该会触发终止处理程序，并调用我们传递给`std::set_terminate`函数的lambda。
- en: 'Exceptions are propagated up the call stack. Let us go through the following
    example to demonstrate exception propagation:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 异常沿着调用栈向上传播。让我们通过以下示例来演示异常传播：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding example is based on a ring buffer from previous chapters that
    uses `std::array` as an underlying container. In the `push` method, it doesn’t
    check the write index, meaning that the array’s `at` method will throw an exception
    if we call the `push` method more than `N` times. An exception is thrown in the
    `push` method, where there is no `try-catch` block, and it gets caught only in
    the `main` function in the `catch` block.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例基于前几章中使用的环形缓冲区，该缓冲区使用`std::array`作为底层容器。在`push`方法中，它没有检查写入索引，这意味着如果我们调用`push`方法超过`N`次，数组的`at`方法将抛出异常。在`push`方法中抛出了异常，但没有`try-catch`块，它只在`main`函数的`catch`块中被捕获。
- en: 'You can run the preceding example in the Renode simulator using the following
    instructions. Start Visual Studio Code, attach it to the running container, open
    `Chapter07/error_handling project` as described in [*Chapter 4*](Chapter_04.xhtml),
    and run the following commands in the Visual Studio Code terminal, or run them
    directly in the container terminal:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下说明在Renode模拟器中运行前面的示例。启动Visual Studio Code，将其附加到正在运行的容器，按照[*第4章*](Chapter_04.xhtml)中所述打开`Chapter07/error_handling项目`，然后在Visual
    Studio Code终端中运行以下命令，或者在容器终端中直接运行它们：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Exception propagation is useful for the type of errors that we don’t want to
    propagate between the software layers manually using error codes. However, the
    problem with exceptions is that they are not visible from function declarations
    as is the case with error codes. We need to rely on good documentation to know
    which function throws an error and where those errors are handled.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 异常传播对于我们不希望手动使用错误代码在软件层之间传播的错误类型非常有用。然而，异常的问题在于它们与错误代码不同，在函数声明中是不可见的。我们需要依赖于良好的文档来了解哪个函数抛出错误以及错误在哪里被处理。
- en: There is a saying that exceptions are used for exceptional errors that are very
    rare. But what are exceptional errors? That depends on the library, application,
    and use case. It is hard to generalize. A failed read to the accelerometer may
    be a recoverable error that is solved by resetting it. We can throw an exception
    on a failed I²C bus communication, and the upper layer that catches this error
    may decide to try resetting the accelerometer.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种说法是，异常用于非常罕见的异常错误。但什么是异常错误？这取决于库、应用程序和用例。很难概括。加速度计的读取失败可能是一个可恢复的错误，可以通过重置它来解决。我们可以在失败的I²C总线通信上抛出异常，并且捕获这个错误的上层可能决定尝试重置加速度计。
- en: Failing to control boost voltage regulator output by DAC may also be recoverable,
    but we may want to terminate the program as we are implementing a medical device
    and that may be the best action possible to prevent any damage to a user. In this
    case, we want to react as fast as possible and exception propagation and stack
    unwinding are probably not desirable so we will rely on a global handler or asserts
    instead.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过DAC未能控制升压稳压器输出可能也是可恢复的，但因为我们正在实施医疗设备，所以我们可能希望终止程序，这可能是防止对用户造成任何损害的最佳行动。在这种情况下，我们希望尽可能快地做出反应，异常传播和堆栈展开可能不是期望的，因此我们将依赖于全局处理程序或断言。
- en: Exceptions come with a price, both in flash and RAM memory consumption, and
    the execution time can’t always be guaranteed, which is a problem if we are working
    with hard real-time systems. But they also solve the problem of error propagation
    and enforce error handling. If there is not a `catch` clause for a specific type,
    `std::terminate_handler` will be called, and the program will not continue with
    the execution.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 异常伴随着代价，包括闪存和RAM内存消耗，并且执行时间不能总是得到保证，如果我们正在处理硬实时系统，这会成为一个问题。但它们也解决了错误传播的问题，并强制执行错误处理。如果没有为特定类型提供`catch`子句，`std::terminate_handler`将被调用，程序将不会继续执行。
- en: Error codes and exceptions can co-exist, and they often do. Embedded C++ projects
    often use C libraries, or legacy C++ code, which often uses error codes. We can
    benefit from exceptions by using them for very rare errors, adding additional
    robustness to our firmware. Still, the decision of whether to use them is influenced
    by available memory resources and the type of project we are working on.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 错误代码和异常可以共存，并且通常如此。嵌入式 C++ 项目通常使用 C 库或遗留的 C++ 代码，这些代码通常使用错误代码。我们可以通过将它们用于非常罕见的错误来从异常中受益，这为我们的固件增加了额外的鲁棒性。然而，是否使用它们的决定受到可用内存资源和我们所从事的项目类型的影
- en: Next, we will cover the C++ `std::optional` and `std::expected` template classes,
    which are used as return types from functions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍 C++ 的 `std::optional` 和 `std::expected` 模板类，这些类用作函数的返回类型。
- en: 'std:: optional and std::expected'
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`std::optional` 和 `std::expected`'
- en: 'C++17 introduced `std::optional`, a template class that either has a value
    or has nothing. This is useful for situations where a function may or may not
    return a value. To better understand it, let’s go through the following example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: C++17 引入了 `std::optional`，这是一个模板类，它要么有一个值，要么什么也没有。这在函数可能返回或不返回值的情况下非常有用。为了更好地理解它，让我们通过以下示例来了解：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding example, we have a `sensor` struct with the `get_data` method,
    which returns a value if some conditions are met. Otherwise, it doesn’t return
    it. The sensor is not in an erroneous state, it just doesn’t have data ready yet.
    For this, we are using `std::optional<data>` to declare that the sensor may or
    may not return the `data` struct. We used the `ret_val` bool to simulate data
    being ready at every second call of the `get_data` function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们有一个具有 `get_data` 方法的 `sensor` 结构体，该方法在某些条件满足时返回一个值。否则，它不返回值。传感器不在错误状态，它只是还没有准备好数据。为此，我们使用
    `std::optional<data>` 来声明传感器可能返回或不返回 `data` 结构体。我们使用 `ret_val` 布尔值来模拟 `get_data`
    函数每第二次调用时数据就绪。
- en: In the main, we created the `get_data_from_main` lambda, which makes a call
    to the sensor’s `get_data`. The `std::optional<data>` return value is converted
    to a bool in the `if` statement. If it is converted to `true`, it means it holds
    data, else it holds nothing. We access the `data` type by dereferencing the `result`
    object.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们创建了 `get_data_from_main` lambda 表达式，它调用传感器的 `get_data` 方法。`std::optional<data>`
    返回值在 `if` 语句中被转换为布尔值。如果它被转换为 `true`，则表示它包含数据，否则它不包含任何数据。我们通过解引用 `result` 对象来访问
    `data` 类型。
- en: 'C++ 23 introduced `std::expected<T, E>`, a template class that either holds
    an expected object of class `T` or an unexpected object of class `E`. To understand
    this better, let us go through the following example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 23 引入了 `std::expected<T, E>`，这是一个模板类，它要么包含类 `T` 的预期对象，要么包含类 `E` 的意外对象。为了更好地理解这一点，让我们通过以下示例来了解：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding example, we have a `ble_light_bulb` struct, a BLE (Bluetooth
    Low Energy) light bulb, with the `get_config` method, which reads some config
    data over the BLE connection from the bulb. This method returns `config`, or an
    `error`. In `main`, we defined the `get_config_from_main` lambda, which calls
    `get_config` on the `ble_light_bulb` object. We use the `has_value` method on
    the expected returned object to check if it holds an expected value. We use `value`
    methods to access the expected value or the `error` method to access the `error`
    object.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们有一个 `ble_light_bulb` 结构体，一个带有 `get_config` 方法的 BLE（蓝牙低功耗）灯泡，该方法通过
    BLE 连接从灯泡读取一些配置数据。此方法返回 `config` 或 `error`。在 `main` 函数中，我们定义了 `get_config_from_main`
    lambda 表达式，它调用 `ble_light_bulb` 对象上的 `get_config` 方法。我们使用预期返回对象上的 `has_value`
    方法来检查它是否包含预期的值。我们使用 `value` 方法来访问预期的值或使用 `error` 方法来访问 `error` 对象。
- en: 'You can run the preceding example in the Renode simulator using the following
    instructions. Start Visual Studio Code, attach it to the running container, open
    `Chapter07/error_handling project` as described in [*Chapter 4*](Chapter_04.xhtml),
    and run the following commands in the Visual Studio Code terminal, or run them
    directly in the container terminal:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下说明在 Renode 模拟器中运行前面的示例。启动 Visual Studio Code，将其附加到正在运行的容器，按照 [*第 4 章*](Chapter_04.xhtml)
    中所述打开 `Chapter07/error_handling project`，然后在 Visual Studio Code 终端中运行以下命令，或者直接在容器终端中运行它们：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Summary
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we analyzed different error-handling strategies in C++. We
    went through error codes, global handlers, asserts, exceptions, `std::optional`,
    and `std::expected`. We learned the pros and cons of each and in which situations
    it makes sense to apply them.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们分析了 C++ 中的不同错误处理策略。我们讨论了错误代码、全局处理程序、断言、异常、`std::optional` 和 `std::expected`。我们学习了每种方法的优缺点，以及在哪些情况下应用它们是有意义的。
- en: In the next chapter, we will cover templates in more detail.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更详细地介绍模板。
- en: Join our community on Discord
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的社区Discord空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/embeddedsystems](https://packt.link/embeddedsystems)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[嵌入式系统](https://packt.link/embeddedsystems)'
- en: '![](img/QR_code_Discord.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![Discord二维码](img/QR_code_Discord.png)'
