["```cpp\ntemplate <typename T>\n```", "```cpp\nstruct processor;          // [1] template declaration\n```", "```cpp\nvoid handle(double value)  // [2] handle(double) definition\n```", "```cpp\n{\n```", "```cpp\n   std::cout << \"processing a double: \" << value << '\\n';\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct parser              // [3] template definition\n```", "```cpp\n{\n```", "```cpp\n   void parse()\n```", "```cpp\n   {\n```", "```cpp\n      handle(42);          // [4] non-dependent name\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\nvoid handle(int value)     // [5] handle(int) definition\n```", "```cpp\n{\n```", "```cpp\n   std::cout << \"processing an int: \" << value << '\\n';\n```", "```cpp\n}\n```", "```cpp\nint main()\n```", "```cpp\n{\n```", "```cpp\n   parser<int> p;          // [6] template instantiation\n```", "```cpp\n   p.parse();\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct handler          // [1] template definition\n```", "```cpp\n{\n```", "```cpp\n   void handle(T value)\n```", "```cpp\n   {\n```", "```cpp\n      std::cout << \"handler<T>: \" << value << '\\n';\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct parser           // [2] template definition\n```", "```cpp\n{\n```", "```cpp\n   void parse(T arg)\n```", "```cpp\n   {\n```", "```cpp\n      arg.handle(42);   // [3] dependent name\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\ntemplate <>\n```", "```cpp\nstruct handler<int>     // [4] template specialization\n```", "```cpp\n{\n```", "```cpp\n   void handle(int value)\n```", "```cpp\n   {\n```", "```cpp\n      std::cout << \"handler<int>: \" << value << '\\n';\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\nint main()\n```", "```cpp\n{\n```", "```cpp\n   handler<int> h;         // [5] template instantiation\n```", "```cpp\n   parser<handler<int>> p; // [6] template instantiation\n```", "```cpp\n   p.parse(h);\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct base_parser\n```", "```cpp\n{\n```", "```cpp\n   void init()\n```", "```cpp\n   {\n```", "```cpp\n      std::cout << \"init\\n\";\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct parser : base_parser<T>\n```", "```cpp\n{\n```", "```cpp\n   void parse()\n```", "```cpp\n   {\n```", "```cpp\n      init();        // error: identifier not found\n```", "```cpp\n      std::cout << \"parse\\n\";\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\nint main()\n```", "```cpp\n{\n```", "```cpp\n   parser<int> p;\n```", "```cpp\n   p.parse();\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct parser : base_parser<T>\n```", "```cpp\n{\n```", "```cpp\n   void parse()\n```", "```cpp\n   {\n```", "```cpp\n      this->init();        // OK\n```", "```cpp\n      std::cout << \"parse\\n\";\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\ntemplate <>\n```", "```cpp\nstruct base_parser<int>\n```", "```cpp\n{\n```", "```cpp\n   void init()\n```", "```cpp\n   {\n```", "```cpp\n      std::cout << \"specialized init\\n\";\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\nint main()\n```", "```cpp\n{\n```", "```cpp\n   parser<int> p1;\n```", "```cpp\n   p1.parse();\n```", "```cpp\n   parser<double> p2;\n```", "```cpp\n   p2.parse();\n```", "```cpp\n}\n```", "```cpp\nspecialized init\n```", "```cpp\nparse\n```", "```cpp\ninit\n```", "```cpp\nparse\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct base_parser\n```", "```cpp\n{\n```", "```cpp\n   using value_type = T;\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct parser : base_parser<T>\n```", "```cpp\n{\n```", "```cpp\n   void parse()\n```", "```cpp\n   {\n```", "```cpp\n      value_type v{};                       // [1] error\n```", "```cpp\n      // or\n```", "```cpp\n      base_parser<T>::value_type v{};       // [2] error\n```", "```cpp\n      std::cout << \"parse\\n\";\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct parser : base_parser<T>\n```", "```cpp\n{\n```", "```cpp\n   void parse()\n```", "```cpp\n   {\n```", "```cpp\n      typename base_parser<T>::value_type v{}; // [3] OK\n```", "```cpp\n      std::cout << \"parse\\n\";\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\nstruct dictionary_traits\n```", "```cpp\n{\n```", "```cpp\n    using key_type = int;\n```", "```cpp\n    using map_type = std::map<key_type, std::string>;\n```", "```cpp\n    static constexpr int identity = 1;\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct dictionary : T::map_type      // [1]\n```", "```cpp\n{\n```", "```cpp\n    int start_key { T::identity };   // [2]\n```", "```cpp\n    typename T::key_type next_key;   // [3]\n```", "```cpp\n};\n```", "```cpp\nint main()\n```", "```cpp\n{\n```", "```cpp\n    dictionary<dictionary_traits> d;\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct dictionary : T::map_type\n```", "```cpp\n{\n```", "```cpp\n   int start_key{ T::identity };\n```", "```cpp\n   T::key_type next_key;                              // [1]\n```", "```cpp\n   using value_type = T::map_type::mapped_type;       // [2]\n```", "```cpp\n   void add(T::key_type const&, value_type const&) {} // [3]\n```", "```cpp\n};.\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct base_parser\n```", "```cpp\n{\n```", "```cpp\n   template <typename U>\n```", "```cpp\n   void init()\n```", "```cpp\n   {\n```", "```cpp\n      std::cout << \"init\\n\";\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct parser : base_parser<T>\n```", "```cpp\n{\n```", "```cpp\n   void parse()\n```", "```cpp\n   {\n```", "```cpp\n      // base_parser<T>::init<int>();        // [1] error\n```", "```cpp\n      base_parser<T>::template init<int>();  // [2] OK\n```", "```cpp\n      std::cout << \"parse\\n\";\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct base_parser\n```", "```cpp\n{\n```", "```cpp\n   template <typename U>\n```", "```cpp\n   struct token {};\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct parser : base_parser<T>\n```", "```cpp\n{\n```", "```cpp\n   void parse()\n```", "```cpp\n   {\n```", "```cpp\n      using token_type = \n```", "```cpp\n         base_parser<T>::template token<int>; // [1]\n```", "```cpp\n      token_type t1{};\n```", "```cpp\n      typename base_parser<T>::template token<int> t2{}; \n```", "```cpp\n                                                     // [2]\n```", "```cpp\n      std::cout << \"parse\\n\";\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct parser\n```", "```cpp\n{\n```", "```cpp\n   parser* p1;          // parser is the CI\n```", "```cpp\n   parser<T>* p2;       // parser<T> is the CI\n```", "```cpp\n   ::parser<T>* p3;     // ::parser<T> is the CI\n```", "```cpp\n   parser<T*> p4;       // parser<T*> is not the CI\n```", "```cpp\n   struct token\n```", "```cpp\n   {\n```", "```cpp\n      token* t1;                  // token is the CI\n```", "```cpp\n      parser<T>::token* t2;       // parser<T>::token is the CI\n```", "```cpp\n      typename parser<T*>::token* t3; \n```", "```cpp\n                         // parser<T*>::token is not the CI\n```", "```cpp\n   };\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct parser<T*>\n```", "```cpp\n{\n```", "```cpp\n   parser<T*>* p1;   // parser<T*> is the CI\n```", "```cpp\n   parser<T>*  p2;   // parser<T> is not the CI\n```", "```cpp\n};\n```", "```cpp\nconstexpr unsigned int factorial(unsigned int const n)\n```", "```cpp\n{\n```", "```cpp\n   return n > 1 ? n * factorial(n - 1) : 1;\n```", "```cpp\n}\n```", "```cpp\ntemplate <unsigned int N>\n```", "```cpp\nstruct factorial\n```", "```cpp\n{\n```", "```cpp\n   static constexpr unsigned int value = \n```", "```cpp\n      N * factorial<N - 1>::value;\n```", "```cpp\n};\n```", "```cpp\ntemplate <>\n```", "```cpp\nstruct factorial<0>\n```", "```cpp\n{\n```", "```cpp\n   static constexpr unsigned int value = 1;\n```", "```cpp\n};\n```", "```cpp\nint main()\n```", "```cpp\n{\n```", "```cpp\n   std::cout << factorial<4>::value << '\\n';\n```", "```cpp\n}\n```", "```cpp\ntemplate<>\n```", "```cpp\nstruct factorial<4>\n```", "```cpp\n{\n```", "```cpp\n   inline static constexpr const unsigned int value = \n```", "```cpp\n      4U * factorial<3>::value;\n```", "```cpp\n};\n```", "```cpp\ntemplate<>\n```", "```cpp\nstruct factorial<3>\n```", "```cpp\n{\n```", "```cpp\n   inline static constexpr const unsigned int value = \n```", "```cpp\n      3U * factorial<2>::value;\n```", "```cpp\n};\n```", "```cpp\ntemplate<>\n```", "```cpp\nstruct factorial<2>\n```", "```cpp\n{\n```", "```cpp\n   inline static constexpr const unsigned int value = \n```", "```cpp\n      2U * factorial<1>::value;\n```", "```cpp\n};\n```", "```cpp\ntemplate<>\n```", "```cpp\nstruct factorial<1>\n```", "```cpp\n{\n```", "```cpp\n   inline static constexpr const unsigned int value = \n```", "```cpp\n      1U * factorial<0>::value;\n```", "```cpp\n};\n```", "```cpp\ntemplate<>\n```", "```cpp\nstruct factorial<0>\n```", "```cpp\n{\n```", "```cpp\n   inline static constexpr const unsigned int value = 1;\n```", "```cpp\n};\n```", "```cpp\ntemplate <unsigned int N>\n```", "```cpp\ninline constexpr unsigned int factorial = N * factorial<N - 1>;\n```", "```cpp\ntemplate <>\n```", "```cpp\ninline constexpr unsigned int factorial<0> = 1;\n```", "```cpp\nint main()\n```", "```cpp\n{\n```", "```cpp\n   std::cout << factorial<4> << '\\n';\n```", "```cpp\n}\n```", "```cpp\ntemplate <unsigned int n>\n```", "```cpp\nconstexpr unsigned int factorial()\n```", "```cpp\n{\n```", "```cpp\n   return n * factorial<n - 1>();\n```", "```cpp\n}\n```", "```cpp\ntemplate<> constexpr unsigned int factorial<1>() { \n```", "```cpp\n                                               return 1; }\n```", "```cpp\ntemplate<> constexpr unsigned int factorial<0>() { \n```", "```cpp\n                                               return 1; }\n```", "```cpp\nint main()\n```", "```cpp\n{\n```", "```cpp\n   std::cout << factorial<4>() << '\\n';\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct wrapper {};\n```", "```cpp\ntemplate <int N>\n```", "```cpp\nstruct manyfold_wrapper\n```", "```cpp\n{\n```", "```cpp\n   using value_type = \n```", "```cpp\n      wrapper<\n```", "```cpp\n             typename manyfold_wrapper<N - 1>::value_type>;\n```", "```cpp\n};\n```", "```cpp\ntemplate <>\n```", "```cpp\nstruct manyfold_wrapper<0>\n```", "```cpp\n{\n```", "```cpp\n   using value_type = unsigned int;\n```", "```cpp\n};\n```", "```cpp\nint main()\n```", "```cpp\n{\n```", "```cpp\n   std::cout << \n```", "```cpp\n    typeid(manyfold_wrapper<0>::value_type).name() << '\\n';\n```", "```cpp\n   std::cout << \n```", "```cpp\n    typeid(manyfold_wrapper<1>::value_type).name() << '\\n';\n```", "```cpp\n   std::cout << \n```", "```cpp\n    typeid(manyfold_wrapper<2>::value_type).name() << '\\n';\n```", "```cpp\n   std::cout << \n```", "```cpp\n    typeid(manyfold_wrapper<3>::value_type).name() << '\\n';\n```", "```cpp\n}\n```", "```cpp\nunsigned int\n```", "```cpp\nstruct wrapper<unsigned int>\n```", "```cpp\nstruct wrapper<struct wrapper<unsigned int> >\n```", "```cpp\nstruct wrapper<struct wrapper<struct wrapper<unsigned int> > >\n```", "```cpp\nfatal error C1202: recursive type or function dependency context too complex\n```", "```cpp\nfatal error: template instantiation depth exceeds maximum of 900 (use '-ftemplate-depth=' to increase the maximum)\n```", "```cpp\nfatal error: recursive template instantiation exceeded maximum depth of 1024\nuse -ftemplate-depth=N to increase recursive template instantiation depth\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nvoid process(T arg)\n```", "```cpp\n{\n```", "```cpp\n   std::cout << \"process \" << arg << '\\n';\n```", "```cpp\n}\n```", "```cpp\nint main()\n```", "```cpp\n{\n```", "```cpp\n   process(42);          // [1] T is int\n```", "```cpp\n   process<int>(42);     // [2] T is int, redundant\n```", "```cpp\n   process<short>(42);   // [3] T is short\n```", "```cpp\n}\n```", "```cpp\n    struct account_t\n    {\n       int number;\n    };\n    template <typename T>\n    void process01(T) { std::cout << \"T\\n\"; }\n    template <typename T>\n    void process02(T const) { std::cout << \"T const\\n\"; }\n    template <typename T>\n    void process03(T volatile) { std::cout << \"T volatile\\n\"; }\n    int main()\n    {\n       account_t ac{ 42 };\n       process01(ac);  // T\n       process02(ac);  // T const\n       process03(ac);  // T volatile\n    }\n    ```", "```cpp\n    template <typename T>\n    void process04(T*) { std::cout << \"T*\\n\"; }\n    template <typename T>\n    void process04(T&) { std::cout << \"T&\\n\"; }\n    template <typename T>\n    void process05(T&&) { std::cout << \"T&&\\n\"; }\n    int main()\n    {\n       account_t ac{ 42 };\n       process04(&ac);  // T*\n       process04(ac);  // T&\n       process05(ac);  // T&&\n    }\n    ```", "```cpp\n    template <typename T>\n    void process06(T[5]) { std::cout << \"T[5]\\n\"; }\n    template <size_t n>\n    void process07(account_t[5][n]) \n    { std::cout << \"C[5][n]\\n\"; }\n    int main()\n    {\n       account_t arr1[5] {};\n       process06(arr1);  // T[5]\n       account_t ac{ 42 };\n       process06(&ac);   // T[5]\n       account_t arr2[5][3];\n       process07(arr2);  // C[5][n]\n    }\n    ```", "```cpp\n    template<typename T>\n    void process08(T(*)()) { std::cout << \"T (*)()\\n\"; }\n    template<typename T>\n    void process08(account_t(*)(T)) \n    { std::cout << \"C (*) (T)\\n\"; }\n    template<typename T, typename U>\n    void process08(T(*)(U)) { std::cout << \"T (*)(U)\\n\"; }\n    int main()\n    {\n       account_t (*pf1)() = nullptr;\n       account_t (*pf2)(int) = nullptr;\n       double    (*pf3)(int) = nullptr;\n       process08(pf1);    // T (*)()\n       process08(pf2);    // C (*)(T)\n       process08(pf3);    // T (*)(U)\n    }\n    ```", "```cpp\n    struct account_t\n    {\n       int number;\n       int get_number() { return number; }\n       int from_string(std::string text) { \n          return std::atoi(text.c_str()); }\n    };\n    struct transaction_t\n    {\n       double amount;\n    };\n    struct balance_report_t {};\n    struct balance_t\n    {\n       account_t account;\n       double    amount;\n       account_t get_account()  { return account; }\n       int get_account_number() { return account.number; }\n       bool can_withdraw(double const value)  \n          {return amount >= value; };\n       transaction_t withdraw(double const value) { \n          amount -= value; return transaction_t{ -value }; }\n       balance_report_t make_report(int const type) \n       {return {}; }\n    };\n    template<typename T>\n    void process09(T(account_t::*)())\n    { std::cout << \"T (C::*)()\\n\"; }\n    template<typename T, typename U>\n    void process09(T(account_t::*)(U))\n    { std::cout << \"T (C::*)(U)\\n\"; }\n    template<typename T, typename U>\n    void process09(T(U::*)())\n    { std::cout << \"T (U::*)()\\n\"; }\n    template<typename T, typename U, typename V>\n    void process09(T(U::*)(V))\n    { std::cout << \"T (U::*)(V)\\n\"; }\n    template<typename T>\n    void process09(account_t(T::*)())\n    { std::cout << \"C (T::*)()\\n\"; }\n    template<typename T, typename U>\n    void process09(transaction_t(T::*)(U))\n    { std::cout << \"C (T::*)(U)\\n\"; }\n    template<typename T>\n    void process09(balance_report_t(balance_t::*)(T))\n    { std::cout << \"D (C::*)(T)\\n\"; }\n    int main()\n    {\n       int (account_t::* pfm1)() = &account_t::get_number;\n       int (account_t::* pfm2)(std::string) = \n          &account_t::from_string;\n       int (balance_t::* pfm3)() =\n          &balance_t::get_account_number;\n       bool (balance_t::* pfm4)(double) =\n          &balance_t::can_withdraw;\n       account_t (balance_t::* pfm5)() = \n          &balance_t::get_account;\n       transaction_t(balance_t::* pfm6)(double) = \n          &balance_t::withdraw;\n       balance_report_t(balance_t::* pfm7)(int) = \n          &balance_t::make_report;\n       process09(pfm1);    // T (C::*)()\n       process09(pfm2);    // T (C::*)(U)\n       process09(pfm3);    // T (U::*)()\n       process09(pfm4);    // T (U::*)(V)\n       process09(pfm5);    // C (T::*)()\n       process09(pfm6);    // C (T::*)(U)\n       process09(pfm7);    // D (C::*)(T)\n    }\n    ```", "```cpp\n    template<typename T>\n    void process10(T account_t::*) \n    { std::cout << \"T C::*\\n\"; }\n    template<typename T>\n    void process10(account_t T::*) \n    { std::cout << \"C T::*\\n\"; }\n    template<typename T, typename U>\n    void process10(T U::*) { std::cout << \"T U::*\\n\"; }\n    int main()\n    {\n       process10(&account_t::number);   // T C::*\n       process10(&balance_t::account);  // C T::*\n       process10(&balance_t::amount);   // T U::*\n    }\n    ```", "```cpp\n    template <typename T>\n    struct wrapper\n    {\n       T data;\n    };\n    template<typename T>\n    void process11(wrapper<T>) { std::cout << \"C<T>\\n\"; }\n    int main()\n    {\n       wrapper<double> wd{ 42.0 };\n       process11(wd); // C<T>\n    }\n    ```", "```cpp\n    template <size_t i>\n    struct int_array\n    {\n       int data[i];\n    };\n    template<size_t i>\n    void process12(int_array<i>) { std::cout << \"C<i>\\n\"; }\n    int main()\n    {\n       int_array<5> ia{};\n       process12(ia); // C<i>\n    }\n    ```", "```cpp\n    template<template<typename> class TT, typename T>\n    void process13(TT<T>) { std::cout << \"TT<T>\\n\"; }\n    int main()\n    {\n       wrapper<double> wd{ 42.0 };\n       process13(wd);    // TT<U>\n    }\n    ```", "```cpp\n    template<template<size_t> typename TT, size_t i>\n    void process14(TT<i>) { std::cout << \"TT<i>\\n\"; }\n    int main()\n    {\n       int_array<5> ia{};\n       process14(ia);    // TT<i>\n    }\n    ```", "```cpp\n    template<template<typename> typename TT>\n    void process15(TT<account_t>) { std::cout << \"TT<C>\\n\"; }\n    int main()\n    {\n       wrapper<account_t> wa{ {42} };\n       process15(wa);    // TT<C>\n    }\n    ```", "```cpp\n    template <typename T, T i>\n    void process(double arr[i])\n    {\n       using index_type = T;\n       std::cout << \"processing \" << i \n                 << \" doubles\" << '\\n';\n\n    std::cout << \"index type is \" \n              << typeid(T).name() << '\\n';\n    }\n    int main()\n    {\n       double arr[5]{};\n       process(arr);         // error\n       process<int, 5>(arr); // OK\n    }\n    ```", "```cpp\ntemplate <typename T>\nvoid process(T a = 0, T b = 42)\n{\n   std::cout << a << \",\" << b << '\\n';\n}\nint main()\n{\n   process();        // [1] error\n   process<int>();   // [2] OK\n   process(10);      // [3] OK\n}\n```", "```cpp\ntemplate <typename T>\nvoid invoke(void(*pfun)(T, int))\n{\n   pfun(T{}, 42);\n}\ntemplate <typename T>\nvoid alpha(T, int)\n{ std::cout << \"alpha(T,int)\" << '\\n'; }\nvoid beta(int, int)\n{ std::cout << \"beta(int,int)\" << '\\n'; }\nvoid beta(short, int)\n{ std::cout << \"beta(short,int)\" << '\\n'; }\nvoid gamma(short, int, long long)\n{ std::cout << \"gamma(short,int,long long)\" << '\\n'; }\nvoid gamma(double, int) \n{ std::cout << \"gamma(double,int)\" << '\\n'; }\nint main()\n{\n   invoke(&alpha);  // [1] error\n   invoke(&beta);   // [2] error\n   invoke(&gamma);  // [3] OK\n}\n```", "```cpp\n        template <size_t Size>\n        void process1(int a[Size])\n        { std::cout << \"process(int[Size])\" << '\\n'; };\n        template <size_t Size>\n        void process2(int a[5][Size])\n        { std::cout << \"process(int[5][Size])\" << '\\n'; };\n        template <size_t Size>\n        void process3(int(&a)[Size])\n        { std::cout << \"process(int[Size]&)\" << '\\n'; };\n        template <size_t Size>\n        void process4(int(*a)[Size])\n        { std::cout << \"process(int[Size]*)\" << '\\n'; };\n        int main()\n        {\n           int arr1[10];\n           int arr2[5][10];\n           process1(arr1);   // [1] error\n           process2(arr2);   // [2] OK\n           process3(arr1);   // [3] OK\n           process4(&arr1);  // [4] OK\n        }\n        ```", "```cpp\ntemplate <size_t N>\nstruct ncube \n{\n   static constexpr size_t dimensions = N;\n};\ntemplate <size_t N>\nvoid process(ncube<N - 1> cube)\n{\n   std::cout << cube.dimensions << '\\n';\n}\nint main()\n{\n   ncube<5> cube;\n   process(cube);    // [1] error\n   process<6>(cube); // [2] OK\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct wrapper\n```", "```cpp\n{\n```", "```cpp\n   T data;\n```", "```cpp\n};\n```", "```cpp\nstd::pair<int, double> p{ 42, 42.0 };\n```", "```cpp\nstd::vector<int>       v{ 1,2,3,4,5 };\n```", "```cpp\nwrapper<int>           w{ 42 };\n```", "```cpp\nauto p = std::make_pair(42, 42.0);\n```", "```cpp\ntemplate <typename T, typename... Ts, \n```", "```cpp\n          typename Allocator = std::allocator<T>>\n```", "```cpp\nauto make_vector(T&& first, Ts&&... args)\n```", "```cpp\n{\n```", "```cpp\n   return std::vector<std::decay_t<T>, Allocator> {\n```", "```cpp\n      std::forward<T>(first),\n```", "```cpp\n      std::forward<Ts>(args)... \n```", "```cpp\n   };\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nconstexpr wrapper<T> make_wrapper(T&& data)\n```", "```cpp\n{\n```", "```cpp\n   return wrapper{ data };\n```", "```cpp\n}\n```", "```cpp\nauto v = make_vector(1, 2, 3, 4, 5);\n```", "```cpp\nauto w = make_wrapper(42);\n```", "```cpp\nstd::pair   p{ 42, 42.0 };   // std::pair<int, double>\n```", "```cpp\nstd::vector v{ 1,2,3,4,5 };  // std::vector<int>\n```", "```cpp\nwrapper     w{ 42 };         // wrapper<int>\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct point_t\n```", "```cpp\n{\n```", "```cpp\n   point_t(T vx, T vy) : x(vx), y(vy) {}\n```", "```cpp\nprivate:\n```", "```cpp\n   T x;\n```", "```cpp\n   T y;\n```", "```cpp\n};\n```", "```cpp\nauto p = new point_t(1, 2);   // [1] point<int>\n```", "```cpp\n                              // new expression\n```", "```cpp\nstd::mutex mt;\n```", "```cpp\nauto l = std::lock_guard(mt); // [2] \n```", "```cpp\n// std::lock_guard<std::mutex>\n```", "```cpp\n// function-style cast expression\n```", "```cpp\ntemplate <typename T1, typename T2>\n```", "```cpp\nstd::pair<T1, T2> F();\n```", "```cpp\ntemplate <typename T1, typename T2>\n```", "```cpp\nstd::pair<T1, T2> F(T1 const& x, T2 const& y);\n```", "```cpp\ntemplate <typename T1, typename T2, typename U1, \n```", "```cpp\n          typename U2>\n```", "```cpp\nstd::pair<T1, T2> F(U1&& x, U2&& y);\n```", "```cpp\nnamespace std\n```", "```cpp\n{\n```", "```cpp\n   template <typename T1, typename T2>\n```", "```cpp\n   pair(T1&& v1, T2&& v2) -> pair<T1, T2>;\n```", "```cpp\n}\n```", "```cpp\nstd::pair  p1{1, \"one\"};    // std::pair<int, const char*>\n```", "```cpp\nstd::pair  p2{\"two\", 2};    // std::pair<const char*, int>\n```", "```cpp\nstd::pair  p3{\"3\", \"three\"};\n```", "```cpp\n                    // std::pair<const char*, const char*>\n```", "```cpp\nnamespace std\n```", "```cpp\n{\n```", "```cpp\n   template <typename T>\n```", "```cpp\n   pair(T&&, char const*) -> pair<T, std::string>;\n```", "```cpp\n   template <typename T>\n```", "```cpp\n   pair(char const*, T&&) -> pair<std::string, T>;\n```", "```cpp\n   pair(char const*, char const*) -> \n```", "```cpp\n      pair<std::string, std::string>;\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct range_t\n```", "```cpp\n{\n```", "```cpp\n   template <typename Iter>\n```", "```cpp\n   range_t(Iter first, Iter last)\n```", "```cpp\n   {\n```", "```cpp\n      std::copy(first, last, std::back_inserter(data));\n```", "```cpp\n   }\n```", "```cpp\nprivate:\n```", "```cpp\n   std::vector<T> data;\n```", "```cpp\n};\n```", "```cpp\nint arr[] = { 1,2,3,4,5 };\n```", "```cpp\nrange_t r(std::begin(arr), std::end(arr));\n```", "```cpp\nerror: no viable constructor or deduction guide for deduction of template arguments of 'range_t'\n   range_t r(std::begin(arr), std::end(arr));\n           ^\nnote: candidate template ignored: couldn't infer template argument 'T'\n      range_t(Iter first, Iter last)\n      ^\nnote: candidate function template not viable: requires 1 argument, but 2 were provided\n   struct range_t\n```", "```cpp\ntemplate <typename Iter>\n```", "```cpp\nrange_t(Iter first, Iter last) -> \n```", "```cpp\n   range_t<\n```", "```cpp\n      typename std::iterator_traits<Iter>::value_type>;\n```", "```cpp\nwrapper w{ 42 }; // wrapper<int>\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nwrapper(T) -> wrapper<T>;\n```", "```cpp\nstd::pair<int, std::string> p1{ 1, \"one\" };  // OK\n```", "```cpp\nstd::pair p2{ 2, \"two\" };                    // OK\n```", "```cpp\nstd::pair<> p3{ 3, \"three\" };                // error\n```", "```cpp\nstd::pair<int> p4{ 4, \"four\" };              // error\n```", "```cpp\nstd::vector v1{ 42 };\n```", "```cpp\nstd::vector v2{ v1, v1 };\n```", "```cpp\nstd::vector v3{ v1 };\n```", "```cpp\nstd::vector<int> v1 = \n```", "```cpp\n   std::vector<int>{std::initializer_list<int>{42}};\n```", "```cpp\nstd::vector<vector<int>> v2 = \n```", "```cpp\n   std::vector<vector<int>>{\n```", "```cpp\n      std::initializer_list<std::vector<int>>{\n```", "```cpp\n         std::vector<int>(v1), \n```", "```cpp\n         std::vector<int>(v1)\n```", "```cpp\n      }\n```", "```cpp\n   };\n```", "```cpp\nstd::vector<int> v3 = std::vector<int>{v1};\n```", "```cpp\nstruct foo\n```", "```cpp\n{\n```", "```cpp\n   int data;\n```", "```cpp\n};\n```", "```cpp\nvoid f(foo& v)\n```", "```cpp\n{ std::cout << \"f(foo&)\\n\"; }\n```", "```cpp\nvoid g(foo& v)\n```", "```cpp\n{ std::cout << \"g(foo&)\\n\"; }\n```", "```cpp\nvoid g(foo&& v)\n```", "```cpp\n{ std::cout << \"g(foo&&)\\n\"; }\n```", "```cpp\nvoid h(foo&& v)\n```", "```cpp\n{ std::cout << \"h(foo&&)\\n\"; }\n```", "```cpp\nfoo x = { 42 };   //  x is lvalue\n```", "```cpp\nfoo& rx = x;      // rx is lvalue\n```", "```cpp\nf(x);       // f(foo&)\n```", "```cpp\nf(rx);      // f(foo&)\n```", "```cpp\nf(foo{42}); // error: a non-const reference\n```", "```cpp\n            // may only be bound to an lvalue\n```", "```cpp\ng(x);             // g(foo&)\n```", "```cpp\ng(rx);            // g(foo&)\n```", "```cpp\ng(foo{ 42 });     // g(foo&&)\n```", "```cpp\nh(x);      // error, cannot bind an lvalue to an rvalue ref\n```", "```cpp\nh(rx);           // error\n```", "```cpp\nh(foo{ 42 });    // h(foo&&)\n```", "```cpp\nh(std::move(x)); // h(foo&&)\n```", "```cpp\nvoid g(foo& v)  { std::cout << \"g(foo&)\\n\"; }\n```", "```cpp\nvoid g(foo&& v) { std::cout << \"g(foo&&)\\n\"; }\n```", "```cpp\nvoid h(foo& v)  { g(v); }\n```", "```cpp\nvoid h(foo&& v) { g(v); }\n```", "```cpp\nfoo x{ 42 };\n```", "```cpp\nh(x);          // g(foo&)\n```", "```cpp\nh(foo{ 42 });  // g(foo&)\n```", "```cpp\nvoid h(foo& v)  { g(std::forward<foo&>(v)); }\n```", "```cpp\nvoid h(foo&& v) { g(std::forward<foo&&>(v)); }\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nvoid f(T&& arg)               // forwarding reference\n```", "```cpp\n{ std::cout << \"f(T&&)\\n\"; }\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nvoid f(T const&& arg)         // rvalue reference\n```", "```cpp\n{ std::cout << \"f(T const&&)\\n\"; }\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nvoid f(std::vector<T>&& arg)  // rvalue reference\n```", "```cpp\n{ std::cout << \"f(vector<T>&&)\\n\"; }\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct S\n```", "```cpp\n{\n```", "```cpp\n   void f(T&& arg)            // rvalue reference\n```", "```cpp\n   { std::cout << \"S.f(T&&)\\n\"; }\n```", "```cpp\n};\n```", "```cpp\nint x = 42;\n```", "```cpp\nf(x);                   // [1] f(T&&)\n```", "```cpp\nf(42);                  // [2] f(T&&)\n```", "```cpp\nint const cx = 100;\n```", "```cpp\nf(cx);                  // [3] f(T&&)\n```", "```cpp\nf(std::move(cx));       // [4] f(T const&&)\n```", "```cpp\nstd::vector<int> v{ 42 };\n```", "```cpp\nf(v);                   // [5] f(T&&)\n```", "```cpp\nf(std::vector<int>{42});// [6] f(vector<T>&&)\n```", "```cpp\nS<int> s;\n```", "```cpp\ns.f(x);                 // [7] error\n```", "```cpp\ns.f(42);                // [8] S.f(T&&)\n```", "```cpp\nusing lrefint = int&;\n```", "```cpp\nusing rrefint = int&&;\n```", "```cpp\nint x = 42;\n```", "```cpp\nlrefint&  r1 = x; // type of r1 is int&\n```", "```cpp\nlrefint&& r2 = x; // type of r2 is int&\n```", "```cpp\nrrefint&  r3 = x; // type of r3 is int&\n```", "```cpp\nrrefint&& r4 = 1; // type of r4 is int&&\n```", "```cpp\nint x = 42;\n```", "```cpp\nauto&& rx = x;          // [1] int&\n```", "```cpp\nauto&& rc = 42;         // [2] int&&\n```", "```cpp\nauto const&& rcx = x;   // [3] error\n```", "```cpp\nstd::vector<int> v{ 42 };\n```", "```cpp\nauto&& rv = v[0];       // [4] int&\n```", "```cpp\nvoid g(foo& v)  { std::cout << \"g(foo&)\\n\"; }\n```", "```cpp\nvoid g(foo&& v) { std::cout << \"g(foo&&)\\n\"; }\n```", "```cpp\ntemplate <typename T> void h(T& v)  { g(v); }\n```", "```cpp\ntemplate <typename T> void h(T&& v) { g(v); }\n```", "```cpp\nfoo x{ 42 };\n```", "```cpp\nh(x);          // g(foo&)\n```", "```cpp\nh(foo{ 42 });  // g(foo&)\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nvoid h(T&& v)\n```", "```cpp\n{\n```", "```cpp\n   g(std::forward<T>(v));\n```", "```cpp\n}\n```", "```cpp\ntemplate<typename T, typename... Args>\n```", "```cpp\nstd::unique_ptr<T> make_unique(Args&&... args)\n```", "```cpp\n{\n```", "```cpp\n   return std::unique_ptr<T>(\n```", "```cpp\n           new T(std::forward<Args>(args)...));\n```", "```cpp\n}\n```", "```cpp\nint f() { return 42; }\n```", "```cpp\nint g() { return 0; }\n```", "```cpp\nint g(int a) { return a; }\n```", "```cpp\nstruct wrapper\n```", "```cpp\n{\n```", "```cpp\n   int val;\n```", "```cpp\n   int get() const { return val; }\n```", "```cpp\n};\n```", "```cpp\nint a = 42;\n```", "```cpp\nint& ra = a;\n```", "```cpp\nconst double d = 42.99;\n```", "```cpp\nlong arr[10];\n```", "```cpp\nlong l = 0;\n```", "```cpp\nchar* p = nullptr;\n```", "```cpp\nchar c = 'x';\n```", "```cpp\nwrapper w1{ 1 };\n```", "```cpp\nwrapper* w2 = new wrapper{ 2 };\n```", "```cpp\ndecltype(a) e1;             // R1, int\n```", "```cpp\ndecltype(ra) e2 = a;        // R1, int&\n```", "```cpp\ndecltype(f) e3;             // R1, int()\n```", "```cpp\ndecltype(f()) e4;           // R2, int\n```", "```cpp\ndecltype(g) e5;             // R1, error\n```", "```cpp\ndecltype(g(1)) e6;          // R2, int\n```", "```cpp\ndecltype(&f) e7 = nullptr;  // R4, int(*)()\n```", "```cpp\ndecltype(d) e8 = 1;         // R1, const double\n```", "```cpp\ndecltype(arr) e9;           // R1, long[10]\n```", "```cpp\ndecltype(arr[1]) e10 = l;   // R3, long&\n```", "```cpp\ndecltype(w1.val) e11;       // R1, int\n```", "```cpp\ndecltype(w1.get()) e12;     // R1, int\n```", "```cpp\ndecltype(w2->val) e13;      // R1, int\n```", "```cpp\ndecltype(w2->get()) e14;    // R1, int\n```", "```cpp\ndecltype(42) e15 = 1;       // R4, int\n```", "```cpp\ndecltype(1 + 2) e16;        // R4, int\n```", "```cpp\ndecltype(a + 1) e17;        // R4, int\n```", "```cpp\ndecltype(a = 0) e18 = a;    // R3, int&\n```", "```cpp\ndecltype(p) e19 = nullptr;  // R1, char*\n```", "```cpp\ndecltype(*p) e20 = c;       // R3, char&\n```", "```cpp\ndecltype(p[0]) e21 = c;     // R3, char&\n```", "```cpp\nint a = 42;\n```", "```cpp\ndecltype(a = 1) e = a;\n```", "```cpp\nstd::cout << a << '\\n';  // prints 42\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct wrapper\n```", "```cpp\n{\n```", "```cpp\n   T data;\n```", "```cpp\n};\n```", "```cpp\ndecltype(wrapper<double>::data) e1;  // double\n```", "```cpp\nint a = 42;\n```", "```cpp\ndecltype(wrapper<char>::data, a) e2; // int&\n```", "```cpp\nstruct foo\n```", "```cpp\n{\n```", "```cpp\n   int          a = 0;\n```", "```cpp\n   volatile int b = 0;\n```", "```cpp\n   const int    c = 42;\n```", "```cpp\n};\n```", "```cpp\nfoo f;\n```", "```cpp\nfoo const cf;\n```", "```cpp\nvolatile foo* pf = &f;\n```", "```cpp\ndecltype(f.a) e1 = 0;       // int\n```", "```cpp\ndecltype(f.b) e2 = 0;       // int volatile\n```", "```cpp\ndecltype(f.c) e3 = 0;       // int const\n```", "```cpp\ndecltype(cf.a) e4 = 0;      // int\n```", "```cpp\ndecltype(cf.b) e5 = 0;      // int volatile\n```", "```cpp\ndecltype(cf.c) e6 = 0;      // int const\n```", "```cpp\ndecltype(pf->a) e7 = 0;     // int\n```", "```cpp\ndecltype(pf->b) e8 = 0;     // int volatile\n```", "```cpp\ndecltype(pf->c) e9 = 0;     // int const\n```", "```cpp\ndecltype(foo{}.a) e10 = 0;  // int\n```", "```cpp\ndecltype(foo{}.b) e11 = 0;  // int volatile\n```", "```cpp\ndecltype(foo{}.c) e12 = 0;  // int const\n```", "```cpp\nfoo f;\n```", "```cpp\nfoo const cf;\n```", "```cpp\nvolatile foo* pf = &f;\n```", "```cpp\nint x = 1;\n```", "```cpp\nint volatile y = 2;\n```", "```cpp\nint const z = 3;\n```", "```cpp\ndecltype((f.a)) e1 = x;       // int&\n```", "```cpp\ndecltype((f.b)) e2 = y;       // int volatile&\n```", "```cpp\ndecltype((f.c)) e3 = z;       // int const&\n```", "```cpp\ndecltype((cf.a)) e4 = x;      // int const&\n```", "```cpp\ndecltype((cf.b)) e5 = y;      // int const volatile&\n```", "```cpp\ndecltype((cf.c)) e6 = z;      // int const&\n```", "```cpp\ndecltype((pf->a)) e7 = x;     // int volatile&\n```", "```cpp\ndecltype((pf->b)) e8 = y;     // int volatile&\n```", "```cpp\ndecltype((pf->c)) e9 = z;     // int const volatile&\n```", "```cpp\ndecltype((foo{}.a)) e10 = 0;  // int&&\n```", "```cpp\ndecltype((foo{}.b)) e11 = 0;  // int volatile&&\n```", "```cpp\ndecltype((foo{}.c)) e12 = 0;  // int const&&\n```", "```cpp\nint a = 0;\n```", "```cpp\nint& ra = a;\n```", "```cpp\nint const c = 42;\n```", "```cpp\nint volatile d = 99;\n```", "```cpp\ndecltype(ra)& e1 = a;          // int&\n```", "```cpp\ndecltype(c) const e2 = 1;      // int const\n```", "```cpp\ndecltype(d) volatile e3 = 1;   // int volatile\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nT minimum(T&& a, T&& b)\n```", "```cpp\n{\n```", "```cpp\n   return a < b ? a : b;\n```", "```cpp\n}\n```", "```cpp\nauto m1 = minimum(1, 5);       // OK\n```", "```cpp\nauto m2 = minimum(18.49, 9.99);// OK\n```", "```cpp\nauto m3 = minimum(1, 9.99);    \n```", "```cpp\n                     // error, arguments of different type\n```", "```cpp\ntemplate <typename T, typename U>\n```", "```cpp\n??? minimum(T&& a, U&& b)\n```", "```cpp\n{\n```", "```cpp\n   return a < b ? a : b;\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T, typename U>\n```", "```cpp\nauto minimum(T&& a, U&& b) -> decltype(a < b ? a : b)\n```", "```cpp\n{\n```", "```cpp\n   return a < b ? a : b;\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T, typename U>\n```", "```cpp\ndecltype(auto) minimum(T&& a, U&& b)\n```", "```cpp\n{\n```", "```cpp\n   return a < b ? a : b;\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T, typename U>\n```", "```cpp\nauto minimum(T&& a, U&& b)\n```", "```cpp\n{\n```", "```cpp\n   return a < b ? a : b;\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nT const& func(T const& ref)\n```", "```cpp\n{\n```", "```cpp\n   return ref;\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nauto func_caller(T&& ref)\n```", "```cpp\n{\n```", "```cpp\n   return func(std::forward<T>(ref));\n```", "```cpp\n}\n```", "```cpp\nint a = 42;\n```", "```cpp\ndecltype(func(a))        r1 = func(a);        // int const&\n```", "```cpp\ndecltype(func_caller(a)) r2 = func_caller(a); // int\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\ndecltype(auto) func_caller(T&& ref)\n```", "```cpp\n{\n```", "```cpp\n   return func(std::forward<T>(ref));\n```", "```cpp\n}\n```", "```cpp\nint a = 42;\n```", "```cpp\ndecltype(func(a))        r1 = func(a);        // int const&\n```", "```cpp\ndecltype(func_caller(a)) r2 = func_caller(a); // int const&\n```", "```cpp\ntemplate<class T>\n```", "```cpp\ntypename std::add_rvalue_reference<T>::type declval() noexcept;\n```", "```cpp\ntemplate <typename T, typename U>\n```", "```cpp\nstruct composition\n```", "```cpp\n{\n```", "```cpp\n   using result_type = decltype(???);\n```", "```cpp\n};\n```", "```cpp\nstatic_assert(\n```", "```cpp\n  std::is_same_v<double, \n```", "```cpp\n                 composition<int, double>::result_type>);\n```", "```cpp\nstruct wrapper\n```", "```cpp\n{\n```", "```cpp\n   wrapper(int const v) : value(v){}\n```", "```cpp\n   int value;\n```", "```cpp\n   friend wrapper operator+(int const a, wrapper const& w)\n```", "```cpp\n   {\n```", "```cpp\n      return wrapper(a + w.value);\n```", "```cpp\n   }\n```", "```cpp\n   friend wrapper operator+(wrapper const& w, int const a)\n```", "```cpp\n   {\n```", "```cpp\n      return wrapper(a + w.value);\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\n// error, no appropriate default constructor available\n```", "```cpp\nstatic_assert(\n```", "```cpp\n  std::is_same_v<wrapper, \n```", "```cpp\n                 composition<int,wrapper>::result_type>);\n```", "```cpp\ntemplate <typename T, typename U>\n```", "```cpp\nstruct composition\n```", "```cpp\n{\n```", "```cpp\n   using result_type = decltype(std::declval<T>() + \n```", "```cpp\n                                std::declval<U>());\n```", "```cpp\n};\n```", "```cpp\nstruct wrapper\n```", "```cpp\n{   \n```", "```cpp\n   wrapper(int const v) :value(v) {}\n```", "```cpp\nprivate:\n```", "```cpp\n   int value;\n```", "```cpp\n   friend void print(wrapper const & w);\n```", "```cpp\n};\n```", "```cpp\nvoid print(wrapper const& w)\n```", "```cpp\n{ std::cout << w.value << '\\n'; }\n```", "```cpp\nwrapper w{ 42 };\n```", "```cpp\nprint(w);\n```", "```cpp\nstruct wrapper\n```", "```cpp\n{\n```", "```cpp\n   wrapper(int const v) :value(v) {}\n```", "```cpp\nprivate:\n```", "```cpp\n   int value;\n```", "```cpp\n   template <typename T>\n```", "```cpp\n   friend void print(wrapper const&);\n```", "```cpp\n   template <typename T>\n```", "```cpp\n   friend struct printer;\n```", "```cpp\n};   \n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nvoid print(wrapper const& w)\n```", "```cpp\n{ std::cout << w.value << '\\n'; }\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct printer\n```", "```cpp\n{\n```", "```cpp\n   void operator()(wrapper const& w)\n```", "```cpp\n   { std::cout << w.value << '\\n'; }\n```", "```cpp\n};\n```", "```cpp\nwrapper w{ 42 };\n```", "```cpp\nprint<int>(w);\n```", "```cpp\nprint<char>(w);\n```", "```cpp\nprinter<int>()(w);\n```", "```cpp\nprinter<double>()(w);\n```", "```cpp\nstruct wrapper;\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nvoid print(wrapper const& w);\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct printer;\n```", "```cpp\nstruct wrapper\n```", "```cpp\n{\n```", "```cpp\n   wrapper(int const v) :value(v) {}\n```", "```cpp\nprivate:\n```", "```cpp\n   int value;\n```", "```cpp\n   friend void print<int>(wrapper const&);\n```", "```cpp\n   friend struct printer<int>;\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nvoid print(wrapper const& w)\n```", "```cpp\n{ std::cout << w.value << '\\n'; /* error */ }\n```", "```cpp\ntemplate <>\n```", "```cpp\nvoid print<int>(wrapper const& w)\n```", "```cpp\n{ std::cout << w.value << '\\n'; }\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct printer\n```", "```cpp\n{\n```", "```cpp\n   void operator()(wrapper const& w)\n```", "```cpp\n   { std::cout << w.value << '\\n'; /* error*/ }\n```", "```cpp\n};\n```", "```cpp\ntemplate <>\n```", "```cpp\nstruct printer<int>\n```", "```cpp\n{\n```", "```cpp\n   void operator()(wrapper const& w)\n```", "```cpp\n   { std::cout << w.value << '\\n'; }\n```", "```cpp\n};\n```", "```cpp\nwrapper w{ 43 };\n```", "```cpp\nprint<int>(w);\n```", "```cpp\nprint<char>(w);\n```", "```cpp\nprinter<int>()(w);\n```", "```cpp\nprinter<double>()(w);\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct wrapper\n```", "```cpp\n{\n```", "```cpp\n   wrapper(T const v) :value(v) {}\n```", "```cpp\nprivate:\n```", "```cpp\n   T value;\n```", "```cpp\n   friend void print(wrapper<int> const&);\n```", "```cpp\n};\n```", "```cpp\nvoid print(wrapper<int> const& w)\n```", "```cpp\n{ std::cout << w.value << '\\n'; }\n```", "```cpp\nvoid print(wrapper<char> const& w)\n```", "```cpp\n{ std::cout << w.value << '\\n'; /* error */ }\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct printer;\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct wrapper\n```", "```cpp\n{\n```", "```cpp\n   wrapper(T const v) :value(v) {}\n```", "```cpp\nprivate:\n```", "```cpp\n   T value;\n```", "```cpp\n   friend void print<int>(wrapper<int> const&);\n```", "```cpp\n   friend struct printer<int>;\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nvoid print(wrapper<T> const& w)\n```", "```cpp\n{ std::cout << w.value << '\\n'; /* error */ }\n```", "```cpp\ntemplate<>\n```", "```cpp\nvoid print(wrapper<int> const& w)\n```", "```cpp\n{ std::cout << w.value << '\\n'; }\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct printer\n```", "```cpp\n{\n```", "```cpp\n   void operator()(wrapper<T> const& w)\n```", "```cpp\n   { std::cout << w.value << '\\n'; /* error */ }\n```", "```cpp\n};\n```", "```cpp\ntemplate <>\n```", "```cpp\nstruct printer<int>\n```", "```cpp\n{\n```", "```cpp\n   void operator()(wrapper<int> const& w)\n```", "```cpp\n   { std::cout << w.value << '\\n'; }\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct printer;\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct wrapper\n```", "```cpp\n{\n```", "```cpp\n   wrapper(T const v) :value(v) {}\n```", "```cpp\nprivate:\n```", "```cpp\n   T value;\n```", "```cpp\n   template <typename U>\n```", "```cpp\n   friend void print(wrapper<U> const&);\n```", "```cpp\n   template <typename U>\n```", "```cpp\n   friend struct printer;\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nvoid print(wrapper<T> const& w)\n```", "```cpp\n{  std::cout << w.value << '\\n'; }\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct printer\n```", "```cpp\n{\n```", "```cpp\n   void operator()(wrapper<T> const& w)\n```", "```cpp\n   {  std::cout << w.value << '\\n';  }\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct wrapper\n```", "```cpp\n{\n```", "```cpp\n   wrapper(T const v) :value(v) {}\n```", "```cpp\nprivate:\n```", "```cpp\n   T value;\n```", "```cpp\n   friend void print<T>(wrapper<T> const&);\n```", "```cpp\n   friend struct printer<T>;\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct connection\n```", "```cpp\n{\n```", "```cpp\n   connection(std::string const& host, int const port) \n```", "```cpp\n      :ConnectionString(host + \":\" + std::to_string(port)) \n```", "```cpp\n   {}\n```", "```cpp\nprivate:\n```", "```cpp\n   std::string ConnectionString;\n```", "```cpp\n   friend T;\n```", "```cpp\n};\n```", "```cpp\nstruct executor\n```", "```cpp\n{\n```", "```cpp\n   void run()\n```", "```cpp\n   {\n```", "```cpp\n      connection<executor> c(\"localhost\", 1234);\n```", "```cpp\n      std::cout << c.ConnectionString << '\\n';\n```", "```cpp\n   }\n```", "```cpp\n};\n```"]