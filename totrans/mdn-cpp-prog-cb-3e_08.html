<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer123">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 class="chapterTitle" id="_idParaDest-493"><span class="koboSpan" id="kobo.2.1">Leveraging Threading and Concurrency</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">Most computers contain multiple processors or at least multiple cores, and leveraging this computational power is key to many categories of applications. </span><span class="koboSpan" id="kobo.3.2">Unfortunately, many developers still have a mindset of sequential code execution, even though operations that do not depend on each other could be executed concurrently. </span><span class="koboSpan" id="kobo.3.3">This chapter presents standard library support for threads, asynchronous tasks, and related components, as well as some practical examples at the end.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4.1">Most modern processors (except those dedicated to types of applications that do not require great computing power, such as Internet of Things applications) have two, four, or more cores that enable you to concurrently execute multiple threads of execution. </span><span class="koboSpan" id="kobo.4.2">Applications must be explicitly written to leverage the multiple processing units that exist; you can write such applications by executing functions on multiple threads at the same time. </span><span class="koboSpan" id="kobo.4.3">Since C++11, the standard library provides support for working with threads, synchronization of shared data, thread communication, and asynchronous tasks. </span><span class="koboSpan" id="kobo.4.4">In this chapter, we’ll explore the most important topics related to threads and tasks.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5.1">This chapter includes the following recipes:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.6.1">Working with threads</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.7.1">Synchronizing access to shared data with mutexes and locks</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.8.1">Finding alternatives for recursive mutexes</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.9.1">Handling exceptions from thread functions</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.10.1">Sending notifications between threads</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.11.1">Using promises and futures to return values from threads</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.12.1">Executing functions asynchronously</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.13.1">Using atomic types</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.14.1">Implementing parallel </span><code class="inlineCode"><span class="koboSpan" id="kobo.15.1">map</span></code><span class="koboSpan" id="kobo.16.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.17.1">fold</span></code><span class="koboSpan" id="kobo.18.1"> with threads</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.19.1">Implementing parallel </span><code class="inlineCode"><span class="koboSpan" id="kobo.20.1">map</span></code><span class="koboSpan" id="kobo.21.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.22.1">fold</span></code><span class="koboSpan" id="kobo.23.1"> with tasks</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.24.1">Implementing parallel </span><code class="inlineCode"><span class="koboSpan" id="kobo.25.1">map</span></code><span class="koboSpan" id="kobo.26.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.27.1">fold</span></code><span class="koboSpan" id="kobo.28.1"> with standard parallel algorithms</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.29.1">Using joinable threads and cancellation mechanisms</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.30.1">Synchronizing threads with latches, barriers, and semaphores</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.31.1">Synchronizing writing to output streams from multiple threads</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.32.1">In the first part of this chapter, we will look at the various threading objects and mechanisms that have built-in support in the library, such as threads, locking objects, condition variables, exception handling, and others.</span></p>
<h1 class="heading-1" id="_idParaDest-494"><span class="koboSpan" id="kobo.33.1">Working with threads</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.34.1">A thread is a </span><a id="_idIndexMarker947"/><span class="koboSpan" id="kobo.35.1">sequence of instructions that can be managed independently by a scheduler, such as the operating system. </span><span class="koboSpan" id="kobo.35.2">Threads could be software or hardware. </span><span class="koboSpan" id="kobo.35.3">Software threads are threads of execution that are managed by the operating system. </span><span class="koboSpan" id="kobo.35.4">They can run on single processing units, usually by time slicing. </span><span class="koboSpan" id="kobo.35.5">This is a mechanism where each thread gets a time slot of execution (in the range of milliseconds) on the processing unit before the operating system schedules another software thread to run on the same processing unit. </span><span class="koboSpan" id="kobo.35.6">Hardware threads are threads of execution at the physical level. </span><span class="koboSpan" id="kobo.35.7">They are, basically, a CPU or a CPU core. </span><span class="koboSpan" id="kobo.35.8">They can run simultaneously, that is, in parallel, on systems</span><a id="_idIndexMarker948"/><span class="koboSpan" id="kobo.36.1"> with multiprocessors or multicores. </span><span class="koboSpan" id="kobo.36.2">Many software threads can run concurrently on a hardware thread, usually by using time slicing. </span><span class="koboSpan" id="kobo.36.3">The C++ library provides support for working with software threads. </span><span class="koboSpan" id="kobo.36.4">In this recipe, you will learn how to create and perform operations with threads.</span></p>
<h2 class="heading-2" id="_idParaDest-495"><span class="koboSpan" id="kobo.37.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.38.1">A thread of execution is represented by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.39.1">thread</span></code><span class="koboSpan" id="kobo.40.1"> class, available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.41.1">std</span></code><span class="koboSpan" id="kobo.42.1"> namespace in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.43.1">&lt;thread&gt;</span></code><span class="koboSpan" id="kobo.44.1"> header. </span><span class="koboSpan" id="kobo.44.2">Additional thread utilities are available in the same header but in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.45.1">std::this_thread</span></code><span class="koboSpan" id="kobo.46.1"> namespace.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.47.1">In the following examples, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.48.1">print_time()</span></code><span class="koboSpan" id="kobo.49.1"> function is used. </span><span class="koboSpan" id="kobo.49.2">This function prints the local time to the console. </span><span class="koboSpan" id="kobo.49.3">Its implementation is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.50.1">inline</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.51.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.52.1">print_time</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.53.1">()</span></span><span class="koboSpan" id="kobo.54.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.55.1">auto</span></span><span class="koboSpan" id="kobo.56.1"> now = std::chrono::system_clock::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.57.1">now</span></span><span class="koboSpan" id="kobo.58.1">();
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.59.1">auto</span></span><span class="koboSpan" id="kobo.60.1"> stime = std::chrono::system_clock::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.61.1">to_time_t</span></span><span class="koboSpan" id="kobo.62.1">(now);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.63.1">auto</span></span><span class="koboSpan" id="kobo.64.1"> ltime = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.65.1">localtime</span></span><span class="koboSpan" id="kobo.66.1">(&amp;stime);
  std::cout &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.67.1">put_time</span></span><span class="koboSpan" id="kobo.68.1">(ltime, </span><span class="hljs-string"><span class="koboSpan" id="kobo.69.1">"%c"</span></span><span class="koboSpan" id="kobo.70.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.71.1">'\n'</span></span><span class="koboSpan" id="kobo.72.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.73.1">In the next </span><a id="_idIndexMarker949"/><span class="koboSpan" id="kobo.74.1">section, we will see how to perform common operations with threads.</span></p>
<h2 class="heading-2" id="_idParaDest-496"><span class="koboSpan" id="kobo.75.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.76.1">Use the following solutions to manage threads:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.77.1">To create a </span><code class="inlineCode"><span class="koboSpan" id="kobo.78.1">std::thread</span></code><span class="koboSpan" id="kobo.79.1"> object without starting the execution of a new thread, use its default constructor:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.80.1">std::thread t;
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.81.1">Start the execution of a function on another thread by constructing a </span><code class="inlineCode"><span class="koboSpan" id="kobo.82.1">std::thread</span></code><span class="koboSpan" id="kobo.83.1"> object and passing the function as an argument:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.84.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.85.1">func1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.86.1">()</span></span><span class="koboSpan" id="kobo.87.1">
{
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.88.1">"thread func without params"</span></span><span class="koboSpan" id="kobo.89.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.90.1">'\n'</span></span><span class="koboSpan" id="kobo.91.1">;
}
</span><span class="hljs-function"><span class="koboSpan" id="kobo.92.1">std::thread </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.93.1">t1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.94.1">(func1)</span></span><span class="koboSpan" id="kobo.95.1">;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.96.1">std::thread </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.97.1">t2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.98.1">([]() {</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.99.1">  std::cout &lt;&lt; </span></span><span class="hljs-string"><span class="koboSpan" id="kobo.100.1">"thread func without params"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.101.1"> &lt;&lt; </span></span><span class="hljs-string"><span class="koboSpan" id="kobo.102.1">'\n'</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.103.1">; })</span></span><span class="koboSpan" id="kobo.104.1">;
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.105.1">Start the execution of a function with arguments on another thread by constructing a </span><code class="inlineCode"><span class="koboSpan" id="kobo.106.1">std::thread</span></code><span class="koboSpan" id="kobo.107.1"> object, and then passing the function as an argument to the constructor, followed by its arguments:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.108.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.109.1">func2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.110.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.111.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.112.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.113.1"> i, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.114.1">double</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.115.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.116.1"> d, std::string </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.117.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.118.1"> s)</span></span><span class="koboSpan" id="kobo.119.1">
{
  std::cout &lt;&lt; i &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.120.1">", "</span></span><span class="koboSpan" id="kobo.121.1"> &lt;&lt; d &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.122.1">", "</span></span><span class="koboSpan" id="kobo.123.1"> &lt;&lt; s &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.124.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.125.1">\n'</span></span><span class="koboSpan" id="kobo.126.1">;
}
</span><span class="hljs-function"><span class="koboSpan" id="kobo.127.1">std::thread </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.128.1">t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.129.1">(func2, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.130.1">42</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.131.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.132.1">42.0</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.133.1">, </span></span><span class="hljs-string"><span class="koboSpan" id="kobo.134.1">"42"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.135.1">)</span></span><span class="koboSpan" id="kobo.136.1">;
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.137.1">To wait for a thread to finish its execution, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.138.1">join()</span></code><span class="koboSpan" id="kobo.139.1"> method on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.140.1">thread</span></code><span class="koboSpan" id="kobo.141.1"> object:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.142.1">t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.143.1">join</span></span><span class="koboSpan" id="kobo.144.1">();
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.145.1">To allow a thread to continue its execution independently of the current </span><code class="inlineCode"><span class="koboSpan" id="kobo.146.1">thread</span></code><span class="koboSpan" id="kobo.147.1"> object, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.148.1">detach()</span></code><span class="koboSpan" id="kobo.149.1"> method. </span><span class="koboSpan" id="kobo.149.2">This means the thread will continue its execution until it finishes without being managed by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.150.1">std::thread</span></code><span class="koboSpan" id="kobo.151.1"> object, which will no longer own any thread:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.152.1">t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.153.1">detach</span></span><span class="koboSpan" id="kobo.154.1">();
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.155.1">To pass</span><a id="_idIndexMarker950"/><span class="koboSpan" id="kobo.156.1"> arguments by reference to a function thread, wrap them in either </span><code class="inlineCode"><span class="koboSpan" id="kobo.157.1">std::ref</span></code><span class="koboSpan" id="kobo.158.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.159.1">std::cref</span></code><span class="koboSpan" id="kobo.160.1"> (if the reference is constant):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.161.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.162.1">func3</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.163.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.164.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.165.1"> &amp; i)</span></span><span class="koboSpan" id="kobo.166.1">
{
  i *= </span><span class="hljs-number"><span class="koboSpan" id="kobo.167.1">2</span></span><span class="koboSpan" id="kobo.168.1">;
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.169.1">int</span></span><span class="koboSpan" id="kobo.170.1"> n = </span><span class="hljs-number"><span class="koboSpan" id="kobo.171.1">42</span></span><span class="koboSpan" id="kobo.172.1">;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.173.1">std::thread </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.174.1">t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.175.1">(func3, std::ref(n))</span></span><span class="koboSpan" id="kobo.176.1">;
t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.177.1">join</span></span><span class="koboSpan" id="kobo.178.1">();
std::cout &lt;&lt; n &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.179.1">'\n'</span></span><span class="koboSpan" id="kobo.180.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.181.1">// 84</span></span>
</code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.182.1">To stop the execution of a thread for a specified duration, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.183.1">std::this_thread::sleep_for()</span></code><span class="koboSpan" id="kobo.184.1"> function:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.185.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.186.1">func4</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.187.1">()</span></span><span class="koboSpan" id="kobo.188.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.189.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.190.1">namespace</span></span><span class="koboSpan" id="kobo.191.1"> std::chrono;
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.192.1">print_time</span></span><span class="koboSpan" id="kobo.193.1">();
  std::this_thread::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.194.1">sleep_for</span></span><span class="koboSpan" id="kobo.195.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.196.1">2</span></span><span class="koboSpan" id="kobo.197.1">s);
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.198.1">print_time</span></span><span class="koboSpan" id="kobo.199.1">();
}
</span><span class="hljs-function"><span class="koboSpan" id="kobo.200.1">std::thread </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.201.1">t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.202.1">(func4)</span></span><span class="koboSpan" id="kobo.203.1">;
t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.204.1">join</span></span><span class="koboSpan" id="kobo.205.1">();
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.206.1">To stop the execution of a thread until a specified moment in time, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.207.1">std::this_thread::sleep_until()</span></code><span class="koboSpan" id="kobo.208.1"> function:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.209.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.210.1">func5</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.211.1">()</span></span><span class="koboSpan" id="kobo.212.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.213.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.214.1">namespace</span></span><span class="koboSpan" id="kobo.215.1"> std::chrono;
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.216.1">print_time</span></span><span class="koboSpan" id="kobo.217.1">();
  std::this_thread::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.218.1">sleep_until</span></span><span class="koboSpan" id="kobo.219.1">(
    std::chrono::system_clock::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.220.1">now</span></span><span class="koboSpan" id="kobo.221.1">() + </span><span class="hljs-number"><span class="koboSpan" id="kobo.222.1">2</span></span><span class="koboSpan" id="kobo.223.1">s);
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.224.1">print_time</span></span><span class="koboSpan" id="kobo.225.1">();
}
</span><span class="hljs-function"><span class="koboSpan" id="kobo.226.1">std::thread </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.227.1">t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.228.1">(func5)</span></span><span class="koboSpan" id="kobo.229.1">;
t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.230.1">join</span></span><span class="koboSpan" id="kobo.231.1">();
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.232.1">To </span><a id="_idIndexMarker951"/><span class="koboSpan" id="kobo.233.1">suspend the execution of the current thread and provide an opportunity for another thread to perform the execution, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.234.1">std::this_thread::yield()</span></code><span class="koboSpan" id="kobo.235.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.236.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.237.1">func6</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.238.1">(std::chrono::seconds timeout)</span></span><span class="koboSpan" id="kobo.239.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.240.1">auto</span></span><span class="koboSpan" id="kobo.241.1"> now = std::chrono::system_clock::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.242.1">now</span></span><span class="koboSpan" id="kobo.243.1">();
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.244.1">auto</span></span><span class="koboSpan" id="kobo.245.1"> then = now + timeout;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.246.1">do</span></span><span class="koboSpan" id="kobo.247.1">
  {
    std::this_thread::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.248.1">yield</span></span><span class="koboSpan" id="kobo.249.1">();
  } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.250.1">while</span></span><span class="koboSpan" id="kobo.251.1"> (std::chrono::system_clock::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.252.1">now</span></span><span class="koboSpan" id="kobo.253.1">() &lt; then);
}
</span><span class="hljs-function"><span class="koboSpan" id="kobo.254.1">std::thread </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.255.1">t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.256.1">(func6, std::chrono::seconds(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.257.1">2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.258.1">))</span></span><span class="koboSpan" id="kobo.259.1">;
t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.260.1">join</span></span><span class="koboSpan" id="kobo.261.1">();
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.262.1">print_time</span></span><span class="koboSpan" id="kobo.263.1">();
</span></code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-497"><span class="koboSpan" id="kobo.264.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.265.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.266.1">std::thread</span></code><span class="koboSpan" id="kobo.267.1"> class, which represents a single thread of execution, has several constructors:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.268.1">A default constructor that only creates the thread object but does not start the execution of a new thread.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.269.1">A move constructor that creates a new thread object to represent a thread of execution previously represented by the object it was constructed from. </span><span class="koboSpan" id="kobo.269.2">After the construction of the new object, the other object is no longer associated with the execution thread.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.270.1">A constructor with a variable number of arguments: the first being a function that represents the top-level thread function and the others being arguments to be passed to the thread function. </span><span class="koboSpan" id="kobo.270.2">Arguments need to be passed to the thread function by value. </span><span class="koboSpan" id="kobo.270.3">If the thread function takes parameters by reference or by constant reference, they must be wrapped in either a </span><code class="inlineCode"><span class="koboSpan" id="kobo.271.1">std::ref</span></code><span class="koboSpan" id="kobo.272.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.273.1">std::cref</span></code><span class="koboSpan" id="kobo.274.1"> object. </span><span class="koboSpan" id="kobo.274.2">These are helper function templates that generate objects of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.275.1">std::reference_wrapper</span></code><span class="koboSpan" id="kobo.276.1">, which wraps a reference in a copyable and assignable object.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.277.1">The thread function, in </span><a id="_idIndexMarker952"/><span class="koboSpan" id="kobo.278.1">this case, cannot return a value. </span><span class="koboSpan" id="kobo.278.2">It is not illegal for the function to actually have a return type other than </span><code class="inlineCode"><span class="koboSpan" id="kobo.279.1">void</span></code><span class="koboSpan" id="kobo.280.1">, but it ignores any value that is directly returned by the function. </span><span class="koboSpan" id="kobo.280.2">If it has to return a value, it can do so using a shared variable or a function argument. </span><span class="koboSpan" id="kobo.280.3">In the </span><em class="italic"><span class="koboSpan" id="kobo.281.1">Using promises and futures to return values from threads</span></em><span class="koboSpan" id="kobo.282.1"> recipe, later in this chapter, we will see how a thread function returns a value to another thread using a </span><em class="italic"><span class="koboSpan" id="kobo.283.1">promise</span></em><span class="koboSpan" id="kobo.284.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.285.1">If the function terminates with an exception, the exception cannot be caught with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.286.1">try...catch</span></code><span class="koboSpan" id="kobo.287.1"> statement in the context where a thread was started and the program terminates abnormally with a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.288.1">std::terminate()</span></code><span class="koboSpan" id="kobo.289.1">. </span><span class="koboSpan" id="kobo.289.2">All exceptions must be caught within the executing thread, but they can be transported across threads via a </span><code class="inlineCode"><span class="koboSpan" id="kobo.290.1">std::exception_ptr</span></code><span class="koboSpan" id="kobo.291.1"> object. </span><span class="koboSpan" id="kobo.291.2">We’ll discuss this topic in a later recipe, called </span><em class="italic"><span class="koboSpan" id="kobo.292.1">Handling exceptions from thread functions</span></em><span class="koboSpan" id="kobo.293.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.294.1">After a thread has started its execution, it is both joinable and detachable. </span><span class="koboSpan" id="kobo.294.2">Joining a thread implies blocking the execution of the current thread until the joined thread ends its execution. </span><span class="koboSpan" id="kobo.294.3">Detaching a thread means decoupling the thread object from the thread of execution it represents, allowing both the current thread and the detached thread to be executed at the same time. </span><span class="koboSpan" id="kobo.294.4">Detached threads are sometimes called background threads or daemon threads. </span><span class="koboSpan" id="kobo.294.5">When a program terminates (by returning from the main function), the detached threads that are still running are not waited for. </span><span class="koboSpan" id="kobo.294.6">That means the stack of those threads is not unwound. </span><span class="koboSpan" id="kobo.294.7">Because of this, the destructor of the objects on the stack is not called, which may lead to resource leaks or corrupted resources (files, shared memory, etc.).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.295.1">Joining a thread is done with </span><code class="inlineCode"><span class="koboSpan" id="kobo.296.1">join()</span></code><span class="koboSpan" id="kobo.297.1"> and detaching a thread is done with </span><code class="inlineCode"><span class="koboSpan" id="kobo.298.1">detach()</span></code><span class="koboSpan" id="kobo.299.1">. </span><span class="koboSpan" id="kobo.299.2">Once you call either of these two methods, the thread is said to be non-joinable and the thread object can be safely destroyed. </span><span class="koboSpan" id="kobo.299.3">When a thread is detached, the shared data it may need to access must be available throughout its execution. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.300.1">When you detach a thread, you cannot join it anymore. </span><span class="koboSpan" id="kobo.300.2">An attempt to do so will result in a runtime error. </span><span class="koboSpan" id="kobo.300.3">You can prevent this by checking whether the thread can be joined or not by using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.301.1">joinable()</span></code><span class="koboSpan" id="kobo.302.1"> member function.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.303.1">If a thread</span><a id="_idIndexMarker953"/><span class="koboSpan" id="kobo.304.1"> object goes out of scope and is destroyed but neither </span><code class="inlineCode"><span class="koboSpan" id="kobo.305.1">join()</span></code><span class="koboSpan" id="kobo.306.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.307.1">detach()</span></code><span class="koboSpan" id="kobo.308.1"> has been called, then </span><code class="inlineCode"><span class="koboSpan" id="kobo.309.1">std::terminate()</span></code><span class="koboSpan" id="kobo.310.1"> is invoked.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.311.1">Each thread has an identifier that can be retrieved. </span><span class="koboSpan" id="kobo.311.2">For the current thread, call the </span><code class="inlineCode"><span class="koboSpan" id="kobo.312.1">std::this_thread::get_id()</span></code><span class="koboSpan" id="kobo.313.1"> function. </span><span class="koboSpan" id="kobo.313.2">For another thread of execution represented by a </span><code class="inlineCode"><span class="koboSpan" id="kobo.314.1">thread</span></code><span class="koboSpan" id="kobo.315.1"> object, call its </span><code class="inlineCode"><span class="koboSpan" id="kobo.316.1">get_id()</span></code><span class="koboSpan" id="kobo.317.1"> method.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.318.1">There are several additional utility functions available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.319.1">std::this_thread</span></code><span class="koboSpan" id="kobo.320.1"> namespace:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.321.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.322.1">yield()</span></code><span class="koboSpan" id="kobo.323.1"> method hints at the scheduler to activate another thread. </span><span class="koboSpan" id="kobo.323.2">This is useful when implementing a busy-waiting routine, as in the last example from the previous section. </span><span class="koboSpan" id="kobo.323.3">However, the actual behavior is implementation-specific. </span><span class="koboSpan" id="kobo.323.4">A call to this function, in fact, may have no effect on the execution of threads.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.324.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.325.1">sleep_for()</span></code><span class="koboSpan" id="kobo.326.1"> method blocks the execution of the current thread for at least the specified period of time (the actual time the thread is put to sleep may be longer than the requested period due to scheduling).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.327.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.328.1">sleep_until()</span></code><span class="koboSpan" id="kobo.329.1"> method blocks the execution of the current thread until at least the specified time point (the actual duration of the sleep may be longer than requested due to scheduling).</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.330.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.331.1">std::thread</span></code><span class="koboSpan" id="kobo.332.1"> class requires the </span><code class="inlineCode"><span class="koboSpan" id="kobo.333.1">join()</span></code><span class="koboSpan" id="kobo.334.1"> method to be called explicitly to wait for the thread to finish. </span><span class="koboSpan" id="kobo.334.2">This can lead to programming errors (as detailed above). </span><span class="koboSpan" id="kobo.334.3">The C++20 standard provides a new thread class, called </span><code class="inlineCode"><span class="koboSpan" id="kobo.335.1">std::jthread</span></code><span class="koboSpan" id="kobo.336.1">, that solves this inconvenience. </span><span class="koboSpan" id="kobo.336.2">This will be the topic of the </span><em class="italic"><span class="koboSpan" id="kobo.337.1">Using joinable threads and cancellation mechanisms</span></em><span class="koboSpan" id="kobo.338.1"> recipe, later in this chapter.</span></p>
<h2 class="heading-2" id="_idParaDest-498"><span class="koboSpan" id="kobo.339.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.340.1">Synchronizing access to shared data with mutexes and locks</span></em><span class="koboSpan" id="kobo.341.1">, to see what mechanisms are available for synchronizing thread access to shared data and how they work</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.342.1">Finding alternatives for recursive mutexes</span></em><span class="koboSpan" id="kobo.343.1">, to learn why recursive mutexes should be avoided, and also how to transform a thread-safe type using a recursive mutex into a thread-safe type using a non-recursive mutex</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.344.1">Handling exceptions from thread functions</span></em><span class="koboSpan" id="kobo.345.1">, to understand how to handle exceptions thrown in a worker thread from the main thread or the thread where it was joined</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.346.1">Sending notifications between threads</span></em><span class="koboSpan" id="kobo.347.1">, to see how to use condition variables to send notifications between producer and consumer threads</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.348.1">Using promises and futures to return values from threads</span></em><span class="koboSpan" id="kobo.349.1">, to learn how to use a </span><code class="inlineCode"><span class="koboSpan" id="kobo.350.1">std::promise</span></code><span class="koboSpan" id="kobo.351.1"> object to return a value or an exception from a thread</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-499"><span class="koboSpan" id="kobo.352.1">Synchronizing access to shared data with mutexes and locks</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.353.1">Threads</span><a id="_idIndexMarker954"/><span class="koboSpan" id="kobo.354.1"> allow you to execute multiple functions at the same time, but it is often necessary that these functions access shared resources. </span><span class="koboSpan" id="kobo.354.2">Access to shared resources must be synchronized so that only one thread can read or write from or to the shared resource at a time. </span><span class="koboSpan" id="kobo.354.3">In this recipe, we will see what mechanisms the C++ standard defines for synchronizing thread access to shared data and how they work.</span></p>
<h2 class="heading-2" id="_idParaDest-500"><span class="koboSpan" id="kobo.355.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.356.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.357.1">mutex</span></code><span class="koboSpan" id="kobo.358.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.359.1">lock</span></code><span class="koboSpan" id="kobo.360.1"> classes discussed in this recipe are available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.361.1">std</span></code><span class="koboSpan" id="kobo.362.1"> namespace in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.363.1">&lt;mutex&gt;</span></code><span class="koboSpan" id="kobo.364.1"> header, and, respectively, </span><code class="inlineCode"><span class="koboSpan" id="kobo.365.1">&lt;shared_mutex&gt;</span></code><span class="koboSpan" id="kobo.366.1"> for C++14 shared mutexes and locks.</span></p>
<h2 class="heading-2" id="_idParaDest-501"><span class="koboSpan" id="kobo.367.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.368.1">Use the following pattern for synchronizing access with a single shared resource:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.369.1">Define a </span><code class="inlineCode"><span class="koboSpan" id="kobo.370.1">mutex</span></code><span class="koboSpan" id="kobo.371.1"> in the appropriate context (class or global scope):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.372.1">std::mutex g_mutex;
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.373.1">Acquire a </span><code class="inlineCode"><span class="koboSpan" id="kobo.374.1">lock</span></code><span class="koboSpan" id="kobo.375.1"> on this </span><code class="inlineCode"><span class="koboSpan" id="kobo.376.1">mutex</span></code><span class="koboSpan" id="kobo.377.1"> before accessing the shared resource in each thread:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.378.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.379.1">thread_func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.380.1">()</span></span><span class="koboSpan" id="kobo.381.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.382.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.383.1">namespace</span></span><span class="koboSpan" id="kobo.384.1"> std::chrono_literals;
  {
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.385.1">std::lock_guard&lt;std::mutex&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.386.1">lock</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.387.1">(g_mutex)</span></span><span class="koboSpan" id="kobo.388.1">;
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.389.1">"running thread "</span></span><span class="koboSpan" id="kobo.390.1"> 
              &lt;&lt; std::this_thread::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.391.1">get_id</span></span><span class="koboSpan" id="kobo.392.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.393.1">'\n'</span></span><span class="koboSpan" id="kobo.394.1">;
  }
  std::this_thread::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.395.1">yield</span></span><span class="koboSpan" id="kobo.396.1">();
  std::this_thread::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.397.1">sleep_for</span></span><span class="koboSpan" id="kobo.398.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.399.1">2</span></span><span class="koboSpan" id="kobo.400.1">s);
  {
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.401.1">std::lock_guard&lt;std::mutex&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.402.1">lock</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.403.1">(g_mutex)</span></span><span class="koboSpan" id="kobo.404.1">;
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.405.1">"done in thread "</span></span><span class="koboSpan" id="kobo.406.1"> 
              &lt;&lt; std::this_thread::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.407.1">get_id</span></span><span class="koboSpan" id="kobo.408.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.409.1">'\n'</span></span><span class="koboSpan" id="kobo.410.1">;
  }
}
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.411.1">Use the following pattern for synchronizing access to multiple shared resources at the same time to avoid deadlocks:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.412.1">Define a </span><a id="_idIndexMarker955"/><span class="koboSpan" id="kobo.413.1">mutex for each shared resource in the appropriate context (global or class scope):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.414.1">template</span></span><span class="koboSpan" id="kobo.415.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.416.1">typename</span></span><span class="koboSpan" id="kobo.417.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.418.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.419.1">container</span></span><span class="koboSpan" id="kobo.420.1">
{
  std::mutex     mutex;
  std::vector&lt;T&gt; data;
};
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.421.1">Lock the mutexes at the same time using a deadlock avoidance algorithm with </span><code class="inlineCode"><span class="koboSpan" id="kobo.422.1">std::lock()</span></code><span class="koboSpan" id="kobo.423.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.424.1">template</span></span><span class="koboSpan" id="kobo.425.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.426.1">typename</span></span><span class="koboSpan" id="kobo.427.1"> T&gt;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.428.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.429.1">move_between</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.430.1">(container&lt;T&gt; &amp; c1, container&lt;T&gt; &amp; c2, </span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.431.1">                  T </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.432.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.433.1"> value)</span></span><span class="koboSpan" id="kobo.434.1">
{
  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.435.1">lock</span></span><span class="koboSpan" id="kobo.436.1">(c1.mutex, c2.mutex);
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.437.1">// continued at 3.</span></span><span class="koboSpan" id="kobo.438.1">
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.439.1">After locking them, adopt the ownership of each mutex into a </span><code class="inlineCode"><span class="koboSpan" id="kobo.440.1">std::lock_guard</span></code><span class="koboSpan" id="kobo.441.1"> class to ensure they are safely released at the end of the function (or scope):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.442.1">// continued from 2.</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.443.1">std::lock_guard&lt;std::mutex&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.444.1">l1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.445.1">(c1.mutex, std::adopt_lock)</span></span><span class="koboSpan" id="kobo.446.1">;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.447.1">std::lock_guard&lt;std::mutex&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.448.1">l2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.449.1">(c2.mutex, std::adopt_lock)</span></span><span class="koboSpan" id="kobo.450.1">;
c1.data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.451.1">erase</span></span><span class="koboSpan" id="kobo.452.1">(
  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.453.1">remove</span></span><span class="koboSpan" id="kobo.454.1">(c1.data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.455.1">begin</span></span><span class="koboSpan" id="kobo.456.1">(), c1.data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.457.1">end</span></span><span class="koboSpan" id="kobo.458.1">(), value), 
  c1.data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.459.1">end</span></span><span class="koboSpan" id="kobo.460.1">());
c2.data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.461.1">push_back</span></span><span class="koboSpan" id="kobo.462.1">(value);
</span></code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-502"><span class="koboSpan" id="kobo.463.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.464.1">A </span><strong class="keyWord"><span class="koboSpan" id="kobo.465.1">mutex </span></strong><span class="koboSpan" id="kobo.466.1">(</span><strong class="keyWord"><span class="koboSpan" id="kobo.467.1">mutual exclusion</span></strong><span class="koboSpan" id="kobo.468.1">) is a </span><a id="_idIndexMarker956"/><span class="koboSpan" id="kobo.469.1">synchronization primitive that allows us to protect simultaneous access to shared resources from multiple threads. </span><span class="koboSpan" id="kobo.469.2">The C++ standard library provides</span><a id="_idIndexMarker957"/><span class="koboSpan" id="kobo.470.1"> several implementations:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.471.1">std::mutex</span></code><span class="koboSpan" id="kobo.472.1"> is the most commonly used mutex type; it is illustrated in the preceding code snippet. </span><span class="koboSpan" id="kobo.472.2">It provides methods to acquire and release the mutex. </span><code class="inlineCode"><span class="koboSpan" id="kobo.473.1">lock()</span></code><span class="koboSpan" id="kobo.474.1"> tries to acquire the mutex and blocks it if it is not available, </span><code class="inlineCode"><span class="koboSpan" id="kobo.475.1">try_lock()</span></code><span class="koboSpan" id="kobo.476.1"> tries to acquire the mutex and returns it without blocking if the mutex is not available, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.477.1">unlock()</span></code><span class="koboSpan" id="kobo.478.1"> releases the mutex.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.479.1">std::timed_mutex</span></code><span class="koboSpan" id="kobo.480.1"> is similar to </span><code class="inlineCode"><span class="koboSpan" id="kobo.481.1">std::mutex</span></code><span class="koboSpan" id="kobo.482.1"> but provides two more methods to acquire the mutex using a timeout: </span><code class="inlineCode"><span class="koboSpan" id="kobo.483.1">try_lock_for()</span></code><span class="koboSpan" id="kobo.484.1"> tries to acquire the mutex and returns it if the mutex is not made available during the specified duration, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.485.1">try_lock_until()</span></code><span class="koboSpan" id="kobo.486.1"> tries to acquire the mutex and returns it if the mutex is not made available until a specified time point.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.487.1">std::recursive_mutex</span></code><span class="koboSpan" id="kobo.488.1"> is similar to </span><code class="inlineCode"><span class="koboSpan" id="kobo.489.1">std::mutex</span></code><span class="koboSpan" id="kobo.490.1">, but the mutex can be acquired multiple times from the same thread without being blocked.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.491.1">std::recursive_timed_mutex</span></code><span class="koboSpan" id="kobo.492.1"> is a combination of a recursive mutex and a timed mutex.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.493.1">std::shared_timed_mutex</span></code><span class="koboSpan" id="kobo.494.1">, since C++14, is to be used in scenarios when multiple readers can access the same resource at the same time without causing data races, while only one writer is allowed to do so. </span><span class="koboSpan" id="kobo.494.2">It implements locking with two levels of access – </span><em class="italic"><span class="koboSpan" id="kobo.495.1">shared</span></em><span class="koboSpan" id="kobo.496.1"> (several threads can share the ownership of the same mutex) and </span><em class="italic"><span class="koboSpan" id="kobo.497.1">exclusive</span></em><span class="koboSpan" id="kobo.498.1"> (only one thread can own the mutex) – and provides timeout facilities.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.499.1">std::shared_mutex</span></code><span class="koboSpan" id="kobo.500.1">, since C++17, is similar to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.501.1">shared_timed_mutex</span></code><span class="koboSpan" id="kobo.502.1"> but without the timeout facilities.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.503.1">The first </span><a id="_idIndexMarker958"/><span class="koboSpan" id="kobo.504.1">thread that locks an available mutex takes ownership of it and continues with the execution. </span><span class="koboSpan" id="kobo.504.2">All consecutive attempts to lock the mutex from any thread fail, including the thread that already owns the mutex, and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.505.1">lock()</span></code><span class="koboSpan" id="kobo.506.1"> method blocks the thread until the mutex is released with a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.507.1">unlock()</span></code><span class="koboSpan" id="kobo.508.1">. </span><span class="koboSpan" id="kobo.508.2">If a thread needs to be able to lock a mutex multiple times without blocking it and therefore enter a deadlock, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.509.1">recursive_mutex</span></code><span class="koboSpan" id="kobo.510.1"> class template should be used.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.511.1">The typical use of a mutex to</span><a id="_idIndexMarker959"/><span class="koboSpan" id="kobo.512.1"> protect access to a shared resource comprises locking the mutex, using the shared resource, and then unlocking the mutex:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.513.1">g_mutex.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.514.1">lock</span></span><span class="koboSpan" id="kobo.515.1">();
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.516.1">// use the shared resource such as std::cout</span></span><span class="koboSpan" id="kobo.517.1">
std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.518.1">"accessing shared resource"</span></span><span class="koboSpan" id="kobo.519.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.520.1">'\n'</span></span><span class="koboSpan" id="kobo.521.1">;
g_mutex.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.522.1">unlock</span></span><span class="koboSpan" id="kobo.523.1">();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.524.1">This method of using the mutex is, however, prone to error. </span><span class="koboSpan" id="kobo.524.2">This is because each call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.525.1">lock()</span></code><span class="koboSpan" id="kobo.526.1"> must be paired with a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.527.1">unlock()</span></code><span class="koboSpan" id="kobo.528.1"> on all execution paths; that is, both normal return paths and exception return paths. </span><span class="koboSpan" id="kobo.528.2">In order to safely acquire and release a mutex, regardless of the way the execution of a function goes, the C++ standard defines several locking classes:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.529.1">std::lock_guard</span></code><span class="koboSpan" id="kobo.530.1"> is the locking mechanism seen earlier; it represents a mutex wrapper implemented in an RAII manner. </span><span class="koboSpan" id="kobo.530.2">It attempts to acquire the mutex at the time of its construction and release it upon destruction. </span><span class="koboSpan" id="kobo.530.3">This is available in C++11. </span><span class="koboSpan" id="kobo.530.4">The following is a typical implementation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.531.1">lock_guard</span></code><span class="koboSpan" id="kobo.532.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.533.1">template</span></span><span class="koboSpan" id="kobo.534.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.535.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.536.1">M</span></span><span class="koboSpan" id="kobo.537.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.538.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.539.1">lock_guard</span></span><span class="koboSpan" id="kobo.540.1">
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.541.1">public</span></span><span class="koboSpan" id="kobo.542.1">:
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.543.1">typedef</span></span><span class="koboSpan" id="kobo.544.1"> M mutex_type;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.545.1">explicit</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.546.1">lock_guard</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.547.1">(M&amp; Mtx)</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.548.1"> : mtx(Mtx)</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.549.1">  {</span></span><span class="koboSpan" id="kobo.550.1">
    mtx.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.551.1">lock</span></span><span class="koboSpan" id="kobo.552.1">();
  }
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.553.1">lock_guard</span></span><span class="koboSpan" id="kobo.554.1">(M&amp; Mtx, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.555.1">adopt_lock_t</span></span><span class="koboSpan" id="kobo.556.1">) : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.557.1">mtx</span></span><span class="koboSpan" id="kobo.558.1">(Mtx)
  { }
  ~</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.559.1">lock_guard</span></span><span class="koboSpan" id="kobo.560.1">() </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.561.1">noexcept</span></span><span class="koboSpan" id="kobo.562.1">
  {
    mtx.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.563.1">unlock</span></span><span class="koboSpan" id="kobo.564.1">();
  }
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.565.1">lock_guard</span></span><span class="koboSpan" id="kobo.566.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.567.1">const</span></span><span class="koboSpan" id="kobo.568.1"> lock_guard&amp;) = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.569.1">delete</span></span><span class="koboSpan" id="kobo.570.1">;
  lock_guard&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.571.1">operator</span></span><span class="koboSpan" id="kobo.572.1">=(</span><span class="hljs-type"><span class="koboSpan" id="kobo.573.1">const</span></span><span class="koboSpan" id="kobo.574.1"> lock_guard&amp;) = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.575.1">delete</span></span><span class="koboSpan" id="kobo.576.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.577.1">private</span></span><span class="koboSpan" id="kobo.578.1">:
  M&amp; mtx;
};
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.579.1">std::unique_lock</span></code><span class="koboSpan" id="kobo.580.1"> is a mutex ownership wrapper that provides support for deferred locking, time locking, recursive locking, transfer of ownership, and using it with condition variables. </span><span class="koboSpan" id="kobo.580.2">This is available in C++11.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.581.1">std::shared_lock</span></code><span class="koboSpan" id="kobo.582.1"> is a mutex-shared ownership wrapper that provides support for deferred locking, time locking, and transfer of ownership. </span><span class="koboSpan" id="kobo.582.2">This is available in C++14.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.583.1">std::scoped_lock</span></code><span class="koboSpan" id="kobo.584.1"> is a wrapper for multiple mutexes implemented in an RAII manner. </span><span class="koboSpan" id="kobo.584.2">Upon construction, it attempts to acquire ownership of the mutexes in a deadlock avoidance manner as if it is using </span><code class="inlineCode"><span class="koboSpan" id="kobo.585.1">std::lock()</span></code><span class="koboSpan" id="kobo.586.1">, and upon destruction, it releases the mutexes in reverse order of the way they were acquired. </span><span class="koboSpan" id="kobo.586.2">This is available in C++17.</span></li>
</ul>
<div class="note">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.587.1">RAII</span></strong><span class="koboSpan" id="kobo.588.1">, which stands for </span><strong class="keyWord"><span class="koboSpan" id="kobo.589.1">Resource Acquisition Is Initialization</span></strong><span class="koboSpan" id="kobo.590.1">, is a programming technique </span><a id="_idIndexMarker960"/><span class="koboSpan" id="kobo.591.1">used in some programming languages, including C++, that simplifies resource management, ensures program correctness, and reduces code size. </span><span class="koboSpan" id="kobo.591.2">This technique binds the life cycle of a resource to an object. </span><span class="koboSpan" id="kobo.591.3">The allocation, also referred to as the acquisition, of a resource is done during the creation of the object (in the constructor) and the release of the resource (deallocation) is done when the object is destroyed (in the destructor). </span><span class="koboSpan" id="kobo.591.4">This ensures resources do not leak, provided that the bound objects are not themselves leaked. </span><span class="koboSpan" id="kobo.591.5">For more information about RAII, see </span><a href="https://en.cppreference.com/w/cpp/language/raii"><span class="url"><span class="koboSpan" id="kobo.592.1">https://en.cppreference.com/w/cpp/language/raii</span></span></a><span class="koboSpan" id="kobo.593.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.594.1">In the first example in the </span><em class="italic"><span class="koboSpan" id="kobo.595.1">How to do it...</span></em><span class="koboSpan" id="kobo.596.1"> section, we used </span><code class="inlineCode"><span class="koboSpan" id="kobo.597.1">std::mutex</span></code><span class="koboSpan" id="kobo.598.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.599.1">std::lock_guard</span></code><span class="koboSpan" id="kobo.600.1"> to protect access to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.601.1">std::cout</span></code><span class="koboSpan" id="kobo.602.1"> stream object, which is shared between </span><a id="_idIndexMarker961"/><span class="koboSpan" id="kobo.603.1">all the threads in a program. </span><span class="koboSpan" id="kobo.603.2">The following example shows how the </span><code class="inlineCode"><span class="koboSpan" id="kobo.604.1">thread_func()</span></code><span class="koboSpan" id="kobo.605.1"> function can be executed concurrently on several threads:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.606.1">std::vector&lt;std::thread&gt; threads;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.607.1">for</span></span><span class="koboSpan" id="kobo.608.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.609.1">int</span></span><span class="koboSpan" id="kobo.610.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.611.1">0</span></span><span class="koboSpan" id="kobo.612.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.613.1">5</span></span><span class="koboSpan" id="kobo.614.1">; ++i)
  threads.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.615.1">emplace_back</span></span><span class="koboSpan" id="kobo.616.1">(thread_func);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.617.1">for</span></span><span class="koboSpan" id="kobo.618.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.619.1">auto</span></span><span class="koboSpan" id="kobo.620.1"> &amp; t : threads)
  t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.621.1">join</span></span><span class="koboSpan" id="kobo.622.1">();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.623.1">A possible output for this program is as follows:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.624.1">running thread 140296854550272
running thread 140296846157568
running thread 140296837764864
running thread 140296829372160
running thread 140296820979456
done in thread 140296854550272
done in thread 140296846157568
done in thread 140296837764864
done in thread 140296820979456
done in thread 140296829372160
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.625.1">When a thread needs to take ownership of multiple mutexes that are meant to protect multiple shared resources, acquiring them one by one may lead to deadlocks. </span><span class="koboSpan" id="kobo.625.2">Let’s consider the following example (where </span><code class="inlineCode"><span class="koboSpan" id="kobo.626.1">container</span></code><span class="koboSpan" id="kobo.627.1"> is the class shown in the </span><em class="italic"><span class="koboSpan" id="kobo.628.1">How to do it...</span></em><span class="koboSpan" id="kobo.629.1"> section):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.630.1">template</span></span><span class="koboSpan" id="kobo.631.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.632.1">typename</span></span><span class="koboSpan" id="kobo.633.1"> T&gt;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.634.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.635.1">move_between</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.636.1">(container&lt;T&gt; &amp; c1, container&lt;T&gt; &amp; c2, T </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.637.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.638.1"> value)</span></span><span class="koboSpan" id="kobo.639.1">
{
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.640.1">std::lock_guard&lt;std::mutex&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.641.1">l1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.642.1">(c1.mutex)</span></span><span class="koboSpan" id="kobo.643.1">;
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.644.1">std::lock_guard&lt;std::mutex&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.645.1">l2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.646.1">(c2.mutex)</span></span><span class="koboSpan" id="kobo.647.1">;
  c1.data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.648.1">erase</span></span><span class="koboSpan" id="kobo.649.1">(
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.650.1">remove</span></span><span class="koboSpan" id="kobo.651.1">(c1.data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.652.1">begin</span></span><span class="koboSpan" id="kobo.653.1">(), c1.data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.654.1">end</span></span><span class="koboSpan" id="kobo.655.1">(), value), 
    c1.data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.656.1">end</span></span><span class="koboSpan" id="kobo.657.1">());
  c2.data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.658.1">push_back</span></span><span class="koboSpan" id="kobo.659.1">(value);
}
container&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.660.1">int</span></span><span class="koboSpan" id="kobo.661.1">&gt; c1;
c1.data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.662.1">push_back</span></span><span class="koboSpan" id="kobo.663.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.664.1">1</span></span><span class="koboSpan" id="kobo.665.1">);
c1.data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.666.1">push_back</span></span><span class="koboSpan" id="kobo.667.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.668.1">2</span></span><span class="koboSpan" id="kobo.669.1">);
c1.data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.670.1">push_back</span></span><span class="koboSpan" id="kobo.671.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.672.1">3</span></span><span class="koboSpan" id="kobo.673.1">);
container&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.674.1">int</span></span><span class="koboSpan" id="kobo.675.1">&gt; c2;
c2.data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.676.1">push_back</span></span><span class="koboSpan" id="kobo.677.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.678.1">4</span></span><span class="koboSpan" id="kobo.679.1">);
c2.data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.680.1">push_back</span></span><span class="koboSpan" id="kobo.681.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.682.1">5</span></span><span class="koboSpan" id="kobo.683.1">);
c2.data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.684.1">push_back</span></span><span class="koboSpan" id="kobo.685.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.686.1">6</span></span><span class="koboSpan" id="kobo.687.1">);
</span><span class="hljs-function"><span class="koboSpan" id="kobo.688.1">std::thread </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.689.1">t1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.690.1">(move_between&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.691.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.692.1">&gt;, std::ref(c1), std::ref(c2), </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.693.1">3</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.694.1">)</span></span><span class="koboSpan" id="kobo.695.1">;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.696.1">std::thread </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.697.1">t2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.698.1">(move_between&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.699.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.700.1">&gt;, std::ref(c2), std::ref(c1), </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.701.1">6</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.702.1">)</span></span><span class="koboSpan" id="kobo.703.1">;
t1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.704.1">join</span></span><span class="koboSpan" id="kobo.705.1">();
t2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.706.1">join</span></span><span class="koboSpan" id="kobo.707.1">();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.708.1">In this </span><a id="_idIndexMarker962"/><span class="koboSpan" id="kobo.709.1">example, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.710.1">container</span></code><span class="koboSpan" id="kobo.711.1"> class holds data that may be accessed simultaneously from different threads; therefore, it needs to be protected by acquiring a mutex. </span><span class="koboSpan" id="kobo.711.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.712.1">move_between()</span></code><span class="koboSpan" id="kobo.713.1"> function is a thread-safe function that removes an element from a container and adds it to a second container. </span><span class="koboSpan" id="kobo.713.2">To do so, it acquires the mutexes of the two containers sequentially, then erases the element from the first container and adds it to the end of the second container.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.714.1">This function is, however, prone to deadlocks because a race condition might be triggered while acquiring the locks. </span><span class="koboSpan" id="kobo.714.2">Suppose we have a scenario where two different threads execute this function, but with different arguments:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.715.1">The first thread starts executing with the arguments </span><code class="inlineCode"><span class="koboSpan" id="kobo.716.1">c1</span></code><span class="koboSpan" id="kobo.717.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.718.1">c2</span></code><span class="koboSpan" id="kobo.719.1"> in this order.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.720.1">The first thread is suspended after it acquires the lock for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.721.1">c1</span></code><span class="koboSpan" id="kobo.722.1"> container. </span><span class="koboSpan" id="kobo.722.2">The second thread starts executing with the arguments </span><code class="inlineCode"><span class="koboSpan" id="kobo.723.1">c2</span></code><span class="koboSpan" id="kobo.724.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.725.1">c1</span></code><span class="koboSpan" id="kobo.726.1"> in this order.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.727.1">The second thread is suspended after it acquires the lock for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.728.1">c2</span></code><span class="koboSpan" id="kobo.729.1"> container.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.730.1">The first thread continues the execution and tries to acquire the mutex for </span><code class="inlineCode"><span class="koboSpan" id="kobo.731.1">c2</span></code><span class="koboSpan" id="kobo.732.1">, but the mutex is unavailable. </span><span class="koboSpan" id="kobo.732.2">Therefore, a deadlock occurs (this can be simulated by putting the thread to sleep for a short while after it acquires the first mutex).</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.733.1">To avoid possible deadlocks such as these, mutexes should be acquired in a deadlock avoidance manner, and the standard library provides a utility function called </span><code class="inlineCode"><span class="koboSpan" id="kobo.734.1">std::lock()</span></code><span class="koboSpan" id="kobo.735.1"> that does that. </span><span class="koboSpan" id="kobo.735.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.736.1">move_between()</span></code><span class="koboSpan" id="kobo.737.1"> function needs to change by replacing the two locks with the following code (as shown in the </span><em class="italic"><span class="koboSpan" id="kobo.738.1">How to do it...</span></em><span class="koboSpan" id="kobo.739.1"> section):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.740.1">std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.741.1">lock</span></span><span class="koboSpan" id="kobo.742.1">(c1.mutex, c2.mutex);
</span><span class="hljs-function"><span class="koboSpan" id="kobo.743.1">std::lock_guard&lt;std::mutex&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.744.1">l1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.745.1">(c1.mutex, std::adopt_lock)</span></span><span class="koboSpan" id="kobo.746.1">;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.747.1">std::lock_guard&lt;std::mutex&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.748.1">l2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.749.1">(c2.mutex, std::adopt_lock)</span></span><span class="koboSpan" id="kobo.750.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.751.1">The </span><a id="_idIndexMarker963"/><span class="koboSpan" id="kobo.752.1">ownership of the mutexes must still be transferred to a lock guard object so they are properly released after the execution of the function ends (or, depending on the case, when a particular scope ends).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.753.1">In C++17, a new mutex wrapper is available, </span><code class="inlineCode"><span class="koboSpan" id="kobo.754.1">std::scoped_lock</span></code><span class="koboSpan" id="kobo.755.1">, that can be used to simplify code, such as the one in the preceding example. </span><span class="koboSpan" id="kobo.755.2">This type of lock can acquire the ownership of multiple mutexes in a deadlock-free manner. </span><span class="koboSpan" id="kobo.755.3">These mutexes are released when the scoped lock is destroyed. </span><span class="koboSpan" id="kobo.755.4">The preceding code is equivalent to the following single line of code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.756.1">std::scoped_lock </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.757.1">lock</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.758.1">(c1.mutex, c2.mutex)</span></span><span class="koboSpan" id="kobo.759.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.760.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.761.1">scoped_lock</span></code><span class="koboSpan" id="kobo.762.1"> class provides a simplified mechanism for owning one or more mutexes for the duration of a scoped block and also helps with writing simple and more robust code.</span></p>
<h2 class="heading-2" id="_idParaDest-503"><span class="koboSpan" id="kobo.763.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.764.1">Working with threads</span></em><span class="koboSpan" id="kobo.765.1">, to learn about the </span><code class="inlineCode"><span class="koboSpan" id="kobo.766.1">std::thread</span></code><span class="koboSpan" id="kobo.767.1"> class and the basic operations for working with threads in C++</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.768.1">Using joinable threads and cancellation mechanisms</span></em><span class="koboSpan" id="kobo.769.1">, to learn about the C++20 </span><code class="inlineCode"><span class="koboSpan" id="kobo.770.1">std::jthread</span></code><span class="koboSpan" id="kobo.771.1"> class, which manages a thread of execution and automatically joins during its destruction, as well as the improved mechanisms for stopping the execution of threads</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.772.1">Finding alternatives for recursive mutexes</span></em><span class="koboSpan" id="kobo.773.1">, to learn why recursive mutexes should be avoided and how to transform a thread-safe type using a recursive mutex into a thread-safe type using a non-recursive mutex</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-504"><span class="koboSpan" id="kobo.774.1">Finding alternatives for recursive mutexes</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.775.1">The </span><a id="_idIndexMarker964"/><span class="koboSpan" id="kobo.776.1">standard library provides several mutex types for protecting access to shared resources. </span><code class="inlineCode"><span class="koboSpan" id="kobo.777.1">std::recursive_mutex</span></code><span class="koboSpan" id="kobo.778.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.779.1">std::recursive_timed_mutex</span></code><span class="koboSpan" id="kobo.780.1"> are two implementations that allow you to use multiple locking in the same thread. </span><span class="koboSpan" id="kobo.780.2">A typical use for a recursive mutex is to protect access to a shared resource from a recursive function. </span><span class="koboSpan" id="kobo.780.3">A </span><code class="inlineCode"><span class="koboSpan" id="kobo.781.1">std::recursive_mutex</span></code><span class="koboSpan" id="kobo.782.1"> class may be locked multiple times from a thread, either with a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.783.1">lock()</span></code><span class="koboSpan" id="kobo.784.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.785.1">try_lock()</span></code><span class="koboSpan" id="kobo.786.1">. </span><span class="koboSpan" id="kobo.786.2">When a thread locks an available recursive mutex, it acquires its ownership; as a result of this, consecutive attempts to lock the mutex from the same thread do not block the execution of the thread, creating a deadlock. </span><span class="koboSpan" id="kobo.786.3">The recursive mutex is, however, released only when an equal number of calls to </span><code class="inlineCode"><span class="koboSpan" id="kobo.787.1">unlock()</span></code><span class="koboSpan" id="kobo.788.1"> are made. </span><span class="koboSpan" id="kobo.788.2">Recursive mutexes may also have a greater overhead than non-recursive mutexes. </span><span class="koboSpan" id="kobo.788.3">For these reasons, when possible, they should be avoided. </span><span class="koboSpan" id="kobo.788.4">This recipe presents a use case for transforming a thread-safe type using a recursive mutex into a thread-safe type using a non-recursive mutex.</span></p>
<h2 class="heading-2" id="_idParaDest-505"><span class="koboSpan" id="kobo.789.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.790.1">You need to be familiar with the various mutexes and locks available in the standard library. </span><span class="koboSpan" id="kobo.790.2">I recommend that you read the previous recipe, </span><em class="italic"><span class="koboSpan" id="kobo.791.1">Synchronizing access to shared data with mutex and locks</span></em><span class="koboSpan" id="kobo.792.1">, to get an overview of them.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.793.1">For this recipe, we will consider the following class:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.794.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.795.1">foo_rec</span></span><span class="koboSpan" id="kobo.796.1">
{
  std::recursive_mutex m;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.797.1">int</span></span><span class="koboSpan" id="kobo.798.1"> data;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.799.1">public</span></span><span class="koboSpan" id="kobo.800.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.801.1">foo_rec</span></span><span class="koboSpan" id="kobo.802.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.803.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.804.1">const</span></span><span class="koboSpan" id="kobo.805.1"> d = </span><span class="hljs-number"><span class="koboSpan" id="kobo.806.1">0</span></span><span class="koboSpan" id="kobo.807.1">) : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.808.1">data</span></span><span class="koboSpan" id="kobo.809.1">(d) {}
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.810.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.811.1">update</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.812.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.813.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.814.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.815.1"> d)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.816.1">{
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.817.1">std::lock_guard&lt;std::recursive_mutex&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.818.1">lock</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.819.1">(m)</span></span><span class="koboSpan" id="kobo.820.1">;
    data = d;
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.821.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.822.1">update_with_return</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.823.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.824.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.825.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.826.1"> d)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.827.1">{
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.828.1">std::lock_guard&lt;std::recursive_mutex&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.829.1">lock</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.830.1">(m)</span></span><span class="koboSpan" id="kobo.831.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.832.1">auto</span></span><span class="koboSpan" id="kobo.833.1"> temp = data;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.834.1">update</span></span><span class="koboSpan" id="kobo.835.1">(d);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.836.1">return</span></span><span class="koboSpan" id="kobo.837.1"> temp;
  }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.838.1">The purpose of this recipe is to transform the </span><code class="inlineCode"><span class="koboSpan" id="kobo.839.1">foo_rec</span></code><span class="koboSpan" id="kobo.840.1"> class so we can avoid using </span><code class="inlineCode"><span class="koboSpan" id="kobo.841.1">std::recursive_mutex</span></code><span class="koboSpan" id="kobo.842.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-506"><span class="koboSpan" id="kobo.843.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.844.1">To transform </span><a id="_idIndexMarker965"/><span class="koboSpan" id="kobo.845.1">the preceding implementation into a thread-safe type using a non-recursive mutex, do this:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.846.1">Replace </span><code class="inlineCode"><span class="koboSpan" id="kobo.847.1">std::recursive_mutex</span></code><span class="koboSpan" id="kobo.848.1"> with </span><code class="inlineCode"><span class="koboSpan" id="kobo.849.1">std::mutex</span></code><span class="koboSpan" id="kobo.850.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.851.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.852.1">foo</span></span><span class="koboSpan" id="kobo.853.1">
{
  std::mutex m;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.854.1">int</span></span><span class="koboSpan" id="kobo.855.1">        data;
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.856.1">// continued at 2.</span></span><span class="koboSpan" id="kobo.857.1">
};
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.858.1">Define private non-thread-safe versions of the public methods or helper functions to be used in thread-safe public methods:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.859.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.860.1">internal_update</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.861.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.862.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.863.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.864.1"> d)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.865.1">{ data = d; }
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.866.1">// continued at 3.</span></span>
</code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.867.1">Rewrite the public methods to use the newly defined non-thread-safe private methods:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.868.1">public</span></span><span class="koboSpan" id="kobo.869.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.870.1">foo</span></span><span class="koboSpan" id="kobo.871.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.872.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.873.1">const</span></span><span class="koboSpan" id="kobo.874.1"> d = </span><span class="hljs-number"><span class="koboSpan" id="kobo.875.1">0</span></span><span class="koboSpan" id="kobo.876.1">) : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.877.1">data</span></span><span class="koboSpan" id="kobo.878.1">(d) {}
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.879.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.880.1">update</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.881.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.882.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.883.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.884.1"> d)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.885.1">{
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.886.1">std::lock_guard&lt;std::mutex&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.887.1">lock</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.888.1">(m)</span></span><span class="koboSpan" id="kobo.889.1">;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.890.1">internal_update</span></span><span class="koboSpan" id="kobo.891.1">(d);
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.892.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.893.1">update_with_return</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.894.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.895.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.896.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.897.1"> d)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.898.1">{
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.899.1">std::lock_guard&lt;std::mutex&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.900.1">lock</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.901.1">(m)</span></span><span class="koboSpan" id="kobo.902.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.903.1">auto</span></span><span class="koboSpan" id="kobo.904.1"> temp = data;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.905.1">internal_update</span></span><span class="koboSpan" id="kobo.906.1">(d);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.907.1">return</span></span><span class="koboSpan" id="kobo.908.1"> temp;
  }
</span></code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-507"><span class="koboSpan" id="kobo.909.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.910.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.911.1">foo_rec</span></code><span class="koboSpan" id="kobo.912.1"> class we</span><a id="_idIndexMarker966"/><span class="koboSpan" id="kobo.913.1"> just discussed uses a recursive mutex to protect access to shared data; in this case, it is an integer member variable that is accessed from two thread-safe public functions:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.914.1">update()</span></code><span class="koboSpan" id="kobo.915.1"> sets a new value in the private variable.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.916.1">update_and_return()</span></code><span class="koboSpan" id="kobo.917.1"> sets a new value in the private variable and returns the previous value to the called function. </span><span class="koboSpan" id="kobo.917.2">This function calls </span><code class="inlineCode"><span class="koboSpan" id="kobo.918.1">update()</span></code><span class="koboSpan" id="kobo.919.1"> to set the new value.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.920.1">The implementation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.921.1">foo_rec</span></code><span class="koboSpan" id="kobo.922.1"> was probably intended to avoid duplication of code, yet this particular approach is rather a design error that can be improved, as shown in the </span><em class="italic"><span class="koboSpan" id="kobo.923.1">How to do it...</span></em><span class="koboSpan" id="kobo.924.1"> section. </span><span class="koboSpan" id="kobo.924.2">Rather than reusing public thread-safe functions, we can provide private non-thread-safe functions that could then be called from the public interface.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.925.1">The same solution can be applied to other similar problems: define a non-thread-safe version of the code and then provide perhaps lightweight, thread-safe wrappers.</span></p>
<h2 class="heading-2" id="_idParaDest-508"><span class="koboSpan" id="kobo.926.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.927.1">Working with threads</span></em><span class="koboSpan" id="kobo.928.1">, to learn about the </span><code class="inlineCode"><span class="koboSpan" id="kobo.929.1">std::thread</span></code><span class="koboSpan" id="kobo.930.1"> class and the basic operations for working with threads in C++</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.931.1">Synchronizing access to shared data with mutexes and locks</span></em><span class="koboSpan" id="kobo.932.1">, to see what mechanisms are available for synchronizing thread access to shared data and how they work</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-509"><span class="koboSpan" id="kobo.933.1">Handling exceptions from thread functions</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.934.1">In the first </span><a id="_idIndexMarker967"/><span class="koboSpan" id="kobo.935.1">recipe, we introduced the thread support library and saw how to do some basic operations with threads. </span><span class="koboSpan" id="kobo.935.2">In that recipe, we briefly discussed exception handling in thread functions and mentioned that exceptions</span><a id="_idIndexMarker968"/><span class="koboSpan" id="kobo.936.1"> cannot be caught with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.937.1">try…catch</span></code><span class="koboSpan" id="kobo.938.1"> statement in the context where the thread was started. </span><span class="koboSpan" id="kobo.938.2">On the other hand, exceptions can be transported between threads within a </span><code class="inlineCode"><span class="koboSpan" id="kobo.939.1">std::exception_ptr</span></code><span class="koboSpan" id="kobo.940.1"> wrapper. </span><span class="koboSpan" id="kobo.940.2">In this recipe, we will see how to handle exceptions from thread functions.</span></p>
<h2 class="heading-2" id="_idParaDest-510"><span class="koboSpan" id="kobo.941.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.942.1">You are now familiar with the thread operations we discussed in the previous recipe, </span><em class="italic"><span class="koboSpan" id="kobo.943.1">Working with threads</span></em><span class="koboSpan" id="kobo.944.1">. </span><span class="koboSpan" id="kobo.944.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.945.1">exception_ptr</span></code><span class="koboSpan" id="kobo.946.1"> class is available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.947.1">std</span></code><span class="koboSpan" id="kobo.948.1"> namespace, which is in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.949.1">&lt;exception&gt;</span></code><span class="koboSpan" id="kobo.950.1"> header; </span><code class="inlineCode"><span class="koboSpan" id="kobo.951.1">mutex</span></code><span class="koboSpan" id="kobo.952.1"> (which we discussed in more detail previously) is also available in the same namespace but in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.953.1">&lt;mutex&gt;</span></code><span class="koboSpan" id="kobo.954.1"> header.</span></p>
<h2 class="heading-2" id="_idParaDest-511"><span class="koboSpan" id="kobo.955.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.956.1">To properly handle exceptions thrown in a worker thread from the main thread or the thread where it was joined, do the following (assuming multiple exceptions can be thrown from multiple threads):</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.957.1">Use a global container to hold instances of </span><code class="inlineCode"><span class="koboSpan" id="kobo.958.1">std::exception_ptr</span></code><span class="koboSpan" id="kobo.959.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.960.1">std::vector&lt;std::exception_ptr&gt; g_exceptions;
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.961.1">Use a global </span><code class="inlineCode"><span class="koboSpan" id="kobo.962.1">mutex</span></code><span class="koboSpan" id="kobo.963.1"> to synchronize access to the shared container:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.964.1">std::mutex g_mutex;
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.965.1">Use a </span><code class="inlineCode"><span class="koboSpan" id="kobo.966.1">try...catch</span></code><span class="koboSpan" id="kobo.967.1"> block for the code that is being executed in the top-level thread function. </span><span class="koboSpan" id="kobo.967.2">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.968.1">std::current_exception()</span></code><span class="koboSpan" id="kobo.969.1"> to capture the current exception and wrap a copy or its reference into a </span><code class="inlineCode"><span class="koboSpan" id="kobo.970.1">std::exception_ptr</span></code><span class="koboSpan" id="kobo.971.1"> pointer, which is added to the shared container for exceptions:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.972.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.973.1">func1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.974.1">()</span></span><span class="koboSpan" id="kobo.975.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.976.1">throw</span></span><span class="koboSpan" id="kobo.977.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.978.1">runtime_error</span></span><span class="koboSpan" id="kobo.979.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.980.1">"exception 1"</span></span><span class="koboSpan" id="kobo.981.1">);
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.982.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.983.1">func2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.984.1">()</span></span><span class="koboSpan" id="kobo.985.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.986.1">throw</span></span><span class="koboSpan" id="kobo.987.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.988.1">runtime_error</span></span><span class="koboSpan" id="kobo.989.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.990.1">"exception 2"</span></span><span class="koboSpan" id="kobo.991.1">);
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.992.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.993.1">thread_func1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.994.1">()</span></span><span class="koboSpan" id="kobo.995.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.996.1">try</span></span><span class="koboSpan" id="kobo.997.1">
  {
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.998.1">func1</span></span><span class="koboSpan" id="kobo.999.1">();
  }
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1000.1">catch</span></span><span class="koboSpan" id="kobo.1001.1"> (...)
  {
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.1002.1">std::lock_guard&lt;std::mutex&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1003.1">lock</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1004.1">(g_mutex)</span></span><span class="koboSpan" id="kobo.1005.1">;
    g_exceptions.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1006.1">push_back</span></span><span class="koboSpan" id="kobo.1007.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1008.1">current_exception</span></span><span class="koboSpan" id="kobo.1009.1">());
  }
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1010.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1011.1">thread_func2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1012.1">()</span></span><span class="koboSpan" id="kobo.1013.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1014.1">try</span></span><span class="koboSpan" id="kobo.1015.1">
  {
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1016.1">func2</span></span><span class="koboSpan" id="kobo.1017.1">();
  }
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1018.1">catch</span></span><span class="koboSpan" id="kobo.1019.1"> (...)
  {
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.1020.1">std::lock_guard&lt;std::mutex&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1021.1">lock</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1022.1">(g_mutex)</span></span><span class="koboSpan" id="kobo.1023.1">;
    g_exceptions.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1024.1">push_back</span></span><span class="koboSpan" id="kobo.1025.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1026.1">current_exception</span></span><span class="koboSpan" id="kobo.1027.1">());
  }
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1028.1">Clear </span><a id="_idIndexMarker969"/><span class="koboSpan" id="kobo.1029.1">the container from the main thread before you start the threads:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1030.1">g_exceptions.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1031.1">clear</span></span><span class="koboSpan" id="kobo.1032.1">();
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1033.1">In the </span><a id="_idIndexMarker970"/><span class="koboSpan" id="kobo.1034.1">main thread, after the execution of all the threads has finished, inspect the caught exceptions and handle each of them appropriately:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.1035.1">std::thread </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1036.1">t1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1037.1">(thread_func1)</span></span><span class="koboSpan" id="kobo.1038.1">;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.1039.1">std::thread </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1040.1">t2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1041.1">(thread_func2)</span></span><span class="koboSpan" id="kobo.1042.1">;
t1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1043.1">join</span></span><span class="koboSpan" id="kobo.1044.1">();
t2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1045.1">join</span></span><span class="koboSpan" id="kobo.1046.1">();
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1047.1">for</span></span><span class="koboSpan" id="kobo.1048.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1049.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1050.1">const</span></span><span class="koboSpan" id="kobo.1051.1"> &amp; e : g_exceptions)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1052.1">try</span></span><span class="koboSpan" id="kobo.1053.1">
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1054.1">if</span></span><span class="koboSpan" id="kobo.1055.1">(e)
      std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1056.1">rethrow_exception</span></span><span class="koboSpan" id="kobo.1057.1">(e);
  }
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1058.1">catch</span></span><span class="koboSpan" id="kobo.1059.1">(std::exception </span><span class="hljs-type"><span class="koboSpan" id="kobo.1060.1">const</span></span><span class="koboSpan" id="kobo.1061.1"> &amp; ex)
  {
    std::cout &lt;&lt; ex.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1062.1">what</span></span><span class="koboSpan" id="kobo.1063.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1064.1">'\n'</span></span><span class="koboSpan" id="kobo.1065.1">;
  }
}
</span></code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-512"><span class="koboSpan" id="kobo.1066.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1067.1">For the </span><a id="_idIndexMarker971"/><span class="koboSpan" id="kobo.1068.1">example in the preceding section, we assumed that multiple threads could throw exceptions and therefore need a container to hold them all. </span><span class="koboSpan" id="kobo.1068.2">If there is a single exception from a single thread at a time, then you do not need a shared container and a mutex to synchronize access to it. </span><span class="koboSpan" id="kobo.1068.3">You can use a single global object of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.1069.1">std::exception_ptr</span></code><span class="koboSpan" id="kobo.1070.1"> to hold the exception that’s transported between threads.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1071.1">std::current_exception()</span></code><span class="koboSpan" id="kobo.1072.1"> is a function that is typically used in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1073.1">catch</span></code><span class="koboSpan" id="kobo.1074.1"> clause to capture the </span><a id="_idIndexMarker972"/><span class="koboSpan" id="kobo.1075.1">current exception and create an instance of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1076.1">std::exception_ptr</span></code><span class="koboSpan" id="kobo.1077.1">. </span><span class="koboSpan" id="kobo.1077.2">This is done to hold a copy or reference (depending on the implementation) to the original exception, which remains valid as long as there is a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1078.1">std::exception_ptr</span></code><span class="koboSpan" id="kobo.1079.1"> pointer available that refers to it. </span><span class="koboSpan" id="kobo.1079.2">If this function is called when no exception is being handled, then it creates an empty </span><code class="inlineCode"><span class="koboSpan" id="kobo.1080.1">std::exception_ptr</span></code><span class="koboSpan" id="kobo.1081.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1082.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1083.1">std::exception_ptr</span></code><span class="koboSpan" id="kobo.1084.1"> pointer is a wrapper for an exception captured with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1085.1">std::current_exception()</span></code><span class="koboSpan" id="kobo.1086.1">. </span><span class="koboSpan" id="kobo.1086.2">If default constructed, it does not hold any exception; it is, in this case, a null pointer. </span><span class="koboSpan" id="kobo.1086.3">Two objects of this type are equal if they are both empty or point to the same exception object. </span><span class="koboSpan" id="kobo.1086.4">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1087.1">std::exception_ptr</span></code><span class="koboSpan" id="kobo.1088.1"> objects can be passed to other threads, where they can be rethrown and caught in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1089.1">try...catch</span></code><span class="koboSpan" id="kobo.1090.1"> block.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1091.1">std::rethrow_exception()</span></code><span class="koboSpan" id="kobo.1092.1"> is a function that takes </span><code class="inlineCode"><span class="koboSpan" id="kobo.1093.1">std::exception_ptr</span></code><span class="koboSpan" id="kobo.1094.1"> as an argument and throws the exception object referred to by its argument.</span></p>
<div class="note">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1095.1">std::current_exception()</span></code><span class="koboSpan" id="kobo.1096.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1097.1">std::rethrow_exception()</span></code><span class="koboSpan" id="kobo.1098.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1099.1">std::exception_ptr</span></code><span class="koboSpan" id="kobo.1100.1"> are all available in C++11.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1101.1">In the </span><a id="_idIndexMarker973"/><span class="koboSpan" id="kobo.1102.1">example from the previous section, each thread function uses a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1103.1">try...catch</span></code><span class="koboSpan" id="kobo.1104.1"> statement for the entire code it executes so that no exception may leave the function uncaught. </span><span class="koboSpan" id="kobo.1104.2">When an exception is handled, a lock on the global </span><code class="inlineCode"><span class="koboSpan" id="kobo.1105.1">mutex</span></code><span class="koboSpan" id="kobo.1106.1"> object is acquired and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1107.1">std::exception_ptr</span></code><span class="koboSpan" id="kobo.1108.1"> object holding the current exception is added to the shared container. </span><span class="koboSpan" id="kobo.1108.2">With this approach, the thread function stops at the first exception; however, in other circumstances, you may need to execute multiple operations, even if the previous one throws an exception. </span><span class="koboSpan" id="kobo.1108.3">In this case, you will have multiple </span><code class="inlineCode"><span class="koboSpan" id="kobo.1109.1">try...catch</span></code><span class="koboSpan" id="kobo.1110.1"> statements </span><a id="_idIndexMarker974"/><span class="koboSpan" id="kobo.1111.1">and perhaps transport only some of the exceptions outside the thread.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1112.1">In the main thread, after all the threads have finished executing, the container is iterated, and each non-empty exception is rethrown and caught with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1113.1">try...catch</span></code><span class="koboSpan" id="kobo.1114.1"> block and handled appropriately.</span></p>
<h2 class="heading-2" id="_idParaDest-513"><span class="koboSpan" id="kobo.1115.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1116.1">Working with threads</span></em><span class="koboSpan" id="kobo.1117.1">, to learn about the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1118.1">std::thread</span></code><span class="koboSpan" id="kobo.1119.1"> class and the basic operations for working with threads in C++</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1120.1">Synchronizing access to shared data with mutexes and locks</span></em><span class="koboSpan" id="kobo.1121.1">, to see what mechanisms are available for synchronizing thread access to shared data and how they work</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-514"><span class="koboSpan" id="kobo.1122.1">Sending notifications between threads</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1123.1">Mutexes are </span><a id="_idIndexMarker975"/><span class="koboSpan" id="kobo.1124.1">synchronization primitives that can be used to </span><a id="_idIndexMarker976"/><span class="koboSpan" id="kobo.1125.1">protect access to shared data. </span><span class="koboSpan" id="kobo.1125.2">However, the standard library provides a synchronization primitive, called a </span><em class="italic"><span class="koboSpan" id="kobo.1126.1">condition variable</span></em><span class="koboSpan" id="kobo.1127.1">, that enables a thread to signal to others that a certain condition has occurred. </span><span class="koboSpan" id="kobo.1127.2">The thread or threads that are waiting on the condition variable are blocked until the condition variable is signaled or until a timeout or a spurious wakeup occurs. </span><span class="koboSpan" id="kobo.1127.3">In this recipe, we will see how to use condition variables to send notifications between thread-producing data and thread-consuming data.</span></p>
<h2 class="heading-2" id="_idParaDest-515"><span class="koboSpan" id="kobo.1128.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1129.1">For this recipe, you need to be familiar with threads, mutexes, and locks. </span><span class="koboSpan" id="kobo.1129.2">Condition variables are available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1130.1">std</span></code><span class="koboSpan" id="kobo.1131.1"> namespace in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1132.1">&lt;condition_variable&gt;</span></code><span class="koboSpan" id="kobo.1133.1"> header.</span></p>
<h2 class="heading-2" id="_idParaDest-516"><span class="koboSpan" id="kobo.1134.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1135.1">Use the</span><a id="_idIndexMarker977"/><span class="koboSpan" id="kobo.1136.1"> following pattern for synchronizing threads with </span><a id="_idIndexMarker978"/><span class="koboSpan" id="kobo.1137.1">notifications on condition variables:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1138.1">Define a condition variable (in the appropriate context):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1139.1">std::condition_variable cv;
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1140.1">Define a mutex for threads to lock on. </span><span class="koboSpan" id="kobo.1140.2">A second mutex should be used for synchronizing access to the standard console from different threads:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1141.1">std::mutex data_mutex; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1142.1">// data mutex</span></span><span class="koboSpan" id="kobo.1143.1">
std::mutex io_mutex;   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1144.1">// I/O mutex</span></span>
</code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1145.1">Define the shared data used between the threads:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1146.1">int</span></span><span class="koboSpan" id="kobo.1147.1"> data = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1148.1">0</span></span><span class="koboSpan" id="kobo.1149.1">;
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1150.1">In the producing thread, lock the mutex before you modify the data:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.1151.1">std::thread </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1152.1">producer</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1153.1">([&amp;](){</span></span>
<span class="hljs-params"> </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1154.1">// simulate long running operation</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1155.1">  {</span></span>
<span class="hljs-params"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1156.1">using</span></span><span class="hljs-params"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1157.1">namespace</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1158.1"> std::chrono_literals;</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1159.1">    std::this_thread::sleep_for(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1160.1">2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1161.1">s);</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1162.1">  }</span></span>
<span class="hljs-params"> </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1163.1">// produce</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1164.1">  {</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1165.1">    std::unique_lock lock(data_mutex);</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1166.1">    data = </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1167.1">42</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1168.1">;</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1169.1">  }</span></span>
<span class="hljs-params"> </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1170.1">// print message</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1171.1">  {</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1172.1">    std::lock_guard l(io_mutex);</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1173.1">    std::cout &lt;&lt; </span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1174.1">"produced "</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1175.1"> &lt;&lt; data &lt;&lt; </span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1176.1">'\n'</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1177.1">;</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1178.1">  }</span></span>
<span class="hljs-params"> </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1179.1">// continued at 5.</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1180.1">})</span></span><span class="koboSpan" id="kobo.1181.1">;
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1182.1">In the producing thread, signal the condition variable with a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1183.1">notify_one()</span></code><span class="koboSpan" id="kobo.1184.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1185.1">notify_all()</span></code><span class="koboSpan" id="kobo.1186.1"> (do this after the mutex used to protect the shared data is unlocked):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1187.1">// continued from 4.</span></span><span class="koboSpan" id="kobo.1188.1">
cv.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1189.1">notify_one</span></span><span class="koboSpan" id="kobo.1190.1">();
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1191.1">In the </span><a id="_idIndexMarker979"/><span class="koboSpan" id="kobo.1192.1">consuming thread, acquire a unique </span><a id="_idIndexMarker980"/><span class="koboSpan" id="kobo.1193.1">lock on the data mutex and use it to wait on the condition variable. </span><span class="koboSpan" id="kobo.1193.2">Beware that spurious wakeups may occur, which is a subject we’ll discuss in detail in the </span><em class="italic"><span class="koboSpan" id="kobo.1194.1">How it works…</span></em><span class="koboSpan" id="kobo.1195.1"> section:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.1196.1">std::thread </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1197.1">consumer</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1198.1">([&amp;](){</span></span>
<span class="hljs-params"> </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1199.1">// wait for notification</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1200.1">  {</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1201.1">    std::unique_lock lock(data_mutex);</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1202.1">    cv.wait(lock);</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1203.1">  }</span></span>
<span class="hljs-params"> </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1204.1">// continued at 7.</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1205.1">})</span></span><span class="koboSpan" id="kobo.1206.1">;
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1207.1">In the consuming thread, use the shared data after the condition is notified:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1208.1">// continued from 6.</span></span><span class="koboSpan" id="kobo.1209.1">
{
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.1210.1">std::lock_guard </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1211.1">lock</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1212.1">(io_mutex)</span></span><span class="koboSpan" id="kobo.1213.1">;
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1214.1">"consumed "</span></span><span class="koboSpan" id="kobo.1215.1"> &lt;&lt; data &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1216.1">'\n'</span></span><span class="koboSpan" id="kobo.1217.1">;
}
</span></code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-517"><span class="koboSpan" id="kobo.1218.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1219.1">The preceding example represents two threads that share common data (in this case, an integer variable). </span><span class="koboSpan" id="kobo.1219.2">One thread produces data after a lengthy computation (simulated with a sleep), while the other consumes it only after it is produced. </span><span class="koboSpan" id="kobo.1219.3">To do so, they use a synchronization mechanism that uses a mutex and a condition variable that blocks the consuming thread until a notification arises from the producer thread, indicating that data has been made available. </span><span class="koboSpan" id="kobo.1219.4">The key in this communication channel is the condition variable that the consuming thread waits on until the producing thread notifies it. </span><span class="koboSpan" id="kobo.1219.5">Both threads start at about the same time. </span><span class="koboSpan" id="kobo.1219.6">The producer thread begins a long computation that is supposed </span><a id="_idIndexMarker981"/><span class="koboSpan" id="kobo.1220.1">to produce data for the consuming thread. </span><span class="koboSpan" id="kobo.1220.2">At the same time, the consuming thread cannot actually proceed until the data is made available; it must remain </span><a id="_idIndexMarker982"/><span class="koboSpan" id="kobo.1221.1">blocked until it is notified that the data has been produced. </span><span class="koboSpan" id="kobo.1221.2">Once notified, it can continue its execution. </span><span class="koboSpan" id="kobo.1221.3">The entire mechanism works as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1222.1">There must be at least one thread waiting on the condition variable to be notified.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1223.1">There must be at least one thread that is signaling the condition variable.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1224.1">The waiting threads must first acquire a lock on a mutex (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1225.1">std::unique_lock&lt;std::mutex&gt;</span></code><span class="koboSpan" id="kobo.1226.1">) and pass it to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1227.1">wait()</span></code><span class="koboSpan" id="kobo.1228.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1229.1">wait_for()</span></code><span class="koboSpan" id="kobo.1230.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1231.1">wait_until()</span></code><span class="koboSpan" id="kobo.1232.1"> method of the condition variable. </span><span class="koboSpan" id="kobo.1232.2">All the waiting methods atomically release the mutex and block the thread until the condition variable is signaled. </span><span class="koboSpan" id="kobo.1232.3">At this point, the thread is unblocked and the mutex is atomically acquired again (that means the operations involved are treated as a whole and the thread cannot be interrupted while performing them).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1233.1">The thread that signals the condition variable can do so with either </span><code class="inlineCode"><span class="koboSpan" id="kobo.1234.1">notify_one()</span></code><span class="koboSpan" id="kobo.1235.1">, where one blocked thread is unblocked, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1236.1">notify_all()</span></code><span class="koboSpan" id="kobo.1237.1">, where all the blocked threads waiting for the condition variable are unblocked.</span></li>
</ul>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1238.1">Condition variables cannot be made completely predictable on multiprocessor systems. </span><span class="koboSpan" id="kobo.1238.2">Therefore, </span><em class="italic"><span class="koboSpan" id="kobo.1239.1">spurious wakeups</span></em><span class="koboSpan" id="kobo.1240.1"> may occur, and a thread is unlocked even if nobody signals the condition variable. </span><span class="koboSpan" id="kobo.1240.2">So, it is necessary to check whether the condition is true after the thread has been unblocked. </span><span class="koboSpan" id="kobo.1240.3">However, spurious wakeups may occur multiple times and, therefore, it is necessary to check the condition variable in a loop. </span><span class="koboSpan" id="kobo.1240.4">You can learn more about spurious wakeups at </span><a href="https://en.wikipedia.org/wiki/Spurious_wakeup"><span class="url"><span class="koboSpan" id="kobo.1241.1">https://en.wikipedia.org/wiki/Spurious_wakeup</span></span></a><span class="koboSpan" id="kobo.1242.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1243.1">The C++ standard provides two implementations of condition variables:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1244.1">std::condition_variable</span></code><span class="koboSpan" id="kobo.1245.1">, used in this recipe, defines a condition variable associated with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1246.1">std::unique_lock</span></code><span class="koboSpan" id="kobo.1247.1">.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1248.1">std::condition_variable_any</span></code><span class="koboSpan" id="kobo.1249.1"> represents a more general implementation that works with any lock that meets the requirements of a basic lock (implements the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1250.1">lock()</span></code><span class="koboSpan" id="kobo.1251.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1252.1">unlock()</span></code><span class="koboSpan" id="kobo.1253.1"> methods). </span><span class="koboSpan" id="kobo.1253.2">A possible use of this implementation is providing interruptible waits, as explained by Anthony Williams in </span><em class="italic"><span class="koboSpan" id="kobo.1254.1">C++ Concurrency In Action</span></em><span class="koboSpan" id="kobo.1255.1"> (2012):</span></li>
</ul>
<blockquote class="packt_quote">
<p class="quote"><span class="koboSpan" id="kobo.1256.1">A custom lock operation would both lock the associated mutex as expected and also perform the necessary job of notifying this condition variable when the interrupting signal is received.</span></p>
</blockquote>
<p class="normal"><span class="koboSpan" id="kobo.1257.1">All the </span><a id="_idIndexMarker983"/><span class="koboSpan" id="kobo.1258.1">waiting </span><a id="_idIndexMarker984"/><span class="koboSpan" id="kobo.1259.1">methods of the condition variable have two overloads:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1260.1">The first overload takes </span><code class="inlineCode"><span class="koboSpan" id="kobo.1261.1">std::unique_lock&lt;std::mutex&gt;</span></code><span class="koboSpan" id="kobo.1262.1"> (based on the type; that is, duration or time point) and causes the thread to remain blocked until the condition variable is signaled. </span><span class="koboSpan" id="kobo.1262.2">This overload atomically releases the mutex and blocks the current thread, and then adds it to the list of threads waiting on the condition variable. </span><span class="koboSpan" id="kobo.1262.3">The thread is unblocked when the condition is notified with either </span><code class="inlineCode"><span class="koboSpan" id="kobo.1263.1">notify_one()</span></code><span class="koboSpan" id="kobo.1264.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1265.1">notify_all()</span></code><span class="koboSpan" id="kobo.1266.1">, a spurious wakeup occurs, or a timeout occurs (depending on the function overload). </span><span class="koboSpan" id="kobo.1266.2">When this happens, the mutex is atomically acquired again.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1267.1">The second overload takes a predicate in addition to the arguments of the other overloads. </span><span class="koboSpan" id="kobo.1267.2">This predicate can be used to avoid spurious wakeups while waiting for a condition to become </span><code class="inlineCode"><span class="koboSpan" id="kobo.1268.1">true</span></code><span class="koboSpan" id="kobo.1269.1">. </span><span class="koboSpan" id="kobo.1269.2">This overload is equivalent to the following:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1270.1">while</span></span><span class="koboSpan" id="kobo.1271.1">(!</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1272.1">pred</span></span><span class="koboSpan" id="kobo.1273.1">())
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1274.1">wait</span></span><span class="koboSpan" id="kobo.1275.1">(lock);
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1276.1">The following code illustrates a similar but more complex example than the one presented in the previous section. </span><span class="koboSpan" id="kobo.1276.2">The producing thread generates data in a loop (in this example, it is a finite loop), and the consuming thread waits for new data to be made available and consumes it (prints it to the console). </span><span class="koboSpan" id="kobo.1276.3">The producing thread terminates when it finishes producing data, and the consuming thread terminates when there is no more data to consume. </span><span class="koboSpan" id="kobo.1276.4">Data is added to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1277.1">queue&lt;int&gt;</span></code><span class="koboSpan" id="kobo.1278.1">, and a Boolean variable is used to indicate to the consuming thread that the process of producing data is finished. </span><span class="koboSpan" id="kobo.1278.2">The following snippet shows the implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1279.1">producer</span></code><span class="koboSpan" id="kobo.1280.1"> thread:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1281.1">std::mutex g_lockprint;
std::mutex g_lockqueue;
std::condition_variable g_queuecheck;
std::queue&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1282.1">int</span></span><span class="koboSpan" id="kobo.1283.1">&gt; g_buffer;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1284.1">bool</span></span><span class="koboSpan" id="kobo.1285.1"> g_done;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1286.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1287.1">producer</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1288.1">(</span></span>
<span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1289.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1290.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1291.1"> id, </span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1292.1">  std::mt19937&amp; generator,</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1293.1">  std::uniform_int_distribution&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1294.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1295.1">&gt;&amp; dsleep,</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.1296.1">  std::uniform_int_distribution&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1297.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1298.1">&gt;&amp; dcode)</span></span><span class="koboSpan" id="kobo.1299.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1300.1">for</span></span><span class="koboSpan" id="kobo.1301.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.1302.1">int</span></span><span class="koboSpan" id="kobo.1303.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1304.1">0</span></span><span class="koboSpan" id="kobo.1305.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.1306.1">5</span></span><span class="koboSpan" id="kobo.1307.1">; ++i)
  {
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1308.1">// simulate work</span></span><span class="koboSpan" id="kobo.1309.1">
    std::this_thread::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1310.1">sleep_for</span></span><span class="koboSpan" id="kobo.1311.1">(
      std::chrono::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1312.1">seconds</span></span><span class="koboSpan" id="kobo.1313.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1314.1">dsleep</span></span><span class="koboSpan" id="kobo.1315.1">(generator)));
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1316.1">// generate data</span></span><span class="koboSpan" id="kobo.1317.1">
    {
      </span><span class="hljs-function"><span class="koboSpan" id="kobo.1318.1">std::unique_lock&lt;std::mutex&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1319.1">locker</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1320.1">(g_lockqueue)</span></span><span class="koboSpan" id="kobo.1321.1">;
      </span><span class="hljs-type"><span class="koboSpan" id="kobo.1322.1">int</span></span><span class="koboSpan" id="kobo.1323.1"> value = id * </span><span class="hljs-number"><span class="koboSpan" id="kobo.1324.1">100</span></span><span class="koboSpan" id="kobo.1325.1"> + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1326.1">dcode</span></span><span class="koboSpan" id="kobo.1327.1">(generator);
      g_buffer.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1328.1">push</span></span><span class="koboSpan" id="kobo.1329.1">(value);
      {
        </span><span class="hljs-function"><span class="koboSpan" id="kobo.1330.1">std::unique_lock&lt;std::mutex&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1331.1">locker</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1332.1">(g_lockprint)</span></span><span class="koboSpan" id="kobo.1333.1">;
        std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1334.1">"[produced("</span></span><span class="koboSpan" id="kobo.1335.1"> &lt;&lt; id &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1336.1">")]: "</span></span><span class="koboSpan" id="kobo.1337.1"> &lt;&lt; value &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1338.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1339.1">\n'</span></span><span class="koboSpan" id="kobo.1340.1">;
      }
    }
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1341.1">// notify consumers </span></span><span class="koboSpan" id="kobo.1342.1">
    g_queuecheck.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1343.1">notify_one</span></span><span class="koboSpan" id="kobo.1344.1">();
  }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1345.1">On the</span><a id="_idIndexMarker985"/><span class="koboSpan" id="kobo.1346.1"> other </span><a id="_idIndexMarker986"/><span class="koboSpan" id="kobo.1347.1">hand, the consumer thread’s implementation is listed here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1348.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1349.1">consumer</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1350.1">()</span></span><span class="koboSpan" id="kobo.1351.1">
{
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1352.1">// loop until end is signaled</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1353.1">while</span></span><span class="koboSpan" id="kobo.1354.1"> (!g_done)
  {
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.1355.1">std::unique_lock&lt;std::mutex&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1356.1">locker</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1357.1">(g_lockqueue)</span></span><span class="koboSpan" id="kobo.1358.1">;
    g_queuecheck.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1359.1">wait_for</span></span><span class="koboSpan" id="kobo.1360.1">(
      locker, 
      std::chrono::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1361.1">seconds</span></span><span class="koboSpan" id="kobo.1362.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1363.1">1</span></span><span class="koboSpan" id="kobo.1364.1">),
      [&amp;]() {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1365.1">return</span></span><span class="koboSpan" id="kobo.1366.1"> !g_buffer.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1367.1">empty</span></span><span class="koboSpan" id="kobo.1368.1">(); });
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1369.1">// if there are values in the queue process them</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1370.1">while</span></span><span class="koboSpan" id="kobo.1371.1"> (!g_done &amp;&amp; !g_buffer.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1372.1">empty</span></span><span class="koboSpan" id="kobo.1373.1">())
    {
      </span><span class="hljs-function"><span class="koboSpan" id="kobo.1374.1">std::unique_lock&lt;std::mutex&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1375.1">locker</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1376.1">(g_lockprint)</span></span><span class="koboSpan" id="kobo.1377.1">;
      std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1378.1">"[consumed]: "</span></span><span class="koboSpan" id="kobo.1379.1"> &lt;&lt; g_buffer.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1380.1">front</span></span><span class="koboSpan" id="kobo.1381.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1382.1">'\n'</span></span><span class="koboSpan" id="kobo.1383.1">;
      g_buffer.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1384.1">pop</span></span><span class="koboSpan" id="kobo.1385.1">();
    }
  }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1386.1">The</span><a id="_idIndexMarker987"/><span class="koboSpan" id="kobo.1387.1"> consumer thread does the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1388.1">Loops until it is signaled that the process of producing data is finished.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1389.1">Acquires a unique lock on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1390.1">mutex</span></code><span class="koboSpan" id="kobo.1391.1"> object associated with the condition variable.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1392.1">Uses the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1393.1">wait_for()</span></code><span class="koboSpan" id="kobo.1394.1"> overload, which takes a predicate, checking that the buffer is not empty when a wakeup occurs (to avoid spurious wakeups). </span><span class="koboSpan" id="kobo.1394.2">This method uses a timeout of 1 second and returns after the timeout has occurred, even if the condition is signaled.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1395.1">Consumes all of the data from the queue after it is signaled through the condition variable.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1396.1">To test this, we </span><a id="_idIndexMarker988"/><span class="koboSpan" id="kobo.1397.1">can start several producing threads and one consuming thread. </span><span class="koboSpan" id="kobo.1397.2">Producer threads generate random data and, therefore, share the pseudo-random generator engines and distributions. </span><span class="koboSpan" id="kobo.1397.3">All of this is shown in the following code sample:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1398.1">auto</span></span><span class="koboSpan" id="kobo.1399.1"> seed_data = std::array&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1400.1">int</span></span><span class="koboSpan" id="kobo.1401.1">, std::mt19937::state_size&gt; {};
std::random_device rd {};
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1402.1">generate</span></span><span class="koboSpan" id="kobo.1403.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1404.1">begin</span></span><span class="koboSpan" id="kobo.1405.1">(seed_data), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1406.1">end</span></span><span class="koboSpan" id="kobo.1407.1">(seed_data),
              std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1408.1">ref</span></span><span class="koboSpan" id="kobo.1409.1">(rd));
</span><span class="hljs-function"><span class="koboSpan" id="kobo.1410.1">std::seed_seq </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1411.1">seq</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1412.1">(std::begin(seed_data), std::end(seed_data))</span></span><span class="koboSpan" id="kobo.1413.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1414.1">auto</span></span><span class="koboSpan" id="kobo.1415.1"> generator = std::mt19937{ seq };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1416.1">auto</span></span><span class="koboSpan" id="kobo.1417.1"> dsleep = std::uniform_int_distribution&lt;&gt;{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.1418.1">1</span></span><span class="koboSpan" id="kobo.1419.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1420.1">5</span></span><span class="koboSpan" id="kobo.1421.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1422.1">auto</span></span><span class="koboSpan" id="kobo.1423.1"> dcode = std::uniform_int_distribution&lt;&gt;{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.1424.1">1</span></span><span class="koboSpan" id="kobo.1425.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1426.1">99</span></span><span class="koboSpan" id="kobo.1427.1"> };
std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1428.1">"start producing and consuming..."</span></span><span class="koboSpan" id="kobo.1429.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1430.1">'\n'</span></span><span class="koboSpan" id="kobo.1431.1">;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.1432.1">std::thread </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1433.1">consumerthread</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1434.1">(consumer)</span></span><span class="koboSpan" id="kobo.1435.1">;
std::vector&lt;std::thread&gt; threads;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1436.1">for</span></span><span class="koboSpan" id="kobo.1437.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.1438.1">int</span></span><span class="koboSpan" id="kobo.1439.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1440.1">0</span></span><span class="koboSpan" id="kobo.1441.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.1442.1">5</span></span><span class="koboSpan" id="kobo.1443.1">; ++i)
{
  threads.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1444.1">emplace_back</span></span><span class="koboSpan" id="kobo.1445.1">(producer, 
                       i + </span><span class="hljs-number"><span class="koboSpan" id="kobo.1446.1">1</span></span><span class="koboSpan" id="kobo.1447.1">, 
                       std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1448.1">ref</span></span><span class="koboSpan" id="kobo.1449.1">(generator),
                       std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1450.1">ref</span></span><span class="koboSpan" id="kobo.1451.1">(dsleep),
                       std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1452.1">ref</span></span><span class="koboSpan" id="kobo.1453.1">(dcode));
}
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1454.1">// work for the workers to finish</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1455.1">for</span></span><span class="koboSpan" id="kobo.1456.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1457.1">auto</span></span><span class="koboSpan" id="kobo.1458.1">&amp; t : threads)
  t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1459.1">join</span></span><span class="koboSpan" id="kobo.1460.1">();
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1461.1">// notify the logger to finish and wait for it</span></span><span class="koboSpan" id="kobo.1462.1">
g_done = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1463.1">true</span></span><span class="koboSpan" id="kobo.1464.1">;
consumerthread.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1465.1">join</span></span><span class="koboSpan" id="kobo.1466.1">();
std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1467.1">"done producing and consuming"</span></span><span class="koboSpan" id="kobo.1468.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1469.1">'\n'</span></span><span class="koboSpan" id="kobo.1470.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1471.1">A possible</span><a id="_idIndexMarker989"/><span class="koboSpan" id="kobo.1472.1"> output</span><a id="_idIndexMarker990"/><span class="koboSpan" id="kobo.1473.1"> of this program is as follows (the actual output would be different for each execution):</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1474.1">start producing and consuming...
</span><span class="koboSpan" id="kobo.1474.2">[produced(5)]: 550
[consumed]: 550
[produced(5)]: 529
[consumed]: 529
[produced(5)]: 537
[consumed]: 537
[produced(1)]: 122
[produced(2)]: 224
[produced(3)]: 326
[produced(4)]: 458
[consumed]: 122
[consumed]: 224
[consumed]: 326
[consumed]: 458
...
</span><span class="koboSpan" id="kobo.1474.3">done producing and consuming
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1475.1">The standard also features a helper function called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1476.1">notify_all_at_thread_exit()</span></code><span class="koboSpan" id="kobo.1477.1">, which provides a way for a thread to notify other threads through a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1478.1">condition_variable</span></code><span class="koboSpan" id="kobo.1479.1"> object that it’s completely finished execution, including destroying all </span><code class="inlineCode"><span class="koboSpan" id="kobo.1480.1">thread_local</span></code><span class="koboSpan" id="kobo.1481.1"> objects. </span><span class="koboSpan" id="kobo.1481.2">This </span><a id="_idIndexMarker991"/><span class="koboSpan" id="kobo.1482.1">function has two parameters: a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1483.1">condition_variable</span></code><span class="koboSpan" id="kobo.1484.1"> and a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1485.1">std::unique_lock&lt;std::mutex&gt;</span></code><span class="koboSpan" id="kobo.1486.1"> associated with the condition variable (that it takes ownership of). </span><span class="koboSpan" id="kobo.1486.2">The typical use case for this function is running a detached thread that calls this function</span><a id="_idIndexMarker992"/><span class="koboSpan" id="kobo.1487.1"> just before finishing.</span></p>
<h2 class="heading-2" id="_idParaDest-518"><span class="koboSpan" id="kobo.1488.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1489.1">Working with threads</span></em><span class="koboSpan" id="kobo.1490.1">, to learn about the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1491.1">std::thread</span></code><span class="koboSpan" id="kobo.1492.1"> class and the basic operations for working with threads in C++</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1493.1">Synchronizing access to shared data with mutexes and locks</span></em><span class="koboSpan" id="kobo.1494.1">, to see what mechanisms are available for synchronizing thread access to shared data and how they work</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-519"><span class="koboSpan" id="kobo.1495.1">Using promises and futures to return values from threads</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1496.1">In the first</span><a id="_idIndexMarker993"/><span class="koboSpan" id="kobo.1497.1"> recipe of this chapter, we discussed how to work with threads. </span><span class="koboSpan" id="kobo.1497.2">You also learned that thread functions cannot return values and that threads should use other means, such as shared data, to do so; however, for this, synchronization is required. </span><span class="koboSpan" id="kobo.1497.3">An alternative to communicating a return value or an exception with either the main or another thread is using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1498.1">std::promise</span></code><span class="koboSpan" id="kobo.1499.1">. </span><span class="koboSpan" id="kobo.1499.2">This recipe will explain how this mechanism works.</span></p>
<h2 class="heading-2" id="_idParaDest-520"><span class="koboSpan" id="kobo.1500.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1501.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1502.1">promise</span></code><span class="koboSpan" id="kobo.1503.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1504.1">future</span></code><span class="koboSpan" id="kobo.1505.1"> classes used in this recipe are available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1506.1">std</span></code><span class="koboSpan" id="kobo.1507.1"> namespace in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1508.1">&lt;future&gt;</span></code><span class="koboSpan" id="kobo.1509.1"> header.</span></p>
<h2 class="heading-2" id="_idParaDest-521"><span class="koboSpan" id="kobo.1510.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1511.1">To communicate a value from one thread to another through promises and futures, do this:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1512.1">Make a promise available to the thread function through a parameter; for example:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1513.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1514.1">produce_value</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1515.1">(std::promise&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1516.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1517.1">&gt;&amp; p)</span></span><span class="koboSpan" id="kobo.1518.1">
{
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1519.1">// simulate long running operation</span></span><span class="koboSpan" id="kobo.1520.1">
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1521.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1522.1">namespace</span></span><span class="koboSpan" id="kobo.1523.1"> std::chrono_literals;
    std::this_thread::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1524.1">sleep_for</span></span><span class="koboSpan" id="kobo.1525.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1526.1">2</span></span><span class="koboSpan" id="kobo.1527.1">s);
  }
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1528.1">// continued at 2.</span></span><span class="koboSpan" id="kobo.1529.1">
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1530.1">Call </span><code class="inlineCode"><span class="koboSpan" id="kobo.1531.1">set_value()</span></code><span class="koboSpan" id="kobo.1532.1"> on </span><a id="_idIndexMarker994"/><span class="koboSpan" id="kobo.1533.1">the promise to set the result to represent a value or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1534.1">set_exception()</span></code><span class="koboSpan" id="kobo.1535.1"> to set the result to indicate an exception:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1536.1">// continued from 1.</span></span><span class="koboSpan" id="kobo.1537.1">
p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1538.1">set_value</span></span><span class="koboSpan" id="kobo.1539.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1540.1">42</span></span><span class="koboSpan" id="kobo.1541.1">);
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1542.1">Make the future associated with the promise available to the other thread function through a parameter; for example:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1543.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1544.1">consume_value</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1545.1">(std::future&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1546.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1547.1">&gt;&amp; f)</span></span><span class="koboSpan" id="kobo.1548.1">
{
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1549.1">// continued at 4.</span></span><span class="koboSpan" id="kobo.1550.1">
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1551.1">Call </span><code class="inlineCode"><span class="koboSpan" id="kobo.1552.1">get()</span></code><span class="koboSpan" id="kobo.1553.1"> on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1554.1">future</span></code><span class="koboSpan" id="kobo.1555.1"> object to get the result set to the promise:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1556.1">// continued from 3.</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1557.1">auto</span></span><span class="koboSpan" id="kobo.1558.1"> value = f.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1559.1">get</span></span><span class="koboSpan" id="kobo.1560.1">();
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1561.1">In the calling thread, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1562.1">get_future()</span></code><span class="koboSpan" id="kobo.1563.1"> on the promise to get the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1564.1">future</span></code><span class="koboSpan" id="kobo.1565.1"> associated with the promise:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1566.1">std::promise&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1567.1">int</span></span><span class="koboSpan" id="kobo.1568.1">&gt; p;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.1569.1">std::thread </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1570.1">t1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1571.1">(produce_value, std::ref(p))</span></span><span class="koboSpan" id="kobo.1572.1">;
std::future&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1573.1">int</span></span><span class="koboSpan" id="kobo.1574.1">&gt; f = p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1575.1">get_future</span></span><span class="koboSpan" id="kobo.1576.1">();
</span><span class="hljs-function"><span class="koboSpan" id="kobo.1577.1">std::thread </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1578.1">t2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1579.1">(consume_value, std::ref(f))</span></span><span class="koboSpan" id="kobo.1580.1">;
t1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1581.1">join</span></span><span class="koboSpan" id="kobo.1582.1">();
t2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1583.1">join</span></span><span class="koboSpan" id="kobo.1584.1">();
</span></code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-522"><span class="koboSpan" id="kobo.1585.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1586.1">The </span><a id="_idIndexMarker995"/><span class="koboSpan" id="kobo.1587.1">promise-future pair is basically a communication channel that enables a thread to communicate a value or exception with another thread through a shared state. </span><code class="inlineCode"><span class="koboSpan" id="kobo.1588.1">promise</span></code><span class="koboSpan" id="kobo.1589.1"> is an asynchronous provider of the result and has an associated </span><code class="inlineCode"><span class="koboSpan" id="kobo.1590.1">future</span></code><span class="koboSpan" id="kobo.1591.1"> that represents an asynchronous return object. </span><span class="koboSpan" id="kobo.1591.2">To establish this channel, you must first create a promise. </span><span class="koboSpan" id="kobo.1591.3">This, in turn, creates a shared state that can be later read through the future associated with the promise.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1592.1">To set a result to a promise, you can use any of the following methods:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1593.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1594.1">set_value()</span></code><span class="koboSpan" id="kobo.1595.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1596.1">set_value_at_thread_exit()</span></code><span class="koboSpan" id="kobo.1597.1"> method is used to set a return value; the latter function stores the value in the shared state but only makes it available through the associated future if the thread exits.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1598.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1599.1">set_exception()</span></code><span class="koboSpan" id="kobo.1600.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1601.1">set_exception_at_thread_exit()</span></code><span class="koboSpan" id="kobo.1602.1"> method is used to set an exception as a return value. </span><span class="koboSpan" id="kobo.1602.2">The exception is wrapped in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1603.1">std::exception_ptr</span></code><span class="koboSpan" id="kobo.1604.1"> object. </span><span class="koboSpan" id="kobo.1604.2">The latter function stores the exception in the shared state but only makes it available when the thread exits.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1605.1">To retrieve the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1606.1">future</span></code><span class="koboSpan" id="kobo.1607.1"> object associated with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1608.1">promise</span></code><span class="koboSpan" id="kobo.1609.1">, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1610.1">get_future()</span></code><span class="koboSpan" id="kobo.1611.1"> method. </span><span class="koboSpan" id="kobo.1611.2">To get the value from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1612.1">future</span></code><span class="koboSpan" id="kobo.1613.1"> value, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1614.1">get()</span></code><span class="koboSpan" id="kobo.1615.1"> method. </span><span class="koboSpan" id="kobo.1615.2">This blocks the calling thread until the value from the shared state is made available. </span><span class="koboSpan" id="kobo.1615.3">The future class has several methods for blocking the thread until the result from the shared state is made available:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1616.1">wait()</span></code><span class="koboSpan" id="kobo.1617.1"> only returns when the result is available.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1618.1">wait_for()</span></code><span class="koboSpan" id="kobo.1619.1"> returns either when the result is available or when the specified timeout expires.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1620.1">wait_until()</span></code><span class="koboSpan" id="kobo.1621.1"> returns either when the result is available or when the specified time point is reached.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1622.1">If an exception is set to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1623.1">promise</span></code><span class="koboSpan" id="kobo.1624.1"> value, calling the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1625.1">get()</span></code><span class="koboSpan" id="kobo.1626.1"> method on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1627.1">future</span></code><span class="koboSpan" id="kobo.1628.1"> object will throw this exception. </span><span class="koboSpan" id="kobo.1628.2">The example from the previous section has been rewritten as follows to throw an exception instead of setting a result:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1629.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1630.1">produce_value</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1631.1">(std::promise&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1632.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1633.1">&gt;&amp; p)</span></span><span class="koboSpan" id="kobo.1634.1">
{
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1635.1">// simulate long running operation</span></span><span class="koboSpan" id="kobo.1636.1">
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1637.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1638.1">namespace</span></span><span class="koboSpan" id="kobo.1639.1"> std::chrono_literals;
    std::this_thread::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1640.1">sleep_for</span></span><span class="koboSpan" id="kobo.1641.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1642.1">2</span></span><span class="koboSpan" id="kobo.1643.1">s);
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1644.1">try</span></span><span class="koboSpan" id="kobo.1645.1">
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1646.1">throw</span></span><span class="koboSpan" id="kobo.1647.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1648.1">runtime_error</span></span><span class="koboSpan" id="kobo.1649.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1650.1">"an error has occurred!"</span></span><span class="koboSpan" id="kobo.1651.1">);
  }
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1652.1">catch</span></span><span class="koboSpan" id="kobo.1653.1">(...)
  {
    p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1654.1">set_exception</span></span><span class="koboSpan" id="kobo.1655.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1656.1">current_exception</span></span><span class="koboSpan" id="kobo.1657.1">());
  }
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1658.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1659.1">consume_value</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1660.1">(std::future&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1661.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1662.1">&gt;&amp; f)</span></span><span class="koboSpan" id="kobo.1663.1">
{
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.1664.1">std::lock_guard&lt;std::mutex&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1665.1">lock</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1666.1">(g_mutex)</span></span><span class="koboSpan" id="kobo.1667.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1668.1">try</span></span><span class="koboSpan" id="kobo.1669.1">
  {
    std::cout &lt;&lt; f.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1670.1">get</span></span><span class="koboSpan" id="kobo.1671.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1672.1">'\n'</span></span><span class="koboSpan" id="kobo.1673.1">;
  }
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1674.1">catch</span></span><span class="koboSpan" id="kobo.1675.1">(std::exception </span><span class="hljs-type"><span class="koboSpan" id="kobo.1676.1">const</span></span><span class="koboSpan" id="kobo.1677.1"> &amp; e)
  {
    std::cout &lt;&lt; e.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1678.1">what</span></span><span class="koboSpan" id="kobo.1679.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1680.1">'\n'</span></span><span class="koboSpan" id="kobo.1681.1">;
  } 
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1682.1">You can</span><a id="_idIndexMarker996"/><span class="koboSpan" id="kobo.1683.1"> see here that, in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1684.1">consume_value()</span></code><span class="koboSpan" id="kobo.1685.1"> function, the call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1686.1">get()</span></code><span class="koboSpan" id="kobo.1687.1"> is put in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1688.1">try...catch</span></code><span class="koboSpan" id="kobo.1689.1"> block. </span><span class="koboSpan" id="kobo.1689.2">If an exception is caught – and in this particular implementation, it is – its message is printed to the console.</span></p>
<h2 class="heading-2" id="_idParaDest-523"><span class="koboSpan" id="kobo.1690.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1691.1">Establishing a promise-future channel in this manner is a rather explicit operation that can be avoided by using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1692.1">std::async()</span></code><span class="koboSpan" id="kobo.1693.1"> function; this is a higher-level utility that runs a function asynchronously, creates an internal promise and a shared state, and returns a future associated with the shared state. </span><span class="koboSpan" id="kobo.1693.2">We will see how </span><code class="inlineCode"><span class="koboSpan" id="kobo.1694.1">std::async()</span></code><span class="koboSpan" id="kobo.1695.1"> works in the next recipe, </span><em class="italic"><span class="koboSpan" id="kobo.1696.1">Executing functions asynchronously</span></em><span class="koboSpan" id="kobo.1697.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-524"><span class="koboSpan" id="kobo.1698.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1699.1">Working with threads</span></em><span class="koboSpan" id="kobo.1700.1">, to learn about the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1701.1">std::thread</span></code><span class="koboSpan" id="kobo.1702.1"> class and the basic operations for working with threads in C++</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1703.1">Handling exceptions from thread functions</span></em><span class="koboSpan" id="kobo.1704.1">, to understand how to handle exceptions thrown in a worker thread from the main thread or the thread where it was joined</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-525"><span class="koboSpan" id="kobo.1705.1">Executing functions asynchronously</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1706.1">Threads </span><a id="_idIndexMarker997"/><span class="koboSpan" id="kobo.1707.1">enable us to run multiple functions at the same time; this helps us take advantage of the hardware facilities in multiprocessor or multicore systems. </span><span class="koboSpan" id="kobo.1707.2">However, threads require explicit, lower-level operations. </span><span class="koboSpan" id="kobo.1707.3">An alternative to threads is tasks, which are units of work that run in a particular thread. </span><span class="koboSpan" id="kobo.1707.4">The C++ standard does not provide a complete task library, but it enables developers to execute functions asynchronously on different threads and communicate results back through a promise-future channel, as seen in the previous recipe. </span><span class="koboSpan" id="kobo.1707.5">In this recipe, we will see how to do this using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1708.1">std::async()</span></code><span class="koboSpan" id="kobo.1709.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1710.1">std::future</span></code><span class="koboSpan" id="kobo.1711.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-526"><span class="koboSpan" id="kobo.1712.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1713.1">For the examples in this recipe, we will use the following functions:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1714.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1715.1">do_something</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1716.1">()</span></span><span class="koboSpan" id="kobo.1717.1">
{
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1718.1">// simulate long running operation</span></span><span class="koboSpan" id="kobo.1719.1">
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1720.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1721.1">namespace</span></span><span class="koboSpan" id="kobo.1722.1"> std::chrono_literals;
    std::this_thread::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1723.1">sleep_for</span></span><span class="koboSpan" id="kobo.1724.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1725.1">2</span></span><span class="koboSpan" id="kobo.1726.1">s);
  } 
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.1727.1">std::lock_guard&lt;std::mutex&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1728.1">lock</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1729.1">(g_mutex)</span></span><span class="koboSpan" id="kobo.1730.1">;
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1731.1">"operation 1 done"</span></span><span class="koboSpan" id="kobo.1732.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1733.1">'\n'</span></span><span class="koboSpan" id="kobo.1734.1">; 
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1735.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1736.1">do_something_else</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1737.1">()</span></span><span class="koboSpan" id="kobo.1738.1">
{
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1739.1">// simulate long running operation</span></span><span class="koboSpan" id="kobo.1740.1">
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1741.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1742.1">namespace</span></span><span class="koboSpan" id="kobo.1743.1"> std::chrono_literals;
    std::this_thread::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1744.1">sleep_for</span></span><span class="koboSpan" id="kobo.1745.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1746.1">1</span></span><span class="koboSpan" id="kobo.1747.1">s);
  } 
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.1748.1">std::lock_guard&lt;std::mutex&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1749.1">lock</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1750.1">(g_mutex)</span></span><span class="koboSpan" id="kobo.1751.1">;
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1752.1">"operation 2 done"</span></span><span class="koboSpan" id="kobo.1753.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1754.1">'\n'</span></span><span class="koboSpan" id="kobo.1755.1">; 
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1756.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1757.1">compute_something</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1758.1">()</span></span><span class="koboSpan" id="kobo.1759.1">
{
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1760.1">// simulate long running operation</span></span><span class="koboSpan" id="kobo.1761.1">
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1762.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1763.1">namespace</span></span><span class="koboSpan" id="kobo.1764.1"> std::chrono_literals;
    std::this_thread::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1765.1">sleep_for</span></span><span class="koboSpan" id="kobo.1766.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1767.1">2</span></span><span class="koboSpan" id="kobo.1768.1">s);
  } 
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1769.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1770.1">42</span></span><span class="koboSpan" id="kobo.1771.1">;
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1772.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1773.1">compute_something_else</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1774.1">()</span></span><span class="koboSpan" id="kobo.1775.1">
{
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1776.1">// simulate long running operation</span></span><span class="koboSpan" id="kobo.1777.1">
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1778.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1779.1">namespace</span></span><span class="koboSpan" id="kobo.1780.1"> std::chrono_literals;
    std::this_thread::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1781.1">sleep_for</span></span><span class="koboSpan" id="kobo.1782.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1783.1">1</span></span><span class="koboSpan" id="kobo.1784.1">s);
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1785.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1786.1">24</span></span><span class="koboSpan" id="kobo.1787.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1788.1">In this recipe, we</span><a id="_idIndexMarker998"/><span class="koboSpan" id="kobo.1789.1"> will use futures; therefore, you are advised to read the previous recipe to get a quick overview of how they work. </span><span class="koboSpan" id="kobo.1789.2">Both </span><code class="inlineCode"><span class="koboSpan" id="kobo.1790.1">async()</span></code><span class="koboSpan" id="kobo.1791.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1792.1">future</span></code><span class="koboSpan" id="kobo.1793.1"> are available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1794.1">std</span></code><span class="koboSpan" id="kobo.1795.1"> namespace in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1796.1">&lt;future&gt;</span></code><span class="koboSpan" id="kobo.1797.1"> header.</span></p>
<h2 class="heading-2" id="_idParaDest-527"><span class="koboSpan" id="kobo.1798.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1799.1">To execute a function asynchronously on another thread when the current thread is continuing with the execution without expecting a result, do the following:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1800.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1801.1">std::async()</span></code><span class="koboSpan" id="kobo.1802.1"> to start a new thread to execute the specified function. </span><span class="koboSpan" id="kobo.1802.2">This will create an asynchronous provider and return a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1803.1">future</span></code><span class="koboSpan" id="kobo.1804.1"> associated with it. </span><span class="koboSpan" id="kobo.1804.2">Use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1805.1">std::launch::async</span></code><span class="koboSpan" id="kobo.1806.1"> policy for the first argument to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1807.1">std::async()</span></code><span class="koboSpan" id="kobo.1808.1"> function in order to make sure the function will run asynchronously:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1809.1">auto</span></span><span class="koboSpan" id="kobo.1810.1"> f = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1811.1">async</span></span><span class="koboSpan" id="kobo.1812.1">(std::launch::async, do_something);
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1813.1">Continue with the execution of the current thread:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.1814.1">do_something_else</span></span><span class="koboSpan" id="kobo.1815.1">();
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1816.1">Call the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1817.1">wait()</span></code><span class="koboSpan" id="kobo.1818.1"> method on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1819.1">future</span></code><span class="koboSpan" id="kobo.1820.1"> object returned by </span><code class="inlineCode"><span class="koboSpan" id="kobo.1821.1">std::async()</span></code><span class="koboSpan" id="kobo.1822.1"> when you need to make sure the asynchronous operation is completed:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1823.1">f.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1824.1">wait</span></span><span class="koboSpan" id="kobo.1825.1">();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1826.1">To </span><a id="_idIndexMarker999"/><span class="koboSpan" id="kobo.1827.1">execute a function asynchronously on a worker thread while the current thread continues its execution, until the result from the asynchronous function is needed in the current thread, do the following:</span></p> </li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="4"><span class="koboSpan" id="kobo.1828.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1829.1">std::async()</span></code><span class="koboSpan" id="kobo.1830.1"> to start a new thread to execute the specified function, create an asynchronous provider, and return a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1831.1">future</span></code><span class="koboSpan" id="kobo.1832.1"> associated with it. </span><span class="koboSpan" id="kobo.1832.2">Use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1833.1">std::launch::async</span></code><span class="koboSpan" id="kobo.1834.1"> policy of the first argument to the function to make sure the function does run asynchronously:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1835.1">auto</span></span><span class="koboSpan" id="kobo.1836.1"> f = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1837.1">async</span></span><span class="koboSpan" id="kobo.1838.1">(std::launch::async, compute_something);
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1839.1">Continue the execution of the current thread:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1840.1">auto</span></span><span class="koboSpan" id="kobo.1841.1"> value = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1842.1">compute_something_else</span></span><span class="koboSpan" id="kobo.1843.1">();
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1844.1">Call the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1845.1">get()</span></code><span class="koboSpan" id="kobo.1846.1"> method on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1847.1">future</span></code><span class="koboSpan" id="kobo.1848.1"> object returned by </span><code class="inlineCode"><span class="koboSpan" id="kobo.1849.1">std::async()</span></code><span class="koboSpan" id="kobo.1850.1"> when you need the result from the function to be executed asynchronously:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1851.1">value += f.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1852.1">get</span></span><span class="koboSpan" id="kobo.1853.1">();
</span></code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-528"><span class="koboSpan" id="kobo.1854.1">How it works...</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1855.1">std::async()</span></code><span class="koboSpan" id="kobo.1856.1"> is a</span><a id="_idIndexMarker1000"/><span class="koboSpan" id="kobo.1857.1"> variadic function template that has two overloads: one that specifies a launch policy as the first argument and another that does not. </span><span class="koboSpan" id="kobo.1857.2">The other arguments to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1858.1">std::async()</span></code><span class="koboSpan" id="kobo.1859.1"> are the function to execute and its arguments, if any. </span><span class="koboSpan" id="kobo.1859.2">The launch policy is defined by a scoped enumeration called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1860.1">std::launch</span></code><span class="koboSpan" id="kobo.1861.1">, available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1862.1">&lt;future&gt;</span></code><span class="koboSpan" id="kobo.1863.1"> header:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1864.1">enum class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1865.1">launch</span></span><span class="koboSpan" id="kobo.1866.1"> : </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1867.1">/* unspecified */</span></span><span class="koboSpan" id="kobo.1868.1"> 
{
  async = </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1869.1">/* unspecified */</span></span><span class="koboSpan" id="kobo.1870.1">,
  deferred = </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1871.1">/* unspecified */</span></span><span class="koboSpan" id="kobo.1872.1">,
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1873.1">/* implementation-defined */</span></span><span class="koboSpan" id="kobo.1874.1">
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1875.1">The two available launch policies specify the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1876.1">With </span><code class="inlineCode"><span class="koboSpan" id="kobo.1877.1">async</span></code><span class="koboSpan" id="kobo.1878.1">, a new thread is launched to execute the task asynchronously.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1879.1">With </span><code class="inlineCode"><span class="koboSpan" id="kobo.1880.1">deferred</span></code><span class="koboSpan" id="kobo.1881.1">, the task is executed on the calling thread the first time its result is requested.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1882.1">When both</span><a id="_idIndexMarker1001"/><span class="koboSpan" id="kobo.1883.1"> flags are specified (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1884.1">std::launch::async | std::launch::deferred</span></code><span class="koboSpan" id="kobo.1885.1">), it is an implementation decision regarding whether to run the task asynchronously on a new thread or synchronously on the current thread. </span><span class="koboSpan" id="kobo.1885.2">This</span><a id="_idIndexMarker1002"/><span class="koboSpan" id="kobo.1886.1"> is the behavior of the other </span><code class="inlineCode"><span class="koboSpan" id="kobo.1887.1">std::async()</span></code><span class="koboSpan" id="kobo.1888.1"> overload that does not specify a launch policy. </span><span class="koboSpan" id="kobo.1888.2">This behavior is not deterministic.</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.1889.1">Do not use the non-deterministic overload of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1890.1">std::async()</span></code><span class="koboSpan" id="kobo.1891.1"> to run tasks asynchronously. </span><span class="koboSpan" id="kobo.1891.2">For this purpose, always use the overload that requires a launch policy, and always use only </span><code class="inlineCode"><span class="koboSpan" id="kobo.1892.1">std::launch::async</span></code><span class="koboSpan" id="kobo.1893.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1894.1">Both overloads of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1895.1">std::async()</span></code><span class="koboSpan" id="kobo.1896.1"> return a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1897.1">future</span></code><span class="koboSpan" id="kobo.1898.1"> object that refers to the shared state created internally by </span><code class="inlineCode"><span class="koboSpan" id="kobo.1899.1">std::async()</span></code><span class="koboSpan" id="kobo.1900.1"> for the promise-future channel it establishes. </span><span class="koboSpan" id="kobo.1900.2">When you need the result of the asynchronous operation, call the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1901.1">get()</span></code><span class="koboSpan" id="kobo.1902.1"> method on the future. </span><span class="koboSpan" id="kobo.1902.2">This blocks the current thread until either the result value or an exception is made available. </span><span class="koboSpan" id="kobo.1902.3">If the future does not transport any value or if you are not actually interested in that value, but you want to make sure the asynchronous operation will be completed at some point, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1903.1">wait()</span></code><span class="koboSpan" id="kobo.1904.1"> method; it blocks the current thread until the shared state is made available through the future.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1905.1">The future class has two more waiting methods: </span><code class="inlineCode"><span class="koboSpan" id="kobo.1906.1">wait_for()</span></code><span class="koboSpan" id="kobo.1907.1"> specifies a duration after which the call ends and returns even if the shared state is not yet available through the future, while </span><code class="inlineCode"><span class="koboSpan" id="kobo.1908.1">wait_until()</span></code><span class="koboSpan" id="kobo.1909.1"> specifies a time point after which the call returns, even if the shared state is not yet available. </span><span class="koboSpan" id="kobo.1909.2">These methods could be used to create a polling routine and display a status message to the user, as shown in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1910.1">auto</span></span><span class="koboSpan" id="kobo.1911.1"> f = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1912.1">async</span></span><span class="koboSpan" id="kobo.1913.1">(std::launch::async, do_something);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1914.1">while</span></span><span class="koboSpan" id="kobo.1915.1">(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1916.1">true</span></span><span class="koboSpan" id="kobo.1917.1">)
{
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1918.1">"waiting...\n"</span></span><span class="koboSpan" id="kobo.1919.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1920.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1921.1">namespace</span></span><span class="koboSpan" id="kobo.1922.1"> std::chrono_literals;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1923.1">auto</span></span><span class="koboSpan" id="kobo.1924.1"> status = f.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1925.1">wait_for</span></span><span class="koboSpan" id="kobo.1926.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1927.1">500</span></span><span class="koboSpan" id="kobo.1928.1">ms);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1929.1">if</span></span><span class="koboSpan" id="kobo.1930.1">(status == std::future_status::ready) 
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1931.1">break</span></span><span class="koboSpan" id="kobo.1932.1">;
}
std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1933.1">"done!\n"</span></span><span class="koboSpan" id="kobo.1934.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1935.1">The result of</span><a id="_idIndexMarker1003"/><span class="koboSpan" id="kobo.1936.1"> running this program is as follows:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1937.1">waiting...
</span><span class="koboSpan" id="kobo.1937.2">waiting...
</span><span class="koboSpan" id="kobo.1937.3">waiting...
</span><span class="koboSpan" id="kobo.1937.4">operation 1 done
done!
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-529"><span class="koboSpan" id="kobo.1938.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1939.1">Using promises and futures to return values from threads</span></em><span class="koboSpan" id="kobo.1940.1">, to learn how to use a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1941.1">std::promise</span></code><span class="koboSpan" id="kobo.1942.1"> object to return a value or an exception from a thread</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-530"><span class="koboSpan" id="kobo.1943.1">Using atomic types</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1944.1">The thread</span><a id="_idIndexMarker1004"/><span class="koboSpan" id="kobo.1945.1"> support library offers functionalities for managing threads and synchronizing access to shared data with mutexes and locks, and, as of C++20, with latches, barriers, and semaphores. </span><span class="koboSpan" id="kobo.1945.2">The standard library provides support for the complementary, lower-level atomic operations on data, which are indivisible operations that can be executed concurrently from different threads on shared data, without the risk of producing race conditions and without the use of locks. </span><span class="koboSpan" id="kobo.1945.3">The support it provides includes atomic types, atomic operations, and memory synchronization ordering. </span><span class="koboSpan" id="kobo.1945.4">In this recipe, we will see how to use some of these types and functions.</span></p>
<h2 class="heading-2" id="_idParaDest-531"><span class="koboSpan" id="kobo.1946.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1947.1">All the atomic types and operations are defined in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1948.1">std</span></code><span class="koboSpan" id="kobo.1949.1"> namespace in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1950.1">&lt;atomic&gt;</span></code><span class="koboSpan" id="kobo.1951.1"> header.</span></p>
<h2 class="heading-2" id="_idParaDest-532"><span class="koboSpan" id="kobo.1952.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1953.1">The following are a series </span><a id="_idIndexMarker1005"/><span class="koboSpan" id="kobo.1954.1">of typical operations that use atomic types:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1955.1">Use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1956.1">std::atomic</span></code><span class="koboSpan" id="kobo.1957.1"> class template to create atomic objects that support atomic operations, such as loading, storing, or performing arithmetic or bitwise operations:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1958.1">std::atomic&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1959.1">int</span></span><span class="koboSpan" id="kobo.1960.1">&gt; counter {</span><span class="hljs-number"><span class="koboSpan" id="kobo.1961.1">0</span></span><span class="koboSpan" id="kobo.1962.1">};
std::vector&lt;std::thread&gt; threads;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1963.1">for</span></span><span class="koboSpan" id="kobo.1964.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.1965.1">int</span></span><span class="koboSpan" id="kobo.1966.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1967.1">0</span></span><span class="koboSpan" id="kobo.1968.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.1969.1">10</span></span><span class="koboSpan" id="kobo.1970.1">; ++i)
{
  threads.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1971.1">emplace_back</span></span><span class="koboSpan" id="kobo.1972.1">([&amp;counter](){
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1973.1">for</span></span><span class="koboSpan" id="kobo.1974.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.1975.1">int</span></span><span class="koboSpan" id="kobo.1976.1"> j = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1977.1">0</span></span><span class="koboSpan" id="kobo.1978.1">; j &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.1979.1">10</span></span><span class="koboSpan" id="kobo.1980.1">; ++j)
      ++counter;
    });
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1981.1">for</span></span><span class="koboSpan" id="kobo.1982.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1983.1">auto</span></span><span class="koboSpan" id="kobo.1984.1"> &amp; t : threads) t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1985.1">join</span></span><span class="koboSpan" id="kobo.1986.1">();
std::cout &lt;&lt; counter &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1987.1">'\n'</span></span><span class="koboSpan" id="kobo.1988.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1989.1">// prints 100</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1990.1">In C++20, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1991.1">std::atomic_ref</span></code><span class="koboSpan" id="kobo.1992.1"> class template to apply atomic operations to a referenced object, which can be a reference or pointer to an integral type, a floating-point type, or a user-defined type:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1993.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1994.1">do_count</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1995.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1996.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1997.1">&amp; c)</span></span><span class="koboSpan" id="kobo.1998.1">
{
  std::atomic_ref&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1999.1">int</span></span><span class="koboSpan" id="kobo.2000.1">&gt; counter{ c };
  std::vector&lt;std::thread&gt; threads;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2001.1">for</span></span><span class="koboSpan" id="kobo.2002.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.2003.1">int</span></span><span class="koboSpan" id="kobo.2004.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2005.1">0</span></span><span class="koboSpan" id="kobo.2006.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.2007.1">10</span></span><span class="koboSpan" id="kobo.2008.1">; ++i)
  {
    threads.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2009.1">emplace_back</span></span><span class="koboSpan" id="kobo.2010.1">([&amp;counter]() {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2011.1">for</span></span><span class="koboSpan" id="kobo.2012.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.2013.1">int</span></span><span class="koboSpan" id="kobo.2014.1"> j = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2015.1">0</span></span><span class="koboSpan" id="kobo.2016.1">; j &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.2017.1">10</span></span><span class="koboSpan" id="kobo.2018.1">; ++j)
        ++counter;
      });
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2019.1">for</span></span><span class="koboSpan" id="kobo.2020.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2021.1">auto</span></span><span class="koboSpan" id="kobo.2022.1">&amp; t : threads) t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2023.1">join</span></span><span class="koboSpan" id="kobo.2024.1">();
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2025.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2026.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2027.1">()</span></span><span class="koboSpan" id="kobo.2028.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.2029.1">int</span></span><span class="koboSpan" id="kobo.2030.1"> c = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2031.1">0</span></span><span class="koboSpan" id="kobo.2032.1">;
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2033.1">do_count</span></span><span class="koboSpan" id="kobo.2034.1">(c);
  std::cout &lt;&lt; c &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2035.1">'\n'</span></span><span class="koboSpan" id="kobo.2036.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2037.1">// prints 100</span></span><span class="koboSpan" id="kobo.2038.1">
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2039.1">Use </span><a id="_idIndexMarker1006"/><span class="koboSpan" id="kobo.2040.1">the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2041.1">std::atomic_flag</span></code><span class="koboSpan" id="kobo.2042.1"> class for an atomic Boolean type:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2043.1">std::atomic_flag lock = ATOMIC_FLAG_INIT;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2044.1">int</span></span><span class="koboSpan" id="kobo.2045.1"> counter = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2046.1">0</span></span><span class="koboSpan" id="kobo.2047.1">;
std::vector&lt;std::thread&gt; threads;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2048.1">for</span></span><span class="koboSpan" id="kobo.2049.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.2050.1">int</span></span><span class="koboSpan" id="kobo.2051.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2052.1">0</span></span><span class="koboSpan" id="kobo.2053.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.2054.1">10</span></span><span class="koboSpan" id="kobo.2055.1">; ++i)
{
  threads.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2056.1">emplace_back</span></span><span class="koboSpan" id="kobo.2057.1">([&amp;](){
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2058.1">while</span></span><span class="koboSpan" id="kobo.2059.1">(lock.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2060.1">test_and_set</span></span><span class="koboSpan" id="kobo.2061.1">(std::memory_order_acquire));
      ++counter;
      lock.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2062.1">clear</span></span><span class="koboSpan" id="kobo.2063.1">(std::memory_order_release);
  });
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2064.1">for</span></span><span class="koboSpan" id="kobo.2065.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2066.1">auto</span></span><span class="koboSpan" id="kobo.2067.1"> &amp; t : threads) t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2068.1">join</span></span><span class="koboSpan" id="kobo.2069.1">();
std::cout &lt;&lt; counter &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2070.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2071.1">\n'</span></span><span class="koboSpan" id="kobo.2072.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2073.1">// prints 10</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2074.1">Use the atomic type’s members – </span><code class="inlineCode"><span class="koboSpan" id="kobo.2075.1">load()</span></code><span class="koboSpan" id="kobo.2076.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2077.1">store()</span></code><span class="koboSpan" id="kobo.2078.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2079.1">exchange()</span></code><span class="koboSpan" id="kobo.2080.1"> – or non-member functions – </span><code class="inlineCode"><span class="koboSpan" id="kobo.2081.1">atomic_load()</span></code><span class="koboSpan" id="kobo.2082.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.2083.1">atomic_load_explicit()</span></code><span class="koboSpan" id="kobo.2084.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2085.1">atomic_store()</span></code><span class="koboSpan" id="kobo.2086.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.2087.1">atomic_store_explicit()</span></code><span class="koboSpan" id="kobo.2088.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2089.1">atomic_exchange()</span></code><span class="koboSpan" id="kobo.2090.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.2091.1">atomic_exchange_explicit()</span></code><span class="koboSpan" id="kobo.2092.1"> – to atomically read, set, or exchange the value of an atomic object.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2093.1">Use its member functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.2094.1">fetch_add()</span></code><span class="koboSpan" id="kobo.2095.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2096.1">fetch_sub()</span></code><span class="koboSpan" id="kobo.2097.1"> or non-member functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.2098.1">atomic_fetch_add()</span></code><span class="koboSpan" id="kobo.2099.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.2100.1">atomic_fetch_add_explicit()</span></code><span class="koboSpan" id="kobo.2101.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2102.1">atomic_fetch_sub()</span></code><span class="koboSpan" id="kobo.2103.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.2104.1">atomic_fetch_sub_explicit()</span></code><span class="koboSpan" id="kobo.2105.1"> to atomically add or subtract a value to/from an atomic object and return its value before the operation:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2106.1">std::atomic&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2107.1">int</span></span><span class="koboSpan" id="kobo.2108.1">&gt; sum {</span><span class="hljs-number"><span class="koboSpan" id="kobo.2109.1">0</span></span><span class="koboSpan" id="kobo.2110.1">};
std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2111.1">int</span></span><span class="koboSpan" id="kobo.2112.1">&gt; numbers = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2113.1">generate_random</span></span><span class="koboSpan" id="kobo.2114.1">();
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2115.1">size_t</span></span><span class="koboSpan" id="kobo.2116.1"> size = numbers.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2117.1">size</span></span><span class="koboSpan" id="kobo.2118.1">();
std::vector&lt;std::thread&gt; threads;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2119.1">for</span></span><span class="koboSpan" id="kobo.2120.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.2121.1">int</span></span><span class="koboSpan" id="kobo.2122.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2123.1">0</span></span><span class="koboSpan" id="kobo.2124.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.2125.1">10</span></span><span class="koboSpan" id="kobo.2126.1">; ++i)
{
  threads.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2127.1">emplace_back</span></span><span class="koboSpan" id="kobo.2128.1">([&amp;sum, &amp;numbers](</span><span class="hljs-type"><span class="koboSpan" id="kobo.2129.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2130.1">const</span></span><span class="koboSpan" id="kobo.2131.1"> start,
                                        </span><span class="hljs-type"><span class="koboSpan" id="kobo.2132.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2133.1">const</span></span><span class="koboSpan" id="kobo.2134.1"> end) {
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2135.1">for</span></span><span class="koboSpan" id="kobo.2136.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.2137.1">size_t</span></span><span class="koboSpan" id="kobo.2138.1"> j = start; j &lt; end; ++j)
  {
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2139.1">atomic_fetch_add_explicit</span></span><span class="koboSpan" id="kobo.2140.1">(
      &amp;sum, numbers[j], 
      std::memory_order_acquire);
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2141.1">// same as </span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.2142.1">// sum.fetch_add(numbers[i], std::memory_order_acquire);</span></span><span class="koboSpan" id="kobo.2143.1">
  }},
  i*(size/</span><span class="hljs-number"><span class="koboSpan" id="kobo.2144.1">10</span></span><span class="koboSpan" id="kobo.2145.1">),
  (i+</span><span class="hljs-number"><span class="koboSpan" id="kobo.2146.1">1</span></span><span class="koboSpan" id="kobo.2147.1">)*(size/</span><span class="hljs-number"><span class="koboSpan" id="kobo.2148.1">10</span></span><span class="koboSpan" id="kobo.2149.1">));
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2150.1">for</span></span><span class="koboSpan" id="kobo.2151.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2152.1">auto</span></span><span class="koboSpan" id="kobo.2153.1"> &amp; t : threads) t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2154.1">join</span></span><span class="koboSpan" id="kobo.2155.1">();
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2156.1">Use its </span><a id="_idIndexMarker1007"/><span class="koboSpan" id="kobo.2157.1">member functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.2158.1">fetch_and()</span></code><span class="koboSpan" id="kobo.2159.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2160.1">fetch_or()</span></code><span class="koboSpan" id="kobo.2161.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2162.1">fetch_xor()</span></code><span class="koboSpan" id="kobo.2163.1"> or non-member functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.2164.1">atomic_fetch_and()</span></code><span class="koboSpan" id="kobo.2165.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.2166.1">atomic_fetch_and_explicit()</span></code><span class="koboSpan" id="kobo.2167.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2168.1">atomic_fetch_or()</span></code><span class="koboSpan" id="kobo.2169.1">/ </span><code class="inlineCode"><span class="koboSpan" id="kobo.2170.1">atomic_fetch_or_explicit()</span></code><span class="koboSpan" id="kobo.2171.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2172.1">atomic_fetch_xor()</span></code><span class="koboSpan" id="kobo.2173.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.2174.1">atomic_fetch_xor_explicit()</span></code><span class="koboSpan" id="kobo.2175.1"> to perform AND, OR, and XOR atomic operations, respectively, with the specified argument and return the value of the atomic object before the operation.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2176.1">Use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2177.1">std::atomic_flag</span></code><span class="koboSpan" id="kobo.2178.1"> member functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.2179.1">test_and_set()</span></code><span class="koboSpan" id="kobo.2180.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2181.1">clear()</span></code><span class="koboSpan" id="kobo.2182.1"> or non-member functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.2183.1">atomic_flag_test_and_set()</span></code><span class="koboSpan" id="kobo.2184.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.2185.1">atomic_flag_test_and_set_explicit()</span></code><span class="koboSpan" id="kobo.2186.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2187.1">atomic_flag_clear()</span></code><span class="koboSpan" id="kobo.2188.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.2189.1">atomic_flag_clear_explicit()</span></code><span class="koboSpan" id="kobo.2190.1"> to set or reset an atomic flag. </span><span class="koboSpan" id="kobo.2190.2">In addition, in C++20, you can use the member function </span><code class="inlineCode"><span class="koboSpan" id="kobo.2191.1">test()</span></code><span class="koboSpan" id="kobo.2192.1"> and the non-member function </span><code class="inlineCode"><span class="koboSpan" id="kobo.2193.1">atomic_flag_test()</span></code><span class="koboSpan" id="kobo.2194.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.2195.1">atomic_flag_test_explicit()</span></code><span class="koboSpan" id="kobo.2196.1"> to atomically return the value of the flag.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2197.1">In C++20, perform thread synchronization with member functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.2198.1">wait()</span></code><span class="koboSpan" id="kobo.2199.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2200.1">notify_one()</span></code><span class="koboSpan" id="kobo.2201.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2202.1">notify_all()</span></code><span class="koboSpan" id="kobo.2203.1">, available to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2204.1">std::atomic</span></code><span class="koboSpan" id="kobo.2205.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2206.1">std::atomic_ref</span></code><span class="koboSpan" id="kobo.2207.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2208.1">std::atomic_flag</span></code><span class="koboSpan" id="kobo.2209.1">, as well as the non-member functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.2210.1">atomic_wait()</span></code><span class="koboSpan" id="kobo.2211.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.2212.1">atomic_wait_explicit()</span></code><span class="koboSpan" id="kobo.2213.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2214.1">atomic_notify_one()</span></code><span class="koboSpan" id="kobo.2215.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2216.1">atomic_notify_all()</span></code><span class="koboSpan" id="kobo.2217.1">. </span><span class="koboSpan" id="kobo.2217.2">These functions provide a more efficient mechanism for waiting for the value of an atomic object to change than polling.</span></li>
</ul>
<h2 class="heading-2" id="_idParaDest-533"><span class="koboSpan" id="kobo.2218.1">How it works...</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2219.1">std::atomic</span></code><span class="koboSpan" id="kobo.2220.1"> is a </span><a id="_idIndexMarker1008"/><span class="koboSpan" id="kobo.2221.1">class template that defines (including its specializations) an atomic type. </span><span class="koboSpan" id="kobo.2221.2">The behavior of an object of an atomic type is well defined when one thread writes to the object and the other reads data, without using locks to protect access. </span><span class="koboSpan" id="kobo.2221.3">The operations on atomic variables are treated as single, uninterruptable actions. </span><span class="koboSpan" id="kobo.2221.4">If two threads want to write on the same atomic variable, the first to take hold of it will write, while the other will wait for the atomic write to complete before it writes. </span><span class="koboSpan" id="kobo.2221.5">This is a deterministic behavior and does not require additional locking.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2222.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2223.1">std::atomic</span></code><span class="koboSpan" id="kobo.2224.1"> class</span><a id="_idIndexMarker1009"/><span class="koboSpan" id="kobo.2225.1"> provides several specializations:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2226.1">Full specialization for </span><code class="inlineCode"><span class="koboSpan" id="kobo.2227.1">bool</span></code><span class="koboSpan" id="kobo.2228.1">, with a typedef called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2229.1">atomic_bool</span></code><span class="koboSpan" id="kobo.2230.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2231.1">Full specialization for all integral types, with type aliases (typedefs) called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2232.1">atomic_bool</span></code><span class="koboSpan" id="kobo.2233.1"> (for </span><code class="inlineCode"><span class="koboSpan" id="kobo.2234.1">std::atomic&lt;bool&gt;</span></code><span class="koboSpan" id="kobo.2235.1">), </span><code class="inlineCode"><span class="koboSpan" id="kobo.2236.1">atomic_int</span></code><span class="koboSpan" id="kobo.2237.1"> (for </span><code class="inlineCode"><span class="koboSpan" id="kobo.2238.1">std::atomic&lt;int&gt;</span></code><span class="koboSpan" id="kobo.2239.1">), </span><code class="inlineCode"><span class="koboSpan" id="kobo.2240.1">atomic_long</span></code><span class="koboSpan" id="kobo.2241.1"> (for </span><code class="inlineCode"><span class="koboSpan" id="kobo.2242.1">std::atomic&lt;long&gt;</span></code><span class="koboSpan" id="kobo.2243.1">), </span><code class="inlineCode"><span class="koboSpan" id="kobo.2244.1">atomic_char</span></code><span class="koboSpan" id="kobo.2245.1"> (for </span><code class="inlineCode"><span class="koboSpan" id="kobo.2246.1">std::atomic&lt;char&gt;</span></code><span class="koboSpan" id="kobo.2247.1">), </span><code class="inlineCode"><span class="koboSpan" id="kobo.2248.1">atomic_size_t</span></code><span class="koboSpan" id="kobo.2249.1"> (for </span><code class="inlineCode"><span class="koboSpan" id="kobo.2250.1">std::atomic&lt;std::size_t&gt;</span></code><span class="koboSpan" id="kobo.2251.1">), and many others.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2252.1">Partial specialization for pointer types.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2253.1">In C++20, full specializations for the floating-point types </span><code class="inlineCode"><span class="koboSpan" id="kobo.2254.1">float</span></code><span class="koboSpan" id="kobo.2255.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2256.1">double</span></code><span class="koboSpan" id="kobo.2257.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2258.1">long double</span></code><span class="koboSpan" id="kobo.2259.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2260.1">In C++20, partial specializations such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2261.1">std::atomic&lt;std::shared_ptr&lt;U&gt;&gt;</span></code><span class="koboSpan" id="kobo.2262.1"> for </span><code class="inlineCode"><span class="koboSpan" id="kobo.2263.1">std::shared_ptr</span></code><span class="koboSpan" id="kobo.2264.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2265.1">std::atomic&lt;std::weak_ptr&lt;U&gt;&gt;</span></code><span class="koboSpan" id="kobo.2266.1"> for </span><code class="inlineCode"><span class="koboSpan" id="kobo.2267.1">std::weak_ptr</span></code><span class="koboSpan" id="kobo.2268.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2269.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2270.1">atomic</span></code><span class="koboSpan" id="kobo.2271.1"> class template has various member functions that perform atomic operations, such as the following:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2272.1">load()</span></code><span class="koboSpan" id="kobo.2273.1"> to atomically load and return the value of the object.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2274.1">store()</span></code><span class="koboSpan" id="kobo.2275.1"> to atomically store a non-atomic value in the object; this function does not return anything.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2276.1">exchange()</span></code><span class="koboSpan" id="kobo.2277.1"> to atomically store a non-atomic value in the object and return the previous value.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2278.1">operator=</span></code><span class="koboSpan" id="kobo.2279.1">, which has the same effect as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2280.1">store(arg)</span></code><span class="koboSpan" id="kobo.2281.1">.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2282.1">fetch_add()</span></code><span class="koboSpan" id="kobo.2283.1"> to atomically add a non-atomic argument to the atomic value and return the value stored previously.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2284.1">fetch_sub()</span></code><span class="koboSpan" id="kobo.2285.1"> to atomically subtract a non-atomic argument from the atomic value and return the value stored previously.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2286.1">fetch_and()</span></code><span class="koboSpan" id="kobo.2287.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2288.1">fetch_or()</span></code><span class="koboSpan" id="kobo.2289.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2290.1">fetch_xor()</span></code><span class="koboSpan" id="kobo.2291.1"> to atomically perform a bitwise AND, OR, or XOR operation between the argument and the atomic value; store the new value in the atomic object; and return the previous value.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2292.1">Prefixing and postfixing </span><code class="inlineCode"><span class="koboSpan" id="kobo.2293.1">operator++</span></code><span class="koboSpan" id="kobo.2294.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2295.1">operator--</span></code><span class="koboSpan" id="kobo.2296.1"> to atomically increment and decrement the value of the atomic object with 1. </span><span class="koboSpan" id="kobo.2296.2">These operations are equivalent to using </span><code class="inlineCode"><span class="koboSpan" id="kobo.2297.1">fetch_add()</span></code><span class="koboSpan" id="kobo.2298.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2299.1">fetch_sub()</span></code><span class="koboSpan" id="kobo.2300.1">.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2301.1">operator +=</span></code><span class="koboSpan" id="kobo.2302.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2303.1">-=</span></code><span class="koboSpan" id="kobo.2304.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2305.1">&amp;=</span></code><span class="koboSpan" id="kobo.2306.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2307.1">|=</span></code><span class="koboSpan" id="kobo.2308.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2309.1">ˆ=</span></code><span class="koboSpan" id="kobo.2310.1"> to add, subtract, or perform bitwise AND, OR, or XOR operations between the argument and the atomic value and store the new value in the atomic object. </span><span class="koboSpan" id="kobo.2310.2">These operations are equivalent to using </span><code class="inlineCode"><span class="koboSpan" id="kobo.2311.1">fetch_add()</span></code><span class="koboSpan" id="kobo.2312.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2313.1">fetch_sub()</span></code><span class="koboSpan" id="kobo.2314.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2315.1">fetch_and()</span></code><span class="koboSpan" id="kobo.2316.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2317.1">fetch_or()</span></code><span class="koboSpan" id="kobo.2318.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2319.1">fetch_xor()</span></code><span class="koboSpan" id="kobo.2320.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2321.1">Consider you </span><a id="_idIndexMarker1010"/><span class="koboSpan" id="kobo.2322.1">have an atomic variable, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2323.1">std::atomic&lt;int&gt; a</span></code><span class="koboSpan" id="kobo.2324.1">; the following is not an atomic operation:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2325.1">a = a + </span><span class="hljs-number"><span class="koboSpan" id="kobo.2326.1">42</span></span><span class="koboSpan" id="kobo.2327.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2328.1">This involves a series of operations, some of which are atomic:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2329.1">Atomically load the value of the atomic object</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2330.1">Add 42 to the value that was loaded (which is not an atomic operation)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2331.1">Atomically store the result in the atomic object </span><code class="inlineCode"><span class="koboSpan" id="kobo.2332.1">a</span></code></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2333.1">On the other hand, the following operation, which uses the member operator </span><code class="inlineCode"><span class="koboSpan" id="kobo.2334.1">+=</span></code><span class="koboSpan" id="kobo.2335.1">, is atomic:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2336.1">a += </span><span class="hljs-number"><span class="koboSpan" id="kobo.2337.1">42</span></span><span class="koboSpan" id="kobo.2338.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2339.1">This operation has the same effect as either of the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2340.1">a.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2341.1">fetch_add</span></span><span class="koboSpan" id="kobo.2342.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2343.1">42</span></span><span class="koboSpan" id="kobo.2344.1">);               </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2345.1">// using member function</span></span><span class="koboSpan" id="kobo.2346.1">
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2347.1">atomic_fetch_add</span></span><span class="koboSpan" id="kobo.2348.1">(&amp;a, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2349.1">42</span></span><span class="koboSpan" id="kobo.2350.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2351.1">// using non-member function</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2352.1">Though </span><code class="inlineCode"><span class="koboSpan" id="kobo.2353.1">std::atomic</span></code><span class="koboSpan" id="kobo.2354.1"> has a full specialization for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2355.1">bool</span></code><span class="koboSpan" id="kobo.2356.1"> type, called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2357.1">std::atomic&lt;bool&gt;</span></code><span class="koboSpan" id="kobo.2358.1">, the standard defines yet another atomic type called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2359.1">std::atomic_flag</span></code><span class="koboSpan" id="kobo.2360.1">, which is guaranteed to be lock-free. </span><span class="koboSpan" id="kobo.2360.2">This atomic type, however, is very different than </span><code class="inlineCode"><span class="koboSpan" id="kobo.2361.1">std::atomic&lt;bool&gt;</span></code><span class="koboSpan" id="kobo.2362.1">, and it has only the following member functions:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2363.1">test_and_set()</span></code><span class="koboSpan" id="kobo.2364.1"> atomically sets the value to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2365.1">true</span></code><span class="koboSpan" id="kobo.2366.1"> and returns the previous value.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2367.1">clear()</span></code><span class="koboSpan" id="kobo.2368.1"> atomically sets the value to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2369.1">false</span></code><span class="koboSpan" id="kobo.2370.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2371.1">In C++20, there’s </span><code class="inlineCode"><span class="koboSpan" id="kobo.2372.1">test()</span></code><span class="koboSpan" id="kobo.2373.1">, which atomically returns the value of the flag.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2374.1">Prior to C++20, the</span><a id="_idIndexMarker1011"/><span class="koboSpan" id="kobo.2375.1"> only way to initialize a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2376.1">std::atomic_flag</span></code><span class="koboSpan" id="kobo.2377.1"> to a definite value was by using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2378.1">ATOMIC_FLAG_INIT</span></code><span class="koboSpan" id="kobo.2379.1"> macro. </span><span class="koboSpan" id="kobo.2379.2">This initializes the atomic flag to the clear (</span><code class="inlineCode"><span class="koboSpan" id="kobo.2380.1">false</span></code><span class="koboSpan" id="kobo.2381.1">) value:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2382.1">std::atomic_flag lock = ATOMIC_FLAG_INIT;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2383.1">In C++20, this macro has been deprecated because the default constructor of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2384.1">std::atomic_flag</span></code><span class="koboSpan" id="kobo.2385.1"> initializes it to the clear state.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2386.1">All member functions mentioned earlier, for both </span><code class="inlineCode"><span class="koboSpan" id="kobo.2387.1">std::atomic</span></code><span class="koboSpan" id="kobo.2388.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2389.1">std::atomic_flag</span></code><span class="koboSpan" id="kobo.2390.1">, have non-member equivalents that are prefixed with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2391.1">atomic_</span></code><span class="koboSpan" id="kobo.2392.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2393.1">atomic_flag_</span></code><span class="koboSpan" id="kobo.2394.1">, depending on the type they refer to. </span><span class="koboSpan" id="kobo.2394.2">For instance, the equivalent of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2395.1">std::atomic::fetch_add()</span></code><span class="koboSpan" id="kobo.2396.1"> is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2397.1">std::atomic_fetch_add()</span></code><span class="koboSpan" id="kobo.2398.1">, and the first argument of these non-member functions is always a pointer to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2399.1">std::atomic</span></code><span class="koboSpan" id="kobo.2400.1"> object. </span><span class="koboSpan" id="kobo.2400.2">Internally, the non-member function calls the equivalent member function on the provided </span><code class="inlineCode"><span class="koboSpan" id="kobo.2401.1">std::atomic</span></code><span class="koboSpan" id="kobo.2402.1"> argument. </span><span class="koboSpan" id="kobo.2402.2">Similarly, the equivalent of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2403.1">std::atomic_flag::test_and_set()</span></code><span class="koboSpan" id="kobo.2404.1"> is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2405.1">std::atomic_flag_test_and_set()</span></code><span class="koboSpan" id="kobo.2406.1">, and its first parameter is a pointer to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2407.1">std::atomic_flag</span></code><span class="koboSpan" id="kobo.2408.1"> object.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2409.1">All these member functions of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2410.1">std::atomic</span></code><span class="koboSpan" id="kobo.2411.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2412.1">std::atomic_flag</span></code><span class="koboSpan" id="kobo.2413.1"> have two sets of overloads; one of them has an extra argument representing a memory order. </span><span class="koboSpan" id="kobo.2413.2">Similarly, all non-member functions – such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2414.1">std::atomic_load()</span></code><span class="koboSpan" id="kobo.2415.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2416.1">std::atomic_fetch_add()</span></code><span class="koboSpan" id="kobo.2417.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2418.1">std::atomic_flag_test_and_set()</span></code><span class="koboSpan" id="kobo.2419.1"> – have a companion with the suffix </span><code class="inlineCode"><span class="koboSpan" id="kobo.2420.1">_explicit</span></code><span class="koboSpan" id="kobo.2421.1"> – </span><code class="inlineCode"><span class="koboSpan" id="kobo.2422.1">std::atomic_load_explicit()</span></code><span class="koboSpan" id="kobo.2423.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2424.1">std::atomic_fetch_add_explicit()</span></code><span class="koboSpan" id="kobo.2425.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2426.1">std::atomic_flag_test_and_set_explicit()</span></code><span class="koboSpan" id="kobo.2427.1">; these functions have an extra argument that represents the memory order.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2428.1">The memory order specifies how non-atomic memory accesses are to be ordered around atomic operations. </span><span class="koboSpan" id="kobo.2428.2">By default, the memory order of all atomic types and operations is </span><em class="italic"><span class="koboSpan" id="kobo.2429.1">sequential consistency</span></em><span class="koboSpan" id="kobo.2430.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2431.1">Additional ordering types are defined in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2432.1">std::memory_order</span></code><span class="koboSpan" id="kobo.2433.1"> enumeration and can be passed as an argument to the member functions of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2434.1">std::atomic</span></code><span class="koboSpan" id="kobo.2435.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2436.1">std::atomic_flag</span></code><span class="koboSpan" id="kobo.2437.1">, or the non-member functions with the suffix </span><code class="inlineCode"><span class="koboSpan" id="kobo.2438.1">_explicit()</span></code><span class="koboSpan" id="kobo.2439.1">.</span></p>
<div class="note">
<p class="normal"><em class="italic"><span class="koboSpan" id="kobo.2440.1">Sequential consistency</span></em><span class="koboSpan" id="kobo.2441.1"> is a consistency model that requires that, in a multiprocessor system, all instructions are executed in some order and all writes become instantly visible throughout the system. </span><span class="koboSpan" id="kobo.2441.2">This model was first proposed by Leslie Lamport in the 70s, and is described as follows:</span></p>
<p class="normal"><em class="italic"><span class="koboSpan" id="kobo.2442.1">“the results of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program.”</span></em></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.2443.1">Various types </span><a id="_idIndexMarker1012"/><span class="koboSpan" id="kobo.2444.1">of memory ordering functions are described in the following table, taken from the C++ reference website (</span><a href="http://en.cppreference.com/w/cpp/atomic/memory_order"><span class="url"><span class="koboSpan" id="kobo.2445.1">http://en.cppreference.com/w/cpp/atomic/memory_order</span></span></a><span class="koboSpan" id="kobo.2446.1">). </span><span class="koboSpan" id="kobo.2446.2">The details of how each of these works is beyond the scope of this book and can be looked up in the standard C++ reference (see the previous link):</span></p>
<table class="table-container" id="table001-5">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.2447.1">Model</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.2448.1">Explanation</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2449.1">memory_order_relaxed</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2450.1">This is a relaxed operation. </span><span class="koboSpan" id="kobo.2450.2">There are no synchronization or ordering constraints; only atomicity is required from this operation.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2451.1">memory_order_consume</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2452.1">A load operation with this memory order performs a consume operation on the affected memory location; no reads or writes in the current thread that are dependent on the value currently loaded can be reordered before this load operation. </span><span class="koboSpan" id="kobo.2452.2">Writes to data-dependent variables in other threads that release the same atomic variable are visible in the current thread. </span><span class="koboSpan" id="kobo.2452.3">On most platforms, this affects compiler optimizations only.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2453.1">memory_order_acquire</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2454.1">A load operation with this memory order performs the acquire operation on the affected memory location; no reads or writes in the current thread can be reordered before this load. </span><span class="koboSpan" id="kobo.2454.2">All writes in other threads that release the same atomic variable are visible in the current thread.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2455.1">memory_order_release</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2456.1">A store operation with this memory order performs the release operation; no reads or writes in the current thread can be reordered after this store. </span><span class="koboSpan" id="kobo.2456.2">All writes in the current thread are visible in other threads that acquire the same atomic variable, and writes that carry a dependency to the atomic variable become visible in other threads that consume the same atomic variable.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2457.1">memory_order_acq_rel</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2458.1">A read-modify-write operation with this memory order is both an acquire operation and a release operation. </span><span class="koboSpan" id="kobo.2458.2">No memory reads or writes in the current thread can be reordered before or after this store. </span><span class="koboSpan" id="kobo.2458.3">All writes in other threads that release the same atomic variable are visible before the modification, and the modification is visible in other threads that acquire the same atomic variable.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2459.1">memory_order_seq_cst</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2460.1">Any operation with this memory order is both an acquire operation and a release operation; a single total order exists in which all threads observe all modifications in the same order.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.2461.1">Table 8.1: std::memory_order members that describe how memory access is ordered for an atomic operation</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2462.1">The first </span><a id="_idIndexMarker1013"/><span class="koboSpan" id="kobo.2463.1">example in the </span><em class="italic"><span class="koboSpan" id="kobo.2464.1">How to do it...</span></em><span class="koboSpan" id="kobo.2465.1"> section shows several threads repeatedly modifying a shared resource – a counter – by incrementing it concurrently. </span><span class="koboSpan" id="kobo.2465.2">This example can be refined further by implementing a class to represent an atomic counter with methods such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2466.1">increment()</span></code><span class="koboSpan" id="kobo.2467.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2468.1">decrement()</span></code><span class="koboSpan" id="kobo.2469.1">, which modify the value of the counter, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2470.1">get()</span></code><span class="koboSpan" id="kobo.2471.1">, which retrieves its current value:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2472.1">template</span></span><span class="koboSpan" id="kobo.2473.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2474.1">typename</span></span><span class="koboSpan" id="kobo.2475.1"> T, 
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2476.1">typename</span></span><span class="koboSpan" id="kobo.2477.1"> I = 
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2478.1">typename</span></span><span class="koboSpan" id="kobo.2479.1"> std::enable_if&lt;std::is_integral_v&lt;T&gt;&gt;::type&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2480.1">class</span></span><span class="koboSpan" id="kobo.2481.1"> atomic_counter
{
  std::atomic&lt;T&gt; counter {</span><span class="hljs-number"><span class="koboSpan" id="kobo.2482.1">0</span></span><span class="koboSpan" id="kobo.2483.1">};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2484.1">public</span></span><span class="koboSpan" id="kobo.2485.1">:
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.2486.1">T </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2487.1">increment</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2488.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.2489.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2490.1">return</span></span><span class="koboSpan" id="kobo.2491.1"> counter.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2492.1">fetch_add</span></span><span class="koboSpan" id="kobo.2493.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2494.1">1</span></span><span class="koboSpan" id="kobo.2495.1">);
  }
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.2496.1">T </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2497.1">decrement</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2498.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.2499.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2500.1">return</span></span><span class="koboSpan" id="kobo.2501.1"> counter.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2502.1">fetch_sub</span></span><span class="koboSpan" id="kobo.2503.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2504.1">1</span></span><span class="koboSpan" id="kobo.2505.1">);
  }
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.2506.1">T </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2507.1">get</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2508.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.2509.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2510.1">return</span></span><span class="koboSpan" id="kobo.2511.1"> counter.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2512.1">load</span></span><span class="koboSpan" id="kobo.2513.1">();
  }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2514.1">With this class</span><a id="_idIndexMarker1014"/><span class="koboSpan" id="kobo.2515.1"> template, the first example can be rewritten in the following form with the same result:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2516.1">atomic_counter&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2517.1">int</span></span><span class="koboSpan" id="kobo.2518.1">&gt; counter;
std::vector&lt;std::thread&gt; threads;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2519.1">for</span></span><span class="koboSpan" id="kobo.2520.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.2521.1">int</span></span><span class="koboSpan" id="kobo.2522.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2523.1">0</span></span><span class="koboSpan" id="kobo.2524.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.2525.1">10</span></span><span class="koboSpan" id="kobo.2526.1">; ++i)
{
  threads.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2527.1">emplace_back</span></span><span class="koboSpan" id="kobo.2528.1">([&amp;counter](){
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2529.1">for</span></span><span class="koboSpan" id="kobo.2530.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.2531.1">int</span></span><span class="koboSpan" id="kobo.2532.1"> j = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2533.1">0</span></span><span class="koboSpan" id="kobo.2534.1">; j &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.2535.1">10</span></span><span class="koboSpan" id="kobo.2536.1">; ++j)
      counter.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2537.1">increment</span></span><span class="koboSpan" id="kobo.2538.1">();
  });
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2539.1">for</span></span><span class="koboSpan" id="kobo.2540.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2541.1">auto</span></span><span class="koboSpan" id="kobo.2542.1"> &amp; t : threads) t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2543.1">join</span></span><span class="koboSpan" id="kobo.2544.1">();
std::cout &lt;&lt; counter.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2545.1">get</span></span><span class="koboSpan" id="kobo.2546.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2547.1">'\n'</span></span><span class="koboSpan" id="kobo.2548.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2549.1">// prints 100</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2550.1">If you need to perform atomic operations on references, you cannot use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2551.1">std::atomic</span></code><span class="koboSpan" id="kobo.2552.1">. </span><span class="koboSpan" id="kobo.2552.2">However, in C++20, you can use the new </span><code class="inlineCode"><span class="koboSpan" id="kobo.2553.1">std::atomic_ref</span></code><span class="koboSpan" id="kobo.2554.1"> type. </span><span class="koboSpan" id="kobo.2554.2">This is a class template that applies atomic operations to the object it references. </span><span class="koboSpan" id="kobo.2554.3">This object must outlive the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2555.1">std::atomic_ref</span></code><span class="koboSpan" id="kobo.2556.1"> object and, as long as any </span><code class="inlineCode"><span class="koboSpan" id="kobo.2557.1">std::atomic_ref</span></code><span class="koboSpan" id="kobo.2558.1"> instance referencing this object exists, the object must be accessed only through the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2559.1">std::atomic_ref</span></code><span class="koboSpan" id="kobo.2560.1"> instances.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2561.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2562.1">std::atomic_ref</span></code><span class="koboSpan" id="kobo.2563.1"> type has the following specializations:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2564.1">The primary template can be instantiated with any trivially copyable type </span><code class="inlineCode"><span class="koboSpan" id="kobo.2565.1">T</span></code><span class="koboSpan" id="kobo.2566.1">, including </span><code class="inlineCode"><span class="koboSpan" id="kobo.2567.1">bool</span></code><span class="koboSpan" id="kobo.2568.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2569.1">Partial specialization for all pointer types.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2570.1">Specializations for integral types (character types, signed and unsigned integer types, and any additional integral types needed by the typedefs in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2571.1">&lt;cstdint&gt;</span></code><span class="koboSpan" id="kobo.2572.1"> header).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2573.1">Specializations for the floating-point types </span><code class="inlineCode"><span class="koboSpan" id="kobo.2574.1">float</span></code><span class="koboSpan" id="kobo.2575.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2576.1">double</span></code><span class="koboSpan" id="kobo.2577.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2578.1">long double</span></code><span class="koboSpan" id="kobo.2579.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2580.1">When using </span><code class="inlineCode"><span class="koboSpan" id="kobo.2581.1">std::atomic_ref</span></code><span class="koboSpan" id="kobo.2582.1">, you must keep in mind that:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2583.1">It is not thread-safe to access any sub-object of the object referenced by a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2584.1">std::atomic_ref</span></code><span class="koboSpan" id="kobo.2585.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2586.1">It is possible to modify the referenced value through a const </span><code class="inlineCode"><span class="koboSpan" id="kobo.2587.1">std::atomic_ref</span></code><span class="koboSpan" id="kobo.2588.1"> object.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2589.1">Also, in C++20, there </span><a id="_idIndexMarker1015"/><span class="koboSpan" id="kobo.2590.1">are new member and non-member functions that provide an efficient thread-synchronization mechanism:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2591.1">The member function </span><code class="inlineCode"><span class="koboSpan" id="kobo.2592.1">wait()</span></code><span class="koboSpan" id="kobo.2593.1"> and non-member functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.2594.1">atomic_wait()</span></code><span class="koboSpan" id="kobo.2595.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.2596.1">atomic_wait_explicit()</span></code><span class="koboSpan" id="kobo.2597.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2598.1">atomic_flag_wait()</span></code><span class="koboSpan" id="kobo.2599.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.2600.1">atomic_flag_wait_explicit()</span></code><span class="koboSpan" id="kobo.2601.1"> perform atomic wait operations, blocking a thread until notified and the atomic value changes. </span><span class="koboSpan" id="kobo.2601.2">Its behavior is similar to repeatedly comparing the provided argument with the value returned by </span><code class="inlineCode"><span class="koboSpan" id="kobo.2602.1">load()</span></code><span class="koboSpan" id="kobo.2603.1"> and, if equal, blocks until notified by </span><code class="inlineCode"><span class="koboSpan" id="kobo.2604.1">notify_one()</span></code><span class="koboSpan" id="kobo.2605.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2606.1">notify_all()</span></code><span class="koboSpan" id="kobo.2607.1">, or the thread is unblocked spuriously. </span><span class="koboSpan" id="kobo.2607.2">If the compared values are not equal, then the function returns without blocking.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2608.1">The member function </span><code class="inlineCode"><span class="koboSpan" id="kobo.2609.1">notify_one()</span></code><span class="koboSpan" id="kobo.2610.1"> and non-member functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.2611.1">atomic_notify_one()</span></code><span class="koboSpan" id="kobo.2612.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2613.1">atomic_flag_notify_one()</span></code><span class="koboSpan" id="kobo.2614.1"> notify, atomically, at least one thread blocked in an atomic waiting operation. </span><span class="koboSpan" id="kobo.2614.2">If there is no such thread blocked, the function does nothing.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2615.1">The member function </span><code class="inlineCode"><span class="koboSpan" id="kobo.2616.1">notify_all()</span></code><span class="koboSpan" id="kobo.2617.1"> and the non-member functions </span><code class="inlineCode"><span class="koboSpan" id="kobo.2618.1">atomic_notify_all()</span></code><span class="koboSpan" id="kobo.2619.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2620.1">atomic_flag_notify_all()</span></code><span class="koboSpan" id="kobo.2621.1"> unblock all the threads blocked in an atomic waiting operation or do nothing if no such thread exists.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2622.1">Finally, it should be mentioned that all the atomic objects from the standard atomic operations library – </span><code class="inlineCode"><span class="koboSpan" id="kobo.2623.1">std::atomic</span></code><span class="koboSpan" id="kobo.2624.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2625.1">std::atomic_ref</span></code><span class="koboSpan" id="kobo.2626.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2627.1">std::atomic_flag</span></code><span class="koboSpan" id="kobo.2628.1"> – are free of data races.</span></p>
<h2 class="heading-2" id="_idParaDest-534"><span class="koboSpan" id="kobo.2629.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2630.1">Working with threads</span></em><span class="koboSpan" id="kobo.2631.1">, to learn about the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2632.1">std::thread</span></code><span class="koboSpan" id="kobo.2633.1"> class and the basic operations for working with threads in C++</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2634.1">Synchronizing access to shared data with mutexes and locks</span></em><span class="koboSpan" id="kobo.2635.1">, to see what mechanisms are available for synchronizing thread access to shared data and how they work</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2636.1">Executing functions asynchronously</span></em><span class="koboSpan" id="kobo.2637.1">, to learn how to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2638.1">std::future</span></code><span class="koboSpan" id="kobo.2639.1"> class and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2640.1">std::async()</span></code><span class="koboSpan" id="kobo.2641.1"> function to execute functions asynchronously on different threads and communicate the result back</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-535"><span class="koboSpan" id="kobo.2642.1">Implementing parallel map and fold with threads</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2643.1">In </span><em class="italic"><span class="koboSpan" id="kobo.2644.1">Chapter 3</span></em><span class="koboSpan" id="kobo.2645.1">, </span><em class="italic"><span class="koboSpan" id="kobo.2646.1">Exploring Functions</span></em><span class="koboSpan" id="kobo.2647.1">, we discussed two higher-order functions: </span><code class="inlineCode"><span class="koboSpan" id="kobo.2648.1">map</span></code><span class="koboSpan" id="kobo.2649.1">, which applies a function to the elements of a range by either transforming the range or producing a </span><a id="_idIndexMarker1016"/><span class="koboSpan" id="kobo.2650.1">new range, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2651.1">fold</span></code><span class="koboSpan" id="kobo.2652.1"> (also referred to as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2653.1">reduce</span></code><span class="koboSpan" id="kobo.2654.1">), which combines the elements of a range into a single value. </span><span class="koboSpan" id="kobo.2654.2">The </span><a id="_idIndexMarker1017"/><span class="koboSpan" id="kobo.2655.1">various implementations we did were sequential. </span><span class="koboSpan" id="kobo.2655.2">However, in the context of concurrency, threads, and asynchronous tasks, we can leverage the hardware and run parallel versions of these functions to speed up their execution for large ranges, or when the transformation and aggregation are time-consuming. </span><span class="koboSpan" id="kobo.2655.3">In this recipe, we will see a possible solution for implementing </span><code class="inlineCode"><span class="koboSpan" id="kobo.2656.1">map</span></code><span class="koboSpan" id="kobo.2657.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2658.1">fold</span></code><span class="koboSpan" id="kobo.2659.1"> using threads.</span></p>
<h2 class="heading-2" id="_idParaDest-536"><span class="koboSpan" id="kobo.2660.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2661.1">You need to be familiar with the concepts of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2662.1">map</span></code><span class="koboSpan" id="kobo.2663.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2664.1">fold</span></code><span class="koboSpan" id="kobo.2665.1"> functions. </span><span class="koboSpan" id="kobo.2665.2">It is recommended that you read the </span><em class="italic"><span class="koboSpan" id="kobo.2666.1">Implementing higher-order functions map and fold</span></em><span class="koboSpan" id="kobo.2667.1"> recipe from </span><em class="chapterRef"><span class="koboSpan" id="kobo.2668.1">Chapter 3</span></em><span class="koboSpan" id="kobo.2669.1">, </span><em class="italic"><span class="koboSpan" id="kobo.2670.1">Exploring Functions</span></em><span class="koboSpan" id="kobo.2671.1">. </span><span class="koboSpan" id="kobo.2671.2">In this recipe, we will use the various thread functionalities presented in the </span><em class="italic"><span class="koboSpan" id="kobo.2672.1">Working with threads</span></em><span class="koboSpan" id="kobo.2673.1"> recipe.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2674.1">To measure the execution time of these functions and compare it with sequential alternatives, we will use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2675.1">perf_timer</span></code><span class="koboSpan" id="kobo.2676.1"> class template, which we introduced in the </span><em class="italic"><span class="koboSpan" id="kobo.2677.1">Measuring function execution time with a standard clock</span></em><span class="koboSpan" id="kobo.2678.1"> recipe in </span><em class="chapterRef"><span class="koboSpan" id="kobo.2679.1">Chapter 6</span></em><span class="koboSpan" id="kobo.2680.1">, </span><em class="italic"><span class="koboSpan" id="kobo.2681.1">General-Purpose Utilities</span></em><span class="koboSpan" id="kobo.2682.1">.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2683.1">A parallel version of an algorithm can potentially speed up execution time, but this is not necessarily true in all circumstances. </span><span class="koboSpan" id="kobo.2683.2">Context switching for threads and synchronized access to shared data can introduce a significant overhead. </span><span class="koboSpan" id="kobo.2683.3">For some implementations and particular datasets, this overhead could make a parallel version actually take a longer time to execute than a sequential version.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.2684.1">To determine the number of threads required to split the work, we will use the following function:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.2685.1">unsigned</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2686.1">get_no_of_threads</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2687.1">()</span></span><span class="koboSpan" id="kobo.2688.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2689.1">return</span></span><span class="koboSpan" id="kobo.2690.1"> std::thread::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2691.1">hardware_concurrency</span></span><span class="koboSpan" id="kobo.2692.1">();
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2693.1">We’ll explore </span><a id="_idIndexMarker1018"/><span class="koboSpan" id="kobo.2694.1">the first possible implementation for a parallel version of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2695.1">map</span></code><span class="koboSpan" id="kobo.2696.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2697.1">fold</span></code><span class="koboSpan" id="kobo.2698.1"> functions in the next section.</span></p>
<h2 class="heading-2" id="_idParaDest-537"><span class="koboSpan" id="kobo.2699.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2700.1">To </span><a id="_idIndexMarker1019"/><span class="koboSpan" id="kobo.2701.1">implement a parallel version of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2702.1">map</span></code><span class="koboSpan" id="kobo.2703.1"> function, do the following:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.2704.1">Define a function template that takes the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2705.1">begin</span></code><span class="koboSpan" id="kobo.2706.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2707.1">end</span></code><span class="koboSpan" id="kobo.2708.1"> iterators of a range and a function to apply to all the elements:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2709.1">template</span></span><span class="koboSpan" id="kobo.2710.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2711.1">typename</span></span><span class="koboSpan" id="kobo.2712.1"> Iter, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2713.1">typename</span></span><span class="koboSpan" id="kobo.2714.1"> F&gt;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2715.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2716.1">parallel_map</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2717.1">(Iter begin, Iter end, F&amp;&amp; f)</span></span><span class="koboSpan" id="kobo.2718.1">
{
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.2719.1">Check the size of the range. </span><span class="koboSpan" id="kobo.2719.2">If the number of elements is smaller than a predefined threshold (for this implementation, the threshold is 10,000), execute the mapping in a sequential manner:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2720.1">auto</span></span><span class="koboSpan" id="kobo.2721.1"> size = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2722.1">distance</span></span><span class="koboSpan" id="kobo.2723.1">(begin, end);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2724.1">if</span></span><span class="koboSpan" id="kobo.2725.1">(size &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.2726.1">10000</span></span><span class="koboSpan" id="kobo.2727.1">)
  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2728.1">transform</span></span><span class="koboSpan" id="kobo.2729.1">(begin, end, begin, std::forward&lt;F&gt;(f));
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.2730.1">For larger ranges, split the work on multiple threads and let each thread map be a part of the range. </span><span class="koboSpan" id="kobo.2730.2">These parts should not overlap to avoid the need to synchronize access to the shared data:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2731.1">else</span></span><span class="koboSpan" id="kobo.2732.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2733.1">auto</span></span><span class="koboSpan" id="kobo.2734.1"> no_of_threads = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2735.1">get_no_of_threads</span></span><span class="koboSpan" id="kobo.2736.1">();
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2737.1">auto</span></span><span class="koboSpan" id="kobo.2738.1"> part = size / no_of_threads;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2739.1">auto</span></span><span class="koboSpan" id="kobo.2740.1"> last = begin;
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2741.1">// continued at 4. </span><span class="koboSpan" id="kobo.2741.2">and 5.</span></span><span class="koboSpan" id="kobo.2742.1">
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.2743.1">Start the threads, and on each thread, run a sequential version of the mapping:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2744.1">std::vector&lt;std::thread&gt; threads;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2745.1">for</span></span><span class="koboSpan" id="kobo.2746.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.2747.1">unsigned</span></span><span class="koboSpan" id="kobo.2748.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2749.1">0</span></span><span class="koboSpan" id="kobo.2750.1">; i &lt; no_of_threads; ++i)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2751.1">if</span></span><span class="koboSpan" id="kobo.2752.1">(i == no_of_threads - </span><span class="hljs-number"><span class="koboSpan" id="kobo.2753.1">1</span></span><span class="koboSpan" id="kobo.2754.1">) last = end;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2755.1">else</span></span><span class="koboSpan" id="kobo.2756.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2757.1">advance</span></span><span class="koboSpan" id="kobo.2758.1">(last, part);
  threads.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2759.1">emplace_back</span></span><span class="koboSpan" id="kobo.2760.1">(
    [=,&amp;f]{std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2761.1">transform</span></span><span class="koboSpan" id="kobo.2762.1">(begin, last, 
                          begin, std::forward&lt;F&gt;(f));});
  begin = last;
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.2763.1">Wait until all the threads have finished their execution:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2764.1">for</span></span><span class="koboSpan" id="kobo.2765.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2766.1">auto</span></span><span class="koboSpan" id="kobo.2767.1"> &amp; t : threads) t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2768.1">join</span></span><span class="koboSpan" id="kobo.2769.1">();
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.2770.1">The </span><a id="_idIndexMarker1020"/><span class="koboSpan" id="kobo.2771.1">preceding steps, when put together, result </span><a id="_idIndexMarker1021"/><span class="koboSpan" id="kobo.2772.1">in the following implementation:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2773.1">template</span></span><span class="koboSpan" id="kobo.2774.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2775.1">typename</span></span><span class="koboSpan" id="kobo.2776.1"> Iter, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2777.1">typename</span></span><span class="koboSpan" id="kobo.2778.1"> F&gt;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2779.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2780.1">parallel_map</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2781.1">(Iter begin, Iter end, F&amp;&amp; f)</span></span><span class="koboSpan" id="kobo.2782.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2783.1">auto</span></span><span class="koboSpan" id="kobo.2784.1"> size = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2785.1">distance</span></span><span class="koboSpan" id="kobo.2786.1">(begin, end);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2787.1">if</span></span><span class="koboSpan" id="kobo.2788.1">(size &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.2789.1">10000</span></span><span class="koboSpan" id="kobo.2790.1">)
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2791.1">transform</span></span><span class="koboSpan" id="kobo.2792.1">(begin, end, begin, std::forward&lt;F&gt;(f)); 
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2793.1">else</span></span><span class="koboSpan" id="kobo.2794.1">
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2795.1">auto</span></span><span class="koboSpan" id="kobo.2796.1"> no_of_threads = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2797.1">get_no_of_threads</span></span><span class="koboSpan" id="kobo.2798.1">();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2799.1">auto</span></span><span class="koboSpan" id="kobo.2800.1"> part = size / no_of_threads;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2801.1">auto</span></span><span class="koboSpan" id="kobo.2802.1"> last = begin;
    std::vector&lt;std::thread&gt; threads;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2803.1">for</span></span><span class="koboSpan" id="kobo.2804.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.2805.1">unsigned</span></span><span class="koboSpan" id="kobo.2806.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2807.1">0</span></span><span class="koboSpan" id="kobo.2808.1">; i &lt; no_of_threads; ++i)
    {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2809.1">if</span></span><span class="koboSpan" id="kobo.2810.1">(i == no_of_threads - </span><span class="hljs-number"><span class="koboSpan" id="kobo.2811.1">1</span></span><span class="koboSpan" id="kobo.2812.1">) last = end;
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2813.1">else</span></span><span class="koboSpan" id="kobo.2814.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2815.1">advance</span></span><span class="koboSpan" id="kobo.2816.1">(last, part);
      threads.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2817.1">emplace_back</span></span><span class="koboSpan" id="kobo.2818.1">(
        [=,&amp;f]{std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2819.1">transform</span></span><span class="koboSpan" id="kobo.2820.1">(begin, last, 
                              begin, std::forward&lt;F&gt;(f));});
      begin = last;
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2821.1">for</span></span><span class="koboSpan" id="kobo.2822.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2823.1">auto</span></span><span class="koboSpan" id="kobo.2824.1"> &amp; t : threads) t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2825.1">join</span></span><span class="koboSpan" id="kobo.2826.1">();
  }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2827.1">To implement a </span><a id="_idIndexMarker1022"/><span class="koboSpan" id="kobo.2828.1">parallel version of</span><a id="_idIndexMarker1023"/><span class="koboSpan" id="kobo.2829.1"> the left </span><code class="inlineCode"><span class="koboSpan" id="kobo.2830.1">fold</span></code><span class="koboSpan" id="kobo.2831.1"> function, do the following:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.2832.1">Define a function template that takes a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2833.1">begin</span></code><span class="koboSpan" id="kobo.2834.1"> and an </span><code class="inlineCode"><span class="koboSpan" id="kobo.2835.1">end</span></code><span class="koboSpan" id="kobo.2836.1"> iterator for a range, an initial value, and a binary function to apply to the elements of the range:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2837.1">template</span></span><span class="koboSpan" id="kobo.2838.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2839.1">typename</span></span><span class="koboSpan" id="kobo.2840.1"> Iter, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2841.1">typename</span></span><span class="koboSpan" id="kobo.2842.1"> R, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2843.1">typename</span></span><span class="koboSpan" id="kobo.2844.1"> F&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2845.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2846.1">parallel_fold</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2847.1">(Iter begin, Iter end, R init, F&amp;&amp; op)</span></span><span class="koboSpan" id="kobo.2848.1">
{
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.2849.1">Check the size of the range. </span><span class="koboSpan" id="kobo.2849.2">If the number of elements is smaller than a predefined threshold (for this implementation, it is 10,000), execute the folding in a sequential manner:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2850.1">auto</span></span><span class="koboSpan" id="kobo.2851.1"> size = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2852.1">distance</span></span><span class="koboSpan" id="kobo.2853.1">(begin, end);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2854.1">if</span></span><span class="koboSpan" id="kobo.2855.1">(size &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.2856.1">10000</span></span><span class="koboSpan" id="kobo.2857.1">)
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2858.1">return</span></span><span class="koboSpan" id="kobo.2859.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2860.1">accumulate</span></span><span class="koboSpan" id="kobo.2861.1">(begin, end, 
                         init, std::forward&lt;F&gt;(op));
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.2862.1">For larger ranges, split the work into multiple threads and let each thread fold a part of the range. </span><span class="koboSpan" id="kobo.2862.2">These parts should not overlap in order to avoid thread synchronization of shared data. </span><span class="koboSpan" id="kobo.2862.3">The result can be returned through a reference passed to the thread function in order to avoid data synchronization:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2863.1">else</span></span><span class="koboSpan" id="kobo.2864.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2865.1">auto</span></span><span class="koboSpan" id="kobo.2866.1"> no_of_threads = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2867.1">get_no_of_threads</span></span><span class="koboSpan" id="kobo.2868.1">();
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2869.1">auto</span></span><span class="koboSpan" id="kobo.2870.1"> part = size / no_of_threads;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2871.1">auto</span></span><span class="koboSpan" id="kobo.2872.1"> last = begin;
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2873.1">// continued with 4. </span><span class="koboSpan" id="kobo.2873.2">and 5.</span></span><span class="koboSpan" id="kobo.2874.1">
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.2875.1">Start the threads, and on each thread, execute a sequential version of the folding:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2876.1">std::vector&lt;std::thread&gt; threads;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.2877.1">std::vector&lt;R&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2878.1">values</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2879.1">(no_of_threads)</span></span><span class="koboSpan" id="kobo.2880.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2881.1">for</span></span><span class="koboSpan" id="kobo.2882.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.2883.1">unsigned</span></span><span class="koboSpan" id="kobo.2884.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2885.1">0</span></span><span class="koboSpan" id="kobo.2886.1">; i &lt; no_of_threads; ++i)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2887.1">if</span></span><span class="koboSpan" id="kobo.2888.1">(i == no_of_threads - </span><span class="hljs-number"><span class="koboSpan" id="kobo.2889.1">1</span></span><span class="koboSpan" id="kobo.2890.1">) last = end;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2891.1">else</span></span><span class="koboSpan" id="kobo.2892.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2893.1">advance</span></span><span class="koboSpan" id="kobo.2894.1">(last, part);
  threads.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2895.1">emplace_back</span></span><span class="koboSpan" id="kobo.2896.1">(
    [=,&amp;op](R&amp; result){
      result = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2897.1">accumulate</span></span><span class="koboSpan" id="kobo.2898.1">(begin, last, R{}, 
                               std::forward&lt;F&gt;(op));},
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2899.1">ref</span></span><span class="koboSpan" id="kobo.2900.1">(values[i]));
  begin = last;
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.2901.1">Wait</span><a id="_idIndexMarker1024"/><span class="koboSpan" id="kobo.2902.1"> until all the threads have finished execution and fold the partial results into the final result:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2903.1">for</span></span><span class="koboSpan" id="kobo.2904.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2905.1">auto</span></span><span class="koboSpan" id="kobo.2906.1"> &amp; t : threads) t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2907.1">join</span></span><span class="koboSpan" id="kobo.2908.1">();
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2909.1">return</span></span><span class="koboSpan" id="kobo.2910.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2911.1">accumulate</span></span><span class="koboSpan" id="kobo.2912.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2913.1">begin</span></span><span class="koboSpan" id="kobo.2914.1">(values), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2915.1">end</span></span><span class="koboSpan" id="kobo.2916.1">(values),
                       init, std::forward&lt;F&gt;(op));
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.2917.1">The steps</span><a id="_idIndexMarker1025"/><span class="koboSpan" id="kobo.2918.1"> we just put together result in the following implementation:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2919.1">template</span></span><span class="koboSpan" id="kobo.2920.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2921.1">typename</span></span><span class="koboSpan" id="kobo.2922.1"> Iter, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2923.1">typename</span></span><span class="koboSpan" id="kobo.2924.1"> R, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2925.1">typename</span></span><span class="koboSpan" id="kobo.2926.1"> F&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2927.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2928.1">parallel_fold</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2929.1">(Iter begin, Iter end, R init, F&amp;&amp; op)</span></span><span class="koboSpan" id="kobo.2930.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2931.1">auto</span></span><span class="koboSpan" id="kobo.2932.1"> size = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2933.1">distance</span></span><span class="koboSpan" id="kobo.2934.1">(begin, end);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2935.1">if</span></span><span class="koboSpan" id="kobo.2936.1">(size &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.2937.1">10000</span></span><span class="koboSpan" id="kobo.2938.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2939.1">return</span></span><span class="koboSpan" id="kobo.2940.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2941.1">accumulate</span></span><span class="koboSpan" id="kobo.2942.1">(begin, end, init, std::forward&lt;F&gt;(op));
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2943.1">else</span></span><span class="koboSpan" id="kobo.2944.1">
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2945.1">auto</span></span><span class="koboSpan" id="kobo.2946.1"> no_of_threads = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2947.1">get_no_of_threads</span></span><span class="koboSpan" id="kobo.2948.1">();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2949.1">auto</span></span><span class="koboSpan" id="kobo.2950.1"> part = size / no_of_threads;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2951.1">auto</span></span><span class="koboSpan" id="kobo.2952.1"> last = begin;
    std::vector&lt;std::thread&gt; threads;
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.2953.1">std::vector&lt;R&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2954.1">values</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2955.1">(no_of_threads)</span></span><span class="koboSpan" id="kobo.2956.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2957.1">for</span></span><span class="koboSpan" id="kobo.2958.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.2959.1">unsigned</span></span><span class="koboSpan" id="kobo.2960.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2961.1">0</span></span><span class="koboSpan" id="kobo.2962.1">; i &lt; no_of_threads; ++i)
    {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2963.1">if</span></span><span class="koboSpan" id="kobo.2964.1">(i == no_of_threads - </span><span class="hljs-number"><span class="koboSpan" id="kobo.2965.1">1</span></span><span class="koboSpan" id="kobo.2966.1">) last = end;
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2967.1">else</span></span><span class="koboSpan" id="kobo.2968.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2969.1">advance</span></span><span class="koboSpan" id="kobo.2970.1">(last, part);
      threads.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2971.1">emplace_back</span></span><span class="koboSpan" id="kobo.2972.1">(
        [=,&amp;op](R&amp; result){
          result = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2973.1">accumulate</span></span><span class="koboSpan" id="kobo.2974.1">(begin, last, R{}, 
                                   std::forward&lt;F&gt;(op));},
        std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2975.1">ref</span></span><span class="koboSpan" id="kobo.2976.1">(values[i]));
      begin = last;
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2977.1">for</span></span><span class="koboSpan" id="kobo.2978.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2979.1">auto</span></span><span class="koboSpan" id="kobo.2980.1"> &amp; t : threads) t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2981.1">join</span></span><span class="koboSpan" id="kobo.2982.1">();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2983.1">return</span></span><span class="koboSpan" id="kobo.2984.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2985.1">accumulate</span></span><span class="koboSpan" id="kobo.2986.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2987.1">begin</span></span><span class="koboSpan" id="kobo.2988.1">(values), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2989.1">end</span></span><span class="koboSpan" id="kobo.2990.1">(values), 
                           init, std::forward&lt;F&gt;(op));
  }
}
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-538"><span class="koboSpan" id="kobo.2991.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2992.1">These </span><a id="_idIndexMarker1026"/><span class="koboSpan" id="kobo.2993.1">parallel implementations</span><a id="_idIndexMarker1027"/><span class="koboSpan" id="kobo.2994.1"> of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2995.1">map</span></code><span class="koboSpan" id="kobo.2996.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2997.1">fold</span></code><span class="koboSpan" id="kobo.2998.1"> are similar in several aspects:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2999.1">They both fall back to a sequential version if the number of elements in the range is smaller than 10,000.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3000.1">They both start the same number of threads. </span><span class="koboSpan" id="kobo.3000.2">These threads are determined using the static function </span><code class="inlineCode"><span class="koboSpan" id="kobo.3001.1">std::thread::hardware_concurrency()</span></code><span class="koboSpan" id="kobo.3002.1">, which returns the number of concurrent threads supported by the implementation. </span><span class="koboSpan" id="kobo.3002.2">However, this value is more of a hint than an accurate value and should be used with that in mind.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3003.1">No shared data is used to avoid synchronization of access. </span><span class="koboSpan" id="kobo.3003.2">Even though all the threads work on the elements from the same range, they all process parts of the range that do not overlap.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3004.1">Both of these functions are implemented as function templates that take a begin and an end iterator to define the range to be processed. </span><span class="koboSpan" id="kobo.3004.2">In order to split the range into multiple parts to be processed independently by different threads, use additional iterators in the middle of the range. </span><span class="koboSpan" id="kobo.3004.3">For this, we use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3005.1">std::advance()</span></code><span class="koboSpan" id="kobo.3006.1"> to increment an iterator with a particular number of positions. </span><span class="koboSpan" id="kobo.3006.2">This works well for vectors or arrays but is very inefficient for containers such as lists. </span><span class="koboSpan" id="kobo.3006.3">Therefore, this implementation is suited only for ranges that have random access iterators.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.3007.1">The </span><a id="_idIndexMarker1028"/><span class="koboSpan" id="kobo.3008.1">sequential versions of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3009.1">map</span></code><span class="koboSpan" id="kobo.3010.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3011.1">fold</span></code><span class="koboSpan" id="kobo.3012.1"> can be simply implemented in C++ with </span><code class="inlineCode"><span class="koboSpan" id="kobo.3013.1">std::transform()</span></code><span class="koboSpan" id="kobo.3014.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3015.1">std::accumulate()</span></code><span class="koboSpan" id="kobo.3016.1">. </span><span class="koboSpan" id="kobo.3016.2">In fact, to verify the correctness of the parallel algorithms and check whether they provide any execution speedup, we can compare them with the execution of these general-purpose algorithms.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3017.1">To put this to </span><a id="_idIndexMarker1029"/><span class="koboSpan" id="kobo.3018.1">the test, we will use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3019.1">map</span></code><span class="koboSpan" id="kobo.3020.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3021.1">fold</span></code><span class="koboSpan" id="kobo.3022.1"> on a vector with sizes varying from 10,000 to 50 million elements. </span><span class="koboSpan" id="kobo.3022.2">The range is first mapped (that is, transformed) by doubling the value of each element, and then the result is folded into a single value by adding together all the elements of the range. </span><span class="koboSpan" id="kobo.3022.3">For simplicity, each element in the range is equal to its 1-based index (the first element is 1, the second element is 2, and so on). </span><span class="koboSpan" id="kobo.3022.4">The following sample runs both the sequential and parallel versions of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3023.1">map</span></code><span class="koboSpan" id="kobo.3024.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3025.1">fold</span></code><span class="koboSpan" id="kobo.3026.1"> on vectors of different sizes and prints the execution time in a tabular format:</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.3027.1">As an exercise, you can vary the number of elements, as well as the number of threads, and see how the parallel version performs compared to the sequential version.</span></p>
</div>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3028.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3029.1">int</span></span><span class="koboSpan" id="kobo.3030.1">&gt; sizes
{
  </span><span class="hljs-number"><span class="koboSpan" id="kobo.3031.1">10000</span></span><span class="koboSpan" id="kobo.3032.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3033.1">100000</span></span><span class="koboSpan" id="kobo.3034.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3035.1">500000</span></span><span class="koboSpan" id="kobo.3036.1">, 
  </span><span class="hljs-number"><span class="koboSpan" id="kobo.3037.1">1000000</span></span><span class="koboSpan" id="kobo.3038.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3039.1">2000000</span></span><span class="koboSpan" id="kobo.3040.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3041.1">5000000</span></span><span class="koboSpan" id="kobo.3042.1">, 
  </span><span class="hljs-number"><span class="koboSpan" id="kobo.3043.1">10000000</span></span><span class="koboSpan" id="kobo.3044.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3045.1">25000000</span></span><span class="koboSpan" id="kobo.3046.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3047.1">50000000</span></span><span class="koboSpan" id="kobo.3048.1">
};
std::cout
  &lt;&lt; std::right &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3049.1">setw</span></span><span class="koboSpan" id="kobo.3050.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3051.1">8</span></span><span class="koboSpan" id="kobo.3052.1">) &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3053.1">setfill</span></span><span class="koboSpan" id="kobo.3054.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3055.1">' '</span></span><span class="koboSpan" id="kobo.3056.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3057.1">"size"</span></span><span class="koboSpan" id="kobo.3058.1">
  &lt;&lt; std::right &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3059.1">setw</span></span><span class="koboSpan" id="kobo.3060.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3061.1">8</span></span><span class="koboSpan" id="kobo.3062.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3063.1">"s map"</span></span><span class="koboSpan" id="kobo.3064.1">
  &lt;&lt; std::right &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3065.1">setw</span></span><span class="koboSpan" id="kobo.3066.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3067.1">8</span></span><span class="koboSpan" id="kobo.3068.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3069.1">"p map"</span></span><span class="koboSpan" id="kobo.3070.1">
  &lt;&lt; std::right &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3071.1">setw</span></span><span class="koboSpan" id="kobo.3072.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3073.1">8</span></span><span class="koboSpan" id="kobo.3074.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3075.1">"s fold"</span></span><span class="koboSpan" id="kobo.3076.1">
  &lt;&lt; std::right &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3077.1">setw</span></span><span class="koboSpan" id="kobo.3078.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3079.1">8</span></span><span class="koboSpan" id="kobo.3080.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3081.1">"p fold"</span></span><span class="koboSpan" id="kobo.3082.1">
  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3083.1">'\n'</span></span><span class="koboSpan" id="kobo.3084.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3085.1">for</span></span><span class="koboSpan" id="kobo.3086.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3087.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3088.1">const</span></span><span class="koboSpan" id="kobo.3089.1"> size : sizes)
{
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.3090.1">std::vector&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3091.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3092.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3093.1">v</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3094.1">(size)</span></span><span class="koboSpan" id="kobo.3095.1">;
  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3096.1">iota</span></span><span class="koboSpan" id="kobo.3097.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3098.1">begin</span></span><span class="koboSpan" id="kobo.3099.1">(v), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3100.1">end</span></span><span class="koboSpan" id="kobo.3101.1">(v), </span><span class="hljs-number"><span class="koboSpan" id="kobo.3102.1">1</span></span><span class="koboSpan" id="kobo.3103.1">);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3104.1">auto</span></span><span class="koboSpan" id="kobo.3105.1"> v1 = v;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3106.1">auto</span></span><span class="koboSpan" id="kobo.3107.1"> s1 = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3108.1">0LL</span></span><span class="koboSpan" id="kobo.3109.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3110.1">auto</span></span><span class="koboSpan" id="kobo.3111.1"> tsm = perf_timer&lt;&gt;::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3112.1">duration</span></span><span class="koboSpan" id="kobo.3113.1">([&amp;] {
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3114.1">transform</span></span><span class="koboSpan" id="kobo.3115.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3116.1">begin</span></span><span class="koboSpan" id="kobo.3117.1">(v1), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3118.1">end</span></span><span class="koboSpan" id="kobo.3119.1">(v1), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3120.1">begin</span></span><span class="koboSpan" id="kobo.3121.1">(v1), 
                   [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.3122.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3123.1">const</span></span><span class="koboSpan" id="kobo.3124.1"> i) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3125.1">return</span></span><span class="koboSpan" id="kobo.3126.1"> i + i; }); });
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3127.1">auto</span></span><span class="koboSpan" id="kobo.3128.1"> tsf = perf_timer&lt;&gt;::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3129.1">duration</span></span><span class="koboSpan" id="kobo.3130.1">([&amp;] {
    s1 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3131.1">accumulate</span></span><span class="koboSpan" id="kobo.3132.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3133.1">begin</span></span><span class="koboSpan" id="kobo.3134.1">(v1), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3135.1">end</span></span><span class="koboSpan" id="kobo.3136.1">(v1), </span><span class="hljs-number"><span class="koboSpan" id="kobo.3137.1">0LL</span></span><span class="koboSpan" id="kobo.3138.1">,
                         std::plus&lt;&gt;()); });
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3139.1">auto</span></span><span class="koboSpan" id="kobo.3140.1"> v2 = v;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3141.1">auto</span></span><span class="koboSpan" id="kobo.3142.1"> s2 = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3143.1">0LL</span></span><span class="koboSpan" id="kobo.3144.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3145.1">auto</span></span><span class="koboSpan" id="kobo.3146.1"> tpm = perf_timer&lt;&gt;::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3147.1">duration</span></span><span class="koboSpan" id="kobo.3148.1">([&amp;] {
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3149.1">parallel_map</span></span><span class="koboSpan" id="kobo.3150.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3151.1">begin</span></span><span class="koboSpan" id="kobo.3152.1">(v2), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3153.1">end</span></span><span class="koboSpan" id="kobo.3154.1">(v2), 
                 [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.3155.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3156.1">const</span></span><span class="koboSpan" id="kobo.3157.1"> i) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3158.1">return</span></span><span class="koboSpan" id="kobo.3159.1"> i + i; }); });
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3160.1">auto</span></span><span class="koboSpan" id="kobo.3161.1"> tpf = perf_timer&lt;&gt;::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3162.1">duration</span></span><span class="koboSpan" id="kobo.3163.1">([&amp;] {
    s2 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3164.1">parallel_fold</span></span><span class="koboSpan" id="kobo.3165.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3166.1">begin</span></span><span class="koboSpan" id="kobo.3167.1">(v2), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3168.1">end</span></span><span class="koboSpan" id="kobo.3169.1">(v2), </span><span class="hljs-number"><span class="koboSpan" id="kobo.3170.1">0LL</span></span><span class="koboSpan" id="kobo.3171.1">,
                       std::plus&lt;&gt;()); });
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3172.1">assert</span></span><span class="koboSpan" id="kobo.3173.1">(v1 == v2);
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3174.1">assert</span></span><span class="koboSpan" id="kobo.3175.1">(s1 == s2);
  std::cout
    &lt;&lt; std::right &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3176.1">setw</span></span><span class="koboSpan" id="kobo.3177.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3178.1">8</span></span><span class="koboSpan" id="kobo.3179.1">) &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3180.1">setfill</span></span><span class="koboSpan" id="kobo.3181.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3182.1">' '</span></span><span class="koboSpan" id="kobo.3183.1">) &lt;&lt; size
    &lt;&lt; std::right &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3184.1">setw</span></span><span class="koboSpan" id="kobo.3185.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3186.1">8</span></span><span class="koboSpan" id="kobo.3187.1">) 
    &lt;&lt; std::chrono::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3188.1">duration</span></span><span class="koboSpan" id="kobo.3189.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3190.1">double</span></span><span class="koboSpan" id="kobo.3191.1">, std::micro&gt;(tsm).</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3192.1">count</span></span><span class="koboSpan" id="kobo.3193.1">()
    &lt;&lt; std::right &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3194.1">setw</span></span><span class="koboSpan" id="kobo.3195.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3196.1">8</span></span><span class="koboSpan" id="kobo.3197.1">) 
    &lt;&lt; std::chrono::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3198.1">duration</span></span><span class="koboSpan" id="kobo.3199.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3200.1">double</span></span><span class="koboSpan" id="kobo.3201.1">, std::micro&gt;(tpm).</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3202.1">count</span></span><span class="koboSpan" id="kobo.3203.1">()
    &lt;&lt; std::right &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3204.1">setw</span></span><span class="koboSpan" id="kobo.3205.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3206.1">8</span></span><span class="koboSpan" id="kobo.3207.1">) 
    &lt;&lt; std::chrono::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3208.1">duration</span></span><span class="koboSpan" id="kobo.3209.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3210.1">double</span></span><span class="koboSpan" id="kobo.3211.1">, std::micro&gt;(tsf).</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3212.1">count</span></span><span class="koboSpan" id="kobo.3213.1">()
    &lt;&lt; std::right &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3214.1">setw</span></span><span class="koboSpan" id="kobo.3215.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3216.1">8</span></span><span class="koboSpan" id="kobo.3217.1">) 
    &lt;&lt; std::chrono::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3218.1">duration</span></span><span class="koboSpan" id="kobo.3219.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3220.1">double</span></span><span class="koboSpan" id="kobo.3221.1">, std::micro&gt;(tpf).</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3222.1">count</span></span><span class="koboSpan" id="kobo.3223.1">()
    &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3224.1">'\n'</span></span><span class="koboSpan" id="kobo.3225.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3226.1">A possible output of this program is shown in the following chart (executed on a machine running Windows 64-bit with an Intel Core i7 processor and 4 physical and 8 logical cores). </span><span class="koboSpan" id="kobo.3226.2">The parallel version, especially the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3227.1">fold</span></code><span class="koboSpan" id="kobo.3228.1"> implementation, performs better than the sequential version. </span><span class="koboSpan" id="kobo.3228.2">But this</span><a id="_idIndexMarker1030"/><span class="koboSpan" id="kobo.3229.1"> is true only when the length of the vector exceeds a certain size. </span><span class="koboSpan" id="kobo.3229.2">In the following table, we can see that for up to 1 million elements, the sequential version is still faster. </span><span class="koboSpan" id="kobo.3229.3">The parallel version executes faster when there are 2 million or more elements in the vector. </span><span class="koboSpan" id="kobo.3229.4">Notice that the actual times vary slightly from one run to another, even on the same machine, and they can be very different on different machines:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3230.1">    size   s map   p map  s fold  p fold
   10000      11      10       7      10
  100000     108    1573      72     710
  500000     547    2006     361     862
 1000000    1146    1163     749     862
 2000000    2503    1527    1677    1289
 5000000    5937    3000    4203    2314
10000000   11959    6269    8269    3868
25000000   29872   13823   20961    9156
50000000   60049   27457   41374   19075
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3231.1">To better </span><a id="_idIndexMarker1031"/><span class="koboSpan" id="kobo.3232.1">visualize these results, we can represent the speedup of the parallel version in the form of a bar chart. </span><span class="koboSpan" id="kobo.3232.2">In the following chart, the blue bars represent the speedup of a parallel </span><code class="inlineCode"><span class="koboSpan" id="kobo.3233.1">map</span></code><span class="koboSpan" id="kobo.3234.1"> implementation, while the orange bars show the speedup of the parallel </span><code class="inlineCode"><span class="koboSpan" id="kobo.3235.1">fold</span></code><span class="koboSpan" id="kobo.3236.1"> implementation. </span><span class="koboSpan" id="kobo.3236.2">A positive value indicates that the parallel version is faster; a negative version indicates that the sequential version is faster:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.3237.1"><img alt="" src="../Images/B21549_08_01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.3238.1">Figure 8.1: The speedup of the parallel implementation for map (in blue) and fold (in orange) for various processed elements</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3239.1">This </span><a id="_idIndexMarker1032"/><span class="koboSpan" id="kobo.3240.1">chart makes it easier to see that only when the number of elements exceeds a certain threshold (which is about 2 million in my benchmarks) is the parallel implementation </span><a id="_idIndexMarker1033"/><span class="koboSpan" id="kobo.3241.1">faster than the sequential version.</span></p>
<h2 class="heading-2" id="_idParaDest-539"><span class="koboSpan" id="kobo.3242.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.3243.1">Chapter 3</span></em><span class="koboSpan" id="kobo.3244.1">, </span><em class="italic"><span class="koboSpan" id="kobo.3245.1">Implementing higher-order functions map and fold</span></em><span class="koboSpan" id="kobo.3246.1">, to learn about higher-order functions in functional programming and see how to implement the widely used </span><code class="inlineCode"><span class="koboSpan" id="kobo.3247.1">map</span></code><span class="koboSpan" id="kobo.3248.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3249.1">fold</span></code><span class="koboSpan" id="kobo.3250.1"> (or reduce) functions</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3251.1">Implementing parallel map and fold with tasks</span></em><span class="koboSpan" id="kobo.3252.1">, to see how to implement the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3253.1">map</span></code><span class="koboSpan" id="kobo.3254.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3255.1">fold</span></code><span class="koboSpan" id="kobo.3256.1"> functions from functional programming using asynchronous functions</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3257.1">Implementing parallel map and fold with standard parallel algorithms</span></em><span class="koboSpan" id="kobo.3258.1">, to see how to implement the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3259.1">map</span></code><span class="koboSpan" id="kobo.3260.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3261.1">fold</span></code><span class="koboSpan" id="kobo.3262.1"> functions from functional programming using parallel algorithms from C++17</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3263.1">Working with threads</span></em><span class="koboSpan" id="kobo.3264.1">, to learn about the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3265.1">std::thread</span></code><span class="koboSpan" id="kobo.3266.1"> class and the basic operations for working with threads in C++</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-540"><span class="koboSpan" id="kobo.3267.1">Implementing parallel map and fold with tasks</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3268.1">Tasks </span><a id="_idIndexMarker1034"/><span class="koboSpan" id="kobo.3269.1">are a</span><a id="_idIndexMarker1035"/><span class="koboSpan" id="kobo.3270.1"> higher-level alternative to threads for performing concurrent computations. </span><code class="inlineCode"><span class="koboSpan" id="kobo.3271.1">std::async()</span></code><span class="koboSpan" id="kobo.3272.1"> enables us to execute functions asynchronously, without the need to handle lower-level threading details. </span><span class="koboSpan" id="kobo.3272.2">In this recipe, we will take the same task of implementing a parallel version of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3273.1">map</span></code><span class="koboSpan" id="kobo.3274.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3275.1">fold</span></code><span class="koboSpan" id="kobo.3276.1"> functions, as in the previous recipe, but we will use tasks and see how it compares with the thread version.</span></p>
<h2 class="heading-2" id="_idParaDest-541"><span class="koboSpan" id="kobo.3277.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3278.1">The </span><a id="_idIndexMarker1036"/><span class="koboSpan" id="kobo.3279.1">solution presented in this recipe is similar in many aspects to the one that uses threads in the previous recipe, </span><em class="italic"><span class="koboSpan" id="kobo.3280.1">Implementing parallel map and fold with threads</span></em><span class="koboSpan" id="kobo.3281.1">. </span><span class="koboSpan" id="kobo.3281.2">Make sure you read that one before continuing with the current recipe.</span></p>
<h2 class="heading-2" id="_idParaDest-542"><span class="koboSpan" id="kobo.3282.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3283.1">To implement a parallel version of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3284.1">map</span></code><span class="koboSpan" id="kobo.3285.1"> function, do the following:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.3286.1">Define a function template that takes a begin and end iterator for a range and a function to apply to all the elements:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3287.1">template</span></span><span class="koboSpan" id="kobo.3288.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3289.1">typename</span></span><span class="koboSpan" id="kobo.3290.1"> Iter, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3291.1">typename</span></span><span class="koboSpan" id="kobo.3292.1"> F&gt;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.3293.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3294.1">parallel_map</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3295.1">(Iter begin, Iter end, F&amp;&amp; f)</span></span><span class="koboSpan" id="kobo.3296.1">
{
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.3297.1">Check the size of the range. </span><span class="koboSpan" id="kobo.3297.2">For a number of elements smaller than the predefined threshold (for this implementation, the threshold is 10,000), execute the mapping in a sequential manner:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3298.1">auto</span></span><span class="koboSpan" id="kobo.3299.1"> size = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3300.1">distance</span></span><span class="koboSpan" id="kobo.3301.1">(begin, end);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3302.1">if</span></span><span class="koboSpan" id="kobo.3303.1">(size &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.3304.1">10000</span></span><span class="koboSpan" id="kobo.3305.1">)
  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3306.1">transform</span></span><span class="koboSpan" id="kobo.3307.1">(begin, end, begin, std::forward&lt;F&gt;(f));
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.3308.1">For larger ranges, split the work into multiple tasks and let each task map a part of the range. </span><span class="koboSpan" id="kobo.3308.2">These parts should not overlap to avoid synchronizing thread access to shared data:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3309.1">else</span></span><span class="koboSpan" id="kobo.3310.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3311.1">auto</span></span><span class="koboSpan" id="kobo.3312.1"> no_of_tasks = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3313.1">get_no_of_threads</span></span><span class="koboSpan" id="kobo.3314.1">();
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3315.1">auto</span></span><span class="koboSpan" id="kobo.3316.1"> part = size / no_of_tasks;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3317.1">auto</span></span><span class="koboSpan" id="kobo.3318.1"> last = begin;
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3319.1">// continued at 4. </span><span class="koboSpan" id="kobo.3319.2">and 5.</span></span><span class="koboSpan" id="kobo.3320.1">
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.3321.1">Start the</span><a id="_idIndexMarker1037"/><span class="koboSpan" id="kobo.3322.1"> asynchronous functions and run a sequential version of the mapping on each of them:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3323.1">std::vector&lt;std::future&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3324.1">void</span></span><span class="koboSpan" id="kobo.3325.1">&gt;&gt; tasks;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3326.1">for</span></span><span class="koboSpan" id="kobo.3327.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.3328.1">unsigned</span></span><span class="koboSpan" id="kobo.3329.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3330.1">0</span></span><span class="koboSpan" id="kobo.3331.1">; i &lt; no_of_tasks; ++i)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3332.1">if</span></span><span class="koboSpan" id="kobo.3333.1">(i == no_of_tasks - </span><span class="hljs-number"><span class="koboSpan" id="kobo.3334.1">1</span></span><span class="koboSpan" id="kobo.3335.1">) last = end;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3336.1">else</span></span><span class="koboSpan" id="kobo.3337.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3338.1">advance</span></span><span class="koboSpan" id="kobo.3339.1">(last, part);
  tasks.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3340.1">emplace_back</span></span><span class="koboSpan" id="kobo.3341.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3342.1">async</span></span><span class="koboSpan" id="kobo.3343.1">(
    std::launch::async, 
      [=,&amp;f]{std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3344.1">transform</span></span><span class="koboSpan" id="kobo.3345.1">(begin, last, begin, 
                            std::forward&lt;F&gt;(f));}));
    begin = last;
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.3346.1">Wait until all the asynchronous functions have finished their execution:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3347.1">for</span></span><span class="koboSpan" id="kobo.3348.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3349.1">auto</span></span><span class="koboSpan" id="kobo.3350.1"> &amp; t : tasks) t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3351.1">wait</span></span><span class="koboSpan" id="kobo.3352.1">();
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.3353.1">These steps, when </span><a id="_idIndexMarker1038"/><span class="koboSpan" id="kobo.3354.1">put together, result in the following implementation:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3355.1">template</span></span><span class="koboSpan" id="kobo.3356.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3357.1">typename</span></span><span class="koboSpan" id="kobo.3358.1"> Iter, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3359.1">typename</span></span><span class="koboSpan" id="kobo.3360.1"> F&gt;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.3361.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3362.1">parallel_map</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3363.1">(Iter begin, Iter end, F&amp;&amp; f)</span></span><span class="koboSpan" id="kobo.3364.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3365.1">auto</span></span><span class="koboSpan" id="kobo.3366.1"> size = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3367.1">distance</span></span><span class="koboSpan" id="kobo.3368.1">(begin, end);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3369.1">if</span></span><span class="koboSpan" id="kobo.3370.1">(size &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.3371.1">10000</span></span><span class="koboSpan" id="kobo.3372.1">)
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3373.1">transform</span></span><span class="koboSpan" id="kobo.3374.1">(begin, end, begin, std::forward&lt;F&gt;(f)); 
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3375.1">else</span></span><span class="koboSpan" id="kobo.3376.1">
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3377.1">auto</span></span><span class="koboSpan" id="kobo.3378.1"> no_of_tasks = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3379.1">get_no_of_threads</span></span><span class="koboSpan" id="kobo.3380.1">();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3381.1">auto</span></span><span class="koboSpan" id="kobo.3382.1"> part = size / no_of_tasks;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3383.1">auto</span></span><span class="koboSpan" id="kobo.3384.1"> last = begin;
    std::vector&lt;std::future&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3385.1">void</span></span><span class="koboSpan" id="kobo.3386.1">&gt;&gt; tasks;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3387.1">for</span></span><span class="koboSpan" id="kobo.3388.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.3389.1">unsigned</span></span><span class="koboSpan" id="kobo.3390.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3391.1">0</span></span><span class="koboSpan" id="kobo.3392.1">; i &lt; no_of_tasks; ++i)
    {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3393.1">if</span></span><span class="koboSpan" id="kobo.3394.1">(i == no_of_tasks - </span><span class="hljs-number"><span class="koboSpan" id="kobo.3395.1">1</span></span><span class="koboSpan" id="kobo.3396.1">) last = end;
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3397.1">else</span></span><span class="koboSpan" id="kobo.3398.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3399.1">advance</span></span><span class="koboSpan" id="kobo.3400.1">(last, part);
      tasks.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3401.1">emplace_back</span></span><span class="koboSpan" id="kobo.3402.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3403.1">async</span></span><span class="koboSpan" id="kobo.3404.1">(
        std::launch::async, 
          [=,&amp;f]{std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3405.1">transform</span></span><span class="koboSpan" id="kobo.3406.1">(begin, last, begin, 
                                std::forward&lt;F&gt;(f));}));
      begin = last;
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3407.1">for</span></span><span class="koboSpan" id="kobo.3408.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3409.1">auto</span></span><span class="koboSpan" id="kobo.3410.1"> &amp; t : tasks) t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3411.1">wait</span></span><span class="koboSpan" id="kobo.3412.1">();
  }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3413.1">To implement a </span><a id="_idIndexMarker1039"/><span class="koboSpan" id="kobo.3414.1">parallel version of the left </span><code class="inlineCode"><span class="koboSpan" id="kobo.3415.1">fold</span></code><span class="koboSpan" id="kobo.3416.1"> function, do the following:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.3417.1">Define a function template that takes a begin and end iterator for a range, an initial value, and a binary function to apply to the elements of the range:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3418.1">template</span></span><span class="koboSpan" id="kobo.3419.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3420.1">typename</span></span><span class="koboSpan" id="kobo.3421.1"> Iter, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3422.1">typename</span></span><span class="koboSpan" id="kobo.3423.1"> R, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3424.1">typename</span></span><span class="koboSpan" id="kobo.3425.1"> F&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3426.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3427.1">parallel_fold</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3428.1">(Iter begin, Iter end, R init, F&amp;&amp; op)</span></span><span class="koboSpan" id="kobo.3429.1">
{
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.3430.1">Check the size of the range. </span><span class="koboSpan" id="kobo.3430.2">For a number of elements smaller than the predefined threshold (for this implementation, the threshold is 10,000), execute the folding in a sequential manner:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3431.1">auto</span></span><span class="koboSpan" id="kobo.3432.1"> size = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3433.1">distance</span></span><span class="koboSpan" id="kobo.3434.1">(begin, end);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3435.1">if</span></span><span class="koboSpan" id="kobo.3436.1">(size &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.3437.1">10000</span></span><span class="koboSpan" id="kobo.3438.1">)
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3439.1">return</span></span><span class="koboSpan" id="kobo.3440.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3441.1">accumulate</span></span><span class="koboSpan" id="kobo.3442.1">(begin, end, init, std::forward&lt;F&gt;(op));
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.3443.1">For </span><a id="_idIndexMarker1040"/><span class="koboSpan" id="kobo.3444.1">larger ranges, split the work into multiple tasks and let each task fold a part of the range. </span><span class="koboSpan" id="kobo.3444.2">These parts should not overlap to avoid synchronizing thread access to the shared data. </span><span class="koboSpan" id="kobo.3444.3">The result can be returned through a reference passed to the asynchronous function to avoid synchronization:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3445.1">else</span></span><span class="koboSpan" id="kobo.3446.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3447.1">auto</span></span><span class="koboSpan" id="kobo.3448.1"> no_of_tasks = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3449.1">get_no_of_threads</span></span><span class="koboSpan" id="kobo.3450.1">();
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3451.1">auto</span></span><span class="koboSpan" id="kobo.3452.1"> part = size / no_of_tasks;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3453.1">auto</span></span><span class="koboSpan" id="kobo.3454.1"> last = begin;
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3455.1">// continued at 4. </span><span class="koboSpan" id="kobo.3455.2">and 5.</span></span><span class="koboSpan" id="kobo.3456.1">
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.3457.1">Start the</span><a id="_idIndexMarker1041"/><span class="koboSpan" id="kobo.3458.1"> asynchronous functions and execute a sequential version of folding on each one of them:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3459.1">std::vector&lt;std::future&lt;R&gt;&gt; tasks;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3460.1">for</span></span><span class="koboSpan" id="kobo.3461.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.3462.1">unsigned</span></span><span class="koboSpan" id="kobo.3463.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3464.1">0</span></span><span class="koboSpan" id="kobo.3465.1">; i &lt; no_of_tasks; ++i)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3466.1">if</span></span><span class="koboSpan" id="kobo.3467.1">(i == no_of_tasks - </span><span class="hljs-number"><span class="koboSpan" id="kobo.3468.1">1</span></span><span class="koboSpan" id="kobo.3469.1">) last = end;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3470.1">else</span></span><span class="koboSpan" id="kobo.3471.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3472.1">advance</span></span><span class="koboSpan" id="kobo.3473.1">(last, part);
  tasks.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3474.1">emplace_back</span></span><span class="koboSpan" id="kobo.3475.1">(
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3476.1">async</span></span><span class="koboSpan" id="kobo.3477.1">(
      std::launch::async,
      [=,&amp;op]{</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3478.1">return</span></span><span class="koboSpan" id="kobo.3479.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3480.1">accumulate</span></span><span class="koboSpan" id="kobo.3481.1">(
                          begin, last, R{}, 
                          std::forward&lt;F&gt;(op));}));
  begin = last;
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.3482.1">Wait until </span><a id="_idIndexMarker1042"/><span class="koboSpan" id="kobo.3483.1">all the asynchronous functions have finished execution and fold the partial results into the final result:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3484.1">std::vector&lt;R&gt; values;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3485.1">for</span></span><span class="koboSpan" id="kobo.3486.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3487.1">auto</span></span><span class="koboSpan" id="kobo.3488.1"> &amp; t : tasks)
  values.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3489.1">push_back</span></span><span class="koboSpan" id="kobo.3490.1">(t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3491.1">get</span></span><span class="koboSpan" id="kobo.3492.1">());
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3493.1">return</span></span><span class="koboSpan" id="kobo.3494.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3495.1">accumulate</span></span><span class="koboSpan" id="kobo.3496.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3497.1">begin</span></span><span class="koboSpan" id="kobo.3498.1">(values), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3499.1">end</span></span><span class="koboSpan" id="kobo.3500.1">(values), 
                       init, std::forward&lt;F&gt;(op));
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.3501.1">These steps, when put together, result in the following implementation:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3502.1">template</span></span><span class="koboSpan" id="kobo.3503.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3504.1">typename</span></span><span class="koboSpan" id="kobo.3505.1"> Iter, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3506.1">typename</span></span><span class="koboSpan" id="kobo.3507.1"> R, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3508.1">typename</span></span><span class="koboSpan" id="kobo.3509.1"> F&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3510.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3511.1">parallel_fold</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3512.1">(Iter begin, Iter end, R init, F&amp;&amp; op)</span></span><span class="koboSpan" id="kobo.3513.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3514.1">auto</span></span><span class="koboSpan" id="kobo.3515.1"> size = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3516.1">distance</span></span><span class="koboSpan" id="kobo.3517.1">(begin, end);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3518.1">if</span></span><span class="koboSpan" id="kobo.3519.1">(size &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.3520.1">10000</span></span><span class="koboSpan" id="kobo.3521.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3522.1">return</span></span><span class="koboSpan" id="kobo.3523.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3524.1">accumulate</span></span><span class="koboSpan" id="kobo.3525.1">(begin, end, init, std::forward&lt;F&gt;(op));
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3526.1">else</span></span><span class="koboSpan" id="kobo.3527.1">
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3528.1">auto</span></span><span class="koboSpan" id="kobo.3529.1"> no_of_tasks = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3530.1">get_no_of_threads</span></span><span class="koboSpan" id="kobo.3531.1">();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3532.1">auto</span></span><span class="koboSpan" id="kobo.3533.1"> part = size / no_of_tasks;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3534.1">auto</span></span><span class="koboSpan" id="kobo.3535.1"> last = begin;
    std::vector&lt;std::future&lt;R&gt;&gt; tasks;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3536.1">for</span></span><span class="koboSpan" id="kobo.3537.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.3538.1">unsigned</span></span><span class="koboSpan" id="kobo.3539.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3540.1">0</span></span><span class="koboSpan" id="kobo.3541.1">; i &lt; no_of_tasks; ++i)
    {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3542.1">if</span></span><span class="koboSpan" id="kobo.3543.1">(i == no_of_tasks - </span><span class="hljs-number"><span class="koboSpan" id="kobo.3544.1">1</span></span><span class="koboSpan" id="kobo.3545.1">) last = end;
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3546.1">else</span></span><span class="koboSpan" id="kobo.3547.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3548.1">advance</span></span><span class="koboSpan" id="kobo.3549.1">(last, part);
      tasks.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3550.1">emplace_back</span></span><span class="koboSpan" id="kobo.3551.1">(
        std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3552.1">async</span></span><span class="koboSpan" id="kobo.3553.1">(
          std::launch::async,
          [=,&amp;op]{</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3554.1">return</span></span><span class="koboSpan" id="kobo.3555.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3556.1">accumulate</span></span><span class="koboSpan" id="kobo.3557.1">(
                            begin, last, R{}, 
                            std::forward&lt;F&gt;(op));}));
      begin = last;
    }
    std::vector&lt;R&gt; values;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3558.1">for</span></span><span class="koboSpan" id="kobo.3559.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3560.1">auto</span></span><span class="koboSpan" id="kobo.3561.1"> &amp; t : tasks)
      values.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3562.1">push_back</span></span><span class="koboSpan" id="kobo.3563.1">(t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3564.1">get</span></span><span class="koboSpan" id="kobo.3565.1">());
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3566.1">return</span></span><span class="koboSpan" id="kobo.3567.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3568.1">accumulate</span></span><span class="koboSpan" id="kobo.3569.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3570.1">begin</span></span><span class="koboSpan" id="kobo.3571.1">(values), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3572.1">end</span></span><span class="koboSpan" id="kobo.3573.1">(values), 
                           init, std::forward&lt;F&gt;(op));
  }
}
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-543"><span class="koboSpan" id="kobo.3574.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3575.1">The </span><a id="_idIndexMarker1043"/><span class="koboSpan" id="kobo.3576.1">implementation </span><a id="_idIndexMarker1044"/><span class="koboSpan" id="kobo.3577.1">just proposed is only slightly different than what we did in the previous recipe. </span><span class="koboSpan" id="kobo.3577.2">Threads were replaced with asynchronous functions, starting with </span><code class="inlineCode"><span class="koboSpan" id="kobo.3578.1">std::async()</span></code><span class="koboSpan" id="kobo.3579.1">, and results were made available through the returned </span><code class="inlineCode"><span class="koboSpan" id="kobo.3580.1">std::future</span></code><span class="koboSpan" id="kobo.3581.1">. </span><span class="koboSpan" id="kobo.3581.2">The number of asynchronous functions that are launched concurrently is equal to the </span><a id="_idIndexMarker1045"/><span class="koboSpan" id="kobo.3582.1">number of threads the implementation can support. </span><span class="koboSpan" id="kobo.3582.2">This is returned by the static method </span><code class="inlineCode"><span class="koboSpan" id="kobo.3583.1">std::thread::hardware_concurrency()</span></code><span class="koboSpan" id="kobo.3584.1">, but this value is only a hint and should not </span><a id="_idIndexMarker1046"/><span class="koboSpan" id="kobo.3585.1">be considered very reliable.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3586.1">There are mainly two reasons for taking this approach:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3587.1">Seeing how a function implemented for parallel execution with threads can be modified to use asynchronous functions and, therefore, avoid lower-level details of threading.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3588.1">Running a number of asynchronous functions equal to the number of supported threads can potentially run one function per thread; this could provide the fastest execution time for the parallel function because there is a minimum overhead of context switching and waiting time.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.3589.1">We can test the performance of the new </span><code class="inlineCode"><span class="koboSpan" id="kobo.3590.1">map</span></code><span class="koboSpan" id="kobo.3591.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3592.1">fold</span></code><span class="koboSpan" id="kobo.3593.1"> implementations using the same method as in the previous recipe:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3594.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3595.1">int</span></span><span class="koboSpan" id="kobo.3596.1">&gt; sizes
{
  </span><span class="hljs-number"><span class="koboSpan" id="kobo.3597.1">10000</span></span><span class="koboSpan" id="kobo.3598.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3599.1">100000</span></span><span class="koboSpan" id="kobo.3600.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3601.1">500000</span></span><span class="koboSpan" id="kobo.3602.1">,
  </span><span class="hljs-number"><span class="koboSpan" id="kobo.3603.1">1000000</span></span><span class="koboSpan" id="kobo.3604.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3605.1">2000000</span></span><span class="koboSpan" id="kobo.3606.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3607.1">5000000</span></span><span class="koboSpan" id="kobo.3608.1">,
  </span><span class="hljs-number"><span class="koboSpan" id="kobo.3609.1">10000000</span></span><span class="koboSpan" id="kobo.3610.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3611.1">25000000</span></span><span class="koboSpan" id="kobo.3612.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3613.1">50000000</span></span><span class="koboSpan" id="kobo.3614.1">
};
std::cout
  &lt;&lt; std::right &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3615.1">setw</span></span><span class="koboSpan" id="kobo.3616.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3617.1">8</span></span><span class="koboSpan" id="kobo.3618.1">) &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3619.1">setfill</span></span><span class="koboSpan" id="kobo.3620.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3621.1">' '</span></span><span class="koboSpan" id="kobo.3622.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3623.1">"size"</span></span><span class="koboSpan" id="kobo.3624.1">
  &lt;&lt; std::right &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3625.1">setw</span></span><span class="koboSpan" id="kobo.3626.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3627.1">8</span></span><span class="koboSpan" id="kobo.3628.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3629.1">"s map"</span></span><span class="koboSpan" id="kobo.3630.1">
  &lt;&lt; std::right &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3631.1">setw</span></span><span class="koboSpan" id="kobo.3632.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3633.1">8</span></span><span class="koboSpan" id="kobo.3634.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3635.1">"p map"</span></span><span class="koboSpan" id="kobo.3636.1">
  &lt;&lt; std::right &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3637.1">setw</span></span><span class="koboSpan" id="kobo.3638.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3639.1">8</span></span><span class="koboSpan" id="kobo.3640.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3641.1">"s fold"</span></span><span class="koboSpan" id="kobo.3642.1">
  &lt;&lt; std::right &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3643.1">setw</span></span><span class="koboSpan" id="kobo.3644.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3645.1">8</span></span><span class="koboSpan" id="kobo.3646.1">) &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3647.1">"p fold"</span></span><span class="koboSpan" id="kobo.3648.1">
  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3649.1">'\n'</span></span><span class="koboSpan" id="kobo.3650.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3651.1">for</span></span><span class="koboSpan" id="kobo.3652.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3653.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3654.1">const</span></span><span class="koboSpan" id="kobo.3655.1"> size : sizes)
{
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.3656.1">std::vector&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3657.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3658.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3659.1">v</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3660.1">(size)</span></span><span class="koboSpan" id="kobo.3661.1">;
  std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3662.1">iota</span></span><span class="koboSpan" id="kobo.3663.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3664.1">begin</span></span><span class="koboSpan" id="kobo.3665.1">(v), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3666.1">end</span></span><span class="koboSpan" id="kobo.3667.1">(v), </span><span class="hljs-number"><span class="koboSpan" id="kobo.3668.1">1</span></span><span class="koboSpan" id="kobo.3669.1">);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3670.1">auto</span></span><span class="koboSpan" id="kobo.3671.1"> v1 = v;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3672.1">auto</span></span><span class="koboSpan" id="kobo.3673.1"> s1 = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3674.1">0LL</span></span><span class="koboSpan" id="kobo.3675.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3676.1">auto</span></span><span class="koboSpan" id="kobo.3677.1"> tsm = perf_timer&lt;&gt;::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3678.1">duration</span></span><span class="koboSpan" id="kobo.3679.1">([&amp;] {
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3680.1">transform</span></span><span class="koboSpan" id="kobo.3681.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3682.1">begin</span></span><span class="koboSpan" id="kobo.3683.1">(v1), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3684.1">end</span></span><span class="koboSpan" id="kobo.3685.1">(v1), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3686.1">begin</span></span><span class="koboSpan" id="kobo.3687.1">(v1), 
                   [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.3688.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3689.1">const</span></span><span class="koboSpan" id="kobo.3690.1"> i) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3691.1">return</span></span><span class="koboSpan" id="kobo.3692.1"> i + i; }); });
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3693.1">auto</span></span><span class="koboSpan" id="kobo.3694.1"> tsf = perf_timer&lt;&gt;::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3695.1">duration</span></span><span class="koboSpan" id="kobo.3696.1">([&amp;] {
    s1 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3697.1">accumulate</span></span><span class="koboSpan" id="kobo.3698.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3699.1">begin</span></span><span class="koboSpan" id="kobo.3700.1">(v1), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3701.1">end</span></span><span class="koboSpan" id="kobo.3702.1">(v1), </span><span class="hljs-number"><span class="koboSpan" id="kobo.3703.1">0LL</span></span><span class="koboSpan" id="kobo.3704.1">,
                         std::plus&lt;&gt;()); });
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3705.1">auto</span></span><span class="koboSpan" id="kobo.3706.1"> v2 = v;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3707.1">auto</span></span><span class="koboSpan" id="kobo.3708.1"> s2 = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3709.1">0LL</span></span><span class="koboSpan" id="kobo.3710.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3711.1">auto</span></span><span class="koboSpan" id="kobo.3712.1"> tpm = perf_timer&lt;&gt;::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3713.1">duration</span></span><span class="koboSpan" id="kobo.3714.1">([&amp;] {
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3715.1">parallel_map</span></span><span class="koboSpan" id="kobo.3716.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3717.1">begin</span></span><span class="koboSpan" id="kobo.3718.1">(v2), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3719.1">end</span></span><span class="koboSpan" id="kobo.3720.1">(v2), 
               [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.3721.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3722.1">const</span></span><span class="koboSpan" id="kobo.3723.1"> i) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3724.1">return</span></span><span class="koboSpan" id="kobo.3725.1"> i + i; }); });
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3726.1">auto</span></span><span class="koboSpan" id="kobo.3727.1"> tpf = perf_timer&lt;&gt;::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3728.1">duration</span></span><span class="koboSpan" id="kobo.3729.1">([&amp;] {
  s2 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3730.1">parallel_fold</span></span><span class="koboSpan" id="kobo.3731.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3732.1">begin</span></span><span class="koboSpan" id="kobo.3733.1">(v2), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3734.1">end</span></span><span class="koboSpan" id="kobo.3735.1">(v2), </span><span class="hljs-number"><span class="koboSpan" id="kobo.3736.1">0LL</span></span><span class="koboSpan" id="kobo.3737.1">, 
                       std::plus&lt;&gt;()); });
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3738.1">assert</span></span><span class="koboSpan" id="kobo.3739.1">(v1 == v2);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3740.1">assert</span></span><span class="koboSpan" id="kobo.3741.1">(s1 == s2);
std::cout
  &lt;&lt; std::right &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3742.1">setw</span></span><span class="koboSpan" id="kobo.3743.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3744.1">8</span></span><span class="koboSpan" id="kobo.3745.1">) &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3746.1">setfill</span></span><span class="koboSpan" id="kobo.3747.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3748.1">' '</span></span><span class="koboSpan" id="kobo.3749.1">) &lt;&lt; size
  &lt;&lt; std::right &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3750.1">setw</span></span><span class="koboSpan" id="kobo.3751.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3752.1">8</span></span><span class="koboSpan" id="kobo.3753.1">) 
  &lt;&lt; std::chrono::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3754.1">duration</span></span><span class="koboSpan" id="kobo.3755.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3756.1">double</span></span><span class="koboSpan" id="kobo.3757.1">, std::micro&gt;(tsm).</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3758.1">count</span></span><span class="koboSpan" id="kobo.3759.1">()
  &lt;&lt; std::right &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3760.1">setw</span></span><span class="koboSpan" id="kobo.3761.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3762.1">8</span></span><span class="koboSpan" id="kobo.3763.1">) 
  &lt;&lt; std::chrono::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3764.1">duration</span></span><span class="koboSpan" id="kobo.3765.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3766.1">double</span></span><span class="koboSpan" id="kobo.3767.1">, std::micro&gt;(tpm).</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3768.1">count</span></span><span class="koboSpan" id="kobo.3769.1">()
  &lt;&lt; std::right &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3770.1">setw</span></span><span class="koboSpan" id="kobo.3771.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3772.1">8</span></span><span class="koboSpan" id="kobo.3773.1">) 
  &lt;&lt; std::chrono::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3774.1">duration</span></span><span class="koboSpan" id="kobo.3775.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3776.1">double</span></span><span class="koboSpan" id="kobo.3777.1">, std::micro&gt;(tsf).</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3778.1">count</span></span><span class="koboSpan" id="kobo.3779.1">()
  &lt;&lt; std::right &lt;&lt; std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3780.1">setw</span></span><span class="koboSpan" id="kobo.3781.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3782.1">8</span></span><span class="koboSpan" id="kobo.3783.1">) 
  &lt;&lt; std::chrono::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3784.1">duration</span></span><span class="koboSpan" id="kobo.3785.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3786.1">double</span></span><span class="koboSpan" id="kobo.3787.1">, std::micro&gt;(tpf).</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3788.1">count</span></span><span class="koboSpan" id="kobo.3789.1">()
  &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3790.1">'\n'</span></span><span class="koboSpan" id="kobo.3791.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3792.1">A </span><a id="_idIndexMarker1047"/><span class="koboSpan" id="kobo.3793.1">possible output of the preceding program, which</span><a id="_idIndexMarker1048"/><span class="koboSpan" id="kobo.3794.1"> can vary slightly from one execution to another and greatly from one machine to another, is as follows:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3795.1">    size   s map   p map  s fold  p fold
   10000      11      11      11      11
  100000     117     260     113      94
  500000     576     303     571     201
 1000000    1180     573    1165     283
 2000000    2371     911    2330     519
 5000000    5942    2144    5841    1886
10000000   11954    4999   11643    2871
25000000   30525   11737   29053    9048
50000000   59665   22216   58689   12942
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3796.1">Similar to the illustration of the solution with threads, the speedup of the parallel </span><code class="inlineCode"><span class="koboSpan" id="kobo.3797.1">map</span></code><span class="koboSpan" id="kobo.3798.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3799.1">fold</span></code><span class="koboSpan" id="kobo.3800.1"> implementations can be seen in the following chart.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3801.1">Negative values indicate that the sequential version was faster:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.3802.1"><img alt="" src="../Images/B21549_08_02.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.3803.1">Figure 8.2: The speedup of the parallel implementation of map (in blue) and fold (in orange) using asynchronous functions, compared to the sequential implementation</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3804.1">If we </span><a id="_idIndexMarker1049"/><span class="koboSpan" id="kobo.3805.1">compare this with the results from </span><a id="_idIndexMarker1050"/><span class="koboSpan" id="kobo.3806.1">the parallel version using threads, we will find that these are faster execution times and that the speedup is significant, especially for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3807.1">fold</span></code><span class="koboSpan" id="kobo.3808.1"> function. </span><span class="koboSpan" id="kobo.3808.2">The following chart shows the speedup of the task’s implementation over the thread’s implementation. </span><span class="koboSpan" id="kobo.3808.3">In this chart, a value smaller than 1 means that the thread’s implementation was faster:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.3809.1"><img alt="" src="../Images/B21549_08_03.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.3810.1">Figure 8.3: The speedup of the parallel implementation using asynchronous functions over the parallel implementation using threads for map (in blue) and fold (in orange)</span></p>
<h2 class="heading-2" id="_idParaDest-544"><span class="koboSpan" id="kobo.3811.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3812.1">The</span><a id="_idIndexMarker1051"/><span class="koboSpan" id="kobo.3813.1"> implementation</span><a id="_idIndexMarker1052"/><span class="koboSpan" id="kobo.3814.1"> shown earlier is only one of the possible approaches we can take for parallelizing the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3815.1">map</span></code><span class="koboSpan" id="kobo.3816.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3817.1">fold</span></code><span class="koboSpan" id="kobo.3818.1"> functions. </span><span class="koboSpan" id="kobo.3818.2">A possible alternative uses the following strategy:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3819.1">Divide the range to process into two equal parts.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3820.1">Recursively call the parallel function asynchronously to process the first part of the range.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3821.1">Recursively call the parallel function synchronously to process the second part of the range.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3822.1">After the synchronous recursive call is finished, wait for the asynchronous recursive call to end too before finishing the execution.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.3823.1">This divide-and-conquer algorithm can potentially create a lot of tasks. </span><span class="koboSpan" id="kobo.3823.2">Depending on the size of the range, the number of asynchronous calls can greatly exceed the number of threads, and in this case, there will be lots of waiting time that will affect the overall execution time.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3824.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3825.1">map</span></code><span class="koboSpan" id="kobo.3826.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3827.1">fold</span></code><span class="koboSpan" id="kobo.3828.1"> functions </span><a id="_idIndexMarker1053"/><span class="koboSpan" id="kobo.3829.1">can be implemented</span><a id="_idIndexMarker1054"/><span class="koboSpan" id="kobo.3830.1"> using a divide-and-conquer algorithm, as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3831.1">template</span></span><span class="koboSpan" id="kobo.3832.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3833.1">typename</span></span><span class="koboSpan" id="kobo.3834.1"> Iter, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3835.1">typename</span></span><span class="koboSpan" id="kobo.3836.1"> F&gt;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.3837.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3838.1">parallel_map</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3839.1">(Iter begin, Iter end, F f)</span></span><span class="koboSpan" id="kobo.3840.1">
{ 
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3841.1">auto</span></span><span class="koboSpan" id="kobo.3842.1"> size = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3843.1">distance</span></span><span class="koboSpan" id="kobo.3844.1">(begin, end);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3845.1">if</span></span><span class="koboSpan" id="kobo.3846.1">(size &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.3847.1">10000</span></span><span class="koboSpan" id="kobo.3848.1">)
  {
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3849.1">transform</span></span><span class="koboSpan" id="kobo.3850.1">(begin, end, begin, std::forward&lt;F&gt;(f)); 
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3851.1">else</span></span><span class="koboSpan" id="kobo.3852.1">
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3853.1">auto</span></span><span class="koboSpan" id="kobo.3854.1"> middle = begin;
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3855.1">advance</span></span><span class="koboSpan" id="kobo.3856.1">(middle, size / </span><span class="hljs-number"><span class="koboSpan" id="kobo.3857.1">2</span></span><span class="koboSpan" id="kobo.3858.1">);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3859.1">auto</span></span><span class="koboSpan" id="kobo.3860.1"> result = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3861.1">async</span></span><span class="koboSpan" id="kobo.3862.1">(
      std::launch::deferred, 
      parallel_map&lt;Iter, F&gt;, 
      begin, middle, std::forward&lt;F&gt;(f));
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3863.1">parallel_map</span></span><span class="koboSpan" id="kobo.3864.1">(middle, end, std::forward&lt;F&gt;(f));
    result.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3865.1">wait</span></span><span class="koboSpan" id="kobo.3866.1">();
  }
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3867.1">template</span></span><span class="koboSpan" id="kobo.3868.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3869.1">typename</span></span><span class="koboSpan" id="kobo.3870.1"> Iter, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3871.1">typename</span></span><span class="koboSpan" id="kobo.3872.1"> R, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3873.1">typename</span></span><span class="koboSpan" id="kobo.3874.1"> F&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3875.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3876.1">parallel_fold</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3877.1">(Iter begin, Iter end, R init, F op)</span></span><span class="koboSpan" id="kobo.3878.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3879.1">auto</span></span><span class="koboSpan" id="kobo.3880.1"> size = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3881.1">distance</span></span><span class="koboSpan" id="kobo.3882.1">(begin, end);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3883.1">if</span></span><span class="koboSpan" id="kobo.3884.1">(size &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.3885.1">10000</span></span><span class="koboSpan" id="kobo.3886.1">)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3887.1">return</span></span><span class="koboSpan" id="kobo.3888.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3889.1">accumulate</span></span><span class="koboSpan" id="kobo.3890.1">(begin, end, init, std::forward&lt;F&gt;(op));
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3891.1">else</span></span><span class="koboSpan" id="kobo.3892.1">
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3893.1">auto</span></span><span class="koboSpan" id="kobo.3894.1"> middle = begin;
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3895.1">advance</span></span><span class="koboSpan" id="kobo.3896.1">(middle, size / </span><span class="hljs-number"><span class="koboSpan" id="kobo.3897.1">2</span></span><span class="koboSpan" id="kobo.3898.1">);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3899.1">auto</span></span><span class="koboSpan" id="kobo.3900.1"> result1 = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3901.1">async</span></span><span class="koboSpan" id="kobo.3902.1">(
      std::launch::async, 
      parallel_reduce&lt;Iter, R, F&gt;, 
      begin, middle, R{}, std::forward&lt;F&gt;(op));
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3903.1">auto</span></span><span class="koboSpan" id="kobo.3904.1"> result2 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3905.1">parallel_fold</span></span><span class="koboSpan" id="kobo.3906.1">(middle, end, init, 
                                 std::forward&lt;F&gt;(op));
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3907.1">return</span></span><span class="koboSpan" id="kobo.3908.1"> result1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3909.1">get</span></span><span class="koboSpan" id="kobo.3910.1">() + result2;
  }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3911.1">The execution times for this implementation are listed here, next to the ones for the previous implementations:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3912.1">    size   s map p1 map  p2 map  s fold p1 fold p2 fold
   10000      11     11      10       7      10      10
  100000     111    275     120      72      96     426
  500000     551    230     596     365     210    1802
 1000000    1142    381    1209     753     303    2378
 2000000    2411    981    2488    1679     503    4190
 5000000    5962   2191    6237    4177    1969    7974
10000000   11961   4517   12581    8384    2966   15174
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3913.1">When we</span><a id="_idIndexMarker1055"/><span class="koboSpan" id="kobo.3914.1"> compare these execution times, we </span><a id="_idIndexMarker1056"/><span class="koboSpan" id="kobo.3915.1">can see that this version (indicated by </span><code class="inlineCode"><span class="koboSpan" id="kobo.3916.1">p2</span></code><span class="koboSpan" id="kobo.3917.1"> in the preceding output) is similar to the sequential version for both </span><code class="inlineCode"><span class="koboSpan" id="kobo.3918.1">map</span></code><span class="koboSpan" id="kobo.3919.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3920.1">fold</span></code><span class="koboSpan" id="kobo.3921.1"> and much worse than the first parallel version shown earlier (indicated by </span><code class="inlineCode"><span class="koboSpan" id="kobo.3922.1">p1</span></code><span class="koboSpan" id="kobo.3923.1">).</span></p>
<h2 class="heading-2" id="_idParaDest-545"><span class="koboSpan" id="kobo.3924.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3925.1">Implementing parallel map and fold with threads</span></em><span class="koboSpan" id="kobo.3926.1">, to see how to implement the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3927.1">map</span></code><span class="koboSpan" id="kobo.3928.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3929.1">fold</span></code><span class="koboSpan" id="kobo.3930.1"> functions from functional programming using raw threads</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3931.1">Implementing parallel map and fold with standard parallel algorithms</span></em><span class="koboSpan" id="kobo.3932.1">, to see how to implement the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3933.1">map</span></code><span class="koboSpan" id="kobo.3934.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3935.1">fold</span></code><span class="koboSpan" id="kobo.3936.1"> functions from functional programming using parallel algorithms from C++17</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3937.1">Executing functions asynchronously</span></em><span class="koboSpan" id="kobo.3938.1">, to learn how to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3939.1">std::future</span></code><span class="koboSpan" id="kobo.3940.1"> class and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3941.1">std::async()</span></code><span class="koboSpan" id="kobo.3942.1"> function to execute functions asynchronously on different threads and communicate the result back</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-546"><span class="koboSpan" id="kobo.3943.1">Implementing parallel map and fold with standard parallel algorithms</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3944.1">In the </span><a id="_idIndexMarker1057"/><span class="koboSpan" id="kobo.3945.1">previous two recipes, we implemented parallel versions of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3946.1">map</span></code><span class="koboSpan" id="kobo.3947.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3948.1">fold</span></code><span class="koboSpan" id="kobo.3949.1"> functions (which are called </span><code class="inlineCode"><span class="koboSpan" id="kobo.3950.1">std::transform()</span></code><span class="koboSpan" id="kobo.3951.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3952.1">std::accumulate()</span></code><span class="koboSpan" id="kobo.3953.1"> in the standard library) using threads </span><a id="_idIndexMarker1058"/><span class="koboSpan" id="kobo.3954.1">and tasks. </span><span class="koboSpan" id="kobo.3954.2">However, these implementations required manual handling of parallelization details, such as splitting data into chunks to be processed in parallel and creating threads or tasks, synchronizing their execution, and merging the results.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3955.1">In C++17, many of the standard generic algorithms have been parallelized. </span><span class="koboSpan" id="kobo.3955.2">In fact, the same algorithm can execute sequentially or in parallel, depending on a provided execution policy. </span><span class="koboSpan" id="kobo.3955.3">In this recipe, we will learn how to implement </span><code class="inlineCode"><span class="koboSpan" id="kobo.3956.1">map</span></code><span class="koboSpan" id="kobo.3957.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3958.1">fold</span></code><span class="koboSpan" id="kobo.3959.1"> in parallel with standard algorithms.</span></p>
<h2 class="heading-2" id="_idParaDest-547"><span class="koboSpan" id="kobo.3960.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3961.1">Before you continue with this recipe, it is recommended that you read the previous two to make sure you understand the differences between various parallel implementations.</span></p>
<h2 class="heading-2" id="_idParaDest-548"><span class="koboSpan" id="kobo.3962.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3963.1">To use the standard algorithms with parallel execution, you should do the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3964.1">Find a good candidate for an algorithm to parallelize. </span><span class="koboSpan" id="kobo.3964.2">Not every algorithm runs faster in parallel. </span><span class="koboSpan" id="kobo.3964.3">Make sure you correctly identify the parts of the program that can be improved with parallelization. </span><span class="koboSpan" id="kobo.3964.4">Use profilers for this purpose and, in general, look at operations that have </span><em class="italic"><span class="koboSpan" id="kobo.3965.1">O(n)</span></em><span class="koboSpan" id="kobo.3966.1"> or worse complexity.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3967.1">Include the header </span><code class="inlineCode"><span class="koboSpan" id="kobo.3968.1">&lt;execution&gt;</span></code><span class="koboSpan" id="kobo.3969.1"> for the execution policies.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3970.1">Provide the parallel execution policy (</span><code class="inlineCode"><span class="koboSpan" id="kobo.3971.1">std::execution::par</span></code><span class="koboSpan" id="kobo.3972.1">) as the first argument to the overloaded algorithm.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.3973.1">A parallel implementation of the map function using the parallel overload of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3974.1">std::transform()</span></code><span class="koboSpan" id="kobo.3975.1"> is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3976.1">template</span></span><span class="koboSpan" id="kobo.3977.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3978.1">typename</span></span><span class="koboSpan" id="kobo.3979.1"> Iter, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3980.1">typename</span></span><span class="koboSpan" id="kobo.3981.1"> F&gt;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.3982.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3983.1">parallel_map</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3984.1">(Iter begin, Iter end, F&amp;&amp; f)</span></span><span class="koboSpan" id="kobo.3985.1">
{
   std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3986.1">transform</span></span><span class="koboSpan" id="kobo.3987.1">(std::execution::par,
                  begin, end,
                  begin,
                  std::forward&lt;F&gt;(f));
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3988.1">A </span><a id="_idIndexMarker1059"/><span class="koboSpan" id="kobo.3989.1">parallel implementation of the fold function using the parallel overload of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3990.1">std::reduce()</span></code><span class="koboSpan" id="kobo.3991.1"> is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3992.1">template</span></span><span class="koboSpan" id="kobo.3993.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3994.1">typename</span></span><span class="koboSpan" id="kobo.3995.1"> Iter, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3996.1">typename</span></span><span class="koboSpan" id="kobo.3997.1"> R, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3998.1">typename</span></span><span class="koboSpan" id="kobo.3999.1"> F&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4000.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4001.1">parallel_fold</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4002.1">(Iter begin, Iter end, R init, F&amp;&amp; op)</span></span><span class="koboSpan" id="kobo.4003.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4004.1">return</span></span><span class="koboSpan" id="kobo.4005.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4006.1">reduce</span></span><span class="koboSpan" id="kobo.4007.1">(std::execution::par,
                      begin, end,
                      init,
                      std::forward&lt;F&gt;(op));
}
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-549"><span class="koboSpan" id="kobo.4008.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4009.1">In C++17, 69 of </span><a id="_idIndexMarker1060"/><span class="koboSpan" id="kobo.4010.1">the standard generic algorithms have been overloaded to support parallel execution. </span><span class="koboSpan" id="kobo.4010.2">These overloads take an execution policy as the first parameter. </span><span class="koboSpan" id="kobo.4010.3">The available execution policies, from header </span><code class="inlineCode"><span class="koboSpan" id="kobo.4011.1">&lt;execution&gt;</span></code><span class="koboSpan" id="kobo.4012.1">, are as follows:</span></p>
<table class="table-container" id="table002-4">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.4013.1">Policy</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.4014.1">Since</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.4015.1">Description</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.4016.1">Global object</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4017.1">std::execution::sequenced_policy</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4018.1">C++17</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4019.1">Indicates that the algorithm may not execute in parallel.</span></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4020.1">std::execution::seq</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4021.1">std::execution::parallel_policy</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4022.1">C++17</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4023.1">Indicates that the algorithm’s execution may be parallelized.</span></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4024.1">std::execution::par</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4025.1">std::execution::parallel_unsequenced_policy</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4026.1">C++17</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4027.1">Indicates that the algorithm’s execution may be parallelized and vectorized.</span></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4028.1">std::execution::par_unseq</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4029.1">std::execution::unsequenced_policy</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4030.1">C++20</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4031.1">Indicates that the algorithm’s execution may be vectorized.</span></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4032.1">std::execution::unseq</span></code></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.4033.1">Table 8.2: Execution policies from the &lt;execution&gt; header</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.4034.1">Vectorization is the process of transforming an algorithm so that instead of working on a single value at a time it would work on a set of values (vector) at the same time. </span><span class="koboSpan" id="kobo.4034.2">Modern processors provide this at a hardware level through </span><strong class="keyWord"><span class="koboSpan" id="kobo.4035.1">SIMD</span></strong><span class="koboSpan" id="kobo.4036.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.4037.1">Single Instruction, Multiple Data</span></strong><span class="koboSpan" id="kobo.4038.1">) units.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.4039.1">Apart</span><a id="_idIndexMarker1061"/><span class="koboSpan" id="kobo.4040.1"> from the existing </span><a id="_idIndexMarker1062"/><span class="koboSpan" id="kobo.4041.1">algorithms that have been overloaded, seven new algorithms have been added:</span></p>
<table class="table-container" id="table003-4">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.4042.1">Algorithm</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.4043.1">Description</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4044.1">std::for_each_n</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4045.1">Applies a given function to the first </span><em class="italic"><span class="koboSpan" id="kobo.4046.1">N</span></em><span class="koboSpan" id="kobo.4047.1"> elements of the specified range, according to the specified execution policy.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4048.1">std::exclusive_scan</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4049.1">Computes the partial sum of a range of elements (using either </span><code class="inlineCode"><span class="koboSpan" id="kobo.4050.1">std::plus&lt;&gt;</span></code><span class="koboSpan" id="kobo.4051.1"> or a binary operation) but excludes the </span><em class="italic"><span class="koboSpan" id="kobo.4052.1">i</span></em><span class="koboSpan" id="kobo.4053.1">th element from the </span><em class="italic"><span class="koboSpan" id="kobo.4054.1">i</span></em><span class="koboSpan" id="kobo.4055.1">th sum. </span><span class="koboSpan" id="kobo.4055.2">If the binary operation is associative, the result is the same as when using </span><code class="inlineCode"><span class="koboSpan" id="kobo.4056.1">std::partial_sum()</span></code><span class="koboSpan" id="kobo.4057.1">.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4058.1">std::inclusive_scan</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4059.1">Computes the partial sum of a range of elements (using either </span><code class="inlineCode"><span class="koboSpan" id="kobo.4060.1">std::plus&lt;&gt;</span></code><span class="koboSpan" id="kobo.4061.1"> or a binary operation) but includes the </span><em class="italic"><span class="koboSpan" id="kobo.4062.1">i</span></em><span class="koboSpan" id="kobo.4063.1">th element in the </span><em class="italic"><span class="koboSpan" id="kobo.4064.1">i</span></em><span class="koboSpan" id="kobo.4065.1">th sum.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4066.1">std::transform_exclusive_scan</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4067.1">Applies a unary function to each element of a range and then calculates an exclusive scan on the resulting range.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4068.1">std::transform_inclusive_scan</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4069.1">Applies a unary function to each element of a range and then calculates an inclusive scan on the resulting range.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4070.1">std::reduce</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4071.1">An out-of-order version of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4072.1">std::accumulate()</span></code><span class="koboSpan" id="kobo.4073.1">.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4074.1">std::transform_reduce</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4075.1">Applies a function to the elements of a range then accumulates the elements of the resulting range out of order (that is, reduces).</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.4076.1">Table 8.2: New algorithms in C++17 from the &lt;algorithm&gt; and &lt;numeric&gt; headers</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4077.1">In the preceding examples, we used </span><code class="inlineCode"><span class="koboSpan" id="kobo.4078.1">std::transform()</span></code><span class="koboSpan" id="kobo.4079.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4080.1">std::reduce()</span></code><span class="koboSpan" id="kobo.4081.1"> with an execution policy – in our case, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4082.1">std::execution::par</span></code><span class="koboSpan" id="kobo.4083.1">. </span><span class="koboSpan" id="kobo.4083.2">The algorithm </span><code class="inlineCode"><span class="koboSpan" id="kobo.4084.1">std::reduce()</span></code><span class="koboSpan" id="kobo.4085.1"> is similar to </span><code class="inlineCode"><span class="koboSpan" id="kobo.4086.1">std::accumulate()</span></code><span class="koboSpan" id="kobo.4087.1"> but it processes the elements out of order. </span><code class="inlineCode"><span class="koboSpan" id="kobo.4088.1">std::accumulate()</span></code><span class="koboSpan" id="kobo.4089.1"> does not have an</span><a id="_idIndexMarker1063"/><span class="koboSpan" id="kobo.4090.1"> overload for specifying an execution policy, so it can only execute sequentially.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.4091.1">It is important to note that, just because an algorithm supports parallelization, it doesn’t mean that it will run faster than the sequential version. </span><span class="koboSpan" id="kobo.4091.2">Execution depends on the actual hardware, datasets, and algorithm particularities. </span><span class="koboSpan" id="kobo.4091.3">In fact, some of these algorithms may never, or hardly ever, execute faster when parallelized than sequentially. </span><span class="koboSpan" id="kobo.4091.4">For this reason, for instance, the Microsoft implementation of several algorithms that permute, copy, or move elements does not perform parallelization but falls back to sequential execution in all cases. </span><span class="koboSpan" id="kobo.4091.5">These algorithms are </span><code class="inlineCode"><span class="koboSpan" id="kobo.4092.1">copy()</span></code><span class="koboSpan" id="kobo.4093.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4094.1">copy_n()</span></code><span class="koboSpan" id="kobo.4095.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4096.1">fill()</span></code><span class="koboSpan" id="kobo.4097.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4098.1">fill_n()</span></code><span class="koboSpan" id="kobo.4099.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4100.1">move()</span></code><span class="koboSpan" id="kobo.4101.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4102.1">reverse()</span></code><span class="koboSpan" id="kobo.4103.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4104.1">reverse_copy()</span></code><span class="koboSpan" id="kobo.4105.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4106.1">rotate()</span></code><span class="koboSpan" id="kobo.4107.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4108.1">rotate_copy()</span></code><span class="koboSpan" id="kobo.4109.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4110.1">swap_ranges()</span></code><span class="koboSpan" id="kobo.4111.1">. </span><span class="koboSpan" id="kobo.4111.2">Moreover, the standard does not guarantee a particular execution; specifying a policy is actually a request for an execution strategy but with no guarantees implied.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.4112.1">On the </span><a id="_idIndexMarker1064"/><span class="koboSpan" id="kobo.4113.1">other hand, the standard library allows parallel algorithms to allocate memory. </span><span class="koboSpan" id="kobo.4113.2">When this cannot be done, an algorithm throws </span><code class="inlineCode"><span class="koboSpan" id="kobo.4114.1">std::bad_alloc</span></code><span class="koboSpan" id="kobo.4115.1">. </span><span class="koboSpan" id="kobo.4115.2">However, again, the Microsoft implementation differs and instead of throwing an exception, it falls back to the sequential version of the algorithm.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4116.1">Another important aspect that must be known is that the standard algorithms work with different kinds of iterators. </span><span class="koboSpan" id="kobo.4116.2">Some require forward iterators, some input iterators. </span><span class="koboSpan" id="kobo.4116.3">However, all the overloads that allow specifying an execution policy restrict the use of the algorithm with forward iterators.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4117.1">Take a look at the following table:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.4118.1"><img alt="" src="../Images/B21549_08_04.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.4119.1">Figure 8.4: A comparison of execution times for sequential and parallel implementations of the map and reduce functions</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4120.1">Here, you can </span><a id="_idIndexMarker1065"/><span class="koboSpan" id="kobo.4121.1">see a comparison of execution times for sequential and parallel implementations of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4122.1">map</span></code><span class="koboSpan" id="kobo.4123.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4124.1">reduce</span></code><span class="koboSpan" id="kobo.4125.1"> functions. </span><span class="koboSpan" id="kobo.4125.2">Highlighted are the versions of the functions implemented in this recipe. </span><span class="koboSpan" id="kobo.4125.3">These times may vary slightly from execution to execution. </span><span class="koboSpan" id="kobo.4125.4">These values were obtained by running a 64-bit released version compiled with Visual C++ 2019 16.4.x on a machine with an Intel Xeon CPU with four cores. </span><span class="koboSpan" id="kobo.4125.5">Although the</span><a id="_idIndexMarker1066"/><span class="koboSpan" id="kobo.4126.1"> parallel versions perform better than the sequential version for these datasets, which one is actually better varies with the size of the dataset. </span><span class="koboSpan" id="kobo.4126.2">This is why profiling is key when you optimize by parallelizing work.</span></p>
<h2 class="heading-2" id="_idParaDest-550"><span class="koboSpan" id="kobo.4127.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4128.1">In this example, we have seen separate implementations for </span><code class="inlineCode"><span class="koboSpan" id="kobo.4129.1">map</span></code><span class="koboSpan" id="kobo.4130.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4131.1">fold</span></code><span class="koboSpan" id="kobo.4132.1"> (which is also called reduce). </span><span class="koboSpan" id="kobo.4132.2">However, in C++17, there is a standard algorithm called </span><code class="inlineCode"><span class="koboSpan" id="kobo.4133.1">std::transform_reduce()</span></code><span class="koboSpan" id="kobo.4134.1">, which composes the two operations into a single function call. </span><span class="koboSpan" id="kobo.4134.2">This algorithm has overloads for sequential execution, as well as policy-based execution for parallelism and vectorization. </span><span class="koboSpan" id="kobo.4134.3">We can, therefore, utilize this algorithm instead of the handwritten implementation we did in these previous three recipes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4135.1">The following are the sequential and parallel versions of the algorithm used to compute the sum of the doubles of all the elements of a range:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.4136.1">std::vector&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4137.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4138.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4139.1">v</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4140.1">(size)</span></span><span class="koboSpan" id="kobo.4141.1">;
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4142.1">iota</span></span><span class="koboSpan" id="kobo.4143.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4144.1">begin</span></span><span class="koboSpan" id="kobo.4145.1">(v), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4146.1">end</span></span><span class="koboSpan" id="kobo.4147.1">(v), </span><span class="hljs-number"><span class="koboSpan" id="kobo.4148.1">1</span></span><span class="koboSpan" id="kobo.4149.1">);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4150.1">// sequential</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.4151.1">auto</span></span><span class="koboSpan" id="kobo.4152.1"> sums = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4153.1">transform_reduce</span></span><span class="koboSpan" id="kobo.4154.1">(
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4155.1">begin</span></span><span class="koboSpan" id="kobo.4156.1">(v), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4157.1">end</span></span><span class="koboSpan" id="kobo.4158.1">(v), 
    </span><span class="hljs-number"><span class="koboSpan" id="kobo.4159.1">0LL</span></span><span class="koboSpan" id="kobo.4160.1">,
    std::plus&lt;&gt;(),
    [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.4161.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4162.1">const</span></span><span class="koboSpan" id="kobo.4163.1"> i) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4164.1">return</span></span><span class="koboSpan" id="kobo.4165.1"> i + i; } );
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4166.1">// parallel</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.4167.1">auto</span></span><span class="koboSpan" id="kobo.4168.1"> sump = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4169.1">transform_reduce</span></span><span class="koboSpan" id="kobo.4170.1">(
    std::execution::par,
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4171.1">begin</span></span><span class="koboSpan" id="kobo.4172.1">(v), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4173.1">end</span></span><span class="koboSpan" id="kobo.4174.1">(v),
    </span><span class="hljs-number"><span class="koboSpan" id="kobo.4175.1">0LL</span></span><span class="koboSpan" id="kobo.4176.1">,
    std::plus&lt;&gt;(),
    [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.4177.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4178.1">const</span></span><span class="koboSpan" id="kobo.4179.1"> i) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4180.1">return</span></span><span class="koboSpan" id="kobo.4181.1"> i + i; });  
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4182.1">If we compare</span><a id="_idIndexMarker1067"/><span class="koboSpan" id="kobo.4183.1"> the execution time of these two calls, seen in the following table in the last two columns, with the total time for separately calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.4184.1">map</span></code><span class="koboSpan" id="kobo.4185.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4186.1">reduce</span></code><span class="koboSpan" id="kobo.4187.1">, as seen in the other implementations, you can see that </span><code class="inlineCode"><span class="koboSpan" id="kobo.4188.1">std::transform_reduce()</span></code><span class="koboSpan" id="kobo.4189.1">, especially the parallel </span><a id="_idIndexMarker1068"/><span class="koboSpan" id="kobo.4190.1">version, executes better in most cases:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.4191.1"><img alt="" src="../Images/B21549_08_05.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.4192.1">Figure 8.5: A comparison of execution times for the transform/reduce pattern with a highlight of the times for the std::transform_reduce() standard algorithm from C++17</span></p>
<h2 class="heading-2" id="_idParaDest-551"><span class="koboSpan" id="kobo.4193.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.4194.1">Chapter 3</span></em><span class="koboSpan" id="kobo.4195.1">, </span><em class="italic"><span class="koboSpan" id="kobo.4196.1">Implementing higher-order functions map and fold</span></em><span class="koboSpan" id="kobo.4197.1">, to learn about higher-order functions in functional programming and see how to implement the widely used </span><code class="inlineCode"><span class="koboSpan" id="kobo.4198.1">map</span></code><span class="koboSpan" id="kobo.4199.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4200.1">fold</span></code><span class="koboSpan" id="kobo.4201.1"> (or reduce) functions</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.4202.1">Implementing parallel map and fold with threads</span></em><span class="koboSpan" id="kobo.4203.1">, to see how to implement the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4204.1">map</span></code><span class="koboSpan" id="kobo.4205.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4206.1">fold</span></code><span class="koboSpan" id="kobo.4207.1"> functions from functional programming using raw threads</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.4208.1">Implementing parallel map and fold with tasks</span></em><span class="koboSpan" id="kobo.4209.1">, to see how to implement the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4210.1">map</span></code><span class="koboSpan" id="kobo.4211.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4212.1">fold</span></code><span class="koboSpan" id="kobo.4213.1"> functions from functional programming using asynchronous functions</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-552"><span class="koboSpan" id="kobo.4214.1">Using joinable threads and cancellation mechanisms</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.4215.1">The C++11 class </span><code class="inlineCode"><span class="koboSpan" id="kobo.4216.1">std::thread</span></code><span class="koboSpan" id="kobo.4217.1"> represents a single thread of execution and allows multiple functions to execute concurrently. </span><span class="koboSpan" id="kobo.4217.2">However, it has a major inconvenience: you must explicitly</span><a id="_idIndexMarker1069"/><span class="koboSpan" id="kobo.4218.1"> invoke the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4219.1">join()</span></code><span class="koboSpan" id="kobo.4220.1"> method to wait for the thread to finish execution. </span><span class="koboSpan" id="kobo.4220.2">This can lead to problems because if a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4221.1">std::thread</span></code><span class="koboSpan" id="kobo.4222.1"> object is destroyed while it is still joinable, then </span><code class="inlineCode"><span class="koboSpan" id="kobo.4223.1">std::terminate()</span></code><span class="koboSpan" id="kobo.4224.1"> is called. </span><span class="koboSpan" id="kobo.4224.2">C++20 provides an improved thread </span><a id="_idIndexMarker1070"/><span class="koboSpan" id="kobo.4225.1">class called </span><code class="inlineCode"><span class="koboSpan" id="kobo.4226.1">std::jthread</span></code><span class="koboSpan" id="kobo.4227.1"> (from </span><em class="italic"><span class="koboSpan" id="kobo.4228.1">joinable thread</span></em><span class="koboSpan" id="kobo.4229.1">) that automatically calls </span><code class="inlineCode"><span class="koboSpan" id="kobo.4230.1">join()</span></code><span class="koboSpan" id="kobo.4231.1"> if the thread is still joinable when the object is destroyed. </span><span class="koboSpan" id="kobo.4231.2">Moreover, this type supports cancellation through </span><code class="inlineCode"><span class="koboSpan" id="kobo.4232.1">std::stop_source</span></code><span class="koboSpan" id="kobo.4233.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.4234.1">std::stop_token</span></code><span class="koboSpan" id="kobo.4235.1"> and its destructor also requests the thread to stop before joining. </span><span class="koboSpan" id="kobo.4235.2">In this recipe, you will learn how to use these new C++20 types.</span></p>
<h2 class="heading-2" id="_idParaDest-553"><span class="koboSpan" id="kobo.4236.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4237.1">Before you continue with this, you should read the first recipe of this chapter, </span><em class="italic"><span class="koboSpan" id="kobo.4238.1">Working with threads</span></em><span class="koboSpan" id="kobo.4239.1">, to make sure you are familiar with </span><code class="inlineCode"><span class="koboSpan" id="kobo.4240.1">std::thread</span></code><span class="koboSpan" id="kobo.4241.1">. </span><span class="koboSpan" id="kobo.4241.2">To use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4242.1">std::jthread</span></code><span class="koboSpan" id="kobo.4243.1">, you need to include the same </span><code class="inlineCode"><span class="koboSpan" id="kobo.4244.1">&lt;thread&gt;</span></code><span class="koboSpan" id="kobo.4245.1"> header. </span><span class="koboSpan" id="kobo.4245.2">For </span><code class="inlineCode"><span class="koboSpan" id="kobo.4246.1">std::stop_source</span></code><span class="koboSpan" id="kobo.4247.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4248.1">std::stop_token</span></code><span class="koboSpan" id="kobo.4249.1">, you need to include the header </span><code class="inlineCode"><span class="koboSpan" id="kobo.4250.1">&lt;stop_token&gt;</span></code><span class="koboSpan" id="kobo.4251.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-554"><span class="koboSpan" id="kobo.4252.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4253.1">The typical scenarios for using joinable threads and a cooperative cancellation mechanism are as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4254.1">If you want to automatically join a thread object when it goes out of scope, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4255.1">std::jthread</span></code><span class="koboSpan" id="kobo.4256.1"> instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4257.1">std::thread</span></code><span class="koboSpan" id="kobo.4258.1">. </span><span class="koboSpan" id="kobo.4258.2">You can still use all the methods that </span><code class="inlineCode"><span class="koboSpan" id="kobo.4259.1">std::thread</span></code><span class="koboSpan" id="kobo.4260.1"> has, such as explicitly joining with </span><code class="inlineCode"><span class="koboSpan" id="kobo.4261.1">join()</span></code><span class="koboSpan" id="kobo.4262.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.4263.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4264.1">thread_func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4265.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4266.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4267.1"> i)</span></span><span class="koboSpan" id="kobo.4268.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4269.1">while</span></span><span class="koboSpan" id="kobo.4270.1">(i-- &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.4271.1">0</span></span><span class="koboSpan" id="kobo.4272.1">)
    {
        std::cout &lt;&lt; i &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4273.1">'\n'</span></span><span class="koboSpan" id="kobo.4274.1">;
    }
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.4275.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4276.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4277.1">()</span></span><span class="koboSpan" id="kobo.4278.1">
{
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.4279.1">std::jthread </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4280.1">t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4281.1">(thread_func, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4282.1">10</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4283.1">)</span></span><span class="koboSpan" id="kobo.4284.1">;
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4285.1">If you </span><a id="_idIndexMarker1071"/><span class="koboSpan" id="kobo.4286.1">need to be able to cancel the execution of a thread, you</span><a id="_idIndexMarker1072"/><span class="koboSpan" id="kobo.4287.1"> should do the following:</span><ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4288.1">Make sure the first parameter of the thread function is a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4289.1">std::stop_token</span></code><span class="koboSpan" id="kobo.4290.1"> object.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4291.1">In the thread function, periodically check if stopping was requested using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4292.1">stop_requested()</span></code><span class="koboSpan" id="kobo.4293.1"> method of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4294.1">std::stop_token</span></code><span class="koboSpan" id="kobo.4295.1"> object and stop when signaled.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4296.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4297.1">std::jthread</span></code><span class="koboSpan" id="kobo.4298.1"> for executing the function on a separate thread.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4299.1">From the calling thread, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4300.1">request_stop()</span></code><span class="koboSpan" id="kobo.4301.1"> method of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4302.1">std::jthread</span></code><span class="koboSpan" id="kobo.4303.1"> object to request the thread function to stop and return:
            </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.4304.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4305.1">thread_func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4306.1">(std::stop_token st, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4307.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4308.1">&amp; i)</span></span><span class="koboSpan" id="kobo.4309.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4310.1">while</span></span><span class="koboSpan" id="kobo.4311.1">(!st.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4312.1">stop_requested</span></span><span class="koboSpan" id="kobo.4313.1">() &amp;&amp; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.4314.1">100</span></span><span class="koboSpan" id="kobo.4315.1">)
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4316.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4317.1">namespace</span></span><span class="koboSpan" id="kobo.4318.1"> std::chrono_literals;
        std::this_thread::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4319.1">sleep_for</span></span><span class="koboSpan" id="kobo.4320.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4321.1">200</span></span><span class="koboSpan" id="kobo.4322.1">ms);
        i++;
    }
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.4323.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4324.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4325.1">()</span></span><span class="koboSpan" id="kobo.4326.1">
{
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.4327.1">int</span></span><span class="koboSpan" id="kobo.4328.1"> a = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4329.1">0</span></span><span class="koboSpan" id="kobo.4330.1">;
    
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.4331.1">std::jthread </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4332.1">t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4333.1">(thread_func, std::ref(a))</span></span><span class="koboSpan" id="kobo.4334.1">;
    
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4335.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4336.1">namespace</span></span><span class="koboSpan" id="kobo.4337.1"> std::chrono_literals;
    std::this_thread::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4338.1">sleep_for</span></span><span class="koboSpan" id="kobo.4339.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4340.1">1</span></span><span class="koboSpan" id="kobo.4341.1">s);
    
    t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4342.1">request_stop</span></span><span class="koboSpan" id="kobo.4343.1">();
    
    std::cout &lt;&lt; a &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4344.1">'\n'</span></span><span class="koboSpan" id="kobo.4345.1">;       </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4346.1">// prints 4</span></span><span class="koboSpan" id="kobo.4347.1">
}
</span></code></pre>
</li>
</ul>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4348.1">If you </span><a id="_idIndexMarker1073"/><span class="koboSpan" id="kobo.4349.1">need to cancel the work of multiple threads, then</span><a id="_idIndexMarker1074"/><span class="koboSpan" id="kobo.4350.1"> you can do the following:</span><ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4351.1">All thread functions must take a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4352.1">std::stop_token</span></code><span class="koboSpan" id="kobo.4353.1"> object as the first argument.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4354.1">All thread functions should periodically check if a stop was requested by calling the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4355.1">stop_requested()</span></code><span class="koboSpan" id="kobo.4356.1"> method of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4357.1">std::stop_token</span></code><span class="koboSpan" id="kobo.4358.1"> and, if a stop was requested, abort the execution.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4359.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4360.1">std::jthread</span></code><span class="koboSpan" id="kobo.4361.1"> to execute functions on different threads.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4362.1">In the calling thread, create a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4363.1">std::stop_source</span></code><span class="koboSpan" id="kobo.4364.1"> object.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4365.1">Get a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4366.1">std::stop_token</span></code><span class="koboSpan" id="kobo.4367.1"> object by calling the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4368.1">get_token()</span></code><span class="koboSpan" id="kobo.4369.1"> method of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4370.1">std::stop_source</span></code><span class="koboSpan" id="kobo.4371.1"> object and pass it as the first argument for the thread function when creating </span><code class="inlineCode"><span class="koboSpan" id="kobo.4372.1">std::jthread</span></code><span class="koboSpan" id="kobo.4373.1"> objects.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4374.1">When you want to stop the execution of the thread functions, call the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4375.1">request_stop()</span></code><span class="koboSpan" id="kobo.4376.1"> method of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4377.1">std::stop_source</span></code><span class="koboSpan" id="kobo.4378.1"> object.
            </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.4379.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4380.1">thread_func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4381.1">(std::stop_token st, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4382.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4383.1">&amp; i)</span></span><span class="koboSpan" id="kobo.4384.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4385.1">while</span></span><span class="koboSpan" id="kobo.4386.1">(!st.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4387.1">stop_requested</span></span><span class="koboSpan" id="kobo.4388.1">() &amp;&amp; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.4389.1">100</span></span><span class="koboSpan" id="kobo.4390.1">)
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4391.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4392.1">namespace</span></span><span class="koboSpan" id="kobo.4393.1"> std::chrono_literals;
        std::this_thread::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4394.1">sleep_for</span></span><span class="koboSpan" id="kobo.4395.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4396.1">200</span></span><span class="koboSpan" id="kobo.4397.1">ms);
        i++;
    }
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.4398.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4399.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4400.1">()</span></span><span class="koboSpan" id="kobo.4401.1">
{
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.4402.1">int</span></span><span class="koboSpan" id="kobo.4403.1"> a = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4404.1">0</span></span><span class="koboSpan" id="kobo.4405.1">;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.4406.1">int</span></span><span class="koboSpan" id="kobo.4407.1"> b = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4408.1">10</span></span><span class="koboSpan" id="kobo.4409.1">;
    
    std::stop_source st;
    
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.4410.1">std::jthread </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4411.1">t1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4412.1">(thread_func, st.get_token(),</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.4413.1">                    std::ref(a))</span></span><span class="koboSpan" id="kobo.4414.1">;
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.4415.1">std::jthread </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4416.1">t2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4417.1">(thread_func, st.get_token(),</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.4418.1">                    std::ref(b))</span></span><span class="koboSpan" id="kobo.4419.1">;
        
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4420.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4421.1">namespace</span></span><span class="koboSpan" id="kobo.4422.1"> std::chrono_literals;
    std::this_thread::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4423.1">sleep_for</span></span><span class="koboSpan" id="kobo.4424.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4425.1">1</span></span><span class="koboSpan" id="kobo.4426.1">s);
    
    st.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4427.1">request_stop</span></span><span class="koboSpan" id="kobo.4428.1">();
    
    std::cout &lt;&lt; a &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4429.1">' '</span></span><span class="koboSpan" id="kobo.4430.1"> &lt;&lt; b &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4431.1">'\n'</span></span><span class="koboSpan" id="kobo.4432.1">;       </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4433.1">// prints 4</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.4434.1">// and 14</span></span><span class="koboSpan" id="kobo.4435.1">
}
</span></code></pre>
</li>
</ul>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4436.1">If you </span><a id="_idIndexMarker1075"/><span class="koboSpan" id="kobo.4437.1">need to execute a piece of code when a stop source is </span><a id="_idIndexMarker1076"/><span class="koboSpan" id="kobo.4438.1">requesting cancellation, you can use a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4439.1">std::stop_callback</span></code><span class="koboSpan" id="kobo.4440.1"> created with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4441.1">std::stop_token</span></code><span class="koboSpan" id="kobo.4442.1"> object, which signals the stop request and a callback function that is invoked when the stop is requested (through the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4443.1">std::stop_source</span></code><span class="koboSpan" id="kobo.4444.1"> object associated with </span><code class="inlineCode"><span class="koboSpan" id="kobo.4445.1">std::stop_token</span></code><span class="koboSpan" id="kobo.4446.1">):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.4447.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4448.1">thread_func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4449.1">(std::stop_token st, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4450.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4451.1">&amp; i)</span></span><span class="koboSpan" id="kobo.4452.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4453.1">while</span></span><span class="koboSpan" id="kobo.4454.1">(!st.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4455.1">stop_requested</span></span><span class="koboSpan" id="kobo.4456.1">() &amp;&amp; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.4457.1">100</span></span><span class="koboSpan" id="kobo.4458.1">)
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4459.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4460.1">namespace</span></span><span class="koboSpan" id="kobo.4461.1"> std::chrono_literals;
        std::this_thread::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4462.1">sleep_for</span></span><span class="koboSpan" id="kobo.4463.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4464.1">200</span></span><span class="koboSpan" id="kobo.4465.1">ms);
        i++;
    }
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.4466.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4467.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4468.1">()</span></span><span class="koboSpan" id="kobo.4469.1">
{
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.4470.1">int</span></span><span class="koboSpan" id="kobo.4471.1"> a = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4472.1">0</span></span><span class="koboSpan" id="kobo.4473.1">;
    
    std::stop_source src;
    std::stop_token token = src.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4474.1">get_token</span></span><span class="koboSpan" id="kobo.4475.1">();
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.4476.1">std::stop_callback </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4477.1">cb</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4478.1">(token, []{std::cout &lt;&lt; </span></span><span class="hljs-string"><span class="koboSpan" id="kobo.4479.1">"the end\n"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4480.1">;})</span></span><span class="koboSpan" id="kobo.4481.1">;
    
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.4482.1">std::jthread </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4483.1">t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4484.1">(thread_func, token, std::ref(a))</span></span><span class="koboSpan" id="kobo.4485.1">;
        
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4486.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4487.1">namespace</span></span><span class="koboSpan" id="kobo.4488.1"> std::chrono_literals;
    std::this_thread::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4489.1">sleep_for</span></span><span class="koboSpan" id="kobo.4490.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4491.1">1</span></span><span class="koboSpan" id="kobo.4492.1">s);
    
    src.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4493.1">request_stop</span></span><span class="koboSpan" id="kobo.4494.1">();
    
    std::cout &lt;&lt; a &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4495.1">'\n'</span></span><span class="koboSpan" id="kobo.4496.1">;       </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4497.1">// prints "the end" and 4</span></span><span class="koboSpan" id="kobo.4498.1">
}
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-555"><span class="koboSpan" id="kobo.4499.1">How it works...</span></h2>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4500.1">std::jthread</span></code><span class="koboSpan" id="kobo.4501.1"> is very </span><a id="_idIndexMarker1077"/><span class="koboSpan" id="kobo.4502.1">similar to </span><code class="inlineCode"><span class="koboSpan" id="kobo.4503.1">std::thread</span></code><span class="koboSpan" id="kobo.4504.1">. </span><span class="koboSpan" id="kobo.4504.2">It is, in fact, an attempt to fix</span><a id="_idIndexMarker1078"/><span class="koboSpan" id="kobo.4505.1"> what was missing for threads in C++11. </span><span class="koboSpan" id="kobo.4505.2">Its public interface is very similar to </span><code class="inlineCode"><span class="koboSpan" id="kobo.4506.1">std::thread</span></code><span class="koboSpan" id="kobo.4507.1">. </span><span class="koboSpan" id="kobo.4507.2">All</span><a id="_idIndexMarker1079"/><span class="koboSpan" id="kobo.4508.1"> the methods </span><code class="inlineCode"><span class="koboSpan" id="kobo.4509.1">std::thread</span></code><span class="koboSpan" id="kobo.4510.1"> has are also present in </span><code class="inlineCode"><span class="koboSpan" id="kobo.4511.1">std::thread</span></code><span class="koboSpan" id="kobo.4512.1">. </span><span class="koboSpan" id="kobo.4512.2">However, it differs in the following key aspects:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4513.1">Internally, it maintains, at least logically, a shared stop state, which allows for the request of the thread function to stop execution.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4514.1">It has several methods for handling cooperative cancellation: </span><code class="inlineCode"><span class="koboSpan" id="kobo.4515.1">get_stop_source()</span></code><span class="koboSpan" id="kobo.4516.1">, which returns a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4517.1">std::stop_source</span></code><span class="koboSpan" id="kobo.4518.1"> object associated with the shared stop state of the thread, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4519.1">get_stop_token()</span></code><span class="koboSpan" id="kobo.4520.1">, which returns a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4521.1">std::stop_token</span></code><span class="koboSpan" id="kobo.4522.1"> associated with the shared stop state of the thread, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4523.1">request_stop()</span></code><span class="koboSpan" id="kobo.4524.1">, which requests the cancellation of the execution of the thread function via the shared stop state.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4525.1">The behavior of its destructor, which, when the thread is joinable, calls </span><code class="inlineCode"><span class="koboSpan" id="kobo.4526.1">request_stop()</span></code><span class="koboSpan" id="kobo.4527.1"> and then </span><code class="inlineCode"><span class="koboSpan" id="kobo.4528.1">join()</span></code><span class="koboSpan" id="kobo.4529.1"> to first signal the request to stop execution and then wait until the thread has finished its execution.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.4530.1">You can create </span><code class="inlineCode"><span class="koboSpan" id="kobo.4531.1">std::jthread</span></code><span class="koboSpan" id="kobo.4532.1"> objects just as you would create </span><code class="inlineCode"><span class="koboSpan" id="kobo.4533.1">std::thread</span></code><span class="koboSpan" id="kobo.4534.1"> objects. </span><span class="koboSpan" id="kobo.4534.2">However, the callable function that you pass to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4535.1">std::jthread</span></code><span class="koboSpan" id="kobo.4536.1"> can have a first argument of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.4537.1">std::stop_token</span></code><span class="koboSpan" id="kobo.4538.1">. </span><span class="koboSpan" id="kobo.4538.2">This is necessary when you want to be able to cooperatively cancel the thread’s execution. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.4539.1">Typical scenarios include graphical user interfaces where user interaction may cancel work in progress, but many other situations can be envisioned. </span><span class="koboSpan" id="kobo.4539.2">The invocation of such a function thread happens as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4540.1">If the first argument for the thread function, supplied when constructing </span><code class="inlineCode"><span class="koboSpan" id="kobo.4541.1">std::jthread</span></code><span class="koboSpan" id="kobo.4542.1">, is a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4543.1">std::stop_token</span></code><span class="koboSpan" id="kobo.4544.1">, it is forwarded to the callable function.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4545.1">If the first argument, when there are arguments, for the callable function is not a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4546.1">std::stop_token</span></code><span class="koboSpan" id="kobo.4547.1"> object, then the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4548.1">std::stop_token</span></code><span class="koboSpan" id="kobo.4549.1"> object associated with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4550.1">std::jthread</span></code><span class="koboSpan" id="kobo.4551.1"> object’s internal shared stop state is passed to the function. </span><span class="koboSpan" id="kobo.4551.2">This token is obtained with a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.4552.1">get_stop_token()</span></code><span class="koboSpan" id="kobo.4553.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.4554.1">The function thread </span><a id="_idIndexMarker1080"/><span class="koboSpan" id="kobo.4555.1">must periodically check the status of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4556.1">std::stop_token</span></code><span class="koboSpan" id="kobo.4557.1"> object. </span><span class="koboSpan" id="kobo.4557.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.4558.1">stop_requested()</span></code><span class="koboSpan" id="kobo.4559.1"> method checks if a stop was requested. </span><span class="koboSpan" id="kobo.4559.2">The request to stop comes from a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4560.1">std::stop_source</span></code><span class="koboSpan" id="kobo.4561.1"> object.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4562.1">If multiple stop </span><a id="_idIndexMarker1081"/><span class="koboSpan" id="kobo.4563.1">tokens are associated with the same stop source, a stop request is visible to all the stop tokens. </span><span class="koboSpan" id="kobo.4563.2">If a stop is requested, it cannot be withdrawn, and successive stop requests have no meaning. </span><span class="koboSpan" id="kobo.4563.3">To request a stop, you should call the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4564.1">request_stop()</span></code><span class="koboSpan" id="kobo.4565.1"> method. </span><span class="koboSpan" id="kobo.4565.2">You can check if a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4566.1">std::stop_source</span></code><span class="koboSpan" id="kobo.4567.1"> is associated with a stop state and can be requested to stop by calling the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4568.1">stop_possible()</span></code><span class="koboSpan" id="kobo.4569.1"> method.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4570.1">If you need to invoke a callback function when a stop source is requested to stop, then you can use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4571.1">std::stop_callback</span></code><span class="koboSpan" id="kobo.4572.1"> class. </span><span class="koboSpan" id="kobo.4572.2">This associates a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4573.1">std::stop_token</span></code><span class="koboSpan" id="kobo.4574.1"> object with a callback function. </span><span class="koboSpan" id="kobo.4574.2">When the stop source of the stop token is requested to stop the callback is invoked. </span><span class="koboSpan" id="kobo.4574.3">Callback functions are invoked as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4575.1">In the same thread that invoked </span><code class="inlineCode"><span class="koboSpan" id="kobo.4576.1">request_stop()</span></code><span class="koboSpan" id="kobo.4577.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4578.1">In the thread constructing the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4579.1">std::stop_callback</span></code><span class="koboSpan" id="kobo.4580.1"> object, if the stop has already been requested before the stop callback object has been constructed.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.4581.1">You can create any number of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4582.1">std::stop_callback</span></code><span class="koboSpan" id="kobo.4583.1"> objects for the same stop token. </span><span class="koboSpan" id="kobo.4583.2">However, the order the callbacks are invoked in is unspecified. </span><span class="koboSpan" id="kobo.4583.3">The only guarantee is that they will be executed synchronously, provided that the stop has been requested after the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4584.1">std::stop_callback</span></code><span class="koboSpan" id="kobo.4585.1"> objects have been created.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4586.1">It is also important to note that, if any callback function returns via an exception, then </span><code class="inlineCode"><span class="koboSpan" id="kobo.4587.1">std::terminate()</span></code><span class="koboSpan" id="kobo.4588.1"> will be invoked.</span></p>
<h2 class="heading-2" id="_idParaDest-556"><span class="koboSpan" id="kobo.4589.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.4590.1">Working with threads</span></em><span class="koboSpan" id="kobo.4591.1">, to learn about the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4592.1">std::thread</span></code><span class="koboSpan" id="kobo.4593.1"> class and the basic operations for working with threads in C++</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.4594.1">Sending notifications between threads</span></em><span class="koboSpan" id="kobo.4595.1">, to see how to use condition variables to send notifications between producer and consumer threads</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-557"><span class="koboSpan" id="kobo.4596.1">Synchronizing threads with latches, barriers, and semaphores </span></h1>
<p class="normal"><span class="koboSpan" id="kobo.4597.1">The</span><a id="_idIndexMarker1082"/><span class="koboSpan" id="kobo.4598.1"> thread support library from C++11 includes mutexes and condition variables that enable thread-synchronization to shared resources. </span><span class="koboSpan" id="kobo.4598.2">A mutex allows only one thread of multiple processes to execute, while other threads that want to access a shared resource are put to sleep. </span><span class="koboSpan" id="kobo.4598.3">Mutexes can be expensive to use in some scenarios. </span><span class="koboSpan" id="kobo.4598.4">For this reason, the C++20 standard features several new, simpler synchronization mechanisms: latches, barriers, and semaphores. </span><span class="koboSpan" id="kobo.4598.5">Although these do not provide new use cases, they are simpler to use and can be more performant because they may internally rely on lock-free mechanisms.</span></p>
<h2 class="heading-2" id="_idParaDest-558"><span class="koboSpan" id="kobo.4599.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4600.1">The new</span><a id="_idIndexMarker1083"/><span class="koboSpan" id="kobo.4601.1"> C++20 synchronization mechanisms are defined in new headers. </span><span class="koboSpan" id="kobo.4601.2">You have to include </span><code class="inlineCode"><span class="koboSpan" id="kobo.4602.1">&lt;latch&gt;</span></code><span class="koboSpan" id="kobo.4603.1"> for </span><code class="inlineCode"><span class="koboSpan" id="kobo.4604.1">std::latch</span></code><span class="koboSpan" id="kobo.4605.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4606.1">&lt;barrier&gt;</span></code><span class="koboSpan" id="kobo.4607.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.4608.1">std::barrier</span></code><span class="koboSpan" id="kobo.4609.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4610.1">&lt;semaphore&gt;</span></code><span class="koboSpan" id="kobo.4611.1"> for </span><code class="inlineCode"><span class="koboSpan" id="kobo.4612.1">std::counting_semaphore</span></code><span class="koboSpan" id="kobo.4613.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4614.1">std::binary_semaphore</span></code><span class="koboSpan" id="kobo.4615.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4616.1">The code snippets in this recipe will use the following two functions:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.4617.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4618.1">process</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4619.1">(std::vector&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4620.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4621.1">&gt; </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4622.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4623.1">&amp; data)</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4624.1">noexcept</span></span><span class="koboSpan" id="kobo.4625.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4626.1">for</span></span><span class="koboSpan" id="kobo.4627.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4628.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4629.1">const</span></span><span class="koboSpan" id="kobo.4630.1"> e : data)
      std::cout &lt;&lt; e &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4631.1">' '</span></span><span class="koboSpan" id="kobo.4632.1">;  
   std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4633.1">'\n'</span></span><span class="koboSpan" id="kobo.4634.1">;
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.4635.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4636.1">create</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4637.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4638.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4639.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4640.1"> i, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4641.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4642.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4643.1"> factor)</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4644.1">noexcept</span></span><span class="koboSpan" id="kobo.4645.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4646.1">return</span></span><span class="koboSpan" id="kobo.4647.1"> i * factor;
}
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-559"><span class="koboSpan" id="kobo.4648.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4649.1">Use the C++20 synchronization mechanisms</span><a id="_idIndexMarker1084"/><span class="koboSpan" id="kobo.4650.1"> as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4651.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4652.1">std::latch</span></code><span class="koboSpan" id="kobo.4653.1"> when you need threads to wait until a counter, decreased by other</span><a id="_idIndexMarker1085"/><span class="koboSpan" id="kobo.4654.1"> threads, reaches zero. </span><span class="koboSpan" id="kobo.4654.2">The latch must be initialized with a non-zero count and multiple threads can decrease it, while others wait for the count to reach zero. </span><span class="koboSpan" id="kobo.4654.3">When that happens, all waiting threads are awakened and the latch can no longer be used. </span><span class="koboSpan" id="kobo.4654.4">If the latch count does not decrease to zero (not enough threads decrease it) the waiting threads will be blocked forever. </span><span class="koboSpan" id="kobo.4654.5">In the following example, four threads are creating data (stored in a vector of integers) and the main thread waits for the completion of them all by utilizing a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4655.1">std::latch</span></code><span class="koboSpan" id="kobo.4656.1">, decremented by each thread after completing its work:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.4657.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4658.1">const</span></span><span class="koboSpan" id="kobo.4659.1"> jobs = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4660.1">4</span></span><span class="koboSpan" id="kobo.4661.1">;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.4662.1">std::latch </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4663.1">work_done</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4664.1">(jobs)</span></span><span class="koboSpan" id="kobo.4665.1">;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.4666.1">std::vector&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4667.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4668.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4669.1">data</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4670.1">(jobs)</span></span><span class="koboSpan" id="kobo.4671.1">;
std::vector&lt;std::jthread&gt; threads;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4672.1">for</span></span><span class="koboSpan" id="kobo.4673.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.4674.1">int</span></span><span class="koboSpan" id="kobo.4675.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4676.1">1</span></span><span class="koboSpan" id="kobo.4677.1">; i &lt;= jobs; ++i)
{   
   threads.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4678.1">push_back</span></span><span class="koboSpan" id="kobo.4679.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4680.1">jthread</span></span><span class="koboSpan" id="kobo.4681.1">([&amp;data, i, &amp;work_done]{
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4682.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4683.1">namespace</span></span><span class="koboSpan" id="kobo.4684.1"> std::chrono_literals;
      std::this_thread::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4685.1">sleep_for</span></span><span class="koboSpan" id="kobo.4686.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4687.1">1</span></span><span class="koboSpan" id="kobo.4688.1">s); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4689.1">// simulate work</span></span><span class="koboSpan" id="kobo.4690.1">
      data[i-1] = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4691.1">create</span></span><span class="koboSpan" id="kobo.4692.1">(i, 1);        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4693.1">// create data</span></span><span class="koboSpan" id="kobo.4694.1">
      
      work_done.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4695.1">count_down</span></span><span class="koboSpan" id="kobo.4696.1">();          </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4697.1">// decrement counter</span></span><span class="koboSpan" id="kobo.4698.1">
   }));   
}
work_done.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4699.1">wait</span></span><span class="koboSpan" id="kobo.4700.1">();             </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4701.1">// wait for all jobs to finish</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.4702.1">process</span></span><span class="koboSpan" id="kobo.4703.1">(data);                </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4704.1">// process data from all jobs</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4705.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4706.1">std::barrier</span></code><span class="koboSpan" id="kobo.4707.1"> when you need to perform loop synchronization between parallel tasks. </span><span class="koboSpan" id="kobo.4707.2">You construct a barrier with a count and, optionally, a completion function. </span><span class="koboSpan" id="kobo.4707.3">Threads arrive at the barrier, decrease the internal counter, and block. </span><span class="koboSpan" id="kobo.4707.4">When the counter reaches zero, the completion function is invoked, all blocked threads are awakened, and a new cycle begins. </span><span class="koboSpan" id="kobo.4707.5">In the following example, four threads are creating data that they store in a vector of integers. </span><span class="koboSpan" id="kobo.4707.6">When all the threads have completed a cycle, the data is processed in the main thread, by a completion function. </span><span class="koboSpan" id="kobo.4707.7">Each thread blocks after completing a cycle until they are awakened through the use of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4708.1">std::barrier</span></code><span class="koboSpan" id="kobo.4709.1"> object, which also stores the completion function. </span><span class="koboSpan" id="kobo.4709.2">This </span><a id="_idIndexMarker1086"/><span class="koboSpan" id="kobo.4710.1">process is repeated 10 times:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.4711.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4712.1">const</span></span><span class="koboSpan" id="kobo.4713.1"> jobs = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4714.1">4</span></span><span class="koboSpan" id="kobo.4715.1">;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.4716.1">std::vector&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4717.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4718.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4719.1">data</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4720.1">(jobs)</span></span><span class="koboSpan" id="kobo.4721.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.4722.1">int</span></span><span class="koboSpan" id="kobo.4723.1"> cycle = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4724.1">1</span></span><span class="koboSpan" id="kobo.4725.1">;
std::stop_source st;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4726.1">// completion function</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.4727.1">auto</span></span><span class="koboSpan" id="kobo.4728.1"> on_completion = [&amp;data, &amp;cycle, &amp;st]() </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4729.1">noexcept</span></span><span class="koboSpan" id="kobo.4730.1"> {
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4731.1">process</span></span><span class="koboSpan" id="kobo.4732.1">(data);          </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4733.1">// process data from all jobs</span></span><span class="koboSpan" id="kobo.4734.1">
   cycle++;
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4735.1">if</span></span><span class="koboSpan" id="kobo.4736.1"> (cycle == </span><span class="hljs-number"><span class="koboSpan" id="kobo.4737.1">10</span></span><span class="koboSpan" id="kobo.4738.1">)        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4739.1">// stop after ten cycles</span></span><span class="koboSpan" id="kobo.4740.1">
      st.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4741.1">request_stop</span></span><span class="koboSpan" id="kobo.4742.1">();
   };
</span><span class="hljs-function"><span class="koboSpan" id="kobo.4743.1">std::barrier </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4744.1">work_done</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4745.1">(jobs, on_completion)</span></span><span class="koboSpan" id="kobo.4746.1">;
std::vector&lt;std::jthread&gt; threads;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4747.1">for</span></span><span class="koboSpan" id="kobo.4748.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.4749.1">int</span></span><span class="koboSpan" id="kobo.4750.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4751.1">1</span></span><span class="koboSpan" id="kobo.4752.1">; i &lt;= jobs; ++i)
{
   threads.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4753.1">push_back</span></span><span class="koboSpan" id="kobo.4754.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4755.1">jthread</span></span><span class="koboSpan" id="kobo.4756.1">(
      [&amp;data, &amp;cycle, &amp;work_done](std::stop_token st, 
                                  </span><span class="hljs-type"><span class="koboSpan" id="kobo.4757.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4758.1">const</span></span><span class="koboSpan" id="kobo.4759.1"> i)
      {
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4760.1">while</span></span><span class="koboSpan" id="kobo.4761.1"> (!st.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4762.1">stop_requested</span></span><span class="koboSpan" id="kobo.4763.1">())
         {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4764.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4765.1">namespace</span></span><span class="koboSpan" id="kobo.4766.1"> std::chrono_literals;
            </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4767.1">// simulate work</span></span><span class="koboSpan" id="kobo.4768.1">
            std::this_thread::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4769.1">sleep_for</span></span><span class="koboSpan" id="kobo.4770.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4771.1">200</span></span><span class="koboSpan" id="kobo.4772.1">ms); 
            data[i</span><span class="hljs-number"><span class="koboSpan" id="kobo.4773.1">-1</span></span><span class="koboSpan" id="kobo.4774.1">] = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4775.1">create</span></span><span class="koboSpan" id="kobo.4776.1">(i, cycle); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4777.1">// create data </span></span><span class="koboSpan" id="kobo.4778.1">
            work_done.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4779.1">arrive_and_wait</span></span><span class="koboSpan" id="kobo.4780.1">();  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4781.1">// decrement counter</span></span><span class="koboSpan" id="kobo.4782.1">
         }
      },
      st.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4783.1">get_token</span></span><span class="koboSpan" id="kobo.4784.1">(),
      i));
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4785.1">for</span></span><span class="koboSpan" id="kobo.4786.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4787.1">auto</span></span><span class="koboSpan" id="kobo.4788.1">&amp; t : threads) t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4789.1">join</span></span><span class="koboSpan" id="kobo.4790.1">();
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4791.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4792.1">std::counting_semaphore&lt;N&gt;</span></code><span class="koboSpan" id="kobo.4793.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.4794.1">std::binary_semaphore</span></code><span class="koboSpan" id="kobo.4795.1"> when you want to restrict a number of </span><em class="italic"><span class="koboSpan" id="kobo.4796.1">N</span></em><span class="koboSpan" id="kobo.4797.1"> threads (a single thread, in the case of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4798.1">binary_semaphore</span></code><span class="koboSpan" id="kobo.4799.1">) to access a shared resource, or when you want to pass notifications between different threads. </span><span class="koboSpan" id="kobo.4799.2">In the following example, four threads </span><a id="_idIndexMarker1087"/><span class="koboSpan" id="kobo.4800.1">are creating data that is added to the end of a vector of integers. </span><span class="koboSpan" id="kobo.4800.2">To avoid race conditions, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4801.1">binary_semaphore</span></code><span class="koboSpan" id="kobo.4802.1"> object is used to restrict the access to the vector to a single thread:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.4803.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4804.1">const</span></span><span class="koboSpan" id="kobo.4805.1"> jobs = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4806.1">4</span></span><span class="koboSpan" id="kobo.4807.1">;
std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4808.1">int</span></span><span class="koboSpan" id="kobo.4809.1">&gt; data;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.4810.1">std::binary_semaphore </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4811.1">sem</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4812.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4813.1">1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4814.1">)</span></span><span class="koboSpan" id="kobo.4815.1">;
std::vector&lt;std::jthread&gt; threads;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4816.1">for</span></span><span class="koboSpan" id="kobo.4817.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.4818.1">int</span></span><span class="koboSpan" id="kobo.4819.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4820.1">1</span></span><span class="koboSpan" id="kobo.4821.1">; i &lt;= jobs; ++i)
{
   threads.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4822.1">push_back</span></span><span class="koboSpan" id="kobo.4823.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4824.1">jthread</span></span><span class="koboSpan" id="kobo.4825.1">([&amp;data, i, &amp;sem] {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4826.1">for</span></span><span class="koboSpan" id="kobo.4827.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.4828.1">int</span></span><span class="koboSpan" id="kobo.4829.1"> k = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4830.1">1</span></span><span class="koboSpan" id="kobo.4831.1">; k &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.4832.1">5</span></span><span class="koboSpan" id="kobo.4833.1">; ++k)
      {
         </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4834.1">// simulate work</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.4835.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4836.1">namespace</span></span><span class="koboSpan" id="kobo.4837.1"> std::chrono_literals;
         std::this_thread::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4838.1">sleep_for</span></span><span class="koboSpan" id="kobo.4839.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4840.1">200</span></span><span class="koboSpan" id="kobo.4841.1">ms);
         </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4842.1">// create data</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.4843.1">int</span></span><span class="koboSpan" id="kobo.4844.1"> value = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4845.1">create</span></span><span class="koboSpan" id="kobo.4846.1">(i, k);
         </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4847.1">// acquire the semaphore</span></span><span class="koboSpan" id="kobo.4848.1">
         sem.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4849.1">acquire</span></span><span class="koboSpan" id="kobo.4850.1">();
         </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4851.1">// write to the shared resource</span></span><span class="koboSpan" id="kobo.4852.1">
         data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4853.1">push_back</span></span><span class="koboSpan" id="kobo.4854.1">(value);
         </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4855.1">// release the semaphore</span></span><span class="koboSpan" id="kobo.4856.1">
         sem.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4857.1">release</span></span><span class="koboSpan" id="kobo.4858.1">();
      }
   }));
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4859.1">for</span></span><span class="koboSpan" id="kobo.4860.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4861.1">auto</span></span><span class="koboSpan" id="kobo.4862.1">&amp; t : threads) t.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4863.1">join</span></span><span class="koboSpan" id="kobo.4864.1">();
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4865.1">process</span></span><span class="koboSpan" id="kobo.4866.1">(data); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4867.1">// process data from all jobs</span></span>
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-560"><span class="koboSpan" id="kobo.4868.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4869.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.4870.1">std::latch</span></code><span class="koboSpan" id="kobo.4871.1"> class implements a counter that can be used to synchronize threads. </span><span class="koboSpan" id="kobo.4871.2">It is a race-free class </span><a id="_idIndexMarker1088"/><span class="koboSpan" id="kobo.4872.1">that works as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4873.1">The counter is initialized when the latch is created and can only be decreased.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4874.1">A thread may decrease the value of the latch and can do so multiple times.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4875.1">A thread may block by waiting until the latch counter reaches zero.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4876.1">When the counter reaches zero, the latch becomes permanently signaled and all the threads that are blocked on the latch are awakened.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.4877.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.4878.1">std::latch</span></code><span class="koboSpan" id="kobo.4879.1"> class has the</span><a id="_idIndexMarker1089"/><span class="koboSpan" id="kobo.4880.1"> following methods:</span></p>
<table class="table-container" id="table004-3">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.4881.1">Methods</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.4882.1">Descriptions</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4883.1">count_down()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4884.1">Decrements the internal counter by </span><em class="italic"><span class="koboSpan" id="kobo.4885.1">N</span></em><span class="koboSpan" id="kobo.4886.1"> (which is </span><code class="inlineCode"><span class="koboSpan" id="kobo.4887.1">1</span></code><span class="koboSpan" id="kobo.4888.1"> by default) without blocking the caller. </span><span class="koboSpan" id="kobo.4888.2">This operation is performed atomically. </span><em class="italic"><span class="koboSpan" id="kobo.4889.1">N</span></em><span class="koboSpan" id="kobo.4890.1"> must be a positive value no greater than the value of the internal counter; otherwise, the behavior is undefined.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4891.1">try_wait()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4892.1">Indicates whether the internal counter reaches zero, in which case it returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.4893.1">true</span></code><span class="koboSpan" id="kobo.4894.1">. </span><span class="koboSpan" id="kobo.4894.2">There is a very low probability that, although the counter has reached zero, the function may still return </span><code class="inlineCode"><span class="koboSpan" id="kobo.4895.1">false</span></code><span class="koboSpan" id="kobo.4896.1">.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4897.1">wait()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4898.1">Blocks the calling thread until the internal counter reaches zero. </span><span class="koboSpan" id="kobo.4898.2">If the internal counter is already zero, the function returns immediately without blocking.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4899.1">arrive_and_wait()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4900.1">This function is equivalent to calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.4901.1">count_down()</span></code><span class="koboSpan" id="kobo.4902.1">, followed by </span><code class="inlineCode"><span class="koboSpan" id="kobo.4903.1">wait()</span></code><span class="koboSpan" id="kobo.4904.1">. </span><span class="koboSpan" id="kobo.4904.2">It decrements the internal counter with </span><em class="italic"><span class="koboSpan" id="kobo.4905.1">N</span></em><span class="koboSpan" id="kobo.4906.1"> (which is </span><code class="inlineCode"><span class="koboSpan" id="kobo.4907.1">1</span></code><span class="koboSpan" id="kobo.4908.1"> by default) and then blocks the calling thread until the internal counter reaches zero.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.4909.1">Table 8.3: std::memory_order members that describe how memory access is ordered for an atomic operation</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4910.1">In the first example in the previous section, we have a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4911.1">std::latch</span></code><span class="koboSpan" id="kobo.4912.1">, called </span><code class="inlineCode"><span class="koboSpan" id="kobo.4913.1">work_done</span></code><span class="koboSpan" id="kobo.4914.1">, initialized with the number of threads (or jobs) that perform work. </span><span class="koboSpan" id="kobo.4914.2">Each thread produces data that is then written in a shared resource, a vector of integers. </span><span class="koboSpan" id="kobo.4914.3">Although this is shared, there is no race condition because each thread writes to a different place; therefore, there is no need for a synchronization mechanism. </span><span class="koboSpan" id="kobo.4914.4">After completing its work, each thread decrements the counter of the latch. </span><span class="koboSpan" id="kobo.4914.5">The main thread waits until the counter of the latch reaches zero, after which it processes the data from the threads.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4915.1">Because </span><a id="_idIndexMarker1090"/><span class="koboSpan" id="kobo.4916.1">the internal counter of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4917.1">std::latch</span></code><span class="koboSpan" id="kobo.4918.1"> cannot be incremented or reset, this synchronization mechanism can be used only once. </span><span class="koboSpan" id="kobo.4918.2">A similar but reusable synchronization mechanism is </span><code class="inlineCode"><span class="koboSpan" id="kobo.4919.1">std::barrier</span></code><span class="koboSpan" id="kobo.4920.1">. </span><span class="koboSpan" id="kobo.4920.2">A barrier </span><a id="_idIndexMarker1091"/><span class="koboSpan" id="kobo.4921.1">allows threads to block until an operation is completed and is useful for managing repeated tasks performed by multiple threads.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4922.1">A barrier works as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4923.1">A barrier contains a counter that is initialized during its creation and can be decreased by threads arriving at the barrier. </span><span class="koboSpan" id="kobo.4923.2">When the counter reaches zero, it is reset to its initial value and the barrier can be reused.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4924.1">A barrier also contains a completion function that is called when the counter reaches zero. </span><span class="koboSpan" id="kobo.4924.2">If a default completion function is used, it is invoked as part of the call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.4925.1">arrive_and_wait()</span></code><span class="koboSpan" id="kobo.4926.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.4927.1">arrive_and_drop()</span></code><span class="koboSpan" id="kobo.4928.1">. </span><span class="koboSpan" id="kobo.4928.2">Otherwise, the completion function is invoked on one of the threads that participate in the completion phase.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4929.1">The process through</span><a id="_idIndexMarker1092"/><span class="koboSpan" id="kobo.4930.1"> which a barrier goes from start to reset is called the </span><strong class="keyWord"><span class="koboSpan" id="kobo.4931.1">completion phase</span></strong><span class="koboSpan" id="kobo.4932.1">. </span><span class="koboSpan" id="kobo.4932.2">This </span><a id="_idIndexMarker1093"/><span class="koboSpan" id="kobo.4933.1">starts with a </span><a id="_idIndexMarker1094"/><span class="koboSpan" id="kobo.4934.1">so-called </span><strong class="keyWord"><span class="koboSpan" id="kobo.4935.1">synchronization point</span></strong><span class="koboSpan" id="kobo.4936.1"> and ends with the </span><strong class="keyWord"><span class="koboSpan" id="kobo.4937.1">completion step</span></strong><span class="koboSpan" id="kobo.4938.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4939.1">The first </span><em class="italic"><span class="koboSpan" id="kobo.4940.1">N</span></em><span class="koboSpan" id="kobo.4941.1"> threads that arrive at the synchronization point after the construction of the barrier are said to be</span><a id="_idIndexMarker1095"/><span class="koboSpan" id="kobo.4942.1"> the </span><strong class="keyWord"><span class="koboSpan" id="kobo.4943.1">set of participating threads</span></strong><span class="koboSpan" id="kobo.4944.1">. </span><span class="koboSpan" id="kobo.4944.2">Only these threads are allowed to arrive at the barrier during each of the following cycles.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4945.1">A thread that arrives at the synchronization point may decide to participate in the completion phase by calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.4946.1">arrive_and_wait()</span></code><span class="koboSpan" id="kobo.4947.1">. </span><span class="koboSpan" id="kobo.4947.2">However, a thread may remove itself from the participation set by calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.4948.1">arrive_and_drop()</span></code><span class="koboSpan" id="kobo.4949.1">. </span><span class="koboSpan" id="kobo.4949.2">In this case, another thread must take its place in the participation set.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4950.1">When all the threads in the participation set have arrived at the synchronization point, the completion phase is executed. </span><span class="koboSpan" id="kobo.4950.2">There are three steps that occur: first, the completion function is invoked. </span><span class="koboSpan" id="kobo.4950.3">Second, all the threads that are blocked are awakened. </span><span class="koboSpan" id="kobo.4950.4">Third, and last, the barrier count is reset and a new cycle begins.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.4951.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.4952.1">std::barrier</span></code><span class="koboSpan" id="kobo.4953.1"> class</span><a id="_idIndexMarker1096"/><span class="koboSpan" id="kobo.4954.1"> has the following methods:</span></p>
<table class="table-container" id="table005-2">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.4955.1">Methods</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.4956.1">Descriptions</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4957.1">arrive()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4958.1">Arrives at the barrier’s synchronization point and decrements the expected count by a value n. </span><span class="koboSpan" id="kobo.4958.2">The behavior is undefined if the value of n is greater than the expected count, or equal to or less than zero. </span><span class="koboSpan" id="kobo.4958.3">The function executes atomically.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4959.1">wait()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4960.1">Blocks at the synchronization point until the completion step is executed.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4961.1">arrive_and_wait()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4962.1">Arrives at the barrier’s synchronization point and blocks. </span><span class="koboSpan" id="kobo.4962.2">The calling thread must be in the participating set; otherwise, the behavior is undefined. </span><span class="koboSpan" id="kobo.4962.3">This function only returns after the completion phase ends.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.4963.1">arrive_and_drop()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.4964.1">Arrives at the barrier’s synchronization point and removes the thread from the participation set. </span><span class="koboSpan" id="kobo.4964.2">It is an implementation detail whether the function blocks or not until the end of the completion phase. </span><span class="koboSpan" id="kobo.4964.3">The calling thread must be in the participation set; otherwise, the behavior is undefined.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.4965.1">Table 8.4: The member functions of the std::barrier class</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4966.1">We saw an</span><a id="_idIndexMarker1097"/><span class="koboSpan" id="kobo.4967.1"> example with </span><code class="inlineCode"><span class="koboSpan" id="kobo.4968.1">std::barrier</span></code><span class="koboSpan" id="kobo.4969.1"> in the second snippet from the </span><em class="italic"><span class="koboSpan" id="kobo.4970.1">How to do it...</span></em><span class="koboSpan" id="kobo.4971.1"> section. </span><span class="koboSpan" id="kobo.4971.2">In this example, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4972.1">std::barrier</span></code><span class="koboSpan" id="kobo.4973.1"> is created and initialized with a counter, which represents the number of threads, and a completion function. </span><span class="koboSpan" id="kobo.4973.2">This function processes the data produced by all the threads, then increments a loop counter, and requests threads to stop after 10 loops. </span><span class="koboSpan" id="kobo.4973.3">This basically means that the barrier will perform 10 cycles before the threads will finish their work. </span><span class="koboSpan" id="kobo.4973.4">Each thread loops until a stop is requested, and, in each iteration, they produce some data, written to the shared vector of integers. </span><span class="koboSpan" id="kobo.4973.5">At the end of the loop, each thread arrives at the barrier synchronization point, decrements the counter, and waits for it to reach zero and the completion function to execute. </span><span class="koboSpan" id="kobo.4973.6">This is done with a call to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4974.1">arrive_and_wait()</span></code><span class="koboSpan" id="kobo.4975.1"> method of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4976.1">std::barrier</span></code><span class="koboSpan" id="kobo.4977.1"> class.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4978.1">The last synchronization mechanism available in the thread support library in C++20 is represented by semaphores. </span><span class="koboSpan" id="kobo.4978.2">A semaphore contains an internal counter that can be both decreased and increased by multiple threads. </span><span class="koboSpan" id="kobo.4978.3">When the counter reaches zero, further attempts to decrease it will block the thread, until another thread increases the counter.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4979.1">There are two</span><a id="_idIndexMarker1098"/><span class="koboSpan" id="kobo.4980.1"> semaphore classes: </span><code class="inlineCode"><span class="koboSpan" id="kobo.4981.1">std::counting_semaphore&lt;N&gt;</span></code><span class="koboSpan" id="kobo.4982.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4983.1">std::binary_semaphore</span></code><span class="koboSpan" id="kobo.4984.1">. </span><span class="koboSpan" id="kobo.4984.2">The latter is actually just an alias for </span><code class="inlineCode"><span class="koboSpan" id="kobo.4985.1">std::counting_semaphore&lt;1&gt;</span></code><span class="koboSpan" id="kobo.4986.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4987.1">A </span><code class="inlineCode"><span class="koboSpan" id="kobo.4988.1">counting_semaphore</span></code><span class="koboSpan" id="kobo.4989.1"> allows </span><a id="_idIndexMarker1099"/><em class="italic"><span class="koboSpan" id="kobo.4990.1">N</span></em><span class="koboSpan" id="kobo.4991.1"> threads to access a shared resource, unlike a mutex, which only allows one. </span><code class="inlineCode"><span class="koboSpan" id="kobo.4992.1">binary_semaphore</span></code><span class="koboSpan" id="kobo.4993.1">, is, in this matter, similar to the mutex, because only one thread can access the shared resource. </span><span class="koboSpan" id="kobo.4993.2">On the other hand, a mutex is bound to a thread: the thread that locked the mutex must unlock it. </span><span class="koboSpan" id="kobo.4993.3">However, this is not the case for semaphores. </span><span class="koboSpan" id="kobo.4993.4">A semaphore can be released by threads that did not acquire it, and a </span><a id="_idIndexMarker1100"/><span class="koboSpan" id="kobo.4994.1">thread that acquired a semaphore does not have to also release it.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4995.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.4996.1">std::counting_semaphore</span></code><span class="koboSpan" id="kobo.4997.1"> class</span><a id="_idIndexMarker1101"/><span class="koboSpan" id="kobo.4998.1"> has the following methods:</span></p>
<table class="table-container" id="table006-2">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.4999.1">Methods</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.5000.1">Descriptions</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5001.1">acquire()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.5002.1">Decrements the internal counter by 1 if it is greater than 0. </span><span class="koboSpan" id="kobo.5002.2">Otherwise, it blocks until the counter becomes greater than 0.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5003.1">try_acquire()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.5004.1">Tries to decrement the counter by 1 if it is greater than 0. </span><span class="koboSpan" id="kobo.5004.2">It returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.5005.1">true</span></code><span class="koboSpan" id="kobo.5006.1"> if it succeeds, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.5007.1">false</span></code><span class="koboSpan" id="kobo.5008.1"> otherwise. </span><span class="koboSpan" id="kobo.5008.2">This method does not block.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5009.1">try_acquire_for()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.5010.1">Tries to decrease the counter by 1 if it is greater than 0. </span><span class="koboSpan" id="kobo.5010.2">Otherwise, it blocks either until the counter becomes greater than 0 or a specified timeout occurs. </span><span class="koboSpan" id="kobo.5010.3">The function returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.5011.1">true</span></code><span class="koboSpan" id="kobo.5012.1"> if it succeeds in decreasing the counter.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5013.1">try_acquire_until()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.5014.1">Tries to decrease the counter by 1 if it is greater than 0. </span><span class="koboSpan" id="kobo.5014.2">Otherwise, it blocks either until the counter becomes greater than 0 or a specified time point has been passed. </span><span class="koboSpan" id="kobo.5014.3">The function returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.5015.1">true</span></code><span class="koboSpan" id="kobo.5016.1"> if it succeeds in decreasing the counter.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5017.1">release()</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.5018.1">Increments the internal counter by the specified value (which is 1 by default). </span><span class="koboSpan" id="kobo.5018.2">Any thread that was blocked waiting for the counter to become greater than 0 is awakened.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.5019.1">Table 8.5: The member functions of the std::counting_semaphore class</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5020.1">All the increment and decrement operations performed on the counter by the methods listed here are executed atomically.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5021.1">The last example in the </span><em class="italic"><span class="koboSpan" id="kobo.5022.1">How to do it...</span></em><span class="koboSpan" id="kobo.5023.1"> section shows how a </span><code class="inlineCode"><span class="koboSpan" id="kobo.5024.1">binary_semaphore</span></code><span class="koboSpan" id="kobo.5025.1"> can be used. </span><span class="koboSpan" id="kobo.5025.2">A number of threads (four, in this example) produce work in a loop and write to a shared resource. </span><span class="koboSpan" id="kobo.5025.3">Unlike the previous examples, they simply add to the end of a vector of integers. </span><span class="koboSpan" id="kobo.5025.4">Therefore, the access to this vector must be synchronized between the threads, and this is where the binary semaphore is used. </span><span class="koboSpan" id="kobo.5025.5">In each loop, the thread function creates a new value (which may take some time). </span><span class="koboSpan" id="kobo.5025.6">This value is then appended to the end of the vector. </span><span class="koboSpan" id="kobo.5025.7">However, the thread must call the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5026.1">acquire()</span></code><span class="koboSpan" id="kobo.5027.1"> method of the semaphore </span><a id="_idIndexMarker1102"/><span class="koboSpan" id="kobo.5028.1">to make sure it is the only thread that can continue execution and access the shared resource. </span><span class="koboSpan" id="kobo.5028.2">After the write operation completes, the thread calls the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5029.1">release()</span></code><span class="koboSpan" id="kobo.5030.1"> method of the semaphore in order to increment the internal counter and allow another thread to access the shared resource.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5031.1">Semaphores can </span><a id="_idIndexMarker1103"/><span class="koboSpan" id="kobo.5032.1">be used for multiple purposes: to block access to shared resources (similar to mutexes), to signal or pass notifications between threads (similar to condition variables), or to implement barriers, often with better performance than similar mechanisms.</span></p>
<h2 class="heading-2" id="_idParaDest-561"><span class="koboSpan" id="kobo.5033.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.5034.1">Working with threads</span></em><span class="koboSpan" id="kobo.5035.1">, to learn about the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5036.1">std::thread</span></code><span class="koboSpan" id="kobo.5037.1"> class and the basic operations for working with threads in C++</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.5038.1">Synchronizing access to shared data with mutexes and locks</span></em><span class="koboSpan" id="kobo.5039.1">, to see what mechanisms are available for synchronizing thread access to shared data and how they work</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.5040.1">Sending notifications between threads</span></em><span class="koboSpan" id="kobo.5041.1">, to see how to use condition variables to send notifications between producer and consumer threads</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-562"><span class="koboSpan" id="kobo.5042.1">Synchronizing writing to output streams from multiple threads</span></h1>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.5043.1">std::cout</span></code><span class="koboSpan" id="kobo.5044.1"> is a</span><a id="_idIndexMarker1104"/><span class="koboSpan" id="kobo.5045.1"> global object of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5046.1">std::ostream</span></code><span class="koboSpan" id="kobo.5047.1"> type. </span><span class="koboSpan" id="kobo.5047.2">It is used to write text to the standard output console. </span><span class="koboSpan" id="kobo.5047.3">Although writing to it is guaranteed to be thread-safe, this applies to just one invocation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5048.1">operator&lt;&lt;</span></code><span class="koboSpan" id="kobo.5049.1">. </span><span class="koboSpan" id="kobo.5049.2">Multiple such sequenced calls to </span><code class="inlineCode"><span class="koboSpan" id="kobo.5050.1">operator&lt;&lt;</span></code><span class="koboSpan" id="kobo.5051.1"> can be interrupted and resumed later, making it necessary to employ synchronization mechanisms to avoid corrupted results. </span><span class="koboSpan" id="kobo.5051.2">This applies to all scenarios where multiple threads operate on the same output stream. </span><span class="koboSpan" id="kobo.5051.3">To simplify this scenario, C++20 introduced </span><code class="inlineCode"><span class="koboSpan" id="kobo.5052.1">std::basic_osyncstream</span></code><span class="koboSpan" id="kobo.5053.1"> to provide a mechanism to synchronize threads writing to the same output stream. </span><span class="koboSpan" id="kobo.5053.2">In this recipe, you will learn how to use this new utility.</span></p>
<h2 class="heading-2" id="_idParaDest-563"><span class="koboSpan" id="kobo.5054.1">How to do it…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5055.1">To</span><a id="_idIndexMarker1105"/><span class="koboSpan" id="kobo.5056.1"> synchronize access to an output stream for writing from multiple threads, do the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.5057.1">Include the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5058.1">&lt;syncstream&gt;</span></code><span class="koboSpan" id="kobo.5059.1"> header.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5060.1">Define a variable of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5061.1">std::osyncstream</span></code><span class="koboSpan" id="kobo.5062.1"> type to wrap the shared output stream, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.5063.1">std::cout</span></code><span class="koboSpan" id="kobo.5064.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.5065.1">Use the wrapper variable exclusively to write to the output stream.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.5066.1">The following snippet shows an example for this pattern:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.5067.1">std::vector&lt;std::jthread&gt; threads;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5068.1">for</span></span><span class="koboSpan" id="kobo.5069.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.5070.1">int</span></span><span class="koboSpan" id="kobo.5071.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.5072.1">1</span></span><span class="koboSpan" id="kobo.5073.1">; i &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.5074.1">10</span></span><span class="koboSpan" id="kobo.5075.1">; ++i)
{
   threads.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5076.1">push_back</span></span><span class="koboSpan" id="kobo.5077.1">(
      std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5078.1">jthread</span></span><span class="koboSpan" id="kobo.5079.1">([](</span><span class="hljs-type"><span class="koboSpan" id="kobo.5080.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5081.1">int</span></span><span class="koboSpan" id="kobo.5082.1"> id)
         {
            std::osyncstream scout{ std::cout };
            scout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5083.1">"thread "</span></span><span class="koboSpan" id="kobo.5084.1"> &lt;&lt; id &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5085.1">" running\n"</span></span><span class="koboSpan" id="kobo.5086.1">;
         }, i));
}
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-564"><span class="koboSpan" id="kobo.5087.1">How it works…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5088.1">By default, the standard C++ stream objects </span><code class="inlineCode"><span class="koboSpan" id="kobo.5089.1">std::cin</span></code><span class="koboSpan" id="kobo.5090.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.5091.1">std::wcin</span></code><span class="koboSpan" id="kobo.5092.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5093.1">std::cout</span></code><span class="koboSpan" id="kobo.5094.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.5095.1">std::wcout</span></code><span class="koboSpan" id="kobo.5096.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5097.1">std::cerr</span></code><span class="koboSpan" id="kobo.5098.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.5099.1">std::wcerr</span></code><span class="koboSpan" id="kobo.5100.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5101.1">std::clog</span></code><span class="koboSpan" id="kobo.5102.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.5103.1">std::wclog</span></code><span class="koboSpan" id="kobo.5104.1"> are synchronized with their respective C streams, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5105.1">stdin</span></code><span class="koboSpan" id="kobo.5106.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5107.1">stdout</span></code><span class="koboSpan" id="kobo.5108.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5109.1">stderr</span></code><span class="koboSpan" id="kobo.5110.1"> (unless a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.5111.1">std::ios_base::sync_with_stdio()</span></code><span class="koboSpan" id="kobo.5112.1"> disables this synchronization). </span><span class="koboSpan" id="kobo.5112.2">What this means is that any operation applied to a C++ stream object is immediately applied to the corresponding C stream. </span><span class="koboSpan" id="kobo.5112.3">Moreover, accessing these streams is guaranteed to be thread-safe. </span><span class="koboSpan" id="kobo.5112.4">This means that calls to </span><code class="inlineCode"><span class="koboSpan" id="kobo.5113.1">operator &lt;&lt;</span></code><span class="koboSpan" id="kobo.5114.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.5115.1">&gt;&gt;</span></code><span class="koboSpan" id="kobo.5116.1"> are atomic; another thread cannot access the stream until the call completes. </span><span class="koboSpan" id="kobo.5116.2">However, multiple calls can be interrupted, as shown in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.5117.1">std::vector&lt;std::jthread&gt; threads;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5118.1">for</span></span><span class="koboSpan" id="kobo.5119.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.5120.1">int</span></span><span class="koboSpan" id="kobo.5121.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.5122.1">1</span></span><span class="koboSpan" id="kobo.5123.1">; i &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.5124.1">10</span></span><span class="koboSpan" id="kobo.5125.1">; ++i)
{
   threads.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5126.1">push_back</span></span><span class="koboSpan" id="kobo.5127.1">(
      std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5128.1">jthread</span></span><span class="koboSpan" id="kobo.5129.1">([](</span><span class="hljs-type"><span class="koboSpan" id="kobo.5130.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5131.1">int</span></span><span class="koboSpan" id="kobo.5132.1"> id)
         {
            std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5133.1">"thread "</span></span><span class="koboSpan" id="kobo.5134.1"> &lt;&lt; id &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5135.1">" running\n"</span></span><span class="koboSpan" id="kobo.5136.1">;
         }, i));
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5137.1">The output</span><a id="_idIndexMarker1106"/><span class="koboSpan" id="kobo.5138.1"> differs on different executions, but it looks like the following:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.5139.1">thread thread thread 6 running
thread 2 running
1 running
thread 3 running
5 running
thread 4thread 7 running
thread 10 running
thread 9 running
 running
thread 8 running
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5140.1">There are three different invocations to </span><code class="inlineCode"><span class="koboSpan" id="kobo.5141.1">operator &lt;&lt;</span></code><span class="koboSpan" id="kobo.5142.1"> in the thread function. </span><span class="koboSpan" id="kobo.5142.2">Although each executes atomically, the thread can be suspended in between calls for another thread to get a chance to execute. </span><span class="koboSpan" id="kobo.5142.3">This is why we see the output having the shape shown earlier. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.5143.1">This can be solved in several ways. </span><span class="koboSpan" id="kobo.5143.2">One can use a synchronization mechanism, such as a mutex. </span><span class="koboSpan" id="kobo.5143.3">However, in this particular case, a simpler solution is to use a local </span><code class="inlineCode"><span class="koboSpan" id="kobo.5144.1">std::stringstream</span></code><span class="koboSpan" id="kobo.5145.1"> object to build the text to be displayed on the console and make a single invocation to </span><code class="inlineCode"><span class="koboSpan" id="kobo.5146.1">operator&lt;&lt;</span></code><span class="koboSpan" id="kobo.5147.1">, as shown next:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.5148.1">std::vector&lt;std::jthread&gt; threads;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5149.1">for</span></span><span class="koboSpan" id="kobo.5150.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.5151.1">int</span></span><span class="koboSpan" id="kobo.5152.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.5153.1">1</span></span><span class="koboSpan" id="kobo.5154.1">; i &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.5155.1">10</span></span><span class="koboSpan" id="kobo.5156.1">; ++i)
{
   threads.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5157.1">push_back</span></span><span class="koboSpan" id="kobo.5158.1">(
      std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5159.1">jthread</span></span><span class="koboSpan" id="kobo.5160.1">([](</span><span class="hljs-type"><span class="koboSpan" id="kobo.5161.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5162.1">int</span></span><span class="koboSpan" id="kobo.5163.1"> id)
         {
            std::stringstream ss;
            ss &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5164.1">"thread "</span></span><span class="koboSpan" id="kobo.5165.1"> &lt;&lt; id &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5166.1">" running\n"</span></span><span class="koboSpan" id="kobo.5167.1">;
            std::cout &lt;&lt; ss.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5168.1">str</span></span><span class="koboSpan" id="kobo.5169.1">();
         }, i));
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5170.1">With these changes, the output has the form that was expected:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.5171.1">thread 1 running
thread 2 running
thread 3 running
thread 4 running
thread 5 running
thread 6 running
thread 7 running
thread 8 running
thread 9 running
thread 10 running
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5172.1">In C++20, you can use a </span><code class="inlineCode"><span class="koboSpan" id="kobo.5173.1">std::osyncstream</span></code><span class="koboSpan" id="kobo.5174.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.5175.1">std::wosyncstream</span></code><span class="koboSpan" id="kobo.5176.1"> object to wrap an output stream to synchronize access, as shown in the </span><em class="italic"><span class="koboSpan" id="kobo.5177.1">How to do it…</span></em><span class="koboSpan" id="kobo.5178.1"> section. </span><span class="koboSpan" id="kobo.5178.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.5179.1">osyncstream</span></code><span class="koboSpan" id="kobo.5180.1"> class guarantees there are no data races if all the write operations from different threads occur through instances of this class. </span><span class="koboSpan" id="kobo.5180.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.5181.1">std::basic_osyncstream</span></code><span class="koboSpan" id="kobo.5182.1"> class wraps an instance of </span><code class="inlineCode"><span class="koboSpan" id="kobo.5183.1">std::basic_syncbuf</span></code><span class="koboSpan" id="kobo.5184.1">, which, in turn, wraps an output buffer but also </span><a id="_idIndexMarker1107"/><span class="koboSpan" id="kobo.5185.1">contains a separate internal buffer. </span><span class="koboSpan" id="kobo.5185.2">This class accumulates output in an internal buffer and transmits it to the wrapped buffer when the object is destructed or when an explicit call to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5186.1">emit()</span></code><span class="koboSpan" id="kobo.5187.1"> member function occurs.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5188.1">The sync stream wrappers can be used to synchronize access to any output stream, not just </span><code class="inlineCode"><span class="koboSpan" id="kobo.5189.1">std::ostream</span></code><span class="koboSpan" id="kobo.5190.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.5191.1">std::wostream</span></code><span class="koboSpan" id="kobo.5192.1"> (the type of </span><code class="inlineCode"><span class="koboSpan" id="kobo.5193.1">std::cout</span></code><span class="koboSpan" id="kobo.5194.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.5195.1">std::wcout</span></code><span class="koboSpan" id="kobo.5196.1">). </span><span class="koboSpan" id="kobo.5196.2">For instance, it can be used to synchronize access to a string stream, as shown in the following snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.5197.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5198.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5199.1">()</span></span><span class="koboSpan" id="kobo.5200.1">
{
   std::ostringstream str{ };
   {
      std::osyncstream syncstr{ str };
      syncstr &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5201.1">"sync stream demo"</span></span><span class="koboSpan" id="kobo.5202.1">;
      std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5203.1">"A:"</span></span><span class="koboSpan" id="kobo.5204.1"> &lt;&lt; str.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5205.1">str</span></span><span class="koboSpan" id="kobo.5206.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5207.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.5208.1">\n'</span></span><span class="koboSpan" id="kobo.5209.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5210.1">// [1]</span></span><span class="koboSpan" id="kobo.5211.1">
   }
   std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5212.1">"B:"</span></span><span class="koboSpan" id="kobo.5213.1"> &lt;&lt; str.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5214.1">str</span></span><span class="koboSpan" id="kobo.5215.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5216.1">'\n'</span></span><span class="koboSpan" id="kobo.5217.1">;    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5218.1">// [2]</span></span><span class="koboSpan" id="kobo.5219.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5220.1">In this example, we define a </span><code class="inlineCode"><span class="koboSpan" id="kobo.5221.1">std::ostringstream</span></code><span class="koboSpan" id="kobo.5222.1"> object called </span><code class="inlineCode"><span class="koboSpan" id="kobo.5223.1">str</span></code><span class="koboSpan" id="kobo.5224.1">. </span><span class="koboSpan" id="kobo.5224.2">In the inner block, this is wrapped by a </span><code class="inlineCode"><span class="koboSpan" id="kobo.5225.1">std::osyncstream</span></code><span class="koboSpan" id="kobo.5226.1"> object and then we write the text </span><code class="inlineCode"><span class="koboSpan" id="kobo.5227.1">"sync stream demo"</span></code><span class="koboSpan" id="kobo.5228.1"> through this wrapper to the string stream. </span><span class="koboSpan" id="kobo.5228.2">On the line marked with </span><strong class="keyWord"><span class="koboSpan" id="kobo.5229.1">[1]</span></strong><span class="koboSpan" id="kobo.5230.1">, we print the content of the string stream to the console. </span><span class="koboSpan" id="kobo.5230.2">However, the content of the stream’s buffer is empty because the sync stream has not been destroyed, nor has a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.5231.1">emit()</span></code><span class="koboSpan" id="kobo.5232.1"> occurred. </span><span class="koboSpan" id="kobo.5232.2">When the sync stream goes out of scope, the content of its inner buffer is </span><a id="_idIndexMarker1108"/><span class="koboSpan" id="kobo.5233.1">transferred to the wrapped stream. </span><span class="koboSpan" id="kobo.5233.2">Therefore, on the line marked with </span><strong class="keyWord"><span class="koboSpan" id="kobo.5234.1">[2]</span></strong><span class="koboSpan" id="kobo.5235.1">, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5236.1">str</span></code><span class="koboSpan" id="kobo.5237.1"> string stream contains the text </span><code class="inlineCode"><span class="koboSpan" id="kobo.5238.1">"sync stream demo"</span></code><span class="koboSpan" id="kobo.5239.1">. </span><span class="koboSpan" id="kobo.5239.2">This results in the following output for the program:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.5240.1">A:
B:sync stream demo
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5241.1">We can elaborate on this example to show how the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5242.1">emit()</span></code><span class="koboSpan" id="kobo.5243.1"> member function affects the behavior of the streams. </span><span class="koboSpan" id="kobo.5243.2">Let’s consider the following snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.5244.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5245.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5246.1">()</span></span><span class="koboSpan" id="kobo.5247.1">
{
   std::ostringstream str{ };
   {
      std::osyncstream syncstr{ str };
      syncstr &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5248.1">"sync stream demo"</span></span><span class="koboSpan" id="kobo.5249.1">;
      std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5250.1">"A:"</span></span><span class="koboSpan" id="kobo.5251.1"> &lt;&lt; str.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5252.1">str</span></span><span class="koboSpan" id="kobo.5253.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5254.1">'\n'</span></span><span class="koboSpan" id="kobo.5255.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5256.1">// [1]</span></span><span class="koboSpan" id="kobo.5257.1">
      syncstr.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5258.1">emit</span></span><span class="koboSpan" id="kobo.5259.1">();
      std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5260.1">"B:"</span></span><span class="koboSpan" id="kobo.5261.1"> &lt;&lt; str.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5262.1">str</span></span><span class="koboSpan" id="kobo.5263.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5264.1">'\n'</span></span><span class="koboSpan" id="kobo.5265.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5266.1">// [2]</span></span><span class="koboSpan" id="kobo.5267.1">
      syncstr &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5268.1">"demo part 2"</span></span><span class="koboSpan" id="kobo.5269.1">;
      std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5270.1">"C:"</span></span><span class="koboSpan" id="kobo.5271.1"> &lt;&lt; str.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5272.1">str</span></span><span class="koboSpan" id="kobo.5273.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5274.1">'\n'</span></span><span class="koboSpan" id="kobo.5275.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5276.1">// [3]</span></span><span class="koboSpan" id="kobo.5277.1">
   }
   std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5278.1">"D:"</span></span><span class="koboSpan" id="kobo.5279.1"> &lt;&lt; str.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5280.1">str</span></span><span class="koboSpan" id="kobo.5281.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5282.1">'\n'</span></span><span class="koboSpan" id="kobo.5283.1">;    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5284.1">// [4]</span></span><span class="koboSpan" id="kobo.5285.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5286.1">The first part of this second example is the same. </span><span class="koboSpan" id="kobo.5286.2">On line </span><strong class="keyWord"><span class="koboSpan" id="kobo.5287.1">[1]</span></strong><span class="koboSpan" id="kobo.5288.1">, the content of the string buffer is empty. </span><span class="koboSpan" id="kobo.5288.2">However, after the call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.5289.1">emit()</span></code><span class="koboSpan" id="kobo.5290.1">, the sync stream transfers the content of its inner buffer to the wrapped output stream. </span><span class="koboSpan" id="kobo.5290.2">Therefore, on line </span><strong class="keyWord"><span class="koboSpan" id="kobo.5291.1">[2]</span></strong><span class="koboSpan" id="kobo.5292.1">, the string buffer contains the text </span><code class="inlineCode"><span class="koboSpan" id="kobo.5293.1">"sync stream demo"</span></code><span class="koboSpan" id="kobo.5294.1">. </span><span class="koboSpan" id="kobo.5294.2">New text, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5295.1">"demo part 2"</span></code><span class="koboSpan" id="kobo.5296.1">, is written to the string stream through the sync stream, but this is not transferred to the string stream before the line marked with </span><strong class="keyWord"><span class="koboSpan" id="kobo.5297.1">[3]</span></strong><span class="koboSpan" id="kobo.5298.1"> executes; therefore, at this point the content of the string stream is unchanged. </span><span class="koboSpan" id="kobo.5298.2">Upon going out of scope at the end of the inner block, the new content of the sync stream’s inner buffer is again transferred to the wrapped string stream, which will now contain the text </span><code class="inlineCode"><span class="koboSpan" id="kobo.5299.1">"sync stream demodemo part 2"</span></code><span class="koboSpan" id="kobo.5300.1">. </span><span class="koboSpan" id="kobo.5300.2">As a result, the output of this second example is the following:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.5301.1">A:
B:sync stream demo
C:sync stream demo
D:sync stream demodemo part 2
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5302.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.5303.1">std::basic_syncstream</span></code><span class="koboSpan" id="kobo.5304.1"> class has a member function called </span><code class="inlineCode"><span class="koboSpan" id="kobo.5305.1">get_wrapped()</span></code><span class="koboSpan" id="kobo.5306.1">, which returns a </span><a id="_idIndexMarker1109"/><span class="koboSpan" id="kobo.5307.1">pointer to the wrapped stream buffer. </span><span class="koboSpan" id="kobo.5307.2">This can be used to construct a new instance of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5308.1">std::basic_syncstream</span></code><span class="koboSpan" id="kobo.5309.1"> class so that you can sequence content to the same output stream through different instances of </span><code class="inlineCode"><span class="koboSpan" id="kobo.5310.1">std::basic_osyncstream</span></code><span class="koboSpan" id="kobo.5311.1">. </span><span class="koboSpan" id="kobo.5311.2">The next snippet demonstrates how this works:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.5312.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5313.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5314.1">()</span></span><span class="koboSpan" id="kobo.5315.1">
{
   std::ostringstream str{ };
   {
      std::osyncstream syncstr{ str };
      syncstr &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5316.1">"sync stream demo"</span></span><span class="koboSpan" id="kobo.5317.1">;
      std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5318.1">"A:"</span></span><span class="koboSpan" id="kobo.5319.1"> &lt;&lt; str.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5320.1">str</span></span><span class="koboSpan" id="kobo.5321.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5322.1">'\n'</span></span><span class="koboSpan" id="kobo.5323.1">;    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5324.1">// [1]</span></span><span class="koboSpan" id="kobo.5325.1">
      {
         std::osyncstream syncstr2{ syncstr.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5326.1">get_wrapped</span></span><span class="koboSpan" id="kobo.5327.1">() };
         syncstr2 &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5328.1">"demo part 3"</span></span><span class="koboSpan" id="kobo.5329.1">;
         std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5330.1">"B:"</span></span><span class="koboSpan" id="kobo.5331.1"> &lt;&lt; str.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5332.1">str</span></span><span class="koboSpan" id="kobo.5333.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5334.1">'\n'</span></span><span class="koboSpan" id="kobo.5335.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5336.1">// [2]</span></span><span class="koboSpan" id="kobo.5337.1">
      }
      std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5338.1">"C:"</span></span><span class="koboSpan" id="kobo.5339.1"> &lt;&lt; str.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5340.1">str</span></span><span class="koboSpan" id="kobo.5341.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5342.1">'\n'</span></span><span class="koboSpan" id="kobo.5343.1">;    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5344.1">// [3]</span></span><span class="koboSpan" id="kobo.5345.1">
   }
   std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5346.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.5347.1">D:"</span></span><span class="koboSpan" id="kobo.5348.1"> &lt;&lt; str.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5349.1">str</span></span><span class="koboSpan" id="kobo.5350.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5351.1">'\n'</span></span><span class="koboSpan" id="kobo.5352.1">;       </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5353.1">// [4]</span></span><span class="koboSpan" id="kobo.5354.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5355.1">Again, the first part of the example is unchanged. </span><span class="koboSpan" id="kobo.5355.2">However, here we have a second inner block where a second instance of </span><code class="inlineCode"><span class="koboSpan" id="kobo.5356.1">std::osyncstream</span></code><span class="koboSpan" id="kobo.5357.1"> is constructed with a pointer to the stream buffer returned by the call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.5358.1">syncstr</span></code><span class="koboSpan" id="kobo.5359.1">'s </span><code class="inlineCode"><span class="koboSpan" id="kobo.5360.1">get_wrapped()</span></code><span class="koboSpan" id="kobo.5361.1"> member function. </span><span class="koboSpan" id="kobo.5361.2">At the line marked with </span><strong class="keyWord"><span class="koboSpan" id="kobo.5362.1">[2]</span></strong><span class="koboSpan" id="kobo.5363.1">, none of the two instances of </span><code class="inlineCode"><span class="koboSpan" id="kobo.5364.1">std::osyncstream</span></code><span class="koboSpan" id="kobo.5365.1"> has been destroyed; therefore, the content of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5366.1">str</span></code><span class="koboSpan" id="kobo.5367.1"> string stream is still empty. </span><span class="koboSpan" id="kobo.5367.2">The first sync stream to be destroyed is </span><code class="inlineCode"><span class="koboSpan" id="kobo.5368.1">syncstr2</span></code><span class="koboSpan" id="kobo.5369.1">, at the end of the second inner block. </span><span class="koboSpan" id="kobo.5369.2">Therefore, on the line marked with </span><strong class="keyWord"><span class="koboSpan" id="kobo.5370.1">[3]</span></strong><span class="koboSpan" id="kobo.5371.1">, the content of the string stream will be </span><code class="inlineCode"><span class="koboSpan" id="kobo.5372.1">"demo part 3"</span></code><span class="koboSpan" id="kobo.5373.1">. </span><span class="koboSpan" id="kobo.5373.2">Then, the first sync stream object, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5374.1">syncstr</span></code><span class="koboSpan" id="kobo.5375.1">, goes out of scope at the end of the first inner block, adding the text </span><code class="inlineCode"><span class="koboSpan" id="kobo.5376.1">"sync stream demo"</span></code><span class="koboSpan" id="kobo.5377.1"> to the string stream. </span><span class="koboSpan" id="kobo.5377.2">The output of running this program is the following:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.5378.1">A:
B:
C:demo part 3
D:demo part 3sync stream demo
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5379.1">Although in </span><a id="_idIndexMarker1110"/><span class="koboSpan" id="kobo.5380.1">all these examples we defined named variables, you can write to an output stream using a temporary sync stream too, as shown below:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.5381.1">threads.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5382.1">push_back</span></span><span class="koboSpan" id="kobo.5383.1">(
   std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5384.1">jthread</span></span><span class="koboSpan" id="kobo.5385.1">([](</span><span class="hljs-type"><span class="koboSpan" id="kobo.5386.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5387.1">int</span></span><span class="koboSpan" id="kobo.5388.1"> id)
      {
         std::osyncstream{ std::cout } &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5389.1">"thread "</span></span><span class="koboSpan" id="kobo.5390.1"> &lt;&lt; id 
                                       &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.5391.1">" running\n"</span></span><span class="koboSpan" id="kobo.5392.1">;
      }, i));
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-565"><span class="koboSpan" id="kobo.5393.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.5394.1">Working with threads</span></em><span class="koboSpan" id="kobo.5395.1">, to learn about the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5396.1">std::thread</span></code><span class="koboSpan" id="kobo.5397.1"> class and the basic operations for working with threads in C++</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.5398.1">Using joinable threads and cancellation mechanisms</span></em><span class="koboSpan" id="kobo.5399.1">, to learn about the C++20 </span><code class="inlineCode"><span class="koboSpan" id="kobo.5400.1">std::jthread</span></code><span class="koboSpan" id="kobo.5401.1"> class, which manages a thread of execution and automatically joins during its destruction, as well as the improved mechanisms for stopping the execution of threads</span></li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.5402.1">Learn more on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.5403.1">Join our community’s Discord space for discussions with the author and other readers:</span></p>
<p class="normal"><a href="Chapter_08.xhtml"><span class="url"><span class="koboSpan" id="kobo.5404.1">https://discord.gg/7xRaTCeEhx</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.5405.1"><img alt="" src="../Images/QR_Code2659294082093549796.png"/></span></p>
</div>
</body></html>