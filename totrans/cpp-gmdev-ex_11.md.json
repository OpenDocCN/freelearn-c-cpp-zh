["```cpp\nMeshRenderer(MeshType modelType, std::string _name, Camera *  \n   _camera, btRigidBody* _rigidBody) \n```", "```cpp\n         std::string name = \"\"; \n```", "```cpp\nMeshRenderer::MeshRenderer(MeshType modelType, std::string _name,  \n   Camera* _camera, btRigidBody* _rigidBody){ \n\n   name = _name; \n... \n... \n\n} \n```", "```cpp\n   // Sphere Rigid Body \n\n   btCollisionShape* sphereShape = new btSphereShape(1); \n   btDefaultMotionState* sphereMotionState = new \n     btDefaultMotionState(btTransform(btQuaternion(0, 0, 0, 1), \n     btVector3(0, 0.5, 0))); \n\n   btScalar mass = 13.0f; \n   btVector3 sphereInertia(0, 0, 0); \n   sphereShape->calculateLocalInertia(mass, sphereInertia); \n\n   btRigidBody::btRigidBodyConstructionInfo sphereRigidBodyCI(mass, \n      sphereMotionState, sphereShape, sphereInertia); \n\n   btRigidBody* sphereRigidBody = new btRigidBody(\n                                  sphereRigidBodyCI); \n\n   sphereRigidBody->setFriction(1.0f); \n   sphereRigidBody->setRestitution(0.0f); \n\n   sphereRigidBody->setActivationState(DISABLE_DEACTIVATION); \n\n   dynamicsWorld->addRigidBody(sphereRigidBody); \n\n   // Sphere Mesh \n\n   sphere = new MeshRenderer(MeshType::kSphere, \"hero\", camera, \n            sphereRigidBody); \n   sphere->setProgram(texturedShaderProgram); \n   sphere->setTexture(sphereTexture); \n   sphere->setScale(glm::vec3(1.0f)); \n\n   sphereRigidBody->setUserPointer(sphere); \n\n   // Ground Rigid body \n\n   btCollisionShape* groundShape = new btBoxShape(btVector3(4.0f, \n                                   0.5f, 4.0f)); \n   btDefaultMotionState* groundMotionState = new \n       btDefaultMotionState(btTransform(btQuaternion(0, 0, 0, 1), \n       btVector3(0, -1.0f, 0))); \n\n   btRigidBody::btRigidBodyConstructionInfo groundRigidBodyCI(0.0f, \n      groundMotionState, groundShape, btVector3(0, 0, 0)); \n\n   btRigidBody* groundRigidBody = new btRigidBody(\n                                  groundRigidBodyCI); \n\n   groundRigidBody->setFriction(1.0); \n   groundRigidBody->setRestitution(0.0); \n\n   groundRigidBody->setCollisionFlags(\n       btCollisionObject::CF_STATIC_OBJECT); \n\n   dynamicsWorld->addRigidBody(groundRigidBody); \n\n   // Ground Mesh \n   ground = new MeshRenderer(MeshType::kCube, \"ground\", camera, \n            groundRigidBody); \n   ground->setProgram(texturedShaderProgram); \n   ground->setTexture(groundTexture); \n   ground->setScale(glm::vec3(4.0f, 0.5f, 4.0f)); \n\n   groundRigidBody->setUserPointer(ground); \n\n```", "```cpp\n// Enemy Rigid body \n\nbtCollisionShape* shape = new btBoxShape(btVector3(1.0f, 1.0f, 1.0f)); \nbtDefaultMotionState* motionState = new btDefaultMotionState(btTransform(btQuaternion(0, 0, 0, 1), \nbtVector3(18.0, 1.0f, 0))); \nbtRigidBody::btRigidBodyConstructionInfo rbCI(0.0f, motionState, shape, btVector3(0.0f, 0.0f, 0.0f)); \n\n   btRigidBody* rb = new btRigidBody(rbCI); \n\n   rb->setFriction(1.0); \n   rb->setRestitution(0.0); \n\n//rb->setCollisionFlags(btCollisionObject::CF_KINEMATIC_OBJECT); \n\nrb->setCollisionFlags(btCollisionObject::CF_NO_CONTACT_RESPONSE); \n\n   dynamicsWorld->addRigidBody(rb); \n\n   // Enemy Mesh \n   enemy = new MeshRenderer(MeshType::kCube, \"enemy\", camera, rb); \n   enemy->setProgram(texturedShaderProgram); \n   enemy->setTexture(groundTexture); \n   enemy->setScale(glm::vec3(1.0f, 1.0f, 1.0f)); \n\n   rb->setUserPointer(enemy); \n```", "```cpp\n   void myTickCallback(btDynamicsWorld *dynamicsWorld, \n      btScalar timeStep); \n```", "```cpp\nvoid myTickCallback(btDynamicsWorld *dynamicsWorld, btScalar timeStep) { \n\n         // Get enemy transform \n         btTransform t(enemy->rigidBody->getWorldTransform()); \n\n         // Set enemy position \n         t.setOrigin(t.getOrigin() + btVector3(-15, 0, 0) * \n         timeStep); \n\n         // Check if offScreen \n         if(t.getOrigin().x() <= -18.0f) { \n               t.setOrigin(btVector3(18, 1, 0)); \n         } \n         enemy->rigidBody->setWorldTransform(t); \n         enemy->rigidBody->getMotionState()->setWorldTransform(t); \n\n} \n```", "```cpp\ndynamicsWorld = new btDiscreteDynamicsWorld(dispatcher, broadphase, \n                solver, collisionConfiguration); \ndynamicsWorld->setGravity(btVector3(0, -9.8f, 0));  \ndynamicsWorld->setInternalTickCallback(myTickCallback); \n```", "```cpp\nint numManifolds = dynamicsWorld->getDispatcher()->\n  getNumManifolds(); \n\n   for (int i = 0; i < numManifolds; i++) { \n\n       btPersistentManifold *contactManifold = dynamicsWorld->\n       getDispatcher()->getManifoldByIndexInternal(i); \n\n       int numContacts = contactManifold->getNumContacts(); \n\n       if (numContacts > 0) { \n\n           const btCollisionObject *objA = contactManifold->\n           getBody0(); \n           const btCollisionObject *objB = contactManifold->\n           getBody1(); \n\n           MeshRenderer* gModA = (MeshRenderer*)objA->\n           getUserPointer(); \n           MeshRenderer* gModB = (MeshRenderer*)objB->\n           getUserPointer(); \n\n                if ((gModA->name == \"hero\" && gModB->name == \n                  \"enemy\") || (gModA->name == \"enemy\" && gModB->\n                  name == \"hero\")) { \n                        printf(\"collision: %s with %s \\n\",\n                        gModA->name, gModB->name); \n\n                         if (gModB->name == \"enemy\") { \n                             btTransform b(gModB->rigidBody-\n                             >getWorldTransform()); \n                             b.setOrigin(btVector3(18, 1, 0)); \n                             gModB->rigidBody-\n                             >setWorldTransform(b); \n                             gModB->rigidBody-> \n                             getMotionState()-\n                             >setWorldTransform(b); \n                           }else { \n\n                                 btTransform a(gModA->rigidBody->\n                                 getWorldTransform()); \n                                 a.setOrigin(btVector3(18, 1, 0)); \n                                 gModA->rigidBody->\n                                 setWorldTransform(a); \n                                 gModA->rigidBody->\n                                 getMotionState()->\n                                 setWorldTransform(a); \n                           } \n\n                     } \n\n                     if ((gModA->name == \"hero\" && gModB->name == \n                         \"ground\") || (gModA->name == \"ground\" &&               \n                          gModB->name  == \"hero\")) { \n                           printf(\"collision: %s with %s \\n\",\n                           gModA->name, gModB->name); \n\n                     } \n         } \n   } \n```", "```cpp\nvoid updateKeyboard(GLFWwindow* window, int key, int scancode, int action, int mods){ \n\n   if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) { \n         glfwSetWindowShouldClose(window, true);    \n   } \n\n   if (key == GLFW_KEY_UP && action == GLFW_PRESS) { \n               if (grounded == true) { \n                     grounded = false; \n\nsphere->rigidBody->applyImpulse(btVector3(0.0f, \n   100.0f, 0.0f), btVector3(0.0f, 0.0f, 0.0f)); \n                     printf(\"pressed up key \\n\"); \n               } \n         } \n} \n```", "```cpp\n grounded = false; \n\n   int numManifolds = dynamicsWorld->getDispatcher()->\n                      getNumManifolds(); \n```", "```cpp\n   if ((gModA->name == \"hero\" && gModB->name == \"ground\") || \n         (gModA->name == \"ground\" && gModB->name == \"hero\")) { \n\n//printf(\"collision: %s with %s \\n\", gModA->name, gModB->name); \n\n         grounded = true; \n\n   }   \n```", "```cpp\nint main(int argc, char **argv) { \n...       \n   glfwMakeContextCurrent(window); \n   glfwSetKeyCallback(window, updateKeyboard); \n   ... \n   }\n```", "```cpp\nGLuint sphereTexture, groundTexture; \n\nbool grounded = false; \nbool gameover = true; \nint score = 0; \n\n```", "```cpp\nvoid myTickCallback(btDynamicsWorld *dynamicsWorld, btScalar timeStep) { \n\n   if (!gameover) { \n\n         // Get enemy transform \n         btTransform t(enemy->rigidBody->getWorldTransform()); \n\n         // Set enemy position \n\n         t.setOrigin(t.getOrigin() + btVector3(-15, 0, 0) * \n         timeStep); \n\n         // Check if offScreen \n\n         if (t.getOrigin().x() <= -18.0f) { \n\n               t.setOrigin(btVector3(18, 1, 0)); \n               score++; \n               label->setText(\"Score: \" + std::to_string(score)); \n\n         } \n\n         enemy->rigidBody->setWorldTransform(t); \n         enemy->rigidBody->getMotionState()->setWorldTransform(t); \n   } \n... \n} \n```", "```cpp\n\n         if ((gModA->name == \"hero\" && gModB->name == \"enemy\") || \n                    (gModA->name == \"enemy\" && gModB->name ==\n                     \"hero\")) { \n\n                     if (gModB->name == \"enemy\") { \n                         btTransform b(gModB->rigidBody->\n                         getWorldTransform()); \n                         b.setOrigin(btVector3(18, 1, 0)); \n                         gModB->rigidBody->\n                         setWorldTransform(b); \n                         gModB->rigidBody->getMotionState()->\n                         setWorldTransform(b); \n                           }else { \n\n                           btTransform a(gModA->rigidBody->\n                           getWorldTransform()); \n                           a.setOrigin(btVector3(18, 1, 0)); \n                           gModA->rigidBody->\n                           setWorldTransform(a); \n                           gModA->rigidBody->getMotionState()->\n                           setWorldTransform(a); \n                           } \n\n                           gameover = true; \n                           score = 0; \n\n                     }   \n```", "```cpp\nvoid updateKeyboard(GLFWwindow* window, int key, int scancode, int action, int mods){ \n\n   if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) { \n         glfwSetWindowShouldClose(window, true); \n   } \n\n   if (key == GLFW_KEY_UP && action == GLFW_PRESS) { \n\n         if (gameover) { \n               gameover = false; \n         } else { \n\n               if (grounded == true) { \n\n                     grounded = false; \n\nsphere->rigidBody->applyImpulse(btVector3(0.0f, 100.0f, 0.0f), \n   btVector3(0.0f, 0.0f, 0.0f)); \n                     printf(\"pressed up key \\n\"); \n               } \n         } \n   } \n}   \n```", "```cpp\n#include <GL/glew.h> \n\n#include \"Dependencies/glm/glm/glm.hpp\" \n#include \"Dependencies/glm/glm/gtc/matrix_transform.hpp\" \n#include \"Dependencies/glm/glm/gtc/type_ptr.hpp\"\n```", "```cpp\n#include <ft2build.h> \n#include FT_FREETYPE_H    \n```", "```cpp\n#include <string> \n```", "```cpp\nstruct Character { \n   GLuint     TextureID;  // Texture ID of each glyph texture \n   glm::ivec2 Size;       // glyph Size \n   glm::ivec2 Bearing;    // baseline to left/top of glyph \n   GLuint     Advance;    // id to next glyph \n}; \n\n```", "```cpp\nclass TextRenderer{ \n\npublic: \n   TextRenderer(std::string text, std::string font, int size, \n     glm::vec3 color, GLuint  program); \n   ~TextRenderer(); \n\n   void draw(); \n   void setPosition(glm::vec2 _position); \n   void setText(std::string _text); \n\nprivate: \n   std::string text; \n   GLfloat scale; \n   glm::vec3 color; \n   glm::vec2 position; \n\n   GLuint VAO, VBO, program; \n   std::map<GLchar, Character> Characters; \n\n};   \n```", "```cpp\nTextRenderer::TextRenderer(std::string text, std::string font, int size, glm::vec3 color, GLuint program){ \n\n} \n```", "```cpp\n   this->text = text; \n   this->color = color; \n   this->scale = 1.0; \n   this->program = program; \n   this->setPosition(position); \n```", "```cpp\n   glm::mat4 projection = glm::ortho(0.0f, static_cast<GLfloat>\n                         (800), 0.0f, static_cast<GLfloat>(600)); \n   glUseProgram(program); \n   glUniformMatrix4fv(glGetUniformLocation(program, \"projection\"), \n      1, GL_FALSE, glm::value_ptr(projection)); \n```", "```cpp\n// FreeType \nFT_Library ft; \n\n// Initialise freetype \nif (FT_Init_FreeType(&ft)) \nstd::cout << \"ERROR::FREETYPE: Could not init FreeType Library\" \n          << std::endl; \n```", "```cpp\n// Load font \nFT_Face face; \nif (FT_New_Face(ft, font.c_str(), 0, &face)) \n         std::cout << \"ERROR::FREETYPE: Failed to load font\" \n                   << std::endl; \n\n```", "```cpp\n// Set size of glyphs \nFT_Set_Pixel_Sizes(face, 0, size); \n\n// Disable byte-alignment restriction \nglPixelStorei(GL_UNPACK_ALIGNMENT, 1); \n```", "```cpp\n   for (GLubyte i = 0; i < 128; i++){ \n\n         // Load character glyph  \n         if (FT_Load_Char(face, i, FT_LOAD_RENDER)){ \n               std::cout << \"ERROR::FREETYTPE: Failed to \n                            load Glyph\" << std::endl; \n               continue; \n         } \n\n         // Generate texture \n         GLuint texture; \n         glGenTextures(1, &texture); \n         glBindTexture(GL_TEXTURE_2D, texture); \n\n         glTexImage2D( \n               GL_TEXTURE_2D, \n               0, \n               GL_RED, \n               face->glyph->bitmap.width, \n               face->glyph->bitmap.rows, \n               0, \n               GL_RED, \n               GL_UNSIGNED_BYTE, \n               face->glyph->bitmap.buffer \n               ); \n\n         // Set texture filtering options \n         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, \n         GL_CLAMP_TO_EDGE); \n         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, \n         GL_CLAMP_TO_EDGE); \n         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,\n         GL_LINEAR); \n         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,\n         GL_LINEAR); \n\n         // Create a character \n         Character character = { \n               texture, \n               glm::ivec2(face->glyph->bitmap.width, \n                           face->glyph->bitmap.rows), \n               glm::ivec2(face->glyph->bitmap_left, \n           face->glyph->bitmap_top), \n               face->glyph->advance.x \n         }; \n\n         // Store character in characters map \n         Characters.insert(std::pair<GLchar, Character>(i,\n         character)); \n   } \n```", "```cpp\n   glBindTexture(GL_TEXTURE_2D, 0); \n\n   // Destroy FreeType once we're finished \n   FT_Done_Face(face); \n   FT_Done_FreeType(ft);\n```", "```cpp\n   glGenVertexArrays(1, &VAO); \n   glGenBuffers(1, &VBO); \n\n   glBindVertexArray(VAO); \n\n   glBindBuffer(GL_ARRAY_BUFFER, VBO); \n   glBufferData(GL_ARRAY_BUFFER, sizeof(GLfloat) * 6 * 4, NULL, \n       GL_DYNAMIC_DRAW); \n\n   glEnableVertexAttribArray(0); \n   glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 4 * \n      sizeof(GLfloat), 0); \n\n```", "```cpp\n   glBindBuffer(GL_ARRAY_BUFFER, 0); \n   glBindVertexArray(0); \n\n```", "```cpp\nvoid TextRenderer::draw(){\n} \n```", "```cpp\nglm::vec2 textPos = this->position; \n```", "```cpp\n   glEnable(GL_BLEND); \n```", "```cpp\nglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); \n```", "```cpp\n   glUseProgram(program); \n   glUniform3f(glGetUniformLocation(program, \"textColor\"), \n      this->color.x, this->color.y, this->color.z); \n   glActiveTexture(GL_TEXTURE0); \n```", "```cpp\n   glBindVertexArray(VAO); \n```", "```cpp\n   std::string::const_iterator c; \n\n   for (c = text.begin(); c != text.end(); c++){ \n\n         Character ch = Characters[*c]; \n\n         GLfloat xpos = textPos.x + ch.Bearing.x * this->scale; \n         GLfloat ypos = textPos.y - (ch.Size.y - ch.Bearing.y) * \n         this->scale; \n\n         GLfloat w = ch.Size.x * this->scale; \n         GLfloat h = ch.Size.y * this->scale; \n\n         // Per Character Update VBO \n         GLfloat vertices[6][4] = { \n               { xpos, ypos + h, 0.0, 0.0 }, \n               { xpos, ypos, 0.0, 1.0 }, \n               { xpos + w, ypos, 1.0, 1.0 }, \n\n               { xpos, ypos + h, 0.0, 0.0 }, \n               { xpos + w, ypos, 1.0, 1.0 }, \n               { xpos + w, ypos + h, 1.0, 0.0 } \n         }; \n\n         // Render glyph texture over quad \n         glBindTexture(GL_TEXTURE_2D, ch.TextureID); \n\n         // Update content of VBO memory \n         glBindBuffer(GL_ARRAY_BUFFER, VBO); \n\n         // Use glBufferSubData and not glBufferData \n         glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(vertices), \n         vertices);  \n\n         glBindBuffer(GL_ARRAY_BUFFER, 0); \n\n         // Render quad \n         glDrawArrays(GL_TRIANGLES, 0, 6); \n\n         // Now advance cursors for next glyph (note that advance \n         is number of 1/64 pixels) \n         // Bitshift by 6 to get value in pixels (2^6 = 64 (divide \n         amount of 1/64th pixels by 64 to get amount of pixels)) \n         textPos.x += (ch.Advance >> 6) * this->scale;  \n   } \n```", "```cpp\nglBindVertexArray(0); \nglBindTexture(GL_TEXTURE_2D, 0); \n\nglDisable(GL_BLEND);  \n```", "```cpp\nvoid TextRenderer::setPosition(glm::vec2 _position){ \n\n   this->position = _position; \n} \n\nvoid TextRenderer::setText(std::string _text){ \n   this->text = _text; \n} \n```", "```cpp\n#include \"TextRenderer.h\" \n\nTextRenderer* label;  \n\n```", "```cpp\nGLuint textProgram \n```", "```cpp\ntextProgram = shader.CreateProgram(\"Assets/Shaders/text.vs\", \"Assets/Shaders/text.fs\"); \n```", "```cpp\n#version 450 core \nlayout (location = 0) in vec4 vertex; \nuniform mat4 projection; \n\nout vec2 TexCoords; \n\nvoid main(){ \n    gl_Position = projection * vec4(vertex.xy, 0.0, 1.0); \n    TexCoords = vertex.zw; \n}   \n```", "```cpp\n#version 450 core \n\nin vec2 TexCoords; \n\nuniform sampler2D text; \nuniform vec3 textColor; \n\nout vec4 color; \n\nvoid main(){     \nvec4 sampled = vec4(1.0, 1.0, 1.0, texture(text, TexCoords).r); \ncolor = vec4(textColor, 1.0) * sampled; \n} \n```", "```cpp\nlabel = new TextRenderer(\"Score: 0\", \"Assets/fonts/gooddog.ttf\", \n        64, glm::vec3(1.0f, 0.0f, 0.0f), textProgram); \n   label->setPosition(glm::vec2(320.0f, 500.0f)); \n\n```", "```cpp\n         if (t.getOrigin().x() <= -18.0f) { \n\n               t.setOrigin(btVector3(18, 1, 0)); \n               score++; \n               label->setText(\"Score: \" + std::to_string(score));\n         }\n```", "```cpp\n               gameover = true; \n               score = 0; \n               label->setText(\"Score: \" + std::to_string(score));\n```", "```cpp\nvoid renderScene(float dt){ \n\n   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); \n   glClearColor(1.0, 1.0, 0.0, 1.0); \n\n   // Draw Objects \n\n   //light->draw(); \n\n   sphere->draw(); \n   enemy->draw(); \n   ground->draw(); \n\n   label->draw(); \n} \n```", "```cpp\nMeshRenderer(MeshType modelType, std::string _name, Camera * \n   _camera, btRigidBody* _rigidBody, LightRenderer* _light, float \n   _specularStrength, float _ambientStrength);\n```", "```cpp\n#include \"LightRenderer.h\"\n```", "```cpp\n        GLuint vao, vbo, ebo, texture, program; \n        LightRenderer* light;\n        float ambientStrength, specularStrength;\n```", "```cpp\nMeshRenderer::MeshRenderer(MeshType modelType, std::string _name, \n   Camera* _camera, btRigidBody* _rigidBody, LightRenderer* _light, \n   float _specularStrength, float _ambientStrength) { \n\n   name = _name; \n   rigidBody = _rigidBody; \n   camera = _camera; \n   light = _light; \n   ambientStrength = _ambientStrength; \n   specularStrength = _specularStrength; \n... \n} \n\n```", "```cpp\nglEnableVertexAttribArray(0); \nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), \n   (GLvoid*)0); \n\n glEnableVertexAttribArray(1); \n glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), \n      (void*)(offsetof(Vertex, Vertex::texCoords))); \n glEnableVertexAttribArray(2);\n glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), \n     (void*)(offsetof(Vertex, Vertex::normal))); \n\n```", "```cpp\n   // Set Texture \n   glBindTexture(GL_TEXTURE_2D, texture); \n\n   // Set Lighting \n   GLuint cameraPosLoc = glGetUniformLocation(program, \n                         \"cameraPos\"); \n   glUniform3f(cameraPosLoc, camera->getCameraPosition().x,\n   camera-> getCameraPosition().y, camera->getCameraPosition().z); \n\n   GLuint lightPosLoc = glGetUniformLocation(program, \"lightPos\"); \n   glUniform3f(lightPosLoc, this->light->getPosition().x, \n     this-> light->getPosition().y, this->light->getPosition().z); \n\n   GLuint lightColorLoc = glGetUniformLocation(program, \n                          \"lightColor\"); \n   glUniform3f(lightColorLoc, this->light->getColor().x, \n     this-> light->getColor().y, this->light->getColor().z); \n\n   GLuint specularStrengthLoc = glGetUniformLocation(program, \n                                \"specularStrength\"); \n   glUniform1f(specularStrengthLoc, specularStrength); \n\n   GLuint ambientStrengthLoc = glGetUniformLocation(\n                               program, \"ambientStrength\"); \n   glUniform1f(ambientStrengthLoc, ambientStrength); \n\n   glBindVertexArray(vao);        \n   glDrawElements(GL_TRIANGLES, indices.size(), \n      GL_UNSIGNED_INT, 0); \n   glBindVertexArray(0); \n\n```", "```cpp\n#version 450 core \nlayout (location = 0) in vec3 position; \nlayout (location = 1) in vec2 texCoord; \nlayout (location = 2) in vec3 normal; \n\nout vec2 TexCoord; \nout vec3 Normal; \nout vec3 fragWorldPos; \n\nuniform mat4 vp; \nuniform mat4 model; \n\nvoid main(){ \n\n   gl_Position = vp * model *vec4(position, 1.0); \n\n   TexCoord = texCoord; \n   fragWorldPos = vec3(model * vec4(position, 1.0)); \n   Normal = mat3(transpose(inverse(model))) * normal; \n\n} \n```", "```cpp\n#version 450 core \n\nin vec2 TexCoord; \nin vec3 Normal; \nin vec3 fragWorldPos; \n\nuniform vec3 cameraPos; \nuniform vec3 lightPos; \nuniform vec3 lightColor; \n\nuniform float specularStrength; \nuniform float ambientStrength; \n\n// texture \nuniform sampler2D Texture; \n\nout vec4 color;    \n```", "```cpp\n void main(){ \n\n       vec3 norm = normalize(Normal); \n       vec4 objColor = texture(Texture, TexCoord); \n\n       //**ambient \n       vec3 ambient = ambientStrength * lightColor; \n\n       //**diffuse \n       vec3 lightDir = normalize(lightPos - fragWorldPos); \n       float diff = max(dot(norm, lightDir), 0.0); \n       vec3 diffuse = diff * lightColor; \n\n       //**specular  \n       vec3 viewDir = normalize(cameraPos - fragWorldPos); \n       vec3 reflectionDir = reflect(-lightDir, norm); \n       float spec = pow(max(dot(viewDir, \n                    reflectionDir),0.0),128); \n       vec3 specular = specularStrength * spec * lightColor; \n\n       // lighting shading calculation \n       vec3 totalColor = (ambient + diffuse + specular) * \n       objColor.rgb; \n\n       color = vec4(totalColor, 1.0f); \n\n}  \n```", "```cpp\nGLuint litTexturedShaderProgram; \nCreate the shader program and assign it to it in the init function in main.cpp. \n   litTexturedShaderProgram = shader.CreateProgram(\n                              \"Assets/Shaders/LitTexturedModel.vs\",                 \n                              \"Assets/Shaders/LitTexturedModel.fs\"); \n```", "```cpp\n  // Sphere Rigid Body \n\n  btCollisionShape* sphereShape = new btSphereShape(1);\n  btDefaultMotionState* sphereMotionState = new \n     btDefaultMotionState(btTransform(btQuaternion(0, 0, 0, 1), \n     btVector3(0, 0.5, 0)));\n\n  btScalar mass = 13.0f;\n  btVector3 sphereInertia(0, 0, 0);\n  sphereShape->calculateLocalInertia(mass, sphereInertia);\n\n  btRigidBody::btRigidBodyConstructionInfo \n     sphereRigidBodyCI(mass, sphereMotionState, sphereShape, \n     sphereInertia);\n\n  btRigidBody* sphereRigidBody = new btRigidBody\n                                 (sphereRigidBodyCI);\n\n  sphereRigidBody->setFriction(1.0f);\n  sphereRigidBody->setRestitution(0.0f);\n\n  sphereRigidBody->setActivationState(DISABLE_DEACTIVATION);\n\n  dynamicsWorld->addRigidBody(sphereRigidBody);\n\n  // Sphere Mesh\n\n  sphere = new MeshRenderer(MeshType::kSphere, “hero”, \n           camera, sphereRigidBody, light, 0.1f, 0.5f);\n  sphere->setProgram(litTexturedShaderProgram);\n  sphere->setTexture(sphereTexture);\n  sphere->setScale(glm::vec3(1.0f));\n\n  sphereRigidBody->setUserPointer(sphere);\n\n  // Ground Rigid body\n\n  btCollisionShape* groundShape = new btBoxShape(btVector3(4.0f,   \n                                  0.5f, 4.0f));\n  btDefaultMotionState* groundMotionState = new \n    btDefaultMotionState(btTransform(btQuaternion(0, 0, 0, 1), \n     btVector3(0, -1.0f, 0)));\n\n  btRigidBody::btRigidBodyConstructionInfo \n    groundRigidBodyCI(0.0f, groundMotionState, groundShape, \n    btVector3(0, 0, 0));\n\n  btRigidBody* groundRigidBody = new btRigidBody\n                                 (groundRigidBodyCI);\n\n  groundRigidBody->setFriction(1.0);\n  groundRigidBody->setRestitution(0.0);\n\n  groundRigidBody->setCollisionFlags(\n     btCollisionObject::CF_STATIC_OBJECT);\n\n  dynamicsWorld->addRigidBody(groundRigidBody);\n\n  // Ground Mesh\n  ground = new MeshRenderer(MeshType::kCube, “ground”,\n           camera, groundRigidBody, light, 0.1f, 0.5f);\n  ground->setProgram(litTexturedShaderProgram);\n  ground->setTexture(groundTexture);\n  ground->setScale(glm::vec3(4.0f, 0.5f, 4.0f));\n\n  groundRigidBody->setUserPointer(ground);\n\n  // Enemy Rigid body\n\n  btCollisionShape* shape = new btBoxShape(btVector3(1.0f, \n                            1.0f, 1.0f));\n  btDefaultMotionState* motionState = new btDefaultMotionState(\n      btTransform(btQuaternion(0, 0, 0, 1), \n      btVector3(18.0, 1.0f, 0)));\n  btRigidBody::btRigidBodyConstructionInfo rbCI(0.0f, \n     motionState, shape, btVector3(0.0f, 0.0f, 0.0f));\n\n  btRigidBody* rb = new btRigidBody(rbCI);\n\n  rb->setFriction(1.0);\n  rb->setRestitution(0.0);\n\n  //rb->setCollisionFlags(btCollisionObject::CF_KINEMATIC_OBJECT);\n\n  rb->setCollisionFlags(btCollisionObject::CF_NO_CONTACT_RESPONSE);\n\n  dynamicsWorld->addRigidBody(rb);\n\n  // Enemy Mesh\n  enemy = new MeshRenderer(MeshType::kCube, “enemy”, \n          camera, rb, light, 0.1f, 0.5f);\n  enemy->setProgram(litTexturedShaderProgram);\n  enemy->setTexture(groundTexture);\n  enemy->setScale(glm::vec3(1.0f, 1.0f, 1.0f));\n\n  rb->setUserPointer(enemy);\n\n```"]