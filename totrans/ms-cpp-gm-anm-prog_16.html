<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer156" class="Basic-Text-Frame">
    <h1 class="chapterNumber">12</h1>
    <h1 id="_idParaDest-346" class="chapterTitle">Advanced Collision Detection</h1>
    <p class="normal">Welcome to <a href=""><em class="italic">Chapter 12</em></a>! In the previous chapter, we added the ability to load static level data to the virtual world. Now the instances no longer have to run in thin air; they can get a virtual home. First, we explored the differences between model and level data, which file formats are mostly used for level data, and where to find game maps on the internet. Then, we added code to load level data and replaced the two-dimensional quadtree with a three-dimensional octree. Finally, we implemented the level data rendering, including debug data for wireframe, octree, and level AABB lines.</p>
    <p class="normal">In this chapter, we will extend the level data from the previous chapter. First, we will add a specialized octree for the level data and update the code to also support collision detection between instances and level geometry. Then, we will add a simplified form of gravity to the virtual world to keep the instances at ground level instead of having them floating around. As the last step, we will introduce inverse kinematics for the instance legs to allow the instances to climb slopes and stairs with more natural leg motions and to prevent the feet from clipping into the ground or floating in the air.</p>
    <p class="normal">In this chapter, we will cover the following topics:</p>
    <ul>
      <li class="bulletList">Enhancing collision detection for level data</li>
      <li class="bulletList">Using gravity to keep the instances at floor level</li>
      <li class="bulletList">Adding inverse kinematics</li>
    </ul>
    <h1 id="_idParaDest-347" class="heading-1">Technical requirements</h1>
    <p class="normal">The example code for this chapter is available in the <code class="inlineCode">chapter12</code> folder, in the <code class="inlineCode">01_opengl_adv_collision</code> subfolder for OpenGL, and the <code class="inlineCode">02_vulkan_adv_collision</code> subfolder for Vulkan.</p>
    <h1 id="_idParaDest-348" class="heading-1">Enhancing collision detection for level data</h1>
    <p class="normal">To speed up collision <a id="_idIndexMarker641"/>detection between instances and level geometry, we will create spatial partitioning for the level data, like the octree. But instead of adding the level triangles to the instance octree, we build a specialized octree for the triangle data alone.</p>
    <h2 id="_idParaDest-349" class="heading-2">Adding a new octree type</h2>
    <p class="normal">Using a separate data structure for level <a id="_idIndexMarker642"/>data makes more sense than trying to mix both data types in the existing octree for several reasons:</p>
    <ul>
      <li class="bulletList">The level data is static while the instance positions change frequently. We need to do costly updates to a quite heavily utilized octree on every instance position change, possibly resulting in a lot of additional split and merge operations when removing and re-adding the instances.</li>
      <li class="bulletList">The number of subdivisions for level data and instances may be completely different, depending on the level’s complexity and the number of instances. Having only a small number of instances roaming around a detailed level may lead to a huge overhead when searching for nearby triangles or instances.</li>
      <li class="bulletList">We are using an octree for the level data for simplicity, but other data structures, like BSP trees or <strong class="keyWord">boundary volume hierarchies (BVHs)</strong>, are more common. Since BSP trees and BVHs cannot be dynamically updated as quickly as our octree, a split between level data and instances would still be necessary.</li>
    </ul>
    <p class="normal">With two different octrees, we can overcome these mentioned problems. The level data octree is kept unchanged after adding all the level triangles, both octrees have their own subdivisions, depending on the amount of data per octant, but we can still combine the information by using the instance bounding boxes in the level octree.</p>
    <p class="normal">As the first step for the level octree, we add a new <code class="inlineCode">struct</code> named <code class="inlineCode">MeshTriangle</code> to the <code class="inlineCode">OGLRenderData.h</code> file in the <code class="inlineCode">opengl</code> folder:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span> <span class="hljs-title">MeshTriangle</span> {
  <span class="hljs-type">int</span> index;
  std::array&lt;glm::vec3, 3&gt; points;
  BoundingBox3D boundingBox;
};
</code></pre>
    <p class="normal">For Vulkan, the triangle <code class="inlineCode">struct</code> will be added to the <code class="inlineCode">VkRenderData.h</code> file in the <code class="inlineCode">vulkan</code> folder.</p>
    <p class="normal">The <code class="inlineCode">index</code> member is mostly for debugging purposes and will be added to a log output line in case some triangles cannot be added to the octree. In the <code class="inlineCode">points</code> array, we save the world positions of each of the three points of a triangle. The world position is needed to create the proper bounding box for the triangle, we will use the world position also later for collision detection. And the <code class="inlineCode">boundingBox</code> member contains the <code class="inlineCode">AABB</code> for every triangle of the level data mesh.</p>
    <p class="normal">Using bounding boxes instead of the real triangle data in the octree simplifies the query operations a lot since we do not have to check the exact outline of every triangle when searching for collision. We may end up with more triangles to check by using the AABB, but the <code class="inlineCode">AABB</code> checks are cheap since we only need a maximum of six simple <code class="inlineCode">float</code> comparisons. As most parts of a level geometry are either wall or ground, the additional size of the <code class="inlineCode">AABB</code> does not matter.</p>
    <p class="normal">Next, we add the new octree class named <code class="inlineCode">TriangleOctree</code>. The new triangle octree will be implemented in the two new files, <code class="inlineCode">TriangleOctree.h</code> and <code class="inlineCode">TriangleOctree.cpp</code>, in the <code class="inlineCode">octree</code> folder.</p>
    <p class="normal">The <code class="inlineCode">TriangleOctree</code> class is a copy of the normal <code class="inlineCode">Octree</code> class, with a few exceptions:</p>
    <ul>
      <li class="bulletList">We store the triangle data in the tree instead of the instance index.</li>
      <li class="bulletList">Since the level data octree will be kept read-only, we don’t need the methods to update or<a id="_idIndexMarker643"/> remove objects or merge octants.</li>
      <li class="bulletList">We handle only static data in the triangle octree, a search for intersections between triangles of the level does not return any useful information for us. So, the <code class="inlineCode">findAllIntersections()</code> and <code class="inlineCode">findIntersectionsInDescendants()</code> methods can be skipped too.</li>
    </ul>
    <p class="normal">In addition to the reasons to use a separate octree for the level data mentioned in the <em class="italic">Adding a new octree type</em> section, we also use a different approach for objects not fitting in a single octant.</p>
    <p class="normal">In the instance octree, a bounding box of an instance will be only in rare cases larger than a single octant, for instance when an instance is scaled by a large factor. But within the level octree, the bounding box of many triangles may not fit into a single subdivided octant. The creator of a level will try to minimize the number of triangles in a level for good rendering performance, resulting in areas of the level made of only a few large triangles.</p>
    <p class="normal">We could overcome the size problem with one of the following three methods:</p>
    <ol>
      <li class="numberedList" value="1">Keep a large triangle in the octant big enough to contain the entire triangle. This solution would store additional objects in a parent node, not only in a leaf.</li>
      <li class="numberedList">Add the triangle to all affected subdivided octants. We would only have data in the leaves but would duplicate the triangle data in the worst case 8 times.</li>
      <li class="numberedList">Split the triangle on the octant boundaries and add only the sub-triangles to each octant. Again, we would have an additional triangle per affected octant, plus possible problems with rounding errors in the split lines.</li>
    </ol>
    <p class="normal">To keep the code simple, we will use the first method and add any triangle exceeding the dimensions of a subdivided octant only in the parent octant.</p>
    <p class="normal">We can achieve the storage process for oversized triangles with a two-step check in the <code class="inlineCode">add()</code> and <code class="inlineCode">split()</code> methods. First, we iterate over all child octants to find possible intersections of the triangle with the boundaries of the child octant:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-type">int</span> intersectingChildren = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; node-&gt;childs.<span class="hljs-built_in">size</span>(); ++i) {
      BoundingBox3D childBox = <span class="hljs-built_in">getChildOctant</span>(box, i);
      <span class="hljs-keyword">if</span> (childBox.<span class="hljs-built_in">intersects</span>(triangle.boundingBox)) {
        intersectingChildren++;
      }
    }
</code></pre>
    <p class="normal">If we find an intersection with a child octant, we increment the <code class="inlineCode">intersectingChildren</code> variable. Then, for the <code class="inlineCode">add()</code> method, we check how many child octants the triangle would intersect. In case of more <a id="_idIndexMarker644"/>than one octant, the triangle is kept in the current octant:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">if</span> (intersectingChildren &gt; <span class="hljs-number">1</span>) {
      node-&gt;triangles.<span class="hljs-built_in">emplace_back</span>(triangle);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-type">int</span> i = <span class="hljs-built_in">getOctantId</span>(box, triangle.boundingBox);
      <span class="hljs-keyword">if</span> (i != <span class="hljs-number">-1</span>) {
        <span class="hljs-built_in">add</span>(node-&gt;childs.<span class="hljs-built_in">at</span>(i), depth + <span class="hljs-number">1</span>,
         <span class="hljs-built_in">getChildOctant</span>(box, i), triangle);
      }
    }
</code></pre>
    <p class="normal">And if we found only an intersection with a single child octant, we hand over the triangle recursively to the child octant.</p>
    <p class="normal">For the <code class="inlineCode">split()</code> method, we do the same, and keep the triangle in the current octant if we find more than one intersection with the future child octants:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">if</span> (intersectingChildren &gt; <span class="hljs-number">1</span>) {
      newTriangles.<span class="hljs-built_in">emplace_back</span>(triangle);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-type">int</span> i = <span class="hljs-built_in">getOctantId</span>(box, triangle.boundingBox);
      <span class="hljs-keyword">if</span> (i != <span class="hljs-number">-1</span>) {
        node-&gt;childs.<span class="hljs-built_in">at</span>(i)
          -&gt;triangles.<span class="hljs-built_in">emplace_back</span>(triangle);
      }
    }
</code></pre>
    <p class="normal">The <code class="inlineCode">query()</code> methods to query the triangle octree for collisions with a bounding box and <code class="inlineCode">getTreeBoxes()</code> boxes to show octree debug lines remain the same as in the original octree, only the data type for the <code class="inlineCode">private</code> <code class="inlineCode">query()</code> method needs to be adjusted.</p>
    <p class="normal">After the <code class="inlineCode">TriangleOctree</code> is ready, we can add the level data to the new octree and query for the tree for collisions.</p>
    <h2 id="_idParaDest-350" class="heading-2">Filling the level data octree</h2>
    <p class="normal">Like the instance octree, we<a id="_idIndexMarker645"/> need to add the <code class="inlineCode">TriangleOctree.h</code> header to the renderer header, and then add a new <code class="inlineCode">private</code> member named <code class="inlineCode">mTriangleOctree</code> and the two <code class="inlineCode">private</code> methods <code class="inlineCode">initTriangleOctree()</code> and <code class="inlineCode">generateLevelOctree()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">std::shared_ptr&lt;TriangleOctree&gt; mTriangleOctree = <span class="hljs-literal">nullptr</span>;
<span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">initTriangleOctree</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> thresholdPerBox, </span><span class="hljs-type">int</span><span class="hljs-params"> maxDepth)</span>;
<span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">generateLevelOctree</span><span class="hljs-params">()</span>;
</code></pre>
    <p class="normal">To have default values for threshold and depth and to be able to control the settings via UI later, two new variables named <code class="inlineCode">rdLevelOctreeThreshold</code> and <code class="inlineCode">rdLevelOctreeMaxDepth</code> are stored in the <code class="inlineCode">OGLRenderData</code> <code class="inlineCode">struct</code> in the <code class="inlineCode">OGLRenderData.h</code> file in the <code class="inlineCode">opengl</code> folder:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-type">int</span> rdLevelOctreeThreshold = <span class="hljs-number">10</span>;
  <span class="hljs-type">int</span> rdLevelOctreeMaxDepth = <span class="hljs-number">5</span>;
</code></pre>
    <p class="normal">Again, for Vulkan, the two variables are added to the <code class="inlineCode">VkRenderData</code> <code class="inlineCode">struct</code> in the <code class="inlineCode">VkRenderData.h</code> file in the <code class="inlineCode">vulkan</code> folder.</p>
    <p class="normal">During the <code class="inlineCode">init()</code> method of<a id="_idIndexMarker646"/> the renderer, <code class="inlineCode">initTriangleOctree()</code> is called to create an octree with the given threshold and maximum depth:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">OGLRenderer::initTriangleOctree</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> thresholdPerBox,</span>
<span class="hljs-params">  </span><span class="hljs-type">int</span><span class="hljs-params"> maxDepth)</span><span class="hljs-function"> </span>{
  mTriangleOctree = std::<span class="hljs-built_in">make_shared</span>&lt;TriangleOctree&gt;(
    mWorldBoundaries, thresholdPerBox, maxDepth);
}
</code></pre>
    <p class="normal">The world boundaries are updated during level <code class="inlineCode">AABB</code> generation, so our triangle octree is exactly the same size as the level data after the level was loaded.</p>
    <p class="normal">Filling the level data octree is done in the <code class="inlineCode">generateLevelOctree()</code> method. We just walk through the important parts here since the outer code is only a loop over all levels in the <code class="inlineCode">micLevels</code> vector of the <code class="inlineCode">ModelInstanceCamData</code> struct.</p>
    <p class="normal">For every level in <code class="inlineCode">micLevels</code>, we get the level meshes in the form of optimized meshes for drawing the level. Then, we iterate over all the indices of the level mesh:</p>
    <pre class="programlisting code"><code class="hljs-code">    std::vector&lt;OGLMesh&gt; levelMeshes =
      level-&gt;<span class="hljs-built_in">getLevelMeshes</span>();
      glm::mat4 transformMat =
        level-&gt;<span class="hljs-built_in">getWorldTransformMatrix</span>();
      glm::mat3 normalMat =
        level-&gt;<span class="hljs-built_in">getNormalTransformMatrix</span>();
    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; mesh : levelMeshes) {
      <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; mesh.indices.<span class="hljs-built_in">size</span>(); i += <span class="hljs-number">3</span>) {
</code></pre>
    <p class="normal">For Vulkan, the <code class="inlineCode">levelMeshes</code> vector will contain the <code class="inlineCode">VkMesh</code> data type.</p>
    <p class="normal">We must use the indices to draw the triangles since the triangle data is stored based on indices; using the vertices directly would not give us the correct information to deduce the triangles’ vertices. We also retrieve the world and normal transformation matrices from the level. The normal transformation matrix is just the transpose of the inverse world transform matrix, the <code class="inlineCode">getNormalTransformMatrix()</code> method has been added to keep the additional transformations in the <code class="inlineCode">AssimpLevel</code> class.</p>
    <p class="normal">Next, we create an empty <code class="inlineCode">MeshTriangle</code> and use the transformation matrix of the level to transform the level vertices to the world position:</p>
    <pre class="programlisting code"><code class="hljs-code">        MeshTriangle tri{};
        tri.points.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>) = transformMat *
          glm::<span class="hljs-built_in">vec4</span>(glm::<span class="hljs-built_in">vec3</span>(mesh.vertices.<span class="hljs-built_in">at</span>(
          mesh.indices.<span class="hljs-built_in">at</span>(i)).position), <span class="hljs-number">1.0f</span>);
        tri.points.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>) = transformMat *
          glm::<span class="hljs-built_in">vec4</span>(glm::<span class="hljs-built_in">vec3</span>(mesh.vertices.<span class="hljs-built_in">at</span>(
          mesh.indices.<span class="hljs-built_in">at</span>(i + <span class="hljs-number">1</span>)).position), <span class="hljs-number">1.0f</span>);
        tri.points.<span class="hljs-built_in">at</span>(<span class="hljs-number">2</span>) = transformMat *
          glm::<span class="hljs-built_in">vec4</span>(glm::<span class="hljs-built_in">vec3</span>(mesh.vertices.<span class="hljs-built_in">at</span>(
          mesh.indices.<span class="hljs-built_in">at</span>(i + <span class="hljs-number">2</span>)).position), <span class="hljs-number">1.0f</span>);
</code></pre>
    <p class="normal">Now it is time to create the boundaries for each triangle:</p>
    <pre class="programlisting code"><code class="hljs-code">        AABB triangleAABB;
        triangleAABB.<span class="hljs-built_in">clear</span>();
        triangleAABB.<span class="hljs-built_in">addPoint</span>(tri.points.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>));
        triangleAABB.<span class="hljs-built_in">addPoint</span>(tri.points.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>));
        triangleAABB.<span class="hljs-built_in">addPoint</span>(tri.points.<span class="hljs-built_in">at</span>(<span class="hljs-number">2</span>));
</code></pre>
    <p class="normal">Using an <code class="inlineCode">AABB</code> makes it<a id="_idIndexMarker647"/> easy to calculate the bounding box coordinates. From this <code class="inlineCode">AABB</code>, we create a <code class="inlineCode">BoundingBox3D</code> and store the result in the <code class="inlineCode">boundingBox</code> member of the <code class="inlineCode">MeshTriangle</code> <code class="inlineCode">struct</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">        tri.boundingBox = <span class="hljs-built_in">BoundingBox3D</span>(
          triangleAABB.<span class="hljs-built_in">getMinPos</span>() -
          glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0001f</span>),
          triangleAABB.<span class="hljs-built_in">getMaxPos</span>() -
          triangleAABB.<span class="hljs-built_in">getMinPos</span>() + glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0002f</span>));
</code></pre>
    <p class="normal">Adding a small offset is needed to keep triangles that are coplanar to one of the <code class="inlineCode">X</code>, <code class="inlineCode">Y</code>, or <code class="inlineCode">Z</code> planes in the level. Without the offset, the dimension for the bounding box of a triangle could become zero in one or more dimensions, making it impossible for us to detect collisions with that triangle.</p>
    <p class="normal">Finally, we store and increment the debug index number and add the triangle to the level data octree:</p>
    <pre class="programlisting code"><code class="hljs-code">        tri.index = index++;
        mTriangleOctree-&gt;<span class="hljs-built_in">add</span>(tri);
     }
</code></pre>
    <p class="normal">By calling <code class="inlineCode">generateLevelOctree</code> whenever level data has been added or removed, we assure that our octree has the correct world positions for all triangles. The best way to achieve the update on level changes is to tie the octree update to the already implemented <code class="inlineCode">AABB</code> update for level data.</p>
    <p class="normal">To achieve this coupling, we add a new <code class="inlineCode">private</code> method named <code class="inlineCode">generateLevelVertexData()</code> and call <code class="inlineCode">AABB</code> and octree generation there:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">OGLRenderer::generateLevelVertexData</span><span class="hljs-params">()</span><span class="hljs-function"> </span>{
  <span class="hljs-built_in">generateLevelAABB</span>();
  <span class="hljs-built_in">generateLevelOctree</span>();
}
</code></pre>
    <p class="normal">Then, all occurrences of <code class="inlineCode">generateLevelAABB()</code> are replaced by the new <code class="inlineCode">generateLevelVertexData()</code> method, and whenever the level data or other properties, such as rotation or scaling, are<a id="_idIndexMarker648"/> changed, the level octree is also updated.</p>
    <p class="normal">With an up-to-date level octree, we can finally check if the instances collide with level geometry.</p>
    <h2 id="_idParaDest-351" class="heading-2">Detecting instance/level collisions</h2>
    <p class="normal">By using the same strategy as we used in the <em class="italic">Adding a quadtree to store nearby model instances</em> section in <a href="Chapter_8.xhtml"><em class="italic">Chapter 8</em></a>, for instance/instance collisions, finding collisions between instances and level triangles is easy. All we must do is loop over all instances, get the bounding box of the instance, and query the<a id="_idIndexMarker649"/> triangle octree for collisions with that bounding box. The octree delivers us all the triangles where the bounding box of the triangle collides with the bounding box of the instance, even if the instance is not stored inside the triangle octree.</p>
    <p class="normal">To implement collision detection between instances and level data, follow these steps:</p>
    <ol>
      <li class="numberedList" value="1">First, we add a new member named <code class="inlineCode">isCollidingTriangles</code> to the <code class="inlineCode">InstanceSettings</code> <code class="inlineCode">struct</code> in the <code class="inlineCode">InstanceSettings.h</code> file to store the colliding triangles:
        <pre class="programlisting code-one"><code class="hljs-code">  std::vector&lt;MeshTriangle&gt; isCollidingTriangles{};
</code></pre>
      </li>
      <li class="numberedList">Then, a new <code class="inlineCode">public</code> method called <code class="inlineCode">setCollidingTriangles()</code> of the <code class="inlineCode">AssimpInstance</code> class is created, storing the incoming triangle data in the instance settings:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">AssimpInstance::setCollidingTriangles</span><span class="hljs-params">(</span>
<span class="hljs-params">    std::vector&lt;MeshTriangle&gt;&amp; collidingTriangles)</span><span class="hljs-function"> </span>{
  mInstanceSettings.isCollidingTriangles =
   collidingTriangles;
}
</code></pre>
      </li>
      <li class="numberedList">Next, we create a new private method called <code class="inlineCode">checkForLevelCollisions()</code> in the renderer. We start by getting the instance settings and skipping the null instance:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">OGLRenderer::checkForLevelCollisions</span><span class="hljs-params">()</span><span class="hljs-function"> </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; instance :
      mModelInstCamData.micAssimpInstances) {
    InstanceSettings instSettings =
      instance-&gt;<span class="hljs-built_in">getInstanceSettings</span>();
    <span class="hljs-keyword">if</span> (instSettings.isInstanceIndexPosition == <span class="hljs-number">0</span>)
      <span class="hljs-keyword">continue</span>;
    }
</code></pre>
      </li>
      <li class="numberedList">Then, we simply query the triangle octree with the bounding box of the instances:
        <pre class="programlisting code-one"><code class="hljs-code">    std::vector&lt;MeshTriangle&gt; collidingTriangles =
      mTriangleOctree→<span class="hljs-built_in">query</span>(instance-&gt;<span class="hljs-built_in">getBoundingBox</span>());
</code></pre>
      </li>
      <li class="numberedList">Just knowing that <a id="_idIndexMarker650"/>we have collisions is nice, but we want to store the collision data for further actions, such as reacting to collisions or drawing debug lines. So, we store the vector of <code class="inlineCode">MeshTriangles</code> in the instance settings:
        <pre class="programlisting code-one"><code class="hljs-code">    instances.<span class="hljs-built_in">at</span>(i)-&gt;<span class="hljs-built_in">setCollidingTriangles</span>(
      collidingTriangles);
  }
}
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The method <code class="inlineCode">checkForLevelCollisions()</code> is called to the <code class="inlineCode">draw()</code> method of the renderer, after the instances have been rendered and before the UI is drawn. Now all instances are checked in every frame for collisions with the level geometry, and if colliding triangles were found, we store them in the <code class="inlineCode">InstanceSettings</code> of the instance.</p>
    <p class="normal">Although you could have trust in the general functionality of collision detection to work, seeing is believing. We add extra debug lines for the various level data now, allowing us to draw viable information as overlaying lines on the screen.</p>
    <h2 id="_idParaDest-352" class="heading-2">Drawing debug lines</h2>
    <p class="normal">If we would like to see<a id="_idIndexMarker651"/> the collisions in real time on the screen, we can highlight the affected triangles in the level geometry. To achieve this highlighting, we will follow these steps:</p>
    <ol>
      <li class="numberedList" value="1">We add a new <code class="inlineCode">private</code> member, <code class="inlineCode">mLevelCollidingTriangleMesh</code>, to store the colliding triangle meshes to the renderer:
        <pre class="programlisting code-one"><code class="hljs-code">    std::shared_ptr&lt;OGLLineMesh&gt;
      mLevelCollidingTriangleMesh = <span class="hljs-literal">nullptr</span>;
</code></pre>
      </li>
      <li class="numberedList">Then, in <code class="inlineCode">checkForLevelCollisions()</code>, we clear the mesh:
        <pre class="programlisting code-one"><code class="hljs-code">  mLevelCollidingTriangleMesh-&gt;vertices.<span class="hljs-built_in">clear</span>();
</code></pre>
      </li>
      <li class="numberedList">Next, we iterate over all colliding triangles, adding the vertices pairwise to the mesh storage to create a line for every side of the triangle:
        <pre class="programlisting code-one"><code class="hljs-code">   <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; tri : collidingTriangles) {
     OGLLineVertex vert;
     vert.color = glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>);
     vert.position = glm::<span class="hljs-built_in">vec4</span>(tri.points.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>), <span class="hljs-number">1.0f</span>);
     mLevelCollidingTriangleMesh-&gt;vertices.<span class="hljs-built_in">push_back</span>(vert);
     vert.position = glm::<span class="hljs-built_in">vec4</span>(tri.points.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>), <span class="hljs-number">1.0f</span>);
     mLevelCollidingTriangleMesh-&gt;vertices.<span class="hljs-built_in">push_back</span>(vert);
     vert.position = glm::<span class="hljs-built_in">vec4</span>(tri.points.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>), <span class="hljs-number">1.0f</span>);
     mLevelCollidingTriangleMesh-&gt;vertices.<span class="hljs-built_in">push_back</span>(vert);
     vert.position = glm::<span class="hljs-built_in">vec4</span>(tri.points.<span class="hljs-built_in">at</span>(<span class="hljs-number">2</span>), <span class="hljs-number">1.0f</span>);
     mLevelCollidingTriangleMesh-&gt;vertices.<span class="hljs-built_in">push_back</span>(vert);
     vert.position = glm::<span class="hljs-built_in">vec4</span>(tri.points.<span class="hljs-built_in">at</span>(<span class="hljs-number">2</span>), <span class="hljs-number">1.0f</span>);
     mLevelCollidingTriangleMesh-&gt;vertices.<span class="hljs-built_in">push_back</span>(vert);
     vert.position = glm::<span class="hljs-built_in">vec4</span>(tri.points.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>), <span class="hljs-number">1.0f</span>);
     mLevelCollidingTriangleMesh-&gt;vertices.<span class="hljs-built_in">push_back</span>(vert);
  }
</code></pre>
      </li>
      <li class="numberedList">Now we have saved the outlines of the detected triangles for all instances. Rendering the<a id="_idIndexMarker652"/> triangles to the screen can be done with a simple line draw call:
        <pre class="programlisting code-one"><code class="hljs-code">mLineVertexBuffer.<span class="hljs-built_in">uploadData</span>(*mLevelCollidingTriangleMesh);
  <span class="hljs-keyword">if</span> (mLevelCollidingTriangleMesh-&gt;vertices.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) {
    mLineShader.<span class="hljs-built_in">use</span>();
    mLineVertexBuffer.<span class="hljs-built_in">bindAndDraw</span>(GL_LINES, <span class="hljs-number">0</span>,
      mLevelCollidingTriangleMesh-&gt;vertices.<span class="hljs-built_in">size</span>());
  }
</code></pre>
      </li>
    </ol>
    <p class="normal">Running the application with instance/level collision and debug drawing results in a picture similar to <em class="italic">Figure 12.1</em>:</p>
    <figure class="mediaobject"><img src="../Images/figure_12_01.png" alt="" width="1144" height="1060"/></figure>
    <p class="packt_figref">Figure 12.1: Collision between an instance and the level geometry</p>
    <p class="normal">In <em class="italic">Figure 12.1</em>, the instance collides with the ground and several walls. All the triangles were detected by using their <a id="_idIndexMarker653"/>bounding boxes, so don’t be alarmed if a triangle is highlighted while the instance is still a bit away from the triangle itself. In this case, the bounding box of the triangle was hit, spanning a larger area than the triangle itself. But the number of false positives among the detected collisions is low and may only affect the performance of the collision detection by a small amount.</p>
    <p class="normal">To add a proper reaction of the instance to a collision with the level geometry, we will enhance the node tree next.</p>
    <h2 id="_idParaDest-353" class="heading-2">Extending the node tree to support level geometry collisions</h2>
    <p class="normal">Thanks to the good foundation built in the last chapters, adding a new collision type takes a matter of minutes by<a id="_idIndexMarker654"/> following these steps:</p>
    <ol>
      <li class="numberedList" value="1">First, we add the new event type to the <code class="inlineCode">nodeEvent</code> <code class="inlineCode">enum</code> in the <code class="inlineCode">Enums.h</code> file:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-keyword">enum class</span> <span class="hljs-title">nodeEvent</span> : <span class="hljs-type">uint8_t</span> {
  ...
<span class="code-highlight"><strong class="hljs-slc">  instanceToLevelCollision,</strong></span>
  NUM
};
</code></pre>
      </li>
      <li class="numberedList">We also add some text to the <code class="inlineCode">micNodeUpdateMap</code> during the <code class="inlineCode">init()</code> method of the renderer to add a name in the node tree:
        <pre class="programlisting code-one"><code class="hljs-code">  mModelInstCamData.micNodeUpdateMap[
    nodeEvent::instanceToLevelCollision] =
    <span class="hljs-string">“Inst to Level collision”</span>;
</code></pre>
      </li>
      <li class="numberedList">Then, in <code class="inlineCode">checkForLevelCollisions()</code>, trigger the new event if we have at least one colliding triangle:
        <pre class="programlisting code-one"><code class="hljs-code">    <span class="hljs-keyword">if</span> (collidingTriangles.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) {
      mModelInstCamData.<span class="hljs-built_in">micNodeEventCallbackFunction</span>(
        instSettings.isInstanceIndexPosition,
        nodeEvent::instanceToLevelCollision);
    }
</code></pre>
      </li>
      <li class="numberedList">The event informs <a id="_idIndexMarker655"/>the node tree of the instance that a collision with level geometry occurred. As an example, we could just let the instance turn around by 180 degrees, as shown in <em class="italic">Figure 12.2</em>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/figure_12_02.png" alt="" width="836" height="917"/></figure>
    <p class="packt_figref">Figure 12.2: An Event node reacting to instance/level collisions</p>
    <p class="normal-one">In the Event node in <em class="italic">Figure 12.2</em>, the instance would instantly turn around when running into a collision with the level. Also, a cooldown of 250 milliseconds has been added. Using a cooldown should give the instance a bit of time to walk far enough away from the affected level geometry to avoid immediately re-triggering a level collision.</p>
    <p class="normal">But right now, collision detection has a huge drawback: the instances keep walking at the same height level, thus running through hills or walking in the air when the elevation changes.</p>
    <p class="normal">To keep the instances on the ground, let’s add a simple form of gravity to the application.</p>
    <h1 id="_idParaDest-354" class="heading-1">Using gravity to keep the instances on the floor</h1>
    <p class="normal">Gravity is literally always around <a id="_idIndexMarker656"/>us, accelerating objects downwards until they hit some other, immovable object, such as the ground. We mostly don’t realize the effects of gravity while walking around or standing still; we only realize its power when something falls down and most probably breaks when it hits the ground.</p>
    <p class="normal">Before we can add gravity, we need to find a way to detect if a triangle in the level geometry belongs to the ground or not.</p>
    <h2 id="_idParaDest-355" class="heading-2">Finding ground triangles in level data</h2>
    <p class="normal">For real-world levels, extra attributes could be used to mark areas of a level as walkable or not. Since we want to keep the ground-level technique as generic as possible, we will use a different approach and use the<a id="_idIndexMarker657"/> triangle normal to check if the area around us belongs to the floor or a wall, and up to which angle a sloped area can be walked on.</p>
    <p class="normal">We store the <code class="inlineCode">normal</code> of each triangle as 3-element vector inside the <code class="inlineCode">MeshTriangle</code> <code class="inlineCode">struct</code>, along with the other triangle data:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span> <span class="hljs-title">MeshTriangle</span> {
  ...
<span class="code-highlight"><strong class="hljs-slc">  glm::vec3 normal;</strong></span>
  BoundingBox3D boundingBox;
};
</code></pre>
    <p class="normal">When generating the triangle octree in <code class="inlineCode">generateLevelOctree()</code>, the normal from the first vertex of the triangle is taken:</p>
    <pre class="programlisting code"><code class="hljs-code">        tri.normal = glm::<span class="hljs-built_in">normalize</span>(normalMat *
          glm::<span class="hljs-built_in">vec3</span>(mesh.vertices.<span class="hljs-built_in">at</span>(
          mesh.indices.<span class="hljs-built_in">at</span>(i)).normal));
</code></pre>
    <p class="normal">Due to the indexed structure of the level data, using one of the normals of the vertices could lead to artifacts caused by reusing the same vertex for different triangles. In this case, we could alter the calculation of the normal to be the cross product of two edges of every triangle:</p>
    <pre class="programlisting code"><code class="hljs-code">        glm::vec3 edge1 = glm::<span class="hljs-built_in">vec3</span>(mesh.vertices.<span class="hljs-built_in">at</span>(
          mesh.indices.<span class="hljs-built_in">at</span>(i + <span class="hljs-number">1</span>)).position -
          mesh.vertices.<span class="hljs-built_in">at</span>(mesh.indices.<span class="hljs-built_in">at</span>(i)).position);
        glm::vec3 edge2 = glm::<span class="hljs-built_in">vec3</span>(mesh.vertices.<span class="hljs-built_in">at</span>(
          mesh.indices.<span class="hljs-built_in">at</span>(i + <span class="hljs-number">2</span>)).position -
          mesh.vertices.<span class="hljs-built_in">at</span>(mesh.indices.<span class="hljs-built_in">at</span>(i)).position);
        tri.normal = glm::<span class="hljs-built_in">normalize</span>(normalMat *
          glm::<span class="hljs-built_in">cross</span>(edge1, edge2));
</code></pre>
    <p class="normal">To be able to control the ground slope in the user interface, we add a new variable called <code class="inlineCode">rdMaxLevelGroundSlopeAngle</code> to the <code class="inlineCode">OGLRenderData</code> <code class="inlineCode">struct</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-type">float</span> rdMaxLevelGroundSlopeAngle = <span class="hljs-number">0.0f</span>;
</code></pre>
    <p class="normal">For Vulkan, as always, the variable will be added to the <code class="inlineCode">VkRenderData</code> <code class="inlineCode">struct</code>.</p>
    <p class="normal">Then, in <code class="inlineCode">checkForLevelCollisions()</code>, we add a new check to find out if the angle between an upward-pointing <a id="_idIndexMarker658"/>vector and the normal of the triangle is larger than the maximum configurable ground slope:</p>
    <pre class="programlisting code"><code class="hljs-code">      <span class="hljs-keyword">if</span> (glm::<span class="hljs-built_in">dot</span>(tri.normal, glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>))
         &gt;= glm::<span class="hljs-built_in">cos</span>(glm::<span class="hljs-built_in">radians</span>(
         mRenderData.rdMaxLevelGroundSlopeAngle))) {
</code></pre>
    <p class="normal">Inside the <code class="inlineCode">if</code> block, we can now limit the event sending code to be triggered only for walls, no longer for ground triangles. We also change the color of the debug lines for triangles detected as ground triangles to blue while wall triangles remain red:</p>
    <pre class="programlisting code"><code class="hljs-code">        vertexColor = glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>);
     } <span class="hljs-keyword">else</span> {
        vertexColor = glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>);
        mModelInstCamData.<span class="hljs-built_in">micNodeEventCallbackFunction</span>(
          instSettings.isInstanceIndexPosition,
          nodeEvent::instanceToLevelCollision);
        }
</code></pre>
    <p class="normal">In the <strong class="screenText">Levels...</strong> section of the <code class="inlineCode">UserInterface</code> class, we add a float slider to enable controlling the maximum ground slope interactively:</p>
    <pre class="programlisting code"><code class="hljs-code">    ImGui::<span class="hljs-built_in">Text</span>(<span class="hljs-string">"</span><span class="hljs-string">Max Ground Slope:"</span>);
    ImGui::<span class="hljs-built_in">SameLine</span>();
    ImGui::<span class="hljs-built_in">SliderFloat</span>(<span class="hljs-string">"##MaxSlope"</span>,
      &amp;renderData.rdMaxLevelGroundSlopeAngle,
      <span class="hljs-number">0.0f</span>, <span class="hljs-number">45.0f</span>, <span class="hljs-string">"%.2f"</span>, flags);
</code></pre>
    <p class="normal">Now the application draws collisions with walls and ground in different colors, as shown in <em class="italic">Figure 12.3</em>:</p>
    <figure class="mediaobject"><img src="../Images/figure_12_03.png" alt="" width="1400" height="979"/></figure>
    <p class="packt_figref">Figure 12.3: Separate collisions for ground and walls</p>
    <p class="normal">As you can see in <em class="italic">Figure 12.3</em>, wall collisions are now marked by red triangle edges, while ground collisions are highlighted by blue triangle edges. The slope angle can be configured by a slider, allowing finetuning of which slope of a hill or edge will be still seen as the ground.</p>
    <p class="normal">In addition to the distinct colors for collisions between instances and walls or the ground, the event reporting also <a id="_idIndexMarker659"/>differs. For a ground collision, no instance/level geometry collision event will be generated, allowing the instances to run around in the level and only collide with walls.</p>
    <p class="normal">After we can check if an instance collides with a ground polygon, it’s time to add the gravity to the code.</p>
    <h2 id="_idParaDest-356" class="heading-2">Adding basic gravity</h2>
    <p class="normal">For our application, we are<a id="_idIndexMarker660"/> using only simple gravity. We just move the instance down by some amount every frame, without thinking about more complex patterns, such as acceleration over time. If you want to implement more details, the <em class="italic">Addition resources</em> section contains the ISBNs of books that dive into advanced physics and collision detection topics. Also, a task in the <em class="italic">Practical sessions</em> section implements enhanced gravity.</p>
    <p class="normal">To be able to add a gravity effect to an instance, we create a new <code class="inlineCode">public</code> method named <code class="inlineCode">applyGravity()</code> to the <code class="inlineCode">AssimpInstance</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">AssimpInstance::applyGravity</span><span class="hljs-params">(</span><span class="hljs-type">float</span><span class="hljs-params"> deltaTime)</span><span class="hljs-function"> </span>{
  glm::vec3 gravity =
    glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">GRAVITY_CONSTANT</span> * deltaTime, <span class="hljs-number">0.0f</span>);
  mInstanceSettings.isWorldPosition -= gravity;
} 
</code></pre>
    <p class="normal">The private variable <code class="inlineCode">GRAVITY_CONSTANT</code> is defined in the <code class="inlineCode">AssimpInstance.h</code> header and set to <code class="inlineCode">9.81</code>, similar to the real gravity on earth. The gravity is then applied in the instances loop in the <code class="inlineCode">draw()</code> method of the renderer:</p>
    <pre class="programlisting code"><code class="hljs-code">          <span class="hljs-keyword">if</span> (mRenderData.rdEnableSimpleGravity) {
            instances.<span class="hljs-built_in">at</span>(i)-&gt;<span class="hljs-built_in">applyGravity</span>(deltaTime);
          }
</code></pre>
    <p class="normal">The <code class="inlineCode">rdEnableSimpleGravity</code> variable <a id="_idIndexMarker661"/>has been added to the <code class="inlineCode">OGLRenderData</code> <code class="inlineCode">struct</code> in the <code class="inlineCode">OGLRenderData.h</code> file for OpenGL, and to the <code class="inlineCode">VkRenderData</code> <code class="inlineCode">struct</code> in the <code class="inlineCode">VkRenderData.h</code> header for Vulkan.</p>
    <p class="normal">In the <strong class="screenText">Levels...</strong> collapsing header of the <code class="inlineCode">createFrame()</code> method in the <code class="inlineCode">UserInterface</code> class, a checkbox is used to control the gravity:</p>
    <pre class="programlisting code"><code class="hljs-code">    ImGui::<span class="hljs-built_in">Text</span>(<span class="hljs-string">"Simple Gravity:  "</span>);
    ImGui::<span class="hljs-built_in">SameLine</span>();
    ImGui::<span class="hljs-built_in">Checkbox</span>(<span class="hljs-string">"##EnableGravity"</span>,
      &amp;renderData.rdEnableSimpleGravity);
</code></pre>
    <p class="normal">We will use this checkbox to prevent all instances from falling when no level geometry is loaded.</p>
    <p class="normal">One last step is needed to enable instances to roam around on the floor of the levels. Let’s create the final parts of the code the finish the ground handling for the instances.</p>
    <h2 id="_idParaDest-357" class="heading-2">Keeping the instances on the ground triangles</h2>
    <p class="normal">With the code from the previous sections of this chapter, we can detect collisions between instances and level walls and floors <a id="_idIndexMarker662"/>and the handle wall collision. For ground collisions, we need special handling since the instance will, most of the time, stay on the floor of the level.</p>
    <p class="normal">A naive idea for ground collision would be to move the instance upward a bit after gravity is applied. Sadly, applying gravity and moving the instance back leads to oscillations if the amounts of vertical movement are not identical. But instead of moving the instance up, we can avoid applying gravity in the first place, leaving the instance on the ground triangle once the collision is detected.</p>
    <p class="normal">The functionality to keep instances on the ground triangles of the level will be implemented by the following steps:</p>
    <ol>
      <li class="numberedList" value="1">For every instance, we store the “on ground” state by using a new Boolean variable named <code class="inlineCode">isInstanceOnGround</code> in the <code class="inlineCode">InstanceSettings</code> <code class="inlineCode">struct</code> in the <code class="inlineCode">InstanceSettings.h</code> file:
        <pre class="programlisting code-one"><code class="hljs-code">  <span class="hljs-type">bool</span> isInstanceOnGround = <span class="hljs-literal">false</span>;
</code></pre>
      </li>
      <li class="numberedList">In the <code class="inlineCode">AssimpInstance</code> class, a <code class="inlineCode">public</code> setter for the state will be added too:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">AssimpInstance::setInstanceOnGround</span><span class="hljs-params">(</span><span class="hljs-type">bool</span><span class="hljs-params"> value)</span><span class="hljs-function"> </span>{
  mInstanceSettings.isInstanceOnGround = value;
}
</code></pre>
      </li>
      <li class="numberedList">Then we update the <code class="inlineCode">applyGravity()</code> method to disable adding the gravity to the vertical position if the instance is found to reside on the ground:
        <pre class="programlisting code-one"><code class="hljs-code">    <span class="hljs-keyword">if</span> (!mInstanceSettings.isInstanceOnGround) {
      mInstanceSettings.isWorldPosition -= gravity;
    }
</code></pre>
      </li>
    </ol>
    <p class="normal-one">To set the <code class="inlineCode">isInstanceOnGround</code> instance variable in the renderer, a new checking code will be added to the <code class="inlineCode">draw()</code> method of the renderer, right below the <code class="inlineCode">query()</code> call to the triangle octree. This <a id="_idIndexMarker663"/>way, we make sure we are using the most recent triangle colliding data.</p>
    <ol>
      <li class="numberedList" value="4">First, we set the local <code class="inlineCode">instanceOnGround</code> Boolean to <code class="inlineCode">true</code>, which prevents instances from falling if the gravity is disabled. Next, we calculate the gravity with the same formula as the instance, and we initialize the current <code class="inlineCode">footPoint</code> of the instance with the world position:
        <pre class="programlisting code-one"><code class="hljs-code">    <span class="hljs-type">bool</span> instanceOnGround = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">if</span> (mRenderData.rdEnableSimpleGravity) {
      glm::vec3 gravity =
        glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">9.81</span> * deltaTime, <span class="hljs-number">0.0f</span>);
      glm::vec3 footPoint =
        instSettings.isWorldPosition;
</code></pre>
      </li>
    </ol>
    <p class="normal-one">We need the foot point in the next step to have a valid position for the instance in case the ground detection fails.</p>
    <ol>
      <li class="numberedList" value="5">Now, we set <code class="inlineCode">instanceOnGround</code> to false as the default setting for ground-level detection, and we iterate over all colliding triangles:
        <pre class="programlisting code-one"><code class="hljs-code">        instanceOnGround = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; tri : collidingTriangles) {
</code></pre>
      </li>
      <li class="numberedList">Then, the same angle check between the normal vector of the triangle and an upwards pointing vector as in <code class="inlineCode">checkForLevelCollisions()</code> is used to find out if the triangle is a ground triangle and thus considered walkable:
        <pre class="programlisting code-one"><code class="hljs-code">          <span class="hljs-keyword">if</span> (glm::<span class="hljs-built_in">dot</span>(tri.normal, glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>,
            <span class="hljs-number">0.0f</span>)) &gt;= glm::<span class="hljs-built_in">cos</span>(glm::<span class="hljs-built_in">radians</span>(
            mRenderData.rdMaxLevelGroundSlopeAngle))) {
</code></pre>
      </li>
      <li class="numberedList">If the triangle is walkable ground, we try to get the intersection between a virtual ray pointing <a id="_idIndexMarker664"/>upwards, originating from the instance after it has already been sunk slightly into the ground:
        <pre class="programlisting code-one"><code class="hljs-code">              std::optional&lt;glm::vec3&gt; result =
                Tools::<span class="hljs-built_in">rayTriangleIntersection</span>(
                instSettings.isWorldPosition – gravity,
                glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>), tri);
                <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">has_value</span>()) {
                  footPoint = result.<span class="hljs-built_in">value</span>();
                  instances.<span class="hljs-built_in">at</span>(i)-&gt;<span class="hljs-built_in">setWorldPosition</span>(
                    footPoint);
                  instanceOnGround = <span class="hljs-literal">true</span>;
               }
             }
</code></pre>
      </li>
    </ol>
    <p class="normal-one">Checking the instance after applying the gravity value is required because no collision will be reported if the instance is exactly at the same level as the ground triangle.</p>
    <p class="normal-one">The helper function <code class="inlineCode">rayTriangleIntersection()</code> in the <code class="inlineCode">Tools</code> class implements the Möller-Trumbore algorithm to find an intersection between a ray and a triangle. This algorithm detects if a ray intersects the triangle and returns the exact point of the intersection.</p>
    <p class="normal-one">A visualization of the algorithm is shown in <em class="italic">Figure 12.4</em>:</p>
    <figure class="mediaobject"><img src="../Images/figure_12_04.png" alt="" width="674" height="670"/></figure>
    <p class="packt_figref">Figure 12.4: Visualization of the Möller-Trumbore algorithm</p>
    <p class="normal-one">The Möller-Trumbore algorithm uses the barycentric coordinates of the triangle created by the three vertices <code class="inlineCode">V0</code>, <code class="inlineCode">V1</code>, and <code class="inlineCode">V2</code> to check if the ray is inside or outside of the triangle. To simplify the detection process, the algorithm transforms both the triangle vertices and the ray so that two of the triangle sides are mapped to the <code class="inlineCode">X</code> and <code class="inlineCode">Y</code> axes of the Cartesian coordinate system, defining a unit triangle. The barycentric coordinates of the intersection point stay intact during these transformations. The final test for intersection just needs to <a id="_idIndexMarker665"/>check if the <code class="inlineCode">x</code> and <code class="inlineCode">y</code> coordinates of the intersection point are inside the triangle by testing for valid barycentric coordinates. A link to the mathematical backgrounds of the algorithm is available in the <em class="italic">Additional resources</em> section.</p>
    <ol>
      <li class="numberedList" value="8">As the last step in the <code class="inlineCode">draw()</code> call part of the new renderer code, we set the ground flag to the instance and apply the gravity:
        <pre class="programlisting code-one"><code class="hljs-code">    instances.<span class="hljs-built_in">at</span>(i)-<span class="hljs-built_in">setInstanceOnGround</span>(instanceOnGround);
    instances.<span class="hljs-built_in">at</span>(i)-&gt;<span class="hljs-built_in">applyGravity</span>(deltaTime);
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The extra check for <code class="inlineCode">rdEnableSimpleGravity</code> around <code class="inlineCode">applyGravity()</code> that was added in the <em class="italic">Adding basic gravity</em> section can be removed. We already ensure that no gravity will be added if <code class="inlineCode">rdEnableSimpleGravity</code> is <code class="inlineCode">false</code> by setting the default value of <code class="inlineCode">instanceOnGround</code> to <code class="inlineCode">true</code>.</p>
    <p class="normal">Running the application with collision triangle debug draw enabled and the ground slope adjusted will result in an image similar to <em class="italic">Figure 12.5</em>:</p>
    <figure class="mediaobject"><img src="../Images/figure_12_05.png" alt="" width="1350" height="782"/></figure>
    <p class="packt_figref">Figure 12.5: Instances walking at different heights of the level</p>
    <p class="normal">In <em class="italic">Figure 12.5</em>, we can see that the instances are walking on their own level, with the left instance climbing up a small slope. In the running application, you will see that climbing down a hill is also working as expected.</p>
    <p class="normal">After level gravity is enabled, the instances are running on the level floor. But on an uneven floor, one either intersects with the floor when going up a hill, or one of the feet is still in the air when going down a slope. You can see this effect on the right foot of the left instance: the entire foot is clipping into<a id="_idIndexMarker666"/> the ground triangle.</p>
    <p class="normal">Let’s fix the instance feet by adding inverse kinematics.</p>
    <h1 id="_idParaDest-358" class="heading-1">Adding inverse kinematics</h1>
    <p class="normal">The word “kinematics” is defined as the mechanics behind the motion of an object, but without referencing the forces that <a id="_idIndexMarker667"/>cause this motion. So, every part of our daily motion can be described in terms of kinematics as the movement of our bones.</p>
    <h2 id="_idParaDest-359" class="heading-2">The two types of kinematics</h2>
    <p class="normal">The type of animation of our<a id="_idIndexMarker668"/> characters in the previous chapters is called <strong class="keyWord">forward kinematics</strong>. An <a id="_idIndexMarker669"/>example of forward kinematics is shown in <em class="italic">Figure 12.6</em>:</p>
    <figure class="mediaobject"><img src="../Images/figure_12_06.png" alt="" width="878" height="443"/></figure>
    <p class="packt_figref">Figure 12.6: Raising the hand of the simple skeleton by using Forward Kinematics</p>
    <p class="normal">The skeleton in <em class="italic">Figure 12.6</em> raises its simplified hand by rotating at bone number one, the shoulder, and number two, the elbow.</p>
    <p class="normal">During the movement or rotation of the skeletal bone, all the other nodes attached to it are also affected. Rotating the arm <a id="_idIndexMarker670"/>around the shoulder does not change the elbow or the forearm, as we only change one bone at a time. Next, the forearm is rotated around the elbow, bringing the hand to the final position. This final position of the hand is defined by the concatenation of the changes of all the bones before the hand.</p>
    <p class="normal">But… what happens if we only know the desired final position of the hand?</p>
    <p class="normal">If we want to move the hand of the skeleton in <em class="italic">Figure 12.7</em> to the green target point, or we want to put the foot onto the green target block, our only option with forward kinematics would be trial and error.</p>
    <figure class="mediaobject"><img src="../Images/figure_12_07.png" alt="" width="874" height="537"/></figure>
    <p class="packt_figref">Figure 12.7: How to move the hand to the target, or put the foot on the box?</p>
    <p class="normal">We would have to adjust all the nodes on the arm or the leg over and over again until we reach a matching position. This is <a id="_idIndexMarker671"/>where <strong class="keyWord">inverse kinematics</strong> comes into play. Instead of rotating the nodes directly, we calculate bone positions matching the final movement and read the node rotations from the final bone positions,</p>
    <p class="normal">In inverse kinematics, the name <strong class="keyWord">effector</strong> is used <a id="_idIndexMarker672"/>to describe the part of the skeleton that should reach the <strong class="keyWord">target</strong>. If the target is <a id="_idIndexMarker673"/>too far away to be reached by the effector node, we should at least try to find a position as close as possible to the target. In addition to effector and target, a <strong class="keyWord">root node</strong> must be chosen. The<a id="_idIndexMarker674"/> root node is<a id="_idIndexMarker675"/> the first unchanged node of the skeleton.</p>
    <p class="normal">Although many inverse kinematics solver algorithms have been created, we will use one of the basic <a id="_idIndexMarker676"/>algorithms: FABRIK, the <strong class="keyWord">Forward And Backward Reaching Inverse Kinematics</strong> solver. FABRIK is easy to understand and implement and finds good solutions for the nodes. So, let’s dive into inverse kinematics with FABRIK.</p>
    <h2 id="_idParaDest-360" class="heading-2">Understanding the FABRIK basics</h2>
    <p class="normal">FABRIK was introduced in 2011 by Dr. Andreas Aristidou. The FABRIK algorithm solves the inverse kinematics problem by moving the nodes of a bone chain one by one closer to the target and then rescaling the <a id="_idIndexMarker677"/>bones back to the original length. Also, FABRIK moves along the chain of bones in both directions, forward and backward, hence its name.</p>
    <p class="normal">We will use a simple robotics arm to describe the steps to solve an inverse kinematics problem with FABRIK. Four nodes of the arm define three bones, and the target and the effector were drawn in every step, with the blue node attached to the ground as the root node and the outer red node used as the effector. All the steps are shown in <em class="italic">Figure 12.8</em> to <em class="italic">Figure 12.11</em>.</p>
    <p class="normal">Let’s step through a single iteration of the algorithm. First, we will examine the <em class="italic">forward</em> solving part of FABRIK.</p>
    <figure class="mediaobject"><img src="../Images/figure_12_08.png" alt="" width="1159" height="414"/></figure>
    <p class="packt_figref">Figure 12.8: Doing inverse kinematics using FABRIK forward iteration – part 1</p>
    <p class="normal">The start situation is shown in <em class="italic">Figure 12.8</em> (<strong class="screenText">1</strong>):</p>
    <ol>
      <li class="numberedList" value="1">As shown in <em class="italic">Figure 12.8</em> (<strong class="screenText">2</strong>), we will <em class="italic">move</em> the effector to the position of the target as the first step. You can see that moving the node stretches the red bone far beyond its original length.</li>
      <li class="numberedList">We must correct the length of the red bone, so we need to save the length of our bone before moving the<a id="_idIndexMarker678"/> effector. By using the saved length, we scale the red bone back to its original length, right after the effector has been moved, as shown in <em class="italic">Figure 12.8</em> (<strong class="screenText">3</strong>). Scaling back the red bone to the previous length rips apart our robotics arm, as seen in <em class="italic">Figure 12.8</em> (<strong class="screenText">3</strong>), but this is an intended behavior during a FABRIK iteration.</li>
      <li class="numberedList">Then, we will move the outer node of the purple bone back to the end of the red bone, scaling it again to an arbitrary length. <em class="italic">Figure 12.8</em> (<strong class="screenText">4</strong>) shows the result after the robotics arm has been reconnected.</li>
      <li class="numberedList">The purple bone is scaled back to its previous length, as shown in <em class="italic">Figure 12.9</em> (<strong class="screenText">5</strong>), moving the end node away from the blue bone.</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/figure_12_09.png" alt="" width="1126" height="408"/></figure>
    <p class="packt_figref">Figure 12.9: Inverse kinematics using FABRIK forward iteration – part 2</p>
    <ol>
      <li class="numberedList" value="5">Finally, we will repeat <em class="italic">steps 4</em> and <em class="italic">5</em> of the purple bone movement with the blue bone. We will <a id="_idIndexMarker679"/>reconnect the arm every time and scale the bone back to its original length, as shown in <em class="italic">Figure 12.9</em> (<strong class="screenText">6</strong>) and <em class="italic">Figure 12.9</em> (<strong class="screenText">7</strong>).</li>
    </ol>
    <p class="normal-one"><em class="italic">Figure 12.9</em> (<strong class="screenText">8</strong>) shows the result after the <em class="italic">forward</em> steps of the FABRIK algorithm are finished. But having the robotic arm disconnected from the ground is not the result we want. To fix the arm, we will repeat the same steps, but this time <em class="italic">backward</em> on the same chain of bones.</p>
    <p class="normal-one">In the <em class="italic">backward</em> part of FABRIK, we will swap the target, effector node, and root node. We use the original connection point of the arm as the target, the end of the blue bone becomes the effector, and the original effector node is the new root node.</p>
    <ol>
      <li class="numberedList" value="6">As the first step in the backward operation, we will reconnect the arm to the ground, as shown in <em class="italic">Figure 12.10</em> (<strong class="screenText">9</strong>).</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/figure_12_10.png" alt="" width="1124" height="412"/></figure>
    <p class="packt_figref">Figure 12.10: Inverse kinematics using FABRIK backward iteration – part 1</p>
    <ol>
      <li class="numberedList" value="7">Then, we scale the blue bone back to its previous size and move the purple bone in the same way as we did initially in <em class="italic">steps 2</em> and <em class="italic">3</em>. In <em class="italic">Figure 12.10</em> (<strong class="screenText">10</strong>), <em class="italic">Figure 12.10</em> (<strong class="screenText">11</strong>), and <em class="italic">Figure 12.10</em> (<strong class="screenText">12</strong>), the results of adjusting the blue and purple bones are shown.</li>
      <li class="numberedList">Now, the lower node<a id="_idIndexMarker680"/> of the red bone will move, and the red bone is scaled back to its previous size, as shown in <em class="italic">Figure 12.11</em> (<strong class="screenText">13</strong>) and <em class="italic">Figure 12.11</em> (<strong class="screenText">14</strong>).</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/figure_12_11.png" alt="" width="874" height="407"/></figure>
    <p class="packt_figref">Figure 12.11: Inverse kinematics using FABRIK backward iteration - part 2</p>
    <p class="normal-one"><em class="italic">Figure 12.11</em> (<strong class="screenText">14</strong>) moves the effector away from the position of the target, but again, this is the intended behavior in FABRIK if the target cannot be reached. In <em class="italic">Figure 12.11</em> (<strong class="screenText">15</strong>), a single FABRIK iteration has ended.</p>
    <p class="normal-one">For the next iterations of FABRIK, <em class="italic">steps 2</em> to <em class="italic">9</em> are repeated until the effector node reaches the target position, or until we hit the maximum number of iterations.</p>
    <p class="normal">By using simple pseudo-code, FABRIK can be melted down to this procedure:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-variable">NodePositions</span> <span class="hljs-operator">:=</span> <span class="hljs-variable">OrigNodePositions</span>
<span class="hljs-variable">StoreOriginalBoneLengths</span>
<span class="hljs-variable">RootNodePos</span> <span class="hljs-operator">:=</span> <span class="hljs-variable">NodePositions</span><span class="hljs-punctuation">[</span><span class="hljs-variable">LastPosition</span><span class="hljs-punctuation">]</span><span class="hljs-operator">;</span>
<span class="hljs-built_in">For</span> <span class="hljs-variable">NumIterations</span><span class="hljs-operator">;</span> <span class="hljs-built_in">Do</span>
    <span class="hljs-variable">EffectorPos</span> <span class="hljs-operator">:=</span> <span class="hljs-variable">NodePositions</span><span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-punctuation">]</span>
    <span class="hljs-built_in">If</span> <span class="hljs-variable">TargetIsCloseToEffector</span>
       <span class="hljs-built_in">Return</span>
    <span class="hljs-variable">SolveForward</span><span class="hljs-punctuation">(</span><span class="hljs-variable">TargetNodePos</span><span class="hljs-punctuation">)</span>
    <span class="hljs-variable">SolveBackwards</span><span class="hljs-punctuation">(</span><span class="hljs-variable">RootNodePos</span><span class="hljs-punctuation">)</span>
<span class="hljs-variable">EndFor</span>
</code></pre>
    <p class="normal">The <code class="inlineCode">SolveForward</code> and <code class="inlineCode">SolveBackwards</code> methods are similar, so we can look only at pseudo-code for the forward-solving part of FABRIK:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attribute">NodePositions</span>[<span class="hljs-number">0</span>] = TargetNodePos
<span class="hljs-attribute">For</span> i = <span class="hljs-number">1</span>; i &lt; NodePositions.Size; i += <span class="hljs-number">1</span>
    <span class="hljs-attribute">BoneDirection</span> = NodePositions[i] - NodePositions[i-<span class="hljs-number">1</span>]
    <span class="hljs-attribute">NewOffset</span> = BoneDirection * BoneLengths[i - <span class="hljs-number">1</span>]
    <span class="hljs-attribute">NodePositions</span>[i] = NodePositions[i-<span class="hljs-number">1</span>] + NewOffset
<span class="hljs-attribute">EndFor</span>
</code></pre>
    <p class="normal">The backward-solving <a id="_idIndexMarker681"/>part just starts with the saved root node position and iterates over the bones in the opposite direction.</p>
    <p class="normal">As you can see, the number of steps is small and the actions in these steps are simple. Armed with the new knowledge, let’s add a FABRIK solver.</p>
    <h2 id="_idParaDest-361" class="heading-2">Implementing the FABRIK inverse kinematics algorithm</h2>
    <p class="normal">The inverse<a id="_idIndexMarker682"/> kinematics solver using the FABRIK algorithm is implemented by the following steps:</p>
    <ol>
      <li class="numberedList" value="1">For the FABRIK inverse kinematics solver, we<a id="_idIndexMarker683"/> create a new class, <code class="inlineCode">IKSolver</code>, by adding the <code class="inlineCode">IKSolver.h</code> and <code class="inlineCode">IKSolver.cpp</code> files to the <code class="inlineCode">tools</code> folder.</li>
      <li class="numberedList">Next to the constructor and a setter for the number of iterations, a <code class="inlineCode">public</code> method named <code class="inlineCode">solveFABRIK()</code> is added:
        <pre class="programlisting code-one"><code class="hljs-code">    <span class="hljs-function">std::vector&lt;glm::vec3&gt; </span><span class="hljs-title">solveFARBIK</span><span class="hljs-params">(</span>
<span class="hljs-params">      std::vector&lt;glm::mat4&gt;&amp; nodeMatrices,</span>
<span class="hljs-params">    glm::vec3 targetPos)</span>;
</code></pre>
      </li>
      <li class="numberedList">We also add the two <code class="inlineCode">private</code> members, <code class="inlineCode">mNodePositions</code> and <code class="inlineCode">mBoneLengths</code>, and three private methods, <code class="inlineCode">solveFABRIKForward()</code>, <code class="inlineCode">solveFABRIKBackwards()</code>, and <code class="inlineCode">calculateOrigBoneLengths()</code>:
        <pre class="programlisting code-one"><code class="hljs-code">    std::vector&lt;glm::vec3&gt; mNodePositions{};
    std::vector&lt;<span class="hljs-type">float</span>&gt; mBoneLengths{};
    <span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">solveFABRIKForward</span><span class="hljs-params">(glm::vec3 targetPos)</span>;
    <span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">solveFABRIKBackwards</span><span class="hljs-params">(glm::vec3 rootPos)</span>;
    <span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">calculateOrigBoneLengths</span><span class="hljs-params">()</span>;
</code></pre>
      </li>
      <li class="numberedList">In <code class="inlineCode">mNodePositions</code>, we store the world positions of the nodes during calculation, and in <code class="inlineCode">mBoneLengths</code>, the required original bone lengths are saved. The name of the <code class="inlineCode">calculateOrigBoneLengths()</code> method speaks for itself; we don’t need to dive into details there. But let’s do a<a id="_idIndexMarker684"/> quick walkthrough of the three remaining methods.</li>
      <li class="numberedList">The forward part of FABRIK is handled in <code class="inlineCode">solveFABRIKForward()</code>. First, we set the first element of <code class="inlineCode">mNodePositions</code> to the target position:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">IKSolver::solveFABRIKForward</span><span class="hljs-params">(glm::vec3 targetPos)</span><span class="hljs-function"> </span>{
  mNodePositions.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>) = targetPos;
  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">1</span>; i &lt; mNodePositions.<span class="hljs-built_in">size</span>(); ++i) {
    glm::vec3 boneDirection =
      glm::<span class="hljs-built_in">normalize</span>(mNodePositions.<span class="hljs-built_in">at</span>(i) -
      mNodePositions.<span class="hljs-built_in">at</span>(i – <span class="hljs-number">1</span>));
    glm::vec3 offset = boneDirection *
      mBoneLengths.<span class="hljs-built_in">at</span>(i – <span class="hljs-number">1</span>);
    mNodePositions.<span class="hljs-built_in">at</span>(i) =
      mNodePositions.<span class="hljs-built_in">at</span>(i - <span class="hljs-number">1</span>) + offset;
  }
}
</code></pre>
      </li>
      <li class="numberedList">Then we loop over the remaining nodes, calculate the new direction of the bone after moving the previous node, and calculate the new position of the node by using the original length. Finally, we move the node to the new position, retaining the length.</li>
      <li class="numberedList">In <code class="inlineCode">solveFABRIKBackwards()</code>, we do the same operations as in <em class="italic">steps 5 and 6</em> but in the opposite direction along the node chain. We start with the root node position as the target and adjust the<a id="_idIndexMarker685"/> node positions one by one:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-type">void</span><span class="hljs-function"> </span><span class="hljs-title">IKSolver::solveFABRIKBackwards</span><span class="hljs-params">(glm::vec3 rootPos)</span><span class="hljs-function"> </span>{
  mNodePositions.<span class="hljs-built_in">at</span>(mNodePositions.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) = rootPos;
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = mNodePositions.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) {
    glm::vec3 boneDirection =
      glm::<span class="hljs-built_in">normalize</span>(mNodePositions.<span class="hljs-built_in">at</span>(i) -
      mNodePositions.<span class="hljs-built_in">at</span>(i + <span class="hljs-number">1</span>));
    glm::vec3 offset = boneDirection * mBoneLengths.<span class="hljs-built_in">at</span>(i);
    mNodePositions.<span class="hljs-built_in">at</span>(i) =
      mNodePositions.<span class="hljs-built_in">at</span>(i + <span class="hljs-number">1</span>) + offset;
  }
}
</code></pre>
      </li>
      <li class="numberedList">The last method, <code class="inlineCode">solveFARBIK()</code>, is used to control the iterations of FABRIK plus the comparison of the effector and target positions. We start with a simple check for an empty node matrix vector. In this case, we return an empty vector:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-function">std::vector&lt;glm::vec3&gt; </span><span class="hljs-title">IKSolver::solveFARBIK</span><span class="hljs-params">(</span>
<span class="hljs-params">    std::vector&lt;glm::mat4&gt;&amp; nodeMatrices,</span>
<span class="hljs-params">    glm::vec3 targetPos)</span><span class="hljs-function"> </span>{
  <span class="hljs-keyword">if</span> (nodeMatrices.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> std::vector&lt;glm::vec3&gt;{};
  }
</code></pre>
      </li>
      <li class="numberedList">Then, we resize<a id="_idIndexMarker686"/> and fill the <code class="inlineCode">mNodePositions</code> vector:
        <pre class="programlisting code-one"><code class="hljs-code">  mNodePositions.<span class="hljs-built_in">resize</span>(nodeMatrices.<span class="hljs-built_in">size</span>());
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nodeMatrices.<span class="hljs-built_in">size</span>(); ++i) {
    mNodePositions.<span class="hljs-built_in">at</span>(i) =
      Tools::<span class="hljs-built_in">extractGlobalPosition</span>(
      nodeMatrices.<span class="hljs-built_in">at</span>(i));
  }
</code></pre>
      </li>
      <li class="numberedList">In the helper method <code class="inlineCode">extractGlobalPosition()</code>, the translational part of the node matrix is extracted and returned. Now we can calculate the bone lengths, and we store the position of the root node for the backward part of FABRIK:
        <pre class="programlisting code-one"><code class="hljs-code">  <span class="hljs-built_in">calculateOrigBoneLengths</span>();
  glm::vec3 rootPos =
    mNodePositions.<span class="hljs-built_in">at</span>(mNodePositions.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);
</code></pre>
      </li>
      <li class="numberedList">We need to store the root node position because we alter the <code class="inlineCode">mNodePositions</code> vector during the forward<a id="_idIndexMarker687"/> calculations. Without saving the original root node, the backward part would be impossible to solve.</li>
      <li class="numberedList">Then, we start a loop with the maximum number of iterations:
        <pre class="programlisting code-one"><code class="hljs-code">  <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; mIterations; ++i) {
    glm::vec3 effector = mNodePositions.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">if</span>(glm::<span class="hljs-built_in">length</span>(targetPos - effector) &lt;
        mCloseThreshold) {
      <span class="hljs-keyword">return</span> mNodePositions;
    }
</code></pre>
      </li>
    </ol>
    <p class="normal-one">At the start of the loop, we compare the positions of the effector node and the desired target. If the positions are close together, we return the current node positions as solutions.</p>
    <ol>
      <li class="numberedList" value="13">Now comes the FABRIK solving part. We call the forward solver method with the target position and then the backward solver method with the saved root node position:
        <pre class="programlisting code-one"><code class="hljs-code">    <span class="hljs-built_in">solveFABRIKForward</span>(targetPos);
    <span class="hljs-built_in">solveFABRIKBackwards</span>(rootPos);
  }
</code></pre>
      </li>
      <li class="numberedList">After both solving parts are finished, we continue with the next iteration. Finally, we return the positions FABRIK found for the nodes:
        <pre class="programlisting code-one"><code class="hljs-code">  <span class="hljs-keyword">return</span> mNodePositions;
}
</code></pre>
      </li>
    </ol>
    <p class="normal-one">It’s possible that the <a id="_idIndexMarker688"/>effector node is unable to reach the target position, i.e., because the node chain is too short. In this case, the best position FABRIK could find will be returned.</p>
    <p class="normal">Before we can continue with the last part of the FABRIK, we need to make sure to configure the root and effector nodes of the model. Here, we will use only the feet to create a natural appearance while walking up or down a hill.</p>
    <h2 id="_idParaDest-362" class="heading-2">Defining the node chain for the instance’s feet</h2>
    <p class="normal">To be able to configure the nodes<a id="_idIndexMarker689"/> for the feet, two new members of the <code class="inlineCode">ModelSettings</code> <code class="inlineCode">struct</code> in the <code class="inlineCode">ModelSettings.h</code> file are added:</p>
    <pre class="programlisting code"><code class="hljs-code">  std::array&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, 2&gt; msFootIKChainPair{};
  std::array&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;, 2&gt; msFootIKChainNodes{};
</code></pre>
    <p class="normal">In the <code class="inlineCode">msFootIKChainPair</code> array, we store the node IDs of the effector and the root node for the left foot and right foot. We only need this pair for the user interface since the contents of the <code class="inlineCode">msFootIKChainNodes</code> array will be calculated from the effector and root node IDs.</p>
    <p class="normal">For the user interface, we use the names from the bone name list of the instance’s model. Since we have a 1:1 relationship between the bone IDs and the names, iterating over the list to create a combo box is easy.</p>
    <p class="normal">Together with a Boolean variable to enable or disable inverse kinematics and an iteration slider, the user interface for the section about inverse kinematics for the model’s feet looks like <em class="italic">Figure 12.12</em>:</p>
    <figure class="mediaobject"><img src="../Images/figure_12_12.png" alt="" width="1072" height="312"/></figure>
    <p class="packt_figref">Figure 12.12: Configured inverse kinematics for the Women model</p>
    <p class="normal">For <em class="italic">Figure 12.12</em>, the <code class="inlineCode">Women</code> model was used as an example. For other models, the node names may be different.</p>
    <div class="note">
      <p class="normal">Inverse kinematics depends on the model</p>
      <p class="normal">The ability to configure inverse kinematics for the feet of a model depends heavily on the model’s skeleton. It’s likely that some models you find on the internet may miss some parent-child relationships between nodes of the skeleton, for instance between leg and feet nodes, leading to non-working inverse kinematics.</p>
    </div>
    <p class="normal">The FABRIK algorithm has <a id="_idIndexMarker690"/>another part that adjusts the world positions of the original nodes by using the calculated positions. We skipped the code for the final part in the <em class="italic">Implementing the FABRIK inverse kinematics algorithm</em> section since we have to split the FABRIK algorithm for technical reasons – the node data used by the FABRIK algorithm resides on the GPU, but some of the calculations are easier to handle on the CPU.</p>
    <p class="normal">Let’s combine the node positions now.</p>
    <h2 id="_idParaDest-363" class="heading-2">Adjusting the node positions</h2>
    <p class="normal">Due to the usage of <a id="_idIndexMarker691"/>compute shaders, the matrices containing the rotation, translation, and scale plus the data for the world positions of the nodes only reside in GPU memory. Plus, the node positions are calculated for performance reasons in a compute shader. We need to copy the data back and forth between the CPU and the GPU to adjust the node rotations to the results delivered by the FABRIK solver. After calculating the final node positions for all instances with FABRIK, the rotation data for every node from target to effector is updated. The resulting transform matrices are uploaded to the GPU, and a compute shader is used to calculate the new transform matrices. Since all child nodes of a node are affected by the transform matrix, we have to perform these steps for each node individually.</p>
    <h3 id="_idParaDest-364" class="heading-3">Keeping the node transformations separate</h3>
    <p class="normal">To simplify using the data <a id="_idIndexMarker692"/>calculated in the compute shaders, we will not combine the rotation, translation, and scale data for the TRS matrix into a single matrix. Instead, we store the values in a new <code class="inlineCode">struct</code>.</p>
    <p class="normal">In the three shaders files, <code class="inlineCode">assimp_instance_matrix_mult.comp</code>, <code class="inlineCode">assimp_instance_transform.comp</code>, and <code class="inlineCode">assimp_instance_headmove_transform.comp</code>, we add the following <code class="inlineCode">TRSMat</code> <code class="inlineCode">struct</code> at the top:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span> <span class="hljs-title">TRSMat</span> {
  <span class="hljs-type">vec4</span> translation;
  <span class="hljs-type">vec4</span> rotation;
  <span class="hljs-type">vec4</span> scale;
};
</code></pre>
    <p class="normal">Be aware that the <code class="inlineCode">rotation</code> element is a quaternion; we just use a <code class="inlineCode">vec4</code> for the transport to the shader since GLSL does not support quaternions directly.</p>
    <p class="normal">To avoid adding translation, rotation, and scale to a matrix in one shader and extracting the values again in another shader, we will keep the decomposed transformation data as separate values in the SSBO:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-type">uint</span> <span class="hljs-keyword">index</span> = node + numberOfBones * instance;
  trsMat[<span class="hljs-keyword">index</span>].translation = finalTranslation;
  trsMat[<span class="hljs-keyword">index</span>].rotation = finalRotation;
  trsMat[<span class="hljs-keyword">index</span>].scale = finalScale;
</code></pre>
    <p class="normal">Creating the final TRS matrix is moved into the matrix multiplication shader, along with the <code class="inlineCode">createTRSMatrix()</code>, <code class="inlineCode">createTranslationMatrix()</code>, <code class="inlineCode">createScaleMatrix()</code>, and <code class="inlineCode">createRotationMatrix()</code> helper methods. The TRS matrices will be created on the fly instead of doing a lookup<a id="_idIndexMarker693"/> in the <code class="inlineCode">main()</code> method of the <code class="inlineCode">assimp_instance_matrix_mult.comp</code> shader:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-type">mat4</span> nodeMatrix = <span class="code-highlight"><strong class="hljs-slc">createTRSMatrix(</strong><strong class="hljs-keyword-slc">index</strong><strong class="hljs-slc">)</strong></span>;
  ...
  nodeMatrix = <span class="code-highlight"><strong class="hljs-slc">createTRSMatrix(parent)</strong></span> * nodeMatrix;
</code></pre>
    <p class="normal">Since the calculation was done entirely on the GPU, the only change in the renderer code to reflect the TRS data split is the size <a id="_idIndexMarker694"/>calculation for the <code class="inlineCode">mShaderTRSMatrixBuffer</code> SSBO:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-type">size_t</span> trsMatrixSize = numberOfBones *
    numberOfInstances * <span class="hljs-number">3</span> * <span class="hljs-built_in">sizeof</span>(glm::vec4);
</code></pre>
    <p class="normal">Instead of a <code class="inlineCode">glm::mat4</code> for the full TRS matrix, we use three <code class="inlineCode">glm::vec4</code> instances here, keeping the node transform split into translation, rotation, and scale like in the compute shader.</p>
    <p class="normal">In the <code class="inlineCode">OGLRenderData.h</code> file, a matching <code class="inlineCode">TRSMatrixData</code> <code class="inlineCode">struct</code> is added:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span> <span class="hljs-title">TRSMatrixData</span>{
  glm::<span class="hljs-type">vec4</span> translation;
  glm::quat rotation;
  glm::<span class="hljs-type">vec4</span> scale;
};
</code></pre>
    <p class="normal">For Vulkan, the addition of <code class="inlineCode">TRSMatrixData</code> happens in the <code class="inlineCode">VkRenderData.h</code> file.</p>
    <p class="normal">Right after the final node positions were calculated by the compute shaders, but before the instances are rendered, new code will be added for the animated instances.</p>
    <h3 id="_idParaDest-365" class="heading-3">Adding the code for the animated instances</h3>
    <p class="normal">We start by<a id="_idIndexMarker695"/> retrieving the current contents of the TRS buffer:</p>
    <pre class="programlisting code"><code class="hljs-code">    mTRSData =
      mShaderTRSMatrixBuffer.<span class="hljs-built_in">getSsboDataTRSMatrixData</span>();
</code></pre>
    <p class="normal">Then we iterate over the two feet and calculate the size of the node chain for each foot:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> foot = <span class="hljs-number">0</span>; foot &lt;
      modSettings.msFootIKChainPair.<span class="hljs-built_in">size</span>(); ++foot) {
      <span class="hljs-type">int</span> nodeChainSize =
        modSettings.msFootIKChainNodes[foot].<span class="hljs-built_in">size</span>();
      <span class="hljs-keyword">if</span> (nodeChainSize == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">continue</span>;
      }
</code></pre>
    <p class="normal">If the foot node chain is empty, we continue immediately since we don’t have anything to calculate here. But if we have a valid foot node chain, we iterate backward over the node chain, and in each node chain, we iterate forward over all instances:</p>
    <pre class="programlisting code"><code class="hljs-code">      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> index = nodeChainSize - <span class="hljs-number">1</span>; index &gt; <span class="hljs-number">0</span>;
          --index) {
        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; numberOfInstances; ++i) {
</code></pre>
    <p class="normal">The order of the loops – foot first, then the node chain, and instance last – has a good reason: it is much easier to handle cases where one of the foot node chains is empty or the foot node chains have different sizes, as we can skip an entire loop or use a different number of iterations. Iterating the node chain backward is necessary because the foot chain vector contains the nodes in order from the effector to the root node, but the world position update starts with the root node as the first node.</p>
    <p class="normal">In the inner loop, we extract the node IDs of the current node and the previous node from the foot node chains:</p>
    <pre class="programlisting code"><code class="hljs-code">          <span class="hljs-type">int</span> nodeId =
            modSettings.msFootIKChainNodes[foot].<span class="hljs-built_in">at</span>(index);
          <span class="hljs-type">int</span> nextNodeId =
            modSettings.msFootIKChainNodes[foot]
            .<span class="hljs-built_in">at</span>(index - <span class="hljs-number">1</span>);
</code></pre>
    <p class="normal">By using the two node IDs, we extract the world position of the nodes:</p>
    <pre class="programlisting code"><code class="hljs-code">        glm::vec3 position = Tools::<span class="hljs-built_in">extractGlobalPosition</span>(
          mWorldPosMatrices.<span class="hljs-built_in">at</span>(i) *
          mShaderBoneMatrices.<span class="hljs-built_in">at</span>(i * numberOfBones +
          nodeId) *
          model-&gt;<span class="hljs-built_in">getInverseBoneOffsetMatrix</span>(nodeId));
        glm::vec3 nextPosition =
          Tools::<span class="hljs-built_in">extractGlobalPosition</span>(
          mWorldPosMatrices.<span class="hljs-built_in">at</span>(i) *
          mShaderBoneMatrices.<span class="hljs-built_in">at</span>(i * numberOfBones +
          nextNodeId) *
          model-&gt;<span class="hljs-built_in">getInverseBoneOffsetMatrix</span>(nextNodeId));
</code></pre>
    <p class="normal">After multiplying the inverse of the bone offset node, the current node position, and the instance world position, we get the world position of the two adjacent nodes of the foot node chain.</p>
    <p class="normal">With the two positions, we calculate the normalized <code class="inlineCode">toNext</code> vector:</p>
    <pre class="programlisting code"><code class="hljs-code">          glm::vec3 toNext = glm::<span class="hljs-built_in">normalize</span>(nextPosition -
            position);
</code></pre>
    <p class="normal">To calculate the <a id="_idIndexMarker696"/>desired rotation for the node, we need to find a quaternion that rotates the bone from the current world rotation to the rotation computed by the FABRIK algorithm.</p>
    <h3 id="_idParaDest-366" class="heading-3">Creating the new world positions</h3>
    <p class="normal">We extract the new world positions <a id="_idIndexMarker697"/>of the same nodes calculated by FABRIK, calculate the normalized <code class="inlineCode">toDesired</code> vector between the new world positions, and compute the rotation angle between the <code class="inlineCode">toNext</code> and <code class="inlineCode">toDesired</code> vectors as a quaternion, <code class="inlineCode">nodeRotation</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">          <span class="hljs-type">int</span> newNodePosOffset = i * nodeChainSize + index;
          glm::vec3 toDesired = glm::<span class="hljs-built_in">normalize</span>(
            mNewNodePositions.<span class="hljs-built_in">at</span>(foot)
            .<span class="hljs-built_in">at</span>(newNodePosOffset - <span class="hljs-number">1</span>) –
            mNewNodePositions.<span class="hljs-built_in">at</span>(foot)
            .<span class="hljs-built_in">at</span>(newNodePosOffset));
          glm::quat nodeRotation = glm::<span class="hljs-built_in">rotation</span>(toNext,
            toDesired);
</code></pre>
    <p class="normal">At this point, we have the world-level rotation between the current position of the bone and the new position of the same bone of the model’s skeleton.</p>
    <p class="normal">Now we extract the world-level rotation of the current node and calculate the local rotation that would be needed to match the world-level rotation of the node:</p>
    <pre class="programlisting code"><code class="hljs-code">        glm::quat rotation = Tools::<span class="hljs-built_in">extractGlobalRotation</span>(
          mWorldPosMatrices.<span class="hljs-built_in">at</span>(i) *
          mShaderBoneMatrices.<span class="hljs-built_in">at</span>(i * numberOfBones +
          nodeId) *
          model-&gt;<span class="hljs-built_in">getInverseBoneOffsetMatrix</span>(nodeId));
        glm::quat localRotation = rotation *
          nodeRotation * glm::<span class="hljs-built_in">conjugate</span>(rotation);
</code></pre>
    <p class="normal">Finally, we read the current local rotation of the node, concatenate the new rotation, and store the rotation back to the TRS data:</p>
    <pre class="programlisting code"><code class="hljs-code">          glm::quat currentRotation = mTRSData.<span class="hljs-built_in">at</span>(i *
            numberOfBones + nodeId).rotation;
          glm::quat newRotation = currentRotation *
            localRotation;
          mTRSData.<span class="hljs-built_in">at</span>(i*numberOfBones + nodeId).rotation =
            newRotation;
        }
</code></pre>
    <p class="normal">By running the <code class="inlineCode">mAssimpMatrixComputeShader</code> and uploading the updated TRS data, the new node matrices for all the nodes in the foot node chain are recalculated. As the last step, we read back the contents of the <code class="inlineCode">mShaderBoneMatrixBuffer</code> to have the new node matrices available for the next node in the foot node chain.</p>
    <p class="normal">We are just one step away from a working inverse kinematics implementation. What’s left now is detecting the<a id="_idIndexMarker698"/> collisions between the foot position and the ground triangle. Let’s tackle the last section of this chapter.</p>
    <h2 id="_idParaDest-367" class="heading-2">Detecting feet-to-ground collisions</h2>
    <p class="normal">The general idea behind detecting collisions between instance feet and the ground is the same as for the instances. We use <a id="_idIndexMarker699"/>the ray-to-triangle check to find the intersection of a ray with the triangle below or above the defined foot node. This intersection point is then used as the target position for the FABRIK solver.</p>
    <p class="normal">For both feet of every instance, we use the same method to extract the world position as in the last step of the FABRIK solver code:</p>
    <pre class="programlisting code"><code class="hljs-code">        <span class="hljs-type">int</span> footNodeId =
          modSettings.msFootIKChainPair.<span class="hljs-built_in">at</span>(foot).first;
        glm::vec3 footWorldPos =
          Tools::<span class="hljs-built_in">extractGlobalPosition</span>(
          mWorldPosMatrices.<span class="hljs-built_in">at</span>(i) *
          mShaderBoneMatrices.<span class="hljs-built_in">at</span>(i * numberOfBones +
          footNodeId) *
          model-&gt;<span class="hljs-built_in">getInverseBoneOffsetMatrix</span>(footNodeId));
</code></pre>
    <p class="normal">We also calculate the offset of the foot node from the ground:</p>
    <pre class="programlisting code"><code class="hljs-code">        <span class="hljs-type">float</span> footDistAboveGround = std::<span class="hljs-built_in">fabs</span>(
          instSettings.isWorldPosition.y - footWorldPos.y);
</code></pre>
    <p class="normal">This <code class="inlineCode">footDistAboveGround</code> offset is needed to let the foot hover above the sloped ground triangle at the same distance as the foot would be on a plain ground triangle. Then, we use the <code class="inlineCode">AABB</code> of the instance to calculate the full and half height of the bounding box:</p>
    <pre class="programlisting code"><code class="hljs-code">        AABB instanceAABB = model-&gt;<span class="hljs-built_in">getAABB</span>(instSettings);
        <span class="hljs-type">float</span> instanceHeight = instanceAABB.<span class="hljs-built_in">getMaxPos</span>().y -
          instanceAABB.<span class="hljs-built_in">getMinPos</span>().y;
        <span class="hljs-type">float</span> instanceHalfHeight = instanceHeight / <span class="hljs-number">2.0f</span>
</code></pre>
    <p class="normal">With the two <a id="_idIndexMarker700"/>height values, we create a ray to detect the intersection with the ground triangle. Next, we set a default value for the final <code class="inlineCode">hitPoint</code> of the intersection and iterate over the colliding triangles:</p>
    <pre class="programlisting code"><code class="hljs-code">        glm::vec3 hitPoint = footWorldPos;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; tri :
          instSettings.isCollidingTriangles) {
           std::optional&lt;glm::vec3&gt; result{};
</code></pre>
    <p class="normal">Then we check every colliding triangle for an intersection with a ray starting at the half height of the instance, pointing at most the entire instance height down:</p>
    <pre class="programlisting code"><code class="hljs-code">          result = Tools::<span class="hljs-built_in">rayTriangleIntersection</span>(
            footWorldPos +
            glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, instanceHalfHeight, <span class="hljs-number">0.0f</span>),
            glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, -instanceHeight, <span class="hljs-number">0.0f</span>), tri);
</code></pre>
    <p class="normal">Using an upper and lower limit for the ray helps prevent the misdetection of any nearby triangles. Next, we check if we have found an intersection:</p>
    <pre class="programlisting code"><code class="hljs-code">          <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">has_value</span>()) {
            hitPoint = result.<span class="hljs-built_in">value</span>() +
              glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, footDistAboveGround, <span class="hljs-number">0.0f</span>);
          }
</code></pre>
    <p class="normal">Here, we add the <code class="inlineCode">footDistAboveGround</code> to the resulting value to keep the original distance from the animation to the ground. <em class="italic">Figure 12.13</em> shows a simplified example of how keeping the foot-to-ground distance affects the instance:</p>
    <figure class="mediaobject"><img src="../Images/figure_12_13.png" alt="" width="992" height="432"/></figure>
    <p class="packt_figref">Figure 12.13: Retaining the distance of the foot above the ground</p>
    <p class="normal">Now we can run the inverse kinematics solver to calculate the adjusted node positions.</p>
    <h2 id="_idParaDest-368" class="heading-2">Running the FABRIK solver</h2>
    <p class="normal">First, we clear the vector <a id="_idIndexMarker701"/>containing positions to solve. Then, we place the matrices of the <a id="_idIndexMarker702"/>nodes in the current foot node chain in <code class="inlineCode">mIKWorldPositionsToSolve</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">        mIKWorldPositionsToSolve.<span class="hljs-built_in">clear</span>();
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> nodeId :
            modSettings.msFootIKChainNodes[foot]) {
          mIKWorldPositionsToSolve.<span class="hljs-built_in">emplace_back</span>(
            mWorldPosMatrices.<span class="hljs-built_in">at</span>(i) *
            mShaderBoneMatrices.<span class="hljs-built_in">at</span>(i * numberOfBones +
            nodeId) *
            model-&gt;<span class="hljs-built_in">getInverseBoneOffsetMatrix</span>(nodeId));
        }
</code></pre>
    <p class="normal">As the final step of the inverse kinematics, we let FABRIK solve the node positions for the intersection point we have found, and insert the results into the <code class="inlineCode">mNewNodePositions</code> vector for the foot we are working on:</p>
    <pre class="programlisting code"><code class="hljs-code">        mIKSolvedPositions = mIKSolver.<span class="hljs-built_in">solveFARBIK</span>(
          mIKWorldPositionsToSolve, hitPoint);
        mNewNodePositions.<span class="hljs-built_in">at</span>(foot).<span class="hljs-built_in">insert</span>(
          mNewNodePositions.<span class="hljs-built_in">at</span>(foot).<span class="hljs-built_in">end</span>(),
          mIKSolvedPositions.<span class="hljs-built_in">begin</span>(),
          mIKSolvedPositions.<span class="hljs-built_in">end</span>());
</code></pre>
    <p class="normal">At this point, the foot positions are ready for the node matrix and TRS updates from the <em class="italic">Detecting foot to ground collisions</em> section.</p>
    <p class="normal">Enabling and configuring<a id="_idIndexMarker703"/> inverse kinematics after loading a level will render an image similar to <em class="italic">Figure 12.14</em> to the screen:</p>
    <figure class="mediaobject"><img src="../Images/figure_12_14.png" alt="" width="1139" height="899"/></figure>
    <p class="packt_figref">Figure 12.14: The right foot of the right instance has less intersection on sloped ground</p>
    <p class="normal">As you can see in the right instance in <em class="italic">Figure 12.14</em>, the right foot no longer fully intersects the ground triangle. Also, the angle of the right knee has been adjusted to allow the foot to be placed on the higher part of the<a id="_idIndexMarker704"/> ground triangle.</p>
    <p class="normal">There is still some intersection with the toes on the left. Fixing the remaining intersection by aligning the toes to the ground slope is a task in the <em class="italic">Practical sessions</em> section. But even with this minimal intersection, it’s a lot of fun to watch the instances going up and down on hills much more like a real human.</p>
    <h2 id="_idParaDest-369" class="heading-2">Limitations of FABRIK</h2>
    <p class="normal">Animations created by using a FABRIK solver for inverse kinematics usually look good, but the algorithm has some limitations that should be addressed.</p>
    <p class="normal">The biggest problem arises when note rotations create unnatural bone positions. For example, a human cannot bend their <a id="_idIndexMarker705"/>knees forward, but our instances on the screen can do so. Without checking and restricting the rotations of the nodes, the bones of the instances can end up in virtually any position. A task in the <em class="italic">Practical sessions</em> section handles this issue by limiting node rotations.</p>
    <p class="normal">Another problem emerges if the target is too far away from the effector, thus becoming unreachable. FABRIK solves unreachable targets by stretching the entire bone chain from the root node to the effector node in a straight line, causing the instance to walk around with stiff legs like a robot. Since we can detect if the target cannot be reached by the effector, handling these situations is easier than unlimited node rotations. There is a task in the <em class="italic">Practical sessions</em> section to solve problems with unreachable targets.</p>
    <h1 id="_idParaDest-370" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we enhanced the collision detection in our level. First, we added a separate and specialized octree for the level data, allowing us to do a quick check for collisions between instances and level geometry. Then, we added simple gravity to the virtual world and adjusted the collision detection to allow instances to walk on the level floor. Finally, we added inverse kinematics for the feet of the instances, bringing a more natural foot and leg movement on sloped grounds by avoiding the feet floating above the ground or clipping into ground triangles of the level.</p>
    <p class="normal">In the next chapter, we will add a final extension to the level data and add simple navigation. We will start with a brief roundup of several ways to implement navigation in games. Next, we will explore the A* pathfinding algorithm and implement it in the application. Then, we will add waypoints to the map, serving as targets for A* calculations. Finally, we will implement waypoint navigation to the instances, enabling the instances to move to random waypoints or to patrol between a set of defined waypoints.</p>
    <h1 id="_idParaDest-371" class="heading-1">Practical sessions</h1>
    <p class="normal">Here are some additions you could make to the code:</p>
    <ul>
      <li class="bulletList">Add a more complete gravity.</li>
    </ul>
    <p class="normal-one">Instead of just manipulating the vertical position of the instances, use a more complex way to apply gravity by using vertical acceleration. Since gravity is used in two places, in the instance for the speed and in the renderer for the collision detection, synchronization between both code parts is needed.</p>
    <ul>
      <li class="bulletList">Add collision detection for the third-person camera.</li>
    </ul>
    <p class="normal-one">In real games, the camera is also a normal object in the virtual world. And instead of clipping through the level data, the camera always stays inside the same boundaries as the character it follows, connected by a spring arm structure to allow adjustments if the camera is unable to keep the exact position behind the character. You can try to add a bounding box for the third-person camera and check the boundaries against the level octree too. Remember to also check and change the distance and height of the camera if a collision occurs.</p>
    <ul>
      <li class="bulletList">Enhance stair and cliff detection.</li>
    </ul>
    <p class="normal-one">To enable the instances climbing stairs, basic logic has been added to the code that compares the step height of stairs with the instance position. This idea may not work for different kinds of game maps, plus the instance may fall off a cliff when the stair detection returns the wrong result. Enhance the logic to have better stair detection and also prevent the instance from falling down when it “thinks” it is standing in front of a step when it is actually on the edge of an abyss.</p>
    <ul>
      <li class="bulletList">Align the instance’s feet to follow the slope and normal if the floor.</li>
    </ul>
    <p class="normal-one">Right now, the feet of the instances may still intersect the ground, depending on the slope of the ground and the instance position. Add some code, and maybe even more nodes to the model(s), to align the feet of the instance to the ground triangle. This adjustment should work for forward/backward inclination and for a sideway rotation of the feet to match the ground.</p>
    <ul>
      <li class="bulletList">Handle unreachable targets.</li>
    </ul>
    <p class="normal-one">Implement logic to detect if the effector cannot reach the target and add some kind of default rotations for the nodes, for instance, taken from the current frame of the animation clip.</p>
    <ul>
      <li class="bulletList">Move the node update part of FABRIK to a compute shader.</li>
    </ul>
    <p class="normal-one">To keep the FABRIK code for updating the final node rotations simple and easy to follow, a CPU/GPU combination was used. The downside of the current code is the need to copy both TRS matrix data and final node positions from GPU memory at the start of every update of the node chain. By creating a compute shader for the node rotation updates, you can keep the entire node update process on the GPU.</p>
    <ul>
      <li class="bulletList">Extended difficulty: Write a compute shader for inverse kinematics.</li>
    </ul>
    <p class="normal-one">The FABRIK inverse kinematics algorithm is simple and straightforward. Implementing the same algorithm in a compute shader should not be too hard. You can use the matrix multiplication compute shader as an example of how to do loops in GLSL code without hard coding the loop variable.</p>
    <ul>
      <li class="bulletList">Extended difficulty: Add node limits to the inverse kinematics algorithm.</li>
    </ul>
    <p class="normal-one">In the default version, inverse kinematics does not worry about unnatural bone rotations when solving for the position. For a game character, it looks strange if a knee or an elbow is bent in the wrong direction. By adding per-node limits for all three rotation axes, the target may not be reachable, but the character still looks like a human. But be warned: adding node limits may influence the stability of the inverse kinematics algorithm.</p>
    <ul>
      <li class="bulletList">Extended difficulty: Use a <strong class="keyWord">bounding volume hierarchy</strong> (<strong class="keyWord">BVH</strong>) for collision detection.</li>
    </ul>
    <p class="normal-one">The idea of a bounding volume hierarchy was mentioned in the <em class="italic">Using spatial partitioning to reduce complexity</em> section of <a href="Chapter_8.xhtml"><em class="italic">Chapter 8</em></a>, and the book <em class="italic">Real-Time Collision Detection</em> by Christer Ericson has an entire chapter about BHVs. Replacing the octree with a BHV to detect collisions may be a long task since the creation of the hierarchy already adds a significant amount of complexity to collision detection.</p>
    <h1 id="_idParaDest-372" class="heading-1">Additional resources</h1>
    <ul>
      <li class="bulletList">Introduction to the Jacobian Matrix: <a href="https://medium.com/unity3danimation/overview-of-jacobian-ik-a33939639ab2"><span class="url">https://medium.com/unity3danimation/overview-of-jacobian-ik-a33939639ab2</span></a></li>
      <li class="bulletList"><em class="italic">Collision Detection in Interactive 3D Environments</em> by <em class="italic">Gino van den Bergen</em>, published by <em class="italic">CRC Press</em>: ISBN 978-1558608016</li>
      <li class="bulletList"><em class="italic">Game Physics Engine Development</em> by <em class="italic">Ian Millington</em>, published by <em class="italic">CRC Press</em>: ISBN 978-0123819765</li>
      <li class="bulletList"><em class="italic">Game Physics</em> by <em class="italic">David H. Eberly</em>, published by <em class="italic">Morgan Kaufmann</em>: ISBN 978-0123749031</li>
      <li class="bulletList"><em class="italic">Real-Time Collision Detection</em> by <em class="italic">Christer Ericson</em>, published by <em class="italic">CRC Press</em>: ISBN 9781000750553</li>
      <li class="bulletList">FABRIK publications: <a href="http://www.andreasaristidou.com/FABRIK.html"><span class="url">http://www.andreasaristidou.com/FABRIK.html</span></a></li>
      <li class="bulletList">Inverse kinematics in Unreal Engine: <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/ik-setups?application_version=4.27"><span class="url">https://dev.epicgames.com/documentation/en-us/unreal-engine/ik-setups?application_version=4.27</span></a></li>
      <li class="bulletList">Full body inverse kinematic: <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/control-rig-full-body-ik-in-unreal-engine"><span class="url">https://dev.epicgames.com/documentation/en-us/unreal-engine/control-rig-full-body-ik-in-unreal-engine</span></a></li>
      <li class="bulletList">Möller-Trumbore algorithm for ray-triangle intersection checks: <a href="http://www.lighthouse3d.com/tutorials/maths/ray-triangle-intersection/"><span class="url">http://www.lighthouse3d.com/tutorials/maths/ray-triangle-intersection/</span></a></li>
    </ul>
  </div>
</div></div></body></html>