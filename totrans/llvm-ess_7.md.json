["```cpp\nclass TOYReg<bits<16> Enc, string n> : Register<n> {\nlet HWEncoding = Enc;\nlet Namespace = \"TOY\";\n}\n```", "```cpp\nforeach i = 0-3 in {\ndef R#i : R<i, \"r\"#i >;\n}\n\ndef GRRegs : RegisterClass<\"TOY\", [i32], 32,\n(add R0, R1, R2, R3, SP)>;\n```", "```cpp\ndef SP : TOYReg<13, \"sp\">;\ndef LR : TOYReg<14, \"lr\">;\ndef CPSR  : TOYReg<16, \"cpsr\">;\n```", "```cpp\nclass TOYReg<bits<16> Enc, string n> : Register<n> {\nlet HWEncoding = Enc;\nlet Namespace = \"TOY\";\n}\n\nforeach i = 0-3 in {\ndef R#i : R<i, \"r\"#i >;\n}\n\ndef SP : TOYReg<13, \"sp\">;\ndef LR : TOYReg<14, \"lr\">;\ndef GRRegs : RegisterClass<\"TOY\", [i32], 32,\n(add R0, R1, R2, R3, SP)>;\n```", "```cpp\ndef RetCC_TOY : CallingConv<[\nCCIfType<[i32], CCAssignToReg<[R0]>>,\nCCIfType<[i32], CCAssignToStack<4, 4>>\n]>;\n```", "```cpp\ndef CC_TOY : CallingConv<[\nCCIfType<[i8, i16], CCPromoteToType<i32>>,\nCCIfType<[i32], CCAssignToReg<[R0, R1]>>,\nCCIfType<[i32], CCAssignToStack<4, 4>>\n]>;\n```", "```cpp\ndef CC_Save : CalleeSavedRegs<(add R2, R3)>;\n```", "```cpp\ndef ADDrr : InstTOY<(outs GRRegs:$dst),\n(ins GRRegs:$src1, GRRegs:$src2),\n\"add $dst, $src1,z$src2\",\n[(set i32:$dst, (add i32:$src1, i32:$src2))]>;\n```", "```cpp\nadd r0, r0, r1\n```", "```cpp\nvoid TOYFrameLowering::emitPrologue(MachineFunction &MF) const {\n  const TargetInstrInfo &TII = *MF.getSubtarget().getInstrInfo();\n  MachineBasicBlock &MBB = MF.front();\n  MachineBasicBlock::iterator MBBI = MBB.begin();\n\n  uint64_t StackSize = computeStackSize(MF);\n  if (!StackSize) {\n    return;\n  }\n  unsigned StackReg = TOY::SP;\n  unsigned OffsetReg = materializeOffset(MF, MBB, MBBI, (unsigned)StackSize);\n  if (OffsetReg) {\n    BuildMI(MBB, MBBI, dl, TII.get(TOY::SUBrr), StackReg)\n        .addReg(StackReg)\n        .addReg(OffsetReg)\n        .setMIFlag(MachineInstr::FrameSetup);\n  } else {\n    BuildMI(MBB, MBBI, dl, TII.get(TOY::SUBri), StackReg)\n        .addReg(StackReg)\n        .addImm(StackSize)\n        .setMIFlag(MachineInstr::FrameSetup);\n  }\n}\n```", "```cpp\nvoid TOYFrameLowering::emitEpilogue(MachineFunction &MF,\n                                    MachineBasicBlock &MBB) const {\n  const TargetInstrInfo &TII = *MF.getSubtarget().getInstrInfo();\n  MachineBasicBlock::iterator MBBI = MBB.getLastNonDebugInstr();\n  DebugLoc dl = MBBI->getDebugLoc();\n  uint64_t StackSize = computeStackSize(MF);\n  if (!StackSize) {\n    return;\n  }\n  unsigned StackReg = TOY::SP;\n  unsigned OffsetReg = materializeOffset(MF, MBB, MBBI, (unsigned)StackSize);\n  if (OffsetReg) {\n    BuildMI(MBB, MBBI, dl, TII.get(TOY::ADDrr), StackReg)\n        .addReg(StackReg)\n        .addReg(OffsetReg)\n        .setMIFlag(MachineInstr::FrameSetup);\n  } else {\n    BuildMI(MBB, MBBI, dl, TII.get(TOY::ADDri), StackReg)\n        .addReg(StackReg)\n        .addImm(StackSize)\n        .setMIFlag(MachineInstr::FrameSetup);\n  }\n}\n```", "```cpp\n%p = alloca i32, align 4\nstore i32 2, i32* %p\n%b = load i32* %p, align 4\n%c = add nsw i32 %a, %b\n```", "```cpp\nsub sp, sp, #4 ; prologue\nmovw r1, #2\nstr r1, [sp]\nadd r0, r0, #2\nadd sp, sp, #4 ; epilogue\n```", "```cpp\nSDValue TOYTar-getLoweing::LowerCall(TargetLowering::CallLoweringInfo &CLI, SmallVectorImpl<SDValue> &InVals)\n const {\n  SelectionDAG &DAG = CLI.DAG;\n  SDLoc &Loc = CLI.DL;\n  SmallVectorImpl<ISD::OutputArg> &Outs = CLI.Outs;\n  SmallVectorImpl<SDValue> &OutVals = CLI.OutVals;\n  SmallVectorImpl<ISD::InputArg> &Ins = CLI.Ins;\n  SDValue Chain = CLI.Chain;\n  SDValue Callee = CLI.Callee;\n  CallingConv::ID CallConv = CLI.CallConv;\n  const bool isVarArg = CLI.IsVarArg;\n\n  CLI.IsTailCall = false;\n\n  if (isVarArg) {\n    llvm_unreachable(\"Unimplemented\");\n  }\n\n  // Analyze operands of the call, assigning locations to each\n  // operand.\n  SmallVector<CCValAssign, 16> ArgLocs;\n  CCState CCInfo(CallConv, isVarArg, DAG.getMachineFunction(), ArgLocs, *DAG.getContext());\n  CCInfo.AnalyzeCallOperands(Outs, CC_TOY);\n\n  // Get the size of the outgoing arguments stack space\n  // requirement.\n  const unsigned NumBytes = CCInfo.getNextStackOffset();\n\n  Chain = DAG.getCALLSEQ_START(Chain,\n                               DAG.getIntPtrConstant(NumBytes, Loc, true), Loc);\n\n  SmallVector<std::pair<unsigned, SDValue>, 8> RegsToPass;\n  SmallVector<SDValue, 8> MemOpChains;\n\n  // Walk the register/memloc assignments, inserting copies/loads.\n  for (unsigned i = 0, e = ArgLocs.size(); i != e; ++i) {\n    CCValAssign &VA = ArgLocs[i];\n    SDValue Arg = OutVals[i];\n\n    // We only handle fully promoted arguments.\n    assert(VA.getLocInfo() == CCValAssign::Full && \"Unhandled loc \n    info\");\n\n    if (VA.isRegLoc()) {\n      RegsToPass.push_back(std::make_pair(VA.getLocReg(), Arg));\n      continue;\n    }\n\n    assert(VA.isMemLoc() &&\n           \"Only support passing arguments through registers or \n           via the stack\");\n\n    SDValue StackPtr = DAG.getRegister(TOY::SP, MVT::i32);\n    SDValue PtrOff = DAG.getIntPtrConstant(VA.getLocMemOffset(), \n    Loc);\n    PtrOff = DAG.getNode(ISD::ADD, Loc, MVT::i32, StackPtr, \n    PtrOff);\n    MemOpChains.push_back(DAG.getStore(Chain, Loc, Arg, PtrOff,\n                                       MachinePointerInfo(), false, false, 0));\n  }\n\n  // Emit all stores, make sure they occur before the call.\n  if (!MemOpChains.empty()) {\n    Chain = DAG.getNode(ISD::TokenFactor, Loc, MVT::Other, MemOpChains);\n  }\n\n  // Build a sequence of copy-to-reg nodes chained together with\n  // token chain\n  // and flag operands which copy the outgoing args into the\n  // appropriate regs.\n  SDValue InFlag;\n  for (auto &Reg : RegsToPass) {\n    Chain = DAG.getCopyToReg(Chain, Loc, Reg.first, Reg.second, InFlag);\n    InFlag = Chain.getValue(1);\n  }\n\n  // We only support calling global addresses.\n  GlobalAddressSDNode *G = dyn_cast<GlobalAddressSDNode>(Callee);\n  assert(G && \"We only support the calling of global address-es\");\n\n  EVT PtrVT = getPointerTy(DAG.getDataLayout());\n  Callee = DAG.getGlobalAddress(G->getGlobal(), Loc, PtrVT, 0);\n\n  std::vector<SDValue> Ops;\n  Ops.push_back(Chain);\n  Ops.push_back(Callee);\n\n  // Add argument registers to the end of the list so that they\n  // are known live into the call.\n  for (auto &Reg : RegsToPass) {\n    Ops.push_back(DAG.getRegister(Reg.first, Reg.second.getValueType()));\n  }\n\n  // Add a register mask operand representing the call-preserved\n  // registers.\n  const uint32_t *Mask;\n  const TargetRegisterInfo *TRI = DAG.getSubtarget().getRegisterInfo();\n  Mask = TRI->getCallPreservedMask(DAG.getMachineFunction(), CallConv);\n\n  assert(Mask && \"Missing call preserved mask for calling \n  convention\");\n  Ops.push_back(DAG.getRegisterMask(Mask));\n\n  if (InFlag.getNode()) {\n    Ops.push_back(InFlag);\n  }\n\n  SDVTList NodeTys = DAG.getVTList(MVT::Other, MVT::Glue);\n\n  // Returns a chain and a flag for retval copy to use.\n  Chain = DAG.getNode(TOYISD::CALL, Loc, NodeTys, Ops);\n  InFlag = Chain.getValue(1);\n\n  Chain = DAG.getCALLSEQ_END(Chain, DAG.getIntPtrConstant(NumBytes, Loc, true),\n                             DAG.getIntPtrConstant(0, Loc, true), InFlag, Loc);\n  if (!Ins.empty()) {\n    InFlag = Chain.getValue(1);\n  }\n\n  // Handle result values, copying them out of physregs into vregs \n  // that we return.\n  return LowerCallResult(Chain, InFlag, CallConv, isVarArg, Ins, \n                         Loc, DAG, InVals);\n}\n```", "```cpp\nSDValue TOYTargetLowering::LowerFormalArguments(\n    SDValue Chain, CallingConv::ID CallConv, bool isVarArg,\n    const SmallVectorImpl<ISD::InputArg> &Ins, SDLoc dl, SelectionDAG &DAG,\n    SmallVectorImpl<SDValue> &InVals) const {\n  MachineFunction &MF = DAG.getMachineFunction();\n  MachineRegisterInfo &RegInfo = MF.getRegInfo();\n\n  assert(!isVarArg && \"VarArg not supported\");\n\n  // Assign locations to all of the incoming arguments.\n  SmallVector<CCValAssign, 16> ArgLocs;\n  CCState CCInfo(CallConv, isVarArg, DAG.getMachineFunction(), ArgLocs, *DAG.getContext());\n\n  CCInfo.AnalyzeFormalArguments(Ins, CC_TOY);\n\n  for (auto &VA : ArgLocs) {\n    if (VA.isRegLoc()) {\n      // Arguments passed in registers\n      EVT RegVT = VA.getLocVT();\n      assert(RegVT.getSimpleVT().SimpleTy == MVT::i32 &&\n             \"Only support MVT::i32 register passing\");\n      const unsigned VReg =\n          RegInfo.createVirtualRegister(&TOY::GRRegsRegClass);\n      RegInfo.addLiveIn(VA.getLocReg(), VReg);\n      SDValue ArgIn = DAG.getCopyFromReg(Chain, dl, VReg, RegVT);\n\n      InVals.push_back(ArgIn);\n      continue;\n    }\n\n    assert(VA.isMemLoc() &&\n           \"Can only pass arguments as either registers or via the \n           stack\");\n\n    const unsigned Offset = VA.getLocMemOffset();\n\n    const int FI = MF.getFrameInfo()->CreateFixedObject(4, Offset, \n    true);\n    EVT PtrTy = getPointerTy(DAG.getDataLayout());\n    SDValue FIPtr = DAG.getFrameIndex(FI, PtrTy);\n\n    assert(VA.getValVT() == MVT::i32 &&\n           \"Only support passing arguments as i32\");\n    SDValue Load = DAG.getLoad(VA.getValVT(), dl, Chain, FIPtr,\n                               MachinePointerInfo(), false, false, false, 0);\n\n    InVals.push_back(Load);\n  }\n  return Chain;\n}\n```", "```cpp\nbool TOYTargetLowering::CanLowerReturn(\n    CallingConv::ID CallConv, MachineFunction &MF, bool isVarArg,\n    const SmallVectorImpl<ISD::OutputArg> &Outs, LLVMContext &Context) const {\n  SmallVector<CCValAssign, 16> RVLocs;\n  CCState CCInfo(CallConv, isVarArg, MF, RVLocs, Context);\n  if (!CCInfo.CheckReturn(Outs, RetCC_TOY)) {\n    return false;\n  }\n  if (CCInfo.getNextStackOffset() != 0 && isVarArg) {\n    return false;\n  }\n  return true;\n}\n\nSDValue\nTOYTargetLowering::LowerReturn(SDValue Chain, CallingConv::ID CallConv, bool isVarArg, const SmallVec torImpl<ISD::OutputArg> & Outs, const SmallVectorImpl<SDValue> const SmallVec torImpl<ISD::OutputArg> & Outs,\n  if (isVarArg) {\n    report_fatal_error(\"VarArg not supported\");\n  }\n\n  // CCValAssign - represent the assignment of\n  // the return value to a location\n  SmallVector<CCValAssign, 16> RVLocs;\n\n  // CCState - Info about the registers and stack slot.\n  CCState CCInfo(CallConv, isVarArg, DAG.getMachineFunction(), RVLocs,\n                 *DAG.getContext());\n\n  CCInfo.AnalyzeReturn(Outs, RetCC_TOY);\n\n  SDValue Flag;\n  SmallVector<SDValue, 4> RetOps(1, Chain);\n\n  // Copy the result values into the output registers.\n  for (unsigned i = 0, e = RVLocs.size(); i < e; ++i) {\n    CCValAssign &VA = RVLocs[i];\n    assert(VA.isRegLoc() && \"Can only return in registers!\");\n\n    Chain = DAG.getCopyToReg(Chain, dl, VA.getLocReg(), OutVals[i], Flag);\n\n    Flag = Chain.getValue(1);\n    RetOps.push_back(DAG.getRegister(VA.getLocReg(), VA.getLocVT()));\n  }\n\n  RetOps[0] = Chain; // Update chain.\n\n  // Add the flag if we have it.\n  if (Flag.getNode()) {\n    RetOps.push_back(Flag);\n  }\n\n  return DAG.getNode(TOYISD::RET_FLAG, dl, MVT::Other, RetOps);\n}\n```", "```cpp\nclass InstTOY<dag outs, dag ins, string asmstr, list<dag> pattern>\n    : Instruction {\n  field bits<32> Inst;\n  let Namespace = \"TOY\";\n  dag OutOperandList = outs;\n  dag InOperandList = ins;\n  let AsmString = asmstr;\n  let Pattern = pattern;\n  let Size = 4;\n}\n```", "```cpp\nvoid TOYInstPrinter::printOperand(const MCInst *MI, unsigned OpNo,\n                                  raw_ostream &O) {\n  const MCOperand &Op = MI->getOperand(OpNo);\n  if (Op.isReg()) {\n    printRegName(O, Op.getReg());\n    return;\n  }\n  if (Op.isImm()) {\n    O << \"#\" << Op.getImm();\n    return;\n  }\n  assert(Op.isExpr() && \"unknown operand kind in printOperand\");\n  printExpr(Op.getExpr(), O);\n}\n```", "```cpp\nvoid TOYInstPrinter::printRegName(raw_ostream &OS, unsigned RegNo) const {\n  OS << StringRef(getRegisterName(RegNo)).lower();\n}\n```", "```cpp\nvoid TOYInstPrinter::printInst(const MCInst *MI, raw_ostream &O,\n                               StringRef Annot) {\n  printInstruction(MI, O);\n  printAnnotation(O, Annot);\n}\n```", "```cpp\n#ifndef TOYTARGETASMINFO_H\n#define TOYTARGETASMINFO_H\n#include \"llvm/MC/MCAsmInfoELF.h\"\nnamespace llvm {\nclass StringRef;\nclass Target;\nclass TOYMCAsmInfo : public MCAsmInfoELF {\n  virtual void anchor();\n\npublic:\n  explicit TOYMCAsmInfo(StringRef TT);\n};\n} // namespace llvm\n#endif\n```", "```cpp\n#include \"TOYMCAsmInfo.h\"\n#include \"llvm/ADT/StringRef.h\"\nusing namespace llvm;\nvoid TOYMCAsmInfo::anchor() {}\nTOYMCAsmInfo::TOYMCAsmInfo(StringRef TT) {\n  SupportsDebugInformation = true;\n  Data16bitsDirective = \"\\t.short\\t\";\n  Data32bitsDirective = \"\\t.long\\t\";\n  Data64bitsDirective = 0;\n  ZeroDirective = \"\\t.space\\t\";\n  CommentString = \"#\";\n  AscizDirective = \".asciiz\";\n  HiddenVisibilityAttr = MCSA_Invalid;\n  HiddenDeclarationVisibilityAttr = MCSA_Invalid;\n  ProtectedVisibilityAttr = MCSA_Invalid;\n}\n```", "```cpp\n[component_0]\ntype = Library\nname = TOYAsmPrinter\nparent = TOY\nrequired_libraries = MC Support\nadd_to_library_groups = TOY\n```", "```cpp\nadd_llvm_library(LLVMTOYAsmPrinter\nTOYInstPrinter.cpp\n)\n```", "```cpp\n    set(LLVM_ALL_TARGETS\n    AArch64\n    ARM\n    …\n    …\n    TOY\n    )\n    ```", "```cpp\n    class Triple {\n    public:\n    enum ArchType {\n    UnknownArch,\n    arm, // ARM (little endian): arm, armv.*, xscale\n    armeb, // ARM (big endian): armeb\n    aarch64, // AArch64 (little endian): aarch64\n    …\n    …\n    toy // TOY: toy\n    };\n    ```", "```cpp\n    class MCSymbolRefExpr : public MCExpr {\n    public:\n    enum VariantKind {\n    ...\n    VK_TOY_LO,\n    VK_TOY_HI,\n    };\n    ```", "```cpp\n    enum {\n    EM_NONE = 0, // No machine\n    EM_M32 = 1, // AT&T WE 32100\n    …\n    …\n    EM_TOY = 220 // whatever is the next number\n    };\n    ```", "```cpp\n    StringRef MCSymbolRefExpr::getVariantKindName(VariantKind\n    Kind) {\n    switch (Kind) {\n    …\n    …\n    case VK_TOY_LO: return \"TOY_LO\";\n    case VK_TOY_HI: return \"TOY_HI\";\n    }\n    …\n    }\n    ```", "```cpp\n    const char *Triple::getArchTypeName(ArchType Kind) {\n    switch (Kind) {\n    …\n    …\n    case toy: return \"toy\";\n    }\n    const char *Triple::getArchTypePrefix(ArchType Kind) {\n    switch (Kind) {\n    …\n    …\n    case toy: return \"toy\";\n    }\n    }\n    Triple::ArchType Triple::getArchTypeForLLVMName(StringRef\n    Name) {\n    …\n    …\n    .Case(\"toy\", toy)\n    …\n    }\n    static Triple::ArchType parseArch(StringRef ArchName) {\n    …\n    …\n    .Case(\"toy\", Triple::toy)\n    …\n    }\n    static unsigned\n    getArchPointerBitWidth(llvm::Triple::ArchType Arch) {\n    …\n    …\n    case llvm::Triple::toy:\n    return 32;\n    …\n    …\n    }\n    Triple Triple::get32BitArchVariant() const {\n    …\n    …\n    case Triple::toy:\n    // Already 32-bit.\n    break;\n    …\n    }\n    Triple Triple::get64BitArchVariant() const {\n    …\n    …\n    case Triple::toy:\n    T.setArch(UnknownArch);\n    break;\n    …\n    …\n    }\n    ```", "```cpp\n    [common]\n    subdirectories = ARM AArch64 CppBackend Hexagon MSP430 … …\n    TOY\n    ```", "```cpp\n    #ifndef TARGET_TOY_H\n    #define TARGET_TOY_H\n    #include \"MCTargetDesc/TOYMCTargetDesc.h\"\n    #include \"llvm/Target/TargetMachine.h\"\n    namespace llvm {\n    class TargetMachine;\n    class TOYTargetMachine;\n    FunctionPass *createTOYISelDag(TOYTargetMachine &TM,\n                                   CodeGenOpt::Level OptLevel);\n    } // end namespace llvm;\n    #endif\n    ```", "```cpp\n    #include \"TOY.h\"\n    #include \"llvm/IR/Module.h\"\n    #include \"llvm/Support/TargetRegistry.h\"\n    using namespace llvm;\n    Target llvm::TheTOYTarget;\n    extern \"C\" void LLVMInitializeTOYTargetInfo() {\n      RegisterTarget<Triple::toy> X(TheTOYTarget, \"toy\", \"TOY\");\n    }\n    ```", "```cpp\n    add_llvm_library(LLVMTOYInfo TOYTargetInfo.cpp)\n    ```", "```cpp\n    [component_0]\n    type = Library\n    name = TOYInfo\n    parent = TOY\n    required_libraries = Support\n    add_to_library_groups = TOY\n    ```", "```cpp\n    #include \"TOYTargetMachine.h\"\n    #include \"TOY.h\"\n    #include \"TOYFrameLowering.h\"\n    #include \"TOYInstrInfo.h\"\n    #include \"TOYISelLowering.h \"\n    #include \"TOYSelectionDAGInfo.h\"\n    #include \"llvm/CodeGen/Passes.h\"\n    #include \"llvm/IR/Module.h\"\n    #include \"llvm/PassManager.h\"\n    #include \"llvm/Support/TargetRegistry.h\"\n    using namespace llvm;\n\n    TOYTargetMachine::TOYTargetMachine(const Target &T, StringRef TT, StringRef CPU, StringRef FS, const \n    TargetOptions &Options, Reloc::Model RM, CodeModel::Model CM, CodeGenOpt::Level OL)\n        : LLVMTargetMachine(T, TT, CPU, FS, Options, RM, CM, OL),\n          Subtarget(TT, CPU, FS, *this) {\n      initAsmInfo();\n    }\n\n    namespace {\n    class TOYPassConfig : public TargetPassConfig {\n    public:\n      TOYPassConfig(TOYTargetMachine *TM, PassManagerBase &PM)\n          : TargetPassConfig(TM, PM) {}\n      TOYTargetMachine &getTOYTargetMachine() const {\n        return getTM<TOYTargetMachine>();\n      }\n      virtual bool addPreISel();\n      virtual bool addInstSelector();\n      virtual bool addPreEmitPass();\n    };\n    } // namespace\n\n    TargetPassConfig *TOYTargetMachine::createPassConfig\n    (PassManagerBase &PM) {\n      return new TOYPassConfig(this, PM);\n    }\n\n    bool TOYPassConfig::addPreISel() { return false; }\n\n    bool TOYPassConfig::addInstSelector() {\n      addPass(createTOYISelDag(getTOYTargetMachine(), \n    getOptLevel()));\n      return false;\n    }\n\n    bool TOYPassConfig::addPreEmitPass() { return false; }\n\n    // Force static initialization.\n    extern \"C\" void LLVMInitializeTOYTarget() {\n      RegisterTargetMachine<TOYTargetMachine> X(TheTOYTarget);\n    }\n    void TOYTargetMachine::addAnalysisPasses(PassManagerBase &PM) {}\n    ```", "```cpp\n    #ifndef TOYMCTARGETDESC_H\n    #define TOYMCTARGETDESC_H\n    #include \"llvm/Support/DataTypes.h\"\n    namespace llvm {\n    class Target;\n    class MCInstrInfo;\n    class MCRegisterInfo;\n    class MCSubtargetInfo;\n    class MCContext;\n    class MCCodeEmitter;\n    class MCAsmInfo;\n    class MCCodeGenInfo;\n    class MCInstPrinter;\n    class MCObjectWriter;\n    class MCAsmBackend;\n    class StringRef;\n    class raw_ostream;\n    extern Target TheTOYTarget;\n\n    MCCodeEmitter *createTOYMCCodeEmitter(const MCInstrInfo &MCII, const MCRegisterInfo &MRI, const MCSubtargetInfo &STI, MCContext &Ctx);\n\n    MCAsmBackend *createTOYAsmBackend(const Target &T, const MCRegisterInfo &MRI, StringRef TT, StringRef CPU);\n\n    MCObjectWriter *createTOYELFObjectWriter(raw_ostream &OS, uint8_t OSABI);\n    } // End llvm namespace\n    #define GET_REGINFO_ENUM\n    #include \"TOYGenRegisterInfo.inc\"\n    #define GET_INSTRINFO_ENUM\n    #include \"TOYGenInstrInfo.inc\"\n    #define GET_SUBTARGETINFO_ENUM\n    #include \"TOYGenSubtargetInfo.inc\"\n    #endif\n    ```", "```cpp\n    #include \"TOYMCTargetDesc.h\"\n    #include \"InstPrinter/TOYInstPrinter.h\"\n    #include \"TOYMCAsmInfo.h\"\n    #include \"llvm/MC/MCCodeGenInfo.h\"\n    #include \"llvm/MC/MCInstrInfo.h\"\n    #include \"llvm/MC/MCRegisterInfo.h\"\n    #include \"llvm/MC/MCSubtargetInfo.h\"\n    #include \"llvm/MC/MCStreamer.h\"\n    #include \"llvm/Support/ErrorHandling.h\"\n    #include \"llvm/Support/FormattedStream.h\"\n    #include \"llvm/Support/TargetRegistry.h\"\n    #define GET_INSTRINFO_MC_DESC\n    #include \"TOYGenInstrInfo.inc\"\n    #define GET_SUBTARGETINFO_MC_DESC\n    #include \"TOYGenSubtargetInfo.inc\"\n    #define GET_REGINFO_MC_DESC\n    #include \"TOYGenRegisterInfo.inc\"\n    using namespace llvm;\n\n    static MCInstrInfo *createTOYMCInstrInfo() {\n      MCInstrInfo *X = new MCInstrInfo();\n      InitTOYMCInstrInfo(X);\n      return X;\n    }\n\n    static MCRegisterInfo *createTOYMCRegisterInfo(StringRef TT) {\n      MCRegisterInfo *X = new MCRegisterInfo();\n      InitTOYMCRegisterInfo(X, TOY::LR);\n      return X;\n    }\n\n    static MCSubtargetInfo *createTOYMCSubtargetInfo(StringRef TT, StringRef CPU, StringRef FS) {\n      MCSubtargetInfo *X = new MCSubtargetInfo();\n      InitTOYMCSubtargetInfo(X, TT, CPU, FS);\n      return X;\n    }\n\n    static MCAsmInfo *createTOYMCAsmInfo(const MCRegisterInfo &MRI, StringRef TT) {\n      MCAsmInfo *MAI = new TOYMCAsmInfo(TT);\n      return MAI;\n    }\n    static MCCodeGenInfo *createTOYMCCodeGenInfo(StringRef TT, Reloc::Model RM, CodeModel::Model CM, CodeGenOpt::Level OL)\n     {\n      MCCodeGenInfo *X = new MCCodeGenInfo();\n      if (RM == Reloc::Default) {\n        RM = Reloc::Static;\n      }\n      if (CM == CodeModel::Default) {\n        CM = CodeModel::Small;\n      }\n      if (CM != CodeModel::Small && CM != CodeModel::Large) {\n        report_fatal_error(\"Target only supports CodeModel Small or Large\");\n      }\n      X->InitMCCodeGenInfo(RM, CM, OL);\n      return X;\n    }\n\n    static MCInstPrinter *\n    createTOYMCInstPrinter(const Target &T, unsigned SyntaxVariant,\n                           const MCAsmInfo &MAI, const MCInstrInfo & MII, const MCRegisterInfo &MRI, const MCSubtargetInfo &STI) {\n      return new TOYInstPrinter(MAI, MII, MRI);\n    }\n\n    static MCStreamer *\n    createMCAsmStreamer(MCContext &Ctx, formatted_raw_ostream &OS,\n                        bool isVerboseAsm, bool useDwarfDirectory,\n                        MCInstPrinter *InstPrint, MCCodeEmitter *CE,\n                        MCAsmBackend *TAB, bool ShowInst) {\n      return createAsmStreamer(Ctx, OS, isVerboseAsm, useD - warfDirectory, InstPrint, CE, TAB, ShowInst);\n    }\n\n    static MCStreamer *createMCStreamer(const Target &T, StringRef TT,\n    MCContext &Ctx, MCAsmBackend &MAB, raw_ostream &OS,\n    MCCodeEmitter *Emitter, const MCSubtargetInfo &STI,\n    bool RelaxAll, bool NoExecStack) {\n      return createELFStreamer(Ctx, MAB, OS, Emitter, false, NoExecStack);\n    }\n\n    // Force static initialization.\n    extern \"C\" void LLVMInitializeTOYTargetMC() {\n      // Register the MC asm info.\n      RegisterMCAsmInfoFn X(TheTOYTarget, createTOYMCAsmInfo);\n      // Register the MC codegen info.\n      TargetRegistry::RegisterMCCodeGenInfo(TheTOYTarget, createTOYMCCodeGenInfo);\n      // Register the MC instruction info.\n      TargetRegistry::RegisterMCInstrInfo(TheTOYTarget, createTOYMCInstrInfo);\n      // Register the MC register info.\n      TargetRegistry::RegisterMCRegInfo(TheTOYTarget, createTOYMCRegisterInfo);\n      // Register the MC subtarget info.\n      TargetRegistry::RegisterMCSubtargetInfo(TheTOYTarget,\n                                              createTOYMCSub targetInfo);\n      // Register the MCInstPrinter\n      TargetRegistry::RegisterMCInstPrinter(TheTOYTarget, createTOYMCInstPrinter);\n      // Register the ASM Backend.\n      TargetRegistry::RegisterMCAsmBackend(TheTOYTarget, createTOYAsmBackend);\n      // Register the assembly streamer.\n      TargetRegistry::RegisterAsmStreamer(TheTOYTarget, createMCAsmStreamer);\n      // Register the object streamer.\n      TargetRegistry::RegisterMCObjectStreamer(TheTOYTarget, createMCStreamer);\n      // Register the MCCodeEmitter\n      TargetRegistry::RegisterMCCodeEmitter(TheTOYTarget, createTOYMCCodeEmitter);\n    }\n    ```", "```cpp\n    [component_0]\n    type = Library\n    name = TOYDesc\n    parent = TOY\n    required_libraries = MC Support TOYAsmPrinter TOYInfo\n    add_to_library_groups = TOY\n    ```", "```cpp\n    add_llvm_library(LLVMTOYDesc\n    TOYMCTargetDesc.cpp)\n    ```", "```cpp\n    $ cmake llvm_src_dir –DCMAKE_BUILD_TYPE=Release –\n    DLLVM_TARGETS_TO_BUILD=\"TOY\"\n    $ make\n\n    Here, we have specified that we are building the LLVM compiler for the toy target. After the build completes, check whether the TOY target appears with the llc command:\n    $ llc –version\n    …\n    …\n    Registered Targets :\n    toy – TOY\n    ```", "```cpp\ntarget datalayout = \"e-m:e-p:32:32-i1:8:32-i8:8:32- i16:16:32-i64:32-f64:32-a:0:32-n32\"\ntarget triple = \"toy\"\ndefine i32 @foo(i32 %a, i32 %b){\n  %c = add nsw i32 %a, %b\n  ret i32 %c\n}\n\n$ llc foo.ll\n\n.text\n.file \"foo.ll\"\n.globl foo\n.type foo,@function\nfoo: # @foo\n# BB#0: # %entry\nadd r0, r0, r1\nb lr\n.Ltmp0:\n.size foo, .Ltmp0-foo\n```"]