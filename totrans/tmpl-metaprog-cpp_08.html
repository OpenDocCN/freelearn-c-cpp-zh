<html><head></head><body><div><div><h1 id="_idParaDest-93"><em class="italic"><a id="_idTextAnchor099"/>Chapter 6</em>: Concepts and Constraints</h1>
			<p>The C++20 standard provides a series of significant improvements to template metaprogramming with concepts and constraints. A <strong class="bold">constraint</strong> is a modern way to define requirements on template parameters. A <strong class="bold">concept</strong> is a set of named constraints. Concepts provide several benefits to the traditional way of writing templates, mainly improved readability of code, better diagnostics, and reduced compilation times.</p>
			<p>In this chapter, we will address the following topics:</p>
			<ul>
				<li>Understanding the need for concepts</li>
				<li>Defining concepts</li>
				<li>Exploring requires expressions</li>
				<li>Composing constraints</li>
				<li>Learning about the ordering of templates with constraints</li>
				<li>Constraining non-template member functions</li>
				<li>Constraining class templates</li>
				<li>Constraining variable templates and template aliases</li>
				<li>Learning more ways to specify constraints</li>
				<li>Using concepts to constrain auto parameters</li>
				<li>Exploring the standard concepts library</li>
			</ul>
			<p>By the end of this chapter, you will have a good understanding of the C++20 concepts, and an overview of what concepts the standard library provides.</p>
			<p>We will start the chapter by discussing what led to the development of concepts and what their main benefits are.</p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor100"/>Understanding the need for concepts</h1>
			<p>As briefly mentioned in the introduction to this chapter, there are some important benefits that <a id="_idIndexMarker512"/>concepts provide. Arguably, the most important ones are code readability and better error messages. Before we look at how to use concepts, let’s revisit an example we saw previously and see how it stands in relation to these two programming aspects:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">T add(T const a, T const b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a + b;</pre>
			<pre class="source-code">}</pre>
			<p>This simple function template takes two arguments and returns their sum. In fact, it does not return the sum, but the result of applying the plus operator to the two arguments. A user-defined type can overload this operator and perform some particular operation. The term <em class="italic">sum</em> only makes <a id="_idIndexMarker513"/>sense when we discuss mathematical types, such as integral types, floating-point types, the <code>std::complex</code> type, matrix types, vector types, etc.</p>
			<p>For a string type, for instance, the plus operator can mean concatenation. And for most types, its overloading <a id="_idIndexMarker514"/>does not make sense at all. Therefore, just by looking at the declaration of the function, without inspecting its body, we cannot really say what this function may accept as input and what it does. We can call this function as follows:</p>
			<pre class="source-code">add(42, 1);       // [1]</pre>
			<pre class="source-code">add(42.0, 1.0);   // [2]</pre>
			<pre class="source-code">add("42"s, "1"s); // [3]</pre>
			<pre class="source-code">add("42", "1");   // [4] error: cannot add two pointers</pre>
			<p>The first three calls are all good; the first call adds two integers, the second adds two <code>double</code> values, and the third concatenates two <code>std::string</code> objects. However, the fourth call will produce a compiler error because <code>const char *</code> is substituted for the <code>T</code> type template parameter, and the plus operator is not overloaded for pointer types. </p>
			<p>The intention for this <code>add</code> function template is to allow passing only values of arithmetic types, that is, integer and floating-point types. Before C++20, we could do this in several ways. </p>
			<p>One way is to use <code>std::enable_if</code> and SFINAE, as we saw in the previous chapter. Here is such an implementation:</p>
			<pre class="source-code">template &lt;typename T,</pre>
			<pre class="source-code">   typename = typename std::enable_if_t</pre>
			<pre class="source-code">      &lt;std::is_arithmetic_v&lt;T&gt;&gt;&gt;</pre>
			<pre class="source-code">T add(T const a, T const b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a + b;</pre>
			<pre class="source-code">}</pre>
			<p>The first thing to notice here is that the readability has decreased. The second type template parameter is difficult to read and requires good knowledge of templates to understand. However, this <a id="_idIndexMarker515"/>time, both the calls on the lines marked with <code>[3]</code> and <code>[4]</code> are producing a compiler error. Different compilers are issuing different error messages. Here are the ones for the three major compilers:</p>
			<ul>
				<li>In <strong class="bold">VC++ 17</strong>, the output is:<pre><strong class="bold">error C2672: 'add': no matching overloaded function found</strong>
<strong class="bold">error C2783: 'T add(const T,const T)': could not deduce template argument for '&lt;unnamed-symbol&gt;'</strong></pre></li>
				<li>In <strong class="bold">GCC 12</strong>, the output is:<pre><strong class="bold">prog.cc: In function 'int main()':</strong>
<strong class="bold">prog.cc:15:8: error: no matching function for call to 'add(std::__cxx11::basic_string&lt;char&gt;, std::__cxx11::basic_string&lt;char&gt;)'</strong>
<strong class="bold">   </strong><strong class="bold">15 |     add("42"s, "1"s);</strong>
<strong class="bold">      |     ~~~^~~~~~~~~~~~~</strong>
<strong class="bold">prog.cc:6:6: note: candidate: 'template&lt;class T, class&gt; T add(T, T)'</strong>
<strong class="bold">    6 |    T add(T const a, T const b)</strong>
<strong class="bold">      |      ^~~</strong>
<strong class="bold">prog.cc:6:6: note:   template argument deduction/substitution failed:</strong>
<strong class="bold">In file included from /opt/wandbox/gcc-head/include/c++/12.0.0/bits/move.h:57,</strong>
<strong class="bold">                 from /opt/wandbox/gcc-head/include/c++/12.0.0/bits/nested_exception.h:40,</strong>
<strong class="bold">                 </strong><strong class="bold">from /opt/wandbox/gcc-head/include/c++/12.0.0/exception:154,</strong>
<strong class="bold">                 from /opt/wandbox/gcc-head/include/c++/12.0.0/ios:39,</strong>
<strong class="bold">                 from /opt/wandbox/gcc-head/include/c++/12.0.0/ostream:38,</strong>
<strong class="bold">                 from /opt/wandbox/gcc-head/include/c++/12.0.0/iostream:39,</strong>
<strong class="bold">                 from prog.cc:1:</strong>
<strong class="bold">/opt/wandbox/gcc-head/include/c++/12.0.0/type_traits: In substitution of 'template&lt;bool _Cond, class _Tp&gt; using enable_if_t = typename std::enable_if::type [with bool _Cond = false; _Tp = void]':</strong>
<strong class="bold">prog.cc:5:14:   required from here</strong>
<strong class="bold">/opt/wandbox/gcc-head/include/c++/12.0.0/type_traits:2603:11: error: no type named 'type' in 'struct std::enable_if&lt;false, void&gt;'</strong>
<strong class="bold"> 2603 |     using enable_if_t = typename enable_if&lt;_Cond, _Tp&gt;::type;</strong>
<strong class="bold">      |           ^~~~~~~~~~~</strong></pre></li>
				<li>In <strong class="bold">Clang 13</strong>, the output is:<pre><strong class="bold">prog.cc:15:5: error: no matching function for call to 'add'</strong>
<strong class="bold">    add("42"s, "1"s);</strong>
<strong class="bold">    ^~~</strong>
<strong class="bold">prog.cc:6:6: note: candidate template ignored: requirement 'std::is_arithmetic_v&lt;std::string&gt;' was not satisfied [with T = std::string]</strong>
<strong class="bold">   T add(T const a, T const b)</strong>
<strong class="bold">     ^</strong></pre></li>
			</ul>
			<p>The error message in GCC is <a id="_idIndexMarker516"/>very verbose, and VC++ doesn’t say what the reason for failing to match the template argument is. Clang does, arguably, a better job at providing an understandable error message.</p>
			<p>Another way to define restrictions for this function, prior to C++20, is with the help of a <code>static_assert</code> statement, as shown in the following snippet:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">T add(T const a, T const b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   static_assert(std::is_arithmetic_v&lt;T&gt;, </pre>
			<pre class="source-code">                 "Arithmetic type required");</pre>
			<pre class="source-code">   return a + b;</pre>
			<pre class="source-code">}</pre>
			<p>With this implementation, however, we returned to the original problem that just by looking at the declaration of the function, we wouldn’t know what kind of parameters it would accept, provided that any restriction exists. The error messages, on the other hand, are as follows:</p>
			<ul>
				<li>In <strong class="bold">VC++ 17</strong>:<pre><strong class="bold">error C2338: Arithmetic type required</strong>
<strong class="bold">main.cpp(157): message : see reference to function template instantiation 'T add&lt;std::string&gt;(const T,const T)' being compiled</strong>
<strong class="bold">     with</strong>
<strong class="bold">     [</strong>
<strong class="bold">         T=std::string</strong>
<strong class="bold">     ]</strong></pre></li>
				<li>In <strong class="bold">GCC 12</strong>:<pre><strong class="bold">prog.cc: In instantiation of 'T add(T, T) [with T = std::__cxx11::basic_string&lt;char&gt;]':</strong>
<strong class="bold">prog.cc:15:8:   required from here</strong>
<strong class="bold">prog.cc:7:24: error: static assertion failed: Arithmetic type required</strong>
<strong class="bold">    7 |</strong><strong class="bold">     static_assert(std::is_arithmetic_v&lt;T&gt;, "Arithmetic type required");</strong>
<strong class="bold">      |                   ~~~~~^~~~~~~~~~~~~~~~~~</strong>
<strong class="bold">prog.cc:7:24: note: 'std::is_arithmetic_v&lt;std::__cxx11::basic_string&lt;char&gt; &gt;' evaluates to false</strong></pre></li>
				<li>In <strong class="bold">Clang 13</strong>:<pre><strong class="bold">prog.cc:7:5: error: static_assert failed due to requirement 'std::is_arithmetic_v&lt;std::string&gt;' "Arithmetic type required"</strong>
<strong class="bold">    static_assert(std::is_arithmetic_v&lt;T&gt;, "Arithmetic type required");</strong>
<strong class="bold">    ^             ~~~~~~~~~~~~~~~~~~~~~~~</strong>
<strong class="bold">prog.cc:15:5: note: in instantiation of function template specialization 'add&lt;std::string&gt;' requested here</strong>
<strong class="bold">    add("42"s, "1"s);</strong>
<strong class="bold">    ^</strong></pre></li>
			</ul>
			<p>The use of the <code>static_assert</code> statement results in similar error messages received regardless of the compiler.</p>
			<p>We can improve these two <a id="_idIndexMarker517"/>discussed aspects (readability and error messages) in C++20 by using constraints. These are introduced with the new <code>requires</code> keyword as follows:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">requires std::is_arithmetic_v&lt;T&gt;</pre>
			<pre class="source-code">T add(T const a, T const b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a + b;</pre>
			<pre class="source-code">}</pre>
			<p>The <code>requires</code> keyword introduces a clause, called the <strong class="bold">requires clause</strong>, that defines the constraints on the template <a id="_idIndexMarker518"/>parameters. There are, actually, two alternative syntaxes: one when the requires clause follows the template parameter list, as seen previously, and one when the requires clause follows the function declaration, as shown in the next snippet:</p>
			<pre class="source-code">template &lt;typename T&gt;      </pre>
			<pre class="source-code">T add(T const a, T const b)</pre>
			<pre class="source-code">requires std::is_arithmetic_v&lt;T&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a + b;</pre>
			<pre class="source-code">}</pre>
			<p>Choosing between these two syntaxes is a matter of personal preference. However, in both cases, the readability is much better than in the pre-C++20 implementations. You know just by reading the declaration that the <code>T</code> type template parameter must be of an arithmetic type. Also, this implies that the function is simply adding two numbers. You don’t really need to see the definition to know that. Let’s see how the error message changes when we <a id="_idIndexMarker519"/>call the function with invalid arguments:</p>
			<ul>
				<li>In <strong class="bold">VC++ 17</strong>:<pre><strong class="bold">error C2672: 'add': no matching overloaded function found</strong>
<strong class="bold">error C7602: 'add': the associated constraints are not satisfied</strong></pre></li>
				<li>In <strong class="bold">GCC 12</strong>:<pre><strong class="bold">prog.cc: In function 'int main()':</strong>
<strong class="bold">prog.cc:15:8: error: no matching function for call to 'add(std::__cxx11::basic_string&lt;char&gt;, std::__cxx11::basic_string&lt;char&gt;)'</strong>
<strong class="bold">   15 |     add("42"s, "1"s);</strong>
<strong class="bold">      </strong><strong class="bold">|     ~~~^~~~~~~~~~~~~</strong>
<strong class="bold">prog.cc:6:6: note: candidate: 'template&lt;class T&gt;  requires  is_arithmetic_v&lt;T&gt; T add(T, T)'</strong>
<strong class="bold">    6 |    T add(T const a, T const b)</strong>
<strong class="bold">      |      ^~~</strong>
<strong class="bold">prog.cc:6:6: note:   template argument deduction/substitution failed:</strong>
<strong class="bold">prog.cc:6:6: note: constraints not satisfied</strong>
<strong class="bold">prog.cc: In substitution of 'template&lt;class T&gt;  requires  </strong><strong class="bold">is_arithmetic_v&lt;T&gt; T add(T, T) [with T = std::__cxx11::basic_string&lt;char&gt;]':</strong>
<strong class="bold">prog.cc:15:8:   required from here</strong>
<strong class="bold">prog.cc:6:6:   required by the constraints of 'template&lt;class T&gt;  requires  is_arithmetic_v&lt;T&gt; T add(T, T)'</strong>
<strong class="bold">prog.cc:5:15: note: the expression 'is_arithmetic_v&lt;T&gt; [with T = std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;]' evaluated to 'false'</strong>
<strong class="bold">    5 | requires std::is_arithmetic_v&lt;T&gt;</strong>
<strong class="bold">      |          ~~~~~^~~~~~~~~~~~~~~~~~</strong></pre></li>
				<li>In <strong class="bold">Clang 13</strong>:<pre><strong class="bold">prog.cc:15:5: error: no matching function for call to 'add'</strong>
<strong class="bold">    </strong><strong class="bold">add("42"s, "1"s);</strong>
<strong class="bold">    ^~~</strong>
<strong class="bold">prog.cc:6:6: note: candidate template ignored: constraints not satisfied [with T = std::string]</strong>
<strong class="bold">   T add(T const a, T const b)</strong>
<strong class="bold">     ^</strong>
<strong class="bold">prog.cc:5:10: note: because 'std::is_arithmetic_v&lt;std::string&gt;' evaluated to false</strong>
<strong class="bold">requires std::is_arithmetic_v&lt;T&gt;</strong>
<strong class="bold">         ^</strong></pre></li>
			</ul>
			<p>The error messages follow the same patterns seen already: GCC is too verbose, VC++ is missing essential <a id="_idIndexMarker520"/>information (the constraint that is not met), while Clang is more concise and better pinpoints the cause of the error. Overall, there is an improvement in the diagnostic messages, although there is still room for improvement. </p>
			<p>A constraint is a predicate that evaluates to true or false at compile-time. The expression used in <a id="_idIndexMarker521"/>the previous example, <code>std::is_arithmetic_v&lt;T&gt;</code>, is simply using a standard type trait (which we saw in the previous chapter). However, these are different kinds of expressions that can be used in a constraint, and we will learn about them later in this chapter.</p>
			<p>In the next section, we look at how to define and use named constraints.</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor101"/>Defining concepts</h1>
			<p>The constraints seen previously <a id="_idIndexMarker522"/>are nameless predicates defined in the places they are used. Many constraints are generic and can be used in multiple places. Let’s consider the following example of a function similar to the <code>add</code> function. This function performs the multiplication of arithmetic values and is shown next:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">requires std::is_arithmetic_v&lt;T&gt;</pre>
			<pre class="source-code">T mul(T const a, T const b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a * b;</pre>
			<pre class="source-code">}</pre>
			<p>The same requires clause seen with the <code>add</code> function is present here. To avoid this repetitive code, we can <a id="_idIndexMarker523"/>define a name constraint that can be reused in multiple places. A named constraint is called a <code>concept</code> keyword and template syntax. Here is an example:</p>
			<pre class="source-code">template&lt;typename T&gt;</pre>
			<pre class="source-code">concept arithmetic = std::is_arithmetic_v&lt;T&gt;;</pre>
			<p>Even though they are assigned a Boolean value, concept names should not contain verbs. They represent requirements and are used as attributes or qualifiers on template parameters. Therefore, you should prefer names such as <em class="italic">arithmetic</em>, <em class="italic">copyable</em>, <em class="italic">serializable</em>, <em class="italic">container</em>, and more, and not <em class="italic">is_arithmetic</em>, <em class="italic">is_copyable</em>, <em class="italic">is_serializable</em>, and <em class="italic">is_container</em>. The previously defined arithmetic concept can be used as follows:</p>
			<pre class="source-code">template &lt;arithmetic T&gt;</pre>
			<pre class="source-code">T add(T const a, T const b) { return a + b; }</pre>
			<pre class="source-code">template &lt;arithmetic T&gt;</pre>
			<pre class="source-code">T mul(T const a, T const b) { return a * b; }</pre>
			<p>You can see from this snippet that the concept is used instead of the <code>typename</code> keyword. It qualifies the <code>T</code> type with the arithmetic quality, meaning that only the types that satisfy this requirement can be used as template arguments. The same arithmetic concept can be defined with a different syntax, shown in the following snippet:</p>
			<pre class="source-code">template&lt;typename T&gt;</pre>
			<pre class="source-code">concept arithmetic = requires { std::is_arithmetic_v&lt;T&gt;; };</pre>
			<p>This uses a <em class="italic">requires expression</em>. A requires expression uses curly branches, <code>{}</code>, whereas <a id="_idIndexMarker524"/>a <em class="italic">requires clause</em> does not. A requires expression can contain a sequence of requirements of different kinds: simple requirements, type requirements, compound <a id="_idIndexMarker525"/>requirements, and nested requirements. The one seen here is a simple requirement. For the purpose of defining this particular concept, this syntax is more complicated but has the same final effect. However, in some cases, complex requirements are needed. Let’s look at an example.</p>
			<p>Consider the case when we want to define a template that should only take container types for an argument. Before concepts were available, this could have been solved with the help of a type trait <a id="_idIndexMarker526"/>and SFINAE or a <code>static_assert</code> statement, as we saw at the beginning of this chapter. However, a container type is not really easy to define formally. We can do it based on some properties of the standard containers:</p>
			<ul>
				<li>They have the member types <code>value_type</code>, <code>size_type</code>, <code>allocator_type</code>, <code>iterator</code>, and <code>const_iterator</code>.</li>
				<li>They have the member function <code>size</code> that returns the number of elements in the container.</li>
				<li>They have the member functions <code>begin</code>/<code>end</code> and <code>cbegin</code>/<code>cend</code> that return iterators and constant iterators to the first and one-past-the-last element in the container.</li>
			</ul>
			<p>With the knowledge accumulated from <a href="B18367_05_ePub.xhtml#_idTextAnchor080"><em class="italic">Chapter 5</em></a>, <em class="italic">Type Traits and Conditional Compilation</em>, we can define an <code>is_containter</code> type trait as follows:</p>
			<pre class="source-code">template &lt;typename T, typename U = void&gt;</pre>
			<pre class="source-code">struct is_container : std::false_type {};</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct is_container&lt;T,</pre>
			<pre class="source-code">   std::void_t&lt;typename T::value_type,</pre>
			<pre class="source-code">               typename T::size_type,</pre>
			<pre class="source-code">               typename T::allocator_type,</pre>
			<pre class="source-code">               typename T::iterator,</pre>
			<pre class="source-code">               typename T::const_iterator,</pre>
			<pre class="source-code">               decltype(std::declval&lt;T&gt;().size()),</pre>
			<pre class="source-code">               decltype(std::declval&lt;T&gt;().begin()),</pre>
			<pre class="source-code">               decltype(std::declval&lt;T&gt;().end()),</pre>
			<pre class="source-code">               decltype(std::declval&lt;T&gt;().cbegin()),</pre>
			<pre class="source-code">               decltype(std::declval&lt;T&gt;().cend())&gt;&gt; </pre>
			<pre class="source-code">   : std::true_type{};</pre>
			<pre class="source-code">template &lt;typename T, typename U = void&gt;</pre>
			<pre class="source-code">constexpr bool is_container_v = is_container&lt;T, U&gt;::value;</pre>
			<p>We can verify with the help of <code>static_assert</code> statements that the type trait correctly identifies <a id="_idIndexMarker527"/>container types. Here is an example:</p>
			<pre class="source-code">struct foo {};</pre>
			<pre class="source-code">static_assert(!is_container_v&lt;foo&gt;);</pre>
			<pre class="source-code">static_assert(is_container_v&lt;std::vector&lt;foo&gt;&gt;);</pre>
			<p>Concepts make writing such a template constraint much easier. We can employ the concept syntax and requires expressions to define the following:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">concept container = requires(T t)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   typename T::value_type;</pre>
			<pre class="source-code">   typename T::size_type;</pre>
			<pre class="source-code">   typename T::allocator_type;</pre>
			<pre class="source-code">   typename T::iterator;</pre>
			<pre class="source-code">   typename T::const_iterator;</pre>
			<pre class="source-code">   t.size();</pre>
			<pre class="source-code">   t.begin();</pre>
			<pre class="source-code">   t.end();</pre>
			<pre class="source-code">   t.cbegin();</pre>
			<pre class="source-code">   t.cend();</pre>
			<pre class="source-code">};</pre>
			<p>This definition is both shorter and more readable. It uses both simple requirements, such as <code>t.size()</code>, and type requirements, such as <code>typename T::value_type</code>. It can be used to constrain template <a id="_idIndexMarker528"/>parameters in the manner seen previously but can also be used with the <code>static_assert</code> statements (since constraints evaluate to a compile-time Boolean value):</p>
			<pre class="source-code">struct foo{};</pre>
			<pre class="source-code">static_assert(!container&lt;foo&gt;);</pre>
			<pre class="source-code">static_assert(container&lt;std::vector&lt;foo&gt;&gt;);</pre>
			<pre class="source-code">template &lt;container C&gt;</pre>
			<pre class="source-code">void process(C&amp;&amp; c) {}</pre>
			<p>In the following section, we will explore in depth the various kinds of requirements that can be used in requires expressions.</p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor102"/>Exploring requires expressions</h1>
			<p>A requires expression may be a complex expression, as seen earlier in the example with the container <a id="_idIndexMarker529"/>concept. The actual form of a requires expression is very similar to function syntax and is as follows:</p>
			<pre class="source-code">requires (parameter-list) { requirement-seq }</pre>
			<p>The <code>parameter-list</code> is a comma-separated list of parameters. The only difference from a function declaration is that default values are not allowed. However, the parameters that are specified in this list do not have storage, linkage, or lifetime. The compiler does not allocate any memory for them; they are only used to define requirements. However, they do have a scope, and that is the closing curly brace of the requires expression.</p>
			<p>The <code>requirements-seq</code> is a sequence of requirements. Each such requirement must end with a semicolon, like any <a id="_idIndexMarker530"/>statement in C++. There are four types of requirements:</p>
			<ul>
				<li>Simple requirements</li>
				<li>Type requirements</li>
				<li>Compound requirements</li>
				<li>Nested requirements</li>
			</ul>
			<p>These requirements may refer to the following:</p>
			<ul>
				<li>Template parameters that are in scope</li>
				<li>Local parameters introduced in the parameter list of the requires expression</li>
				<li>Any other declaration that is visible from the enclosing context</li>
			</ul>
			<p>In the following subsections, we will explore all the mentioned types of requirements. In the beginning, we’ll look at the simple requirements.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor103"/>Simple requirements</h2>
			<p>A <code>true</code>. The expression must not start with the <code>requires</code> keyword as that defines a nested requirement (which will be discussed later).</p>
			<p>We already saw <a id="_idIndexMarker533"/>examples of simple statements when we <a id="_idIndexMarker534"/>defined the <code>arithmetic</code> and <code>container</code> concepts earlier. Let’s see a few more:</p>
			<pre class="source-code">template&lt;typename T&gt;</pre>
			<pre class="source-code">concept arithmetic = requires </pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   std::is_arithmetic_v&lt;T&gt;; </pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">concept addable = requires(T a, T b) </pre>
			<pre class="source-code">{ </pre>
			<pre class="source-code">   a + b; </pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">concept logger = requires(T t)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   t.error("just");</pre>
			<pre class="source-code">   t.warning("a");</pre>
			<pre class="source-code">   t.info("demo");</pre>
			<pre class="source-code">};</pre>
			<p>The first concept, <code>arithmetic</code>, is the same one we defined earlier. The <code>std::is_arithmetic_v&lt;T&gt;</code> expression is a simple requirement. Notice that when the parameter list is empty it can be completely omitted, as seen in this case, where we only check that the <code>T</code> type template parameter is an arithmetic type.</p>
			<p>The <code>addable</code> and <code>logger</code> concepts both have a parameter list because we are checking operations on values of the <code>T</code> type. The expression <code>a + b</code> is a simple requirement, as the compiler just checks that the plus operator is overloaded for the <code>T</code> type. In the last example, we make sure that the <code>T</code> type has three member functions called <code>error</code>, <code>warning</code>, and <code>info</code> that take a single parameter of the <code>const char*</code> type or some <a id="_idIndexMarker535"/>type that can be constructed <a id="_idIndexMarker536"/>from <code>const char*</code>. Keep in mind that the actual values passed as arguments have no importance since these calls are never performed; they are only checked for correctness.</p>
			<p>Let’s elaborate briefly on the last example and consider the following snippet:</p>
			<pre class="source-code">template &lt;logger T&gt;</pre>
			<pre class="source-code">void log_error(T&amp; logger)</pre>
			<pre class="source-code">{}</pre>
			<pre class="source-code">struct console_logger</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void error(std::string_view text){}</pre>
			<pre class="source-code">   void warning(std::string_view text) {}</pre>
			<pre class="source-code">   void info(std::string_view text) {}</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">struct stream_logger</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void error(std::string_view text, bool = false) {}</pre>
			<pre class="source-code">   void warning(std::string_view text, bool = false) {}</pre>
			<pre class="source-code">   void info(std::string_view text, bool) {}</pre>
			<pre class="source-code">};</pre>
			<p>The <code>log_error</code> function template requires an argument of a type that meets the <code>logger</code> requirements. We have two classes, called <code>console_logger</code> and <code>stream_logger</code>. The first meets the <code>logger</code> requirements, but the second does not. That is because the <code>info</code> function cannot be invoked with a single argument of type <code>const char*</code>. This function also requires a second, Boolean, argument. The first two methods, <code>error</code> and <code>warning</code>, define a default value for the second argument, so they can be invoked with calls such as <code>t.error("just")</code> and <code>warning("a")</code>. </p>
			<p>However, because <a id="_idIndexMarker537"/>of the third member function, <code>stream_logger</code> is not <a id="_idIndexMarker538"/>a log class that meets the expected requirements and, therefore, cannot be used with the <code>log_error</code> function. The use of <code>console_logger</code> and <code>stream_logger</code> is exemplified in the following snippet:</p>
			<pre class="source-code">console_logger cl;</pre>
			<pre class="source-code">log_error(cl);      // OK</pre>
			<pre class="source-code">stream_logger sl;</pre>
			<pre class="source-code">log_error(sl);      // error</pre>
			<p>In the next section, we look at the second category of requirements, type requirements.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor104"/>Type requirements</h2>
			<p><code>typename</code> followed by the name of a type. We have <a id="_idIndexMarker539"/>already seen several examples when we <a id="_idIndexMarker540"/>defined the <code>container</code> constraint. The name of the type must be valid for the requirement to be true. Type requirements can be <a id="_idIndexMarker541"/>used for several purposes:</p>
			<ul>
				<li>To verify that a nested type exists (such as in <code>typename T::value_type;</code>)</li>
				<li>To verify that a class template specialization names a type</li>
				<li>To verify that an alias <a id="_idIndexMarker542"/>template specialization names a type</li>
			</ul>
			<p>Let’s see several examples to learn how to use type requirements. In the first example, we check whether <a id="_idIndexMarker543"/>a type contains the inner <a id="_idIndexMarker544"/>types, <code>key_type</code> and <code>value_type</code>:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">concept KVP = requires </pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   typename T::key_type;</pre>
			<pre class="source-code">   typename T::value_type;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename T, typename V&gt;</pre>
			<pre class="source-code">struct key_value_pair</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   using key_type = T;</pre>
			<pre class="source-code">   using value_type = V;</pre>
			<pre class="source-code">   key_type    key;</pre>
			<pre class="source-code">   value_type  value;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">static_assert(KVP&lt;key_value_pair&lt;int, std::string&gt;&gt;);</pre>
			<pre class="source-code">static_assert(!KVP&lt;std::pair&lt;int, std::string&gt;&gt;);</pre>
			<p>The type, <code>key_value_pair&lt;int, std::string&gt;</code>, satisfies these type requirements, but <code>std::pair&lt;int, std::string&gt;</code> does not. The <code>std::pair</code> type does have inner types, but they are called <code>first_type</code> and <code>second_type</code>.</p>
			<p>In the second <a id="_idIndexMarker545"/>example, we check whether a class <a id="_idIndexMarker546"/>template specialization names a type. The class template is <code>container</code>, and the specialization is <code>container&lt;T&gt;</code>:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">requires std::is_arithmetic_v&lt;T&gt;</pre>
			<pre class="source-code">struct container</pre>
			<pre class="source-code">{ /* ... */ };</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">concept containerizeable = requires {</pre>
			<pre class="source-code">   typename container&lt;T&gt;;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">static_assert(containerizeable&lt;int&gt;);</pre>
			<pre class="source-code">static_assert(!containerizeable&lt;std::string&gt;);</pre>
			<p>In this snippet, <code>container</code> is a class template that can only be specialized for arithmetic types, such as <code>int</code>, <code>long</code>, <code>float</code>, or <code>double</code>. Therefore, specializations such as <code>container&lt;int&gt;</code> exist, but <code>container&lt;std::string&gt;</code> does not. The <code>containerizeable</code> concept specifies a requirement for a type <code>T</code> to define a valid specialization of <code>container</code>. Therefore, <code>containerizeable&lt;int&gt;</code> is true, but <code>containerizeable&lt;std::string&gt;</code> is false.</p>
			<p>Now that we have understood simple requirements and type requirements it is time to explore the more complex category of requirements. The first to look at is compound requirements.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor105"/>Compound requirements</h2>
			<p>Simple requirements <a id="_idIndexMarker547"/>allow us to verify that an expression is valid. However, sometimes we need to verify some properties of an expression not <a id="_idIndexMarker548"/>just that it is valid. This can include whether an expression does not throw exceptions or requirements on the result type (such as the return type of a function). The general form is the following:</p>
			<pre class="source-code">{ expression } noexcept -&gt; type_constraint;</pre>
			<p>Both the <code>noexcept</code> specification and the <code>type_constraint</code> (with the leading <code>-&gt;</code>) are optional. The substitution process and the checking of the constraints occur as follows:</p>
			<ol>
				<li>The template arguments are substituted in the expression.</li>
				<li>If <code>noexcept</code> is specified, then the expression must not throw exceptions; otherwise, the requirement is false.</li>
				<li>If the type constraint is present, then the template arguments are also substituted into <code>type_contraint</code> and <code>decltype((expression))</code> must satisfy the conditions imposed by <code>type_constraint</code>; otherwise, the requirement is false.</li>
			</ol>
			<p>We will discuss a couple of examples to learn how to use compound requirements. In the first example, we check whether a function is marked with the <code>noexcept</code> specifier:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">void f(T) noexcept {}</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">void g(T) {}</pre>
			<pre class="source-code">template &lt;typename F, typename ... T&gt;</pre>
			<pre class="source-code">concept NonThrowing = requires(F &amp;&amp; func, T ... t)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   {func(t...)} noexcept;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;typename F, typename ... T&gt;</pre>
			<pre class="source-code">   requires NonThrowing&lt;F, T...&gt;</pre>
			<pre class="source-code">void invoke(F&amp;&amp; func, T... t)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   func(t...);</pre>
			<pre class="source-code">}</pre>
			<p>In this snippet, there are two function templates: <code>f</code> is declared <code>noexcept</code>; therefore, it shall not throw any <a id="_idIndexMarker549"/>exception, and <code>g</code>, which potentially throws exceptions. The <code>NonThrowing</code> concept <a id="_idIndexMarker550"/>imposes the requirement that the variadic function of type <code>F</code> must not throw exceptions. Therefore, of the following two invocations, only the first is valid and the second will produce a compiler error:</p>
			<pre class="source-code">invoke(f&lt;int&gt;, 42);</pre>
			<pre class="source-code">invoke(g&lt;int&gt;, 42); // error</pre>
			<p>The error messages generated by Clang are shown in the following listing:</p>
			<pre>prog.cc:28:7: error: no matching function for call to 'invoke'
      invoke(g&lt;int&gt;, 42);
      ^~~~~~
prog.cc:18:9: note: candidate template ignored: constraints not satisfied [with F = void (&amp;)(int), T = &lt;int&gt;]
   void invoke(F&amp;&amp; func, T... t)
        ^
prog.cc:17:16: note: because 'NonThrowing&lt;void (&amp;)(int), int&gt;' evaluated to false
      requires NonThrowing&lt;F, T...&gt;
               ^
prog.cc:13:20: note: because 'func(t)' may throw an exception
      {func(t...)} noexcept;
                   ^</pre>
			<p>These error messages tell us that the <code>invoke(g&lt;int&gt;, 42)</code> call is not valid because <code>g&lt;int&gt;</code> may throw an exception, which results in <code>NonThrowing&lt;F, T…&gt;</code> to evaluating as <code>false</code>.</p>
			<p>For the second example, we will define a concept that provides requirements for timer classes. Specifically, it requires that a function called <code>start</code> exists, that it can be invoked <a id="_idIndexMarker551"/>without any parameters, and that it returns <code>void</code>. It also <a id="_idIndexMarker552"/>requires that a second function called <code>stop</code> exists, that it can be invoked without any parameters, and that it returns a value that can be converted to <code>long long</code>. The concept is defined as follows:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">concept timer = requires(T t)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   {t.start()} -&gt; std::same_as&lt;void&gt;;</pre>
			<pre class="source-code">   {t.stop()}  -&gt; std::convertible_to&lt;long long&gt;;</pre>
			<pre class="source-code">};</pre>
			<p>Notice that the type constraint cannot be any compile-time Boolean expression, but an actual type requirement. Therefore, we use other concepts for specifying the return type. Both <code>std::same_as</code> and <code>std::convertible_to</code> are concepts available in the standard library in the <code>&lt;concepts&gt;</code> header. We’ll learn more about these in the <em class="italic">Exploring the standard concepts library</em> section. Now, let’s consider the following classes that implement timers:</p>
			<pre class="source-code">struct timerA</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void start() {}</pre>
			<pre class="source-code">   long long stop() { return 0; }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">struct timerB</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void start() {}</pre>
			<pre class="source-code">   int stop() { return 0; }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">struct timerC</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   void start() {}</pre>
			<pre class="source-code">   void stop() {}</pre>
			<pre class="source-code">   long long getTicks() { return 0; }</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">static_assert(timer&lt;timerA&gt;);</pre>
			<pre class="source-code">static_assert(timer&lt;timerB&gt;);</pre>
			<pre class="source-code">static_assert(!timer&lt;timerC&gt;);</pre>
			<p>In this example, <code>timerA</code> satisfies the timer concept because it contains the two required <a id="_idIndexMarker553"/>methods: <code>start</code> that returns <code>void</code> and <code>stop</code> that <a id="_idIndexMarker554"/>returns <code>long long</code>. Similarly, <code>timerB</code> also satisfies the timer concept because it features the same methods, even though <code>stop</code> returns an <code>int</code>. However, the <code>int</code> type is implicitly convertible to the <code>long long</code> type; therefore, the type requirement is met. Lastly, <code>timerC</code> also has <a id="_idIndexMarker555"/>the same methods, but both of them return <code>void</code>, which <a id="_idIndexMarker556"/>means the type requirement for the return type of <code>stop</code> is not met, and therefore, the constraints imposed by the <code>timer</code> concept are not satisfied.</p>
			<p>The last category of requirements left to look into is nested requirements. We will do this next.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor106"/>Nested requirements</h2>
			<p>The last category <a id="_idIndexMarker557"/>of requirements is nested requirements. A nested requirement is introduced with the <code>requires</code> keyword (remember we <a id="_idIndexMarker558"/>mentioned that a simple requirement is a requirement that is not introduced with the <code>requires</code> keyword) and has the following form:</p>
			<pre class="source-code">requires constraint-expression;</pre>
			<p>The expression must be satisfied by the substituted arguments. The substitution of the template arguments into <code>constraint-expression</code> is done only to check whether the expression is satisfied or not.</p>
			<p>In the following example, we want to define a function that performs addition on a variable number of arguments. However, we want to impose some conditions:</p>
			<ul>
				<li>There is more than one argument.</li>
				<li>All the arguments have the same type.</li>
				<li>The expression <code>arg1 + arg2 + … + argn</code> is valid.</li>
			</ul>
			<p>To ensure this, we define a concept called <code>HomogenousRange</code> as follows:</p>
			<pre class="source-code">template&lt;typename T, typename... Ts&gt;</pre>
			<pre class="source-code">inline constexpr bool are_same_v = </pre>
			<pre class="source-code">   std::conjunction_v&lt;std::is_same&lt;T, Ts&gt;...&gt;;</pre>
			<pre class="source-code">template &lt;typename ... T&gt;</pre>
			<pre class="source-code">concept HomogenousRange = requires(T... t)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   (... + t);</pre>
			<pre class="source-code">   requires are_same_v&lt;T...&gt;;</pre>
			<pre class="source-code">   requires sizeof...(T) &gt; 1;</pre>
			<pre class="source-code">};</pre>
			<p>This concept contains one simple requirement and two nested requirements. One nested requirement uses the <code>are_same_v</code> variable template whose value is determined by the <a id="_idIndexMarker559"/>conjunction of one or more type <a id="_idIndexMarker560"/>traits (<code>std::is_same</code>), and the other, the compile-time Boolean expression <code>size…(T) &gt; 1</code>. </p>
			<p>Using this concept, we can define the <code>add</code> variadic function template as follows:</p>
			<pre class="source-code">template &lt;typename ... T&gt;</pre>
			<pre class="source-code">requires HomogenousRange&lt;T...&gt;</pre>
			<pre class="source-code">auto add(T&amp;&amp;... t)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return (... + t);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">add(1, 2);   // OK</pre>
			<pre class="source-code">add(1, 2.0); // error, types not the same</pre>
			<pre class="source-code">add(1);      // error, size not greater than 1</pre>
			<p>The first call exemplified previously is correct, as there are two arguments, and both are of type <code>int</code>. The second call produces an error because the types of the arguments are different (<code>int</code> and <code>double</code>). Similarly, the third call also produces an error because only one argument was supplied. </p>
			<p>The <code>HomogenousRange</code> concept can also be tested with the help of several <code>static_assert</code> statements, as shown next:</p>
			<pre class="source-code">static_assert(HomogenousRange&lt;int, int&gt;);</pre>
			<pre class="source-code">static_assert(!HomogenousRange&lt;int&gt;);</pre>
			<pre class="source-code">static_assert(!HomogenousRange&lt;int, double&gt;);</pre>
			<p>We have walked <a id="_idIndexMarker561"/>through all the categories of the <a id="_idIndexMarker562"/>requires expressions that can be used for defining constraints. However, constraints can also be composed, and this is what we will discuss next.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor107"/>Composing constraints</h1>
			<p>We have seen multiple examples of constraining template arguments but in all the cases so far, we used a single <a id="_idIndexMarker563"/>constraint. It is possible though for constraints to be composed using the <code>&amp;&amp;</code> and <code>||</code> operators. A composition of two constraints <a id="_idIndexMarker564"/>using the <code>&amp;&amp;</code> operator <a id="_idIndexMarker565"/>is called a <code>||</code> operator is called a <strong class="bold">disjunction</strong>.</p>
			<p>For a conjunction to be true, both constraints must be true. Like in the case of logical <strong class="bold">AND</strong> operations, the two constraints are evaluated from left to right, and if the left constraint is false, the right constraint is not evaluated. Let’s look at an example:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">requires std::is_integral_v&lt;T&gt; &amp;&amp; std::is_signed_v&lt;T&gt;</pre>
			<pre class="source-code">T decrement(T value) </pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return value--;</pre>
			<pre class="source-code">}</pre>
			<p>In this snippet, we have a function template that returns the decremented value of the received argument. However, it only accepts signed integral values. This is specified with the conjunction of two constraints, <code>std::is_integral_v&lt;T&gt; &amp;&amp; std::is_signed_v&lt;T&gt;</code>. The same result can be achieved using a different approach to defining the conjunction, as shown next:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">concept Integral = std::is_integral_v&lt;T&gt;;</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">concept Signed = std::is_signed_v&lt;T&gt;;</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">concept SignedIntegral = Integral&lt;T&gt; &amp;&amp; Signed&lt;T&gt;;</pre>
			<pre class="source-code">template &lt;SignedIngeral T&gt;      </pre>
			<pre class="source-code">T decrement(T value)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return value--;</pre>
			<pre class="source-code">}</pre>
			<p>You can see three <a id="_idIndexMarker568"/>concepts defined here: one that constrains integral types, one that constrains signed types, and one that constrains integral and signed types.</p>
			<p>Disjunctions work in a similar way. For a disjunction to be true, at least one of the constraints must be true. If the left constraint is true, then the right one is not evaluated. Again, let’s see an example. If you recall the <code>add</code> function template from the first section of the chapter, we constrained it with the <code>std::is_arithmetic</code> type trait. However, we can get the same result using <code>std::is_integral</code> and <code>std::is_floating_point</code>, used as follows:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">requires std::is_integral_v&lt;T&gt; || std::is_floating_point_v&lt;T&gt;</pre>
			<pre class="source-code">T add(T a, T b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a + b;</pre>
			<pre class="source-code">}</pre>
			<p>The expression <code>std::is_integral_v&lt;T&gt; || std::is_floating_point_v&lt;T&gt;</code> defines a disjunction of two atomic constraints. We will look at this kind of constraint in more detail later. For the time being, keep in mind that an atomic <a id="_idIndexMarker569"/>constraint is an expression of the <code>bool</code> type that cannot be decomposed into smaller parts. Similarly, to what we’ve done previously, we can also build a disjunction of concepts and use that. Here is how:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">concept Integral = std::is_integral_v&lt;T&gt;;</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">concept FloatingPoint = std::is_floating_point_v&lt;T&gt;;</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">concept Number = Integral&lt;T&gt; || FloatingPoint&lt;T&gt;;</pre>
			<pre class="source-code">template &lt;Number T&gt;</pre>
			<pre class="source-code">T add(T a, T b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a + b;</pre>
			<pre class="source-code">}</pre>
			<p>As already mentioned, conjunctions and disjunctions are short-circuited. This has an important implication in checking the correctness of a program. Considering a conjunction of the form <code>A&lt;T&gt; &amp;&amp; B&lt;T&gt;</code>, then <code>A&lt;T&gt;</code> is checked and evaluated first, and if it is false, the second constraint, <code>B&lt;T&gt;</code>, is not checked anymore.</p>
			<p>Similarly, for the <code>A&lt;T&gt; || B&lt;T&gt;</code> disjunction, after <code>A&lt;T&gt;</code> is checked, if it evaluates to true, the second constraint, <code>B&lt;T&gt;</code>, will not be checked. If you want both conjunctions to be checked for well-formedness <a id="_idIndexMarker570"/>and then their Boolean value determined, then you must use the <code>&amp;&amp;</code> and <code>||</code> operators differently. A conjunction or disjunction is formed only when the <code>&amp;&amp;</code> and <code>||</code> tokens, respectively, appear nested in parentheses or as an operand of the <code>&amp;&amp;</code> or <code>||</code> tokens. Otherwise, these operators are treated as logical operators. Let’s explain this with examples:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">requires A&lt;T&gt; || B&lt;T&gt;</pre>
			<pre class="source-code">void f() {}</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">requires (A&lt;T&gt; || B&lt;T&gt;)</pre>
			<pre class="source-code">void f() {}</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">requires A&lt;T&gt; &amp;&amp; (!A&lt;T&gt; || B&lt;T&gt;)</pre>
			<pre class="source-code">void f() {}</pre>
			<p>In all these examples, the <code>||</code> token defines a disjunction. However, when used inside a cast expression or a logical <code>&amp;&amp;</code> and <code>||</code> tokens define a logical expression:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">requires (!(A&lt;T&gt; || B&lt;T&gt;))</pre>
			<pre class="source-code">void f() {}</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">requires (static_cast&lt;bool&gt;(A&lt;T&gt; || B&lt;T&gt;))</pre>
			<pre class="source-code">void f() {}</pre>
			<p>In these cases, the entire expression is first checked for correctness, and then its Boolean value is <a id="_idIndexMarker571"/>determined. It is worth mentioning that in this latter example both expressions, <code>!(A&lt;T&gt; || B&lt;T&gt;)</code> and <code>static_cast&lt;bool&gt;(A&lt;T&gt; || B&lt;T&gt;)</code>, need to be wrapped inside another set of parentheses because the expression of a requires clause cannot start with the <code>!</code> token or a cast.</p>
			<p>Conjunctions and disjunctions cannot be used to constrain template parameter packs. However, there is <a id="_idIndexMarker572"/>a workaround to make it happen. Let’s consider a variadic implementation <a id="_idIndexMarker573"/>of the <code>add</code> function template with the requirement that all arguments must be integral types. One would attempt to write such a constraint in the following form:</p>
			<pre class="source-code">template &lt;typename ... T&gt;</pre>
			<pre class="source-code">requires std::is_integral_v&lt;T&gt; &amp;&amp; ...</pre>
			<pre class="source-code">auto add(T ... args)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return (args + ...);</pre>
			<pre class="source-code">}</pre>
			<p>This will generate a compiler error because the ellipsis is not allowed in this context. What we can do to avoid this error is to wrap the expression in a set of parentheses, as follows:</p>
			<pre class="source-code">template &lt;typename ... T&gt;</pre>
			<pre class="source-code">requires (std::is_integral_v&lt;T&gt; &amp;&amp; ...)</pre>
			<pre class="source-code">auto add(T ... args)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return (args + ...);</pre>
			<pre class="source-code">}</pre>
			<p>The expression, <code>(std::is_integral_v&lt;T&gt; &amp;&amp; ...)</code>, is now a fold expression. It is not a conjunction, as one would expect. Therefore, we get a single atomic constraint. The compiler will first check the correctness of the entire expression and then determine its Boolean value. To build a conjunction we first need to define a concept:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">concept Integral = std::is_integral_v&lt;T&gt;;</pre>
			<p>What we need to do next is change the requires clause so that it uses the newly defined concept and not the Boolean variable, <code>std::is_integral_v&lt;T&gt;</code>:</p>
			<pre class="source-code">template &lt;typename ... T&gt;</pre>
			<pre class="source-code">requires (Integral&lt;T&gt; &amp;&amp; ...)</pre>
			<pre class="source-code">auto add(T ... args)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return (args + ...);</pre>
			<pre class="source-code">}</pre>
			<p>It does not look like much of a change but, in fact, because of the use of concepts, validating the correctness <a id="_idIndexMarker574"/>and determining the Boolean value occur individually for each template argument. If the constraint is not met for a type, the rest is short-circuited, and the validation stops.</p>
			<p>You must have noticed that earlier in this section I used the term <em class="italic">atomic constraint</em> twice. Therefore, one would ask, what is an atomic constraint? It is an expression of the <code>bool</code> type that cannot be decomposed further. Atomic constraints are formed during the process of constraint <a id="_idIndexMarker575"/>normalization when the compiler decomposes constraints into conjunction and disjunctions of atomic constraints. This works as follows:</p>
			<ul>
				<li>The expression, <code>E1 &amp;&amp; E2</code>, is decomposed into the conjunction of <code>E1</code> and <code>E2</code>.</li>
				<li>The expression, <code>E1 || E2</code>, is decomposed into the disjunction of <code>E1</code> and <code>E2</code>.</li>
				<li>The concept, <code>C&lt;A1, A2, … An&gt;</code>, is replaced with its definition after substituting all the template arguments into its atomic constraints.</li>
			</ul>
			<p>Atomic constraints are used for determining the partial ordering of constraints that, in turn, determine the partial ordering of function templates and class template specializations, as well as the next candidate for non-template functions in overload resolution. We will discuss this topic next.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor108"/>Learning about the ordering of templates with constraints</h1>
			<p>When a compiler encounters function calls or class template instantiations, it needs to figure out what overload (for a function) or specialization (for a class) is the best match. A function may be <a id="_idIndexMarker576"/>overloaded with different type <a id="_idIndexMarker577"/>constraints. Class templates can also be specialized with different type constraints. In order to decide which is the best match, the compiler needs to figure out which one is the most constrained and, at the same time, evaluates to <code>true</code> after substituting all the template parameters. In order to figure this out, it performs the <strong class="bold">constraints normalization</strong>. This is the process of transforming <a id="_idIndexMarker578"/>the constraint expression into conjunctions and disjunctions of atomic constraints, as described at the end of the previous section.</p>
			<p>An atomic constraint <code>A</code> is said to subsume another atomic constraint <code>B</code> if <code>A</code> implies <code>B</code>. A constraint declaration <code>D1</code> whose constraints subsume the constraints of another declaration <code>D2</code> is said to be at least as constrained as <code>D2</code>. Moreover, if <code>D1</code> is at least as constrained as <code>D2</code> but the reciprocal is not true, then it’s said that <code>D1</code> is more constrained than <code>D2</code>. More constrained overloads are selected as the best match.</p>
			<p>We will discuss several examples in order to understand how constraints affect overload resolution. First, let’s start with the following two overloads:</p>
			<pre class="source-code">int add(int a, int b) </pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a + b; </pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">T add(T a, T b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a + b;</pre>
			<pre class="source-code">}</pre>
			<p>The first overload is a non-template function that takes two <code>int</code> arguments and returns their sum. The second is the template implementation we have seen already in the chapter.</p>
			<p>Having these two, let’s consider the following calls:</p>
			<pre class="source-code">add(1.0, 2.0);  // [1]</pre>
			<pre class="source-code">add(1, 2);      // [2]</pre>
			<p>The first call (at line <code>[1]</code>) takes two <code>double</code> values so only the template overload is a match. Therefore, its instantiation for the <code>double</code> type will be called. The second invocation <a id="_idIndexMarker579"/>of the <code>add</code> function (at line <code>[2]</code>) takes two integer <a id="_idIndexMarker580"/>arguments. Both overloads are a possible match. The compiler will select the most specific one, which is the non-template overload.</p>
			<p>What if both overloads are templates but one of them is constrained? Here is an example to discuss:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">T add(T a, T b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a + b;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">requires std::is_integral_v&lt;T&gt;</pre>
			<pre class="source-code">T add(T a, T b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a + b;</pre>
			<pre class="source-code">}</pre>
			<p>The first overload is the function template seen previously. The second has an identical implementation except that it specifies a requirement for the template argument, which is restricted to integral types. If we consider the same two calls from the previous snippet, for the call at line <code>[1]</code> with two <code>double</code> values, only the first overload is a good match. For the call at line <code>[2]</code> with two integer values, both overloads are a good match. However, the second overload is more constrained (it has one constraint compared to the first one that has no constraint) so the compiler will select this one for the invocation.</p>
			<p>In the next example, both overloads are constrained. The first overload requires that the size of the <a id="_idIndexMarker581"/>template argument is four, and the second <a id="_idIndexMarker582"/>overload requires that the template argument must be an integral type:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">requires (sizeof(T) == 4)</pre>
			<pre class="source-code">T add(T a, T b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a + b;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">requires std::is_integral_v&lt;T&gt;</pre>
			<pre class="source-code">T add(T a, T b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a + b;</pre>
			<pre class="source-code">}</pre>
			<p>Let’s consider the following calls to this overloaded function template:</p>
			<pre class="source-code">add((short)1, (short)2);  // [1]</pre>
			<pre class="source-code">add(1, 2);                // [2]</pre>
			<p>The call at line <code>[1]</code> uses arguments of the <code>short</code> type. This is an integral type with the size <code>2</code>; therefore, only the second overload is a match. However, the call at line <code>[2]</code> uses arguments of the <code>int</code> type. This is an integral type of size <code>4</code>. Therefore, both overloads are a <a id="_idIndexMarker583"/>good match. However, this is an ambiguous <a id="_idIndexMarker584"/>situation, and the compiler is not able to select between the two and it will trigger an error.</p>
			<p>What happens, though, if we change the two overloads slightly, as shown in the next snippet?</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">requires std::is_integral_v&lt;T&gt;</pre>
			<pre class="source-code">T add(T a, T b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a + b;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">requires std::is_integral_v&lt;T&gt; &amp;&amp; (sizeof(T) == 4)</pre>
			<pre class="source-code">T add(T a, T b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a + b;</pre>
			<pre class="source-code">}</pre>
			<p>Both overloads require that the template argument must be an integral type, but the second also requires that the size of the integral type must be <code>4</code> bytes. So, for the second overload, we use a conjunction of two atomic constraints. We will discuss the same two calls, with <code>short</code> arguments and with <code>int</code> arguments.</p>
			<p>For the call at line <code>[1]</code>, passing two <code>short</code> values, only the first overload is a good match, so this one will be invoked. For the call at line <code>[2]</code> that takes two <code>int</code> arguments, both overloads are a match. The second, however, is more constrained. Yet, the compiler is not able to decide which is a better match and will issue an ambiguous call error. This may be surprising to you because, in the beginning, I said that the most constrained overload will be selected from the overload set. It does not work in our example because we used type traits to constrain the two functions. The behavior is different if we instead use concepts. Here is how:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">concept Integral = std::is_integral_v&lt;T&gt;;</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">requires Integral&lt;T&gt;</pre>
			<pre class="source-code">T add(T a, T b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a + b;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">requires Integral&lt;T&gt; &amp;&amp; (sizeof(T) == 4)</pre>
			<pre class="source-code">T add(T a, T b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a + b;</pre>
			<pre class="source-code">}</pre>
			<p>There is no ambiguity anymore; the compiler will select the second overload as the best match from the <a id="_idIndexMarker585"/>overload set. This demonstrates that <a id="_idIndexMarker586"/>concepts are handled preferentially by the compiler. Remember, there are different ways to use constraints using concepts, but the preceding definition simply replaced a type trait with a concept; therefore, they are arguably a better choice for demonstrating this behavior than the next implementation:</p>
			<pre class="source-code">template &lt;Integral T&gt;</pre>
			<pre class="source-code">T add(T a, T b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a + b;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template &lt;Integral T&gt;</pre>
			<pre class="source-code">requires (sizeof(T) == 4)</pre>
			<pre class="source-code">T add(T a, T b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a + b;</pre>
			<pre class="source-code">}</pre>
			<p>All the examples discussed in this chapter involved constraining function templates. However, it’s possible <a id="_idIndexMarker587"/>to constrain non-template member functions <a id="_idIndexMarker588"/>as well as class templates and class template specializations. We will discuss these in the next sections, and we will start with the former.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor109"/>Constraining non-template member functions</h1>
			<p>Non-template functions that are members of class templates can be constrained in a similar way to what <a id="_idIndexMarker589"/>we have seen so far. This enables template classes to define member functions only for types that satisfy some requirements. In the following example, the equality operator is constrained:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct wrapper</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   T value;</pre>
			<pre class="source-code">   bool operator==(std::string_view str)</pre>
			<pre class="source-code">   requires std::is_convertible_v&lt;T, std::string_view&gt;</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      return value == str;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">};</pre>
			<p>The <code>wrapper</code> class holds a value of a <code>T</code> type and defines the <code>operator==</code> member only for types that are convertible to <code>std::string_view</code>. Let’s see how this can be used:</p>
			<pre class="source-code">wrapper&lt;int&gt;         a{ 42 };</pre>
			<pre class="source-code">wrapper&lt;char const*&gt; b{ "42" };</pre>
			<pre class="source-code">if(a == 42)   {} // error</pre>
			<pre class="source-code">if(b == "42") {} // OK</pre>
			<p>We have two instantiations of the <code>wrapper</code> class here, one for <code>int</code> and one for <code>char const*</code>. The attempt to compare the <code>a</code> object with the literal <code>42</code> generates a compiler error, because <a id="_idIndexMarker590"/>the <code>operator==</code> is not defined for this type. However, comparing the <code>b</code> object with the string literal <code>"42"</code> is possible because the equality operator is defined for types that can be implicitly converted to <code>std::string_view</code>, and <code>char const*</code> is such a type.</p>
			<p>Constraining non-template members is useful because it’s a cleaner solution than forcing members to be templates and using SFINAE. To understand this better let’s consider the following implementation of the <code>wrapper</code> class:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct wrapper</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">    T value;</pre>
			<pre class="source-code">    wrapper(T const &amp; v) :value(v) {}</pre>
			<pre class="source-code">};</pre>
			<p>This class template can be instantiated as follows:</p>
			<pre class="source-code">wrapper&lt;int&gt; a = 42;            //OK</pre>
			<pre class="source-code">wrapper&lt;std::unique_ptr&lt;int&gt;&gt; p = </pre>
			<pre class="source-code">   std::make_unique&lt;int&gt;(42);   //error</pre>
			<p>The first line compiles successfully, but the second generates a compiler error. There are different messages issued by different compilers, but at the core of the error is the call to the implicitly deleted copy constructor of <code>std::unique_ptr</code>.</p>
			<p>What we want to do is restrict the copy construction of <code>wrapper</code> from objects of the <code>T</code> type so that it <a id="_idIndexMarker591"/>only works for <code>T</code> types that are copy-constructible. The approach available before C++20 was to transform the copy constructor into a template and employ SFINAE. This would look as follows:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct wrapper</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   T value;</pre>
			<pre class="source-code">   template &lt;typename U,</pre>
			<pre class="source-code">             typename = std::enable_if_t&lt;</pre>
			<pre class="source-code">                   std::is_copy_constructible_v&lt;U&gt; &amp;&amp;</pre>
			<pre class="source-code">                   std::is_convertible_v&lt;U, T&gt;&gt;&gt;</pre>
			<pre class="source-code">   wrapper(U const&amp; v) :value(v) {}</pre>
			<pre class="source-code">};</pre>
			<p>This time we also get an error when trying to initialize a <code>wrapper&lt;std::unique_ptr&lt;int&gt;&gt;</code> from an <code>std::unique_ptr&lt;int&gt;</code> value but the errors <a id="_idIndexMarker592"/>are different. For instance, here are the error messages generated by Clang:</p>
			<pre class="source-code">prog.cc:19:35: error: no viable conversion from 'typename __unique_if&lt;int&gt;::__unique_single' (aka 'unique_ptr&lt;int&gt;') to 'wrapper&lt;std::unique_ptr&lt;int&gt;&gt;'</pre>
			<pre class="source-code">    wrapper&lt;std::unique_ptr&lt;int&gt;&gt; p = std::make_unique&lt;int&gt;(42); // error</pre>
			<pre class="source-code">                                  ^   ~~~~~~~~~~~~~~~~~~~~~~~~~</pre>
			<pre class="source-code">prog.cc:6:8: note: candidate constructor (the implicit copy constructor) not viable: no known conversion from 'typename __unique_if&lt;int&gt;::__unique_single' (aka 'unique_ptr&lt;int&gt;') to 'const wrapper&lt;std::unique_ptr&lt;int&gt;&gt; &amp;' for 1st argument</pre>
			<pre class="source-code">struct wrapper</pre>
			<pre class="source-code">       ^</pre>
			<pre class="source-code">prog.cc:6:8: note: candidate constructor (the implicit move constructor) not viable: no known conversion from 'typename __unique_if&lt;int&gt;::__unique_single' (aka 'unique_ptr&lt;int&gt;') to 'wrapper&lt;std::unique_ptr&lt;int&gt;&gt; &amp;&amp;' for 1st argument</pre>
			<pre class="source-code">struct wrapper</pre>
			<pre class="source-code">       ^</pre>
			<pre class="source-code"><strong class="bold">prog.cc:13:9: note: candidate template ignored: requirement 'std::is_copy_constructible_v&lt;std::unique_ptr&lt;int, std::default_delete&lt;int&gt;&gt;&gt;' was not satisfied [with U = std::unique_ptr&lt;int&gt;]</strong></pre>
			<pre class="source-code">        wrapper(U const&amp; v) :value(v) {}</pre>
			<pre class="source-code">        ^</pre>
			<p>The most important message to help understand the cause of the problem is the last one. It says that the requirement that <code>U</code> substituted with <code>std::unique_ptr&lt;int&gt;</code> does not satisfy the Boolean condition. In C++20, we can do a better job at implementing the same restriction on the <code>T</code> template argument. This time, we can use constraints and the copy constructor does not need to be a template anymore. The implementation in C++20 can look as follows:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">struct wrapper</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   T value;</pre>
			<pre class="source-code">   wrapper(T const&amp; v) </pre>
			<pre class="source-code">      requires std::is_copy_constructible_v&lt;T&gt; </pre>
			<pre class="source-code">      :value(v)</pre>
			<pre class="source-code">   {}</pre>
			<pre class="source-code">};</pre>
			<p>Not only there is less code that does not require complicated SFINAE machinery, but it is simpler and <a id="_idIndexMarker593"/>easier to understand. It also generates potentially better error messages. In the case of Clang, the last note listed earlier is replaced with the following:</p>
			<pre class="source-code">prog.cc:9:5: note: candidate constructor not viable: constraints not satisfied</pre>
			<pre class="source-code">    wrapper(T const&amp; v) </pre>
			<pre class="source-code">    ^</pre>
			<pre class="source-code">prog.cc:10:18: note: because 'std::is_copy_constructible_v&lt;std::unique_ptr&lt;int&gt; &gt;' evaluated to false</pre>
			<pre class="source-code">        requires std::is_copy_constructible_v&lt;T&gt;</pre>
			<p>Before closing this section, it’s worth mentioning that not only non-template functions that are members of classes can be constrained but also free functions. The use cases for non-template functions are rare and can be achieved with alternative simple solutions such as constexpr if. Let’s look at an example, though:</p>
			<pre class="source-code">void handle(int v)</pre>
			<pre class="source-code">{ /* do something */ }</pre>
			<pre class="source-code">void handle(long v)</pre>
			<pre class="source-code">    requires (sizeof(long) &gt; sizeof(int))</pre>
			<pre class="source-code">{ /* do something else */ }</pre>
			<p>In this snippet, we have two overloads of the <code>handle</code> function. The first overload takes an <code>int</code> value and the second a <code>long</code> value. The body of these overloaded functions is not important but they should do different things, if and only if the size of <code>long</code> is different from the size of <code>int</code>. The standard specifies that the size of <code>int</code> is at least 16 bits, although <a id="_idIndexMarker594"/>on most platforms it is 32 bits. The size of <code>long</code> is at least 32 bits. However, there are platforms, such as <code>int</code> is 32 bits and <code>long</code> is 64 bits. On these platforms, both overloads should be available. On all the other platforms, where the two types have the same size, only the first overload should be available. This can be defined in the form shown earlier, although the same can be achieved in C++17 with constexpr if as follows:</p>
			<pre class="source-code">void handle(long v)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   if constexpr (sizeof(long) &gt; sizeof(int))</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      /* do something else */</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   else</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      /* do something */</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>In the next section, we’ll learn <a id="_idIndexMarker595"/>how to use constraints to define restrictions on template arguments of class templates.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor110"/>Constraining class templates</h1>
			<p>Class templates and class template specializations can also be constrained just like function <a id="_idIndexMarker596"/>templates. To start, we’ll consider the <code>wrapper</code> class template again, but this time with the requirement that it should only work for template arguments of integral types. This can be simply specified in C++20 as follows:</p>
			<pre class="source-code">template &lt;std::integral T&gt;</pre>
			<pre class="source-code">struct wrapper</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   T value;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">wrapper&lt;int&gt;    a{ 42 };    // OK</pre>
			<pre class="source-code">wrapper&lt;double&gt; b{ 42.0 };  // error</pre>
			<p>Instantiating the template for the <code>int</code> type is fine but does not work for <code>double</code> because this is not an integral type.</p>
			<p>Requirements that also be specified with requires clauses and class template specializations can also be constrained. To demonstrate this, let’s consider the scenario when we want to specialize the <code>wrapper</code> class template but only for types whose size is <code>4</code> bytes. This can be implemented as follows:</p>
			<pre class="source-code">template &lt;std::integral T&gt;</pre>
			<pre class="source-code">struct wrapper</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   T value;</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template &lt;std::integral T&gt;</pre>
			<pre class="source-code">requires (sizeof(T) == 4)</pre>
			<pre class="source-code">struct wrapper&lt;T&gt;</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   union</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      T value;</pre>
			<pre class="source-code">      struct</pre>
			<pre class="source-code">      {</pre>
			<pre class="source-code">         uint8_t byte4;</pre>
			<pre class="source-code">         uint8_t byte3;</pre>
			<pre class="source-code">         uint8_t byte2;</pre>
			<pre class="source-code">         uint8_t byte1;</pre>
			<pre class="source-code">      };</pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">};</pre>
			<p>We can use <a id="_idIndexMarker597"/>this class template as shown in the following snippet:</p>
			<pre class="source-code">wrapper&lt;short&gt; a{ 42 };</pre>
			<pre class="source-code">std::cout &lt;&lt; a.value &lt;&lt; '\n';</pre>
			<pre class="source-code">wrapper&lt;int&gt; b{ 0x11223344 };</pre>
			<pre class="source-code">std::cout &lt;&lt; std::hex &lt;&lt; b.value &lt;&lt; '\n';</pre>
			<pre class="source-code">std::cout &lt;&lt; std::hex &lt;&lt; (int)b.byte1 &lt;&lt; '\n';</pre>
			<pre class="source-code">std::cout &lt;&lt; std::hex &lt;&lt; (int)b.byte2 &lt;&lt; '\n';</pre>
			<pre class="source-code">std::cout &lt;&lt; std::hex &lt;&lt; (int)b.byte3 &lt;&lt; '\n';</pre>
			<pre class="source-code">std::cout &lt;&lt; std::hex &lt;&lt; (int)b.byte4 &lt;&lt; '\n';</pre>
			<p>The object <code>a</code> is an instance of <code>wrapper&lt;short&gt;</code>; therefore, the primary template is used. On the other hand, the object <code>b</code> is an instance of <code>wrapper&lt;int&gt;</code>. Since <code>int</code> has a size of 4 bytes (on most platforms) the specialization is used and we can access the individual types <a id="_idIndexMarker598"/>of the wrapped value through the <code>byte1</code>, <code>byte2</code>, <code>byte3</code>, and <code>byte4</code> members.</p>
			<p>Lastly on this topic, we will discuss how variable templates and template aliases can also be constrained.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor111"/>Constraining variable templates and template aliases</h1>
			<p>As you well know, apart from function templates and class templates we also have variable templates <a id="_idIndexMarker599"/>and alias templates in C++. These make no exception <a id="_idIndexMarker600"/>of the need to define constraints. The same rules for constraining the template arguments discussed so far apply to these two. In this section, we will demonstrate them shortly. Let’s start with variable templates.</p>
			<p>It is a typical example to define the <code>PI</code> constant for showing how variable templates work. Indeed, it is a simple definition that looks as follows:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">constexpr T PI = T(3.1415926535897932385L);</pre>
			<p>However, this only makes sense for floating-point types (and maybe other types such as <code>decimal</code>, which does not exist in C++ yet). Therefore, this definition should be restricted to floating-point types, as follows:</p>
			<pre class="source-code">template &lt;<strong class="bold">std::floating_point T</strong>&gt;</pre>
			<pre class="source-code">constexpr T PI = T(3.1415926535897932385L);</pre>
			<pre class="source-code">std::cout &lt;&lt; PI&lt;double&gt; &lt;&lt; '\n';  // OK</pre>
			<pre class="source-code">std::cout &lt;&lt; PI&lt;int&gt; &lt;&lt; '\n';     // error</pre>
			<p>The use of <code>PI&lt;double&gt;</code> is correct but <code>PI&lt;int&gt;</code> produces a compiler error. This is what constraints can <a id="_idIndexMarker601"/>provide in a simple and readable <a id="_idIndexMarker602"/>manner.</p>
			<p>Finally, the last category of templates that we have in the language, alias templates, can also be constrained. In the following snippet, we can see such an example:</p>
			<pre class="source-code">template &lt;std::integral T&gt;</pre>
			<pre class="source-code">using integral_vector = std::vector&lt;T&gt;;</pre>
			<p>The <code>integral_vector</code> template is an alias for <code>std::vector&lt;T&gt;</code> when <code>T</code> is an integral type. The very same can be achieved with the following alternative, although longer, declaration:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">requires std::integral&lt;T&gt;</pre>
			<pre class="source-code">using integral_vector = std::vector&lt;T&gt;;</pre>
			<p>We can use this <code>integral_vector</code> alias template as follows:</p>
			<pre class="source-code">integral_vector&lt;int&gt;    v1 { 1,2,3 };       // OK</pre>
			<pre class="source-code">integral_vector&lt;double&gt; v2 {1.0, 2.0, 3.0}; // error</pre>
			<p>Defining the <code>v1</code> object works fine since <code>int</code> is an integral type. However, defining the <code>v2</code> vector generates a compiler error because <code>double</code> is not an integral type.</p>
			<p>If you paid attention to the examples in this section, you will have noticed that they don’t use the type traits (and the associated variable templates) we used previously in the chapter, but a couple of concepts: <code>std::integral</code> and <code>std::floating_point</code>. These are defined in the <code>&lt;concepts&gt;</code> header and help us avoid repeatedly defining the same concepts based on available C++11 (or newer) type traits. We will look at the content of the standard concepts library shortly. Before we do that, let’s see what other ways we can employ to define constraints in C++20.</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor112"/>Learning more ways to specify constraints</h1>
			<p>We have discussed in this chapter about requires clauses and requires expressions. Although both <a id="_idIndexMarker603"/>are introduced with the new <code>requires</code> keyword, they are different things and should be fully understood:</p>
			<ul>
				<li>A <em class="italic">requires clause</em> determines whether a function participates in overload resolution or not. This happens <a id="_idIndexMarker604"/>based on the value of a compile-time Boolean expression.</li>
				<li>A <em class="italic">requires expression</em> determines whether a set of one or more expressions is well-formed, without <a id="_idIndexMarker605"/>having any side effects on the behavior of the program. A requires expression is a Boolean expression that can be used with a requires clause.</li>
			</ul>
			<p>Let’s see an example again:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">concept addable = requires(T a, T b) { a + b; };</pre>
			<pre class="source-code">                       // [1] requires expression</pre>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">requires addable&lt;T&gt;    // [2] requires clause</pre>
			<pre class="source-code">auto add(T a, T b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a + b;</pre>
			<pre class="source-code">}</pre>
			<p>The construct at line <code>[1]</code> that starts with the <code>requires</code> keyword is a requires expression. It verifies that the expression, <code>a + b</code>, is well-formed for any <code>T</code>. On the other hand, the construct at line <code>[2]</code> is a requires clause. If the Boolean expression <code>addable&lt;T&gt;</code> evaluates to <code>true</code>, the function takes part in overload resolution; otherwise, it does not.</p>
			<p>Although requires clauses are supposed to use concepts, a requires expression can also be used. Basically, anything that can be placed on the right-hand side of the <code>=</code> token in a concept definition <a id="_idIndexMarker606"/>can be used with a requires clause. That means we can do the following:</p>
			<pre class="source-code">template &lt;typename T&gt;</pre>
			<pre class="source-code">   requires requires(T a, T b) { a + b; }</pre>
			<pre class="source-code">auto add(T a, T b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a + b;</pre>
			<pre class="source-code">}</pre>
			<p>Although this is perfectly legal code it is arguable whether it’s a good way of using constraints. I would recommend avoiding creating constructs that start with <code>requires requires</code>. They are less readable and may create confusion. Moreover, named concepts can be used anywhere, while a requires clause with a requires expression will have to be duplicated if it needs to be used for multiple functions.</p>
			<p>Now that we’ve seen how to constrain template arguments in several ways using constraints and concepts, let’s see how we can simplify function template syntax and constrain the template arguments.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor113"/>Using concepts to constrain auto parameters</h1>
			<p>In <a href="B18367_02_ePub.xhtml#_idTextAnchor024"><em class="italic">Chapter 2</em></a>, <em class="italic">Template Fundamentals</em>, we discussed generic lambdas, introduced in C++14, as well <a id="_idIndexMarker607"/>as lambda templates, introduced <a id="_idIndexMarker608"/>in C++20. A lambda that uses the <code>auto</code> specifier for at least one parameter is called a <strong class="bold">generic lambda</strong>. The function object generated by the compiler <a id="_idIndexMarker609"/>will have a templated call operator. Here is an example to refresh your memory:</p>
			<pre class="source-code">auto lsum = [](auto a, auto b) {return a + b; };</pre>
			<p>The C++20 standard generalizes this feature for all functions. You can use the <code>auto</code> specifier in the function parameter list. This has the effect of transforming the function into a template function. Here is an example:</p>
			<pre class="source-code">auto add(auto a, auto b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a + b;</pre>
			<pre class="source-code">}</pre>
			<p>This is a <a id="_idIndexMarker610"/>function that takes two parameters and <a id="_idIndexMarker611"/>returns their sum (or to be more precise, the result of applying <code>operator+</code> on the two values). Such a function using <code>auto</code> for function parameters is called an <strong class="bold">abbreviated function template</strong>. It is basically <a id="_idIndexMarker612"/>shorthand syntax for a function template. The equivalent template for the previous function is the following:</p>
			<pre class="source-code">template&lt;typename T, typename U&gt;</pre>
			<pre class="source-code">auto add(T a, U b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a + b;</pre>
			<pre class="source-code">}</pre>
			<p>We can call this function as we would call any template function, and the compiler will generate the proper instantiations by substituting the template arguments with the actual types. For instance, let’s consider the following calls:</p>
			<pre class="source-code">add(4, 2);   // returns 6</pre>
			<pre class="source-code">add(4.0, 2); // returns 6.0</pre>
			<p>We can use the <a href="http://cppinsights.io">cppinsights.io</a> website to check the compiler-generated code for the <code>add</code> abbreviated function template based on these two calls. The following specializations are generated:</p>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">int add&lt;int, int&gt;(int a, int b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  return a + b;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">double add&lt;double, int&gt;(double a, int b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">  return a + static_cast&lt;double&gt;(b);</pre>
			<pre class="source-code">}</pre>
			<p>Since an abbreviated function template is nothing but a regular function template with a simplified syntax, such a function can be explicitly specialized by the user. Here is an example:</p>
			<pre class="source-code">template&lt;&gt;</pre>
			<pre class="source-code">auto add(char const* a, char const* b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return std::string(a) + std::string(b);</pre>
			<pre class="source-code">}</pre>
			<p>This is a full <a id="_idIndexMarker613"/>specialization for the <code>char const*</code> type. This <a id="_idIndexMarker614"/>specialization enables us to make calls such as <code>add("4", "2")</code>, although the result is a <code>std::string</code> value.</p>
			<p>This category of abbreviated function templates is called <code>add</code> function constrained for integral types:</p>
			<pre class="source-code">auto add(std::integral auto a, std::integral auto b)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a + b;</pre>
			<pre class="source-code">}</pre>
			<p>If we consider again the same calls we saw earlier, the first would be successful, but the second would produce a compiler error because there is no overload that takes a <code>double</code> and an <code>int</code> value:</p>
			<pre class="source-code">add(4, 2);   // OK</pre>
			<pre class="source-code">add(4.2, 0); // error</pre>
			<p>Constrained <code>auto</code> can also be used for variadic abbreviated function templates. An example is shown in the following snippet:</p>
			<pre class="source-code">auto add(std::integral auto ... args)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return (args + ...);</pre>
			<pre class="source-code">}</pre>
			<p>Last but not least, constrained <code>auto</code> can be used with generic lambdas too. If we would like the <a id="_idIndexMarker617"/>generic lambda shown at the beginning <a id="_idIndexMarker618"/>of this section to be used only with integral types, then we can constrain it as follows:</p>
			<pre class="source-code">auto lsum = [](std::integral auto a, std::integral auto b) </pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">   return a + b;</pre>
			<pre class="source-code">};</pre>
			<p>With the closing of this section, we have seen all the language features related to concepts and constraints in C++20. What is left to discuss is the set of concepts provided by the standard library, of which we have seen a couple already. We will do this next.</p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor114"/>Exploring the standard concepts library</h1>
			<p>The standard library provides a set of fundamental concepts that can be used to define requirements <a id="_idIndexMarker619"/>on the template arguments of function templates, class templates, variable templates, and alias templates, as we have seen throughout this chapter. The standard concepts in C++20 are spread across several headers and namespaces. We will present some of them in this section although not all of them. You can find all of them online at <a href="https://en.cppreference.com/">https://en.cppreference.com/</a>.</p>
			<p>The main set of concepts is available in the <code>&lt;concepts&gt;</code> header and the <code>std</code> namespace. Most of these concepts are equivalent to one or more existing type traits. For some of <a id="_idIndexMarker620"/>them, their implementation is well-defined; for some, it is unspecified. They are grouped into four categories: core language concepts, comparison concepts, object concepts, and callable concepts. This set of concepts contains the following (but not only):</p>
			<div><div><img src="img/B18367_06_Table1.1.jpg" alt="Table 6.1&#10;" width="1577" height="1401"/>
				</div>
			</div>
			<p class="figure-caption"><img src="img/B18367_06_Table1.2.png" alt="Table 6.1&#10;" width="1577" height="2100"/></p>
			<p class="figure-caption">Table 6.1</p>
			<p>Some of these concepts are defined using type traits, some are a combination of other concepts or <a id="_idIndexMarker621"/>concepts and type traits, and some have, at least partially, an unspecified implementation. Here are some examples:</p>
			<pre class="source-code">template &lt; class T &gt;</pre>
			<pre class="source-code">concept integral = std::is_integral_v&lt;T&gt;;</pre>
			<pre class="source-code">template &lt; class T &gt;</pre>
			<pre class="source-code">concept signed_integral = std::integral&lt;T&gt; &amp;&amp; </pre>
			<pre class="source-code">                          std::is_signed_v&lt;T&gt;;</pre>
			<pre class="source-code">template &lt;class T&gt;</pre>
			<pre class="source-code">concept regular = std::semiregular&lt;T&gt; &amp;&amp; </pre>
			<pre class="source-code">                  std::equality_comparable&lt;T&gt;;</pre>
			<p>C++20 also introduces a new system of iterators, based on concepts, and defines a set of concepts <a id="_idIndexMarker622"/>in the <code>&lt;iterator&gt;</code> header. Some of these concepts are listed in the following table:</p>
			<div><div><img src="img/B18367_06_Table2.1.jpg" alt="Table 6.2&#10;" width="1577" height="990"/>
				</div>
			</div>
			<div><div><img src="img/B18367_06_Table2.2.jpg" alt="Table 6.2&#10;" width="1577" height="580"/>
				</div>
			</div>
			<p class="figure-caption">Table 6.2</p>
			<p>Here is how the <code>random_access_iterator</code> concept is defined in the C++ standard:</p>
			<pre class="source-code">template&lt;typename I&gt;</pre>
			<pre class="source-code">concept random_access_iterator =</pre>
			<pre class="source-code">   std::bidirectional_iterator&lt;I&gt; &amp;&amp;</pre>
			<pre class="source-code">   std::derived_from&lt;/*ITER_CONCEPT*/&lt;I&gt;,</pre>
			<pre class="source-code">                     std::random_access_iterator_tag&gt; &amp;&amp;</pre>
			<pre class="source-code">   std::totally_ordered&lt;I&gt; &amp;&amp;</pre>
			<pre class="source-code">   std::sized_sentinel_for&lt;I, I&gt; &amp;&amp;</pre>
			<pre class="source-code">   requires(I i, </pre>
			<pre class="source-code">            const I j, </pre>
			<pre class="source-code">            const std::iter_difference_t&lt;I&gt; n)</pre>
			<pre class="source-code">   {</pre>
			<pre class="source-code">      { i += n } -&gt; std::same_as&lt;I&amp;&gt;;</pre>
			<pre class="source-code">      { j +  n } -&gt; std::same_as&lt;I&gt;;</pre>
			<pre class="source-code">      { n +  j } -&gt; std::same_as&lt;I&gt;;</pre>
			<pre class="source-code">      { i -= n } -&gt; std::same_as&lt;I&amp;&gt;;</pre>
			<pre class="source-code">      { j -  n } -&gt; std::same_as&lt;I&gt;;</pre>
			<pre class="source-code">      {  j[n]  } -&gt; std::same_as&lt;std::iter_reference_t&lt;I&gt;&gt;;</pre>
			<pre class="source-code">   };</pre>
			<p>As you can see, it uses several concepts (some of them not listed here) as well as a requires expression to ensure that some expressions are well-formed.</p>
			<p>Also, in the <code>&lt;iterator&gt;</code> header, there is a set of concepts designed to simplify the constraining <a id="_idIndexMarker623"/>of general-purpose algorithms. Some of these concepts are listed in the next table:</p>
			<div><div><img src="img/B18367_06_Table3.jpg" alt="Table 6.3&#10;" width="1577" height="862"/>
				</div>
			</div>
			<p class="figure-caption">Table 6.3</p>
			<p>One of the several major features included in C++20 (along with concepts, modules, and coroutines) are ranges. The <code>ranges</code> library defines a series of classes and functions for simplifying <a id="_idIndexMarker624"/>operations with ranges. Among these is a set of concepts. These are defined in the <code>&lt;ranges&gt;</code> header and the <code>std::ranges</code> namespace. Some of these concepts are listed as follows:</p>
			<div><div><img src="img/B18367_06_Table4.1.jpg" alt="Table 6.4&#13;&#10;" width="1577" height="938"/>
				</div>
			</div>
			<div><div><img src="img/B18367_06_Table4.2.jpg" alt="Table 6.4&#13;&#10;" width="1577" height="656"/>
				</div>
			</div>
			<p class="figure-caption">Table 6.4</p>
			<p>Here is how <a id="_idIndexMarker625"/>some of these concepts are defined:</p>
			<pre class="source-code">template&lt; class T &gt;</pre>
			<pre class="source-code">concept range = requires( T&amp; t ) {</pre>
			<pre class="source-code">   ranges::begin(t);</pre>
			<pre class="source-code">   ranges::end  (t);</pre>
			<pre class="source-code">};</pre>
			<pre class="source-code">template&lt; class T &gt;</pre>
			<pre class="source-code">concept sized_range = ranges::range&lt;T&gt; &amp;&amp;</pre>
			<pre class="source-code">   requires(T&amp; t) {</pre>
			<pre class="source-code">      ranges::size(t);</pre>
			<pre class="source-code">   };</pre>
			<pre class="source-code">template&lt; class T &gt;</pre>
			<pre class="source-code">concept input_range = ranges::range&lt;T&gt; &amp;&amp; </pre>
			<pre class="source-code">   std::input_iterator&lt;ranges::iterator_t&lt;T&gt;&gt;;</pre>
			<p>As mentioned already, there are more concepts than those listed here. Others will probably be added <a id="_idIndexMarker626"/>in the future. This section is not intended as a complete reference to the standard concepts but rather as an introduction to them. You can learn more about each of these concepts from the official C++ reference <a id="_idIndexMarker627"/>documentation available at <a href="https://en.cppreference.com/">https://en.cppreference.com/</a>. As for ranges, we will learn more about them and explore what the standard library provides in <a href="B18367_08_ePub.xhtml#_idTextAnchor179"><em class="italic">Chapter 8</em></a>, <em class="italic">Ranges and Algorithms</em>.</p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor115"/>Summary</h1>
			<p>The C++20 standard introduced some new major features to the language and the standard library. One of these is concepts, which was the topic of this chapter. A concept is a named constraint that can be used to define requirements on template arguments for function templates, class templates, variable templates, and alias templates.</p>
			<p>In this chapter, we have explored in detail how we can use constraints and concepts and how they work. We have learned about requires clauses (that determine whether a template participates in overload resolution) and requires expressions (that specify requirements for well-formedness of expressions). We have seen what various syntaxes are for specifying constraints. We also learned about abbreviated function templates that provide a simplified syntax for function templates. At the end of the chapter, we explored the fundamental concepts available in the standard library.</p>
			<p>In the next chapter, we will shift our attention toward applying the knowledge accumulated so far to implement various template-based patterns and idioms.</p>
			<h1 id="_idParaDest-110">Questio<a id="_idTextAnchor116"/>ns</h1>
			<ol>
				<li value="1">What are constraints and what are concept<a id="_idTextAnchor117"/>s?</li>
				<li>What are a requires clause and a requires expressio<a id="_idTextAnchor118"/>n?</li>
				<li>What are the categories of requires expression<a id="_idTextAnchor119"/>s?</li>
				<li>How do constraints affect the ordering of templates in overload resolutio<a id="_idTextAnchor120"/>n?</li>
				<li>What are abbreviated function templates?</li>
			</ol>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor121"/>Further reading</h1>
			<ul>
				<li><em class="italic">C++20 Concepts - A Quick Introduction</em>, Bartlomiej Filipek, <a href="https://www.cppstories.com/2021/concepts-intro/">https://www.cppstories.com/2021/concepts-intro/</a></li>
				<li><em class="italic">How C++20 Concepts can simplify your code</em>, Andreas Fertig, <a href="https://andreasfertig.blog/2020/07/how-cpp20-concepts-can-simplify-your-code/">https://andreasfertig.blog/2020/07/how-cpp20-concepts-can-simplify-your-code/</a></li>
				<li><em class="italic">What are C++20 concepts and constraints? How to use them?</em>, Sorush Khajepor, <a href="https://iamsorush.com/posts/concepts-cpp/">https://iamsorush.com/posts/concepts-cpp/</a></li>
				<li><em class="italic">Requires-clause</em>, Andrzej Krzemieński, <a href="https://akrzemi1.wordpress.com/2020/03/26/requires-clause/">https://akrzemi1.wordpress.com/2020/03/26/requires-clause/</a></li>
				<li><em class="italic">Ordering by constraints</em>, Andrzej Krzemieński, <a href="https://akrzemi1.wordpress.com/2020/05/07/ordering-by-constraints/">https://akrzemi1.wordpress.com/2020/05/07/ordering-by-constraints/</a></li>
			</ul>
		</div>
	</div></body></html>