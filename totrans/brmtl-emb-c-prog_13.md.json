["```cpp\n#include \"stm32f4xx.h\"\n#define     GPIOBEN            (1U<<1)\n#define     I2C1EN            (1U<<21)\n#define     I2C_100KHZ            80\n#define     SD_MODE_MAX_RISE_TIME    17\n#define    CR1_PE            (1U<<0)\n#define    SR2_BUSY            (1U<<1)\n#define    CR1_START            (1U<<8)\n#define    SR1_SB            (1U<<0)\n#define    SR1_ADDR            (1U<<1)\n#define    SR1_TXE            (1U<<7)\n#define    CR1_ACK            (1U<<10)\n#define    CR1_STOP            (1U<<9)\n#define    SR1_RXNE            (1U<<6)\n#define    SR1_BTF            (1U<<2)\n/*\n * PB8 ---- SCL\n * PB9 ----- SDA\n * */\nvoid i2c1_init(void)\n{\n    /*Enable clock access to GPIOB*/\n     RCC->AHB1ENR |=GPIOBEN;\n    /*Set PB8 and PB9 mode to alternate function*/\n    GPIOB->MODER &=~(1U<<16);\n    GPIOB->MODER |=(1U<<17);\n    GPIOB->MODER &=~(1U<<18);\n    GPIOB->MODER |=(1U<<19);\n    /*Set PB8 and PB9 output type to  open drain*/\n    GPIOB->OTYPER |=(1U<<8);\n    GPIOB->OTYPER |=(1U<<9);\n    /*Enable Pull-up for PB8 and PB9*/\n    GPIOB->PUPDR |=(1U<<16);\n    GPIOB->PUPDR &=~(1U<<17);\n    GPIOB->PUPDR |=(1U<<18);\n    GPIOB->PUPDR &=~(1U<<19);\n    /*Set PB8 and PB9 alternate function type to I2C (AF4)*/\n    GPIOB->AFR[1] &=~(1U<<0);\n    GPIOB->AFR[1] &=~(1U<<1);\n    GPIOB->AFR[1] |=(1U<<2);\n    GPIOB->AFR[1] &=~(1U<<3);\n    GPIOB->AFR[1] &=~(1U<<4);\n    GPIOB->AFR[1] &=~(1U<<5);\n    GPIOB->AFR[1] |=(1U<<6);\n    GPIOB->AFR[1] &=~(1U<<7);\n    /*Enable clock access to I2C1*/\n     RCC->APB1ENR |= I2C1EN;\n    /*Enter reset mode  */\n    I2C1->CR1 |= (1U<<15);\n    /*Come out of reset mode  */\n    I2C1->CR1 &=~(1U<<15);\n    /*Set Peripheral clock frequency*/\n    I2C1->CR2 = (1U<<4);   //16 Mhz\n    /*Set I2C to standard mode, 100kHz clock */\n    I2C1->CCR = I2C_100KHZ;\n    /*Set rise time */\n    I2C1->TRISE = SD_MODE_MAX_RISE_TIME;\n    /*Enable I2C1 module */\n    I2C1->CR1 |= CR1_PE;\n}\n```", "```cpp\nRCC->AHB1ENR |= GPIOBEN;\n```", "```cpp\nGPIOB->MODER &=~(1U<<16);\nGPIOB->MODER |=(1U<<17);\nGPIOB->MODER &=~(1U<<18);\nGPIOB->MODER |=(1U<<19);\n```", "```cpp\nGPIOB->OTYPER |=(1U<<8);\nGPIOB->OTYPER |=(1U<<9);\n```", "```cpp\nGPIOB->PUPDR |=(1U<<16);\nGPIOB->PUPDR &=~(1U<<17);\nGPIOB->PUPDR |=(1U<<18);\nGPIOB->PUPDR &=~(1U<<19);\n```", "```cpp\nGPIOB->AFR[1] &=~(1U<<0);\nGPIOB->AFR[1] &=~(1U<<1);\nGPIOB->AFR[1] |=(1U<<2);\nGPIOB->AFR[1] &=~(1U<<3);\nGPIOB->AFR[1] &=~(1U<<4);\nGPIOB->AFR[1] &=~(1U<<5);\nGPIOB->AFR[1] |=(1U<<6);\nGPIOB->AFR[1] &=~(1U<<7);\n```", "```cpp\n RCC->APB1ENR |= I2C1EN;\n```", "```cpp\nI2C1->CR1 |= (1U<<15);\nI2C1->CR1 &=~(1U<<15);\n```", "```cpp\nI2C1->CR2 = (1U<<4);\n```", "```cpp\n I2C1->CCR = I2C_100KHZ;\n```", "```cpp\nI2C1->TRISE = SD_MODE_MAX_RISE_TIME;\n```", "```cpp\nI2C1->CR1 |= CR1_PE;\n```", "```cpp\nvoid i2c1_byte_read(char saddr, char maddr, char* data) {\n      volatile int tmp;\n      /* Wait until bus not busy */\n      while (I2C1->SR2 & (SR2_BUSY)){}\n      /* Generate start */\n      I2C1->CR1 |= CR1_START;\n      /* Wait until start flag is set */\n      while (!(I2C1->SR1 & (SR1_SB))){}\n      /* Transmit slave address + Write */\n      I2C1->DR = saddr << 1;\n      /* Wait until addr flag is set */\n      while (!(I2C1->SR1 & (SR1_ADDR))){}\n      /* Clear addr flag */\n      tmp = I2C1->SR2;\n      /* Send memory address */\n      I2C1->DR = maddr;\n      /*Wait until transmitter empty */\n      while (!(I2C1->SR1 & SR1_TXE)){}\n     /*Generate restart */\n     I2C1->CR1 |= CR1_START;\n      /* Wait until start flag is set */\n      while (!(I2C1->SR1 & SR1_SB)){}\n     /* Transmit slave address + Read */\n     I2C1->DR = saddr << 1 | 1;\n     /* Wait until addr flag is set */\n     while (!(I2C1->SR1 & (SR1_ADDR))){}\n    /* Disable Acknowledge */\n    I2C1->CR1 &= ~CR1_ACK;\n    /* Clear addr flag */\n    tmp = I2C1->SR2;\n    /* Generate stop after data received */\n    I2C1->CR1 |= CR1_STOP;\n    /* Wait until RXNE flag is set */\n    while (!(I2C1->SR1 & SR1_RXNE)){}\n    /* Read data from DR */\n      *data++ = I2C1->DR;\n}\n```", "```cpp\nvoid i2c1_burst_read(char saddr, char maddr, int n, char* data) {\n    volatile int tmp;\n     /* Wait until bus not busy */\n     while (I2C1->SR2 & (SR2_BUSY)){}\n     /* Generate start */\n     I2C1->CR1 |= CR1_START;\n     /* Wait until start flag is set */\n     while (!(I2C1->SR1 & SR1_SB)){}\n     /* Transmit slave address + Write */\n     I2C1->DR = saddr << 1;\n     /* Wait until addr flag is set */\n     while (!(I2C1->SR1 & SR1_ADDR)){}\n    /* Clear addr flag */\n     tmp = I2C1->SR2;\n    /* Wait until transmitter empty */\n    while (!(I2C1->SR1 & SR1_TXE)){}\n    /*Send memory address */\n    I2C1->DR = maddr;\n    /*Wait until transmitter empty */\n    while (!(I2C1->SR1 & SR1_TXE)){}\n    /*Generate restart */\n    I2C1->CR1 |= CR1_START;\n    /* Wait until start flag is set */\n    while (!(I2C1->SR1 & SR1_SB)){}\n    /* Transmit slave address + Read */\n    I2C1->DR = saddr << 1 | 1;\n    /* Wait until addr flag is set */\n    while (!(I2C1->SR1 & (SR1_ADDR))){}\n    /* Clear addr flag */\n    tmp = I2C1->SR2;\n    /* Enable Acknowledge */\n      I2C1->CR1 |=  CR1_ACK;\n    while(n > 0U)\n    {\n        /*if one byte*/\n        if(n == 1U)\n        {\n            /* Disable Acknowledge */\n            I2C1->CR1 &= ~CR1_ACK;\n            /* Generate Stop */\n            I2C1->CR1 |= CR1_STOP;\n            /* Wait for RXNE flag set */\n            while (!(I2C1->SR1 & SR1_RXNE)){}\n            /* Read data from DR */\n            *data++ = I2C1->DR;\n            break;\n        }\n        else\n        {\n           /* Wait until RXNE flag is set */\n           while (!(I2C1->SR1 & SR1_RXNE)){}\n           /* Read data from DR */\n           (*data++) = I2C1->DR;\n           n--;\n        }\n    }\n}\n```", "```cpp\nvoid i2c1_burst_write(char saddr, char maddr, int n, char* data) {\n    volatile int tmp;\n    /* Wait until bus not busy */\n    while (I2C1->SR2 & (SR2_BUSY)){}\n    /* Generate start */\n    I2C1->CR1 |= CR1_START;\n    /* Wait until start flag is set */\n    while (!(I2C1->SR1 & (SR1_SB))){}\n    /* Transmit slave address */\n    I2C1->DR = saddr << 1;\n    /* Wait until addr flag is set */\n    while (!(I2C1->SR1 & (SR1_ADDR))){}\n    /* Clear addr flag */\n    tmp = I2C1->SR2;\n    /* Wait until data register empty */\n    while (!(I2C1->SR1 & (SR1_TXE))){}\n    /* Send memory address */\n    I2C1->DR = maddr;\n    for (int i = 0; i < n; i++) {\n     /* Wait until data register empty */\n        while (!(I2C1->SR1 & (SR1_TXE))){}\n      /* Transmit memory address */\n      I2C1->DR = *data++;\n    }\n    /* Wait until transfer finished */\n    while (!(I2C1->SR1 & (SR1_BTF))){}\n    /* Generate stop */\n    I2C1->CR1 |= CR1_STOP;\n}\n```", "```cpp\n#ifndef I2C_H_\n#define I2C_H_\nvoid i2c1_init(void);\nvoid i2c1_byte_read(char saddr, char maddr, char* data);\nvoid i2c1_burst_read(char saddr, char maddr, int n, char* data);\nvoid i2c1_burst_write(char saddr, char maddr, int n, char* data);\n#endif\n```", "```cpp\n#include \"adxl345.h\"\n// Variable to store single byte of data\nchar data;\n// Buffer to store multiple bytes of data from the ADXL345\nuint8_t data_buffer[6];\nvoid adxl_read_address (uint8_t reg)\n{\n     i2c1_byte_read( ADXL345_DEVICE_ADDR, reg, &data);\n}\nvoid adxl_write (uint8_t reg, char value)\n{\n    char data[1];\n    data[0] = value;\n    i2c1_burst_write( ADXL345_DEVICE_ADDR, reg,1, data) ;\n}\nvoid adxl_read_values (uint8_t reg)\n{\n    // Read 6 bytes into wthe data buffer\n    i2c1_burst_read(ADXL345_DEVICE_ADDR, reg, 6,(char *)data_buffer);\n}\nvoid adxl_init (void)\n{\n    /*Enable I2C*/\n    i2c1_init();\n    /*Read the DEVID, this should return 0xE5*/\n    adxl_read_address(ADXL345_REG_DEVID);\n    /*Set data format range to +-4g*/\n    adxl_write (ADXL345_REG_DATA_FORMAT, ADXL345_RANGE_4G);\n    /*Reset all bits*/\n    adxl_write (ADXL345_REG_POWER_CTL, ADXL345_RESET);\n    /*Configure power control measure bit*/\n    adxl_write (ADXL345_REG_POWER_CTL, ADXL345_MEASURE_BIT);\n}\n```", "```cpp\n#ifndef ADXL345_H_\n#define ADXL345_H_\n#include \"i2c.h\"\n#include <stdint.h>\n#define   ADXL345_REG_DEVID                (0x00)\n#define   ADXL345_DEVICE_ADDR            (0x53)\n#define   ADXL345_REG_DATA_FORMAT           (0x31)\n#define   ADXL345_REG_POWER_CTL             (0x2D)\n#define   ADXL345_REG_DATA_START            (0x32)\n#define   ADXL345_REG_DATA_FORMAT           (0x31)\n#define       ADXL345_RANGE_4G                (0x01)\n#define       ADXL345_RESET                    (0x00)\n#define    ADXL345_MEASURE_BIT                    (0x08)\nvoid adxl_init(void);\nvoid adxl_read_values(uint8_t reg);\nmain.c file.\n\t\t\tThe main function\n\t\t\tUpdate your `main.c` file, as shown here:\n\n```", "```cpp\n\n\t\t\tIt’s time to test the project. To do so, compile the code and run it on your microcontroller. Open RealTerm or another serial terminal application, and then configure it with the appropriate port and baud rate to view the debug messages. Press the black push button on the development board to reset the microcontroller. You should see the *X*, *Y*, and *Z* accelerometer values continuously being printed. Try moving the accelerometer to see how the values change significantly.\n\t\t\tSummary\n\t\t\tIn this chapter, we learned about the I2C communication protocol. We began by discussing the fundamental principles of the I2C protocol, including its modes of operation, addressing schemes, and the step-by-step communication process.\n\t\t\tWe then delved into the specifics of the STM32 I2C peripheral, highlighting key registers such as Control Register 1 (**I2C_CR1**), Control Register 2 (**I2C_CR2**), the Clock Control Register (**I2C_CCR**), and the Data Register (**I2C_DR**).\n\t\t\tFinally, we applied this theoretical knowledge to develop a bare-metal I2C driver. This driver allows us to initialize the I2C peripheral, perform both single-byte and burst data transfers, and handle communication with an external device such as the ADXL345 accelerometer.\n\t\t\tIn the next chapter, we will learn about interrupts, a critical feature in modern microcontrollers that enables responsive and efficient handling of real-time events.\n\n```"]