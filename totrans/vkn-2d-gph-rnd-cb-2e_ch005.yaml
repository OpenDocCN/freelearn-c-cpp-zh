- en: 4 Adding User Interaction and Productivity Tools
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 添加用户交互和生产工具
- en: Join our book community on Discord
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 书籍社区
- en: '![](img/file40.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/file40.png)'
- en: '[https://packt.link/unitydev](https://packt.link/unitydev)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/unitydev](https://packt.link/unitydev)'
- en: In this chapter, we will learn how to implement basic helpers to drastically
    simplify the debugging of graphical applications. The demos are implemented in
    Vulkan using all the material from the previous three chapters. In *Chapter 3*,
    *Working with Vulkan Objects*, we demonstrated how to wrap various instances of
    raw Vulkan code to create and maintain basic Vulkan state and objects. In this
    chapter, we will show how to start implementing Vulkan rendering code in a way
    that is easily extensible and adaptable for different applications. Beginning
    with 2D user-interface rendering is the best way to learn this, as it makes things
    easier and allows us to focus on the rendering code without being overwhelmed
    by complex 3D graphics algorithms.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何实现基本的辅助工具，以极大地简化图形应用程序的调试。这些示例使用 Vulkan 实现，并使用了前三个章节的所有材料。在 *第 3
    章*，*与 Vulkan 对象一起工作* 中，我们展示了如何包装原始 Vulkan 代码的各种实例，以创建和维护基本的 Vulkan 状态和对象。在本章中，我们将展示如何以易于扩展和适应不同应用程序的方式开始实现
    Vulkan 渲染代码。从 2D 用户界面渲染开始是最好的学习方法，因为它使事情变得简单，并允许我们专注于渲染代码，而不会被复杂的 3D 图形算法所淹没。
- en: 'We will cover the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下食谱：
- en: Rendering ImGui user interfaces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染 ImGui 用户界面
- en: Integrating Tracy into C++ applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Tracy 集成到 C++ 应用程序中
- en: Adding a frames-per-second counter
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加每秒帧数计数器
- en: Using cube map textures in Vulkan
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Vulkan 中使用立方体贴图纹理
- en: Working with a 3D camera and basic user interaction
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 3D 相机和基本用户交互一起工作
- en: Adding camera animations and motion
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加相机动画和运动
- en: Implementing an immediate-mode 3D drawing canvas
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现即时模式 3D 绘图画布
- en: Rendering on-screen graphs with ImGui and ImPlot
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ImGui 和 ImPlot 在屏幕上渲染图表
- en: Putting it all together into a Vulkan application
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有内容整合到 Vulkan 应用程序中
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: To run code from this chapter on your Linux or Windows PC, you will need a GPU
    with recent drivers that support Vulkan 1.3\. The source code used in this chapter
    can be downloaded from [https://github.com/PacktPublishing/3D-Graphics-Rendering-Cookbook](https://github.com/PacktPublishing/3D-Graphics-Rendering-Cookbook).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的 Linux 或 Windows PC 上运行本章的代码，您需要一个支持 Vulkan 1.3 的最新驱动程序的 GPU。本章使用的源代码可以从
    [https://github.com/PacktPublishing/3D-Graphics-Rendering-Cookbook](https://github.com/PacktPublishing/3D-Graphics-Rendering-Cookbook)
    下载。
- en: Rendering ImGui user interfaces
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染 ImGui 用户界面
- en: ImGui is a popular bloat-free graphical user interface library for C++ and is
    essential to the interactive debugging of graphics apps. ImGui integration comes
    as a part of the *LightweightVK* library. In this recipe, we go step by step through
    the code and show how to create an example app with ImGui rendering.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ImGui 是一个流行的无冗余图形用户界面库，用于 C++，对于图形应用程序的交互式调试至关重要。ImGui 集成是 *LightweightVK* 库的一部分。在本食谱中，我们将逐步通过代码，展示如何创建一个带有
    ImGui 渲染的示例应用程序。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: It is recommended to revisit the *Using Vulkan descriptor indexing* recipe from
    *Chapter 3, Working with Vulkan Objects*, and also recall the Vulkan basics described
    in the other recipes of that chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 建议重新查看 *第 3 章，与 Vulkan 对象一起工作* 中的 *使用 Vulkan 描述符索引* 食谱，并回忆该章节其他食谱中描述的 Vulkan
    基础知识。
- en: This recipe covers the source code of `lightweight/lvk/HelpersImGui.cpp`. The
    demo code for this recipe is in `Chapter04/01_ImGui`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱涵盖了 `lightweight/lvk/HelpersImGui.cpp` 的源代码。本食谱的示例代码位于 `Chapter04/01_ImGui`。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let us start with a minimalistic ImGui demo application and take a look at
    how to use the ImGui Vulkan wrapper provided by *LightweightVK*:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的 ImGui 示例应用程序开始，看看如何使用由 *LightweightVK* 提供的 ImGui Vulkan 包装器：
- en: 'First, we create an `lvk::ImGuiRenderer` object. It takes in a pointer to our
    `lvk::IContext`, the name of the default font, and the default font size in pixels.
    `ImGuiRenderer` will take care of all the low-level ImGui initialization and code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个 `lvk::ImGuiRenderer` 对象。它接受一个指向我们的 `lvk::IContext` 的指针，默认字体的名称以及像素中的默认字体大小。`ImGuiRenderer`
    将负责所有低级 ImGui 初始化和代码：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let us create some GLFW callbacks that pass mouse movements and button presses
    into ImGui. GLFW mouse button IDs should be converted into ImGui ones:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一些 GLFW 回调，将鼠标移动和按钮按下传递到 ImGui 中。应将 GLFW 鼠标按钮 ID 转换为 ImGui 的 ID：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Inside our typical rendering loop, we can invoke ImGui rendering commands as
    follows. The `ImGuiRenderer::beginFrame()` method takes in an `lvk::Framebuffer`
    object so it can set up a rendering pipeline properly:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的典型渲染循环中，我们可以按照以下方式调用 ImGui 渲染命令。`ImGuiRenderer::beginFrame()` 方法接受一个 `lvk::Framebuffer`
    对象，以便它可以正确设置渲染管线：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s draw an ImGui window with a texture. A texture index is passed into ImGui
    as an `ImTextureID` value so it can be used with the bindless rendering scheme
    we discussed in the previous chapter in the *Using Vulkan descriptor sets* recipe:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们绘制一个带有纹理的 ImGui 窗口。一个纹理索引作为 `ImTextureID` 值传递给 ImGui，以便它可以与我们在上一章的 *使用 Vulkan
    描述符集* 菜单中讨论的无绑定渲染方案一起使用：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `ImGuiRenderer::endFrame()` method is a command buffer with actual Vulkan
    commands to render the user interface. Then we can call `cmdEndRendering()` and
    submit our command buffer:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImGuiRenderer::endFrame()` 方法是一个包含实际 Vulkan 命令的命令缓冲区，然后我们可以调用 `cmdEndRendering()`
    并提交我们的命令缓冲区：'
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This demo application should render a simple ImGui interface like that shown
    in the following screenshot:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示应用程序应该渲染一个类似于以下截图所示的简单 ImGui 界面：
- en: '![Figure 4.1: ImGui rendering](img/file19.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1：ImGui 渲染](img/file19.png)'
- en: 'Figure 4.1: ImGui rendering'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：ImGui 渲染
- en: Now let’s take a look at the underlying low-level implementation inside LightweightVK
    that renders ImGui data.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看 LightweightVK 内部低级实现，它负责渲染 ImGui 数据。
- en: How it works…
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `lvk::ImGuiRenderer` helper class is declared in `lvk\HelpersImGui.h`. Here
    is its declaration.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`lvk::ImGuiRenderer` 辅助类在 `lvk\HelpersImGui.h` 中声明。以下是它的声明。'
- en: 'The constructor accepts a reference to `lvk::IContext`, the name of the default
    `.ttf` font file, and the default font size in pixels. The `updateFont()`method
    can be invoked at a later point to override the previously used font. This method
    gets called from the constructor to set the default font:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数接受对 `lvk::IContext` 的引用、默认 `.ttf` 字体文件的名称以及默认字体大小（以像素为单位）。`updateFont()`
    方法可以在稍后阶段调用以覆盖之前使用的字体。此方法从构造函数中调用，以设置默认字体：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `beginFrame()` and `endFrame()` methods are necessary to prepare ImGui
    for rendering and generate Vulkan commands from the ImGui draw data. The `setDisplayScale()`
    method can be used to override ImGui’s `DisplayFramebufferScale` factor:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`beginFrame()` 和 `endFrame()` 方法是必要的，用于准备 ImGui 以进行渲染并从 ImGui 绘制数据生成 Vulkan
    命令。`setDisplayScale()` 方法可以用来覆盖 ImGui 的 `DisplayFramebufferScale` 因子：'
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The private section of the `lvk::ImGuiRenderer` class contains a method to
    create a new rendering pipeline and a bunch of data necessary for rendering. There’s
    a single set of vertex and fragment shaders, a rendering pipeline, and a texture
    created from the `.ttf` font file we provided at construction time:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`lvk::ImGuiRenderer` 类的私有部分包含一个创建新渲染管线和渲染所需的一组数据的函数。有一个单独的顶点和片段着色器集、一个渲染管线以及从我们在构造时提供的
    `.ttf` 字体文件创建的纹理：'
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To ensure stall-free operation, *LightweightVK* uses multiple buffers to pass
    ImGui vertex and index data into Vulkan (`vb` and `ib` in the following code,
    for the vertex and index buffers respectively):'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保无停滞操作，*LightweightVK* 使用多个缓冲区将 ImGui 顶点和索引数据传递到 Vulkan（以下代码中的 `vb` 和 `ib`
    分别代表顶点缓冲区和索引缓冲区）：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now we can dive into the implementation, which resides in `lvk/HelpersImGui.cpp`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以深入到实现部分，这部分位于 `lvk/HelpersImGui.cpp`。
- en: The vertex shader uses programmable-vertex pulling, which we briefly touched
    on in the previous chapter in the *Dealing with buffers in Vulkan* recipe. Let’s
    take a closer look at it.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶点着色器使用可编程顶点提取，我们在上一章的 *处理 Vulkan 中的缓冲区* 菜单中简要提到了它。让我们更详细地看看它。
- en: 'ImGui provides 2D screen coordinates for each vertex, 2D texture coordinates,
    and an RGBA color. We declare a `Vertex` structure to hold per-vertex data and
    store all vertices inside the `vertices[]` array residing inside `VertexBuffer`.
    The `buffer_reference` GLSL layout qualifier declares a type and not an instance
    of a buffer, so that a reference to that buffer can be passed into the shader
    at a later point:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ImGui 为每个顶点提供二维屏幕坐标、二维纹理坐标以及一个 RGBA 颜色。我们声明一个 `Vertex` 结构来存储每个顶点的数据，并将所有顶点存储在
    `VertexBuffer` 内部的 `vertices[]` 数组中。`buffer_reference` GLSL 布局限定符声明了一个类型，而不是缓冲区的实例，这样可以在稍后阶段将对该缓冲区的引用传递到着色器中：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A reference to `VertexBuffer` containing our per-vertex data is passed via
    Vulkan push constants. Besides that, we pass a texture ID and some 2D viewport
    parameters represented as left, right, top, and bottom planes inside `vec4 LRTB`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过Vulkan推送常量传递对包含我们每个顶点数据的`VertexBuffer`的引用。除此之外，我们传递一个纹理ID和一些表示为`vec4 LRTB`内部左、右、上、下平面的2D视口参数：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once we have the viewport parameters, we can construct an orthographic projection
    matrix the following way, which is similar to how `glm::ortho()` creates a projection
    matrix:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了视口参数，我们可以按照以下方式构造一个正交投影矩阵，这与`glm::ortho()`创建投影矩阵的方式相似：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The current vertex is extracted from the `VertexBuffer::vertices` array using
    the `gl_VertexIndex` built-in GLSL variable. The RGBA vertex color `v.rgba` is
    packed into a 32-bit unsigned integer and can be unpacked into `vec4` using the
    `unpackUnorm4x8()` GLSL built-in function:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用内置的GLSL变量`gl_VertexIndex`从`VertexBuffer::vertices`数组中提取当前顶点。RGBA顶点颜色`v.rgba`打包成一个32位无符号整数，可以使用`unpackUnorm4x8()`
    GLSL内置函数解包到`vec4`：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The texture coordinates and texture ID are passed into the fragment shader
    unchanged. The projection matrix is multiplied by the vertex position expanded
    into `vec4` by adding `0` as the `Z` component:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 纹理坐标和纹理ID未经更改地传递到片段着色器。投影矩阵通过将`0`作为`Z`分量添加到`vec4`中，与顶点位置相乘：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A corresponding GLSL fragment shader is much simpler and looks as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的GLSL片段着色器要简单得多，如下所示：
- en: 'The input locations should match the corresponding output locations from the
    vertex shader:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 输入位置应与顶点着色器中的相应输出位置匹配：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*LightweightVK* supports some basic sRGB framebuffer rendering. This shader
    constant is used to enable some rudimentary tone mapping. The texture ID is used
    to access a required bindless texture. The sampler is always a default sampler
    at index `0`. The `constant_id` GLSL modifier is used to specify specialization
    constants for Vulkan:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*LightweightVK*支持一些基本的sRGB帧缓冲区渲染。此着色器常量用于启用一些基本的色调映射。纹理ID用于访问所需的免绑定纹理。采样器始终是索引`0`的默认采样器。`constant_id`
    GLSL修饰符用于指定Vulkan的专用常量：'
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here we can render our UI in linear color space into an sRGB framebuffer:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以将我们的UI以线性颜色空间渲染到sRGB帧缓冲区中：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now let’s take a look at the C++ code in the `lvk::ImGuiRender` implementation.
    There’s a private `ImGuiRenderer::createNewPipelineState()` helper function there,
    which is responsible for creating a new rendering pipeline for ImGui rendering.
    As the entire relevant Vulkan state can be dynamic in Vulkan 1.3, a single immutable
    pipeline is sufficient.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看`lvk::ImGuiRender`实现中的C++代码。那里有一个私有的`ImGuiRenderer::createNewPipelineState()`辅助函数，它负责为ImGui渲染创建一个新的渲染管线。由于Vulkan
    1.3中所有相关Vulkan状态都可以是动态的，因此一个不可变的管线就足够了。
- en: 'A framebuffer description is required to create a pipeline because we need
    information about color and depth attachment formats:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建管线需要帧缓冲区描述，因为我们需要有关颜色和深度附加格式的信息：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The sRGB mode is enabled based on the swapchain color space and passed into
    the shaders as Vulkan specialization constants:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据swapchain颜色空间启用sRGB模式，并将其作为Vulkan专用常量传递到着色器中：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'All ImGui elements require alpha blending to be enabled. If a depth buffer
    is present, it is retained unchanged but the rendering pipeline should know about
    it:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有ImGui元素都需要启用alpha混合。如果存在深度缓冲区，它将保持不变，但渲染管线应该知道这一点：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Another helper function `ImGuiRenderer::updateFont()` is called from the constructor.
    Here’s how it is implemented.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从构造函数中调用另一个辅助函数`ImGuiRenderer::updateFont()`。以下是它的实现方式。
- en: 'First, it sets up ImGui font configuration parameters using the provided font
    size:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它使用提供的字体大小设置ImGui字体配置参数：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then it loads the default font from a `.ttf` file:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它从`.ttf`文件加载默认字体：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Last but not least, the rasterized TrueType font data is retrieved from ImGui
    and stored as a *LightweightVK* texture. This font texture is used later for rendering
    via its index ID:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，从ImGui检索光栅化的TrueType字体数据并将其作为*LightweightVK*纹理存储。这个字体纹理稍后通过其索引ID用于渲染：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: All the preparations are completed and we can now look at the constructor and
    destructor of `ImGuiRenderer`. Both member functions are very short.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所有准备工作都完成了，我们现在可以看看`ImGuiRenderer`的构造函数和析构函数。这两个成员函数都非常简短。
- en: 'The constructor initializes both ImGui and ImPlot contexts in case *LightweightVK*
    was compiled with optional ImPlot support. At the moment, *LightweightVK* supports
    only a single ImGui context:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数初始化ImGui和ImPlot上下文，以防*LightweightVK*编译了可选的ImPlot支持。目前，*LightweightVK*只支持单个ImGui上下文：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here we set the `ImGuiBackendFlags_RendererHasVtxOffset` flag telling ImGui
    that our renderer has support for vertex offsets. It enables the output of large
    meshes while still using 16-bit indices, making UI rendering more efficient:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置`ImGuiBackendFlags_RendererHasVtxOffset`标志，告诉ImGui我们的渲染器支持顶点偏移。它启用了使用16位索引输出大型网格的功能，使UI渲染更高效：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'All the work to create the default font and shaders is delegated as we have
    just discussed:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 所有创建默认字体和着色器的工作都委托给了我们刚才讨论的内容：
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The destructor is trivial and cleans up both ImGui and the optional ImPlot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数很简单，它会清理ImGui和可选的ImPlot：
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'There’s one more simple function that we want to see before going on to the
    rendering: `ImGuiRenderer::beginFrame()`. It starts a new ImGui frame using the
    provided framebuffer. A graphics pipeline is lazily created here based on the
    actual framebuffer parameters because we did not have any framebuffer provided
    to us in the constructor:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续渲染之前，我们还想看看一个简单的函数：`ImGuiRenderer::beginFrame()`。它使用提供的帧缓冲区开始一个新的ImGui帧。在这里，基于实际的帧缓冲区参数懒惰地创建了一个图形管线，因为我们构造函数中没有提供任何帧缓冲区：
- en: '[PRE27]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now we are ready to tackle the UI rendering in the `ImGuiRenderer::endFrame()`
    function. This function runs every frame and populates a Vulkan command buffer.
    It is a bit more complicated, so let’s go over it step by step to see how it works.
    Error checking is omitted in the following code snippets for the sake of brevity.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好在`ImGuiRenderer::endFrame()`函数中处理UI渲染。这个函数每帧运行一次，并填充一个Vulkan命令缓冲区。它稍微复杂一些，所以让我们一步一步地了解它是如何工作的。为了简洁起见，以下代码片段省略了错误检查。
- en: 'First, we should finalize ImGui frame rendering and retrieve the frame draw
    data:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该最终完成ImGui帧渲染并检索帧绘制数据：
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let’s prepare the render state. We disable the depth test and depth buffer
    writes. A viewport is constructed based on the ImGui framebuffer size, which we
    set up earlier in `beginFrame()` to be equal to our *LightweightVK* framebuffer
    size:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们准备渲染状态。我们禁用了深度测试和深度缓冲区写入。基于ImGui帧缓冲区大小构建了一个视口，我们之前在`beginFrame()`中设置，使其等于我们的*LightweightVK*帧缓冲区大小：
- en: '[PRE29]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The parameters of the orthographic projection matrix are prepared here. They
    will be passed to shaders later via Vulkan push constants inside the rendering
    loop together with other parameters. Clipping parameters are prepared here as
    well to be used inside the rendering loop:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正交投影矩阵的参数在这里准备。它们将通过渲染循环中的Vulkan推送常数传递给着色器，与其他参数一起。裁剪参数也在这里准备，以便在渲染循环中使用：
- en: '[PRE30]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We have a set of separate LVK buffers per each frame. These buffers store ImGui
    vertex and index data for the entire frame:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 每个帧都有一个单独的LVK缓冲区。这些缓冲区存储整个帧的ImGui顶点和索引数据：
- en: '[PRE31]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If there are buffers already existing from the previous frames and these buffers’
    sizes are insufficient to fit in the new vertex or index data, the buffers are
    re-created with the new size. The index buffer is created via `BufferUsageBits_Index`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在来自前一帧的缓冲区，并且这些缓冲区的大小不足以容纳新的顶点或索引数据，则将使用新大小重新创建缓冲区。索引缓冲区通过`BufferUsageBits_Index`创建：
- en: '[PRE32]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The buffer to store vertices is actually a `BufferUsageBits_Storage` storage
    buffer, because our GLSL shaders use programmable-vertex pulling to load the vertices:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 存储顶点的缓冲区实际上是一个`BufferUsageBits_Storage`存储缓冲区，因为我们的GLSL着色器使用可编程顶点提取来加载顶点：
- en: '[PRE33]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let’s upload some data to the vertex and index buffers. The entire ImGui frame
    data is uploaded here. Offsets are carefully preserved so we know where every
    ImGui draw command data is stored:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将一些数据上传到顶点和索引缓冲区。整个ImGui帧数据都上传到这里。偏移量被仔细保留，这样我们就能知道每个ImGui绘制命令数据存储的位置：
- en: '[PRE34]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The host-visible memory needs to be flushed. This will allow *LightweightVK*
    to issue a corresponding Vulkan `vkFlushMappedMemoryRanges()` command if the memory
    is not host-coherent:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 需要刷新可见于主机的内存。这将允许*LightweightVK*在内存不是主机对齐的情况下发出相应的Vulkan `vkFlushMappedMemoryRanges()`命令：
- en: '[PRE35]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let’s bind our index buffer and the rendering pipeline to a command buffer,
    and enter the rendering loop that iterates over all ImGui rendering commands:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将索引缓冲区和渲染管线绑定到命令缓冲区，并进入渲染循环，该循环遍历所有ImGui渲染命令：
- en: '[PRE36]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Viewport clipping is done right here on the CPU side. If the ImGui draw command
    is completely clipped, we should skip it:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 视口裁剪是在 CPU 端完成的。如果 ImGui 绘制命令完全被裁剪，我们应该跳过它：
- en: '[PRE37]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'All the data necessary for rendering is passed into GLSL shaders via Vulkan
    push constants. It consists of the orthographic projection data, which is the
    left, right, top, and bottom planes, a reference to the vertex buffer, and a texture
    ID for bindless rendering:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 所有必要的渲染数据都通过 Vulkan 推送常数传递到 GLSL 着色器中。它包括正交投影数据，即左、右、上、下平面，对顶点缓冲区的引用以及用于无绑定渲染的纹理
    ID：
- en: '[PRE38]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Set up the scissor test so it can do precise clipping of ImGui elements:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 设置裁剪测试，以便它可以对 ImGui 元素进行精确裁剪：
- en: '[PRE39]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The actual rendering is done via `cmdDrawIndexed()`. Here we use both the index
    offset and vertex offset parameters to access the correct data in our large per-frame
    vertex and index buffers:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的渲染是通过 `cmdDrawIndexed()` 完成的。在这里，我们使用索引偏移量和顶点偏移量参数来访问我们大型的每帧顶点和索引缓冲区中的正确数据：
- en: '[PRE40]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now we have done all the ImGui rendering and can render the entire ImGui user
    interface using Vulkan. Let’s jump to the next recipes and learn other productivity
    and debugging tools, such as profiling, 3D camera controls, frames-per-second
    counters, and a drawing canvas.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了所有的 ImGui 渲染，并且可以使用 Vulkan 渲染整个 ImGui 用户界面。让我们跳到下一个菜谱，学习其他生产力和调试工具，例如性能分析、3D
    摄像机控制、每秒帧数计数器和绘图画布。
- en: Integrating Tracy into C++ applications
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Tracy 集成到 C++ 应用程序中
- en: In the previous chapter, *Working with Vulkan Objects*, we learned how to write
    small graphics applications with Vulkan and LightweightVK. In real-world applications,
    it is often necessary to be able to quickly get performance profiling information
    at runtime. In this recipe, we will show how to make use of the Tracy profiler
    in your 3D applications.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章 *使用 Vulkan 对象* 中，我们学习了如何使用 Vulkan 和 LightweightVK 编写小型图形应用程序。在实际应用程序中，通常需要在运行时能够快速获取性能分析信息。在本菜谱中，我们将展示如何在使用
    3D 应用程序中利用 Tracy 性能分析器。
- en: Getting ready
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: The complete source code of the demo application for this recipe is located
    in `Chapter04/02_TracyProfiler`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的演示应用程序的完整源代码位于 `Chapter04/02_TracyProfiler`。
- en: Make sure to download a precompiled Tracy client app for your platform from
    [https://github.com/wolfpld/tracy](https://github.com/wolfpld/tracy). In our book,
    we use Tracy version 0.10 that can be downloaded from [https://github.com/wolfpld/tracy/releases/tag/v0.10](https://github.com/wolfpld/tracy/releases/tag/v0.10).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保从 [https://github.com/wolfpld/tracy](https://github.com/wolfpld/tracy) 下载适用于您平台的预编译
    Tracy 客户端应用程序。在我们的书中，我们使用的是可以从 [https://github.com/wolfpld/tracy/releases/tag/v0.10](https://github.com/wolfpld/tracy/releases/tag/v0.10)
    下载的 Tracy 版本 0.10。
- en: How to do it...
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The Tracy profiler itself is integrated into the *LightweightVK* library. Our
    demo application, as well as many parts of the *LightweightVK* rendering code,
    is augmented with calls to profiling functions. Those calls are wrapped into a
    set of macros so as not to call Tracy directly. This allows turning the profiler
    on and off, and even switching to other profilers when necessary. Let’s take a
    look at the demo application and then explore the underlying low-level implementation:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Tracy 性能分析器本身集成在 *LightweightVK* 库中。我们的演示应用程序以及 *LightweightVK* 渲染代码的许多部分都增加了对性能分析函数的调用。这些调用被封装在一组宏中，以便不直接调用
    Tracy。这允许在需要时打开和关闭分析器，甚至切换到其他分析器。让我们看一下演示应用程序，然后探索其底层低级实现：
- en: 'First, let’s take a look at the root LightweightVK CMake configuration file
    `deps/src/lightweightvk/CMakeLists.txt` to see how the Tracy library is added
    to the project. At the beginning, we should see an option enabled by default:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下根 LightweightVK CMake 配置文件 `deps/src/lightweightvk/CMakeLists.txt`，看看
    Tracy 库是如何添加到项目中的。一开始，我们应该看到一个默认启用的选项：
- en: '[PRE41]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'A few lines later in the same file, the CMake option is converted into a `TRACY_ENABLE`
    C++ compiler macro definition and the Tracy library is added to the project. Note
    that this is the `third-party/deps/src/` folder of the *LightweightVK* Git repository,
    which itself resides inside the `deps/src/` folder of the book repository:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件的几行之后，CMake 选项被转换为 `TRACY_ENABLE` C++ 编译器宏定义，并将 Tracy 库添加到项目中。请注意，这是 *LightweightVK*
    Git 仓库的 `third-party/deps/src/` 文件夹，它本身位于书籍仓库的 `deps/src/` 文件夹中：
- en: '[PRE42]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let’s continue scrolling the same file, `deps/src/lightweightvk/CMakeLitsts.txt`,
    for a few pages further. Based on the previously enabled `LVK_WITH_TRACY` CMake
    option, we export the `LVK_WITH_TRACY` C++ macro definition to all users of *LightweightVK*.
    The Tracy library is linked with the `LVKLibrary` target so that every app using
    *LightweightVK* has access to Tracy functions as well:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续滚动相同的文件，`deps/src/lightweightvk/CMakeLists.txt`，再翻几页。根据之前启用的`LVK_WITH_TRACY`
    CMake选项，我们将`LVK_WITH_TRACY` C++宏定义导出到*LightweightVK*的所有用户。Tracy库与`LVKLibrary`目标链接，这样每个使用*LightweightVK*的应用程序都可以访问Tracy函数：
- en: '[PRE43]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now let’s look into `lightweightvk/lvk/LVK.h` and check out some macro definitions.
    The `LVK_WITH_TRACY` macro is used to enable or disable Tracy usage. Some predefined
    RGB colors are declared as macros to be used to mark important point-of-interest
    operations:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们查看`lightweightvk/lvk/LVK.h`并检查一些宏定义。`LVK_WITH_TRACY`宏用于启用或禁用Tracy的使用。一些预定义的RGB颜色被声明为宏，用于标记重要的兴趣点操作：
- en: '[PRE44]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Other macros are mapped directly to Tracy functions so that we can work with
    Tracy zones in a non-intrusive way:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他宏直接映射到Tracy函数，这样我们就可以以非侵入的方式使用Tracy区域：
- en: '[PRE45]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `LVK_PROFILER_THREAD` macro can be used to set the name of a C++ thread.
    The `LVK_PROFILER_FRAME` macro is used to mark the start of the next frame during
    rendering. It is used by *LightweightVK* in `lvk::VulkanSwapchain::present()`
    and can be helpful if you want to implement your own swapchain management code,
    for example, on Android using OpenXR:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LVK_PROFILER_THREAD`宏可以用来设置C++线程的名称。`LVK_PROFILER_FRAME`宏用于在渲染期间标记下一帧的开始。它在`lvk::VulkanSwapchain::present()`中由*LightweightVK*使用，如果您想实现自己的交换链管理代码，例如在Android上使用OpenXR，这可能很有帮助：'
- en: '[PRE46]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Once Tracy is disabled, all macros are defined to no-ops and zones are defined
    as empty C++ scopes:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦禁用Tracy，所有宏都定义为无操作，区域被定义为空的C++作用域：
- en: '[PRE47]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Macros `LVK_PROFILER_FUNCTION` and `LVK_PROFILER_FUNCTION_COLOR` are spread
    all over the *LightweightVK* code to give good profiling coverage. Let’s take
    a look at how to use them in our own apps.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`LVK_PROFILER_FUNCTION`和`LVK_PROFILER_FUNCTION_COLOR`宏在*LightweightVK*代码中广泛使用，以提供良好的分析覆盖率。让我们看看如何在我们的应用程序中使用它们。'
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The demo application is located in `Chapter04/02_TracyProfiler/src.main.cpp`.
    Tracy is initialized automatically together with *LightweightVK*. All we have
    to do now is put corresponding macros in our code. Let’s take a look at how it
    works.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 示例应用程序位于`Chapter04/02_TracyProfiler/src.main.cpp`。Tracy与*LightweightVK*一起自动初始化。我们现在需要做的是在我们的代码中放置相应的宏。让我们看看它是如何工作的。
- en: 'In our initialization part where we create `lvk::IContext`, we use `LVK_PROFILER_ZONE`
    and `LVK_PROFILER_ZONE_END` to mark an interesting fragment of our initialization
    code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建`lvk::IContext`的初始化部分，我们使用`LVK_PROFILER_ZONE`和`LVK_PROFILER_ZONE_END`来标记初始化代码中的有趣片段：
- en: '[PRE48]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Inside the rendering loop, we can mark different point-of-interest code blocks
    the same way. The hex value is an RGB color that will be used by Tracy in the
    profiling window to highlight this profiling zone. Some predefined colors were
    mentioned earlier in this recipe:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染循环内部，我们可以以相同的方式标记不同的兴趣点代码块。十六进制值是Tracy在分析窗口中用于突出显示此分析区域的RGB颜色。在本文档中之前提到了一些预定义的颜色：
- en: '[PRE49]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If we need to mark the entire function and want to have an automatic name assigned
    to it, we should use the `LVK_PROFILER_FUNCTION` macro as in the following snippet.
    This macro does not require closing:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要标记整个函数并希望为其自动分配一个名称，我们应该使用以下代码片段中的`LVK_PROFILER_FUNCTION`宏。此宏不需要关闭：
- en: '[PRE50]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Let’s take a look at the profiler output while running this demo app. To retrieve
    the profiling data, you have to run a Tracy client and connect it to your graphics
    app. We use Tracy version 0.10, which can be downloaded from GitHub at [https://github.com/wolfpld/tracy/releases/tag/v0.10](https://github.com/wolfpld/tracy/releases/tag/v0.10).
    Here is a screenshot from a connected Tracy client showing a flame graph of our
    app.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在运行此演示应用程序时分析器的输出。要检索分析数据，您必须运行一个Tracy客户端并将其连接到您的图形应用程序。我们使用的是Tracy版本0.10，可以从GitHub下载[https://github.com/wolfpld/tracy/releases/tag/v0.10](https://github.com/wolfpld/tracy/releases/tag/v0.10)。以下是连接的Tracy客户端的屏幕截图，显示了我们的应用程序的火焰图。
- en: '![Figure 4.2: Tracy user interface](img/file20.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2：Tracy用户界面](img/file20.png)'
- en: 'Figure 4.2: Tracy user interface'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：Tracy用户界面
- en: This approach allows for fully transparent enabling and disabling of the Tracy
    profiler at build time. Adding other profilers, such as EasyProfiler and Optick,
    which provide similar APIs, is mostly trivial and can be easily implemented yourself
    as an exercise.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许在构建时完全透明地启用和禁用Tracy性能分析器。添加其他性能分析器，如提供类似API的EasyProfiler和Optick，主要是微不足道的，并且可以很容易地作为练习自行实现。
- en: Before returning to Vulkan rendering, let’s explore yet another small but useful
    profiling trick and learn how to implement a simple yet good frames-per-second
    counter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回Vulkan渲染之前，让我们探索另一个小而实用的性能分析技巧，并学习如何实现一个简单但良好的每秒帧数计数器。
- en: Adding a frames-per-second counter
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加每秒帧数计数器
- en: The **frames-per-second** (**FPS**) counter is the cornerstone of all graphical
    applications profiling and performance measurements. In this recipe, we will learn
    how to implement a simple FPS counter class and use it to roughly measure the
    performance of our applications.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**每秒帧数**（**FPS**）计数器是所有图形应用程序性能分析和测量的基石。在本教程中，我们将学习如何实现一个简单的FPS计数器类，并使用它来大致测量我们应用程序的性能。'
- en: Getting ready
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: The source code for this recipe can be found in `Chapter04/03_FPS`. The `FramesPerSecondCounter`
    class is located in `shared/UtilsFPS.h`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程的源代码位于`Chapter04/03_FPS`。`FramesPerSecondCounter`类位于`shared/UtilsFPS.h`。
- en: How to do it...
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let’s implement the `FramesPerSecondCounter` class containing all the machinery
    required to calculate the average FPS for a given time interval:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现包含计算给定时间间隔平均FPS所需所有机制的`FramesPerSecondCounter`类：
- en: 'First, we need some member fields to store the duration of a sliding window,
    the number of frames rendered in the current interval, and the accumulated time
    of this interval. The `printFPS_ Boolean` field can be used to enable or disable
    FPS printing to the console:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要一些成员字段来存储滑动窗口的持续时间、当前间隔内渲染的帧数以及该间隔的累积时间。`printFPS_ Boolean` 字段可以用来启用或禁用将帧率（FPS）打印到控制台：
- en: '[PRE51]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'A single explicit constructor can override the averaging interval’s default
    duration:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单一显式构造函数可以覆盖平均间隔的默认持续时间：
- en: '[PRE52]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `tick()` method should be called from the main loop. It accepts the time
    duration elapsed since the previous call and a Boolean flag, which should be set
    to `true` if a new frame has been rendered during this iteration. This flag is
    a convenience feature to handle situations where frame rendering can be skipped
    in the main loop for various reasons, such as simulation pausing. The time accumulates
    until it reaches the value of `avgInterval_`:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tick()`方法应该从主循环中调用。它接受自上次调用以来经过的时间持续时间和一个布尔标志，如果在此迭代期间渲染了新帧，则该标志应设置为`true`。这个标志是一个便利功能，用于处理在主循环中由于各种原因（如模拟暂停）跳过帧渲染的情况。时间累积直到达到`avgInterval_`的值：'
- en: '[PRE53]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Once enough time has accumulated, we can do averaging, update the current FPS
    value, and print debug info to the console. We should reset the number of frames
    and accumulated time at this point:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦累积了足够的时间，我们就可以进行平均，更新当前的FPS值，并将调试信息打印到控制台。此时，我们应该重置帧数和累积时间：
- en: '[PRE54]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let’s add a helper method to retrieve the current FPS value:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个辅助方法来获取当前的帧率值：
- en: '[PRE55]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, let’s take a look at how to use this class in our main loop. Let’s augment
    the main loop of our demo applications to display an FPS counter in the console:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在主循环中使用这个类。让我们增强我们的演示应用程序的主循环，以在控制台显示FPS计数器：
- en: 'First, let us define a `FramesPerSecondCounter` object and a couple of variables
    to store the current timestamp and the delta since the last rendered frame. We
    have chosen to use an ad hoc 0.5-second averaging interval; feel free to experiment
    with different values:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们定义一个`FramesPerSecondCounter`对象和几个变量来存储当前时间戳和自上次渲染帧以来的时间差。我们选择使用一个临时的0.5秒平均间隔；请随意尝试不同的值：
- en: '[PRE56]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Within the main loop, update the current timestamp and calculate the frame
    duration by finding a delta between two consecutive timestamps. Then, pass this
    calculated delta to the `tick()` method:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主循环中，更新当前时间戳，通过找到两个连续时间戳之间的差值来计算帧持续时间。然后，将这个计算出的差值传递给`tick()`方法：
- en: '[PRE57]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The console output of the running application should look similar to the following.
    Vertical sync is turned off:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序的控制台输出应类似于以下内容。垂直同步已关闭：
- en: '[PRE58]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The application window should look like that shown in the following screenshot,
    with an FPS counter rendered in the top-right corner:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序窗口应该看起来像以下截图所示，帧率计数器渲染在右上角：
- en: '![Figure 4.3: ImGui and ImPlot user interfaces with an FPS counter](img/file21.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3：带有FPS计数的ImGui和ImPlot用户界面](img/file21.png)'
- en: 'Figure 4.3: ImGui and ImPlot user interfaces with an FPS counter'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：带有FPS计数的ImGui和ImPlot用户界面
- en: 'Let’s check the source code to learn how to add this ImGui FPS widget to your
    app. Here’s a fragment that fills in a command buffer:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查源代码，了解如何将这个ImGui FPS小部件添加到你的应用中。以下是一个填充命令缓冲区的片段：
- en: 'We set up the framebuffer parameters and start rendering. ImGui rendering is
    started with `imgui->beginFrame()` as we learned in the *Rendering ImGui user
    interface* recipe:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置了帧缓冲区参数并开始渲染。与我们在*渲染ImGui用户界面*菜谱中学到的相同，ImGui渲染从`imgui->beginFrame()`开始：
- en: '[PRE59]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We get the current viewport parameters from ImGui and set the position of the
    next ImGui window to be aligned close to the top-right corner of the viewport
    work area. Sizes are hardcoded to be in the app window’s pixels. The `ImGuiCond_Always`
    flag tells ImGui to set this position every frame:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从ImGui获取当前视口参数，并将下一个ImGui窗口的位置设置为与视口工作区域的右上角对齐。大小被硬编码为应用窗口的像素。`ImGuiCond_Always`标志告诉ImGui在每一帧都设置这个位置：
- en: '[PRE60]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Set the next window to be transparent. We use `SetNextWindowSize()` to assign
    a fixed size value to the window. The width is calculated using `CalcTextSize()`.
    Note how that `“FPS : _______”` placeholder string is used here as a parameter
    to make sure the width of the window does not fluctuate based on the number of
    digits in the numeric FPS value:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将下一个窗口设置为透明。我们使用`SetNextWindowSize()`为窗口分配一个固定的大小值。宽度是通过`CalcTextSize()`计算的。注意这里如何使用`“FPS
    : _______”`占位符字符串作为参数，以确保窗口的宽度不会根据数字FPS值的位数而波动：'
- en: '[PRE61]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'An ImGui window that contains the FPS counter is rendered using various ImGui
    flags so that all unnecessary window decorations are disabled and no user interaction
    can happen with the window:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个包含FPS计数的ImGui窗口使用各种ImGui标志进行渲染，以便禁用所有不必要的窗口装饰，并且无法与窗口进行用户交互：
- en: '[PRE62]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'After we have rendered the FPS window, let’s draw ImPlot and ImGui demo windows
    so you can explore them. The ImPlot library will be covered a bit more in subsequent
    recipes:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们渲染了FPS窗口之后，让我们绘制ImPlot和ImGui演示窗口，以便你可以探索它们。ImPlot库将在后续菜谱中进一步介绍：
- en: '[PRE63]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now you know how to display a window in your apps that includes a nice FPS counter.
    Although this feature is straightforward, it can be tiresome to repeatedly include
    this code in every app. In the upcoming recipes, we will introduce a `VulkanApp`
    helper class that will handle various utility functions like this. But for now,
    let’s go back to rendering and explore how to work with cube map textures.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何在你的应用中显示包含一个漂亮的FPS计数的窗口。尽管这个功能很简单，但反复在每一个应用中包含这段代码可能会很麻烦。在接下来的菜谱中，我们将介绍一个`VulkanApp`辅助类，它将处理各种类似这样的实用功能。但就目前而言，让我们回到渲染，探索如何使用立方图纹理。
- en: There is more...
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `frameRendered` parameter in `float tick(float deltaSeconds, bool frameRendered
    = true)` will be used in subsequent recipes to allow Vulkan applications to skip
    frames when a swapchain image is not available.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`float tick(float deltaSeconds, bool frameRendered = true)`中的`frameRendered`参数将在后续菜谱中使用，以允许Vulkan应用程序在交换链图像不可用时跳过帧。'
- en: Using cube map textures in Vulkan
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Vulkan中使用立方图纹理
- en: A cube map is a texture that contains 6 individual 2D textures that together
    form 6 sides of a cube. A useful property of cube maps is that they can be sampled
    using a direction vector. This comes in handy when representing light coming into
    a scene from different directions. For example, we can store the diffuse part
    of the physically based lighting equation in an irradiance cube map, which we
    will touch on in *Chapter 6*.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 立方图是一种包含6个独立的2D纹理的纹理，这些纹理共同构成了立方体的6个面。立方图的一个有用特性是它们可以使用方向向量进行采样。这在表示从不同方向进入场景的光线时非常有用。例如，我们可以将基于物理的照明方程中的漫反射部分存储在辐照度立方图中，我们将在*第6章*中讨论这一点。
- en: Loading 6 faces of a cube map into *LightweightVK* is a fairly straightforward
    operation. However, instead of just 6 faces, cube maps are often stored as **equirectangular
    projections** or as vertical or horizontal crosses. The equirectangular projection
    is such a projection that maps longitude and latitude (vertical and horizontal
    lines) to straight, even lines, making it a very easy and popular way to store
    light probe images, as shown in *Figure 4.4* later in this recipe.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 将立方体贴图的6个面加载到*LightweightVK*中是一个相当直接的操作。然而，立方体贴图通常存储为**等经线投影**或垂直或水平交叉。等经线投影是一种将经度和纬度（垂直和水平线）映射为直线、均匀线的投影，这使得它成为存储光探针图像的一种非常简单且流行的存储方式，如图4.4中所示。
- en: In this recipe, we will learn how to convert this cube map representation into
    6 faces and render them with Vulkan.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何将此立方体贴图表示转换为6个面，并使用Vulkan进行渲染。
- en: Getting ready
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: There are many websites that offer high-dynamic range environment textures under
    various licenses. Check out [https://polyhaven.com](https://polyhaven.com) and
    [https://hdrmaps.com](https://hdrmaps.com) for useful content.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多网站提供各种许可下的高动态范围环境纹理。请查看[https://polyhaven.com](https://polyhaven.com)和[https://hdrmaps.com](https://hdrmaps.com)以获取有用内容。
- en: The complete source code for this recipe can be found in the source code bundle
    under the name `Chapter04/04_CubeMap`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的完整源代码可以在源代码包中找到，名称为`Chapter04/04_CubeMap`。
- en: 'Before we start working with cube maps, let us introduce a simple `Bitmap`
    helper class to work with bitmap images in 8-bit and 32-bit floating point formats.
    You can find it in `shared/Bitmap.h`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用立方体贴图之前，让我们介绍一个简单的`Bitmap`辅助类，用于处理8位和32位浮点格式的位图图像。您可以在`shared/Bitmap.h`中找到它：
- en: 'Let us declare the interface part of the `Bitmap` class as follows:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们声明`Bitmap`类的接口部分如下：
- en: '[PRE64]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Let’s set the width, height, depth, and number of components per pixel:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们设置宽度、高度、深度以及每像素的组件数量：
- en: '[PRE65]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The type of a single component can be either unsigned byte or float. The type
    of this bitmap can be a 2D texture or a cube map. We store the actual pixel data
    of this bitmap in an `std::vector` container for simplicity:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单个组件的类型可以是无符号字节或浮点数。此位图的类型可以是2D纹理或立方体贴图。为了简化，我们将此位图的实际像素数据存储在`std::vector`容器中：
- en: '[PRE66]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Next we need a helper function to get the number of bytes necessary to store
    one component of a specified format. This also requires a getter and setter for
    a two-dimensional image. We will come back to this later:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们需要一个辅助函数来获取存储指定格式的一个组件所需的字节数。这也需要一个二维图像的获取器和设置器。我们稍后会回到这个问题：
- en: '[PRE67]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The implementation is also located in `shared/Bitmap.h`. Now let us use this
    class to build more high-level cube map conversion functions.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 实现也位于`shared/Bitmap.h`中。现在让我们使用这个类来构建更高级的立方体贴图转换函数。
- en: How to do it...
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We have a cube map at `data/piazza_bologni_1k.hdr`, which is available under
    the CC0 license and was originally downloaded from [https://hdrihaven.com/hdri/?h=piazza_bologni](https://hdrihaven.com/hdri/?h=piazza_bologni).
    The environment map image comes in an equirectangular projection and looks like
    this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个位于`data/piazza_bologni_1k.hdr`的立方体贴图，它可在CC0许可下使用，最初是从[https://hdrihaven.com/hdri/?h=piazza_bologni](https://hdrihaven.com/hdri/?h=piazza_bologni)下载的。环境贴图图像以等经线投影形式呈现，如下所示：
- en: '![Figure 4.4: Equirectangular projection](img/file22.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4：等经线投影](img/file22.png)'
- en: 'Figure 4.4: Equirectangular projection'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：等经线投影
- en: 'Let us convert it into a vertical cross. In the vertical cross format, each
    cube map face is represented as a square inside the entire image, as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将它转换为垂直交叉。在垂直交叉格式中，每个立方体贴图面在整幅图像中代表为一个正方形，如下所示：
- en: '![Figure 4.5: Vertical cross](img/file23.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5：垂直交叉](img/file23.png)'
- en: 'Figure 4.5: Vertical cross'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：垂直交叉
- en: 'If we use a naive way to convert an equirectangular projection to cube map
    faces by iterating over its pixels, calculating the Cartesian coordinates for
    each pixel, and saving the pixel into a cube map face using the Cartesian coordinates,
    we will end up with a texture heavily damaged by a Moiré pattern caused by the
    insufficient sampling of the resulting cube map. A better way is to do it the
    other way round. That means iterating over each pixel of the resulting cube map
    faces, calculating source floating-point equirectangular coordinates corresponding
    to each pixel, and sampling the equirectangular texture using bilinear interpolation.
    This way the final cube map will be free of artifacts:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过迭代其像素、计算每个像素的笛卡尔坐标并将像素保存到立方体贴图面中来将等经圆投影转换为立方体贴图面，由于结果立方体贴图采样不足，最终会得到一个严重受损的纹理，上面有摩尔纹。更好的方法是反过来操作。这意味着迭代结果立方体贴图面的每个像素，计算对应每个像素的源浮点等经圆坐标，并使用双线性插值采样等经圆纹理。这样最终的立方体贴图将没有伪影：
- en: 'The first step is to introduce a helper function that maps integer coordinates
    inside a specified cube map face into floating-point normalized coordinates. This
    helper is handy because all faces in the vertical cross cube map have different
    vertical orientations:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是引入一个辅助函数，该函数将指定立方体贴图面内的整数坐标映射到浮点归一化坐标。这个辅助函数很方便，因为垂直交叉立方体贴图的各个面都有不同的垂直方向：
- en: '[PRE68]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The conversion function starts as follows and calculates the face size, width,
    and height of the resulting bitmap. It is located in `shared/UtilsCubemap.cpp`:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转换函数开始如下，并计算结果位图的面积、宽度和高度。它位于 `shared/UtilsCubemap.cpp`：
- en: '[PRE69]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'These points define the locations of individual faces inside the cross:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些点定义了交叉中各个面的位置：
- en: '[PRE70]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Two constants will be necessary to clamp the texture lookup:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要两个常量来限制纹理查找：
- en: '[PRE71]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now we can start iterating over the 6 cube map faces and each pixel inside
    each face:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以开始迭代 6 个立方体贴图面以及每个面内的每个像素：
- en: '[PRE72]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We use trigonometry functions to calculate the latitude and longitude coordinates
    from the Cartesian cube map coordinates.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用三角函数从笛卡尔立方体贴图坐标计算纬度和经度坐标。
- en: '[PRE73]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'To learn more about spherical coordinate systems, please follow this link:
    [https://en.wikipedia.org/wiki/Spherical_coordinate_system](https://en.wikipedia.org/wiki/Spherical_coordinate_system).'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要了解更多关于球坐标系统，请点击此链接：[https://en.wikipedia.org/wiki/Spherical_coordinate_system](https://en.wikipedia.org/wiki/Spherical_coordinate_system)。
- en: 'Now we can map the latitude and longitude into floating-point coordinates inside
    the equirectangular image:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将纬度和经度映射到等经圆图像内的浮点坐标：
- en: '[PRE74]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Based on these floating-point coordinates, we get two pairs of integer UV coordinates,
    which we will use to sample 4 texels for bilinear interpolation:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于这些浮点坐标，我们得到两对整数 UV 坐标，我们将使用这些坐标来采样 4 个 texels 以进行双线性插值：
- en: '[PRE75]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Get the fractional part for the bilinear interpolation and fetch 4 samples,
    `A`, `B`, `C`, and `D`, from the equirectangular map:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取双线性插值的分数部分，并从等经圆图中获取 4 个样本，`A`、`B`、`C` 和 `D`：
- en: '[PRE76]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Do the bilinear interpolation and set the resulting pixel value in the vertical-cross
    cube map:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行双线性插值，并将结果像素值设置在垂直交叉立方体贴图中：
- en: '[PRE77]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The `Bitmap` class takes care of the pixel format inside the image data.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bitmap` 类负责处理图像数据中的像素格式。'
- en: 'Now we can write code to cut the vertical cross into tightly packed rectangular
    cube map faces. Here is how to do it:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写代码来将垂直交叉切割成紧密排列的矩形立方体贴图面。以下是操作方法：
- en: First, let us review the layout of the vertical cross image corresponding to
    the Vulkan cube map faces layout.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们回顾一下与 Vulkan 立方体贴图面布局相对应的垂直交叉图像布局。
- en: '![Figure 4.6: Layout of the vertical cross image](img/file24.png)'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 4.6：垂直交叉图像布局](img/file24.png)'
- en: 'Figure 4.6: Layout of the vertical cross image'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.6：垂直交叉图像布局
- en: 'The layout is `3` by `4` faces, which makes it possible to calculate the dimensions
    of the resulting cube map as follows. The code is from `shared/UtilsCubemap.cpp`:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 布局是 `3` 行 `4` 列的面，这使得我们可以如下计算结果立方体贴图的尺寸。代码来自 `shared/UtilsCubemap.cpp`：
- en: '[PRE78]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Let us set up pointers to read data from and write data to. This function is
    pixel format-agnostic so it needs to know the size of each pixel in bytes to be
    able to move pixels around with `memcpy()`:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们设置指针来读取数据和写入数据。这个函数与像素格式无关，因此它需要知道每个像素的字节数，以便能够使用 `memcpy()` 移动像素：
- en: '[PRE79]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Iterate over the faces and over every pixel of each face. The order of cube
    map faces here corresponds to the order of Vulkan cube map faces as described
    in *Vulkan specification 16.5.4\. Cube Map Face Selection*:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历面和每个面的每个像素。这里立方体贴图面的顺序对应于在*Vulkan规范16.5.4*中描述的Vulkan立方体贴图面的顺序：*立方体贴图面选择*：
- en: '[PRE80]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Calculate the source pixel position in the vertical cross layout based on the
    destination cube map face index:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据目标立方体贴图面索引计算垂直交叉布局中的源像素位置：
- en: '[PRE81]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Copy the pixel and advance to the next one:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制像素并移动到下一个像素：
- en: '[PRE82]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The resulting cube map contains an array of 6 2D images. Let us write some
    more C++ code to load and convert the actual texture data and upload it into *LightweightVK*.
    The source code is located in `Chapter04/04_CubeMap/src/main.cpp`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的立方体贴图包含一个包含6个2D图像的数组。让我们编写一些更多的C++代码来加载和转换实际的纹理数据，并将其上传到*LightweightVK*。源代码位于`Chapter04/04_CubeMap/src/main.cpp`：
- en: 'Use the `STB_image` floating point API to load a high dynamic range image from
    an `.hdr` file:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`STB_image`浮点API从`.hdr`文件中加载高动态范围图像：
- en: '[PRE83]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Convert an equirectangular map to a vertical cross and save the resulting image
    to an `.hdr` file for further inspection:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将等经线地图转换为垂直交叉并保存结果图像到`.hdr`文件以供进一步检查：
- en: '[PRE84]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Convert the loaded vertical cross image to the actual cube map faces:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将加载的垂直交叉图像转换为实际的立方体贴图面：
- en: '[PRE85]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now, uploading texture data to LightweightVK is straightforward. We call the
    `IContext::createTexture()` member function to create a texture and provide a
    pointer to the cube map data returned by `cubemap.data_.data()`:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将纹理数据上传到LightweightVK是直接的。我们调用`IContext::createTexture()`成员函数来创建一个纹理，并提供由`cubemap.data_.data()`返回的立方体贴图数据的指针：
- en: '[PRE86]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now we should take a look at how to write the GLSL shaders for this example:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该看看如何编写这个示例的GLSL着色器：
- en: 'Let us make a vertex shader `Chapter04/04_CubeMap/src/main.vert` that will
    take a model, view, and projection matrices as its inputs. We also need a camera
    position and bindless texture IDs for a mesh texture and for our cube map:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个顶点着色器`Chapter04/04_CubeMap/src/main.vert`，它将模型、视图和投影矩阵作为输入。我们还需要相机位置以及用于网格纹理和立方体贴图的免绑定纹理ID：
- en: '[PRE87]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'A buffer reference to `PerFrameData` is passed into the shader using Vulkan
    **push constants** (`pc` in the following code):'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Vulkan **推送常量**（以下代码中的`pc`）将`PerFrameData`的缓冲区引用传递到着色器中：
- en: '[PRE88]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The per-vertex attributes are provided to the vertex shader. The `PerVertex`
    structure is used to pass parameters to a fragment shader. Normal vectors are
    transformed with a matrix calculated as the inverse-transpose of the model matrix:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个顶点的属性被提供给顶点着色器。`PerVertex`结构用于将参数传递给片段着色器。法向量使用模型矩阵的逆转置矩阵进行变换：
- en: '[PRE89]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Now let’s take a look at the fragment shader found at `Chapter04/04_CubeMap/src/main.frag`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看位于`Chapter04/04_CubeMap/src/main.frag`的片段着色器：
- en: 'It shares the declaration of the `PerVertex` structure with the vertex shader
    mentioned above. The declaration is located in the file `Chapter04/04_CubeMap/src/common.sp`.
    We skip it here for the sake of brevity. The fragment shader uses the `textureBindlessCube()`
    helper function to sample the cube map using the calculated reflection vector.
    This function was discussed in detail in the *Using texture data in Vulkan* recipe
    in *Chapter 3, Working with Vulkan Objects*. The reflected direction vector is
    calculated using the `reflect()` GLSL built-in function:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它与上面提到的顶点着色器中`PerVertex`结构的声明共享。声明位于文件`Chapter04/04_CubeMap/src/common.sp`中。为了简洁起见，这里省略了它。片段着色器使用`textureBindlessCube()`辅助函数通过计算出的反射向量采样立方体贴图。这个函数在*第3章，使用Vulkan对象*中的*使用纹理数据在Vulkan*配方中进行了详细讨论。反射方向向量使用`reflect()`
    GLSL内置函数计算：
- en: '[PRE90]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'To add a more developed visual appearance, we add some diffuse lighting to
    our 3D model using a hardcoded light direction of `(0, 0.1, -1)`:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了增加更发达的视觉效果，我们使用硬编码的光方向`(0, 0.1, -1)`对我们的3D模型添加一些漫反射光照：
- en: '[PRE91]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The resulting output from the application looks as follows. Note the blown-out
    white areas of the sky in the reflection due to how a high dynamic range image
    is displayed directly onto a low dynamic range framebuffer. We will come back
    to this issue in *Chapter 10, Image-Based Techniques*, and implement a simple
    HDR tone-mapping operator.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序生成的输出如下所示。注意，由于高动态范围图像直接显示在低动态范围帧缓冲区上，反射中天空的白色区域被过度曝光。我们将在*第10章，基于图像的技术*中回到这个问题，并实现一个简单的HDR色调映射算子。
- en: '![Figure 4.7: Reflective rubber duck](img/file25.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7：反射的橡皮鸭](img/file25.jpg)'
- en: 'Figure 4.7: Reflective rubber duck'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：反光橡皮鸭
- en: Now let’s get back to improving the user interaction capabilities and learn
    how to implement a simple camera class to move around and debug our 3D scenes.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到提高用户交互能力，学习如何实现一个简单的相机类来移动和调试我们的3D场景。
- en: There’s more...
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In OpenGL, developers had to enable a special cube map sampling mode to ensure
    seamless filtering across all cube map faces. In Vulkan, all cube map texture
    fetches are seamless (as described under *Cube Map Edge Handling* in the Vulkan
    specification), except the ones with `VK_FILTER_NEAREST`, which are clamped to
    the face edge.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL中，开发者必须启用一个特殊的立方体贴图采样模式，以确保所有立方体贴图面的无缝过滤。在Vulkan中，所有立方体贴图纹理提取都是无缝的（如Vulkan规范中*立方体贴图边缘处理*部分所述），除了那些带有`VK_FILTER_NEAREST`的，它们被夹在面边缘。
- en: Working with a 3D camera and basic user interaction
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用3D相机和基本用户交互
- en: To debug a graphical application, it is very helpful to be able to navigate
    and move around within a 3D scene using a keyboard or mouse. Graphics APIs themselves
    are not familiar with concepts of cameras and user interaction, so we have to
    implement a camera model that will convert user input into a view matrix usable
    by Vulkan. In this recipe, we will learn how to create a simple yet extensible
    3D camera implementation and use it to enhance the functionality of our Vulkan
    examples.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 要调试一个图形应用程序，能够使用键盘或鼠标在3D场景中导航和移动是非常有帮助的。图形API本身并不熟悉相机和用户交互的概念，因此我们必须实现一个相机模型，该模型将用户输入转换为Vulkan可用的视图矩阵。在这个菜谱中，我们将学习如何创建一个简单但可扩展的3D相机实现，并使用它来增强我们的Vulkan示例的功能。
- en: Getting ready
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: The source code for this recipe can be found in `Chapter04/05_Camera`. The camera
    classes are declared and implemented in the file `shared/Camera.h`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的源代码可以在`Chapter04/05_Camera`中找到。相机类在文件`shared/Camera.h`中声明和实现。
- en: How to do it...
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Our camera implementation will calculate a view matrix and a 3D position point
    based on the selected dynamic model. Let’s look at the steps:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的相机实现将根据所选的动态模型计算视图矩阵和3D位置点。让我们看看步骤：
- en: 'First, let us implement the `Camera` class, which will represent our main API
    to work with a 3D camera. The class stores a reference to an instance of the `CameraPositionerInterface`
    class, being a polymorphic implementation of the underlying camera model to allow
    runtime switches of camera behaviors:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们实现`Camera`类，它将代表我们与3D相机工作的主要API。该类存储对`CameraPositionerInterface`类实例的引用，这是一个底层相机模型的泛型实现，允许在运行时切换相机行为：
- en: '[PRE92]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The interface of `CameraPositionerInterface` contains only pure virtual methods
    and a default virtual destructor:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`CameraPositionerInterface`的接口只包含纯虚方法和一个默认的虚析构函数：'
- en: '[PRE93]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now we can implement the actual camera model. We will start with a quaternion-based
    first-person camera that can be freely moved in space in any direction. Let us
    look at the `CameraPositioner_FirstPerson` class. The inner `Movement` structure
    contains Boolean flags that define the current motion state of our camera. This
    is useful to decouple keyboard and mouse inputs from the camera control logic:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以实现实际的相机模型。我们将从一个基于四元数的第一人称相机开始，该相机可以在空间中自由地向任何方向移动。让我们看看`CameraPositioner_FirstPerson`类。内部`Movement`结构包含布尔标志，用于定义我们相机的当前运动状态。这对于将键盘和鼠标输入与相机控制逻辑解耦非常有用：
- en: '[PRE94]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Various numeric parameters define how responsive the camera will be to acceleration
    and damping. These parameters can be tweaked as you see fit:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不同的数值参数定义了相机对加速度和阻尼的响应程度。这些参数可以根据您的需要进行调整：
- en: '[PRE95]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We need certain private data members to control the camera state, such as the
    previous mouse position, the current camera position and orientation, the current
    movement speed, and the vector representing the “up” direction:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要某些私有数据成员来控制相机状态，例如前一个鼠标位置、当前相机位置和方向、当前移动速度以及表示“向上”方向的向量：
- en: '[PRE96]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The non-default constructor takes the camera’s initial position, a target position,
    and a vector pointing upwards. This input is similar to what one might normally
    use to construct a look-at viewing matrix. Indeed, we use the `glm::lookAt()`
    function to initialize the camera:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 非默认构造函数接受相机的初始位置、目标位置以及指向向上的向量。这个输入类似于人们通常用来构造查看矩阵的输入。实际上，我们使用`glm::lookAt()`函数来初始化相机：
- en: '[PRE97]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Now, we can add some dynamics to our camera model. The `update()` method should
    be called every frame and take the time elapsed since the previous frame, as well
    as the mouse position and a mouse-button-pressed flag:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以给我们的摄像机模型添加一些动态效果。`update()` 方法应该在每一帧调用，并获取自上一帧以来经过的时间，以及鼠标位置和鼠标按钮按下标志：
- en: '[PRE98]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Now, when the mouse button is pressed, we calculate a delta vector versus the
    previous mouse position, and use it to construct a rotation quaternion. This quaternion
    is used to rotate the camera. Once the camera rotation is applied, we should update
    the mouse position state.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当鼠标按钮被按下时，我们计算一个与之前鼠标位置的增量向量，并使用它来构造一个旋转四元数。这个四元数用于旋转摄像机。一旦摄像机旋转被应用，我们应该更新鼠标位置状态。
- en: 'Now we should establish the camera’s coordinate system to calculate the camera
    movement. Let us extract the forward, right, and up vectors from the `mat4` view
    matrix:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们应该建立摄像机的坐标系以计算摄像机移动。让我们从 `mat4` 视图矩阵中提取前向、右向和上向量：
- en: '[PRE99]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The `forward` vector corresponds to the camera’s direction, which is the direction
    the camera is pointing at. The `right` vector corresponds to the positive X-axis
    of the camera space. The `up` vector is the positive Y-axis of the camera space,
    which is perpendicular to the first two vectors and can be calculated as their
    cross product.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`forward` 向量对应于摄像机的方向，即摄像机指向的方向。`right` 向量对应于摄像机空间的正 X 轴。`up` 向量是摄像机空间的正 Y
    轴，它与前两个向量垂直，可以通过它们的叉积来计算。'
- en: 'The camera coordinate system has been established. Now we can apply our input
    state from the `Movement` structure to control the movement of our camera:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 摄像机坐标系已经建立。现在我们可以将来自 `Movement` 结构的输入状态应用到我们的摄像机上以控制其移动：
- en: '[PRE100]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Instead of controlling the camera speed or position directly, we let the user
    input control only the acceleration vector directly. This way, the camera’s behavior
    is much smoother, more natural, and non-jerky.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是直接控制摄像机速度或位置，而是让用户输入直接控制加速度向量。这样，摄像机的行为会更加平滑、自然，不会出现突然的运动。
- en: 'If, based on the input state, the calculated camera acceleration is zero, we
    should decelerate the camera’s motion gradually, according to the `damping_` parameter.
    Otherwise, we should integrate the camera motion using simple Euler integration.
    The maximum possible speed value is clamped according to the `maxSpeed_` parameter:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果根据输入状态，计算出的摄像机加速度为零，我们应该根据 `damping_` 参数逐渐减速摄像机的运动。否则，我们应该使用简单的欧拉积分来积分摄像机运动。最大可能的速度值根据
    `maxSpeed_` 参数进行限制：
- en: '[PRE101]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The view matrix can be calculated from the camera orientation quaternion and
    camera position in the following way:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图矩阵可以通过以下方式从摄像机方向四元数和摄像机位置计算得出：
- en: '[PRE102]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The translational part is inferred from the `cameraPosition_` vector and the
    rotational part is calculated directly from the orientation quaternion.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 平移部分是从 `cameraPosition_` 向量推断出来的，旋转部分直接从方向四元数计算得出。
- en: 'Helpful getters and setters are trivial, except for the `setUpVector()` method,
    which has to recalculate the camera orientation using the existing camera position
    and direction as follows:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有用的获取器和设置器很简单，除了 `setUpVector()` 方法，它必须使用现有的摄像机位置和方向重新计算摄像机方向，如下所示：
- en: '[PRE103]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'One additional helper function is necessary to reset the previous mouse position
    to prevent jerky rotation movements when, for example, the mouse cursor leaves
    the window:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要一个额外的辅助函数来重置之前的鼠标位置，以防止例如鼠标光标离开窗口时出现突然的旋转运动：
- en: '[PRE104]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The above class can be used in 3D applications to move the viewer around. Let
    us see how it works.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 上述类可以在 3D 应用中使用，以移动观众。让我们看看它是如何工作的。
- en: How it works...
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The demo application is based on the cube map example from the previous *Using
    cube map textures in Vulkan* recipe. The updated code is located at `Chapter04/05_Camera/src/main.cpp`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 演示应用程序基于之前 *在 Vulkan 中使用立方体贴图纹理* 菜单中的立方体贴图示例。更新的代码位于 `Chapter04/05_Camera/src/main.cpp`。
- en: 'We add a mouse state and define `CameraPositioner` and `Camera`. Let them be
    global variables:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加一个鼠标状态并定义 `CameraPositioner` 和 `Camera`。让它们成为全局变量：
- en: '[PRE105]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The GLFW cursor position callback should update `mouseState` the following
    way:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: GLFW 光标位置回调应该按照以下方式更新 `mouseState`：
- en: '[PRE106]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Here, we convert window pixel coordinates into normalized `0...1` coordinates
    and accommodate the inverted Y-axis.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将窗口像素坐标转换为归一化的 `0...1` 坐标，并适应反转的 Y 轴。
- en: 'The GLFW mouse button callback passes GLFW mouse events to ImGui and sets the
    `pressedLeft` flag when the left mouse button is pressed:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: GLFW鼠标按钮回调将GLFW鼠标事件传递给ImGui，并在左鼠标按钮被按下时设置`pressedLeft`标志：
- en: '[PRE107]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'To handle keyboard input for camera movement, let us write the following GLFW
    keyboard callback:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理相机移动的键盘输入，让我们编写以下GLFW键盘回调函数：
- en: '[PRE108]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The *WSAD* keys are used to move the camera around and the *Spacebar* is used
    to reorient the camera up vector to the world `(0, 1, 0)` vector and reset the
    position camera back to the initial position. The Shift key is used to move the
    camera faster.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '*WSAD*键用于移动相机，*空格键*用于将相机向上向量重新定向到世界`(0, 1, 0)`向量，并将相机位置重置到初始位置。Shift键用于加快相机移动速度。'
- en: 'We can update the camera positioner from the main loop using the following
    statement:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下语句从主循环中更新相机定位器：
- en: '[PRE109]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Here’s a code fragment to upload matrices into a Vulkan per-frame uniform buffer,
    similar to how it was done with fixed values in the previous chapters:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个代码片段，用于将矩阵上传到Vulkan每帧均匀缓冲区，类似于在前面章节中使用固定值时的操作：
- en: '[PRE110]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Run the demo from `Chapter04/05_Camera` to play around with the keyboard and
    mouse:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Chapter04/05_Camera`运行演示，以使用键盘和鼠标进行操作：
- en: '![Figure 4.8: Camera](img/file26.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![图4.8：相机](img/file26.jpg)'
- en: 'Figure 4.8: Camera'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8：相机
- en: There is more...
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This camera design approach can be extended to accommodate different motion
    behaviors. In the next recipe, we will learn how to implement some other useful
    camera positioners.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这种相机设计方法可以扩展以适应不同的运动行为。在下一个菜谱中，我们将学习如何实现一些其他有用的相机定位器。
- en: The 3D camera functionality introduced in this recipe is incredibly valuable
    for our book. To reduce code duplication, we’ve created a helper class called
    `VulkanApp`. This class wraps the first-person camera positioner along with other
    features such as the frames-per-second counter, `ImGuiRenderer`, and some others.
    The `VulkanApp` class will be utilized in all the subsequent recipes throughout
    this book. You can find it in the `shared/VulkanApp.h` and `shared/VulkanApp.cpp`
    files.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱中引入的3D相机功能对我们这本书来说非常有价值。为了减少代码重复，我们创建了一个名为`VulkanApp`的辅助类。这个类封装了第一人称相机定位器以及其他功能，如每秒帧数计数器、`ImGuiRenderer`等。`VulkanApp`类将在本书的所有后续菜谱中用到。你可以在`shared/VulkanApp.h`和`shared/VulkanApp.cpp`文件中找到它。
- en: Adding camera animations and motion
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加相机动画和运动
- en: 'Besides having a user-controlled first-person camera, it is convenient to be
    able to position and move the camera programmatically inside a 3D scene – this
    is helpful for debugging when we need to organize automatic screenshot tests with
    camera movement, for example. In this recipe, we will show how to do it and extend
    our minimalistic 3D camera framework from the previous recipe. We will draw a
    combo box using ImGui to select between two camera modes: a first-person free
    camera, and a fixed camera moving to a user-specified point settable from the
    UI.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 除了拥有用户控制的第一个人称相机外，能够在3D场景中编程地定位和移动相机也很方便——这在需要组织带有相机移动的自动截图测试时进行调试时很有帮助。在这个菜谱中，我们将展示如何做到这一点，并扩展前面菜谱中的最小化3D相机框架。我们将使用ImGui绘制一个组合框，以在两个相机模式之间进行选择：一个第一人称自由相机和一个移动到用户从UI设置的指定点的固定相机。
- en: Getting ready
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: The full source code for this recipe is a part of the final demo application
    for this chapter, and you can find it in `Chapter04/06_DemoApp`. Implementations
    of all new camera-related functionality are located in the `shared/Camera.h` file.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的完整源代码是本章最终演示应用程序的一部分，你可以在`Chapter04/06_DemoApp`中找到它。所有新的相机相关功能实现都位于`shared/Camera.h`文件中。
- en: How to do it...
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let’s look at how to programmatically control our 3D camera using a simple
    ImGui-based user interface:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用基于ImGui的简单用户界面来编程控制我们的3D相机：
- en: 'First, we need to add a new `CameraPosition_MoveTo` camera positioner that
    automatically moves the camera to a specified `vec3` point. For this purpose,
    we have to declare a bunch of global constants and variables:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要添加一个新的`CameraPosition_MoveTo`相机定位器，该定位器能够自动将相机移动到指定的`vec3`点。为此，我们必须声明一系列全局常量和变量：
- en: '[PRE111]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Inside the main loop, we should update our new camera positioner. The first-person
    camera positioner is updated automatically inside the `VulkanApp` class mentioned
    in the previous recipe:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主循环内部，我们应该更新我们新的相机定位器。第一人称相机定位器在前面菜谱中提到的`VulkanApp`类内部自动更新：
- en: '[PRE112]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Now, let’s draw an ImGui combo box to select which camera positioner should
    be used to control the camera motion:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们绘制一个ImGui组合框来选择应该使用哪个相机定位器来控制相机运动：
- en: 'First, a few more global variables will come in handy to store the current
    camera type, items of the combo box UI, and the new value selected in the combo
    box:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，一些额外的全局变量将很有用，用于存储当前相机类型、组合框UI的项以及组合框中选中的新值：
- en: '[PRE113]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'To render the camera control UI with a combo box, let’s write the following
    code. A new ImGui window starts with a call to `ImGui::Begin()`:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用组合框渲染相机控制UI，让我们编写以下代码。一个新的ImGui窗口通过调用`ImGui::Begin()`开始：
- en: '[PRE114]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The combo box itself is rendered via `ImGui::BeginCombo()`. The second parameter
    is the previewed label name to show before opening the combo box. This function
    will return true if the user has clicked on a label:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组合框本身是通过`ImGui::BeginCombo()`渲染的。第二个参数是在打开组合框之前显示的预览标签名称。如果用户点击了标签，此函数将返回true：
- en: '[PRE115]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'You may set the initial focus when opening the combo box. This is useful if
    you want to support scrolling or keyboard navigation inside the combo box:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在打开组合框时设置初始焦点。如果您想在组合框内支持滚动或键盘导航，这很有用：
- en: '[PRE116]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Finalize the ImGui combo box rendering:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成ImGui组合框的渲染：
- en: '[PRE117]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'If the `MoveTo` camera type is selected, render `vec3` input sliders to get
    the camera position and Euler angles from the user:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果选择`MoveTo`相机类型，则渲染`vec3`输入滑块以从用户获取相机位置和欧拉角：
- en: '[PRE118]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'If a new selected combo box item is different from the current camera type,
    print a debug message and change the active camera mode:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果新选中的组合框项与当前相机类型不同，则打印调试消息并更改活动相机模式：
- en: '[PRE119]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The resulting combo box should look as in the following screenshot:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的组合框应该看起来如下截图所示：
- en: '![Figure 4.9: Camera controls](img/file27.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![图4.9：相机控制](img/file27.png)'
- en: 'Figure 4.9: Camera controls'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9：相机控制
- en: The preceding code is called from the main loop on every frame to draw ImGui.
    Check out the `Chapter04/06_DemoApp/src/main.cpp` file for the complete source
    code.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码在每帧的主循环中被调用以绘制ImGui。查看`Chapter04/06_DemoApp/src/main.cpp`文件以获取完整的源代码。
- en: How it works...
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let’s take a look at the implementation of the `CameraPositioner_MoveTo` class
    in `shared/Camera.h` we mentioned earlier in *steps 1* and *2*. In contrast to
    the first-person camera positioner introduced in the previous recipe, which relies
    on quaternions, this new positioner employs a straightforward Euler angles approach
    to store the camera orientation. This method is more user-friendly and intuitive
    for controlling the camera. The following are the steps to help us understand
    how this camera positioner works:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们之前在*步骤1*和*步骤2*中提到的`shared/Camera.h`中`CameraPositioner_MoveTo`类的实现。与之前菜谱中引入的第一人称相机定位器不同，它依赖于四元数，这个新的定位器采用简单的欧拉角方法来存储相机方向。这种方法对用户来说更友好，也更直观，用于控制相机。以下是一些步骤，帮助我们理解这个相机定位器是如何工作的：
- en: 'First, we want to have some user-configurable parameters for linear and angular
    damping coefficients:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们希望有一些用户可配置的参数，用于线性阻尼系数和角阻尼系数：
- en: '[PRE120]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'We store the current and desired positions of the camera as well as two sets
    of pitch, pan, and roll Euler angles in `vec3` member fields. The current camera
    transformation is updated every frame and saved in a `mat4` field:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将当前和期望的相机位置以及两套俯仰、偏航和翻滚欧拉角存储在`vec3`成员字段中。当前相机变换每帧更新并保存在`mat4`字段中：
- en: '[PRE121]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The constructor initializes both the current and desired data sets of the camera:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数初始化相机的当前和期望数据集：
- en: '[PRE122]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The most interesting part happens in the `update()` function. The current camera
    position is changed to move towards the desired camera position. The movement
    speed is proportional to the distance between these two positions and scaled using
    the linear damping coefficient:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最有趣的部分发生在`update()`函数中。当前相机位置会改变，以移动到所需的相机位置。移动速度与这两个位置之间的距离成正比，并使用线性阻尼系数进行缩放：
- en: '[PRE123]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Now, let’s deal with Euler angles. We should clip them accordingly to make
    sure they remain within the `0…360` degrees range. This is required to prevent
    our camera from “spinning” around the object `2*Pi` times:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们处理欧拉角。我们应该相应地剪辑它们，以确保它们保持在`0…360`度的范围内。这是防止我们的相机围绕对象旋转`2*Pi`次所必需的：
- en: '[PRE124]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Similar to how we dealt with the camera position, the Euler angles are updated
    based on the distance between the desired and current set of angles. Before calculating
    the camera transformation matrix, clip the updated angles again and convert the
    values from degrees to radians. Note how the pitch, pan, and roll angles are swizzled
    before they are forwarded into `glm::yawPitchRoll()`:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似于我们处理相机位置的方式，欧拉角是根据期望和当前角度集合之间的距离进行更新的。在计算相机变换矩阵之前，再次剪辑更新的角度并将值从度转换为弧度。注意在转发到
    `glm::yawPitchRoll()` 之前，俯仰、偏航和翻滚角度是如何进行置换的：
- en: '[PRE125]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The functions for the angle clipping are straightforward and look as follows:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 角度剪辑的函数很简单，如下所示：
- en: '[PRE126]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The delta between two sets of angles can be calculated in the following way:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两组角度之间的差值可以按以下方式计算：
- en: '[PRE127]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Try running the demo application, `Chapter04/06_DemoApp`. Switch to the `MoveTo`
    camera and change the position and orientation from the ImGui user interface.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行演示应用程序，`Chapter04/06_DemoApp`。切换到 `MoveTo` 相机，并从ImGui用户界面更改位置和方向。
- en: There’s more...
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Further camera functionality can be built on top of this example implementation.
    One more useful extension might be a camera that follows a spline curve defined
    using a set of key points for positions and targets. We will leave this as an
    exercise for you.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在这个示例实现的基础上构建更多的相机功能。另一个有用的扩展可能是一个跟随使用一组关键点定义的位置和目标的样条曲线的相机。我们将把这个留给你作为练习。
- en: Implementing an immediate-mode 3D drawing canvas
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现即时模式3D绘图画布
- en: The *Setting up Vulkan debugging capabilities* recipe from *Chapter 2, Getting
    Started with Vulkan*, only scratched the surface of graphical application debugging.
    The validation layers provided by the Vulkan API are invaluable but they do not
    allow you to debug logical and calculation-related errors. To see what is happening
    in our virtual world, we need to be able to render auxiliary graphical information
    such as objects’ bounding boxes and plot time-varying charts of different values
    or plain straight lines. The Vulkan API does not provide any immediate-mode rendering
    facilities. All it can do is add commands to command buffers scheduled for later
    submission. To overcome this difficulty and add an immediate-mode rendering canvas
    to our applications, we have to write some additional code. Let’s learn how to
    do it in this recipe.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 《第2章，Vulkan入门》中的*设置Vulkan调试功能*配方只是触及了图形应用程序调试的表面。Vulkan API提供的验证层非常有价值，但它们不允许你调试逻辑和计算相关的错误。为了看到我们虚拟世界中的情况，我们需要能够渲染辅助图形信息，例如对象的边界框和绘制不同值的时变图表或普通直线。Vulkan
    API不提供任何即时模式渲染设施。它所能做的就是向计划稍后提交的命令缓冲区添加命令。为了克服这个困难并向我们的应用程序添加即时模式渲染画布，我们必须编写一些额外的代码。让我们在本配方中学习如何做到这一点。
- en: Getting ready
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you are proficient with all the rendering recipes from *Chapter 3,
    Working with Vulkan Objects*. Check the `shared/LineCanvas.h` and `shared/LineCanvas.cpp`
    files for a working implementation of this recipe. An example of how to use a
    new `LineCanvas3D` 3D line drawing class is a part of the demo app at `Chapter04/06_DemoApp`.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你精通《第3章，与Vulkan对象一起工作》中所有的渲染配方。检查 `shared/LineCanvas.h` 和 `shared/LineCanvas.cpp`
    文件以获取此配方的有效实现。一个如何使用新的 `LineCanvas3D` 3D线条绘制类的示例是演示应用程序 `Chapter04/06_DemoApp`
    的一部分。
- en: How to do it...
  id: totrans-396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The `LineCanvas3D` class contains a CPU-accessible list of 3D lines defined
    by two points and a color. Each frame, the user can call the `line()` method to
    draw a new 3D line that should be rendered in the current frame. To render these
    lines into the framebuffer, we maintain a collection of Vulkan buffers to store
    line geometry data, which we will update every frame. Let’s take a look at the
    interface of this class:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`LineCanvas3D` 类包含一个由两个点和颜色定义的3D线条的CPU可访问列表。在每一帧中，用户可以调用 `line()` 方法来绘制一个新的3D线条，该线条应在当前帧中渲染。为了将这些线条渲染到帧缓冲区中，我们维护一个Vulkan缓冲区集合来存储线条几何数据，我们将每帧更新这些数据。让我们看看这个类的接口：'
- en: 'The `LineCanvas3D` class has its internal 3D line representation as a pair
    of vertices for each and every line, whereas each vertex consists of a `vec4`
    position and a color. Each `linesBuffer` buffer holds a GPU-visible copy of the
    `lines_` container. We have one buffer for each swapchain image to avoid any additional
    Vulkan synchronization:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LineCanvas3D` 类将其内部3D线条表示为每条线的顶点对，而每个顶点由一个 `vec4` 位置和一个颜色组成。每个 `linesBuffer`
    缓冲区包含 `lines_` 容器的GPU可见副本。我们为每个swapchain图像有一个缓冲区，以避免任何额外的Vulkan同步：'
- en: '[PRE128]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'The actual drawing functionality consists of a set of functions. We want to
    be able to clear the canvas, render one line, and render some useful primitives,
    such as 3D planes, boxes, and frustums. Further utility functions can easily be
    built on top of the functionality provided by the `line()` member function:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际的绘图功能由一系列函数组成。我们希望能够清除画布，渲染一条线，以及渲染一些有用的原语，例如3D平面、盒子和视锥体。可以在 `line()` 成员函数提供的功能之上轻松构建更多实用函数：
- en: '[PRE131]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'The longest method of this class is `render()`, which generates Vulkan commands
    into the provided command buffer to render the current contents of `LineCanvas3D`.
    We will look into its implementation in a few moments:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个类中最长的方法是 `render()`，它将Vulkan命令生成到提供的命令缓冲区中，以渲染 `LineCanvas3D` 的当前内容。我们将在稍后查看其实现：
- en: '[PRE132]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Now, let us deal with the non-Vulkan part of the code:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们处理代码的非Vulkan部分：
- en: 'The `line()` member function itself just adds two colored `vec3` points to
    the container:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`line()` 成员函数本身只是将两个彩色的 `vec3` 点添加到容器中：'
- en: '[PRE133]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The `plane()` method uses `line()` internally to create a visual representation
    of a three-dimensional plane spanned by the `v1` and `v2` vectors with half-sizes
    `s1` and `s2`, and an origin point `o`. The `n1` and `n2` parameters specify how
    many lines we want to render along each coordinate direction:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`plane()` 方法内部使用 `line()` 函数来创建由 `v1` 和 `v2` 向量以及半尺寸 `s1` 和 `s2` 以及原点 `o` 张成的三维平面的可视化表示。`n1`
    和 `n2` 参数指定了我们想要在每个坐标方向上渲染多少条线：'
- en: '[PRE134]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Draw the 4 outer lines representing a plane segment:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制代表平面段的4条外线：
- en: '[PRE135]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Draw `n1` horizontal lines and `n2` vertical lines inside the plane:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在平面上绘制 `n1` 条水平线和 `n2` 条垂直线：
- en: '[PRE136]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'The `box()` member function draws a colored box oriented using the provided
    `m` model matrix and half-size `size` along the `X`, `Y`, and `Z` axes. The idea
    is to create 8 corner points of the box and transform them using the `m` matrix:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`box()` 成员函数使用提供的 `m` 模型矩阵和沿 `X`、`Y` 和 `Z` 轴的半尺寸 `size` 绘制一个彩色盒子。其想法是创建盒子的8个角点，并使用
    `m` 矩阵变换它们：'
- en: '[PRE137]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Then render all 12 edges of the box using the `line()` function:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后使用 `line()` 函数渲染盒子的所有12条边：
- en: '[PRE138]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'There’s yet another overload of the `box()` function, which takes in the `BoundingBox`
    class declared in `shared/UtilsMath.h`. It is just a trivial wrapper over the
    previous variant of this function:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`box()` 函数还有一个重载版本，它接受在 `shared/UtilsMath.h` 中声明的 `BoundingBox` 类。它只是对这个函数之前版本的简单包装：'
- en: '[PRE139]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The most interesting drawing function is `frustum()`, which renders a 3D frustum
    represented by a `camProj` view matrix positioned in the world using the `camView`
    matrix. Long story short, if you have a 3D camera somewhere in your world and
    its view and projection matrix are `camView` and `camProj` respectively, you can
    use this function to visualize that camera’s viewing frustum:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最有趣的绘图函数是 `frustum()`，它使用 `camProj` 视矩阵在世界上渲染一个由 `camView` 矩阵定位的3D视锥体。简而言之，如果你在你的世界中有一个3D摄像机，并且它的视图和投影矩阵分别是
    `camView` 和 `camProj`，你可以使用这个函数来可视化该摄像机的视锥体：
- en: This code is invaluable in debugging things such as shadow maps or culling frustums.
    We will put it to heavy use in the final chapters of this book.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在调试诸如阴影图或视锥体裁剪等问题时非常有价值。我们将在本书的最后一章中大量使用它。
- en: '[PRE140]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The idea is somewhat similar to the `box()` function mentioned above. We create
    a set of corner points on a cube corresponding to 8 corners of the camera frustum
    (points are referred to as `pp` in the following code). Then, we transform each
    of these points with the inverse of the provided view-projection matrix, essentially
    warping a box into a frustum shape. Then we use `line()` to connect the dots:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个想法与上面提到的 `box()` 函数有些相似。我们在一个立方体上创建一组角点，对应于摄像机视锥体的8个角（在以下代码中，这些点被称为 `pp`）。然后，我们使用提供的视图-投影矩阵的逆变换每个这些点，本质上是将一个盒子变形为视锥体形状。然后我们使用
    `line()` 函数连接这些点：
- en: '[PRE141]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'These are four lines representing the side edges of the camera frustum:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这四条线代表摄像机视锥体的侧面边缘：
- en: '[PRE142]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'With the side edges done, we need to draw the near plane. The extra two lines
    are used to draw a cross inside the near plane:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 侧面边缘绘制完成后，我们需要绘制近平面。我们使用额外的两条线在近平面内画一个十字：
- en: '[PRE143]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Next, we do the far plane. Here again, the extra two lines are used to draw
    a cross to give better visual cues:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们处理远平面。在这里，我们再次使用额外的两条线来画一个十字，以提供更好的视觉提示：
- en: '[PRE144]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Now let’s draw the sides of the frustum to give a nice perception of volume.
    We use a dimmed color and `100` lines on each side:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们绘制视锥体的侧面，以获得良好的体积感。我们使用较暗的颜色和每侧 `100` 条线：
- en: '[PRE145]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Here are the bottom and the top sides:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是底部和顶部两侧：
- en: '[PRE146]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'The same should be done with the left and right sides of our frustum:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该对截锥体的左右两侧做同样的处理：
- en: '[PRE147]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: That covers the user-facing part of our line-drawing API. Let’s take a look
    at the actual rendering code to learn how it works in an app.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 这就涵盖了我们的线条绘制API的用户界面部分。让我们看看实际的渲染代码，了解它在应用程序中的工作方式。
- en: How it works…
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: All the rendering and graphics pipeline creation is done within a single `render()`
    function.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 所有渲染和图形管线创建都是在单个 `render()` 函数中完成的。
- en: 'The function accepts a *LightweightVK* context, a framebuffer, and a command
    buffer:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受一个 *LightweightVK* 上下文、一个帧缓冲区和命令缓冲区：
- en: '[PRE148]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'The required GPU buffer size is calculated based on the current number of lines.
    If the current buffer capacity is not sufficient, the buffer is reallocated:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的GPU缓冲区大小是根据当前行数计算的。如果当前缓冲区容量不足，则重新分配缓冲区：
- en: '[PRE149]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'If there’s no rendering pipeline available, we should create a new one. We
    use `lvk::Topology_Line`, which matches `VK_PRIMITIVE_TOPOLOGY_LINE_LIST`. Simple
    alpha blending is used to render all the lines:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有可用的渲染管线，我们应该创建一个新的。我们使用 `lvk::Topology_Line`，它与 `VK_PRIMITIVE_TOPOLOGY_LINE_LIST`
    匹配。使用简单的alpha混合来渲染所有线条：
- en: '[PRE150]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Our line-drawing vertex shader accepts the current combined model-view-projection
    matrix `mvp` and a GPU reference to the buffer containing the line data. Everything
    is updated using Vulkan push constants:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 我们线条绘制的顶点着色器接受当前组合的模型视图投影矩阵 `mvp` 和包含线条数据的GPU缓冲区引用。所有内容都使用Vulkan推送常数进行更新：
- en: '[PRE151]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Once the Vulkan rendering state is prepared, we can render the lines and switch
    to the next frame to use one of the available buffers:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦准备好的Vulkan渲染状态，我们就可以绘制线条并切换到下一帧以使用可用的缓冲区之一：
- en: '[PRE152]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: It is also worth taking a quick look at the line-drawing GLSL shaders.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 值得快速查看一下线绘制GLSL着色器。
- en: 'The vertex shader is as follows. Programmable-vertex pulling is used to extract
    line data from the provided buffer:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器如下。使用可编程顶点提取从提供的缓冲区中提取线条数据：
- en: '[PRE153]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'The fragment shader is trivial and simply outputs the provided color:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器很简单，只是输出提供的颜色：
- en: '[PRE154]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: That is everything regarding drawing 3D lines. For a comprehensive example showing
    how to use this 3D drawing canvas, check the final *Putting it all together into
    a Vulkan application* recipe in this chapter.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是关于绘制3D线条的所有内容。要查看如何使用此3D绘图画布的综合示例，请查看本章末尾的 *将所有内容组合到Vulkan应用程序中* 配方。
- en: The next recipe will conclude Vulkan auxiliary rendering by showing how to render
    2D lines and charts with the help of the ImGui and ImPlot libraries.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个配方将通过展示如何使用ImGui和ImPlot库绘制2D线条和图表来总结Vulkan辅助渲染。
- en: Rendering on-screen graphs with ImGui and ImPlot
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ImGui和ImPlot在屏幕上渲染图表
- en: In the previous recipe, we learned how to create immediate mode drawing facilities
    in Vulkan with basic drawing functionality. That 3D canvas was rendered on top
    of a 3D scene sharing a view-projection matrix with it. In this recipe, we will
    continue adding useful debugging features to our framework and learn how to implement
    pure 2D line drawing functionality. It is possible to implement such a class in
    a way similar to `LineCanvas3D`. However, we already use the ImGui library in
    our apps as described in the *Rendering ImGui user interface* recipe. Let’s put
    it to use to render our 2D lines.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个配方中，我们学习了如何在Vulkan中使用基本绘图功能创建即时模式绘图功能。那个3D画布是在与它共享视图投影矩阵的3D场景之上渲染的。在这个配方中，我们将继续向我们的框架添加有用的调试功能，并学习如何实现纯2D线条绘制功能。可以以类似于
    `LineCanvas3D` 的方式实现此类。然而，正如在 *渲染ImGui用户界面* 配方中所描述的，我们已经在我们的应用程序中使用了ImGui库。让我们将其用于渲染我们的2D线条。
- en: Getting ready
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: We recommend revisiting the *Rendering ImGui user interfaces* and *Implementing
    an immediate-mode 3D drawing canvas* recipes to get a better grasp of how a simple
    Vulkan drawing canvas can be implemented.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议重新查看 *渲染ImGui用户界面* 和 *实现即时模式3D绘图画布* 配方，以更好地了解如何实现简单的Vulkan绘图画布。
- en: How to do it...
  id: totrans-462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'What we need at this point essentially boils down to decomposing a 2D chart
    or graph into a set of lines and rendering them using ImGui. Let’s go through
    the code to see how to do it:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们本质上需要将2D图表或图形分解成一系列线条并使用ImGui进行渲染。让我们通过代码看看如何实现：
- en: 'We introduce a `LineCanvas2D` class to render 2D lines. It stores a collection
    of 2D lines:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们引入一个 `LineCanvas2D` 类来渲染2D线条。它存储了一组2D线条：
- en: '[PRE155]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'The `render()` method is quite simple. We create a new full-screen ImGui window
    with all decorations removed and user input disabled:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`render()`方法相当简单。我们创建一个新全屏ImGui窗口，移除所有装饰并禁用用户输入：'
- en: '[PRE156]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Then we obtain ImGui’s background draw list and add all our colored lines to
    it one by one. The rest of the rendering will be handled as a part of the ImGui
    user interface rendering, as described in the *Rendering ImGui user interfaces*
    recipe:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们获取ImGui的背景绘制列表，并将所有我们的彩色线条逐一添加到其中。其余的渲染将作为ImGui用户界面渲染的一部分来处理，如*渲染ImGui用户界面*菜谱中所述：
- en: '[PRE157]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Inside the `Chapter04/06_DemoApp/src/main.cpp` demo application, we can work
    with an instance of `LineCanvas2D` the following way:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter04/06_DemoApp/src/main.cpp`演示应用程序内部，我们可以以下这种方式与`LineCanvas2D`的实例一起工作：
- en: '[PRE158]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'This functionality is sufficient to render 2D lines for various debugging purposes.
    However, there’s yet another way to do rendering using the ImPlot library. Let’s
    use it to render an FPS graph. The helper code is in `shared/Graph.h`:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 这种功能足以渲染用于各种调试目的的2D线条。然而，还有另一种使用ImPlot库进行渲染的方法。让我们用它来渲染FPS图表。辅助代码在`shared/Graph.h`中：
- en: 'We declare another small `LinearGraph` helper class to draw a graph of changing
    values, such as the number of rendered frames per second:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明另一个小的`LinearGraph`辅助类来绘制变化值的图表，例如每秒渲染的帧数：
- en: '[PRE159]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'As we add more points to the graph, the old points are popped out, making the
    graph look like it is scrolling on the screen right-to-left. This is helpful to
    observe local fluctuations in values such as frames per second counters, and so
    on:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着我们向图表添加更多点，旧点被弹出，使图表看起来像在屏幕上从右到左滚动。这对于观察诸如每秒帧数计数器等值的局部波动很有帮助：
- en: '[PRE160]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'The idea is to find the minimum and maximum values and normalize the graph
    into the `0...1` range:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 策略是找到最小值和最大值，并将图表归一化到`0...1`的范围：
- en: '[PRE161]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Then we need to create an *ImGui* window to hold our graph. *ImPlot* drawing
    can work only inside an *ImGui* window. All decorations and user interactions
    are disabled:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们需要创建一个*ImGui*窗口来容纳我们的图表。*ImPlot*绘制只能在*ImGui*窗口内部进行。所有装饰和用户交互都被禁用：
- en: '[PRE162]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'A new *ImPlot* plot can be started in a similar way. We disable decorations
    for the *ImPlot* axes and set up colors for the line drawing:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以以类似的方式启动一个新的*ImPlot*图表。我们禁用*ImPlot*轴的装饰，并设置线条绘制的颜色：
- en: '[PRE163]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'The `ImPlot::PlotLine()` function uses our collection of points’ `X` and `Y`
    values to render a graph:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ImPlot::PlotLine()`函数使用我们收集的点的`X`和`Y`值来渲染图表：'
- en: '[PRE164]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: This is the entire underlying implementation code.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 这是整个底层实现代码。
- en: Let’s now take a look at `Chapter04/06_DemoApp/src/main.cpp` to learn how 2D
    chart rendering works.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下`Chapter04/06_DemoApp/src/main.cpp`，学习2D图表渲染是如何工作的。
- en: How it works...
  id: totrans-487
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The app at `Chapter04/06_DemoApp` makes use of `LinearGraph` to render an FPS
    graph, and a simple sine graph for reference. Here is how it works:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chapter04/06_DemoApp`应用程序使用`LinearGraph`来渲染FPS图表，以及一个简单的正弦图作为参考。以下是它是如何工作的：'
- en: 'Both graphs are declared as global variables. They can render up to `2048`
    points:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个图表都声明为全局变量。它们可以渲染多达`2048`个点：
- en: '[PRE165]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Inside the main loop, we add points to both graphs like this:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主循环内部，我们像这样向两个图表添加点：
- en: '[PRE166]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Then we render both graphs as follows:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们按照以下方式渲染两个图表：
- en: '[PRE167]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: The resulting graphs look as shown in the following screenshot.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图表看起来如下截图所示。
- en: '![Figure 4.10: Frames-per-second and sine wave graphs](img/file28.jpg)'
  id: totrans-496
  prefs: []
  type: TYPE_IMG
  zh: '![图4.10：每秒帧数和正弦波图表](img/file28.jpg)'
- en: 'Figure 4.10: Frames-per-second and sine wave graphs'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10：每秒帧数和正弦波图表
- en: Putting it all together into a Vulkan application
  id: totrans-498
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将所有内容整合到一个Vulkan应用程序中
- en: In this recipe, we use all the material from previous recipes of this chapter
    to build a Vulkan demo application combining 3D scene rendering with 2D and 3D
    debug line drawing functionality.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用本章之前所有菜谱中的所有材料来构建一个结合3D场景渲染和2D及3D调试线绘制功能的Vulkan演示应用程序。
- en: Getting ready
  id: totrans-500
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is a consolidation of all the material in this chapter into a final
    demo app. It might be useful to revisit all the previous recipes to get to grips
    with the different user interaction and debugging techniques described in this
    chapter.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱是将本章中所有材料整合到一个最终演示应用程序中。回顾所有之前的菜谱可能会有助于掌握本章中描述的不同用户交互和调试技术。
- en: The full source code for this recipe can be found in `Chapter04/06_DemoApp`.
    The `VulkanApp` class used in this recipe is declared in `shared/VulkanApp.h`.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的完整源代码可以在`Chapter04/06_DemoApp`中找到。本菜谱中使用的`VulkanApp`类在`shared/VulkanApp.h`中声明。
- en: How to do it...
  id: totrans-503
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let’s skim through the source code to see how we can integrate the functionality
    from all the recipes together into a single application. We put all of the source
    code here so we can reference it in the subsequent chapters when necessary. All
    error checking is skipped again for the sake of brevity:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览源代码，看看我们如何将所有配方中的功能集成到一个单一的应用程序中。我们将所有源代码放在这里，以便在后续章节中必要时进行引用。为了简洁起见，再次跳过所有错误检查：
- en: 'The `shared/VulkanApp.h` header provides a wrapper for *LightweightVK* context
    creation and GLFW window lifetime management. Check the *Initializing the Vulkan
    instance and graphical device* and *Initializing Vulkan swapchain* recipes in
    *Chapter 2* for more details:'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`shared/VulkanApp.h`头文件提供了*LightweightVK*上下文创建和GLFW窗口生命周期管理的包装器。有关更多详细信息，请查看*第2章*中的*初始化Vulkan实例和图形设备*和*初始化Vulkan交换链*配方：'
- en: '[PRE168]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'Here we demonstrate a camera positioner for the *Adding camera animations and
    motion* recipe:'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们演示了一个用于*添加相机动画和运动*配方的相机定位器：
- en: '[PRE169]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'The following is for the FPS graph described in the previous *Rendering on-screen
    graphs with ImGui and ImPlot* recipe:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是为之前*使用ImGui和ImPlot在屏幕上渲染图形*配方中描述的FPS图表：
- en: '[PRE170]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'The `VulkanApp` class has a built-in first-person camera as described in the
    *Working with a 3D camera and basic user interaction* recipe. We provide an initial
    camera position and target, as well as reducing the FPS-averaging interval for
    the purpose of drawing a nice fast-moving graph:'
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`VulkanApp`类如*使用3D相机和基本用户交互*配方中所述内置了第一人称相机。我们提供了一个初始相机位置和目标，以及为了绘制漂亮的快速移动图形而减少FPS平均间隔：'
- en: '[PRE171]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Let’s create a local variable to make the access to `lvk::IContext` stored
    in `VulkanApp` more convenient. We call `ctx.release()` explicitly later:'
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个局部变量，以便更方便地访问存储在`VulkanApp`中的`lvk::IContext`。我们稍后显式调用`ctx.release()`：
- en: '[PRE172]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'All the shaders are loaded from files. The cube map rendering was described
    in the *Using cube map textures in Vulkan* recipe:'
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有着色器都是从文件中加载的。立方体贴图渲染已在*在Vulkan中使用立方体贴图纹理*配方中描述：
- en: '[PRE173]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'The rubber duck mesh rendering pipeline is created as follows:'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 橡皮鸭网格渲染管线创建如下：
- en: '[PRE174]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'The skybox rendering pipeline uses programmable-vertex pulling and has no vertex
    input state. See the *Using cube map textures in Vulkan* recipe for details:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 天空盒渲染管线使用可编程顶点提取，并且没有顶点输入状态。有关详细信息，请参阅*在Vulkan中使用立方体贴图纹理*配方：
- en: '[PRE175]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'Let’s load the rubber duck from a `.gltf` file and pack it into the `vertices`
    and `indices` arrays:'
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从`.gltf`文件中加载橡皮鸭并将其打包到`vertices`和`indices`数组中：
- en: '[PRE176]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Create two GPU buffers to hold `indices` and `vertices`:'
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个GPU缓冲区来存储`indices`和`vertices`：
- en: '[PRE177]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'A uniform buffer is used to hold per-frame data, such as model-view-projection
    matrices, the camera position, and bindless IDs for both textures:'
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用统一缓冲区来存储每帧数据，例如模型视图投影矩阵、相机位置以及两个纹理的无绑定ID：
- en: '[PRE178]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Now let’s bring in a 2D texture for the rubber duck model and a cube map texture
    for our skybox, as described in the *Using cube map textures in Vulkan* recipe:'
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们引入一个2D纹理用于橡皮鸭模型，以及一个立方体贴图纹理用于我们的天空盒，如*在Vulkan中使用立方体贴图纹理*配方中所述：
- en: '[PRE179]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'Run the main loop using a lambda provided by the `VulkanApp::run()` method.
    The camera positioner is updated as described in the *Adding camera animations
    and motion* recipe:'
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`VulkanApp::run()`方法提供的lambda表达式运行主循环。相机定位器如*添加相机动画和运动*配方中所述进行更新：
- en: '[PRE180]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'To recap the details on render passes and frame buffers, check the *Dealing
    with buffers in Vulkan* recipe in *Chapter 3*:'
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要回顾渲染通道和帧缓冲区的详细信息，请查看*第3章*中的*在Vulkan中处理缓冲区*配方：
- en: '[PRE181]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'We render the skybox as described in the *Using cube map textures in Vulkan*
    recipe. Note that 36 vertices are used to draw the skybox:'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们按照*在Vulkan中使用立方体贴图纹理*配方中的描述渲染天空盒。请注意，使用了36个顶点来绘制天空盒：
- en: '[PRE182]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'Rendering the rubber duck mesh is done as follows:'
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 橡皮鸭网格的渲染过程如下：
- en: '[PRE183]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'Rendering an ImGui window with a memo for keyboard hints is done as follows:'
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以备忘录形式渲染ImGui窗口以提供键盘提示的操作如下：
- en: '[PRE184]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'We render a frames-per-second counter as described in the *Adding a frames-per-second
    counter* recipe:'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们按照*添加帧率计数器*配方中的描述渲染帧率计数器：
- en: '[PRE185]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'Our on-screen graphs and a 2D drawing canvas are handled as shown in the *Rendering
    on-screen graphs with ImGui and ImPlot* recipe:'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们按照*使用ImGui和ImPlot在屏幕上渲染图形*配方中的描述处理屏幕上的图形和2D绘图画布：
- en: '[PRE186]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'The following code handles a 3D drawing canvas, as described in the *Implementing
    immediate mode 3D drawing canvas* recipe. To demonstrate the `frustum()` function,
    we render an ad hoc rotating frustum constructed via the `lootAt()` and `perspective()`
    GLM functions:'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码处理3D绘图画布，如*实现即时模式3D绘图画布*配方中所述。为了演示`frustum()`函数，我们通过`lookAt()`和`perspective()`GLM函数渲染了一个临时旋转的棱台：
- en: '[PRE187]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'Lastly, finalize the rendering, submit the command buffer to the GPU, and update
    the graphs:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，完成渲染，将命令缓冲区提交给GPU，并更新图表：
- en: '[PRE188]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'The following is a screenshot from the running application. The white graph
    displays the average FPS values and the rotating white frustum can be used to
    debug shadow mapping, as we will do in subsequent chapters:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从运行中的应用程序中截取的屏幕截图。白色图表显示平均FPS值，旋转的白色棱台可用于调试阴影映射，正如我们在后续章节中所做的那样：
- en: '![Figure 4.11: Demo application](img/file29.jpg)'
  id: totrans-548
  prefs: []
  type: TYPE_IMG
  zh: '![图4.11：演示应用程序](img/file29.jpg)'
- en: 'Figure 4.11: Demo application'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11：演示应用程序
- en: This chapter focused on combining multiple rendering aspects into one working
    Vulkan application. The graphical side still lacks some essential features, such
    as advanced lighting and materials, but we have almost everything in place to
    start rendering much more complex scenes. The next few chapters will cover more
    complicated mesh rendering techniques and physically-based lighting calculations
    based on the glTF2 format.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了将多个渲染方面结合到一个工作Vulkan应用程序中。图形方面仍缺少一些基本功能，例如高级光照和材质，但我们几乎已经准备好开始渲染更复杂的场景。接下来的几章将涵盖更复杂的网格渲染技术以及基于glTF2格式的基于物理的光照计算。
