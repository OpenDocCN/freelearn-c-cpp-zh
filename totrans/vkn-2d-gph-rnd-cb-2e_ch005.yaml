- en: 4 Adding User Interaction and Productivity Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Join our book community on Discord
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](img/file40.png)'
  prefs: []
  type: TYPE_IMG
- en: '[https://packt.link/unitydev](https://packt.link/unitydev)'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to implement basic helpers to drastically
    simplify the debugging of graphical applications. The demos are implemented in
    Vulkan using all the material from the previous three chapters. In *Chapter 3*,
    *Working with Vulkan Objects*, we demonstrated how to wrap various instances of
    raw Vulkan code to create and maintain basic Vulkan state and objects. In this
    chapter, we will show how to start implementing Vulkan rendering code in a way
    that is easily extensible and adaptable for different applications. Beginning
    with 2D user-interface rendering is the best way to learn this, as it makes things
    easier and allows us to focus on the rendering code without being overwhelmed
    by complex 3D graphics algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Rendering ImGui user interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Tracy into C++ applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a frames-per-second counter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using cube map textures in Vulkan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with a 3D camera and basic user interaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding camera animations and motion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing an immediate-mode 3D drawing canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering on-screen graphs with ImGui and ImPlot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting it all together into a Vulkan application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To run code from this chapter on your Linux or Windows PC, you will need a GPU
    with recent drivers that support Vulkan 1.3\. The source code used in this chapter
    can be downloaded from [https://github.com/PacktPublishing/3D-Graphics-Rendering-Cookbook](https://github.com/PacktPublishing/3D-Graphics-Rendering-Cookbook).
  prefs: []
  type: TYPE_NORMAL
- en: Rendering ImGui user interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ImGui is a popular bloat-free graphical user interface library for C++ and is
    essential to the interactive debugging of graphics apps. ImGui integration comes
    as a part of the *LightweightVK* library. In this recipe, we go step by step through
    the code and show how to create an example app with ImGui rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is recommended to revisit the *Using Vulkan descriptor indexing* recipe from
    *Chapter 3, Working with Vulkan Objects*, and also recall the Vulkan basics described
    in the other recipes of that chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe covers the source code of `lightweight/lvk/HelpersImGui.cpp`. The
    demo code for this recipe is in `Chapter04/01_ImGui`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us start with a minimalistic ImGui demo application and take a look at
    how to use the ImGui Vulkan wrapper provided by *LightweightVK*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create an `lvk::ImGuiRenderer` object. It takes in a pointer to our
    `lvk::IContext`, the name of the default font, and the default font size in pixels.
    `ImGuiRenderer` will take care of all the low-level ImGui initialization and code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us create some GLFW callbacks that pass mouse movements and button presses
    into ImGui. GLFW mouse button IDs should be converted into ImGui ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside our typical rendering loop, we can invoke ImGui rendering commands as
    follows. The `ImGuiRenderer::beginFrame()` method takes in an `lvk::Framebuffer`
    object so it can set up a rendering pipeline properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s draw an ImGui window with a texture. A texture index is passed into ImGui
    as an `ImTextureID` value so it can be used with the bindless rendering scheme
    we discussed in the previous chapter in the *Using Vulkan descriptor sets* recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ImGuiRenderer::endFrame()` method is a command buffer with actual Vulkan
    commands to render the user interface. Then we can call `cmdEndRendering()` and
    submit our command buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This demo application should render a simple ImGui interface like that shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: ImGui rendering](img/file19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: ImGui rendering'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s take a look at the underlying low-level implementation inside LightweightVK
    that renders ImGui data.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `lvk::ImGuiRenderer` helper class is declared in `lvk\HelpersImGui.h`. Here
    is its declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor accepts a reference to `lvk::IContext`, the name of the default
    `.ttf` font file, and the default font size in pixels. The `updateFont()`method
    can be invoked at a later point to override the previously used font. This method
    gets called from the constructor to set the default font:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `beginFrame()` and `endFrame()` methods are necessary to prepare ImGui
    for rendering and generate Vulkan commands from the ImGui draw data. The `setDisplayScale()`
    method can be used to override ImGui’s `DisplayFramebufferScale` factor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The private section of the `lvk::ImGuiRenderer` class contains a method to
    create a new rendering pipeline and a bunch of data necessary for rendering. There’s
    a single set of vertex and fragment shaders, a rendering pipeline, and a texture
    created from the `.ttf` font file we provided at construction time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure stall-free operation, *LightweightVK* uses multiple buffers to pass
    ImGui vertex and index data into Vulkan (`vb` and `ib` in the following code,
    for the vertex and index buffers respectively):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now we can dive into the implementation, which resides in `lvk/HelpersImGui.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: The vertex shader uses programmable-vertex pulling, which we briefly touched
    on in the previous chapter in the *Dealing with buffers in Vulkan* recipe. Let’s
    take a closer look at it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'ImGui provides 2D screen coordinates for each vertex, 2D texture coordinates,
    and an RGBA color. We declare a `Vertex` structure to hold per-vertex data and
    store all vertices inside the `vertices[]` array residing inside `VertexBuffer`.
    The `buffer_reference` GLSL layout qualifier declares a type and not an instance
    of a buffer, so that a reference to that buffer can be passed into the shader
    at a later point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'A reference to `VertexBuffer` containing our per-vertex data is passed via
    Vulkan push constants. Besides that, we pass a texture ID and some 2D viewport
    parameters represented as left, right, top, and bottom planes inside `vec4 LRTB`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the viewport parameters, we can construct an orthographic projection
    matrix the following way, which is similar to how `glm::ortho()` creates a projection
    matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The current vertex is extracted from the `VertexBuffer::vertices` array using
    the `gl_VertexIndex` built-in GLSL variable. The RGBA vertex color `v.rgba` is
    packed into a 32-bit unsigned integer and can be unpacked into `vec4` using the
    `unpackUnorm4x8()` GLSL built-in function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The texture coordinates and texture ID are passed into the fragment shader
    unchanged. The projection matrix is multiplied by the vertex position expanded
    into `vec4` by adding `0` as the `Z` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'A corresponding GLSL fragment shader is much simpler and looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The input locations should match the corresponding output locations from the
    vertex shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*LightweightVK* supports some basic sRGB framebuffer rendering. This shader
    constant is used to enable some rudimentary tone mapping. The texture ID is used
    to access a required bindless texture. The sampler is always a default sampler
    at index `0`. The `constant_id` GLSL modifier is used to specify specialization
    constants for Vulkan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we can render our UI in linear color space into an sRGB framebuffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s take a look at the C++ code in the `lvk::ImGuiRender` implementation.
    There’s a private `ImGuiRenderer::createNewPipelineState()` helper function there,
    which is responsible for creating a new rendering pipeline for ImGui rendering.
    As the entire relevant Vulkan state can be dynamic in Vulkan 1.3, a single immutable
    pipeline is sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'A framebuffer description is required to create a pipeline because we need
    information about color and depth attachment formats:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The sRGB mode is enabled based on the swapchain color space and passed into
    the shaders as Vulkan specialization constants:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'All ImGui elements require alpha blending to be enabled. If a depth buffer
    is present, it is retained unchanged but the rendering pipeline should know about
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Another helper function `ImGuiRenderer::updateFont()` is called from the constructor.
    Here’s how it is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, it sets up ImGui font configuration parameters using the provided font
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then it loads the default font from a `.ttf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Last but not least, the rasterized TrueType font data is retrieved from ImGui
    and stored as a *LightweightVK* texture. This font texture is used later for rendering
    via its index ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: All the preparations are completed and we can now look at the constructor and
    destructor of `ImGuiRenderer`. Both member functions are very short.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor initializes both ImGui and ImPlot contexts in case *LightweightVK*
    was compiled with optional ImPlot support. At the moment, *LightweightVK* supports
    only a single ImGui context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we set the `ImGuiBackendFlags_RendererHasVtxOffset` flag telling ImGui
    that our renderer has support for vertex offsets. It enables the output of large
    meshes while still using 16-bit indices, making UI rendering more efficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'All the work to create the default font and shaders is delegated as we have
    just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The destructor is trivial and cleans up both ImGui and the optional ImPlot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s one more simple function that we want to see before going on to the
    rendering: `ImGuiRenderer::beginFrame()`. It starts a new ImGui frame using the
    provided framebuffer. A graphics pipeline is lazily created here based on the
    actual framebuffer parameters because we did not have any framebuffer provided
    to us in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now we are ready to tackle the UI rendering in the `ImGuiRenderer::endFrame()`
    function. This function runs every frame and populates a Vulkan command buffer.
    It is a bit more complicated, so let’s go over it step by step to see how it works.
    Error checking is omitted in the following code snippets for the sake of brevity.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we should finalize ImGui frame rendering and retrieve the frame draw
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s prepare the render state. We disable the depth test and depth buffer
    writes. A viewport is constructed based on the ImGui framebuffer size, which we
    set up earlier in `beginFrame()` to be equal to our *LightweightVK* framebuffer
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameters of the orthographic projection matrix are prepared here. They
    will be passed to shaders later via Vulkan push constants inside the rendering
    loop together with other parameters. Clipping parameters are prepared here as
    well to be used inside the rendering loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a set of separate LVK buffers per each frame. These buffers store ImGui
    vertex and index data for the entire frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are buffers already existing from the previous frames and these buffers’
    sizes are insufficient to fit in the new vertex or index data, the buffers are
    re-created with the new size. The index buffer is created via `BufferUsageBits_Index`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The buffer to store vertices is actually a `BufferUsageBits_Storage` storage
    buffer, because our GLSL shaders use programmable-vertex pulling to load the vertices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s upload some data to the vertex and index buffers. The entire ImGui frame
    data is uploaded here. Offsets are carefully preserved so we know where every
    ImGui draw command data is stored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The host-visible memory needs to be flushed. This will allow *LightweightVK*
    to issue a corresponding Vulkan `vkFlushMappedMemoryRanges()` command if the memory
    is not host-coherent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s bind our index buffer and the rendering pipeline to a command buffer,
    and enter the rendering loop that iterates over all ImGui rendering commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Viewport clipping is done right here on the CPU side. If the ImGui draw command
    is completely clipped, we should skip it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'All the data necessary for rendering is passed into GLSL shaders via Vulkan
    push constants. It consists of the orthographic projection data, which is the
    left, right, top, and bottom planes, a reference to the vertex buffer, and a texture
    ID for bindless rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Set up the scissor test so it can do precise clipping of ImGui elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual rendering is done via `cmdDrawIndexed()`. Here we use both the index
    offset and vertex offset parameters to access the correct data in our large per-frame
    vertex and index buffers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now we have done all the ImGui rendering and can render the entire ImGui user
    interface using Vulkan. Let’s jump to the next recipes and learn other productivity
    and debugging tools, such as profiling, 3D camera controls, frames-per-second
    counters, and a drawing canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Tracy into C++ applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, *Working with Vulkan Objects*, we learned how to write
    small graphics applications with Vulkan and LightweightVK. In real-world applications,
    it is often necessary to be able to quickly get performance profiling information
    at runtime. In this recipe, we will show how to make use of the Tracy profiler
    in your 3D applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The complete source code of the demo application for this recipe is located
    in `Chapter04/02_TracyProfiler`.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to download a precompiled Tracy client app for your platform from
    [https://github.com/wolfpld/tracy](https://github.com/wolfpld/tracy). In our book,
    we use Tracy version 0.10 that can be downloaded from [https://github.com/wolfpld/tracy/releases/tag/v0.10](https://github.com/wolfpld/tracy/releases/tag/v0.10).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Tracy profiler itself is integrated into the *LightweightVK* library. Our
    demo application, as well as many parts of the *LightweightVK* rendering code,
    is augmented with calls to profiling functions. Those calls are wrapped into a
    set of macros so as not to call Tracy directly. This allows turning the profiler
    on and off, and even switching to other profilers when necessary. Let’s take a
    look at the demo application and then explore the underlying low-level implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s take a look at the root LightweightVK CMake configuration file
    `deps/src/lightweightvk/CMakeLists.txt` to see how the Tracy library is added
    to the project. At the beginning, we should see an option enabled by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'A few lines later in the same file, the CMake option is converted into a `TRACY_ENABLE`
    C++ compiler macro definition and the Tracy library is added to the project. Note
    that this is the `third-party/deps/src/` folder of the *LightweightVK* Git repository,
    which itself resides inside the `deps/src/` folder of the book repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s continue scrolling the same file, `deps/src/lightweightvk/CMakeLitsts.txt`,
    for a few pages further. Based on the previously enabled `LVK_WITH_TRACY` CMake
    option, we export the `LVK_WITH_TRACY` C++ macro definition to all users of *LightweightVK*.
    The Tracy library is linked with the `LVKLibrary` target so that every app using
    *LightweightVK* has access to Tracy functions as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s look into `lightweightvk/lvk/LVK.h` and check out some macro definitions.
    The `LVK_WITH_TRACY` macro is used to enable or disable Tracy usage. Some predefined
    RGB colors are declared as macros to be used to mark important point-of-interest
    operations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Other macros are mapped directly to Tracy functions so that we can work with
    Tracy zones in a non-intrusive way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LVK_PROFILER_THREAD` macro can be used to set the name of a C++ thread.
    The `LVK_PROFILER_FRAME` macro is used to mark the start of the next frame during
    rendering. It is used by *LightweightVK* in `lvk::VulkanSwapchain::present()`
    and can be helpful if you want to implement your own swapchain management code,
    for example, on Android using OpenXR:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Once Tracy is disabled, all macros are defined to no-ops and zones are defined
    as empty C++ scopes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Macros `LVK_PROFILER_FUNCTION` and `LVK_PROFILER_FUNCTION_COLOR` are spread
    all over the *LightweightVK* code to give good profiling coverage. Let’s take
    a look at how to use them in our own apps.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The demo application is located in `Chapter04/02_TracyProfiler/src.main.cpp`.
    Tracy is initialized automatically together with *LightweightVK*. All we have
    to do now is put corresponding macros in our code. Let’s take a look at how it
    works.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our initialization part where we create `lvk::IContext`, we use `LVK_PROFILER_ZONE`
    and `LVK_PROFILER_ZONE_END` to mark an interesting fragment of our initialization
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the rendering loop, we can mark different point-of-interest code blocks
    the same way. The hex value is an RGB color that will be used by Tracy in the
    profiling window to highlight this profiling zone. Some predefined colors were
    mentioned earlier in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to mark the entire function and want to have an automatic name assigned
    to it, we should use the `LVK_PROFILER_FUNCTION` macro as in the following snippet.
    This macro does not require closing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Let’s take a look at the profiler output while running this demo app. To retrieve
    the profiling data, you have to run a Tracy client and connect it to your graphics
    app. We use Tracy version 0.10, which can be downloaded from GitHub at [https://github.com/wolfpld/tracy/releases/tag/v0.10](https://github.com/wolfpld/tracy/releases/tag/v0.10).
    Here is a screenshot from a connected Tracy client showing a flame graph of our
    app.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2: Tracy user interface](img/file20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: Tracy user interface'
  prefs: []
  type: TYPE_NORMAL
- en: This approach allows for fully transparent enabling and disabling of the Tracy
    profiler at build time. Adding other profilers, such as EasyProfiler and Optick,
    which provide similar APIs, is mostly trivial and can be easily implemented yourself
    as an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Before returning to Vulkan rendering, let’s explore yet another small but useful
    profiling trick and learn how to implement a simple yet good frames-per-second
    counter.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a frames-per-second counter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **frames-per-second** (**FPS**) counter is the cornerstone of all graphical
    applications profiling and performance measurements. In this recipe, we will learn
    how to implement a simple FPS counter class and use it to roughly measure the
    performance of our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code for this recipe can be found in `Chapter04/03_FPS`. The `FramesPerSecondCounter`
    class is located in `shared/UtilsFPS.h`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s implement the `FramesPerSecondCounter` class containing all the machinery
    required to calculate the average FPS for a given time interval:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need some member fields to store the duration of a sliding window,
    the number of frames rendered in the current interval, and the accumulated time
    of this interval. The `printFPS_ Boolean` field can be used to enable or disable
    FPS printing to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'A single explicit constructor can override the averaging interval’s default
    duration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tick()` method should be called from the main loop. It accepts the time
    duration elapsed since the previous call and a Boolean flag, which should be set
    to `true` if a new frame has been rendered during this iteration. This flag is
    a convenience feature to handle situations where frame rendering can be skipped
    in the main loop for various reasons, such as simulation pausing. The time accumulates
    until it reaches the value of `avgInterval_`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Once enough time has accumulated, we can do averaging, update the current FPS
    value, and print debug info to the console. We should reset the number of frames
    and accumulated time at this point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s add a helper method to retrieve the current FPS value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s take a look at how to use this class in our main loop. Let’s augment
    the main loop of our demo applications to display an FPS counter in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let us define a `FramesPerSecondCounter` object and a couple of variables
    to store the current timestamp and the delta since the last rendered frame. We
    have chosen to use an ad hoc 0.5-second averaging interval; feel free to experiment
    with different values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the main loop, update the current timestamp and calculate the frame
    duration by finding a delta between two consecutive timestamps. Then, pass this
    calculated delta to the `tick()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output of the running application should look similar to the following.
    Vertical sync is turned off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The application window should look like that shown in the following screenshot,
    with an FPS counter rendered in the top-right corner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3: ImGui and ImPlot user interfaces with an FPS counter](img/file21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: ImGui and ImPlot user interfaces with an FPS counter'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s check the source code to learn how to add this ImGui FPS widget to your
    app. Here’s a fragment that fills in a command buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We set up the framebuffer parameters and start rendering. ImGui rendering is
    started with `imgui->beginFrame()` as we learned in the *Rendering ImGui user
    interface* recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the current viewport parameters from ImGui and set the position of the
    next ImGui window to be aligned close to the top-right corner of the viewport
    work area. Sizes are hardcoded to be in the app window’s pixels. The `ImGuiCond_Always`
    flag tells ImGui to set this position every frame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the next window to be transparent. We use `SetNextWindowSize()` to assign
    a fixed size value to the window. The width is calculated using `CalcTextSize()`.
    Note how that `“FPS : _______”` placeholder string is used here as a parameter
    to make sure the width of the window does not fluctuate based on the number of
    digits in the numeric FPS value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'An ImGui window that contains the FPS counter is rendered using various ImGui
    flags so that all unnecessary window decorations are disabled and no user interaction
    can happen with the window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have rendered the FPS window, let’s draw ImPlot and ImGui demo windows
    so you can explore them. The ImPlot library will be covered a bit more in subsequent
    recipes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Now you know how to display a window in your apps that includes a nice FPS counter.
    Although this feature is straightforward, it can be tiresome to repeatedly include
    this code in every app. In the upcoming recipes, we will introduce a `VulkanApp`
    helper class that will handle various utility functions like this. But for now,
    let’s go back to rendering and explore how to work with cube map textures.
  prefs: []
  type: TYPE_NORMAL
- en: There is more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `frameRendered` parameter in `float tick(float deltaSeconds, bool frameRendered
    = true)` will be used in subsequent recipes to allow Vulkan applications to skip
    frames when a swapchain image is not available.
  prefs: []
  type: TYPE_NORMAL
- en: Using cube map textures in Vulkan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A cube map is a texture that contains 6 individual 2D textures that together
    form 6 sides of a cube. A useful property of cube maps is that they can be sampled
    using a direction vector. This comes in handy when representing light coming into
    a scene from different directions. For example, we can store the diffuse part
    of the physically based lighting equation in an irradiance cube map, which we
    will touch on in *Chapter 6*.
  prefs: []
  type: TYPE_NORMAL
- en: Loading 6 faces of a cube map into *LightweightVK* is a fairly straightforward
    operation. However, instead of just 6 faces, cube maps are often stored as **equirectangular
    projections** or as vertical or horizontal crosses. The equirectangular projection
    is such a projection that maps longitude and latitude (vertical and horizontal
    lines) to straight, even lines, making it a very easy and popular way to store
    light probe images, as shown in *Figure 4.4* later in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to convert this cube map representation into
    6 faces and render them with Vulkan.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many websites that offer high-dynamic range environment textures under
    various licenses. Check out [https://polyhaven.com](https://polyhaven.com) and
    [https://hdrmaps.com](https://hdrmaps.com) for useful content.
  prefs: []
  type: TYPE_NORMAL
- en: The complete source code for this recipe can be found in the source code bundle
    under the name `Chapter04/04_CubeMap`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start working with cube maps, let us introduce a simple `Bitmap`
    helper class to work with bitmap images in 8-bit and 32-bit floating point formats.
    You can find it in `shared/Bitmap.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us declare the interface part of the `Bitmap` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s set the width, height, depth, and number of components per pixel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The type of a single component can be either unsigned byte or float. The type
    of this bitmap can be a 2D texture or a cube map. We store the actual pixel data
    of this bitmap in an `std::vector` container for simplicity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we need a helper function to get the number of bytes necessary to store
    one component of a specified format. This also requires a getter and setter for
    a two-dimensional image. We will come back to this later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The implementation is also located in `shared/Bitmap.h`. Now let us use this
    class to build more high-level cube map conversion functions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have a cube map at `data/piazza_bologni_1k.hdr`, which is available under
    the CC0 license and was originally downloaded from [https://hdrihaven.com/hdri/?h=piazza_bologni](https://hdrihaven.com/hdri/?h=piazza_bologni).
    The environment map image comes in an equirectangular projection and looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: Equirectangular projection](img/file22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Equirectangular projection'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us convert it into a vertical cross. In the vertical cross format, each
    cube map face is represented as a square inside the entire image, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5: Vertical cross](img/file23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: Vertical cross'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use a naive way to convert an equirectangular projection to cube map
    faces by iterating over its pixels, calculating the Cartesian coordinates for
    each pixel, and saving the pixel into a cube map face using the Cartesian coordinates,
    we will end up with a texture heavily damaged by a Moiré pattern caused by the
    insufficient sampling of the resulting cube map. A better way is to do it the
    other way round. That means iterating over each pixel of the resulting cube map
    faces, calculating source floating-point equirectangular coordinates corresponding
    to each pixel, and sampling the equirectangular texture using bilinear interpolation.
    This way the final cube map will be free of artifacts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to introduce a helper function that maps integer coordinates
    inside a specified cube map face into floating-point normalized coordinates. This
    helper is handy because all faces in the vertical cross cube map have different
    vertical orientations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The conversion function starts as follows and calculates the face size, width,
    and height of the resulting bitmap. It is located in `shared/UtilsCubemap.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'These points define the locations of individual faces inside the cross:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Two constants will be necessary to clamp the texture lookup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can start iterating over the 6 cube map faces and each pixel inside
    each face:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: We use trigonometry functions to calculate the latitude and longitude coordinates
    from the Cartesian cube map coordinates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'To learn more about spherical coordinate systems, please follow this link:
    [https://en.wikipedia.org/wiki/Spherical_coordinate_system](https://en.wikipedia.org/wiki/Spherical_coordinate_system).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we can map the latitude and longitude into floating-point coordinates inside
    the equirectangular image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on these floating-point coordinates, we get two pairs of integer UV coordinates,
    which we will use to sample 4 texels for bilinear interpolation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the fractional part for the bilinear interpolation and fetch 4 samples,
    `A`, `B`, `C`, and `D`, from the equirectangular map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Do the bilinear interpolation and set the resulting pixel value in the vertical-cross
    cube map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The `Bitmap` class takes care of the pixel format inside the image data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can write code to cut the vertical cross into tightly packed rectangular
    cube map faces. Here is how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: First, let us review the layout of the vertical cross image corresponding to
    the Vulkan cube map faces layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.6: Layout of the vertical cross image](img/file24.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 4.6: Layout of the vertical cross image'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The layout is `3` by `4` faces, which makes it possible to calculate the dimensions
    of the resulting cube map as follows. The code is from `shared/UtilsCubemap.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us set up pointers to read data from and write data to. This function is
    pixel format-agnostic so it needs to know the size of each pixel in bytes to be
    able to move pixels around with `memcpy()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterate over the faces and over every pixel of each face. The order of cube
    map faces here corresponds to the order of Vulkan cube map faces as described
    in *Vulkan specification 16.5.4\. Cube Map Face Selection*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Calculate the source pixel position in the vertical cross layout based on the
    destination cube map face index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the pixel and advance to the next one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting cube map contains an array of 6 2D images. Let us write some
    more C++ code to load and convert the actual texture data and upload it into *LightweightVK*.
    The source code is located in `Chapter04/04_CubeMap/src/main.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `STB_image` floating point API to load a high dynamic range image from
    an `.hdr` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert an equirectangular map to a vertical cross and save the resulting image
    to an `.hdr` file for further inspection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert the loaded vertical cross image to the actual cube map faces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, uploading texture data to LightweightVK is straightforward. We call the
    `IContext::createTexture()` member function to create a texture and provide a
    pointer to the cube map data returned by `cubemap.data_.data()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we should take a look at how to write the GLSL shaders for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us make a vertex shader `Chapter04/04_CubeMap/src/main.vert` that will
    take a model, view, and projection matrices as its inputs. We also need a camera
    position and bindless texture IDs for a mesh texture and for our cube map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'A buffer reference to `PerFrameData` is passed into the shader using Vulkan
    **push constants** (`pc` in the following code):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The per-vertex attributes are provided to the vertex shader. The `PerVertex`
    structure is used to pass parameters to a fragment shader. Normal vectors are
    transformed with a matrix calculated as the inverse-transpose of the model matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s take a look at the fragment shader found at `Chapter04/04_CubeMap/src/main.frag`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It shares the declaration of the `PerVertex` structure with the vertex shader
    mentioned above. The declaration is located in the file `Chapter04/04_CubeMap/src/common.sp`.
    We skip it here for the sake of brevity. The fragment shader uses the `textureBindlessCube()`
    helper function to sample the cube map using the calculated reflection vector.
    This function was discussed in detail in the *Using texture data in Vulkan* recipe
    in *Chapter 3, Working with Vulkan Objects*. The reflected direction vector is
    calculated using the `reflect()` GLSL built-in function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'To add a more developed visual appearance, we add some diffuse lighting to
    our 3D model using a hardcoded light direction of `(0, 0.1, -1)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The resulting output from the application looks as follows. Note the blown-out
    white areas of the sky in the reflection due to how a high dynamic range image
    is displayed directly onto a low dynamic range framebuffer. We will come back
    to this issue in *Chapter 10, Image-Based Techniques*, and implement a simple
    HDR tone-mapping operator.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7: Reflective rubber duck](img/file25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: Reflective rubber duck'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s get back to improving the user interaction capabilities and learn
    how to implement a simple camera class to move around and debug our 3D scenes.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In OpenGL, developers had to enable a special cube map sampling mode to ensure
    seamless filtering across all cube map faces. In Vulkan, all cube map texture
    fetches are seamless (as described under *Cube Map Edge Handling* in the Vulkan
    specification), except the ones with `VK_FILTER_NEAREST`, which are clamped to
    the face edge.
  prefs: []
  type: TYPE_NORMAL
- en: Working with a 3D camera and basic user interaction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To debug a graphical application, it is very helpful to be able to navigate
    and move around within a 3D scene using a keyboard or mouse. Graphics APIs themselves
    are not familiar with concepts of cameras and user interaction, so we have to
    implement a camera model that will convert user input into a view matrix usable
    by Vulkan. In this recipe, we will learn how to create a simple yet extensible
    3D camera implementation and use it to enhance the functionality of our Vulkan
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code for this recipe can be found in `Chapter04/05_Camera`. The camera
    classes are declared and implemented in the file `shared/Camera.h`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our camera implementation will calculate a view matrix and a 3D position point
    based on the selected dynamic model. Let’s look at the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let us implement the `Camera` class, which will represent our main API
    to work with a 3D camera. The class stores a reference to an instance of the `CameraPositionerInterface`
    class, being a polymorphic implementation of the underlying camera model to allow
    runtime switches of camera behaviors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The interface of `CameraPositionerInterface` contains only pure virtual methods
    and a default virtual destructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can implement the actual camera model. We will start with a quaternion-based
    first-person camera that can be freely moved in space in any direction. Let us
    look at the `CameraPositioner_FirstPerson` class. The inner `Movement` structure
    contains Boolean flags that define the current motion state of our camera. This
    is useful to decouple keyboard and mouse inputs from the camera control logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Various numeric parameters define how responsive the camera will be to acceleration
    and damping. These parameters can be tweaked as you see fit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'We need certain private data members to control the camera state, such as the
    previous mouse position, the current camera position and orientation, the current
    movement speed, and the vector representing the “up” direction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The non-default constructor takes the camera’s initial position, a target position,
    and a vector pointing upwards. This input is similar to what one might normally
    use to construct a look-at viewing matrix. Indeed, we use the `glm::lookAt()`
    function to initialize the camera:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can add some dynamics to our camera model. The `update()` method should
    be called every frame and take the time elapsed since the previous frame, as well
    as the mouse position and a mouse-button-pressed flag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Now, when the mouse button is pressed, we calculate a delta vector versus the
    previous mouse position, and use it to construct a rotation quaternion. This quaternion
    is used to rotate the camera. Once the camera rotation is applied, we should update
    the mouse position state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we should establish the camera’s coordinate system to calculate the camera
    movement. Let us extract the forward, right, and up vectors from the `mat4` view
    matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: The `forward` vector corresponds to the camera’s direction, which is the direction
    the camera is pointing at. The `right` vector corresponds to the positive X-axis
    of the camera space. The `up` vector is the positive Y-axis of the camera space,
    which is perpendicular to the first two vectors and can be calculated as their
    cross product.
  prefs: []
  type: TYPE_NORMAL
- en: 'The camera coordinate system has been established. Now we can apply our input
    state from the `Movement` structure to control the movement of our camera:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Instead of controlling the camera speed or position directly, we let the user
    input control only the acceleration vector directly. This way, the camera’s behavior
    is much smoother, more natural, and non-jerky.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, based on the input state, the calculated camera acceleration is zero, we
    should decelerate the camera’s motion gradually, according to the `damping_` parameter.
    Otherwise, we should integrate the camera motion using simple Euler integration.
    The maximum possible speed value is clamped according to the `maxSpeed_` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The view matrix can be calculated from the camera orientation quaternion and
    camera position in the following way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: The translational part is inferred from the `cameraPosition_` vector and the
    rotational part is calculated directly from the orientation quaternion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Helpful getters and setters are trivial, except for the `setUpVector()` method,
    which has to recalculate the camera orientation using the existing camera position
    and direction as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'One additional helper function is necessary to reset the previous mouse position
    to prevent jerky rotation movements when, for example, the mouse cursor leaves
    the window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The above class can be used in 3D applications to move the viewer around. Let
    us see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The demo application is based on the cube map example from the previous *Using
    cube map textures in Vulkan* recipe. The updated code is located at `Chapter04/05_Camera/src/main.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We add a mouse state and define `CameraPositioner` and `Camera`. Let them be
    global variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'The GLFW cursor position callback should update `mouseState` the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Here, we convert window pixel coordinates into normalized `0...1` coordinates
    and accommodate the inverted Y-axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GLFW mouse button callback passes GLFW mouse events to ImGui and sets the
    `pressedLeft` flag when the left mouse button is pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'To handle keyboard input for camera movement, let us write the following GLFW
    keyboard callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: The *WSAD* keys are used to move the camera around and the *Spacebar* is used
    to reorient the camera up vector to the world `(0, 1, 0)` vector and reset the
    position camera back to the initial position. The Shift key is used to move the
    camera faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can update the camera positioner from the main loop using the following
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a code fragment to upload matrices into a Vulkan per-frame uniform buffer,
    similar to how it was done with fixed values in the previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the demo from `Chapter04/05_Camera` to play around with the keyboard and
    mouse:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8: Camera](img/file26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: Camera'
  prefs: []
  type: TYPE_NORMAL
- en: There is more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This camera design approach can be extended to accommodate different motion
    behaviors. In the next recipe, we will learn how to implement some other useful
    camera positioners.
  prefs: []
  type: TYPE_NORMAL
- en: The 3D camera functionality introduced in this recipe is incredibly valuable
    for our book. To reduce code duplication, we’ve created a helper class called
    `VulkanApp`. This class wraps the first-person camera positioner along with other
    features such as the frames-per-second counter, `ImGuiRenderer`, and some others.
    The `VulkanApp` class will be utilized in all the subsequent recipes throughout
    this book. You can find it in the `shared/VulkanApp.h` and `shared/VulkanApp.cpp`
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Adding camera animations and motion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides having a user-controlled first-person camera, it is convenient to be
    able to position and move the camera programmatically inside a 3D scene – this
    is helpful for debugging when we need to organize automatic screenshot tests with
    camera movement, for example. In this recipe, we will show how to do it and extend
    our minimalistic 3D camera framework from the previous recipe. We will draw a
    combo box using ImGui to select between two camera modes: a first-person free
    camera, and a fixed camera moving to a user-specified point settable from the
    UI.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The full source code for this recipe is a part of the final demo application
    for this chapter, and you can find it in `Chapter04/06_DemoApp`. Implementations
    of all new camera-related functionality are located in the `shared/Camera.h` file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s look at how to programmatically control our 3D camera using a simple
    ImGui-based user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to add a new `CameraPosition_MoveTo` camera positioner that
    automatically moves the camera to a specified `vec3` point. For this purpose,
    we have to declare a bunch of global constants and variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the main loop, we should update our new camera positioner. The first-person
    camera positioner is updated automatically inside the `VulkanApp` class mentioned
    in the previous recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s draw an ImGui combo box to select which camera positioner should
    be used to control the camera motion:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, a few more global variables will come in handy to store the current
    camera type, items of the combo box UI, and the new value selected in the combo
    box:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'To render the camera control UI with a combo box, let’s write the following
    code. A new ImGui window starts with a call to `ImGui::Begin()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'The combo box itself is rendered via `ImGui::BeginCombo()`. The second parameter
    is the previewed label name to show before opening the combo box. This function
    will return true if the user has clicked on a label:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'You may set the initial focus when opening the combo box. This is useful if
    you want to support scrolling or keyboard navigation inside the combo box:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Finalize the ImGui combo box rendering:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `MoveTo` camera type is selected, render `vec3` input sliders to get
    the camera position and Euler angles from the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'If a new selected combo box item is different from the current camera type,
    print a debug message and change the active camera mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting combo box should look as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9: Camera controls](img/file27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.9: Camera controls'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code is called from the main loop on every frame to draw ImGui.
    Check out the `Chapter04/06_DemoApp/src/main.cpp` file for the complete source
    code.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s take a look at the implementation of the `CameraPositioner_MoveTo` class
    in `shared/Camera.h` we mentioned earlier in *steps 1* and *2*. In contrast to
    the first-person camera positioner introduced in the previous recipe, which relies
    on quaternions, this new positioner employs a straightforward Euler angles approach
    to store the camera orientation. This method is more user-friendly and intuitive
    for controlling the camera. The following are the steps to help us understand
    how this camera positioner works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we want to have some user-configurable parameters for linear and angular
    damping coefficients:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'We store the current and desired positions of the camera as well as two sets
    of pitch, pan, and roll Euler angles in `vec3` member fields. The current camera
    transformation is updated every frame and saved in a `mat4` field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor initializes both the current and desired data sets of the camera:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'The most interesting part happens in the `update()` function. The current camera
    position is changed to move towards the desired camera position. The movement
    speed is proportional to the distance between these two positions and scaled using
    the linear damping coefficient:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s deal with Euler angles. We should clip them accordingly to make
    sure they remain within the `0…360` degrees range. This is required to prevent
    our camera from “spinning” around the object `2*Pi` times:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to how we dealt with the camera position, the Euler angles are updated
    based on the distance between the desired and current set of angles. Before calculating
    the camera transformation matrix, clip the updated angles again and convert the
    values from degrees to radians. Note how the pitch, pan, and roll angles are swizzled
    before they are forwarded into `glm::yawPitchRoll()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'The functions for the angle clipping are straightforward and look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'The delta between two sets of angles can be calculated in the following way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Try running the demo application, `Chapter04/06_DemoApp`. Switch to the `MoveTo`
    camera and change the position and orientation from the ImGui user interface.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Further camera functionality can be built on top of this example implementation.
    One more useful extension might be a camera that follows a spline curve defined
    using a set of key points for positions and targets. We will leave this as an
    exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an immediate-mode 3D drawing canvas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Setting up Vulkan debugging capabilities* recipe from *Chapter 2, Getting
    Started with Vulkan*, only scratched the surface of graphical application debugging.
    The validation layers provided by the Vulkan API are invaluable but they do not
    allow you to debug logical and calculation-related errors. To see what is happening
    in our virtual world, we need to be able to render auxiliary graphical information
    such as objects’ bounding boxes and plot time-varying charts of different values
    or plain straight lines. The Vulkan API does not provide any immediate-mode rendering
    facilities. All it can do is add commands to command buffers scheduled for later
    submission. To overcome this difficulty and add an immediate-mode rendering canvas
    to our applications, we have to write some additional code. Let’s learn how to
    do it in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure you are proficient with all the rendering recipes from *Chapter 3,
    Working with Vulkan Objects*. Check the `shared/LineCanvas.h` and `shared/LineCanvas.cpp`
    files for a working implementation of this recipe. An example of how to use a
    new `LineCanvas3D` 3D line drawing class is a part of the demo app at `Chapter04/06_DemoApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `LineCanvas3D` class contains a CPU-accessible list of 3D lines defined
    by two points and a color. Each frame, the user can call the `line()` method to
    draw a new 3D line that should be rendered in the current frame. To render these
    lines into the framebuffer, we maintain a collection of Vulkan buffers to store
    line geometry data, which we will update every frame. Let’s take a look at the
    interface of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `LineCanvas3D` class has its internal 3D line representation as a pair
    of vertices for each and every line, whereas each vertex consists of a `vec4`
    position and a color. Each `linesBuffer` buffer holds a GPU-visible copy of the
    `lines_` container. We have one buffer for each swapchain image to avoid any additional
    Vulkan synchronization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual drawing functionality consists of a set of functions. We want to
    be able to clear the canvas, render one line, and render some useful primitives,
    such as 3D planes, boxes, and frustums. Further utility functions can easily be
    built on top of the functionality provided by the `line()` member function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'The longest method of this class is `render()`, which generates Vulkan commands
    into the provided command buffer to render the current contents of `LineCanvas3D`.
    We will look into its implementation in a few moments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us deal with the non-Vulkan part of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `line()` member function itself just adds two colored `vec3` points to
    the container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'The `plane()` method uses `line()` internally to create a visual representation
    of a three-dimensional plane spanned by the `v1` and `v2` vectors with half-sizes
    `s1` and `s2`, and an origin point `o`. The `n1` and `n2` parameters specify how
    many lines we want to render along each coordinate direction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'Draw the 4 outer lines representing a plane segment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Draw `n1` horizontal lines and `n2` vertical lines inside the plane:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'The `box()` member function draws a colored box oriented using the provided
    `m` model matrix and half-size `size` along the `X`, `Y`, and `Z` axes. The idea
    is to create 8 corner points of the box and transform them using the `m` matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Then render all 12 edges of the box using the `line()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s yet another overload of the `box()` function, which takes in the `BoundingBox`
    class declared in `shared/UtilsMath.h`. It is just a trivial wrapper over the
    previous variant of this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'The most interesting drawing function is `frustum()`, which renders a 3D frustum
    represented by a `camProj` view matrix positioned in the world using the `camView`
    matrix. Long story short, if you have a 3D camera somewhere in your world and
    its view and projection matrix are `camView` and `camProj` respectively, you can
    use this function to visualize that camera’s viewing frustum:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This code is invaluable in debugging things such as shadow maps or culling frustums.
    We will put it to heavy use in the final chapters of this book.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'The idea is somewhat similar to the `box()` function mentioned above. We create
    a set of corner points on a cube corresponding to 8 corners of the camera frustum
    (points are referred to as `pp` in the following code). Then, we transform each
    of these points with the inverse of the provided view-projection matrix, essentially
    warping a box into a frustum shape. Then we use `line()` to connect the dots:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'These are four lines representing the side edges of the camera frustum:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'With the side edges done, we need to draw the near plane. The extra two lines
    are used to draw a cross inside the near plane:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we do the far plane. Here again, the extra two lines are used to draw
    a cross to give better visual cues:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s draw the sides of the frustum to give a nice perception of volume.
    We use a dimmed color and `100` lines on each side:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the bottom and the top sides:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'The same should be done with the left and right sides of our frustum:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: That covers the user-facing part of our line-drawing API. Let’s take a look
    at the actual rendering code to learn how it works in an app.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the rendering and graphics pipeline creation is done within a single `render()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function accepts a *LightweightVK* context, a framebuffer, and a command
    buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'The required GPU buffer size is calculated based on the current number of lines.
    If the current buffer capacity is not sufficient, the buffer is reallocated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'If there’s no rendering pipeline available, we should create a new one. We
    use `lvk::Topology_Line`, which matches `VK_PRIMITIVE_TOPOLOGY_LINE_LIST`. Simple
    alpha blending is used to render all the lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'Our line-drawing vertex shader accepts the current combined model-view-projection
    matrix `mvp` and a GPU reference to the buffer containing the line data. Everything
    is updated using Vulkan push constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the Vulkan rendering state is prepared, we can render the lines and switch
    to the next frame to use one of the available buffers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: It is also worth taking a quick look at the line-drawing GLSL shaders.
  prefs: []
  type: TYPE_NORMAL
- en: 'The vertex shader is as follows. Programmable-vertex pulling is used to extract
    line data from the provided buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'The fragment shader is trivial and simply outputs the provided color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: That is everything regarding drawing 3D lines. For a comprehensive example showing
    how to use this 3D drawing canvas, check the final *Putting it all together into
    a Vulkan application* recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The next recipe will conclude Vulkan auxiliary rendering by showing how to render
    2D lines and charts with the help of the ImGui and ImPlot libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering on-screen graphs with ImGui and ImPlot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous recipe, we learned how to create immediate mode drawing facilities
    in Vulkan with basic drawing functionality. That 3D canvas was rendered on top
    of a 3D scene sharing a view-projection matrix with it. In this recipe, we will
    continue adding useful debugging features to our framework and learn how to implement
    pure 2D line drawing functionality. It is possible to implement such a class in
    a way similar to `LineCanvas3D`. However, we already use the ImGui library in
    our apps as described in the *Rendering ImGui user interface* recipe. Let’s put
    it to use to render our 2D lines.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We recommend revisiting the *Rendering ImGui user interfaces* and *Implementing
    an immediate-mode 3D drawing canvas* recipes to get a better grasp of how a simple
    Vulkan drawing canvas can be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What we need at this point essentially boils down to decomposing a 2D chart
    or graph into a set of lines and rendering them using ImGui. Let’s go through
    the code to see how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We introduce a `LineCanvas2D` class to render 2D lines. It stores a collection
    of 2D lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'The `render()` method is quite simple. We create a new full-screen ImGui window
    with all decorations removed and user input disabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we obtain ImGui’s background draw list and add all our colored lines to
    it one by one. The rest of the rendering will be handled as a part of the ImGui
    user interface rendering, as described in the *Rendering ImGui user interfaces*
    recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `Chapter04/06_DemoApp/src/main.cpp` demo application, we can work
    with an instance of `LineCanvas2D` the following way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'This functionality is sufficient to render 2D lines for various debugging purposes.
    However, there’s yet another way to do rendering using the ImPlot library. Let’s
    use it to render an FPS graph. The helper code is in `shared/Graph.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare another small `LinearGraph` helper class to draw a graph of changing
    values, such as the number of rendered frames per second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'As we add more points to the graph, the old points are popped out, making the
    graph look like it is scrolling on the screen right-to-left. This is helpful to
    observe local fluctuations in values such as frames per second counters, and so
    on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'The idea is to find the minimum and maximum values and normalize the graph
    into the `0...1` range:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to create an *ImGui* window to hold our graph. *ImPlot* drawing
    can work only inside an *ImGui* window. All decorations and user interactions
    are disabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'A new *ImPlot* plot can be started in a similar way. We disable decorations
    for the *ImPlot* axes and set up colors for the line drawing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ImPlot::PlotLine()` function uses our collection of points’ `X` and `Y`
    values to render a graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: This is the entire underlying implementation code.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now take a look at `Chapter04/06_DemoApp/src/main.cpp` to learn how 2D
    chart rendering works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The app at `Chapter04/06_DemoApp` makes use of `LinearGraph` to render an FPS
    graph, and a simple sine graph for reference. Here is how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Both graphs are declared as global variables. They can render up to `2048`
    points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the main loop, we add points to both graphs like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we render both graphs as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: The resulting graphs look as shown in the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10: Frames-per-second and sine wave graphs](img/file28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.10: Frames-per-second and sine wave graphs'
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together into a Vulkan application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we use all the material from previous recipes of this chapter
    to build a Vulkan demo application combining 3D scene rendering with 2D and 3D
    debug line drawing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This recipe is a consolidation of all the material in this chapter into a final
    demo app. It might be useful to revisit all the previous recipes to get to grips
    with the different user interaction and debugging techniques described in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The full source code for this recipe can be found in `Chapter04/06_DemoApp`.
    The `VulkanApp` class used in this recipe is declared in `shared/VulkanApp.h`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s skim through the source code to see how we can integrate the functionality
    from all the recipes together into a single application. We put all of the source
    code here so we can reference it in the subsequent chapters when necessary. All
    error checking is skipped again for the sake of brevity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `shared/VulkanApp.h` header provides a wrapper for *LightweightVK* context
    creation and GLFW window lifetime management. Check the *Initializing the Vulkan
    instance and graphical device* and *Initializing Vulkan swapchain* recipes in
    *Chapter 2* for more details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we demonstrate a camera positioner for the *Adding camera animations and
    motion* recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is for the FPS graph described in the previous *Rendering on-screen
    graphs with ImGui and ImPlot* recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'The `VulkanApp` class has a built-in first-person camera as described in the
    *Working with a 3D camera and basic user interaction* recipe. We provide an initial
    camera position and target, as well as reducing the FPS-averaging interval for
    the purpose of drawing a nice fast-moving graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s create a local variable to make the access to `lvk::IContext` stored
    in `VulkanApp` more convenient. We call `ctx.release()` explicitly later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'All the shaders are loaded from files. The cube map rendering was described
    in the *Using cube map textures in Vulkan* recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'The rubber duck mesh rendering pipeline is created as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'The skybox rendering pipeline uses programmable-vertex pulling and has no vertex
    input state. See the *Using cube map textures in Vulkan* recipe for details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s load the rubber duck from a `.gltf` file and pack it into the `vertices`
    and `indices` arrays:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'Create two GPU buffers to hold `indices` and `vertices`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'A uniform buffer is used to hold per-frame data, such as model-view-projection
    matrices, the camera position, and bindless IDs for both textures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s bring in a 2D texture for the rubber duck model and a cube map texture
    for our skybox, as described in the *Using cube map textures in Vulkan* recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the main loop using a lambda provided by the `VulkanApp::run()` method.
    The camera positioner is updated as described in the *Adding camera animations
    and motion* recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'To recap the details on render passes and frame buffers, check the *Dealing
    with buffers in Vulkan* recipe in *Chapter 3*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'We render the skybox as described in the *Using cube map textures in Vulkan*
    recipe. Note that 36 vertices are used to draw the skybox:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'Rendering the rubber duck mesh is done as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'Rendering an ImGui window with a memo for keyboard hints is done as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'We render a frames-per-second counter as described in the *Adding a frames-per-second
    counter* recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'Our on-screen graphs and a 2D drawing canvas are handled as shown in the *Rendering
    on-screen graphs with ImGui and ImPlot* recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code handles a 3D drawing canvas, as described in the *Implementing
    immediate mode 3D drawing canvas* recipe. To demonstrate the `frustum()` function,
    we render an ad hoc rotating frustum constructed via the `lootAt()` and `perspective()`
    GLM functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, finalize the rendering, submit the command buffer to the GPU, and update
    the graphs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a screenshot from the running application. The white graph
    displays the average FPS values and the rotating white frustum can be used to
    debug shadow mapping, as we will do in subsequent chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11: Demo application](img/file29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.11: Demo application'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter focused on combining multiple rendering aspects into one working
    Vulkan application. The graphical side still lacks some essential features, such
    as advanced lighting and materials, but we have almost everything in place to
    start rendering much more complex scenes. The next few chapters will cover more
    complicated mesh rendering techniques and physically-based lighting calculations
    based on the glTF2 format.
  prefs: []
  type: TYPE_NORMAL
