- en: '*Chapter 7*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*'
- en: Architecture
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构
- en: Introduction
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引言
- en: The term "software architect" has become sadly maligned of late, probably as
    a result of developers working with **architecture astronauts**—[http://www.joelonsoftware.com/items/2005/10/21.html](http://www.joelonsoftware.com/items/2005/10/21.html)
    who communicate through PowerPoint-Driven Development. Simon Brown has written
    a book called **Software Architecture for Developers**—[https://leanpub.com/software-architecture-for-developers](https://leanpub.com/software-architecture-for-developers);
    check it out for a complete discussion of the responsibility of a software architect.
    The focus of this chapter is on the incremental differences between thinking about
    a problem as code and as architecture that supports the code. It's also about
    some of the things to think about as you're designing your application, when to
    think about them, and how to communicate the results of such considerations to
    other people on the team.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: “软件架构师”这个术语最近变得有些声名狼藉，可能是因为开发者与那些通过PowerPoint-Driven Development进行沟通的**架构宇航员**——[http://www.joelonsoftware.com/items/2005/10/21.html](http://www.joelonsoftware.com/items/2005/10/21.html)合作的结果。西蒙·布朗（Simon
    Brown）写了一本名为**《软件开发者的软件架构》**的书——[https://leanpub.com/software-architecture-for-developers](https://leanpub.com/software-architecture-for-developers)；您可以查看这本书，以获得对软件架构师职责的全面讨论。本章的重点是思考问题作为代码和作为支持代码的架构之间的增量差异。它还涉及到在设计应用程序时需要考虑的一些事情，何时考虑它们，以及如何将这些考虑的结果传达给团队中的其他人。
- en: Non-Functional Requirements Are Essential
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非功能性需求至关重要
- en: I'd almost go as far as to say that the *primary indicator of success* for an
    application architecture is whether it supports the non-functional requirements
    the customer has described. Anyone can, given enough patience and stubbornness,
    carry on gluing features together arbitrarily until all of the required functionality
    is present. However, making it do that coherently, in a way that combines desired
    attributes from the customer side (the NFRs) and the developer side (adaptability,
    readability, and the like) is where the art form of software architecture comes
    in.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我几乎可以说，一个应用程序架构成功的主要指标是它是否支持客户描述的非功能性需求。任何人只要足够有耐心和固执，都可以随意将功能粘合在一起，直到所有必需的功能都出现。然而，以结合客户侧（NFRs）和开发侧（适应性、可读性等）所需属性的方式使它具有连贯性，这正是软件架构的艺术所在。
- en: 'So, what are these non-functional requirements? It''s common to say that these
    are the "-ility" statements made about the software. It takes a bit of squinting
    to accept that, but it''s roughly true:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这些非功能性需求是什么？通常说，这些是关于软件的“-ility”声明。需要稍微眯起眼睛才能接受这一点，但大体上是正确的：
- en: '**Performance**: How is this an -ility? Is it speedability? Velocitility? Well,
    something like that anyway. It''s important to understand what''s meant by *performance*,
    as it has many different aspects. It could refer to the software''s behavior with
    restricted resources, or large datasets. If we''re talking "speed," that could
    be about the rate at which requests are processed, or the time to process any
    one request (measured in wall time or clock cycles, depending on which is more
    important). It could be an average, or under peak conditions. If it''s an average,
    over what time is it measured? And is it the *mean* time or another average? Perhaps
    the *median*?'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：这算是什么“-ility”？是速度性？速度性？还是速度性？无论如何，重要的是要理解“性能”的含义，因为它有许多不同的方面。它可能指的是软件在资源受限或大数据集下的行为。如果我们谈论“速度”，那可能是关于处理请求的速率，或者处理单个请求的时间（根据哪个更重要，以墙时或时钟周期来衡量）。它可能是平均值，或者在峰值条件下。如果是平均值，是在多长时间内测量的？它是**均值**还是另一个平均值？或许是**中位数**？'
- en: '*I worked on one project where the performance requirements were described
    thus: the time and memory required to complete certain operations should be within
    105% of the previous versions of the software. That''s easy to measure, and whether
    the software has succeeded is unambiguous.*'
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*我在一个项目中处理过性能需求，描述如下：完成某些操作所需的时间和内存应在软件前一个版本的105%以内。这是容易衡量的，软件是否成功是明确的。*'
- en: '**Compatibility**: What operating systems will the software have to run on?
    What versions? What other software components will it communicate with? Are there
    reasons to choose particular languages, environments, or third-party components?'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**兼容性**：软件需要在哪些操作系统上运行？哪些版本？它将与其他哪些软件组件进行通信？是否有选择特定语言、环境或第三方组件的理由？'
- en: '**Reliability**: What happens when there''s some problem? Is there a failure,
    a recovery, or some restricted mode of operation? How much downtime can be accepted,
    over what period? Or maybe there are limits on how many users may be affected
    simultaneously?'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠性**：当出现问题时会发生什么？是失败、恢复还是某种受限的操作模式？可以接受多长时间的中断，在多长时间内？或者可能有关于同时受影响的用户数量的限制？'
- en: '**Legal or regulatory requirements**: These can be requirements *not* to do
    things (such as don''t give customer data to third parties) or mandates that the
    software *must* do something (such as keeping a record of any request from data).'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**法律或监管要求**：这些可以是要求不做什么（例如，不要将客户数据提供给第三方）或强制软件必须做什么（例如，记录任何数据请求）的规定。'
- en: '**Security**: Such a wide topic that many books have been written, including
    *one of my own*. Now, I''m sure security experts will get annoyed that I''ve lumped
    security in with "other" NFRs, but that''s what it is. For most software, security
    is not functionality that the customer wants but a property of how they want that
    functionality to be delivered. Notice that while security isn''t directly related
    to other requirements, such as compliance, it can be a prerequisite to ensure
    that other requirements are still satisfied in the face of subversion.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：这是一个非常广泛的话题，以至于许多书籍都涉及，包括我自己的其中一本。现在，我确信安全专家会对我将安全性与其他NFRs（非功能性需求）归为一类而感到恼火，但这就是它的本质。对于大多数软件来说，安全性不是客户想要的特定功能，而是他们希望功能以何种方式交付的特性。请注意，虽然安全性与合规性等其他要求没有直接关系，但它可以是确保其他要求在面临颠覆时仍然得到满足的前提条件。'
- en: '**Usability**: This can cover a wide range of requirements: ease of use, obviously;
    but also what (human) languages should be supported, accessibility, design aesthetics,
    and so on. I mentioned usability, but usability by *whom*? The people who will
    be using it, of course; but is there anyone else who needs to be considered? Who
    will be deploying, installing, testing, configuring, and supporting the software?
    What usability requirements do those people have?'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：这可以涵盖广泛的需求：易用性，显然；但也包括应该支持哪些（人类）语言、可访问性、设计美学等等。我提到了可用性，但由谁来使用它？当然是使用它的人；但还有其他人需要考虑吗？谁将部署、安装、测试、配置和支持软件？这些人有什么可用性需求？'
- en: '**Adaptability**: What are the most likely variations in the execution environment
    or the (human) system that the software''s supporting? There''s no need to support
    those things now, of course, but an architecture that makes it easier to make
    those changes (without causing unacceptable costs now, of course) could be beneficial.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适应性**：软件支持的执行环境或（人类）系统中最可能发生的变化有哪些？当然，现在没有必要支持这些事物，但一个能够使这些更改更容易进行（当然，现在不会造成不可接受的成本）的架构可能是有益的。'
- en: 'With a list like that, we can come up with a less hand-wavy definition of non-functional
    requirements: they''re the *constraints* within which the product needs to provide
    its functionality – not the things it does, but the ways in which it must do them.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有这样一个列表，我们可以给出一个不那么模糊的非功能性需求的定义：它们是产品需要在其中提供其功能性的*约束*——不是它所做的事情，而是它必须以何种方式完成这些事情。
- en: That's why a successful architecture *must* support satisfaction of the non-functional
    requirements. If the software doesn't remain within the constraints of its operation,
    customers may not be able to use it at all; in which case, the software would
    be a failure. To support these requirements, the software architecture needs to
    provide a coherent, high-level structure into which developers can build the app's
    features. The architecture should make it clear how each feature is supposed to
    fit, and what limitations are imposed onto the implementation of each component.
    In other words, the architecture should guide developers such that the most obvious
    implementation of a feature is one that conforms to the NFRs. Ideally, whenever
    a developer has a question along the lines of "where would I add this?" or "how
    should I make this change?", the architect (or even the architecture) should already
    have an answer.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: When Should I Think About the NFRs?
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The above discussion probably makes it seem that you need to get the architecture
    in place *before* any of the features are built, because the feature implementation
    must be constrained by the architecture. That's more or less true, though often
    you'll find that requirements for the app's functionality feed back into architecture
    decisions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: I find this iteration is best handled by a series of successively high-fidelity
    prototypes. ("Fidelity" here refers to the technical accuracy and functional completeness
    of prototypes; these are for architectural evaluation, after all. I'm not talking
    about the prototypes' applicability to UI testing, which is **a whole separate
    issue**—[http://dl.acm.org/citation.cfm?id=223514](http://dl.acm.org/citation.cfm?id=223514).)
    The architecture is roughly defined and some of the features are roughly implemented;
    any identified problems are resolved and the design is refined slightly. This
    carries on until everything stabilizes, by which time the product is ready to
    ship.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a discussion on project methodologies in *Chapter 13, Teamwork*. Those
    who have read that, or a similar discussion, will realize that this sounds somewhat
    similar to the **spiral model of software development**— [http://dl.acm.org/citation.cfm?doid=12944.12948](http://dl.acm.org/citation.cfm?doid=12944.12948),
    proposed by Boehm in 1986\. The difference between that proposition and prototyping
    in stages as I practice it is the length of each iteration: days or weeks rather
    than the months to years Boehm was considering.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: People who believe in the "build one to throw away" line are at this point picking
    up their mortified jaws from the floor. The problem with that line is actually
    getting around to throwing away the one to throw away. You *intend* to throw the
    first one away, but somehow it manages to hang around and end up in production.
    You may as well accept from the beginning that this is going to happen and write
    a prototype that isn't ready *yet* but will be at *some time*, supported by documentation
    that helps the team understand the gap between the prototype and production-readiness.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 相信“先做出来再扔掉”这一理念的人此时可能已经从地板上抬起惊愕的嘴巴。这个理念的问题实际上在于如何真正地扔掉那个“扔掉的”东西。你*打算*扔掉第一个版本，但不知为何它竟然留了下来并最终投入了生产。你不妨从一开始就接受这种情况的发生，并编写一个尚未准备好*但将来会准备好*的原型，同时提供帮助团队理解原型与生产就绪之间差距的文档。
- en: Performance in Low–Fidelity Prototypes
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 低保真原型中的性能
- en: Tools for measuring the performance of an application are among some of the
    most capable developer tools available. Time profilers, memory managers, network
    packet inspectors, and others all help you to discover the performance characteristics
    of your application. But how do you do that when it isn't written yet?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 测量应用程序性能的工具是开发者可用的一些最强大的工具之一。时间分析器、内存管理器、网络数据包检查器等工具都有助于你发现应用程序的性能特征。但在它尚未编写出来时，你该如何做呢？
- en: You write simulations that have the expected performance characteristics. If,
    for example, you estimated that an operation requested over the network would
    take about 0.1±0.01s to complete, using about 4 MB of heap memory, you could write
    a simulation that allocates about 4 MB then sleeps for the appropriate amount
    of time. How many of those requests can the app's architecture support at once?
    Is the latency to complete any one operation acceptable? Remember to consider
    both the **normal and saturated cases**—[http://queue.acm.org/detail.cfm?id=2413037](http://queue.acm.org/detail.cfm?id=2413037)
    in testing.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写具有预期性能特征的模拟。例如，如果你估计一个通过网络请求的操作大约需要0.1±0.01秒来完成，大约使用4 MB的堆内存，你可以编写一个模拟，分配大约4
    MB的内存然后休眠适当的时间。应用程序的架构一次能支持多少这样的请求？完成任何单个操作的延迟是否可接受？记住在测试时考虑**正常和饱和情况**——[http://queue.acm.org/detail.cfm?id=2413037](http://queue.acm.org/detail.cfm?id=2413037)。
- en: This form of simulation will not be new to many developers. Just as mock objects
    are simulations designed to test *functionality* when integrating two modules,
    these simulations are the performance equivalent.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模拟形式对许多开发者来说并不陌生。正如模拟对象是为了在集成两个模块时测试*功能*而设计的模拟，这些模拟是性能的等效物。
- en: Security in Low-Fidelity Prototypes
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 低保真原型中的安全
- en: Retrofitting a security model to an existing architecture can be intensely problematic.
    Finding all of the points where access control is needed (This is a key use case
    for aspect-oriented programming; access control can be inserted at the "join points"
    of the application's code), or where data should be inspected for different abuses
    is difficult when the data flow was designed without those aspects being considered.
    For critical security concerns, including access control and data protection,
    it's best to incorporate them in the design from the start.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将安全模型适配到现有架构可能会非常棘手。在数据流设计时未考虑这些方面的情况下，找到所有需要访问控制（这是面向方面编程的关键用例；可以在应用程序代码的“连接点”插入访问控制）或应该检查不同滥用情况的数据点是很困难的。对于关键的安全问题，包括访问控制和数据保护，最好从一开始就在设计中融入它们。
- en: That doesn't necessarily mean completely polishing their implementation; it
    just means making sure that even the early prototypes are capable of (even prototypical)
    protection. As an example, on one project I was involved in, we knew that the
    application needed to encrypt documents that were written to disk. The early versions
    of the app used a **Caesar cipher**—[http://en.wikipedia.org/wiki/Caesar_cipher](http://en.wikipedia.org/wiki/Caesar_cipher)
    to do this – far from cryptographically sound, but sufficient for showing which
    files were being protected and whether anything was being written through another
    route. You can imagine doing the same for authorization, by ensuring that even
    stub functionality cannot be used by unauthorized people.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不一定意味着完全完善他们的实现；这只是意味着确保即使是早期原型也具备（即使是原型性的）保护能力。例如，在一个我参与的项目中，我们知道该应用程序需要加密写入磁盘的文档。该应用的早期版本使用**凯撒密码**[http://en.wikipedia.org/wiki/Caesar_cipher](http://en.wikipedia.org/wiki/Caesar_cipher)来执行此操作——远非密码学上安全，但足以显示哪些文件受到保护，以及是否有其他途径写入。你可以想象通过确保即使占位符功能也不能被未经授权的人使用，为授权执行相同的操作。
- en: Reliability in Low-Fidelity Prototypes
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 低保真原型中的可靠性
- en: You can easily explore how an architecture responds to failures by injecting
    those failures and observing what happens. In the *Performance* section in this
    chapter, I talked about having a stub network module that simulates the memory
    and time requirements of real network requests. Similarly, you could arrange for
    it to fail every so often and observe how the rest of the system copes with that
    failure. Some companies even inject random failures **in production**—[https://github.com/Netflix/SimianArmy/wiki](https://github.com/Netflix/SimianArmy/wiki))
    to ensure that their systems are capable of coping.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过注入这些故障并观察发生了什么来轻松地探索架构对故障的反应。在本章的*性能*部分，我谈到了拥有一个模拟真实网络请求内存和时间需求的占位符网络模块。同样，你可以安排它时不时地失败，并观察系统其他部分如何应对这种故障。一些公司甚至在生产中注入随机故障**[https://github.com/Netflix/SimianArmy/wiki](https://github.com/Netflix/SimianArmy/wiki**)，以确保他们的系统能够应对。
- en: Defer When Appropriate; Commit When Necessary
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适当推迟；必要时承诺
- en: 'Working with successively refined prototypes means that the architecture becomes
    iteratively more complete; therefore, certain decisions become more "baked in"
    and difficult to change. Remember the notion presented earlier: that the architecture
    should always be ready to answer developer questions. This means that whatever
    the developers work on first are the things that should be solved first. But that''s
    a tautological statement, because you can probably arrange the development work
    to track the architectural changes.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与逐步精炼的原型一起工作意味着架构会迭代地更加完整；因此，某些决策会变得更加“固定”和难以更改。记住之前提出的概念：架构应该始终准备好回答开发者的疑问。这意味着开发者首先工作的东西应该是首先解决的问题。但这是一种同义反复的陈述，因为你可能能够安排开发工作以跟踪架构的变化。
- en: The best things to start with are the riskiest things. They might be the exploratory
    aspects of the product that aren't similar to anything the team has worked on
    before, they could be the parts that interface with other software or other organizations,
    or they could be the aspects that will potentially have the highest cost. These
    are the aspects of the application that will most likely change, and where change
    will be expensive. Dealing with these issues first means a high rate of change,
    early on in the project before the schedule and costs have become too well-established,
    rather than at the end, when people have expectations about when everything will
    be ready. In addition, changes made before much code has been written mean less
    code to rework.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从最具风险的事情开始是最好的。它们可能是产品探索性的方面，这些方面与团队之前所做的工作不相似，它们可能是与其他软件或其他组织接口的部分，或者它们可能是可能产生最高成本的部分。这些是应用中最有可能发生变化的部分，变化将非常昂贵。首先处理这些问题意味着在项目早期，在计划和成本变得过于固定之前，会有很高的变化率，而不是在项目结束时，当人们对何时一切准备就绪有期望。此外，在编写大量代码之前做出的更改意味着需要重写的代码更少。
- en: There's an expectation management issue here. During the exploratory and experimental
    work, you have to be able to convince clients, managers, and anyone else who asks
    that the answer to "how long will it take?" is "I don't know; we're not sure what
    it is yet" and any progress that has been made so far is illusory. It might *look*
    like you've made a lot of progress, but most of it will be simulation code that
    doesn't really do what it looks like it does. On two separate projects I've led
    the development of, we've run into trouble where a stakeholder has based assumptions
    about the project's progress on seeing a prototype. It's not their fault; it's
    my responsibility to provide a realistic appraisal of the project's status on
    which they can base their judgements on how to proceed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里存在一个期望管理问题。在探索性和实验性工作中，你必须能够说服客户、经理以及任何询问的人，对于“需要多长时间？”的回答是“我不知道；我们还没有确定”以及到目前为止所取得的任何进展都是虚假的。它可能看起来你取得了很大的进展，但其中大部分将是模拟代码，实际上并没有做它看起来要做的事情。在我领导的两个独立项目中，我们遇到了麻烦，因为某个利益相关者基于看到原型而对项目的进展做出了假设。这不是他们的错；这是我的责任，要提供关于项目状况的现实评估，让他们可以根据这个评估来判断如何继续进行。
- en: Justify Your Decisions
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 证明你的决策是合理的
- en: So, you've chosen the technology that will be used in a particular aspect of
    your application. Was that because it will lead to satisfying the customer's requirements
    with the least effort, or because it's the new shiny thing you've wanted to use
    since you went to that conference?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你已经选择了将在应用程序的某个特定方面使用的技术。这是因为它将以最少的努力满足客户的需求，还是因为它是你自从参加那个会议以来就想使用的最新潮的东西？
- en: 'When someone asks why the team is using a particular language, framework, or
    pattern, a shrug of the shoulders accompanied by the phrase "right tool for the
    job" isn''t going to be a very satisfactory answer. What is it that *makes* that
    tool right for the job? Does it satisfy some requirement, such as compatibility,
    that other alternatives don''t? Is it cheaper than the alternatives? (Remember
    that cost is calculated holistically: a commercial tool can be cheaper than a
    free one if it significantly reduces effort and the likelihood of introducing
    bugs.)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人问为什么团队使用特定的语言、框架或模式时，仅仅耸耸肩，并说“适合这项工作的正确工具”并不是一个令人满意的答案。是什么让这个工具成为适合这项工作的正确工具？它是否满足了一些其他替代方案不具备的要求，比如兼容性？它是否比替代方案更便宜？（记住，成本是整体计算的：如果它显著减少了工作量并降低了引入错误的可能性，那么商业工具可能比免费工具更便宜。）
- en: 'You need to convince other people that the solution you''re choosing is appropriate
    for the task at hand. Before brushing up on your rhetoric skills (which are indeed
    useful – there''s a section on negotiation in *Chapter 13, Teamwork*, and a whole
    chapter on critical thinking), the first thing to do is to make sure that it *is*
    an appropriate tool for the job. Think about the different considerations people
    will have:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要说服其他人，你选择的解决方案适合当前的任务。在提升你的修辞技巧（这确实很有用——第13章“团队合作”中有一个关于谈判的部分，以及一个关于批判性思考的整章）之前，首先要确保它确实是一个适合这项工作的工具。考虑人们可能会有哪些不同的考虑因素：
- en: 'The customers: Will this technology let you build something that satisfies
    all of the requirements? Will you, or someone else, be able to adapt the solution
    as our needs change? Can we afford it? Is it compatible with our existing environment?'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户：这项技术能否让你构建出满足所有要求的东西？你或其他人能否随着我们的需求变化而调整解决方案？我们负担得起吗？它与我们的现有环境兼容吗？
- en: 'The developers: Do I already know this, or will I have to learn it? Will it
    be interesting to learn? Is using this technology consistent with my career plans?'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者：我已经知道这些了吗，还是我需要去学习？学习这个技术会有趣吗？使用这项技术是否符合我的职业规划？
- en: 'Management: Is this cost-effective? Is it actually the best solution for this
    project, or is it just something you''ve always wanted to learn? What''s the **bus
    factor**—[http://en.wikipedia.org/wiki/Bus_factor](http://en.wikipedia.org/wiki/Bus_factor)
    going to be? Can we sell this to other customers? Can we buy support from the
    vendor? Does it fit well with the capabilities and goals of the company?'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理层：这是否具有成本效益？这真的是这个项目的最佳解决方案，还是只是你一直想学习的东西？**总线因素**[http://en.wikipedia.org/wiki/Bus_factor](http://en.wikipedia.org/wiki/Bus_factor)会是什么？我们能向其他客户销售这个吗？我们能从供应商那里购买支持吗？它是否与公司的能力和目标相匹配？
- en: If you can answer those questions honestly and your chosen technology still
    comes out looking like the best answer, well, I'm not going to say you won't need
    your skills of persuasion and negotiation – just that you'll make it easier to
    employ them.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够诚实地回答这些问题，并且你选择的技术仍然看起来是最好的答案，那么，我并不会说你不需要你的说服力和谈判技巧——只是说你会更容易地运用它们。
- en: 'But remember that negotiation is one of those tangos that requires two people.
    In **Metaphors we Live By**—[http://theliterarylink.com/metaphors.html](http://theliterarylink.com/metaphors.html),
    Lakoff and Johnson propose that the way we think about argument is colored by
    our use of combat metaphors. Well, destroying your opponent with a deft collection
    of rhetorical thrusts is fine for the school debating society, but we all need
    to remember that we win at software by *building the best thing,* not by steamrollering
    dissenting arguments. It can be hard, especially under pressure, to put ego to
    one side and accept criticism as a way of collaborating on building better things.
    But it''s important to do so: look back to the list of different concerns people
    have, think of any others I''ve forgotten to add, and realize that your opinion
    of what''s best for the project only covers a part of the story.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，谈判就像是一种需要两个人的探戈。在《我们生活的隐喻》——[http://theliterarylink.com/metaphors.html](http://theliterarylink.com/metaphors.html)中，拉科夫和约翰逊提出，我们思考论点的方式受到我们使用战斗隐喻的影响。好吧，用巧妙收集的修辞手法击败对手在学校辩论社团中是可以的，但我们都需要记住，我们在软件领域是通过*构建最好的东西*来取得胜利的，而不是通过压倒性的反对意见。在压力之下，尤其是要放下自我，接受批评作为共同构建更好事物的手段可能会很困难。但这样做很重要：回顾一下人们提出的不同担忧，想想我可能忘记添加的其他担忧，并意识到你对项目最佳看法的看法只覆盖了故事的一部分。
- en: When to Fix and When to Replace
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时修复和何时更换
- en: A particular decision you often have to justify as a software architect is the
    choice of whether to continue using some existing code, or whether to throw it
    away and replace it with something else. Well, you rarely have to justify the
    decision to keep what you already have; you often have to justify its replacement.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件架构师，你经常需要证明的一个特定决定是是否继续使用一些现有的代码，或者是否将其丢弃并用其他东西替换。好吧，你很少需要证明保留现有东西的决定；你经常需要证明替换它的合理性。
- en: This is as it should be. While it's satisfying – even calming – to think of
    leaving all that legacy cruft behind and starting on a greenfield implementation,
    there are good reasons to avoid doing so. The existing code may seem buggy and
    hard to understand, but your team has existing experience with it and probably
    knows where the problems and limitations are. The same cannot be said of the as-yet
    nonexistent replacement, which will probably bring its own difficulties and bugs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这本应是如此。虽然想象着抛开所有遗留的垃圾并开始一个新的绿色实施项目可能会让人感到满足——甚至让人感到平静——但避免这样做有很好的理由。现有的代码可能看起来有缺陷且难以理解，但你的团队已经对它有了现成的经验，并且可能知道问题和限制在哪里。对于尚未存在的替代品来说，情况并非如此，它可能会带来自己的困难和缺陷。
- en: It's important to realize now that this argument is not the same as the sunk-cost
    fallacy. That would be to argue that you shouldn't throw away existing code because
    of the time and resources that have already been spent on it; I'm saying that
    you should consider carefully whether the cost of developing something new is
    really lower than the cost of carrying on with what you've got.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重要的是要认识到，这个论点与沉没成本谬误不同。那将是争论你不应该丢弃现有的代码，因为它已经花费了时间和资源；我在说的是，你应该仔细考虑开发新事物的成本是否真的低于继续使用现有事物的成本。
- en: 'It probably isn''t in many cases. Here''s a question: how many bugs will your
    replacement implementation have? What will those bugs be? How long will they take
    to fix? If you could predict that, you probably wouldn''t leave those problems
    in, and you could also predict how long it''d take to fix the bugs in the existing
    implementation and compare the two. Experience has taught us, though, that predicting
    the quality of a piece of development work is really difficult. There is thus
    a probability that, while your new implementation will fix some bugs in the original
    (because you''re conscious of those problems when you''re developing it), it will
    introduce new problems, including regressions where the earlier version worked
    better than its replacement. You''ve got to factor that risk into your decision.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下可能并非如此。这里有一个问题：你的替代实现将有多少个错误？这些错误是什么？修复这些错误需要多长时间？如果你能预测这一点，你可能不会留下这些问题，你也可以预测修复现有实现中的错误需要多长时间，并比较两者。然而，经验告诉我们，预测一项开发工作的质量是非常困难的。因此，存在一种可能性，即虽然你的新实现可能会修复原始版本中的一些错误（因为你在开发它时意识到了这些问题），但它可能会引入新的问题，包括回归问题，即早期版本的工作效果比其替代品更好。你必须将这种风险纳入你的决策中。
- en: A significant shift in the economics of this situation occurs when the replacement
    is not something, you're going to build in-house but is an open source or commercial
    module you can use. In those cases, the cost of acquiring the software will be
    well-known, and the fitness for purpose could probably be investigated by examining
    the bug database or asking the community or vendor. The cost of integration, and
    the extent to which you'll be responsible for fixing problems (and the costs you'll
    incur if you aren't) are the remaining costs to consider.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当替代品不是你打算内部构建的东西，而是一个你可以使用的开源或商业模块时，这种情况的经济学发生了重大转变。在这种情况下，获取软件的成本将是众所周知的，并且可以通过检查错误数据库或询问社区或供应商来调查其适用性。集成成本以及你将负责解决问题的程度（以及如果你不解决这些问题将产生的成本）是剩余需要考虑的成本。
- en: 'Another thought on rewrites: while they''re not clearly an advantage for the
    developers, they certainly aren''t a benefit to customers. I''ve seen a number
    of applications where a new version is touted as being "a complete rewrite" and,
    as Danny Greg from GitHub said, this is not a good thing. If the new version of
    the software is a complete rewrite, then, to me as a customer, all it shares with
    the previous version is the name and the icon.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 关于重写的另一个想法：虽然它们对开发者来说可能不是明显的优势，但它们肯定不是对客户的益处。我见过许多应用程序，其中新版本被吹捧为“完全重写”，正如GitHub的Danny
    Greg所说，这不是一件好事。如果软件的新版本是一个完全重写，那么对我来说作为客户，它与上一个版本唯一共享的是名称和图标。
- en: There's a risk that things I relied on in the previous version won't work as
    well, or at all, in the rewritten version. This is an excellent opportunity for
    me to evaluate competing products.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在重写版本中，我依赖的前版本中的某些东西可能不会像以前那样工作，或者根本无法工作。这对我来说是一个评估竞争产品的绝佳机会。
- en: You're faced with a known, and well-understood code module, with some known
    problems. Using this is free, but you might have to spend some time fixing some
    of the problems to extend it to cope with your new project. The alternative is
    to spend a while building something that does the same work but has an *unknown*
    collection of problems. Your team doesn't have the same experience with it, though
    it might better conform to your team's idea of what well-designed code should
    look like... this month. Given the choice between those two things, and the principle
    that my code is a liability not an asset, I conclude that I'd rather choose the
    devil I know than the devil I don't.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你面对的是一个已知且被充分理解的代码模块，存在一些已知问题。使用它是免费的，但你可能需要花一些时间修复一些问题，以便将其扩展以适应你的新项目。另一种选择是花一些时间构建做相同工作但具有未知问题集合的东西。尽管你的团队可能没有同样的经验，但它可能更符合你团队对良好设计代码的看法……这个月。在两者之间做出选择，以及我的代码是负债而不是资产的原则，我得出结论，我宁愿选择我认识的恶魔，而不是不认识的恶魔。
- en: Know When to Nitpick, And When to Leave It
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 知道何时吹毛求疵，何时放手
- en: One of the attributes of a good developer is being able to pick apart the small
    details of a problem. Developers are good at that because computers demand it;
    computers are really bad at inference, so you have to predict every little case
    that could happen, no matter how rare, and tell the computer what to do with them.
    Unfortunately, this attribute, if carried too far, turns programmers into **lousy
    conversationalists**—[http://tirania.org/blog/archive/2011/Feb-17.html](http://tirania.org/blog/archive/2011/Feb-17.html)
    in all other fields, including other areas of software creation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一个优秀开发者的一个属性是能够分析问题的细节。开发者擅长这一点，因为计算机要求这样做；计算机在推理方面真的很差，所以你必须预测可能发生的每一个小情况，无论多么罕见，并告诉计算机如何处理它们。不幸的是，如果这个属性做得太过分，就会使程序员变成**糟糕的交谈者**——[http://tirania.org/blog/archive/2011/Feb-17.html](http://tirania.org/blog/archive/2011/Feb-17.html)，在所有其他领域，包括其他软件创建领域。
- en: 'When you or someone else is designing the architecture for a software system,
    think of it as a low-fidelity proposal for the *shape* of the solution, not the
    actual solution. The answer to the question "how does this solve X?" is almost
    certainly "it doesn''t – this is an early-stage prototype," so there''s not even
    any point asking the question. You could demonstrate the answer by building the
    solution into the proposed architecture: if it works, you''ve built a feature;
    if it doesn''t work, you''ve found something important. But often, you''ll start
    by thinking that something isn''t going to work and find out that it actually
    does.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当你或其他人正在为软件系统设计架构时，把它看作是对解决方案**形状**的低保真提案，而不是实际的解决方案。对于“这如何解决X？”的问题，几乎可以肯定的是“它解决不了——这是一个早期阶段的原型”，所以甚至问这个问题都没有意义。你可以通过将解决方案构建到所提出的架构中来证明答案：如果它有效，你就创建了一个功能；如果它不起作用，你就发现了一些重要的事情。但通常，你会先认为某件事不会起作用，然后发现它实际上是可以的。
- en: Similarly, "why did you do it like *that*?" is not a useful question. If the
    person who did it like that didn't think that doing it like that was a good idea,
    they wouldn't have done it like that. Many developers don't like reading other
    programmers' code, and I think it's because *developers aren't taught how to critically
    analyze code well*—[http://blog.securemacprogramming.com/2012/12/can-code-be-readable/](http://blog.securemacprogramming.com/2012/12/can-code-be-readable/).
    If you can't turn "what is *that*?" into a specific question about the proposed
    solution, don't ask.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，“你为什么这样做？”这样的问题并没有什么用。如果那样做的人没有认为那样做是个好主意，他们就不会那样做。许多开发者不喜欢阅读其他程序员的代码，我认为这是因为**开发者没有被教会如何有效地批判性地分析代码**——[http://blog.securemacprogramming.com/2012/12/can-code-be-readable/](http://blog.securemacprogramming.com/2012/12/can-code-be-readable/)。如果你不能将“那是什么？”转化为关于所提解决方案的具体问题，就别问了。
- en: This is not to say that criticism is bad or unwanted. Of course it's wanted
    – the architecture will benefit from the input of multiple people. But the feedback
    has to be at the *same level of abstraction* as the architecture itself.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说批评是坏的或不想要的。当然，它是受欢迎的——建筑将受益于多个人输入。但反馈必须与建筑本身处于相同的**抽象级别**。
- en: In other words, the feedback must be in terms of the constraints placed on the
    solution and whether they can be met while providing the required features. Problems
    like "I can't see how errors from the `frobulator` interface would get into the
    audit component" are fine. Questions like "how does this degrade under ongoing
    saturation?" are fine. Suggestions like "if we use this pattern, then the database
    plugin can be interchangeable without much additional effort" are welcome. Comments
    along the lines of "this is useless – it doesn't handle the filesystem reporting
    a recursive link problem when you open a named pipe" can be deferred.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，反馈必须以对解决方案施加的约束以及它们是否可以在提供所需功能的同时得到满足为条件。像“我看不到`frobulator`接口的错误如何进入审计组件”这样的问题是好的。像“在持续饱和下这是如何退化的？”这样的问题是好的。像“如果我们使用这个模式，那么数据库插件可以很容易地互换”这样的建议是受欢迎的。像“这毫无用处——它不能处理当你打开命名管道时文件系统报告递归链接问题”这样的评论可以推迟。
- en: Support, Don't Control
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持，而不是控制
- en: Given the definition that architecture serves to support the application's features
    within the constraints of its non-functional requirements, we can describe the
    role of architect in similar terms.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 根据架构服务于在非功能性要求的约束内支持应用程序功能的定义，我们可以用类似的话来描述架构师的角色。
- en: What Does A Software Architect Do?
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 软件架构师做什么？
- en: A software architect is there to identify risks that affect the technical implementation
    of the software product and address those risks. Preferably, before they stop
    or impede the development of the product.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构师的存在是为了识别影响软件产品技术实现的潜在风险，并解决这些风险。最好是，在他们停止或阻碍产品开发之前。
- en: That could mean doing tests to investigate the feasibility or attributes of
    a proposed solution. It could mean evangelizing the developers to the clients
    or managers to avoid those people interrupting the development work. It could
    mean giving a junior developer a tutorial on a certain technology – or getting
    that developer to tutor the rest of the team on the thing that person is an expert
    on.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能意味着进行测试以调查提议解决方案的可行性或属性。这可能意味着向开发者和客户或经理传教，以避免这些人打断开发工作。这可能意味着给初级开发者提供关于某种技术的教程——或者让这位开发者辅导团队其他成员关于他/她擅长的东西。
- en: What A Software Architect Doesn't Do
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 软件架构师不做的事情
- en: A software architect doesn't micromanage the developers who work with them.
    An architect doesn't rule by memos and UML diagrams. The architect doesn't prognosticate
    on things they have no experience of. Perhaps confusingly, the role of software
    architect bears very little resemblance to the profession after which it's named.
    If you want analogies with civil engineering, all developers are like architects.
    If you want to see the software analog to the builder, that's work done by the
    compiler and IDE.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构师不会对与他们合作的开发者进行微观管理。架构师不会通过备忘录和UML图来统治。架构师不会对没有经验的事情进行预测。也许有些令人困惑，软件架构师的职责与它所命名的职业相差甚远。如果你想找到与土木工程相关的类比，所有的开发者都像是建筑师。如果你想看到软件与建造者的对应，那是由编译器和IDE完成的工作。
- en: Architects don't make decisions where none is necessary. They don't ignore or
    belittle suggestions that come from people who aren't architects either.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 架构师不会在没有必要的情况下做出决定。他们也不会忽视或轻视来自非架构师人士的建议。
- en: In one sentence
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简而言之
- en: A software architect is there to make it easier for developers to develop.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构师的存在是为了让开发者更容易地进行开发。
