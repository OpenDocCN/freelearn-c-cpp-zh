["```cpp\n$ ninja llvm-tblgen\n```", "```cpp\nclass Person {\n  string Name = \"John Smith\";\n  int Age;\n}\n```", "```cpp\ndef john_smith : Person;\n```", "```cpp\ndef john_smith : Person {\n  let Age = 87;\n}\n```", "```cpp\ndef john_smith : Person {\n  let Age = 87;\n  string Job = \"Teacher\";\n}\n```", "```cpp\nclass Weight<int kilogram> {\n  int Gram = !mul(kilogram, 1000);\n}\n```", "```cpp\nclass AutoPart<int quantity> {…}\ndef car1_fuel_tank : AutoPart<1>;\ndef car1_engine : AutoPart<1>;\ndef car1_wheels : AutoPart<4>;\n…\ndef car2_fuel_tank : AutoPart<1>;\ndef car2_engine : AutoPart<1>;\ndef car2_wheels : AutoPart<4>;\n…\n```", "```cpp\nclass AutoPart<int quantity> {…}\nmulticlass Car<int quantity> {\n  def _fuel_tank : AutoPart<quantity>;\n  def _engine : AutoPart<quantity>;\n  def _wheels : AutoPart<!mul(quantity, 4)>;\n  …\n}\n```", "```cpp\ndefm car1 : Car<1>;\ndefm car2 : Car<1>;\n```", "```cpp\n(operator operand1, operand2,…, operandN)\n```", "```cpp\nclass Variable {…}\nclass Operator {…}\nclass Expression<dag expr> {…}\n// define variables\ndef x : Variable;\ndef y : Variable;\ndef z : Variable;\n// define operators\ndef mul : Operator;\ndef plus : Operator;\n// define expression\ndef tmp1 : Expression<(mul x, 2)>;\ndef tmp2 : Expression<(mul 8, z)>;\ndef result : Expression<(plus tmp1, tmp2, y)>;\n```", "```cpp\n…\ndef tmp1 : Expression<(mul:$op x, 2)>;\ndef tmp2 : Expression<(mul:$op 8, z)>;\ndef result : Expression<(plus tmp1:$term1, tmp2:$term2, y:$term3)>;\n```", "```cpp\n    class Unit {\n      string Text;\n      bit Imperial;\n    }\n    ```", "```cpp\n    def gram_unit : Unit {\n      let Imperial = false;\n      let Text = \"g\";\n    }\n    def tbsp_unit : Unit {\n      let Imperial = true;\n      let Text = \"tbsp\";\n    }\n    ```", "```cpp\n    class Unit<bit imperial, string text> {\n      string Text = text;\n      bit Imperial = imperial;\n    }\n    def gram_unit : Unit<false, \"g\">;\n    def tbsp_unit : Unit<true, \"tbsp\">;\n    ```", "```cpp\n    class NplusQuarter<class is simply just integrating its fields.\n    ```", "```cpp\n    class NplusQuarter<num_quarter variable. By writing num_quarter{1…0}, this gives you a bits value that is equal to the 0th and first bit of num_quarter. There are some other variants of this technique. For example, it can slice a non-continuous range of bits, as follows:\n\n    ```", "```cpp\n\n    Or, it can extract bits in reversed ordering, as follows:\n\n    ```", "```cpp\n\n    NoteYou might wonder why the code needs to extract the smallest 2 bits *explicitly* even it has declared that `num_quarter` has a width of 2 bits (the `bits<2>` type). It turned out that for some reason, TableGen will not stop anyone from assigning values greater than `3` into `num_quarter`, like this: `def x : NplusQuarter<1,999>`.\n    ```", "```cpp\n    // In Ingredients.td…\n    include \"Kitchen.td\"\n    ```", "```cpp\n    class IngredientBase<Unit unit> {\n      IngredientBase, with parameters to specify the quantity needed by a recipe, and the unit used to measure this ingredient. Take milk, for example, as shown in the following code snippet:\n\n    ```", "```cpp\n    def ingredient_milk : Milk<1,2>; // Need 1.5 cup of milk\n    ```", "```cpp\n\n    ```", "```cpp\n    defm syntax to create multiclass records, as follows:\n\n    ```", "```cpp\n\n    After using `defm`, three records will actually be created: `egg_ingredient_whole`, `egg_ingredient_yolk`, and `egg_ingredient_white`, inheriting from `WholeEgg`, `EggYolk`, and `EggWhite`, respectively. \n    ```", "```cpp\n    class Step<Action field carries the baking instructions and information about the ingredients used. Here is an example:\n\n    ```", "```cpp\n    …\n    def step_mixing : Step<(mix milk, flour), …>;\n    def step_mixing2 : Step<Step records will form a DAG, in which a vertex will either be a step or an ingredient record.We're also annotating our `dag` operator and operand with tags, as follows:\n\n    ```", "```cpp\n    def step_prep : Step<(heat:$action, $oil, and $temp in the string with the textual representation of those records, generating a string such as *heat the peanut oil until it reaches 300 F*.\n    ```", "```cpp\n\n    ```", "```cpp\n\n    ```", "```cpp\n=======Ingredients=======\n1\\. oil 500 ml\n2\\. flour 300 g\n3\\. milk 1.25 cup\n4\\. whole egg 1\n5\\. yeast 1.50 tsp\n6\\. butter 3.50 tbsp\n7\\. sugar 2.0 tbsp\n8\\. salt 0.50 tsp\n9\\. vanilla extract 1.0 tsp\n=======Instructions=======\n1\\. use deep fryer to heat oil until 160 C\n2\\. use mixer to mix flour, milk, whole egg, yeast, butter, sugar, salt, and vanilla extract. stir in low speed.\n3\\. use mixer to mix outcome from (step 2). stir in medium speed.\n4\\. use bowl to ferment outcome from (step 3).\n5\\. use rolling pin to flatten outcome from (step 4).\n6\\. use cutter to cut outcome from (step 5).\n7\\. use deep fryer to fry outcome from (step 1) and outcome from (step 6).\n```", "```cpp\nclass SampleEmitter {\n  RecordKeeper &Records;\npublic:\n  SampleEmitter(RecordKeeper &RK) : Records(RK) {}\n  void run(raw_ostream &OS);\n};\n```", "```cpp\n$ cd llvm\n$ cp lib/TableGen/TableGenBackendSkeleton.cpp \\\n     utils/TableGen/RecipePrinter.cpp\n```", "```cpp\n// In RecipePrinter::run method…\nstd::vector<Record*> Steps = Records.getAllDerivedDefinitions(\"Step\");\n```", "```cpp\nvoid RecipePrinter::printUnit(raw_ostream& OS, Record* UnitRecord) {\n  OS << UnitRecord->getValueAsString(\"Text\");\n}\n```", "```cpp\nconst auto* SIDef = cast<const DefInit>(StepOrIngredient);\n```", "```cpp\nRecord* SIRecord = SIDef->getDef();\nif (SIRecord->isSubClassOf(\"Step\")) {\n  // This Record is a baking step!\n} else if (SIRecord->isSubClassOf(\"IngredientBase\")){\n  // This Record is an ingredient!\n} \n```", "```cpp\ndef step_prep : Step<(heat:$action fry_oil:$oil, oil_temp:$temp)> {\n  let CustomFormat = \"$action $oil until $temp\";\n}\n```", "```cpp\nDagInit* DAG = StepRecord->getValueAsDag(\"Action\");\n```", "```cpp\nfor(i = 0; i < DAG->arg_size; ++i) {\n  Init* Arg = DAG->getArg(i);\n}\n```", "```cpp\nfor(i = 0; i < DAG->arg_size; ++i) {\n  StringRef ArgTok = DAG->getArgNameStr(i);\n}\n```", "```cpp\n$ llvm-tblgen -gen-instr-info /path/to/X86.td -o GenX86InstrInfo.inc\n```", "```cpp\n    …\n    void EmitX86FoldTables(RecordKeeper &RK, raw_ostream &OS);\n    void EmitRecipe(RecordKeeper &RK, raw_ostream &OS);\n    void EmitRegisterBank(RecordKeeper &RK, raw_ostream &OS);\n    …\n    ```", "```cpp\n    enum Action Type {\n    …\n      GenRecipe,\n    …\n    }\n    …\n    cl::opt<ActionType> Action(\n        cl::desc(\"Action to perform:\"),\n        cl::values(\n            …\n            clEnumValN(GenRecipe, \"gen-recipe\",\n                       \"Print delicious recipes\"),\n            …\n        ));\n    ```", "```cpp\n    bool LLVMTableGenMain(raw_ostream &OS, RecordKeeper &Records) {\n      switch (Action) {\n      …\n      case GenRecipe:\n        EmitRecipe(Records, OS);\n        break;\n      }\n    }\n    ```", "```cpp\n    add_tablegen(llvm-tblgen LLVM\n      …\n      RecipePrinter.cpp\n      …)\n    ```", "```cpp\n    -o option.)The preceding command will print out a (mostly) normal donut recipe, just like this:\n\n    ```", "```cpp\n\n    ```"]