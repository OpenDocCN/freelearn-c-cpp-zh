<html><head></head><body>
        

                            
                    <h1 class="header-title">Changing Levels, Streaming, and Retaining Data</h1>
                
            
            
                


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>Switching levels in UE4 comes in two varieties. One is very simple: unload the old level, load in the new one, done (if that's all you need, this chapter may be a very short one!). The second method of streaming levels in and out continuously has many more challenges, but can be a much more rewarding user experience too. And in both cases, the question remains: what game elements or player data stay with you as these levels load? Having that data persist can be a real challenge with a couple of solutions we'll explore here too so that whichever methods are chosen, in the end, your player can have a continuous experience that hopefully is not too much of a strain on those working on level design!  Our goals here are:</p>
<ul>
<li>Cover the basics of map-switching in UE4</li>
<li>Adding a new level to transition to</li>
<li>Adapting the load/save system to persist state across map-transitions</li>
<li>Create a practical example of level streaming from a persistent level</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>As usual, it is recommended to pick up from the end of Chapter 5, <em>Adding Enemies!</em>, for continuity, but it is by no means required. All lessons here should be able to be applied to any UE4 project at any stage of development.</p>
<p>The GitHub project corresponding to it is found here:</p>
<p><a href="https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-6">https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-6</a></p>
<p>Engine version used: 4.19.2.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Traditional level loading</h1>
                
            
            
                
<p>Changing levels (maps) has been an inherent system of the Unreal Engine since its inception. So, naturally, there are several tools and options that have evolved with it over the years. That said, we already have all the tools needed for basic level changing, but it's still instructive to walk through them, and we'll update our loading and saving in this section to keep our progress and game state during those switches. First, a quick review of the foundations of level changing in UE4.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The basics</h1>
                
            
            
                
<p>Blueprint and C++ both have a built-in way to change levels. In a quick blueprint example we'll use here, it's the Open Level node accessible from most places you could ever want to use it in blueprint. In C++, we already used it during load/save (though note that for a server-based game, you would normally pass the desired level as the first parameter; here, we simply use it to restart the existing level with the <kbd>"?Restart"</kbd> special string):</p>
<pre>if (mapName == currentMapName)
{
        World-&gt;ServerTravel("?Restart", true);
}
else
{
        UGameplayStatics::OpenLevel(World, *mapName, true);
}</pre>
<p>So, triggering one of these in the game is about as simple as it can get. In our default FirstPersonExampleMap, I've added a few blocks to resemble a portal that is at the top of the moving platform we added some time ago.</p>
<p>If you check GitHub, there is a Stash for this chapter on fixing the moving platforms because they can squish pawns (player or NPCs) out of the level when moving back down. It's not a perfect fix, but it simply disables collision as the platform moves back down and re-enables it once it reaches the bottom (and some other minor logic was fixed in the platforms). As this is not a specific goal of this chapter, however, it was stashed instead of checked directly into the GitHub project.</p>
<p>In the middle of this, I added a simple trigger volume from the Volumes set on the left (no new blueprint class or instance is even needed):</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/6a94ed8a-d097-4223-83b3-de14afd5fa43.png"/></p>
<p>With this selected, open the level blueprint by clicking Blueprints button at the top on the main menu bar, and selecting Open Level Blueprint. In there, while the volume is selected and you right-click, at the very top you have access to options specific to that specific object in the level. We'll use its overlap event, check whether it's the player, and if so, open MasteringTestLevel, as seen here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/bdb38767-10e3-4c4a-8dcf-122a81de24e9.png"/></p>
<p>That's it. Really. Just walk into the trigger and we'll be launched in the other level. If this is all your project needs, then it's best to stop here and keep life simple!</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Using load/save to transition</h1>
                
            
            
                
<p>Most games, especially those with a story-based single player mode or the like, though, will want the player's status after leaving, as well as the state of the level itself, to be persistent across this transition. If we make a simple portal back to <kbd>FirstPersonExampleMap</kbd> just like we did in the preceding section, you'll notice when switching back and forth that our player, the items, NPCs, and so on in those levels are as if we had opened them anew, rather than the state they were in when we left, and the player's inventory is loaded anew as well. So now really we need two distinct things:</p>
<ul>
<li>Keeping the player's data intact across any level load</li>
<li>Loading and saving the state of that level and its dynamic objects when switching</li>
</ul>
<p>Fortunately, we have already implemented dynamic any-time loading and saving, so we'll just modify that and take advantage of it for the level state. But then we need something new for persisting data across map changes. There are several options to this (some definitely safer or more clean than others) but for our game, we'll make a new <kbd>UGameInstance</kbd> C++ class and use it like a singleton to hold data and information that will persist throughout the entire lifetime of the game being run.</p>
<p>Any time static or global data is introduced, you must be extremely careful as it can have unforeseen effects on things such as play in editor, where even though you stop playing, so long as the editor is not closed and re-opened, any of that static data persists and so you cannot count on the same behavior starting and restarting PIE versus a standalone version of the game, say, on a device or other platform. We'll put in some safeguards here for our example, but use caution and minimize dangerous data storage whenever possible!</p>
<p>We'll name the new game instance <kbd>MasteringGameInstance</kbd> and give it some singleton-like functionality:</p>
<pre>UCLASS()
class MASTERING_API UMasteringGameInstance : public UGameInstance
{
        GENERATED_BODY()
 
public:
        UFUNCTION(BlueprintCallable, Category = "Mastering Game Instance")
        static UMasteringGameInstance* GetInstance();
 
        virtual void Init() override;
        virtual void BeginDestroy() override;
        virtual void FinishDestroy() override;
 
        bool ShouldPersistInventory() const
        {
                return bPersistPlayerInventory;
        }
 
        void SetPersistInventory(const bool bPersist = true)
        {
                bPersistPlayerInventory = bPersist;
        }
 
        void SetPlayerInventory(class UMasteringInventory* Inv);
 
        FORCEINLINE class UMasteringInventory* GetInventory() const
        {
                return PlayerInv;
        }
 
        void SetPlayerSafeLocation(const FVector&amp; InLoc)
        {
                PlayerSafeLocation = InLoc;
        }
 
        FORCEINLINE FVector GetPlayerSafeLocation() const
        {
                return PlayerSafeLocation;
        }
 
        void ClearData();
 
protected:
 
        UPROPERTY()
        class UMasteringInventory* PlayerInv;
 
        bool bPersistPlayerInventory;
        FVector PlayerSafeLocation;
};<br/><br/><br/></pre>
<p>As you can see above, this gives us a few pieces of persistent data that we'd like to survive loading and saving cycles.</p>
<p>Next, some helper functions to get all of this working, and to make setting the player's inventory and cleaning up our own state in the game instance simple:</p>
<pre>static UMasteringGameInstance* Instance = nullptr;
 
UMasteringGameInstance* UMasteringGameInstance::GetInstance()
{
        checkf(Instance != nullptr, TEXT("Someone is trying to use the game instance before it has initialized!"));
 
        return Instance;
}
 
void UMasteringGameInstance::Init()
{
        Super::Init();
 
        Instance = this;
 
        AddToRoot();
}
 
void UMasteringGameInstance::BeginDestroy()
{
        ClearData();
        Super::BeginDestroy();
}
 
void UMasteringGameInstance::FinishDestroy()
{
        Super::FinishDestroy();
}
 
void UMasteringGameInstance::SetPlayerInventory(class UMasteringInventory* Inv)
{
        if (PlayerInv == nullptr)
        {
                PlayerInv = NewObject&lt;UMasteringInventory&gt;(this, TEXT("PlayerInventory"));
        }
 
        PlayerInv-&gt;CopyFromOther(Inv);
}
 
void UMasteringGameInstance::ClearData()
{
        bPersistPlayerInventory = false;
        PlayerInv = nullptr;
        PlayerSafeLocation = FVector::ZeroVector;
}</pre>
<p>At this point, <kbd>BeginDestroy</kbd> and <kbd>FinishDestroy</kbd> probably won't need to both be here for us; but it's usually a good idea with static data holders such as this to have both. In <kbd>FinishDestroy</kbd>, if nothing else, you can put in safeguards to make sure no code after a session uses this same instance of the <kbd>GameInstance</kbd> without calling <kbd>Init</kbd> first, and clean up any remaining issues (you can even set <kbd>Instance</kbd> back to <kbd>nullptr</kbd> if you want to be extra safe). <kbd>BeginDestroy</kbd> for reference is the place to immediately clear out any data that any other classes might look to and make use of. We'll have a couple of those once we start this load/save task in earnest ( for example you definitely don't want to be in the middle of a load/save cycle, quit the game, and then upon restarting it have your variables set to what they were set to by that load/save starting). Be sure this point to go to Settings, Project Settings, and in Maps and Modes, set your game instance to <kbd>MasteringGameInstance</kbd>.</p>
<p>Next, to consolidate and abstract our game loading code a bit, we'll make a new Blueprint Function Library C++ class (which almost by definition is a collection of static functions, which is just what we need here, even if it's not necessarily ever called from blueprint):</p>
<pre>class MASTERING_API LoadSaveLibrary
{
public:
        LoadSaveLibrary();
        ~LoadSaveLibrary();
 
        UFUNCTION(BlueprintCallable)
        static void LoadGameFile(FString SaveFile, UWorld* World);
 
        UFUNCTION(BlueprintCallable)
        static void SaveGameFile(FString SaveFile, UWorld* World);
 
        static void OnGameLoadedFixup(UWorld* World);
 
        static void FixupPlayer(UWorld* World, class AMasteringCharacter* Char);
 
protected:
        static TArray&lt;uint8&gt; BinaryData;
};</pre>
<p class="mce-root"/>
<p>And refactor the <kbd>MainMenuWidget</kbd> class to move huge swathes of code here where it's more appropriate going forward, making that UI class much more focused and specific. Also, we now have some extra fix-up code that adjusts our player's position and accounts for persisting the current inventory through a load cycle, like we want when returning to a level we previously visited:</p>
<pre>TArray&lt;uint8&gt; LoadSaveLibrary::BinaryData;
 
LoadSaveLibrary::LoadSaveLibrary()
{
}
 
LoadSaveLibrary::~LoadSaveLibrary()
{
}
 
void LoadSaveLibrary::LoadGameFile(FString SaveFile, UWorld* World)
{
        FString outPath = FPaths::ProjectSavedDir() + SaveFile;
        if (!FFileHelper::LoadFileToArray(BinaryData, *outPath))
        {
                UE_LOG(LogTemp, Warning, TEXT("%s"), *(FString("Game Load Failed: ") + outPath));
                return;
        }
 
        checkSlow(World != nullptr);
        FMemoryReader FromBinary = FMemoryReader(BinaryData, true);
        FromBinary.Seek(0);
 
        FGameSavedData SaveGameData;
        FromBinary &lt;&lt; SaveGameData;
 
        FromBinary.FlushCache();
        FromBinary.Close();
 
        UMasteringGameInstance* gameInst = UMasteringGameInstance::GetInstance();
        FVector playerSafeLoc = SaveGameData.PlayerSafeLocation;
        gameInst-&gt;SetPlayerSafeLocation(playerSafeLoc);
 
        FString mapName = SaveGameData.MapName.ToString();
 
        FString currentMapName = World-&gt;GetMapName();
 
        currentMapName.Split("UEDPIE_0_", nullptr, &amp;currentMapName);
 
        if (mapName == currentMapName)
        {
                World-&gt;ServerTravel("?Restart", true);
        }
        else
        {
                UGameplayStatics::OpenLevel(World, *mapName);
        }
}</pre>
<p>Above you can see the method of loading, if we're going to the same world we're already on, we tell the world to restart essentially, otherwise, we open the new level.  We also save out the player's current position as "safe" as we can be confident it is a valid position for the player to occupy and we might need it if we're transitioning back to this level later.</p>
<pre>void LoadSaveLibrary::SaveGameFile(FString SaveFile, UWorld* World)
{
        checkSlow(World != nullptr);
        FGameSavedData SaveGameData;
        FString outPath = FPaths::ProjectSavedDir() + SaveFile;
 
        SaveGameData.Timestamp = FDateTime::Now();
 
        FString mapName = World-&gt;GetMapName();
 
        mapName.Split("UEDPIE_0_", nullptr, &amp;mapName);
 
        SaveGameData.MapName = *mapName;
 
        UMasteringGameInstance* gameInst = UMasteringGameInstance::GetInstance();
        SaveGameData.PlayerSafeLocation = gameInst-&gt;GetPlayerSafeLocation();
        gameInst-&gt;SetPlayerSafeLocation(FVector::ZeroVector); // so this will not be valid in future saves unless set again
 
        TArray&lt;AActor*&gt; Actors;
        UGameplayStatics::GetAllActorsWithInterface(World, USavedActorInterface::StaticClass(), Actors);
 
        TArray&lt;FActorSavedData&gt; SavedActors;
        for (auto Actor : Actors)
        {
                FActorSavedData ActorRecord;
                ActorRecord.MyName = FName(*Actor-&gt;GetName());
                ActorRecord.MyClass = Actor-&gt;GetClass()-&gt;GetPathName();
                ActorRecord.MyTransform = Actor-&gt;GetTransform();
                ActorRecord.MyVelocity = Actor-&gt;GetVelocity();
 
                FMemoryWriter MemoryWriter(ActorRecord.MyData, true);
                FSaveGameArchive Ar(MemoryWriter);
                AMasteringCharacter* Mast = Cast&lt;AMasteringCharacter&gt;(Actor);
 
                ISavedActorInterface::Execute_ActorSaved(Actor);
 
                Actor-&gt;Serialize(Ar);
 
                if (Mast != nullptr)
                {
                        UMasteringInventory* Inv = Mast-&gt;GetInventory();
                        SaveGameData.InventoryData.CurrentWeapon = Inv-&gt;GetCurrentWeapon()-&gt;GetPathName();
                        SaveGameData.InventoryData.CurrentWeaponPower = Inv-&gt;GetCurrentWeaponPower();
                        for (FWeaponProperties weapon : Inv-&gt;GetWeaponsArray())
                        {
                                FInventoryItemData data;
                                data.WeaponClass = weapon.WeaponClass-&gt;GetPathName();
                                data.WeaponPower = weapon.WeaponPower;
                                data.Ammo = weapon.Ammo;
                                data.TextureClass = weapon.InventoryIcon-&gt;GetPathName();
 
                                SaveGameData.InventoryData.WeaponsArray.Add(data);
                        }
                }
 
                SavedActors.Add(ActorRecord);
        }
 
        FBufferArchive SaveData;
 
        SaveGameData.SavedActors = SavedActors;
 
        SaveData &lt;&lt; SaveGameData;
 
        FFileHelper::SaveArrayToFile(SaveData, *outPath);
 
        SaveData.FlushCache();
        SaveData.Empty();
}</pre>
<p>Saving is where the real work is done, and following the flow can be a bit tricky; but if you collapse the implementation of the actor loop above, the rest is pretty straight-forward, get the safe-location, clear out the safe-location (for clarity), then iterate those actors, serialize to our output, and save that as a file.</p>
<pre>void LoadSaveLibrary::FixupPlayer(UWorld* World, class AMasteringCharacter* Char)
{
        UMasteringGameInstance* gameInst = UMasteringGameInstance::GetInstance();
 
        // Assuming we found our player character and saved out some inventory, this is where we do its custom serialization and fix-up
        if (Char != nullptr)
        {
                if (!gameInst-&gt;GetPlayerSafeLocation().IsZero())
                {
                        Char-&gt;SetActorLocation(gameInst-&gt;GetPlayerSafeLocation());
                }
 
                if (gameInst-&gt;ShouldPersistInventory())
                {
                        UMasteringInventory* NewInv = NewObject&lt;UMasteringInventory&gt;(Char, TEXT("PlayerInventory"), RF_Transient);
 
                        checkf(gameInst-&gt;GetInventory() != nullptr, TEXT("Game Instance is trying to persist inventory with no inventory setup!"));
                        NewInv-&gt;CopyFromOther(gameInst-&gt;GetInventory(), Char);
 
                        Char-&gt;SetInventory(NewInv);
                        NewInv-&gt;SetupToCurrent();
                }
                else if (BinaryData.Num() &gt; 0)
                {
                        FMemoryReader FromBinary = FMemoryReader(BinaryData, true);
                        FromBinary.Seek(0);
 
                        FGameSavedData SaveGameData;
                        FromBinary &lt;&lt; SaveGameData;
 
                        UMasteringInventory* NewInv = NewObject&lt;UMasteringInventory&gt;(Char, TEXT("PlayerInventory"), RF_Transient);
 
                        Char-&gt;SetInventory(NewInv);
 
                        FWeaponProperties propsEquipped;
                        for (FInventoryItemData ItemData : SaveGameData.InventoryData.WeaponsArray)
                        {
                                FWeaponProperties props;
                                props.WeaponClass = FindObject&lt;UClass&gt;(ANY_PACKAGE, *ItemData.WeaponClass);
                                props.InventoryIcon = FindObject&lt;UTexture2D&gt;(ANY_PACKAGE, *ItemData.TextureClass);
                                props.WeaponPower = ItemData.WeaponPower;
                                props.Ammo = ItemData.Ammo;
 
                                if (ItemData.WeaponClass == SaveGameData.InventoryData.CurrentWeapon)
                                        propsEquipped = props;
 
                                NewInv-&gt;AddWeapon(props);
                        }
 
                        Char-&gt;GetInventory()-&gt;SelectWeapon(propsEquipped);
                }
        }
}</pre>
<p>Fixing up the player is a special case that takes a lot of delicate work so is included here in its full form.  It's quite tricky to get all of the properties of the player put back to where we wanted them at the time of saving, but take the time to go through (and step through in your IDE with breakpoints!) the above code a couple of times.  Getting this right, and starting the precedent of it <em>being</em> right from the start of a load/save system like this is critical.  Take the time to understand it and when implementing it, to get it right, and test, test, test!</p>
<p>The changes needed to the menu widget class should be self-evident, but this can be seen in a checkpoint in the GitHub project if necessary. This allows us to take advantage of the loading and saving code from essentially anywhere C++ (or even blueprint).</p>
<p class="mce-root"/>
<p>So now, really our only missing piece is a new trigger box type that has a little bit of special C++ code, adjusting our load/save process to ignore loading the inventory saved at save time, and restoring inventory at level-switch time. So, two quick steps: make a new trigger box subclass, and add the player inventory and volume's safe position to the game instance. So, naming our new volume <kbd>LevelTransitionVolume</kbd> and giving it some functionality with added variables and functions to the game instance, we can now transition with our player's inventory and the rest loaded from the save game of where we are going, and if we're just switching levels, we keep the player's current inventory (and if necessary, any other information). If we're doing a full load, of course we need to restore what was saved.</p>
<p>The logic for this volume, in which we'll replace the two volumes in the two levels used previously for testing, looks like this:</p>
<pre>void ALevelTransitionVolume::NotifyActorBeginOverlap(AActor* OtherActor)
{
        AMasteringCharacter* Mast = Cast&lt;AMasteringCharacter&gt;(OtherActor);
        UWorld* World = GetWorld();
 
        if (Mast != nullptr)
        {
                UMasteringGameInstance* gameInst = UMasteringGameInstance::GetInstance();
                gameInst-&gt;SetPersistInventory();
 
                AMasteringCharacter* Char = Cast&lt;AMasteringCharacter&gt;(World-&gt;GetFirstPlayerController()-&gt;GetPawn());
                check(Char != nullptr);
 
                gameInst-&gt;SetPlayerInventory(Char-&gt;GetInventory());
 
                FString currentMapName = World-&gt;GetMapName();
                currentMapName.Split("UEDPIE_0_", nullptr, &amp;currentMapName); // strip out PIE prefix if in PIE
                FString toMapName = TransitionLevel;
 
                FString fromFile = currentMapName + TEXT("_to_") + toMapName + TEXT(".sav");
                FString toFile = toMapName + TEXT("_to_") + currentMapName + TEXT(".sav");
 
                gameInst-&gt;SetPlayerSafeLocation(GetPlayerSafeLocation());
 
                // always save on our way out so we can restore the state on the way back
                LoadSaveLibrary::SaveGameFile(fromFile, World);
 
                if (FPaths::FileExists(FPaths::ProjectSavedDir() + toFile))
                {
                        LoadSaveLibrary::LoadGameFile(toFile, World);
                }
                else
                {
                        UGameplayStatics::OpenLevel(World, *toMapName);
                }
        }
}</pre>
<p>So now we're transitioning to the new level, and have saved where we were at the time we left the current one.</p>
<pre>void LoadSaveLibrary::OnGameLoadedFixup(UWorld* World)
{
        if (BinaryData.Num() == 0)
        {
                checkSlow(World-&gt;GetFirstPlayerController() != nullptr);
                AMasteringCharacter* charPawn = Cast&lt;AMasteringCharacter&gt;(World-&gt;GetFirstPlayerController()-&gt;GetPawn());
 
                FixupPlayer(World, charPawn);
                return;
        }
 
        FMemoryReader FromBinary = FMemoryReader(BinaryData, true);
        FromBinary.Seek(0);
 
        FGameSavedData SaveGameData;
        FromBinary &lt;&lt; SaveGameData;
 
        FromBinary.FlushCache();
        BinaryData.Empty();
        FromBinary.Close();
 
        TArray&lt;AActor*&gt; Actors;
        UGameplayStatics::GetAllActorsWithInterface(World, USavedActorInterface::StaticClass(), Actors);
 
        TArray&lt;FActorSavedData&gt; ActorDatas = SaveGameData.SavedActors;
 
        AMasteringCharacter* Char = nullptr; // if ever more than one, we'll need an array and a map to their inventory
 
        // iterate these arrays backwards as we will remove objects as we go, can also use iterators, but RemoveAt is simpler here for now
        for (int i = Actors.Num() - 1; i &gt;= 0; --i)
        {
                AActor* Actor = Actors[i];
 
                for (int j = ActorDatas.Num() - 1; j &gt;= 0; --j)
                {
                        FActorSavedData ActorRecord = ActorDatas[j];
 
                        // These are actors spawned into the world that we also found in our save data (TODO: use TArray intersection?)
                        if (ActorRecord.MyName == *Actor-&gt;GetName())
                        {
                                FMemoryReader MemoryReader(ActorRecord.MyData, true);
                                FSaveGameArchive Ar(MemoryReader);
 
                                AMasteringCharacter* Mast = Cast&lt;AMasteringCharacter&gt;(Actor);
                                if (Mast != nullptr)
                                {
                                        Char = Mast;
                                }
 
                                Actor-&gt;Serialize(Ar);
                                Actor-&gt;SetActorTransform(ActorRecord.MyTransform);
                                ISavedActorInterface::Execute_ActorLoaded(Actor);
 
                                APawn* pawn = Cast&lt;APawn&gt;(Actor);
                                if (pawn != nullptr)
                                {
                                        // controller needs the rotation too as this may set the pawn's rotation once play starts
                                        AController* controller = pawn-&gt;GetController();
                                        controller-&gt;ClientSetRotation(ActorRecord.MyTransform.Rotator());
                                }
 
                                ActorDatas.RemoveAt(j);
                                Actors.RemoveAt(i);
                                break;
                        }
                }
        }
 </pre>
<p class="mce-root"/>
<p>We'll do the player here at this point, then finish off with finding any actors we found saved data for that haven't already respawned (typically projectiles we made, for example):</p>
<pre>        FixupPlayer(World, Char);
 
        // These are actors in our save data, but not in the world, spawn them
        for (FActorSavedData ActorRecord : ActorDatas)
        {
                FVector SpawnPos = ActorRecord.MyTransform.GetLocation();
                FRotator SpawnRot = ActorRecord.MyTransform.Rotator();
                FActorSpawnParameters SpawnParams;
                // if we were in a space when saved, we should be able to spawn there again when loaded, but we could also
                // be overlapping an object that loaded, but will be subsequently destroyed below as it was there at level start
                // but not there at save time
                SpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;
                SpawnParams.Name = ActorRecord.MyName;
                UClass* SpawnClass = FindObject&lt;UClass&gt;(ANY_PACKAGE, *ActorRecord.MyClass);
                if (SpawnClass)
                {
                        AActor* NewActor = GWorld-&gt;SpawnActor(SpawnClass, &amp;SpawnPos, &amp;SpawnRot, SpawnParams);
                        FMemoryReader MemoryReader(ActorRecord.MyData, true);
                        FSaveGameArchive Ar(MemoryReader);
                        NewActor-&gt;Serialize(Ar);
                        NewActor-&gt;SetActorTransform(ActorRecord.MyTransform);
                        ISavedActorInterface::Execute_ActorLoaded(NewActor);
                }
        }
 
        // These are actors in the world that are not in our save data, destroy them (for example, a weapon pickup that was, well, picked up)
        for (auto Actor : Actors)
        {
                Actor-&gt;Destroy();
        }
}</pre>
<p>After replacing the old trigger volumes and setting the right Transition Level names on the new boxes in the levels, of course we can remove the old logic in the level blueprints too. So, as seen previously, if we already have a save file matching the transition of to/from that we are about to do, load that save file. In any case, we will still preserve the player's inventory because of the lines setting this in the game instance near the top of this function, and save the state in our from/to form before leaving.</p>
<p>To allow our inventory to easily be transferred around, we can add a couple of utility functions. Note: it's also possible to persist <kbd>UObject </kbd> instances (other than the game instance) across level loading, but this often has unforeseen consequences with objects that reference other objects, which may be destroyed during a level load. So, in this case, we just make copying of inventory objects simple:</p>
<pre>void UMasteringInventory::CopyFromOther(UMasteringInventory *Other, class AMasteringCharacter* ownerOverride /* = nullptr */)
{
        Reset();
 
        TArray&lt;FWeaponProperties&gt;&amp; otherProps = Other-&gt;GetWeaponsArray();
        for (auto prop : otherProps)
        {
                WeaponsArray.Add(prop);
        }
 
        DefaultWeaponPickup = Other-&gt;DefaultWeaponPickup;
        CurrentWeapon = Other-&gt;GetCurrentWeapon();
        CurrentWeaponPower = Other-&gt;GetCurrentWeaponPower();
        MyOwner = ownerOverride == nullptr ? Other-&gt;GetOwningCharacter() : ownerOverride;
}
 
void UMasteringInventory::Reset()
{
        WeaponsArray.Empty();
        CurrentWeapon = nullptr;
        CurrentWeaponPower = -1;
        MyOwner = nullptr;
}
 
void UMasteringInventory::SetupToCurrent()
{
        for (auto WeaponIt = WeaponsArray.CreateConstIterator(); WeaponIt; ++WeaponIt)
        {
                const FWeaponProperties &amp;currentProps = *WeaponIt;
                OnWeaponAdded.Broadcast(currentProps);
                if (currentProps.WeaponClass == CurrentWeapon)
                {
                        SelectWeapon(currentProps);
                }
        }
}</pre>
<p>Now the last thing to do is to make an actual blueprint of the new trigger box and give it a proper safe-location where we can place the player. If we don't do this, the player will be continually placed at the same spot they saved from (when they intersected the box), and you'll get the player bouncing back and forth between the two levels infinitely. For those looking closely, you'll see in the construction script that collision is initially disabled, and then the timer here re-enables it. This is because we need one tick of the game world to move the player to the updated position, and if we don't briefly disable overlap events, we get the ping-pong behavior mentioned earlier when we do try to do the move:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/7d6400fa-245f-43ea-80c4-4b4d51a87d55.png"/></p>
<p class="mce-root"/>
<p>At this point, the player can transition back and forth between our two playable levels, have inventory persist at the current level, be placed at a safe position so they don't immediately go back to the other level, and each level saves and restores the rest of its state like a normal load of a save. The only thing now missing as a general feature would be a spinning icon or fade-to-black and progress bar during the loading itself. UE4 certainly allows for these kinds of things, which update outside of the main game thread tick, but will not be specifically implemented here as we still have another major topic to delve into: streaming levels.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Perchance to stream?</h1>
                
            
            
                
<p>So far we have now used triggering elements to load a specific level. Streaming, as it's commonly known, is another method of loading levels on demand and allows for a much larger playing area without having to have all the encompassing actors loaded at any given time. Unreal allows this in two distinct ways, but they can complement each other: streaming volumes, and world composition. We'll briefly explore these here, but they are great solutions for giving a huge playing area and keeping loaded memory at any given moment at a reasonable level. There are, of course, some drawbacks to this as well.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Streaming advantages and disadvantages</h1>
                
            
            
                
<p>The advantages of streaming are probably obvious. As already noted, there's big spaces and manageable memory load. The disadvantages are probably a little less obvious, but are clearly illustrated with our first checkpoint here in the GitHub project: essentially duplicating (minus skybox and lighting) the <kbd>MasteringTestMap</kbd> into two other levels that are offset from it and streaming those in with streaming volumes. To do this, first go to the main editor Window menu and select Levels. Two new levels have been added with their offsets and each has a NavMesh volume around it to generate proper meshes. These meshes, when the levels are loaded, will combine.</p>
<p>When a level is streamed out, however, all the actors in it will be destroyed, and when it is streamed back in, they will all be recreated as if loaded anew. So in this example, there are two new levels, MasteringTestMapW1 and W2. MasteringTestMap will be our persistent level. This is the top-most level, which is <em>always</em> loaded. All streaming volumes also need to be placed in this level. So, as seen here, in a rough, demonstrative way, when starting MasteringTestMap and turning 90-degrees left and running, you see there is a short overlap of a few meters for the volume that streams in W1, and similarly there is a small overlap of W1's map and the streaming volume for W2. Normally you want these volumes to encompass any time the player can see that area, but in this case, we want to show streaming out: so if you run left, before hitting the edge of MasteringTestMap, W1 streams in. A similar thing will happen if you continue to W2. If you go further into W2 you'll see that W1 then streams out when the player leaves W1's volume, and similarly when heading back through W1 you can watch as W2 quickly streams out. Now come our problems. In W2 there is a volume to spawn more countess enemies. If you go slowly and carefully, they can chase you back into W1, but if you run quickly, W2 streams out and the countesses fall out of the world. Also, when streaming W1 back in, any weapon pickups that were previously collected now return.</p>
<p>Dynamic objects and streaming like this are the biggest issue to reconcile: how do you inform the newly loaded level that it should not respawn weapon pickups placed on the ground? How do the countesses handle their home level streaming out?  This utterly breaks their return-home behavior as they literally can't do so (their pathfinding fails). Of course, it's possible to save the state of objects spawned or destroyed in various levels when their streamed level streams out, either in the persistent level in a small way (such as simply storing the actor's position and state) or possibly in the game instance as we with the player's inventory across the level loads in the previous section. However, this is a lot of upkeep, so as with many features like this, if you intend to use streaming be sure to decide early and educate any other team-members on how to properly set these things up so your player feels like it is a seamless world. But first, let's see a quick difference between these two streaming methods and observe the difficulties mentioned.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Example streaming and best practices</h1>
                
            
            
                
<p>To stream these levels, in the Levels window, you first have to click the Levels drop-down at the top and click on Add Existing.</p>
<p>Adding W1 and W2 allows us to select them and then hook their loading state to the volumes shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/866065cb-a875-4596-8330-4096b918f137.png"/></p>
<p>With those added, and the volumes added like so to MasteringTestMap, it should look like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/ce29f67a-44ee-4676-8ac1-695607c63615.png"/></p>
<p class="mce-root"/>
<p>Back in the levels window, clicking the plus button on the volumes array allows us to then use the eye-dropper to drag into the world and select the right volume, or simply use the drop-down and pick the volume we want to associate with this level. Again, note the small overlaps. To avoid players noticing the streaming, it's usually best to make a much larger overlap area and also potentially bring in a fog-distance so the actual loading is not so obvious. For our instructive case, again, we want it to be obvious here. Now, with these pieces in place you can run West and see the levels come in and drop out as the player (actually the camera, to be exact) enters these areas and leaves them.  And again, with a couple of test runs, it should be obvious how the drawbacks mentioned are clearly visible if not accounted for as levels stream in and out. Should a countess never leave her home level? Should she disappear when her home level streams out? Should pickups somehow know they've previously been picked up and either not spawn or destroy themselves, like we do with pick-ups picked up when loading a save game? These are all questions each project must decide, weighing the complexity of maintaining such a system versus the player experience and not breaking their immersion.</p>
<p>Using volumes can be a great way to manually control exact levels of detail. For example, you can stream in basic physics and a bit of static mesh geometry with a very large volume to avoid any worries of the falling out of world problems such as the countess has, while then having an additional level with a smaller volume that only loads in when the player is closer, which loads a large number of cosmetic geometry that doesn't impact gameplay. A limitation of volume-based streaming, though, is that levels can only extend from the origin of the persistent level out to <kbd>WORLD_MAX</kbd>, which is about 2 km (or from the start, 1 km East/West, 1 km North/South). In most games, this is plenty. For an open world (and don't forget you can still hard-transition to other persistent levels, such as indoor areas!) within this size limitation, we found a brick-like tiling was best for overlapping levels to be loaded. So, when you're in the level in the center, the levels around it in this pattern would be loaded:</p>
<div><img src="img/227e7fa7-bedb-4bd9-be9c-cb9d62905b45.png" style="width:14.75em;height:14.42em;"/></div>
<p>This way you can also work with level designers so that the sum memory of those seven levels is always less than a certain cap. So, for example, you could have some low-detail areas with a very high-detail area in the center, but of course as you move around and this pattern repeats, the sum of any seven loaded levels should be maintained under that agreed-upon cap. And the nice part is that server-based multiplayer games already respect this kind of streaming and have no problems tracking players across these boundaries from their clients. If your world needs a much larger or nearly boundless play space, world composition is worth exploring.</p>
<p>World composition is a great way to create automated, grid-based tiling built into UE4. This is particularly useful for very large worlds where the player can then travel almost endlessly in any given direction, but requires a large effort by artists or level designers typically to make these sections and make them match exactly at their borders. A perfect application for world composition is a single-player open-world game where exploration and a truly vast play area are the goal. As this is a bit niche, and Epic themselves have done a very nice job of documenting the feature, a link will be added to the <em>Further reading</em> section.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>From the start of this chapter to its completion, we have now demonstrated how to persist level state and player state independently across traditional level loads, as well as the basics of streaming levels as the player moves around. These are fundamental to almost all conceivable games in UE4 and should now form the basis of whatever strategy works best for a team and project going forward. Always remember: make these decisions early! It can be nearly impossible, for example, to retrofit levels built assuming a hard level-load into a streaming model, but if you adopt that streaming model and help your team stick to its limits from day one, this is one worry that won't haunt you late in a project cycle.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>What existing classes or objects can be used in UE4 to implement level loading with no new changes?</li>
<li>What are some limitations of using only these methods?</li>
<li>What is the scope of the lifetime of the game instance object?</li>
<li>How is the game instance used to persist data when opening a new level or loading an existing one's state?</li>
<li>What is the purpose of abstracting level load/save code to a blueprint function library?</li>
<li>Why is the player's inventory copied rather than scoping a <kbd>UObject</kbd> to the game instance?</li>
<li>What are the major drawbacks of volume-based streaming?</li>
<li>Which types of games should definitely use world composition?</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<p>World composition in UE4:</p>
<p><a href="https://docs.unrealengine.com/en-US/Engine/LevelStreaming/WorldBrowser">https://docs.unrealengine.com/en-US/Engine/LevelStreaming/WorldBrowser</a></p>


            

            
        
    </body></html>