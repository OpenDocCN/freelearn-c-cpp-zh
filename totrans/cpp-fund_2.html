<html><head></head><body>
		<div class="Content" id="_idContainer023">
			<h1 id="_idParaDest-47"><em class="italics"><a id="_idTextAnchor049"/>Chapter 2</em></h1>
		</div>
		<div class="Content" id="_idContainer024">
			<h1 id="_idParaDest-48"><a id="_idTextAnchor050"/>Functions</h1>
		</div>
		<div class="Content" id="_idContainer025">
			<h2>Lesson Objectives</h2>
			<p>By the end of this chapter, you will be able to:</p>
			<ul>
				<li class="bullets">Explain what functions are and how to declare them</li>
				<li class="bullets">Utilize local and global variables </li>
				<li class="bullets">Pass arguments to functions and return values from functions </li>
				<li class="bullets">Create overloaded functions and call them appropriately </li>
				<li class="bullets">Apply the concept of namespaces in organizing functions </li>
			</ul>
			<p>In this chapter, we are going to look at functions in C++, how to use them, and why we would want to use them.</p>
		</div>
		<div class="Content" id="_idContainer027">
			<h2 id="_idParaDest-49"><a id="_idTextAnchor051"/>Introduction</h2>
			<p>Functions are a core tool in a programmer's toolkit for writing maintainable code. The concept of a function is common in almost every programming language. Functions have different names in various languages: procedures, routines, and many more, but they all have two main characteristics in common:</p>
			<ul>
				<li>They represent a sequence of instructions grouped together.</li>
				<li>The sequence of instructions is identified by a name, which can be used to refer to the function.</li>
			</ul>
			<p>The programmer can call, or invoke a function when the functionalities provided by the function are needed.</p>
			<p>When the function is called, the sequence of instructions is executed. The caller can also provide some data to the function to be used in operations within the program. The following are the main advantages of using functions:</p>
			<ul>
				<li><strong class="bold">Reduces repetition</strong>: It often occurs that a program needs to repeat the same operations in different parts of the codebase. Functions allow us to write a single implementation that is carefully tested, documented, and of high quality. This code can be called from different places in the codebase, which enables code reusability. This, in turn, increases the productivity of the programmer and the quality of the software.</li>
				<li><strong class="bold">Boosts code readability and modification</strong>: Often, we need several operations to implement a functionality in our program. In these cases, grouping the operations together in a function and giving a descriptive name to the function helps to express what we want to do instead of how we do it.<p>Using functions greatly increases the readability of our code because it's now composed of descriptive names of what we are trying to achieve, without the noise of how the result is achieved. </p><p>In fact, it is easier to test and debug as you may only need to modify a function without having to revisit the structure of the program.</p></li>
				<li><strong class="bold">Higher level of abstraction</strong>: We can give a meaningful name to the function to represent what it should achieve. This way, the calling code can be concerned with what the function is supposed to do, and it does not need to know how the operations are performed.<h4>Note</h4><p class="callout">Abstraction is the process of extracting all relevant properties from a class and exposing them, while hiding details that are not important for a specific usage.</p><p class="callout">Let's take a tree as an example. If we were to use it in the context of an orchard, we could abstract the tree to be a "machine" that takes a determined amount of space and, given sunlight, water, and fertilizers, produces a certain number of fruits per year. The property we are interested in is the tree's fruit production ability, so we want to expose it and hide all the other details that are not relevant to our case.</p><p class="callout">In computer science, we want to apply the same concept: capture the key fundamental properties of a class without showing the algorithm that implements it. </p></li>
			</ul>
			<p>A prime example of this is the <strong class="inline">sort</strong> function, which is present in many languages. We know what the function expects and what it is going to do, but rarely are we aware of the algorithm that is used to do it, and it might also change between different implementations of the language.</p>
			<p>In the following sections, we will demystify how function declaration and definition works.<a id="_idTextAnchor052"/></p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor053"/>Function Declaration and Definition</h2>
			<p>A <strong class="inline">function</strong> declaration has the role of telling the compiler the name, the parameters, and the return type of a function. After a function has been declared, it can be used in the rest of the program.</p>
			<p>The definition of the function specifies what operations a function performs.</p>
			<p>A declaration is composed of the type of the returned value, followed by the name of the function and by a list of parameters inside a pair of parentheses. These last two components form the signature of the function. The syntax of a function declaration is as follows:</p>
			<p class="snippet">// Declaration: function without body</p>
			<p class="snippet">return_type function_name( parameter list );</p>
			<p>If a function returns nothing, then  the type <strong class="inline">void</strong> can be used, and if a function is not expecting any parameters the list can be empty.</p>
			<p>Let's look at an example of a function declaration:</p>
			<p class="snippet">void doNothingForNow();</p>
			<p>Here, we declared a function named <strong class="inline">doNothingForNow()</strong>, which takes no arguments and returns nothing. After this declaration, we can call the <strong class="inline">doNothingForNow()</strong> function in our program.</p>
			<p>To call a function that does not have any parameters, write the name of the function followed by a pair of parentheses.</p>
			<p>When a function is called, the execution flow goes from the body of the function currently being executed to the body of the called function.</p>
			<p>In the following example, the execution flow starts at the beginning of the body of <strong class="inline">main</strong> function and starts executing its operations in order. The first operation it encounters is the call to <strong class="inline">doNothingForNow()</strong>. At that point, the execution flow goes into the body of <strong class="inline">doNothingForNow()</strong>.</p>
			<p>When all the operations inside a function are executed, or the function instructs them to go back to the caller, the execution flow resumes from the operation after the function call.</p>
			<p>In our example, the operation after the function call prints <strong class="inline">Done</strong> on the console:</p>
			<p class="snippet"><a id="_idTextAnchor054"/>#include &lt;iostream&gt;</p>
			<p class="snippet"><a id="_idTextAnchor055"/></p>
			<p class="snippet"><a id="_idTextAnchor056"/>void doNothingForNow();</p>
			<p class="snippet">int main() {</p>
			<p class="snippet">  doNothingForNow ();</p>
			<p class="snippet">  std::cout &lt;&lt; "Done";</p>
			<p class="snippet">}</p>
			<p>If we were to compile this program, the compilation would succeed, but linking would <em class="italics">fail</em>.</p>
			<p>In this program, we instructed the compiler that a function called <strong class="inline">doNothingForNow()</strong> exists and then we invoked it. The compiler generates an output that calls <strong class="inline">doNothingForNow()</strong>.</p>
			<p>The linker then tries to create an executable from the compiler output, but since we did not define <strong class="inline">doNothingForNow()</strong>, it cannot find the function's definition, so it fails.</p>
			<p>To successfully compile the program, we need to define <strong class="inline">doNothingForNow()</strong>. In the next section, we will explore how to define a function using the same example.</p>
			<h3 id="_idParaDest-51"><a id="_idTextAnchor057"/>Defining a Function</h3>
			<p>To define a function, we need to write the same information that we used for the declaration: the return type, the name of the function, and the parameter list, followed by the function body. The function body delimits a new scope and is composed of a sequence of statements delimited by curly braces.</p>
			<p>When the function is executed, the statements are executed in order:</p>
			<p class="snippet">// Definition: function with body</p>
			<p class="snippet">return_type function_name( parameter_list ) {</p>
			<p class="snippet">  statement1;</p>
			<p class="snippet">  statement2;</p>
			<p class="snippet">...</p>
			<p class="snippet">  last statement;</p>
			<p class="snippet">}</p>
			<p>Let's fix the program by adding the body for <strong class="inline">doNothingForNow()</strong>:</p>
			<p class="snippet">void doNothingForNow() {</p>
			<p class="snippet">  // Do nothing</p>
			<p class="snippet">}</p>
			<p>Here, we defined <strong class="inline">doNothingForNow()</strong> with an empty body. This means that as soon as the function execution starts, the control flow returns to the function that called it.</p>
			<h4>Note</h4>
			<p class="callout">When we define a function, we need to make sure that the signature (the return value, the name, and the parameters) are the same as the declaration.</p>
			<p class="callout">The definition counts as a declaration as well. We can skip the declaration if we define the function before calling it.</p>
			<p>Let's revisit our program now since we have added the definition for our function:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">void doNothingForNow() {</p>
			<p class="snippet">  // do nothing</p>
			<p class="snippet">}</p>
			<p class="snippet">int main() {</p>
			<p class="snippet">  doNothingForNow();</p>
			<p class="snippet">  std::cout &lt;&lt; "Done";</p>
			<p class="snippet">}</p>
			<p>If we compile and run the program, it will succeed and show <strong class="inline">Done</strong> on the output console.</p>
			<p>In a program, there can be multiple declarations of the same function, as long as the declarations are the same. On the other hand, only a single definition of the function can exist, as mandated by the <strong class="keyword">One Definition Rule</strong> (<strong class="keyword">ODR</strong>).</p>
			<h4>Note</h4>
			<p class="callout">Several definitions of the same function may exist if compiled in different files, but they need to be identical. If they are not, then the program might do unpredictable things.</p>
			<p class="callout">The compiler is not going to warn you!</p>
			<p>The solution is to have the declaration in a <strong class="bold">header</strong> file, and the definition in an <strong class="bold">implementation</strong> file.</p>
			<p>A header file is included in many different implementation files, and the code in these files can call the function.</p>
			<p>An implementation file is compiled only once, so we can guarantee that the definition is seen only once by the compiler.</p>
			<p>Then, the linker puts all of the outputs of the compiler together, finds a definition of the function, and produces a valid executable.</p>
			<h3 id="_idParaDest-52"><a id="_idTextAnchor058"/>Exercise 3: Calling a Function from main()</h3>
			<p>In our application, we want to log errors. To do so, we have to specify a function called <strong class="inline">log(), </strong>which prints <strong class="inline">Error!</strong> to the standard output when called.</p>
			<p>Let's create a function that can be called from several files, and put it in a different header file that can be included:</p>
			<ol>
				<li>Create a file named <strong class="inline">log.h</strong> and declare a function called <strong class="inline">log()</strong> with no parameters and that returns nothing:<p class="snippet">void log();</p></li>
				<li>Now, let's create a new file, <strong class="inline">log.cpp</strong>, where we define the <strong class="inline">log()</strong> function to print to the standard output:<p class="snippet">#include &lt;iostream&gt; </p><p class="snippet">// This is where std::cout and std::endl are defined</p><p class="snippet">void log() {</p><p class="snippet">  std::cout &lt;&lt; "Error!" &lt;&lt; std::endl;</p><p class="snippet">}</p></li>
				<li>Change the <strong class="inline">main.cpp</strong> file to include <strong class="inline">log.h</strong> and call <strong class="inline">log()</strong> in the <strong class="inline">main()</strong> function:<p class="snippet">#include &lt;log.h&gt;</p><p class="snippet">int main() {</p><p class="snippet">  log();</p><p class="snippet">}</p></li>
				<li>Compile the two files and run the executable. You will see that the message <strong class="bold">Error!</strong> is printed when we execute it.</li>
			</ol>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor059"/>Local and Global Variables</h2>
			<p>The body of a function is a code block that can contain valid statements, one of which is a <strong class="bold">variable definition</strong>. As we learned in <em class="italics">Lesson 1</em>, <em class="italics">Getting Started</em>, when such a statement appears, the function declares a <strong class="bold">local variable</strong>.</p>
			<p>This is in contrast to global variables, which are the variables that are declared outside of functions (and classes, which we will look at in <em class="italics">Lesson 3</em>, <em class="italics">Classes</em>).</p>
			<p>The difference between a local and a global variable is in the <em class="italics">scope</em> in which it is declared, and thus, in who can access it.</p>
			<h4>Note</h4>
			<p class="callout">Local variables are in the function scope and can only be accessed by the function. On the contrary, global variables can be accessed by any function that can see them.</p>
			<p>It is desirable to use local variables over global variables because they enable <strong class="keyword">encapsulation</strong>: only the code inside the function body can access and modify the variable, making the variable invisible to the rest of the program. This makes it easy to understand how a variable is used by a function since its usage is restricted to the function body and we are guaranteed that no other code is accessing it.</p>
			<p>Encapsulation is usually used for three separate reasons, which we will explore in more detail in <em class="italics">Lesson 3</em>, <em class="italics">Classes</em>:</p>
			<ul>
				<li>To restrict the access to data used by a functionality</li>
				<li>To bundle together the data and the functionality that operates on it</li>
				<li>Encapsulation is a key concept that allows you to create abstractions</li>
			</ul>
			<p>On the other hand, global variables can be accessed by <em class="italics">any </em>function.</p>
			<p>This makes it hard to be sure of the function's value when interacting with them, unless we know not only what our function does, but also what all the other code in the program that interacts with the global variable does.</p>
			<p>Additionally, code that we add later to the program, might start modifying the global variable in a way that we did not expect in our function, breaking the functionality of our function without ever modifying the function itself. This makes it extremely difficult to modify, maintain, and evolve programs.</p>
			<p>The solution to this problem is to use the <strong class="inline">const</strong> qualifier so that no code can change the variable, and we can treat it as a value that never changes.</p>
			<h4>Note</h4>
			<p class="callout">Always use the <strong class="inline">const</strong> qualifier with global variables whenever possible.</p>
			<p class="callout">Try to avoid using mutable global variables.</p>
			<p class="callout">It is a good practice to use global <strong class="inline">const</strong> variables instead of using values directly in the code. They allow you to give a name and a meaning to the value, without any of the risks that come with mutable global variables.</p>
			<h3 id="_idParaDest-54"><a id="_idTextAnchor060"/>Working with Variable Objects</h3>
			<p>It is important to understand the relationship between variables, objects, and the lifetime of objects in C++ to write programs correctly.</p>
			<h4>Note</h4>
			<p class="callout">An object is a piece of data in the program's memory.</p>
			<p class="callout">A variable is a name we give to an object.</p>
			<p>There is a distinction in C++ between the scope of a variable and the lifetime of the object it refers to. The scope of a variable is the part of the program where the variable can be used.</p>
			<p>The lifetime of an object, on the contrary, is the time during execution wherein the object is valid to access.</p>
			<p>Let's examine the following program to understand the lifetime of an object:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">/* 1 */ const int globalVar = 10;</p>
			<p class="snippet">int* foo(const int* other) {</p>
			<p class="snippet">    /* 5 */ int fooLocal = 0;</p>
			<p class="snippet">     std::cout &lt;&lt; "foo's local: " &lt;&lt; fooLocal &lt;&lt; std::endl;</p>
			<p class="snippet">    std::cout &lt;&lt; "main's local: " &lt;&lt; *other &lt;&lt; std::endl;</p>
			<p class="snippet">    /* 6 */ return &amp;fooLocal;</p>
			<p class="snippet">}</p>
			<p class="snippet">int main()</p>
			<p class="snippet">{</p>
			<p class="snippet">    /* 2 */ int mainLocal = 15;</p>
			<p class="snippet">    /* 3 */ int* fooPointer = foo(&amp;mainLocal);</p>
			<p class="snippet">    std::cout &lt;&lt; "main's local: " &lt;&lt; mainLocal &lt;&lt; std::endl;</p>
			<p class="snippet">    std::cout &lt;&lt; "We should not access the content of fooPointer! It's not valid." &lt;&lt; std::endl;</p>
			<p class="snippet">    /* 4 */ return 0;</p>
			<p class="snippet">}</p>
			<div>
				<div class="IMG---Figure" id="_idContainer026">
					<img alt="Figure 2.1: Lifetime of an object" src="image/C11557_02_02.jpg"/>
				</div>
			</div>
			<h6>Figure 2.1: Lifetime of an object</h6>
			<p>The lifetime of a variable starts when it is initialized and ends when the containing block ends. Even if we have a pointer or reference to a variable, we should access it only if it's still valid. <strong class="inline">fooPointer</strong> is pointing to a variable which is no longer valid, so it should not be used!</p>
			<p>When we declare a local variable in the scope of a function, the compiler automatically creates an object when the function execution reaches the variable declaration; the variable refers to that object.</p>
			<p>When we declare a global variable instead, we are declaring it in a scope that does not have a clear duration – it is valid for the complete duration of the program. Because of this, the compiler creates the object when the program starts before any function is executed – even the <strong class="inline">main()</strong> function.</p>
			<p>The compiler also takes care of terminating the object's lifetime when the execution exits from the scope in which the variable has been declared, or when the program terminates in the case of a global variable. The termination of the lifetime of an object is usually called <strong class="keyword">destruction</strong>.</p>
			<p>Variables declared in a scope block, either local or global, are called <strong class="keyword">automatic variables</strong>, because the compiler takes care of initializing and terminating the lifetime of the object associated with the variables.</p>
			<p>Let's look at an example of a local variable:</p>
			<p class="snippet">void foo() {</p>
			<p class="snippet">  int a;</p>
			<p class="snippet">}</p>
			<p>In this case, the variable <strong class="inline">a</strong> is a local variable of type <strong class="inline">int</strong>. The compiler automatically initializes the object it refers to with what is called its <strong class="keyword">default initialization</strong> when the execution reaches that statement, and the object will be destroyed at the end of the function, again, automatically.</p>
			<h4>Note</h4>
			<p class="callout">The default initialization of basic types, such as integers, is doing nothing for us. This means that the variable <strong class="inline">a</strong> will have an unspecified value.</p>
			<p>If multiple local variables are defined, the initialization of the objects happens in the order of declaration:</p>
			<p class="snippet">void foo() {</p>
			<p class="snippet">  int a;</p>
			<p class="snippet">  int b;</p>
			<p class="snippet">}</p>
			<p>Variable <strong class="inline">a</strong> is initialized before <strong class="inline">b</strong>. Since variable <strong class="inline">b</strong> was initialized after <strong class="inline">a</strong>, its object is destroyed before the one <strong class="inline">a</strong> refers to.</p>
			<p>If the execution never reaches the declaration, the variable is not initialized. If the variable is not initialized, it is also not destroyed:</p>
			<p class="snippet">void foo() {</p>
			<p class="snippet">  if (false) {</p>
			<p class="snippet">    int a;</p>
			<p class="snippet">  }</p>
			<p class="snippet">  int b;</p>
			<p class="snippet">}</p>
			<p>Here, the variable <strong class="inline">a</strong> is never default initialized, and thus never destroyed. This is similar for global variables:</p>
			<p class="snippet">const int a = 1;</p>
			<p class="snippet">void main() {</p>
			<p class="snippet">  std::cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; std::endl;</p>
			<p class="snippet">}</p>
			<p>Variable <strong class="inline">a</strong> is initialized before the <strong class="inline">main()</strong> function is called and is destroyed after we return the value from the <strong class="inline">main()</strong> function.</p>
			<h3 id="_idParaDest-55"><a id="_idTextAnchor061"/>Exercise 4: Using Local and Global Variables in a Fibonacci Sequence</h3>
			<p>We want to write a function that returns the 10th number in a Fibonacci sequence.</p>
			<h4>Note</h4>
			<p class="callout">The <em class="italics">nth</em> Fibonacci number is defined as the sum of the <em class="italics">n-1th</em> and the <em class="italics">n-2th</em>, with the first number in the sequence being 0 and the second being 1.</p>
			<p class="callout">Example:</p>
			<p class="callout">10th Fibonacci number = 8th Fibonacci number + 9th Fibonacci number</p>
			<p>We want to use the best practice of giving a name and a meaning to values, so instead of using 10 in the code, we are going to define a <strong class="inline">const</strong> global variable, named <strong class="inline">POSITION</strong>.</p>
			<p>We will also use two local variables in the function to remember the <strong class="inline">n-1th</strong> and the <strong class="inline">n-2th</strong> number:</p>
			<ol>
				<li value="1">Write the program and include the following constant global variable after the header file:<p class="snippet">#include &lt;iostream&gt;</p><p class="snippet">const int POSITION = 10;</p><p class="snippet">const int ALREADY_COMPUTED = 3;</p></li>
				<li>Now, create a function named <strong class="inline">print_tenth_fibonacci()</strong> with the return type as <strong class="inline">void</strong>:<p class="snippet">void print_tenth_fibonacci()</p></li>
				<li>Within the function, include three local variables, named <strong class="inline">n_1</strong>, <strong class="inline">n_2</strong>, and <strong class="inline">current</strong> of type <strong class="inline">int</strong>, as shown here:<p class="snippet">  int n_1 = 1;</p><p class="snippet">  int n_2 = 0;</p><p class="snippet">  int current = n_1 + n_2;</p></li>
				<li>Let's create a <strong class="inline">for</strong> loop to generate the remaining Fibonacci numbers until we reach the 10th, using the global variables we defined previously as starting and ending indices:<p class="snippet">for(int i = ALREADY_COMPUTED; i &lt; POSITION; ++i){</p><p class="snippet">	n_2 = n_1;</p><p class="snippet">	n_1 = current;</p><p class="snippet">	current = n_1 + n_2;</p><p class="snippet">}</p></li>
				<li>Now, after the previous <strong class="inline">for</strong> loop, add the following print statement to print the last value stored in the <strong class="inline">current</strong> variable:<p class="snippet">  std::cout &lt;&lt; current &lt;&lt; std::endl;</p></li>
				<li>In the <strong class="inline">main()</strong> function, call <strong class="inline">print_tenth_fibonacci()</strong> and print the value of the 10th element of the Fibonacci sequence:<p class="snippet">int main() {</p><p class="snippet">  std::cout &lt;&lt; "Computing the 10th Fibonacci number" &lt;&lt; std::endl;</p><p class="snippet">  print_tenth_fibonacci();</p><p class="snippet">}</p></li>
			</ol>
			<p>Let's understand the variable data flow of this exercise. First, the <strong class="inline">n_1</strong> variable is initialized, then <strong class="inline">n_2</strong> is initialized, and right after that, <strong class="inline">current</strong> is initialized. And then, <strong class="inline">current</strong> is destroyed, <strong class="inline">n_2</strong> is destroyed, and finally, <strong class="inline">n_1</strong> is destroyed.</p>
			<p><strong class="inline">i</strong> is also an automatic variable in the scope that's created by the <strong class="inline">for</strong> loop, so it is destroyed at the end of the <strong class="inline">for</strong> loop scope.</p>
			<p>For each combination of <strong class="inline">cond1</strong> and <strong class="inline">cond2</strong>, identify when initialization and destruction occurs in the following program:</p>
			<p class="snippet">void foo()</p>
			<p class="snippet">  if(cond1) {</p>
			<p class="snippet">    int a;</p>
			<p class="snippet">  }</p>
			<p class="snippet">  if (cond2) {</p>
			<p class="snippet">    int b;</p>
			<p class="snippet">  }</p>
			<p class="snippet">}</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor062"/>Passing Arguments and Returning Values</h2>
			<p>In the <em class="italics">Introduction</em> section, we mentioned that the caller can provide some data to the function. This is done by passing arguments to the parameters of the function.</p>
			<p>The parameters that a function accept are part of its signature, so we need to specify them in every declaration.</p>
			<p>The list of parameters a function can accept is contained in the parentheses after the function name. The parameters in the function parentheses are comma-separated, composed by a type, and optionally an identifier.</p>
			<p>For example, a function taking two integer numbers would be declared as follows:</p>
			<p class="snippet">void two_ints(int, int);</p>
			<p>If we wanted to give a name to these parameters, <strong class="inline">a</strong> and <strong class="inline">b</strong> respectively, we would write the following:</p>
			<p class="snippet">void two_ints(int a, int b);</p>
			<p>Inside its body, the function can access the identifiers defined in the function signature as if they were declared variables. The values of the function parameters are decided when the function is called.</p>
			<p>To call a function that takes a parameter, you need to write the name of the function, followed by a list of expressions inside a pair of parentheses:</p>
			<p class="snippet">two_ints(1,2);</p>
			<p>Here, we called the <strong class="inline">two_ints</strong> function with two arguments: <strong class="inline">1</strong> and <strong class="inline">2</strong>.</p>
			<p>The arguments used to call the function initialize the parameters that the function is expecting. Inside the <strong class="inline">two_ints</strong> function, variable <strong class="inline">a</strong> will be equal to <strong class="inline">1</strong>, and <strong class="inline">b</strong> will be equal to <strong class="inline">2</strong>.</p>
			<p>Each time the function is called, a new set of parameters is initialized from the arguments that were used to call the function.</p>
			<h4>Note</h4>
			<p class="callout"><strong class="bold">Parameter</strong>: This is a variable that was defined by a function, and can be used to provide data as per the code.</p>
			<p class="callout"><strong class="bold">Argument</strong>: The value the caller wants to bind to the parameters of the function.</p>
			<p>In the following example, we used two values, but we can also use arbitrary expressions as arguments:</p>
			<p class="snippet">two_ints(1+2, 2+3);</p>
			<h4>Note</h4>
			<p class="callout">The order in which the expression is evaluated is not specified!</p>
			<p>This means that when calling <strong class="inline">two_ints(1+2, 2+3);</strong>, the compiler might first execute <strong class="inline">1+2</strong> and then <strong class="inline">2+3</strong>, or <strong class="inline">2+3</strong> and then <strong class="inline">1+2</strong>. This is usually not a problem if the expression does not change any state in the program, but it can create bugs that are hard to detect when it does. For example, given <strong class="inline">int i = 0;</strong>, if we call <strong class="inline">two_ints(i++, i++)</strong>, we don't know whether the function is going to be called with <strong class="inline">two_ints(0, 1)</strong> or <strong class="inline">two_ints(1, 0)</strong>. </p>
			<p>In general, it's better to declare expressions that change the state of the program in their own statements, and call functions with expressions that do not modify the program's state.</p>
			<p>The function parameters can be of any type. As we already saw, a type in C++ could be a value, a reference, or a pointer. This gives the programmer a few options on how to accept parameters from the callers, based on the behavior it wants.</p>
			<p>In the following subsections, we will explore the working mechanism of <em class="italics">Pass by value</em> and <em class="italics">Pass by reference</em> in more detail.</p>
			<h3 id="_idParaDest-57"><a id="_idTextAnchor063"/>Pass by Value</h3>
			<p>When the parameter type of a function is a value type, we say that the function is taking an argument by value or the argument is passed by value.</p>
			<p>When a parameter is a value type, a new local object is created each time the function is called.</p>
			<p>As we saw with automatic variables, the lifetime of the object lasts until the execution does not reach the end of the function's scope.</p>
			<p>When the parameter is initialized, a new copy is made from the argument provided when invoking the function.</p>
			<h4>Note</h4>
			<p class="callout">If you want to modify a parameter but do not want or do not care about the calling code seeing the modification, use <em class="italics">pass by value</em>.</p>
			<h3 id="_idParaDest-58"><a id="_idTextAnchor064"/>Exercise 5: Calculating Age using Pass by Value Arguments</h3>
			<p>James wants to write a C++ program to calculate what the age of a person will be after five years by providing their current age as an input.</p>
			<p>To implement such a program, he is going to write a function that takes a person's age by value and computes how old they will be in 5 years, and then prints it on the screen:</p>
			<ol>
				<li value="1">Create a function named <strong class="inline">byvalue_age_in_5_years</strong>, as illustrated here. Make sure that the value in the calling code does not change:<p class="snippet">void byvalue_age_in_5_years(int age) {</p><p class="snippet">  age += 5;</p><p class="snippet">  std::cout &lt;&lt; "Age in 5 years: " &lt;&lt; age &lt;&lt; std::endl;</p><p class="snippet">  // Prints 100</p><p class="snippet">}</p></li>
				<li>Now, in <strong class="inline">main()</strong>, call the function we created in the previous step by passing the variable <strong class="inline">age</strong> as a value:<p class="snippet">int main() {</p><p class="snippet">  int age = 95;</p><p class="snippet">  byvalue_age_in_5_years(age);</p><p class="snippet">  std::cout &lt;&lt; "Current age: " &lt;&lt; age;</p><p class="snippet">  // Prints 95</p><p class="snippet">}</p><h4>Note</h4><p class="callout">Pass by value should be the default way of accepting arguments: always use it unless you have a specific reason not to.</p><p class="callout">The reason for this is that it makes the separation between the calling code and the called function stricter: the calling code cannot see the changes that the called function makes on the parameters.</p></li>
			</ol>
			<p>Passing parameters by value creates a clear boundary between the calling function and the called function, because the parameters are copied:</p>
			<ol>
				<li value="1">As the calling function, we know that the variables we passed to the functions will not be modified by it.</li>
				<li>As the called function, we know that even if we modify the provided parameters, there will be no impact on the called function.</li>
			</ol>
			<p>This makes it easy to understand the code, because the changes we make to the parameters have no impact outside of the function.</p>
			<p>Pass by value can be the faster option when taking an argument, especially if the memory size of the argument is small (for example, integers, characters, float, or small structures).</p>
			<p>We need to remember though that passing by value performs a copy of the argument. Sometimes, this can be an expensive operation both in terms of memory and processing time, like when copying a container with many elements.</p>
			<p>There are some cases where this limitation can be overcome with the <strong class="inline">move</strong> semantic that was added in C++11. We will see more of it in <em class="italics">Lesson 3</em>, <em class="italics">Classes</em>.</p>
			<p>Let's look at an alternative to pass by value that has a different set of properties.</p>
			<h3 id="_idParaDest-59"><a id="_idTextAnchor065"/>Pass by Reference</h3>
			<p>When the parameter type of the function is a reference type, we say that the function is taking an argument by reference or the argument is passed by reference.</p>
			<p>We saw earlier that a reference type does not create a new object – it is simply a new variable, or name that refers to an object that already exists.</p>
			<p>When the function that accepts the argument by reference is called, the reference is bound to the object used in the argument: the parameter will refer to the given object. This means that the function has access to the object the calling code provided and can modify it.</p>
			<p>This is convenient if the goal of the function is to modify an object, but it can be more difficult to understand the interaction between the caller and the called function in such situations.</p>
			<h4>Note</h4>
			<p class="callout">Unless the function must modify the variable, always use <strong class="inline">const</strong> references, as we will see later.</p>
			<h3 id="_idParaDest-60"><a id="_idTextAnchor066"/>Exercise 6: Calculating Incrementation of Age using Pass by Reference</h3>
			<p>James would like to write a C++ program which, given anyone's age as input, prints <strong class="inline">Congratulations!</strong> if their age will be 18 or older in the next 5 years.</p>
			<p>Let's write a function that accepts its parameters by reference:</p>
			<ol>
				<li value="1">Create a function named <strong class="inline">byreference_age_in_5_years()</strong> of type <strong class="inline">void</strong>, as illustrated here:<p class="snippet">void byreference_age_in_5_years(int&amp; age) {</p><p class="snippet">  age += 5;</p><p class="snippet">}</p></li>
				<li>Now, in <strong class="inline">main()</strong>, call the function we created in the previous step by passing the variable <strong class="inline">age</strong> as a reference:<p class="snippet">int main() {</p><p class="snippet">  int age = 13;</p><p class="snippet">  byreference_age_in_5_years(age);</p><p class="snippet">  if (age &gt;= 18) {</p><p class="snippet">    std::cout &lt;&lt; "Congratulations! " &lt;&lt; std::endl;</p><p class="snippet">  }</p><p class="snippet">}</p></li>
			</ol>
			<p>Contrary to passing by value the speed when passing by reference does not change when the memory size of the object passed.</p>
			<p>This makes pass by reference the preferred method when copying an object, since providing pass by value to the function is expensive, especially if we cannot use the <strong class="inline">move</strong> semantic that was added in C++11.</p>
			<h4>Note</h4>
			<p class="callout">If you want to use pass by reference, but you are not modifying the provided object, make sure to use <strong class="inline">const</strong>.</p>
			<p>With C++, we can use <strong class="inline">std::cin</strong> to read input from the console executing the program.</p>
			<p>When writing <strong class="inline">std::cin &gt;&gt; variable;</strong>, the program will block waiting for some user input, and then it will populate <strong class="inline">variable</strong> with the value read from the input as long as it is a valid value and the program knows how to read it. By default, we can assign all the built-in data types and some types defined in the standard library, such as <strong class="inline">string</strong>.</p>
			<h3 id="_idParaDest-61"><a id="_idTextAnchor067"/>Activity 3: Checking Voting Eligibility</h3>
			<p>James is creating a program to print a message on the console screen: "<em class="italics">Congratulations! You are eligible to vote in your country</em>" or "<em class="italics">No worries, just &lt;value&gt; more years to go.</em>" after the user provides their current age as input.</p>
			<ol>
				<li value="1">Create a function named <strong class="inline">byreference_age_in_5_years(int&amp; age)</strong> and add the following code:<p class="snippet">#include &lt;iostream&gt;</p><p class="snippet">void byreference_age_in_5_years(int&amp; age) {</p><p class="snippet">  if (age &gt;= 18) {</p><p class="snippet">    std::cout &lt;&lt; "Congratulations! You are eligible to vote for your nation." &lt;&lt; std::endl;</p><p class="snippet">    return;</p></li>
				<li>In the <strong class="inline">else</strong> block, add the code to calculate the years remaining until they can vote:<p class="snippet">  } else{</p><p class="snippet">    int reqAge = 18;</p><p class="snippet">  }</p><p class="snippet">}</p></li>
				<li>In <strong class="inline">main()</strong>, add the input stream, as illustrated, to accept the input from the user. Pass the value as a reference in the previous function:<p class="snippet">int main() {</p><p class="snippet">    int age;</p><p class="snippet">    std::cout &lt;&lt; "Please enter your age:";</p><p class="snippet">    std::cin &gt;&gt; age;</p><p class="callout">The solution for this activity can be found on page 284.</p></li>
			</ol>
			<h2 id="_idParaDest-62">W<a id="_idTextAnchor068"/>orking with const References or r-value References</h2>
			<p>A temporary object cannot be passed as an argument for a reference parameter. To accept temporary parameters, we need to use <strong class="inline">const</strong> references or <em class="italics">r-value</em> references. The r-value references are references that are identified by two ampersands, <strong class="inline">&amp;&amp;</strong>, and can only refer to temporary values. We will look at them in more detail in <em class="italics">Lesson 4</em>, <em class="italics">Generic Programming and Templates</em>.</p>
			<p>We need to remember that a pointer is a value that represents the location of an object.</p>
			<p>Being a value, it means that when we are accepting a parameter as a pointer, the pointer itself is passed as a value.</p>
			<p>This means that the modification of the pointer inside the function is not going to be visible to the caller.</p>
			<p>But if we are modifying the object the pointer points to, then the original object is going to be modified:</p>
			<p class="snippet">void modify_pointer(int* pointer) {</p>
			<p class="snippet">  *pointer = 1;</p>
			<p class="snippet">  pointer = 0;</p>
			<p class="snippet">}</p>
			<p class="snippet">int main() {</p>
			<p class="snippet">  int a = 0;</p>
			<p class="snippet">  int* ptr = &amp;a;</p>
			<p class="snippet">  modify_pointer(ptr);</p>
			<p class="snippet">  std::cout &lt;&lt; "Value: " &lt;&lt; *ptr &lt;&lt; std::endl;</p>
			<p class="snippet">  std::cout &lt;&lt; "Did the pointer change? " &lt;&lt; std::boolalpha &lt;&lt;  (ptr == &amp;a);</p>
			<p class="snippet">}</p>
			<p>Most of the time, we can think of passing a pointer as passing a reference, with the caveat that you need to be aware that the pointer might be null.</p>
			<p>Accepting a parameter as a pointer is mainly used for three reasons:</p>
			<ul>
				<li>Traversing the elements of an array, by providing the start pointer and either the end pointer or the size of the array.</li>
				<li>Optionally modifying a value. This means that the function modifies a value if it is provided.</li>
				<li>Returning more than a single value. This is often done to set the value of a pointer passed as an argument and then return an error code to signal whether the operation was performed.</li>
			</ul>
			<p>We will see in <em class="italics">Lesson 4</em>, <em class="italics">Generic Programming and Templates</em>, how features introduced in C++11 and C++17 allow us to avoid using pointers for some of these use cases, eliminating the possibility of some common classes of errors, such as dereferencing invalid pointers or accessing unallocated memory.</p>
			<p>The options of passing by value or passing by reference are applicable to every single parameter the function expects, independently.</p>
			<p>This means that a function can take some arguments by value and some by reference.</p>
			<h3 id="_idParaDest-63"><a id="_idTextAnchor069"/>Returning Values from Functions</h3>
			<p>Up until now, we have seen how to provide values to a function. In this section, we will see how a function can provide value back to the caller.</p>
			<p>We said earlier that the first part of a function declaration is the type returned by the function: this is often referred to as the function's return type.</p>
			<p>All the previous examples used <strong class="inline">void</strong> to signal that they were returning nothing. Now, it is time to look at an example of a function returning a value:</p>
			<p class="snippet">int sum(int, int);</p>
			<p>The previous function accepts two integers by value as parameters and returns an integer.</p>
			<p>The invocation of the function in the caller code is an expression evaluating to an integer. This means that we can use it anywhere that an expression is allowed:</p>
			<p class="snippet">int a = sum(1, 2);</p>
			<p>A function can return a value by using the <strong class="inline">return</strong> keyword, followed by the value it wants to return.</p>
			<p>The function can use the <strong class="inline">return</strong> keyword several times inside its body, and each time the execution reaches the <strong class="inline">return</strong> keyword, the program will stop executing the function and go back to the caller, with the value returned by the function, if any. Let's look at the following code:</p>
			<p class="snippet">void rideRollercoasterWithChecks(int heightInCm) {</p>
			<p class="snippet">  if (heightInCm &lt; 100) {</p>
			<p class="snippet">    std::cout &lt;&lt; "Too short";</p>
			<p class="snippet">    return;</p>
			<p class="snippet">  }</p>
			<p class="snippet">  if (heightInCm &gt; 210) {</p>
			<p class="snippet">    std::cout &lt;&lt; "Too tall";</p>
			<p class="snippet">    return;</p>
			<p class="snippet">  }</p>
			<p class="snippet">  rideRollercoaster();</p>
			<p class="snippet">  // implicit return at the end of the function</p>
			<p class="snippet">}</p>
			<p>A function also returns to the caller if it reaches the end of its body.</p>
			<p>This is what we did in the earlier examples since we did not use the <strong class="inline">return</strong> keyword.</p>
			<p>Not explicitly returning can be okay if a function has a <strong class="inline">void</strong> return type. However, it will give unexpected results if the function is expected to return a value: the returned type will have an unspecified value and the program will not be correct.</p>
			<p>Be sure to enable the warning, as it will save you a lot of debugging time.</p>
			<h4>Note</h4>
			<p class="callout">It is surprising, but every major compiler allows the compiling of functions, which declare a return type other than void, but don't return a value.</p>
			<p class="callout">This is easy to spot in simple functions, but it is much harder in complex ones with lots of branches.</p>
			<p class="callout">Every compiler supports options to warn you if a function returns without providing a value.</p>
			<p>Let's look at an example of a function returning an integer:</p>
			<p class="snippet">int sum(int a, int b) {</p>
			<p class="snippet">  return a + b;</p>
			<p class="snippet">}</p>
			<p>As we said earlier, a function can use the <strong class="inline">return</strong> statement several times inside its body, as shown in the following example:</p>
			<p class="snippet">int max(int a, int b) {</p>
			<p class="snippet">  if(a &gt; b) {</p>
			<p class="snippet">    return a;</p>
			<p class="snippet">  } else {</p>
			<p class="snippet">    return b;</p>
			<p class="snippet">  }</p>
			<p class="snippet">}</p>
			<p>We always return a value that's independent of the values of the arguments.</p>
			<h4>Note</h4>
			<p class="callout">It is a good practice to return as early as possible in an <strong class="bold">algorithm</strong>.</p>
			<p class="callout">The reason for this is that as you follow the logic of the code, especially when there are many conditionals, a <strong class="inline">return</strong> statement tells you when that execution path is finished, allowing you to ignore what happens in the remaining part of the function.</p>
			<p class="callout">If you only return at the end of the function, you always have to look at the full code of the function.</p>
			<p>Since a function can be declared to return any type, we have to decide whether to return a value or a reference.</p>
			<h3 id="_idParaDest-64"><a id="_idTextAnchor070"/>Returning by Value</h3>
			<p>A function whose return type is a value type is said to return by value.</p>
			<p>When a function that returns by value reaches a <strong class="inline">return</strong> statement, the program creates a new object, which is initialized from the value of the expression in the return statement.</p>
			<p>In the previous function, <strong class="inline">sum</strong>, when the code reaches the stage of returning <strong class="inline">a + b</strong>, a new integer is created, with the value equal to the sum of <strong class="inline">a</strong> and <strong class="inline">b</strong>, and is returned.</p>
			<p>On the side of the caller, <strong class="inline">int a = sum(1,2);</strong>, a new temporary automatic object is created and is initialized from the value returned by the function (the integer that was created from the sum of <strong class="inline">a</strong> and <strong class="inline">b</strong>).</p>
			<p>This object is called <strong class="keyword">temporary</strong> because its lifetime is valid only while the full-expression in which it is created is executed. We will see in the <em class="italics">Returning by Reference</em> section, what this means and why this is important.</p>
			<p>The calling code can then use the returned temporary value in another expression or assign it to a value.</p>
			<p>Add the end of the full expression, since the lifetime of the temporary object is over, it is destroyed.</p>
			<p>In this explanation, we mentioned that objects are initialized several times while returning a value. This is not a performance concern as C++ allows compilers to optimize all these initializations, and often initialization happens only once.</p>
			<h4>Note</h4>
			<p class="callout">It is preferable to return by value as it's often easier to understand, easier to use, and as fast as returning by reference.</p>
			<p class="callout">How can returning by value be so fast? C++11 introduced the <strong class="inline">move</strong> semantic, which allows moving instead of copying the return types when they support the <strong class="inline">move</strong> operation. We'll see how in <em class="italics">Lesson 3</em>, <em class="italics">Classes</em>. Even before C++11, all mainstream compilers implemented <strong class="keyword">return value optimization</strong> (<strong class="keyword">RVO</strong>) and <strong class="keyword">named return value optimization</strong> (<strong class="keyword">NRVO</strong>), where the return value of a function is constructed directly in the variable into which they would have been copied to when returned. In C++17, this optimization, also called <strong class="keyword">copy elision</strong>, became mandatory.</p>
			<h3 id="_idParaDest-65"><a id="_idTextAnchor071"/>Returning by Reference</h3>
			<p>A function whose return type is a reference is said to return by reference.</p>
			<p>When a function returning a reference reaches a <strong class="inline">return</strong> statement, a new reference is initialized from the expression that's used in the <strong class="inline">return</strong> statement.</p>
			<p>In the caller, the function call expression is <strong class="bold">substituted</strong> by the returned reference.</p>
			<p>However, in this situation, we need to also be aware of the lifetime of the object the reference is referring to. Let's look at an example:</p>
			<p class="snippet">const int&amp; max(const int&amp; a, const int&amp; b) {</p>
			<p class="snippet">  if (a &gt; b) {</p>
			<p class="snippet">    return a;</p>
			<p class="snippet">  } else {</p>
			<p class="snippet">    return b;</p>
			<p class="snippet">  }</p>
			<p class="snippet">}</p>
			<p>First, we need to note that this function already has a caveat. The <strong class="inline">max</strong> function is returning by value, and it did not make a difference if we returned <strong class="inline">a</strong> or <strong class="inline">b</strong> when they were equal.</p>
			<p>In this function, instead, when <strong class="inline">a == b</strong> we are returning <strong class="inline">b</strong>, this means that the code calling this function needs to be aware of this distinction. In the case where a function returns a non-<strong class="inline">const</strong> reference it might modify the object referred to by the returned reference, and whether <strong class="inline">a</strong> or <strong class="inline">b</strong> is returned might make a difference.</p>
			<p>We are already seeing how references can make our code harder to understand.</p>
			<p>Let's look at the function we used:</p>
			<p class="snippet">int main() {</p>
			<p class="snippet">  const int&amp; a = max(1,2);</p>
			<p class="snippet">  std::cout &lt;&lt; a;</p>
			<p class="snippet">}</p>
			<p>This program has an error! The reason is that <strong class="inline">1</strong> and <strong class="inline">2</strong> are temporary values, and as we explained before, a temporary value is alive until the end of the full expression containing it.</p>
			<p>To better understand what is meant by "<em class="italics">the end of the full expression containing it</em>", let's look at the code we have in the preceding code block: <strong class="inline">int&amp; a = max(1,2);</strong>. There are four expressions in this piece of code:</p>
			<ul>
				<li><strong class="inline">1</strong> is an integer literal, which still counts as an expression</li>
				<li><strong class="inline">2</strong> is an integer literal, similar to <strong class="inline">1</strong></li>
				<li><strong class="inline">max(expression1, expression2)</strong> is a function call expression</li>
				<li><strong class="inline">a = expression3</strong> is an assignment expression</li>
			</ul>
			<p>All of this happens in the declaration statement of variable <strong class="inline">a</strong>.</p>
			<p>The third point covers the function call expression, while containing the full expression is covered in the following point.</p>
			<p>This means that lifetimes <strong class="inline">1</strong> and <strong class="inline">2</strong> will stop at the end of the assignment. But we got a reference to one of them! And we are using it!</p>
			<p>Accessing an object whose lifetime is terminated is prohibited by C++, and this will result in an invalid program.</p>
			<p>In a more complex example, such as <strong class="inline">int a = max(1,2) + max(3,4);</strong>, the temporary objects returned by the <strong class="inline">max</strong> functions will be valid until the end of the assignment, but no longer.</p>
			<p>Here, we are using the two references to <strong class="inline">sum</strong> them, and then we assign the result as a value. If we assigned the result to a reference, as in the following example, <strong class="inline">int&amp; a = max(1,2) + max(3,4);</strong>, instead, the program would have been wrong. </p>
			<p>This sounds confusing, but it is important to understand as it can be a source of hard-to-debug problems if we use a temporary object after the full expression in which it's created has finished executing.</p>
			<p>Let's look at another common mistake in functions returning references:</p>
			<p class="snippet">int&amp; sum(int a, int b) {</p>
			<p class="snippet">  int c = a + b;</p>
			<p class="snippet">  return c;</p>
			<p class="snippet">}</p>
			<p>We created a local, automatic object in the function body and then we returned a reference to it.</p>
			<p>In the previous section, we saw that local objects' lifetimes end at the end of the function. This means that we are returning a reference to an object whose lifetime will always be terminated.</p>
			<p>Earlier, we mentioned the similarities between passing arguments by reference and passing arguments by pointers.</p>
			<p>This similarity persists when returning pointers: the object pointed to by a pointer needs to be alive when the pointer is later <strong class="bold">dereferenced</strong>.</p>
			<p>So far, we have covered examples of mistakes while returning by reference. How can references be used correctly as return types to functions?</p>
			<p>The important part of using references correctly as return values is to make sure that the object outlives the reference: the object must always be alive – at least until there is a reference to it.</p>
			<p>A common example is accessing a part of an object, for example, using an <strong class="inline">std::array</strong>, which is a safe option compared to the built-in array:</p>
			<p class="snippet">int&amp; getMaxIndex(std::array&lt;int, 3&gt;&amp; array, int index1, int index2) {</p>
			<p class="snippet">  /* This function requires that index1 and index2 must be smaller than 3! */</p>
			<p class="snippet">  int maxIndex = max(index1, index2);</p>
			<p class="snippet">  return array[maxIndex];</p>
			<p>The calling code would look as follows:</p>
			<p class="snippet">int main() {</p>
			<p class="snippet">  std:array&lt;int, 3&gt; array = {1,2,3};</p>
			<p class="snippet">  int&amp; elem = getMaxIndex(array, 0, 2);</p>
			<p class="snippet">  elem = 0;</p>
			<p class="snippet">  std::cout &lt;&lt; array[2];</p>
			<p class="snippet">  // Prints 0</p>
			<p class="snippet">}</p>
			<p>In this example, we are returning a reference to an element inside an array, and the array remains alive longer than the reference.</p>
			<p>The following are guidelines for using return by reference correctly:</p>
			<ul>
				<li>Never return a reference to a local variable (or a part of it)</li>
				<li>Never return a reference to a parameter accepted by value (or a part of it)</li>
			</ul>
			<p>When returning a reference that was received as a parameter, the argument passed to the function must live longer than the returned reference.</p>
			<p>Apply the previous rule, even when you are returning a reference to a part of the object (for example, an element of an array).</p>
			<h3 id="_idParaDest-66"><a id="_idTextAnchor072"/>Activity 4: Using Pass by Reference and Pass by Value</h3>
			<p>In this activity, we are going to see the different trade-offs that can be made when writing a function, depending on the parameters the function accepts:</p>
			<ol>
				<li value="1">Write a function that takes two numbers and returns the sum. Should it take the arguments by value or reference? Should it return by value or by reference?</li>
				<li>After that, write a function that takes two <strong class="inline">std::arrays</strong> of ten integers and an index (guaranteed to be less than 10) and returns the greater of the two elements to the given index in the two arrays.</li>
				<li>The calling function should then modify the element. Should it take the arguments by value or reference? Should it return by value or by reference? What happens if the values are the same?</li>
			</ol>
			<p>Take the arrays by reference and return by reference because we are saying that the calling function is supposed to modify the element. Take the index by value since there is no reason to use references.</p>
			<p>If the values are the same, the element from the first array is returned.</p>
			<h4>Note</h4>
			<p class="callout">The solution to this activity can be found at page 285.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor073"/>Const Parameters and Default Arguments</h2>
			<p>In the previous chapter, we saw how and when to use references in function parameters and return types. C++ has an additional qualifier, the <strong class="inline">const</strong> qualifier, which can be used independently from the <em class="italics">ref-ness</em> (whether the type is a reference or not) of the type.</p>
			<p>Let's see how <strong class="inline">const</strong> is used in the various scenarios we investigated when looking at how functions can accept parameters.</p>
			<h3 id="_idParaDest-68"><a id="_idTextAnchor074"/>Passing by const Value</h3>
			<p>In pass by value, the function parameter is a value type: when invoked, the argument is copied into the parameter.</p>
			<p>This means that regardless of whether <strong class="inline">const</strong> is used in the parameter or not, the calling code cannot see the difference.</p>
			<p>The only reason to use <strong class="inline">const</strong> in the function signature is to document to the implementation that it cannot modify such a value.</p>
			<p>This is not commonly done, as the biggest value of a function signature is for the caller to understand the contract of calling the function. Because of this, it is rare to see <strong class="inline">int max(const int, const int)</strong>, even if the function does not modify the parameters.</p>
			<p>There is an exception, though: when the function accepts a <strong class="inline">pointer</strong>.</p>
			<p>In such cases, the function wants to make sure that it is not assigning a new value to the pointer. The pointer acts similar to a reference here, since it cannot be bound to a new object, but provides nullability.</p>
			<p>An example could be <strong class="inline">setValue(int * const)</strong>, a function that takes a <strong class="inline">const</strong> pointer to an <strong class="inline">int</strong>.</p>
			<p>The integer is not <strong class="inline">const</strong>, so it can be changed, but the pointer is <strong class="inline">const</strong> and the implementation cannot change it during implementation.</p>
			<h3 id="_idParaDest-69"><a id="_idTextAnchor075"/>Passing by const Reference</h3>
			<p>Const is extremely important in pass by reference, and any time you use a reference in the parameters of a function, you should also add <strong class="inline">const</strong> to it (if the function is not designed to modify it).</p>
			<p>The reason for this is that a reference allows you to modify the provided object freely.</p>
			<p>It is error-prone, since the function might modify an object the caller does not expect to be modified by mistake, and it is hard to understand as there is no clear boundary between the caller and the function, again, because the function can modify the state of the caller.</p>
			<p><strong class="inline">const</strong> instead fixes the problem, since a function cannot modify an object through a <strong class="inline">const</strong> reference.</p>
			<p>This allows the function to use reference parameters without some of the drawbacks of using references.</p>
			<p>The function should remove the <strong class="inline">const</strong> from a reference, but only if it is intended to modify the provided object, otherwise every reference should be <strong class="inline">const</strong>.</p>
			<p>Another advantage of <strong class="inline">const</strong> reference parameters is that temporary objects can be used as arguments for them.</p>
			<h3 id="_idParaDest-70"><a id="_idTextAnchor076"/>Returning by const Value</h3>
			<p>There is no widespread reason to return by <strong class="inline">const</strong> value since the calling code often assigns the value to a variable, in which case the <strong class="inline">const</strong>-ness of the variables is going to be the deciding factor, or passes the value to a next expression, and it is rare for an expression to expect a <strong class="inline">const</strong> value.</p>
			<p>Returning by <strong class="inline">const</strong> value also inhibits the <strong class="inline">move</strong> semantic of C++11, thus reducing performance.</p>
			<h3 id="_idParaDest-71"><a id="_idTextAnchor077"/>Returning by const Reference</h3>
			<p>A function should always return by <strong class="inline">const</strong> reference when the returned reference is meant to only be read and not be modified by the calling code.</p>
			<p>The same concept we applied to object lifetimes when returning references to them also apply to <strong class="inline">const</strong>:</p>
			<ul>
				<li>When returning a reference accepted as a parameter, if the parameter is a <strong class="inline">const</strong> reference, the returned reference must be <strong class="inline">const</strong> as well</li>
				<li>When returning a reference to a part of an object accepted as the <strong class="inline">const</strong> reference parameter, the returned reference must be <strong class="inline">const</strong> as well</li>
			</ul>
			<p>A parameter accepted as a reference should be returned as a <strong class="inline">const</strong> reference if the caller is not expected to modify it.</p>
			<p>Sometimes, the compilation fails, stating that the code is trying to modify an object that is a <strong class="inline">const</strong> reference. Unless the function is meant to modify the object, the solution is not to remove <strong class="inline">const</strong> from the reference in the parameter. Instead, look for why the operation that you are trying to perform does not work with <strong class="inline">const</strong>, and what the possible alternatives are.</p>
			<p><strong class="inline">const</strong> is not about the implementation, it is about the meaning of the function.</p>
			<p>When you write the function signature, you should decide whether to use <strong class="inline">const</strong>, as the implementation will have to find a way to respect that.</p>
			<p>For example:</p>
			<p class="snippet">void setTheThirdItem(std::array&lt;int, 10&gt;&amp; array, int item)</p>
			<p>This should clearly take a reference to the array since its purpose is to modify the array.</p>
			<p>On the other hand, we can use the following:</p>
			<p class="snippet">int findFirstGreaterThan(const std::array&lt;int, 10&gt;&amp;  array, int threshold)</p>
			<p>This tells us that we are only looking into the array – we are not changing it, so we should use <strong class="inline">const</strong>.</p>
			<h4>Note</h4>
			<p class="callout">It is a best practice to use <strong class="inline">const</strong> as much as possible, as it allows the compiler to make sure that we are not modifying objects that we do not want to modify.</p>
			<p class="callout">This can help to prevent bugs.</p>
			<p class="callout">It also helps to keep another best practice in mind: never use the same variable to represent different concepts. Since the variable cannot be changed, it is less natural to reuse it instead of creating a new one.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor078"/>Default Arguments</h2>
			<p>Another feature C++ provides to make life easier for the caller when it comes to calling functions are default arguments.</p>
			<p>Default arguments are added to a function declaration. The syntax is to add an <strong class="inline">=</strong> sign and supply the value of the default argument after the identifier of the parameter of the function. An example of this would be:</p>
			<p class="snippet">int multiply(int multiplied, int multiplier = 1);</p>
			<p>The caller of the function can call <strong class="inline">multiply</strong> either with <strong class="inline">1</strong> or <strong class="inline">2</strong> arguments:</p>
			<p class="snippet">multiply(10); // Returns 10</p>
			<p class="snippet">multiply(10, 2); // Returns 20</p>
			<p>When an argument with a default value is omitted, the function uses the default value instead. This is extremely convenient if there are functions with sensible defaults that callers mostly do not want to modify, except in specific cases.</p>
			<p>Imagine a function that returns the first word of a string: </p>
			<p><strong class="inline">char const * firstWord(char const * string, char separator = ' ').</strong></p>
			<p>Most of the time, a word is separated by a whitespace character, but a function can decide whether or not it should use a different separator. The fact that a function offers the possibility to provide a separator is not forcing most callers, which simply want to use the space, to specify it.</p>
			<p>It is a best practice to set the default arguments in the function signature declaration, and not declare them in the definition.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor079"/>Namespaces</h2>
			<p>One of the goals of functions is to better organize our code. To do so, it is important to give meaningful names to them.</p>
			<p>For example, in package management software, there might be a function called <strong class="inline">sort</strong> for sorting packages. As you can see, the name is the same as the function that would sort a list of numbers.</p>
			<p>C++ has a feature that allows you to avoid these kinds of problems and groups names together: <strong class="keyword">namespaces</strong>.</p>
			<p>A namespace starts a scope in which all the names declared inside are part of the namespace.</p>
			<p>To create a namespace, we use the <strong class="inline">namespace</strong> keyword, followed by the identifier and then the code block:</p>
			<p class="snippet">namespace example_namespace {</p>
			<p class="snippet">  // code goes here</p>
			<p class="snippet">}</p>
			<p>To access an identifier inside a namespace, we prepend the name of the namespace to the name of the function.</p>
			<p>Namespaces can be nested as well. Simply use the same declaration as before inside the namespace:</p>
			<p class="snippet">namespace parent {</p>
			<p class="snippet">  namespace child {</p>
			<p class="snippet">    // code goes here</p>
			<p class="snippet">  }</p>
			<p class="snippet">}</p>
			<p>To access an identifier inside a namespace, you prepend the name of the identifier with the name of the namespace in which it is declared, followed by <strong class="inline">::</strong>.</p>
			<p>You might have noticed that, before we were using <strong class="inline">std::cout</strong>. This is because the C++ standard library defines the <strong class="inline">std</strong> namespace and we were accessing the variable named <strong class="inline">cout</strong>.</p>
			<p>To access an identifier inside multiple namespaces, you can prepend the list of all the namespaces separated by <strong class="inline">::</strong> – <strong class="inline">parent::child::some_identifier</strong>. We can access names in the global scope by prepending <strong class="inline">::</strong> to the name—<strong class="inline">::name_in_global_scope</strong>.</p>
			<p>If we were to only use <strong class="inline">cout</strong>, the compiler would have told us that the name does not exist in the current scope.</p>
			<p>This is because the compiler searches only in the current namespace and the parent namespaces to find an identifier by default, so unless we specify the <strong class="inline">std</strong> namespace, the compiler will not search in it.</p>
			<p>C++ helps make this more ergonomic with the help of the <strong class="inline">using</strong> declaration.</p>
			<p>The <strong class="inline">using</strong> declaration is defined by the <strong class="inline">using</strong> keyword, followed by an identifier specified with its namespaces.</p>
			<p>For example, <strong class="inline">using std::cout;</strong> is a <strong class="inline">using</strong> declaration that declares that we want to use <strong class="inline">cout</strong>. When we want to use all the declarations from a namespace, we can write <strong class="inline">using namespace namespace_name</strong>;. For example, if we want to use every name defined in the <strong class="inline">std</strong> namespace, we would write: <strong class="inline">using namespace std;</strong>.</p>
			<p>When a name is declared inside the <strong class="inline">using</strong> declaration, the compiler also looks for that name when looking for an identifier.</p>
			<p>This means that, in our code, we can use <strong class="inline">cout</strong> and the compiler will find <strong class="inline">std::cout</strong>.</p>
			<p>A <strong class="inline">using</strong> declaration is valid as long as we are in the scope in which it is declared.</p>
			<h4>Note</h4>
			<p class="callout">To better organize your code and avoid naming conflicts, you should always put your code inside a namespace that's specific to either your application or library.</p>
			<p class="callout">Namespaces can also be used to specify that some code is used only by the current code.</p>
			<p>Let's imagine you have a file called <strong class="inline">a.cpp</strong> that contains <strong class="inline">int default_name = 0;</strong> and another file called <strong class="inline">b.cpp</strong> with <strong class="inline">int default_name = 1;</strong>. When you compile the two files and link them together, we get an invalid program: the same variable has been declared with two different values, and this violates the <strong class="keyword">One Definition Rule</strong> (<strong class="keyword">ODR</strong>).</p>
			<p>But you never meant for those to be the same variable. To you, they were some variables that you just wanted to use inside your <strong class="inline">.cpp</strong> file.</p>
			<p>To tell that to the compiler, you can use anonymous namespaces: a namespace with no identifier.</p>
			<p>All the identifiers created inside it will be private to the <em class="italics">current translation unit</em> (normally the <strong class="inline">.cpp</strong> file).</p>
			<p>How can you access an identifier inside an anonymous namespace? You can access the identifier directly, without the need to use the namespace name, which does not exist, or the <strong class="inline">using</strong> declaration.</p>
			<h4>Note</h4>
			<p class="callout">You should only use anonymous namespaces in <strong class="inline">.cpp</strong> files.</p>
			<h3 id="_idParaDest-74"><a id="_idTextAnchor080"/>Activity 5: Organizing Functions in Namespaces</h3>
			<p>Write a function to read the name of a car for a lottery in a namespace based on numerical input. If the user inputs <strong class="inline">1</strong>, they win a Lamborghini, and if the user inputs <strong class="inline">2</strong>, they win a Porsche:</p>
			<ol>
				<li value="1">Define the first namespace as <strong class="inline">LamborghiniCar</strong> with an <strong class="inline">output()</strong> function that will print "<strong class="inline">Congratulations! You deserve the Lamborghini.</strong>" when called.</li>
				<li>Define the second namespace as <strong class="inline">PorscheCar</strong> with an <strong class="inline">output()</strong> function that will print "<strong class="inline">Congratulations! You deserve the Porsche.</strong>" when called.</li>
				<li>Write a <strong class="inline">main</strong> function to read the input of numbers <strong class="inline">1</strong> and <strong class="inline">2</strong> into a variable called <strong class="inline">magicNumber</strong>.</li>
				<li>Create an <strong class="inline">if-else</strong> loop with the <strong class="inline">if</strong> condition calling the first namespace with <strong class="inline">LamborghiniCar::output()</strong> if the input is <strong class="inline">1</strong>. Otherwise, the second namespace is called similarly when the input is <strong class="inline">2</strong>.</li>
				<li>If neither of these conditions are met, we print a message asking them to enter a number between <strong class="inline">1</strong> and <strong class="inline">2</strong>.<h4>Note</h4><p class="callout">The solution for this activity can be found on page 285.</p></li>
			</ol>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor081"/>Function Overloading</h2>
			<p>W<a id="_idTextAnchor082"/>e saw how C++ allows us to write a function that takes parameters either by value or by reference, using <strong class="inline">const</strong>, and organizes them in namespaces.</p>
			<p>There is an additional powerful feature of C++ that allows us to give the same name to functions that perform the same conceptual operation on different types: <strong class="keyword">function overloading</strong>.</p>
			<p>Function overloading is the ability to declare several functions with the same name – that is, if the set of parameters they accept is different.</p>
			<p>An example of this is the <strong class="inline">multiply</strong> function. We can imagine this function being defined for integers and floats, or even for vectors and matrices.</p>
			<p>If the concept represented by the function is the same, we can provide several functions that accept different kinds of parameters.</p>
			<p>When a function is invoked, the compiler looks at all the functions with that name, called the <strong class="keyword">overload set</strong>, and picks the function that is the best match for the arguments provided.</p>
			<p>The precise rule on how the function is selected is complex, but the behavior is often intuitive: the compiler looks for the better match between the arguments and the expected parameters of the function. If we have two functions, <strong class="inline">int increment(int)</strong> and <strong class="inline">float increment(float)</strong>, and we call them with <strong class="inline">increment(1)</strong>, the integer overload is selected because an integer is a better match to an integer than a float, even if an integer can be converted into a float. An example of this would be:</p>
			<p class="snippet">bool isSafeHeightForRollercoaster(int heightInCm) {</p>
			<p class="snippet">  return heightInCm &gt; 100 &amp;&amp; heightInCm &lt; 210;</p>
			<p class="snippet">}</p>
			<p class="snippet">bool isSafeHeightForRollercoaster(float heightInM) {</p>
			<p class="snippet">  return heightInM &gt; 1.0f &amp;&amp; heightInM &lt; 2.1f;</p>
			<p class="snippet">}</p>
			<p class="snippet">// Calls the int overload</p>
			<p class="snippet">isSafeHeightForRollercoaster(187);</p>
			<p class="snippet">// Class the float overload</p>
			<p class="snippet">isSafeHeightForRollercoaster(1.67f);</p>
			<p>Thanks to this feature, the calling code does not need to worry about which overload of the function the compiler is going to select, and the code can be more expressive thanks to using the same function to express the same meaning.</p>
			<h3 id="_idParaDest-76"><a id="_idTextAnchor083"/>Activity 6: Writing a Math Library for a 3D Game</h3>
			<p>Johnny wants to implement a <em class="italics">math</em> library for the video game he is making. It will be a 3D game, so he will need to operate on points representing the three coordinates: <em class="italics">x</em>, <em class="italics">y</em>, and <em class="italics">z</em>.</p>
			<p>The points are represented as <strong class="inline">std::array&lt;float, 3&gt;</strong>. A library will be used throughout the game, so Johnny needs to be sure it can work when included multiple times (by creating a header file and declaring the functions there).</p>
			<p>The library needs to support the following steps:</p>
			<ol>
				<li value="1">Finding the distance between 2 floats, 2 integers, or 2 points.</li>
				<li>If only one of the 2 points is provided, the other one is assumed to be the origin (the point at location <strong class="inline">(0,0,0)</strong>).</li>
				<li>Additionally, Johnny often needs to compute the circumference of a circle from its radius (defined as <strong class="inline">2*pi*r</strong>) to understand how far enemies can see. <strong class="inline">pi</strong> is constant for the duration of the program (which can be declared globally in the <strong class="inline">.cpp</strong> file).</li>
				<li>When an enemy moves, it visits several points. Johnny needs to compute the total distance that it would take to walk along those points.</li>
				<li>For simplicity, we will limit the number of points to <strong class="inline">10</strong>, but Johnny might need up to 100. The function would take <strong class="inline">std::array&lt;std::array&lt;float, 3&gt;, 10&gt;</strong> and compute the distance between consecutive points.<p>For example (with a list of 5 points): for the array <strong class="inline">{{0,0,0}, {1,0,0}, {1,1,0}, {0,1,0}, {0,1,1}}</strong>, the total distance is 5, because going from <strong class="inline">{0,0,0}</strong> to <strong class="inline">{1,0,0}</strong> is a distance of <strong class="inline">1</strong>, then going from <strong class="inline">{1,0,0}</strong> to <strong class="inline">{1,1,0}</strong> is a distance of <strong class="inline">1</strong> again, and so on for the remaining 3 points.</p><h4>Note</h4><p class="callout">The solution for this activity can be found on page 286.</p></li>
			</ol>
			<p>Make sure that the functions are well-organized by grouping them together.</p>
			<p>Remember that the distance between two points is computed as the square root of (<strong class="inline">x2-x1)^2 + (y2-y1)^2 + (z2-z1)^2</strong>.</p>
			<p>C++ offers the <strong class="inline">std::pow</strong> function for the <strong class="bold">power function</strong>, which takes the base and the exponent, and the <strong class="inline">std::sqrt</strong> function, which takes the number to square. Both are in the <strong class="inline">cmath</strong> header.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor084"/>Summary</h2>
			<p>In this chapter, we saw the powerful features C++ offers to implement functions. </p>
			<p>We started by discussing why functions are useful and what they can be used for, and then we dove into how to declare and define them.</p>
			<p>We analyzed different ways of accepting parameters and returning values, how to make use of local variables, and then explored how to improve the safety and convenience of calling them with <strong class="inline">const</strong> and default arguments.</p>
			<p>Finally, we saw how functions can be organized in namespaces and the ability to give the same name to different functions that implement the same concept, making the calling code not have to think about which version to call.</p>
			<p>In the next chapter, we will look at how to create classes and how they are used in C++ to make building complex programs easy and safe.</p>
		</div>
</body></html>