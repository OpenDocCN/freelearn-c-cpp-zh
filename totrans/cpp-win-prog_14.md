# 第14章。对话框、控件和页面设置

在本章中，我们将探讨以下内容的实现：

+   **自定义对话框**：`Dialog`类旨在被子类继承并配备控件。

+   **控件**：`Control`类及其子类。有用于编辑字段、复选框、单选按钮、列表框和组合框的控件。

+   **转换器**：在字符串和其他值之间。例如，当用户输入代表数值的文本时，可以添加一个转换器将文本转换为值，或者如果文本不包含有效值，则显示错误消息。

+   **页面设置**：在这里我们扩展`Dialog`类。当设置`StandardDocument`类的文档页面设置时使用对话框。它处理有关页眉、页脚和边距的信息。

# 自定义对话框

`Dialog`类处理一组**控件**，这些控件通过`AddControl`方法添加到对话框中。对于`Dialog`类的子类，请参考本章最后部分的`PageSetupDialog`。`Dialog`类提供了一个模态对话框，这意味着在对话框关闭之前，应用程序中的所有其他窗口都将被禁用。

用户可以使用***Tab***键在控件之间导航，使用箭头键在同一个组中的单选按钮之间导航。他们还可以使用快捷键来访问控件。

**Dialog.h**

[PRE0]

`dialogMap`字段由`DialogProc`用于查找接收消息的对话框：

[PRE1]

尽管`Dialog`类调用了默认的`Window`构造函数，该构造函数不调用Win32 API函数`CreateWindowEx`，但`Dialog`类仍然是`Window`的子类。`DoModal`收集有关对话框及其控件的信息，并调用Win32 API函数`DialogBoxIndirectParam`：

[PRE2]

如其名所示，`DoModal`在其父窗口可见期间禁用其父窗口。也就是说，直到用户关闭对话框：

[PRE3]

析构函数删除所有控件，这意味着`Dialog`的子类应该在对话框中动态分配控件而不删除它们：

[PRE4]

`AddControl`方法为控件分配一个身份号码并将其添加到`idMap`。

[PRE5]

每当用户更改对话框的大小时，都会调用`OnSize`函数，它会遍历控件并调整它们的大小，以便它们保持相对于对话框客户端区域的大小。

[PRE6]

当用户按下***回车***键时，会调用`OnReturn`，而当他们按下***Esc***键时，会调用`OnEscape`。它们的默认行为是关闭对话框并将控制权返回给`DoModal`，返回码为1和0；1被解释为`true`，0被解释为`false`。

[PRE7]

`OnControlInit`方法旨在被子类覆盖，并在对话框初始化时（当它接收`WM_INITDIALOG`消息时）被调用。

[PRE8]

`TryClose`方法旨在被子类覆盖，其默认行为是返回`true`。当用户尝试关闭对话框时，会调用`OnClose`方法，其默认行为是调用`TryClose`，如果返回`true`则关闭对话框，在这种情况下也会调用`OnDestroy`：

[PRE9]

每个控件在添加到对话框时都会分配一个标识符，该标识符映射到`idMap`中控制器的指针：

[PRE10]

对话框有一个标题文本、左上角位置、字体、常规样式和扩展样式，这些由构造函数存储，并在`DialogBoxIndirectParam`调用中由`DoModal`使用。然而，对话框的大小不是构造函数参数；相反，大小基于控件尺寸：

[PRE11]

在计算对话框大小时，使用`leftMargin`、`maxWidth`、`topMargin`和`maxHeight`字段。其思路是调整大小，使左右边距以及最接近的控件的上边距和下边距相等：

[PRE12]

第一个控件没有分配0的标识符，因为这会导致在处理消息时产生混淆，如果具有标识符0的控件是按钮。相反，我们用1000初始化`currentId`，并且随着每个新控件的增加而减少其值。减少值是为了使对话框中的***Tab***键能够正确工作：

[PRE13]

当对话框初始化（通过接收`WM_INITDIALOG`消息）时，其大小被存储在`originalClientSize`中，以便在`OnSize`计算控件大小时使用：

[PRE14]

每次对话框收到消息时都会调用`DialogProc`方法。与`WindowProc`不同，如果消息已被处理且不需要进一步处理，它将返回`TRUE`。此外，它不会在末尾调用`DefWindowProc`；相反，如果消息未被处理，它将返回`FALSE`：

[PRE15]

**Dialog.cpp**

[PRE16]

默认对话框字体设置为12点Times New Roman。

[PRE17]

构造函数调用`Window`构造函数，它设置父窗口指针并执行其他操作。也就是说，它不会调用Win32 API函数`CreateWindowEx`。`header`、`topLeft`、`style`、`extendedStyle`和`font`字段被存储起来，以便在`DoModal`中使用：

[PRE18]

`DoModal`函数使对话框进入模态状态。也就是说，其父窗口在对话框被销毁之前将变为禁用状态。但是，它首先将信息加载到`infoList`中。`AddValue`方法是`InfoList`类的模板方法，并将不同类型的值添加到列表中：

[PRE19]

首先，我们需要添加值`1`，以便设置我们想要工作的对话框模板版本：

[PRE20]

`0xFFFF`值表示我们想要使用扩展对话框模板：

[PRE21]

下一个单词是为了帮助标识符；然而，我们不使用它，所以我们将其设置为0：

[PRE22]

然后是扩展和常规样式。除了发送给构造函数的样式外，我们还设置对话框具有标题、系统菜单、模态框架和字体。由于`DS_SETFONT`标志，我们将在稍后添加有关对话框字体信息：

[PRE23]

下一个值是对话框中控件的数量，由`idMap`的大小给出：

[PRE24]

顶部左边的位置由`topLeft`字段给出：

[PRE25]

对话框客户端区域的大小由`maxWidth`、`leftMargin`、`maxHeight`和`topMargin`设置，这些已在`AddControl`中计算。客户端区域的宽度是控件集的最大宽度加上其左边距。这样，我们调整对话框以容纳具有相等左右边距以及上下边距的控件：

[PRE26]

接下来的两个零表示我们不希望使用菜单，并且我们使用默认的对话框`Windows`类：

[PRE27]

然后，我们设置对话框的标题。`AddString`方法是一个`InfoList`模板方法，它将带有终止符0的字符串添加到信息列表：

[PRE28]

最后，我们设置对话框的字体。我们从`Font`类的`LOGFONT`结构中提取其大小（`lfHeight`）、是否加粗（`lfWeight`）或斜体，其字符集（由于我们不使用它，所以为0）和字体名称：

[PRE29]

当对话框信息已添加到信息列表中时，我们为每个控件调用`AddControlInfo`，以便将控件信息添加到列表：

[PRE30]

当列表已完全加载时，我们分配一个全局缓冲区并将其加载到列表中。`ToBuffer`方法将列表复制到缓冲区：

[PRE31]

如果存在，我们需要父窗口的句柄，然后我们通过调用Win32 API函数`DialogBoxIndirectParam`创建对话框，该函数将在用户关闭对话框之前不返回。最后一个参数是`Dialog`对象的指针，它将与`WM_INITDIALOG`消息一起发送。存储在`result`中的返回值是`EndDialog`调用的第二个参数：

[PRE32]

如果结果值不等于0，我们返回`true`：

[PRE33]

如果全局缓冲区分配失败，我们返回`false`：

[PRE34]

析构函数遍历`idMap`并删除对话框中的每个控件：

[PRE35]

`AddControl`方法将控件添加到对话框。如果是第一个要添加的控件（`idMap`为空），则将`leftMargin`和`topMargin`设置为控件的左上角，并将`maxWidth`和`maxHeight`设置为左上角加上控件的宽度或高度。但是，如果不是，我们需要比较的第一个控件是其左上角和大小，与当前值，以找到控件集的边距和最大大小：

[PRE36]

控件的标识号设置为`currentId`，然后返回并递减：

[PRE37]

`OnSize`方法比较客户端区域的新大小与其原始大小。它们之间的比率存储在`factorPair`中：

[PRE38]

`idMap`的控件被迭代，每个控件的原始大小乘以`factorPair`，这是新客户端区域大小与原始客户端区域大小的比率。这样，当用户改变对话框大小时，控件将保持它们相对于对话框客户端区域大小的相对大小。

[PRE39]

当用户按下***Return***键时调用`OnReturn`方法，当用户按下***Esc***键时调用`OnEscape`，当用户关闭对话框时调用`OnClose`。默认行为是调用`TryClose`，如果它返回`true`，则调用Win32 API函数`EndDialog`，这将导致`DoModal`中的`DialogBoxIndirectParam`调用返回`EndDialog`的第二个参数给出的整数值：

[PRE40]

每次对话框收到消息时调用`DialogProc`方法。第一个参数是对话框的句柄，通过`dialogMap`映射到`Dialog`指针：

[PRE41]

当对话框创建时调用`WM_INITDIALOG`情况，但在它变得可见之前。当对话框通过`DialogBoxIndirectParam`方法创建时，最后一个参数是指向封装的`Dialog`对象的指针。该指针在`longParam`参数中给出，它被转换为指向`Dialog`的指针，并添加到`dialogMap`中：

[PRE42]

将对话框的Win32 API窗口句柄分配给`dialogHandle`，计算并存储客户端区域的原始大小在`originalClientSize`中，并调用`OnDialogInit`：

[PRE43]

对于对话框中的每个控件，通过调用Win32 API函数`GetDlgItem`设置其窗口句柄，该函数接受对话框窗口句柄和由`AddControl`设置的控件身份号码。类似于对话框的原始客户端大小，控件的原始大小和位置也被存储。最后，对每个控件调用`OnControlInit`：

[PRE44]

消息处理完毕后，返回`TRUE`：

[PRE45]

每次对话框的大小发生变化时，都会向对话框发送`WM_SIZE`情况。宽度和高度存储在`longParam`参数的低位和高位字中。调用`OnSize`方法以处理该消息：

[PRE46]

当用户尝试关闭对话框时调用`WM_CLOSE`情况。调用`OnClose`方法来处理消息，该消息可能会也可能不会关闭对话框：

[PRE47]

当对话框正在被销毁时调用`WM_DESTROY`情况。与`WM_CLOSE`不同，无法阻止对话框被销毁。由于`WM_DESTROY`是发送到对话框的最后一个消息，对话框从`dialogMap`中移除：

[PRE48]

当用户使用其中一个控件执行某些操作时，将发送`WM_COMMAND`消息到对话框。在涉及控件的行动中，其身份号码存储在`wordParam`的低位字中：

[PRE49]

如果身份号码是`IDOK`或`IDCANCEL`，则用户按下了***Return***或***Esc***键：

[PRE50]

如果身份号码不是`IDOK`或`IDCANCEL`，我们使用`idMap`和`wordParam`的高位字中的通知代码查找控件。通知代码可能具有与`IDOK`或`IDCANCEL`相同的值，这就是为什么我们使用这种有些繁琐的结构来处理代码的原因：

[PRE51]

当控件获得或失去输入焦点时，调用`OnGainFocus`或`OnLoseFocus`；当它们更改文本字段的输入文本时，调用`OnChange`；当它们更改组合框、列表框或多个列表框的选择时，调用`OnSelect`；当它们点击按钮、复选框或单选按钮时，调用`OnClick`：

[PRE52]

当命令消息已被处理时，无需进一步处理。因此，我们返回`true`：

[PRE53]

如果消息未被处理，我们返回`false`以便消息可以被Windows系统进一步处理：

[PRE54]

# 控件

这里是小型窗口控件层次结构：

![控件](img/B05475_14_01.jpg)

**Control.h**

[PRE55]

构造函数将父窗口指针发送到`Window`构造函数，并将其他值存储起来，直到通过`AddControlInfo`将其添加到对话框信息列表中：

[PRE56]

以下方法旨在由子类重写，并且默认为空：

[PRE57]

持有原始大小和位置的矩形由`Dialog`在接收到`MW_INITDIALOG`消息时设置：

[PRE58]

每个控件都有一个身份号码，由`Dialog`中的`AddControl`提供。它有一个常规样式；扩展样式始终为0。样式、左上角和控件大小、类名以及控件文本在`Dialog`中的`DoModal`调用`AddControlInfo`时添加到信息列表中：

[PRE59]

**Control.cpp**

[PRE60]

构造函数为其父对话框调用`AddControl`以将控件添加到对话框并接收控件的身份号码：

[PRE61]

`AddControlInfo`方法，由`Dialog`中的`DoModal`调用，添加控件信息。首先，我们需要将信息列表与双字大小（4字节）对齐：

[PRE62]

帮助身份和扩展样式始终为0：

[PRE63]

样式通过子窗口和可见标志扩展，表示控件是对话框的子窗口，并且当对话框可见时它变得可见：

[PRE64]

控件的上角和大小以**对话框**单位给出，这些单位基于对话框字体，并转换为设备单位：

[PRE65]

控制身份号码用于在用户执行某些操作时识别控制，例如点击按钮或选择列表项：

[PRE66]

每个控件都有一个类名，它是按钮、列表、组合、静态（标签）或编辑（文本字段），以及文本，它是文本字段的文本或框或按钮的标签，但对于列表和组合框则忽略：

[PRE67]

最后，可以与控件一起发送额外数据。然而，我们放弃了这个机会，只发送了0：

[PRE68]

## 按钮控件

有四种按钮控件：组合框、按钮、复选框和单选按钮。复选框和单选按钮可以被选中；`Check`和`IsChecked`方法在`ButtonControl`中定义。

**ButtonControl.h**

[PRE69]

**ButtonControl.cpp**

[PRE70]

我们向复选框、复选框或单选按钮发送`BM_SETCHECK`消息，以确定它是否被选中，并通过发送`BM_GETCHECK`消息来查找它是否被选中：

[PRE71]

组合框非常简单；它封装了一组其他控件，除了其图形外观外没有其他功能。

**GroupBox.h**

[PRE72]

**GroupBox.cpp**

[PRE73]

`clickListener`构造函数参数是一个当用户点击按钮时被调用的监听器。`OnClick`方法覆盖了`Control`类。

**PushButton.h**

[PRE74]

**PushButton.cpp**

[PRE75]

复选框独立于其他复选框工作。`checkPtr`参数是一个指向`Boolean`值的指针，该值设置为`true`或`false`，具体取决于复选框是否被选中。

**CheckBox.h**

[PRE76]

**CheckBox.cpp**

[PRE77]

`OnControlInit`方法覆盖了`Control`类，并根据`checkPtr`指向的值来检查复选框：`OnClick`方法也覆盖了`Control`类，如果复选框被选中，则将值设置为`true`：

[PRE78]

单选按钮旨在与组中的其他单选按钮一起工作，每次恰好选中一个按钮。当用户在组中选中一个按钮时，它会被选中，而之前选中的按钮会被取消选中。组中的每个单选按钮都有一个基于零的索引；`indexPtr`指向一个整数值，该值对所有组中的单选按钮都是共同的，并将其设置为当前选中的按钮的索引。

**RadioButton.h**

[PRE79]

**RadioButton.cpp**

[PRE80]

如果索引为0，则构造函数将组和标签停止样式发送到`Control`构造函数，因为第一个按钮是组中的第一个按钮。组中的所有按钮都不会通过`***Tab***`键访问，而只有第一个按钮。`group`样式表示按钮开始一个组，所有附加的单选按钮都被视为组的成员，直到添加了具有`group`样式的另一个按钮：

[PRE81]

如果单选按钮的索引与`indexPtr`指向的值相同，则该单选按钮被选中，并将值设置为已选按钮的索引：

[PRE82]

## 列表控件

列表框有两种类型：单选列表框和复选列表框。单选列表框一次只能选择一个项目，而复选列表框可以同时选择一个或多个（或全部不选）项目。构造函数接受一个字符串列表，该列表通过`LoadList`加载到列表框中。

**ListControl.h**

[PRE83]

**ListControl.cpp**

[PRE84]

`LoadList`方法通过调用`LB_ADDSTRING`消息将`textList`中的项目文本添加到（单选或复选）列表框中：

[PRE85]

一个（单个）列表框是一个包含可见项的框，与下拉列表的组合框相对。如果需要，列表可以滚动。一次只能选择一个项，与多列表不同。类似于单选框组，构造函数接受一个指向整数值的`indexPtr`指针，该值表示当前选中项的零基于索引。此外，构造函数还接受一个字符串列表，该列表通过`ListControl`中的`LoadList`加载到列表框中。

**ListBox.h**

[PRE86]

**ListBox.cpp**

[PRE87]

我们发送`LB_SETCURSEL`消息来选择一个项，并使用`LB_GETCURSEL`来获取当前选中项的索引：

[PRE88]

多列表框是一个用户可以选择多个值或根本不选择值的列表框；因此，`indexSetPtr`参数是指向索引集的指针，而不是指向单个索引的指针。

**MultipleListBox.h**

[PRE89]

**MultipleListBox.cpp**

[PRE90]

当用户在多列表中选择0个或多个值时，我们遍历索引并为每个索引发送带有`Boolean`值的`LB_SETSEL`消息，该值指示其项是否将被设置：

[PRE91]

当检查哪些值当前被选中时，我们为每个索引发送`LB_GETSEL`消息，并将选中项的索引添加到集合中，然后返回该集合：

[PRE92]

## 组合框

组合框是一个下拉列表项，用户可以从中选择一个。组合框的功能与列表框相同，只是它们的图形外观不同。此外，功能也等同于单选按钮组。类似于`ListBox`和`Radiobutton`，构造函数接受一个`indexPtr`参数，它是一个指向整数值的指针，表示当前选中项的零基于索引。

**ComboBox.h**

[PRE93]

**ComboBox.cpp**

[PRE94]

`CB_ADDSTRING`消息将项加载到组合框中，`CB_SETCURSEL`设置选中项，`CB_GETCURSEL`返回选中项的索引：

[PRE95]

## 标签

标签是一种显示的文本，通常用作文本框的提示；除了其图形外观外，它没有其他功能。

**Label.h**

[PRE96]

**Label.cpp**

[PRE97]

## `TextField`类

`TextField`类是一个文本框的模板；它接受存储在文本框中的值的类型；八进制、十进制或十六进制整数的整数基数（对于非整型类型忽略）；以及下一节中`Converter`类的转换器，它可以在值和文本之间进行转换。构造函数的`valuePtr`参数是指向要编辑的值的指针。

**TextField.h**

[PRE98]

当文本框被创建时，会调用`OnControlInit`方法。它将值转换为文本框中显示的文本。当用户离开文本框时，会调用`OnLoseFocus`方法，如果文本有效，则将其文本转换为模板类型的值。如果文本无效，文本框将设置为从最新有效值转换的文本：

[PRE99]

Win32 API函数`GetWindowText`获取文本字段的文本，`SetWindowText`设置其文本。我们需要通过调用`String`构造函数将零终止的字符指针字符串转换为`String`对象，并通过调用`String`类的`c_str`方法将`String`对象转换为零终止的字符指针：

[PRE100]

当文本字段已初始化时，`Converter`类的`ValueToText`方法被调用，以将`valuePtr`指向的值转换为文本字段中显示的文本：

[PRE101]

当文本字段失去输入焦点时，文本将通过`Check`方法进行评估，以确定它是否适合转换为值。如果适合，则调用`ValueToText`方法进行实际转换，然后文本被加载到文本字段中：

[PRE102]

# 转换器

`Converter`类是一个模板类，旨在通过类型进行特殊化。其任务是转换模板类型和`String`对象之间的值。`Check`变量接受一个字符串，如果它包含一个有效的值则返回`true`，`TextToValue`将文本转换为值，而`ValueToText`将值转换为文本。

**Converter.h**

[PRE103]

## 有符号整数

小窗口自带一组预定义的转换器，这些是`Converter`的特殊化。其中之一处理类型为`int`的有符号整数值。

**Converter.h**

[PRE104]

**Converter.cpp**

[PRE105]

当检查给定的字符串是否包含有效的整数值时，我们创建一个初始化为修剪后的文本（移除了初始和终止的空白字符）的`IStringStream`对象（`istringstream`的泛型版本，使用`TCHAR`代替`char`）。然后，我们使用基数参数将文本读取到整数变量中，并测试流是否已到达文件末尾（`eof`）。如果已到达，则意味着已读取文本的所有字符，这表明文本包含一个有效的整数值，并返回`true`：

[PRE106]

字符串转换为整数的转换与之前我们提到的`Check`函数类似，区别在于我们返回整数值，假设`Check`已经确认文本包含一个有效的整数值：

[PRE107]

当将整数转换为字符串时，我们使用`OStringStream`方法（`ostringstream`的泛型版本），将值写入流，并通过`str`将流转换为字符串返回：

[PRE108]

## 无符号整数

无符号整数与有符号整数的工作方式相同，唯一的区别是`int`被替换为`unsigned int`：

**Converter.h**

[PRE109]

**Converter.cpp**

[PRE110]

## 双精度值

双精度值忽略基数参数，不使用`setbase`操作符；否则，测试和转换与整数情况相同。

**Converter.h**

[PRE111]

**Converter.cpp**

[PRE112]

## 字符串

字符串情况很简单，因为字符串总是可以转换为另一个字符串。

**Converter.h**

[PRE113]

## 有理数

一个**有理数**是一个可以表示为两个整数分数的数，其中第二个整数不为零。在我们的应用中，我们实际上并不使用有理数或下一节中的复数。它们仅用于演示转换器，并在书的附录中实现。

**Converter.h**

[PRE114]

当检查文本是否包含一个有效的有理数时，我们简单地创建一个`Rational`类的对象。如果构造函数接受文本而不抛出`NotaRationalNumber`异常，我们返回`true`。如果它抛出异常，则文本不可接受，我们返回`false`。

**Converter.cpp**

[PRE115]

当将字符串转换为有理数时，我们创建并返回一个`Rational`对象，假设`Check`已经确认该文本包含一个有效的有理数：

[PRE116]

当将有理数转换为字符串时，我们调用`Rational`类的`String`转换操作符。

[PRE117]

## 复数

一个复数是实数*x*和实数*y*乘以**虚数单位***i*的和，*i*是方程*x*² + 1 = 0的解。`Converter`类关于`Complex`类的特殊化与`Rational`特殊化类似。

**Converter.h**

[PRE118]

**Converter.cpp**

[PRE119]

# 页面设置

最后一个部分描述了页面设置功能，分为处理页面设置信息的`PageSetupInfo`类、用于用户输入页面设置信息的`PageSetupDialog`子类，以及将用户在**页面设置**对话框中输入的代码转换为实际值的`Template`函数。

## 页面设置信息

`PageSetupInfo`类包含有关页面的信息：纵向或横向方向、页边距、页眉和页脚的文本和字体、页眉和页脚是否出现在第一页上，以及页面是否被框架包围。

**PageSetupInfo.h**

[PRE120]

**PageSetupInfo.cpp**

[PRE121]

默认构造函数通过调用`PageSetupInfo`初始化默认成员值。

[PRE122]

默认构造函数和赋值操作符复制成员值。

[PRE123]

等价操作符比较所有字段：

[PRE124]

页面设置信息可以写入或从流中读取：

[PRE125]

## 页面设置对话框

`PageSetupDialog`类是Small Windows的一部分，当用户选择**页面设置**菜单项时，由`StandardDocument`框架显示。本书前面的文字处理程序给出了一个示例。`PageSetupDialog`类是`Dialog`的子类，并允许用户在`PageSetupInfo`中输入信息。请注意，页眉和页脚的文本可以用下一节中解释的代码块进行注释。

![页面设置对话框](img/B05475_14_02.jpg)

**PageSetupDialog.h**

[PRE126]

每个按钮都有一个自己的监听器：

[PRE127]

页面设置信息由 `infoPtr` 指向，当用户更改控件的状态时，它将被修改。还有一个 `backupInfo`，以防用户取消对话框：

[PRE128]

**PageSetupDialog.cpp**

[PRE129]

构造函数将指针 `infoPtr` 设置为指向页面设置信息。该信息也存储在 `backupInfo` 中，如果用户取消对话框，将使用它；请参阅 `OnCancel`：

[PRE130]

每个控件都将 **页面设置** 对话框（`this`）作为其父对话框，这意味着控件将由对话框的析构函数删除。这表明我们确实需要跟踪控件以便手动删除。实际上，我们不会手动删除它们，因为这会导致悬空指针：

[PRE131]

注意，我们提供一个引用作为顶部边距值的指针。当用户更改值时，此值将被修改：

[PRE132]

与 `TextField` 的情况类似，我们提供一个指向 `HeaderFirst` 值的引用的指针，这是一个 `Boolean` 值。当用户勾选复选框时，它将被修改：

[PRE133]

当用户按下按钮时，会调用 `OnHeaderFont` 监听器：

[PRE134]

`OnHeaderFont` 和 `OnFooterFont` 方法显示字体对话框：

[PRE135]

`OnOk` 和 `OnCancel` 方法用于终止对话框。`OnCancel` 方法还会复制构造函数在开始时存储的备份信息，因为当用户取消对话框时，不会返回任何新信息：

[PRE136]

## 模板函数

当用户在 **页面设置** 对话框中的页眉和页脚字段中输入文本时，他们可以在文本中插入代码，这些代码需要翻译成有效的值。代码如下表所示：

| **代码** | **描述** | **示例** |
| --- | --- | --- |
| %P | 带后缀的路径 | `C:\Test\Test.wrd` |
| %p | 无后缀的路径 | `C:\Test\Test` |
| %F | 带后缀的文件 | `Test.wrd` |
| %f | 无后缀的文件 | Test |
| %N | 总页数 | 7 |
| %n | 当前页 | 5 |
| %c | 当前副本 | 3 |
| %D | 带完整月份的日期 | 2016年1月1日 |
| %d | 带缩写月份的日期 | 2016年1月1日 |
| %T | 带秒的时间 | 07:08:09 |
| %t | 不带秒的时间 | 07:08 |
| %% | 百分号字符 | % |

`Template` 函数的任务是用有效值替换代码。它接受带有模板代码的 `templateText` 字符串，并返回用有效值替换代码的文本。它还需要当前副本和页码以及总页数。

例如，`页 %n / 总页数 %N` 文本可以翻译为 **页 3 / 5**，而 `文件: %F，日期: %d` 可以翻译为 **文件: Text.txt，日期: 2016年12月31日**。

**Template.h**

[PRE137]

**Template.cpp**

[PRE138]

我们首先用副本数和当前页以及总页数替换 `c`、`n` 和 `N` 代码。数值通过 `to_String` 转换为字符串：

[PRE139]

路径的文件是其最后一个反斜杠（**\**）之后的文本，后缀是其最后一个点（**.**）之后的文本。如果没有反斜杠，文件与路径相同；如果没有点，没有后缀的路径和文件与带有后缀的文件和路径相同：

[PRE140]

当前日期和时间是通过调用标准C函数`time`和`localtime_s`获得的：

[PRE141]

当前时间（带或不带秒）和当前日期（带完整月份名称和缩写月份名称）被写入字符串输出流。`setw`操纵符确保总是写入两个字符，`setfill`在必要时用零填充，而`ios::right`以右对齐的方式写入值：

[PRE142]

最后，我们需要将每个`%%`实例替换为`%`：

[PRE143]

# 摘要

在本章中，我们探讨了自定义对话框、控件、转换器和页面设置对话框。本书剩下的部分是理性类和复数类的实现：
