<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch13"/>Chapter 13.  All Packed and Ready to Deploy </h1></div></div></div><p>In the previous chapter, you learned to create a robust application with unit tests. The final step for an application is packaging. The Qt framework enables you to develop cross-platform applications but packaging is really a platform-specific task. Moreover, when your application is ready to be shipped, you need a one-step procedure to generate and pack your application.</p><p>In this chapter, we will reuse the gallery application (both on desktop and mobile platforms) to learn the steps required to package a Qt application. There are many ways to prepare the packaging of an application. In this chapter, we want to package the gallery application, from <a class="link" title="Chapter 4.  Conquering the Desktop UI" href="part0040.xhtml#aid-164MG2">Chapters 4</a>, <em>Conquering the Desktop UI</em>, and <a class="link" title="Chapter 5.  Dominating the Mobile UI" href="part0048.xhtml#aid-1DOR02">Chapter 5</a>, <em>Dominating the Mobile UI</em>, on the supported platforms (Windows, Linux, Mac, Android, and iOS).</p><p>Here are the topics covered in this chapter:</p><div><ul class="itemizedlist"><li class="listitem">Packaging a Qt application on Windows</li><li class="listitem">Packaging a Qt application on Linux</li><li class="listitem">Packaging a Qt application on Mac</li><li class="listitem">Packaging a Qt application on Android</li><li class="listitem">Packaging a Qt application on iOS</li></ul></div><div><div><div><div><h1 class="title"><a id="ch13lvl1sec115"/>Packaging your application</h1></div></div></div><p>You will create, for each platform, a dedicated script to perform all the tasks required to build a standalone application. Depending on the OS type, the packaged application will be <code class="literal">gallery-desktop</code> or <code class="literal">gallery-mobile</code>. Because the whole gallery project has to be compiled, it also has to include <code class="literal">gallery-core</code>. Therefore, we will create a parent project with <code class="literal">gallery-core</code>, <code class="literal">gallery-desktop</code>, and <code class="literal">gallery-mobile</code>.</p><p>For each platform, we will prepare the project to be packaged and create a specific script. All the scripts follow the same workflow:</p><div><ol class="orderedlist arabic"><li class="listitem">Set the input and output directories.</li><li class="listitem">Create Makefiles with <code class="literal">qmake</code>.</li><li class="listitem">Build the project.</li><li class="listitem">Regroup only the necessary files in the output directory.</li><li class="listitem">Package the application with platform-specific tasks.</li><li class="listitem">Store the packed application in the output directory.</li></ol><div></div><p>These scripts could run on a developer computer or on a continuous integration server running software such as Jenkins as long as the packaging computer OS matches the script target OS (except for the mobile platforms). In other words, you need to run the Windows script on a computer that runs Windows to be able to package a Qt application for Windows.</p><p>Technically, you can perform cross-compilation (given the appropriate toolchain and libraries), but this is beyond the scope of this book. It is easy to cross-compile for a RaspberryPI when you are on Linux, but the same cannot be said when you want to compile for MacOS and you are on Windows.</p><div><h3 class="title"><a id="note54"/>Note</h3><p>From Linux, you can cross-compile Qt for Windows with tools such as MXE at <a class="ulink" href="http://mxe.cc/">http://mxe.cc/</a>.</p></div><p>Create a new subdir project named <code class="literal">ch13-gallery-packaging</code> with the following hierarchy:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">ch13-gallery-packaging</code>:<div><ul class="itemizedlist"><li class="listitem"><code class="literal">gallery-core</code></li><li class="listitem"><code class="literal">gallery-desktop</code></li><li class="listitem"><code class="literal">gallery-mobile</code></li></ul></div></li></ul></div><p>Even if you are now an expert on Qt subdirs projects, here is the <code class="literal">ch13-gallery-packaging.pro</code> file:</p><pre class="programlisting">TEMPLATE = subdirs 
 
SUBDIRS += \ 
    gallery-core \ 
    gallery-desktop \ 
    gallery-mobile 
 
gallery-desktop.depends = gallery-core 
gallery-mobile.depends = gallery-core 
</pre><p>You are now ready to work through any of the following sections, depending on the platform you are targeting.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec116"/>Packaging for Windows</h1></div></div></div><p>To package a standalone application on Windows, you need to provide all the dependencies of your executable. The <code class="literal">gallery-core.dll</code> file, the Qt libraries (for example, <code class="literal">Qt5Core.dll</code>), and compiler-specific libraries (for example, <code class="literal">libstdc++-6.dll</code>) are some examples of dependencies required by our executable. If you forget to provide a library, an error will be displayed when you run the <code class="literal">gallery-desktop.exe</code> program.</p><div><h3 class="title"><a id="note55"/>Note</h3><p>On Windows, you can use the utility Dependency Walker (<code class="literal">depends</code>). It will give you a list of all libraries required by your application. You can download it here: <a class="ulink" href="http://www.dependencywalker.com">www.dependencywalker.com</a>.</p></div><p>For this section, we will create a script to build the project via the command line interface. Then we will use the Qt tool <code class="literal">windeployqt</code> to gather all dependencies required by our application. This example is for a MinGW compiler but you can easily adapt it for a MSVC compiler.</p><p>Here is a list of required files and folders gathered by <code class="literal">winqtdeploy</code>, to properly run <code class="literal">gallery-desktop</code> on Windows:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">iconengines</code>:<div><ul class="itemizedlist"><li class="listitem"><code class="literal">qsvgicon.dll</code></li></ul></div></li><li class="listitem"><code class="literal">imageformats</code>:<div><ul class="itemizedlist"><li class="listitem"><code class="literal">qjpeg.dll</code></li><li class="listitem"><code class="literal">qwbmp.dll</code></li><li class="listitem"><code class="literal">...</code></li></ul></div></li><li class="listitem"><code class="literal">Platforms</code>:<div><ul class="itemizedlist"><li class="listitem"><code class="literal">qwindows.dll</code></li></ul></div></li><li class="listitem"> <code class="literal">translations</code>:<div><ul class="itemizedlist"><li class="listitem"><code class="literal">qt_en.qm</code></li><li class="listitem"><code class="literal">qt_fr.qm</code></li><li class="listitem"><code class="literal">...</code></li></ul></div></li><li class="listitem"><code class="literal">D3Dcompiler_47.dll</code></li><li class="listitem"><code class="literal">gallery-core.dll</code></li><li class="listitem"><code class="literal">gallery-desktop.exe</code></li><li class="listitem"><code class="literal">libEGL.dll</code></li><li class="listitem"><code class="literal">libgcc_s_dw2-1.dll</code></li><li class="listitem"><code class="literal">libGLESV2.dll</code></li><li class="listitem"><code class="literal">libstdc++-6.dll</code></li><li class="listitem"><code class="literal">libwinpthread-1.dll</code></li><li class="listitem"><code class="literal">opengl32sw.dll</code></li><li class="listitem"><code class="literal">Qt5Core.dll</code></li><li class="listitem"><code class="literal">Qt5Gui.dll</code></li><li class="listitem"><code class="literal">Qt5Svg.dll</code></li><li class="listitem"><code class="literal">Qt5Widgets.dll</code></li></ul></div><p>Check that your environment variables are correctly set:</p><div><img src="img/image00446.jpeg" alt="Packaging for Windows"/></div><p style="clear:both; height: 1em;"> </p><p>Create a file, <code class="literal">package-windows.bat</code>, in the <code class="literal">scripts</code> directory:</p><pre class="programlisting">@ECHO off 
 
set DIST_DIR=dist\desktop-windows 
set BUILD_DIR=build 
set OUT_DIR=gallery 
 
mkdir %DIST_DIR% &amp;&amp; pushd %DIST_DIR% 
mkdir %BUILD_DIR% %OUT_DIR% 
 
pushd %BUILD_DIR% 
%QTDIR%\bin\qmake.exe ^ 
  -spec win32-g++ ^ 
  "CONFIG += release" ^ 
  ..\..\..\ch13-gallery-packaging.pro 
 
%MINGWROOT%\bin\mingw32-make.exe qmake_all 
 
pushd gallery-core 
%MINGWROOT%\bin\mingw32-make.exe &amp;&amp; popd 
 
pushd gallery-desktop 
%MINGWROOT%\bin\mingw32-make.exe &amp;&amp; popd 
 
popd 
copy %BUILD_DIR%\gallery-core\release\gallery-core.dll %OUT_DIR% 
copy %BUILD_DIR%\gallery-desktop\release\gallery-desktop.exe %OUT_DIR% 
%QTDIR%\bin\windeployqt %OUT_DIR%\gallery-desktop.exe %OUT_DIR%\gallery-core.dll 
 
popd 
</pre><p>Let's talk about the steps performed:</p><div><ol class="orderedlist arabic"><li class="listitem">Set the main path variables. The output directory is <code class="literal">DIST_DIR</code>. All files are generated in the <code class="literal">dist/desktop-windows/build</code> directory.</li><li class="listitem">Create all directories and launch <code class="literal">dist/desktop-windows/build</code>.</li><li class="listitem">Execute <code class="literal">qmake</code> in release mode for the Win32 platform to generate the parent project <code class="literal">Makefile</code>. The spec <code class="literal">win32-g++</code> is for the MinGW compiler. You should use the spec <code class="literal">win32-msvc</code> if you want to use the MSVC compiler.</li><li class="listitem">Run the <code class="literal">mingw32-make qmake_all</code> command to generate the sub-project Makefiles. With an MSVC compiler you must replace <code class="literal">mingw32-make</code> with <code class="literal">nmake</code> or <code class="literal">jom</code>.</li><li class="listitem">Perform the <code class="literal">mingw32-make</code> commands to build each required sub-project.</li><li class="listitem">Copy the generated files, <code class="literal">gallery-desktop.exe</code> and <code class="literal">gallery-core.dll,</code> into the <code class="literal">gallery</code> directory.</li><li class="listitem">Call the Qt tool, <code class="literal">windeployqt</code>, on both files and copy all required dependencies (for example, <code class="literal">Qt5Core.dll</code>, <code class="literal">Qt5Sql.dll</code>,
 <code class="literal">libstdc++-6.dll</code>, <code class="literal">qwindows.dll</code>, and so on).</li></ol><div></div></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec117"/>Packaging for Linux with a distribution package</h1></div></div></div><p>Packaging an application for a Linux distribution is a bumpy road. Because each distribution can have its own packaging format (<code class="literal">.deb</code>, <code class="literal">.rpm</code>, and so on), the first question to answer is: which distribution do you wish to target? Covering every major packaging format would take several chapters. Even detailing a single distribution could be unfair (you wanted to package for RHEL? Too bad, we only covered Arch Linux!). After all, from a Qt application developer perspective, what you want is to ship your product to your users, you do not (yet) aim to become an official Debian repository maintainer.</p><p>Having all this in mind, we decided to focus on a tool that packages the application for you for each distribution. That is right, you do not need to learn the internals of Debian or Red Hat! We will still explain the common principles in the packaging systems without excessive detail.</p><p>For our purpose, we will demonstrate how a packaging can be done using the <code class="literal">.deb</code> format on an Ubuntu machine, but as you will see it can be easily updated to generate a <code class="literal">.rpm</code>.</p><p>The tool we are going to use is named <code class="literal">fpm</code> (<strong>eFfing Package Management</strong>).</p><div><h3 class="title"><a id="note56"/>Note</h3><p>The <code class="literal">fpm</code> tool is available at <a class="ulink" href="https://github.com/jordansissel/fpm">https://github.com/jordansissel/fpm</a>.</p></div><p>The <code class="literal">fpm</code> tool is a Ruby application that aims to do exactly what we need: take care of the distribution-specific details and generate the final package. First, take the time to install <code class="literal">fpm</code> on your machine and make sure that it is working.</p><p>In a nutshell, a Linux package is a file format that contains all the files you want to deploy with a lot of metadata. It can contain description of the content, a changelog, a license file, the list of dependencies, checksums, pre- and post-installation triggers, and much, much more.</p><div><h3 class="title"><a id="note57"/>Note</h3><p>If you want to learn how to package a Debian binary by hand, go to <a class="ulink" href="http://tldp.org/HOWTO/html_single/Debian-Binary-Package-Building-HOWTO/">http://tldp.org/HOWTO/html_single/Debian-Binary-Package-Building-HOWTO/</a>.</p></div><p>In our case, we still have to do some project preparation to let <code class="literal">fpm</code> do its job. The files we want to deploy have to match the target filesystem. Here is how the deployment should look:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">gallery-desktop</code>: This binary should be deployed in <code class="literal">/usr/bin</code></li><li class="listitem"><code class="literal">libgallery-core.so</code>: This should be deployed in <code class="literal">/usr/lib</code></li></ul></div><p>To achieve this, we are going to organize our outputs in <code class="literal">dist/desktop-linux</code> like so:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="literal">build</code> directory will contain the compiled project (it is our release shadow build)</li><li class="listitem">The <code class="literal">root</code> directory will contain the to-be-packaged files, meaning the binary and library files in the proper hierarchy (<code class="literal">usr/bin</code> and <code class="literal">usr/lib</code>)</li></ul></div><p>To generate the root directories, we will rely on Qt and the power of the <code class="literal">.pro</code> files. When compiling a Qt project, the target files are already tracked. All we have to do is to add an additional install target for <code class="literal">gallery-core</code> and <code class="literal">gallery-desktop</code>.</p><p>Add the following scope in <code class="literal">gallery-core/gallery-core.pro</code>:</p><pre class="programlisting">linux { 
    target.path = $$_PRO_FILE_PWD_/../dist/desktop-linux/root/usr/lib/ 
    INSTALLS += target 
} 
</pre><p>Here we define a new <code class="literal">target.path</code> that is going to deploy the <code class="literal">DISTFILES</code> (the <code class="literal">.so</code> files) to our desired root tree. Note the use of <code class="literal">$$_PRO_FILE_PWD_</code>, which points to the directory where the current <code class="literal">.pro</code> file is stored.</p><p>Almost the same procedure is carried out in <code class="literal">gallery-desktop/gallery-desktop.pro</code>:</p><pre class="programlisting">linux { 
    target.path = $$_PRO_FILE_PWD_/../dist/desktop-linux/root/usr/bin/ 
    INSTALLS += target 
} 
</pre><p>With these lines, when we call make install, the files are going to be deployed in <code class="literal">dist/desktop-linux/root/...</code>.</p><p>Now that the project configuration is completed, we can switch to the packaging script. We will cover the script in two parts:</p><div><ul class="itemizedlist"><li class="listitem">Project compilation and <code class="literal">root</code> preparation</li><li class="listitem">The <code class="literal">.deb</code> package generation with <code class="literal">fpm</code></li></ul></div><p>First, check that your environment variables are correctly set:</p><div><img src="img/image00447.jpeg" alt="Packaging for Linux with a distribution package"/></div><p style="clear:both; height: 1em;"> </p><p>Create <code class="literal">scripts/package-linux-deb.sh</code> with the following content:</p><pre class="programlisting">#!/bin/bash 
 
DIST_DIR=dist/desktop-linux 
BUILD_DIR=build 
ROOT_DIR=root 
 
BIN_DIR=$ROOT_DIR/usr/bin 
LIB_DIR=$ROOT_DIR/usr/lib 
 
mkdir -p $DIST_DIR &amp;&amp; cd $DIST_DIR 
mkdir -p $BIN_DIR $LIB_DIR $BUILD_DIR 
 
pushd $BUILD_DIR 
$QTDIR/bin/qmake \ 
    -spec linux-g++ \ 
    "CONFIG += release" \ 
    ../../../ch13-gallery-packaging.pro 
 
make qmake_all 
pushd gallery-core &amp;&amp; make &amp;&amp; make install ; popd 
pushd gallery-desktop &amp;&amp; make &amp;&amp; make install ; popd 
popd 
</pre><p>Let's break this down:</p><div><ol class="orderedlist arabic"><li class="listitem">Set the main path variables. The output directory is <code class="literal">DIST_DIR</code>. All files are generated in the <code class="literal">dist/desktop-linux/build</code> folder.</li><li class="listitem">Create all the directories and launch <code class="literal">dist/desktop-linux/build</code>.</li><li class="listitem">Execute <code class="literal">qmake</code> in release mode for the Linux platform to generate the parent project <code class="literal">Makefile</code>.</li><li class="listitem">Run the <code class="literal">make qmake_all</code> command to generate the sub-projects Makefiles.</li><li class="listitem">Perform the <code class="literal">make</code> commands to build each required sub-project.</li><li class="listitem">Use the <code class="literal">make install</code> command to deploy the binary and the libraries to the <code class="literal">dist/desktop-linux/root</code> directory.</li></ol><div></div><p>If you execute <code class="literal">scripts/package-linux-deb.sh</code>, the final file tree in <code class="literal">dist/desktop-linux</code> looks like this:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">build/</code><div><ul class="itemizedlist"><li class="listitem"><code class="literal">gallery-core/*.o</code></li><li class="listitem"><code class="literal">gallery-desktop/*.p</code></li><li class="listitem"><code class="literal">Makefile</code></li></ul></div></li><li class="listitem"><code class="literal">root/</code><div><ul class="itemizedlist"><li class="listitem"><code class="literal">usr/bin/gallery-desktop</code></li><li class="listitem"><code class="literal">usr/lib/libgallery-core.so</code></li></ul></div></li></ul></div><p>Everything is now ready for <code class="literal">fpm</code> to work. The final part of <code class="literal">scripts/package-linux-deb.sh</code> contains this:</p><pre class="programlisting">fpm --input-type dir \ 
    --output-type deb \ 
    --force \ 
    --name gallery-desktop \ 
    --version 1.0.0 \ 
    --vendor "Mastering Qt 5" \ 
    --description "A Qt gallery application to organize and manage your pictures in albums" \ 
    --depends qt5-default \ 
    --depends libsqlite3-dev \ 
    --chdir $ROOT_DIR \ 
    --package gallery-desktop_VERSION_ARCH.deb 
</pre><p>Most of the arguments are explicit enough. We will focus on the most important ones:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">--input-type</code>: This argument refers to what <code class="literal">fpm</code> will work with. It can take <code class="literal">deb</code>, <code class="literal">rpm</code>, <code class="literal">gem</code>, <code class="literal">dir</code> and so on and repackage it to another format. Here we use the <code class="literal">dir</code> option to tell <code class="literal">fpm</code> to use a directory tree as the input source.</li><li class="listitem"><code class="literal">--output-type</code>: This argument refers to the desired output type. Take a look at the official documentation to see how many platforms are supported.</li><li class="listitem"><code class="literal">--name</code>: This is the name given to the package (if you want to uninstall it, you write <code class="literal">apt-get remove gallery-desktop</code>).</li><li class="listitem"><code class="literal">--depends</code>: This argument refers to a library package dependency of the project. You can add as many dependencies as you want. In our case, we only depend on <code class="literal">qt5 -default</code> and <code class="literal">sqlite3-dev</code>. This option is very important so be sure that the application will be able to run on the target platform. You can specify the version of the dependency with <code class="literal">--depends library &gt;= 1.2.3</code>.</li><li class="listitem"><code class="literal">--chdir</code>: This argument refers to the base directory from which <code class="literal">fpm</code> will run. We set it to <code class="literal">dist/desktop-linux/root</code>, where our file tree is ready to be loaded!</li><li class="listitem"><code class="literal">--package</code>: This argument is the name of the final package. The <code class="literal">VERSION</code> and <code class="literal">ARCH</code> are placeholders that are automatically filled based on your system.</li></ul></div><p>The rest of the options are purely informative; you can specify a changelog, a license file, and much more. Just by changing the <code class="literal">--output-type</code><code class="literal">deb</code> to <code class="literal">rpm</code>, the package format is properly updated. The <code class="literal">fpm</code> tool also provides specific package format options, letting you have fine control over what is generated.</p><p>If you now execute <code class="literal">scripts/package-linux-deb.sh</code>, you should get a new <code class="literal">dist/desktop-linux/gallery-desktop_1.0.0_amd64.deb</code> file. Try to install it with the commands:</p><pre class="programlisting">
<strong>sudo dpkg -i  dist/desktop-linux/gallery-desktop_1.0.0_amd64.deb</strong>
<strong>sudo apt-get install -f</strong>
</pre><p>The first command deploys the package in your system. You should now have the files <code class="literal">/usr/bin/gallery-desktop</code> and <code class="literal">/usr/lib/libgallery-core.so</code>.</p><p>However, because we installed the package using the <code class="literal">dpkg</code> command, the dependencies are not automatically installed. This would be done if the package was provided by a Debian repository (thus, installing the package with <code class="literal">apt-get install gallery-desktop</code>). The missing dependencies are still "marked" and <code class="literal">apt-get install -f</code> does their installation.</p><p>You can now start <code class="literal">gallery-desktop</code> from anywhere in your system with the command, <code class="literal">gallery-desktop</code>. When we wrote this chapter in 2016, if you execute it on a "fresh" Ubuntu, you might run into the following issue:</p><pre class="programlisting">
<strong>$ gallery-desktop </strong>
<strong>gallery-desktop: /usr/lib/x86_64-linux-gnu/libQt5Core.so.5: version `Qt_5.7' not found (required by gallery-desktop)</strong>
<strong>gallery-desktop: /usr/lib/x86_64-linux-gnu/libQt5Core.so.5: version `Qt_5' not found (required by gallery-desktop)</strong>
<strong>...</strong>
<strong>gallery-desktop: /usr/lib/x86_64-linux-gnu/libQt5Core.so.5: version `Qt_5' not found (required by /usr/lib/libgallery-core.so.1)</strong>
</pre><p>What happened? We installed the dependencies with <code class="literal">apt-get install -f</code>! We encounter here a major pain point in Linux package management. The dependencies we specify in our <code class="literal">.deb</code> could refer to a specific version of Qt, but the reality is that we depend on the package version maintained by the upstream. In other words, each time a new version of Qt is released, the distribution maintainers (Ubuntu, Fedora, and so on) have to repackage it to make it available in the official repository. This can be a long process and the maintainers have a huge number of packages to port!</p><p>To be confident about what we are stating, let's view the library dependencies of <code class="literal">gallery-desktop</code> with an <code class="literal">ldd</code> command:</p><pre class="programlisting">
<strong>$ ldd /usr/bin/gallery-desktop</strong>
<strong>    libgallery-core.so.1 =&gt; /usr/lib/libgallery-core.so.1 (0x00007f8110775000)</strong>
<strong>    libQt5Widgets.so.5 =&gt; /usr/lib/x86_64-linux-gnu/libQt5Widgets.so.5 (0x00007f81100e8000)</strong>
<strong>    libQt5Gui.so.5 =&gt; /usr/lib/x86_64-linux-gnu/libQt5Gui.so.5 (0x00007f810fb9f000)</strong>
<strong>    libQt5Core.so.5 =&gt; /usr/lib/x86_64-linux-gnu/libQt5Core.so.5 (0x00007f810f6c9000)</strong>
<strong>   ...</strong>
<strong>    libXext.so.6 =&gt; /usr/lib/x86_64-linux-gnu/libXext.so.6 (0x00007f810966e000)</strong>
</pre><p>As you can see, <code class="literal">libgallery-core.so</code> is correctly resolved in <code class="literal">/usr/lib</code> and the Qt dependencies too in <code class="literal">/usr/lib/x86_64-linux-gnu</code>. But what version of Qt is used? The answer lies in the details of the libraries:</p><pre class="programlisting">
<strong>$ ll /usr/lib/x86_64-linux-gnu/libQt5Core.*</strong>
<strong>-rw-r--r-- 1 root root    1014 may    2 15:37 libQt5Core.prl</strong>
<strong>lrwxrwxrwx 1 root root      19 may    2 15:39 libQt5Core.so -&gt; libQt5Core.so.5.5.1</strong>
<strong>lrwxrwxrwx 1 root root      19 may    2 15:39 libQt5Core.so.5 -&gt; libQt5Core.so.5.5.1</strong>
<strong>lrwxrwxrwx 1 root root      19 may    2 15:39 libQt5Core.so.5.5 -&gt; libQt5Core.so.5.5.1</strong>
<strong>-rw-r--r-- 1 root root 5052920 may    2 15:41 libQt5Core.so.5.5.1</strong>
</pre><p>The <code class="literal">libQt5Core.so</code> file is a soft link to <code class="literal">libQt5Core.so.5.5.1</code>, meaning that the system version of Qt is 5.5.1, whereas <code class="literal">gallery-desktop</code> relies on Qt 5.7. You can configure your system to have the system Qt pointing to your Qt installation (done with the Qt installer). However, it is highly improbable that your customer will install Qt by hand just to have <code class="literal">gallery-desktop</code> running.</p><p>Even worse, for an older version of your distribution, the packages are usually not updated at all after some time. Just try to install a Qt 5.7 Debian package on Ubuntu 14.04 to understand how complicated things become. We did not even mention incompatible dependencies. If we rely on a specific version of <code class="literal">libsqlite3-dev</code> and another application needs another one, things will get ugly, and only one can survive.</p><p>A Linux package has many advantages if you want it to be available on an official repository or if you have specific needs. Using official repositories is a common way of installing an application on Linux and your users will not be disoriented. If you can restrict your Qt version to the one deployed on the Linux distribution that may be a fine solution.</p><p>Unfortunately, it also brings major headaches: you need to support multiple distributions, handle the dependencies without breaking the system, and make sure that your application has old enough dependencies, and so on.</p><p>Do not worry, everything is not lost; smart people are already resolving this issue on Linux with self-contained packages. As a matter of fact, we are going to cover a self-contained package.</p></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec118"/>Packaging for Linux with AppImage</h1></div></div></div><p>On Windows or Mac, an application is self-sufficient: it contains all the dependencies it needs to be executed. On the one hand, this creates more file duplication, and on the other hand it simplifies packaging for the developer.</p><p>Based on this premise, efforts have been made to have the same pattern on Linux (as opposed to a repository/distribution-specific package). Today, several solutions offer a self-contained package on Linux. We suggest you study one of these solutions: AppImage. This particular tool is gaining traction in the Linux community. There is a growing number of developers relying on AppImage to package and deploy their application.</p><p>AppImage is a file format that contains an application with all its libraries included. You download a single AppImage file, execute it, and you are done: the application is running. Behind the scenes, an AppImage is an ISO file on steroids, mounted on-the-fly when you execute it. The AppImage file itself is read-only and can also run in a sandbox such as Firejail (a SUID sandbox program that reduces the risk of security breaches by restricting the running environment of applications).</p><div><h3 class="title"><a id="note58"/>Note</h3><p>More information on AppImage is available at <a class="ulink" href="http://appimage.org/">http://appimage.org/</a>.</p></div><p>To package <code class="literal">gallery-desktop</code> into an AppImage, there are two major steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Gather all the dependencies of <code class="literal">gallery-desktop</code>.</li><li class="listitem">Package <code class="literal">gallery-desktop</code> and its dependencies in the AppImage format.</li></ol><div></div><p>Fortunately, this whole process can be done by using a nifty tool: <code class="literal">linuxdeployqt</code>. It started as a hobby project and became the official way to package a Qt application in the AppImage documentation.</p><div><h3 class="title"><a id="note59"/>Note</h3><p>Get <code class="literal">linuxdeployqt</code> from <a class="ulink" href="https://github.com/probonopd/linuxdeployqt/">https://github.com/probonopd/linuxdeployqt/</a>.</p></div><p>The script we are going to write now assumes that the binary <code class="literal">linuxdeployqt</code> is available in your <code class="literal">$PATH</code> variable. Check that your environment variables are correctly set:</p><div><img src="img/image00448.jpeg" alt="Packaging for Linux with AppImage"/></div><p style="clear:both; height: 1em;"> </p><p>Create <code class="literal">scripts/package-linux-appimage.sh</code> and update it like so:</p><pre class="programlisting">#!/bin/bash 
 
DIST_DIR=dist/desktop-linux 
BUILD_DIR=build 
 
mkdir -p $DIST_DIR &amp;&amp; cd $DIST_DIR 
mkdir -p $BUILD_DIR 
 
pushd $BUILD_DIR 
$QTDIR/bin/qmake \ 
    -spec linux-g++ \ 
    "CONFIG += release" \ 
    ../../../ch13-gallery-packaging.pro 
make qmake_all 
pushd gallery-core &amp;&amp; make ; popd 
pushd gallery-desktop &amp;&amp; make ; popd 
popd 
 
export QT_PLUGIN_PATH=$QTDIR/plugins/ 
export LD_LIBRARY_PATH=$QTDIR/lib:$(pwd)/build/gallery-core 
 
linuxdeployqt \ 
    build/gallery-desktop/gallery-desktop \ 
    -appimage 
 
mv build/gallery-desktop.AppImage . 
</pre><p>The first part is the compilation of the project:</p><div><ol class="orderedlist arabic"><li class="listitem">Set the main path variables. The output directory is <code class="literal">DIST_DIR</code>. All files are generated in the <code class="literal">dist/desktop-linux/build</code> folder.</li><li class="listitem">Create all the directories and go in <code class="literal">dist/desktop-linux/build</code>.</li><li class="listitem">Execute <code class="literal">qmake</code> in release mode for the Linux platform to generate the parent project <code class="literal">Makefile</code>.</li><li class="listitem">Run the <code class="literal">make qmake_all</code> command to generate the sub-project Makefiles.</li><li class="listitem">Perform the <code class="literal">make</code> commands to build each required sub-project.</li></ol><div></div><p>The second part of the script concerns <code class="literal">linuxdeployqt</code>. We first have to export some paths to let <code class="literal">linuxdeployqt</code> properly find all the dependencies of <code class="literal">gallery-desktop</code> (Qt libraries and the <code class="literal">gallery-core</code> library).</p><p>After that, we execute <code class="literal">linuxdeployqt</code> by specifying the source binary to work with and the target file type (AppImage). The resulting file is a single <code class="literal">gallery-desktop.AppImage</code> ready to be launched on the user's computer without any Qt package installed!</p></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec119"/>Packaging for Mac OS X</h1></div></div></div><p>On OS X, applications are built and run from a bundle: a single directory that contains the application binary and all its dependencies. In the Finder, these bundles are viewed as <code class="literal">.app</code> special directories.</p><p>When running <code class="literal">gallery-desktop</code> from Qt Creator, the application is already bundled in a <code class="literal">.app</code> file. Because we are using a custom library, <code class="literal">gallery-core</code>, this <code class="literal">gallery-desktop.app</code> does not contain all the dependencies and Qt Creator handles it for us.</p><p>What we aim to create is a script that completely packages <code class="literal">gallery-desktop</code> (<code class="literal">gallery-core</code> included) in a <code class="literal">.dmg</code> file, a Mac OS X disk image file that is mounted upon execution and lets the user install the application with ease.</p><p>To achieve this, Qt provides the <code class="literal">macdeployqt</code> tool, which gathers the dependencies and creates the <code class="literal">.dmg</code> file.</p><p>First, check that your environment variables are correctly set:</p><div><img src="img/image00449.jpeg" alt="Packaging for Mac OS X"/></div><p style="clear:both; height: 1em;"> </p><p>Create the <code class="literal">scripts/package-macosx.sh</code> file with the following content:</p><pre class="programlisting">#!/bin/bash 
 
DIST_DIR=dist/desktop-macosx 
BUILD_DIR=build 
 
mkdir -p $DIST_DIR &amp;&amp; cd $DIST_DIR 
mkdir -p $BUILD_DIR 
 
pushd $BUILD_DIR 
$QTDIR/bin/qmake \ 
  -spec macx-clang \ 
  "CONFIG += release x86_64" \ 
  ../../../ch13-gallery-packaging.pro 
make qmake_all 
pushd gallery-core &amp;&amp; make ; popd 
pushd gallery-desktop &amp;&amp; make ; popd 
 
cp gallery-core/*.dylib \ 
    gallery-desktop/gallery-desktop.app/Contents/Frameworks/ 
 
install_name_tool -change \ 
  libgallery-core.1.dylib \ 
  @rpath/libgallery-core.1.dylib \ 
  gallery-desktop/gallery-desktop.app/Contents/MacOS/gallery-desktop 
popd 
 
$QTDIR/bin/macdeployqt \ 
    build/gallery-desktop/gallery-desktop.app \ 
    -dmg 
 
mv build/gallery-desktop/gallery-desktop.dmg . 
</pre><p>We can split the script in two. The first part prepares the application for <code class="literal">macdeployqt</code>:</p><div><ol class="orderedlist arabic"><li class="listitem">Set the main path variables. The output directory is <code class="literal">DIST_DIR</code>. All files are generated in the <code class="literal">dist/desktop-macosx/build</code> folder.</li><li class="listitem">Create all the directories and go in <code class="literal">dist/desktop-macosx/build</code>.</li><li class="listitem">Execute <code class="literal">qmake</code> in release mode for the Mac OS X platform to generate the parent project <code class="literal">Makefile</code>.</li><li class="listitem">Run the <code class="literal">make qmake_all</code> command to generate the sub-projects Makefiles.</li><li class="listitem">Perform the <code class="literal">make</code> commands to build each required sub-project.</li></ol><div></div><p>The following part includes the <code class="literal">gallery-core</code> library in the generated <code class="literal">gallery-desktop.app</code>. If we do not execute the <code class="literal">cp</code> command stated in the script and everything that comes after it, we might be quite surprised by the <code class="literal">gallery-desktop</code> binary content. Let's take a look at it by executing the following command:</p><pre class="programlisting">
<strong>$ otool -L dist/desktop-macosx/build/gallery-desktop/gallery-desktop.app/Contents/MacOS/gallery-desktop </strong>
<strong>dist/desktop-macosx/build/gallery-desktop/gallery-desktop.app/Contents/MacOS/gallery-desktop:</strong>
<strong>  libgallery-core.1.dylib (compatibility version 1.0.0, current version 1.0.0)</strong>
<strong>  @rpath/QtWidgets.framework/Versions/5/QtWidgets (compatibility version 5.7.0, current version 5.7.0)</strong>
<strong>...</strong>
<strong>  /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1226.10.1)</strong>
</pre><p>As you can see, <code class="literal">libgallery-core.1.dylib</code> is resolved in the local path but not in the special dependencies path as is done for <code class="literal">QtWidget</code> with <code class="literal">@rpath</code> (namely <code class="literal">Contents/Frameworks/</code>). To mitigate this, <code class="literal">package-macosx.sh</code> copies the <code class="literal">.dylib</code> file in <code class="literal">gallery-desktop.app/Contents/Frameworks/</code> and regenerates the dependencies index of the binary with <code class="literal">install_name_tool</code>.</p><p>Finally, in <code class="literal">package-macosx.sh</code>, <code class="literal">macdeployqt</code> is called with the updated <code class="literal">gallery-deskop.app</code> and the target <code class="literal">dmg</code> format. The resulting <code class="literal">gallery-desktop.dmg</code> can be deployed on your user computer.</p></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec120"/>Packaging for Android</h1></div></div></div><p>The aim of this section is to generate a standalone APK file for the <code class="literal">gallery-mobile</code> application. Packaging and deploying an application for Android require multiple steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Configure the Android build details.</li><li class="listitem">Generate a keystore and a certificate.</li><li class="listitem">Customize the Android manifest from a template.</li><li class="listitem">Create a script to automate the packaging.</li></ol><div></div><p>You can do most of the tasks directly from Qt Creator. Under the hood, the Qt tool, <code class="literal">androiddeployqt</code>, is called to generate the APK file. Go to <strong>Projects</strong> | <strong>Android for armeabi-v7a</strong> | <strong>Build Steps</strong>. You should see a special build step: <strong>Build Android APK</strong>. The details look like the following screenshot:</p><div><img src="img/image00450.jpeg" alt="Packaging for Android"/></div><p style="clear:both; height: 1em;"> </p><p>The first thing to do is to select which Android API level you want to use to generate the <strong>Application</strong>. In our case, we selected <strong>android-23</strong> for the Android API Level 23. Try to always build your application with the latest SDK version available.</p><p>To publish your application on the Play Store, you must sign the package. To be able to update an application, the signature of the current version and the new version must be the same. This procedure is a protection to make sure that any future versions of the application were really created by you. The first time you should create a keystore, the next time you can reuse it with the <strong>Browse...</strong> button. For now, click on the <strong>Create...</strong> button on the <strong>Sign package</strong>  |<strong>Keystore</strong> line. You will get the following popup:</p><div><img src="img/image00451.jpeg" alt="Packaging for Android"/></div><p style="clear:both; height: 1em;"> </p><p>Follow these steps to generate a new keystore:</p><div><ol class="orderedlist arabic"><li class="listitem">The keystore must be protected by a password. Do not forget it or you will not be able to use this keystore for a future release.</li><li class="listitem">Specify an <strong>Alias name</strong> for the certificate. The default values for <strong>Keysize</strong> and <strong>Validity(days)</strong> are fine. You can specify a different password for the certificate or use the keystore one.</li><li class="listitem">In the <strong>Certificate Distinguished Names</strong> group, enter information about you and your company.</li><li class="listitem">Save the keystore file in a safe place.</li><li class="listitem">Enter the keystore password to validate its selection for the deployment.</li></ol><div></div><p>The next part concerns <strong>Qt deployment</strong>. Indeed, your application needs some Qt libraries. Qt supports three kinds of deployment:</p><div><ul class="itemizedlist"><li class="listitem">Create a minimal APK relying on <strong>Ministro</strong> for the Qt dependencies. Ministro is an Android application that can be downloaded from the Play Store. It acts as a Qt shared libraries installer/provider for all Qt applications on Android.</li><li class="listitem">Create a standalone <strong>bundle</strong> APK that embeds Qt libraries.</li><li class="listitem">Create an APK that relies on the fact that the Qt libraries are in a specific directory. The libraries are copied into a <strong>temporary directory</strong> during the first deployment.</li></ul></div><p>During the developing and debugging phase, you should select the <strong>temporary directory</strong> way to reduce the packaging time. For a deployment, you can use the <strong>Ministro</strong> or the <strong>bundle</strong> option. In our case, we chose the standalone bundle to generate a complete APK.</p><p>The <strong>Advanced actions</strong> pane offers three options:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Use Gradle</strong>: This option generates Gradle wrappers and a script, useful if you plan to customize the Java part in an IDE such as Android Studio</li><li class="listitem"><strong>Open package location after build</strong>: This option opens the directory with the packages generated by <code class="literal">androiddeployqt</code></li><li class="listitem"><strong>Verbose Output</strong>: This option displays additional information about the <code class="literal">androiddeployqt</code> processing</li></ul></div><p>The Android build details and signing options are finished. We can now customize the Android manifest. Click on <strong>Create Templates</strong>, select the <code class="literal">gallery-mobile.pro</code> file, and click on <strong>Finish</strong>. The wizard creates for you an <code class="literal">android</code> sub-directory with several files; for example, <code class="literal">AndroidManifest.xml</code>. The <code class="literal">gallery-mobile.pro</code> file has to be updated automatically with these files. However, do not forget to add the <code class="literal">android</code> scope like the following snippet:</p><pre class="programlisting">TEMPLATE = app 
... 
android { 
    contains(ANDROID_TARGET_ARCH,x86) { 
        ANDROID_EXTRA_LIBS = \ 
            $$[QT_INSTALL_LIBS]/libQt5Sql.so 
    } 
 
    DISTFILES += \ 
        android/AndroidManifest.xml \ 
        android/gradle/wrapper/gradle-wrapper.jar \ 
        android/gradlew \ 
        android/res/values/libs.xml \ 
        android/build.gradle \ 
        android/gradle/wrapper/gradle-wrapper.properties \ 
        android/gradlew.bat 
 
    ANDROID_PACKAGE_SOURCE_DIR = $$PWD/android 
} 
</pre><p>You can now edit the <code class="literal">AndroidManifest.xml</code> file. Qt Creator provides a dedicated editor. You can also edit it with a plain text editor with caution. You can open it from the hierarchical project view: <strong>gallery-mobile</strong> | <strong>Other files</strong> | <strong>android</strong>.</p><p>Here is our Android manifest in Qt Creator:</p><div><img src="img/image00452.jpeg" alt="Packaging for Android"/></div><p style="clear:both; height: 1em;"> </p><p>Here are the most important steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Replace the default <strong>Package name</strong> with yours.</li><li class="listitem">The <strong>Version code</strong> is an integer that must be increased for each official release.</li><li class="listitem">The <strong>Version name</strong> is the displayed version for users.</li><li class="listitem">Select the <strong>Minimum required SDK</strong>. Users with an older version will not be able to install your application.</li><li class="listitem">Select the SDK that will be used to compile your application with the <strong>Target SDK.</strong></li><li class="listitem">Change the application and activity name.</li><li class="listitem">Select an <strong>Application icon</strong> depending on the screen DPI (Dots per Inch). From left to right: the low, medium, and high DPI icon.</li><li class="listitem">Finally, if required by your application, you can add some Android permissions.</li></ol><div></div><p>You can already build and deploy your signed application from Qt Creator. You should see the new application name and icon on your Android phone or emulator. However, we will now create a script to easily generate and package the signed APK from the command line.</p><p>Several environment variables are required by the Android and Qt tools but also for the script itself. Here is a summary with an example:</p><div><img src="img/image00453.jpeg" alt="Packaging for Android"/></div><p style="clear:both; height: 1em;"> </p><p>This example is a bash script but feel free to adapt it to a <code class="literal">.bat</code> file if you are on Windows. Create a <code class="literal">package-android.sh</code> file in the <code class="literal">scripts</code> directory:</p><pre class="programlisting">#!/bin/bash 
 
DIST_DIR=dist/mobile-android 
BUILD_DIR=build 
APK_DIR=apk 
KEYSTORE_PATH="$(pwd)/scripts/android-data" 
ANDROID_BUILD_PATH="$(pwd)/$DIST_DIR/$BUILD_DIR/android-build" 
 
mkdir -p $DIST_DIR &amp;&amp; cd $DIST_DIR 
mkdir -p $APK_DIR $BUILD_DIR 
 
pushd $BUILD_DIR 
$QTDIR_ANDROID/bin/qmake \ 
    -spec android-g++ \ 
    "CONFIG += release" \ 
    ../../../ch13-gallery-packaging.pro 
make qmake_all 
pushd gallery-core &amp;&amp; make ; popd 
pushd gallery-mobile &amp;&amp; make ; popd 
pushd gallery-mobile &amp;&amp; make INSTALL_ROOT=$ANDROID_BUILD_PATH install ; popd 
 
$QTDIR_ANDROID/bin/androiddeployqt 
    --input ./gallery-mobile/android-libgallery-mobile.so-deployment-settings.json \ 
    --output $ANDROID_BUILD_PATH \ 
    --deployment bundled \ 
    --android-platform android-23 \ 
    --jdk $JAVA_HOME \ 
    --ant $ANT_ROOT/ant \ 
    --sign $KEYSTORE_PATH/android.keystore myandroidkey \ 
    --storepass 'masteringqt' 
     
cp $ANDROID_BUILD_PATH/bin/QtApp-release-signed.apk ../apk/cute-gallery.apk 
popd 
</pre><p>Let's analyze this script together:</p><div><ol class="orderedlist arabic"><li class="listitem">Set the main path variables. The output directory is <code class="literal">DIST_DIR</code>. All files are generated in the <code class="literal">dist/mobile-android/build</code> directory. The final signed APK is copied in the <code class="literal">dist/mobile-android/apk</code> directory.</li><li class="listitem">Create all the directories and go in <code class="literal">dist/mobile-android/build</code>.</li><li class="listitem">Execute <code class="literal">qmake</code> in release mode for the Android platform to generate the parent project Makefile.</li><li class="listitem">Run the <code class="literal">make qmake_all</code> command to generate the sub-project Makefiles.</li><li class="listitem">Perform the <code class="literal">make</code> commands to build each required sub-project.</li><li class="listitem">Run the <code class="literal">make install</code> command on the <code class="literal">gallery-mobile</code> directory specifying the <code class="literal">INSTALL_ROOT</code> to copy all binaries and files required by the APK generation.</li></ol><div></div><p>The final part of the script calls the <code class="literal">androiddeployqt</code> binary, a Qt tool to generate the APK. Take a look at the following options:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="literal">--deployment</code> option used here is <code class="literal">bundled</code> like the mode we used in Qt Creator.</li><li class="listitem">The <code class="literal">--sign</code> option requires two parameters: the URL to the keystore file and the alias to the key for the certificate.</li><li class="listitem">The <code class="literal">--storepass</code> option is used to specify the keystore password. In our case the password is "masteringqt".</li></ul></div><p>Finally, the generated signed APK is copied to the <code class="literal">dist/mobile-android/apk</code> directory with the name <code class="literal">cute-gallery.apk</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec121"/>Packaging for iOS</h1></div></div></div><p>Packaging a Qt application for iOS relies on XCode. When you build and run gallery-mobile from Qt Creator, XCode will be called under the hood. In the end, an <code class="literal">.xcodeproj</code> file is generated and passed to XCode.</p><p>Knowing this, the packaging part will be fairly limited: the only thing than can be automated is the generation of the <code class="literal">.xcodeproj</code>.</p><p>First, check that your environment variables are correctly set:</p><div><img src="img/image00454.jpeg" alt="Packaging for iOS"/></div><p style="clear:both; height: 1em;"> </p><p>Create <code class="literal">scripts/package-ios.sh</code> and add this snippet to it:</p><pre class="programlisting">#!/bin/bash 
 
DIST_DIR=dist/mobile-ios 
BUILD_DIR=build 
 
mkdir -p $DIST_DIR &amp;&amp; cd $DIST_DIR 
mkdir -p $BIN_DIR $LIB_DIR $BUILD_DIR 
 
pushd $BUILD_DIR 
$QTDIR_IOS/bin/qmake \ 
  -spec macx-ios-clang \ 
  "CONFIG += release iphoneos device" \ 
  ../../../ch13-gallery-packaging.pro 
make qmake_all 
pushd gallery-core &amp;&amp; make ; popd 
pushd gallery-mobile &amp;&amp; make ; popd 
 
popd 
</pre><p>The script performs the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Set the main path variables. The output directory is <code class="literal">DIST_DIR</code>. All files are generated in the <code class="literal">dist/mobile-ios/build</code> folder.</li><li class="listitem">Create all the directories and go in <code class="literal">dist/mobile-ios/build</code>.</li><li class="listitem">Execute <code class="literal">qmake</code> in release mode for the iPhone device (as opposed to the iPhone simulator) platform to generate the parent project <code class="literal">Makefile</code>.</li><li class="listitem">Run the <code class="literal">make qmake_all</code> command to generate the sub-project Makefiles.</li><li class="listitem">Perform the <code class="literal">make</code> command to build each required sub-projects.</li></ol><div></div><p>Once this script has been executed, <code class="literal">dist/mobile-ios/build/gallery-mobile/gallery-mobile.xcodeproj</code> is ready to be opened in XCode. The remaining steps are entirely done in XCode:</p><div><ol class="orderedlist arabic"><li class="listitem">Open <code class="literal">gallery-mobile.xcodeproj</code> in XCode.</li><li class="listitem">Compile the application for an iOS device.</li><li class="listitem">Follow the Apple procedure to distribute your application (through the App Store or as a standalone file).</li></ol><div></div><p>After that, <code class="literal">gallery-mobile</code> will be ready for your users!</p></div>
<div><div><div><div><h1 class="title"><a id="ch13lvl1sec122"/>Summary</h1></div></div></div><p>Even if your application runs well on your computer, your development environment can affect this behavior. Its packaging must be correct to run your application on the user's hardware. You learned the steps required to package an application before deploying it. Some platforms required specific tasks that must be followed carefully. You can now bake a standalone package if your application is running a unique script.</p><p>The next chapter describes some tricks that can be useful for developing applications with Qt. You will learn some tips concerning Qt Creator.</p></div></body></html>