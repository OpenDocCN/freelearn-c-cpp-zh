- en: Building a Simple Web Server
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建简单的Web服务器
- en: This chapter builds on the previous one by looking at the HTTP protocol from
    the server's perspective. In it, we will build a simple web server. This web server
    will work using the HTTP protocol, and you will be able to connect to it with
    any standard web browser. Although it won't be full-featured, it will be suitable
    for serving a few static files locally. It will be able to handle a few simultaneous
    connections from multiple clients at once.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章基于前一章，从服务器的角度来查看HTTP协议。在其中，我们将构建一个简单的Web服务器。这个Web服务器将使用HTTP协议工作，您可以使用任何标准的Web浏览器连接到它。虽然它不会是功能齐全的，但它适合本地提供一些静态文件。它将能够同时处理来自多个客户端的几个并发连接。
- en: 'The following topics are covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Accepting and buffering multiple connections
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受和缓冲多个连接
- en: Parsing an HTTP request line
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析HTTP请求行
- en: Formatting an HTTP response
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化HTTP响应
- en: Serving a file
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供文件服务
- en: Security considerations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全考虑
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The example programs from this chapter can be compiled with any modern C compiler.
    We recommend MinGW on Windows and GCC on Linux and macOS; see [Appendices B](47da8507-709b-44a6-9399-b18ce6afd8c9.xhtml), *Setting
    Up Your C Compiler on Windows*, [Appendices C](221eebc0-0bb1-4661-a5aa-eafed9fcba7e.xhtml), *Setting
    Up Your C Compiler on Linux*, and [Appendices D](632db68e-0911-4238-a2be-bd1aa5296120.xhtml), *Setting
    Up Your C Compiler on macOS,* for compiler setup.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例程序可以使用任何现代的C编译器编译。我们推荐在Windows上使用MinGW，在Linux和macOS上使用GCC；有关编译器设置，请参阅[附录B](47da8507-709b-44a6-9399-b18ce6afd8c9.xhtml)，*在Windows上设置您的C编译器*，[附录C](221eebc0-0bb1-4661-a5aa-eafed9fcba7e.xhtml)，*在Linux上设置您的C编译器*，以及[附录D](632db68e-0911-4238-a2be-bd1aa5296120.xhtml)，*在macOS上设置您的C编译器*。
- en: The code for this book can be found at [https://github.com/codeplea/Hands-On-Network-Programming-with-C](https://github.com/codeplea/Hands-On-Network-Programming-with-C).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本书代码可在[https://github.com/codeplea/Hands-On-Network-Programming-with-C](https://github.com/codeplea/Hands-On-Network-Programming-with-C)找到。
- en: 'From the command line, you can download the code for this chapter with the
    following command:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行，您可以使用以下命令下载本章的代码：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each example program in this chapter runs on Windows, Linux, and macOS. While
    compiling on Windows, each example program requires linking to the **Winsock**
    library. This can be accomplished by passing the `-lws2_32` option to `gcc`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的每个示例程序都在Windows、Linux和macOS上运行。在Windows上编译时，每个示例程序都需要链接到**Winsock**库。这可以通过将`-lws2_32`选项传递给`gcc`来实现。
- en: We provide the exact commands needed to compile each example as they are introduced.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了编译每个示例所需的精确命令，当它们被介绍时。
- en: All of the example programs in this chapter require the same header files and
    C macros that we developed in [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml),
    *Getting to Grips with Socket APIs*. For brevity, we put these statements in a
    separate header file, `chap07.h`, which we can include in each program. For an
    explanation of these statements, please refer to [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml),
    *Getting to Grips with Socket APIs*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有示例程序都需要我们在[第2章](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml)，*掌握Socket
    API*中开发的相同的头文件和C宏。为了简洁，我们将这些语句放在一个单独的头文件`chap07.h`中，我们可以在每个程序中包含它。有关这些语句的解释，请参阅[第2章](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml)，*掌握Socket
    API*。
- en: 'The content of `chap07.h` is as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`chap07.h`的内容如下：'
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The HTTP server
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP服务器
- en: In this chapter, we are going to implement an HTTP web server that can serve
    static files from a local directory. HTTP is a text-based client-server protocol
    that uses the **Transmission Control Protocol** (**TCP**).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现一个可以从前目录提供静态文件的HTTP Web服务器。HTTP是一种基于文本的客户端-服务器协议，它使用**传输控制协议**（**TCP**）。
- en: When implementing our HTTP server, we need to support multiple, simultaneous
    connections from many clients at once. Each received **HTTP Request** needs to
    be parsed, and our server needs to reply with the proper **HTTP Response**. This
    **HTTP Response** should include the requested file if possible.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现我们的HTTP服务器时，我们需要支持来自许多客户端的同时多个并发连接。每个接收到的**HTTP请求**都需要被解析，并且我们的服务器需要回复适当的**HTTP响应**。如果可能的话，这个**HTTP响应**应包括请求的文件。
- en: 'Consider the HTTP transaction illustrated in the following diagram:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下图示中的HTTP事务：
- en: '![](img/5d678947-2cad-44df-a4a4-5e78fd50fb52.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d678947-2cad-44df-a4a4-5e78fd50fb52.png)'
- en: In the preceding diagram, the client is requesting `/document.htm` from the
    server. The server finds `/document.htm` and returns it to the client.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，客户端正在从服务器请求`/document.htm`。服务器找到`/document.htm`并将其返回给客户端。
- en: Our HTTP server is somewhat simplified, and we only need to look at the first
    line of the HTTP request. This first line is called the **request line**. Our
    server only supports `GET` type requests, so it needs to first check that the
    request line starts with `GET`. It then parses out the requested resource, `/document.htm`
    in the preceding example.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开发的HTTP服务器有些简化，我们只需要查看HTTP请求的第一行。这一行被称为**请求行**。我们的服务器只支持`GET`类型的请求，因此它需要首先检查请求行是否以`GET`开头。然后它会解析出请求的资源，在前面的例子中是`/document.htm`。
- en: A more full-featured HTTP server would look at several other HTTP headers. It
    would look at the `Host` header to determine which site it is hosting. Our server
    only supports hosting one site, so this header is not meaningful for us.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一个功能更全面的HTTP服务器会查看几个其他的HTTP头信息。它会查看`Host`头信息以确定它正在托管哪个网站。我们的服务器只支持托管一个网站，因此这个头信息对我们来说没有意义。
- en: A production server would also look at headers such as Accept-Encoding and Accept-Language,
    which could inform a proper response format. Our server just ignores these, and
    it instead serves files in only the most straightforward way.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 生产服务器还会查看诸如Accept-Encoding和Accept-Language等头信息，这些信息可以告知适当的响应格式。我们的服务器只是忽略这些，并且它以最直接的方式提供文件服务。
- en: The internet can sometimes be a hostile environment. A production-grade web
    server needs to include security in layers. It should be absolutely meticulous
    about file access and resource allocation. In the interest of clear explanation
    and brevity, the server we develop in this chapter is not security-hardened, and
    it should not be used on the public internet for this reason.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网有时可能是一个敌对的环境。一个生产级别的Web服务器需要在多个层次上包含安全性。它应该对文件访问和资源分配绝对细致入微。为了清晰解释和简洁，我们本章开发的这个服务器没有进行安全加固，因此出于这个原因，它不应该在公共互联网上使用。
- en: The server architecture
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器架构
- en: An HTTP server is a complicated program. It must handle multiple simultaneous
    connections, parse a complex text-based protocol, handle malformed requests with
    the proper errors, and serve files. The example we develop in this chapter is
    greatly simplified from a production-ready server, but it is still a few hundred
    lines of code. We benefit from breaking the program down into separate functions
    and data structures.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP服务器是一个复杂的程序。它必须处理多个同时连接、解析复杂的基于文本的协议、以适当的错误处理格式不正确的请求，以及提供文件服务。我们本章开发的例子是从一个生产就绪的服务器中大大简化而来的，但它仍然是几百行代码。我们从将程序分解为单独的函数和数据结构中受益。
- en: At the global level, our program stores a linked list of data structures. This
    linked list contains one separate data structure for each connected client. This
    data structure stores information about each client such as their address, their
    socket, and their data received so far. We implement many helper functions that
    work on this global linked list. These functions are used to add new clients,
    drop clients, wait on client data, look up clients by their socket (as sockets
    are returned by `select()`), serve files to clients, and send error messages to
    clients.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在全局层面，我们的程序存储了一个数据结构链表。这个链表为每个连接的客户端包含一个独立的数据结构。这个数据结构存储了有关每个客户端的信息，例如它们的地址、套接字以及迄今为止接收到的数据。我们实现了许多在全局链表上工作的辅助函数。这些函数用于添加新客户端、删除客户端、等待客户端数据、通过套接字查找客户端（因为套接字是由`select()`返回的）、向客户端提供文件以及向客户端发送错误信息。
- en: Our server's main loop can then be simplified. It waits for new connections
    or new data. When new data is received, it checks whether the data consists of
    a complete HTTP request. If a complete HTTP request is received, the server attempts
    to send the requested resource. If the HTTP request is malformed or the resource
    cannot be found, then the server sends an error message to the connected client
    instead.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器主循环可以被简化。它等待新的连接或新的数据。当接收到新数据时，它会检查这些数据是否构成一个完整的HTTP请求。如果接收到一个完整的HTTP请求，服务器会尝试发送请求的资源。如果HTTP请求格式不正确或资源无法找到，那么服务器会向连接的客户端发送错误信息。
- en: Most of the server complexity lies in handling multiple connections, parsing
    the HTTP request, and handling error conditions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的大部分复杂性在于处理多个连接、解析HTTP请求和处理错误条件。
- en: The server is also responsible for telling the client the content type of each
    resource it sends. There are a few ways to accomplish this; let's consider them
    next.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器还负责告知客户端它发送的每个资源的类型。有几种方法可以实现这一点；让我们接下来考虑它们。
- en: Content types
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容类型
- en: It is the HTTP server's job to tell its client the type of content being sent.
    This is done by the `Content-Type` header. The value of the `Content-Type` header
    should be a valid media type (formerly known as the **MIME type**) registered
    with the **Internet Assigned Numbers Authority** (**IANA**). See the *Further
    reading* section of this chapter for a link to the IANA list of media types.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是HTTP服务器的职责，告诉其客户端发送的内容类型。这是通过`Content-Type`头完成的。`Content-Type`头的值应该是一个有效的媒体类型（以前称为**MIME类型**），它已在**互联网数字分配机构**（**IANA**）注册。参见本章的**进一步阅读**部分，以获取IANA媒体类型列表的链接。
- en: There are a few ways to determine the media type of a file. If you're on a Unix-based
    system, such as Linux or macOS, then your operating system already provides a
    utility for this.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以确定文件的媒体类型。如果你使用的是基于Unix的系统，例如Linux或macOS，那么你的操作系统已经提供了这个工具。
- en: 'Try the following command on Linux or macOS (replace `example.txt` with a real
    filename):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux或macOS上尝试以下命令（将`example.txt`替换为实际文件名）：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following screenshot shows its usage:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了其用法：
- en: '![](img/43a83200-c274-422a-9851-d014c8b9614b.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43a83200-c274-422a-9851-d014c8b9614b.png)'
- en: As you can see in the preceding screenshot, the `file` utility told us the media
    type of `index.html` is `text/html`. It also said the media type of `smile.png`
    is `image/png`, and the media type of `test.txt` is `text/plain`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，`file`实用程序告诉我们`index.html`的媒体类型是`text/html`。它还表示`smile.png`的媒体类型是`image/png`，`test.txt`的媒体类型是`text/plain`。
- en: Our web server just uses the file's extension to determine the media type.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Web服务器仅使用文件的扩展名来确定媒体类型。
- en: 'Common file extensions and their media type are listed in the following table:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的文件扩展名及其媒体类型列在以下表格中：
- en: '| **Extension** | **Media Type** |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **扩展名** | **媒体类型** |'
- en: '| --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `.css` | `text/css` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `.css` | `text/css` |'
- en: '| `.csv` | `text/csv` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `.csv` | `text/csv` |'
- en: '| `.gif` | `image/gif` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `.gif` | `image/gif` |'
- en: '| `.htm` | `text/html` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `.htm` | `text/html` |'
- en: '| `.html` | `text/html` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `.html` | `text/html` |'
- en: '| `.ico` | `image/x-icon` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `.ico` | `image/x-icon` |'
- en: '| `.jpeg` | `image/jpeg` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `.jpeg` | `image/jpeg` |'
- en: '| `.jpg` | `image/jpeg` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `.jpg` | `image/jpeg` |'
- en: '| `.js` | `application/javascript` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `.js` | `application/javascript` |'
- en: '| `.json` | `application/json` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `.json` | `application/json` |'
- en: '| `.png` | `image/png` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `.png` | `image/png` |'
- en: '| `.pdf` | `application/pdf` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `.pdf` | `application/pdf` |'
- en: '| `.svg` | `image/svg+xml` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `.svg` | `image/svg+xml` |'
- en: '| `.txt` | `text/plain` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `.txt` | `text/plain` |'
- en: If a file's media type is unknown, then our server should use `application/octet-stream`
    as a default. This indicates that the browser should treat the content as an unknown
    binary blob.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个文件的媒体类型未知，那么我们的服务器应该使用`application/octet-stream`作为默认值。这表示浏览器应该将内容视为一个未知的二进制blob。
- en: Let's continue by writing code to get `Content-Type` from a filename.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续编写代码来从文件名获取`Content-Type`。
- en: Returning Content-Type from a filename
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文件名返回`Content-Type`
- en: Our server code uses a series of `if` statements to determine the proper media
    type based only on the requested file's extension. This isn't a perfect solution,
    but it is a common one, and it works for our purposes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器代码使用一系列`if`语句来确定基于请求文件的扩展名的正确媒体类型。这不是一个完美的解决方案，但这是一个常见的解决方案，并且适用于我们的目的。
- en: 'The code to determine a file''s media type is as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 确定文件媒体类型的代码如下：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `get_content_type()` function works by matching the filename extension to
    a list of known extensions. This is done by using the `strrchr()` function to
    find the last dot (`.`) in the filename. If a dot is found, then `strcmp()` is
    used to check for a match on each extension. When a match is found, the proper
    media type is returned. Otherwise, the default of `application/octet-stream` is
    returned instead.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_content_type()`函数通过将文件名扩展名与已知扩展名列表进行匹配来工作。这是通过使用`strrchr()`函数在文件名中找到最后一个点（`.`）来完成的。如果找到点，则使用`strcmp()`检查每个扩展名的匹配。当找到匹配项时，返回适当的媒体类型。否则，返回默认值`application/octet-stream`。'
- en: Let's continue building helper functions for our server.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续为我们的服务器构建辅助函数。
- en: Creating the server socket
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建服务器套接字
- en: 'Before entertaining the exciting parts of the HTTP server, such as message
    parsing, let''s get the basics out of the way. Our HTTP server, like all servers,
    needs to create a listening socket to accept new connections. We define a function,
    `create_socket()`, for this purpose. This function begins by using `getaddrinfo()`
    to find the listening address:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理HTTP服务器的激动人心部分，如消息解析之前，让我们先解决基础知识。我们的HTTP服务器，像所有服务器一样，需要创建一个监听套接字以接受新的连接。我们定义了一个名为`create_socket()`的函数来完成这个目的。此函数首先使用`getaddrinfo()`来查找监听地址：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`create_socket()` then continues with creating a socket using `socket()`, binding
    that socket to the listening address with `bind()`, and having the socket enter
    a listening state with `listen()`. The following code calls these functions while
    detecting error conditions:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_socket()`函数接着使用`socket()`创建套接字，使用`bind()`将套接字绑定到监听地址，并使用`listen()`使套接字进入监听状态。以下代码在调用这些函数的同时检测错误条件：'
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code should be very familiar to you if you're working through
    this book in order. If not, please refer to [Chapter 3](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml),
    *An In-Depth Overview of TCP Connections*, for information about setting up TCP
    servers.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您按照本书的顺序学习，前面的代码应该非常熟悉。如果不熟悉，请参阅[第3章](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml)，*TCP连接的深入概述*，以获取有关设置TCP服务器的信息。
- en: Multiple connections buffering
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个连接缓冲
- en: One important hurdle to overcome, when implementing any server software, is
    accepting and parsing requests from multiple clients simultaneously.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现任何服务器软件时，克服的一个重要障碍是同时接受和解析来自多个客户的请求。
- en: Consider a client that sends only the beginning of an HTTP request, followed
    by a delay, and then the remainder of the HTTP request. In this case, we cannot
    respond to that client until the entire HTTP request is received. However, at
    the same time, we do not wish to delay servicing other connected clients while
    waiting. For this reason, we need to buffer up received data for each client separately.
    Only once we've received an entire HTTP request from a client can we respond to
    that client.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个只发送HTTP请求开头，然后延迟，再发送剩余HTTP请求的客户。在这种情况下，我们无法在接收到整个HTTP请求之前对该客户做出响应。然而，同时，我们也不希望等待时延迟服务其他已连接的客户。因此，我们需要为每个客户分别缓冲接收到的数据。只有当我们从客户那里接收到完整的HTTP请求后，我们才能对该客户做出响应。
- en: 'It is useful to define a C `struct` to store information on each connected
    client. Our program uses the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个C `struct`来存储每个已连接客户的详细信息是有用的。我们的程序使用以下结构：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This `struct` allows us to store information about each connected client. A
    client's address is stored in the `address` field, the address length in `address_length`,
    and the socket in the `socket` field. All of the data received from the client
    so far is stored in the `request` array; `received` indicates the number of bytes
    stored in that array. The `next` field is a pointer that allows us to store `client_info`
    structures in a linked list.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`struct`允许我们存储有关每个已连接客户的详细信息。客户的地址存储在`address`字段中，地址长度在`address_length`中，套接字在`socket`字段中。迄今为止从客户那里接收到的所有数据都存储在`request`数组中；`received`指示该数组中存储的字节数。`next`字段是一个指针，允许我们将`client_info`结构存储在链表中。
- en: 'To simplify our code, we store the root of our linked list in a global variable,
    `clients`. The declaration is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化我们的代码，我们将链表的根存储在全局变量`clients`中。声明如下：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Declaring `clients` as a global variable helps to keep our code slightly shorter
    and clearer. However, if you require the code to be re-entrant (for example, if
    you want multiple servers running simultaneously), you will want to avoid the
    global state. This can be done by passing around the linked list root as a separate
    argument to each function call. This chapter's code repository includes an example
    of this alternative technique in the `web_server2.c` file.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将`clients`声明为全局变量有助于使我们的代码略微简短且清晰。然而，如果您需要代码可重入（例如，如果您想同时运行多个服务器），您将想要避免全局状态。这可以通过将链表根作为单独的参数传递给每个函数调用来实现。本章的代码仓库在`web_server2.c`文件中包含了这个替代技术的示例。
- en: 'It is useful to define a number of helper functions that work on the `client_info`
    data structure and the `clients` linked list. We implement the following helper
    functions for these purposes:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一些辅助函数，这些函数在`client_info`数据结构和`clients`链表上工作，是有用的。我们实现了以下辅助函数来完成这些目的：
- en: '`get_client()` takes a `SOCKET` variable and searches our linked list for the
    corresponding `client_info` data structure.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_client()` 函数接收一个 `SOCKET` 变量并在我们的链表中搜索相应的 `client_info` 数据结构。'
- en: '`drop_client()` closes the connection to a client and removes it from the `clients`
    linked list.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drop_client()` 关闭与客户端的连接并将其从 `clients` 链表中移除。'
- en: '`get_client_address()` returns a client''s IP address as a string (character
    array).'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_client_address()` 返回客户端的 IP 地址作为字符串（字符数组）。'
- en: '`wait_on_clients()` uses the `select()` function to wait until either a client
    has data available or a new client is attempting to connect.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wait_on_clients()` 使用 `select()` 函数等待直到有客户端有数据可用或新的客户端尝试连接。'
- en: '`send_400()` and `send_404()` are used to handle HTTP error conditions.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`send_400()` 和 `send_404()` 用于处理 HTTP 错误条件。'
- en: '`serve_resource()` attempts to transfer a file to a connected client.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serve_resource()` 尝试将文件传输到已连接的客户端。'
- en: Let's now implement these functions one at a time.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将逐个实现这些函数。
- en: get_client()
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`get_client()`'
- en: Our `get_client()` function accepts a `SOCKET` and searches through the linked
    list of connected clients to return the relevant `client_info` for that `SOCKET`.
    If no matching `client_info` is found in the linked list, then a new `client_info` is
    allocated and added to the linked list. Therefore, `get_client()` serves two purposes—it
    can find an existing `client_info`, or it can create a new `client_info`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `get_client()` 函数接受一个 `SOCKET` 并在连接客户端的链表中搜索，以返回该 `SOCKET` 对应的 `client_info`。如果在链表中找不到匹配的
    `client_info`，则分配一个新的 `client_info` 并将其添加到链表中。因此，`get_client()` 具有两个作用——它可以找到现有的
    `client_info`，或者它可以创建一个新的 `client_info`。
- en: '`get_client()` takes a `SOCKET` as its input and return a `client_info` structure.
    The following code is the first part of the `get_client()` function:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_client()` 函数接收一个 `SOCKET` 作为输入，并返回一个 `client_info` 结构体。以下代码是 `get_client()`
    函数的第一部分：'
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code, we created the `get_client()` function and implemented
    our linked list search functionality. First, the linked list root, `clients`,
    is saved into a temporary variable, `ci`. If `ci->socket` is the socket we are
    searching for, then the loop breaks and `ci` is returned. If the `client_info`
    structure for the given socket isn''t found, then the code continues on and must
    create a new `client_info` structure. The following code achieves this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了 `get_client()` 函数并实现了我们的链表搜索功能。首先，将链表根 `clients` 保存到一个临时变量 `ci`
    中。如果 `ci->socket` 是我们要搜索的套接字，则循环中断并返回 `ci`。如果找不到给定套接字的 `client_info` 结构体，则代码继续执行并必须创建一个新的
    `client_info` 结构体。以下代码实现了这一点：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, the `calloc()` function is used to allocate memory for
    a new `client_info` structure. The `calloc()` function also zeroes-out the data
    structure, which is useful in this case. The code then checks that the memory
    allocation succeeded, and it prints an error message if it fails.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，使用了 `calloc()` 函数为新 `client_info` 结构体分配内存。`calloc()` 函数还会将数据结构清零，这在这种情况下很有用。然后代码检查内存分配是否成功，如果失败则打印错误信息。
- en: The code then sets `n->address_length` to the proper size. This allows us to
    use `accept()` directly on the `client_info` address later, as `accept()` requires
    the maximum address length as an input.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后代码将 `n->address_length` 设置为适当的大小。这允许我们稍后直接在 `client_info` 地址上使用 `accept()`，因为
    `accept()` 需要最大地址长度作为输入。
- en: The `n->next` field is set to the current global linked list root, and the global
    linked list root, `clients`, is set to `n`. This accomplishes the task of adding
    in the new data structure at the beginning of the linked list.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `n->next` 字段设置为当前全局链表根，并将全局链表根 `clients` 设置为 `n`。这实现了在链表开头添加新的数据结构。
- en: The `get_client()` function ends by returning the newly allocated `client_info`
    structure, `n`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_client()` 函数通过返回新分配的 `client_info` 结构体 `n` 来结束。'
- en: drop_client()
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`drop_client()`'
- en: The `drop_client()` function searches through our linked list of clients and
    removes a given client.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`drop_client()` 函数搜索我们的客户端链表并移除指定的客户端。'
- en: 'The entire function is given in the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 整个函数的代码如下：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see in the preceding code, `CLOSESOCKET()` is first used to close
    and clean up the client's connection.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的代码所示，首先使用 `CLOSESOCKET()` 关闭并清理客户端的连接。
- en: The function then declares a pointer-to-pointer variable, `p`, and sets it to
    `clients`. This pointer-to-pointer variable is useful because we can use it to
    change the value of `clients` directly. Indeed, if the client to be removed is
    the first element in the linked list, then `clients` needs to be updated, so that
    `clients` points to the second element in the list.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 函数随后声明了一个指针的指针变量，`p`，并将其设置为`clients`。这个指针的指针变量很有用，因为我们可以用它直接更改`clients`的值。确实，如果要删除的客户是链表中的第一个元素，那么`clients`需要更新，以便`clients`指向列表中的第二个元素。
- en: The code uses a `while` loop to walk through the linked list. Once it finds
    that `*p == client`, `*p`, is set to `client->next`, which effectively removes
    the client from the linked list, the allocated memory is then freed and the function
    returns.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用一个`while`循环遍历链表。一旦找到`*p == client`，就将`*p`设置为`client->next`，这实际上从链表中移除了客户，随后释放了分配的内存，并返回函数。
- en: Although `drop_client()` is a simple function, it is handy as it can be called
    in several circumstances. It must be called when we finish sending a client a
    resource, and it also must be called when we finish sending a client an error
    message.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`drop_client()`是一个简单的函数，但它很方便，因为它可以在几种情况下调用。当完成向客户发送资源后必须调用它，同样，当完成向客户发送错误消息后也必须调用它。
- en: get_client_address()
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`get_client_address()`'
- en: 'It is useful to have a helper function that converts a given client''s IP address
    into text. This function is given in the following code snippet:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个辅助函数将给定客户的IP地址转换为文本很有用。这个函数在下面的代码片段中给出：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`get_client_address()` is a simple function. It first allocates a `char` array
    to store the IP address in. This `char` array is declared `static`, which ensures
    that its memory is available after the function returns. This means that we don''t
    need to worry about having the caller `free()` the memory. The downside to this
    method is that `get_client_address()` has a global state and is not re-entrant-safe.
    See `web_server2.c` for an alternative version that is re-entrant-safe.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_client_address()`是一个简单的函数。它首先分配一个`char`数组来存储IP地址。这个`char`数组被声明为`static`，这确保了在函数返回后其内存仍然是可用的。这意味着我们不需要担心调用者`free()`内存。这种方法的不利之处在于`get_client_address()`具有全局状态，并且不是可重入安全的。请参阅`web_server2.c`以获取一个可重入安全的替代版本。'
- en: After a `char` buffer is available, the code simply uses `getnameinfo()` to
    convert the binary IP address into a text address; `getnameinfo()` was covered
    in detail in previous chapters, but [Chapter 5](3d80e3b8-07d3-49f4-b60f-b006a17f7213.xhtml),
    *Hostname Resolution and DNS*, has a particularly detailed explanation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在获得`char`缓冲区后，代码简单地使用`getnameinfo()`将二进制IP地址转换为文本地址；`getnameinfo()`在前面章节中有详细的介绍，但[第5章](3d80e3b8-07d3-49f4-b60f-b006a17f7213.xhtml)，*主机名解析和DNS*，有特别详细的解释。
- en: wait_on_clients()
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`wait_on_clients()`'
- en: Our server is capable of handling many simultaneous connections. This means
    that our server must have a way to wait for data from multiple clients at once.
    We define a function, `wait_on_clients()`, which blocks until an existing client
    sends data, or a new client attempts to connect. This function uses `select()`
    as described in previous chapters. [Chapter 3](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml),
    *An In-Depth Overview of TCP Connections*, has a detailed explanation of `select()`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器能够处理许多并发连接。这意味着我们的服务器必须有一种方式来同时等待来自多个客户的数据。我们定义了一个函数，`wait_on_clients()`，该函数会阻塞，直到现有客户发送数据，或者新客户尝试连接。这个函数使用了在前面章节中描述的`select()`。[第3章](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml)，*TCP连接的深入概述*，对`select()`有详细的解释。
- en: 'The `wait_on_clients()` function is defined as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait_on_clients()`函数定义如下：'
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, first a new `fd_set` is declared and zeroed-out. The
    server socket is then added to the `fd_set` first. Then the code loops through
    the linked list of connected clients and adds the socket for each one in turn.
    A variable, `max_socket`, is maintained throughout this process to store the maximum
    socket number as required by `select()`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先声明了一个新的`fd_set`并将其清零。然后，将服务器套接字首先添加到`fd_set`中。然后代码遍历已连接客户的链表，并依次添加每个客户的套接字。在整个过程中维护一个变量`max_socket`，以存储`select()`所需的最大套接字号。
- en: After all the sockets are added to `fd_set reads`, the code calls `select()`,
    and `select()` returns when one or more of the sockets in `reads` is ready.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在将所有套接字添加到`fd_set reads`之后，代码调用`select()`，并且当`reads`中的一个或多个套接字准备好时，`select()`返回。
- en: The `wait_on_clients()` function returns `reads` so that the caller can see
    which socket is ready.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait_on_clients()` 函数返回 `reads`，以便调用者可以看到哪个套接字已准备好。'
- en: send_400()
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: send_400()
- en: 'In the case where a client sends an HTTP request which our server does not
    understand, it is helpful to send a code `400` error. Because errors of this type
    can arise in several situations, we wrap this functionality in the `send_400()`
    function. The entire function follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端发送的HTTP请求是我们服务器不理解的情况下，发送代码 `400` 错误是有帮助的。因为这种类型的错误可以在几种情况下出现，所以我们把这个功能封装在
    `send_400()` 函数中。整个函数如下：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `send_400()` function first declares a text array with the entire HTTP response
    hard-coded. This text is sent using the `send()` function, and then the client
    is dropped by calling the `drop_client()` function we defined earlier.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`send_400()` 函数首先声明一个包含整个HTTP响应的文本数组，该响应是硬编码的。使用 `send()` 函数发送此文本，然后通过调用我们之前定义的
    `drop_client()` 函数来断开客户端连接。'
- en: send_404()
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: send_404()
- en: 'In addition to the `400 Bad Request` error, our server also needs to handle
    the case where a requested resource is not found. In this case, a `404 Not Found`
    error should be returned. We define a helper function to return this error as
    follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 除了处理 `400 Bad Request` 错误之外，我们的服务器还需要处理请求的资源未找到的情况。在这种情况下，应返回 `404 Not Found`
    错误。我们定义了一个辅助函数来返回此错误，如下所示：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `send_404()` function works exactly like the `send_400()` function defined
    previously.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`send_404()` 函数与之前定义的 `send_400()` 函数工作方式完全相同。'
- en: serve_resource()
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: serve_resource()
- en: The `serve_resource()` function sends a connected client a requested resource.
    Our server expects all hosted files to be in a subdirectory called `public`. Ideally,
    our server should not allow access to any files outside of this `public` directory.
    However, as we shall see, enforcing this restriction may be more difficult than
    it first appears.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`serve_resource()` 函数向连接的客户端发送请求的资源。我们的服务器期望所有托管文件都在名为 `public` 的子目录中。理想情况下，我们的服务器不应允许访问
    `public` 目录之外的任何文件。然而，正如我们将看到的，实施这种限制可能比最初看起来更困难。'
- en: 'Our `serve_resource()` function takes as arguments a connected client and a
    requested resource path. The function begins as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `serve_resource()` 函数接受一个已连接客户端和一个请求的资源路径作为参数。函数开始如下：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The connected client's IP address and the requested path are printed to aid
    in debugging. In a production server, you would also want to print additional
    information. Most production servers log the date, time, request method, the client's
    user-agent string, and the response code as a minimum.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将连接客户端的IP地址和请求的路径打印出来，以帮助调试。在生产服务器中，您还希望打印其他信息。大多数生产服务器至少记录日期、时间、请求方法、客户端的用户代理字符串和响应代码。
- en: Our function then normalizes the requested path. There are a few things to check
    for. First, if the path is `/`, then we need to serve a default file. There is
    a tradition of serving a file called `index` in that case, and, indeed, this is
    what our code does.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的功能随后将请求的路径标准化。有几个事项需要检查。首先，如果路径是 `/`，那么我们需要提供默认文件。在这种情况下，有一个提供名为 `index`
    的文件的惯例，实际上这正是我们的代码所做的事情。
- en: We also check that the path isn't too long. Once we ensure that the path is
    below a maximum length, we can use fixed-size arrays to store it without worrying
    about buffer overflows.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还检查路径长度是否过长。一旦我们确保路径长度低于最大长度，我们就可以使用固定大小的数组来存储它，而不用担心缓冲区溢出。
- en: Our code also checks that the path doesn't contain two consecutive dots—`..`.
    In file paths, two dots indicate a reference to a parent directory. However, for
    security reasons, we want to allow access only into our `public` directory. We
    do not want to provide access to any parent directory. If we allowed paths with
    `..`, then a malicious client could send `GET /../web_server.c HTTP/1.1` and gain
    access to our server source code!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码还检查路径中不包含两个连续的点——`..`。在文件路径中，两个点表示对父目录的引用。然而，出于安全考虑，我们只想允许访问我们的 `public`
    目录。我们不想提供对任何父目录的访问。如果我们允许包含 `..` 的路径，那么恶意客户端可以发送 `GET /../web_server.c HTTP/1.1`
    并获取我们的服务器源代码的访问权限！
- en: 'The following code is used to redirect root requests and to prevent long or
    obviously malicious requests:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于重定向根请求以及防止长或明显恶意的请求：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Our code now needs to convert the path to refer to files in the `public` directory.
    This is done with the `sprintf()` function. First, a text-array is reserved, `full_path`,
    and then `sprintf()` is used to store the full path into it. We are able to reserve
    a fixed allocation for `full_path`, as our earlier code ensured that `path` does
    not exceed `100` characters in length.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的代码需要将路径转换为指向 `public` 目录中的文件。这是通过 `sprintf()` 函数完成的。首先，预留一个文本数组 `full_path`，然后使用
    `sprintf()` 将完整路径存储到其中。我们能够为 `full_path` 预留一个固定分配，因为之前的代码确保了 `path` 的长度不超过 `100`
    个字符。
- en: 'The code to set `full_path` is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `full_path` 的代码如下：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It is important to note that the directory separator differs between Windows
    and other operating systems. While Unix-based systems use a slash (`/`), Windows
    instead uses a backslash (`\`) as its standard. Many Windows functions handle
    the conversion automatically, but the difference is sometimes important. For our
    simple server, the slash conversion isn't an absolute requirement. However, we
    include it anyway as a good practice.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，目录分隔符在 Windows 和其他操作系统之间是不同的。虽然基于 Unix 的系统使用斜杠 (`/`)，但 Windows 使用反斜杠
    (`\`) 作为其标准。许多 Windows 函数会自动处理转换，但有时这种差异很重要。对于我们的简单服务器，斜杠转换不是绝对必要的。然而，我们仍然包括它作为一种良好的实践。
- en: 'The following code converts slashes to backslashes on Windows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码在 Windows 上将斜杠转换为反斜杠：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding code works by stepping through the `full_path` text array and
    detecting slash characters. When a slash is found, it is simply overwritten with
    a backslash. Note that the C code `'\\'` is equivalent to only one backslash.
    This is because the backslash has special meaning in C, and therefore the first
    backslash is used to escape the second backslash.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码通过遍历 `full_path` 文本数组并检测斜杠字符来工作。当找到斜杠时，它被简单地覆盖为反斜杠。请注意，C 代码 `'\\'` 等价于一个反斜杠。这是因为反斜杠在
    C 中有特殊含义，因此第一个反斜杠用于转义第二个反斜杠。
- en: 'At this point, our server can check whether the requested resource actually
    exists. This is done by using the `fopen()` function. If `fopen()` fails, for
    any reason, then our server assumes that the file does not exist. The following
    code sends a `404` error if the requested resource isn''t available:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们的服务器可以检查请求的资源是否实际存在。这是通过使用 `fopen()` 函数完成的。如果 `fopen()` 由于任何原因失败，那么我们的服务器假设该文件不存在。以下代码在请求的资源不可用的情况下发送一个
    `404` 错误：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If `fopen()` succeeds, then we can use `fseek()` and `ftell()` to determine
    the requested file''s size. This is important, as we need to use the file''s size
    in the `Content-Length` header. The following code finds the file size and stores
    it in the `cl` variable:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `fopen()` 成功，那么我们可以使用 `fseek()` 和 `ftell()` 来确定请求文件的尺寸。这是重要的，因为我们需要在 `Content-Length`
    头部中使用文件的大小。以下代码找到文件大小并将其存储在 `cl` 变量中：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once the file size is known, we also want to get the file''s type. This is
    used in the `Content-Type` header. We already defined a function, `get_content_type()`,
    which makes this task easy. The content type is store in the variable `ct` by
    the following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦知道文件大小，我们还想获取文件的类型。这在 `Content-Type` 头部中使用。我们已定义了一个函数 `get_content_type()`，这使得这项任务变得简单。内容类型通过以下代码存储在变量
    `ct` 中：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once the file has been located and we have its length and type, the server
    can begin sending the HTTP response. We first reserve a temporary buffer to store
    header fields in:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到文件并获取其长度和类型，服务器就可以开始发送 HTTP 响应。我们首先预留一个临时缓冲区来存储头部字段：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once the buffer is reserved, the server prints relevant headers into it and
    then sends those headers to the client. This is done using `sprintf()` and then
    `send()` in turn. The following code sends the HTTP response header:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦预留了缓冲区，服务器将相关头部打印到其中，然后依次发送这些头部到客户端。这是通过 `sprintf()` 和 `send()` 完成的。以下代码发送
    HTTP 响应头部：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that the last `send()` statement sends `\r\n`. This has the effect of transmitting
    a blank line. This blank line is used by the client to delineate the HTTP header
    from the beginning of the HTTP body.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，最后的 `send()` 语句发送 `\r\n`。这会产生发送一个空白行的效果。这个空白行被客户端用来区分 HTTP 头部与 HTTP 主体开始。
- en: 'The server can now send the actual file content. This is done by calling `fread()`
    repeatedly until the entire file is sent:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器现在可以发送实际的文件内容。这是通过重复调用 `fread()` 直到整个文件发送完毕来完成的：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding code, `fread()` is used to read enough data to fill `buffer`.
    This buffer is then transmitted to the client using `send()`. These steps are
    looped until `fread()` returns `0`; this indicates that the entire file has been
    read.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`fread()`用于读取足够的数据以填充`buffer`。然后，使用`send()`将这个缓冲区传输给客户端。这些步骤会一直循环，直到`fread()`返回`0`；这表示已经读取了整个文件。
- en: Note that `send()` may block on large files. In a truly robust, production-ready
    server, you would need to handle this case. It could be done by using `select()`
    to determine when each socket is ready to read. Another common method is to use
    `fork()` or similar APIs to create separate threads/processes for each connected
    client. For simplicity, our server accepts the limitation that `send()` blocks
    on large files. Please refer to [Chapter 13](11c5bb82-e55f-4977-bf7f-5dbe791fde92.xhtml),
    *Socket Programming Tips and Pitfalls*, for more information about the blocking
    behavior of `send()`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`send()`在处理大文件时可能会阻塞。在一个真正健壮、准备投入生产的服务器中，你需要处理这种情况。这可以通过使用`select()`来确定每个套接字何时准备好读取来实现。另一种常见的方法是使用`fork()`或类似的API为每个连接的客户端创建单独的线程/进程。为了简单起见，我们的服务器接受`send()`在处理大文件时可能会阻塞的限制。请参阅[第13章](11c5bb82-e55f-4977-bf7f-5dbe791fde92.xhtml)，*Socket编程技巧与陷阱*，以获取有关`send()`阻塞行为的更多信息。
- en: 'The function can finish by closing the file handle and using `drop_client()`
    to disconnect the client:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以通过关闭文件句柄并使用`drop_client()`来断开客户端的连接：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: That concludes the `serve_resource()` function.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了`serve_resource()`函数。
- en: Keep in mind that while `serve_resource()` attempts to limit access to only
    the `public` directory, it is not adequate in doing so, and `serve_resource()`
    should not be used in production code without carefully considering additional
    access loopholes. We discuss more security concerns later in this chapter.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，虽然`serve_resource()`函数试图限制访问仅限于`public`目录，但这并不充分，且在生产代码中不应在没有仔细考虑额外的访问漏洞的情况下使用`serve_resource()`。我们将在本章后面讨论更多的安全问题。
- en: With these helper functions out of the way, implementing our main server loop
    is a much easier task. We begin that next.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些辅助函数处理完毕后，实现我们的主服务器循环就变得容易多了。我们将在下一节开始介绍。
- en: The main loop
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主循环
- en: With our many helper functions out of the way, we can now finish `web_server.c`.
    Remember to first `#include chap07.h` and also add in all of the types and functions
    we've defined so far—`struct client_info`, `get_content_type()`, `create_socket()`,
    `get_client()`, `drop_client()`, `get_client_address()`, `wait_on_clients()`,
    `send_400()`, `send_404()`, and `serve_resource()`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完许多辅助函数后，我们现在可以完成`web_server.c`。请记住，首先`#include chap07.h`，并添加我们之前定义的所有类型和函数—`struct
    client_info`、`get_content_type()`、`create_socket()`、`get_client()`、`drop_client()`、`get_client_address()`、`wait_on_clients()`、`send_400()`、`send_404()`和`serve_resource()`。
- en: 'We can then begin the `main()` function. It starts by initializing Winsock
    on Windows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以开始编写`main()`函数。它首先在Windows上初始化Winsock：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We then use our earlier function, `create_socket()`, to create the listening
    socket. Our server listens on port `8080`, but feel free to change it. On Unix-based
    systems, listening on low port numbers is reserved for privileged accounts. For
    security reasons, our web server should be running with unprivileged accounts
    only. This is why we use `8080` as our port number instead of the HTTP standard
    port, `80`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用之前定义的函数`create_socket()`来创建监听套接字。我们的服务器监听端口`8080`，但你可以自由更改它。在基于Unix的系统上，监听低端口是为特权账户保留的。出于安全原因，我们的Web服务器应该仅以非特权账户运行。这就是为什么我们使用`8080`作为端口号而不是HTTP标准端口`80`。
- en: 'The code to create the server socket is as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 创建服务器套接字的代码如下：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you want to accept connections from only the local system, and not outside
    systems, use the following code instead:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想接受来自本地系统的连接，而不是来自外部系统的连接，请使用以下代码：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We then begin an endless loop that waits on clients. We call `wait_on_clients()`
    to wait until a new client connects or an old client sends new data:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们开始一个无限循环，等待客户端连接。我们调用`wait_on_clients()`等待新的客户端连接或旧的客户端发送新数据：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `server` then detects whether a new `client` has connected. This case is
    indicated by `server` being set in `fd_set reads`. We use the `FD_ISSET()` macro
    to detect this condition:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`server`随后检测是否有新的`client`连接。这种情况由`server`在`fd_set reads`中被设置来指示。我们使用`FD_ISSET()`宏来检测这种条件：'
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Once a new client connection has been detected, `get_client()` is called with
    the argument `-1`; `-1` is not a valid socket specifier, so `get_client()` creates
    a new `struct client_info`. This `struct client_info` is assigned to the `client`
    variable.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦检测到新的客户端连接，就使用带有参数`-1`的`get_client()`进行调用；`-1`不是一个有效的套接字指定符，因此`get_client()`创建一个新的`struct
    client_info`。这个`struct client_info`被分配给`client`变量。
- en: The `accept()` socket function is used to accept the new connection and place
    the connected clients address information into the respective `client` fields.
    The new socket returned by `accept()` is stored in `client->socket`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`accept()`套接字函数用于接受新的连接，并将连接的客户端地址信息放入相应的`client`字段。`accept()`返回的新套接字存储在`client->socket`中。'
- en: The client's address is printed using a call to `get_client_address()`. This
    is helpful for debugging.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的地址通过调用`get_client_address()`来打印。这对于调试很有帮助。
- en: Our server must then handle the case where an already connected client is sending
    data. This is a bit more complicated. We first walk through the linked list of
    clients and use `FD_ISSET()` on each client to determine which clients have data
    available. Recall that the linked list root is stored in the `clients` global
    variable.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的服务器必须处理已经连接的客户端发送数据的情况。这要复杂一些。我们首先遍历客户端链表，并对每个客户端使用`FD_ISSET()`来确定哪些客户端有可用数据。回想一下，链表根存储在`clients`全局变量中。
- en: 'We begin our linked list walk with the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从以下内容开始我们的链表遍历：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We then check that we have memory available to store more received data for `client`.
    If the client''s buffer is already completely full, then we send a `400` error.
    The following code checks for this condition:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查是否有内存可用来存储更多为`client`接收到的数据。如果客户端的缓冲区已经完全填满，则发送一个`400`错误。以下代码检查这种条件：
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Knowing that we have at least some memory left to store received data, we can
    use `recv()` to store the client''s data. The following code uses `recv()` to
    write new data into the client''s buffer while being careful to not overflow that
    buffer:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 知道我们至少还有一些内存来存储接收到的数据，我们可以使用`recv()`来存储客户端的数据。以下代码使用`recv()`将新数据写入客户端的缓冲区，同时小心不要溢出该缓冲区：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'A client that disconnects unexpectedly causes `recv()` to return a non-positive
    number. In this case, we need to use `drop_client()` to clean up our memory allocated
    for that client:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一个意外断开的客户端会导致`recv()`返回一个非正数。在这种情况下，我们需要使用`drop_client()`来清理为该客户端分配的内存：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If the received data was written successfully, our server adds a null terminating
    character to the end of that client's data buffer. This allows us to use `strstr()`
    to search the buffer, as the null terminator tells `strstr()` when to stop.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果接收到的数据已成功写入，我们的服务器会在该客户端数据缓冲区的末尾添加一个空终止字符。这允许我们使用`strstr()`来搜索缓冲区，因为空终止字符告诉`strstr()`何时停止。
- en: 'Recall that the HTTP header and body is delineated by a blank line. Therefore,
    if `strstr()` finds a blank line (`\r\n\r\n`), we know that the HTTP header has
    been received and we can begin to parse it. The following code detects whether
    the HTTP header has been received:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，HTTP头和正文由一个空白行分隔。因此，如果`strstr()`找到一个空白行（`\r\n\r\n`），我们知道已经接收到了HTTP头，我们可以开始解析它。以下代码检测是否已接收到HTTP头：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Our server only handles `GET` requests. We also enforce that any valid path
    should start with a slash character; `strncmp()` is used to detect these two conditions
    in the following code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器只处理`GET`请求。我们还强制任何有效的路径应以斜杠字符开始；`strncmp()`在以下代码中用于检测这两个条件：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding code, a proper `GET` request causes the execution of the `else`
    branch. Here, we set the `path` variable to the beginning of the request path,
    which is starting at the fifth character of the HTTP request (because C arrays
    start at zero, the fifth character is located at `client->request + 4`).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，一个合适的`GET`请求会导致执行`else`分支。在这里，我们将`path`变量设置为请求路径的开始，它从HTTP请求的第五个字符开始（因为C数组从零开始，第五个字符位于`client->request
    + 4`）。
- en: The end of the requested path is indicated by finding the next space character.
    If found, we just call our `serve_resource()` function to fulfil the client's
    request.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 请求路径的结束通过找到下一个空格字符来指示。如果找到了，我们就调用我们的`serve_resource()`函数来满足客户端的请求。
- en: 'Our server is basically functional at this point. We only need to finish our
    loops and close out the `main()` function. The following code accomplishes this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的服务器基本上是功能性的。我们只需要完成我们的循环并关闭`main()`函数。以下代码实现了这一点：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that our server doesn't actually have a way to break from its infinite
    loop. It simply listens to connections forever. As an exercise, you may want to
    add in functionality that allows the server to shut down cleanly. This was omitted
    only to keep the code simpler. It may also be useful to drop all connected clients
    with this line of code—`while(clients) drop_client(clients);`
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的服务器实际上没有一种方法可以跳出无限循环。它只是永远地监听连接。作为一个练习，您可能想要添加允许服务器干净关闭的功能。这被省略了，只是为了使代码更简单。也可能有用的是，使用此行代码——`while(clients)
    drop_client(clients);`——断开所有已连接客户端。
- en: That concludes the code for `web_server.c`. I recommend you download `web_server.c`
    from this book's code repository and try it out.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了 `web_server.c` 的代码。我建议您从本书的代码库中下载 `web_server.c` 并尝试运行它。
- en: 'You can compile and run `web_server.c` on Linux and macOS with the following
    commands:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令在 Linux 和 macOS 上编译和运行 `web_server.c`：
- en: '[PRE38]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'On Windows, the command to compile and run using MinGW is as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，使用 MinGW 编译和运行的命令如下：
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following screenshot shows the server being compiled and run on macOS:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在 macOS 上编译和运行服务器的情况：
- en: '![](img/a3be806f-1a15-46dd-bc3d-e7e99eacab87.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a3be806f-1a15-46dd-bc3d-e7e99eacab87.png)'
- en: 'If you connect to the server using a standard web browser, you should see something
    such as the following screenshot:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用标准网络浏览器连接到服务器，您应该看到以下截图所示的内容：
- en: '![](img/177aacbc-25f5-4d57-a3af-7ffafa9f3ccd.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/177aacbc-25f5-4d57-a3af-7ffafa9f3ccd.png)'
- en: You can also drop different files into the `public` folder and play around with
    creating more complicated websites.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以将不同的文件拖放到 `public` 文件夹中，并尝试创建更复杂的网站。
- en: An alternative source file, `web_server2.c`, is also provided in this chapter's
    code repository. It behaves exactly like the code we developed, but it avoids
    having global state (at the expense of a little added verbosity). This may make
    `web_server2.c` more suitable for integration into more significant projects and
    continued development.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码库中还提供了一个替代源文件 `web_server2.c`。它的行为与我们开发的代码完全一样，但它避免了全局状态（以牺牲一点额外的冗长为代价）。这可能使
    `web_server2.c` 更适合集成到更重要的项目中，并继续开发。
- en: Although the web server we developed certainly works, it does have a number
    of shortcomings. Please don't deploy this server (or any other network code) in
    the wild without very carefully considering these shortcomings, some of which
    we address next.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们开发的 Web 服务器确实可以工作，但它确实存在一些缺点。请在非常仔细地考虑这些缺点之后，再部署此服务器（或任何其他网络代码），其中一些缺点我们将在下面讨论。
- en: Security and robustness
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性和健壮性
- en: One of the most important rules, when developing networked code, is that your
    program should never trust the connected peer. Your code should never assume that
    the connected peer sends data in a particular format. This is especially vital
    for server code that may communicate with multiple clients at once.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发网络代码时，最重要的规则之一是您的程序永远不应该信任连接的对方。您的代码永远不应该假设连接的对方以特定的格式发送数据。这对于可能同时与多个客户端通信的服务器代码尤其重要。
- en: If your code doesn't carefully check for errors and unexpected conditions, then
    it will be vulnerable to exploits.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的代码没有仔细检查错误和意外条件，那么它将容易受到攻击。
- en: 'Consider the following code which receives data into a buffer until a **space**
    character is found:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，它将数据读入缓冲区，直到找到 **空格** 字符：
- en: '[PRE40]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The preceding code works simply. It reserves 1,028 bytes of buffer space and
    then uses `recv()` to write received data into that space. The `p` pointer is
    updated on each read to indicate where the next data should be written. The code
    then loops until the `strstr()` function detects a space character.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码很简单。它预留了 1,028 字节的缓冲区空间，然后使用 `recv()` 将接收到的数据写入该空间。每次读取时，`p` 指针都会更新，以指示下一个数据应该写入的位置。然后代码循环，直到
    `strstr()` 函数检测到空格字符。
- en: That code could be useful to read data from a client until an HTTP verb is detected.
    For example, it could receive data until `GET` is received, at which point the
    server can begin to process a `GET` request.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码可以用来从客户端读取数据，直到检测到 HTTP 动词。例如，它可以接收数据直到接收到 `GET`，此时服务器可以开始处理 `GET` 请求。
- en: One problem with the preceding code is that `recv()` could write past the end
    of the allocated space for `buffer`. This is because `1028` is passed to `recv()`,
    even if some data has already been written. If a network client can cause your
    code to write past the end of a buffer, then that client may be able to completely
    compromise your server. This is because both data and executable code are stored
    in your server's memory. A malicious client may be able to write executable code
    past the `buffer` array and cause your program to execute it. Even if the malicious
    code isn't executed, the client could still overwrite other important data in
    your server's memory.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的一个问题是`recv()`可能会超出为`buffer`分配的空间的末尾进行写入。这是因为即使已经写入了一些数据，也会将`1028`传递给`recv()`。如果一个网络客户能够让你的代码写入到缓冲区末尾之外，那么该客户可能能够完全破坏你的服务器。这是因为数据和可执行代码都存储在你的服务器内存中。恶意客户可能能够在`buffer`数组之后写入可执行代码，并导致你的程序执行它。即使恶意代码没有被执行，客户仍然可以覆盖服务器内存中的其他重要数据。
- en: 'The preceding code can be fixed by passing to `recv()` only the amount of buffer
    space remaining:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码可以通过只传递给`recv()`剩余的缓冲区空间来修复：
- en: '[PRE41]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this case, `recv()` is not be able to write more than 1,028 bytes total into
    `buffer`. You may think that the memory errors are resolved, but you would still
    be wrong. Consider a client that sends 1,028 bytes, but no space characters. Your
    code then calls `strstr()` looking for a space character. Considering that `buffer`
    is completely full now, `strstr()` cannot find a space character or a null terminating
    character! In that case, `strstr()` continues to read past the end of `buffer`
    into unallocated memory.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`recv()`无法将超过1,028个字节的总量写入`buffer`。你可能认为内存错误已经解决，但你仍然会犯错。考虑一个发送1,028个字节但不含空格字符的客户。然后你的代码调用`strstr()`寻找空格字符。考虑到`buffer`现在已完全填满，`strstr()`无法找到空格字符或空终止字符！在这种情况下，`strstr()`会继续读取到`buffer`末尾之后的未分配内存。
- en: 'So, you fix this issue by only allowing `recv()` to write 1,027 bytes total.
    This reserves one byte to remain as the null terminating character:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你通过只允许`recv()`写入总共1,027个字节来解决这个问题。这保留了一个字节作为空终止字符：
- en: '[PRE42]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now your code won't write or read past the array bounds for `buffer`, but the
    code is still very broken. Consider a client that sends 1,027 characters. Or consider
    a client that sends a single null character. In either case, the preceding code
    continues to loop forever, thus locking up your server and preventing other clients
    from being served.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的代码不会超出`buffer`数组的边界进行写入或读取，但代码仍然非常糟糕。考虑一个发送1,027个字符的客户。或者考虑一个只发送单个空字符的客户。在任一情况下，前面的代码会持续无限循环，从而锁定你的服务器，阻止其他客户被服务。
- en: Hopefully, the previous examples illustrate the care needed to implement a server
    in C. Indeed, it's easy to create bugs in any programming language, but in C special
    care needs to be taken to avoid memory errors.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 希望前面的例子说明了在C语言中实现服务器所需的谨慎。确实，在任何编程语言中创建错误都很容易，但在C语言中需要特别注意以避免内存错误。
- en: Another issue with server software is that the server wants to allow access
    to some files on the system, but not others. A malicious client could send an
    HTTP request that tries to download arbitrary files from your server system. For
    example, if an HTTP request such as `GET /../secret_file.c HTTP/1.1` was sent
    to a naive HTTP server, that server may send the `secret_file.c` to the connected
    client, even though it exists outside of the `public` directory!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器软件的另一个问题是，服务器希望允许访问系统上的某些文件，但不允许访问其他文件。恶意客户可以发送一个尝试从你的服务器系统下载任意文件的HTTP请求。例如，如果发送了一个如`GET
    /../secret_file.c HTTP/1.1`这样的HTTP请求到一个天真的HTTP服务器，那个服务器可能会将`secret_file.c`发送给连接的客户，即使它存在于`public`目录之外！
- en: Our code in `web_server.c` detects the most obvious attempts at this by searching
    for requests containing `..` and denying those requests.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`web_server.c`中的代码通过搜索包含`..`的请求并拒绝这些请求来检测这种尝试的最明显尝试。
- en: A robust server should use operating systems features to detect that requested
    files exist as actual files in the permitted directory. Unfortunately, there is
    no cross-platform way to do this, and the platform-dependent options are somewhat
    complicated.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一个健壮的服务器应该使用操作系统功能来检测请求的文件是否实际存在于允许的目录中。不幸的是，没有跨平台的方法来做这件事，并且平台相关的选项相当复杂。
- en: Please understand that these are not purely theoretical concerns, but actual
    exploitable bugs. For example, if you run our `web_server.c` program on Windows
    and a client sends the request `GET /this_will_be_funny/PRN HTTP/1.1`, what do
    you suppose happens?
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 请理解，这些问题并非纯粹的理论担忧，而是实际可利用的漏洞。例如，如果你在Windows上运行我们的`web_server.c`程序，并且一个客户端发送了请求`GET
    /this_will_be_funny/PRN HTTP/1.1`，你认为会发生什么？
- en: The `this_will_be_funny` directory doesn't exist, and the `PRN` file  certainly
    doesn't exist in that non-existent directory. These facts may lead you to think
    that the server simply returns a `404 Not Found` error, as expected. However,
    that's not what happens. Under Windows, `PRN` is a special filename. When your
    server calls `fopen()` on this special name, Windows doesn't look for a file,
    but rather it connects to a *printer* interface! Other special names include `COM1`
    (connects to serial port 1) and `LPT1` (connects to parallel port 1), although
    there are others. Even if these filenames have an extension, such as `PRN.txt`,
    Windows still redirects instead of looking for a file.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`this_will_be_funny`目录不存在，并且在该不存在的目录中肯定不存在`PRN`文件。这些事实可能会让你认为服务器会简单地返回预期的`404
    Not Found`错误。然而，事实并非如此。在Windows中，`PRN`是一个特殊的文件名。当你的服务器调用`fopen()`对这个特殊名称时，Windows不会寻找文件，而是连接到一个*打印机*接口！其他特殊名称包括`COM1`（连接到串行端口1）和`LPT1`（连接到并行端口1），尽管还有其他。即使这些文件名有扩展名，例如`PRN.txt`，Windows也会重定向而不是寻找文件。'
- en: One generally applicable piece of security advice is this—run your networked
    programs under non-privileged accounts that have access to only the minimum resources
    needed to function. In other words, if you are going to run a networked server,
    create a new account to run it under. Give that account read access to only the
    files that server needs to serve. This is not a substitute for writing secure
    code, but rather running as a non-privilege user creates one final barrier. It
    is advice you should apply even when running hardened, industry-tested server
    software.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一条普遍适用的安全建议是——在只有访问执行所需的最小资源的非特权账户下运行你的网络程序。换句话说，如果你要运行网络服务器，创建一个新的账户来运行它。只给该账户读取访问服务器需要服务的文件。这不是编写安全代码的替代品，而是在作为非特权用户运行时创建了一个最后的障碍。即使运行经过加固、经过行业测试的服务器软件，你也应该应用这条建议。
- en: Hopefully, the previous examples illustrate that programming is complicated,
    and safe network programming in C can be difficult. It is best approached with
    care. Oftentimes, it is not possible to know that you have all the loopholes covered.
    Operating systems don't always have adequate documentation. Operating system APIs
    often behave in non-obvious and non-intuitive ways. Be careful.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 希望前面的例子能说明编程是复杂的，使用C进行安全网络编程可能很困难。最好谨慎处理。通常，你无法确定你已经覆盖了所有漏洞。操作系统并不总是有充分的文档。操作系统API的行为往往是非直观的。请小心。
- en: Open source servers
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开源服务器
- en: The code developed in this chapter is suitable for use in trusted applications
    on trusted networks. For example, if you are developing a video game, it can be
    very useful to make it serve a web page that displays debugging information. This
    doesn't have to be a security concern, as it can limit connections to the local
    machine.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开发的代码适用于在受信任网络上运行的受信任应用程序。例如，如果你正在开发一款视频游戏，让它提供显示调试信息的网页可能非常有用。这不必成为安全担忧，因为它可以限制连接到本地机器。
- en: If you must deploy a web server on the internet, I suggest you consider using
    a free and open source implementation that's already available. The web servers
    Nginx and Apache, for example, are highly performant, cross-platform, secure,
    written in C, and completely free. They are also well-documented and easy to find
    support for.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须在互联网上部署Web服务器，我建议你考虑使用已经可用的免费和开源实现。例如，Nginx和Apache等Web服务器性能卓越，跨平台，安全，用C语言编写，并且完全免费。它们也具有良好的文档，并且容易找到支持。
- en: If you want to expose your program to the internet, you can communicate to a
    web server using either CGI or FastCGI. With CGI, the web server handles the HTTP
    request. When a request comes in, it runs your program and returns your program's
    output in the HTTP response body.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将你的程序暴露在互联网上，你可以使用CGI或FastCGI与Web服务器通信。使用CGI时，Web服务器处理HTTP请求。当请求到来时，它会运行你的程序，并在HTTP响应体中返回你的程序输出。
- en: Alternatively, many web servers (such as Nginx or Apache) work as a reverse
    proxy. This essentially puts the web server between your code and the internet.
    The web server accepts and forwards HTTP messages to your HTTP server. This can
    have the effect of slightly shielding your code from attackers.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，许多网络服务器（如Nginx或Apache）作为反向代理工作。这实际上将网络服务器置于你的代码和互联网之间。网络服务器接受并转发HTTP消息到你的HTTP服务器。这可以稍微保护你的代码免受攻击者侵害。
- en: Summary
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we worked through implementing an HTTP server in C from scratch.
    That's no small feat! Although the text-based nature of HTTP makes parsing HTTP
    requests simple, we needed to spend a lot of effort to ensure that multiple clients
    could be served simultaneously. We accomplished this by buffering received data
    for each client separately. Each client's state information was organized into
    a linked list.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从零开始实现了C语言中的HTTP服务器。这可不是一件小事！尽管HTTP的文本性质使得解析HTTP请求变得简单，但我们仍需付出大量努力以确保能够同时服务多个客户端。我们通过为每个客户端分别缓冲接收到的数据来实现这一点。每个客户端的状态信息被组织成一个链表。
- en: Another difficulty was ensuring the safe handling of received data and detecting
    errors. We learned that a programmer must be very careful when handling network
    data to avoid creating security risks. We also saw that even very subtle issues,
    such as Windows's special filenames, can potentially create dangerous security
    holes for networked server applications.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个困难是确保接收到的数据的安全处理和错误检测。我们了解到，程序员在处理网络数据时必须非常小心，以避免创建安全风险。我们还看到，即使是微不足道的问题，例如Windows的特殊文件名，也可能为网络服务器应用程序造成潜在的危险安全漏洞。
- en: In the next chapter, [Chapter 8](47e209f2-0231-418c-baef-82db74df8c29.xhtml), *Making
    Your Program Send Email*, we move on from HTTP and consider the primary protocol
    associated with email—**Simple Mail Transfer Protocol** (**SMTP**).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，[第8章](47e209f2-0231-418c-baef-82db74df8c29.xhtml)，*让你的程序发送电子邮件*，我们将从HTTP转向考虑与电子邮件相关的主要协议——**简单邮件传输协议**
    (**SMTP**)。
- en: Questions
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Try these questions to test your knowledge from this chapter:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下问题以测试你对本章知识的掌握：
- en: How does an HTTP client indicate that it has finished sending the HTTP request?
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTTP客户端如何表明它已经完成了HTTP请求的发送？
- en: How does an HTTP client know what type of content the HTTP server is sending?
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTTP客户端如何知道HTTP服务器发送的内容类型？
- en: How can an HTTP server identify a file's media type?
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTTP服务器如何识别文件的媒体类型？
- en: How can you tell whether a file exists on the filesystem and is readable by
    your program? Is `fopen(filename, "r") != 0` a good test?
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何判断文件是否存在于文件系统中，并且你的程序可以读取它？`fopen(filename, "r") != 0`是一个好的测试吗？
- en: The answers to these questions can be found in [Appendix A](bd8b8f52-52cb-4d34-b01b-e907564bfece.xhtml),
    *Answers to Questions*.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的答案可以在[附录A](bd8b8f52-52cb-4d34-b01b-e907564bfece.xhtml)，*问题答案*中找到。
- en: Further reading
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information about HTTP and HTML, please refer to the following:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 关于HTTP和HTML的更多信息，请参考以下内容：
- en: '**RFC 7230**: *Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing*
    ([https://tools.ietf.org/html/rfc7230](https://tools.ietf.org/html/rfc7230))'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RFC 7230**：*超文本传输协议 (HTTP/1.1)：消息语法和路由* ([https://tools.ietf.org/html/rfc7230](https://tools.ietf.org/html/rfc7230))'
- en: '**RFC 7231**: *Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content* ([https://tools.ietf.org/html/rfc7231](https://tools.ietf.org/html/rfc7231))'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RFC 7231**：*超文本传输协议 (HTTP/1.1)：语义和内容* ([https://tools.ietf.org/html/rfc7231](https://tools.ietf.org/html/rfc7231))'
- en: '*Media Types* ([https://www.iana.org/assignments/media-types/media-types.xhtml](https://www.iana.org/assignments/media-types/media-types.xhtml))'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*媒体类型* ([https://www.iana.org/assignments/media-types/media-types.xhtml](https://www.iana.org/assignments/media-types/media-types.xhtml))'
