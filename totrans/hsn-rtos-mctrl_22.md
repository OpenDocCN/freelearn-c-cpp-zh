# 评估

# 第一章

1.  No. 具有实时要求的系统简单来说就是动作需要是确定的。时间要求由每个系统的需求决定。

1.  No. 实现实时性能有几种不同的方法。

1.  No.

1.  任何对给定事件有确定响应的系统都可以被认为是**实时**的。

1.  大多数工业控制、闭环控制系统、无人机飞行控制器、**防抱死制动系统（ABS**）、**发动机控制单元（ECU**）、喷墨打印机、测试设备（如示波器和网络分析仪）等等。

1.  基于微控制器（MCU）的实时操作系统（RTOS）的强项是中等复杂度的系统。

# 第一章

1.  上述两种选项。

1.  错误。

1.  复杂的超循环往往在执行循环所需的时间上有很大的变化。这可能导致系统中的确定性较差，因为没有简单的方法来提供一种让高优先级工作在循环中优先于其他所有操作的手段。

1.  中断和直接内存访问（DMA）都可以用来提高超级循环对外部事件的响应。它们允许在超级循环周期内无需轮询即可服务硬件外设。

1.  系统中只有一个超循环正在运行。它共享系统堆栈。然而，任务各自接收它们自己的专用堆栈。每个任务都接收一个优先级，这与没有优先级概念的超级循环不同。

1.  优先级。

1.  预先占先的调度器试图确保具有最高优先级的任务总是正在执行的任务。

# 第三章

1.  队列。

1.  是的。

1.  信号量。

1.  网络堆栈或任何必须强制执行最大同时用户数量的地方。

1.  优先级继承。

1.  互斥锁。

1.  优先级反转允许低优先级任务优先于高优先级任务。这是危险的，因为它增加了高优先级任务错过截止日期的可能性。

# 第四章

1.  固件编程，尤其是对于微控制器（MCU），非常接近底层，这意味着它非常接近硬件。通常有硬件特定的功能，固件工程师必须熟悉这些功能才能从 MCU 中获得最佳性能。

1.  错误。

1.  硬件外设。

1.  快速原型设计、现有硬件、社区、不同微控制器（MCU）之间的一致性高级 API。

1.  评估板通常展示了产品的关键差异化特性。它们也被设计得尽可能完整，便于访问设备的各个方面。

1.  睡眠电流、唤醒时间、功耗（uA/MHz）、低功耗模式的功能以及电源电压。

1.  为了使其对尽可能多的读者都易于访问——所以请确保购买一个并使用真实硬件上的练习！

# 第五章

1.  错误。理想的集成开发环境（IDE）将反映个人/组织偏好。一个非常适合某个团队或工作流程的特定 IDE 可能不适合其他地方。

1.  错误。许多免费可用的集成开发环境非常适合专业嵌入式系统开发。

1.  错误。供应商提供的集成开发环境在质量上可能会有很大差异。小心不要过于依赖供应商的 IDE，尤其是如果您更喜欢使用其他供应商的 MCU。

1.  错误。至少，我们期望软件生成的代码第一次就能在语法上正确。除此之外，代码生成的好坏取决于提供它的前端，这通常比底层代码库演变得更慢（因此您稍后仍需要编写自定义代码）。

1.  错误。本书的 IDE 是根据成本选择的，并且只考虑了与 STM32 设备的兼容性。

1.  设备选择、硬件启动和中间件集成。*为什么*它在这些领域都有用，在*考虑 STMCube*部分中进行了说明。

# 第六章

1.  错误。在本章中，Nucleo 开发板上的 ST-Link 被重新烧录以提供与 J-Link 相同的功能。

1.  错误。有许多方法可以验证实时系统的时序要求。Segger SystemView 提供了一种测量响应时间的方法，查看系统输入和输出也可以通过传统的逻辑分析仪来实现。

1.  错误。RTOS 感知调试器提供了查看系统中所有堆栈的能力。这也是任何基于 Open GDB 的调试使用 Eclipse 时的一个选项，如前一章所述。

1.  错误。您编写的每个模块都应该尽可能彻底地进行测试，以最小化在集成模块和进行系统级测试时出现的任何惊喜和复杂交互。

1.  单元测试。在单元测试中，每个模块在开发过程中都会被测试。集成测试是在多个模块“集成”后确保它们按预期工作的测试。系统测试是在所有内容都集成后测试整个系统（通常在集成之后）。黑盒测试是一种测试风格，它对“黑盒”内部的系统一无所知，并且仅将输出与给定的输入集的预期行为进行比较。

1.  **测试驱动开发**（**TDD**）。

# 第七章

1.  有两种选项——`xTaskCreate()`和`xTaskCreateStatic()`。

1.  正确。如果所需的内存不可用，`xTaskCreate()`可能会失败。

1.  正确。如果空闲任务的所需内存不可用，`vTaskStartScheduler()`可能会失败。

1.  错误。每个任务所需的 RAM 为 64 字节加上任务堆栈大小。确切的堆栈大小需求完全取决于您的代码，而不是 FreeRTOS。

1.  错误。可以通过调用`vTaskDelete()`来删除任务，前提是使用兼容的堆（有关详细信息，请参阅第十五章，*FreeRTOS 内存管理*）。

# 第八章

1.  同步；共享资源保护。

1.  优先级反转（访问*优先级反转（如何不使用信号量）*部分以获取详细信息）

1.  **MUT**utual **EX**clusion，指的是对共享资源访问的控制方式。

1.  它通过自动提高等待高优先级任务所持有的互斥锁的低优先级任务的优先级，确保高优先级任务尽可能少地阻塞，从而限制优先级反转。

1.  错误。尽管易于使用，但软件定时器有其局限性，包括抖动和频率。

# 第九章

1.  由于底层有`void*`输入参数，队列可以持有任何数据类型。

1.  正在等待向队列发送数据的任务被置于阻塞状态（如果指定了`portMAX_DELAY`，则挂起）。

1.  提到了三个考虑因素：底层值的拥有权、确保将正确的数据类型传递到队列中，以及确保数据保持完整（通过不在易变堆栈上放置它）。

1.  错误。任务通知只存储单个`uint32_t`，并允许一个具有已知任务句柄的单个任务被解除阻塞。队列能够存储任何数据类型，并且可以在多个任意任务之间使用。

1.  错误。任务通知只存储单个`uint32_t`。

1.  速度和 RAM 效率。

# 第十章

1.  中断驱动的驱动程序更复杂，因为至少涉及三段代码（设置代码、ISR 代码和回调代码）。使用轮询驱动程序，所有这些操作都是串行发生的。

1.  错误。只有以`FromISR`结尾的函数才可以在中断服务例程（ISR）中调用。

1.  错误。由于调度器应配置为从最低优先级中断运行，因此中断优先于调度器。

1.  DMA – 它使用硬件在外围设备和内存之间传输数据，无需任何 CPU 干预。

1.  直接内存访问。

1.  在任何时间点尝试接收数据，使用原始缓冲区很难做得很好。当接收未知长度的数据时，原始缓冲区也可能变得有点复杂。

# 第十一章

1.  错误。

1.  错误。在决定共享硬件外设是否可接受之前，必须考虑诸如增加延迟和降低确定性以及更少的通信带宽等时间权衡。

1.  所有上述内容。

1.  错误。流缓冲区可以被单个写者和单个读者使用。这些写者和读者不需要是同一个任务。如果有多个写者或多个读者，那么需要一个同步机制（例如互斥锁）。

1.  互斥锁。

# 第十二章

1.  错误。抽象在最小的 MCU 中也是有用的。

1.  错误。本章介绍了实现一致接口的方法。

1.  可能的答案包括以下内容：

    +   常用组件将在其他项目中重用。

    +   适应不同硬件的便携性是可取的。

    +   代码将被单元测试。

    +   团队将并行工作。

1.  错误。有关更多详细信息，请参阅*避免复制粘贴修改陷阱*部分。

1.  错误。当正确编写时，任务可以是跨项目重用的优秀候选者（有关更多详细信息，请参阅*重用包含任务的代码*部分）。

# 第十三章

1.  错误。队列创建了一个明确的接口，从而将组件彼此解耦。

1.  错误。任何数据类型都可以放入队列中。

1.  不，省略底层格式化允许队列项的生产者有更多的灵活性。如果数据没有绑定到特定格式，则可以修改格式而不会影响队列或从队列中出来的数据消费者。

1.  可能的答案包括以下：

    +   由于创建了副本，因此不需要考虑队列项的生存期。

    +   如果通过值传递到队列中，则不需要考虑队列项的作用域。

    +   如果通过引用传递项目，则需要清楚地了解谁**拥有**该项目，以及谁负责释放与其相关的资源。

1.  可能的答案包括以下：

    +   深队列引入的延迟

    +   由于请求在队列中等待而不是立即执行（或拒绝）而引起的非确定性行为

    +   内存限制

# 第十四章

1.  **CMSIS-RTOS**代表**Cortex 微控制器软件接口标准 - 实时操作系统**。CMSIS-RTOS 规范由 ARM 编写，但许多供应商可以选择在其 RTOS 中提供符合 CMSIS-RTOS 的接口。

1.  Linux 和 Android。

1.  错误。

1.  错误。

# 第十五章

1.  错误。

1.  错误。

1.  有五种实现：`heap_1.c`至`heap_5.c`。

1.  `vApplicationStackOverflowHook`和`vApplicationMallocFailedHook`。

1.  **MPU**代表**内存保护单元**。它用于防止非法内存访问，特别是作为划分任务的方式，以便它们只能访问自己的内存空间。

# 第十六章

1.  **多核**意味着同一 IC 上的多个核心，而**多处理器**意味着同一设计中的多个处理器（IC）。

1.  正确。非对称架构不需要以相同的方式处理各种处理核心，因此可以使用任何操作系统和裸机编程语言的组合（在硬件限制范围内）。

1.  错误。在选择特定应用的**最佳**总线时需要考虑许多方面，因为每个应用都将有其独特的环境和需求。

1.  需要权衡额外的复杂性以及不执行相同工作的可能性。当开发可重用子系统时，在适当的情况下可以创造相当大的成本节约。它们在重用时几乎没有或没有**非重复工程**（**NRE**）成本。

# 第十七章

1.  你应该做以下：

    1.  连接调试器。

    1.  找出程序停止的地方。

    1.  如果是`configASSERT`，请阅读围绕断言的注释。如果它在调度器启动之前失败，你很可能已经溢出了 FreeRTOS 堆。

1.  以下任何一个：

    +   任务堆栈溢出

    +   优先级错误的 ISR

    +   堆大小不足

1.  错误。存在调试工具，如 Segger SystemView，它们提供 printf 风格的输出以及用于观察代码行为的仪器功能。
