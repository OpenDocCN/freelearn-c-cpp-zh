- en: '*Chapter 17*: Sound Spatialization and the HUD'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be adding all the sound effects and the HUD. We have
    done this in two of the previous projects, but we will do things a bit differently
    this time. We will explore the concept of sound **spatialization** and how SFML
    makes this otherwise complicated concept nice and easy. In addition, we will build
    a HUD class to encapsulate our code that draws information to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: We will complete these tasks in the following order.
  prefs: []
  type: TYPE_NORMAL
- en: What is spatialization?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How SFML handles spatialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a SoundManager class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying emitters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the SoundManager class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a `HUD` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `HUD` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is spatialization?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Spatialization** is the act of making something relative to the space it
    is a part of, or within. In our daily lives, everything in the natural world,
    by default, is spatialized. If a motorbike whizzes past from left to right, we
    will hear the sound grow from faint to loud from one side to the other. As it
    passes by, it will become more prominent in the other ear, before fading into
    the distance once more. If we were to wake up one morning and the world was no
    longer spatialized, it would be exceptionally weird.'
  prefs: []
  type: TYPE_NORMAL
- en: If we can make our video games a little bit more like the real world, our players
    can become more immersed. Our zombie game would have been a lot more fun if the
    player could have heard them faintly in the distance and their inhuman wailing
    grew louder as they drew closer, from one direction or another.
  prefs: []
  type: TYPE_NORMAL
- en: It is probably obvious that the mathematics of spatialization will be complex.
    How do we calculate how loud a given sound will be in a specific speaker based
    on the distance and direction from the player (the hearer of the sound) to the
    object that is making the sound (the emitter)?
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, SFML does all the complicated processes for us. All we need to
    do is get familiar with a few technical terms and then we can start using SFML
    to spatialize our sound effects.
  prefs: []
  type: TYPE_NORMAL
- en: Emitters, attenuation, and listeners
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will need to be aware of a few pieces of information in order to give SFML
    what it needs to do its work. We will need to be aware of where the sound is coming
    from in our game world. This source of the sound is called an **emitter**. In
    a game, the emitter could be a zombie, a vehicle, or in the case of our current
    project, a fire tile. We have already been keeping track of the position of the
    objects in our game, so giving SFML the emitter's location will be quite straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: The next factor we need to be aware of is **attenuation**. Attenuation is the
    rate at which a wave deteriorates. You could simplify that statement and make
    it specific to sound and say that attenuation is how quickly the sound reduces
    in volume. It isn't technically accurate, but it is a good enough description
    for the purposes of this chapter and our game.
  prefs: []
  type: TYPE_NORMAL
- en: The final factor that we need to consider is the **listener**. When SFML spatializes
    the sound, where is it spatializing it relative to; where are the "ears" of the
    game.? In most games, the logical thing to do is use the player character. In
    our game, we will use Thomas (our player character).
  prefs: []
  type: TYPE_NORMAL
- en: Handling spatialization using SFML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SFML has several functions that allow us to handle emitters, attenuation, and
    listeners. Let's take a look at them hypothetically and then we will write some
    code to add spatialized sound to our project for real.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can set up a sound effect ready to be played, as we have done so often already,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can set the position of the emitter using the `setPosition` function shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As suggested in the comments of the previous code, how exactly we can obtain
    the coordinates of the emitter will probably be dependent on the type of game.
    As shown in the previous code, this would be quite simple in the Zombie Arena
    project. We will have a few challenges to overcome when we set the position in
    this project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can set the attenuation level as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The actual attenuation level can be a little ambiguous. The effect that we want
    the player to get might be different from the accurate scientific formula that
    is used to reduce the volume over distance based on attenuation. Getting the right
    attenuation level is usually achieved by experimenting. The higher the level of
    attenuation, the quicker the sound level reduces to silence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we might want to set a zone around the emitter where the volume is not
    attenuated at all. We might do this if the feature isn''t appropriate beyond a
    certain range or if we have many sound sources and don''t won''t to "overdo" the
    feature. To do so, we can use the `setMinimumDistance` function as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With the previous line of code, attenuation would not Â be calculated until the
    listener is 150 pixels/units away from the emitter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some other useful functions from the SFML library include the `setLoop` function.
    This function will tell SFML to keep playing the sound over and over when `true`
    is passed in as a parameter, like in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The sound would continue to play until we end it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'From time to time, we would want to know the status of a sound (playing or
    stopped). We can achieve this with the `getStatus` function, as demonstrated in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'There is just one more aspect of using sound spatialization with SFML that
    we need to cover. The listener. Where is the listener? We can set the position
    of the listener with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will make all the sounds play relative to that location.
    This is just what we need for the distant roar of a fire tile or incoming zombie,
    but for regular sound effects like jumping, this is a problem. We could start
    handling an emitter for the location of the player, but SFML makes things simple
    for us. Whenever we want to play a "normal" sound, we simply call `setRelativeToListener`,
    as shown in the following code, and then play the sound in the exact same way
    we have done so far. Here is how we might play a "normal" unspatialized jump sound
    effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: All we need to do is call `Listener::setPosition` again before we play any spatialized
    sounds.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a wide repertoire of SFML sound functions, and we are ready to make
    some spatialized noise for real.
  prefs: []
  type: TYPE_NORMAL
- en: Building the SoundManager class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might recall from the previous project that all the sound code took up quite
    a few lines of code. Now, consider that, with spatialization, it's going to get
    longer still. To keep our code manageable, we will code a class to manage all
    our sound effects being played. In addition, to help us with spatialization, we
    will add a function to the `Engine` class as well, but we will discuss that when
    we come to it, later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Coding SoundManager.h
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get started by coding and examining the header file.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click `SoundManager.h`. Finally, click the `SoundManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add and examine the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing tricky in the code we just added. There are five `SoundBuffer`
    objects and eight `Sound` objects. Three of the `Sound` objects will play the
    same `SoundBuffer`. This explains the reason for the different number of `Sound`/`SoundBuffer`
    objects. We do this so that we can have multiple roaring sound effects playing,
    with different spatialized parameters, simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Note the `m_NextSound` variable, which will help us keep track of which of these
    simultaneous sounds we should use next.
  prefs: []
  type: TYPE_NORMAL
- en: There is a constructor, `SoundManager`, where we will set up all our sound effects,
    and there are five functions that will play the sound effects. Four of these functions
    simply play "normal" sound effects and their code will be simpler.
  prefs: []
  type: TYPE_NORMAL
- en: One of the functions, `playFire`, will handle the spatialized sound effects
    and will be a bit more in-depth. Notice the parameters of the `playFire` function.
    It receives a `Vector2f`, which is the location of the emitter and a second `Vector2f`,
    which is the location of the listener.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the SoundManager.cpp file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we can code the function definitions. The constructor and the `playFire`
    functions have a large amount of code, so we will look at them individually. The
    other functions are short and sweet, so we will handle them all at once.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click `SoundManager.cpp`. Finally, click the `.cpp` file for the `SoundManager`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the constructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add the following code for the include directives and the constructor to `SoundManager.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we loaded five sound files into the five `SoundBuffer`
    objects. Next, we associated the eight `Sound` objects with one of the `SoundBuffer`
    objects. Notice that `m_Fire1Sound`, `m_Fire2Sound`, and `m_Fire3Sound` are all
    going to be playing from the same `SoundBuffer`, `m_FireBuffer`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set the attenuation and minimum distance for the three fire sounds.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The values of `150` and `15`, respectively, were arrived at through experimentation.
    Once the game is running, it is advisable to experiment with these values by changing
    them around and seeing (or rather, hearing) the difference.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, for the constructor, we use the `setLoop` function on each of the fire-related
    `Sound` objects. Now, when we call `play`, they will play continuously.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the playFire function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add the `playFire` function as follows. Then, we can discuss it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is call `Listener::setPosition` and set the location of
    the listener based on the `Vector2f` that is passed in as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the code enters a `switch` block that tests the value of `m_NextSound`.
    Each of the `case` statements does the exact same thing but to either `m_Fire1Sound`,
    `m_Fire2Sound`, or `m_Fire3Sound`.
  prefs: []
  type: TYPE_NORMAL
- en: In each of the `case` blocks, we set the position of the emitter using the passed
    in parameter with the `setPosition` function. The next part of the code in each
    `case` block checks whether the sound is currently stopped, and, if it is, plays
    the sound. Soon, we will see how we arrive at the positions for the emitter and
    listener that are passed into this function.
  prefs: []
  type: TYPE_NORMAL
- en: The final part of the `playFire` function increments `m_NextSound` and ensures
    that it can only be equal to 1, 2, or 3, as required by the `switch` block.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the rest of the SoundManager functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add these four simple functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `playFallInFire`, `playFallInWater`, and `playReachGoal` functions do just
    two things. First, they each call `setRelativeToListener` so that the sound effect
    is not spatialized, making the sound effect "normal", not directional, and then
    they call `play` on the appropriate `Sound` object.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes the `SoundManager` class. Now, we can use it in the `Engine`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Adding SoundManager to the game engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the `Engine.h` file and add an instance of the new `SoundManager` class,
    as shown in the following highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we could use `m_SM` to call the various `play...` functions.
    Unfortunately, there is still a bit more work to be done in order to manage the
    locations of the emitters (fire tiles).
  prefs: []
  type: TYPE_NORMAL
- en: Populating the sound emitters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the `Engine.h` file and add a new prototype for a `populateEmitters` function
    and a new STL `vector` of `Vector2f` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `populateEmitters` function takes a `vector` of `Vector2f` objects as a
    parameter, as well as a pointer to pointer to `int` (a two-dimensional array).
    The `vector` will hold the location of each emitter in a level. The array is the
    two-dimensional array that holds the layout of a level.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the populateEmitters function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The job of the `populateEmitters` function is to scan through all the elements
    of `arrayLevel` and decide where to put the emitters. It will store its results
    in `m_FireEmitters`.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click `PopulateEmitters.cpp`. Finally, click the `populateEmitters`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code in its entirety. Be sure to study the code as you do, so that
    we can discuss it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Some of the code might appear complex at first glance. Understanding the technique
    we are using to choose where an emitter will be makes this simpler. In our levels,
    there are large blocks of fire tiles. For example, in one of the levels, there
    are more than 30 fire tiles together in a group. The code makes sure that there
    is only one emitter within a given rectangle. This rectangle is stored in `previousEmitter`
    and is 300 pixels by 300 pixels (`TILE_SIZE * 6`).
  prefs: []
  type: TYPE_NORMAL
- en: The code sets up a nested `for` loop that loops through `arrayLevel`, looking
    for fire tiles. When it finds one, it makes sure that it does not intersect with
    `previousEmitter`. Only then does it use the `pushBack` function to add another
    emitter to `vSoundEmitters`. After doing so, it also updates `previousEmitter`
    to avoid getting large clusters of sound emitters.
  prefs: []
  type: TYPE_NORMAL
- en: Let's make some noise.
  prefs: []
  type: TYPE_NORMAL
- en: Playing sounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the `LoadLevel.cpp` file and add the call to the new `populateEmitters`
    function, as highlighted in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first sound to add is the jump sound. We remember that the keyboard handling
    code is in the pure virtual functions within both the `Bob` and `Thomas` classes
    and that the `handleInput` function returns `true` when a jump has been successfully
    initiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Input.cpp` file and add the following highlighted lines of code to
    play a jump sound when Thomas or Bob successfully begins a jump:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `Update.cpp` file and add the following highlighted line of code to
    play a success sound when Thomas and Bob have simultaneously reached the goal
    for the current level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Also, within the `Update.cpp` file, we will add code to loop through the `m_FireEmitters`
    vector and decide when we need to call the `playFire` function of the `SoundManager`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look closely at the small amount of context around the new highlighted code.
    It is essential to add this code in exactly the right place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is a bit like collision detection for sound. Whenever Thomas
    strays within a 500 by 500-pixel rectangle surrounding a fire emitter, the `playFire`
    function is called, passing in the coordinates of the emitter and of Thomas. The
    `playFire` function does the rest of the work and plays a spatialized, looping
    sound effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `DetectCollisions.cpp` file, find the appropriate place, and add the
    following highlighted code. The two highlighted lines of code trigger the sound
    effect when either character falls into a water or fire tile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Playing the game will now allow you to hear all the sounds, including cool spatialization,
    when you're near a fire tile.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the HUD class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HUD is super-simple and not really anything different compared to the Zombie
    Arena project. What we will do that is different is wrap all the code up in a
    new `HUD` class. If we declare all the `Font`, `Text`, and other variables as
    members of this new class, we can then initialize them in the constructor and
    provide getter functions to all their values. This will keep the `Engine` class
    clear from loads of declarations and initializations.
  prefs: []
  type: TYPE_NORMAL
- en: Coding HUD.h
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we will code the `HUD.h` file with all the member variables and function
    declarations. Right-click `HUD.h`. Finally, click the `HUD` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `HUD.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we added one `Font` instance and three `Text` instances.
    The `Text` objects will be used to show a message prompting the user to start,
    the time remaining, and the current level number.
  prefs: []
  type: TYPE_NORMAL
- en: The public functions are more interesting. First, there is the constructor where
    most of the code will go. The constructor will initialize the `Font` and `Text`
    objects, as well as position them on the screen relative to the current screen
    resolution.
  prefs: []
  type: TYPE_NORMAL
- en: The three getter functions, `getMessage`, `getLevel`, and `getTime`, will return
    a `Text` object to the calling code so that it can draw them to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The `setLevel` and `setTime` functions will be used to update the text shown
    in `m_LevelText` and `m_TimeText`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can code all the definitions for the functions we have just declared.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the HUD.cpp file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right-click `HUD.cpp`. Finally, click the `.cpp` file for the `HUD` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the include directives and the following code. Then, we will discuss it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: First, we store the horizontal and vertical resolution in a `Vector2u` called
    `resolution`. Next, we load the font from the `fonts` directory that we added
    back in [*Chapter 14*](B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292), *Abstraction
    and Code Management â Making Better Use of OOP*.
  prefs: []
  type: TYPE_NORMAL
- en: The next four lines of code set the font, the color, the size, and the text
    of `m_StartText`. The block of code after this captures the size of the rectangle
    that wraps `m_StartText` and performs a calculation to work out how to position
    it centrally on the screen. If you want a more thorough explanation of this part
    of the code, then refer to [*Chapter 3*](B14278_03_Final_AG_ePub.xhtml#_idTextAnchor098),
    *C++ Strings and SFML Time â Player Input and HUD*.
  prefs: []
  type: TYPE_NORMAL
- en: In the final two blocks of code in the constructor, the font, text size, color,
    position, and actual text for `m_TimeText` and `m_LevelText` are set. In a moment,
    we will see that these two `Text` objects will be updatable through two setter
    functions, whenever it is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following getter and setter functions immediately underneath the code
    we have just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The first three functions in the previous code simply return the appropriate
    `Text` object, that is, `m_StartText`, `m_LevelText`, or `m_TimeText`. We will
    use these functions shortly when we draw the HUD to the screen. The final two
    functions, `setLevel` and `setTime`, use the `setString` functions to update the
    appropriate `Text` object with the value that will be passed in from the `update`
    function of the `Engine` class, every 500 frames.
  prefs: []
  type: TYPE_NORMAL
- en: With all that done, we can put the HUD class to work in our game engine.
  prefs: []
  type: TYPE_NORMAL
- en: Using the HUD class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open `Engine.h`, add an include for our new class, declare an instance of the
    new `HUD` class, and declare and initialize two new member variables that will
    keep track of how often we update the HUD. As we learned in the previous projects,
    we don't need to update the HUD every frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following highlighted code to `Engine.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add some code to the `update` function of the `Engine` class.
    Open `Update.cpp` and add the following highlighted code to update the HUD once
    every 500 frames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `m_FramesSinceLastUpdate` is incremented each frame.
    When `m_FramesSinceLastUpdate` exceeds `m_TargetFramesPerHUDUpdate`, then execution
    enters the `if` block. Inside the `if` block, we use `stringstream` objects to
    update our `Text`, like we did in the previous projects. In this project, we are
    using the `HUD` class, so we call the `setTime` and `setLevel` functions by passing
    in the current values that the `Text` objects need to be set to.
  prefs: []
  type: TYPE_NORMAL
- en: The final step in the `if` block is to set `m_FramesSinceLastUpdate` back to
    zero so it can start counting toward the next update.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, open the `Draw.cpp` file and add the following highlighted code to
    draw the HUD each frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code draws the HUD by using the getter functions from the HUD
    class. Notice that the call to draw the message that prompts the player to start
    is only used when the game is not currently playing `(!m_Playing)`.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game and play a few levels to see the time tick down and the levels
    tick up. When you get back to level 1 again, notice that you have 10% less time
    than before.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored sound spatialization. Our "Thomas Was Late"
    game is not only fully playable now, but we have added directional sound effects
    and a simple but informative HUD. We can also add new levels with ease. At this
    point, we could call it a day.
  prefs: []
  type: TYPE_NORMAL
- en: It would be nice to add a bit more sparkle. In the next chapter, we will look
    into two gaming concepts. First, we will look at particle systems, which are how
    we can handle things such as explosions or other special effects. To achieve this,
    we will need to learn a bit more C++. Due to this, the topic of multiple inheritance
    will be introduced.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we will add the final flourish to the game when we learn about OpenGL
    and the programmable graphics pipeline. We will then be able to dip our toes into
    the **GLSL** language, which allows us to write code that executes directly on
    the GPU so that we can create some special effects.
  prefs: []
  type: TYPE_NORMAL
