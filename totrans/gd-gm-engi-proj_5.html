<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Jungle Jump (Platformer)</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, you'll build a classic <em class="calibre17">platform</em>, style game in the tradition of <em class="calibre17">Super Mario Bros.</em> Platform games are a very popular genre, and understanding how they work can help you make a variety of different game styles. The physics of platformers can be deceptively complex, and you'll see how Godot's <kbd class="calibre12">KinematicBody2D</kbd> physics node has features to help you implement the character controller features you need for a satisfying experience. Take a look at the following screenshot:</p>
<div class="cdpaligncenter1"><img class="alignnone11" src="../images/00106.jpeg"/></div>
<p class="calibre2">In this project, you will learn about:</p>
<ul class="calibre10">
<li class="calibre11">Using the <kbd class="calibre12">KinematicBody2D</kbd> physics node</li>
<li class="calibre11">Combining animations and user input to produce complex character behavior</li>
<li class="calibre11">Creating an infinitely scrolling background using ParallaxLayers</li>
<li class="calibre11">Organizing your project and planning for expansion</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Project setup</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre5">Create a new project. Before you download the assets from the link that follows, you need to prepare the import settings for the game art. </span>The art assets for this project use a <em class="calibre17">pixel art</em> style, which means they look best when not filtered, which is Godot's default setting for textures. <strong class="calibre4">Filtering</strong> is a method by which the pixels of an image are smoothed. It can improve the look of some art, but not pixel-based images:</p>
<div class="cdpaligncenter1"><img class="alignnone12" src="../images/00107.jpeg"/></div>
<p class="calibre2">It's inconvenient to have to disable this for every image, so Godot allows you to customize the default import settings. Click on the <kbd class="calibre12">icon.png</kbd> file in the <span class="calibre5">FileSystem</span> dock, then click the <span class="calibre5">Impor</span>t tab next to the <span class="calibre5">Scene</span> tab on the right. This window allows you to change the import settings for the file you've selected. Uncheck the <span class="calibre5">Filter</span> property, then click <span class="calibre5">Preset</span> and choose <span class="calibre5">Set as Default for 'Texture'</span>. This way, all images will be imported with filtering disabled. Refer to the following screenshot:</p>
<div class="cdpaligncenter1"><img src="../images/00108.jpeg" class="calibre118"/></div>
<div class="packt_tip">If you've already imported images, their import settings won't be updated automatically. After changing the default, you'll have to reimport any existing images. You can select multiple files in the <span class="calibre24">FileSystem</span> dock and click the <span class="calibre24">Reimport</span> button to apply the settings to many files at once.</div>
<p class="calibre2">Now, you can download the game assets from the following link and unzip them in your project folder. Godot will import all the images with the new default settings, <a href="https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases" class="calibre9">https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases</a></p>
<p class="calibre2">Next, open <span class="calibre5">Project</span><span class="calibre5"> | </span><span class="calibre5">Project Settings</span><em class="calibre17"> </em>and under <span class="calibre5">Rendering</span>/<span class="calibre5">Quality</span>, set <span class="calibre5">Use Pixel Snap</span> to <kbd class="calibre12">On</kbd>. This will ensure that all images will be aligned properly—something that will be very important when you're designing your game's levels.</p>
<p class="calibre2">While you have the settings window open, go to the <span class="calibre5">Display</span>/<span class="calibre5">Window</span> section and change <span class="calibre5">Stretch</span>/<span class="calibre5">Mode</span> to <kbd class="calibre12">2d</kbd> and <span class="calibre5">Aspect</span> to <kbd class="calibre12">expand</kbd>. These settings will allow the user to resize the game window while preserving the image's quality. Once the project has been completed, you'll be able to see the effects of this setting.</p>
<p class="calibre2">Next, set up the collision layer names so that it will be more convenient to set up collisions between different types of objects. Go to <span class="calibre5">Layer Names</span>/<span class="calibre5">2d Physics</span> and name the first four layers like this:</p>
<div class="cdpaligncenter1"><img src="../images/00109.jpeg" class="calibre119"/></div>
<p class="calibre2">Finally, add the following actions for the player controls in the <span class="calibre5"><span class="calibre5">Input Map</span> tab </span><span class="calibre5">under </span><span class="calibre5">Project</span><span class="calibre5"> | </span><span class="calibre5">Project Settings</span>:</p>
<table border="1" class="calibre70">
<tbody class="calibre71">
<tr class="calibre72">
<td class="calibre73"><strong class="calibre1">Action Name</strong></td>
<td class="calibre73"><strong class="calibre1">Key(s)</strong></td>
</tr>
<tr class="calibre72">
<td class="calibre73">right</td>
<td class="calibre73">D, →</td>
</tr>
<tr class="calibre72">
<td class="calibre73">left</td>
<td class="calibre73">A, ←</td>
</tr>
<tr class="calibre72">
<td class="calibre73">jump</td>
<td class="calibre73">Space</td>
</tr>
<tr class="calibre72">
<td class="calibre73">crouch</td>
<td class="calibre73">S, ↓</td>
</tr>
<tr class="calibre72">
<td class="calibre73">climb</td>
<td class="calibre73">W, ↑</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Introducing kinematic bodies</h1>
                
            
            <article>
                
<p class="calibre2">A platform game requires gravity, collisions, jumping, and other physics behavior, so you might think that <kbd class="calibre12">RigidBody2D</kbd> would be the perfect choice to implement the character's movement. In practice, however, you'll find that the <em class="calibre17">realistic</em> physics of the rigid body are not desirable for a platform character. To the player, realism is less important than responsive control and an <em class="calibre17">action</em> feel. As the developer, you therefore want to have precise control over the character's movements and collision response. For this reason, a kinematic body is usually the better choice for a platform character.</p>
<p class="calibre2">The <kbd class="calibre12">KinematicBody2D</kbd> node is designed for implementing bodies that are to be controlled directly by the user or via code. These nodes detect collisions with other bodies when moving, but are not affected by global physics properties like gravity or friction. This doesn't mean that a kinematic body can't be affected by gravity and other forces, just that you must calculate those forces and their effects in code; the engine will not move a kinematic body automatically.</p>
<p class="calibre2">When moving <kbd class="calibre12">KinematicBody2D</kbd>, as with <kbd class="calibre12">RigidBody2D</kbd>, you should not set its <kbd class="calibre12">position</kbd> directly. Instead, you use either the <kbd class="calibre12">move_and_collide()</kbd> or <kbd class="calibre12">move_and_slide()</kbd> methods. These methods move the body along a given vector and instantly stop if a collision is detected with another body. After <kbd class="calibre12">KinematicBody2D</kbd> has collided, any <em class="calibre17">collision response</em> must be coded manually.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Collision response</h1>
                
            
            <article>
                
<p class="calibre2">After a collision, you may want the body to bounce, to slide along a wall, or to alter the properties of the object it hit. The way you handle collision response depends on which method you used to move the body.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">move_and_collide</h1>
                
            
            <article>
                
<p class="calibre2">When using <kbd class="calibre12">move_and_collide()</kbd>, the function returns a <kbd class="calibre12">KinematicCollision2D</kbd> object upon collision. This object contains information about the collision and the colliding body. You can use this information to determine the response. Note that the function returns <kbd class="calibre12">null</kbd> when the movement was completed successfully with no collision.</p>
<p class="calibre2">For example, if you want the body to bounce off of the colliding object, you could use the following script:</p>
<pre class="calibre18"><span>extends</span> <span>KinematicBody2D</span>

<span>var</span> <span>velocity</span> <span>=</span> <span>Vector2</span><span>(</span><span>250</span><span>,</span> <span>250</span><span>)</span>

<span>func</span> <span>_physics_process</span><span>(</span><span>delta</span><span>):</span>
    <span>var</span> <span>collide</span> <span>=</span> <span>move_and_collide</span><span>(</span><span>velocity</span> <span>*</span> <span>delta</span><span>)</span>
    <span>if</span> <span>collide</span><span>:</span>
        <span>velocity</span> <span>=</span> <span>velocity</span><span>.</span><span>bounce</span><span>(</span><span>collide</span><span>.</span><span>normal</span><span>)</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">move_and_slide</h1>
                
            
            <article>
                
<p class="calibre2">Sliding is a very common option for collision response. Imagine a player moving along walls in a top-down game or running up and down slopes in a platformer. While it's possible to code this response yourself after using <kbd class="calibre12">move_and_collide()</kbd>, <kbd class="calibre12">move_and_slide()</kbd> provides a convenient way to implement sliding movement. When using this method, the body will automatically slide along the colliding surface. In addition, sliding collisions allow you to use methods like <kbd class="calibre12">is_on_floor()</kbd> to detect the orientation of the colliding surface.</p>
<p class="calibre2">Since this project will require not just moving along the ground, but also running up and down slopes, <kbd class="calibre12">move_and_slide()</kbd> is going to play a large role in your player's movement. You'll see how it works as you build up the player object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Player scene</h1>
                
            
            <article>
                
<p class="calibre2">Open a new scene and add a <kbd class="calibre12">KinematicBody2D</kbd> object named <kbd class="calibre12">Player</kbd> as the root and save the scene (don't forget to click the <span class="calibre5">Make children unselectable</span> button). When saving the <kbd class="calibre12">Player</kbd> scene, you should also create a new folder to contain it. This will help keep your project folder organized as you add more scenes and scripts.</p>
<p class="calibre2">As you've done in other projects, you'll include all the nodes that the player character needs to function in the <kbd class="calibre12">Player</kbd> scene. For this game, that means handling collisions with various game objects, including platforms, enemies, and collectibles; displaying animations for actions, such as running or jumping; and a camera to follow the player around the level.</p>
<p class="calibre2">Scripting the various animations can quickly become unmanageable, so you'll use a <em class="calibre17">finite state machine</em> to manage and track the player's state. See <a href="part0079.html#2BASE0-5809b3bef8d2453086d97dfad17b2ee2" class="calibre9">Chapter 3</a>, <em class="calibre17">Escape the Maze</em>, to review how the simplified FSM was built. You'll follow a similar pattern for this project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Collision Layer/Mask</h1>
                
            
            <article>
                
<p class="calibre2">A body's collision layer property sets what layer(s) the body is found on. <kbd class="calibre12">Player</kbd><span class="calibre5"> </span>needs to be assigned to the player layer you named in <span class="calibre5">Project Settings</span>.</p>
<p class="calibre2">The <span class="calibre5">Collision</span>/<span class="calibre5">Mask</span> property allows you to set what types of objects the body will detect. Set the<span class="calibre5"> </span><span class="calibre5">Player</span> layer to <kbd class="calibre12">player</kbd> and its mask to <span class="calibre5">environment</span>, <span class="calibre5">enemies</span>, and <span class="calibre5">collectibles</span> (<kbd class="calibre12">1</kbd>, <kbd class="calibre12">3</kbd>, and <kbd class="calibre12">4</kbd>):</p>
<div class="cdpaligncenter1"><img src="../images/00110.jpeg" class="calibre120"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Sprite</h1>
                
            
            <article>
                
<p class="calibre2">Add a Sprite node to <kbd class="calibre12">Player</kbd>. Drag the <kbd class="calibre12">res://assets/player_sheet.png</kbd> file from the <span class="calibre5">FileSystem</span> dock and drop it in the <span class="calibre5">Texture</span> property of the <kbd class="calibre12">Sprite</kbd>. The player animation is saved in the form of a sprite sheet:</p>
<div class="cdpaligncenter1"><img src="../images/00111.jpeg" class="calibre25"/></div>
<p class="calibre2">You'll use <kbd class="calibre12">AnimationPlayer</kbd> to handle the animations, so in the <span class="calibre5">Animation</span> properties of <kbd class="calibre12">Sprite</kbd>, set <span class="calibre5">Vframes</span> to <kbd class="calibre12">1</kbd> and <span class="calibre5">Hframes</span> to <kbd class="calibre12">19</kbd>. Set <span class="calibre5">Frame</span> to <kbd class="calibre12">7</kbd> to begin, as this is the frame that shows the character standing still (it's the first frame of the <kbd class="calibre12">idle</kbd> animation):</p>
<div class="cdpaligncenter1"><img src="../images/00112.jpeg" class="calibre121"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Collision shape</h1>
                
            
            <article>
                
<p class="calibre2">As with other physics bodies, <kbd class="calibre12">KinematicBody2D</kbd> needs a shape assigned to define its collision bounds. Add a <kbd class="calibre12">CollisionShape2D</kbd> object and create a new <kbd class="calibre12">RectangleShape2D</kbd> object inside it. When sizing the rectangle, you want it to reach the bottom of the image but not be quite as wide. In general, making the collision shape a bit smaller than the image will result in a better <em class="calibre17">feel</em> when playing, avoiding the experience of hitting something that looks like it wouldn't result in a collision.</p>
<p class="calibre2">You'll also need to offset the shape a small amount to make it fit. Setting <span class="calibre5">Position</span> to <kbd class="calibre12">(0, 5)</kbd> works well. When you're done, it should look approximately like this:</p>
<div class="cdpaligncenter1"><img src="../images/00113.jpeg" class="calibre122"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Shapes</h1>
                
            
            <article>
                
<p class="calibre2">Some developers prefer a capsule shape over a rectangle shape for sidescrolling characters. A capsule is a pill-shaped collision that's rounded on both ends:</p>
<div class="cdpaligncenter1"><img src="../images/00114.jpeg" class="calibre123"/></div>
<p class="calibre2">However, while this shape might seem to <em class="calibre17">cover</em> the sprite better, it can lead to difficulties when implementing platformer-style movement. For example, when standing too near the edge of a platform, the character may slide off due to the rounded bottom, which can be very frustrating for the player.</p>
<p class="calibre2">In some cases, d<span class="calibre5">epending on the complexity of your character and its interactions with other objects, </span>you may want to add multiple shapes to the same object. You might have one shape at the character's feet to detect ground collisions, another on its body to detect damage (sometimes called a hurtbox), and yet another covering the player's front to detect contact with walls.</p>
<p class="calibre2">It's recommended that you stick to <kbd class="calibre12">RectangleShape2D</kbd>, as shown in the preceding screenshot, for this character. However, once you've finished the project, you should try changing the player's collision shape to <kbd class="calibre12">CapsuleShape2D</kbd> and observing the resulting behavior. If you like it better, feel free to use it instead.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Animations</h1>
                
            
            <article>
                
<p class="calibre2">Add an <kbd class="calibre12">AnimationPlayer</kbd> node to the <kbd class="calibre12">Player</kbd> scene. You'll use this node to change the <span class="calibre5">Frame</span> property on <kbd class="calibre12">Sprite</kbd> to display the character's animations. Start by making a new animation named <kbd class="calibre12">idle</kbd>:</p>
<div class="cdpaligncenter1"><img src="../images/00115.jpeg" class="calibre124"/></div>
<p class="calibre2">Set <span class="calibre5">Length</span> to <kbd class="calibre12">0.4</kbd> seconds and keep <span class="calibre5">Step</span> at <kbd class="calibre12">0.1</kbd> seconds. Change the <span class="calibre5">Frame</span> of <kbd class="calibre12">Sprite</kbd> to <kbd class="calibre12">7</kbd> and click the <span class="calibre5">Add keyframe</span> button next to the <span class="calibre5">Frame</span> property to create a new animation track, then press it again, noting that it automatically increments the <span class="calibre5">Frame</span> property:</p>
<div class="cdpaligncenter1"><img src="../images/00116.jpeg" class="calibre125"/></div>
<p class="calibre2">Continue pressing it until you have frames <kbd class="calibre12">7</kbd> through <kbd class="calibre12">10</kbd>. Finally, click the <span class="calibre5">Enable</span>/<span class="calibre5">Disable looping</span> button to enable looping and then press <span class="calibre5">Play</span> to view your animation. Your animation setup should look like this:</p>
<div class="cdpaligncenter1"><img src="../images/00117.jpeg" class="calibre126"/></div>
<p class="calibre2">Now you need to repeat the process for the other animations. See the following table for a list of settings:</p>
<table border="1" class="calibre70">
<tbody class="calibre71">
<tr class="calibre72">
<td class="calibre73"><strong class="calibre1">name</strong></td>
<td class="calibre73"><strong class="calibre1">length</strong></td>
<td class="calibre73"><strong class="calibre1">frames</strong></td>
<td class="calibre73"><strong class="calibre1">looping</strong></td>
</tr>
<tr class="calibre72">
<td class="calibre73"><kbd class="calibre12">idle</kbd></td>
<td class="calibre73"><kbd class="calibre12">0.4</kbd></td>
<td class="calibre73"><kbd class="calibre12">7, 8, 9 ,10</kbd></td>
<td class="calibre73">on</td>
</tr>
<tr class="calibre72">
<td class="calibre73"><kbd class="calibre12">run</kbd></td>
<td class="calibre73"><kbd class="calibre12">0.5</kbd></td>
<td class="calibre73"><kbd class="calibre12">13, 14, 15, 16, 17, 18</kbd></td>
<td class="calibre73">on</td>
</tr>
<tr class="calibre72">
<td class="calibre73"><kbd class="calibre12">hurt</kbd></td>
<td class="calibre73"><kbd class="calibre12">0.2</kbd></td>
<td class="calibre73"><kbd class="calibre12">5, 6</kbd></td>
<td class="calibre73">on</td>
</tr>
<tr class="calibre72">
<td class="calibre73"><kbd class="calibre12">jump_up</kbd></td>
<td class="calibre73"><kbd class="calibre12">0.1</kbd></td>
<td class="calibre73"><kbd class="calibre12">11</kbd></td>
<td class="calibre73">off</td>
</tr>
<tr class="calibre72">
<td class="calibre73"><kbd class="calibre12">jump_down</kbd></td>
<td class="calibre73"><kbd class="calibre12">0.1</kbd></td>
<td class="calibre73"><kbd class="calibre12">12</kbd></td>
<td class="calibre73">0ff</td>
</tr>
</tbody>
</table>
<p class="calibre2"> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Finishing up the scene tree</h1>
                
            
            <article>
                
<p class="calibre2">Add <kbd class="calibre12">Camera2D</kbd> to the <kbd class="calibre12">Player</kbd> scene. This node will keep the game window centered on the player as it moves around the level. You can also use it to zoom in on the player, since the pixel art is relatively small. Remember, since you set filtering off in the import settings, <span class="calibre5">the player's texture will remain pixelated and blocky when zoomed in.</span> </p>
<p class="calibre2">To enable the camera, click the <span class="calibre5">Current</span> property to <kbd class="calibre12">On</kbd>, then set the <span class="calibre5">Zoom</span> property to <kbd class="calibre12">(0.4, 0.4)</kbd>. Values smaller than one zoom the camera in, while larger values zoom it out. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Player states</h1>
                
            
            <article>
                
<p class="calibre2">The player character has a wide variety of behaviors, such as jumping, running, and crouching. Coding such behaviors can become very complex and hard to manage. One solution is to use Boolean variables (<kbd class="calibre12">is_jumping</kbd> or <kbd class="calibre12">is_running</kbd>, for example), but this leads to possibly confusing states (what if <kbd class="calibre12">is_crouching</kbd> and <kbd class="calibre12">is_jumping</kbd> are both <kbd class="calibre12">true</kbd>?) and quickly leads to spaghetti code.</p>
<p class="calibre2">A better solution to this problem is to use a state machine to handle the player's current state and control the transitions to other states. Finite state machines were discussed in <a href="part0079.html#2BASE0-5809b3bef8d2453086d97dfad17b2ee2" class="calibre9">Chapter 3</a>, <em class="calibre17">Escape the Maze</em>. </p>
<p class="calibre2">Here is a diagram of the player's states and the transitions between them:</p>
<div class="cdpaligncenter1"><img class="alignnone13" src="../images/00118.jpeg"/></div>
<p class="calibre2">As you can see, state machine diagrams can become quite complex, even with a relatively small number of states.</p>
<div class="packt_infobox">Note that while the spritesheet contains animations for them, the CROUCH and CLIMB animations are not included here. This is to keep the number of states manageable at the beginning of the project. Later, you'll have the opportunity to add them to the player's state machine.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Player script</h1>
                
            
            <article>
                
<p class="calibre2">Attach a new script to the <kbd class="calibre12">Player</kbd> node. Add the following code to create the player's state machine:</p>
<pre class="calibre18">extends KinematicBody2D<br class="title-page-name"/>enum {IDLE, RUN, JUMP, HURT, DEAD}<br class="title-page-name"/>var state<br class="title-page-name"/>var anim<br class="title-page-name"/>var new_anim<br class="title-page-name"/><br class="title-page-name"/>func ready():<br class="title-page-name"/>    change_state(IDLE)<br class="title-page-name"/> <br class="title-page-name"/>func change_state(new_state):<br class="title-page-name"/>    state = new_state<br class="title-page-name"/>    match state:<br class="title-page-name"/>        IDLE:<br class="title-page-name"/>            new_anim = 'idle'<br class="title-page-name"/>        RUN:<br class="title-page-name"/>            new_anim = 'run'<br class="title-page-name"/>        HURT:<br class="title-page-name"/>            new_anim = 'hurt'<br class="title-page-name"/>        JUMP:<br class="title-page-name"/>            new_anim = 'jump_up'<br class="title-page-name"/>        DEAD:<br class="title-page-name"/>            hide()<br class="title-page-name"/> <br class="title-page-name"/>func _physics_process(delta):<br class="title-page-name"/>    if new_anim != anim:<br class="title-page-name"/>        anim = new_anim<br class="title-page-name"/>        $AnimationPlayer.play(anim)</pre>
<p class="calibre2">Once again, you're using <kbd class="calibre12">enum</kbd> to list the allowed states for the system. When you want to change the player's state, you'll call <kbd class="calibre12">change_state()</kbd>, for example: <kbd class="calibre12">change_state(IDLE)</kbd>. For now, the script only changes the animation value, but you'll add more state functionality later.</p>
<p class="calibre2">You may be asking, <em class="calibre17">why not just play the animation when the state changes? Why this new_anim business?</em> This is because when you call <kbd class="calibre12">play()</kbd> on <kbd class="calibre12">AnimationPlayer</kbd>, it starts the animation from the beginning. If you did that while running, for example, you'd only see the first frame of the run animation as it restarted every frame. By using the <kbd class="calibre12">new_anim</kbd> variable, you can let the current animation continue to play smoothly until you want it to change.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Player movement</h1>
                
            
            <article>
                
<p class="calibre2">The player needs three controls—left, right, and jump. The combination of the current state plus which keys are pressed will trigger a state change if the transition is allowed by the state rules. Add the <kbd class="calibre12">get_input()</kbd> function to process the inputs and determine the result:</p>
<pre class="calibre18">extends KinematicBody2D<br class="title-page-name"/><br class="title-page-name"/>export (int) var run_speed<br class="title-page-name"/>export (int) var jump_speed<br class="title-page-name"/>export (int) var gravity<br class="title-page-name"/><br class="title-page-name"/>enum {IDLE, RUN, JUMP, HURT, DEAD}<br class="title-page-name"/>var state<br class="title-page-name"/>var anim<br class="title-page-name"/>var new_anim<br class="title-page-name"/>var velocity = Vector2()<br class="title-page-name"/><br class="title-page-name"/>func get_input():<br class="title-page-name"/>    if state == HURT:<br class="title-page-name"/>        return # don't allow movement during hurt state<br class="title-page-name"/>    var right = Input.is_action_pressed('right')<br class="title-page-name"/>    var left = Input.is_action_pressed('left')<br class="title-page-name"/>    var jump = Input.is_action_just_pressed('jump')<br class="title-page-name"/> <br class="title-page-name"/>    # movement occurs in all states<br class="title-page-name"/>    velocity.x = 0<br class="title-page-name"/>    if right:<br class="title-page-name"/>        velocity.x += run_speed<br class="title-page-name"/>        $Sprite.flip_h = false<br class="title-page-name"/>    if left:<br class="title-page-name"/>        velocity.x -= run_speed<br class="title-page-name"/>        $Sprite.flip_h = true<br class="title-page-name"/>    # only allow jumping when on the ground<br class="title-page-name"/>    if jump and is_on_floor():<br class="title-page-name"/>        change_state(JUMP)<br class="title-page-name"/>        velocity.y = jump_speed<br class="title-page-name"/>    # IDLE transitions to RUN when moving<br class="title-page-name"/>    if state == IDLE and velocity.x != 0:<br class="title-page-name"/>        change_state(RUN)<br class="title-page-name"/>    # RUN transitions to IDLE when standing still<br class="title-page-name"/>    if state == RUN and velocity.x == 0:<br class="title-page-name"/>        change_state(IDLE)<br class="title-page-name"/>    # transition to JUMP when falling off an edge<br class="title-page-name"/>    if state in [IDLE, RUN] and !is_on_floor():<br class="title-page-name"/>        change_state(JUMP)</pre>
<p class="calibre2">Note that the jump check is using <kbd class="calibre12">is_action_just_pressed()</kbd> rather than <kbd class="calibre12">is_action_pressed()</kbd>. While the latter always returns <kbd class="calibre12">true</kbd> as long as the key is held down, the former is only <kbd class="calibre12">true</kbd> in the frame after the key was pressed. This means that the player must press the jump key each time they want to jump.</p>
<p class="calibre2">Now, call this function from <kbd class="calibre12">_physics_process()</kbd>, add the pull of gravity to the player's <kbd class="calibre12">velocity</kbd>, and call the <kbd class="calibre12">move_and_slide()</kbd> method to move the body:</p>
<pre class="calibre18">func _physics_process(delta):<br class="title-page-name"/>    velocity.y += gravity * delta<br class="title-page-name"/>    get_input()<br class="title-page-name"/>    if new_anim != anim:<br class="title-page-name"/>        anim = new_anim<br class="title-page-name"/>        $AnimationPlayer.play(anim)<br class="title-page-name"/>    # move the player<br class="title-page-name"/>    velocity = move_and_slide(velocity, Vector2(0, -1))</pre>
<p class="calibre2">The second parameter of <kbd class="calibre12">move_and_slide()</kbd> is a <em class="calibre17">normal</em> vector, indicating what surface direction the engine should consider to be the ground. In physics and geometry, a <em class="calibre17">normal</em> is a vector perpendicular to a surface, defining the direction a surface is facing. Using <kbd class="calibre12">(0, -1)</kbd>, which is a vector pointing upwards, the top of a horizontal surface will be considered as ground. Refer to the following screenshot:</p>
<div class="cdpaligncenter1"><img class="alignnone14" src="../images/00119.jpeg"/></div>
<p class="calibre2">After moving with <kbd class="calibre12">move_and_slide()</kbd>, the physics engine will use this information to set the value of the <kbd class="calibre12">is_on_floor()</kbd>, <kbd class="calibre12">is_on_wall()</kbd> and <kbd class="calibre12">is_on_ceiling</kbd> methods. You can use this fact to detect when the jump ends by adding this after the move:</p>
<pre class="calibre18">    if state == JUMP and is_on_floor():<br class="title-page-name"/>        change_state(IDLE)</pre>
<p class="calibre2">Finally, the jump will look better if the animation switches from <kbd class="calibre12">jump_up</kbd> to <kbd class="calibre12">jump_down</kbd> when falling:</p>
<pre class="calibre18">    if state == JUMP and velocity.y &gt; 0:        new_anim = 'jump_down'Testing the moves</pre>
<p class="calibre2">At this point, it would be a good idea to test out the movement and make sure everything is working. You can't just run the player scene though, because the player will just start falling without a surface to stand on.</p>
<p class="calibre2">Create a new scene and add a <kbd class="calibre12">Node</kbd> called <kbd class="calibre12">Main</kbd> (later, this will become your real main scene). Add an instance of the <kbd class="calibre12">Player</kbd>, then add a <kbd class="calibre12">StaticBody2D</kbd> with a rectangular <kbd class="calibre12">CollisionShape2D</kbd>. Stretch the collision shape horizontally so that it's wide enough to walk back and forth on (like a platform) and place it below the character:</p>
<div class="cdpaligncenter1"><img src="../images/00120.jpeg" class="calibre127"/></div>
<p class="calibre2">Press <span class="calibre5">Play Scene</span> and you should see the player stop falling and run the <kbd class="calibre12">idle</kbd> animation when it hits the static body.</p>
<p class="calibre2">Before moving on, make sure that all the movement and animations are working correctly. Run and jump in all directions and check that the correct animations are playing whenever the state changes. If you find any problems, review the previous sections and make sure you didn't miss a step.</p>
<p class="calibre2">Later, once the level is complete, the player will be passed a spawn location. To handle this, add this function to the <kbd class="calibre12">Player.gd</kbd> script:</p>
<pre class="calibre18">func start(pos):<br class="title-page-name"/>    position = pos<br class="title-page-name"/>    show()<br class="title-page-name"/>    change_state(IDLE)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Player health</h1>
                
            
            <article>
                
<p class="calibre2">Eventually, the player is going to encounter danger, so you should add a damage system. The player will start with three <em class="calibre17">hearts</em> and lose one each time they are damaged. </p>
<p class="calibre2">Add the following to the top of the script:</p>
<pre class="calibre18">signal life_changed<br class="title-page-name"/>signal dead<br class="title-page-name"/><br class="title-page-name"/>var life</pre>
<p class="calibre2">The <kbd class="calibre12">life_changed</kbd> signal will be emitted whenever the value of <kbd class="calibre12">life</kbd> changes, notifying the display to update. <kbd class="calibre12">dead</kbd> will be emitted when <kbd class="calibre12">life</kbd> reaches <kbd class="calibre12">0</kbd>. Add these two lines to the <kbd class="calibre12">start()</kbd> function:</p>
<pre class="calibre18">    life = 3<br class="title-page-name"/>    emit_signal('life_changed', life)</pre>
<p class="calibre2">There are two possible ways for the player to be hurt: running into a <em class="calibre17">spike</em> object in the environment, or being hit by an enemy. In either event, the following function can be called:</p>
<pre class="calibre18">func hurt():<br class="title-page-name"/>    if state != HURT:<br class="title-page-name"/>        change_state(HURT)</pre>
<p class="calibre2">This is being nice to the player: if they're already hurt, they can't get hurt again (at least for the brief time until the <em class="calibre17">hurt</em> animation has stopped playing).</p>
<p class="calibre2">There are several things to do when the state changes to <kbd class="calibre12">HURT</kbd> in <kbd class="calibre12">change_state()</kbd>:</p>
<pre class="calibre18">HURT:<br class="title-page-name"/>    new_anim = 'hurt'<br class="title-page-name"/>    velocity.y = -200<br class="title-page-name"/>    velocity.x = -100 * sign(velocity.x)<br class="title-page-name"/>    life -= 1<br class="title-page-name"/>    emit_signal('life_changed', life)<br class="title-page-name"/>    yield(get_tree().create_timer(0.5), 'timeout')<br class="title-page-name"/>    change_state(IDLE)<br class="title-page-name"/>    if life &lt;= 0:<br class="title-page-name"/>        change_state(DEAD)<br class="title-page-name"/>DEAD:<br class="title-page-name"/>    emit_signal('dead')<br class="title-page-name"/>    hide()</pre>
<p class="calibre2">Not only does does the player lose a life, but they are also bounced up and away from the damaging object. After a short time, the state changes back to <kbd class="calibre12">IDLE</kbd>.</p>
<p class="calibre2">Also, input will be disabled while the player is in the <kbd class="calibre12">HURT</kbd> state. Add this to the beginning of <kbd class="calibre12">get_input()</kbd>:</p>
<pre class="calibre18">if state == HURT:<br class="title-page-name"/>    return</pre>
<p class="calibre2">Now, the player is ready to take damage once the rest of the game is set up.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Collectible items</h1>
                
            
            <article>
                
<p class="calibre2">Before you start making the level, you need to create some pickups for the player to collect, since those will be part of the level as well. The <kbd class="calibre12">assets/sprites</kbd> folder contains sprite sheets for two types of collectibles: cherries and gems.</p>
<p class="calibre2">Rather than make separate scenes for each type of item, you can use a single scene and merely swap out the sprite sheet texture. Both objects will have the same behavior: animating in place and disappearing (that is, being collected) when contacted by the player. You can also add a <kbd class="calibre12">Tween</kbd> animation for the pickup (see <a href="part0022.html#KVCC0-5809b3bef8d2453086d97dfad17b2ee2" class="calibre9">Chapter 1</a>, <em class="calibre17">Introduction</em>, for an example).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Collectible scene</h1>
                
            
            <article>
                
<p class="calibre2">Start the new scene with an <kbd class="calibre12">Area2D</kbd> and name it <kbd class="calibre12">Collectible</kbd>. An area is a good choice for these objects because you want to detect when the player contacts them (using the <kbd class="calibre12">body_entered</kbd> signal), but you don't need collision response from them. In the <span class="calibre5">Inspector</span>, set the <span class="calibre5">Collision</span>/<span class="calibre5">Layer</span> to <span class="calibre5">collectibles</span> (layer 4) and the <span class="calibre5">Collision</span>/<span class="calibre5">Mask</span> to <span class="calibre5">player</span> (layer 2). This will ensure that only the <kbd class="calibre12">Player</kbd> node will be able to collect an item while the enemies will pass right through.</p>
<p class="calibre2">Add three child nodes: <kbd class="calibre12">Sprite</kbd>, <kbd class="calibre12">CollisionShape2D</kbd>, and <kbd class="calibre12">AnimationPlayer</kbd>, then drag the <kbd class="calibre12">res://assets/cherry.png</kbd> Sprite sheet into the Sprite's <span class="calibre5">Texture</span>. Set the <span class="calibre5">Vframes</span> to <kbd class="calibre12">1</kbd> and <span class="calibre5">Hframes</span> to <kbd class="calibre12">5</kbd>. Add a rectangle shape to <kbd class="calibre12">CollisionShape2D</kbd> and size it appropriately.</p>
<div class="packt_tip">As a general rule, you should size your objects' collision shapes so that they benefit the player. This means that enemy hitboxes should generally be a little smaller than the image while the hitboxes of beneficial items should be slightly oversized. This reduces player frustration and results in a better gameplay experience.</div>
<p class="calibre2">Add a new animation to <kbd class="calibre12">AnimationPlayer</kbd> (you only need one, so you can just name it <kbd class="calibre12">anim</kbd>). Set the <span class="calibre5">Length</span> to <kbd class="calibre12">1.6</kbd> seconds and the <span class="calibre5">Step</span> to <kbd class="calibre12">0.2</kbd> seconds.</p>
<p class="calibre2">Set the Sprite's <span class="calibre5">Frame</span> property to <kbd class="calibre12">0</kbd> and click the keyframe button to create the track. When you reach frame number four, start reversing the order back down to <kbd class="calibre12">1</kbd>. The full sequence of keyframes should be:</p>
<pre class="calibre18">0 → <span>1 </span><span>→ 2 → 3 → 4 → 3 → 2 → 1 </span></pre>
<p class="calibre2">Enable looping and press the <span class="calibre5">Play</span> button. Now, you have a nicely animated cherry! Drag <kbd class="calibre12">res://assets/gem.png</kbd> into the texture and check that it animates as well. Finally, click the <span class="calibre5">Autoplay on Load</span> button to ensure the animation will play automatically when the scene begins. Refer to the following screenshot:</p>
<div class="cdpaligncenter1"><img src="../images/00121.jpeg" class="calibre128"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Collectible script</h1>
                
            
            <article>
                
<p class="calibre2">The Collectible's script needs to do two things:</p>
<ul class="calibre10">
<li class="calibre11">Set the start conditions (<kbd class="calibre12">texture</kbd> and <kbd class="calibre12">position</kbd>)</li>
<li class="calibre11">Detect when the player enters the area</li>
</ul>
<p class="calibre2">For the first part, add the following code to the new script:</p>
<pre class="calibre18">extends Area2D<br class="title-page-name"/><br class="title-page-name"/>signal pickup<br class="title-page-name"/><br class="title-page-name"/>var textures = {'cherry': 'res://assets/sprites/cherry.png',<br class="title-page-name"/>                'gem': 'res://assets/sprites/gem.png'}<br class="title-page-name"/> <br class="title-page-name"/>func init(type, pos):<br class="title-page-name"/>    $Sprite.texture = load(textures[type])<br class="title-page-name"/>    position = pos</pre>
<p class="calibre2">The <kbd class="calibre12">pickup</kbd> signal will be emitted when the player collects the item. In the <kbd class="calibre12">textures</kbd> dictionary, you have a list of the item types and their corresponding texture locations. Note that you can quickly paste those file paths by right-clicking on the file in the <span class="calibre5">FileSystem</span> dock and choosing <span class="calibre5">Copy Path</span>:</p>
<div class="cdpaligncenter1"><img src="../images/00122.jpeg" class="calibre129"/></div>
<p class="calibre2">Next, you have an <kbd class="calibre12">init()</kbd> function that sets the <kbd class="calibre12">texture</kbd> and <kbd class="calibre12">position</kbd> to the given values. The level script will use this function to spawn all the collectibles that you add to your level map.</p>
<p class="calibre2">Finally, you need the object to detect when it's been picked up. Click on the <kbd class="calibre12">Area2D</kbd> and connect its <kbd class="calibre12">body_entered</kbd> signal. Add the following code to the created function:</p>
<pre class="calibre18">func _on_Collectible_body_entered(body):<br class="title-page-name"/>    emit_signal('pickup')<br class="title-page-name"/>    queue_free()</pre>
<p class="calibre2">Emitting the signal will allow the game's script to react appropriately to the item pickup. It can add to the score, increase the player's speed, or whatever other effect you want the item to apply.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Designing the level</h1>
                
            
            <article>
                
<p class="calibre2">It wouldn't be a platformer without jumps. For most readers, this section will take up the largest chunk of time. Once you start designing a level, you'll find it's a lot of fun to lay out all the pieces, creating challenging jumps, secret paths, and dangerous encounters.</p>
<p class="calibre2"><span class="calibre5">First, you'll create a generic <kbd class="calibre12">Level</kbd> scene containing all the nodes and code that is common to all levels. You can then create any number of level scenes that inherit from this master level.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">TileSet configuration</h1>
                
            
            <article>
                
<p class="calibre2">In the <kbd class="calibre12">assets</kbd> folder you downloaded at the beginning of the project is a <kbd class="calibre12">tilesets</kbd> folder. It contains three ready-made <kbd class="calibre12">TileSet</kbd> resources using the 16x16 art for the game:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">tiles_world.tres</kbd>: Ground and platform tiles</li>
<li class="calibre11"><kbd class="calibre12">tiles_items.tres</kbd>: Decorative items, foreground objects, and collectibles</li>
<li class="calibre11"><kbd class="calibre12">tiles_spikes.tres</kbd>: Danger items</li>
</ul>
<p class="calibre2">It is recommended that you use these tile sets to create the levels for this project. However, if you would rather make them yourself, the original art is in <kbd class="calibre12">res://assets/environment/layers</kbd>. See <a href="part0036.html#12AK80-5809b3bef8d2453086d97dfad17b2ee2" class="calibre9">Chapter 2</a>, <em class="calibre17">Coin Dash</em>, to review how to create a <kbd class="calibre12">TileSet</kbd> resource.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Base-level setup</h1>
                
            
            <article>
                
<p class="calibre2">Create a new scene and add a <kbd class="calibre12">Node2D</kbd> named <kbd class="calibre12">Level</kbd>. Save the scene in a new folder called <kbd class="calibre12">levels</kbd>. This is where you'll save any other levels you create, after inheriting from <kbd class="calibre12">Level.tscn</kbd>. The node hierarchy will be the same for all levels—only the layout will be different.</p>
<p class="calibre2">Next, add a <kbd class="calibre12">TileMap</kbd> and set its <span class="calibre5">Cell</span>/<span class="calibre5">Size</span> to <kbd class="calibre12">(16, 16)</kbd>, then duplicate it three times (press <em class="calibre17">Ctrl</em> + <em class="calibre17">D</em> to duplicate a node). These will be the layers of your level, holding different tiles and information about the layout. Name the four <kbd class="calibre12">TileMap</kbd> instances as follows and drag-and-drop the corresponding <kbd class="calibre12">TileSet</kbd> into the <span class="calibre5">Tile Set</span> property of each. Refer to the following table:</p>
<table border="1" class="calibre70">
<tbody class="calibre71">
<tr class="calibre72">
<td class="calibre73"><strong class="calibre1">TileMap</strong></td>
<td class="calibre73"><strong class="calibre1">Tile Set</strong></td>
</tr>
<tr class="calibre72">
<td class="calibre73"><kbd class="calibre12">World</kbd></td>
<td class="calibre73"><kbd class="calibre12"><span>tiles_world.tres</span></kbd></td>
</tr>
<tr class="calibre72">
<td class="calibre73"><kbd class="calibre12">Objects</kbd></td>
<td class="calibre73"><kbd class="calibre12"><span>tiles_items.tres</span></kbd></td>
</tr>
<tr class="calibre72">
<td class="calibre73"><kbd class="calibre12">Pickups</kbd></td>
<td class="calibre73"><kbd class="calibre12"><span>tiles_items.tres</span></kbd></td>
</tr>
<tr class="calibre72">
<td class="calibre73"><kbd class="calibre12">Danger</kbd></td>
<td class="calibre73">
<p class="calibre2"><kbd class="calibre12"><span>tiles_spikes.tres</span></kbd></p>
</td>
</tr>
</tbody>
</table>
<div class="packt_tip">It's a good idea to press the Lock button on your <kbd class="calibre51">TileMap</kbd> nodes to prevent accidentally moving them while you're working on your map.</div>
<p class="calibre2">Next, add an instance of the <kbd class="calibre12">Player</kbd> scene and a <kbd class="calibre12">Position2D</kbd> named <kbd class="calibre12">PlayerSpawn</kbd>. Click the hide button on the <kbd class="calibre12">Player</kbd>—you'll use <kbd class="calibre12">show()</kbd> in the level script to make the player appear when it starts. Your scene tree should now look like this:</p>
<div class="cdpaligncenter1"><img src="../images/00123.jpeg" class="calibre130"/></div>
<p class="calibre2">Attach a script to the <kbd class="calibre12">Level</kbd> node:</p>
<pre class="calibre18">extends Node2D<br class="title-page-name"/><br class="title-page-name"/>onready var pickups = $Pickups<br class="title-page-name"/><br class="title-page-name"/>func _ready():<br class="title-page-name"/>    pickups.hide()<br class="title-page-name"/>    $Player.start($PlayerSpawn.position)</pre>
<p class="calibre2">Later, you'll be scanning the <kbd class="calibre12">Pickups</kbd> map to spawn collectible items in the designated locations. This map layer itself shouldn't be seen, but rather than set it as hidden in the scene tree, which is easy to forget before you run the game, you can make sure it's always hidden during gameplay by doing so in <kbd class="calibre12">_ready()</kbd>. Because there will be many references to the node, storing the result of <kbd class="calibre12">$Pickups</kbd> in the <kbd class="calibre12">pickups</kbd> variable will cache the result. (Remember, <kbd class="calibre12">$NodeName</kbd> is the same as writing <kbd class="calibre12">get_node("NodeName")</kbd>.)</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Designing the first level</h1>
                
            
            <article>
                
<p class="calibre2">Now, you're ready to start drawing the level! Click <span class="calibre5">Scene</span> | <span class="calibre5">New Inherited Scene</span> and choose <kbd class="calibre12">Level.tscn</kbd>. Name the new node <kbd class="calibre12">Level01</kbd> and save it (still in the <kbd class="calibre12">levels</kbd> folder).</p>
<p class="calibre2">Start with the <kbd class="calibre12">World</kbd> map and be creative. Do you like lots of jumps, or twisty tunnels to explore? Long runs, or careful upward climbs?</p>
<p class="calibre2">Before going too far in your design, experiment with jump distance. You can change the Player's <kbd class="calibre12">jump_speed</kbd>, <kbd class="calibre12">run_speed</kbd>, and <kbd class="calibre12">gravity</kbd> properties to alter how high and how far they can jump. Set up some different gap sizes and run the scene to try them out. Don't forget to drag the <kbd class="calibre12">PlayerSpawn</kbd> node to the place you want the character to start.</p>
<p class="calibre2">For example, can the player make this jump? Take a look at the following screenshot:</p>
<div class="cdpaligncenter1"><img src="../images/00124.jpeg" class="calibre131"/></div>
<p class="calibre2">How you set the player's movement properties will have a big impact on how your level should be laid out. Make sure you're happy with your settings before spending too much time on the full design.</p>
<p class="calibre2">Once you have the <kbd class="calibre12">World</kbd> layer set up, use the <kbd class="calibre12">Objects</kbd> layer to place decorations and accents like plants, rocks, and vines.</p>
<p class="calibre2">Use the <kbd class="calibre12">Pickups</kbd> layer to mark the locations you'll spawn collectible items at. There are two kinds: gems and cherries. The tiles that spawn them are drawn with a magenta background to make them stand out. Remember, they'll be replaced at runtime by the actual items and the tiles themselves won't be seen.</p>
<p class="calibre2">Once you have your level laid out, you can limit the horizontal scrolling of the player camera to match the size of the map (plus a 5 tile buffer on each end):</p>
<pre class="calibre18">signal score_changed<br class="title-page-name"/>var score <br class="title-page-name"/><br class="title-page-name"/>func _ready():<br class="title-page-name"/>    score = 0<br class="title-page-name"/>    emit_signal('score_changed', score)<br class="title-page-name"/>    pickups.hide()<br class="title-page-name"/>    $Player.start($PlayerSpawn.position)<br class="title-page-name"/>    set_camera_limits()<br class="title-page-name"/><br class="title-page-name"/>func set_camera_limits():<br class="title-page-name"/>    var map_size = $World.get_used_rect()<br class="title-page-name"/>    var cell_size = $World.cell_size<br class="title-page-name"/>    $Player/Camera2D.limit_left = (map_size.position.x - 5) * cell_size.x<br class="title-page-name"/>    $Player/Camera2D.limit_right = (map_size.end.x + 5) * cell_size.x</pre>
<p class="calibre2">The script also needs to scan the <kbd class="calibre12">Pickups</kbd> layer and look for the item markers:</p>
<pre class="calibre18">func spawn_pickups():<br class="title-page-name"/>    for cell in pickups.get_used_cells():<br class="title-page-name"/>        var id = pickups.get_cellv(cell)<br class="title-page-name"/>        var type = pickups.tile_set.tile_get_name(id)<br class="title-page-name"/>        if type in ['gem', 'cherry']:<br class="title-page-name"/>            var c = Collectible.instance()<br class="title-page-name"/>            var pos = pickups.map_to_world(cell)<br class="title-page-name"/>            c.init(type, pos + pickups.cell_size/2)<br class="title-page-name"/>            add_child(c)<br class="title-page-name"/>            c.connect('pickup', self, '_on_Collectible_pickup')<br class="title-page-name"/><br class="title-page-name"/>func _on_Collectible_pickup():<br class="title-page-name"/>    score += 1<br class="title-page-name"/>    emit_signal('score_changed', score)<br class="title-page-name"/><br class="title-page-name"/>func _on_Player_dead():<br class="title-page-name"/>    pass</pre>
<p class="calibre2">This function uses <kbd class="calibre12">get_used_cells()</kbd> to get an array of the tiles that are in use on the <kbd class="calibre12">Pickups</kbd> map. The <kbd class="calibre12">TileMap</kbd> sets each tile's value to an <kbd class="calibre12">id</kbd> that references the individual tile object in the <kbd class="calibre12">TileSet</kbd>. You can then query the <kbd class="calibre12">TileSet</kbd> for the tile's name using <kbd class="calibre12">tile_set.tile_get_name()</kbd>. </p>
<p class="calibre2">Add <kbd class="calibre12">spawn_pickups()</kbd> to <kbd class="calibre12">_ready()</kbd> and add the following at the top of the script:</p>
<pre class="calibre18">var Collectible = preload('res://items/Collectible.tscn')</pre>
<p class="calibre2">Try running your level and you should see your gems and/or cherries appear where you placed them. Also check that they disappear when you run into them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Scrolling background</h1>
                
            
            <article>
                
<p class="calibre2">There are two background images in the <kbd class="calibre12">res://assets/environment/layers</kbd> folder: <kbd class="calibre12">back.png</kbd> and <kbd class="calibre12">middle.png</kbd>, for the far and near background, respectively. By placing these images behind the tilemap and scrolling them at different speeds relative to the camera, you can create an attractive illusion of depth in the background.</p>
<p class="calibre2">To start, add a <kbd class="calibre12">ParallaxBackground</kbd> node to the <kbd class="calibre12">Level</kbd> scene. This node works automatically along with the camera to create a scrolling effect. Drag this node to the top of the scene tree so that it will be drawn behind the rest of the nodes. Next, add a <kbd class="calibre12">ParallaxLayer</kbd> node as a child—<kbd class="calibre12">ParallaxBackground</kbd> can have any number of <kbd class="calibre12">ParallaxLayer</kbd> as children, allowing you to make many independently scrolling layers. Add a <kbd class="calibre12">Sprite</kbd> node as a child to the <kbd class="calibre12">ParallaxLayer</kbd> and drag the <kbd class="calibre12">res://assets/environment/layers/back.png</kbd> image into the <span class="calibre5">Texture</span>. Important—uncheck the box next to the <span class="calibre5">Centered</span> property of the <span class="calibre5">Sprite</span>.</p>
<p class="calibre2">The background image is a little small, so set the Sprite's <span class="calibre5">Scale</span> to <kbd class="calibre12">(1.5, 1.5)</kbd>.</p>
<p class="calibre2">On the <kbd class="calibre12">ParallaxLayer</kbd>, set the <span class="calibre5">Motion</span>/<span class="calibre5">Scale</span> to <kbd class="calibre12">(0.2, 1)</kbd>. This setting controls how fast the background scrolls in relation to the camera. By setting it to a low number, the background will only move a small amount as the player moves left and right.</p>
<p class="calibre2">Next, you want to be sure the image repeats if your level is very wide, so set <span class="calibre5">Mirroring</span> to <kbd class="calibre12">(576, 0)</kbd>. This is exactly the width of the image (<kbd class="calibre12">384</kbd> times <kbd class="calibre12">1.5</kbd>), so the image will be repeated when it has moved by that amount.</p>
<p class="calibre2">Note that this background is best for wide rather than tall levels. If you jump too high, you'll reach the top of the background image and suddenly see the grey emptiness again. You can fix this by setting the top limit of the camera. If you haven't moved it, the upper-left corner of the image will be at <kbd class="calibre12">(0, 0)</kbd>, so you can set the <span class="calibre5">Top</span> limit on the camera to <kbd class="calibre12">0</kbd>. If you've moved the <kbd class="calibre12">ParallaxLayer</kbd>, you can find the correct value by looking at the <kbd class="calibre12">y</kbd> value of the node's <span class="calibre5">Position</span>.</p>
<p class="calibre2">Now, add another <kbd class="calibre12">ParallaxLayer</kbd> (as a sibling of the first) for the middle background layer and give it a <kbd class="calibre12">Sprite</kbd> child. This time, use the <kbd class="calibre12">res://assets/environment/layers/middle.png</kbd> texture. This texture is much narrower than the cloud/sky image, so you'll need to do a little extra adjustment to make it repeat properly. This is because the <kbd class="calibre12">ParallaxBackground</kbd> needs to have images that are at least as big as the viewport area.</p>
<p class="calibre2">First, click on the texture in the <span class="calibre5">FileSystem</span> dock and select the <span class="calibre5">Import</span> tab. Change the <span class="calibre5">Repeat</span> property to <span class="calibre5">Mirrored</span>, and check <kbd class="calibre12">On</kbd> for <span class="calibre5">Mipmaps</span>. Press <span class="calibre5">Reimport</span>. Now, the texture can be repeated to fill the screen (and the parallax system will repeat it after that):</p>
<div class="cdpaligncenter1"><img src="../images/00125.jpeg" class="calibre132"/></div>
<p class="calibre2">The image's original size is <kbd class="calibre12">176x368</kbd>, and it needs to be repeated horizontally. In the <kbd class="calibre12">Sprite</kbd> properties, click <span class="calibre5">On</span> for <span class="calibre5">Region Enabled</span>. Next, set the <span class="calibre5">Rect</span> property to <kbd class="calibre12">(0, 0, 880, 368)</kbd> (880 is 176 times 5, so you should now see five repetitions of the image). Move the <kbd class="calibre12">ParallaxLayer</kbd> so that the image overlaps the bottom half of the ocean/cloud image:</p>
<p class="calibre2">Set the <kbd class="calibre12">ParallaxLayer</kbd> <span class="calibre5">Motion</span>/<span class="calibre5">Scale</span> to <kbd class="calibre12">(0.6, 1)</kbd> and the <span class="calibre5">Mirroring</span> to <kbd class="calibre12">(880, 0)</kbd>. Using a higher scale factor means this layer will scroll a little faster than the cloud layer behind it, giving a satisfying effect of depth, as shown in the following screenshot:</p>
<div class="cdpaligncenter1"><img src="../images/00126.jpeg" class="calibre133"/></div>
<p class="calibre2">Once you're sure everything is working, try adjusting the <span class="calibre5">Scale</span> value for both layers and see how it changes. For example, try a value of <kbd class="calibre12">(1.2, 1)</kbd> on the middle layer for a much different visual effect.</p>
<p class="calibre2">Your main scene's tree should now look like this:</p>
<div class="cdpaligncenter1"><img src="../images/00127.jpeg" class="calibre134"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dangerous objects</h1>
                
            
            <article>
                
<p class="calibre2">The <span class="calibre5">Danger</span> map layer is meant to hold the spike objects that will harm the player if they're touched. Try placing a few of them on your map where you can easily test running into them. Note that because of the way TileMaps work, colliding with <em class="calibre17">any</em> tile on this layer will cause damage to the player!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">About slide collisions</h1>
                
            
            <article>
                
<p class="calibre2">When a <kbd class="calibre12">KinematicBody2D</kbd> is moved with <kbd class="calibre12">move_and_slide()</kbd>, it may collide with more than one object in a given frame. For example, when running into a corner, the character may hit the wall and the floor at the same time. You can use the <kbd class="calibre12">get_slide_count()</kbd> method to find out how many collisions occurred, and then get information about each collision with <kbd class="calibre12">get_slide_collision()</kbd>.</p>
<p class="calibre2">In the case of the <kbd class="calibre12">Player</kbd>, you want to detect when a collision occurs against the Danger <kbd class="calibre12">TileMap</kbd> object. You can do this just after using <kbd class="calibre12">move_and_slide()</kbd> in <kbd class="calibre12">Player.gd</kbd>:</p>
<pre class="calibre18">    velocity = move_and_slide(velocity, Vector2(0, -1))<br class="title-page-name"/>    if state == HURT:<br class="title-page-name"/>        return<br class="title-page-name"/>    for idx in range(get_slide_count()):<br class="title-page-name"/>        var collision = get_slide_collision(idx)<br class="title-page-name"/>        if collision.collider.name == 'Danger':<br class="title-page-name"/>            hurt()</pre>
<p class="calibre2">Before checking for a collision with <kbd class="calibre12">Danger</kbd>, you can check whether the player is already in the <kbd class="calibre12">HURT</kbd> state and skip checking if it is. Next, you must use <kbd class="calibre12">get_slide_count()</kbd> to iterate through any collisions that may have occurred. For each, you can check whether the <kbd class="calibre12">collider.name</kbd> is <kbd class="calibre12">Danger</kbd>.</p>
<p class="calibre2">Run the scene and try running into one of the spike objects. Just like you wrote in the <kbd class="calibre12">hurt()</kbd> function previously, you should see the player change to the <kbd class="calibre12">HURT</kbd> state for a brief time before returning to <kbd class="calibre12">IDLE</kbd>. After three hits, the player enters the <kbd class="calibre12">DEAD</kbd> state, which currently sets the visibility to hidden.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Enemies</h1>
                
            
            <article>
                
<p class="calibre2">Currently, the map is very lonely, so it's time to add some enemies to liven things up.</p>
<p class="calibre2">There are many different behaviors you could create for an enemy. For this project, the enemy will walk along a platform in a straight line and reverse direction when hitting an obstacle.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Scene setup</h1>
                
            
            <article>
                
<p class="calibre2">Start with <kbd class="calibre12">KinematicBody2D</kbd> with three children: <kbd class="calibre12">Sprite</kbd>, <kbd class="calibre12">AnimationPlayer</kbd>, and <kbd class="calibre12">CollisionShape2D</kbd>. Save the scene as <kbd class="calibre12">Enemy.tscn</kbd> in a new folder called <kbd class="calibre12">enemies</kbd>. If you decide to add more enemy types to the game, you can save them all here.</p>
<p class="calibre2">Set the body's collision layer to <kbd class="calibre12">enemies</kbd> and its collision masks to <kbd class="calibre12">environment</kbd>, <kbd class="calibre12">player</kbd>, and <kbd class="calibre12">enemies</kbd>. It's also useful to group the enemies, so click on the <span class="calibre5">Node</span> tab and add the body to a group called <kbd class="calibre12">enemies</kbd>.</p>
<p class="calibre2">Add the <kbd class="calibre12">res://assets/opossum.png</kbd> sprite sheet to the Sprite's <span class="calibre5">Texture</span>. Set <span class="calibre5">Vframes</span> to <kbd class="calibre12">1</kbd> and <span class="calibre5">Hframes</span> to <kbd class="calibre12">6</kbd>. Add a rectangular collision shape that covers most (but not all) of the image, making sure that the bottom of the collision shape is aligned with the bottom of the image's feet:</p>
<div class="cdpaligncenter1"><img src="../images/00128.jpeg" class="calibre135"/></div>
<p class="calibre2">Add a new animation to the <kbd class="calibre12">AnimationPlayer</kbd> called <kbd class="calibre12">walk</kbd>. Set the <span class="calibre5">Length</span> to <kbd class="calibre12">0.6</kbd> seconds and the <span class="calibre5">Step</span> to <kbd class="calibre12">0.1</kbd> seconds. Turn on <span class="calibre5">Looping</span> and <span class="calibre5">Autoplay</span>.</p>
<p class="calibre2">The <kbd class="calibre12">walk</kbd> animation will have two tracks: one that sets the <span class="calibre5">Texture</span> property and one that changes the <span class="calibre5">Frame</span> property. Click the <span class="calibre5">Add keyframe</span> button next to <span class="calibre5">Texture</span> once to add the first track, then click the one next to <span class="calibre5">Frame</span> and repeat until you have frames <kbd class="calibre12">0</kbd> through <kbd class="calibre12">5</kbd>. Press <span class="calibre5">Play</span> and verify that the walk animation is playing correctly. The <span class="calibre5">Animation</span> panel should look like this:</p>
<div class="cdpaligncenter1"><img src="../images/00129.jpeg" class="calibre136"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Script</h1>
                
            
            <article>
                
<p class="calibre2">Add the following script:</p>
<pre class="calibre18">extends KinematicBody2D<br class="title-page-name"/><br class="title-page-name"/>export (int) var speed<br class="title-page-name"/>export (int) var gravity<br class="title-page-name"/><br class="title-page-name"/>var velocity = Vector2()<br class="title-page-name"/>var facing = 1<br class="title-page-name"/><br class="title-page-name"/>func _physics_process(delta):<br class="title-page-name"/>    $Sprite.flip_h = velocity.x &gt; 0<br class="title-page-name"/>    velocity.y += gravity * delta<br class="title-page-name"/>    velocity.x = facing * speed<br class="title-page-name"/><br class="title-page-name"/>    velocity = move_and_slide(velocity, Vector2(0, -1))<br class="title-page-name"/>    for idx in range(get_slide_count()):<br class="title-page-name"/>        var collision = get_slide_collision(idx)<br class="title-page-name"/>        if collision.collider.name == 'Player':<br class="title-page-name"/>            collision.collider.hurt()<br class="title-page-name"/>        if collision.normal.x != 0:<br class="title-page-name"/>            facing = sign(collision.normal.x)<br class="title-page-name"/>            velocity.y = -100<br class="title-page-name"/><br class="title-page-name"/>    if position.y &gt; 1000:<br class="title-page-name"/>        queue_free()</pre>
<p class="calibre2">In this script, the <kbd class="calibre12">facing</kbd> variable tracks the direction of movement (<kbd class="calibre12">1</kbd> or <kbd class="calibre12">-1</kbd>). As with the player, when moving, you iterate through the slide collisions. If the colliding object is the <kbd class="calibre12">Player</kbd>, you call its <kbd class="calibre12">hurt()</kbd> function.</p>
<p class="calibre2">Next, you can check whether the colliding body's normal vector has an <kbd class="calibre12">x</kbd> component that isn't <kbd class="calibre12">0</kbd>. This means it points to the left or right (that is, it is a wall, crate, or other obstacle). The direction of the <em class="calibre17">normal</em> is used to set the new facing. Finally, giving the body a small upward velocity will make the reverse transition look more appealing.</p>
<p class="calibre2">Lastly, if, for some reason, the enemy does fall off a platform, you don't want the game to have to track it falling forever, so delete any enemy whose <em class="calibre17">y</em> coordinate becomes too big.</p>
<p class="calibre2">Set <span class="calibre5">Speed</span> to <kbd class="calibre12">50</kbd> and <span class="calibre5">Gravity</span> to <kbd class="calibre12">900</kbd> in the <span class="calibre5">Inspector</span>, and then create an <kbd class="calibre12">Enemy</kbd> in your level scene. Make sure it has an obstacle on either side, and play the scene. Check that the enemy walks back and forth between the obstacles. Try putting the player in its path and verify that the player's <kbd class="calibre12">hurt()</kbd> method is getting called.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Damaging the enemy</h1>
                
            
            <article>
                
<p class="calibre2">It's not fair if the player can't strike back, so in the tradition of Super Mario Bros., jumping on top of the enemy will defeat it.</p>
<p class="calibre2">Start by adding a new animation to the <kbd class="calibre12">AnimationPlayer</kbd> of the <kbd class="calibre12">Enemy</kbd> and name it <kbd class="calibre12">death</kbd>. Set the <span class="calibre5">Length</span> to <kbd class="calibre12">0.3</kbd> seconds and the <span class="calibre5">Step</span> to <kbd class="calibre12">0.05</kbd>. <em class="calibre17">Don't</em> turn on looping for this animation.</p>
<p class="calibre2">This animation will also set the <span class="calibre5">Texture</span> and <span class="calibre5">Frame</span>. This time, drag the <kbd class="calibre12">res://assets/enemy-death.png</kbd> image into the Sprite's <span class="calibre5">Texture</span> before adding the keyframe for that property. As before, keyframe all the <kbd class="calibre12">Frame</kbd> values from <kbd class="calibre12">0</kbd> through <kbd class="calibre12">5</kbd>. Press Play to see the death animation run.</p>
<p class="calibre2">Add the following code to the Enemy's script:</p>
<pre class="calibre18">func take_damage():<br class="title-page-name"/>    $AnimationPlayer.play('death')<br class="title-page-name"/>    $CollisionShape2D.disabled = true<br class="title-page-name"/>    set_physics_process(false)</pre>
<p class="calibre2">When the <kbd class="calibre12">Player</kbd> hits the <kbd class="calibre12">Enemy</kbd> under the right conditions, it will call <kbd class="calibre12">take_damage()</kbd>, which plays the <kbd class="calibre12">death</kbd> animation. It also disables collision and movement for the duration of the animation.</p>
<p class="calibre2">When the <kbd class="calibre12">death</kbd> animation finishes, it's OK to remove the enemy, so connect the <kbd class="calibre12">animation_finished()</kbd> signal of <kbd class="calibre12">AnimationPlayer</kbd>. This signal is called every time an animation finishes, so you need to check that it's the correct one:</p>
<pre class="calibre18">func _on_AnimationPlayer_animation_finished(anim_name):<br class="title-page-name"/>  if anim_name == 'death':<br class="title-page-name"/>    queue_free()</pre>
<p class="calibre2">To complete the process, go to the <kbd class="calibre12">Player.gd</kbd> script and add the following to the collision checks in the <kbd class="calibre12">_physics_process()</kbd> method:</p>
<pre class="calibre18">for idx in range(get_slide_count()):<br class="title-page-name"/>    var collision = get_slide_collision(idx)<br class="title-page-name"/>    if collision.collider.name == 'Danger':<br class="title-page-name"/>        hurt()<br class="title-page-name"/>    if collision.collider.is_in_group('enemies'):<br class="title-page-name"/>        var player_feet = (position + $CollisionShape2D.shape.extents).y<br class="title-page-name"/>        if player_feet &lt; collision.collider.position.y:<br class="title-page-name"/>            collision.collider.take_damage()<br class="title-page-name"/>            velocity.y = -200<br class="title-page-name"/>        else:<br class="title-page-name"/>            hurt()</pre>
<p class="calibre2">This code checks the <em class="calibre17">y</em> coordinate of the player's feet (that is, the bottom of its collision shape) against the enemy's <em class="calibre17">y</em> coordinate. If the player is higher, the enemy is hurt; otherwise, the player is.</p>
<p class="calibre2">Run the level and try jumping on the enemy to make sure all is working as expected.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">HUD</h1>
                
            
            <article>
                
<p class="calibre2">The purpose of the HUD is to display the information the player needs to know during gameplay. Collecting items will increase the player's score, so that information needs to be displayed. The player also needs to see their remaining life value, which will be displayed as a series of hearts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Scene setup</h1>
                
            
            <article>
                
<p class="calibre2">Create a new scene with a <kbd class="calibre12">MarginContainer</kbd> node. Name it <kbd class="calibre12">HUD</kbd> and save in the <kbd class="calibre12">ui</kbd> folder. Set the <span class="calibre5">Layout</span> to <span class="calibre5">Top Wide</span>. In the <span class="calibre5">Custom Constants</span> section of <span class="calibre5">Inspector</span>, set the following values:</p>
<ul class="calibre10">
<li class="calibre11"><span>Margin Right</span>: <kbd class="calibre12">50</kbd></li>
<li class="calibre11"><span>Margin Top</span>: <kbd class="calibre12">20</kbd></li>
<li class="calibre11"><span>Margin Left</span>: <kbd class="calibre12">50</kbd></li>
<li class="calibre11"><span>Margin Bottom</span>: <kbd class="calibre12">20</kbd></li>
</ul>
<p class="calibre2">Add an <kbd class="calibre12">HBoxContainer</kbd>. This node will contain all the UI elements and keep them aligned. It will have two children: </p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">Label</kbd>: <kbd class="calibre12">ScoreLabel</kbd></li>
<li class="calibre11"><kbd class="calibre12">HBoxContainer</kbd>: <kbd class="calibre12">LifeCounter</kbd></li>
</ul>
<p class="calibre2">On the <kbd class="calibre12">ScoreLabel</kbd>, set the <span class="calibre5">Text</span> property to <kbd class="calibre12">1</kbd>, and under <span class="calibre5">Size Flags</span>, set <span class="calibre5">Horizontal</span> to <span class="calibre5">Fill</span> and <span class="calibre5">Expand</span>. Add a custom <kbd class="calibre12">DynamicFont</kbd> using <kbd class="calibre12">res://assets/Kenney Thick.ttf</kbd> from the <kbd class="calibre12">assets</kbd> folder, with a font size of <kbd class="calibre12">48</kbd>. In the <span class="calibre5">Custom Colors</span> section, set the <span class="calibre5">Font Color</span> to <kbd class="calibre12">white</kbd> and the <span class="calibre5">Font Color Shadow</span> to <kbd class="calibre12">black</kbd>. Finally, under <span class="calibre5">Custom Constants</span>, set <span class="calibre5">Shadow Offset X</span>, <span class="calibre5">Shadow Offset Y</span>, and <span class="calibre5">Shadow As Outline</span> all to <kbd class="calibre12">5</kbd>. You should see a large white <span class="calibre5">1</span> with a black outline.</p>
<p class="calibre2">For the <kbd class="calibre12">LifeCounter</kbd>, add a <kbd class="calibre12">TextureRect</kbd> and name it <kbd class="calibre12">L1</kbd>. Drag <kbd class="calibre12">res://assets/heart.png</kbd> into its <span class="calibre5">Texture</span><em class="calibre17"> </em>and set <span class="calibre5">Stretch Mode</span> to <kbd class="calibre12">Keep Aspect Centered</kbd>. Click on the node and press <em class="calibre17">Ctrl</em> + <em class="calibre17">D</em> four times so that you have a row of five hearts:</p>
<div class="cdpaligncenter1"><img class="calibre137" src="../images/00130.jpeg"/></div>
<p class="calibre2">When finished, your HUD should look like this:</p>
<div class="cdpaligncenter1"><img class="calibre138" src="../images/00131.jpeg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Script</h1>
                
            
            <article>
                
<p class="calibre2">Here is the script for the <kbd class="calibre12">HUD</kbd>:</p>
<pre class="calibre18">extends MarginContainer<br class="title-page-name"/><br class="title-page-name"/>onready var life_counter = [$HBoxContainer/LifeCounter/L1,<br class="title-page-name"/>                            $HBoxContainer/LifeCounter/L2,<br class="title-page-name"/>                            $HBoxContainer/LifeCounter/L3,<br class="title-page-name"/>                            $HBoxContainer/LifeCounter/L4,<br class="title-page-name"/>                            $HBoxContainer/LifeCounter/L5]<br class="title-page-name"/><br class="title-page-name"/>func _on_Player_life_changed(value):<br class="title-page-name"/>    for heart in range(life_counter.size()):<br class="title-page-name"/>        life_counter[heart].visible = value &gt; heart<br class="title-page-name"/><br class="title-page-name"/>func _on_score_changed(value):<br class="title-page-name"/>    $HBoxContainer/ScoreLabel.text = str(value)</pre>
<p class="calibre2">First, you make an array of references to the five heart indicators. Then, in <kbd class="calibre12">_on_Player_life_changed()</kbd>, which will be called when the player gets hurt or healed, you calculate how many hearts to display by setting <kbd class="calibre12">visible</kbd> to <kbd class="calibre12">false</kbd> if the number of the heart is less than the life amount.</p>
<p class="calibre2"><kbd class="calibre12">_on_score_changed()</kbd> is similar, changing the value of the <kbd class="calibre12">ScoreLabel</kbd> when called.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Attaching the HUD</h1>
                
            
            <article>
                
<p class="calibre2">Open <kbd class="calibre12">Level.tscn</kbd> (the base-level scene, <em class="calibre17">not</em> your <kbd class="calibre12">Level01</kbd> scene) and add a <kbd class="calibre12">CanvasLayer</kbd> node. Instance the <kbd class="calibre12">HUD</kbd> scene as a child of this <kbd class="calibre12">CanvasLayer</kbd>.</p>
<p class="calibre2">Click on the <kbd class="calibre12">Player</kbd> node and connect its <kbd class="calibre12">life_changed</kbd> signal to the HUD's <kbd class="calibre12">_on_Player_life_changed()</kbd> method:</p>
<div class="cdpaligncenter1"><img src="../images/00132.jpeg" class="calibre139"/></div>
<p class="calibre2">Next, do the same with the <kbd class="calibre12">score_changed</kbd> signal of the <kbd class="calibre12">Level</kbd> node, connecting it to the HUD's <kbd class="calibre12">_on_score_changed</kbd>.</p>
<p class="calibre2"><strong class="calibre4">Alternative method: </strong>Note that if you don't want to use the scene tree to connect the signals, or if you find the signal connection window confusing, you can accomplish the same thing in code by adding these two lines to the <kbd class="calibre12">_ready()</kbd> function of <kbd class="calibre12">Level.gd</kbd>:</p>
<pre class="calibre18">$Player.connect('life_changed', $CanvasLayer/HUD,  <br class="title-page-name"/>                '_on_Player_life_changed')<br class="title-page-name"/>$Player.connect('dead', self, '_on_Player_dead')<br class="title-page-name"/>connect('score_changed', $CanvasLayer/HUD, '_on_score_changed') </pre>
<p class="calibre2">Run your level and verify that you gain points when collecting items and lose hearts when getting hurt.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Title screen</h1>
                
            
            <article>
                
<p class="calibre2">The title screen is the first scene the player will see. When the player dies, the game will return to this scene and allow you to restart.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Scene setup</h1>
                
            
            <article>
                
<p class="calibre2">Start with a <kbd class="calibre12">Control</kbd> node and set the <span class="calibre5">Layout</span> to <span class="calibre5">Full Rect</span>.</p>
<p class="calibre2">Add a <kbd class="calibre12">TextureRect</kbd>. Set its <span class="calibre5">Texture</span> to <kbd class="calibre12">res://assets/environment/layers/back.png</kbd>, <span class="calibre5">Layout</span> to <span class="calibre5">Full Rect</span>, and <span class="calibre5">Stretch Mode</span> to <span class="calibre5">Keep Aspect Covered</span>.</p>
<p class="calibre2">Add another <kbd class="calibre12">TextureRect</kbd>, this time with the <span class="calibre5">Texture</span> using <kbd class="calibre12">res://assets/environment/layers/middle.png</kbd> and the <span class="calibre5">Stretch Mode</span> set to <span class="calibre5">Tile</span>. Drag the width of the rectangle until it's wider than the screen and arrange it so it covers the bottom half of the screen.</p>
<p class="calibre2">Next, add two <kbd class="calibre12">Label</kbd> nodes (<kbd class="calibre12">Title</kbd> and <kbd class="calibre12">Message</kbd>) and set their <span class="calibre5">Custom Font</span> settings using the same options you used earlier for the score label. Set their <span class="calibre5">Tex</span>t properties to <span class="calibre5">Jungle Jump</span> and <span class="calibre5">Press Space to Play</span>, respectively. When you're finished, the screen should look like this:</p>
<div class="cdpaligncenter1"><img src="../images/00133.jpeg" class="calibre140"/></div>
<p class="calibre2">To make the title screen a bit more interesting, add an <kbd class="calibre12">AnimationPlayer</kbd> node and create a new animation. Name it <kbd class="calibre12">anim</kbd> and set it to autoplay. In this animation, you can animate the various components of the screen to make them move, appear, fade in, or any other effect you like.</p>
<p class="calibre2">Drag the <span class="calibre5">Title</span> label to a position above the top of the screen and add a keyframe. Then, drag it back (or manually type the values in <span class="calibre5">Position</span>) and set another keyframe at around <kbd class="calibre12">0.5</kbd> seconds. Feel free to add tracks that are animating the other nodes' properties.</p>
<p class="calibre2">For example, here is an animation that drops the title down, fades in the two textures, and then makes the message appear (note the names of the properties that are modified by each track):</p>
<div class="cdpaligncenter1"><img src="../images/00134.jpeg" class="calibre141"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Main scene</h1>
                
            
            <article>
                
<p class="calibre2">Delete the extra nodes you added to your temporary <kbd class="calibre12">Main.tscn</kbd> (the <kbd class="calibre12">Player</kbd> instance and the test <kbd class="calibre12">StaticBody2D</kbd>). This scene will now be responsible for loading the current level. Before it can do that, however, you need an Autoload script to track the game state: variables such as <kbd class="calibre12">current_level</kbd> and other data that needs to be carried from scene to scene.</p>
<p class="calibre2">Add a new script called <kbd class="calibre12">GameState.gd</kbd> in the Script editor and add the following code:</p>
<pre class="calibre18">extends Node<br class="title-page-name"/><br class="title-page-name"/>var num_levels = 2<br class="title-page-name"/>var current_level = 1<br class="title-page-name"/><br class="title-page-name"/>var game_scene = 'res://Main.tscn'<br class="title-page-name"/>var title_screen = 'res://ui/TitleScreen.tscn'<br class="title-page-name"/><br class="title-page-name"/>func restart():<br class="title-page-name"/>    get_tree().change_scene(title_screen)<br class="title-page-name"/><br class="title-page-name"/>func next_level():<br class="title-page-name"/>    current_level += 1<br class="title-page-name"/>    if current_level &lt;= num_levels:<br class="title-page-name"/>        get_tree().reload_current_scene()</pre>
<p class="calibre2">Note that you should set <kbd class="calibre12">num_levels</kbd> to the number of levels you've made in the <kbd class="calibre12">levels</kbd> folder. Make sure to name them consistently (<kbd class="calibre12">Level01.tscn</kbd>, <kbd class="calibre12">Level02.tscn</kbd>, and so on) and then you can automatically load the next one in the sequence.</p>
<p class="calibre2"><span class="calibre5">Add this script in the <span class="calibre5">AutoLoad</span> tab of </span><span class="calibre5">Project Settings</span>, and add this script to <kbd class="calibre12">Main</kbd>:</p>
<pre class="calibre18">extends Node<br class="title-page-name"/><br class="title-page-name"/>func _ready():<br class="title-page-name"/>    # make sure your level numbers are 2 digits ("01", etc.)<br class="title-page-name"/>    var level_num = str(GameState.current_level).pad_zeros(2)<br class="title-page-name"/>    var path = 'res://levels/Level%s.tscn' % level_num<br class="title-page-name"/>    var map = load(path).instance()<br class="title-page-name"/>    add_child(map)</pre>
<p class="calibre2">Now, whenever the <kbd class="calibre12">Main</kbd> scene is loaded, it will load the level scene corresponding to <kbd class="calibre12">GameState.current_level</kbd>.</p>
<p class="calibre2">The title screen needs to transition to the game scene, so attach this script to the <kbd class="calibre12">TitleScreen</kbd> node:</p>
<pre class="calibre18">extends Control<br class="title-page-name"/><br class="title-page-name"/>func _input(event):<br class="title-page-name"/>    if event.is_action_pressed('ui_select'):<br class="title-page-name"/>        get_tree().change_scene(GameState.game_scene)</pre>
<p class="calibre2">You can also call the restart function when the player dies by adding it to the method in <kbd class="calibre12">Level.gd</kbd>:</p>
<pre class="calibre18">func _on_Player_dead():<br class="title-page-name"/>    GameState.restart()</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Level transitions</h1>
                
            
            <article>
                
<p class="calibre2">Your levels now need a way to transition from one to the next. In the <kbd class="calibre12">res://assets/environment/layers/props.png</kbd> sprite sheet, there is an image of a door that you can use for your level's exit. Finding and walking into the door will result in the player moving to the next level.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Door scene</h1>
                
            
            <article>
                
<p class="calibre2">Make a new scene with an <kbd class="calibre12">Area2D</kbd> named <kbd class="calibre12">Door</kbd> and save it in the <kbd class="calibre12">items</kbd> folder. Add a <kbd class="calibre12">Sprite</kbd> and use the <kbd class="calibre12"><span>res://assets/environment/layers/props.png</span></kbd> sprite sheet along with the <em class="calibre17">Region</em> setting to select the door image, then attach a rectangular <kbd class="calibre12">CollisionShape2D</kbd>. This scene doesn't need a script, because you're just going to use the area's <kbd class="calibre12">body_entered</kbd> signal.</p>
<p class="calibre2">Put the door on the <kbd class="calibre12">collectibles</kbd> layer and set its mask to only scan the <kbd class="calibre12">player</kbd> layer.</p>
<p class="calibre2">Instance this door scene in your first level and put it somewhere that the player can reach. Click on the <kbd class="calibre12">Door</kbd> node and connect the <kbd class="calibre12">body_entered</kbd> signal to the <kbd class="calibre12">Level.gd</kbd> script where you can add this code:</p>
<pre class="calibre18">func _on_Door_body_entered(body):<br class="title-page-name"/>    GameState.next_level()</pre>
<p class="calibre2">Run the game and try running into the door to check that it immediately transfers to the next level.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Finishing touches</h1>
                
            
            <article>
                
<p class="calibre2">Now that you've completed the structure of the game, you can consider some additions so that you can add more game features, more visual effects, additional enemies, or other ideas you might have. In this section, there are a few suggested features—add them as-is or adjust them to your liking.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Sound effects</h1>
                
            
            <article>
                
<p class="calibre2">As with the previous projects, you can add audio effects and music to improve the gameplay experience. In the <kbd class="calibre12">res://assets/audio</kbd> folder, you'll find a number of files you can use for various game events, such as player jump, enemy hit and pickup. There are also two music files: Intro Theme for the title screen and Grasslands Theme for the level scenes.</p>
<p class="calibre2">Adding these to the game will be left to you, but here are a few tips:</p>
<ul class="calibre10">
<li class="calibre11">Make sure the sound effects have <span>Loop</span> set to <span>Off</span> while the music files have it <span>On</span> in the <span>Import</span> settings tab.</li>
<li class="calibre11">You may find it helpful to adjust the volume of individual sounds. This can be set with the <span>Volume Db</span> property. Setting a negative value will reduce the sound's volume.</li>
<li class="calibre11">You can attach music to the master <kbd class="calibre12">Level.tscn</kbd> and that music will be used for all levels (set the <kbd class="calibre12">AudioStreamPlayer</kbd> to <span>Autoplay</span>).</li>
<li class="calibre11">You an also attach separate music to individual levels if you want to set a certain mood.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Infinite falling</h1>
                
            
            <article>
                
<p class="calibre2">Depending on how you've designed your levels, it may be possible for the player to fall off the level entirely. Typically, you want to design things so that this isn't possible by using walls that are too high to jump, spikes at the bottom of pits, and so on. However, in case it does happen, add the following code to the player's <kbd class="calibre12">_physics_process()</kbd> method:</p>
<pre class="calibre18">if position.y &gt; 1000:<br class="title-page-name"/>    change_state(DEAD)</pre>
<p class="calibre2">Note that if you've designed a level that extends below a <kbd class="calibre12">y</kbd> of <kbd class="calibre12">1000</kbd>, you'll need to increase the value to prevent accidental death.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Double jump</h1>
                
            
            <article>
                
<p class="calibre2">Double-jumps are a popular platforming feature. The player gets a second, usually smaller, upwards boost if they press the jump key a second time while in the air. To implement this feature, you need to add a few things to the player script.</p>
<p class="calibre2">First, you will need two variables to track the state:</p>
<pre class="calibre18">var max_jumps = 2<br class="title-page-name"/>var jump_count = 0</pre>
<p class="calibre2">When entering the <kbd class="calibre12">JUMP</kbd> state, reset the number of jumps:</p>
<pre class="calibre18">JUMP:<br class="title-page-name"/>    new_anim = 'jump_up'<br class="title-page-name"/>    jump_count = 1</pre>
<p class="calibre2">Finally, in <kbd class="calibre12">get_input()</kbd>, allow the jump if it meets the conditions:</p>
<pre class="calibre18">if jump and state == JUMP and jump_count &lt; max_jumps:<br class="title-page-name"/>    new_anim = 'jump_up'<br class="title-page-name"/>    velocity.y = jump_speed / 1.5<br class="title-page-name"/>    jump_count += 1</pre>
<p class="calibre2">Note that this makes the second jump 2/3 the upward speed of the normal jump. You can adjust this according to your preferences.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dust particles</h1>
                
            
            <article>
                
<p class="calibre2">Dust particles at the character's feet are a low-effort effect that can add a lot of character to your player's movements. In this section, you'll add a small puff of dust to the player's feet that is emitted whenever they land on the ground. This adds a sense of weight and impact to the player's jumps.</p>
<p class="calibre2">Add a <kbd class="calibre12">Particles2D</kbd> node and name it <kbd class="calibre12">Dust</kbd>. Note the warning that a process material must be added. First, however, set the properties of the <kbd class="calibre12">Dust</kbd> node:</p>
<table border="1" class="calibre70">
<tbody class="calibre71">
<tr class="calibre72">
<td class="calibre73"><strong class="calibre1">Property</strong></td>
<td class="calibre73"><strong class="calibre1">Value</strong></td>
</tr>
<tr class="calibre72">
<td class="calibre73">Amount</td>
<td class="calibre73"><kbd class="calibre12">20</kbd></td>
</tr>
<tr class="calibre72">
<td class="calibre73">Lifetime</td>
<td class="calibre73"><kbd class="calibre12">0.45</kbd></td>
</tr>
<tr class="calibre72">
<td class="calibre73">One Shot</td>
<td class="calibre73"><kbd class="calibre12">On</kbd></td>
</tr>
<tr class="calibre72">
<td class="calibre73">Speed Scale</td>
<td class="calibre73"><kbd class="calibre12">2</kbd></td>
</tr>
<tr class="calibre72">
<td class="calibre73">Explosiveness</td>
<td class="calibre73"><kbd class="calibre12">0.7</kbd></td>
</tr>
<tr class="calibre72">
<td class="calibre73">Local Coords</td>
<td class="calibre73"><kbd class="calibre12">Off</kbd></td>
</tr>
<tr class="calibre72">
<td class="calibre73">Position</td>
<td class="calibre73"><kbd class="calibre12">(-2, 15)</kbd></td>
</tr>
<tr class="calibre72">
<td class="calibre73">Rotation</td>
<td class="calibre73">
<p class="calibre2"><kbd class="calibre12">-90</kbd></p>
</td>
</tr>
</tbody>
</table>
<p class="calibre2"> </p>
<p class="calibre2">Now, under <span class="calibre5">Process Material</span>, add a new <kbd class="calibre12">ParticlesMaterial</kbd>. Click on it and you'll see all the particle settings. Here are the ones you need for the dust effect:</p>
<table border="1" class="calibre70">
<tbody class="calibre71">
<tr class="calibre72">
<td class="calibre73"><strong class="calibre1">Particle Property</strong></td>
<td class="calibre73"><strong class="calibre1">Value</strong></td>
</tr>
<tr class="calibre72">
<td class="calibre73">Emission Shape</td>
<td class="calibre73"><kbd class="calibre12">Box</kbd></td>
</tr>
<tr class="calibre72">
<td class="calibre73">Box Extents</td>
<td class="calibre73"><kbd class="calibre12">(1, 6, 1)</kbd></td>
</tr>
<tr class="calibre72">
<td class="calibre73">Gravity</td>
<td class="calibre73"><kbd class="calibre12">(0, 0, 0)</kbd></td>
</tr>
<tr class="calibre72">
<td class="calibre73">Initial Velocity</td>
<td class="calibre73"><kbd class="calibre12">10</kbd></td>
</tr>
<tr class="calibre72">
<td class="calibre73">Velocity Random</td>
<td class="calibre73"><kbd class="calibre12">1</kbd></td>
</tr>
<tr class="calibre72">
<td class="calibre73">Scale</td>
<td class="calibre73"><kbd class="calibre12">5</kbd></td>
</tr>
<tr class="calibre72">
<td class="calibre73">Scale Random</td>
<td class="calibre73"> <kbd class="calibre12">1</kbd></td>
</tr>
</tbody>
</table>
<p class="calibre2"> </p>
<p class="calibre2">The default particle color is white, but the dust effect will look better as a tan shade. It should also fade away so that it appears to dissipate. This can be accomplished with a <kbd class="calibre12">ColorRamp</kbd>. Next to <span class="calibre5">Color Ramp</span>, click on <span class="calibre5">New GradientTexture</span>. In the <kbd class="calibre12">GradientTexture</kbd> properties, choose a new <kbd class="calibre12">Gradient</kbd>.</p>
<p class="calibre2">The <kbd class="calibre12">Gradient</kbd> has two colors: a start color on the left and an end color on the right. These are selected by the small rectangles at the ends of the gradient. Clicking on the square on the right allows you to set the color:</p>
<div class="cdpaligncenter1"><img src="../images/00135.jpeg" class="calibre142"/></div>
<p class="calibre2">Set the start color to a tan shade, and set the end color to the same color, but with the alpha value set to <kbd class="calibre12">0</kbd> (transparent). You can test how it looks by checking the <span class="calibre5">Emitting</span> box in the <span class="calibre5">Inspector</span>. Because the node is set to <span class="calibre5">One Shot</span>, there will only be one puff of particles and you have to check the box again to emit them.</p>
<p class="calibre2">Feel free to alter the properties from what is listed here. Experimenting with <kbd class="calibre12">Particles2D</kbd> settings can be great fun, and often you'll stumble on to a very nice effect just by tinkering. Once you're happy with the appearance, add the following to the Player's <kbd class="calibre12">_physics_process()</kbd> code:</p>
<pre class="calibre18">if state == JUMP and is_on_floor():<br class="title-page-name"/>    change_state(IDLE)<br class="title-page-name"/>    $Dust.emitting = true # add this line</pre>
<p class="calibre2">Run the game and every time your character lands on the ground, a small puff of dust will appear.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Crouching state</h1>
                
            
            <article>
                
<p class="calibre2">The crouching state is useful if you have enemies or projectiles that the player needs to dodge by ducking under them. The sprite sheet contains a two-frame animation for this state:</p>
<div class="cdpaligncenter1"><img src="../images/00136.jpeg" class="calibre25"/></div>
<p class="calibre2">Add a new animation called <span class="calibre5">crouch</span> to the player's <kbd class="calibre12">AnimationPlayer</kbd>. Set its <span class="calibre5">Length</span> to <kbd class="calibre12">0.2</kbd> and add a track for the <span class="calibre5">Frame</span> property that changes the value from <kbd class="calibre12">3</kbd> to <kbd class="calibre12">4</kbd>. Set the animation to loop.</p>
<p class="calibre2">In the player's script, add the new state to the <kbd class="calibre12">enum</kbd> and state change:</p>
<pre class="calibre18">enum {IDLE, RUN, JUMP, HURT, DEAD, CROUCH}</pre>
<pre class="calibre18">CROUCH:<br class="title-page-name"/>    new_anim = 'crouch'</pre>
<p class="calibre2">In the <kbd class="calibre12">get_input()</kbd> method, you need to handle the various state transitions. When on the ground, the down input should transition to <kbd class="calibre12">CROUCH</kbd>. When in <kbd class="calibre12">CROUCH</kbd>, releasing the down input should transition to <kbd class="calibre12">IDLE</kbd>. Finally, if in the <kbd class="calibre12">CROUCH</kbd> state and left or right is pressed, the state should change to <kbd class="calibre12">RUN</kbd>:</p>
<pre class="calibre18">var down = Input.is_action_pressed('crouch')<br class="title-page-name"/><br class="title-page-name"/>if down and is_on_floor():<br class="title-page-name"/>    change_state(CROUCH)<br class="title-page-name"/>if !down and state == CROUCH:<br class="title-page-name"/>    change_state(IDLE)</pre>
<p class="calibre2">You also need to change this line:</p>
<pre class="calibre18">if state == IDLE and velocity.x != 0:<br class="title-page-name"/>    change_state(RUN)</pre>
<p class="calibre2">To this:</p>
<pre class="calibre18">if state in [IDLE, CROUCH] and velocity.x != 0:<br class="title-page-name"/>    change_state(RUN)</pre>
<p class="calibre2">That's it! Run the game and try out your new animation state.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Climbing ladders</h1>
                
            
            <article>
                
<p class="calibre2">The player animation also includes frames for a <em class="calibre17">climbing</em> action, and the tileset contains ladders. Currently, the ladder tiles do nothing: in the <span class="calibre5">TileSet</span>, they do not have any collision shape assigned. That's fine, because you don't want the player to collide with the ladders; you want to be able to move up and down on them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Player code</h1>
                
            
            <article>
                
<p class="calibre2">Start by clicking on the player's <kbd class="calibre12">AnimationPlayer</kbd> and adding a new animation named <kbd class="calibre12">climb</kbd>. Its <span class="calibre5">Length</span> should be set to <kbd class="calibre12">0.4</kbd> seconds and the <span class="calibre5">Frame</span> values for the <kbd class="calibre12">Sprite</kbd> are <kbd class="calibre12">0, 1, 0, 2</kbd>. Set the animation to loop.</p>
<p class="calibre2">Now, go to <kbd class="calibre12">Player.gd</kbd> and add a new state, <kbd class="calibre12">CLIMB</kbd>, to the state enum. In addition, add two new variables to the declarations at the top:</p>
<pre class="calibre18">export (int) var climb_speed<br class="title-page-name"/>var is_on_ladder = false</pre>
<p class="calibre2"><kbd class="calibre12">is_on_ladder</kbd> will be used to tell if the player is on a ladder or not. Using this, you can decide whether the up arrow should have any effect. In the <span class="calibre5">Inspector</span>, set <span class="calibre5">Climb Speed</span> to <kbd class="calibre12">50</kbd>.</p>
<p class="calibre2">In <kbd class="calibre12">change_state()</kbd>, add a condition for the new state:</p>
<pre class="calibre18">CLIMB:<br class="title-page-name"/>    new_anim = 'climb'</pre>
<p class="calibre2">Next, in <kbd class="calibre12">_get_input()</kbd>, you need to add the <kbd class="calibre12">climb</kbd> input action and add the code to determine when to trigger the new state. Add the following:</p>
<pre class="calibre18">var climb = Input.is_action_pressed('climb')<br class="title-page-name"/><br class="title-page-name"/>if climb and state != CLIMB and is_on_ladder:<br class="title-page-name"/>    change_state(CLIMB)<br class="title-page-name"/>if state == CLIMB:<br class="title-page-name"/>    if climb:<br class="title-page-name"/>        velocity.y = -climb_speed<br class="title-page-name"/>    elif down:<br class="title-page-name"/>        velocity.y = climb_speed<br class="title-page-name"/>    else:<br class="title-page-name"/>        velocity.y = 0<br class="title-page-name"/>        $AnimationPlayer.play("climb")<br class="title-page-name"/>if state == CLIMB and not is_on_ladder:<br class="title-page-name"/>    change_state(IDLE)</pre>
<p class="calibre2">Here, you have three new conditions to check. First, if the player is not in the <kbd class="calibre12">CLIMB</kbd> state, but is on a ladder, then pressing up should start make the player start climbing. Next, if the player is climbing, then up and down should move them accordingly, but halt movement if no keys are pressed. Finally, if the player leaves the ladder while climbing, it will leave the <kbd class="calibre12">CLIMB</kbd> state. </p>
<p class="calibre2">The one remaining issue is you need gravity to stop pulling the player downwards when climbing. Add the following condition to the gravity code in <kbd class="calibre12">_physics_process()</kbd>:</p>
<pre class="calibre18">if state != CLIMB:<br class="title-page-name"/>    velocity.y += gravity * delta</pre>
<p class="calibre2">Now, the player is ready, and you can add some ladders to your level map.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Level code</h1>
                
            
            <article>
                
<p class="calibre2">Place a few ladder tiles somewhere on your map, then add a Ladder <kbd class="calibre12">Area2D</kbd> to the level scene. Give this node a <kbd class="calibre12">CollisionShape2D</kbd> with a rectangular shape. The best way to size the area is to use grid snapping. Turn this on via the menu and use <span class="calibre5">Configure Snap...</span> to set the grid step to <kbd class="calibre12">(4, 4)</kbd>:</p>
<div class="cdpaligncenter1"><img class="alignnone15" src="../images/00137.jpeg"/></div>
<p class="calibre2">Adjust the collision shape so that it covers the center portion of the ladder from top to bottom. If you make the shape fully as wide as the ladder, the player will still count as climbing even when hanging off the side. You may find that this looks a bit odd, so making the shape a bit smaller than the width of the ladder will prevent this.</p>
<p class="calibre2">Connect the <kbd class="calibre12">body_entered</kbd> and <kbd class="calibre12">body_exited</kbd> signals of the <kbd class="calibre12">Ladder</kbd> and add the following code to have them set the Player's ladder variable:</p>
<pre class="calibre18">func _on_Ladder_body_entered(body):<br class="title-page-name"/>    if body.name == "Player":<br class="title-page-name"/>        body.is_on_ladder = true<br class="title-page-name"/><br class="title-page-name"/>func _on_Ladder_body_exited(body):<br class="title-page-name"/>    if body.name == "Player":<br class="title-page-name"/>        body.is_on_ladder = false</pre>
<p class="calibre2">Now you can give it a try. You should be able to walk to the ladder and climb up and down it. Note that if you are at the top of a ladder and step onto it, you'll fall to the bottom rather than climb down (although pressing up as you fall will grab the ladder). If you prefer to automatically transition to the climbing state, you can add an additional falling check in <kbd class="calibre12">_physics_process()</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Moving platforms</h1>
                
            
            <article>
                
<p class="calibre2">Make a new scene with a <kbd class="calibre12">KinematicBody2D</kbd> root node. Add a <kbd class="calibre12">Sprite</kbd> child and use the <kbd class="calibre12">res://assets/environment/layers/tileset.png</kbd> sprite sheet as the <span class="calibre5">Texture</span> with <span class="calibre5">Region</span> enabled so you can choose one particular tile. You probably want your platform to be wider than one tile, so duplicate the <kbd class="calibre12">Sprite</kbd> as many times as you like. Turn grid snapping on so that the sprites can be aligned in a row:</p>
<div class="cdpaligncenter1"><img class="alignnone16" src="../images/00138.jpeg"/></div>
<p class="calibre2">A grid setting of <kbd class="calibre12">(8, 8)</kbd> works well for aligning the tiles. Add a rectangular <kbd class="calibre12">CollisionShape2D</kbd> that covers the image:</p>
<div class="cdpaligncenter1"><img src="../images/00139.jpeg" class="calibre143"/></div>
<p class="calibre2">Platform movement can be made very complex (following paths, changing speeds, and so on), but this example will stick with a platform that moves horizontally back and forth between two objects.</p>
<p class="calibre2">Here is the platform's script:</p>
<pre class="calibre18">extends KinematicBody2D<br class="title-page-name"/><br class="title-page-name"/>export (Vector2) var velocity<br class="title-page-name"/><br class="title-page-name"/>func _physics_process(delta):<br class="title-page-name"/>    var collision = move_and_collide(velocity * delta)<br class="title-page-name"/>    if collision:<br class="title-page-name"/>        velocity = velocity.bounce(collision.normal)</pre>
<p class="calibre2">This time, you're using <kbd class="calibre12">move_and_collide()</kbd> to move the kinematic body. This is a better choice since the platform shouldn't slide when it collides with another wall. Instead, it bounces off the colliding body. As long as your collision shapes are rectangular (as the <kbd class="calibre12">TileMap</kbd> bodies are), this method will work fine. If you have a rounded object, the bounce may send the platform off in a strange direction, in which case you should use something like the following to keep the motion horizontal:</p>
<pre class="calibre18">func _physics_process(delta):<br class="title-page-name"/>    var collision = move_and_collide(velocity * delta)<br class="title-page-name"/>    if collision:<br class="title-page-name"/>        velocity.x *= -1</pre>
<p class="calibre2">Set the <em class="calibre17">Velocity</em> in the Inspector to <kbd class="calibre12">(50, 0)</kbd>, then go to your level scene and instance one of these objects somewhere in your level. Make sure it is between two objects so that it can move back and forth between them.</p>
<p class="calibre2">Run the scene and try jumping on the moving platform. Since the Player is using <kbd class="calibre12">move_and_slide()</kbd>, they will automatically move along with the platform if you stand on it.</p>
<p class="calibre2">Add as many of these objects as you like to your level. They will even bounce off each other, so you can make chains of moving platforms that cover a large distance and require careful timing of the player's jumps.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, you learned how to use the <kbd class="calibre12">KinematicBody2D</kbd> node to create arcade-style physics. You also used the <kbd class="calibre12">AnimationPlayer</kbd> to create a variety of animations for character behavior, and made extensive use of what you learned in earlier projects to tie everything together. Hopefully, by this point, you have a good grasp of the scene system and how a Godot project is structured.</p>
<p class="calibre2"><span class="calibre5">Remember the </span><span class="calibre5">Stretch Mode</span><span class="calibre5"> and </span><span class="calibre5">Aspect</span><span class="calibre5"> properties you set in the </span><span class="calibre5">Project Settings</span><span class="calibre5"> at the beginning? Run the game and observe what happens when you resize the game window. These settings are the best for this style of game, but try changing the </span><span class="calibre5">Stretch Mode</span><span class="calibre5"> to <span class="calibre5">Viewport</span> instead, then make your game window very wide or tall. Experiment with the other settings to see the effect of the different resizing options.</span></p>
<p class="calibre2">Once again, before moving on, take a few moments to play your game and look through its various scenes and scripts to review how you built it. Review any sections of this chapter that you found particularly tricky.</p>
<p class="calibre2">In the next chapter, you'll make the jump to 3D!</p>


            </article>

            
        </section>
    </body></html>