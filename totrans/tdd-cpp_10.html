<html><head></head><body>
		<div id="_idContainer020">
			<h1 id="_idParaDest-91" class="chapter-number" lang="en-GB"><a id="_idTextAnchor096"/>10</h1>
			<h1 id="_idParaDest-92" lang="en-GB"><a id="_idTextAnchor097"/>The TDD Process in Depth</h1>
			<p lang="en-GB">We’re going to add a lot of code to the logging library in this chapter, and while that’s good, it’s not the main purpose of <span class="No-Break" lang="">the chapter.</span></p>
			<p lang="en-GB">This is a chapter about the <strong class="bold" lang="">test-driven development</strong> (<strong class="bold" lang="">TDD</strong>) process. Wasn’t <a href="B18567_03.xhtml#_idTextAnchor031"><span class="No-Break" lang=""><em class="italic" lang="">Chapter 3</em></span></a> also about the TDD process? Yes, but think of the earlier chapter as an introduction. This chapter will explore the TDD process in detail with a lot <span class="No-Break" lang="">more code.</span></p>
			<p lang="en-GB">You’ll get ideas for writing your own tests, how to figure out what’s important, and how to refactor code without rewriting tests too, and you’ll also learn when testing is too much and learn about many different types <span class="No-Break" lang="">of tests.</span></p>
			<p lang="en-GB">The basic TDD process remains <span class="No-Break" lang="">as follows:</span></p>
			<ul>
				<li lang="en-GB">To write tests first that use the software in a natural and <span class="No-Break" lang="">intuitive way</span></li>
				<li lang="en-GB">To get the code building with minimal changes even if we need to provide fake or <span class="No-Break" lang="">stubbed-out implementations</span></li>
				<li lang="en-GB">To get basic <span class="No-Break" lang="">scenarios working</span></li>
				<li lang="en-GB">To write more tests and enhance <span class="No-Break" lang="">the design</span></li>
			</ul>
			<p lang="en-GB">Along the way, we’ll add log levels, tags, and filtering to the <span class="No-Break" lang="">logging library.</span></p>
			<p lang="en-GB">Specifically, we’ll cover the following main topics in <span class="No-Break" lang="">this chapter:</span></p>
			<ul>
				<li lang="en-GB">Finding gaps in <span class="No-Break" lang="">the testing</span></li>
				<li lang="en-GB">Adding <span class="No-Break" lang="">log levels</span></li>
				<li lang="en-GB">Adding default <span class="No-Break" lang="">tag values</span></li>
				<li lang="en-GB">Exploring <span class="No-Break" lang="">filtering options</span></li>
				<li lang="en-GB">Adding new <span class="No-Break" lang="">tag types</span></li>
				<li lang="en-GB">Refactoring the tag design <span class="No-Break" lang="">with TDD</span></li>
				<li lang="en-GB">Designing tests to filter <span class="No-Break" lang="">log messages</span></li>
				<li lang="en-GB">Controlling what <span class="No-Break" lang="">gets logged</span></li>
				<li lang="en-GB">Enhancing filtering for <span class="No-Break" lang="">relative matches</span></li>
				<li lang="en-GB">When is testing <span class="No-Break" lang="">too much?</span></li>
				<li lang="en-GB">How intrusive should <span class="No-Break" lang="">tests be?</span></li>
				<li lang="en-GB">Where do integration or system tests go <span class="No-Break" lang="">in TDD?</span></li>
				<li lang="en-GB">What about other types <span class="No-Break" lang="">of tests?</span></li>
			</ul>
			<h1 id="_idParaDest-93" lang="en-GB"><a id="_idTextAnchor098"/>Technical requirements</h1>
			<p lang="en-GB">All code in this chapter uses standard C++ that builds on any modern C++ 20 or later compiler and standard library. The code uses the testing library from <em class="italic" lang="">Part 1</em> of this book, <em class="italic" lang="">Testing MVP</em>, and continues the development of a logging library started in the <span class="No-Break" lang="">previous chapter.</span></p>
			<p lang="en-GB">You can find all the code for this chapter in the following <span class="No-Break" lang="">GitHub repository:</span></p>
			<p lang="en-GB"><a href="https://github.com/PacktPublishing/Test-Driven-Development-with-CPP&#13;"><span class="No-Break" lang="">https://github.com/PacktPublishing/Test-Driven-Development-with-CPP</span></a></p>
			<h1 id="_idParaDest-94" lang="en-GB"><a id="_idTextAnchor099"/>Finding gaps in the testing</h1>
			<p lang="en-GB">We really need more tests. Right<a id="_idIndexMarker329"/> now, we only have two logging tests: one for simple log messages and the other for more complicated log messages. The two tests look <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
TEST("Simple message can be logged")
{
    std::string message = "simple ";
    message += Util::randomString();
    MereMemo::log() &lt;&lt; message &lt;&lt; " with more text.";
    bool result = Util::isTextInFile(message,     "application.log");
    CONFIRM_TRUE(result);
}
TEST("Complicated message can be logged")
{
    std::string message = "complicated ";
    message += Util::randomString();
    MereMemo::log() &lt;&lt; message
        &lt;&lt; " double=" &lt;&lt; 3.14
        &lt;&lt; " quoted=" &lt;&lt; std::quoted("in quotes");
    bool result = Util::isTextInFile(message,     "application.log");
    CONFIRM_TRUE(result);
}</pre>
			<p lang="en-GB">But is there a good way to find more tests? Let’s look at what we have so far. I like to start with simple tests. Can things <span class="No-Break" lang="">be constructed?</span></p>
			<p lang="en-GB">That’s why the two tests we have so far are in a file called <strong class="source-inline" lang="">Contruction.cpp</strong>. This is a good place to start <a id="_idIndexMarker330"/>when looking for gaps in your testing. Do you have a simple test for each thing that you can construct? Normally, these will be classes. Write a test for each constructor of each class that your <span class="No-Break" lang="">project provides.</span></p>
			<p lang="en-GB">For the logging library, we don’t have any classes yet. So instead, I created a simple test that calls the <strong class="source-inline" lang="">log</strong> function. Then, another test calls the same function in a slightly more <span class="No-Break" lang="">complicated way.</span></p>
			<p lang="en-GB">There is an argument to be made that the complicated test duplicates some of the functionality of the simple test. I think what we have so far is okay, but it is something you should be aware of to avoid having a test that does everything another test does plus a little more. As long as a simple test represents a common use case, then it’s valuable to include it, even if another test might do something similar. In general, you want tests that will capture how your code will <span class="No-Break" lang="">be used.</span></p>
			<p lang="en-GB">Other things to think about when looking for gaps in your testing can be found by looking for symmetry. If you have construction tests, maybe you should consider destruction tests. We don’t have anything like that for the logging library—at least, not yet—but it is something to consider. Another example of symmetry can be found later in this chapter. We’ll need to confirm that some text exists in a file. Why not include a similar test that makes sure some different text does <em class="italic" lang="">not</em> exist in <span class="No-Break" lang="">the file?</span></p>
			<p lang="en-GB">Major features are a good source for tests. Think about which problems your code solves and write tests that exercise each feature or capability. For each feature, create a simple or common test, and then consider adding a more complicated test, some error tests that explore what can go wrong, and some tests that explore more purposeful misuses to make sure your code handles everything as expected. You’ll even see one example in the next section where a test is added just to make sure that <span class="No-Break" lang="">it compiles.</span></p>
			<p lang="en-GB">This chapter will mostly explore tests for missing features. We’re just getting started with the logging library, so the majority of new tests will be based on new features. This is common for a new project <a id="_idIndexMarker331"/>and is a great way to let the tests drive <span class="No-Break" lang="">the development.</span></p>
			<p lang="en-GB">The next section will add a new feature by first creating tests to define <span class="No-Break" lang="">the feature.</span></p>
			<h1 id="_idParaDest-95" lang="en-GB"><a id="_idTextAnchor100"/>Adding log levels</h1>
			<p lang="en-GB">Logging libraries have a common idea of <em class="italic" lang="">log levels</em> that let you control how much information gets logged when <a id="_idIndexMarker332"/>an application is run. Let’s say you identify an error condition that needs a log message. This error should almost always be logged, but maybe there’s another place in the code where you decide that it might be useful to record what is happening. This other place is not always interesting, so it would be nice to avoid seeing those log messages all <span class="No-Break" lang="">the time.</span></p>
			<p lang="en-GB">By having different log levels, you can decide how verbose your log files become. There are a couple of big problems with this approach. The first thing is simply defining what the log levels should be and what each should mean. Common log levels include errors, warnings, general informational messages, and <span class="No-Break" lang="">debugging messages.</span></p>
			<p lang="en-GB">Errors tend to be easy to identify unless you also want to split them into normal errors and critical errors. What makes an error critical? Do you even need to tell the difference? In order to support as many different customers as possible, a lot of logging libraries provide different log levels and leave it up to the programmer to figure out what each <span class="No-Break" lang="">level means.</span></p>
			<p lang="en-GB">The logging levels end up being used primarily to control how much information gets logged, which can help reduce the size of the log files when the application is running without any problems or complaints. This is a good thing but it leads to the next big problem. When something needs further investigation, the only way to get more information is to change the logging level, rerun the application, and hope to catch the <span class="No-Break" lang="">issue again.</span></p>
			<p lang="en-GB">For large applications, changing the logging level to record more information can quickly cause so much extra information that it becomes difficult to find what you need. The additional log messages can also fill up storage drives and cause extra financial charges if the log files are sent to vendors for further processing. The debugging process is usually rushed so that the new logging level is in effect for a short period <span class="No-Break" lang="">of time.</span></p>
			<p lang="en-GB">To get around the need to change the logging level for the entire application, a common practice is to temporarily change the level that specific parts of the code use when logging information. This requires that an application be rebuilt, deployed, and then put back once the problem <span class="No-Break" lang="">is found.</span></p>
			<p lang="en-GB">How does all this discussion about logging levels help us design a logging library? We know who our target customer is: a microservice developer who will likely be working with large applications <a id="_idIndexMarker333"/>that can produce large log files. Thinking about what would help your customer the most is a great way to create <span class="No-Break" lang="">a design.</span></p>
			<p lang="en-GB">We’re going to fix the two big problems identified. First, we’re not going to define any logging levels in the logging library. There will not be any notion of an error log message versus a debug log message. This doesn’t mean that there will be no way to control how much information will get logged, just that the whole idea of using log levels is fundamentally broken. The levels themselves are too confusing, and turning them on and off leads quickly to information overload and rushed <span class="No-Break" lang="">debugging sessions.</span></p>
			<p lang="en-GB">The idea of adding extra information such as a log level to a log message is good. If we come up with a general-purpose solution that can work for log levels as well as other attached information, then we can let the user add whatever is needed and makes sense. We can provide the ability to add log levels without actually defining what those levels will be and what <span class="No-Break" lang="">they mean.</span></p>
			<p lang="en-GB">So, the first part of the solution will be a general-purpose <em class="italic" lang="">tagging</em> system. This should avoid the confusion of fixed log levels that are defined by the library. We’ll still refer to the idea of a log level, but that’s only because the idea is so common. However, our log levels will be more like log-level tags because there won’t be any idea of one log level being above or below another <span class="No-Break" lang="">log level.</span></p>
			<p lang="en-GB">The second part will need something new. The ability to control whether a message is logged or not based on the value of a log-level tag will just lead to the same problem as before. Turning a log level on will end up opening the logs everywhere and still lead to a flood of extra log messages. What we need is the ability to finely control what gets logged instead of turning extra logging on or off everywhere. We’ll need the ability to filter on more than just a <span class="No-Break" lang="">log level.</span></p>
			<p lang="en-GB">Let’s take these two ideas one at a time. What would a general tagging system look like? Let’s write a test to find out! We should create a new file called <strong class="source-inline" lang="">Tags.cpp</strong> in the <strong class="source-inline" lang="">tests</strong> folder that looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
#include "../Log.h"
#include "LogTags.h"
#include "Util.h"
#include &lt;MereTDD/Test.h&gt;
TEST("Message can be tagged in log")
{
    std::string message = "simple tag ";
    message += Util::randomString();
    MereMemo::log(error) &lt;&lt; message;
    std::string taggedMessage = " log_level=\"error\" ";
    taggedMessage += message;
    bool result = Util::isTextInFile(taggedMessage,          "application.log");
    CONFIRM_TRUE(result);
}</pre>
			<p lang="en-GB">The most important part of this test is the <strong class="source-inline" lang="">log</strong> function call. We want this to be easy to use and to quickly convey to<a id="_idIndexMarker334"/> anybody reading the code that a tag is involved. We don’t want the tag to get hidden in the message. It should stand out as different and at the same time not be awkward <span class="No-Break" lang="">to use.</span></p>
			<p lang="en-GB">The confirmation is a little more complicated. We want the output in the log file to use a <strong class="source-inline" lang="">key="value" </strong>format. This means that there is some text followed by an equals sign and then more text inside quotation marks. This format will let us easily find tags by looking for something <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
key="value"</pre>
			<p lang="en-GB">For the log level, we’ll expect the output to look <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
log_level="error"</pre>
			<p lang="en-GB">We also want to avoid mistakes such as spelling or differences in capitalization. That’s why the syntax doesn’t use a string, which could be mistyped <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
    MereMemo::log("Eror") &lt;&lt; message;</pre>
			<p lang="en-GB">By avoiding strings, we can get the compiler to help make sure that tags are consistent. Any mistake should result in a compilation error instead of a malformed tag in the <span class="No-Break" lang="">log file.</span></p>
			<p lang="en-GB">And because the solution uses a function argument, we don’t need to provide special forms of <strong class="source-inline" lang="">log</strong> such as <strong class="source-inline" lang="">logError</strong>, <strong class="source-inline" lang="">logInfo</strong>, or <strong class="source-inline" lang="">logDebug</strong>. One of our goals was to avoid defining specific logging levels in the library itself and instead come up with something that will let the user decide what the log levels will be, just like any <span class="No-Break" lang="">other tag.</span></p>
			<p lang="en-GB">This is also the reason for <a id="_idIndexMarker335"/>the extra include of <strong class="source-inline" lang="">LogTags.h</strong>, which is also a new file. This is where we will define which log levels we will use. We want the definition to be as simple as possible because the log library will not define these. The <strong class="source-inline" lang="">LogTags.h</strong> file should be placed in the <strong class="source-inline" lang="">tests</strong> folder and look <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
#ifndef MEREMEMO_TESTS_LOGTAGS_H
#define MEREMEMO_TESTS_LOGTAGS_H
#include "../Log.h"
inline MereMemo::LogLevel error("error");
inline MereMemo::LogLevel info("info");
inline MereMemo::LogLevel debug("debug");
#endif // MEREMEMO_TESTS_LOGTAGS_H</pre>
			<p lang="en-GB">Just because the logging library doesn’t define its own logging levels doesn’t mean it can’t help with this common task. We can make use of a helper class that the library will define called <strong class="source-inline" lang="">LogLevel</strong>. We include <strong class="source-inline" lang="">Log.h</strong> in order to gain access to the <strong class="source-inline" lang="">LogLevel</strong> class so that we can define instances. Each instance should have a name such as <strong class="source-inline" lang="">error</strong> that we will use when logging. The constructor also needs a string to be used in the logging output. It’s probably a good idea to use a string that matches the name of the instance. So, for example, the error instance gets an <strong class="source-inline" lang="">"</strong><span class="No-Break" lang=""><strong class="source-inline" lang="">error"</strong></span><span class="No-Break" lang=""> string.</span></p>
			<p lang="en-GB">It’s these instances that get passed to the <strong class="source-inline" lang="">log</strong> function, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
    MereMemo::log(error) &lt;&lt; message;</pre>
			<p lang="en-GB">One thing to note is the namespace of the <strong class="source-inline" lang="">LogLevel</strong> instances. Because we’re testing the logging library itself, we’ll be calling <strong class="source-inline" lang="">log</strong> from within tests. Each test body is actually part of the <strong class="source-inline" lang="">run</strong> method of a test class defined with one of the <strong class="source-inline" lang="">TEST</strong> macros. The test class itself is in an unnamed namespace. I wanted to avoid needing to specify the <strong class="source-inline" lang="">MereMemo</strong> namespace when using one of the log levels, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
    MereMemo::log(MereMemo::error) &lt;&lt; message;</pre>
			<p lang="en-GB">It’s much easier to type just <strong class="source-inline" lang="">error</strong> instead of <strong class="source-inline" lang="">MereMemo::error</strong>. So, the solution (for now) is to declare the log-level instances in the global namespace inside <strong class="source-inline" lang="">LogTags.h</strong>. I recommend<a id="_idIndexMarker336"/> that when you define your own tags for your project, you declare the tags in your project’s namespace. Something like this <span class="No-Break" lang="">would work:</span></p>
			<pre class="source-code" lang="en-GB">
#ifndef YOUR_PROJECT_LOGTAGS_H
#define YOUR_PROJECT_LOGTAGS_H
#include &lt;MereMemo/Log.h&gt;
namespace yourproject
{
inline MereMemo::LogLevel error("error");
inline MereMemo::LogLevel info("info");
inline MereMemo::LogLevel debug("debug");
} // namespace yourproject
#endif // YOUR_PROJECT_LOGTAGS_H</pre>
			<p lang="en-GB">Then, when you are writing your code in your project that is part of your own namespace, you can refer to the tags such as <strong class="source-inline" lang="">error</strong> directly without needing to specify a namespace. You can use whichever namespace you want in place of <strong class="source-inline" lang="">yourproject</strong>. You can see a good example of a project that uses both the logging library and the testing library in <a href="B18567_14.xhtml#_idTextAnchor139"><span class="No-Break" lang=""><em class="italic" lang="">Chapter 14</em></span></a>, <em class="italic" lang="">How To </em><span class="No-Break" lang=""><em class="italic" lang="">Test Services</em></span><span class="No-Break" lang="">.</span></p>
			<p lang="en-GB">Also, note that you should refer to the <strong class="source-inline" lang="">Log.h</strong> file from within your own project as a separate project and use angle brackets. This is just like what we did when we started work on the logging library and had to start referring to the unit test library include with <span class="No-Break" lang="">angle brackets.</span></p>
			<p lang="en-GB">One extra benefit of passing an instance of <strong class="source-inline" lang="">MereMemo::LogLevel</strong> to the <strong class="source-inline" lang="">log</strong> function is that we no longer need to specify the namespace to the <strong class="source-inline" lang="">log</strong> function. The compiler knows to look in namespaces that function arguments use when trying to resolve the function name. The simple act of passing <strong class="source-inline" lang="">error</strong> to the <strong class="source-inline" lang="">log</strong> function lets the compiler figure out that the <strong class="source-inline" lang="">log</strong> function is the one defined in the same namespace as the <strong class="source-inline" lang="">error</strong> instance. I actually thought about this benefit once the code was working and I could try to call <strong class="source-inline" lang="">log</strong> without a namespace. I was then able to add a test to <strong class="source-inline" lang="">Tags.cpp</strong> that looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
TEST("log needs no namespace when used with LogLevel")
{
    log(error) &lt;&lt; "no namespace";
}</pre>
			<p lang="en-GB">Here, you can see that we can call <strong class="source-inline" lang="">log</strong> directly without specifying the <strong class="source-inline" lang="">MereMemo</strong> namespace, and we can do this because the compiler knows that the <strong class="source-inline" lang="">error</strong> instance being passed is itself a member <span class="No-Break" lang="">of </span><span class="No-Break" lang=""><strong class="source-inline" lang="">MereMemo</strong></span><span class="No-Break" lang="">.</span></p>
			<p lang="en-GB">If we try to call <strong class="source-inline" lang="">log</strong> without any arguments, then we’ll need to go back to using <strong class="source-inline" lang="">MereMemo::log</strong> instead of <span class="No-Break" lang="">just </span><span class="No-Break" lang=""><strong class="source-inline" lang="">log</strong></span><span class="No-Break" lang="">.</span></p>
			<p lang="en-GB">Also, notice how this new test was identified. It’s an alternate usage that simplifies the code, and making a test helps make<a id="_idIndexMarker337"/> sure that we don’t do anything later that will break the simpler syntax. The new test has no confirmations either. That’s because the test exists just to make sure that the call to <strong class="source-inline" lang="">log</strong> without the namespace compiles. We already know that <strong class="source-inline" lang="">log</strong> can send a log message to the log file because the other test confirms this. This test doesn’t need to duplicate the confirmation. If it compiles, then it has done <span class="No-Break" lang="">its job.</span></p>
			<p lang="en-GB">The only thing we need now is a definition of the <strong class="source-inline" lang="">LogLevel</strong> class. Remember that we really want a general-purpose tagging solution and that a log level should be just one type of tag. There shouldn’t be anything special about a log level versus any other tag. We might as well define a <strong class="source-inline" lang="">Tag</strong> class too and make <strong class="source-inline" lang="">LogLevel</strong> inherit from <strong class="source-inline" lang="">Tag</strong>. Put the two new classes at the beginning of <strong class="source-inline" lang="">Log.h</strong> just inside the <strong class="source-inline" lang="">MereMemo</strong> namespace, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
class Tag
{
public:
    virtual ~Tag () = default;
    std::string key () const
    {
        return mKey;
    }
    std::string text () const
    {
        return mText;
    }
protected:
    Tag (std::string const &amp; key, std::string const &amp; value)
    : mKey(key), mText(key + "=\"" + value + "\"")
    { }
private:
    std::string mKey;
    std::string const mText;
};
class LogLevel : public Tag
{
public:
    LogLevel (std::string const &amp; text)
    : Tag("log_level", text)
    { }
};</pre>
			<p lang="en-GB">Make sure both classes are defined inside the <strong class="source-inline" lang="">MereMemo</strong> namespace. Let’s start with the <strong class="source-inline" lang="">Tag</strong> class, which should not be used directly. The <strong class="source-inline" lang="">Tag</strong> class should be a base class so that a derived class can<a id="_idIndexMarker338"/> specify the key to be used. The purpose of the <strong class="source-inline" lang="">Tag</strong> class is really just to make sure that the text output follows the <span class="No-Break" lang=""><strong class="source-inline" lang="">key="value"</strong></span><span class="No-Break" lang=""> format.</span></p>
			<p lang="en-GB">The <strong class="source-inline" lang="">LogLevel</strong> class inherits from the <strong class="source-inline" lang="">Tag</strong> class and only requires the text of the log level. The key is hardcoded to always be <strong class="source-inline" lang="">log_level</strong>, which enforces consistency. We get the consistency of the values when we declare instances of <strong class="source-inline" lang="">LogLevel</strong> with specific strings and then use the defined instances when <span class="No-Break" lang="">calling </span><span class="No-Break" lang=""><strong class="source-inline" lang="">log</strong></span><span class="No-Break" lang="">.</span></p>
			<p lang="en-GB">The logging library supports tags and even log-level tags but doesn’t define any specific log levels itself. The library also doesn’t try to order the log levels so that something such as <strong class="source-inline" lang="">error</strong> is a higher or lower level than <strong class="source-inline" lang="">debug</strong>. Everything is just a tag consisting of a key and <span class="No-Break" lang="">a value.</span></p>
			<p lang="en-GB">Now that we have the <strong class="source-inline" lang="">LogLevel</strong> and <strong class="source-inline" lang="">Tag</strong> classes, how are they used by the <strong class="source-inline" lang="">log</strong> function? We’ll first need a new overload of <strong class="source-inline" lang="">log</strong> that accepts a <strong class="source-inline" lang="">Tag</strong> parameter, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
inline std::fstream log (Tag const &amp; tag)
{
    return log(to_string(tag));
}</pre>
			<p lang="en-GB">Place this new <strong class="source-inline" lang="">log</strong> function right after the existing <strong class="source-inline" lang="">log</strong> function and still inside the <strong class="source-inline" lang="">MereMemo</strong> namespace in <strong class="source-inline" lang="">Log.h</strong>. The new <strong class="source-inline" lang="">log</strong> function will convert the tag into a string and pass the string to the existing <strong class="source-inline" lang="">log</strong> function. We’ll need to define a <strong class="source-inline" lang="">to_string</strong> function that can be placed right after the definition of the <strong class="source-inline" lang="">Tag</strong> class, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
inline std::string to_string (Tag const &amp; tag)
{
    return tag.text();
}</pre>
			<p lang="en-GB">The <strong class="source-inline" lang="">to_string</strong> function<a id="_idIndexMarker339"/> just calls the <strong class="source-inline" lang="">text</strong> method in the <strong class="source-inline" lang="">Tag</strong> class to get the string. Do we really need a function for this? Couldn’t we just call the text method directly from within the new overloaded <strong class="source-inline" lang="">log</strong> function? Yes, we could have, but it’s a common practice in C++ to provide a function called <strong class="source-inline" lang="">to_string</strong> that knows how to convert a class into <span class="No-Break" lang="">a string.</span></p>
			<p lang="en-GB">All these new functions need to be declared inline because we’re going to keep the logging library as a single include file that another project can simply include to begin logging. We want to avoid declaring functions in the <strong class="source-inline" lang="">Log.h</strong> file and then implementing them inside a <strong class="source-inline" lang="">Log.cpp</strong> file because that would require users to add <strong class="source-inline" lang="">Log.cpp</strong> to their project, or it would require that the logging library be built as a library and then linked into the project. By keeping everything in a single header file, we make it easier for other projects to use the logging library. It’s not really a library—it’s just a header file that gets included. We’ll still refer to it as the logging <span class="No-Break" lang="">library, though.</span></p>
			<p lang="en-GB">The existing <strong class="source-inline" lang="">log</strong> function needs to be modified to accept a string. It actually used to accept a string for the message to be logged until we removed that and returned a stream instead that the caller uses to specify the message along with any other information to be logged. We’re going to put a string parameter back in the <strong class="source-inline" lang="">log</strong> function and call it <strong class="source-inline" lang="">preMessage</strong>. The <strong class="source-inline" lang="">log</strong> function will still return a stream that the caller can use. The <strong class="source-inline" lang="">preMessage</strong> parameter will be used to pass the formatted tag, and the <strong class="source-inline" lang="">log</strong> function will output the <strong class="source-inline" lang="">preMessage</strong> before returning the stream for the caller to use for the other information to be logged. The modified <strong class="source-inline" lang="">log</strong> function looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
inline std::fstream log (std::string_view preMessage = "")
{
    auto const now = std::chrono::system_clock::now();
    std::time_t const tmNow =          std::chrono::system_clock::to_time_t(now);
    auto const ms = duration_cast&lt;std::chrono::milliseconds&gt;(
        now.time_since_epoch()) % 1000;
    std::fstream logFile("application.log", std::ios::app);
    logFile &lt;&lt; std::endl
        &lt;&lt; std::put_time(std::gmtime(&amp;tmNow),            "%Y-%m-%dT%H:%M:%S.")
        &lt;&lt; std::setw(3) &lt;&lt; std::setfill('0')         &lt;&lt; std::to_string(ms.count())
        &lt;&lt; " " &lt;&lt; preMessage &lt;&lt; " ";
    return logFile;
}</pre>
			<p lang="en-GB">The <strong class="source-inline" lang="">preMessage</strong> parameter has a default value so that the <strong class="source-inline" lang="">log</strong> function can still be called without a log-level <a id="_idIndexMarker340"/>tag. All the <strong class="source-inline" lang="">log</strong> function does is send a timestamp, then the <strong class="source-inline" lang="">preMessage</strong> parameter to the stream, followed by a single space, before letting the caller have access to the <span class="No-Break" lang="">returned stream.</span></p>
			<p lang="en-GB">Note that we still want the log-level tag to be separated from the timestamp with a space too. If there is no log level specified, then the output will have two spaces, which is a detail that will be <span class="No-Break" lang="">fixed soon.</span></p>
			<p lang="en-GB">We have everything we need now to log with a log level that the new tests make <span class="No-Break" lang="">use of:</span></p>
			<pre class="source-code" lang="en-GB">
    MereMemo::log(error) &lt;&lt; message;</pre>
			<p lang="en-GB">And building and running the project shows <span class="No-Break" lang="">everything passes:</span></p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">Running 1 test suites</strong>
<strong class="bold" lang="">--------------- Suite: Single Tests</strong>
<strong class="bold" lang="">------- Test: Message can be tagged in log</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: log needs no namespace when used with LogLevel</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Simple message can be logged</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Complicated message can be logged</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">-----------------------------------</strong>
<strong class="bold" lang="">Tests passed: 4</strong>
<strong class="bold" lang="">Tests failed: 0</strong></pre>
			<p lang="en-GB">And looking at a new log file shows the log levels, <span class="No-Break" lang="">as expected:</span></p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">2022-06-25T23:52:05.842 log_level="error" simple tag 7529</strong>
<strong class="bold" lang="">2022-06-25T23:52:05.844 log_level="error" no namespace</strong>
<strong class="bold" lang="">2022-06-25T23:52:05.844  simple 248 with more text.</strong>
<strong class="bold" lang="">2022-06-25T23:52:05.844  complicated 637 double=3.14 quoted="in quotes"</strong></pre>
			<p lang="en-GB">The first two entries make use of the new log level. The second one is the one we only wanted to make sure compiles. The third and fourth logs are missing a log level. That’s because they never specified a log level. We should fix this and enable some tags to have default values, which would let us add log levels without specifying a log level so that we can make sure that every log message entry has a log level. The third and fourth entries also have an extra <a id="_idIndexMarker341"/>space, which will be fixed too. The next section will add the ability to specify <span class="No-Break" lang="">default tags.</span></p>
			<p lang="en-GB">Before moving on, notice one more thing. The complicated log entry actually looks like it uses tags already. That’s because we formatted the message with a <strong class="source-inline" lang="">key="value"</strong> format. It’s common to include quotation marks around text values and to not use quotation marks around numbers. The quotation marks help define the entire value when the text has spaces inside of the value, while numbers don’t need spaces and therefore don’t need <span class="No-Break" lang="">quotation marks.</span></p>
			<p lang="en-GB">Also, note that we don’t add spaces around the equals sign. We don’t log <span class="No-Break" lang="">the following:</span></p>
			<pre class="source-code" lang="en-GB">
double = 3.14</pre>
			<p lang="en-GB">The reason we don’t log this is that the extra spaces are not needed and only make it harder to process the log output. It might be easier to read with spaces, but trying to automate the processing of log files with scripts is harder <span class="No-Break" lang="">with spaces.</span></p>
			<p lang="en-GB">Likewise, we don’t use commas between tags. So, we don’t <span class="No-Break" lang="">do this:</span></p>
			<pre class="source-code" lang="en-GB">
double=3.14, quoted="in quotes"</pre>
			<p lang="en-GB">Adding commas between tags might make it easier to read, but they are just one more thing that must be handled by code that needs to programmatically process log files. Commas are not needed, so we won’t be <span class="No-Break" lang="">using them.</span></p>
			<p lang="en-GB">Now, we can proceed to add <span class="No-Break" lang="">default tags.</span></p>
			<h1 id="_idParaDest-96" lang="en-GB"><a id="_idTextAnchor101"/>Adding default tag values</h1>
			<p lang="en-GB">The previous section identified the need to sometimes add a tag to log messages even if the tag is not given to the <strong class="source-inline" lang="">log</strong> function. We can use this to add a default log-level tag or any other default value <a id="_idIndexMarker342"/>needed for <span class="No-Break" lang="">any tag.</span></p>
			<p lang="en-GB">With this feature, we’re starting to get to the need for the logging library to support configuration. What I mean is that we want to be able to tell the logging library how to behave before we call <strong class="source-inline" lang="">log</strong>, and we want the logging library to remember <span class="No-Break" lang="">this behavior.</span></p>
			<p lang="en-GB">Most applications support logging only after the configuration is set once at the beginning of the application. This configuration setup is usually done at the beginning of the <strong class="source-inline" lang="">main</strong> function. So, let’s focus on adding some simple configuration that will let us set some default tags and then use those default tags when logging. If we encounter both a default tag and a tag with the same key used during a call to the <strong class="source-inline" lang="">log</strong> function, then we will use the tag provided in the call to <strong class="source-inline" lang="">log</strong>. In other words, the default tags will be used unless overridden in the call <span class="No-Break" lang="">to </span><span class="No-Break" lang=""><strong class="source-inline" lang="">log</strong></span><span class="No-Break" lang="">.</span></p>
			<p lang="en-GB">We’ll start with what it will take to set default tag values. This is a case where we won’t actually have a test for setting a default value inside of <strong class="source-inline" lang="">main</strong>, but we will have a test to make sure that a default value set in <strong class="source-inline" lang="">main</strong> does appear in the log output from within a test. And we might as well design the solution so that default values can be set at any time and not just from inside the <strong class="source-inline" lang="">main</strong> function. This will let us test the setting of a default value directly instead of relying <span class="No-Break" lang="">on </span><span class="No-Break" lang=""><strong class="source-inline" lang="">main</strong></span><span class="No-Break" lang="">.</span></p>
			<p lang="en-GB">Even though the following code isn’t inside of a test, we can still modify <strong class="source-inline" lang="">main</strong> first to make sure that the solution is something we like. Let’s change <strong class="source-inline" lang="">main</strong> to look <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
#include "../Log.h"
#include "LogTags.h"
#include &lt;MereTDD/Test.h&gt;
#include &lt;iostream&gt;
int main ()
{
    MereMemo::addDefaultTag(info);
    MereMemo::addDefaultTag(green);
    return MereTDD::runTests(std::cout);
}</pre>
			<p lang="en-GB">We’ll include <strong class="source-inline" lang="">Log.h</strong> so that we can get a definition of a new <strong class="source-inline" lang="">addDefaultTag</strong> function that we’ll write, and we’ll include <strong class="source-inline" lang="">LogTags.h</strong> to get access to the <strong class="source-inline" lang="">info</strong> log level and a new tag for a color. Why a color? Because when adding new tests, we want to look for simple and general use cases. We already have the <strong class="source-inline" lang="">LogLevel</strong> tag defined by the logging library, and the only thing we need to do is define specific instances with their own values. But we haven’t yet defined our own tags, and this seems like a good place to check that custom tags work too. The usage flows well, and it seems reasonable that users would want to define multiple <span class="No-Break" lang="">default tags.</span></p>
			<p lang="en-GB">It’s easy to go too far and add a bunch of new functionality that needs to be tested, but adding related scenarios such as the two default tags <strong class="source-inline" lang="">info</strong> and <strong class="source-inline" lang="">green</strong> that serve to make a test more generic is okay. At least, it’s the type of thing I would do in one step. You might want to <a id="_idIndexMarker343"/>make these two separate tests. I figure that we can add a single test that just makes sure both tags are present even if not provided to the <strong class="source-inline" lang="">log</strong> function. The fact that one tag type is provided by the logging library and the other is custom is not enough for me to require separate tests. I’ll be happy if they both appear in the <span class="No-Break" lang="">log output.</span></p>
			<p lang="en-GB">Let’s add a test now to <strong class="source-inline" lang="">Tags.cpp</strong> that looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
TEST("Default tags set in main appear in log")
{
    std::string message = "default tag ";
    message += Util::randomString();
    MereMemo::log() &lt;&lt; message;
    std::string logLevelTag = " log_level=\"info\" ";
    std::string colorTag = " color=\"green\" ";
    bool result = Util::isTextInFile(message,          "application.log",
        {logLevelTag, colorTag});
    CONFIRM_TRUE(result);
}</pre>
			<p lang="en-GB">As it turns out, I’m glad that I did add two default tags instead of just one because when writing the test, I started thinking about how to verify they both appear in the log file, and that’s when I realized that the <strong class="source-inline" lang="">isTextInFile</strong> function is too rigid for what we now need. The <strong class="source-inline" lang="">isTextInFile</strong> function worked okay when we were only interested in checking if a specific string appeared in a file, but we’re working with tags now, and the order that the tags appear in the output is not specified. The important part is that we can’t reliably create a single string that will always match the order of the tags in the output, and we definitely don’t want to start checking for all possible <span class="No-Break" lang="">tag orders.</span></p>
			<p lang="en-GB">What we want is the ability to first identify a specific line in the output. This is important because we might have many log file entries that have the same log level or the same color, but the message with the random number is more specific. Once we find a single line in the file that matches the random number, what we really want is to check that same line to make sure all the tags are present. The order within the line is <span class="No-Break" lang="">not important.</span></p>
			<p lang="en-GB">So, I changed the <strong class="source-inline" lang="">isTextInFile</strong> function to take a third parameter, which will be a collection of strings. Each <a id="_idIndexMarker344"/>of these strings will be a single tag value to check. This actually makes the test easier to understand. We can leave the message unchanged and use it as the first argument to identify the line we want to find within the log file. Assuming we find that line, we then pass individually formatted tags in the <strong class="source-inline" lang="">key="value"</strong> format as a collection of strings to verify that they each exist in the same line <span class="No-Break" lang="">found already.</span></p>
			<p lang="en-GB">Notice also that the tag strings begin and end with a single space. This makes sure that the tags are separated properly with spaces and that we also don’t have any commas at the end of a <span class="No-Break" lang="">tag value.</span></p>
			<p lang="en-GB">We should fix the other test that checks for the existence of the log level, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
TEST("Message can be tagged in log")
{
    std::string message = "simple tag ";
    message += Util::randomString();
    MereMemo::log(error) &lt;&lt; message;
    std::string logLevelTag = " log_level=\"error\" ";
    bool result = Util::isTextInFile(message,          "application.log",
        {logLevelTag});
    CONFIRM_TRUE(result);
}</pre>
			<p lang="en-GB">We no longer need to append the message to the end of a formatted log-level tag. We just pass the single <strong class="source-inline" lang="">logLevelTag</strong> instance as the single value in the collection of additional strings to check. Now that we have default tag values set in <strong class="source-inline" lang="">main</strong>, there is no guarantee of the order of the tags. So, we could have failed this test because the color tag happened to come between the error tag and the message. All we check is that the message appears in the output and that the error tag also exists somewhere in the same <span class="No-Break" lang="">log-line entry.</span></p>
			<p lang="en-GB">Let’s enhance the <strong class="source-inline" lang="">isTextInFile</strong> function now to accept a vector of strings in a third parameter. The vector should have a default value of an empty collection in case the caller just wants to verify that a file contains some simple text without also looking for additional strings on the same line. And while we’re doing this, let’s add a fourth parameter, which will<a id="_idIndexMarker345"/> also be a vector of strings. The fourth parameter will check to make sure that its strings are <em class="italic" lang="">not</em> found in the line. The updated function declaration looks like this <span class="No-Break" lang="">in </span><span class="No-Break" lang=""><strong class="source-inline" lang="">Util.h</strong></span><span class="No-Break" lang="">:</span></p>
			<pre class="source-code" lang="en-GB">
#include &lt;string&gt;
#include &lt;string_view&gt;
#include &lt;vector&gt;
struct Util
{
    static std::string randomString ();
    static bool isTextInFile (
        std::string_view text,
        std::string_view fileName,
        std::vector&lt;std::string&gt; const &amp; wantedTags = {},
        std::vector&lt;std::string&gt; const &amp; unwantedTags = {});
};</pre>
			<p lang="en-GB">We need to include <strong class="source-inline" lang="">vector</strong> and make sure to give the extra parameters default empty values. The implementation in <strong class="source-inline" lang="">Util.cpp</strong> looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
bool Util::isTextInFile (
    std::string_view text,
    std::string_view fileName,
    std::vector&lt;std::string&gt; const &amp; wantedTags,
    std::vector&lt;std::string&gt; const &amp; unwantedTags)
{
    std::ifstream logfile(fileName.data());
    std::string line;
    while (getline(logfile, line))
    {
        if (line.find(text) != std::string::npos)
        {
            for (auto const &amp; tag: wantedTags)
            {
                if (line.find(tag) == std::string::npos)
                {
                    return false;
                }
            }
            for (auto const &amp; tag: unwantedTags)
            {
                if (line.find(tag) != std::string::npos)
                {
                    return false;
                }
            }
            return true;
        }
    }
    return false;
}</pre>
			<p lang="en-GB">The change adds an extra <strong class="source-inline" lang="">for</strong> loop once we find the line identified by the <strong class="source-inline" lang="">text</strong> parameter. For all the wanted tags provided, we search through the line again to make sure each tag exists. If any of them are not found, then the function returns <strong class="source-inline" lang="">false</strong>. Assuming it finds all the tags, then the function returns <strong class="source-inline" lang="">true</strong>, just <span class="No-Break" lang="">like before.</span></p>
			<p lang="en-GB">Almost the same thing <a id="_idIndexMarker346"/>happens for the unwanted tags except that the logic is reversed. If we find an unwanted tag, then the function <span class="No-Break" lang="">returns </span><span class="No-Break" lang=""><strong class="source-inline" lang="">false</strong></span><span class="No-Break" lang="">.</span></p>
			<p lang="en-GB">All we need now is to add the definition of the <strong class="source-inline" lang="">Color</strong> tag type and then the <strong class="source-inline" lang="">green</strong> color instance. We can add these to <strong class="source-inline" lang="">LogTags.h</strong>, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
inline MereMemo::LogLevel error("error");
inline MereMemo::LogLevel info("info");
inline MereMemo::LogLevel debug("debug");
class Color : public MereMemo::Tag
{
public:
    Color (std::string const &amp; text)
    : Tag("color", text)
    { }
};
inline Color red("red");
inline Color green("green");
inline Color blue("blue");</pre>
			<p lang="en-GB">Building the project shows that I forgot to implement the <strong class="source-inline" lang="">addDefaultTag</strong> function that we started out using in <strong class="source-inline" lang="">main</strong>. Remember when I said that it’s easy to get sidetracked? I started to add the function to <strong class="source-inline" lang="">Log.h</strong>, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
inline void addDefaultTag (Tag const &amp; tag)
{
    static std::map&lt;std::string, Tag const *&gt; tags;
    tags[tag.key()] = &amp;tag;
}</pre>
			<p lang="en-GB">This is a great example of how writing the usage first helped with the implementation. What we need to do is store the tag passed to the <strong class="source-inline" lang="">addDefaultTag</strong> function so that it can be retrieved later <a id="_idIndexMarker347"/>and added to log messages. We first need a place to store the tags so that the function declares a <span class="No-Break" lang="">static map.</span></p>
			<p lang="en-GB">Originally, I wanted the map to make a copy of the tag, but that would have required changing the <strong class="source-inline" lang="">Tag</strong> class so that it could be used directly instead of working with derived classes. I like how the derived classes help with keeping the key consistent and didn’t want to change that part of <span class="No-Break" lang="">the design.</span></p>
			<p lang="en-GB">So, instead, I decided that the collection of tags would use pointers. The problem with using pointers is that it’s not obvious to the caller of <strong class="source-inline" lang="">addDefaultTag</strong> that the lifetimes of any tags passed to the function must remain valid for as long as the tag remains in the default <span class="No-Break" lang="">tag collection.</span></p>
			<p lang="en-GB">We can still make copies and store the copies in unique pointers, but that requires either extra work for the caller of <strong class="source-inline" lang="">addDefaultTag</strong> or some method that knows how to clone a tag. I don’t want to add extra complexity to the code in <strong class="source-inline" lang="">main</strong> that calls <strong class="source-inline" lang="">addDefaultTag</strong> and force that code to make a copy. We’ve already written the code in <strong class="source-inline" lang="">main</strong>, and we should strive to keep that code as-is because it was written using TDD principles and provides the solution we will be most <span class="No-Break" lang="">happy with.</span></p>
			<p lang="en-GB">To avoid lifetime surprises, we should add a <strong class="source-inline" lang="">clone</strong> method to the <strong class="source-inline" lang="">Tag</strong>-derived classes. And because we are using a map in <strong class="source-inline" lang="">addDefaultTag</strong> and have identified the need for unique pointers, we need to include <strong class="source-inline" lang="">map</strong> and <strong class="source-inline" lang="">memory</strong> at the top of <strong class="source-inline" lang="">Log.h</strong>, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
#include &lt;chrono&gt;
#include &lt;ctime&gt;
#include &lt;fstream&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;</pre>
			<p lang="en-GB">Now, let’s implement the correct <strong class="source-inline" lang="">addDefaultTag</strong> function to make a copy of the passed-in tag instead of storing a pointer directly to the caller’s variable. This will free up the caller so that the tags<a id="_idIndexMarker348"/> passed in no longer have to remain alive indefinitely. Add this code to <strong class="source-inline" lang="">Log.h</strong> right after the <span class="No-Break" lang=""><strong class="source-inline" lang="">LogLevel</strong></span><span class="No-Break" lang=""> class:</span></p>
			<pre class="source-code" lang="en-GB">
inline std::map&lt;std::string, std::unique_ptr&lt;Tag&gt;&gt; &amp; getDefaultTags ()
{
    static std::map&lt;std::string, std::unique_ptr&lt;Tag&gt;&gt; tags;
    return tags;
}
inline void addDefaultTag (Tag const &amp; tag)
{
    auto &amp; tags = getDefaultTags();
    tags[tag.key()] = tag.clone();
}</pre>
			<p lang="en-GB">We use a helper function to store the collection of default tags. The collection is static, so it gets initialized to an empty map the first time the tags <span class="No-Break" lang="">are requested.</span></p>
			<p lang="en-GB">We need to add a pure virtual <strong class="source-inline" lang="">clone</strong> method to the <strong class="source-inline" lang="">Tag</strong> class that will return a unique pointer. The method declaration can go right after the <strong class="source-inline" lang="">text</strong> method and looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
    std::string text () const
    {
        return mText;
    }
    virtual std::unique_ptr&lt;Tag&gt; clone () const = 0;
protected:</pre>
			<p lang="en-GB">And now, we need to add the <strong class="source-inline" lang="">clone</strong> method implementation to both the <strong class="source-inline" lang="">LogLevel</strong> and <strong class="source-inline" lang="">Color</strong> classes. The first looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
class LogLevel : public Tag
{
public:
    LogLevel (std::string const &amp; text)
    : Tag("log_level", text)
    { }
    std::unique_ptr&lt;Tag&gt; clone () const override
    {
        return std::unique_ptr&lt;Tag&gt;(
            new LogLevel(*this));
    }
};</pre>
			<p lang="en-GB">And the implementation<a id="_idIndexMarker349"/> for the <strong class="source-inline" lang="">Color</strong> class looks <span class="No-Break" lang="">almost identical:</span></p>
			<pre class="source-code" lang="en-GB">
class Color : public MereMemo::Tag
{
public:
    Color (std::string const &amp; text)
    : Tag("color", text)
    { }
    std::unique_ptr&lt;Tag&gt; clone () const override
    {
        return std::unique_ptr&lt;Tag&gt;(
            new Color(*this));
    }
};</pre>
			<p lang="en-GB">Even though the implementations look almost identical, each makes a new instance of the specific type involved, which gets returned as a unique pointer to <strong class="source-inline" lang="">Tag</strong>. This is the complexity that I was hoping to avoid when I started, but it’s better to add complexity to the derived classes instead of placing extra and unexpected requirements on the caller <span class="No-Break" lang="">of </span><span class="No-Break" lang=""><strong class="source-inline" lang="">addDefaultTag</strong></span><span class="No-Break" lang="">.</span></p>
			<p lang="en-GB">We’re now ready to build and run the test application. One of the tests fails, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">Running 1 test suites</strong>
<strong class="bold" lang="">--------------- Suite: Single Tests</strong>
<strong class="bold" lang="">------- Test: Message can be tagged in log</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: log needs no namespace when used with LogLevel</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Default tags set in main appear in log</strong>
<strong class="bold" lang="">Failed confirm on line 37</strong>
<strong class="bold" lang="">    Expected: true</strong>
<strong class="bold" lang="">------- Test: Simple message can be logged</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Complicated message can be logged</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">-----------------------------------</strong>
<strong class="bold" lang="">Tests passed: 4</strong>
<strong class="bold" lang="">Tests failed: 1</strong></pre>
			<p lang="en-GB">The failure is actually a good thing and is part of the TDD process. We wrote the code as we intended it to be <a id="_idIndexMarker350"/>used in <strong class="source-inline" lang="">main</strong>, and wrote a test that would verify that the default tags appear in the output log file. The default tags are missing, and that’s because we need to change the <strong class="source-inline" lang="">log</strong> function so that it will include the <span class="No-Break" lang="">default tags.</span></p>
			<p lang="en-GB">Right now, the <strong class="source-inline" lang="">log</strong> function only includes the tags that are directly provided—or, I should say, the tag that is directly provided because we don’t yet have a way to log multiple tags. We’ll get there. One thing at <span class="No-Break" lang="">a time.</span></p>
			<p lang="en-GB">Our <strong class="source-inline" lang="">log</strong> function currently has two overloaded versions. One takes a single <strong class="source-inline" lang="">Tag</strong> parameter and turns it into a string that it passes to the other. Once the tag is turned into a string, it becomes harder to detect which tags are currently being used, and we’ll need to know that so that we don’t end up logging both a default tag and a directly specified tag with the <span class="No-Break" lang="">same key.</span></p>
			<p lang="en-GB">For example, we don’t want a log message to include both <strong class="source-inline" lang="">info</strong> and <strong class="source-inline" lang="">debug</strong> log levels because the log was made with <strong class="source-inline" lang="">debug</strong> while <strong class="source-inline" lang="">info</strong> was the default. We only want the <strong class="source-inline" lang="">debug</strong> tag to appear because it should override <span class="No-Break" lang="">the default.</span></p>
			<p lang="en-GB">We need to pass the tag to the <strong class="source-inline" lang="">log</strong> function that does the output as a <strong class="source-inline" lang="">Tag</strong> instance instead of a string. Instead of a single <strong class="source-inline" lang="">Tag</strong> instance, though, let’s let callers pass more than one tag when calling <strong class="source-inline" lang="">log</strong>. Should we let the number of tags be unlimited? Probably not. Three seems like a good amount. If we need more than three, we’ll come up with a different solution or <span class="No-Break" lang="">add more.</span></p>
			<p lang="en-GB">I thought about different ways to write a <strong class="source-inline" lang="">log</strong> function that takes a variadic number of tags using templates. While it might be possible, the complexity quickly became unworkable. So, instead, here are three overloads of <strong class="source-inline" lang="">log</strong> that turn the parameters into a vector of <span class="No-Break" lang=""><strong class="source-inline" lang="">Tag</strong></span><span class="No-Break" lang=""> pointers:</span></p>
			<pre class="source-code" lang="en-GB">
inline auto log (Tag const &amp; tag1)
{
    return log({&amp;tag1});
}
inline auto log (Tag const &amp; tag1,
    Tag const &amp; tag2)
{
    return log({&amp;tag1, &amp;tag2});
}
inline auto log (Tag const &amp; tag1,
    Tag const &amp; tag2,
    Tag const &amp; tag3)
{
    return log({&amp;tag1, &amp;tag2, &amp;tag3});
}</pre>
			<p lang="en-GB">These functions replace<a id="_idIndexMarker351"/> the earlier <strong class="source-inline" lang="">log</strong> function that converted the tag into a string. The new functions create a vector of <strong class="source-inline" lang="">Tag</strong> pointers. We might eventually need to call <strong class="source-inline" lang="">clone</strong> to create copies instead of using pointers to the caller’s arguments, but for now, this works, and we don’t have to worry about the lifetime issues we had with the <span class="No-Break" lang="">default tags.</span></p>
			<p lang="en-GB">We’ll need to include <strong class="source-inline" lang="">vector</strong> at the top of <strong class="source-inline" lang="">Log.h</strong>, and while implementing the <strong class="source-inline" lang="">log</strong> function that actually does the logging, I ended up needing <strong class="source-inline" lang="">algorithm</strong> too. The new include section looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;ctime&gt;
#include &lt;fstream&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;
#include &lt;vector&gt;</pre>
			<p lang="en-GB">And now, to the changes <a id="_idIndexMarker352"/>to the <strong class="source-inline" lang="">log</strong> function that does the logging. It looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
inline std::fstream log (std::vector&lt;Tag const *&gt; tags = {})
{
    auto const now = std::chrono::system_clock::now();
    std::time_t const tmNow =          std::chrono::system_clock::to_time_t(now);
    auto const ms = duration_cast&lt;std::chrono::milliseconds&gt;(
        now.time_since_epoch()) % 1000;
    std::fstream logFile("application.log", std::ios::app);
    logFile &lt;&lt; std::endl
        &lt;&lt; std::put_time(std::gmtime(&amp;tmNow),            "%Y-%m-%dT%H:%M:%S.")
        &lt;&lt; std::setw(3) &lt;&lt; std::setfill('0')         &lt;&lt; std::to_string(ms.count());
    for (auto const &amp; defaultTag: getDefaultTags())
    {
        if (std::find_if(tags.begin(), tags.end(),
            [&amp;defaultTag](auto const &amp; tag)
            {
                return defaultTag.first == tag-&gt;key();
            }) == tags.end())
        {
            logFile &lt;&lt; " " &lt;&lt; defaultTag.second-&gt;text();
        }
    }
    for (auto const &amp; tag: tags)
    {
        logFile &lt;&lt; " " &lt;&lt; tag-&gt;text();
    }
    logFile &lt;&lt; " ";
    return logFile;
}</pre>
			<p lang="en-GB">Instead of accepting a string of pre-formatted tags, the function now takes a vector of <strong class="source-inline" lang="">Tag</strong> pointers with a default value of an empty collection. As far as this function is concerned, there can be an unlimited number of tags. The limit of three tags comes only because of the overloaded <strong class="source-inline" lang="">log</strong> functions that take up to <span class="No-Break" lang="">three tags.</span></p>
			<p lang="en-GB">The default value for the <strong class="source-inline" lang="">tags</strong> vector lets callers continue to be able to call <strong class="source-inline" lang="">log</strong> with <span class="No-Break" lang="">no arguments.</span></p>
			<p lang="en-GB">The first part of the <a id="_idIndexMarker353"/>function that formats the timestamp, opens the log file, and prints the timestamp remains unchanged, except that we no longer display a pre-formatted string for <span class="No-Break" lang="">the tags.</span></p>
			<p lang="en-GB">The changes start with the first <strong class="source-inline" lang="">for</strong> loop, which looks at each default tag. We want to try finding the same tag key in the vector of tag pointers. If we find the same key, then we skip the default tag and try the next one. If we don’t find the same key, then we display the <span class="No-Break" lang="">default tag.</span></p>
			<p lang="en-GB">To do the searching, we use the <strong class="source-inline" lang="">std::find_if</strong> algorithm and provide a lambda that knows how to compare <span class="No-Break" lang="">the keys.</span></p>
			<p lang="en-GB">After displaying only the default tags that were not overridden, the code goes through a second <strong class="source-inline" lang="">for</strong> loop to display all the tags passed <span class="No-Break" lang="">in directly.</span></p>
			<p lang="en-GB">Building and running the test application shows that all the tests pass, and the log file now contains default tags for all the entries, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">2022-06-26T06:24:26.607 color="green" log_level="error" simple tag 4718</strong>
<strong class="bold" lang="">2022-06-26T06:24:26.609 color="green" log_level="error" no namespace</strong>
<strong class="bold" lang="">2022-06-26T06:24:26.609 color="green" log_level="info" default tag 8444</strong>
<strong class="bold" lang="">2022-06-26T06:24:26.609 color="green" log_level="info" simple 4281 with more text.</strong>
<strong class="bold" lang="">2022-06-26T06:24:26.610 color="green" log_level="info" complicated 8368 double=3.14 quoted="in quotes"</strong></pre>
			<p lang="en-GB">All the log messages contain the color tag set to <strong class="source-inline" lang="">"green"</strong>, and they all contain the <strong class="source-inline" lang="">log_level</strong> tag with either the default value of <strong class="source-inline" lang="">"info"</strong> or the overridden value of <strong class="source-inline" lang="">"error"</strong>. For the test that overrides the default value, let’s make sure that the default value does not exist. We can make use of the unwanted tags parameter in the <strong class="source-inline" lang="">isTextInFile</strong> function, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
TEST("Message can be tagged in log")
{
    std::string message = "simple tag ";
    message += Util::randomString();
    MereMemo::log(error) &lt;&lt; message;
    // Confirm that the error tag value exists and that the
    // default info tag value does not.
    std::string logLevelTag = " log_level=\"error\" ";
    std::string defaultLogLevelTag = " log_level=\"info\" ";
    bool result = Util::isTextInFile(message,          "application.log",
        {logLevelTag}, {defaultLogLevelTag});
    CONFIRM_TRUE(result);
}</pre>
			<p lang="en-GB">Should the extra check<a id="_idIndexMarker354"/> that the default tag value does not exist in the log file be added to a separate test? The benefit of a separate test is that it makes it clear what is being tested. The downside is that the test will be almost identical to this one. It’s something to think about. In this case, I think the extra check and comment in the existing test <span class="No-Break" lang="">is enough.</span></p>
			<p lang="en-GB">Before moving on, we need to add a test for the feature that I slipped in for multiple tags. I really should have written a test for this first before enhancing the code to support multiple tags, but for the purposes of explaining the code, it was much more direct to just explain the idea of multiple tags once instead of going back and adding the <span class="No-Break" lang="">extra explanation.</span></p>
			<p lang="en-GB">Let’s quickly add a new type of <strong class="source-inline" lang="">Tag</strong> called <strong class="source-inline" lang="">Size</strong> with a few named instances in <strong class="source-inline" lang="">LogTags.h</strong>, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
class Size : public MereMemo::Tag
{
public:
    Size (std::string const &amp; text)
    : Tag("size", text)
    { }
    std::unique_ptr&lt;Tag&gt; clone () const override
    {
        return std::unique_ptr&lt;Tag&gt;(
            new Size(*this));
    }
};
inline Size small("small");
inline Size medium("medium");
inline Size large("large");</pre>
			<p lang="en-GB">And now, here is a test for <span class="No-Break" lang="">multiple tags:</span></p>
			<pre class="source-code" lang="en-GB">
TEST("Multiple tags can be used in log")
{
    std::string message = "multi tags ";
    message += Util::randomString();
    MereMemo::log(debug, red, large) &lt;&lt; message;
    std::string logLevelTag = " log_level=\"debug\" ";
    std::string colorTag = " color=\"red\" ";
    std::string sizeTag = " size=\"large\" ";
    bool result = Util::isTextInFile(message,          "application.log",
        {logLevelTag, colorTag, sizeTag});
    CONFIRM_TRUE(result);
}</pre>
			<p lang="en-GB">The log file contains the<a id="_idIndexMarker355"/> entry with all three tags, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">2022-06-26T07:09:31.192 log_level="debug" color="red" size="large" multi tags 9863</strong></pre>
			<p lang="en-GB">We have the ability to log with up to three directly specified tags and multiple default tags. We need to eventually use the tags for more than just displaying information in the log file. We want to be able to filter log messages based on the tag values to control which log messages make it all the way to the log file and which are ignored. We’re not quite ready for filtering. The next section will explore filtering options based on the <span class="No-Break" lang="">tag values.</span></p>
			<h1 id="_idParaDest-97" lang="en-GB"><a id="_idTextAnchor102"/>Exploring filtering options</h1>
			<p lang="en-GB">Filtering log messages lets <a id="_idIndexMarker356"/>us write code that includes calls to log information at important places within the code but then ignore some of those logging calls. Why would we go to all the trouble of adding code to do logging but then not do <span class="No-Break" lang="">the logging?</span></p>
			<p lang="en-GB">For some events in the code such as an error that gets detected, it makes sense to always log that event. Other places might be equally important even if they are not errors. Usually, these are places in the code where something gets created or deleted. I’m not talking about creating or deleting an instance of a local variable. I mean something major, such as the creation of a new customer account, the completion of a quest in an adventure game, or the deletion of an old data file to free up space. All of these are good examples of important events that should probably always <span class="No-Break" lang="">be logged.</span></p>
			<p lang="en-GB">Other events might help a developer understand what a program was doing right before it crashed. These log messages act like signposts along a journey. They’re not as big as the errors or major events, but they can let us figure out what a program was doing. These are usually good to log too because, without them, it can be hard to fix bugs. Sure—the error log might show clearly that something bad happened, but understanding what led up to the problem can be difficult without the <span class="No-Break" lang="">signpost messages.</span></p>
			<p lang="en-GB">And sometimes, when we know the general idea of what led to a problem, we need even more details. This is where we sometimes want to turn off the logging because log messages such as these can sometimes be extremely verbose and cause the size of the log files to increase. They can also make it hard to see the bigger picture. Have you ever tried walking someplace with your eyes intently focused on the ground at your feet? You can get all the details of every step but might find that you get lost. Looking up to see the general direction makes it hard to also notice a small rock that can cause you <span class="No-Break" lang="">to trip.</span></p>
			<p lang="en-GB">When writing code, we want to put all these types of log messages into the code because adding extra logging messages later can be difficult, especially if the program is running at a remote customer location. So, we want the code to try to log everything. And then, at runtime, we want to control exactly how much information appears in the log files. Filtering lets us control how much logging we see by ignoring some <span class="No-Break" lang="">logging requests.</span></p>
			<p lang="en-GB">We’re going to filter log messages based on tags and their values, but we have <span class="No-Break" lang="">a problem.</span></p>
			<p lang="en-GB">Let’s say that we want to ignore a log message unless it has a certain tagged value. The way our <strong class="source-inline" lang="">log</strong> function works now is that it immediately opens a log file and starts streaming a timestamp, then adds tags, and finally lets the caller send whatever else <span class="No-Break" lang="">is needed.</span></p>
			<p lang="en-GB">The only way to know for certain if a log message should be allowed to complete is to look at the tags once they have been finalized. In other words, we need to let everything be sent as if it will be <a id="_idIndexMarker357"/>logged but without actually doing anything. Once we have the complete message, we can look at the message to see if it meets the criteria to be sent to the <span class="No-Break" lang="">output file.</span></p>
			<p lang="en-GB">This means we need to do two things differently. First, we need to stop writing to a log file right away and collect everything in case we do eventually need to write it. And second, we need to know when a log message is complete. We can’t simply return an open stream to the caller and let the caller do whatever they want with the stream. Or, I should say that we can’t return a stream that directly modifies the output log file. Letting the caller work directly with the final output log file gives us no way to know when the caller is done so that we can finish up and either ignore the log or let <span class="No-Break" lang="">it continue.</span></p>
			<p lang="en-GB">I know of three ways to determine when a potential log message is complete. The first is to put everything into a single function call. The function can accept a variable number of arguments, so we won’t be limited to a fixed number. But because the entire log message is bundled into a single function call, we will know when we have everything. It might look <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
MereMemo::log(info, " count=", 5, " with text");</pre>
			<p lang="en-GB">I’m using a tag instance, a couple of string literals, and an integer number in this example. The string literals could instead be string variables or maybe function calls that return information to be logged. One of the string literals, together with the number, actually forms a <strong class="source-inline" lang="">key=value</strong> tag. The point is that the <strong class="source-inline" lang="">log</strong> function would know for certain exactly how much information was sent to be logged and we would know all the values. We could easily test the log message to see if it should be allowed to continue or if it should <span class="No-Break" lang="">be ignored.</span></p>
			<p lang="en-GB">We even have the beginning of a solution like this already because we accept up to three tag instances in the <span class="No-Break" lang=""><strong class="source-inline" lang="">log</strong></span><span class="No-Break" lang=""> function.</span></p>
			<p lang="en-GB">The second way to determine when a log is complete is to use something to terminate the stream we have now. It might look <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
MereMemo::log(info) &lt;&lt; "count=" &lt;&lt; 5 &lt;&lt; " with text" &lt;&lt; MereMemo::endlog;</pre>
			<p lang="en-GB">Notice that we don’t need the extra space inside the <strong class="source-inline" lang="">"count="</strong> string literal because the <strong class="source-inline" lang="">log</strong> function adds <a id="_idIndexMarker358"/>one for us after all <span class="No-Break" lang="">the tags.</span></p>
			<p lang="en-GB">Or, we could even allow tags to be sent to the stream, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
MereMemo::log() &lt;&lt; info &lt;&lt; " count=" &lt;&lt; 5 &lt;&lt; " with text" &lt;&lt; MereMemo::endlog;</pre>
			<p lang="en-GB">And we’re back to needing the leading space before the <strong class="source-inline" lang="">count</strong> string literal again. This is common for streams where the caller needs to manage spaces between streamed elements. The only place where we don’t need to add a space is at the very first item streamed after the <span class="No-Break" lang=""><strong class="source-inline" lang="">log</strong></span><span class="No-Break" lang=""> function.</span></p>
			<p lang="en-GB">The main idea with the stream approach is that we need something at the end to let the logging library know that all the information is ready to be tested against the criteria to see if the log should be ignored <span class="No-Break" lang="">or not.</span></p>
			<p lang="en-GB">I like the stream approach better. It feels more open to me—almost more natural. And because of operator precedence and the chaining of the streaming operators, we know the order in which the log line will be evaluated. That might not be very important, but it plays into the feeling that I like the streaming <span class="No-Break" lang="">approach better.</span></p>
			<p lang="en-GB">With this second approach, the stream that the caller gets back from the <strong class="source-inline" lang="">log</strong> function can’t be a <strong class="source-inline" lang="">std::fstream</strong> instance that is directly tied to the log file. Working with <strong class="source-inline" lang="">fstream</strong> directly would not let us ignore the log message because the information would already be sent to the file. Maybe we could return a stream that’s tied to a string instead and let the terminating <strong class="source-inline" lang="">endlog</strong> element send the string that gets built to the log file or <span class="No-Break" lang="">ignore it.</span></p>
			<p lang="en-GB">What happens if the terminating <strong class="source-inline" lang="">endlog</strong> element is forgotten? The terminating <strong class="source-inline" lang="">endlog</strong> element needs to evaluate the log and move it forward or ignore it. If <strong class="source-inline" lang="">endlog</strong> is forgotten, then the log message will not complete. The developer might not notice the problem until a need to look at the log file shows that the expected log message is <span class="No-Break" lang="">always ignored.</span></p>
			<p lang="en-GB">The third approach is similar to the second but without the need for a terminating element that can be forgotten. Anytime a design relies on a person to remember to do something, there will almost certainly be cases where the required part is left out. By removing the need to remember to add a terminating marker, we get a better design that can no longer be misused due to a <span class="No-Break" lang="">simple oversight.</span></p>
			<p lang="en-GB">We already know that we can’t just return a stream tied directly to a log file. The third approach takes this a step further and returns a custom stream. We don’t use a standard stream at all <a id="_idIndexMarker359"/>because we need to add code in the stream destructor that finishes the logging and decides to either let the message complete or <span class="No-Break" lang="">ignore it.</span></p>
			<p lang="en-GB">This approach relies on specific object lifetime rules defined by C++. We need to know exactly when the destructor will run because we need the destructor to fill the role of a terminating <strong class="source-inline" lang="">endlog</strong> element. Other programming languages that use garbage collection to clean up deleted objects would not be able to support this third solution because the stream would not be deleted until some unspecified time in the future. C++ is very clear about when object instances get deleted, and we can rely on the order. For instance, we could make a call to <strong class="source-inline" lang="">log</strong> <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
MereMemo::log(info) &lt;&lt; "count=" &lt;&lt; 5 &lt;&lt; " with text";</pre>
			<p lang="en-GB">The custom stream that <strong class="source-inline" lang="">log</strong> returns will be destructed at the semicolon, which ends the expression. The programmer cannot forget anything, and the stream will be able to run the same code that an explicit <strong class="source-inline" lang="">endlog</strong> element <span class="No-Break" lang="">would trigger.</span></p>
			<p lang="en-GB">Maybe we could combine the best aspects of all three approaches. The first function call approach doesn’t need a terminating element because it knows exactly how many arguments are being passed. The second terminating <strong class="source-inline" lang="">endlog</strong> approach is more open and natural and can work with a standard stream to a string, and the custom stream approach is open and natural too and <span class="No-Break" lang="">avoids misuse.</span></p>
			<p lang="en-GB">I initially wanted to create a logging library that would be able to filter messages based on the entire message. While filtering on anything in the message seems to be the most flexible and powerful solution, it’s also the most complicated to implement. We don’t want to choose one design over another just because one is easier to code. We should choose a design based on the end usage that we will be happy with and find natural to use. Sometimes, complex implementations are a sign that the end use will also be complicated. A solution that might be less powerful overall but is easier to use will be better, as long as we don’t take away anything that <span class="No-Break" lang="">is required.</span></p>
			<p lang="en-GB">One filtering complexity that we should be able to remove without affecting the end use is to only look at tags formed through the <strong class="source-inline" lang="">Tag</strong>-derived classes. We should be able to drop the ability to filter a log message based on the content of manually <span class="No-Break" lang="">crafted tags.</span></p>
			<p lang="en-GB">Another simplification we can make will be to only filter tags passed to the <strong class="source-inline" lang="">log</strong> function. This will combine the aspect of the first approach where the <strong class="source-inline" lang="">log</strong> function accepts multiple arguments<a id="_idIndexMarker360"/> with the custom streaming approach, which accepts an intuitive series of information in chunks. So, take a look at the following <span class="No-Break" lang="">streaming example:</span></p>
			<pre class="source-code" lang="en-GB">
MereMemo::log(info) &lt;&lt; green &lt;&lt; " count=" &lt;&lt; 5 &lt;&lt; " with text";</pre>
			<p lang="en-GB">Here, there are a total of three <strong class="source-inline" lang="">key=value</strong> tags. The first is the <strong class="source-inline" lang="">info</strong> tag, then the <strong class="source-inline" lang="">green</strong> tag, and then a tag formed manually with the count text and number. Instead of trying to filter based on all three tags, the only information we’ll use for filtering will be the <strong class="source-inline" lang="">info</strong> tag because that is the only tag passed to the <strong class="source-inline" lang="">log</strong> function directly. We should also filter based on default tags because the <strong class="source-inline" lang="">log</strong> function knows about the default tags too. This makes it easy to understand what the <strong class="source-inline" lang="">log</strong> function does. The <strong class="source-inline" lang="">log</strong> function starts the logging and determines if anything that comes after it will be accepted <span class="No-Break" lang="">or ignored.</span></p>
			<p lang="en-GB">If we want to consider the <strong class="source-inline" lang="">green</strong> tag in the filtering, then we just need to add it to the <strong class="source-inline" lang="">log</strong> function too, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
MereMemo::log(info, green) &lt;&lt; "count=" &lt;&lt; 5 &lt;&lt; " with text";</pre>
			<p lang="en-GB">This is the type of use that needs to be thought through with TDD. The result is not always the most powerful. Instead, the goal is to meet the needs of the user and be easy and intuitive <span class="No-Break" lang="">to understand.</span></p>
			<p lang="en-GB">Because tags are becoming more important to this design, we should enhance them to support more than just text values. The next section will add new types <span class="No-Break" lang="">of tags.</span></p>
			<h1 id="_idParaDest-98" lang="en-GB"><a id="_idTextAnchor103"/>Adding new tag types</h1>
			<p lang="en-GB">Since we’re starting to refer to tags with<a id="_idIndexMarker361"/> numbers instead of text for the value, now would be a good time to add support for numeric and Boolean tags that don’t need quotation marks around <span class="No-Break" lang="">the value.</span></p>
			<p lang="en-GB">We’re going to get slightly ahead of ourselves here and add some code that we don’t have a test for. That’s only because the additional support for numeric and Boolean tags is so similar to what we already have. This change is in <strong class="source-inline" lang="">Log.h</strong> in the <strong class="source-inline" lang="">Tag</strong> class. We need to add four extra constructors like this after the existing constructor that accepts <span class="No-Break" lang="">a string:</span></p>
			<pre class="source-code" lang="en-GB">
protected:
    Tag (std::string const &amp; key, std::string const &amp; value)
    : mKey(key), mText(key + "=\"" + value + "\"")
    { }
    Tag (std::string const &amp; key, int value)
    : mKey(key), mText(key + "=" + std::to_string(value))
    { }
    Tag (std::string const &amp; key, long long value)
    : mKey(key), mText(key + "=" + std::to_string(value))
    { }
    Tag (std::string const &amp; key, double value)
    : mKey(key), mText(key + "=" + std::to_string(value))
    { }
    Tag (std::string const &amp; key, bool value)
    : mKey(key), mText(key + "=" + (value?"true":"false"))
    { }</pre>
			<p lang="en-GB">Each constructor forms<a id="_idIndexMarker362"/> text following either the <strong class="source-inline" lang="">key="value"</strong> or the <strong class="source-inline" lang="">key=value</strong> syntax. To test the new constructors, we’re going to need some new derived tag classes. All of these classes can go in <strong class="source-inline" lang="">LogTags.h</strong>. The two integral classes look <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
class Count : public MereMemo::Tag
{
public:
    Count (int value)
    : Tag("count", value)
    { }
    std::unique_ptr&lt;Tag&gt; clone () const override
    {
        return std::unique_ptr&lt;Tag&gt;(
            new Count(*this));
    }
};
class Identity : public MereMemo::Tag
{
public:
    Identity (long long value)
    : Tag("id", value)
    { }
    std::unique_ptr&lt;Tag&gt; clone () const override
    {
        return std::unique_ptr&lt;Tag&gt;(
            new Identity(*this));
    }
};</pre>
			<p lang="en-GB">We’re not going to provide named instances of these tags. The earlier <strong class="source-inline" lang="">Color</strong> and <strong class="source-inline" lang="">Size</strong> tag types both have reasonable and common choices that make sense, but even they can be used directly if a<a id="_idIndexMarker363"/> strange color or an uncommon size needs to be logged. The new tags have no such <span class="No-Break" lang="">common values.</span></p>
			<p lang="en-GB">Continuing, the double tag looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
class Scale : public MereMemo::Tag
{
public:
    Scale (double value)
    : Tag("scale", value)
    { }
    std::unique_ptr&lt;Tag&gt; clone () const override
    {
        return std::unique_ptr&lt;Tag&gt;(
            new Scale(*this));
    }
};</pre>
			<p lang="en-GB">And again, it has no obvious default values. Maybe we could provide a named value for 1.0 or some other specific values, but these seem like they would be best defined by the domain of the application. We’re just testing a logging library and will go without named instances for <span class="No-Break" lang="">this tag.</span></p>
			<p lang="en-GB">The Boolean tag looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
class CacheHit : public MereMemo::Tag
{
public:
    CacheHit (bool value)
    : Tag("cache_hit", value)
    { }
    std::unique_ptr&lt;Tag&gt; clone () const override
    {
        return std::unique_ptr&lt;Tag&gt;(
            new CacheHit(*this));
    }
};
inline CacheHit cacheHit(true);
inline CacheHit cacheMiss(false);</pre>
			<p lang="en-GB">And for this one, we have obvious named values for <strong class="source-inline" lang="">true</strong> and <strong class="source-inline" lang="">false</strong> that we <span class="No-Break" lang="">can provide.</span></p>
			<p lang="en-GB">All of the new tag classes should give you an idea of what they can be used for. Many of these are very applicable for large financial microservices where, for example, values can take a long time to <a id="_idIndexMarker364"/>be calculated and need to be cached. Logging whether a result was due to a cache hit or miss is very valuable when figuring out the flow of <span class="No-Break" lang="">a calculation.</span></p>
			<p lang="en-GB">We’d like to be able to pass one of the new tags to the stream returned by the <strong class="source-inline" lang="">log</strong> function, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
MereMemo::log(info) &lt;&lt; Count(1) &lt;&lt; " message";</pre>
			<p lang="en-GB">To do so, we need to add a stream overload that knows how to handle the <strong class="source-inline" lang="">Tag</strong> class. Add this function to <strong class="source-inline" lang="">Log.h</strong> right after the <span class="No-Break" lang=""><strong class="source-inline" lang="">to_string</strong></span><span class="No-Break" lang=""> function:</span></p>
			<pre class="source-code" lang="en-GB">
inline std::fstream &amp; operator &lt;&lt; (std::fstream &amp;&amp; stream, Tag const &amp; tag)
{
    stream &lt;&lt; to_string(tag);
    return stream;
}</pre>
			<p lang="en-GB">The function uses an <em class="italic" lang="">rvalue reference</em> to the stream because we’re using the temporary stream returned from the <span class="No-Break" lang=""><strong class="source-inline" lang="">log</strong></span><span class="No-Break" lang=""> function.</span></p>
			<p lang="en-GB">Now, we can create a test that will log and confirm each of the new types. You could make separate tests for each<a id="_idIndexMarker365"/> type or put all of them into one test, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
TEST("Tags can be streamed to log")
{
    std::string messageBase = " 1 type ";
    std::string message = messageBase + Util::randomString();
    MereMemo::log(info) &lt;&lt; Count(1) &lt;&lt; message;
    std::string countTag = " count=1 ";
    bool result = Util::isTextInFile(message,          "application.log", {countTag});
    CONFIRM_TRUE(result);
    messageBase = " 2 type ";
    message = messageBase + Util::randomString();
    MereMemo::log(info) &lt;&lt; Identity(123456789012345)             &lt;&lt; message;
    std::string idTag = " id=123456789012345 ";
    result = Util::isTextInFile(message, "application.log",
        {idTag});
    CONFIRM_TRUE(result);
    messageBase = " 3 type ";
    message = messageBase + Util::randomString();
    MereMemo::log(info) &lt;&lt; Scale(1.5) &lt;&lt; message;
    std::string scaleTag = " scale=1.500000 ";
    result = Util::isTextInFile(message, "application.log",
        {scaleTag});
    CONFIRM_TRUE(result);
    messageBase = " 4 type ";
    message = messageBase + Util::randomString();
    MereMemo::log(info) &lt;&lt; cacheMiss &lt;&lt; message;
    std::string cacheTag = " cache_hit=false ";
    result = Util::isTextInFile(message, "application.log",
        {cacheTag});
    CONFIRM_TRUE(result);
}</pre>
			<p lang="en-GB">The reason I wasn’t so worried about creating this test before the code we added to enable the test is that we already thought through the desired usage <span class="No-Break" lang="">before beginning.</span></p>
			<p lang="en-GB">The tag for double values<a id="_idIndexMarker366"/> might need some more work later to control the precision. You can see that it uses the default six decimals of precision. The log entries for the new test look <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">2022-06-27T02:06:43.569 color="green" log_level="info" count=1 1 type 2807</strong>
<strong class="bold" lang="">2022-06-27T02:06:43.569 color="green" log_level="info" id=123456789012345 2 type 7727</strong>
<strong class="bold" lang="">2022-06-27T02:06:43.570 color="green" log_level="info" scale=1.500000 3 type 5495</strong>
<strong class="bold" lang="">2022-06-27T02:06:43.570 color="green" log_level="info" cache_hit=false 4 type 3938</strong></pre>
			<p lang="en-GB">Notice how the message that is prepared for each <strong class="source-inline" lang="">log</strong> call is made unique with the numbers <strong class="source-inline" lang="">1</strong> to <strong class="source-inline" lang="">4</strong>. This makes sure that in the rare case where a duplicate random number will be generated, none of the four log messages will have the <span class="No-Break" lang="">same text.</span></p>
			<p lang="en-GB">We can now log default tags, tags provided directly to the <strong class="source-inline" lang="">log</strong> function, and tags that are streamed just like any other piece of information. Before we implement the actual filtering, there are some enhancements that the next section will make to improve the tag classes even more by reducing the amount of code that needs to be written for each <span class="No-Break" lang="">tag class.</span></p>
			<h1 id="_idParaDest-99" lang="en-GB"><a id="_idTextAnchor104"/>Refactoring the tag design with TDD</h1>
			<p lang="en-GB">We have a base <strong class="source-inline" lang="">Tag</strong> class and <a id="_idIndexMarker367"/>several derived tag classes in the tests. Even though the logging library will only define the log-level tag, it should still make it easy for developers to create new derived tag classes. And<a id="_idIndexMarker368"/> right now, creating a new derived tag class is mostly boilerplate code that needs to be repeated over and over. We should be able to enhance the experience by <span class="No-Break" lang="">using templates.</span></p>
			<p lang="en-GB">Here’s what an existing derived tag class <span class="No-Break" lang="">looks like:</span></p>
			<pre class="source-code" lang="en-GB">
class LogLevel : public Tag
{
public:
    LogLevel (std::string const &amp; text)
    : Tag("log_level", text)
    { }
    std::unique_ptr&lt;Tag&gt; clone () const override
    {
        return std::unique_ptr&lt;Tag&gt;(
            new LogLevel(*this));
    }
};</pre>
			<p lang="en-GB">The <strong class="source-inline" lang="">LogLevel</strong>-derived tag class is the only class like this that the logging library will provide. It defines the log-level tag without actually defining any specific log-level values. It’s better to say <a id="_idIndexMarker369"/>that this class defines what a log level <span class="No-Break" lang="">should be.</span></p>
			<p lang="en-GB">We can compare the <strong class="source-inline" lang="">LogLevel</strong> class to<a id="_idIndexMarker370"/> one of the other derived tag classes from the tests. Let’s choose the <strong class="source-inline" lang="">CacheHit</strong> class, which looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
class CacheHit : public MereMemo::Tag
{
public:
    CacheHit (bool value)
    : Tag("cache_hit", value)
    { }
    std::unique_ptr&lt;Tag&gt; clone () const override
    {
        return std::unique_ptr&lt;Tag&gt;(
            new CacheHit(*this));
    }
};</pre>
			<p lang="en-GB">What can we improve about these classes? They’re almost the same, with a few differences that can be moved into a template class. What’s different about these <span class="No-Break" lang="">two classes?</span></p>
			<ul>
				<li lang="en-GB">The name, obviously. <strong class="source-inline" lang="">LogLevel</strong> <span class="No-Break" lang="">versus </span><span class="No-Break" lang=""><strong class="source-inline" lang="">CacheHit</strong></span><span class="No-Break" lang="">.</span></li>
				<li lang="en-GB">The parent class namespace. <strong class="source-inline" lang="">LogLevel</strong> is already in the <span class="No-Break" lang=""><strong class="source-inline" lang="">MereMemo</strong></span><span class="No-Break" lang=""> namespace.</span></li>
				<li lang="en-GB">The key string. <strong class="source-inline" lang="">LogLevel</strong> uses <strong class="source-inline" lang="">"log_level"</strong> while <strong class="source-inline" lang="">CacheHit</strong> <span class="No-Break" lang="">uses </span><span class="No-Break" lang=""><strong class="source-inline" lang="">"cache_hit"</strong></span><span class="No-Break" lang="">.</span></li>
				<li lang="en-GB">The type of the value. <strong class="source-inline" lang="">LogLevel</strong> uses a <strong class="source-inline" lang="">std::string</strong> value while <strong class="source-inline" lang="">CacheHit</strong> uses a <span class="No-Break" lang=""><strong class="source-inline" lang="">bool</strong></span><span class="No-Break" lang=""> value.</span></li>
			</ul>
			<p lang="en-GB">That’s all the differences. There should be no need to make developers recreate all this every time a new tag class<a id="_idIndexMarker371"/> is needed. And we’re going to need to add more code to the tag classes in order to support filtering, so now is a great time to simplify <span class="No-Break" lang="">the design.</span></p>
			<p lang="en-GB">We should be able to make the <a id="_idIndexMarker372"/>upcoming filtering changes without affecting any of the existing tests, but that will require design changes now. We’re refactoring the design, and the tests will help make sure that the new design continues to behave just like the current design. The confidence we get from knowing everything still works is one of the benefits of <span class="No-Break" lang="">using TDD.</span></p>
			<p lang="en-GB">The <strong class="source-inline" lang="">Tag</strong> class represents an interface that all tags support. We’ll leave it as-is and simple. Instead of changing the <strong class="source-inline" lang="">Tag</strong> class, we’ll introduce a new template class that can hold the <strong class="source-inline" lang="">clone</strong> method implementation and any upcoming <span class="No-Break" lang="">filtering changes.</span></p>
			<p lang="en-GB">Change the <strong class="source-inline" lang="">LogLevel</strong> class in <strong class="source-inline" lang="">Log.h</strong> to use a new <strong class="source-inline" lang="">TagType</strong> template class that can use different types of values, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
template &lt;typename T, typename ValueT&gt;
class TagType : public Tag
{
public:
    std::unique_ptr&lt;Tag&gt; clone () const override
    {
        return std::unique_ptr&lt;Tag&gt;(
            new T(*static_cast&lt;T const *&gt;(this)));
    }
    ValueT value () const
    {
        return mValue;
    }
protected:
    TagType (ValueT const &amp; value)
    : Tag(T::key, value), mValue(value)
    { }
    ValueT mValue;
};
class LogLevel : public TagType&lt;LogLevel, std::string&gt;
{
public:
    static constexpr char key[] = "log_level";
    LogLevel (std::string const &amp; value)
    : TagType(value)
    { }
};</pre>
			<p lang="en-GB">We still have a class called <strong class="source-inline" lang="">LogLevel</strong> that can be used just like before. It now specifies the type of the value, which is <strong class="source-inline" lang="">std::string</strong>, in the template argument to <strong class="source-inline" lang="">TagType</strong>, and the <strong class="source-inline" lang="">key</strong> string is now a constant array of chars that each derived tag class will define. The <strong class="source-inline" lang="">LogLevel</strong> class is simpler because it no longer needs to <span class="No-Break" lang="">handle cloning.</span></p>
			<p lang="en-GB">The new <strong class="source-inline" lang="">TagType</strong> template class <a id="_idIndexMarker373"/>does most of the<a id="_idIndexMarker374"/> hard work. For right now, that work is just cloning, but we’ll need to add more features in order to implement filtering. We should be able to put those upcoming features inside the <strong class="source-inline" lang="">TagType</strong> class and leave the derived tag <span class="No-Break" lang="">classes unchanged.</span></p>
			<p lang="en-GB">The way this design works is based <a id="_idIndexMarker375"/>on something called the <strong class="bold" lang="">Curiously Recurring Template Pattern</strong> (<strong class="bold" lang="">CRTP</strong>) and involves a class inheriting from a template that is parameterized on the class itself. In this case, <strong class="source-inline" lang="">LogLevel</strong> inherits from <strong class="source-inline" lang="">TagType</strong>, and <strong class="source-inline" lang="">TagType</strong> is given <strong class="source-inline" lang="">LogLevel</strong> as one of its template parameters. This allows <strong class="source-inline" lang="">TagType</strong> to refer back to <strong class="source-inline" lang="">LogLevel</strong> from within the <strong class="source-inline" lang="">clone</strong> method in order to construct a new instance of <strong class="source-inline" lang="">LogLevel</strong>. Without the CRTP, then <strong class="source-inline" lang="">TagType</strong> would have no way to create a new <strong class="source-inline" lang="">LogLevel</strong> instance because it would not know what type <span class="No-Break" lang="">to create.</span></p>
			<p lang="en-GB">And <strong class="source-inline" lang="">TagType</strong> needs to refer back to <strong class="source-inline" lang="">LogLevel</strong> one more time in order to get the name of the key. <strong class="source-inline" lang="">TagType</strong> does this again by referring to the type given to it by the CRTP in the <span class="No-Break" lang=""><strong class="source-inline" lang="">T</strong></span><span class="No-Break" lang=""> parameter.</span></p>
			<p lang="en-GB">The <strong class="source-inline" lang="">clone</strong> method is a little more complicated because when we’re inside the <strong class="source-inline" lang="">clone</strong> method, we’re in the <strong class="source-inline" lang="">TagType</strong> class, which means that the <strong class="source-inline" lang="">this</strong> pointer needs to be cast to the <span class="No-Break" lang="">derived type.</span></p>
			<p lang="en-GB">We can now simplify the other derived tag types in <strong class="source-inline" lang="">LogTags.h</strong>. The <strong class="source-inline" lang="">Color</strong> and <strong class="source-inline" lang="">Size</strong> types both use <strong class="source-inline" lang="">std::string</strong> as the value type just like <strong class="source-inline" lang="">LogLevel</strong>, and they look <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
class Color : public MereMemo::TagType&lt;Color, std::string&gt;
{
public:
    static constexpr char key[] = "color";
    Color (std::string const &amp; value)
    : TagType(value)
    { }
};
class Size : public MereMemo::TagType&lt;Size, std::string&gt;
{
public:
    static constexpr char key[] = "size";
    Size (std::string const &amp; value)
    : TagType(value)
    { }
};</pre>
			<p lang="en-GB">The <strong class="source-inline" lang="">Count</strong> and <strong class="source-inline" lang="">Identity</strong> types<a id="_idIndexMarker376"/> both use<a id="_idIndexMarker377"/> integral value types of different lengths, and they look <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
class Count : public MereMemo::TagType&lt;Count, int&gt;
{
public:
    static constexpr char key[] = "count";
    Count (int value)
    : TagType(value)
    { }
};
class Identity : public MereMemo::TagType&lt;Identity, long long&gt;
{
public:
    static constexpr char key[] = "id";
    Identity (long long value)
    : TagType(value)
    { }
};</pre>
			<p lang="en-GB">The <strong class="source-inline" lang="">Scale</strong> type uses a <strong class="source-inline" lang="">double</strong> value type and looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
class Scale : public MereMemo::TagType&lt;Scale, double&gt;
{
public:
    static constexpr char key[] = "scale";
    Scale (double value)
    : TagType(value)
    { }
};</pre>
			<p lang="en-GB">And the <strong class="source-inline" lang="">CacheHit</strong> type uses a <strong class="source-inline" lang="">bool</strong> value type and looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
class CacheHit : public MereMemo::TagType&lt;CacheHit, bool&gt;
{
public:
    static constexpr char key[] = "cache_hit";
    CacheHit (bool value)
    : TagType(value)
    { }
};</pre>
			<p lang="en-GB">Each of the derived tag types<a id="_idIndexMarker378"/> is much simpler than before and can focus on what makes each one unique: the class name, the key name, and<a id="_idIndexMarker379"/> the type of <span class="No-Break" lang="">the value.</span></p>
			<p lang="en-GB">The next section will create filtering tests based on logical criteria that will allow us to specify what should be logged, and we’ll be using the simplified tag classes too with the <span class="No-Break" lang=""><strong class="source-inline" lang="">clone</strong></span><span class="No-Break" lang=""> method.</span></p>
			<h1 id="_idParaDest-100" lang="en-GB"><a id="_idTextAnchor105"/>Designing tests to filter log messages</h1>
			<p lang="en-GB">Filtering log messages is <a id="_idIndexMarker380"/>going to be one of the biggest features of the<a id="_idIndexMarker381"/> logging library. That’s why this chapter is devoting so much effort to exploring ideas and enhancing the design. Most logging libraries offer some support for filtering, but usually, it’s limited to just logging levels. And the logging levels are also usually ordered so that when you set one logging level, then you get all logs with a level equal to and either above or below the <span class="No-Break" lang="">filtered level.</span></p>
			<p lang="en-GB">This always seemed arbitrary to me. Do the logging levels go up or down? Does setting the filtering level to <strong class="source-inline" lang="">info</strong> mean that you get <strong class="source-inline" lang="">debug</strong> too, or just <strong class="source-inline" lang="">info</strong> and <span class="No-Break" lang=""><strong class="source-inline" lang="">error</strong></span><span class="No-Break" lang=""> logs?</span></p>
			<p lang="en-GB">And this ignores the bigger <a id="_idIndexMarker382"/>problem of information overload. Once you do figure out how to get debug-level logs, they all get logged and the logs quickly fill<a id="_idIndexMarker383"/> up. I’ve even seen logs fill up so fast that the messages I was interested in were already zipped up and about to be deleted to save space before I could even exit the application to see <span class="No-Break" lang="">what happened.</span></p>
			<p lang="en-GB">Our target customer for the logging library is a microservices developer. This means that the applications being worked on are probably large and distributed. Turning on debug logging everywhere, even within a single service, causes a lot <span class="No-Break" lang="">of problems.</span></p>
			<p lang="en-GB">The logging library we’re building will fix these problems, but we need to start simple. A test like this in <strong class="source-inline" lang="">Tags.cpp</strong> is a <span class="No-Break" lang="">good start:</span></p>
			<pre class="source-code" lang="en-GB">
TEST("Tags can be used to filter messages")
{
    int id = MereMemo::createFilterClause();
    MereMemo::addFilterLiteral(id, error);
    std::string message = "filter ";
    message += Util::randomString();
    MereMemo::log(info) &lt;&lt; message;
    bool result = Util::isTextInFile(message,          "application.log");
    CONFIRM_FALSE(result);
    MereMemo::clearFilterClause(id);
    MereMemo::log(info) &lt;&lt; message;
    bool result = Util::isTextInFile(message,          "application.log");
    CONFIRM_TRUE(result);
}</pre>
			<p lang="en-GB">The idea for this test is to first set a filter that will cause a log message to be ignored. We confirm that the message does not appear in the log file. Then, the test clears the filter and tries to log the same message again. This time, it should appear in the <span class="No-Break" lang="">log file.</span></p>
			<p lang="en-GB">Normally, a filter match should allow a log to proceed, and no match should cause the message to be ignored. But when there are no filters set at all, then we should let everything through. Letting everything through without any filters lets users opt into filtering. If filtering is being used at all, then it controls the log output, but when there are no filters, then it would be strange to not let anything through. When the test sets a filter that does not match the log message, then the message does not appear in the log file because filtering has been <a id="_idIndexMarker384"/>enabled. When the filter is cleared, then we’re assuming there are no other filters set, and <a id="_idIndexMarker385"/>all log messages will be allowed to <span class="No-Break" lang="">proceed again.</span></p>
			<p lang="en-GB">We’ll be filtering<a id="_idIndexMarker386"/> logs based on formulas in the <strong class="bold" lang="">Disjunctive Normal Form</strong> (<strong class="bold" lang="">DNF</strong>). The DNF specifies one or more clauses that are OR’ed together. Each clause contains literals that are AND’ed together. These are not literals in the C++ sense. Here, literal is a mathematical term. Each literal in a clause can either be AND’ed as-is or NOT’ed first. All this is Boolean logic and has the ability to represent any logical condition from simple to complex filters. Explaining all the details of DNF is not the purpose of this book, so I won’t be explaining all the math behind DNF. Just know that DNF is powerful enough to represent any filter we can <span class="No-Break" lang="">think of.</span></p>
			<p lang="en-GB">This is a case where a powerful solution is needed. Even so, we’ll try to focus on the end use and keep the solution as easy to use <span class="No-Break" lang="">as possible.</span></p>
			<p lang="en-GB">The test calls a <strong class="source-inline" lang="">createFilterClause</strong> function that returns an identifier for the clause created. Then, the test calls <strong class="source-inline" lang="">addFilterLiteral</strong> to add an <strong class="source-inline" lang="">error</strong> tag to the clause just created. What the test is trying to accomplish is to complete a log only if the <strong class="source-inline" lang="">error</strong> tag is present. If this tag is not present, then the log should be ignored. And remember that in order for a tag to be considered, it must either be present in the default tags or supplied directly to the <span class="No-Break" lang=""><strong class="source-inline" lang="">log</strong></span><span class="No-Break" lang=""> function.</span></p>
			<p lang="en-GB">Then, the test calls another function, <strong class="source-inline" lang="">clearFilterClause</strong>, which is intended to clear the filter clause just created and let everything be <span class="No-Break" lang="">logged again.</span></p>
			<p lang="en-GB">Normally, the microservices developer won’t run their application with filtering completely empty because that would allow all log messages to go through. Some amount of filtering will likely be in place at all times. As long as at least one filter clause is active, then filtering will only allow messages to proceed that match one of the clauses. By allowing multiple clauses, what we’re doing is letting extra log messages go through because each additional clause has the chance to match more log messages. We’ll have the ability to adjust what gets logged with a powerful system of <span class="No-Break" lang="">Boolean logic.</span></p>
			<p lang="en-GB">A large project could then <a id="_idIndexMarker387"/>add tags that identify different components. The debug logs could be turned on only for certain components or for other matching criteria. The<a id="_idIndexMarker388"/> extra logic opens up more flexibility to increase the logging for interesting areas during debugging sessions while leaving other areas unaffected and logging at <span class="No-Break" lang="">normal levels.</span></p>
			<p lang="en-GB">What happens if a tag is present in the default tags but gets overridden directly in the call to <strong class="source-inline" lang="">log</strong>? Should the default tag be ignored in favor of the explicit tag? I think so, and this will be a great test to include. Edge cases such as this really help define a project and improve the benefits gained by using TDD. Let’s add the test now so that we don’t forget. It looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
TEST("Overridden default tag not used to filter messages")
{
    int id = MereMemo::createFilterClause();
    MereMemo::addFilterLiteral(id, info);
    std::string message = "override default ";
    message += Util::randomString();
    MereMemo::log(debug) &lt;&lt; message;
    bool result = Util::isTextInFile(message,          "application.log");
    CONFIRM_FALSE(result);
    MereMemo::clearFilterClause(id);
}</pre>
			<p lang="en-GB">This test relies on the <strong class="source-inline" lang="">info</strong> tag already being set in the default tags. We should probably add the ability to test which tags are default so that the test can fail if <strong class="source-inline" lang="">info</strong> is not found in the default tags, and we need to make sure to clear the filter clause at the end of the test so that other tests are not affected. The previous test also cleared the clause but at a specific point in the test. Even so, the previous test should have a stronger guarantee that the test will not end with the filter clause still set. We should make use of a test teardown to always clear the filter clause at the end of any test that <span class="No-Break" lang="">creates one.</span></p>
			<p lang="en-GB">Before continuing to add a teardown, the idea for the test that I started to explain is this. After setting a clause to only allow logs with the <strong class="source-inline" lang="">info</strong> tag, then the log message should have been allowed to continue because it will gain the <strong class="source-inline" lang="">info</strong> tag through the default set of tags. But instead, the log overrides the <strong class="source-inline" lang="">info</strong> tag with the <strong class="source-inline" lang="">debug</strong> tag. The end result is that the log message<a id="_idIndexMarker389"/> should not be found in the output <span class="No-Break" lang="">log file.</span></p>
			<p lang="en-GB">To make sure that we<a id="_idIndexMarker390"/> always clear the filter clause even if a test fails and throws an exception before it reaches the end of the test, we need to define a setup and teardown class in <strong class="source-inline" lang="">Tags.cpp</strong>, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
class TempFilterClause
{
public:
    void setup ()
    {
        mId = MereMemo::createFilterClause();
    }
    void teardown ()
    {
        MereMemo::clearFilterClause(mId);
    }
    int id () const
    {
        return mId;
    }
private:
    int mId;
};</pre>
			<p lang="en-GB">If you want more information about setup and teardown classes, refer to <a href="B18567_07.xhtml#_idTextAnchor065"><span class="No-Break" lang=""><em class="italic" lang="">Chapter 7</em></span></a>,<em class="italic" lang=""> Test Setup </em><span class="No-Break" lang=""><em class="italic" lang="">and Teardown</em></span><span class="No-Break" lang="">.</span></p>
			<p lang="en-GB">It’s okay for a test to clear the filters itself at the appropriate times. Adding an instance of <strong class="source-inline" lang="">SetupAndTeardown</strong> will make sure to call the <strong class="source-inline" lang="">clearFilterClause</strong> function even if it was already<a id="_idIndexMarker391"/> called. The first test from this section looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
TEST("Tags can be used to filter messages")
{
    int id = MereMemo::createFilterClause();
    MereMemo::addFilterLiteral(id, error);
    std::string message = "filter ";
    message += Util::randomString();
    MereMemo::log(info) &lt;&lt; message;
    bool result = Util::isTextInFile(message,          "application.log");
    CONFIRM_FALSE(result);
    MereMemo::clearFilterClause(id);
    MereMemo::log(info) &lt;&lt; message;
    result = Util::isTextInFile(message, "application.log");
    CONFIRM_TRUE(result);
}</pre>
			<p lang="en-GB">The test now gets the clause ID from the setup and teardown instance. The ID is used to add the filter literal and to clear the filter clause at the correct time. The filter clause will be cleared again at the<a id="_idIndexMarker392"/> end of the test with <span class="No-Break" lang="">no effect.</span></p>
			<p lang="en-GB">The second test from this section no longer needs to explicitly clear the filter itself and only needs to add the <strong class="source-inline" lang="">SetupAndTeardown</strong> instance, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
TEST("Overridden default tag not used to filter messages")
{
    MereTDD::SetupAndTeardown&lt;TempFilterClause&gt; filter;
    MereMemo::addFilterLiteral(filter.id(), info);
    std::string message = "override default ";
    message += Util::randomString();
    MereMemo::log(debug) &lt;&lt; message;
    bool result = Util::isTextInFile(message,          "application.log");
    CONFIRM_FALSE(result);
}</pre>
			<p lang="en-GB">This test was calling <strong class="source-inline" lang="">clearFilterClause</strong> at the end to put the filters back in an unfiltered state. The test no longer needs to call <strong class="source-inline" lang="">clearFilterClause</strong> directly because relying on the <strong class="source-inline" lang="">SetupAndTeardown</strong> destructor is <span class="No-Break" lang="">more reliable.</span></p>
			<p lang="en-GB">We have two filter <a id="_idIndexMarker393"/>tests that call functions that don’t exist yet. Let’s add the<a id="_idIndexMarker394"/> following function stubs to <strong class="source-inline" lang="">Log.h</strong> right after the <span class="No-Break" lang=""><strong class="source-inline" lang="">addDefaultTag</strong></span><span class="No-Break" lang=""> function:</span></p>
			<pre class="source-code" lang="en-GB">
inline int createFilterClause ()
{
    return 1;
}
inline void addFilterLiteral (int filterId,
    Tag const &amp; tag,
    bool normal = true)
{
}
inline void clearFilterClause (int filterId)
{
}</pre>
			<p lang="en-GB">The <strong class="source-inline" lang="">createFilterClause</strong> function just returns <strong class="source-inline" lang="">1</strong> for now. It will need to eventually return a different identifier for each <span class="No-Break" lang="">clause created.</span></p>
			<p lang="en-GB">The <strong class="source-inline" lang="">addFilterLiteral</strong> function adds the given tag to the clause identified. The <strong class="source-inline" lang="">normal</strong> parameter will let us add literals that are NOT’ed or inverted by passing <strong class="source-inline" lang="">false</strong>. Be careful with the meaning of flags such as this. When I first wrote this, the flag was called <strong class="source-inline" lang="">invert</strong> and had a default value of <strong class="source-inline" lang="">false</strong>. I didn’t notice the problem until writing a test for an inverted filter and it seemed strange to pass <strong class="source-inline" lang="">true</strong> in order to get an inverted literal. The test highlighted the backward usage while the initial function declaration let it slip <span class="No-Break" lang="">by unnoticed.</span></p>
			<p lang="en-GB">And the <strong class="source-inline" lang="">clearFilterClause</strong> function does nothing for now. We’ll need to have some sort of collection of clauses later that we can <span class="No-Break" lang="">work with.</span></p>
			<p lang="en-GB">Stubbing out the filter functions lets us build and run the test application. We get two test failures, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">Running 1 test suites</strong>
<strong class="bold" lang="">--------------- Suite: Single Tests</strong>
<strong class="bold" lang="">------- Test: Message can be tagged in log</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: log needs no namespace when used with LogLevel</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Default tags set in main appear in log</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Multiple tags can be used in log</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Tags can be streamed to log</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Tags can be used to filter messages</strong>
<strong class="bold" lang="">Failed confirm on line 123</strong>
<strong class="bold" lang="">    Expected: false</strong>
<strong class="bold" lang="">------- Test: Overridden default tag not used to filter messages</strong>
<strong class="bold" lang="">Failed confirm on line 143</strong>
<strong class="bold" lang="">    Expected: false</strong>
<strong class="bold" lang="">------- Test: Simple message can be logged</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Complicated message can be logged</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">-----------------------------------</strong>
<strong class="bold" lang="">Tests passed: 7</strong>
<strong class="bold" lang="">Tests failed: 2</strong></pre>
			<p lang="en-GB">The results are expected <a id="_idIndexMarker395"/>with TDD. We did the bare minimum needed to get the code building so that we can<a id="_idIndexMarker396"/> see the failures. We can add a little more implementation to the stubbed-out <span class="No-Break" lang="">functions next.</span></p>
			<p lang="en-GB">I mentioned that we’ll need a collection for the clauses. Add the following functions to <strong class="source-inline" lang="">Log.h</strong>, right before the stubbed-out <span class="No-Break" lang="">filter functions:</span></p>
			<pre class="source-code" lang="en-GB">
struct FilterClause
{
    std::vector&lt;std::unique_ptr&lt;Tag&gt;&gt; normalLiterals;
    std::vector&lt;std::unique_ptr&lt;Tag&gt;&gt; invertedLiterals;
};
inline std::map&lt;int, FilterClause&gt; &amp; getFilterClauses ()
{
    static std::map&lt;int, FilterClause&gt; clauses;
    return clauses;
}</pre>
			<p lang="en-GB">The pattern is similar to what we did for the default tags. There is a function called <strong class="source-inline" lang="">getFilterClauses</strong> that returns a reference to a static map of <strong class="source-inline" lang="">FilterClause</strong> objects, and the <strong class="source-inline" lang="">FilterClause</strong> struct is <a id="_idIndexMarker397"/>defined to hold a couple of vectors for the normal and inverted literals. The<a id="_idIndexMarker398"/> literals are pointers to the tags that we get <span class="No-Break" lang="">from cloning.</span></p>
			<p lang="en-GB">The <strong class="source-inline" lang="">createFilterClause</strong> function can be implemented to use the collection of clauses, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
inline int createFilterClause ()
{
    static int currentId = 0;
    ++currentId;
    auto &amp; clauses = getFilterClauses();
    clauses[currentId] = FilterClause();
    return currentId;
}</pre>
			<p lang="en-GB">This function keeps track of the current id in a static variable that gets incremented each time the function is called. The only other task that needs to be done is to create an empty filter clause record. The id is returned to the caller so that the filter clause can be modified or <span class="No-Break" lang="">cleared later.</span></p>
			<p lang="en-GB">The <strong class="source-inline" lang="">addfilterLiteral</strong> function can be implemented <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
inline void addFilterLiteral (int filterId,
    Tag const &amp; tag,
    bool normal = true)
{
    auto &amp; clauses = getFilterClauses();
    if (clauses.contains(filterId))
    {
        if (normal)
        {
            clauses[filterId].normalLiterals.push_back(
                tag.clone());
        }
        else
        {
            clauses[filterId].invertedLiterals.push_back(
                tag.clone());
        }
    }
}</pre>
			<p lang="en-GB">This function makes sure that the <strong class="source-inline" lang="">clauses</strong> collection contains an entry for the given filter id before pushing back a<a id="_idIndexMarker399"/> cloned pointer to either the normal or <span class="No-Break" lang="">inverted vector.</span></p>
			<p lang="en-GB">And the <strong class="source-inline" lang="">clearFilterClause</strong> function is the simplest because it just needs to get the collection and erase whichever filter clause exists with the given id <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
inline void clearFilterClause (int filterId)
{
    auto &amp; clauses = getFilterClauses();
    clauses.erase(filterId);
}</pre>
			<p lang="en-GB">We still need to examine <a id="_idIndexMarker400"/>the filter clauses when logging, and that will be explained in the next section. When following TDD, it’s good to get tests working to the point where the code builds and the tests fail when run. Let’s get the tests to pass in the <span class="No-Break" lang="">next section!</span></p>
			<h1 id="_idParaDest-101" lang="en-GB"><a id="_idTextAnchor106"/>Controlling what gets logged</h1>
			<p lang="en-GB">Earlier in this chapter <a id="_idIndexMarker401"/>when we were exploring filtering options, I mentioned that we will need a custom stream class instead of returning <strong class="source-inline" lang="">std::fstream</strong> from the <strong class="source-inline" lang="">log</strong> function. We need this so that we don’t immediately send information to the log file. We need to avoid sending a log message directly to the log file because there could be filtering rules in place that could cause the log message to <span class="No-Break" lang="">be ignored.</span></p>
			<p lang="en-GB">We also decided that we would make the decision to log or not based entirely on the default tags and any tags sent directly to the <strong class="source-inline" lang="">log</strong> function. We could have the <strong class="source-inline" lang="">log</strong> function make the decision and either return <strong class="source-inline" lang="">std::fstream</strong> if the log message should proceed or a fake stream if the log message should be ignored, but it’s probably better to always return the same type. That seems like the simplest and most straightforward solution. Switching between stream types just seems like a more complicated solution that still requires a custom <span class="No-Break" lang="">stream type.</span></p>
			<p lang="en-GB">And using a custom stream type will also let us fix a nagging problem where we have to put newlines <em class="italic" lang="">before</em> each log message instead of <em class="italic" lang="">after</em>. This has resulted in log files with an empty first line and the last line ending abruptly. We went with the temporary solution to put newlines before each log message because we didn’t have anything at the time that would let us know when all the information had <span class="No-Break" lang="">been streamed.</span></p>
			<p lang="en-GB">Well, a custom stream <a id="_idIndexMarker402"/>class will let us solve the nagging newline problem and give us a way to avoid writing log messages directly to the log file. Let’s start with the new stream class. Create this class in <strong class="source-inline" lang="">Log.h</strong>, right before the <strong class="source-inline" lang="">log</strong> functions, <span class="No-Break" lang="">like so:</span></p>
			<pre class="source-code" lang="en-GB">
class LogStream : public std::fstream
{
public:
    LogStream (std::string const &amp; filename,
        std::ios_base::openmode mode = ios_base::app)
    : std::fstream(filename, mode)
    { }
    LogStream (LogStream const &amp; other) = delete;
    LogStream (LogStream &amp;&amp; other)
    : std::fstream(std::move(other))
    { }
    ~LogStream ()
    {
        *this &lt;&lt; std::endl;
    }
    
    LogStream &amp; operator = (LogStream const &amp; rhs) = delete;
    LogStream &amp; operator = (LogStream &amp;&amp; rhs) = delete;
};</pre>
			<p lang="en-GB">We’re going to fix one problem at a time. So, we’ll continue to refactor this class until it does everything we need. Right now, it just inherits from <strong class="source-inline" lang="">std::fstream</strong>, so it won’t solve the problem of writing directly to the log file. The constructor still opens the log file, and all the streaming capability is inherited <span class="No-Break" lang="">from </span><span class="No-Break" lang=""><strong class="source-inline" lang="">fstream</strong></span><span class="No-Break" lang="">.</span></p>
			<p lang="en-GB">What this class does solve is the newline problem. It solves this by sending <strong class="source-inline" lang="">std::endl</strong> to the stream in the class destructor. The constructor that opens the file based on the name provided and the destructor that adds the newline are really the only parts of this class that solve the problem. The rest of the class is needed to get the code to compile and <span class="No-Break" lang="">work properly.</span></p>
			<p lang="en-GB">Because we added a destructor, that set off a chain reaction of other requirements. We now need to provide a copy <a id="_idIndexMarker403"/>constructor. We actually need the <em class="italic" lang="">move copy constructor</em> because streams tend to act strange when copied. Copying a stream is not a simple task, but moving a stream into another stream is much simpler and does everything we need anyway. We don’t need to make any copies of the stream but we do need to return the stream from the <strong class="source-inline" lang="">log</strong> function, which means the stream either needs to be copied or moved. So, we explicitly delete the copy constructor and implement the move <span class="No-Break" lang="">copy constructor.</span></p>
			<p lang="en-GB">We also delete both the assignment operator and the move assignment operator because we don’t need to assign the <span class="No-Break" lang="">stream either.</span></p>
			<p lang="en-GB">We can use the new <strong class="source-inline" lang="">LogStream</strong> class by modifying the <strong class="source-inline" lang="">log</strong> function to look <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
inline LogStream log (std::vector&lt;Tag const *&gt; tags = {})
{
    auto const now = std::chrono::system_clock::now();
    std::time_t const tmNow =          std::chrono::system_clock::to_time_t(now);
    auto const ms = duration_cast&lt;std::chrono::milliseconds&gt;(
        now.time_since_epoch()) % 1000;
    LogStream ls("application.log");
    ls &lt;&lt; std::put_time(std::gmtime(&amp;tmNow),        "%Y-%m-%dT%H:%M:%S.")
        &lt;&lt; std::setw(3) &lt;&lt; std::setfill('0')         &lt;&lt; std::to_string(ms.count());
    for (auto const &amp; defaultTag: getDefaultTags())
    {
        if (std::find_if(tags.begin(), tags.end(),
            [&amp;defaultTag](auto const &amp; tag)
            {
                return defaultTag.first == tag-&gt;key();
            }) == tags.end())
        {
            ls &lt;&lt; " " &lt;&lt; defaultTag.second-&gt;text();
        }
    }
    for (auto const &amp; tag: tags)
    {
        ls &lt;&lt; " " &lt;&lt; tag-&gt;text();
    }
    ls &lt;&lt; " ";
    return ls;
}</pre>
			<p lang="en-GB">The <strong class="source-inline" lang="">log</strong> function now returns a <strong class="source-inline" lang="">LogStream</strong> instance instead of <strong class="source-inline" lang="">std::fstream</strong>. Inside the function, it creates a <strong class="source-inline" lang="">LogStream</strong> instance as if it were a <strong class="source-inline" lang="">fstream</strong> instance. The only thing that changes is the type. And we now have the file open mode defaulted to <strong class="source-inline" lang="">append</strong>, so we don’t <a id="_idIndexMarker404"/>need to specify how to open the file. The name of the stream changed to <strong class="source-inline" lang="">ls</strong> because this is no longer a <span class="No-Break" lang="">log file.</span></p>
			<p lang="en-GB">And then, when sending the initial timestamp, we no longer need to send an initial <strong class="source-inline" lang="">std::endl</strong> instance and can immediately start with <span class="No-Break" lang="">the timestamp.</span></p>
			<p lang="en-GB">The only thing different when the test application runs after these changes is that the log file will no longer have an empty first line and all lines will end with <span class="No-Break" lang="">a newline.</span></p>
			<p lang="en-GB">That’s one small problem fixed. What about the bigger problem of writing directly to the log file? We still want to write to a standard stream because implementing our own stream class adds a lot of complexity we don’t really need right now. So, instead of inheriting the <strong class="source-inline" lang="">LogStream</strong> class from <strong class="source-inline" lang="">std::fstream</strong>, we’ll instead inherit <span class="No-Break" lang="">from </span><span class="No-Break" lang=""><strong class="source-inline" lang="">std::stringstream</strong></span><span class="No-Break" lang="">.</span></p>
			<p lang="en-GB">We’re going to need to include <strong class="source-inline" lang="">sstream</strong> to get a definition of <strong class="source-inline" lang="">stringstream</strong>, and we might as well include <strong class="source-inline" lang="">ostream</strong> now too. We’ll need <strong class="source-inline" lang="">ostream</strong> in order to change our streaming helper function in <strong class="source-inline" lang="">Log.h</strong>, which currently uses <strong class="source-inline" lang="">std::fstream</strong>, to look like <span class="No-Break" lang="">this instead:</span></p>
			<pre class="source-code" lang="en-GB">
inline std::ostream &amp; operator &lt;&lt; (std::ostream &amp;&amp; stream, Tag const &amp; tag)
{
    stream &lt;&lt; to_string(tag);
    return stream;
}</pre>
			<p lang="en-GB">We probably should have implemented this helper function to use <strong class="source-inline" lang="">ostream</strong> from the very beginning. This way, we can stream tags to any output stream. And because both <strong class="source-inline" lang="">fstream</strong> and <strong class="source-inline" lang="">stringstream</strong> are based on <strong class="source-inline" lang="">ostream</strong>, we can use this one helper function to stream <span class="No-Break" lang="">to both.</span></p>
			<p lang="en-GB">Here are the updated<a id="_idIndexMarker405"/> includes <span class="No-Break" lang="">for </span><span class="No-Break" lang=""><strong class="source-inline" lang="">Log.h</strong></span><span class="No-Break" lang="">:</span></p>
			<pre class="source-code" lang="en-GB">
#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;ctime&gt;
#include &lt;fstream&gt;
#include &lt;iomanip&gt;
#include &lt;map&gt;
#include &lt;memory&gt;
#include &lt;ostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;
#include &lt;vector&gt;</pre>
			<p lang="en-GB">Technically, we don’t need to include <strong class="source-inline" lang="">ostream</strong> because we get it already through including <strong class="source-inline" lang="">fstream</strong> and <strong class="source-inline" lang="">stringstream</strong>, but I like to include headers for things we are directly using. And while looking into the headers being included, I noticed that we were including <strong class="source-inline" lang="">iostream</strong>. I think I originally included <strong class="source-inline" lang="">iostream</strong> to get the definition of <strong class="source-inline" lang="">std::endl</strong>, but it seems that <strong class="source-inline" lang="">endl</strong> is actually declared in <strong class="source-inline" lang="">ostream</strong>. So, based on my rule to include headers being used, we should have been including <strong class="source-inline" lang="">ostream</strong> since the very beginning instead <span class="No-Break" lang="">of </span><span class="No-Break" lang=""><strong class="source-inline" lang="">iostream</strong></span><span class="No-Break" lang="">.</span></p>
			<p lang="en-GB">Back to <strong class="source-inline" lang="">LogStream</strong>, we need to change this class to inherit from <strong class="source-inline" lang="">stringstream</strong>, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
class LogStream : public std::stringstream
{
public:
    LogStream (std::string const &amp; filename,
        std::ios_base::openmode mode = ios_base::app)
    : mProceed(true), mFile(filename, mode)
    { }
    LogStream (LogStream const &amp; other) = delete;
    LogStream (LogStream &amp;&amp; other)
    : std::stringstream(std::move(other)),
    mProceed(other.mProceed), mFile(std::move(other.mFile))
    { }
    ~LogStream ()
    {
        if (not mProceed)
        {
            return;
        }
        mFile &lt;&lt; this-&gt;str();
        mFile &lt;&lt; std::endl;
    }
    LogStream &amp; operator = (LogStream const &amp; rhs) = delete;
    LogStream &amp; operator = (LogStream &amp;&amp; rhs) = delete;
    void ignore ()
    {
        mProceed = false;
    }
private:
    bool mProceed;
    std::fstream mFile;
};</pre>
			<p lang="en-GB">There is a new data member called <strong class="source-inline" lang="">mProceed</strong> that we set to <strong class="source-inline" lang="">true</strong> in the constructor. Since we no longer inherit from <strong class="source-inline" lang="">std::fstream</strong>, we now need a data member that is a file stream. We also need to initialize the <strong class="source-inline" lang="">mFile</strong> member. The move copy constructor needs to initialize the<a id="_idIndexMarker406"/> data members, and the destructor checks if the logging should proceed or not. If the logging should proceed, then the string content of <strong class="source-inline" lang="">stringstream</strong> is sent to the <span class="No-Break" lang="">file stream.</span></p>
			<p lang="en-GB">We still haven’t implemented the filtering, but we’re getting close. This change gets us to the point where we can control the logging. The logging will proceed unless we call <strong class="source-inline" lang="">ignore</strong> before the destructor is run. This simple change will let us build and test to make sure that we haven’t <span class="No-Break" lang="">broken anything.</span></p>
			<p lang="en-GB">Running the test application shows the same two test failures as before related to the filtering. The main thing is that the other tests continue to pass, which shows that the changes to use <strong class="source-inline" lang="">stringstream</strong> are working as before when we were streaming directly to the <span class="No-Break" lang="">file stream.</span></p>
			<p lang="en-GB">It’s important when making pivotal changes such as switching streams to make sure that nothing breaks. This is why I made the change with a hardcoded choice to always log. We can use the TDD tests we already have to verify that the stream change works before making more changes to <span class="No-Break" lang="">add filtering.</span></p>
			<p lang="en-GB">Let’s take the next change to the <strong class="source-inline" lang="">log</strong> function in two parts. We’re going to need the full collection of active tags after figuring out which of the default tags have been overridden. Instead <a id="_idIndexMarker407"/>of sending the tags to the stream, we can first put them into an active collection, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
inline LogStream log (std::vector&lt;Tag const *&gt; tags = {})
{
    auto const now = std::chrono::system_clock::now();
    std::time_t const tmNow =          std::chrono::system_clock::to_time_t(now);
    auto const ms = duration_cast&lt;std::chrono::milliseconds&gt;(
        now.time_since_epoch()) % 1000;
    LogStream ls("application.log");
    ls &lt;&lt; std::put_time(std::gmtime(&amp;tmNow),        "%Y-%m-%dT%H:%M:%S.")
        &lt;&lt; std::setw(3) &lt;&lt; std::setfill('0')         &lt;&lt; std::to_string(ms.count());
    std::map&lt;std::string, Tag const *&gt; activeTags;
    for (auto const &amp; defaultTag: getDefaultTags())
    {
        activeTags[defaultTag.first] = defaultTag.second.get();
    }
    for (auto const &amp; tag: tags)
    {
        activeTags[tag-&gt;key()] = tag;
    }
    for (auto const &amp; activeEntry: activeTags)
    {
        ls &lt;&lt; " " &lt;&lt; activeEntry.second-&gt;text();
    }
    ls &lt;&lt; " ";
    // Filtering will go here.
    return ls;
}</pre>
			<p lang="en-GB">This not only gets us the active collection, but it also seems simpler. We let the map handle the overrides by first putting all the default tags into the map and then putting all the provided tags into the map. Building and running the test application shows that the change hasn’t broken anything new. So, we’re ready for the next part, which is comparing the filtering clauses with the <span class="No-Break" lang="">active tags.</span></p>
			<p lang="en-GB">The filtering needs to<a id="_idIndexMarker408"/> change the last part of the <strong class="source-inline" lang="">log</strong> function where the comment indicates that filtering will go, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
    bool proceed = true;
    for (auto const &amp; clause: getFilterClauses())
    {
        proceed = false;
        bool allLiteralsMatch = true;
        for (auto const &amp; normal: clause.second.normalLiterals)
        {
            // We need to make sure that the tag is
            // present and with the correct value.
            if (not activeTags.contains(normal-&gt;key()))
            {
                allLiteralsMatch = false;
                break;
            }
            if (activeTags[normal-&gt;key()]-&gt;text() !=
                normal-&gt;text())
            {
                allLiteralsMatch = false;
                break;
            }
        }
        if (not allLiteralsMatch)
        {
            continue;
        }
        for (auto const &amp; inverted:             clause.second.invertedLiterals)
        {
            // We need to make sure that the tag is either
            // not present or has a mismatched value.
            if (activeTags.contains(inverted-&gt;key()))
            {
                if (activeTags[inverted-&gt;key()]-&gt;text() !=
                    inverted-&gt;text())
                {
                    break;
                }
                allLiteralsMatch = false;
                break;
            }
        }
        if (allLiteralsMatch)
        {
            proceed = true;
            break;
        }
    }
    if (not proceed)
    {
        ls.ignore();
    }
    return ls;</pre>
			<p lang="en-GB">The logic is a little complicated, and this is a case where I found it easier to implement the logic almost completely<a id="_idIndexMarker409"/> instead of trying to break the change into multiple parts. Here’s what the <span class="No-Break" lang="">code does.</span>
Because we are using DNF logic, we can treat each clause separately. We start out as if we will proceed with the log, just in case there are no filters set at all. If there are any filters, then for each one, we start out as if we will not proceed. But we also set a new <strong class="source-inline" lang="">bool</strong> variable that assumes that all the literals will match until proven otherwise. We’ll treat a clause without any literals as a sign that we should proceed with <span class="No-Break" lang="">the log.</span></p>
			<p lang="en-GB">For checking the literals, we have two types: normal and inverted. For the normal literals, the tags must all be present in the active tags and have matching values. If any tag is missing or has the wrong value, then we did not match all the literals for this clause. We’ll continue because there might be another clause that will match. This is what I mean about treating each <span class="No-Break" lang="">clause separately.</span></p>
			<p lang="en-GB">Assuming we matched all the normal literals, we must still check the inverted literals. Here, the logic is reversed, and we need to make sure that either the tag is not present or that it has the <span class="No-Break" lang="">wrong value.</span></p>
			<p lang="en-GB">Once we’ve checked all the clauses or found a clause that matches all the literals, the code makes one last check to see if the log should proceed or not. If not, then we call <strong class="source-inline" lang="">ignore</strong>, which will stop the log message from being sent to the output <span class="No-Break" lang="">log file.</span></p>
			<p lang="en-GB">This approach makes a decision about whether or not to proceed at the time that the <strong class="source-inline" lang="">log</strong> function is called <a id="_idIndexMarker410"/>based on the default tags and tags sent to the <strong class="source-inline" lang="">log</strong> function. We’ll let the calling code send whatever information is desired to the stream. The information will only make it all the way to the output log file if <strong class="source-inline" lang="">ignore</strong> was <span class="No-Break" lang="">not called.</span></p>
			<p lang="en-GB">Everything builds and runs now, and we get all tests passing again, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">Running 1 test suites</strong>
<strong class="bold" lang="">--------------- Suite: Single Tests</strong>
<strong class="bold" lang="">------- Test: Message can be tagged in log</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: log needs no namespace when used with LogLevel</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Default tags set in main appear in log</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Multiple tags can be used in log</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Tags can be streamed to log</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Tags can be used to filter messages</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Overridden default tag not used to filter messages</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Simple message can be logged</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Complicated message can be logged</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">-----------------------------------</strong>
<strong class="bold" lang="">Tests passed: 9</strong>
<strong class="bold" lang="">Tests failed: 0</strong></pre>
			<p lang="en-GB">This shows that the filtering is working! At least, for the equality of the tags. Testing whether or not a tag is present with a matching value is a good start, but our microservices developer will need more power than this. Maybe we will need to log only if a count tag has a value greater than 100 or some other comparison that involves a numeric value greater or lesser than a specified filter value. This is what I meant when I said that I implemented the filtering logic <em class="italic" lang="">almost</em> completely. I got the logic and all the loops and breaks working for tag equality. We should be able to use the same basic structure of the code for relative comparisons in the <span class="No-Break" lang="">next section.</span></p>
			<p lang="en-GB">There’s one more thing to add before we start relative comparisons, and this is important. Whenever code is added like what I did with the DNF logic without a test to back it up, we need to<a id="_idIndexMarker411"/> add a test. Otherwise, a missed test has a way of getting pushed back until it’s forgotten <span class="No-Break" lang="">about completely.</span></p>
			<p lang="en-GB">And this new test helped out in another way. It caught a problem with the initial definition of the <strong class="source-inline" lang="">addFilterLiteral</strong> function. The original function defined a <strong class="source-inline" lang="">bool</strong> parameter called <strong class="source-inline" lang="">invert</strong> that had a default value of <strong class="source-inline" lang="">false</strong>. The default value meant that creating a normal literal could leave out the parameter and use the default. But to create an inverted literal, the function required that the <strong class="source-inline" lang="">true</strong> value be passed. This seemed backward to me. I realized that it would make more sense to pass <strong class="source-inline" lang="">false</strong> for this parameter to get an inverted literal, and that <strong class="source-inline" lang="">true</strong> should create a normal literal. So, I went back and changed the function definition and implementation. The test caught a problem with the usage of a function that went unnoticed <span class="No-Break" lang="">at first.</span></p>
			<p lang="en-GB">Here is the new test that will create an <span class="No-Break" lang="">inverted filter:</span></p>
			<pre class="source-code" lang="en-GB">
TEST("Inverted tag can be used to filter messages")
{
    MereTDD::SetupAndTeardown&lt;TempFilterClause&gt; filter;
    MereMemo::addFilterLiteral(filter.id(), green, false);
    std::string message = "inverted ";
    message += Util::randomString();
    MereMemo::log(info) &lt;&lt; message;
    bool result = Util::isTextInFile(message,          "application.log");
    CONFIRM_FALSE(result);
}</pre>
			<p lang="en-GB">Building and running shows that the new test passes, and we have confirmed that we can filter log messages that contain a matching tag when the filter is inverted. This test uses the default <strong class="source-inline" lang="">green</strong> tag that is added to log messages and makes sure that the log message does not appear in the output log file because of the presence of the <span class="No-Break" lang=""><strong class="source-inline" lang="">green</strong></span><span class="No-Break" lang=""> tag.</span></p>
			<p lang="en-GB">The next section will enhance the filtering to allow filtering based on relative values of tags instead of just <span class="No-Break" lang="">exact matches.</span></p>
			<h1 id="_idParaDest-102" lang="en-GB"><a id="_idTextAnchor107"/>Enhancing filtering for relative matches</h1>
			<p lang="en-GB">TDD encourages incremental changes<a id="_idIndexMarker412"/> and enhancements when designing software. Write a test, get something working, and then write a more elaborate test that enhances the design. We’ve been following a TDD approach to designing the logging library, and the previous section was a great example. We got filtering working in the previous section, but only for <span class="No-Break" lang="">tag equality.</span></p>
			<p lang="en-GB">In other words, we can now filter log messages based on the presence or absence of a tag that matches a filter literal tag. We compare the tags to see if both the key and value match. That was a great first step because even getting that far required a lot of work. Imagine if we had tried to go all the way and supported, for example, logging only if a count tag had a value greater <span class="No-Break" lang="">than 100.</span></p>
			<p lang="en-GB">When designing software using TDD, it really helps to look for obvious steps that can be taken and confirmed to work before taking the next step. Some steps might be bigger than others, and that’s okay as long as you don’t go straight to the final implementation because that will only lead to longer development times and more frustration. It’s so much better to confirm some parts of the design work as expected and have tests to make sure those parts continue to work. It’s like building a house with a solid foundation. It’s much better to make sure that the foundation really is solid before building the walls, and you want to have tests to make sure that the walls stay straight while the roof is <span class="No-Break" lang="">being added.</span></p>
			<p lang="en-GB">We have working tests in place to make sure that basic filtering works. We are testing both normal and inverted literals. We check for matching tags by comparing the text of the tags, which works for all value types. For relative filters such as a count greater than 100, we’re going to need a solution that knows how to compare the values with a numeric check instead of a <span class="No-Break" lang="">string match.</span></p>
			<p lang="en-GB">We can start by figuring out how to represent a filter literal to check for greater or lesser numeric values. Here is a test that can go in <strong class="source-inline" lang="">Tags.cpp</strong> that sets a filter based on a count greater <span class="No-Break" lang="">than 100:</span></p>
			<pre class="source-code" lang="en-GB">
TEST("Tag values can be used to filter messages")
{
    MereTDD::SetupAndTeardown&lt;TempFilterClause&gt; filter;
    MereMemo::addFilterLiteral(filter.id(),
        Count(100, MereMemo::TagOperation::GreaterThan));
    std::string message = "values ";
    message += Util::randomString();
    MereMemo::log(Count(1)) &lt;&lt; message;
    bool result = Util::isTextInFile(message,          "application.log");
    CONFIRM_FALSE(result);
    MereMemo::log() &lt;&lt; Count(101) &lt;&lt; message;
    result = Util::isTextInFile(message, "application.log");
    CONFIRM_FALSE(result);
    MereMemo::log(Count(101)) &lt;&lt; message;
    result = Util::isTextInFile(message, "application.log");
    CONFIRM_TRUE(result);
}</pre>
			<p lang="en-GB">What’s new with this test? The main part is the way the <strong class="source-inline" lang="">Count</strong> tag is created. We previously only added a value when creating tags, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
Count(100)</pre>
			<p lang="en-GB">And because we now need <a id="_idIndexMarker413"/>a way to specify if something should have a relative value, we need a place to say what kind of relative value and a method to communicate which relative value to use. I think an enumeration of various relative comparisons should work. We probably don’t need more advanced relative comparisons such as <strong class="source-inline" lang="">"between"</strong> because we can always use DNF to express more elaborate comparisons. For a brief overview of how we’re using DNF, refer to the <em class="italic" lang="">Designing tests to filter log messages</em> section of <span class="No-Break" lang="">this chapter.</span></p>
			<p lang="en-GB">At the tag level, all we really need is to know how to compare one value against another. So, it makes sense to specify what type of comparison is needed when constructing a tag, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
Count(100, MereMemo::TagOperation::GreaterThan)</pre>
			<p lang="en-GB">It might make sense to treat a tag with a comparison operator such as <strong class="source-inline" lang="">GreaterThan</strong> as a completely different type, but I think we can get away with a single type. With this solution, any tag can have a comparison operator, but it only makes sense to specify comparison operators for tags that will be used <span class="No-Break" lang="">in filters.</span></p>
			<p lang="en-GB">What happens if a regular tag without a comparison operator is used in a filter? Then, we should treat that as an exact match because that’s what the existing <span class="No-Break" lang="">tests expect.</span></p>
			<p lang="en-GB">Back to the new test. It first creates a filter that should only let a message be logged if it has a count tag with a value greater than 100. It first tries to log a message with a count of only 1, and this is verified to not exist in the <span class="No-Break" lang="">log file.</span></p>
			<p lang="en-GB">Then, the test creates <a id="_idIndexMarker414"/>a count of 101 but does not use the count tag directly in the <strong class="source-inline" lang="">log</strong> function call. This also should not make it to the output log file because we only want to filter on tags that are either default or directly specified when <span class="No-Break" lang="">calling </span><span class="No-Break" lang=""><strong class="source-inline" lang="">log</strong></span><span class="No-Break" lang="">.</span></p>
			<p lang="en-GB">And finally, the test calls <strong class="source-inline" lang="">log</strong> with a count tag of 101, and this message is verified to appear in the <span class="No-Break" lang="">log file.</span></p>
			<p lang="en-GB">Now that we have a test, how will we get it working? Let’s define comparison operations first in <strong class="source-inline" lang="">Log.h</strong>, right before the <strong class="source-inline" lang="">TagType</strong> class, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
enum class TagOperation
{
    None,
    Equal,
    LessThan,
    LessThanOrEqual,
    GreaterThan,
    GreaterThanOrEqual
};</pre>
			<p lang="en-GB">We’ll use the <strong class="source-inline" lang="">None</strong> operation for regular tags that only want to express a value. The <strong class="source-inline" lang="">Equal</strong> operation will act like the existing equality checks between tags. And the real change is to support less than, less than or equal, greater than, and greater than or <span class="No-Break" lang="">equal comparisons.</span></p>
			<p lang="en-GB">We need to compare one tag with another without worrying about what the tags represent. A good way to do this is to declare a pure virtual method in the <strong class="source-inline" lang="">Tag</strong> class, just like what we did for cloning. The new method is called <strong class="source-inline" lang="">match</strong> and can go right after the <strong class="source-inline" lang="">clone</strong> method, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
    virtual std::unique_ptr&lt;Tag&gt; clone () const = 0;
    virtual bool match (Tag const &amp; other) const = 0;</pre>
			<p lang="en-GB">Here’s where things get a bit difficult. I had wanted to wrap everything up in the <strong class="source-inline" lang="">TagType</strong> class. The idea was to first check the key of each tag being compared and make sure that the tags were the same. If they have the same key, then check the value. If they don’t have the same key, then they must not match. At least, that was a good plan. I ran into problems <a id="_idIndexMarker415"/>when trying to implement the <strong class="source-inline" lang="">match</strong> method in one place that could compare strings with strings, numerics with numerics, and Booleans with Booleans. A tag such as <strong class="source-inline" lang="">CacheHit</strong> has a <strong class="source-inline" lang="">bool</strong> value type, and the only operation that makes sense is <strong class="source-inline" lang="">Equal</strong> comparisons. Tags based on strings need to compare differently than numerics. And if we really want to get elaborate, doubles should compare differently than an <span class="No-Break" lang=""><strong class="source-inline" lang="">int</strong></span><span class="No-Break" lang=""> type.</span></p>
			<p lang="en-GB">Each derived tag type could know how to compare, but I didn’t want to change the derived types and make them each implement the <strong class="source-inline" lang="">match</strong> method, especially after all the work we went through to avoid the derived types implementing <strong class="source-inline" lang="">clone</strong>. The best solution I came up with was to create an additional set of intermediate classes that derive from <strong class="source-inline" lang="">TagType</strong>. Each new class is based on the type of the value. Since we only support five different tag value types, this is not a bad solution. The main benefit is that the derived tag types that the caller will use are only slightly affected. Here’s a new <strong class="source-inline" lang="">StringTagType</strong> class that inherits from <strong class="source-inline" lang="">TagType</strong> so that you can see what I mean. Place this new class in <strong class="source-inline" lang="">Log.h</strong>, right after the <span class="No-Break" lang=""><strong class="source-inline" lang="">TagType</strong></span><span class="No-Break" lang=""> class:</span></p>
			<pre class="source-code" lang="en-GB">
template &lt;typename T&gt;
class StringTagType : public TagType&lt;T, std::string&gt;
{
protected:
    StringTagType (std::string const &amp; value,
        TagOperation operation)
    : TagType&lt;T, std::string&gt;(value, operation)
    { }
    bool compareTagTypes (std::string const &amp; value,
        TagOperation operation,
        std::string const &amp; criteria) const override
    {
        int result = value.compare(criteria);
        switch (operation)
        {
        case TagOperation::Equal:
            return result == 0;
        case TagOperation::LessThan:
            return result == -1;
        case TagOperation::LessThanOrEqual:
            return result == 0 || result == -1;
        case TagOperation::GreaterThan:
            return result == 1;
        case TagOperation::GreaterThanOrEqual:
            return result == 0 || result == 1;
        default:
            return false;
        }
    }
};</pre>
			<p lang="en-GB">This class is all about comparing string-based tags with other string-based tags. The class implements a new virtual method I’ll explain in just a moment, called <strong class="source-inline" lang="">compareTagTypes</strong>. The only thing this method has to worry about is how to compare two strings based on an operation. One of the strings is called <strong class="source-inline" lang="">value</strong> and the other is called <strong class="source-inline" lang="">criteria</strong>. It’s important to not mix up the <strong class="source-inline" lang="">value</strong> and <strong class="source-inline" lang="">criteria</strong> strings because, for<a id="_idIndexMarker416"/> example, while <strong class="source-inline" lang="">"ABC"</strong> is greater than <strong class="source-inline" lang="">"AAA"</strong>, the same is not true the other way around. The method uses the <strong class="source-inline" lang="">compare</strong> method in the <strong class="source-inline" lang="">std::string</strong> class to do <span class="No-Break" lang="">the comparisons.</span></p>
			<p lang="en-GB">You can see that the <strong class="source-inline" lang="">StringTagType</strong> class inherits from <strong class="source-inline" lang="">TagType</strong> and passes on the <strong class="source-inline" lang="">T</strong> derived type while hardcoding <strong class="source-inline" lang="">std::string</strong> for the value type. One interesting thing about the constructor is the need to repeat the template parameters when constructing <strong class="source-inline" lang="">TagType</strong> in the constructor initialization list. Normally, this should not be required, but maybe there is some arcane rule that only applies here that I’m not aware of whereby the compiler does not look at the <strong class="source-inline" lang="">TagType</strong> parameters in the parent class list to figure out the <span class="No-Break" lang="">template parameters.</span></p>
			<p lang="en-GB">Before moving on to the changes in <strong class="source-inline" lang="">TagType</strong>, let’s look at how a derived tag class such as <strong class="source-inline" lang="">LogLevel</strong> will use the new <strong class="source-inline" lang="">StringTagType</strong> intermediate class. Change the <strong class="source-inline" lang="">LogLevel</strong> class to look <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
class LogLevel : public StringTagType&lt;LogLevel&gt;
{
public:
    static constexpr char key[] = "log_level";
    LogLevel (std::string const &amp; value,
        TagOperation operation = TagOperation::None)
    : StringTagType(value, operation)
    { }
};</pre>
			<p lang="en-GB">The only change needed for <strong class="source-inline" lang="">LogLevel</strong> is to change the parent class from <strong class="source-inline" lang="">TagType</strong> to the more specific <strong class="source-inline" lang="">StringTagType</strong>. We no longer need to worry about specifying <strong class="source-inline" lang="">std::string</strong> as a template parameter because that information is built into the <strong class="source-inline" lang="">StringTagType</strong> class. I <a id="_idIndexMarker417"/>had wanted to keep the derived tag classes completely unchanged, but this slight modification is not so bad because there is no need to write any <span class="No-Break" lang="">comparison code.</span></p>
			<p lang="en-GB">There is more work to be done in the <strong class="source-inline" lang="">TagType</strong> class. In the protected section at the end of the <strong class="source-inline" lang="">TagType</strong> class, make <span class="No-Break" lang="">these changes:</span></p>
			<pre class="source-code" lang="en-GB">
protected:
    TagType (ValueT const &amp; value,
        TagOperation operation)
    : Tag(T::key, value), mValue(value), mOperation(operation)
    { }
    virtual bool compareTagTypes (ValueT const &amp; value,
        TagOperation operation,
        ValueT const &amp; criteria) const
    {
        return false;
    }
    ValueT mValue;
    TagOperation mOperation;
};</pre>
			<p lang="en-GB">The protected constructor needs to store the operation, and this is where the virtual <strong class="source-inline" lang="">compareTagTypes</strong> method is <a id="_idIndexMarker418"/>declared and given a default implementation that returns <strong class="source-inline" lang="">false</strong>. The <strong class="source-inline" lang="">TagType</strong> class also implements the <strong class="source-inline" lang="">match</strong> method that was declared in the <strong class="source-inline" lang="">Tag</strong> class, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
    bool match (Tag const &amp; other) const override
    {
        if (key() != other.key())
        {
            return false;
        }
        TagType const &amp; otherCast =                 static_cast&lt;TagType const &amp;&gt;(other);
        if (mOperation == TagOperation::None)
        {
            switch (otherCast.mOperation)
            {
            case TagOperation::None:
                return mValue == otherCast.mValue;
            default:
                return compareTagTypes(mValue,
                    otherCast.mOperation,
                    otherCast.mValue);
            }
        }
        switch (otherCast.mOperation)
        {
        case TagOperation::None:
            return compareTagTypes(otherCast.mValue,
                mOperation,
                mValue);
        default:
            return false;
        }
    }</pre>
			<p lang="en-GB">The <strong class="source-inline" lang="">match</strong> method first checks the keys to see whether the two tags being compared have the same key. If the keys match, then the types are assumed to be the same and the other tag is cast to the <span class="No-Break" lang="">same </span><span class="No-Break" lang=""><strong class="source-inline" lang="">TagType</strong></span><span class="No-Break" lang="">.</span></p>
			<p lang="en-GB">We have a couple of scenarios to figure out. At least one of the tags should be a normal tag without an operation and is the tag we’ll call the value. The other tag can also be a regular tag without an operation, in which case all we need to do is compare the two values <span class="No-Break" lang="">for equality.</span></p>
			<p lang="en-GB">If one of the two tags is <a id="_idIndexMarker419"/>normal and the other has a comparison operation other than <strong class="source-inline" lang="">None</strong>, then the tag with the comparison operator set is treated as the criteria. Remember that it’s important to know which is the value and which is the criteria. The code needs to handle the case where we are comparing a value with a criterion or the case where we are comparing a criterion with a value. We call into the virtual <strong class="source-inline" lang="">compareTagTypes</strong> method to do the actual comparison, making sure to pass <strong class="source-inline" lang="">mValue</strong> and <strong class="source-inline" lang="">otherCast.mValue</strong> according to which is the normal tag and which is <span class="No-Break" lang="">the criteria.</span></p>
			<p lang="en-GB">And finally, if both tags have the comparison operator set to something other than <strong class="source-inline" lang="">None</strong>, then we treat the match as <strong class="source-inline" lang="">false</strong> because it doesn’t make sense to compare two criteria tags against <span class="No-Break" lang="">each other.</span></p>
			<p lang="en-GB">There’s a bit of complexity wrapped up in the <strong class="source-inline" lang="">match</strong> method that I wanted to implement in only one spot. This is why I decided to keep the <strong class="source-inline" lang="">TagType</strong> class and create value type-specific intermediate classes such as <strong class="source-inline" lang="">StringTagType</strong>. The <strong class="source-inline" lang="">TagType</strong> class implements part of the comparison by figuring out what is being compared with what and then relies on the type-specific classes to do the <span class="No-Break" lang="">actual comparison.</span></p>
			<p lang="en-GB">We need to add other type-specific intermediate tag classes. All of these go in <strong class="source-inline" lang="">Log.h</strong>, right after the <strong class="source-inline" lang="">StringTagType</strong> class. Here is the one for the <span class="No-Break" lang=""><strong class="source-inline" lang="">int</strong></span><span class="No-Break" lang=""> type:</span></p>
			<pre class="source-code" lang="en-GB">
template &lt;typename T&gt;
class IntTagType : public TagType&lt;T, int&gt;
{
protected:
    IntTagType (int const &amp; value,
        TagOperation operation)
    : TagType&lt;T, int&gt;(value, operation)
    { }
    bool compareTagTypes (int const &amp; value,
        TagOperation operation,
        int const &amp; criteria) const override
    {
        switch (operation)
        {
        case TagOperation::Equal:
            return value == criteria;
        case TagOperation::LessThan:
            return value &lt; criteria;
        case TagOperation::LessThanOrEqual:
            return value &lt;= criteria;
        case TagOperation::GreaterThan:
            return value &gt; criteria;
        case TagOperation::GreaterThanOrEqual:
            return value &gt;= criteria;
        default:
            return false;
        }
    }
};</pre>
			<p lang="en-GB">This class is almost identical to the <strong class="source-inline" lang="">StringTagType</strong> class with changes designed for an <strong class="source-inline" lang="">int</strong> type instead of a string. Mainly, the comparisons can be done with simple arithmetic operators instead of calling the string <span class="No-Break" lang=""><strong class="source-inline" lang="">compare</strong></span><span class="No-Break" lang=""> method.</span></p>
			<p lang="en-GB">I thought about using this class for all the <strong class="source-inline" lang="">int</strong>, <strong class="source-inline" lang="">long long</strong>, and <strong class="source-inline" lang="">double</strong> arithmetic types, but that would have meant it would still need a template parameter for the actual type. Then, the question becomes one of consistency. Should the <strong class="source-inline" lang="">StringTagType</strong> class also have a template parameter to specify the type of string? Maybe. There are different kinds of strings so that almost makes sense. But what about the <strong class="source-inline" lang="">bool</strong> type? We’ll need an intermediate class for Booleans too, and it seems strange to specify a <strong class="source-inline" lang="">bool</strong> template<a id="_idIndexMarker420"/> type when the class name will already have <strong class="source-inline" lang="">bool</strong> in it. So, to make everything consistent, I decided to go with separate intermediate classes for all the supported types. We’ll handle ints with the <strong class="source-inline" lang="">IntTagType</strong> class and create another class called <strong class="source-inline" lang="">LongLongTagType</strong>, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
template &lt;typename T&gt;
class LongLongTagType : public TagType&lt;T, long long&gt;
{
protected:
    LongLongTagType (long long const &amp; value,
        TagOperation operation)
    : TagType&lt;T, long long&gt;(value, operation)
    { }
    bool compareTagTypes (long long const &amp; value,
        TagOperation operation,
        long long const &amp; criteria) const override
    {
        switch (operation)
        {
        case TagOperation::Equal:
            return value == criteria;
        case TagOperation::LessThan:
            return value &lt; criteria;
        case TagOperation::LessThanOrEqual:
            return value &lt;= criteria;
        case TagOperation::GreaterThan:
            return value &gt; criteria;
        case TagOperation::GreaterThanOrEqual:
            return value &gt;= criteria;
        default:
            return false;
        }
    }
};</pre>
			<p lang="en-GB">This is the class I am not very happy about because it duplicates exactly the implementation for ints. But<a id="_idIndexMarker421"/> the one thing I am happy about is the consistency it creates. It means that all the intermediate tag-type classes can be used the <span class="No-Break" lang="">same way.</span></p>
			<p lang="en-GB">The next class is for doubles, and while it also has the same implementation, there is the potential to compare doubles differently because they don’t compare like the integral types. There is always a little room for errors and slight discrepancies between floating-point values. For now, we’re not going to do anything different about doubles, but this class will give us the ability to compare them differently if needed. The class looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
template &lt;typename T&gt;
class DoubleTagType : public TagType&lt;T, double&gt;
{
protected:
    DoubleTagType (double const &amp; value,
        TagOperation operation)
    : TagType&lt;T, double&gt;(value, operation)
    { }
    bool compareTagTypes (double const &amp; value,
        TagOperation operation,
        double const &amp; criteria) const override
    {
        switch (operation)
        {
        case TagOperation::Equal:
            return value == criteria;
        case TagOperation::LessThan:
            return value &lt; criteria;
        case TagOperation::LessThanOrEqual:
            return value &lt;= criteria;
        case TagOperation::GreaterThan:
            return value &gt; criteria;
        case TagOperation::GreaterThanOrEqual:
            return value &gt;= criteria;
        default:
            return false;
        }
    }
};</pre>
			<p lang="en-GB">The last intermediate<a id="_idIndexMarker422"/> tag type class is for Booleans, and it does need to do something different. This class is really only interested in equality and looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
template &lt;typename T&gt;
class BoolTagType : public TagType&lt;T, bool&gt;
{
protected:
    BoolTagType (bool const &amp; value,
        TagOperation operation)
    : TagType&lt;T, bool&gt;(value, operation)
    { }
    bool compareTagTypes (bool const &amp; value,
        TagOperation operation,
        bool const &amp; criteria) const override
    {
        switch (operation)
        {
        case TagOperation::Equal:
            return value == criteria;
        default:
            return false;
        }
    }
};</pre>
			<p lang="en-GB">Now that we have all the <a id="_idIndexMarker423"/>tags worked out, the place where comparison needs to be made is in the <strong class="source-inline" lang="">log</strong> function, which currently uses the text of the tags to compare the normal and inverted tags. Change the <strong class="source-inline" lang="">normal</strong> block to look <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
        for (auto const &amp; normal: clause.second.normalLiterals)
        {
            // We need to make sure that the tag is
            // present and with the correct value.
            if (not activeTags.contains(normal-&gt;key()))
            {
                allLiteralsMatch = false;
                break;
            }
            if (not activeTags[normal-&gt;key()]-&gt;match(*normal))
            {
                allLiteralsMatch = false;
                break;
            }
        }</pre>
			<p lang="en-GB">The code still loops through the tags and checks for the existence of the keys involved. Once it finds that the tags exist and need to be compared, instead of getting the text of each tag and comparing for<a id="_idIndexMarker424"/> equality, the code now calls the <span class="No-Break" lang=""><strong class="source-inline" lang="">match</strong></span><span class="No-Break" lang=""> method.</span></p>
			<p lang="en-GB">The inverted block needs to change in a similar manner, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
        for (auto const &amp; inverted:             clause.second.invertedLiterals)
        {
            // We need to make sure that the tag is either
            // not present or has a mismatched value.
            if (activeTags.contains(inverted-&gt;key()))
            {
                if (activeTags[inverted-&gt;key()]-&gt;match(                   *inverted))
                {
                    allLiteralsMatch = false;
                }
                break;
            }
        }</pre>
			<p lang="en-GB">For the inverted loop, I was able to simplify the code a little. The real change is similar to the normal loop where the <strong class="source-inline" lang="">match</strong> method is called to make the comparison instead of directly comparing the <span class="No-Break" lang="">tag text.</span></p>
			<p lang="en-GB">Before we can build and try out the new test, we need to update the other derived tag types in the test application. Just like how we needed to update the <strong class="source-inline" lang="">LogLevel</strong> tag class to use the new intermediate tag class, we need to change all the tag classes in <strong class="source-inline" lang="">LogTags.h</strong>. The first is the <strong class="source-inline" lang="">Color</strong> class, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
class Color : public MereMemo::StringTagType&lt;Color&gt;
{
public:
    static constexpr char key[] = "color";
    Color (std::string const &amp; value,
        MereMemo::TagOperation operation =
            MereMemo::TagOperation::None)
    : StringTagType(value, operation)
    { }
};</pre>
			<p lang="en-GB">The <strong class="source-inline" lang="">Color</strong> class is based on a string value type, just <span class="No-Break" lang="">like </span><span class="No-Break" lang=""><strong class="source-inline" lang="">LogLevel</strong></span><span class="No-Break" lang="">.</span></p>
			<p lang="en-GB">The <strong class="source-inline" lang="">Size</strong> tag type also uses a string and looks like <span class="No-Break" lang="">this now:</span></p>
			<pre class="source-code" lang="en-GB">
class Size : public MereMemo::StringTagType&lt;Size&gt;
{
public:
    static constexpr char key[] = "size";
    Size (std::string const &amp; value,
        MereMemo::TagOperation operation =
            MereMemo::TagOperation::None)
    : StringTagType(value, operation)
    { }
};</pre>
			<p lang="en-GB">The <strong class="source-inline" lang="">Count</strong> and <strong class="source-inline" lang="">Identity</strong> tag types are based on an <strong class="source-inline" lang="">int</strong> type and a <strong class="source-inline" lang="">long long</strong> type respectively, and they<a id="_idIndexMarker425"/> look <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
class Count : public MereMemo::IntTagType&lt;Count&gt;
{
public:
    static constexpr char key[] = "count";
    Count (int value,
        MereMemo::TagOperation operation =
            MereMemo::TagOperation::None)
    : IntTagType(value, operation)
    { }
};
class Identity : public MereMemo::LongLongTagType&lt;Identity&gt;
{
public:
    static constexpr char key[] = "id";
    Identity (long long value,
        MereMemo::TagOperation operation =
            MereMemo::TagOperation::None)
    : LongLongTagType(value, operation)
    { }
};</pre>
			<p lang="en-GB">And finally, the <strong class="source-inline" lang="">Scale</strong> and <strong class="source-inline" lang="">CacheHit</strong> tag types are based on a <strong class="source-inline" lang="">double</strong> type and a <strong class="source-inline" lang="">bool</strong> type, and look <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
class Scale : public MereMemo::DoubleTagType&lt;Scale&gt;
{
public:
    static constexpr char key[] = "scale";
    Scale (double value,
        MereMemo::TagOperation operation =
            MereMemo::TagOperation::None)
    : DoubleTagType(value, operation)
    { }
};
class CacheHit : public MereMemo::BoolTagType&lt;CacheHit&gt;
{
public:
    static constexpr char key[] = "cache_hit";
    CacheHit (bool value,
        MereMemo::TagOperation operation =
            MereMemo::TagOperation::None)
    : BoolTagType(value, operation)
    { }
};</pre>
			<p lang="en-GB">The changes to each tag type<a id="_idIndexMarker426"/> were minimal. I think this is acceptable, especially because the tests that use the tag types don’t need to change. Let’s take another look at the test that started <span class="No-Break" lang="">this section:</span></p>
			<pre class="source-code" lang="en-GB">
TEST("Tag values can be used to filter messages")
{
    MereTDD::SetupAndTeardown&lt;TempFilterClause&gt; filter;
    MereMemo::addFilterLiteral(filter.id(),
        Count(100, MereMemo::TagOperation::GreaterThan));
    std::string message = "values ";
    message += Util::randomString();
    MereMemo::log(Count(1)) &lt;&lt; message;
    bool result = Util::isTextInFile(message,          "application.log");
    CONFIRM_FALSE(result);
    MereMemo::log() &lt;&lt; Count(101) &lt;&lt; message;
    result = Util::isTextInFile(message, "application.log");
    CONFIRM_FALSE(result);
    MereMemo::log(Count(101)) &lt;&lt; message;
    result = Util::isTextInFile(message, "application.log");
    CONFIRM_TRUE(result);
}</pre>
			<p lang="en-GB">This test should make more sense now. It creates a <strong class="source-inline" lang="">Count</strong> tag with a value of <strong class="source-inline" lang="">100</strong> and a <strong class="source-inline" lang="">TagOperation</strong> tag of <strong class="source-inline" lang="">GreaterThan</strong>. The operation is what makes this tag into a criteria tag that can be compared with other instances of the <strong class="source-inline" lang="">Count</strong> tag to see if the count in the other instance is really greater than 100 <span class="No-Break" lang="">or not.</span></p>
			<p lang="en-GB">Then, the test tries to log<a id="_idIndexMarker427"/> with a normal <strong class="source-inline" lang="">Count</strong> tag with a value of <strong class="source-inline" lang="">1</strong>. We know now how this will fail the match, and the log message will <span class="No-Break" lang="">be ignored.</span></p>
			<p lang="en-GB">The test then tries to log with a <strong class="source-inline" lang="">Count</strong> tag of <strong class="source-inline" lang="">101</strong>, but this time, the tag is outside of the <strong class="source-inline" lang="">log</strong> function and will not be considered. The second log message will also be ignored without ever trying to <span class="No-Break" lang="">call </span><span class="No-Break" lang=""><strong class="source-inline" lang="">match</strong></span><span class="No-Break" lang="">.</span></p>
			<p lang="en-GB">The test then tries to log with a count of <strong class="source-inline" lang="">101</strong> inside the <strong class="source-inline" lang="">log</strong> function. This one should match because 101 is indeed greater than 100, and the message should appear in the output <span class="No-Break" lang="">log file.</span></p>
			<p lang="en-GB">Notice how the test is structured. It starts out with a couple of known scenarios that should not succeed before finally moving on to a scenario that should succeed. This is a good pattern for you to follow when writing your tests and helps to confirm that everything is working <span class="No-Break" lang="">as designed.</span></p>
			<p lang="en-GB">The filtering is now working completely even with relative comparisons! The rest of this chapter will provide insights and advice to help you design <span class="No-Break" lang="">better tests.</span></p>
			<h1 id="_idParaDest-103" lang="en-GB"><a id="_idTextAnchor108"/>When is testing too much?</h1>
			<p lang="en-GB">I remember a story I heard once about a child that was in a hospital in intensive care and was connected to all the monitoring machines, including one that watched the heartbeat electrical signals. The child’s condition took a sudden turn for the worse and showed all the signs <a id="_idIndexMarker428"/>of a lack of blood flow to the brain. The doctors couldn’t figure out why because the heart was beating, and they were about to send the child for a scan to look for a blood clot that would cause a stroke when one doctor thought to listen for a heartbeat. There was none. The machine showed that the heart was beating but there was no sound to confirm the beat. The doctors were able to determine that swelling around the heart was putting pressure on the heart and preventing it from beating. I don’t know how, but they reduced the swelling and the child’s heart started <span class="No-Break" lang="">pumping again.</span></p>
			<p lang="en-GB">Why does this story come to mind? Because the machine that monitored heart activity was looking for electrical signals. In normal circumstances, the presence of proper electrical signals is a great way to monitor heart activity. But it’s indirect. Electrical signals are <em class="italic" lang="">how</em> the heart beats. The signals cause the heart to beat, but as the story shows, they don’t always mean <em class="italic" lang="">that</em> the heart <span class="No-Break" lang="">is beating.</span></p>
			<p lang="en-GB">It’s easy to fall into the same trap with software testing. We think that because we have a lot of tests, the software must be well-tested. But are the tests really testing the right things? In other words, is each test looking for tangible results? Or are some tests instead looking at how the results would normally <span class="No-Break" lang="">be obtained?</span></p>
			<p lang="en-GB">When is testing too much? My answer is that testing is good, and every test that you can add will normally help to improve the quality of the software. Testing can become too much if it starts looking at the <span class="No-Break" lang="">wrong things.</span></p>
			<p lang="en-GB">It’s not that a test that is looking at the wrong thing is bad. The bad part comes when we rely on that test to predict some outcome. It’s much better to directly confirm the desired outcome than it is to confirm some internal step along <span class="No-Break" lang="">the way.</span></p>
			<p lang="en-GB">For example, have a look at a recent test that added a <span class="No-Break" lang=""><strong class="source-inline" lang="">filter</strong></span><span class="No-Break" lang=""> literal:</span></p>
			<pre class="source-code" lang="en-GB">
TEST("Tag values can be used to filter messages")
{
    MereTDD::SetupAndTeardown&lt;TempFilterClause&gt; filter;
    MereMemo::addFilterLiteral(filter.id(),
        Count(100, MereMemo::TagOperation::GreaterThan));</pre>
			<p lang="en-GB">We could have verified that a filter was indeed added to the collection. We have access to call the <strong class="source-inline" lang="">getFilterClauses</strong> function from within the test and examine each clause and look for the literal just added. We could even confirm that the literal itself behaves as expected and has the value <strong class="source-inline" lang="">100</strong> assigned to <span class="No-Break" lang="">the literal.</span></p>
			<p lang="en-GB">The test doesn’t do this. Why? Because that is how filters work. Looking for a filter in the collection would be like watching heartbeat electrical signals. The ability to call <strong class="source-inline" lang="">getFilterClauses</strong> is a detail that exists just because of our desire to keep the logging library contained in a<a id="_idIndexMarker429"/> single header file. The function is not intended to be called by customers. The test instead looks at the results of setting <span class="No-Break" lang="">the filter.</span></p>
			<p lang="en-GB">Once the filter is set, the test tries to log a few messages and makes sure that the results match <span class="No-Break" lang="">the expectations.</span></p>
			<p lang="en-GB">What if the logging library needed some type of custom collection? Would it make sense to test that the filter literal was properly added to the collection then? Again, my answer is no, at least not here in the <span class="No-Break" lang="">filter test.</span></p>
			<p lang="en-GB">If the project needed a custom collection, then it would need tests to make sure that the collection works. I’m not saying to skip the tests for any code that needs to be written just because that code serves a supporting role within a project. What I am saying is to keep the tests focused on what they are testing. What is the desired outcome that the test is looking to confirm? In the case of the filters test, the desired outcome is that some log messages will be ignored while others will appear in the output log file. The test directly sets up the conditions needed to confirm the outcome, causes the needed steps to be run, and confirms the outcome. Along the way, the collection and all the matching code will be tested too in an <span class="No-Break" lang="">indirect manner.</span></p>
			<p lang="en-GB">If we have a custom collection involved, then indirect testing is not enough. But direct testing inside the filter test is also not appropriate. What we need is a set of tests designed to directly test the custom <span class="No-Break" lang="">collection itself.</span></p>
			<p lang="en-GB">So, if we have a need for a supporting component such as a custom collection, then that component needs to be tested by itself. The tests can be included in the same overall test application. Maybe put them into their own test suite. Think about the code that will be using the component as a customer of the component and think about the <span class="No-Break" lang="">customer’s needs.</span></p>
			<p lang="en-GB">If the component is big enough or serves a more general purpose so that it might be useful outside of the project, then giving it a project on its own is a good idea. This is what we’re doing in this book by treating the unit test library and the logging library as <span class="No-Break" lang="">separate projects.</span></p>
			<p lang="en-GB">One final thought about when testing is too much will help you to identify when you are in this situation because it can be easy to slide into too much indirect testing. If you find that you need to change a lot of tests after refactoring how your software works, then you could be testing <span class="No-Break" lang="">too much.</span></p>
			<p lang="en-GB">Think about how this chapter added filters and was able to keep the existing tests almost entirely unchanged. Sure—we had to change the code underneath by adding a whole set of intermediate tag-type classes, but we did not have to rewrite the <span class="No-Break" lang="">existing tests.</span></p>
			<p lang="en-GB">If a refactor causes the tests<a id="_idIndexMarker430"/> to also need a lot of work, then either you are testing too much or the problem could be that you are changing the desired usage of the software. Be careful of changing how you want your design to be used, because if you are following TDD, then that initial usage is one of the first things you want to get right. Once you have the software designed in a way that makes it easy and intuitive to use, then be extra cautious about any refactoring that would cause changes to <span class="No-Break" lang="">the test.</span></p>
			<p lang="en-GB">The next section explains a topic related to this section. Once you know what needs to be tested, a question that often comes up next is how to design software to make it easy to be tested, and specifically, if the tests need to reach inside the inner workings of the components <span class="No-Break" lang="">being tested.</span></p>
			<h1 id="_idParaDest-104" lang="en-GB"><a id="_idTextAnchor109"/>How intrusive should tests be?</h1>
			<p lang="en-GB">There is a benefit to designing software that is easy to test. To me, this starts by following TDD and writing tests first that make use of the software as the customer would most expect it to be used. This is the most <span class="No-Break" lang="">important consideration.</span></p>
			<p lang="en-GB">You don’t want to make the user of your software question why extra steps are needed or why it is difficult to understand how to use your software. And by customer or user, I mean anybody that will use your software. A customer or user could be another software developer who needs to use a library that is being designed. The tests are a great example of what a user must go through. If there is an extra step that a user must take that provides no value to the user, then that step should be removed, even if the step makes it easier to test <span class="No-Break" lang="">the code.</span></p>
			<p lang="en-GB">Maybe the extra step can be hidden from the user, and if so, then it might make sense to keep it as long as it makes the testing better. Anytime a test relies on something extra that the user doesn’t need or know about, then the test is intruding on the <span class="No-Break" lang="">software design.</span></p>
			<p lang="en-GB">I’m not saying this is a bad thing. Intrusion often has a negative meaning. It can be good for a test to be able to reach inside a component as long as you are aware that this makes it easy to fall into the trap that the previous section describes: too <span class="No-Break" lang="">much testing.</span></p>
			<p lang="en-GB">The main thing to understand is that anything that a test uses should become part of a supported interface. If a component exposes an inner working so that it can be confirmed by a test, then this inner working should be accepted as part of the design and not some internal <a id="_idIndexMarker431"/>detail that is subject to change at <span class="No-Break" lang="">any time.</span></p>
			<p lang="en-GB">The difference between what this section describes and the previous section comes down to what is agreed to be supported. We get into too much testing when we try to test things that either should be tested someplace else or that are internal details and should be off-limits to testing. If there’s an internal detail that is stable and agreed should not change, and if that internal detail makes testing more reliable, then it might make sense for a test to use <span class="No-Break" lang="">the detail.</span></p>
			<p lang="en-GB">I remember one project I worked on many years ago<a id="_idIndexMarker432"/> that exposed the internal state of classes through <strong class="bold" lang="">Extensible Markup Language</strong> (<strong class="bold" lang="">XML</strong>). The state could be quite complicated at times, and using XML let the tests confirm that the state was configured correctly. The XML would then be passed to other classes that would make use of it. The user was not aware of the XML and did not need to use it, but the tests relied on it to break complicated scenarios in half. One half of the test could make sure that the configuration was correct by verifying the XML matched. The other half could then make sure that the actions taken worked properly when supplied with known XML <span class="No-Break" lang="">input data.</span></p>
			<p lang="en-GB">The software did not have to be designed like this to use XML. It could even be said that the tests intruded on the design. The XML became a supported part of the design. What could have been just a detail became something more. But I would go further and say that the use of XML in this case never started out as a detail. It was a conscious design decision that was added for the specific reason of making the testing <span class="No-Break" lang="">more reliable.</span></p>
			<p lang="en-GB">So far, we’ve only explored unit tests. That’s why this book starts out by building a unit test library. When considering what should be tested and how intrusive the tests should be, there are other types of tests that the next section will <span class="No-Break" lang="">begin explaining.</span></p>
			<h1 id="_idParaDest-105" lang="en-GB"><a id="_idTextAnchor110"/>Where do integration or system tests go in TDD?</h1>
			<p lang="en-GB">Sometimes, it’s good to create a test that brings together multiple components and confirms that the overall system being built works as expected. These are called integration tests because they integrate multiple components to make sure they work well together. Or, the tests can be<a id="_idIndexMarker433"/> called system tests because they test the entire system. The two names are mostly interchangeable with <span class="No-Break" lang="">each other.</span></p>
			<p lang="en-GB">For our microservice developer who is the target customer of the logging library, there will likely be unit tests for an<a id="_idIndexMarker434"/> individual service, and even unit tests for various classes and functions inside the service. Some of the tests for a particular service might even be called integration tests, but usually, an integration test will be working with multiple services. The services should work together to accomplish something bigger. So, having tests that make sure the overall results can be reached will help improve the reliability and quality of all the <span class="No-Break" lang="">services involved.</span></p>
			<p lang="en-GB">What if you’re not building a set of microservices? What if you’re building a desktop application to manage a cryptocurrency wallet? You can still make use of system tests. Maybe you want a system test that opens a new wallet and makes sure it can synchronize the blockchain data up to the current block, or maybe you want another system test that stops the synchronization and then resumes it again. Each of these tests will make use of many different components such as classes and functions in the application. System tests make sure that some higher-level goal can be accomplished and, more importantly, system tests use real data that is downloaded over <span class="No-Break" lang="">the network.</span></p>
			<p lang="en-GB">It’s common for a system test to take a long time to complete. Add in multiple system tests, and the entire set of tests might need several hours to run. Or, maybe there are tests that continuously use the software for a day <span class="No-Break" lang="">or more.</span></p>
			<p lang="en-GB">Whether or not a particular test is called a unit test or a system test often comes down to how long it takes to run and which resources are needed. Unit tests tend to be quick and are able to determine whether something passes without needing to rely on other external factors or components. If a test needs to request information from another service, then that’s a good sign that the test is more of an integration test instead of a unit test. A unit test should never need to download data from <span class="No-Break" lang="">a network.</span></p>
			<p lang="en-GB">When it comes to TDD, in order for a test to actually drive the design—as the name implies—then the test will normally be of the unit test variety. Don’t get me wrong—system tests are important and can help uncover strange usage patterns that can be missed by unit tests. But the typical system test or integration test is not intended to make sure that the design is easy to use and intuitive. Instead, a system test makes sure that a higher-level goal can be reached and that nothing breaks the <span class="No-Break" lang="">ultimate goals.</span></p>
			<p lang="en-GB">If there’s any difference between system tests and integration tests, then in my mind, it comes down to integration tests being all about making sure that multiple components work well together, while a <a id="_idIndexMarker435"/>system test is more about the higher-level goals. Both integration tests and <a id="_idIndexMarker436"/>system tests are at a higher level than <span class="No-Break" lang="">unit tests.</span></p>
			<p lang="en-GB">TDD makes more use of unit tests when creating the initial designs of small components and functions. And then, TDD makes use of system and integration tests to make sure that the overall solution makes sense and <span class="No-Break" lang="">works properly.</span></p>
			<p lang="en-GB">You can think of all the testing we are doing for the logging library as system tests for the unit test library. We’re making sure that the unit test library can actually help design <span class="No-Break" lang="">another project.</span></p>
			<p lang="en-GB">As for where to put system or integration tests, they normally belong in a different test project—something that can be run on its own. This could even be a script. If you put them in the same test project as the unit tests, then there needs to be some way to only run the unit tests when a quick response <span class="No-Break" lang="">is needed.</span></p>
			<p lang="en-GB">Other than system and integration tests, there are still more tests you’ll want to consider adding. The next section describes more types <span class="No-Break" lang="">of tests.</span></p>
			<h1 id="_idParaDest-106" lang="en-GB"><a id="_idTextAnchor111"/>What about other types of tests?</h1>
			<p lang="en-GB">There are still more types of tests to<a id="_idIndexMarker437"/> consider, such as performance testing, load testing, and penetration testing. You can even get into usability testing, upgrade testing, certification testing, continuous operation testing, and more, including types that I’ve probably never <span class="No-Break" lang="">heard of.</span></p>
			<p lang="en-GB">Each type of test has a purpose that is valuable to software development. Each type has its own process and steps, ways of running the test, and ways to <span class="No-Break" lang="">verify success.</span></p>
			<p lang="en-GB">A performance test might pick a specific scenario such as loading a large file and making sure that the operation can complete within a certain amount of time. If the test also checks to make sure that the operation completes by only using a certain amount of computer memory or CPU time, then it starts becoming more of a load test, in my opinion. And if the test makes sure that the end user doesn’t have to wait or is notified of a delay, then it starts becoming more of a <span class="No-Break" lang="">usability test.</span></p>
			<p lang="en-GB">The lines between the test types sometimes are not clear. The previous section already explained that system tests and integration tests are often the same thing, with a subtle distinction that often doesn’t matter. The same is true of other tests. For example, whether a particular test is a load test or a performance test often comes down to the intent. Is the test trying to make sure that an operation completes in a certain time? Who decides what time is good enough? Or, is the test trying to make sure that an operation can complete while other things are going on at the same time? Or, maybe for a test that loads a large file, a large file of several megabytes is used for performance testing because that is a typical large file that a customer might encounter, while a load test would try to load a file much larger. These are just <span class="No-Break" lang="">some ideas.</span></p>
			<p lang="en-GB">Penetration tests are a little different because they are normally created as part of an official security review. The whole software solution will be analyzed, lots of documents produced, and tests <a id="_idIndexMarker438"/>created. A penetration test is often trying to make sure that the software does not crash when malicious data is provided or when the system <span class="No-Break" lang="">is misused.</span></p>
			<p lang="en-GB">Other penetration tests will check for information disclosure. Is it possible to misuse the software so that an attacker gains knowledge that should have <span class="No-Break" lang="">remained confidential?</span></p>
			<p lang="en-GB">Even more important are penetration tests that catch data manipulation. A common example is students trying to change their grades, but this type of attack can be used to steal money or delete <span class="No-Break" lang="">critical information.</span></p>
			<p lang="en-GB">Elevation-of-privilege attacks are super important to prevent penetration testing because they let an attacker gain access that can lead to more attacks. When an attacker is able to take control of a remote server, this is an obvious elevation of privilege, but elevation of privilege can be used to gain any extra permissions or capabilities that an attacker would not <span class="No-Break" lang="">normally have.</span></p>
			<p lang="en-GB">Usability tests are more subjective and often involve customer interviews <span class="No-Break" lang="">or trials.</span></p>
			<p lang="en-GB">All of the various different types of tests are important, and my goal with this section is not to list or describe every type of test possible but to give you an idea of the types of testing available and which benefits different tests <span class="No-Break" lang="">can provide.</span></p>
			<p lang="en-GB">Software testing is not a question of which tests to use but where each type fits into the process. An entire book could be written about each of these test types, and many have been written. There’s a <a id="_idIndexMarker439"/>reason this book is so focused on unit testing: because unit tests are closest to the <span class="No-Break" lang="">TDD process.</span></p>
			<h1 id="_idParaDest-107" lang="en-GB"><a id="_idTextAnchor112"/>Summary</h1>
			<p lang="en-GB">The TDD process is much more important than the features added to the logging library in this chapter. We added log levels, tags, and filtering, and even refactored the design of the logging library. And while all of this is valuable, the most important thing to pay attention to is the <span class="No-Break" lang="">process involved.</span></p>
			<p lang="en-GB">The reason this chapter is so detailed is so that you can see all the decisions that went into the design and how tests were used to guide the entire process. You can apply this learning to your own projects. And if you also use the logging library, then that’s <span class="No-Break" lang="">a bonus.</span></p>
			<p lang="en-GB">You learned the importance of understanding the needs of the customer. A customer doesn’t have to be a person who walks into a store to buy something. A customer is the intended user of whatever software is being developed. This could even be another software developer or another team within your company. Understanding the needs of the intended user will let you write better tests that solve <span class="No-Break" lang="">those needs.</span></p>
			<p lang="en-GB">It’s very easy to write a function or design an interface that seems appropriate, only to find it difficult to use later. Writing the tests first helps to avoid usage problems. And you saw in this chapter a place where I still had to go back and change how a function worked because a test showed it to <span class="No-Break" lang="">be backward.</span></p>
			<p lang="en-GB">There was an extensive set of changes needed to support filtering log messages by value, and this chapter showed how to make changes while keeping the <span class="No-Break" lang="">tests unchanged.</span></p>
			<p lang="en-GB">One of the best ways to understand TDD is to use the process in a project. This chapter developed a lot of new code for the logging library to give you a front-row view into the process and gives you more than simple examples could <span class="No-Break" lang="">ever show.</span></p>
			<p lang="en-GB">The next chapter will explore dependencies and will extend the logging library to send log messages to more than a single log <span class="No-Break" lang="">file destination.</span></p>
		</div>
	</body></html>