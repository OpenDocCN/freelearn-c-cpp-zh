<html><head></head><body>
		<div><h1 id="_idParaDest-91" class="chapter-number" lang="en-GB"><a id="_idTextAnchor096"/>10</h1>
			<h1 id="_idParaDest-92" lang="en-GB"><a id="_idTextAnchor097"/>The TDD Process in Depth</h1>
			<p lang="en-GB">We’re going to add a lot of code to the logging library in this chapter, and while that’s good, it’s not the main purpose of the chapter.</p>
			<p lang="en-GB">This is a chapter about the <strong class="bold" lang="">test-driven development</strong> (<strong class="bold" lang="">TDD</strong>) process. Wasn’t <a href="B18567_03.xhtml#_idTextAnchor031"><em class="italic" lang="">Chapter 3</em></a> also about the TDD process? Yes, but think of the earlier chapter as an introduction. This chapter will explore the TDD process in detail with a lot more code.</p>
			<p lang="en-GB">You’ll get ideas for writing your own tests, how to figure out what’s important, and how to refactor code without rewriting tests too, and you’ll also learn when testing is too much and learn about many different types of tests.</p>
			<p lang="en-GB">The basic TDD process remains as follows:</p>
			<ul>
				<li lang="en-GB">To write tests first that use the software in a natural and intuitive way</li>
				<li lang="en-GB">To get the code building with minimal changes even if we need to provide fake or stubbed-out implementations</li>
				<li lang="en-GB">To get basic scenarios working</li>
				<li lang="en-GB">To write more tests and enhance the design</li>
			</ul>
			<p lang="en-GB">Along the way, we’ll add log levels, tags, and filtering to the logging library.</p>
			<p lang="en-GB">Specifically, we’ll cover the following main topics in this chapter:</p>
			<ul>
				<li lang="en-GB">Finding gaps in the testing</li>
				<li lang="en-GB">Adding log levels</li>
				<li lang="en-GB">Adding default tag values</li>
				<li lang="en-GB">Exploring filtering options</li>
				<li lang="en-GB">Adding new tag types</li>
				<li lang="en-GB">Refactoring the tag design with TDD</li>
				<li lang="en-GB">Designing tests to filter log messages</li>
				<li lang="en-GB">Controlling what gets logged</li>
				<li lang="en-GB">Enhancing filtering for relative matches</li>
				<li lang="en-GB">When is testing too much?</li>
				<li lang="en-GB">How intrusive should tests be?</li>
				<li lang="en-GB">Where do integration or system tests go in TDD?</li>
				<li lang="en-GB">What about other types of tests?</li>
			</ul>
			<h1 id="_idParaDest-93" lang="en-GB"><a id="_idTextAnchor098"/>Technical requirements</h1>
			<p lang="en-GB">All code in this chapter uses standard C++ that builds on any modern C++ 20 or later compiler and standard library. The code uses the testing library from <em class="italic" lang="">Part 1</em> of this book, <em class="italic" lang="">Testing MVP</em>, and continues the development of a logging library started in the previous chapter.</p>
			<p lang="en-GB">You can find all the code for this chapter in the following GitHub repository:</p>
			<p lang="en-GB"><a href="https://github.com/PacktPublishing/Test-Driven-Development-with-CPP&#13;">https://github.com/PacktPublishing/Test-Driven-Development-with-CPP</a></p>
			<h1 id="_idParaDest-94" lang="en-GB"><a id="_idTextAnchor099"/>Finding gaps in the testing</h1>
			<p lang="en-GB">We really need more tests. Right<a id="_idIndexMarker329"/> now, we only have two logging tests: one for simple log messages and the other for more complicated log messages. The two tests look like this:</p>
			<pre class="source-code" lang="en-GB">
TEST("Simple message can be logged")
{
    std::string message = "simple ";
    message += Util::randomString();
    MereMemo::log() &lt;&lt; message &lt;&lt; " with more text.";
    bool result = Util::isTextInFile(message,     "application.log");
    CONFIRM_TRUE(result);
}
TEST("Complicated message can be logged")
{
    std::string message = "complicated ";
    message += Util::randomString();
    MereMemo::log() &lt;&lt; message
        &lt;&lt; " double=" &lt;&lt; 3.14
        &lt;&lt; " quoted=" &lt;&lt; std::quoted("in quotes");
    bool result = Util::isTextInFile(message,     "application.log");
    CONFIRM_TRUE(result);
}</pre>
			<p lang="en-GB">But is there a good way to find more tests? Let’s look at what we have so far. I like to start with simple tests. Can things be constructed?</p>
			<p lang="en-GB">That’s why the two tests we have so far are in a file called <code>Contruction.cpp</code>. This is a good place to start <a id="_idIndexMarker330"/>when looking for gaps in your testing. Do you have a simple test for each thing that you can construct? Normally, these will be classes. Write a test for each constructor of each class that your project provides.</p>
			<p lang="en-GB">For the logging library, we don’t have any classes yet. So instead, I created a simple test that calls the <code>log</code> function. Then, another test calls the same function in a slightly more complicated way.</p>
			<p lang="en-GB">There is an argument to be made that the complicated test duplicates some of the functionality of the simple test. I think what we have so far is okay, but it is something you should be aware of to avoid having a test that does everything another test does plus a little more. As long as a simple test represents a common use case, then it’s valuable to include it, even if another test might do something similar. In general, you want tests that will capture how your code will be used.</p>
			<p lang="en-GB">Other things to think about when looking for gaps in your testing can be found by looking for symmetry. If you have construction tests, maybe you should consider destruction tests. We don’t have anything like that for the logging library—at least, not yet—but it is something to consider. Another example of symmetry can be found later in this chapter. We’ll need to confirm that some text exists in a file. Why not include a similar test that makes sure some different text does <em class="italic" lang="">not</em> exist in the file?</p>
			<p lang="en-GB">Major features are a good source for tests. Think about which problems your code solves and write tests that exercise each feature or capability. For each feature, create a simple or common test, and then consider adding a more complicated test, some error tests that explore what can go wrong, and some tests that explore more purposeful misuses to make sure your code handles everything as expected. You’ll even see one example in the next section where a test is added just to make sure that it compiles.</p>
			<p lang="en-GB">This chapter will mostly explore tests for missing features. We’re just getting started with the logging library, so the majority of new tests will be based on new features. This is common for a new project <a id="_idIndexMarker331"/>and is a great way to let the tests drive the development.</p>
			<p lang="en-GB">The next section will add a new feature by first creating tests to define the feature.</p>
			<h1 id="_idParaDest-95" lang="en-GB"><a id="_idTextAnchor100"/>Adding log levels</h1>
			<p lang="en-GB">Logging libraries have a common idea of <em class="italic" lang="">log levels</em> that let you control how much information gets logged when <a id="_idIndexMarker332"/>an application is run. Let’s say you identify an error condition that needs a log message. This error should almost always be logged, but maybe there’s another place in the code where you decide that it might be useful to record what is happening. This other place is not always interesting, so it would be nice to avoid seeing those log messages all the time.</p>
			<p lang="en-GB">By having different log levels, you can decide how verbose your log files become. There are a couple of big problems with this approach. The first thing is simply defining what the log levels should be and what each should mean. Common log levels include errors, warnings, general informational messages, and debugging messages.</p>
			<p lang="en-GB">Errors tend to be easy to identify unless you also want to split them into normal errors and critical errors. What makes an error critical? Do you even need to tell the difference? In order to support as many different customers as possible, a lot of logging libraries provide different log levels and leave it up to the programmer to figure out what each level means.</p>
			<p lang="en-GB">The logging levels end up being used primarily to control how much information gets logged, which can help reduce the size of the log files when the application is running without any problems or complaints. This is a good thing but it leads to the next big problem. When something needs further investigation, the only way to get more information is to change the logging level, rerun the application, and hope to catch the issue again.</p>
			<p lang="en-GB">For large applications, changing the logging level to record more information can quickly cause so much extra information that it becomes difficult to find what you need. The additional log messages can also fill up storage drives and cause extra financial charges if the log files are sent to vendors for further processing. The debugging process is usually rushed so that the new logging level is in effect for a short period of time.</p>
			<p lang="en-GB">To get around the need to change the logging level for the entire application, a common practice is to temporarily change the level that specific parts of the code use when logging information. This requires that an application be rebuilt, deployed, and then put back once the problem is found.</p>
			<p lang="en-GB">How does all this discussion about logging levels help us design a logging library? We know who our target customer is: a microservice developer who will likely be working with large applications <a id="_idIndexMarker333"/>that can produce large log files. Thinking about what would help your customer the most is a great way to create a design.</p>
			<p lang="en-GB">We’re going to fix the two big problems identified. First, we’re not going to define any logging levels in the logging library. There will not be any notion of an error log message versus a debug log message. This doesn’t mean that there will be no way to control how much information will get logged, just that the whole idea of using log levels is fundamentally broken. The levels themselves are too confusing, and turning them on and off leads quickly to information overload and rushed debugging sessions.</p>
			<p lang="en-GB">The idea of adding extra information such as a log level to a log message is good. If we come up with a general-purpose solution that can work for log levels as well as other attached information, then we can let the user add whatever is needed and makes sense. We can provide the ability to add log levels without actually defining what those levels will be and what they mean.</p>
			<p lang="en-GB">So, the first part of the solution will be a general-purpose <em class="italic" lang="">tagging</em> system. This should avoid the confusion of fixed log levels that are defined by the library. We’ll still refer to the idea of a log level, but that’s only because the idea is so common. However, our log levels will be more like log-level tags because there won’t be any idea of one log level being above or below another log level.</p>
			<p lang="en-GB">The second part will need something new. The ability to control whether a message is logged or not based on the value of a log-level tag will just lead to the same problem as before. Turning a log level on will end up opening the logs everywhere and still lead to a flood of extra log messages. What we need is the ability to finely control what gets logged instead of turning extra logging on or off everywhere. We’ll need the ability to filter on more than just a log level.</p>
			<p lang="en-GB">Let’s take these two ideas one at a time. What would a general tagging system look like? Let’s write a test to find out! We should create a new file called <code>Tags.cpp</code> in the <code>tests</code> folder that looks like this:</p>
			<pre class="source-code" lang="en-GB">
#include "../Log.h"
#include "LogTags.h"
#include "Util.h"
#include &lt;MereTDD/Test.h&gt;
TEST("Message can be tagged in log")
{
    std::string message = "simple tag ";
    message += Util::randomString();
    MereMemo::log(error) &lt;&lt; message;
    std::string taggedMessage = " log_level=\"error\" ";
    taggedMessage += message;
    bool result = Util::isTextInFile(taggedMessage,          "application.log");
    CONFIRM_TRUE(result);
}</pre>
			<p lang="en-GB">The most important part of this test is the <code>log</code> function call. We want this to be easy to use and to quickly convey to<a id="_idIndexMarker334"/> anybody reading the code that a tag is involved. We don’t want the tag to get hidden in the message. It should stand out as different and at the same time not be awkward to use.</p>
			<p lang="en-GB">The confirmation is a little more complicated. We want the output in the log file to use a <code>key="value" </code>format. This means that there is some text followed by an equals sign and then more text inside quotation marks. This format will let us easily find tags by looking for something like this:</p>
			<pre class="source-code" lang="en-GB">
key="value"</pre>
			<p lang="en-GB">For the log level, we’ll expect the output to look like this:</p>
			<pre class="source-code" lang="en-GB">
log_level="error"</pre>
			<p lang="en-GB">We also want to avoid mistakes such as spelling or differences in capitalization. That’s why the syntax doesn’t use a string, which could be mistyped like this:</p>
			<pre class="source-code" lang="en-GB">
    MereMemo::log("Eror") &lt;&lt; message;</pre>
			<p lang="en-GB">By avoiding strings, we can get the compiler to help make sure that tags are consistent. Any mistake should result in a compilation error instead of a malformed tag in the log file.</p>
			<p lang="en-GB">And because the solution uses a function argument, we don’t need to provide special forms of <code>log</code> such as <code>logError</code>, <code>logInfo</code>, or <code>logDebug</code>. One of our goals was to avoid defining specific logging levels in the library itself and instead come up with something that will let the user decide what the log levels will be, just like any other tag.</p>
			<p lang="en-GB">This is also the reason for <a id="_idIndexMarker335"/>the extra include of <code>LogTags.h</code>, which is also a new file. This is where we will define which log levels we will use. We want the definition to be as simple as possible because the log library will not define these. The <code>LogTags.h</code> file should be placed in the <code>tests</code> folder and look like this:</p>
			<pre class="source-code" lang="en-GB">
#ifndef MEREMEMO_TESTS_LOGTAGS_H
#define MEREMEMO_TESTS_LOGTAGS_H
#include "../Log.h"
inline MereMemo::LogLevel error("error");
inline MereMemo::LogLevel info("info");
inline MereMemo::LogLevel debug("debug");
#endif // MEREMEMO_TESTS_LOGTAGS_H</pre>
			<p lang="en-GB">Just because the logging library doesn’t define its own logging levels doesn’t mean it can’t help with this common task. We can make use of a helper class that the library will define called <code>LogLevel</code>. We include <code>Log.h</code> in order to gain access to the <code>LogLevel</code> class so that we can define instances. Each instance should have a name such as <code>error</code> that we will use when logging. The constructor also needs a string to be used in the logging output. It’s probably a good idea to use a string that matches the name of the instance. So, for example, the error instance gets an <code>"</code><code>error"</code> string.</p>
			<p lang="en-GB">It’s these instances that get passed to the <code>log</code> function, like this:</p>
			<pre class="source-code" lang="en-GB">
    MereMemo::log(error) &lt;&lt; message;</pre>
			<p lang="en-GB">One thing to note is the namespace of the <code>LogLevel</code> instances. Because we’re testing the logging library itself, we’ll be calling <code>log</code> from within tests. Each test body is actually part of the <code>run</code> method of a test class defined with one of the <code>TEST</code> macros. The test class itself is in an unnamed namespace. I wanted to avoid needing to specify the <code>MereMemo</code> namespace when using one of the log levels, like this:</p>
			<pre class="source-code" lang="en-GB">
    MereMemo::log(MereMemo::error) &lt;&lt; message;</pre>
			<p lang="en-GB">It’s much easier to type just <code>error</code> instead of <code>MereMemo::error</code>. So, the solution (for now) is to declare the log-level instances in the global namespace inside <code>LogTags.h</code>. I recommend<a id="_idIndexMarker336"/> that when you define your own tags for your project, you declare the tags in your project’s namespace. Something like this would work:</p>
			<pre class="source-code" lang="en-GB">
#ifndef YOUR_PROJECT_LOGTAGS_H
#define YOUR_PROJECT_LOGTAGS_H
#include &lt;MereMemo/Log.h&gt;
namespace yourproject
{
inline MereMemo::LogLevel error("error");
inline MereMemo::LogLevel info("info");
inline MereMemo::LogLevel debug("debug");
} // namespace yourproject
#endif // YOUR_PROJECT_LOGTAGS_H</pre>
			<p lang="en-GB">Then, when you are writing your code in your project that is part of your own namespace, you can refer to the tags such as <code>error</code> directly without needing to specify a namespace. You can use whichever namespace you want in place of <code>yourproject</code>. You can see a good example of a project that uses both the logging library and the testing library in <a href="B18567_14.xhtml#_idTextAnchor139"><em class="italic" lang="">Chapter 14</em></a>, <em class="italic" lang="">How To </em><em class="italic" lang="">Test Services</em>.</p>
			<p lang="en-GB">Also, note that you should refer to the <code>Log.h</code> file from within your own project as a separate project and use angle brackets. This is just like what we did when we started work on the logging library and had to start referring to the unit test library include with angle brackets.</p>
			<p lang="en-GB">One extra benefit of passing an instance of <code>MereMemo::LogLevel</code> to the <code>log</code> function is that we no longer need to specify the namespace to the <code>log</code> function. The compiler knows to look in namespaces that function arguments use when trying to resolve the function name. The simple act of passing <code>error</code> to the <code>log</code> function lets the compiler figure out that the <code>log</code> function is the one defined in the same namespace as the <code>error</code> instance. I actually thought about this benefit once the code was working and I could try to call <code>log</code> without a namespace. I was then able to add a test to <code>Tags.cpp</code> that looks like this:</p>
			<pre class="source-code" lang="en-GB">
TEST("log needs no namespace when used with LogLevel")
{
    log(error) &lt;&lt; "no namespace";
}</pre>
			<p lang="en-GB">Here, you can see that we can call <code>log</code> directly without specifying the <code>MereMemo</code> namespace, and we can do this because the compiler knows that the <code>error</code> instance being passed is itself a member of <code>MereMemo</code>.</p>
			<p lang="en-GB">If we try to call <code>log</code> without any arguments, then we’ll need to go back to using <code>MereMemo::log</code> instead of just <code>log</code>.</p>
			<p lang="en-GB">Also, notice how this new test was identified. It’s an alternate usage that simplifies the code, and making a test helps make<a id="_idIndexMarker337"/> sure that we don’t do anything later that will break the simpler syntax. The new test has no confirmations either. That’s because the test exists just to make sure that the call to <code>log</code> without the namespace compiles. We already know that <code>log</code> can send a log message to the log file because the other test confirms this. This test doesn’t need to duplicate the confirmation. If it compiles, then it has done its job.</p>
			<p lang="en-GB">The only thing we need now is a definition of the <code>LogLevel</code> class. Remember that we really want a general-purpose tagging solution and that a log level should be just one type of tag. There shouldn’t be anything special about a log level versus any other tag. We might as well define a <code>Tag</code> class too and make <code>LogLevel</code> inherit from <code>Tag</code>. Put the two new classes at the beginning of <code>Log.h</code> just inside the <code>MereMemo</code> namespace, like this:</p>
			<pre class="source-code" lang="en-GB">
class Tag
{
public:
    virtual ~Tag () = default;
    std::string key () const
    {
        return mKey;
    }
    std::string text () const
    {
        return mText;
    }
protected:
    Tag (std::string const &amp; key, std::string const &amp; value)
    : mKey(key), mText(key + "=\"" + value + "\"")
    { }
private:
    std::string mKey;
    std::string const mText;
};
class LogLevel : public Tag
{
public:
    LogLevel (std::string const &amp; text)
    : Tag("log_level", text)
    { }
};</pre>
			<p lang="en-GB">Make sure both classes are defined inside the <code>MereMemo</code> namespace. Let’s start with the <code>Tag</code> class, which should not be used directly. The <code>Tag</code> class should be a base class so that a derived class can<a id="_idIndexMarker338"/> specify the key to be used. The purpose of the <code>Tag</code> class is really just to make sure that the text output follows the <code>key="value"</code> format.</p>
			<p lang="en-GB">The <code>LogLevel</code> class inherits from the <code>Tag</code> class and only requires the text of the log level. The key is hardcoded to always be <code>log_level</code>, which enforces consistency. We get the consistency of the values when we declare instances of <code>LogLevel</code> with specific strings and then use the defined instances when calling <code>log</code>.</p>
			<p lang="en-GB">The logging library supports tags and even log-level tags but doesn’t define any specific log levels itself. The library also doesn’t try to order the log levels so that something such as <code>error</code> is a higher or lower level than <code>debug</code>. Everything is just a tag consisting of a key and a value.</p>
			<p lang="en-GB">Now that we have the <code>LogLevel</code> and <code>Tag</code> classes, how are they used by the <code>log</code> function? We’ll first need a new overload of <code>log</code> that accepts a <code>Tag</code> parameter, like this:</p>
			<pre class="source-code" lang="en-GB">
inline std::fstream log (Tag const &amp; tag)
{
    return log(to_string(tag));
}</pre>
			<p lang="en-GB">Place this new <code>log</code> function right after the existing <code>log</code> function and still inside the <code>MereMemo</code> namespace in <code>Log.h</code>. The new <code>log</code> function will convert the tag into a string and pass the string to the existing <code>log</code> function. We’ll need to define a <code>to_string</code> function that can be placed right after the definition of the <code>Tag</code> class, like this:</p>
			<pre class="source-code" lang="en-GB">
inline std::string to_string (Tag const &amp; tag)
{
    return tag.text();
}</pre>
			<p lang="en-GB">The <code>to_string</code> function<a id="_idIndexMarker339"/> just calls the <code>text</code> method in the <code>Tag</code> class to get the string. Do we really need a function for this? Couldn’t we just call the text method directly from within the new overloaded <code>log</code> function? Yes, we could have, but it’s a common practice in C++ to provide a function called <code>to_string</code> that knows how to convert a class into a string.</p>
			<p lang="en-GB">All these new functions need to be declared inline because we’re going to keep the logging library as a single include file that another project can simply include to begin logging. We want to avoid declaring functions in the <code>Log.h</code> file and then implementing them inside a <code>Log.cpp</code> file because that would require users to add <code>Log.cpp</code> to their project, or it would require that the logging library be built as a library and then linked into the project. By keeping everything in a single header file, we make it easier for other projects to use the logging library. It’s not really a library—it’s just a header file that gets included. We’ll still refer to it as the logging library, though.</p>
			<p lang="en-GB">The existing <code>log</code> function needs to be modified to accept a string. It actually used to accept a string for the message to be logged until we removed that and returned a stream instead that the caller uses to specify the message along with any other information to be logged. We’re going to put a string parameter back in the <code>log</code> function and call it <code>preMessage</code>. The <code>log</code> function will still return a stream that the caller can use. The <code>preMessage</code> parameter will be used to pass the formatted tag, and the <code>log</code> function will output the <code>preMessage</code> before returning the stream for the caller to use for the other information to be logged. The modified <code>log</code> function looks like this:</p>
			<pre class="source-code" lang="en-GB">
inline std::fstream log (std::string_view preMessage = "")
{
    auto const now = std::chrono::system_clock::now();
    std::time_t const tmNow =          std::chrono::system_clock::to_time_t(now);
    auto const ms = duration_cast&lt;std::chrono::milliseconds&gt;(
        now.time_since_epoch()) % 1000;
    std::fstream logFile("application.log", std::ios::app);
    logFile &lt;&lt; std::endl
        &lt;&lt; std::put_time(std::gmtime(&amp;tmNow),            "%Y-%m-%dT%H:%M:%S.")
        &lt;&lt; std::setw(3) &lt;&lt; std::setfill('0')         &lt;&lt; std::to_string(ms.count())
        &lt;&lt; " " &lt;&lt; preMessage &lt;&lt; " ";
    return logFile;
}</pre>
			<p lang="en-GB">The <code>preMessage</code> parameter has a default value so that the <code>log</code> function can still be called without a log-level <a id="_idIndexMarker340"/>tag. All the <code>log</code> function does is send a timestamp, then the <code>preMessage</code> parameter to the stream, followed by a single space, before letting the caller have access to the returned stream.</p>
			<p lang="en-GB">Note that we still want the log-level tag to be separated from the timestamp with a space too. If there is no log level specified, then the output will have two spaces, which is a detail that will be fixed soon.</p>
			<p lang="en-GB">We have everything we need now to log with a log level that the new tests make use of:</p>
			<pre class="source-code" lang="en-GB">
    MereMemo::log(error) &lt;&lt; message;</pre>
			<p lang="en-GB">And building and running the project shows everything passes:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">Running 1 test suites</strong>
<strong class="bold" lang="">--------------- Suite: Single Tests</strong>
<strong class="bold" lang="">------- Test: Message can be tagged in log</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: log needs no namespace when used with LogLevel</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Simple message can be logged</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Complicated message can be logged</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">-----------------------------------</strong>
<strong class="bold" lang="">Tests passed: 4</strong>
<strong class="bold" lang="">Tests failed: 0</strong></pre>
			<p lang="en-GB">And looking at a new log file shows the log levels, as expected:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">2022-06-25T23:52:05.842 log_level="error" simple tag 7529</strong>
<strong class="bold" lang="">2022-06-25T23:52:05.844 log_level="error" no namespace</strong>
<strong class="bold" lang="">2022-06-25T23:52:05.844  simple 248 with more text.</strong>
<strong class="bold" lang="">2022-06-25T23:52:05.844  complicated 637 double=3.14 quoted="in quotes"</strong></pre>
			<p lang="en-GB">The first two entries make use of the new log level. The second one is the one we only wanted to make sure compiles. The third and fourth logs are missing a log level. That’s because they never specified a log level. We should fix this and enable some tags to have default values, which would let us add log levels without specifying a log level so that we can make sure that every log message entry has a log level. The third and fourth entries also have an extra <a id="_idIndexMarker341"/>space, which will be fixed too. The next section will add the ability to specify default tags.</p>
			<p lang="en-GB">Before moving on, notice one more thing. The complicated log entry actually looks like it uses tags already. That’s because we formatted the message with a <code>key="value"</code> format. It’s common to include quotation marks around text values and to not use quotation marks around numbers. The quotation marks help define the entire value when the text has spaces inside of the value, while numbers don’t need spaces and therefore don’t need quotation marks.</p>
			<p lang="en-GB">Also, note that we don’t add spaces around the equals sign. We don’t log the following:</p>
			<pre class="source-code" lang="en-GB">
double = 3.14</pre>
			<p lang="en-GB">The reason we don’t log this is that the extra spaces are not needed and only make it harder to process the log output. It might be easier to read with spaces, but trying to automate the processing of log files with scripts is harder with spaces.</p>
			<p lang="en-GB">Likewise, we don’t use commas between tags. So, we don’t do this:</p>
			<pre class="source-code" lang="en-GB">
double=3.14, quoted="in quotes"</pre>
			<p lang="en-GB">Adding commas between tags might make it easier to read, but they are just one more thing that must be handled by code that needs to programmatically process log files. Commas are not needed, so we won’t be using them.</p>
			<p lang="en-GB">Now, we can proceed to add default tags.</p>
			<h1 id="_idParaDest-96" lang="en-GB"><a id="_idTextAnchor101"/>Adding default tag values</h1>
			<p lang="en-GB">The previous section identified the need to sometimes add a tag to log messages even if the tag is not given to the <code>log</code> function. We can use this to add a default log-level tag or any other default value <a id="_idIndexMarker342"/>needed for any tag.</p>
			<p lang="en-GB">With this feature, we’re starting to get to the need for the logging library to support configuration. What I mean is that we want to be able to tell the logging library how to behave before we call <code>log</code>, and we want the logging library to remember this behavior.</p>
			<p lang="en-GB">Most applications support logging only after the configuration is set once at the beginning of the application. This configuration setup is usually done at the beginning of the <code>main</code> function. So, let’s focus on adding some simple configuration that will let us set some default tags and then use those default tags when logging. If we encounter both a default tag and a tag with the same key used during a call to the <code>log</code> function, then we will use the tag provided in the call to <code>log</code>. In other words, the default tags will be used unless overridden in the call to <code>log</code>.</p>
			<p lang="en-GB">We’ll start with what it will take to set default tag values. This is a case where we won’t actually have a test for setting a default value inside of <code>main</code>, but we will have a test to make sure that a default value set in <code>main</code> does appear in the log output from within a test. And we might as well design the solution so that default values can be set at any time and not just from inside the <code>main</code> function. This will let us test the setting of a default value directly instead of relying on <code>main</code>.</p>
			<p lang="en-GB">Even though the following code isn’t inside of a test, we can still modify <code>main</code> first to make sure that the solution is something we like. Let’s change <code>main</code> to look like this:</p>
			<pre class="source-code" lang="en-GB">
#include "../Log.h"
#include "LogTags.h"
#include &lt;MereTDD/Test.h&gt;
#include &lt;iostream&gt;
int main ()
{
    MereMemo::addDefaultTag(info);
    MereMemo::addDefaultTag(green);
    return MereTDD::runTests(std::cout);
}</pre>
			<p lang="en-GB">We’ll include <code>Log.h</code> so that we can get a definition of a new <code>addDefaultTag</code> function that we’ll write, and we’ll include <code>LogTags.h</code> to get access to the <code>info</code> log level and a new tag for a color. Why a color? Because when adding new tests, we want to look for simple and general use cases. We already have the <code>LogLevel</code> tag defined by the logging library, and the only thing we need to do is define specific instances with their own values. But we haven’t yet defined our own tags, and this seems like a good place to check that custom tags work too. The usage flows well, and it seems reasonable that users would want to define multiple default tags.</p>
			<p lang="en-GB">It’s easy to go too far and add a bunch of new functionality that needs to be tested, but adding related scenarios such as the two default tags <code>info</code> and <code>green</code> that serve to make a test more generic is okay. At least, it’s the type of thing I would do in one step. You might want to <a id="_idIndexMarker343"/>make these two separate tests. I figure that we can add a single test that just makes sure both tags are present even if not provided to the <code>log</code> function. The fact that one tag type is provided by the logging library and the other is custom is not enough for me to require separate tests. I’ll be happy if they both appear in the log output.</p>
			<p lang="en-GB">Let’s add a test now to <code>Tags.cpp</code> that looks like this:</p>
			<pre class="source-code" lang="en-GB">
TEST("Default tags set in main appear in log")
{
    std::string message = "default tag ";
    message += Util::randomString();
    MereMemo::log() &lt;&lt; message;
    std::string logLevelTag = " log_level=\"info\" ";
    std::string colorTag = " color=\"green\" ";
    bool result = Util::isTextInFile(message,          "application.log",
        {logLevelTag, colorTag});
    CONFIRM_TRUE(result);
}</pre>
			<p lang="en-GB">As it turns out, I’m glad that I did add two default tags instead of just one because when writing the test, I started thinking about how to verify they both appear in the log file, and that’s when I realized that the <code>isTextInFile</code> function is too rigid for what we now need. The <code>isTextInFile</code> function worked okay when we were only interested in checking if a specific string appeared in a file, but we’re working with tags now, and the order that the tags appear in the output is not specified. The important part is that we can’t reliably create a single string that will always match the order of the tags in the output, and we definitely don’t want to start checking for all possible tag orders.</p>
			<p lang="en-GB">What we want is the ability to first identify a specific line in the output. This is important because we might have many log file entries that have the same log level or the same color, but the message with the random number is more specific. Once we find a single line in the file that matches the random number, what we really want is to check that same line to make sure all the tags are present. The order within the line is not important.</p>
			<p lang="en-GB">So, I changed the <code>isTextInFile</code> function to take a third parameter, which will be a collection of strings. Each <a id="_idIndexMarker344"/>of these strings will be a single tag value to check. This actually makes the test easier to understand. We can leave the message unchanged and use it as the first argument to identify the line we want to find within the log file. Assuming we find that line, we then pass individually formatted tags in the <code>key="value"</code> format as a collection of strings to verify that they each exist in the same line found already.</p>
			<p lang="en-GB">Notice also that the tag strings begin and end with a single space. This makes sure that the tags are separated properly with spaces and that we also don’t have any commas at the end of a tag value.</p>
			<p lang="en-GB">We should fix the other test that checks for the existence of the log level, like this:</p>
			<pre class="source-code" lang="en-GB">
TEST("Message can be tagged in log")
{
    std::string message = "simple tag ";
    message += Util::randomString();
    MereMemo::log(error) &lt;&lt; message;
    std::string logLevelTag = " log_level=\"error\" ";
    bool result = Util::isTextInFile(message,          "application.log",
        {logLevelTag});
    CONFIRM_TRUE(result);
}</pre>
			<p lang="en-GB">We no longer need to append the message to the end of a formatted log-level tag. We just pass the single <code>logLevelTag</code> instance as the single value in the collection of additional strings to check. Now that we have default tag values set in <code>main</code>, there is no guarantee of the order of the tags. So, we could have failed this test because the color tag happened to come between the error tag and the message. All we check is that the message appears in the output and that the error tag also exists somewhere in the same log-line entry.</p>
			<p lang="en-GB">Let’s enhance the <code>isTextInFile</code> function now to accept a vector of strings in a third parameter. The vector should have a default value of an empty collection in case the caller just wants to verify that a file contains some simple text without also looking for additional strings on the same line. And while we’re doing this, let’s add a fourth parameter, which will<a id="_idIndexMarker345"/> also be a vector of strings. The fourth parameter will check to make sure that its strings are <em class="italic" lang="">not</em> found in the line. The updated function declaration looks like this in <code>Util.h</code>:</p>
			<pre class="source-code" lang="en-GB">
#include &lt;string&gt;
#include &lt;string_view&gt;
#include &lt;vector&gt;
struct Util
{
    static std::string randomString ();
    static bool isTextInFile (
        std::string_view text,
        std::string_view fileName,
        std::vector&lt;std::string&gt; const &amp; wantedTags = {},
        std::vector&lt;std::string&gt; const &amp; unwantedTags = {});
};</pre>
			<p lang="en-GB">We need to include <code>vector</code> and make sure to give the extra parameters default empty values. The implementation in <code>Util.cpp</code> looks like this:</p>
			<pre class="source-code" lang="en-GB">
bool Util::isTextInFile (
    std::string_view text,
    std::string_view fileName,
    std::vector&lt;std::string&gt; const &amp; wantedTags,
    std::vector&lt;std::string&gt; const &amp; unwantedTags)
{
    std::ifstream logfile(fileName.data());
    std::string line;
    while (getline(logfile, line))
    {
        if (line.find(text) != std::string::npos)
        {
            for (auto const &amp; tag: wantedTags)
            {
                if (line.find(tag) == std::string::npos)
                {
                    return false;
                }
            }
            for (auto const &amp; tag: unwantedTags)
            {
                if (line.find(tag) != std::string::npos)
                {
                    return false;
                }
            }
            return true;
        }
    }
    return false;
}</pre>
			<p lang="en-GB">The change adds an extra <code>for</code> loop once we find the line identified by the <code>text</code> parameter. For all the wanted tags provided, we search through the line again to make sure each tag exists. If any of them are not found, then the function returns <code>false</code>. Assuming it finds all the tags, then the function returns <code>true</code>, just like before.</p>
			<p lang="en-GB">Almost the same thing <a id="_idIndexMarker346"/>happens for the unwanted tags except that the logic is reversed. If we find an unwanted tag, then the function returns <code>false</code>.</p>
			<p lang="en-GB">All we need now is to add the definition of the <code>Color</code> tag type and then the <code>green</code> color instance. We can add these to <code>LogTags.h</code>, like this:</p>
			<pre class="source-code" lang="en-GB">
inline MereMemo::LogLevel error("error");
inline MereMemo::LogLevel info("info");
inline MereMemo::LogLevel debug("debug");
class Color : public MereMemo::Tag
{
public:
    Color (std::string const &amp; text)
    : Tag("color", text)
    { }
};
inline Color red("red");
inline Color green("green");
inline Color blue("blue");</pre>
			<p lang="en-GB">Building the project shows that I forgot to implement the <code>addDefaultTag</code> function that we started out using in <code>main</code>. Remember when I said that it’s easy to get sidetracked? I started to add the function to <code>Log.h</code>, like this:</p>
			<pre class="source-code" lang="en-GB">
inline void addDefaultTag (Tag const &amp; tag)
{
    static std::map&lt;std::string, Tag const *&gt; tags;
    tags[tag.key()] = &amp;tag;
}</pre>
			<p lang="en-GB">This is a great example of how writing the usage first helped with the implementation. What we need to do is store the tag passed to the <code>addDefaultTag</code> function so that it can be retrieved later <a id="_idIndexMarker347"/>and added to log messages. We first need a place to store the tags so that the function declares a static map.</p>
			<p lang="en-GB">Originally, I wanted the map to make a copy of the tag, but that would have required changing the <code>Tag</code> class so that it could be used directly instead of working with derived classes. I like how the derived classes help with keeping the key consistent and didn’t want to change that part of the design.</p>
			<p lang="en-GB">So, instead, I decided that the collection of tags would use pointers. The problem with using pointers is that it’s not obvious to the caller of <code>addDefaultTag</code> that the lifetimes of any tags passed to the function must remain valid for as long as the tag remains in the default tag collection.</p>
			<p lang="en-GB">We can still make copies and store the copies in unique pointers, but that requires either extra work for the caller of <code>addDefaultTag</code> or some method that knows how to clone a tag. I don’t want to add extra complexity to the code in <code>main</code> that calls <code>addDefaultTag</code> and force that code to make a copy. We’ve already written the code in <code>main</code>, and we should strive to keep that code as-is because it was written using TDD principles and provides the solution we will be most happy with.</p>
			<p lang="en-GB">To avoid lifetime surprises, we should add a <code>clone</code> method to the <code>Tag</code>-derived classes. And because we are using a map in <code>addDefaultTag</code> and have identified the need for unique pointers, we need to include <code>map</code> and <code>memory</code> at the top of <code>Log.h</code>, like this:</p>
			<pre class="source-code" lang="en-GB">
#include &lt;chrono&gt;
#include &lt;ctime&gt;
#include &lt;fstream&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;</pre>
			<p lang="en-GB">Now, let’s implement the correct <code>addDefaultTag</code> function to make a copy of the passed-in tag instead of storing a pointer directly to the caller’s variable. This will free up the caller so that the tags<a id="_idIndexMarker348"/> passed in no longer have to remain alive indefinitely. Add this code to <code>Log.h</code> right after the <code>LogLevel</code> class:</p>
			<pre class="source-code" lang="en-GB">
inline std::map&lt;std::string, std::unique_ptr&lt;Tag&gt;&gt; &amp; getDefaultTags ()
{
    static std::map&lt;std::string, std::unique_ptr&lt;Tag&gt;&gt; tags;
    return tags;
}
inline void addDefaultTag (Tag const &amp; tag)
{
    auto &amp; tags = getDefaultTags();
    tags[tag.key()] = tag.clone();
}</pre>
			<p lang="en-GB">We use a helper function to store the collection of default tags. The collection is static, so it gets initialized to an empty map the first time the tags are requested.</p>
			<p lang="en-GB">We need to add a pure virtual <code>clone</code> method to the <code>Tag</code> class that will return a unique pointer. The method declaration can go right after the <code>text</code> method and looks like this:</p>
			<pre class="source-code" lang="en-GB">
    std::string text () const
    {
        return mText;
    }
    virtual std::unique_ptr&lt;Tag&gt; clone () const = 0;
protected:</pre>
			<p lang="en-GB">And now, we need to add the <code>clone</code> method implementation to both the <code>LogLevel</code> and <code>Color</code> classes. The first looks like this:</p>
			<pre class="source-code" lang="en-GB">
class LogLevel : public Tag
{
public:
    LogLevel (std::string const &amp; text)
    : Tag("log_level", text)
    { }
    std::unique_ptr&lt;Tag&gt; clone () const override
    {
        return std::unique_ptr&lt;Tag&gt;(
            new LogLevel(*this));
    }
};</pre>
			<p lang="en-GB">And the implementation<a id="_idIndexMarker349"/> for the <code>Color</code> class looks almost identical:</p>
			<pre class="source-code" lang="en-GB">
class Color : public MereMemo::Tag
{
public:
    Color (std::string const &amp; text)
    : Tag("color", text)
    { }
    std::unique_ptr&lt;Tag&gt; clone () const override
    {
        return std::unique_ptr&lt;Tag&gt;(
            new Color(*this));
    }
};</pre>
			<p lang="en-GB">Even though the implementations look almost identical, each makes a new instance of the specific type involved, which gets returned as a unique pointer to <code>Tag</code>. This is the complexity that I was hoping to avoid when I started, but it’s better to add complexity to the derived classes instead of placing extra and unexpected requirements on the caller of <code>addDefaultTag</code>.</p>
			<p lang="en-GB">We’re now ready to build and run the test application. One of the tests fails, like this:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">Running 1 test suites</strong>
<strong class="bold" lang="">--------------- Suite: Single Tests</strong>
<strong class="bold" lang="">------- Test: Message can be tagged in log</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: log needs no namespace when used with LogLevel</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Default tags set in main appear in log</strong>
<strong class="bold" lang="">Failed confirm on line 37</strong>
<strong class="bold" lang="">    Expected: true</strong>
<strong class="bold" lang="">------- Test: Simple message can be logged</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Complicated message can be logged</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">-----------------------------------</strong>
<strong class="bold" lang="">Tests passed: 4</strong>
<strong class="bold" lang="">Tests failed: 1</strong></pre>
			<p lang="en-GB">The failure is actually a good thing and is part of the TDD process. We wrote the code as we intended it to be <a id="_idIndexMarker350"/>used in <code>main</code>, and wrote a test that would verify that the default tags appear in the output log file. The default tags are missing, and that’s because we need to change the <code>log</code> function so that it will include the default tags.</p>
			<p lang="en-GB">Right now, the <code>log</code> function only includes the tags that are directly provided—or, I should say, the tag that is directly provided because we don’t yet have a way to log multiple tags. We’ll get there. One thing at a time.</p>
			<p lang="en-GB">Our <code>log</code> function currently has two overloaded versions. One takes a single <code>Tag</code> parameter and turns it into a string that it passes to the other. Once the tag is turned into a string, it becomes harder to detect which tags are currently being used, and we’ll need to know that so that we don’t end up logging both a default tag and a directly specified tag with the same key.</p>
			<p lang="en-GB">For example, we don’t want a log message to include both <code>info</code> and <code>debug</code> log levels because the log was made with <code>debug</code> while <code>info</code> was the default. We only want the <code>debug</code> tag to appear because it should override the default.</p>
			<p lang="en-GB">We need to pass the tag to the <code>log</code> function that does the output as a <code>Tag</code> instance instead of a string. Instead of a single <code>Tag</code> instance, though, let’s let callers pass more than one tag when calling <code>log</code>. Should we let the number of tags be unlimited? Probably not. Three seems like a good amount. If we need more than three, we’ll come up with a different solution or add more.</p>
			<p lang="en-GB">I thought about different ways to write a <code>log</code> function that takes a variadic number of tags using templates. While it might be possible, the complexity quickly became unworkable. So, instead, here are three overloads of <code>log</code> that turn the parameters into a vector of <code>Tag</code> pointers:</p>
			<pre class="source-code" lang="en-GB">
inline auto log (Tag const &amp; tag1)
{
    return log({&amp;tag1});
}
inline auto log (Tag const &amp; tag1,
    Tag const &amp; tag2)
{
    return log({&amp;tag1, &amp;tag2});
}
inline auto log (Tag const &amp; tag1,
    Tag const &amp; tag2,
    Tag const &amp; tag3)
{
    return log({&amp;tag1, &amp;tag2, &amp;tag3});
}</pre>
			<p lang="en-GB">These functions replace<a id="_idIndexMarker351"/> the earlier <code>log</code> function that converted the tag into a string. The new functions create a vector of <code>Tag</code> pointers. We might eventually need to call <code>clone</code> to create copies instead of using pointers to the caller’s arguments, but for now, this works, and we don’t have to worry about the lifetime issues we had with the default tags.</p>
			<p lang="en-GB">We’ll need to include <code>vector</code> at the top of <code>Log.h</code>, and while implementing the <code>log</code> function that actually does the logging, I ended up needing <code>algorithm</code> too. The new include section looks like this:</p>
			<pre class="source-code" lang="en-GB">
#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;ctime&gt;
#include &lt;fstream&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;
#include &lt;vector&gt;</pre>
			<p lang="en-GB">And now, to the changes <a id="_idIndexMarker352"/>to the <code>log</code> function that does the logging. It looks like this:</p>
			<pre class="source-code" lang="en-GB">
inline std::fstream log (std::vector&lt;Tag const *&gt; tags = {})
{
    auto const now = std::chrono::system_clock::now();
    std::time_t const tmNow =          std::chrono::system_clock::to_time_t(now);
    auto const ms = duration_cast&lt;std::chrono::milliseconds&gt;(
        now.time_since_epoch()) % 1000;
    std::fstream logFile("application.log", std::ios::app);
    logFile &lt;&lt; std::endl
        &lt;&lt; std::put_time(std::gmtime(&amp;tmNow),            "%Y-%m-%dT%H:%M:%S.")
        &lt;&lt; std::setw(3) &lt;&lt; std::setfill('0')         &lt;&lt; std::to_string(ms.count());
    for (auto const &amp; defaultTag: getDefaultTags())
    {
        if (std::find_if(tags.begin(), tags.end(),
            [&amp;defaultTag](auto const &amp; tag)
            {
                return defaultTag.first == tag-&gt;key();
            }) == tags.end())
        {
            logFile &lt;&lt; " " &lt;&lt; defaultTag.second-&gt;text();
        }
    }
    for (auto const &amp; tag: tags)
    {
        logFile &lt;&lt; " " &lt;&lt; tag-&gt;text();
    }
    logFile &lt;&lt; " ";
    return logFile;
}</pre>
			<p lang="en-GB">Instead of accepting a string of pre-formatted tags, the function now takes a vector of <code>Tag</code> pointers with a default value of an empty collection. As far as this function is concerned, there can be an unlimited number of tags. The limit of three tags comes only because of the overloaded <code>log</code> functions that take up to three tags.</p>
			<p lang="en-GB">The default value for the <code>tags</code> vector lets callers continue to be able to call <code>log</code> with no arguments.</p>
			<p lang="en-GB">The first part of the <a id="_idIndexMarker353"/>function that formats the timestamp, opens the log file, and prints the timestamp remains unchanged, except that we no longer display a pre-formatted string for the tags.</p>
			<p lang="en-GB">The changes start with the first <code>for</code> loop, which looks at each default tag. We want to try finding the same tag key in the vector of tag pointers. If we find the same key, then we skip the default tag and try the next one. If we don’t find the same key, then we display the default tag.</p>
			<p lang="en-GB">To do the searching, we use the <code>std::find_if</code> algorithm and provide a lambda that knows how to compare the keys.</p>
			<p lang="en-GB">After displaying only the default tags that were not overridden, the code goes through a second <code>for</code> loop to display all the tags passed in directly.</p>
			<p lang="en-GB">Building and running the test application shows that all the tests pass, and the log file now contains default tags for all the entries, like this:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">2022-06-26T06:24:26.607 color="green" log_level="error" simple tag 4718</strong>
<strong class="bold" lang="">2022-06-26T06:24:26.609 color="green" log_level="error" no namespace</strong>
<strong class="bold" lang="">2022-06-26T06:24:26.609 color="green" log_level="info" default tag 8444</strong>
<strong class="bold" lang="">2022-06-26T06:24:26.609 color="green" log_level="info" simple 4281 with more text.</strong>
<strong class="bold" lang="">2022-06-26T06:24:26.610 color="green" log_level="info" complicated 8368 double=3.14 quoted="in quotes"</strong></pre>
			<p lang="en-GB">All the log messages contain the color tag set to <code>"green"</code>, and they all contain the <code>log_level</code> tag with either the default value of <code>"info"</code> or the overridden value of <code>"error"</code>. For the test that overrides the default value, let’s make sure that the default value does not exist. We can make use of the unwanted tags parameter in the <code>isTextInFile</code> function, like this:</p>
			<pre class="source-code" lang="en-GB">
TEST("Message can be tagged in log")
{
    std::string message = "simple tag ";
    message += Util::randomString();
    MereMemo::log(error) &lt;&lt; message;
    // Confirm that the error tag value exists and that the
    // default info tag value does not.
    std::string logLevelTag = " log_level=\"error\" ";
    std::string defaultLogLevelTag = " log_level=\"info\" ";
    bool result = Util::isTextInFile(message,          "application.log",
        {logLevelTag}, {defaultLogLevelTag});
    CONFIRM_TRUE(result);
}</pre>
			<p lang="en-GB">Should the extra check<a id="_idIndexMarker354"/> that the default tag value does not exist in the log file be added to a separate test? The benefit of a separate test is that it makes it clear what is being tested. The downside is that the test will be almost identical to this one. It’s something to think about. In this case, I think the extra check and comment in the existing test is enough.</p>
			<p lang="en-GB">Before moving on, we need to add a test for the feature that I slipped in for multiple tags. I really should have written a test for this first before enhancing the code to support multiple tags, but for the purposes of explaining the code, it was much more direct to just explain the idea of multiple tags once instead of going back and adding the extra explanation.</p>
			<p lang="en-GB">Let’s quickly add a new type of <code>Tag</code> called <code>Size</code> with a few named instances in <code>LogTags.h</code>, like this:</p>
			<pre class="source-code" lang="en-GB">
class Size : public MereMemo::Tag
{
public:
    Size (std::string const &amp; text)
    : Tag("size", text)
    { }
    std::unique_ptr&lt;Tag&gt; clone () const override
    {
        return std::unique_ptr&lt;Tag&gt;(
            new Size(*this));
    }
};
inline Size small("small");
inline Size medium("medium");
inline Size large("large");</pre>
			<p lang="en-GB">And now, here is a test for multiple tags:</p>
			<pre class="source-code" lang="en-GB">
TEST("Multiple tags can be used in log")
{
    std::string message = "multi tags ";
    message += Util::randomString();
    MereMemo::log(debug, red, large) &lt;&lt; message;
    std::string logLevelTag = " log_level=\"debug\" ";
    std::string colorTag = " color=\"red\" ";
    std::string sizeTag = " size=\"large\" ";
    bool result = Util::isTextInFile(message,          "application.log",
        {logLevelTag, colorTag, sizeTag});
    CONFIRM_TRUE(result);
}</pre>
			<p lang="en-GB">The log file contains the<a id="_idIndexMarker355"/> entry with all three tags, like this:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">2022-06-26T07:09:31.192 log_level="debug" color="red" size="large" multi tags 9863</strong></pre>
			<p lang="en-GB">We have the ability to log with up to three directly specified tags and multiple default tags. We need to eventually use the tags for more than just displaying information in the log file. We want to be able to filter log messages based on the tag values to control which log messages make it all the way to the log file and which are ignored. We’re not quite ready for filtering. The next section will explore filtering options based on the tag values.</p>
			<h1 id="_idParaDest-97" lang="en-GB"><a id="_idTextAnchor102"/>Exploring filtering options</h1>
			<p lang="en-GB">Filtering log messages lets <a id="_idIndexMarker356"/>us write code that includes calls to log information at important places within the code but then ignore some of those logging calls. Why would we go to all the trouble of adding code to do logging but then not do the logging?</p>
			<p lang="en-GB">For some events in the code such as an error that gets detected, it makes sense to always log that event. Other places might be equally important even if they are not errors. Usually, these are places in the code where something gets created or deleted. I’m not talking about creating or deleting an instance of a local variable. I mean something major, such as the creation of a new customer account, the completion of a quest in an adventure game, or the deletion of an old data file to free up space. All of these are good examples of important events that should probably always be logged.</p>
			<p lang="en-GB">Other events might help a developer understand what a program was doing right before it crashed. These log messages act like signposts along a journey. They’re not as big as the errors or major events, but they can let us figure out what a program was doing. These are usually good to log too because, without them, it can be hard to fix bugs. Sure—the error log might show clearly that something bad happened, but understanding what led up to the problem can be difficult without the signpost messages.</p>
			<p lang="en-GB">And sometimes, when we know the general idea of what led to a problem, we need even more details. This is where we sometimes want to turn off the logging because log messages such as these can sometimes be extremely verbose and cause the size of the log files to increase. They can also make it hard to see the bigger picture. Have you ever tried walking someplace with your eyes intently focused on the ground at your feet? You can get all the details of every step but might find that you get lost. Looking up to see the general direction makes it hard to also notice a small rock that can cause you to trip.</p>
			<p lang="en-GB">When writing code, we want to put all these types of log messages into the code because adding extra logging messages later can be difficult, especially if the program is running at a remote customer location. So, we want the code to try to log everything. And then, at runtime, we want to control exactly how much information appears in the log files. Filtering lets us control how much logging we see by ignoring some logging requests.</p>
			<p lang="en-GB">We’re going to filter log messages based on tags and their values, but we have a problem.</p>
			<p lang="en-GB">Let’s say that we want to ignore a log message unless it has a certain tagged value. The way our <code>log</code> function works now is that it immediately opens a log file and starts streaming a timestamp, then adds tags, and finally lets the caller send whatever else is needed.</p>
			<p lang="en-GB">The only way to know for certain if a log message should be allowed to complete is to look at the tags once they have been finalized. In other words, we need to let everything be sent as if it will be <a id="_idIndexMarker357"/>logged but without actually doing anything. Once we have the complete message, we can look at the message to see if it meets the criteria to be sent to the output file.</p>
			<p lang="en-GB">This means we need to do two things differently. First, we need to stop writing to a log file right away and collect everything in case we do eventually need to write it. And second, we need to know when a log message is complete. We can’t simply return an open stream to the caller and let the caller do whatever they want with the stream. Or, I should say that we can’t return a stream that directly modifies the output log file. Letting the caller work directly with the final output log file gives us no way to know when the caller is done so that we can finish up and either ignore the log or let it continue.</p>
			<p lang="en-GB">I know of three ways to determine when a potential log message is complete. The first is to put everything into a single function call. The function can accept a variable number of arguments, so we won’t be limited to a fixed number. But because the entire log message is bundled into a single function call, we will know when we have everything. It might look like this:</p>
			<pre class="source-code" lang="en-GB">
MereMemo::log(info, " count=", 5, " with text");</pre>
			<p lang="en-GB">I’m using a tag instance, a couple of string literals, and an integer number in this example. The string literals could instead be string variables or maybe function calls that return information to be logged. One of the string literals, together with the number, actually forms a <code>key=value</code> tag. The point is that the <code>log</code> function would know for certain exactly how much information was sent to be logged and we would know all the values. We could easily test the log message to see if it should be allowed to continue or if it should be ignored.</p>
			<p lang="en-GB">We even have the beginning of a solution like this already because we accept up to three tag instances in the <code>log</code> function.</p>
			<p lang="en-GB">The second way to determine when a log is complete is to use something to terminate the stream we have now. It might look like this:</p>
			<pre class="source-code" lang="en-GB">
MereMemo::log(info) &lt;&lt; "count=" &lt;&lt; 5 &lt;&lt; " with text" &lt;&lt; MereMemo::endlog;</pre>
			<p lang="en-GB">Notice that we don’t need the extra space inside the <code>"count="</code> string literal because the <code>log</code> function adds <a id="_idIndexMarker358"/>one for us after all the tags.</p>
			<p lang="en-GB">Or, we could even allow tags to be sent to the stream, like this:</p>
			<pre class="source-code" lang="en-GB">
MereMemo::log() &lt;&lt; info &lt;&lt; " count=" &lt;&lt; 5 &lt;&lt; " with text" &lt;&lt; MereMemo::endlog;</pre>
			<p lang="en-GB">And we’re back to needing the leading space before the <code>count</code> string literal again. This is common for streams where the caller needs to manage spaces between streamed elements. The only place where we don’t need to add a space is at the very first item streamed after the <code>log</code> function.</p>
			<p lang="en-GB">The main idea with the stream approach is that we need something at the end to let the logging library know that all the information is ready to be tested against the criteria to see if the log should be ignored or not.</p>
			<p lang="en-GB">I like the stream approach better. It feels more open to me—almost more natural. And because of operator precedence and the chaining of the streaming operators, we know the order in which the log line will be evaluated. That might not be very important, but it plays into the feeling that I like the streaming approach better.</p>
			<p lang="en-GB">With this second approach, the stream that the caller gets back from the <code>log</code> function can’t be a <code>std::fstream</code> instance that is directly tied to the log file. Working with <code>fstream</code> directly would not let us ignore the log message because the information would already be sent to the file. Maybe we could return a stream that’s tied to a string instead and let the terminating <code>endlog</code> element send the string that gets built to the log file or ignore it.</p>
			<p lang="en-GB">What happens if the terminating <code>endlog</code> element is forgotten? The terminating <code>endlog</code> element needs to evaluate the log and move it forward or ignore it. If <code>endlog</code> is forgotten, then the log message will not complete. The developer might not notice the problem until a need to look at the log file shows that the expected log message is always ignored.</p>
			<p lang="en-GB">The third approach is similar to the second but without the need for a terminating element that can be forgotten. Anytime a design relies on a person to remember to do something, there will almost certainly be cases where the required part is left out. By removing the need to remember to add a terminating marker, we get a better design that can no longer be misused due to a simple oversight.</p>
			<p lang="en-GB">We already know that we can’t just return a stream tied directly to a log file. The third approach takes this a step further and returns a custom stream. We don’t use a standard stream at all <a id="_idIndexMarker359"/>because we need to add code in the stream destructor that finishes the logging and decides to either let the message complete or ignore it.</p>
			<p lang="en-GB">This approach relies on specific object lifetime rules defined by C++. We need to know exactly when the destructor will run because we need the destructor to fill the role of a terminating <code>endlog</code> element. Other programming languages that use garbage collection to clean up deleted objects would not be able to support this third solution because the stream would not be deleted until some unspecified time in the future. C++ is very clear about when object instances get deleted, and we can rely on the order. For instance, we could make a call to <code>log</code> like this:</p>
			<pre class="source-code" lang="en-GB">
MereMemo::log(info) &lt;&lt; "count=" &lt;&lt; 5 &lt;&lt; " with text";</pre>
			<p lang="en-GB">The custom stream that <code>log</code> returns will be destructed at the semicolon, which ends the expression. The programmer cannot forget anything, and the stream will be able to run the same code that an explicit <code>endlog</code> element would trigger.</p>
			<p lang="en-GB">Maybe we could combine the best aspects of all three approaches. The first function call approach doesn’t need a terminating element because it knows exactly how many arguments are being passed. The second terminating <code>endlog</code> approach is more open and natural and can work with a standard stream to a string, and the custom stream approach is open and natural too and avoids misuse.</p>
			<p lang="en-GB">I initially wanted to create a logging library that would be able to filter messages based on the entire message. While filtering on anything in the message seems to be the most flexible and powerful solution, it’s also the most complicated to implement. We don’t want to choose one design over another just because one is easier to code. We should choose a design based on the end usage that we will be happy with and find natural to use. Sometimes, complex implementations are a sign that the end use will also be complicated. A solution that might be less powerful overall but is easier to use will be better, as long as we don’t take away anything that is required.</p>
			<p lang="en-GB">One filtering complexity that we should be able to remove without affecting the end use is to only look at tags formed through the <code>Tag</code>-derived classes. We should be able to drop the ability to filter a log message based on the content of manually crafted tags.</p>
			<p lang="en-GB">Another simplification we can make will be to only filter tags passed to the <code>log</code> function. This will combine the aspect of the first approach where the <code>log</code> function accepts multiple arguments<a id="_idIndexMarker360"/> with the custom streaming approach, which accepts an intuitive series of information in chunks. So, take a look at the following streaming example:</p>
			<pre class="source-code" lang="en-GB">
MereMemo::log(info) &lt;&lt; green &lt;&lt; " count=" &lt;&lt; 5 &lt;&lt; " with text";</pre>
			<p lang="en-GB">Here, there are a total of three <code>key=value</code> tags. The first is the <code>info</code> tag, then the <code>green</code> tag, and then a tag formed manually with the count text and number. Instead of trying to filter based on all three tags, the only information we’ll use for filtering will be the <code>info</code> tag because that is the only tag passed to the <code>log</code> function directly. We should also filter based on default tags because the <code>log</code> function knows about the default tags too. This makes it easy to understand what the <code>log</code> function does. The <code>log</code> function starts the logging and determines if anything that comes after it will be accepted or ignored.</p>
			<p lang="en-GB">If we want to consider the <code>green</code> tag in the filtering, then we just need to add it to the <code>log</code> function too, like this:</p>
			<pre class="source-code" lang="en-GB">
MereMemo::log(info, green) &lt;&lt; "count=" &lt;&lt; 5 &lt;&lt; " with text";</pre>
			<p lang="en-GB">This is the type of use that needs to be thought through with TDD. The result is not always the most powerful. Instead, the goal is to meet the needs of the user and be easy and intuitive to understand.</p>
			<p lang="en-GB">Because tags are becoming more important to this design, we should enhance them to support more than just text values. The next section will add new types of tags.</p>
			<h1 id="_idParaDest-98" lang="en-GB"><a id="_idTextAnchor103"/>Adding new tag types</h1>
			<p lang="en-GB">Since we’re starting to refer to tags with<a id="_idIndexMarker361"/> numbers instead of text for the value, now would be a good time to add support for numeric and Boolean tags that don’t need quotation marks around the value.</p>
			<p lang="en-GB">We’re going to get slightly ahead of ourselves here and add some code that we don’t have a test for. That’s only because the additional support for numeric and Boolean tags is so similar to what we already have. This change is in <code>Log.h</code> in the <code>Tag</code> class. We need to add four extra constructors like this after the existing constructor that accepts a string:</p>
			<pre class="source-code" lang="en-GB">
protected:
    Tag (std::string const &amp; key, std::string const &amp; value)
    : mKey(key), mText(key + "=\"" + value + "\"")
    { }
    Tag (std::string const &amp; key, int value)
    : mKey(key), mText(key + "=" + std::to_string(value))
    { }
    Tag (std::string const &amp; key, long long value)
    : mKey(key), mText(key + "=" + std::to_string(value))
    { }
    Tag (std::string const &amp; key, double value)
    : mKey(key), mText(key + "=" + std::to_string(value))
    { }
    Tag (std::string const &amp; key, bool value)
    : mKey(key), mText(key + "=" + (value?"true":"false"))
    { }</pre>
			<p lang="en-GB">Each constructor forms<a id="_idIndexMarker362"/> text following either the <code>key="value"</code> or the <code>key=value</code> syntax. To test the new constructors, we’re going to need some new derived tag classes. All of these classes can go in <code>LogTags.h</code>. The two integral classes look like this:</p>
			<pre class="source-code" lang="en-GB">
class Count : public MereMemo::Tag
{
public:
    Count (int value)
    : Tag("count", value)
    { }
    std::unique_ptr&lt;Tag&gt; clone () const override
    {
        return std::unique_ptr&lt;Tag&gt;(
            new Count(*this));
    }
};
class Identity : public MereMemo::Tag
{
public:
    Identity (long long value)
    : Tag("id", value)
    { }
    std::unique_ptr&lt;Tag&gt; clone () const override
    {
        return std::unique_ptr&lt;Tag&gt;(
            new Identity(*this));
    }
};</pre>
			<p lang="en-GB">We’re not going to provide named instances of these tags. The earlier <code>Color</code> and <code>Size</code> tag types both have reasonable and common choices that make sense, but even they can be used directly if a<a id="_idIndexMarker363"/> strange color or an uncommon size needs to be logged. The new tags have no such common values.</p>
			<p lang="en-GB">Continuing, the double tag looks like this:</p>
			<pre class="source-code" lang="en-GB">
class Scale : public MereMemo::Tag
{
public:
    Scale (double value)
    : Tag("scale", value)
    { }
    std::unique_ptr&lt;Tag&gt; clone () const override
    {
        return std::unique_ptr&lt;Tag&gt;(
            new Scale(*this));
    }
};</pre>
			<p lang="en-GB">And again, it has no obvious default values. Maybe we could provide a named value for 1.0 or some other specific values, but these seem like they would be best defined by the domain of the application. We’re just testing a logging library and will go without named instances for this tag.</p>
			<p lang="en-GB">The Boolean tag looks like this:</p>
			<pre class="source-code" lang="en-GB">
class CacheHit : public MereMemo::Tag
{
public:
    CacheHit (bool value)
    : Tag("cache_hit", value)
    { }
    std::unique_ptr&lt;Tag&gt; clone () const override
    {
        return std::unique_ptr&lt;Tag&gt;(
            new CacheHit(*this));
    }
};
inline CacheHit cacheHit(true);
inline CacheHit cacheMiss(false);</pre>
			<p lang="en-GB">And for this one, we have obvious named values for <code>true</code> and <code>false</code> that we can provide.</p>
			<p lang="en-GB">All of the new tag classes should give you an idea of what they can be used for. Many of these are very applicable for large financial microservices where, for example, values can take a long time to <a id="_idIndexMarker364"/>be calculated and need to be cached. Logging whether a result was due to a cache hit or miss is very valuable when figuring out the flow of a calculation.</p>
			<p lang="en-GB">We’d like to be able to pass one of the new tags to the stream returned by the <code>log</code> function, like this:</p>
			<pre class="source-code" lang="en-GB">
MereMemo::log(info) &lt;&lt; Count(1) &lt;&lt; " message";</pre>
			<p lang="en-GB">To do so, we need to add a stream overload that knows how to handle the <code>Tag</code> class. Add this function to <code>Log.h</code> right after the <code>to_string</code> function:</p>
			<pre class="source-code" lang="en-GB">
inline std::fstream &amp; operator &lt;&lt; (std::fstream &amp;&amp; stream, Tag const &amp; tag)
{
    stream &lt;&lt; to_string(tag);
    return stream;
}</pre>
			<p lang="en-GB">The function uses an <em class="italic" lang="">rvalue reference</em> to the stream because we’re using the temporary stream returned from the <code>log</code> function.</p>
			<p lang="en-GB">Now, we can create a test that will log and confirm each of the new types. You could make separate tests for each<a id="_idIndexMarker365"/> type or put all of them into one test, like this:</p>
			<pre class="source-code" lang="en-GB">
TEST("Tags can be streamed to log")
{
    std::string messageBase = " 1 type ";
    std::string message = messageBase + Util::randomString();
    MereMemo::log(info) &lt;&lt; Count(1) &lt;&lt; message;
    std::string countTag = " count=1 ";
    bool result = Util::isTextInFile(message,          "application.log", {countTag});
    CONFIRM_TRUE(result);
    messageBase = " 2 type ";
    message = messageBase + Util::randomString();
    MereMemo::log(info) &lt;&lt; Identity(123456789012345)             &lt;&lt; message;
    std::string idTag = " id=123456789012345 ";
    result = Util::isTextInFile(message, "application.log",
        {idTag});
    CONFIRM_TRUE(result);
    messageBase = " 3 type ";
    message = messageBase + Util::randomString();
    MereMemo::log(info) &lt;&lt; Scale(1.5) &lt;&lt; message;
    std::string scaleTag = " scale=1.500000 ";
    result = Util::isTextInFile(message, "application.log",
        {scaleTag});
    CONFIRM_TRUE(result);
    messageBase = " 4 type ";
    message = messageBase + Util::randomString();
    MereMemo::log(info) &lt;&lt; cacheMiss &lt;&lt; message;
    std::string cacheTag = " cache_hit=false ";
    result = Util::isTextInFile(message, "application.log",
        {cacheTag});
    CONFIRM_TRUE(result);
}</pre>
			<p lang="en-GB">The reason I wasn’t so worried about creating this test before the code we added to enable the test is that we already thought through the desired usage before beginning.</p>
			<p lang="en-GB">The tag for double values<a id="_idIndexMarker366"/> might need some more work later to control the precision. You can see that it uses the default six decimals of precision. The log entries for the new test look like this:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">2022-06-27T02:06:43.569 color="green" log_level="info" count=1 1 type 2807</strong>
<strong class="bold" lang="">2022-06-27T02:06:43.569 color="green" log_level="info" id=123456789012345 2 type 7727</strong>
<strong class="bold" lang="">2022-06-27T02:06:43.570 color="green" log_level="info" scale=1.500000 3 type 5495</strong>
<strong class="bold" lang="">2022-06-27T02:06:43.570 color="green" log_level="info" cache_hit=false 4 type 3938</strong></pre>
			<p lang="en-GB">Notice how the message that is prepared for each <code>log</code> call is made unique with the numbers <code>1</code> to <code>4</code>. This makes sure that in the rare case where a duplicate random number will be generated, none of the four log messages will have the same text.</p>
			<p lang="en-GB">We can now log default tags, tags provided directly to the <code>log</code> function, and tags that are streamed just like any other piece of information. Before we implement the actual filtering, there are some enhancements that the next section will make to improve the tag classes even more by reducing the amount of code that needs to be written for each tag class.</p>
			<h1 id="_idParaDest-99" lang="en-GB"><a id="_idTextAnchor104"/>Refactoring the tag design with TDD</h1>
			<p lang="en-GB">We have a base <code>Tag</code> class and <a id="_idIndexMarker367"/>several derived tag classes in the tests. Even though the logging library will only define the log-level tag, it should still make it easy for developers to create new derived tag classes. And<a id="_idIndexMarker368"/> right now, creating a new derived tag class is mostly boilerplate code that needs to be repeated over and over. We should be able to enhance the experience by using templates.</p>
			<p lang="en-GB">Here’s what an existing derived tag class looks like:</p>
			<pre class="source-code" lang="en-GB">
class LogLevel : public Tag
{
public:
    LogLevel (std::string const &amp; text)
    : Tag("log_level", text)
    { }
    std::unique_ptr&lt;Tag&gt; clone () const override
    {
        return std::unique_ptr&lt;Tag&gt;(
            new LogLevel(*this));
    }
};</pre>
			<p lang="en-GB">The <code>LogLevel</code>-derived tag class is the only class like this that the logging library will provide. It defines the log-level tag without actually defining any specific log-level values. It’s better to say <a id="_idIndexMarker369"/>that this class defines what a log level should be.</p>
			<p lang="en-GB">We can compare the <code>LogLevel</code> class to<a id="_idIndexMarker370"/> one of the other derived tag classes from the tests. Let’s choose the <code>CacheHit</code> class, which looks like this:</p>
			<pre class="source-code" lang="en-GB">
class CacheHit : public MereMemo::Tag
{
public:
    CacheHit (bool value)
    : Tag("cache_hit", value)
    { }
    std::unique_ptr&lt;Tag&gt; clone () const override
    {
        return std::unique_ptr&lt;Tag&gt;(
            new CacheHit(*this));
    }
};</pre>
			<p lang="en-GB">What can we improve about these classes? They’re almost the same, with a few differences that can be moved into a template class. What’s different about these two classes?</p>
			<ul>
				<li lang="en-GB">The name, obviously. <code>LogLevel</code> versus <code>CacheHit</code>.</li>
				<li lang="en-GB">The parent class namespace. <code>LogLevel</code> is already in the <code>MereMemo</code> namespace.</li>
				<li lang="en-GB">The key string. <code>LogLevel</code> uses <code>"log_level"</code> while <code>CacheHit</code> uses <code>"cache_hit"</code>.</li>
				<li lang="en-GB">The type of the value. <code>LogLevel</code> uses a <code>std::string</code> value while <code>CacheHit</code> uses a <code>bool</code> value.</li>
			</ul>
			<p lang="en-GB">That’s all the differences. There should be no need to make developers recreate all this every time a new tag class<a id="_idIndexMarker371"/> is needed. And we’re going to need to add more code to the tag classes in order to support filtering, so now is a great time to simplify the design.</p>
			<p lang="en-GB">We should be able to make the <a id="_idIndexMarker372"/>upcoming filtering changes without affecting any of the existing tests, but that will require design changes now. We’re refactoring the design, and the tests will help make sure that the new design continues to behave just like the current design. The confidence we get from knowing everything still works is one of the benefits of using TDD.</p>
			<p lang="en-GB">The <code>Tag</code> class represents an interface that all tags support. We’ll leave it as-is and simple. Instead of changing the <code>Tag</code> class, we’ll introduce a new template class that can hold the <code>clone</code> method implementation and any upcoming filtering changes.</p>
			<p lang="en-GB">Change the <code>LogLevel</code> class in <code>Log.h</code> to use a new <code>TagType</code> template class that can use different types of values, like this:</p>
			<pre class="source-code" lang="en-GB">
template &lt;typename T, typename ValueT&gt;
class TagType : public Tag
{
public:
    std::unique_ptr&lt;Tag&gt; clone () const override
    {
        return std::unique_ptr&lt;Tag&gt;(
            new T(*static_cast&lt;T const *&gt;(this)));
    }
    ValueT value () const
    {
        return mValue;
    }
protected:
    TagType (ValueT const &amp; value)
    : Tag(T::key, value), mValue(value)
    { }
    ValueT mValue;
};
class LogLevel : public TagType&lt;LogLevel, std::string&gt;
{
public:
    static constexpr char key[] = "log_level";
    LogLevel (std::string const &amp; value)
    : TagType(value)
    { }
};</pre>
			<p lang="en-GB">We still have a class called <code>LogLevel</code> that can be used just like before. It now specifies the type of the value, which is <code>std::string</code>, in the template argument to <code>TagType</code>, and the <code>key</code> string is now a constant array of chars that each derived tag class will define. The <code>LogLevel</code> class is simpler because it no longer needs to handle cloning.</p>
			<p lang="en-GB">The new <code>TagType</code> template class <a id="_idIndexMarker373"/>does most of the<a id="_idIndexMarker374"/> hard work. For right now, that work is just cloning, but we’ll need to add more features in order to implement filtering. We should be able to put those upcoming features inside the <code>TagType</code> class and leave the derived tag classes unchanged.</p>
			<p lang="en-GB">The way this design works is based <a id="_idIndexMarker375"/>on something called the <code>LogLevel</code> inherits from <code>TagType</code>, and <code>TagType</code> is given <code>LogLevel</code> as one of its template parameters. This allows <code>TagType</code> to refer back to <code>LogLevel</code> from within the <code>clone</code> method in order to construct a new instance of <code>LogLevel</code>. Without the CRTP, then <code>TagType</code> would have no way to create a new <code>LogLevel</code> instance because it would not know what type to create.</p>
			<p lang="en-GB">And <code>TagType</code> needs to refer back to <code>LogLevel</code> one more time in order to get the name of the key. <code>TagType</code> does this again by referring to the type given to it by the CRTP in the <code>T</code> parameter.</p>
			<p lang="en-GB">The <code>clone</code> method is a little more complicated because when we’re inside the <code>clone</code> method, we’re in the <code>TagType</code> class, which means that the <code>this</code> pointer needs to be cast to the derived type.</p>
			<p lang="en-GB">We can now simplify the other derived tag types in <code>LogTags.h</code>. The <code>Color</code> and <code>Size</code> types both use <code>std::string</code> as the value type just like <code>LogLevel</code>, and they look like this:</p>
			<pre class="source-code" lang="en-GB">
class Color : public MereMemo::TagType&lt;Color, std::string&gt;
{
public:
    static constexpr char key[] = "color";
    Color (std::string const &amp; value)
    : TagType(value)
    { }
};
class Size : public MereMemo::TagType&lt;Size, std::string&gt;
{
public:
    static constexpr char key[] = "size";
    Size (std::string const &amp; value)
    : TagType(value)
    { }
};</pre>
			<p lang="en-GB">The <code>Count</code> and <code>Identity</code> types<a id="_idIndexMarker376"/> both use<a id="_idIndexMarker377"/> integral value types of different lengths, and they look like this:</p>
			<pre class="source-code" lang="en-GB">
class Count : public MereMemo::TagType&lt;Count, int&gt;
{
public:
    static constexpr char key[] = "count";
    Count (int value)
    : TagType(value)
    { }
};
class Identity : public MereMemo::TagType&lt;Identity, long long&gt;
{
public:
    static constexpr char key[] = "id";
    Identity (long long value)
    : TagType(value)
    { }
};</pre>
			<p lang="en-GB">The <code>Scale</code> type uses a <code>double</code> value type and looks like this:</p>
			<pre class="source-code" lang="en-GB">
class Scale : public MereMemo::TagType&lt;Scale, double&gt;
{
public:
    static constexpr char key[] = "scale";
    Scale (double value)
    : TagType(value)
    { }
};</pre>
			<p lang="en-GB">And the <code>CacheHit</code> type uses a <code>bool</code> value type and looks like this:</p>
			<pre class="source-code" lang="en-GB">
class CacheHit : public MereMemo::TagType&lt;CacheHit, bool&gt;
{
public:
    static constexpr char key[] = "cache_hit";
    CacheHit (bool value)
    : TagType(value)
    { }
};</pre>
			<p lang="en-GB">Each of the derived tag types<a id="_idIndexMarker378"/> is much simpler than before and can focus on what makes each one unique: the class name, the key name, and<a id="_idIndexMarker379"/> the type of the value.</p>
			<p lang="en-GB">The next section will create filtering tests based on logical criteria that will allow us to specify what should be logged, and we’ll be using the simplified tag classes too with the <code>clone</code> method.</p>
			<h1 id="_idParaDest-100" lang="en-GB"><a id="_idTextAnchor105"/>Designing tests to filter log messages</h1>
			<p lang="en-GB">Filtering log messages is <a id="_idIndexMarker380"/>going to be one of the biggest features of the<a id="_idIndexMarker381"/> logging library. That’s why this chapter is devoting so much effort to exploring ideas and enhancing the design. Most logging libraries offer some support for filtering, but usually, it’s limited to just logging levels. And the logging levels are also usually ordered so that when you set one logging level, then you get all logs with a level equal to and either above or below the filtered level.</p>
			<p lang="en-GB">This always seemed arbitrary to me. Do the logging levels go up or down? Does setting the filtering level to <code>info</code> mean that you get <code>debug</code> too, or just <code>info</code> and <code>error</code> logs?</p>
			<p lang="en-GB">And this ignores the bigger <a id="_idIndexMarker382"/>problem of information overload. Once you do figure out how to get debug-level logs, they all get logged and the logs quickly fill<a id="_idIndexMarker383"/> up. I’ve even seen logs fill up so fast that the messages I was interested in were already zipped up and about to be deleted to save space before I could even exit the application to see what happened.</p>
			<p lang="en-GB">Our target customer for the logging library is a microservices developer. This means that the applications being worked on are probably large and distributed. Turning on debug logging everywhere, even within a single service, causes a lot of problems.</p>
			<p lang="en-GB">The logging library we’re building will fix these problems, but we need to start simple. A test like this in <code>Tags.cpp</code> is a good start:</p>
			<pre class="source-code" lang="en-GB">
TEST("Tags can be used to filter messages")
{
    int id = MereMemo::createFilterClause();
    MereMemo::addFilterLiteral(id, error);
    std::string message = "filter ";
    message += Util::randomString();
    MereMemo::log(info) &lt;&lt; message;
    bool result = Util::isTextInFile(message,          "application.log");
    CONFIRM_FALSE(result);
    MereMemo::clearFilterClause(id);
    MereMemo::log(info) &lt;&lt; message;
    bool result = Util::isTextInFile(message,          "application.log");
    CONFIRM_TRUE(result);
}</pre>
			<p lang="en-GB">The idea for this test is to first set a filter that will cause a log message to be ignored. We confirm that the message does not appear in the log file. Then, the test clears the filter and tries to log the same message again. This time, it should appear in the log file.</p>
			<p lang="en-GB">Normally, a filter match should allow a log to proceed, and no match should cause the message to be ignored. But when there are no filters set at all, then we should let everything through. Letting everything through without any filters lets users opt into filtering. If filtering is being used at all, then it controls the log output, but when there are no filters, then it would be strange to not let anything through. When the test sets a filter that does not match the log message, then the message does not appear in the log file because filtering has been <a id="_idIndexMarker384"/>enabled. When the filter is cleared, then we’re assuming there are no other filters set, and <a id="_idIndexMarker385"/>all log messages will be allowed to proceed again.</p>
			<p lang="en-GB">We’ll be filtering<a id="_idIndexMarker386"/> logs based on formulas in the <strong class="bold" lang="">Disjunctive Normal Form</strong> (<strong class="bold" lang="">DNF</strong>). The DNF specifies one or more clauses that are OR’ed together. Each clause contains literals that are AND’ed together. These are not literals in the C++ sense. Here, literal is a mathematical term. Each literal in a clause can either be AND’ed as-is or NOT’ed first. All this is Boolean logic and has the ability to represent any logical condition from simple to complex filters. Explaining all the details of DNF is not the purpose of this book, so I won’t be explaining all the math behind DNF. Just know that DNF is powerful enough to represent any filter we can think of.</p>
			<p lang="en-GB">This is a case where a powerful solution is needed. Even so, we’ll try to focus on the end use and keep the solution as easy to use as possible.</p>
			<p lang="en-GB">The test calls a <code>createFilterClause</code> function that returns an identifier for the clause created. Then, the test calls <code>addFilterLiteral</code> to add an <code>error</code> tag to the clause just created. What the test is trying to accomplish is to complete a log only if the <code>error</code> tag is present. If this tag is not present, then the log should be ignored. And remember that in order for a tag to be considered, it must either be present in the default tags or supplied directly to the <code>log</code> function.</p>
			<p lang="en-GB">Then, the test calls another function, <code>clearFilterClause</code>, which is intended to clear the filter clause just created and let everything be logged again.</p>
			<p lang="en-GB">Normally, the microservices developer won’t run their application with filtering completely empty because that would allow all log messages to go through. Some amount of filtering will likely be in place at all times. As long as at least one filter clause is active, then filtering will only allow messages to proceed that match one of the clauses. By allowing multiple clauses, what we’re doing is letting extra log messages go through because each additional clause has the chance to match more log messages. We’ll have the ability to adjust what gets logged with a powerful system of Boolean logic.</p>
			<p lang="en-GB">A large project could then <a id="_idIndexMarker387"/>add tags that identify different components. The debug logs could be turned on only for certain components or for other matching criteria. The<a id="_idIndexMarker388"/> extra logic opens up more flexibility to increase the logging for interesting areas during debugging sessions while leaving other areas unaffected and logging at normal levels.</p>
			<p lang="en-GB">What happens if a tag is present in the default tags but gets overridden directly in the call to <code>log</code>? Should the default tag be ignored in favor of the explicit tag? I think so, and this will be a great test to include. Edge cases such as this really help define a project and improve the benefits gained by using TDD. Let’s add the test now so that we don’t forget. It looks like this:</p>
			<pre class="source-code" lang="en-GB">
TEST("Overridden default tag not used to filter messages")
{
    int id = MereMemo::createFilterClause();
    MereMemo::addFilterLiteral(id, info);
    std::string message = "override default ";
    message += Util::randomString();
    MereMemo::log(debug) &lt;&lt; message;
    bool result = Util::isTextInFile(message,          "application.log");
    CONFIRM_FALSE(result);
    MereMemo::clearFilterClause(id);
}</pre>
			<p lang="en-GB">This test relies on the <code>info</code> tag already being set in the default tags. We should probably add the ability to test which tags are default so that the test can fail if <code>info</code> is not found in the default tags, and we need to make sure to clear the filter clause at the end of the test so that other tests are not affected. The previous test also cleared the clause but at a specific point in the test. Even so, the previous test should have a stronger guarantee that the test will not end with the filter clause still set. We should make use of a test teardown to always clear the filter clause at the end of any test that creates one.</p>
			<p lang="en-GB">Before continuing to add a teardown, the idea for the test that I started to explain is this. After setting a clause to only allow logs with the <code>info</code> tag, then the log message should have been allowed to continue because it will gain the <code>info</code> tag through the default set of tags. But instead, the log overrides the <code>info</code> tag with the <code>debug</code> tag. The end result is that the log message<a id="_idIndexMarker389"/> should not be found in the output log file.</p>
			<p lang="en-GB">To make sure that we<a id="_idIndexMarker390"/> always clear the filter clause even if a test fails and throws an exception before it reaches the end of the test, we need to define a setup and teardown class in <code>Tags.cpp</code>, like this:</p>
			<pre class="source-code" lang="en-GB">
class TempFilterClause
{
public:
    void setup ()
    {
        mId = MereMemo::createFilterClause();
    }
    void teardown ()
    {
        MereMemo::clearFilterClause(mId);
    }
    int id () const
    {
        return mId;
    }
private:
    int mId;
};</pre>
			<p lang="en-GB">If you want more information about setup and teardown classes, refer to <a href="B18567_07.xhtml#_idTextAnchor065"><em class="italic" lang="">Chapter 7</em></a>,<em class="italic" lang=""> Test Setup </em><em class="italic" lang="">and Teardown</em>.</p>
			<p lang="en-GB">It’s okay for a test to clear the filters itself at the appropriate times. Adding an instance of <code>SetupAndTeardown</code> will make sure to call the <code>clearFilterClause</code> function even if it was already<a id="_idIndexMarker391"/> called. The first test from this section looks like this:</p>
			<pre class="source-code" lang="en-GB">
TEST("Tags can be used to filter messages")
{
    int id = MereMemo::createFilterClause();
    MereMemo::addFilterLiteral(id, error);
    std::string message = "filter ";
    message += Util::randomString();
    MereMemo::log(info) &lt;&lt; message;
    bool result = Util::isTextInFile(message,          "application.log");
    CONFIRM_FALSE(result);
    MereMemo::clearFilterClause(id);
    MereMemo::log(info) &lt;&lt; message;
    result = Util::isTextInFile(message, "application.log");
    CONFIRM_TRUE(result);
}</pre>
			<p lang="en-GB">The test now gets the clause ID from the setup and teardown instance. The ID is used to add the filter literal and to clear the filter clause at the correct time. The filter clause will be cleared again at the<a id="_idIndexMarker392"/> end of the test with no effect.</p>
			<p lang="en-GB">The second test from this section no longer needs to explicitly clear the filter itself and only needs to add the <code>SetupAndTeardown</code> instance, like this:</p>
			<pre class="source-code" lang="en-GB">
TEST("Overridden default tag not used to filter messages")
{
    MereTDD::SetupAndTeardown&lt;TempFilterClause&gt; filter;
    MereMemo::addFilterLiteral(filter.id(), info);
    std::string message = "override default ";
    message += Util::randomString();
    MereMemo::log(debug) &lt;&lt; message;
    bool result = Util::isTextInFile(message,          "application.log");
    CONFIRM_FALSE(result);
}</pre>
			<p lang="en-GB">This test was calling <code>clearFilterClause</code> at the end to put the filters back in an unfiltered state. The test no longer needs to call <code>clearFilterClause</code> directly because relying on the <code>SetupAndTeardown</code> destructor is more reliable.</p>
			<p lang="en-GB">We have two filter <a id="_idIndexMarker393"/>tests that call functions that don’t exist yet. Let’s add the<a id="_idIndexMarker394"/> following function stubs to <code>Log.h</code> right after the <code>addDefaultTag</code> function:</p>
			<pre class="source-code" lang="en-GB">
inline int createFilterClause ()
{
    return 1;
}
inline void addFilterLiteral (int filterId,
    Tag const &amp; tag,
    bool normal = true)
{
}
inline void clearFilterClause (int filterId)
{
}</pre>
			<p lang="en-GB">The <code>createFilterClause</code> function just returns <code>1</code> for now. It will need to eventually return a different identifier for each clause created.</p>
			<p lang="en-GB">The <code>addFilterLiteral</code> function adds the given tag to the clause identified. The <code>normal</code> parameter will let us add literals that are NOT’ed or inverted by passing <code>false</code>. Be careful with the meaning of flags such as this. When I first wrote this, the flag was called <code>invert</code> and had a default value of <code>false</code>. I didn’t notice the problem until writing a test for an inverted filter and it seemed strange to pass <code>true</code> in order to get an inverted literal. The test highlighted the backward usage while the initial function declaration let it slip by unnoticed.</p>
			<p lang="en-GB">And the <code>clearFilterClause</code> function does nothing for now. We’ll need to have some sort of collection of clauses later that we can work with.</p>
			<p lang="en-GB">Stubbing out the filter functions lets us build and run the test application. We get two test failures, like this:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">Running 1 test suites</strong>
<strong class="bold" lang="">--------------- Suite: Single Tests</strong>
<strong class="bold" lang="">------- Test: Message can be tagged in log</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: log needs no namespace when used with LogLevel</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Default tags set in main appear in log</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Multiple tags can be used in log</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Tags can be streamed to log</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Tags can be used to filter messages</strong>
<strong class="bold" lang="">Failed confirm on line 123</strong>
<strong class="bold" lang="">    Expected: false</strong>
<strong class="bold" lang="">------- Test: Overridden default tag not used to filter messages</strong>
<strong class="bold" lang="">Failed confirm on line 143</strong>
<strong class="bold" lang="">    Expected: false</strong>
<strong class="bold" lang="">------- Test: Simple message can be logged</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Complicated message can be logged</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">-----------------------------------</strong>
<strong class="bold" lang="">Tests passed: 7</strong>
<strong class="bold" lang="">Tests failed: 2</strong></pre>
			<p lang="en-GB">The results are expected <a id="_idIndexMarker395"/>with TDD. We did the bare minimum needed to get the code building so that we can<a id="_idIndexMarker396"/> see the failures. We can add a little more implementation to the stubbed-out functions next.</p>
			<p lang="en-GB">I mentioned that we’ll need a collection for the clauses. Add the following functions to <code>Log.h</code>, right before the stubbed-out filter functions:</p>
			<pre class="source-code" lang="en-GB">
struct FilterClause
{
    std::vector&lt;std::unique_ptr&lt;Tag&gt;&gt; normalLiterals;
    std::vector&lt;std::unique_ptr&lt;Tag&gt;&gt; invertedLiterals;
};
inline std::map&lt;int, FilterClause&gt; &amp; getFilterClauses ()
{
    static std::map&lt;int, FilterClause&gt; clauses;
    return clauses;
}</pre>
			<p lang="en-GB">The pattern is similar to what we did for the default tags. There is a function called <code>getFilterClauses</code> that returns a reference to a static map of <code>FilterClause</code> objects, and the <code>FilterClause</code> struct is <a id="_idIndexMarker397"/>defined to hold a couple of vectors for the normal and inverted literals. The<a id="_idIndexMarker398"/> literals are pointers to the tags that we get from cloning.</p>
			<p lang="en-GB">The <code>createFilterClause</code> function can be implemented to use the collection of clauses, like this:</p>
			<pre class="source-code" lang="en-GB">
inline int createFilterClause ()
{
    static int currentId = 0;
    ++currentId;
    auto &amp; clauses = getFilterClauses();
    clauses[currentId] = FilterClause();
    return currentId;
}</pre>
			<p lang="en-GB">This function keeps track of the current id in a static variable that gets incremented each time the function is called. The only other task that needs to be done is to create an empty filter clause record. The id is returned to the caller so that the filter clause can be modified or cleared later.</p>
			<p lang="en-GB">The <code>addfilterLiteral</code> function can be implemented like this:</p>
			<pre class="source-code" lang="en-GB">
inline void addFilterLiteral (int filterId,
    Tag const &amp; tag,
    bool normal = true)
{
    auto &amp; clauses = getFilterClauses();
    if (clauses.contains(filterId))
    {
        if (normal)
        {
            clauses[filterId].normalLiterals.push_back(
                tag.clone());
        }
        else
        {
            clauses[filterId].invertedLiterals.push_back(
                tag.clone());
        }
    }
}</pre>
			<p lang="en-GB">This function makes sure that the <code>clauses</code> collection contains an entry for the given filter id before pushing back a<a id="_idIndexMarker399"/> cloned pointer to either the normal or inverted vector.</p>
			<p lang="en-GB">And the <code>clearFilterClause</code> function is the simplest because it just needs to get the collection and erase whichever filter clause exists with the given id like this:</p>
			<pre class="source-code" lang="en-GB">
inline void clearFilterClause (int filterId)
{
    auto &amp; clauses = getFilterClauses();
    clauses.erase(filterId);
}</pre>
			<p lang="en-GB">We still need to examine <a id="_idIndexMarker400"/>the filter clauses when logging, and that will be explained in the next section. When following TDD, it’s good to get tests working to the point where the code builds and the tests fail when run. Let’s get the tests to pass in the next section!</p>
			<h1 id="_idParaDest-101" lang="en-GB"><a id="_idTextAnchor106"/>Controlling what gets logged</h1>
			<p lang="en-GB">Earlier in this chapter <a id="_idIndexMarker401"/>when we were exploring filtering options, I mentioned that we will need a custom stream class instead of returning <code>std::fstream</code> from the <code>log</code> function. We need this so that we don’t immediately send information to the log file. We need to avoid sending a log message directly to the log file because there could be filtering rules in place that could cause the log message to be ignored.</p>
			<p lang="en-GB">We also decided that we would make the decision to log or not based entirely on the default tags and any tags sent directly to the <code>log</code> function. We could have the <code>log</code> function make the decision and either return <code>std::fstream</code> if the log message should proceed or a fake stream if the log message should be ignored, but it’s probably better to always return the same type. That seems like the simplest and most straightforward solution. Switching between stream types just seems like a more complicated solution that still requires a custom stream type.</p>
			<p lang="en-GB">And using a custom stream type will also let us fix a nagging problem where we have to put newlines <em class="italic" lang="">before</em> each log message instead of <em class="italic" lang="">after</em>. This has resulted in log files with an empty first line and the last line ending abruptly. We went with the temporary solution to put newlines before each log message because we didn’t have anything at the time that would let us know when all the information had been streamed.</p>
			<p lang="en-GB">Well, a custom stream <a id="_idIndexMarker402"/>class will let us solve the nagging newline problem and give us a way to avoid writing log messages directly to the log file. Let’s start with the new stream class. Create this class in <code>Log.h</code>, right before the <code>log</code> functions, like so:</p>
			<pre class="source-code" lang="en-GB">
class LogStream : public std::fstream
{
public:
    LogStream (std::string const &amp; filename,
        std::ios_base::openmode mode = ios_base::app)
    : std::fstream(filename, mode)
    { }
    LogStream (LogStream const &amp; other) = delete;
    LogStream (LogStream &amp;&amp; other)
    : std::fstream(std::move(other))
    { }
    ~LogStream ()
    {
        *this &lt;&lt; std::endl;
    }
    
    LogStream &amp; operator = (LogStream const &amp; rhs) = delete;
    LogStream &amp; operator = (LogStream &amp;&amp; rhs) = delete;
};</pre>
			<p lang="en-GB">We’re going to fix one problem at a time. So, we’ll continue to refactor this class until it does everything we need. Right now, it just inherits from <code>std::fstream</code>, so it won’t solve the problem of writing directly to the log file. The constructor still opens the log file, and all the streaming capability is inherited from <code>fstream</code>.</p>
			<p lang="en-GB">What this class does solve is the newline problem. It solves this by sending <code>std::endl</code> to the stream in the class destructor. The constructor that opens the file based on the name provided and the destructor that adds the newline are really the only parts of this class that solve the problem. The rest of the class is needed to get the code to compile and work properly.</p>
			<p lang="en-GB">Because we added a destructor, that set off a chain reaction of other requirements. We now need to provide a copy <a id="_idIndexMarker403"/>constructor. We actually need the <em class="italic" lang="">move copy constructor</em> because streams tend to act strange when copied. Copying a stream is not a simple task, but moving a stream into another stream is much simpler and does everything we need anyway. We don’t need to make any copies of the stream but we do need to return the stream from the <code>log</code> function, which means the stream either needs to be copied or moved. So, we explicitly delete the copy constructor and implement the move copy constructor.</p>
			<p lang="en-GB">We also delete both the assignment operator and the move assignment operator because we don’t need to assign the stream either.</p>
			<p lang="en-GB">We can use the new <code>LogStream</code> class by modifying the <code>log</code> function to look like this:</p>
			<pre class="source-code" lang="en-GB">
inline LogStream log (std::vector&lt;Tag const *&gt; tags = {})
{
    auto const now = std::chrono::system_clock::now();
    std::time_t const tmNow =          std::chrono::system_clock::to_time_t(now);
    auto const ms = duration_cast&lt;std::chrono::milliseconds&gt;(
        now.time_since_epoch()) % 1000;
    LogStream ls("application.log");
    ls &lt;&lt; std::put_time(std::gmtime(&amp;tmNow),        "%Y-%m-%dT%H:%M:%S.")
        &lt;&lt; std::setw(3) &lt;&lt; std::setfill('0')         &lt;&lt; std::to_string(ms.count());
    for (auto const &amp; defaultTag: getDefaultTags())
    {
        if (std::find_if(tags.begin(), tags.end(),
            [&amp;defaultTag](auto const &amp; tag)
            {
                return defaultTag.first == tag-&gt;key();
            }) == tags.end())
        {
            ls &lt;&lt; " " &lt;&lt; defaultTag.second-&gt;text();
        }
    }
    for (auto const &amp; tag: tags)
    {
        ls &lt;&lt; " " &lt;&lt; tag-&gt;text();
    }
    ls &lt;&lt; " ";
    return ls;
}</pre>
			<p lang="en-GB">The <code>log</code> function now returns a <code>LogStream</code> instance instead of <code>std::fstream</code>. Inside the function, it creates a <code>LogStream</code> instance as if it were a <code>fstream</code> instance. The only thing that changes is the type. And we now have the file open mode defaulted to <code>append</code>, so we don’t <a id="_idIndexMarker404"/>need to specify how to open the file. The name of the stream changed to <code>ls</code> because this is no longer a log file.</p>
			<p lang="en-GB">And then, when sending the initial timestamp, we no longer need to send an initial <code>std::endl</code> instance and can immediately start with the timestamp.</p>
			<p lang="en-GB">The only thing different when the test application runs after these changes is that the log file will no longer have an empty first line and all lines will end with a newline.</p>
			<p lang="en-GB">That’s one small problem fixed. What about the bigger problem of writing directly to the log file? We still want to write to a standard stream because implementing our own stream class adds a lot of complexity we don’t really need right now. So, instead of inheriting the <code>LogStream</code> class from <code>std::fstream</code>, we’ll instead inherit from <code>std::stringstream</code>.</p>
			<p lang="en-GB">We’re going to need to include <code>sstream</code> to get a definition of <code>stringstream</code>, and we might as well include <code>ostream</code> now too. We’ll need <code>ostream</code> in order to change our streaming helper function in <code>Log.h</code>, which currently uses <code>std::fstream</code>, to look like this instead:</p>
			<pre class="source-code" lang="en-GB">
inline std::ostream &amp; operator &lt;&lt; (std::ostream &amp;&amp; stream, Tag const &amp; tag)
{
    stream &lt;&lt; to_string(tag);
    return stream;
}</pre>
			<p lang="en-GB">We probably should have implemented this helper function to use <code>ostream</code> from the very beginning. This way, we can stream tags to any output stream. And because both <code>fstream</code> and <code>stringstream</code> are based on <code>ostream</code>, we can use this one helper function to stream to both.</p>
			<p lang="en-GB">Here are the updated<a id="_idIndexMarker405"/> includes for <code>Log.h</code>:</p>
			<pre class="source-code" lang="en-GB">
#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;ctime&gt;
#include &lt;fstream&gt;
#include &lt;iomanip&gt;
#include &lt;map&gt;
#include &lt;memory&gt;
#include &lt;ostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;
#include &lt;vector&gt;</pre>
			<p lang="en-GB">Technically, we don’t need to include <code>ostream</code> because we get it already through including <code>fstream</code> and <code>stringstream</code>, but I like to include headers for things we are directly using. And while looking into the headers being included, I noticed that we were including <code>iostream</code>. I think I originally included <code>iostream</code> to get the definition of <code>std::endl</code>, but it seems that <code>endl</code> is actually declared in <code>ostream</code>. So, based on my rule to include headers being used, we should have been including <code>ostream</code> since the very beginning instead of <code>iostream</code>.</p>
			<p lang="en-GB">Back to <code>LogStream</code>, we need to change this class to inherit from <code>stringstream</code>, like this:</p>
			<pre class="source-code" lang="en-GB">
class LogStream : public std::stringstream
{
public:
    LogStream (std::string const &amp; filename,
        std::ios_base::openmode mode = ios_base::app)
    : mProceed(true), mFile(filename, mode)
    { }
    LogStream (LogStream const &amp; other) = delete;
    LogStream (LogStream &amp;&amp; other)
    : std::stringstream(std::move(other)),
    mProceed(other.mProceed), mFile(std::move(other.mFile))
    { }
    ~LogStream ()
    {
        if (not mProceed)
        {
            return;
        }
        mFile &lt;&lt; this-&gt;str();
        mFile &lt;&lt; std::endl;
    }
    LogStream &amp; operator = (LogStream const &amp; rhs) = delete;
    LogStream &amp; operator = (LogStream &amp;&amp; rhs) = delete;
    void ignore ()
    {
        mProceed = false;
    }
private:
    bool mProceed;
    std::fstream mFile;
};</pre>
			<p lang="en-GB">There is a new data member called <code>mProceed</code> that we set to <code>true</code> in the constructor. Since we no longer inherit from <code>std::fstream</code>, we now need a data member that is a file stream. We also need to initialize the <code>mFile</code> member. The move copy constructor needs to initialize the<a id="_idIndexMarker406"/> data members, and the destructor checks if the logging should proceed or not. If the logging should proceed, then the string content of <code>stringstream</code> is sent to the file stream.</p>
			<p lang="en-GB">We still haven’t implemented the filtering, but we’re getting close. This change gets us to the point where we can control the logging. The logging will proceed unless we call <code>ignore</code> before the destructor is run. This simple change will let us build and test to make sure that we haven’t broken anything.</p>
			<p lang="en-GB">Running the test application shows the same two test failures as before related to the filtering. The main thing is that the other tests continue to pass, which shows that the changes to use <code>stringstream</code> are working as before when we were streaming directly to the file stream.</p>
			<p lang="en-GB">It’s important when making pivotal changes such as switching streams to make sure that nothing breaks. This is why I made the change with a hardcoded choice to always log. We can use the TDD tests we already have to verify that the stream change works before making more changes to add filtering.</p>
			<p lang="en-GB">Let’s take the next change to the <code>log</code> function in two parts. We’re going to need the full collection of active tags after figuring out which of the default tags have been overridden. Instead <a id="_idIndexMarker407"/>of sending the tags to the stream, we can first put them into an active collection, like this:</p>
			<pre class="source-code" lang="en-GB">
inline LogStream log (std::vector&lt;Tag const *&gt; tags = {})
{
    auto const now = std::chrono::system_clock::now();
    std::time_t const tmNow =          std::chrono::system_clock::to_time_t(now);
    auto const ms = duration_cast&lt;std::chrono::milliseconds&gt;(
        now.time_since_epoch()) % 1000;
    LogStream ls("application.log");
    ls &lt;&lt; std::put_time(std::gmtime(&amp;tmNow),        "%Y-%m-%dT%H:%M:%S.")
        &lt;&lt; std::setw(3) &lt;&lt; std::setfill('0')         &lt;&lt; std::to_string(ms.count());
    std::map&lt;std::string, Tag const *&gt; activeTags;
    for (auto const &amp; defaultTag: getDefaultTags())
    {
        activeTags[defaultTag.first] = defaultTag.second.get();
    }
    for (auto const &amp; tag: tags)
    {
        activeTags[tag-&gt;key()] = tag;
    }
    for (auto const &amp; activeEntry: activeTags)
    {
        ls &lt;&lt; " " &lt;&lt; activeEntry.second-&gt;text();
    }
    ls &lt;&lt; " ";
    // Filtering will go here.
    return ls;
}</pre>
			<p lang="en-GB">This not only gets us the active collection, but it also seems simpler. We let the map handle the overrides by first putting all the default tags into the map and then putting all the provided tags into the map. Building and running the test application shows that the change hasn’t broken anything new. So, we’re ready for the next part, which is comparing the filtering clauses with the active tags.</p>
			<p lang="en-GB">The filtering needs to<a id="_idIndexMarker408"/> change the last part of the <code>log</code> function where the comment indicates that filtering will go, like this:</p>
			<pre class="source-code" lang="en-GB">
    bool proceed = true;
    for (auto const &amp; clause: getFilterClauses())
    {
        proceed = false;
        bool allLiteralsMatch = true;
        for (auto const &amp; normal: clause.second.normalLiterals)
        {
            // We need to make sure that the tag is
            // present and with the correct value.
            if (not activeTags.contains(normal-&gt;key()))
            {
                allLiteralsMatch = false;
                break;
            }
            if (activeTags[normal-&gt;key()]-&gt;text() !=
                normal-&gt;text())
            {
                allLiteralsMatch = false;
                break;
            }
        }
        if (not allLiteralsMatch)
        {
            continue;
        }
        for (auto const &amp; inverted:             clause.second.invertedLiterals)
        {
            // We need to make sure that the tag is either
            // not present or has a mismatched value.
            if (activeTags.contains(inverted-&gt;key()))
            {
                if (activeTags[inverted-&gt;key()]-&gt;text() !=
                    inverted-&gt;text())
                {
                    break;
                }
                allLiteralsMatch = false;
                break;
            }
        }
        if (allLiteralsMatch)
        {
            proceed = true;
            break;
        }
    }
    if (not proceed)
    {
        ls.ignore();
    }
    return ls;</pre>
			<p lang="en-GB">The logic is a little complicated, and this is a case where I found it easier to implement the logic almost completely<a id="_idIndexMarker409"/> instead of trying to break the change into multiple parts. Here’s what the code does.
Because we are using DNF logic, we can treat each clause separately. We start out as if we will proceed with the log, just in case there are no filters set at all. If there are any filters, then for each one, we start out as if we will not proceed. But we also set a new <code>bool</code> variable that assumes that all the literals will match until proven otherwise. We’ll treat a clause without any literals as a sign that we should proceed with the log.</p>
			<p lang="en-GB">For checking the literals, we have two types: normal and inverted. For the normal literals, the tags must all be present in the active tags and have matching values. If any tag is missing or has the wrong value, then we did not match all the literals for this clause. We’ll continue because there might be another clause that will match. This is what I mean about treating each clause separately.</p>
			<p lang="en-GB">Assuming we matched all the normal literals, we must still check the inverted literals. Here, the logic is reversed, and we need to make sure that either the tag is not present or that it has the wrong value.</p>
			<p lang="en-GB">Once we’ve checked all the clauses or found a clause that matches all the literals, the code makes one last check to see if the log should proceed or not. If not, then we call <code>ignore</code>, which will stop the log message from being sent to the output log file.</p>
			<p lang="en-GB">This approach makes a decision about whether or not to proceed at the time that the <code>log</code> function is called <a id="_idIndexMarker410"/>based on the default tags and tags sent to the <code>log</code> function. We’ll let the calling code send whatever information is desired to the stream. The information will only make it all the way to the output log file if <code>ignore</code> was not called.</p>
			<p lang="en-GB">Everything builds and runs now, and we get all tests passing again, like this:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">Running 1 test suites</strong>
<strong class="bold" lang="">--------------- Suite: Single Tests</strong>
<strong class="bold" lang="">------- Test: Message can be tagged in log</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: log needs no namespace when used with LogLevel</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Default tags set in main appear in log</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Multiple tags can be used in log</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Tags can be streamed to log</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Tags can be used to filter messages</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Overridden default tag not used to filter messages</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Simple message can be logged</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Complicated message can be logged</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">-----------------------------------</strong>
<strong class="bold" lang="">Tests passed: 9</strong>
<strong class="bold" lang="">Tests failed: 0</strong></pre>
			<p lang="en-GB">This shows that the filtering is working! At least, for the equality of the tags. Testing whether or not a tag is present with a matching value is a good start, but our microservices developer will need more power than this. Maybe we will need to log only if a count tag has a value greater than 100 or some other comparison that involves a numeric value greater or lesser than a specified filter value. This is what I meant when I said that I implemented the filtering logic <em class="italic" lang="">almost</em> completely. I got the logic and all the loops and breaks working for tag equality. We should be able to use the same basic structure of the code for relative comparisons in the next section.</p>
			<p lang="en-GB">There’s one more thing to add before we start relative comparisons, and this is important. Whenever code is added like what I did with the DNF logic without a test to back it up, we need to<a id="_idIndexMarker411"/> add a test. Otherwise, a missed test has a way of getting pushed back until it’s forgotten about completely.</p>
			<p lang="en-GB">And this new test helped out in another way. It caught a problem with the initial definition of the <code>addFilterLiteral</code> function. The original function defined a <code>bool</code> parameter called <code>invert</code> that had a default value of <code>false</code>. The default value meant that creating a normal literal could leave out the parameter and use the default. But to create an inverted literal, the function required that the <code>true</code> value be passed. This seemed backward to me. I realized that it would make more sense to pass <code>false</code> for this parameter to get an inverted literal, and that <code>true</code> should create a normal literal. So, I went back and changed the function definition and implementation. The test caught a problem with the usage of a function that went unnoticed at first.</p>
			<p lang="en-GB">Here is the new test that will create an inverted filter:</p>
			<pre class="source-code" lang="en-GB">
TEST("Inverted tag can be used to filter messages")
{
    MereTDD::SetupAndTeardown&lt;TempFilterClause&gt; filter;
    MereMemo::addFilterLiteral(filter.id(), green, false);
    std::string message = "inverted ";
    message += Util::randomString();
    MereMemo::log(info) &lt;&lt; message;
    bool result = Util::isTextInFile(message,          "application.log");
    CONFIRM_FALSE(result);
}</pre>
			<p lang="en-GB">Building and running shows that the new test passes, and we have confirmed that we can filter log messages that contain a matching tag when the filter is inverted. This test uses the default <code>green</code> tag that is added to log messages and makes sure that the log message does not appear in the output log file because of the presence of the <code>green</code> tag.</p>
			<p lang="en-GB">The next section will enhance the filtering to allow filtering based on relative values of tags instead of just exact matches.</p>
			<h1 id="_idParaDest-102" lang="en-GB"><a id="_idTextAnchor107"/>Enhancing filtering for relative matches</h1>
			<p lang="en-GB">TDD encourages incremental changes<a id="_idIndexMarker412"/> and enhancements when designing software. Write a test, get something working, and then write a more elaborate test that enhances the design. We’ve been following a TDD approach to designing the logging library, and the previous section was a great example. We got filtering working in the previous section, but only for tag equality.</p>
			<p lang="en-GB">In other words, we can now filter log messages based on the presence or absence of a tag that matches a filter literal tag. We compare the tags to see if both the key and value match. That was a great first step because even getting that far required a lot of work. Imagine if we had tried to go all the way and supported, for example, logging only if a count tag had a value greater than 100.</p>
			<p lang="en-GB">When designing software using TDD, it really helps to look for obvious steps that can be taken and confirmed to work before taking the next step. Some steps might be bigger than others, and that’s okay as long as you don’t go straight to the final implementation because that will only lead to longer development times and more frustration. It’s so much better to confirm some parts of the design work as expected and have tests to make sure those parts continue to work. It’s like building a house with a solid foundation. It’s much better to make sure that the foundation really is solid before building the walls, and you want to have tests to make sure that the walls stay straight while the roof is being added.</p>
			<p lang="en-GB">We have working tests in place to make sure that basic filtering works. We are testing both normal and inverted literals. We check for matching tags by comparing the text of the tags, which works for all value types. For relative filters such as a count greater than 100, we’re going to need a solution that knows how to compare the values with a numeric check instead of a string match.</p>
			<p lang="en-GB">We can start by figuring out how to represent a filter literal to check for greater or lesser numeric values. Here is a test that can go in <code>Tags.cpp</code> that sets a filter based on a count greater than 100:</p>
			<pre class="source-code" lang="en-GB">
TEST("Tag values can be used to filter messages")
{
    MereTDD::SetupAndTeardown&lt;TempFilterClause&gt; filter;
    MereMemo::addFilterLiteral(filter.id(),
        Count(100, MereMemo::TagOperation::GreaterThan));
    std::string message = "values ";
    message += Util::randomString();
    MereMemo::log(Count(1)) &lt;&lt; message;
    bool result = Util::isTextInFile(message,          "application.log");
    CONFIRM_FALSE(result);
    MereMemo::log() &lt;&lt; Count(101) &lt;&lt; message;
    result = Util::isTextInFile(message, "application.log");
    CONFIRM_FALSE(result);
    MereMemo::log(Count(101)) &lt;&lt; message;
    result = Util::isTextInFile(message, "application.log");
    CONFIRM_TRUE(result);
}</pre>
			<p lang="en-GB">What’s new with this test? The main part is the way the <code>Count</code> tag is created. We previously only added a value when creating tags, like this:</p>
			<pre class="source-code" lang="en-GB">
Count(100)</pre>
			<p lang="en-GB">And because we now need <a id="_idIndexMarker413"/>a way to specify if something should have a relative value, we need a place to say what kind of relative value and a method to communicate which relative value to use. I think an enumeration of various relative comparisons should work. We probably don’t need more advanced relative comparisons such as <code>"between"</code> because we can always use DNF to express more elaborate comparisons. For a brief overview of how we’re using DNF, refer to the <em class="italic" lang="">Designing tests to filter log messages</em> section of this chapter.</p>
			<p lang="en-GB">At the tag level, all we really need is to know how to compare one value against another. So, it makes sense to specify what type of comparison is needed when constructing a tag, like this:</p>
			<pre class="source-code" lang="en-GB">
Count(100, MereMemo::TagOperation::GreaterThan)</pre>
			<p lang="en-GB">It might make sense to treat a tag with a comparison operator such as <code>GreaterThan</code> as a completely different type, but I think we can get away with a single type. With this solution, any tag can have a comparison operator, but it only makes sense to specify comparison operators for tags that will be used in filters.</p>
			<p lang="en-GB">What happens if a regular tag without a comparison operator is used in a filter? Then, we should treat that as an exact match because that’s what the existing tests expect.</p>
			<p lang="en-GB">Back to the new test. It first creates a filter that should only let a message be logged if it has a count tag with a value greater than 100. It first tries to log a message with a count of only 1, and this is verified to not exist in the log file.</p>
			<p lang="en-GB">Then, the test creates <a id="_idIndexMarker414"/>a count of 101 but does not use the count tag directly in the <code>log</code> function call. This also should not make it to the output log file because we only want to filter on tags that are either default or directly specified when calling <code>log</code>.</p>
			<p lang="en-GB">And finally, the test calls <code>log</code> with a count tag of 101, and this message is verified to appear in the log file.</p>
			<p lang="en-GB">Now that we have a test, how will we get it working? Let’s define comparison operations first in <code>Log.h</code>, right before the <code>TagType</code> class, like this:</p>
			<pre class="source-code" lang="en-GB">
enum class TagOperation
{
    None,
    Equal,
    LessThan,
    LessThanOrEqual,
    GreaterThan,
    GreaterThanOrEqual
};</pre>
			<p lang="en-GB">We’ll use the <code>None</code> operation for regular tags that only want to express a value. The <code>Equal</code> operation will act like the existing equality checks between tags. And the real change is to support less than, less than or equal, greater than, and greater than or equal comparisons.</p>
			<p lang="en-GB">We need to compare one tag with another without worrying about what the tags represent. A good way to do this is to declare a pure virtual method in the <code>Tag</code> class, just like what we did for cloning. The new method is called <code>match</code> and can go right after the <code>clone</code> method, like this:</p>
			<pre class="source-code" lang="en-GB">
    virtual std::unique_ptr&lt;Tag&gt; clone () const = 0;
    virtual bool match (Tag const &amp; other) const = 0;</pre>
			<p lang="en-GB">Here’s where things get a bit difficult. I had wanted to wrap everything up in the <code>TagType</code> class. The idea was to first check the key of each tag being compared and make sure that the tags were the same. If they have the same key, then check the value. If they don’t have the same key, then they must not match. At least, that was a good plan. I ran into problems <a id="_idIndexMarker415"/>when trying to implement the <code>match</code> method in one place that could compare strings with strings, numerics with numerics, and Booleans with Booleans. A tag such as <code>CacheHit</code> has a <code>bool</code> value type, and the only operation that makes sense is <code>Equal</code> comparisons. Tags based on strings need to compare differently than numerics. And if we really want to get elaborate, doubles should compare differently than an <code>int</code> type.</p>
			<p lang="en-GB">Each derived tag type could know how to compare, but I didn’t want to change the derived types and make them each implement the <code>match</code> method, especially after all the work we went through to avoid the derived types implementing <code>clone</code>. The best solution I came up with was to create an additional set of intermediate classes that derive from <code>TagType</code>. Each new class is based on the type of the value. Since we only support five different tag value types, this is not a bad solution. The main benefit is that the derived tag types that the caller will use are only slightly affected. Here’s a new <code>StringTagType</code> class that inherits from <code>TagType</code> so that you can see what I mean. Place this new class in <code>Log.h</code>, right after the <code>TagType</code> class:</p>
			<pre class="source-code" lang="en-GB">
template &lt;typename T&gt;
class StringTagType : public TagType&lt;T, std::string&gt;
{
protected:
    StringTagType (std::string const &amp; value,
        TagOperation operation)
    : TagType&lt;T, std::string&gt;(value, operation)
    { }
    bool compareTagTypes (std::string const &amp; value,
        TagOperation operation,
        std::string const &amp; criteria) const override
    {
        int result = value.compare(criteria);
        switch (operation)
        {
        case TagOperation::Equal:
            return result == 0;
        case TagOperation::LessThan:
            return result == -1;
        case TagOperation::LessThanOrEqual:
            return result == 0 || result == -1;
        case TagOperation::GreaterThan:
            return result == 1;
        case TagOperation::GreaterThanOrEqual:
            return result == 0 || result == 1;
        default:
            return false;
        }
    }
};</pre>
			<p lang="en-GB">This class is all about comparing string-based tags with other string-based tags. The class implements a new virtual method I’ll explain in just a moment, called <code>compareTagTypes</code>. The only thing this method has to worry about is how to compare two strings based on an operation. One of the strings is called <code>value</code> and the other is called <code>criteria</code>. It’s important to not mix up the <code>value</code> and <code>criteria</code> strings because, for<a id="_idIndexMarker416"/> example, while <code>"ABC"</code> is greater than <code>"AAA"</code>, the same is not true the other way around. The method uses the <code>compare</code> method in the <code>std::string</code> class to do the comparisons.</p>
			<p lang="en-GB">You can see that the <code>StringTagType</code> class inherits from <code>TagType</code> and passes on the <code>T</code> derived type while hardcoding <code>std::string</code> for the value type. One interesting thing about the constructor is the need to repeat the template parameters when constructing <code>TagType</code> in the constructor initialization list. Normally, this should not be required, but maybe there is some arcane rule that only applies here that I’m not aware of whereby the compiler does not look at the <code>TagType</code> parameters in the parent class list to figure out the template parameters.</p>
			<p lang="en-GB">Before moving on to the changes in <code>TagType</code>, let’s look at how a derived tag class such as <code>LogLevel</code> will use the new <code>StringTagType</code> intermediate class. Change the <code>LogLevel</code> class to look like this:</p>
			<pre class="source-code" lang="en-GB">
class LogLevel : public StringTagType&lt;LogLevel&gt;
{
public:
    static constexpr char key[] = "log_level";
    LogLevel (std::string const &amp; value,
        TagOperation operation = TagOperation::None)
    : StringTagType(value, operation)
    { }
};</pre>
			<p lang="en-GB">The only change needed for <code>LogLevel</code> is to change the parent class from <code>TagType</code> to the more specific <code>StringTagType</code>. We no longer need to worry about specifying <code>std::string</code> as a template parameter because that information is built into the <code>StringTagType</code> class. I <a id="_idIndexMarker417"/>had wanted to keep the derived tag classes completely unchanged, but this slight modification is not so bad because there is no need to write any comparison code.</p>
			<p lang="en-GB">There is more work to be done in the <code>TagType</code> class. In the protected section at the end of the <code>TagType</code> class, make these changes:</p>
			<pre class="source-code" lang="en-GB">
protected:
    TagType (ValueT const &amp; value,
        TagOperation operation)
    : Tag(T::key, value), mValue(value), mOperation(operation)
    { }
    virtual bool compareTagTypes (ValueT const &amp; value,
        TagOperation operation,
        ValueT const &amp; criteria) const
    {
        return false;
    }
    ValueT mValue;
    TagOperation mOperation;
};</pre>
			<p lang="en-GB">The protected constructor needs to store the operation, and this is where the virtual <code>compareTagTypes</code> method is <a id="_idIndexMarker418"/>declared and given a default implementation that returns <code>false</code>. The <code>TagType</code> class also implements the <code>match</code> method that was declared in the <code>Tag</code> class, like this:</p>
			<pre class="source-code" lang="en-GB">
    bool match (Tag const &amp; other) const override
    {
        if (key() != other.key())
        {
            return false;
        }
        TagType const &amp; otherCast =                 static_cast&lt;TagType const &amp;&gt;(other);
        if (mOperation == TagOperation::None)
        {
            switch (otherCast.mOperation)
            {
            case TagOperation::None:
                return mValue == otherCast.mValue;
            default:
                return compareTagTypes(mValue,
                    otherCast.mOperation,
                    otherCast.mValue);
            }
        }
        switch (otherCast.mOperation)
        {
        case TagOperation::None:
            return compareTagTypes(otherCast.mValue,
                mOperation,
                mValue);
        default:
            return false;
        }
    }</pre>
			<p lang="en-GB">The <code>match</code> method first checks the keys to see whether the two tags being compared have the same key. If the keys match, then the types are assumed to be the same and the other tag is cast to the same <code>TagType</code>.</p>
			<p lang="en-GB">We have a couple of scenarios to figure out. At least one of the tags should be a normal tag without an operation and is the tag we’ll call the value. The other tag can also be a regular tag without an operation, in which case all we need to do is compare the two values for equality.</p>
			<p lang="en-GB">If one of the two tags is <a id="_idIndexMarker419"/>normal and the other has a comparison operation other than <code>None</code>, then the tag with the comparison operator set is treated as the criteria. Remember that it’s important to know which is the value and which is the criteria. The code needs to handle the case where we are comparing a value with a criterion or the case where we are comparing a criterion with a value. We call into the virtual <code>compareTagTypes</code> method to do the actual comparison, making sure to pass <code>mValue</code> and <code>otherCast.mValue</code> according to which is the normal tag and which is the criteria.</p>
			<p lang="en-GB">And finally, if both tags have the comparison operator set to something other than <code>None</code>, then we treat the match as <code>false</code> because it doesn’t make sense to compare two criteria tags against each other.</p>
			<p lang="en-GB">There’s a bit of complexity wrapped up in the <code>match</code> method that I wanted to implement in only one spot. This is why I decided to keep the <code>TagType</code> class and create value type-specific intermediate classes such as <code>StringTagType</code>. The <code>TagType</code> class implements part of the comparison by figuring out what is being compared with what and then relies on the type-specific classes to do the actual comparison.</p>
			<p lang="en-GB">We need to add other type-specific intermediate tag classes. All of these go in <code>Log.h</code>, right after the <code>StringTagType</code> class. Here is the one for the <code>int</code> type:</p>
			<pre class="source-code" lang="en-GB">
template &lt;typename T&gt;
class IntTagType : public TagType&lt;T, int&gt;
{
protected:
    IntTagType (int const &amp; value,
        TagOperation operation)
    : TagType&lt;T, int&gt;(value, operation)
    { }
    bool compareTagTypes (int const &amp; value,
        TagOperation operation,
        int const &amp; criteria) const override
    {
        switch (operation)
        {
        case TagOperation::Equal:
            return value == criteria;
        case TagOperation::LessThan:
            return value &lt; criteria;
        case TagOperation::LessThanOrEqual:
            return value &lt;= criteria;
        case TagOperation::GreaterThan:
            return value &gt; criteria;
        case TagOperation::GreaterThanOrEqual:
            return value &gt;= criteria;
        default:
            return false;
        }
    }
};</pre>
			<p lang="en-GB">This class is almost identical to the <code>StringTagType</code> class with changes designed for an <code>int</code> type instead of a string. Mainly, the comparisons can be done with simple arithmetic operators instead of calling the string <code>compare</code> method.</p>
			<p lang="en-GB">I thought about using this class for all the <code>int</code>, <code>long long</code>, and <code>double</code> arithmetic types, but that would have meant it would still need a template parameter for the actual type. Then, the question becomes one of consistency. Should the <code>StringTagType</code> class also have a template parameter to specify the type of string? Maybe. There are different kinds of strings so that almost makes sense. But what about the <code>bool</code> type? We’ll need an intermediate class for Booleans too, and it seems strange to specify a <code>bool</code> template<a id="_idIndexMarker420"/> type when the class name will already have <code>bool</code> in it. So, to make everything consistent, I decided to go with separate intermediate classes for all the supported types. We’ll handle ints with the <code>IntTagType</code> class and create another class called <code>LongLongTagType</code>, like this:</p>
			<pre class="source-code" lang="en-GB">
template &lt;typename T&gt;
class LongLongTagType : public TagType&lt;T, long long&gt;
{
protected:
    LongLongTagType (long long const &amp; value,
        TagOperation operation)
    : TagType&lt;T, long long&gt;(value, operation)
    { }
    bool compareTagTypes (long long const &amp; value,
        TagOperation operation,
        long long const &amp; criteria) const override
    {
        switch (operation)
        {
        case TagOperation::Equal:
            return value == criteria;
        case TagOperation::LessThan:
            return value &lt; criteria;
        case TagOperation::LessThanOrEqual:
            return value &lt;= criteria;
        case TagOperation::GreaterThan:
            return value &gt; criteria;
        case TagOperation::GreaterThanOrEqual:
            return value &gt;= criteria;
        default:
            return false;
        }
    }
};</pre>
			<p lang="en-GB">This is the class I am not very happy about because it duplicates exactly the implementation for ints. But<a id="_idIndexMarker421"/> the one thing I am happy about is the consistency it creates. It means that all the intermediate tag-type classes can be used the same way.</p>
			<p lang="en-GB">The next class is for doubles, and while it also has the same implementation, there is the potential to compare doubles differently because they don’t compare like the integral types. There is always a little room for errors and slight discrepancies between floating-point values. For now, we’re not going to do anything different about doubles, but this class will give us the ability to compare them differently if needed. The class looks like this:</p>
			<pre class="source-code" lang="en-GB">
template &lt;typename T&gt;
class DoubleTagType : public TagType&lt;T, double&gt;
{
protected:
    DoubleTagType (double const &amp; value,
        TagOperation operation)
    : TagType&lt;T, double&gt;(value, operation)
    { }
    bool compareTagTypes (double const &amp; value,
        TagOperation operation,
        double const &amp; criteria) const override
    {
        switch (operation)
        {
        case TagOperation::Equal:
            return value == criteria;
        case TagOperation::LessThan:
            return value &lt; criteria;
        case TagOperation::LessThanOrEqual:
            return value &lt;= criteria;
        case TagOperation::GreaterThan:
            return value &gt; criteria;
        case TagOperation::GreaterThanOrEqual:
            return value &gt;= criteria;
        default:
            return false;
        }
    }
};</pre>
			<p lang="en-GB">The last intermediate<a id="_idIndexMarker422"/> tag type class is for Booleans, and it does need to do something different. This class is really only interested in equality and looks like this:</p>
			<pre class="source-code" lang="en-GB">
template &lt;typename T&gt;
class BoolTagType : public TagType&lt;T, bool&gt;
{
protected:
    BoolTagType (bool const &amp; value,
        TagOperation operation)
    : TagType&lt;T, bool&gt;(value, operation)
    { }
    bool compareTagTypes (bool const &amp; value,
        TagOperation operation,
        bool const &amp; criteria) const override
    {
        switch (operation)
        {
        case TagOperation::Equal:
            return value == criteria;
        default:
            return false;
        }
    }
};</pre>
			<p lang="en-GB">Now that we have all the <a id="_idIndexMarker423"/>tags worked out, the place where comparison needs to be made is in the <code>log</code> function, which currently uses the text of the tags to compare the normal and inverted tags. Change the <code>normal</code> block to look like this:</p>
			<pre class="source-code" lang="en-GB">
        for (auto const &amp; normal: clause.second.normalLiterals)
        {
            // We need to make sure that the tag is
            // present and with the correct value.
            if (not activeTags.contains(normal-&gt;key()))
            {
                allLiteralsMatch = false;
                break;
            }
            if (not activeTags[normal-&gt;key()]-&gt;match(*normal))
            {
                allLiteralsMatch = false;
                break;
            }
        }</pre>
			<p lang="en-GB">The code still loops through the tags and checks for the existence of the keys involved. Once it finds that the tags exist and need to be compared, instead of getting the text of each tag and comparing for<a id="_idIndexMarker424"/> equality, the code now calls the <code>match</code> method.</p>
			<p lang="en-GB">The inverted block needs to change in a similar manner, like this:</p>
			<pre class="source-code" lang="en-GB">
        for (auto const &amp; inverted:             clause.second.invertedLiterals)
        {
            // We need to make sure that the tag is either
            // not present or has a mismatched value.
            if (activeTags.contains(inverted-&gt;key()))
            {
                if (activeTags[inverted-&gt;key()]-&gt;match(                   *inverted))
                {
                    allLiteralsMatch = false;
                }
                break;
            }
        }</pre>
			<p lang="en-GB">For the inverted loop, I was able to simplify the code a little. The real change is similar to the normal loop where the <code>match</code> method is called to make the comparison instead of directly comparing the tag text.</p>
			<p lang="en-GB">Before we can build and try out the new test, we need to update the other derived tag types in the test application. Just like how we needed to update the <code>LogLevel</code> tag class to use the new intermediate tag class, we need to change all the tag classes in <code>LogTags.h</code>. The first is the <code>Color</code> class, like this:</p>
			<pre class="source-code" lang="en-GB">
class Color : public MereMemo::StringTagType&lt;Color&gt;
{
public:
    static constexpr char key[] = "color";
    Color (std::string const &amp; value,
        MereMemo::TagOperation operation =
            MereMemo::TagOperation::None)
    : StringTagType(value, operation)
    { }
};</pre>
			<p lang="en-GB">The <code>Color</code> class is based on a string value type, just like <code>LogLevel</code>.</p>
			<p lang="en-GB">The <code>Size</code> tag type also uses a string and looks like this now:</p>
			<pre class="source-code" lang="en-GB">
class Size : public MereMemo::StringTagType&lt;Size&gt;
{
public:
    static constexpr char key[] = "size";
    Size (std::string const &amp; value,
        MereMemo::TagOperation operation =
            MereMemo::TagOperation::None)
    : StringTagType(value, operation)
    { }
};</pre>
			<p lang="en-GB">The <code>Count</code> and <code>Identity</code> tag types are based on an <code>int</code> type and a <code>long long</code> type respectively, and they<a id="_idIndexMarker425"/> look like this:</p>
			<pre class="source-code" lang="en-GB">
class Count : public MereMemo::IntTagType&lt;Count&gt;
{
public:
    static constexpr char key[] = "count";
    Count (int value,
        MereMemo::TagOperation operation =
            MereMemo::TagOperation::None)
    : IntTagType(value, operation)
    { }
};
class Identity : public MereMemo::LongLongTagType&lt;Identity&gt;
{
public:
    static constexpr char key[] = "id";
    Identity (long long value,
        MereMemo::TagOperation operation =
            MereMemo::TagOperation::None)
    : LongLongTagType(value, operation)
    { }
};</pre>
			<p lang="en-GB">And finally, the <code>Scale</code> and <code>CacheHit</code> tag types are based on a <code>double</code> type and a <code>bool</code> type, and look like this:</p>
			<pre class="source-code" lang="en-GB">
class Scale : public MereMemo::DoubleTagType&lt;Scale&gt;
{
public:
    static constexpr char key[] = "scale";
    Scale (double value,
        MereMemo::TagOperation operation =
            MereMemo::TagOperation::None)
    : DoubleTagType(value, operation)
    { }
};
class CacheHit : public MereMemo::BoolTagType&lt;CacheHit&gt;
{
public:
    static constexpr char key[] = "cache_hit";
    CacheHit (bool value,
        MereMemo::TagOperation operation =
            MereMemo::TagOperation::None)
    : BoolTagType(value, operation)
    { }
};</pre>
			<p lang="en-GB">The changes to each tag type<a id="_idIndexMarker426"/> were minimal. I think this is acceptable, especially because the tests that use the tag types don’t need to change. Let’s take another look at the test that started this section:</p>
			<pre class="source-code" lang="en-GB">
TEST("Tag values can be used to filter messages")
{
    MereTDD::SetupAndTeardown&lt;TempFilterClause&gt; filter;
    MereMemo::addFilterLiteral(filter.id(),
        Count(100, MereMemo::TagOperation::GreaterThan));
    std::string message = "values ";
    message += Util::randomString();
    MereMemo::log(Count(1)) &lt;&lt; message;
    bool result = Util::isTextInFile(message,          "application.log");
    CONFIRM_FALSE(result);
    MereMemo::log() &lt;&lt; Count(101) &lt;&lt; message;
    result = Util::isTextInFile(message, "application.log");
    CONFIRM_FALSE(result);
    MereMemo::log(Count(101)) &lt;&lt; message;
    result = Util::isTextInFile(message, "application.log");
    CONFIRM_TRUE(result);
}</pre>
			<p lang="en-GB">This test should make more sense now. It creates a <code>Count</code> tag with a value of <code>100</code> and a <code>TagOperation</code> tag of <code>GreaterThan</code>. The operation is what makes this tag into a criteria tag that can be compared with other instances of the <code>Count</code> tag to see if the count in the other instance is really greater than 100 or not.</p>
			<p lang="en-GB">Then, the test tries to log<a id="_idIndexMarker427"/> with a normal <code>Count</code> tag with a value of <code>1</code>. We know now how this will fail the match, and the log message will be ignored.</p>
			<p lang="en-GB">The test then tries to log with a <code>Count</code> tag of <code>101</code>, but this time, the tag is outside of the <code>log</code> function and will not be considered. The second log message will also be ignored without ever trying to call <code>match</code>.</p>
			<p lang="en-GB">The test then tries to log with a count of <code>101</code> inside the <code>log</code> function. This one should match because 101 is indeed greater than 100, and the message should appear in the output log file.</p>
			<p lang="en-GB">Notice how the test is structured. It starts out with a couple of known scenarios that should not succeed before finally moving on to a scenario that should succeed. This is a good pattern for you to follow when writing your tests and helps to confirm that everything is working as designed.</p>
			<p lang="en-GB">The filtering is now working completely even with relative comparisons! The rest of this chapter will provide insights and advice to help you design better tests.</p>
			<h1 id="_idParaDest-103" lang="en-GB"><a id="_idTextAnchor108"/>When is testing too much?</h1>
			<p lang="en-GB">I remember a story I heard once about a child that was in a hospital in intensive care and was connected to all the monitoring machines, including one that watched the heartbeat electrical signals. The child’s condition took a sudden turn for the worse and showed all the signs <a id="_idIndexMarker428"/>of a lack of blood flow to the brain. The doctors couldn’t figure out why because the heart was beating, and they were about to send the child for a scan to look for a blood clot that would cause a stroke when one doctor thought to listen for a heartbeat. There was none. The machine showed that the heart was beating but there was no sound to confirm the beat. The doctors were able to determine that swelling around the heart was putting pressure on the heart and preventing it from beating. I don’t know how, but they reduced the swelling and the child’s heart started pumping again.</p>
			<p lang="en-GB">Why does this story come to mind? Because the machine that monitored heart activity was looking for electrical signals. In normal circumstances, the presence of proper electrical signals is a great way to monitor heart activity. But it’s indirect. Electrical signals are <em class="italic" lang="">how</em> the heart beats. The signals cause the heart to beat, but as the story shows, they don’t always mean <em class="italic" lang="">that</em> the heart is beating.</p>
			<p lang="en-GB">It’s easy to fall into the same trap with software testing. We think that because we have a lot of tests, the software must be well-tested. But are the tests really testing the right things? In other words, is each test looking for tangible results? Or are some tests instead looking at how the results would normally be obtained?</p>
			<p lang="en-GB">When is testing too much? My answer is that testing is good, and every test that you can add will normally help to improve the quality of the software. Testing can become too much if it starts looking at the wrong things.</p>
			<p lang="en-GB">It’s not that a test that is looking at the wrong thing is bad. The bad part comes when we rely on that test to predict some outcome. It’s much better to directly confirm the desired outcome than it is to confirm some internal step along the way.</p>
			<p lang="en-GB">For example, have a look at a recent test that added a <code>filter</code> literal:</p>
			<pre class="source-code" lang="en-GB">
TEST("Tag values can be used to filter messages")
{
    MereTDD::SetupAndTeardown&lt;TempFilterClause&gt; filter;
    MereMemo::addFilterLiteral(filter.id(),
        Count(100, MereMemo::TagOperation::GreaterThan));</pre>
			<p lang="en-GB">We could have verified that a filter was indeed added to the collection. We have access to call the <code>getFilterClauses</code> function from within the test and examine each clause and look for the literal just added. We could even confirm that the literal itself behaves as expected and has the value <code>100</code> assigned to the literal.</p>
			<p lang="en-GB">The test doesn’t do this. Why? Because that is how filters work. Looking for a filter in the collection would be like watching heartbeat electrical signals. The ability to call <code>getFilterClauses</code> is a detail that exists just because of our desire to keep the logging library contained in a<a id="_idIndexMarker429"/> single header file. The function is not intended to be called by customers. The test instead looks at the results of setting the filter.</p>
			<p lang="en-GB">Once the filter is set, the test tries to log a few messages and makes sure that the results match the expectations.</p>
			<p lang="en-GB">What if the logging library needed some type of custom collection? Would it make sense to test that the filter literal was properly added to the collection then? Again, my answer is no, at least not here in the filter test.</p>
			<p lang="en-GB">If the project needed a custom collection, then it would need tests to make sure that the collection works. I’m not saying to skip the tests for any code that needs to be written just because that code serves a supporting role within a project. What I am saying is to keep the tests focused on what they are testing. What is the desired outcome that the test is looking to confirm? In the case of the filters test, the desired outcome is that some log messages will be ignored while others will appear in the output log file. The test directly sets up the conditions needed to confirm the outcome, causes the needed steps to be run, and confirms the outcome. Along the way, the collection and all the matching code will be tested too in an indirect manner.</p>
			<p lang="en-GB">If we have a custom collection involved, then indirect testing is not enough. But direct testing inside the filter test is also not appropriate. What we need is a set of tests designed to directly test the custom collection itself.</p>
			<p lang="en-GB">So, if we have a need for a supporting component such as a custom collection, then that component needs to be tested by itself. The tests can be included in the same overall test application. Maybe put them into their own test suite. Think about the code that will be using the component as a customer of the component and think about the customer’s needs.</p>
			<p lang="en-GB">If the component is big enough or serves a more general purpose so that it might be useful outside of the project, then giving it a project on its own is a good idea. This is what we’re doing in this book by treating the unit test library and the logging library as separate projects.</p>
			<p lang="en-GB">One final thought about when testing is too much will help you to identify when you are in this situation because it can be easy to slide into too much indirect testing. If you find that you need to change a lot of tests after refactoring how your software works, then you could be testing too much.</p>
			<p lang="en-GB">Think about how this chapter added filters and was able to keep the existing tests almost entirely unchanged. Sure—we had to change the code underneath by adding a whole set of intermediate tag-type classes, but we did not have to rewrite the existing tests.</p>
			<p lang="en-GB">If a refactor causes the tests<a id="_idIndexMarker430"/> to also need a lot of work, then either you are testing too much or the problem could be that you are changing the desired usage of the software. Be careful of changing how you want your design to be used, because if you are following TDD, then that initial usage is one of the first things you want to get right. Once you have the software designed in a way that makes it easy and intuitive to use, then be extra cautious about any refactoring that would cause changes to the test.</p>
			<p lang="en-GB">The next section explains a topic related to this section. Once you know what needs to be tested, a question that often comes up next is how to design software to make it easy to be tested, and specifically, if the tests need to reach inside the inner workings of the components being tested.</p>
			<h1 id="_idParaDest-104" lang="en-GB"><a id="_idTextAnchor109"/>How intrusive should tests be?</h1>
			<p lang="en-GB">There is a benefit to designing software that is easy to test. To me, this starts by following TDD and writing tests first that make use of the software as the customer would most expect it to be used. This is the most important consideration.</p>
			<p lang="en-GB">You don’t want to make the user of your software question why extra steps are needed or why it is difficult to understand how to use your software. And by customer or user, I mean anybody that will use your software. A customer or user could be another software developer who needs to use a library that is being designed. The tests are a great example of what a user must go through. If there is an extra step that a user must take that provides no value to the user, then that step should be removed, even if the step makes it easier to test the code.</p>
			<p lang="en-GB">Maybe the extra step can be hidden from the user, and if so, then it might make sense to keep it as long as it makes the testing better. Anytime a test relies on something extra that the user doesn’t need or know about, then the test is intruding on the software design.</p>
			<p lang="en-GB">I’m not saying this is a bad thing. Intrusion often has a negative meaning. It can be good for a test to be able to reach inside a component as long as you are aware that this makes it easy to fall into the trap that the previous section describes: too much testing.</p>
			<p lang="en-GB">The main thing to understand is that anything that a test uses should become part of a supported interface. If a component exposes an inner working so that it can be confirmed by a test, then this inner working should be accepted as part of the design and not some internal <a id="_idIndexMarker431"/>detail that is subject to change at any time.</p>
			<p lang="en-GB">The difference between what this section describes and the previous section comes down to what is agreed to be supported. We get into too much testing when we try to test things that either should be tested someplace else or that are internal details and should be off-limits to testing. If there’s an internal detail that is stable and agreed should not change, and if that internal detail makes testing more reliable, then it might make sense for a test to use the detail.</p>
			<p lang="en-GB">I remember one project I worked on many years ago<a id="_idIndexMarker432"/> that exposed the internal state of classes through <strong class="bold" lang="">Extensible Markup Language</strong> (<strong class="bold" lang="">XML</strong>). The state could be quite complicated at times, and using XML let the tests confirm that the state was configured correctly. The XML would then be passed to other classes that would make use of it. The user was not aware of the XML and did not need to use it, but the tests relied on it to break complicated scenarios in half. One half of the test could make sure that the configuration was correct by verifying the XML matched. The other half could then make sure that the actions taken worked properly when supplied with known XML input data.</p>
			<p lang="en-GB">The software did not have to be designed like this to use XML. It could even be said that the tests intruded on the design. The XML became a supported part of the design. What could have been just a detail became something more. But I would go further and say that the use of XML in this case never started out as a detail. It was a conscious design decision that was added for the specific reason of making the testing more reliable.</p>
			<p lang="en-GB">So far, we’ve only explored unit tests. That’s why this book starts out by building a unit test library. When considering what should be tested and how intrusive the tests should be, there are other types of tests that the next section will begin explaining.</p>
			<h1 id="_idParaDest-105" lang="en-GB"><a id="_idTextAnchor110"/>Where do integration or system tests go in TDD?</h1>
			<p lang="en-GB">Sometimes, it’s good to create a test that brings together multiple components and confirms that the overall system being built works as expected. These are called integration tests because they integrate multiple components to make sure they work well together. Or, the tests can be<a id="_idIndexMarker433"/> called system tests because they test the entire system. The two names are mostly interchangeable with each other.</p>
			<p lang="en-GB">For our microservice developer who is the target customer of the logging library, there will likely be unit tests for an<a id="_idIndexMarker434"/> individual service, and even unit tests for various classes and functions inside the service. Some of the tests for a particular service might even be called integration tests, but usually, an integration test will be working with multiple services. The services should work together to accomplish something bigger. So, having tests that make sure the overall results can be reached will help improve the reliability and quality of all the services involved.</p>
			<p lang="en-GB">What if you’re not building a set of microservices? What if you’re building a desktop application to manage a cryptocurrency wallet? You can still make use of system tests. Maybe you want a system test that opens a new wallet and makes sure it can synchronize the blockchain data up to the current block, or maybe you want another system test that stops the synchronization and then resumes it again. Each of these tests will make use of many different components such as classes and functions in the application. System tests make sure that some higher-level goal can be accomplished and, more importantly, system tests use real data that is downloaded over the network.</p>
			<p lang="en-GB">It’s common for a system test to take a long time to complete. Add in multiple system tests, and the entire set of tests might need several hours to run. Or, maybe there are tests that continuously use the software for a day or more.</p>
			<p lang="en-GB">Whether or not a particular test is called a unit test or a system test often comes down to how long it takes to run and which resources are needed. Unit tests tend to be quick and are able to determine whether something passes without needing to rely on other external factors or components. If a test needs to request information from another service, then that’s a good sign that the test is more of an integration test instead of a unit test. A unit test should never need to download data from a network.</p>
			<p lang="en-GB">When it comes to TDD, in order for a test to actually drive the design—as the name implies—then the test will normally be of the unit test variety. Don’t get me wrong—system tests are important and can help uncover strange usage patterns that can be missed by unit tests. But the typical system test or integration test is not intended to make sure that the design is easy to use and intuitive. Instead, a system test makes sure that a higher-level goal can be reached and that nothing breaks the ultimate goals.</p>
			<p lang="en-GB">If there’s any difference between system tests and integration tests, then in my mind, it comes down to integration tests being all about making sure that multiple components work well together, while a <a id="_idIndexMarker435"/>system test is more about the higher-level goals. Both integration tests and <a id="_idIndexMarker436"/>system tests are at a higher level than unit tests.</p>
			<p lang="en-GB">TDD makes more use of unit tests when creating the initial designs of small components and functions. And then, TDD makes use of system and integration tests to make sure that the overall solution makes sense and works properly.</p>
			<p lang="en-GB">You can think of all the testing we are doing for the logging library as system tests for the unit test library. We’re making sure that the unit test library can actually help design another project.</p>
			<p lang="en-GB">As for where to put system or integration tests, they normally belong in a different test project—something that can be run on its own. This could even be a script. If you put them in the same test project as the unit tests, then there needs to be some way to only run the unit tests when a quick response is needed.</p>
			<p lang="en-GB">Other than system and integration tests, there are still more tests you’ll want to consider adding. The next section describes more types of tests.</p>
			<h1 id="_idParaDest-106" lang="en-GB"><a id="_idTextAnchor111"/>What about other types of tests?</h1>
			<p lang="en-GB">There are still more types of tests to<a id="_idIndexMarker437"/> consider, such as performance testing, load testing, and penetration testing. You can even get into usability testing, upgrade testing, certification testing, continuous operation testing, and more, including types that I’ve probably never heard of.</p>
			<p lang="en-GB">Each type of test has a purpose that is valuable to software development. Each type has its own process and steps, ways of running the test, and ways to verify success.</p>
			<p lang="en-GB">A performance test might pick a specific scenario such as loading a large file and making sure that the operation can complete within a certain amount of time. If the test also checks to make sure that the operation completes by only using a certain amount of computer memory or CPU time, then it starts becoming more of a load test, in my opinion. And if the test makes sure that the end user doesn’t have to wait or is notified of a delay, then it starts becoming more of a usability test.</p>
			<p lang="en-GB">The lines between the test types sometimes are not clear. The previous section already explained that system tests and integration tests are often the same thing, with a subtle distinction that often doesn’t matter. The same is true of other tests. For example, whether a particular test is a load test or a performance test often comes down to the intent. Is the test trying to make sure that an operation completes in a certain time? Who decides what time is good enough? Or, is the test trying to make sure that an operation can complete while other things are going on at the same time? Or, maybe for a test that loads a large file, a large file of several megabytes is used for performance testing because that is a typical large file that a customer might encounter, while a load test would try to load a file much larger. These are just some ideas.</p>
			<p lang="en-GB">Penetration tests are a little different because they are normally created as part of an official security review. The whole software solution will be analyzed, lots of documents produced, and tests <a id="_idIndexMarker438"/>created. A penetration test is often trying to make sure that the software does not crash when malicious data is provided or when the system is misused.</p>
			<p lang="en-GB">Other penetration tests will check for information disclosure. Is it possible to misuse the software so that an attacker gains knowledge that should have remained confidential?</p>
			<p lang="en-GB">Even more important are penetration tests that catch data manipulation. A common example is students trying to change their grades, but this type of attack can be used to steal money or delete critical information.</p>
			<p lang="en-GB">Elevation-of-privilege attacks are super important to prevent penetration testing because they let an attacker gain access that can lead to more attacks. When an attacker is able to take control of a remote server, this is an obvious elevation of privilege, but elevation of privilege can be used to gain any extra permissions or capabilities that an attacker would not normally have.</p>
			<p lang="en-GB">Usability tests are more subjective and often involve customer interviews or trials.</p>
			<p lang="en-GB">All of the various different types of tests are important, and my goal with this section is not to list or describe every type of test possible but to give you an idea of the types of testing available and which benefits different tests can provide.</p>
			<p lang="en-GB">Software testing is not a question of which tests to use but where each type fits into the process. An entire book could be written about each of these test types, and many have been written. There’s a <a id="_idIndexMarker439"/>reason this book is so focused on unit testing: because unit tests are closest to the TDD process.</p>
			<h1 id="_idParaDest-107" lang="en-GB"><a id="_idTextAnchor112"/>Summary</h1>
			<p lang="en-GB">The TDD process is much more important than the features added to the logging library in this chapter. We added log levels, tags, and filtering, and even refactored the design of the logging library. And while all of this is valuable, the most important thing to pay attention to is the process involved.</p>
			<p lang="en-GB">The reason this chapter is so detailed is so that you can see all the decisions that went into the design and how tests were used to guide the entire process. You can apply this learning to your own projects. And if you also use the logging library, then that’s a bonus.</p>
			<p lang="en-GB">You learned the importance of understanding the needs of the customer. A customer doesn’t have to be a person who walks into a store to buy something. A customer is the intended user of whatever software is being developed. This could even be another software developer or another team within your company. Understanding the needs of the intended user will let you write better tests that solve those needs.</p>
			<p lang="en-GB">It’s very easy to write a function or design an interface that seems appropriate, only to find it difficult to use later. Writing the tests first helps to avoid usage problems. And you saw in this chapter a place where I still had to go back and change how a function worked because a test showed it to be backward.</p>
			<p lang="en-GB">There was an extensive set of changes needed to support filtering log messages by value, and this chapter showed how to make changes while keeping the tests unchanged.</p>
			<p lang="en-GB">One of the best ways to understand TDD is to use the process in a project. This chapter developed a lot of new code for the logging library to give you a front-row view into the process and gives you more than simple examples could ever show.</p>
			<p lang="en-GB">The next chapter will explore dependencies and will extend the logging library to send log messages to more than a single log file destination.</p>
		</div>
	</body></html>