- en: Bluetooth LE
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝牙 LE
- en: In this book so far, all external communication with our Arduino projects has
    been in a closed environment. By closed environment, we mean that our project
    simply received information or direction from a remote control and no information
    was transmitted out from the project. There are numerous use cases where we need
    to transmit information from our Arduino project to an external device such as
    a smartphone or other IoT device. When there is a need such as this, one of the
    first technologies that is brought up is **Bluetooth Low Energy**, also known
    as **Bluetooth LE** or Bluetooth Smart.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书到目前为止的内容中，我们与 Arduino 项目之间的所有外部通信都是在封闭环境中进行的。所谓封闭环境，是指我们的项目仅仅接收来自遥控器的信息或指令，而没有从项目中传出任何信息。有许多用例需要将信息从我们的
    Arduino 项目传输到外部设备，如智能手机或其他物联网设备。当有这种需求时，首先被提出的技术之一是 **蓝牙低功耗**，也称为 **蓝牙 LE** 或蓝牙智能。
- en: 'In this chapter, you will learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习：
- en: What Bluetooth LE is
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是蓝牙低功耗（Bluetooth LE）
- en: How the Bluetooth LE radio works
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝牙低功耗无线电的工作原理
- en: What the GAP profile is
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 GAP 配置文件
- en: What the GATT profile is
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 GATT 配置文件
- en: How to use the HM-10 Bluetooth LE radio module with the Arduino
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 HM-10 蓝牙低功耗无线电模块与 Arduino 配合使用
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: One of the most common misunderstandings of Bluetooth LE by people that are
    not familiar with the technology is that Bluetooth LE is a lightweight subset
    of **Bluetooth Classic**. This is not true, as Bluetooth Classic and Bluetooth
    LE are two fundamentally different protocols with different design goals.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不熟悉这项技术的人来说，蓝牙 LE 最常见的误解之一是蓝牙 LE 是蓝牙经典的一个轻量级子集。这并不正确，因为蓝牙经典和蓝牙 LE 是两种基本不同的协议，具有不同的设计目标。
- en: Most wireless technologies, such as Wi-Fi and Bluetooth Classic, were designed
    to satisfy a wide range of use cases; however, the design of Bluetooth LE is a
    bit different. Originally created by Nokia and known as **Wibree**, the primary
    design focus of Bluetooth LE was to create a radio standard with the lowest possible
    power consumption and optimized for low cost, low complexity, and low bandwidth.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数无线技术，如 Wi-Fi 和蓝牙经典，都是为了满足广泛的用例而设计的；然而，蓝牙低功耗的设计略有不同。最初由诺基亚创建，被称为 **Wibree**，蓝牙低功耗的主要设计重点是创建一个具有可能最低功耗的无线电标准，并针对低成本、低复杂度和低带宽进行优化。
- en: Bluetooth LE specifications were released as part of the Bluetooth 4.0 Core
    specifications in June of 2010\. The Bluetooth Core Specifications are overseen
    and updated by the Bluetooth **Special Interest Group** (**SIG**).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝牙低功耗规范于 2010 年 6 月作为蓝牙 4.0 核心规范的一部分发布。蓝牙核心规范由蓝牙 **特别兴趣小组**（**SIG**）监督和更新。
- en: You can find information about Bluetooth and download the specifications from
    their site at [https://www.bluetooth.com](https://www.bluetooth.com); however,
    at over 2500 pages, I would recommend that you read this chapter instead of the
    Bluetooth specifications unless you are looking for help with insomnia.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从他们的网站 [https://www.bluetooth.com](https://www.bluetooth.com) 获取有关蓝牙的信息并下载规范；然而，由于超过
    2500 页，我建议您阅读本章而不是蓝牙规范，除非您需要帮助治疗失眠。
- en: The adoption rate of Bluetooth LE has been much faster than most other wireless
    technologies. The reason for this is the adoption of the Bluetooth LE standard
    in the mobile industry where Apple and Google have put significant effort into
    including reliable Bluetooth LE stacks with the iOS and Android operating systems
    and developing easy-to-use-and-understand Bluetooth LE APIs for developers. This
    makes it very easy for developers to create and interact with devices that have
    Bluetooth LE radios.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝牙 LE 的采用率比大多数其他无线技术都要快。这其中的原因是移动行业采用了蓝牙 LE 标准，苹果和谷歌在 iOS 和 Android 操作系统中投入了大量精力，包括可靠的蓝牙
    LE 堆栈，并为开发者开发了易于使用和理解的蓝牙 LE API。这使得开发者能够轻松创建和与具有蓝牙 LE 无线电的设备交互。
- en: The reason that the mobile industry has been pushing for the adoption of Bluetooth
    LE is that devices that connect using Bluetooth LE consume far less power, hence
    the name Bluetooth Low Energy, as compared to other wireless technologies such
    as Bluetooth Classic and Wi-Fi. This leads to longer battery life for their phones,
    which leads to happier customers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 移动行业推动采用蓝牙 LE 的原因是，使用蓝牙 LE 连接的设备消耗的电量远低于其他无线技术，如蓝牙经典和 Wi-Fi，因此得名蓝牙低功耗。这导致他们的手机电池寿命更长，从而让客户更加满意。
- en: 'Bluetooth devices come in three types, where each type supports either Bluetooth
    Classic, Bluetooth LE or both. The following chart shows what each type supports:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝牙设备有三种类型，每种类型都支持蓝牙经典、蓝牙LE或两者兼而有之。以下图表显示了每种类型支持的内容：
- en: '| **Device Type** | **Bluetooth Classic Support** | **Bluetooth LE Support**
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| **设备类型** | **蓝牙经典支持** | **蓝牙LE支持** |'
- en: '| Pre-4.0 Bluetooth | Yes | No |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 预4.0蓝牙 | 是 | 否 |'
- en: '| Single-Mode | No | Yes |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 单模 | 否 | 是 |'
- en: '| Dual-Mode | Yes | Yes |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 双模 | 是 | 是 |'
- en: While the Bluetooth 5.0 specifications were released in June of 2016, at the
    time this book is being written, there are very few Bluetooth modules for the
    Arduino that support this new specification. In fact, at this time, there is very
    little support for the Bluetooth 4.1 or 4.2 specifications either; therefore,
    in this book, we are going to focus on the Bluetooth 4.0 specifications, knowing
    that Bluetooth 5.0, 4.2 and 4.1 are all backward compatible with this standard.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然蓝牙5.0规格于2016年6月发布，但在本书撰写时，支持此新规范的Arduino蓝牙模块非常少。实际上，此时对蓝牙4.1或4.2规格的支持也非常有限；因此，在本书中，我们将专注于蓝牙4.0规格，并知道蓝牙5.0、4.2和4.1都与该标准向后兼容。
- en: In order to design IoT devices that use Bluetooth LE we really need to understand
    the technology so we know when actually to use it. Therefore, we will delve into
    this technology a lot further than we have with other technologies in this book.
    We will start off by looking at the radio specifications.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设计使用蓝牙LE的物联网设备，我们确实需要了解这项技术，以便我们知道何时实际使用它。因此，我们将比本书中其他技术更深入地探讨这项技术。我们将从查看无线电规格开始。
- en: Bluetooth LE radio
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝牙LE无线电
- en: 'Since we will be using Bluetooth LE 4.0 for all the projects in this book,
    the following specifications are for this standard:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书中的所有项目都将使用蓝牙LE 4.0，以下规格适用于此标准：
- en: '| **Range** | **Up to 100 meters** |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **范围** | **最多100米** |'
- en: '| Radio Frequency | 2.402 - 2.481 GHz |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 无线电频率 | 2.402 - 2.481 GHz |'
- en: '| Radio Channels | 40 (37 data and 3 advertising) |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 无线电信道 | 40（37个数据信道和3个广告信道） |'
- en: '| Maximum OTA Data Rate | 1 Mbit/s |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 最大OTA数据速率 | 1 Mbit/s |'
- en: '| Application Data Throughput | 0.125 Mbit/s |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 应用数据吞吐量 | 0.125 Mbit/s |'
- en: '| Network Topologies | Point-to-Point |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 网络拓扑 | 点对点 |'
- en: '| Network Standard | IEEE 802.15.1 |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 网络标准 | IEEE 802.15.1 |'
- en: Bluetooth LE has a maximum range of 100 meters, but this is very dependent on
    the surroundings. When the connected devices are indoors, the range will be dramatically
    reduced due to walls and other obstacles that the radio signal needs to go through.
    Generally, we will not see a range close to 100 meters unless we are outside in
    an open field. Even then it is rare to get a range of 100 meters.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝牙LE的最大范围为100米，但这非常依赖于周围环境。当连接的设备在室内时，由于墙壁和其他障碍物，无线电信号需要穿过，范围将显著减小。通常，除非我们在开阔的田野中，否则我们不会看到接近100米的范围。即使如此，也很难达到100米的范围。
- en: The Bluetooth LE radio operates on over 40 channels, ranging from 2.402 GHz
    to 2.481 GHz. Of these channels, 37 are reserved for data and three are reserved
    for advertising. The reason for the multiple channels is Bluetooth LE uses frequency
    hopping to mitigate interference. The three advertising channels are used for
    discovery of devices. Once a device is discovered, the same channel is used to
    exchange initial connection parameters. Once the connection parameters have been
    exchanged, the regular data channels are used for communication.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝牙LE无线电在超过40个信道上运行，频率范围从2.402 GHz到2.481 GHz。在这些信道中，37个用于数据，3个用于广告。多个信道的原因是蓝牙LE使用跳频来减少干扰。三个广告信道用于设备的发现。一旦发现设备，就使用相同的信道来交换初始连接参数。一旦交换了连接参数，就使用常规数据信道进行通信。
- en: 'The following figure shows the channels used by Bluetooth LE:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了蓝牙LE使用的信道：
- en: '![](img/a566589f-731c-4553-9f8d-d2390854732c.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a566589f-731c-4553-9f8d-d2390854732c.png)'
- en: Bluetooth LE is designed to operate at low power, and the best way to avoid
    using power is to turn the radio off as often as possible and for as long as possible.
    For Bluetooth LE, this is achieved by sending short bursts of packets at a certain
    frequency, and in between those radio bursts, the radio is powered off. This is
    often referred to as **Racing to Idle**, since the radio is essentially sending
    out information as fast as it can and then shutting down for a short period of
    time.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝牙低功耗（Bluetooth LE）的设计宗旨是在低功耗下运行，而避免使用电力的最佳方法就是尽可能频繁且尽可能长时间地关闭无线电。对于蓝牙低功耗来说，这是通过在特定频率下发送短数据包脉冲来实现的，而在这些无线电脉冲之间，无线电处于关闭状态。这通常被称为**空闲状态竞争**，因为无线电实际上是以尽可能快的速度发送信息，然后关闭一段时间。
- en: The biggest sacrifice that we make for the low power usage of Bluetooth LE is
    the application data throughput. In the previous chart, we saw that the Bluetooth
    LE radio has a maximum over-the-air data rate of 1 Mbit/s. However, we also listed
    the application data throughput as only 0.125 Mbit/s. This means that the radio
    can theoretically transfer 1 Mbit per second; however, with the limitations put
    on the radio to conserve power, we only have a maximum transfer rate of 0.125
    Mbit per second. In a real-world application, we will actually never see anything
    close to this data transfer rate.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为了蓝牙低功耗的低功耗使用而做出的最大牺牲是应用数据吞吐量。在之前的图表中，我们看到蓝牙低功耗无线电的最大空中数据速率是1兆比特/秒。然而，我们也列出了应用数据吞吐量为仅0.125兆比特/秒。这意味着无线电理论上每秒可以传输1兆比特；然而，由于对无线电施加的限制以节省电力，我们只有每秒0.125兆比特的最大传输速率。在实际应用中，我们实际上永远不会看到接近这个数据传输速率的任何东西。
- en: Let's examine the race to idle and the limitations put on by the Bluetooth LE
    standards to understand why the data throughput is so low. To start off with,
    the Bluetooth LE specifications define that the connection interval, which is
    the time interval between two consecutive connection events (when the two devices
    exchange data), to be between 7.5 ms and 4 s. This means that if we set the connection
    interval to the shortest time possible (7.5 ms), we will have a maximum of 133
    connection events per second.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析空闲状态竞争和蓝牙低功耗标准施加的限制，以了解为什么数据吞吐量如此低。首先，蓝牙低功耗规范定义了连接间隔，即两个连续连接事件（当两个设备交换数据时）之间的时间间隔，应在7.5毫秒到4秒之间。这意味着如果我们将连接间隔设置为可能的最短时间（7.5毫秒），我们每秒将有133个连接事件。
- en: The radio can transmit up to six data packets per connection event, where each
    data packet can contain a maximum of 20 bytes of user data. This gives up a maximum
    of 120 bytes for each connection event.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 无线电在每个连接事件中可以传输多达六个数据包，其中每个数据包可以包含最多20字节的用户数据。这意味着每个连接事件最多有120字节。
- en: 'If we put all of the information together, we get the following formula:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将所有这些信息综合起来，我们得到以下公式：
- en: '![](img/6e19b98a-53db-46dd-8890-ffbed9cc5a77.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![网络拓扑](img/6e19b98a-53db-46dd-8890-ffbed9cc5a77.png)'
- en: This shows that the maximum data throughput would be 0.125 Mbit/second; however,
    as we mentioned earlier, even that number will never be reached because we generally
    will never max out the bytes per packet or have 133 connection events in one second.
    Devices themselves can add further limitations to the connection interval and
    data packets per connection. In the best case, we will generally see around 5-10
    KB per second for the data throughput. This means that we generally only want
    to use Bluetooth LE technology when we are exchanging short bursts of data and
    avoid it when we wish to exchange large amounts or even stream data.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明最大数据吞吐量将是0.125兆比特/秒；然而，正如我们之前提到的，即使这个数字也永远不会达到，因为我们通常永远不会达到每包字节数的最大值或在一秒钟内有133个连接事件。设备本身还可以进一步限制连接间隔和数据包数量。在最佳情况下，我们通常每秒只能看到大约5-10千字节的数据吞吐量。这意味着我们通常只有在需要交换短数据脉冲时才使用蓝牙低功耗技术，而在需要交换大量数据或进行数据流传输时则避免使用。
- en: Now let's look at the network topology for Bluetooth LE connections.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看蓝牙低功耗连接的网络拓扑。
- en: Network topology
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络拓扑
- en: Bluetooth LE devices can communicate with other Bluetooth LE devices through
    broadcasting or an established connection. Each of these methods have their own
    advantages and disadvantages. We will begin by looking at the network topology
    when the devices communicate by broadcasting. For the projects in this chapter,
    we will focus on exchanging data over established connections, but it is good
    to have a knowledge of how data can be exchanged by broadcasting. Therefore, we
    will cover it in this introduction section.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝牙低功耗设备可以通过广播或已建立的连接与其他蓝牙低功耗设备进行通信。每种方法都有其自身的优缺点。我们将首先查看设备通过广播进行通信时的网络拓扑。对于本章的项目，我们将专注于通过已建立的连接交换数据，但了解如何通过广播交换数据也是有益的。因此，我们将在本介绍部分涵盖它。
- en: Bluetooth LE broadcasting
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝牙低功耗广播
- en: 'The following diagram shows the network topology for a broadcast network:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了广播网络的网络拓扑：
- en: '![](img/e2d70c18-31f7-4ee3-81a6-61f5c89613ad.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e2d70c18-31f7-4ee3-81a6-61f5c89613ad.png)'
- en: 'There are two roles defined when broadcasting:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在广播时定义了两个角色：
- en: '**Broadcaster**: This device sends non-connectable advertising packets at set
    time intervals to any other device that is listening'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**广播者**：此设备在设定的时间间隔内向任何正在监听的设备发送非连接性广告数据包'
- en: '**Observer**: This device scans the advertising frequencies to receive the
    non-connectable advertising packets that the broadcaster is sending out'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观察者**：此设备扫描广播频率以接收广播设备发送的非连接性广告数据包'
- en: Broadcasting data is the only way that a device can send data to multiple devices.
    The standard broadcasting packet can have a payload of 31 bytes of data, which
    is usually used to describe the broadcaster and its capabilities. However, it
    can also include any custom information that we wish to broadcast to other devices.
    Bluetooth LE also supports an optional second advertising payload called the **scan
    response**, which can include an additional 31 bytes of data.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 广播数据是设备向多个设备发送数据的唯一方式。标准的广播数据包可以携带31字节的数据负载，通常用于描述广播者和其能力。然而，它也可以包含我们希望向其他设备广播的任何自定义信息。蓝牙低功耗还支持一个可选的第二广告负载，称为**扫描响应**，它可以包含额外的31字节数据。
- en: Broadcasting is fast and easy if we wish to transmit small amounts of data to
    multiple devices; however, there is no security or privacy on the data. The security
    is usually the biggest reason to avoid using broadcast packets. However, another
    big reason to avoid using broadcast packets is the observer does not have the
    ability to send any data back to the broadcaster.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望向多个设备传输少量数据，广播既快又简单；然而，数据没有安全性和隐私性。通常，安全性是避免使用广播数据包的最大原因。然而，避免使用广播数据包的另一个重要原因是观察者没有能力向广播者发送任何数据。
- en: Now let's look at Bluetooth LE connections
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看蓝牙低功耗（LE）连接
- en: Bluetooth LE connections
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝牙低功耗连接
- en: 'The following diagram shows how Bluetooth connections work:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了蓝牙连接的工作原理：
- en: '![](img/b6af8d1f-587e-4b46-acd1-fdee12f701af.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b6af8d1f-587e-4b46-acd1-fdee12f701af.png)'
- en: 'As with the Bluetooth LE broadcasting topology, the connection topology also
    defines two roles:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与蓝牙低功耗广播拓扑结构类似，连接拓扑也定义了两个角色：
- en: '**Central**: The central is usually a device such as, a laptop, tablet or phone.
    These devices will scan the advertising channels and listen for connectable advertising
    packets. When a device is found, the central may attempt to establish a connection
    to the device. After the connection is established the central manages the timing
    and initiates the data exchanges. The central device can connect to more than
    one peripheral.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中心设备**：中心设备通常是一个如笔记本电脑、平板电脑或手机等设备。这些设备将扫描广告频道并监听可连接的广告数据包。当发现设备时，中心设备可能会尝试与该设备建立连接。连接建立后，中心设备管理时间并启动数据交换。中心设备可以连接多个外围设备。'
- en: '**Peripheral**: The peripheral is usually a device such as a smartwatch, a
    weather station or medical device. These devices send out periodic connectable
    advertising packets and accept incoming connections. Once a connection is established,
    the peripheral will generally follow the central''s timing and exchange data when
    the central requests it. A peripheral can connect to only one central device.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外围设备**：外围设备通常是一个如智能手表、气象站或医疗设备等设备。这些设备会定期发送可连接的广告数据包并接受传入的连接。一旦建立连接，外围设备通常会遵循中心设备的时间安排，并在中心设备请求时交换数据。外围设备只能连接到一个中心设备。'
- en: A peripheral will generally advertise until a central device discovers it and
    requests a connection. Once the connection is established, the peripheral will
    stop advertising and then the two devices can exchange data. The data exchange
    in this topology can go both ways, where the peripheral and central can both send
    and receive data.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 外设通常会在中央设备发现它并请求连接之前进行广播。一旦建立连接，外设将停止广播，然后两个设备可以交换数据。在这种拓扑结构中的数据交换是双向的，外设和中央设备都可以发送和接收数据。
- en: When a central and a peripheral establish a connection, the data that is transmitted
    and received is organized in units called **services and characteristics**. We
    will look at this more when we look at the **Generic Attribute Profile** (**GATT**)
    a little later in this chapter. The thing to understand now is that a Bluetooth
    LE peripheral can have multiple characteristics, which are used to send and receive
    data. These characteristics are organized or grouped into services.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当中央设备和外设建立连接时，传输和接收的数据是以称为**服务和特性**的单位组织的。我们将在本章稍后查看**通用属性配置文件**（**GATT**）时进一步探讨这一点。现在要理解的是，蓝牙低功耗外设可以拥有多个特性，这些特性用于发送和接收数据。这些特性被组织或分组到服务中。
- en: The biggest advantage with establishing a Bluetooth LE connection is you can
    have multiple characteristics to organize your data, and each of these characteristics
    may have their own access rights and descriptive metadata. Another advantage is
    the ability to establish secure encrypted connections.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 建立蓝牙低功耗连接的最大优势是可以有多个特性来组织你的数据，并且每个特性都可能有自己的访问权限和描述性元数据。另一个优势是能够建立安全的加密连接。
- en: With Bluetooth 4.0, a device can act as a central or a peripheral but not both.
    Starting with Bluetooth 4.1, this restriction was removed and with newer versions
    of Bluetooth LE, a device can act as a peripheral, a central or both.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝牙4.0中，设备可以作为中央设备或外设，但不能同时作为两者。从蓝牙4.1开始，这种限制被取消，并且在新版本的蓝牙低功耗中，设备可以作为外设、中央设备或两者兼具。
- en: Now let's look at the Bluetooth LE profiles.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看蓝牙低功耗配置文件。
- en: Bluetooth LE profiles
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝牙低功耗配置文件
- en: Bluetooth LE defines two types of profiles. These are profiles that define the
    basic mode of operations required by all Bluetooth LE devices to ensure interoperability
    (Generic Access Profile and GATT) or profiles that are used for specific use cases
    (health device profile and proximity profile). In this chapter, we will not go
    into the specific use cases of these profiles; however, we do want to look at
    both the **Generic Access Profile** (**GAP**) and the Generic Attribute Profile
    (GATT). We will start off by looking at the GAP.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝牙低功耗（Bluetooth LE）定义了两种类型的配置文件。这些配置文件包括定义所有蓝牙低功耗设备所需的基本操作模式的配置文件（通用访问配置文件和GATT）或用于特定用例的配置文件（健康设备配置文件和邻近配置文件）。在本章中，我们不会深入探讨这些配置文件的具体用例；然而，我们确实想看看**通用访问配置文件**（**GAP**）和通用属性配置文件（GATT）。我们将从查看GAP开始。
- en: Generic access profile (GAP)
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用访问配置文件（GAP）
- en: The GAP defines how devices interact with each other to ensure device interoperability.
    It defines how Bluetooth LE devices discover each other, establish secure connections,
    terminate connections, broadcast data and device configuration. This is the lowest
    level of the Bluetooth LE stack that we will cover in this chapter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: GAP定义了设备如何相互交互以确保设备互操作性。它定义了蓝牙低功耗设备如何发现彼此、建立安全连接、终止连接、广播数据和设备配置。这是我们将在本章中涵盖的蓝牙低功耗堆栈的最低级别。
- en: 'Earlier in this chapter, we saw that a Bluetooth LE device could be in one
    of two states. In the broadcasting topology, a device can be either the broadcaster
    (slave) or observer (master). If a connection between the two devices is established,
    then the devices become either a central (master) or peripheral (slave). We introduced
    the terms master and slave here to illustrate the states that the devices can
    be in. The following diagram shows the different states:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我们看到了蓝牙低功耗设备可以处于两种状态之一。在广播拓扑中，设备可以是广播者（从设备）或观察者（主设备）。如果两个设备之间建立了连接，那么设备就变成了中央（主设备）或外设（从设备）。我们在这里引入了主设备和从设备这两个术语，以说明设备可能处于的状态。以下图表显示了不同的状态：
- en: '![](img/c8b6d92a-69ad-48d0-9c56-fe1e34bb3b89.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c8b6d92a-69ad-48d0-9c56-fe1e34bb3b89.png)'
- en: Both types of devices start in an idle or standby state. This is the initial
    state when the device is reset. A slave device will then become an advertiser,
    where it is advertising specific data, letting any master device know that it
    is a connectable device and what services it offers. After the idle state, a master
    device will begin scanning for slaves that are advertising. When a master receives
    an advertisement, it will send a scan request to the advertiser, and the slave
    will respond back with a scan response. This is the device discovery process.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种类型的设备都是从空闲或待机状态开始的。这是设备重置时的初始状态。从机设备随后将成为广播者，它正在广播特定数据，让任何主设备知道它是一个可连接的设备以及它提供的服务。在空闲状态之后，主设备将开始扫描正在广播的从设备。当主设备收到广告时，它将向广播者发送扫描请求，从设备将回以扫描响应。这就是设备发现过程。
- en: After the device discovery process, if the master wishes to connect to the advertising
    device, it will initiate a connection. When initiating the connection, the master
    will specify the connection parameters. Once the connection is made the devices
    will assume their roles as master and slave. With Bluetooth LE 4.0, the slave
    device can have only one master. Also, with Bluetooth LE 4.0, the devices can
    act as either a master or a slave but not both. With later revisions of the Bluetooth
    specifications, these limitations have been removed. I know we have mentioned
    that a couple of times so far in this book, but it is important to keep in mind
    when developing your devices.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备发现过程之后，如果主设备想要连接到广播设备，它将发起一个连接。在发起连接时，主设备将指定连接参数。一旦连接建立，设备将扮演主从角色。在蓝牙低功耗（BLE）4.0中，从机设备只能有一个主设备。此外，在蓝牙低功耗（BLE）4.0中，设备可以充当主设备或从设备，但不能同时充当两者。在蓝牙规范的后续版本中，这些限制已被取消。我知道我们在这本书中已经提到过几次，但在开发您的设备时，这一点很重要。
- en: 'We mentioned that the master specifies the number of connection parameters
    when initiating the connection. Some of these parameters are:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到过，在发起连接时，主设备指定连接参数的数量。其中一些参数包括：
- en: '**Connection Interval**: With Bluetooth LE uses a frequency hopping scheme
    the two devices that are communicating most know which channel to transmit/receive
    on, when to switch channels and when to make the connection. The time interval
    between the connection attempts is known as the connection interval.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接间隔**: 在蓝牙低功耗（BLE）中，使用跳频方案，通信的两个设备最清楚在哪个信道上传输/接收，何时切换信道以及何时建立连接。连接尝试之间的时间间隔称为连接间隔。'
- en: '**Slave Latency**: The slave latency gives the slave device the option to skip
    a certain number of connection events. The slave device must not skip more than
    the number of connection events defined by this parameter.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从机延迟**: 从机延迟允许从机设备选择跳过一定数量的连接事件。从机设备不得跳过超过此参数定义的连接事件数量。'
- en: '**Supervision Time-out**: The supervision time-out is the maximum amount of
    time between two successful connection events. If this time is exceeded, the device
    will terminate the connection, and the slave device will go back to an unconnected
    state.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监督超时**: 监督超时是两次成功连接事件之间的最大时间间隔。如果超过这个时间，设备将终止连接，从机设备将回到未连接状态。'
- en: There are a number of considerations when deciding what to set these parameters
    to. The main consideration is power consumption and data throughput. As the throughput
    increases, the device will use more power. For example, if we lower the connection
    interval, thereby increasing the number of connection attempts per second, the
    power consumption of the device will increase because the radio will be on more
    of the time. By reducing the slave latency, once again the radio will be on more.
    Therefore, it will also increase the power consumption. When working with a Bluetooth
    LE radio, you need to balance the power consumption with the data throughput needs
    for your project. There is no magic ratio that will work for all types of devices;
    it is something you will need to look at on a project-by-project basis.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定将这些参数设置为什么值时，有许多考虑因素。主要考虑因素是功耗和数据吞吐量。随着吞吐量的增加，设备将消耗更多电力。例如，如果我们降低连接间隔，从而增加每秒的连接尝试次数，设备的功耗将增加，因为无线电将在更多的时间内开启。通过减少从机延迟，无线电同样会开启更多。因此，它也会增加功耗。在处理蓝牙低功耗（BLE）无线电时，您需要平衡项目的功耗需求与数据吞吐量需求。没有适用于所有类型设备的神奇比例；这是您需要根据每个项目逐一考虑的事情。
- en: In the example projects for this chapter, we will show how to AT commands to
    adjust the various settings for the Bluetooth LE module. Now let's look at the
    GATT profile.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例项目中，我们将展示如何使用AT命令调整蓝牙低功耗模块的各种设置。现在让我们来看看GATT配置文件。
- en: Generic attribute (GATT) profile
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用属性（GATT）配置文件
- en: While the GAP profile defines the low-level (advertising and connection) interactions
    of Bluetooth LE devices, the GATT profile defines the details on how the devices
    exchange data. The GATT is also the reference framework for all attribute-based
    profiles that define specific use cases, such as heart rate and blood pressure
    profiles.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然GAP配置文件定义了蓝牙低功耗设备的低级（广播和连接）交互，但GATT配置文件定义了设备交换数据的细节。GATT也是所有基于属性配置文件的参考框架，这些配置文件定义了特定的用例，例如心率血压配置文件。
- en: 'As with the GAP profile, the GATT profile defines two roles. These roles are
    the client and the server. When you look at the diagram on how this works, the
    roles may seem a little odd at first; however, once we see how Bluetooth LE devices
    exchange data it will make more sense. The client role in the GATT profile corresponds
    to the master role in the GAP profile and the server role in the GATT profile
    corresponds to the slave role. The following diagram illustrates this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与GAP配置文件一样，GATT配置文件定义了两个角色。这些角色是客户端和服务器。当你查看这个工作原理的图示时，这些角色可能一开始看起来有点奇怪；然而，一旦我们了解了蓝牙低功耗设备如何交换数据，它就会更有意义。GATT配置文件中的客户端角色对应于GAP配置文件中的主角色，而GATT配置文件中的服务器角色对应于从角色。以下图示说明了这一点：
- en: '![](img/d2a0966f-94dd-45a6-8571-63a78db5595c.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d2a0966f-94dd-45a6-8571-63a78db5595c.png)'
- en: In this diagram, we can see that one client can have multiple servers; however,
    each server can have only one client. In the GATT profile, the client (central
    role in the GAP) requests information from the server (peripheral in the GAP).
    While we are showing the relationship between the GATT and GAP roles, it is worth
    noting that the GATT and GAP roles are actually independent of each other, and
    in later versions of the Bluetooth LE specifications, a device can act as both
    a central and a peripheral.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们可以看到一个客户端可以有多个服务器；然而，每个服务器只能有一个客户端。在GATT配置文件中，客户端（GAP中的中心角色）从服务器（GAP中的外围设备）请求信息。当我们展示GATT和GAP角色之间的关系时，值得注意的是，GATT和GAP角色实际上是相互独立的，并且在蓝牙低功耗规范的后续版本中，一个设备可以同时充当中心和外围设备。
- en: The smallest data entity defined by the GATT profile is the attribute. An attribute
    is an addressable piece of information that is located on the server, which can
    be accessed and potentially modified by the client. Each attribute is uniquely
    identified by a **UUID** (**universally unique identifier**), which can be either
    a 16-bit or 128-bit number. This identifier is known as the handle.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: GATT配置文件定义的最小数据实体是属性。属性是位于服务器上的可寻址信息块，客户端可以访问并可能修改它。每个属性都由一个**UUID**（**全球唯一标识符**）唯一标识，该标识符可以是16位或128位数字。这个标识符被称为句柄。
- en: 'The GATT profile defines a set of permissions that are associated with all
    attributes. Permissions specify which operations can be performed on each attribute.
    These permissions are:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: GATT配置文件定义了一组与所有属性关联的权限。权限指定可以对每个属性执行哪些操作。这些权限包括：
- en: '**Access Permissions**: Access permissions specify which actions can be performed
    on the attribute. Each attribute will have one of the following permissions:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问权限**：访问权限指定可以对属性执行哪些操作。每个属性都将具有以下权限之一：'
- en: '**None**: The attribute cannot be read or written by the client'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无**：客户端无法读取或写入属性'
- en: '**Readable**: The attribute can be read by the client'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可读**：客户端可以读取属性'
- en: '**Writable**: The attribute can be written to by the client'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可写**：客户端可以写入属性'
- en: '**Readable and Writable**: The attribute can be read and written to by the
    client'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可读和可写**：客户端可以读取和写入属性'
- en: '**Encryption**: Encryption permission determines the level of encryption that
    is required for a client to access the attribute'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加密**：加密权限确定客户端访问属性所需的加密级别'
- en: '**No Encryption** (Security Mode 1, Level 1): No encryption is required'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无加密**（安全模式1，级别1）：不需要加密'
- en: '**Unauthenticated Encryption** (Security Mode 1, Level 2): The connection must
    be encrypted; however, the encryption keys do not need to be authenticated'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未认证加密**（安全模式1，级别2）：连接必须加密；然而，加密密钥不需要进行认证'
- en: '**Authenticated Encryption** (Security Mode 2, Level 2): The connection must
    be encrypted, and the encryption keys must be authenticated'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证加密**（安全模式2，级别2）：连接必须加密，加密密钥必须经过认证'
- en: '**Authorization**: Authorization permission determines whether the user needs
    to be authorized to access the attribute'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：授权权限决定用户是否需要授权才能访问属性'
- en: '**No Authorization**: No authorization is required to access the attribute'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无需授权**：访问属性无需授权'
- en: '**Authorization Required**: Authorization is required to access the attribute'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**需要授权**：访问属性需要授权'
- en: The GATT defines a strict hierarchy, which organizes the attributes. The attributes
    are grouped into services, where each service may contain zero or more characteristics.
    These characteristics can include zero or more descriptors. Services, characteristics
    and descriptors are all attributes within the GATT server.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: GATT定义了一个严格的层次结构，用于组织属性。属性被分组到服务中，其中每个服务可以包含零个或多个特性。这些特性可以包括零个或多个描述符。服务、特性和描述符都是GATT服务器中的属性。
- en: 'The following diagram shows the hierarchy:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了层次结构：
- en: '![](img/0b365ec6-1983-4b72-bce7-1e23f75ffc3b.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0b365ec6-1983-4b72-bce7-1e23f75ffc3b.png)'
- en: Services are used to group related attributes into a common entity. Each service
    is identified by a unique UUID, which can be either 16-bit for officially adopted
    service types or 128-bit for custom service types.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 服务用于将相关属性分组到一个公共实体中。每个服务都有一个唯一的UUID，可以是16位用于官方采用的服务类型，也可以是128位用于自定义服务类型。
- en: 'You can see a list of officially adopted services on the Bluetooth SIG site
    here: [https://www.bluetooth.com/api/silentlogin/login?return=http%3a%2f%2fwww.bluetooth.com%2fspecifications%2fgatt%2fservices](https://www.bluetooth.com/api/silentlogin/login?return=http%3a%2f%2fwww.bluetooth.com%2fspecifications%2fgatt%2fservices).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在蓝牙SIG网站上查看官方采用的服务列表，请点击此处：[https://www.bluetooth.com/api/silentlogin/login?return=http%3a%2f%2fwww.bluetooth.com%2fspecifications%2fgatt%2fservices](https://www.bluetooth.com/api/silentlogin/login?return=http%3a%2f%2fwww.bluetooth.com%2fspecifications%2fgatt%2fservices).
- en: If you look at the Heart Rate service, you can see that this service contains
    three characteristics.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看心率服务，您会看到该服务包含三个特性。
- en: Characteristics are containers for the data, where each characteristic encapsulates
    a single data point. As with the services, a characteristic is identified by either
    a 16-bit or 128-bit UUID. Characteristics are the main entry point that a Bluetooth
    LE client interacts with a server.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 特性是数据的容器，其中每个特性封装一个单一的数据点。与服务类似，特性通过16位或128位UUID进行标识。特性是蓝牙LE客户端与服务器交互的主要入口点。
- en: 'You can find a list of officially adopted characteristics on the Bluetooth
    SIG site here: [https://www.bluetooth.com/specifications/gatt/characteristics](https://www.bluetooth.com/specifications/gatt/characteristics).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在蓝牙SIG网站上找到官方采用的特性列表，请点击此处：[https://www.bluetooth.com/specifications/gatt/characteristics](https://www.bluetooth.com/specifications/gatt/characteristics).
- en: Access permissions for each characteristic should be either read-only or write-only.
    It is very rare to have a characteristic that has both read and write permission.
    As an example, if we wanted to create a simple serial interface for our Bluetooth
    LE device, we would create a TX characteristic to transmit data with read-only
    permission for the client and an RX characteristic to receive data with write-only
    permission for the client. We would not want to create a single characteristic
    that had both read and write permission because as the client writes data to it,
    the server could overwrite it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 每个特性的访问权限应该是只读或只写。具有读写权限的特性非常罕见。例如，如果我们想为我们的蓝牙LE设备创建一个简单的串行接口，我们会创建一个具有只读权限的TX特性来传输数据，以及一个具有只写权限的RX特性来接收数据。我们不会创建一个同时具有读写权限的单个特性，因为当客户端向其写入数据时，服务器可能会覆盖它。
- en: The descriptors are used to provide the client devices with additional information
    about the characteristics and their values.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符用于向客户端设备提供有关特性和其值的附加信息。
- en: 'You can find a list of officially adopted descriptors on the Bluetooth SIG
    site here: [https://www.bluetooth.com/specifications/gatt/descriptors](https://www.bluetooth.com/specifications/gatt/descriptors).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在蓝牙SIG网站上找到官方采用的描述符列表，请点击此处：[https://www.bluetooth.com/specifications/gatt/descriptors](https://www.bluetooth.com/specifications/gatt/descriptors).
- en: 'Generally, the server simply responds to a client''s request for data from
    a characteristic; however, it is possible for a server to initiate the communication
    by using server-initiated updates. There are two types of server initiated updates,
    which are:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，服务器只是简单地响应客户端对特性的数据请求；然而，服务器也可以通过使用服务器发起的更新来启动通信。有两种类型的服务器发起的更新，它们是：
- en: '**Notification**: Characteristic value change notifications are used when the
    server is configured to notify the client that the value of the characteristic
    has changed but does not expect the client to acknowledge the notification. Notification
    is turned on for all projects in this chapter; however, it is only used in the
    first and third projects.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通知**：当服务器配置为通知客户端特性值已更改，但不期望客户端确认通知时，使用特性值更改通知。在本章的所有项目中，通知都已被打开；然而，它仅在第一个和第三个项目中使用。'
- en: '**Indication**: Characteristic value change indications are used when the server
    is configured to indicate to the client that the value of the characteristic has
    changed and expects the client to acknowledge that it has received the indication.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指示**：当服务器配置为向客户端指示特性值已更改并期望客户端确认它已收到指示时，使用特性值更改指示。'
- en: Now that we have a very basic understanding of Bluetooth LE and how it works,
    let's look at the HM-10 Bluetooth module that we will be using in this chapter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对蓝牙低功耗及其工作原理有了非常基本的了解，让我们看看本章我们将使用的 HM-10 蓝牙模块。
- en: HM-10 Bluetooth module
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HM-10 蓝牙模块
- en: The HM-10 is a Bluetooth 4.0 module that is based on the TI CC2530 or CC2541
    Bluetooth **SOC** (**System-on-Chip**). The HM-10 is a very popular Bluetooth
    4 module for the Arduino, mostly due to its cheap cost and ease of use. The HM-10
    provides a standard serial connection to the Bluetooth layer. This allows for
    a very straightforward interface; however, it does hide the actual Bluetooth LE
    layer.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: HM-10 是一个基于 TI CC2530 或 CC2541 蓝牙 **SOC**（**片上系统**）的蓝牙 4.0 模块。HM-10 是 Arduino
    非常流行的蓝牙 4 模块，这主要归功于其低廉的成本和易用性。HM-10 为蓝牙层提供标准串行连接。这允许一个非常直接的接口；然而，它也隐藏了实际的蓝牙低功耗层。
- en: In [Chapter 21](7abdb5af-1851-4623-b6a9-996fc6b69694.xhtml), *Bluetooth Classic*,
    when we look at the HC-05 Bluetooth module, you will notice that the interface
    between the HC-05 and HM-10 use the same serial interface; however, understanding
    the difference between Bluetooth LE and Bluetooth Classic technologies will help
    you decide which to use in your project.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 21 章](7abdb5af-1851-4623-b6a9-996fc6b69694.xhtml) 的 *蓝牙经典* 中，当我们查看 HC-05
    蓝牙模块时，你会注意到 HC-05 和 HM-10 之间的接口使用相同的串行接口；然而，了解蓝牙低功耗和蓝牙经典技术之间的区别将有助于你决定在你的项目中使用哪种技术。
- en: 'We can control the module using AT commands, and we will look at how to do
    that in the project section of this chapter. The following photograph shows what
    the HM-10 Bluetooth module looks like:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 AT 命令来控制该模块，我们将在本章的项目部分查看如何操作。以下照片显示了 HM-10 蓝牙模块的外观：
- en: '![](img/25551851-e2eb-476c-b508-0b0296e5ac31.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/25551851-e2eb-476c-b508-0b0296e5ac31.png)'
- en: 'The HM-10 has six pins. However, we are only interested in the middle four,
    which are:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: HM-10 模块有六个引脚。然而，我们只对中间的四个感兴趣，它们是：
- en: '**VCC**: Connected to the 3.3V power out on the Arduino'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VCC**：连接到 Arduino 的 3.3V 电源输出'
- en: '**GND**: Connected to the ground on the Arduino'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GND**：连接到 Arduino 的地线'
- en: '**TX**: Transmit pin, connected to one of the digital pins on the Arduino'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TX**：发送引脚，连接到 Arduino 的一个数字引脚'
- en: '**RX**: Receive pin, connected to one of the digital pins on the Arduino'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RX**：接收引脚，连接到 Arduino 的一个数字引脚'
- en: Now let's look at all of the components that we will need for the projects that
    we will be doing in this chapter.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看本章我们将要进行的项目的所有组件。
- en: Components needed
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需要的组件
- en: 'For these, projects you will need the following items:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些项目，你需要以下物品：
- en: One Arduino Uno or compatible board
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块 Arduino Uno 或兼容板
- en: One HM-10 Bluetooth 4.0 module
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 HM-10 蓝牙 4.0 模块
- en: One DHT-11 temperature sensor
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 DHT-11 温度传感器
- en: One LED
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 LED
- en: One 4.7K resistor
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 4.7K 欧姆电阻
- en: One 3.3K resistor
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 3.3K 欧姆电阻
- en: One 1.1K resistor
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 1.1K 欧姆电阻
- en: One 330k resistor
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 330k 欧姆电阻
- en: Jumper wires
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳线
- en: Breadboard
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面板
- en: You will need a Bluetooth LE app for your phone/tablet or computer. I use the
    *BTCommander – Serial port HM10* ([https://itunes.apple.com/us/app/btcommander-serial-port-hm10/id1312640906?mt=8](https://itunes.apple.com/us/app/btcommander-serial-port-hm10/id1312640906?mt=8))
    app on my phone. There are plenty of other apps, such as the *nRF connect* app
    for Android ([https://play.google.com/store/apps/details?id=no.nordicsemi.android.mcp&hl=en_US](https://play.google.com/store/apps/details?id=no.nordicsemi.android.mcp&hl=en_US))
    and iOS ([https://itunes.apple.com/us/app/nrf-connect/id1054362403?mt=8](https://itunes.apple.com/us/app/nrf-connect/id1054362403?mt=8)).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在您的手机/平板电脑或电脑上安装一个蓝牙LE应用程序。我在手机上使用的是*BTCommander – Serial port HM10*应用程序([https://itunes.apple.com/us/app/btcommander-serial-port-hm10/id1312640906?mt=8](https://itunes.apple.com/us/app/btcommander-serial-port-hm10/id1312640906?mt=8))。还有许多其他应用程序，例如Android的*nRF
    connect*应用程序([https://play.google.com/store/apps/details?id=no.nordicsemi.android.mcp&hl=en_US](https://play.google.com/store/apps/details?id=no.nordicsemi.android.mcp&hl=en_US))和iOS([https://itunes.apple.com/us/app/nrf-connect/id1054362403?mt=8](https://itunes.apple.com/us/app/nrf-connect/id1054362403?mt=8))。
- en: Circuit diagrams
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电路图
- en: 'In this chapter, we will be doing three projects. The first project will be
    a simple serial communication project that will send a text to and from the Arduino
    through the Bluetooth radio. We will also show how to configure the Bluetooth
    radio in the first project. For the second project, we will show how to toggle
    a LED on and off remotely. For the final project, we will build a mini weather
    station, which will enable us to read the temperature remotely through the Bluetooth
    radio. Each project will have its own wiring diagram included with it; however,
    if you wish to connect all of the hardware at once, the following diagram shows
    how everything is connected:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进行三个项目。第一个项目将是一个简单的串行通信项目，通过蓝牙无线电将文本从Arduino发送到另一个设备，并从另一个设备发送回Arduino。我们还将展示如何在第一个项目中配置蓝牙无线电。对于第二个项目，我们将展示如何远程切换LED的开关。对于最后一个项目，我们将构建一个迷你气象站，通过蓝牙无线电远程读取温度。每个项目都将包含其自身的接线图；然而，如果您希望一次性连接所有硬件，以下图示显示了所有连接方式：
- en: '![](img/efc48632-99e5-4183-aded-76be6a036f9f.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/efc48632-99e5-4183-aded-76be6a036f9f.png)'
- en: This diagram may initially look complex compared to earlier diagrams; however,
    if we break it down into three parts, it really is not that complex. The first
    part is the DHT-11 temperature sensor, which is located on the right-hand side
    of the breadboard. The second part is the LED, which is in the center of the breadboard.
    The third and final part is the HM-10 Bluetooth module, which is located on the
    left-hand side of the breadboard.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的图示相比，这个图示可能一开始看起来比较复杂；然而，如果我们将其分解为三个部分，它实际上并不复杂。第一部分是DHT-11温度传感器，位于面包板的右侧。第二部分是LED，位于面包板的中心。第三和最后一部分是HM-10蓝牙模块，位于面包板的左侧。
- en: We have already covered wiring the DHT-11 temperature sensor in [Chapter 9](4334ea1c-5df5-4be7-a7c1-86592cb3aaa6.xhtml),
    *Environment Sensors*, and the LED in [Chapter 4](f0039485-e47c-40c8-9130-fba1e1afd421.xhtml),
    *Basic Prototyping*. Therefore, we will repeat the explanation here.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第9章](4334ea1c-5df5-4be7-a7c1-86592cb3aaa6.xhtml)“环境传感器”中介绍了DHT-11温度传感器的接线，以及在[第4章](f0039485-e47c-40c8-9130-fba1e1afd421.xhtml)“基本原型”中介绍了LED的接线。因此，这里我们将重复解释。
- en: To connect the HM-10 Bluetooth module to the Arduino, the **VCC** pin is connected
    to the power rail on the breadboard, which is connected to the 5V power out on
    the Arduino. The **GND** pin on the Bluetooth module is connected to the ground
    rail on the breadboard, which is connected to the ground pin on the Arduino. The
    **RX** pin on the Bluetooth module is connected directly to the digital **pin
    10** on the Arduino.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要将HM-10蓝牙模块连接到Arduino，**VCC**引脚连接到面包板上的电源轨，该电源轨连接到Arduino的5V电源输出。蓝牙模块上的**GND**引脚连接到面包板上的地轨，该地轨连接到Arduino的地线引脚。蓝牙模块上的**RX**引脚直接连接到Arduino的数字**引脚10**。
- en: Connecting the **TX** pin on the Bluetooth module to the Arduino is a little
    different. For this, we want to ensure that the voltage does not exceed 3.3V.
    Therefore, we use a simple voltage divider. A voltage divider is a simple circuit
    that will turn a larger voltage into a smaller one. For this, we use two resistors,
    a 1.1K and a 3.3K. These two resistors are connected in series, where one end
    of the 3.3K resistor is connected to ground, and one end of the 1.1K resistor
    is connected to digital **pin 11** on the Arduino. The **TX** pin is connected
    between the two resistors.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 将蓝牙模块上的 **TX** 引脚连接到 Arduino 是有一点不同的。为此，我们想确保电压不超过 3.3V。因此，我们使用一个简单的分压器。分压器是一个简单的电路，可以将较大的电压转换为较小的电压。为此，我们使用两个电阻，一个
    1.1K 和一个 3.3K。这两个电阻串联连接，其中 3.3K 电阻的一端连接到地，1.1K 电阻的一端连接到 Arduino 的数字 **引脚 11**。**TX**
    引脚连接在这两个电阻之间。
- en: Project 1 – serial communication
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目 1 – 串行通信
- en: 'For this first project, we are only going to use the HM-10 Bluetooth module
    and the Arduino. You will need to connect the Bluetooth module to the Arduino
    as shown in the previous circuit diagram. The following diagram shows this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个第一个项目，我们只将使用 HM-10 蓝牙模块和 Arduino。您需要按照前面的电路图将蓝牙模块连接到 Arduino。以下图示显示了这一点：
- en: '![](img/21db66c9-e40a-4f30-9da4-44189de605a8.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/21db66c9-e40a-4f30-9da4-44189de605a8.png)'
- en: Now we need to write the code to access the Bluetooth module. We will be using
    the `SoftwareSerial` library to interface with the HM-10 Bluetooth LE module.
    This library was developed to allow serial communication on digital pins other
    than pins 0 and 1\. There may be limitations to this library if you are using
    a board other than the Uno. You can reference the documentation ([https://www.arduino.cc/en/Reference/softwareSerial](https://www.arduino.cc/en/Reference/softwareSerial))
    to see if your board has any limitations.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要编写代码来访问蓝牙模块。我们将使用 `SoftwareSerial` 库与 HM-10 蓝牙 LE 模块进行接口。这个库是为了允许在除了引脚
    0 和 1 之外的其他数字引脚上进行串行通信而开发的。如果您使用的是 Uno 以外的板，这个库可能会有局限性。您可以参考文档（[https://www.arduino.cc/en/Reference/softwareSerial](https://www.arduino.cc/en/Reference/softwareSerial)）以查看您的板是否有任何限制。
- en: 'The code will need to start off by including the `SoftwareSerial` header file
    and then initiate an instance of the `SoftwareSerial` type. We also want to add
    a new line whenever a new command is issued from the serial monitor. Therefore,
    we will also define a Boolean variable that will be set to true whenever a new
    command comes in (this will make it easier to read the responses within the serial
    monitor). The following code will do this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 代码需要从包含 `SoftwareSerial` 头文件开始，然后初始化 `SoftwareSerial` 类的一个实例。我们还想在从串行监视器发出新命令时添加新行。因此，我们将定义一个布尔变量，每当收到新命令时将其设置为
    true（这将使在串行监视器中读取响应变得更容易）。以下代码将执行此操作：
- en: '[PRE0]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When creating the instance of the `SoftwareSerial` type, you need to define
    what pins to use for receiving (**RX**) and transmitting (**TX**) data. The first
    value is the `RX` pin and the second value is the `TX` pin.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 `SoftwareSerial` 类的实例时，您需要定义用于接收（**RX**）和发送（**TX**）数据的引脚。第一个值是 `RX` 引脚，第二个值是
    `TX` 引脚。
- en: 'Next, we need to initialize both the serial monitor and the `SoftwareSerial`
    instance. We will do that within the `setup()` function. We also want to let the
    user know when the application is ready to accept commands or connections. The
    following code shows the code for the `setup()` function:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要初始化串行监视器和 `SoftwareSerial` 实例。我们将在 `setup()` 函数中这样做。我们还想让用户知道应用程序何时准备好接受命令或连接。以下代码显示了
    `setup()` 函数的代码：
- en: '[PRE1]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When we initiate the serial monitor and the `SoftwareSerial` interface, we need
    to define what the baud rate will be. Both the HM-10 Bluetooth module and the
    serial monitor communicate at a baud rate of 9600\. Once everything is initiated,
    a message is displayed to the serial monitor letting the user know that everything
    is good to go.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动串行监视器和 `SoftwareSerial` 接口时，我们需要定义波特率。HM-10 蓝牙模块和串行监视器都使用 9600 波特率进行通信。一旦一切启动，串行监视器上会显示一条消息，告知用户一切正常。
- en: 'In the `loop()` function, we will need to write anything that the user types
    into the serial monitor to the Bluetooth module and write anything that comes
    in from the Bluetooth module to the serial monitor. The following code shows the
    `loop()` function:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `loop()` 函数中，我们需要将用户输入到串行监视器中的任何内容写入蓝牙模块，并将从蓝牙模块接收到的任何内容写入串行监视器。以下代码显示了 `loop()`
    函数：
- en: '[PRE2]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this function, we use the `available()` function on both the serial monitor
    and the instance of the `SoftwareSerial` type to check whether either device has
    data to read. If so, we read the data and write it to the other device. In the
    section that reads the serial monitor and writes to the `SoftwareSerial` instance,
    we set the `addNewLine` Boolean variable to true so the next time we write to
    the serial monitor, we will write a carriage return and new line. In the section
    that reads from the Bluetooth module and writes to the serial monitor, we check
    to see whether the `addNewLine` Boolean variable is `true`, and if so, we write
    a carriage return and new line to the serial monitor before setting the `addNewLine`
    variable to `false`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们使用串行监视器和`SoftwareSerial`类型的实例上的`available()`函数来检查任一设备是否有可读数据。如果有，我们读取数据并将其写入另一个设备。在读取串行监视器并写入`SoftwareSerial`实例的部分，我们将`addNewLine`布尔变量设置为true，这样下次我们写入串行监视器时，我们将写入一个回车符和新行。在从蓝牙模块读取并写入串行监视器的部分，我们检查`addNewLine`布尔变量是否为`true`，如果是，我们在将`addNewLine`变量设置为`false`之前，向串行监视器写入一个回车符和新行。
- en: There are two ways that we can use this application. The first is to enter **AT**
    (**ATtention**) commands into the serial monitor, which enables you to get/set
    configuration settings on the Bluetooth module and also control the module. The
    second is to use the Bluetooth LE app on your phone to read and write values to
    the Bluetooth modules. Let's look at the AT commands first.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以使用此应用程序的两种方式。第一种是将**AT**（**注意**）命令输入到串行监视器中，这使您能够获取/设置蓝牙模块的配置设置并控制模块。第二种是使用手机上的蓝牙LE应用程序读取和写入蓝牙模块的值。让我们首先看看AT命令。 '
- en: 'To send an AT command to the Bluetooth LE module, run the preceding code blocks
    and then open the serial monitor, which is part of the Arduino IDE. Once everything
    is initiated, you will see the `Connected to HM-10\. Try connecting from any device
    or issue AT commands` message displayed in the monitor. This indicates that the
    module is ready, and everything is initiated. Once you see the message, type `at`
    in the input box and either click the Send button or hit *Enter*. You should see
    an `OK` response from the Bluetooth module. The output should look like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要向蓝牙LE模块发送AT命令，运行前面的代码块，然后打开串行监视器，它是Arduino IDE的一部分。一旦一切启动，你将在监视器中看到`已连接到HM-10。尝试从任何设备连接或发出AT命令`的消息。这表明模块已准备好，一切已启动。一旦看到消息，在输入框中输入`at`，然后点击发送按钮或按*Enter*键。你应该从蓝牙模块看到`OK`响应。输出应该如下所示：
- en: '![](img/8712490a-c504-4717-807f-d2a8d13e8dd2.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8712490a-c504-4717-807f-d2a8d13e8dd2.png)'
- en: 'To send an AT command, you would use the following format:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送AT命令，您将使用以下格式：
- en: '[PRE3]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To set an item, you type in the letters `AT` followed by the plus sign (`+`),
    the command and the new setting without any spaces. For example, to set the name
    that the Bluetooth module will advertise to "Buddy," we would issue the following
    command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置项目，你输入字母`AT`，然后是加号（`+`），命令和新的设置，中间没有空格。例如，要将蓝牙模块广播的名称设置为“Buddy”，我们会发出以下命令：
- en: '[PRE4]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Note**: AT commands are case insensitive.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：AT命令不区分大小写。'
- en: 'To query the item, we would type in the letters `AT` followed by the plus sign
    (`+`), the command and then a question mark (`?`). For example, to query the name
    that the Bluetooth module is advertising, we would use the following command:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要查询项目，我们输入字母`AT`，然后是加号（`+`），命令，然后是问号（`?`）。例如，要查询蓝牙模块正在广播的名称，我们会使用以下命令：
- en: '[PRE5]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can use the application that we just wrote to set the configuration manually
    from the serial monitor or we can set the configurations from within the application
    by using the `print()` function from the `SoftwareSerial` library like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们刚刚编写的应用程序从串行监视器手动设置配置，或者我们可以通过使用`SoftwareSerial`库中的`print()`函数在应用程序内部设置配置，如下所示：
- en: '[PRE6]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let's look at some of the commonly used commands. Any of these can be used from
    the serial monitor or within the code as we just showed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些常用的命令。这些命令可以从串行监视器或代码中像我们刚才展示的那样使用。
- en: Test command
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试命令
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT` | OK | None | This is a test command that can be used to test theconnection
    to the Bluetooth module. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `AT` | OK | 无 | 这是一个测试命令，可以用来测试与蓝牙模块的连接。|'
- en: Query software version
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询软件版本
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+VERR` | Version number | None | This command will return the versionnumber
    of the firmware for the module. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `AT+VERR` | 版本号 | 无 | 此命令将返回模块的固件版本号。 |'
- en: Restore factory default
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恢复出厂默认
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+RENEW` | `OK+RENEW` | None | Restore the factory defaults. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `AT+RENEW` | `OK+RENEW` | 无 | 恢复出厂默认设置。 |'
- en: Restart module
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重启模块
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+RESET` | `OK+RESET` | None | Restarts Bluetooth module. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `AT+RESET` | `OK+RESET` | 无 | 重启蓝牙模块。 |'
- en: Query MAC (Media Access Control) address
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询MAC（媒体访问控制）地址
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+ADDR?` | `OK+ADDR:{MAC Address}` | None | This command can be used to
    query theMAC address of the Bluetooth radio. |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `AT+ADDR?` | `OK+ADDR:{MAC地址}` | 无 | 此命令可用于查询蓝牙无线电的MAC地址。 |'
- en: Set name
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置名称
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+NAME{parameter}` | `OK+set{parameter}` | None | This command will set
    the name for the module. |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `AT+NAME{参数}` | `OK+set{参数}` | 无 | 此命令将设置模块的名称。 |'
- en: Query name
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询名称
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+NAME?` | `OK+NAME{parameter}` | None | This command will return the name
    of the module. |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `AT+NAME?` | `OK+NAME{参数}` | 无 | 此命令将返回模块的名称。 |'
- en: Set the advertising interval
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置广告间隔
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+ADVI{parameter}` | `OK+Set:{parameter}` | `0`: 100ms`1`: 152.5 ms`2`:
    211.25 ms`3`: 318.75 ms`4`: 417.5 ms`5`: 546.25 ms`6`: 760 ms`7`: 852.5 ms`8`:
    1022.5 ms`9`: 1285 ms`A`: 2000 ms`B`: 3000 ms`C`: 4000 ms`D`: 5000 ms`E`: 6000
    ms`F`: 7000 ms | This command will set the advertising intervalfor the Bluetooth
    LE module. The parametershould be 0-F. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `AT+ADVI{参数}` | `OK+Set:{参数}` | `0`: 100ms`1`: 152.5 ms`2`: 211.25 ms`3`:
    318.75 ms`4`: 417.5 ms`5`: 546.25 ms`6`: 760 ms`7`: 852.5 ms`8`: 1022.5 ms`9`:
    1285 ms`A`: 2000 ms`B`: 3000 ms`C`: 4000 ms`D`: 5000 ms`E`: 6000 ms`F`: 7000 ms
    | 此命令将设置蓝牙低功耗模块的广告间隔。参数应为0-F。 |'
- en: Query the advertising interval
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询广告间隔
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+ADVI?` | `OK+get:{parameter}` | None | This command will retrieve the
    current advertisinginterval and will return a parameter of 0-f. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `AT+ADVI?` | `OK+get:{参数}` | 无 | 此命令将检索当前广告间隔，并将返回0-f的参数。 |'
- en: Set advertising type
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置广告类型
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+ADTY{parameter}` | `OK+set:{parameter}` | `0`: Advertising Scan Response,
    Connectable`1`: Only allow the last device connect in 1.28 seconds`2`: Only allow
    Advertising and Scan Response`3`: Only allow Advertising | This command will set
    the'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '| `AT+ADTY{参数}` | `OK+set:{参数}` | `0`: 广告扫描响应，可连接`1`: 仅允许在1.28秒内连接最后设备`2`:
    仅允许广告和扫描响应`3`: 仅允许广告 | 此命令将设置广告类型。 |'
- en: advertising type. |
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 广告类型。 |
- en: Query advertising type
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询广告类型
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+ADTY?` | `OK+get:{parameter}` | None | This command will retrieve the
    current advertisingtype and will return a parameter of 0-3. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `AT+ADTY?` | `OK+get:{参数}` | 无 | 此命令将检索当前广告类型，并将返回0-3的参数。 |'
- en: Set baud rate
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置波特率
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+BAUD{parameter}` | `OK+set:{parameter}` | `0`: 9600`1`: 19200`2`: 38400`3`:
    57600`4`: 115200`5`: 4800`6`: 2400`7`: 1200`8`: 230400 | This command will set
    the baud rate for the serialinterface of the Bluetooth module. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `AT+BAUD{参数}` | `OK+set:{参数}` | `0`: 9600`1`: 19200`2`: 38400`3`: 57600`4`:
    115200`5`: 4800`6`: 2400`7`: 1200`8`: 230400 | 此命令将设置蓝牙模块的串行接口波特率。 |'
- en: Query baud rate
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询波特率
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+BAUD?` | `OK+get:{parameter}` | None | This command will retrieve the
    current baud rate andwill return a parameter of 0-8. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `AT+BAUD?` | `OK+get:{参数}` | 无 | 此命令将检索当前波特率，并将返回0-8的参数。 |'
- en: Set characteristic id
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置特征ID
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+CHAR{parameter}` | `OK+set:{parameter}` | `0x0001` -> `0xFFFe` | This
    command will set the ID for thecharacteristic. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `AT+CHAR{参数}` | `OK+set:{参数}` | `0x0001` -> `0xFFFe` | 此命令将设置特征的ID。 |'
- en: Set service id
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置服务ID
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+UUID{parameter}` | `OK+set:{parameter}` | `0x0001` -> `0xFFFe` | This
    command will set the ID for the service. |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `AT+UUID{参数}` | `OK+set:{参数}` | `0x0001` -> `0xFFFe` | 此命令将设置服务的ID。 |'
- en: Query service id
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询服务ID
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+UUID?` | `OK+get:{parameter}` | None | This command will retrieve the
    current service ID. |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `AT+UUID?` | `OK+get:{参数}` | None | 此命令将检索当前服务ID。 |'
- en: Set role
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置角色
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+ROLE{parameter}` | `OK+set:{parameter}` | `0`: Peripheral`1`: Central
    | This command will set the role of the Bluetooth module. |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `AT+ROLE{参数}` | `OK+set:{参数}` | `0`: 边缘设备`1`: 中心设备 | 此命令将设置蓝牙模块的角色。 |'
- en: Query role
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询角色
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+ROLE?` | `OK+get:{parameter}` | None | This command will return the role
    of the Bluetoothmodule. |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `AT+ROLE?` | `OK+get:{参数}` | None | 此命令将返回蓝牙模块的角色。 |'
- en: Clear last connected device
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清除最后连接设备
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+CLEAR` | `OK+CLEAR` | None | Clears the address of the last connected
    device. |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `AT+CLEAR` | `OK+CLEAR` | None | 清除最后连接设备的地址。 |'
- en: '**NOTE**: The `at+clear` command is only used when the device is in central
    mode.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：`at+clear`命令仅在设备处于中心模式时使用。'
- en: Try to connect to last connected device
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试连接到最后一次连接的设备
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+CONNL` | `OK+CONN{parameter}` | `L`: Connecting`E`: Connect Error`F`:
    Connect Fail`N`: No Address | This command will attempt to connect to the devicethat
    last successfully connected to it. |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `AT+CONNL` | `OK+CONN{参数}` | `L`: 连接中`E`: 连接错误`F`: 连接失败`N`: 无地址 | 此命令将尝试连接到最后一次成功连接的设备。
    |'
- en: '**NOTE**: The `at+connl` command is only used when the device is in central
    mode.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：`at+connl`命令仅在设备处于中心模式时使用。'
- en: Try to connect to an address
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试连接到地址
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+CON{parameter}` | `OK+CONN{parameter}` | `A`: Connecting`E`: Connect
    Error`F`: Connect Fail | This command will attempt to connect to a devicewith
    the specified address. |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `AT+CON{参数}` | `OK+CONN{参数}` | `A`: 连接`E`: 连接错误`F`: 连接失败 | 此命令将尝试连接到指定地址的设备。
    |'
- en: '**NOTE**: The `at+con` command is only used when the device is in central mode.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：`at+con`命令仅在设备处于中心模式时使用。'
- en: Set pin code
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置PIN码
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+PASS{parameter}` | `OK+set:{parameter}` | `000000` -> `999999` | Sets
    the pin code for connection. |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `AT+PASS{参数}` | `OK+set:{参数}` | `000000` -> `999999` | 设置连接的PIN码。 |'
- en: Query pin code
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询PIN码
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+PASS?` | `OK+get:{parameter}` | None | This command will return the current
    pin code. |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `AT+PASS?` | `OK+get:{参数}` | None | 此命令将返回当前的PIN码。 |'
- en: Set module power
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置模块功率
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+POWE{parameter}` | `OK+set:{parameter}` | `0`: -23db`1`: -6db`2`: 0db`3`:
    6db | Sets the power for the module. |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `AT+POWE{参数}` | `OK+set:{参数}` | `0`: -23db`1`: -6db`2`: 0db`3`: 6db | 设置模块的功率。
    |'
- en: Query module power
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询模块功率
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+POWE?` | `OK+get:{parameter}` | None | This command will return the current
    module power. |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `AT+POWE?` | `OK+get:{参数}` | None | 此命令将返回当前模块的功率。 |'
- en: Set bond mode
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置配对模式
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+TYPE{parameter}` | `OK+set:{parameter}` | `0`: PIN code not needed`1`:
    Auth without PIN code`2`: Auth and PIN`3`: Auth and bond | This command sets the
    authentication neededwhen connecting to this device. |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `AT+TYPE{参数}` | `OK+set:{参数}` | `0`: 不需要PIN码`1`: 无PIN码认证`2`: 有PIN码认证`3`:
    有PIN码配对 | 此命令设置连接到此设备所需的认证。 |'
- en: Query bond mode
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询配对模式
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+TYPE?` | `OK+get:{parameter}` | None | This command will return the current
    authenticationneeded to connect to this device. |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `AT+TYPE?` | `OK+get:{parameter}` | None | 此命令将返回连接到此设备所需的当前认证。 |'
- en: Set notify information
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置通知信息
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+NOTI{parameter}` | `OK+set:{parameter}` | `0`: Don''t Notify`1`: Notify
    | This command enables or disables the notificationwhen a device connects are
    disconnects. |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `AT+NOTI{parameter}` | `OK+set:{parameter}` | `0`: 不通知`1`: 通知 | 此命令启用或禁用设备连接或断开时的通知。
    |'
- en: Query notify information
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询通知信息
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **响应** | **参数** | **描述** |'
- en: '| `AT+NOTI?` | `OK+get:{parameter}` | None | This command will return if the
    device will send anotification when a device connects or disconnects. |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `AT+NOTI?` | `OK+get:{parameter}` | None | 此命令将返回设备在连接或断开时是否会发送通知。 |'
- en: We can only issue AT commands to the Bluetooth module when another device is
    not connected to it. Once a device is connected to the application code that we
    wrote takes over, and the data that is typed into the serial console is sent to
    the connected device. Let's see what happens when we connect to the Bluetooth
    module from another device. I will be using the *BTCommander – Serial Port HM10*
    app to show how this works.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有其他设备连接到蓝牙模块时，我们才能向蓝牙模块发出AT命令。一旦设备连接，我们编写的应用程序代码将接管，并且输入到串行控制台的数据将发送到连接的设备。让我们看看从另一个设备连接到蓝牙模块时会发生什么。我将使用*BTCommander
    – Serial Port HM10*应用程序来展示这是如何工作的。
- en: 'With the application running on the Arduino, start up the Bluetooth application
    on your phone/tablet or computer. The *BTCommander* app will look like this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在Arduino上运行应用程序后，在你的手机/平板电脑或电脑上启动蓝牙应用程序。*BTCommander*应用程序看起来如下所示：
- en: '![](img/06a970b0-493e-4f7f-90ac-eb58809a24df.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/06a970b0-493e-4f7f-90ac-eb58809a24df.png)'
- en: 'To connect to a device, press the blue connection button, which looks like
    an outlet plug, located at the upper right side of the application. Once you press
    the button, you should see a list of devices that the application can connect
    to. This screen looks like this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到设备，请按下位于应用程序右上角的蓝色连接按钮，它看起来像一个电源插座。按下按钮后，你应该会看到应用程序可以连接到的设备列表。此屏幕看起来如下所示：
- en: '![](img/c2f0fc2a-0414-42cb-8461-e5584fab6a62.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c2f0fc2a-0414-42cb-8461-e5584fab6a62.png)'
- en: 'This screen shows all devices that are advertising and are close enough to
    connect. Earlier in this chapter, when we ran the `AT+nameBuddy` command, we renamed
    our device to `Buddy`. Therefore, we know that is the device that we want to connect
    to. If we tap that device and then tap on the Connect button at the upper right
    side of the application, the application will attempt to connect. If the connection
    attempt is successful and the `AT+NOTI` setting on the Bluetooth module has the
    notifications enabled, we should see `OK+CONN` on the serial console as shown
    in the following screenshot:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 此屏幕显示所有正在广播且足够接近以连接的设备。在本章早期，当我们运行`AT+nameBuddy`命令时，我们将我们的设备重命名为`Buddy`。因此，我们知道这是我们想要连接的设备。如果我们点击该设备，然后点击应用程序右上角的连接按钮，应用程序将尝试连接。如果连接尝试成功，并且蓝牙模块上的`AT+NOTI`设置启用了通知，我们应该在串行控制台中看到以下截图所示的`OK+CONN`：
- en: '![](img/d17d039f-2ac0-4a3c-a5c5-81b59055c6be.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d17d039f-2ac0-4a3c-a5c5-81b59055c6be.png)'
- en: 'When the connection is successful, the application will go back to the main
    screen. Now let''s type a message in the input box at the bottom of the screen.
    For example, here we will type a simple `hello` message as shown in the following
    screenshot:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 连接成功后，应用程序将返回主屏幕。现在让我们在屏幕底部的输入框中输入一条消息。例如，在这里我们将输入一个简单的`hello`消息，如下所示：
- en: '![](img/684f46ed-eb2b-41f8-8e81-9cd6f13490b1.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/684f46ed-eb2b-41f8-8e81-9cd6f13490b1.png)'
- en: 'Once the message is entered, press the button next to the input box that looks
    like a paper airplane to send the message. If the message was successfully sent,
    we will see it in the serial console as shown in the following screenshot:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 输入消息后，按下看起来像纸飞机的输入框旁边的按钮以发送消息。如果消息成功发送，我们将在以下截图所示的串行控制台中看到它：
- en: '![](img/ecb0e61e-18bf-4aa0-846e-c8dabdddb33a.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ecb0e61e-18bf-4aa0-846e-c8dabdddb33a.png)'
- en: What is happening here is the message that is entered in the application is
    being passed from the phone application to the chrematistic on the HM-10 Bluetooth
    module, so our application can read it. The message is sent one character at a
    time.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况是，在应用程序中输入的消息正从手机应用程序传递到HM-10蓝牙模块上的特征，因此我们的应用程序可以读取它。消息是逐个字符发送的。
- en: 'To send a message back, type the message in the input box of the serial console
    and press the send button. If the message was sent successfully, we should see
    it in the application as shown in the following screenshot:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送回消息，请在串行控制台输入框中输入消息并按发送按钮。如果消息发送成功，我们应该在以下截图所示的应用程序中看到它：
- en: '![](img/8511eb14-e1d8-44f2-8055-9e28f76788f5.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8511eb14-e1d8-44f2-8055-9e28f76788f5.jpg)'
- en: In this screenshot, we can see that the `hello` message was sent from the application
    and the `Hello from Arduino` was received from the connected device. When a message
    is sent from the HM-10 Bluetooth module back to the phone application, the application
    writes the message to the characteristic (one character at a time) and the Bluetooth
    module uses a notification to notify the client (the phone application) that there
    is new data.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在此截图中，我们可以看到从应用程序发送了 `hello` 消息，并且从连接的设备接收到了 `Hello from Arduino`。当从HM-10蓝牙模块向手机应用程序发送消息时，应用程序将消息写入特征（一次一个字符），蓝牙模块使用通知来通知客户端（手机应用程序）有新数据。
- en: 'If we press the connection button again in the *BTCommander* application to
    disconnect, and the `AT+NOTI` configuration is set to notify, we will see an `OK+LOST`
    message in the serial console as shown in the following screenshot:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 *BTCommander* 应用程序中再次按下连接按钮以断开连接，并且将 `AT+NOTI` 配置设置为通知，我们将在串行控制台中看到如下截图所示的
    `OK+LOST` 消息：
- en: '![](img/3908f18b-285c-47dc-962f-b2d72076f22a.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3908f18b-285c-47dc-962f-b2d72076f22a.png)'
- en: Now let's see how we can use the Bluetooth module to control an LED from our
    phone.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何使用蓝牙模块从我们的手机控制一个LED。
- en: Project 2 – controlling LED
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目2 – 控制LED
- en: 'In this project, we will turn an LED that is connected to the Arduino on or
    off depending on the input from the phone. The first thing we will need to do
    is to add the LED to our circuit. The following diagram shows the new circuit:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将根据手机输入打开或关闭连接到Arduino的LED。我们首先需要做的是将LED添加到我们的电路中。以下图示显示了新的电路：
- en: '![](img/3379c415-722f-4de3-b44a-0e0a287bff3c.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3379c415-722f-4de3-b44a-0e0a287bff3c.png)'
- en: 'The LED is connected to the digital 5 pin on the Arduino through a 330-ohm
    resistor. Now we need to write the code to control the LED. We will start by setting
    up the `SoftwareSerial` library for the Bluetooth module and defining the pin
    that the LED is connected to. The following code will do this:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: LED通过一个330欧姆电阻连接到Arduino的数字5引脚。现在我们需要编写代码来控制LED。我们将首先为蓝牙模块设置 `SoftwareSerial`
    库并定义LED连接的引脚。以下代码将执行此操作：
- en: '[PRE7]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can see that the Bluetooth module is connected to the same pins as the previous
    example, and the LED is connected to digital pin 5 on the Arduino. In the `setup()`
    function, we will need to configure the `SoftwareSerial` instance and the mode
    of the pin that the LED is connected to. The following code shows the `setup()`
    function for this example:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到蓝牙模块连接到与上一个示例相同的引脚，LED连接到Arduino的数字引脚5。在 `setup()` 函数中，我们需要配置 `SoftwareSerial`
    实例以及LED连接的引脚模式。以下代码显示了此示例的 `setup()` 函数：
- en: '[PRE8]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code starts off by defining the mode of the pin that the LED is connected
    to. It then configures the serial port for the serial monitor and the `SoftweareSerial`
    instance. We finally print a message to the serial console letting the user know
    that everything is configured and ready to go.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码首先定义了LED连接的引脚模式。然后配置了串行监视器的串行端口和 `SoftweareSerial` 实例。最后，我们在串行控制台中打印一条消息，让用户知道一切已配置并准备就绪。
- en: 'In our `loop()` function, we will need to check the `SoftwareSerial` instance,
    and if a `1` is received from the connected device, it will turn the LED on, and
    if a `0` is received, it will turn the LED off. If neither a `1` or a `0` is received,
    then it will ignore the input. Here is the code for the `loop()` function:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `loop()` 函数中，我们需要检查 `SoftwareSerial` 实例，如果从连接的设备接收到 `1`，则LED会打开，如果接收到 `0`，则LED会关闭。如果没有接收到
    `1` 或 `0`，则忽略输入。以下是 `loop()` 函数的代码：
- en: '[PRE9]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this code, we check to see whether a value is available from the Bluetooth
    module, and if so, we read the device to get the character that was received.
    If the character is equal to `1` (the character 1 and not the number 1), we pull
    the pin that the LED is connected to `HIGH` to turn the LED on. If the character
    is equal to `0` (the character 0 and not the number 0), we pull the pin that the
    LED is connected to `LOW` to turn the LED off.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们检查蓝牙模块是否有可用值，如果有，我们读取设备以获取接收到的字符。如果字符等于`1`（字符1，而不是数字1），我们将连接LED的引脚拉高以打开LED。如果字符等于`0`（字符0，而不是数字0），我们将连接LED的引脚拉低以关闭LED。
- en: Now let's run this application and use the *BTCommander* application to connect
    to it. From the *BTCommander* application, if we send a `1`, the LED will light
    up, or if we send a `0`, the LED will go off. This type of example can be used
    when we wish to have a phone application to control something that is connected
    to the Arduino such as an LED, DC Motor or some sensor.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行这个应用程序，并使用*BTCommander*应用程序来连接它。从*BTCommander*应用程序，如果我们发送`1`，LED将点亮，如果我们发送`0`，LED将熄灭。这种类型的示例可以用于我们希望手机应用程序控制连接到Arduino的某些设备，如LED、直流电机或某些传感器。
- en: Now let's see how we can retrieve temperature and humidity data from the DHT-11
    sensor via Bluetooth LE.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何通过蓝牙低功耗从DHT-11传感器检索温度和湿度数据。
- en: Project 3 – environmental sensor
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目3 - 环境传感器
- en: 'In this project, we will request, from the phone, that the Arduino send temperature
    or humidity information depending on the character sent. We will need to add the
    DHT-11 sensor to our circuit. The following diagram shows how to do this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将从手机请求Arduino发送温度或湿度信息，具体取决于发送的字符。我们需要将DHT-11传感器添加到我们的电路中。以下图表显示了如何进行：
- en: '![](img/f841810b-72b2-45c7-a6d1-8c9a758b929b.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f841810b-72b2-45c7-a6d1-8c9a758b929b.png)'
- en: 'The DHT-11 temperature sensor is connected to the Arduino exactly as we did
    in [Chapter 9](03634c50-cc88-4b10-8a3a-4054b67f0691.xhtml), *Environment Sensors*.
    If you are unsure how to connect this sensor to the Arduino, please refer back
    to that chapter. Now we will need to write the code, so we can access the data
    from the sensor with Bluetooth LE service. We will start by setting up the `SoftwareSerial`
    library for the Bluetooth module and the DHT-11 temperature sensor. The following
    code will do this:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: DHT-11温度传感器连接到Arduino的方式与我们[第9章](03634c50-cc88-4b10-8a3a-4054b67f0691.xhtml)中所述的*环境传感器*相同。如果您不确定如何将此传感器连接到Arduino，请参阅该章节。现在我们需要编写代码，以便我们可以通过蓝牙低功耗服务访问传感器的数据。我们将首先为蓝牙模块和DHT-11温度传感器设置`SoftwareSerial`库。以下代码将执行此操作：
- en: '[PRE10]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code includes the libraries for the DHT temperature sensor and also the
    `SoftwareSerial` device. It then defines the pin that the temperature sensor is
    connected to and the type of sensor. Finally, it creates instances of the `DHT`
    and the `SoftwareSerial` types.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码包括DHT温度传感器的库以及`SoftwareSerial`设备。然后它定义了连接到温度传感器的引脚和传感器的类型。最后，它创建了`DHT`和`SoftwareSerial`类型的实例。
- en: 'In the `setup()` function, we will need to configure the `SoftwareSerial` instance
    and the mode of the pin that the LED is connected to. The following code shows
    the `setup()` function for our example:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setup()`函数中，我们需要配置`SoftwareSerial`实例和连接到LED的引脚的模式。以下代码显示了我们的示例的`setup()`函数：
- en: '[PRE11]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This function configures the `SoftwareSerial` instance and prints a message
    to the serial console when everything is initiated and ready to go. In the `loop()`
    function, we will want to read the input from the device that is connected to
    the service and then respond back with the appropriate information.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数配置`SoftwareSerial`实例，并在一切启动并准备就绪时向串行控制台打印一条消息。在`loop()`函数中，我们将想要从连接到服务的设备读取输入，然后使用适当的信息进行响应。
- en: 'The following chart shows the input and what should be returned:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了输入以及应该返回的内容：
- en: '| **Input** | **Property Returned** |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| **输入** | **返回属性** |'
- en: '| `f` | Temperature in Fahrenheit |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| `f` | 华氏度温度 |'
- en: '| `c` | Temperature in Celsius |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| `c` | 摄氏度温度 |'
- en: '| `h` | Humidity |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| `h` | 湿度 |'
- en: '| `F` | Heat Index Fahrenheit |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| `F` | 华氏度热指数 |'
- en: '| `C` | Heat Index in Celsius |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| `C` | 摄氏度热指数 |'
- en: 'From the chart, we can see that we will have five inputs and each one will
    return different information back to the remote device. Let''s look at the code
    that will read the input and return the information requested:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 从图表中，我们可以看到我们将有五个输入，每个输入将返回不同的信息给远程设备。让我们看看读取输入并返回所需信息的代码：
- en: '[PRE12]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code starts by checking the Bluetooth adapter to see whether there is any
    input available, and if so, it reads the character. If the input character is
    one of the characters listed in the previous chart, the code retrieves the appropriate
    value from the DHT-11 sensor and returns the value back to the connected device.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码首先检查蓝牙适配器，看是否有可用输入，如果有，则读取字符。如果输入字符是之前图表中列出的字符之一，代码将从DHT-11传感器检索适当的值，并将该值返回给连接的设备。
- en: 'The output from the code in the *BTCommander* iOS app would look similar to
    this:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在*BTCommander* iOS应用中的代码输出将类似于以下内容：
- en: '![](img/547ecbdc-4537-47ac-97d8-85f51efd77da.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/547ecbdc-4537-47ac-97d8-85f51efd77da.jpg)'
- en: Everything we have shown here is compatible with Bluetooth LE 4.0 and above.
    As of the time of writing this book, there really are not that many low-cost Bluetooth
    LE modules for the Arduino that are compatible with the new Bluetooth LE 4.2 and
    5.0 standards, which is why we stuck with 4.0 here. The good news is all of the
    newer standards are backward compatible with the 4.0 standard, so everything we
    talked about in this chapter will work as newer Bluetooth modules are released
    that are compatible with the newer standards. Let's look at what features are
    available with the newer Bluetooth standards.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里展示的所有内容都与蓝牙LE 4.0及以上版本兼容。截至本书编写时，市场上真正与新的蓝牙LE 4.2和5.0标准兼容的低成本蓝牙LE模块并不多，这就是为什么我们坚持使用4.0。好消息是所有新的标准都与4.0标准向后兼容，因此，随着与较新标准兼容的新蓝牙模块的发布，本章中讨论的所有内容都将正常工作。让我们看看较新蓝牙标准提供了哪些特性。
- en: What is new with Bluetooth 4.1, 4.2 and 5.0?
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝牙4.1、4.2和5.0的新特性是什么？
- en: In this section, we will look at what is new with Bluetooth 4.1, 4.2, and 5.0\.
    While these features are not compatible with the Bluetooth LE 4.0 module that
    we used in this chapter, eventually Bluetooth modules for the Arduino that are
    compatible with these standards will be released; therefore, it is good to know
    what features they offer.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨蓝牙4.1、4.2和5.0的新特性。虽然这些特性与我们在本章中使用的蓝牙LE 4.0模块不兼容，但最终将会有与这些标准兼容的Arduino蓝牙模块发布；因此，了解它们提供的特性是很有帮助的。
- en: Bluetooth 4.1
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝牙4.1
- en: Bluetooth 4.1 mainly offers usability updates. One of the most important updates
    is to allow Bluetooth LE and LTE radios to coexist better. This update allows
    the radios to coordinate transmissions to decrease the chance of interference.
    It also makes the data transfer more efficient and allows for better reconnections
    after connection loss.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝牙4.1主要提供可用性更新。其中最重要的更新是允许蓝牙LE和LTE无线电更好地共存。此更新允许无线电协调传输以减少干扰的机会。它还使数据传输更高效，并在连接丢失后允许更好的重新连接。
- en: The big non-usability change with Bluetooth 4.1 allowed a device to be both
    a peripheral and a central at the same time.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝牙4.1的非可用性重大变化允许设备同时作为外围设备和中心设备。
- en: Bluetooth 4.2
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝牙4.2
- en: Bluetooth 4.2 offered numerous new features for IoT, security, faster speed
    and more capacity.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝牙4.2为物联网、安全性、更快速度和更大容量提供了众多新特性。
- en: For IoT, Bluetooth 4.2 added **Bluetooth Smart Internet gateways**, which enables
    Bluetooth 4.2 devices a bridge to the internet. With the internet gateways, Bluetooth
    4.2 also added IPv6/6LoWPAN, which enables IPv6 support over a Bluetooth connection.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 对于物联网，蓝牙4.2增加了**蓝牙智能互联网网关**，这使得蓝牙4.2设备能够连接到互联网。通过互联网网关，蓝牙4.2还增加了IPv6/6LoWPAN，这使得通过蓝牙连接支持IPv6。
- en: Bluetooth 4.2 also added extra security with LE Privacy 1.2\. The encryption
    standards with Bluetooth 4.2 comply with the **Federal Information Processing
    Standards** (**FIPS**), which is a US Government computer security standard.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝牙4.2还通过LE隐私1.2增加了额外的安全性。蓝牙4.2的加密标准符合**联邦信息处理标准**（**FIPS**），这是一项美国政府计算机安全标准。
- en: The transmission packet size was increased by ten times as well. This allows
    for faster and more reliable data transmissions.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 传输数据包大小增加了十倍。这允许更快、更可靠的数据传输。
- en: Bluetooth 5.0
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝牙5.0
- en: Bluetooth offers a number of enhancements,quadrupling the range and doubling
    the speed. The catch with this is that if a device manufacturer increases the
    range of their device, the speed will go down; and likewise, if the speed increases,
    the range will go down.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝牙提供了一系列增强功能，将范围扩大了四倍，速度提高了两倍。但问题是，如果设备制造商增加了设备的范围，速度就会下降；同样，如果速度提高了，范围也会下降。
- en: Bluetooth mesh
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝牙网状网络
- en: One of the latest, and in my opinion, the most exciting, Bluetooth technologies
    is Bluetooth mesh. All previous Bluetooth technologies relied on a one-to-one
    or a one-to-many connection where there was always one master/central device.
    Mesh technology allows Bluetooth devices to establish many-to-many connections,
    which enables large-scale device networks that do not rely on a central controller.
    The Bluetooth mesh technology is still in its infancy at the time we are writing
    this book. However, I believe it is the future of Bluetooth and is a technology
    worth keeping an eye on.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在最新的蓝牙技术中，我认为最令人兴奋的是蓝牙网状网络。所有之前的蓝牙技术都依赖于一对一或一对多的连接，其中始终有一个主/中心设备。网状技术允许蓝牙设备建立多对多的连接，这可以实现不依赖于中心控制器的大规模设备网络。当我们撰写这本书时，蓝牙网状技术仍处于起步阶段。然而，我相信它是蓝牙的未来，并且是一项值得关注的科技。
- en: One thing to note with Bluetooth standards higher than 4.0 is most of the new
    features are optional and not required to be fully implemented. For example, a
    manufacturer may say that their device meets the Bluetooth 4.2 standard. However,
    IPv6/6LoWPAN may not be implemented in the device. A good example of this is the
    iPhone. My iPhone X is Bluetooth 5.0 compatible; however, it is not capable of
    running Bluetooth mesh or IPv6/6LoWPAN.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，对于高于4.0的蓝牙标准，大多数新特性都是可选的，并不要求完全实现。例如，制造商可能会说他们的设备符合蓝牙4.2标准。然而，IPv6/6LoWPAN可能并未在设备中实现。一个很好的例子是iPhone。我的iPhone
    X支持蓝牙5.0；然而，它无法运行蓝牙网状网络或IPv6/6LoWPAN。
- en: Challenge
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战
- en: For the challenge, take the Nokia 5110 LCD display that we used in [Chapter
    13](5daf3c48-d927-436f-81ec-0b04d23d764f.xhtml), *Using LCD Displays*, and the
    serial communication code that we used in the first project of this chapter and
    print any message sent from the phone app to the LCD display. This will require
    some modification to the code in this chapter to use the LCD screen rather than
    the serial console.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个挑战，请使用我们在[第13章](5daf3c48-d927-436f-81ec-0b04d23d764f.xhtml)中使用的Nokia 5110液晶显示屏和本章第一个项目使用的串行通信代码，打印从手机应用发送到液晶显示屏的任何消息。这需要对本章中的代码进行一些修改，以便使用液晶屏幕而不是串行控制台。
- en: Summary
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned a lot about Bluetooth LE, starting with a brief
    introduction on how the radio works and the network topology for Bluetooth LE
    connections. We learned how the GAP is used by Bluetooth LE devices to discover
    and connect to other devices. We also saw how the GATT uses attributes (services,
    characteristics and descriptors) to enable two Bluetooth LE devices to communicate
    with each other. We finally demonstrated how Bluetooth LE works with three projects
    at the end of this chapter.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关于蓝牙LE的很多知识，从对无线电工作原理和蓝牙LE连接的网络拓扑的简要介绍开始。我们学习了蓝牙LE设备如何使用GAP来发现和连接到其他设备。我们还看到了GATT如何使用属性（服务、特性和描述符）使两台蓝牙LE设备能够相互通信。最后，我们在本章末尾通过三个项目展示了蓝牙LE的工作原理。
- en: Bluetooth LE is the technology best suited when we wish to use an external device,
    such as a phone, to control the device that we are building, because almost all
    smartphones have Bluetooth LE built in and the technology is easy to use. It is
    also a good technology to use when we wish to send short bursts of data from one
    device to another. If you wish to build a separate device, such as a remote control,
    to control your main device or stream a lot of data, then I would recommend a
    different Bluetooth technology that is known as Bluetooth Classic or Legacy, which
    we will see in the next chapter.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们希望使用外部设备，如手机，来控制我们正在构建的设备时，蓝牙低功耗（LE）是最适合的技术，因为几乎所有的智能手机都内置了蓝牙LE，并且该技术易于使用。它也是当我们希望从一台设备向另一台设备发送短数据包时使用的好技术。如果您希望构建一个独立的设备，如遥控器，来控制主设备或传输大量数据，那么我建议使用另一种名为蓝牙经典或遗留的蓝牙技术，我们将在下一章中看到。
