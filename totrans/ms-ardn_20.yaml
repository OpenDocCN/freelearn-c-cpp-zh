- en: Bluetooth LE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book so far, all external communication with our Arduino projects has
    been in a closed environment. By closed environment, we mean that our project
    simply received information or direction from a remote control and no information
    was transmitted out from the project. There are numerous use cases where we need
    to transmit information from our Arduino project to an external device such as
    a smartphone or other IoT device. When there is a need such as this, one of the
    first technologies that is brought up is **Bluetooth Low Energy**, also known
    as **Bluetooth LE** or Bluetooth Smart.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: What Bluetooth LEÂ is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the Bluetooth LE radio works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the GAP profile is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the GATT profile is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the HM-10 Bluetooth LE radio module with the Arduino
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common misunderstandings of Bluetooth LE by people that are
    not familiar with the technology is that Bluetooth LE is a lightweight subset
    of **Bluetooth Classic**. This is not true, as Bluetooth Classic and Bluetooth
    LE are two fundamentally different protocols with different design goals.
  prefs: []
  type: TYPE_NORMAL
- en: Most wireless technologies, such as Wi-Fi and Bluetooth Classic, were designed
    to satisfy a wide range of use cases; however, the design of Bluetooth LE is a
    bit different. Originally created by Nokia and known as **Wibree**, the primary
    design focus of Bluetooth LE was to create a radio standard with the lowest possible
    power consumption and optimized for low cost, low complexity, and low bandwidth.
  prefs: []
  type: TYPE_NORMAL
- en: Bluetooth LE specifications were released as part of the Bluetooth 4.0 Core
    specifications in June of 2010\. The Bluetooth Core Specifications are overseen
    and updated by the Bluetooth **Special Interest Group** (**SIG**).
  prefs: []
  type: TYPE_NORMAL
- en: You can find information about Bluetooth and download the specifications from
    their site at [https://www.bluetooth.com](https://www.bluetooth.com); however,
    at over 2500 pages, I would recommend that you read this chapter instead of the
    Bluetooth specifications unless you are looking for help with insomnia.
  prefs: []
  type: TYPE_NORMAL
- en: The adoption rate of Bluetooth LE has been much faster than most other wireless
    technologies. The reason for this is the adoption of the Bluetooth LE standard
    in the mobile industry where Apple and Google have put significant effort into
    including reliable Bluetooth LE stacks with the iOS and Android operating systems
    and developing easy-to-use-and-understand Bluetooth LE APIs for developers. This
    makes it very easy for developers to create and interact with devices that have
    Bluetooth LE radios.
  prefs: []
  type: TYPE_NORMAL
- en: The reason that the mobile industry has been pushing for the adoption of Bluetooth
    LE is that devices that connect using Bluetooth LE consume far less power, hence
    the name Bluetooth Low Energy, as compared to other wireless technologies such
    as Bluetooth Classic and Wi-Fi. This leads to longer battery life for their phones,
    which leads to happier customers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bluetooth devices come in three types, where each type supports either Bluetooth
    Classic, Bluetooth LE or both. The following chart shows what each type supports:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Device Type** | **Bluetooth Classic Support** | **Bluetooth LE Support**
    |'
  prefs: []
  type: TYPE_TB
- en: '| Pre-4.0 Bluetooth | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| Single-Mode | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Dual-Mode | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: While the Bluetooth 5.0 specifications were released in June of 2016, at the
    time this book is being written, there are very few Bluetooth modules for the
    Arduino that support this new specification. In fact, at this time, there is very
    little support for the Bluetooth 4.1 or 4.2 specifications either; therefore,
    in this book, we are going to focus on the Bluetooth 4.0 specifications, knowing
    that Bluetooth 5.0, 4.2 and 4.1 are all backward compatible with this standard.
  prefs: []
  type: TYPE_NORMAL
- en: In order to design IoT devices that use Bluetooth LE we really need to understand
    the technology so we know when actually to use it. Therefore, we will delve into
    this technology a lot further than we have with other technologies in this book.
    We will start off by looking at the radio specifications.
  prefs: []
  type: TYPE_NORMAL
- en: Bluetooth LE radio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we will be using Bluetooth LE 4.0 for all the projects in this book,
    the following specifications are for this standard:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Range** | **Up to 100 meters** |'
  prefs: []
  type: TYPE_TB
- en: '| Radio Frequency | 2.402 - 2.481 GHz |'
  prefs: []
  type: TYPE_TB
- en: '| Radio Channels | 40 (37 data and 3 advertising) |'
  prefs: []
  type: TYPE_TB
- en: '| Maximum OTA Data Rate | 1 Mbit/s |'
  prefs: []
  type: TYPE_TB
- en: '| Application Data Throughput | 0.125 Mbit/s |'
  prefs: []
  type: TYPE_TB
- en: '| Network Topologies | Point-to-Point |'
  prefs: []
  type: TYPE_TB
- en: '| Network Standard | IEEE 802.15.1 |'
  prefs: []
  type: TYPE_TB
- en: Bluetooth LE has a maximum range of 100 meters, but this is very dependent on
    the surroundings. When the connected devices are indoors, the range will be dramatically
    reduced due to walls and other obstacles that the radio signal needs to go through.
    Generally, we will not see a range close to 100 meters unless we are outside in
    an open field. Even then it is rare to get a range of 100 meters.
  prefs: []
  type: TYPE_NORMAL
- en: The Bluetooth LE radio operates on over 40 channels, ranging from 2.402 GHz
    to 2.481 GHz. Of these channels, 37 are reserved for data and three are reserved
    for advertising. The reason for the multiple channels is Bluetooth LE uses frequency
    hopping to mitigate interference. The three advertising channels are used for
    discovery of devices. Once a device is discovered, the same channel is used to
    exchange initial connection parameters. Once the connection parameters have been
    exchanged, the regular data channels are used for communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the channels used by Bluetooth LE:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a566589f-731c-4553-9f8d-d2390854732c.png)'
  prefs: []
  type: TYPE_IMG
- en: Bluetooth LE is designed to operate at low power, and the best way to avoid
    using power is to turn the radio off as often as possible and for as long as possible.
    For Bluetooth LE, this is achieved by sending short bursts of packets at a certain
    frequency, and in between those radio bursts, the radio is powered off. This is
    often referred to as **Racing to Idle**, since the radio is essentially sending
    out information as fast as it can and then shutting down for a short period of
    time.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest sacrifice that we make for the low power usage of Bluetooth LE is
    the application data throughput. In the previous chart, we saw that the Bluetooth
    LE radio has a maximum over-the-air data rate of 1 Mbit/s. However, we also listed
    the application data throughput as only 0.125 Mbit/s. This means that the radio
    can theoretically transfer 1 Mbit per second; however, with the limitations put
    on the radio to conserve power, we only have a maximum transfer rate of 0.125
    Mbit per second. In a real-world application, we will actually never see anything
    close to this data transfer rate.
  prefs: []
  type: TYPE_NORMAL
- en: Let's examine the race to idle and the limitations put on by the Bluetooth LE
    standards to understand why the data throughput is so low. To start off with,
    the Bluetooth LE specifications define that the connection interval, which is
    the time interval between two consecutive connection events (when the two devices
    exchange data), to be between 7.5 ms and 4 s. This means that if we set the connection
    interval to the shortest time possible (7.5 ms), we will have a maximum of 133
    connection events per second.
  prefs: []
  type: TYPE_NORMAL
- en: The radio can transmit up to six data packets per connection event, where each
    data packet can contain a maximum of 20 bytes of user data. This gives up a maximum
    of 120 bytes for each connection event.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we put all of the information together, we get the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e19b98a-53db-46dd-8890-ffbed9cc5a77.png)'
  prefs: []
  type: TYPE_IMG
- en: This shows that the maximum data throughput would be 0.125 Mbit/second; however,
    as we mentioned earlier, even that number will never be reached because we generally
    will never max out the bytes per packet or have 133 connection events in one second.
    Devices themselves can add further limitations to the connection interval and
    data packets per connection. In the best case, we will generally see around 5-10
    KB per second for the data throughput. This means that we generally only want
    to use Bluetooth LE technology when we are exchanging short bursts of data and
    avoid it when we wish to exchange large amounts or even stream data.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at the network topology for Bluetooth LE connections.
  prefs: []
  type: TYPE_NORMAL
- en: Network topology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bluetooth LE devices can communicate with other Bluetooth LE devices through
    broadcasting or an established connection. Each of these methods have their own
    advantages and disadvantages. We will begin by looking at the network topology
    when the devices communicate by broadcasting. For the projects in this chapter,
    we will focus on exchanging data over established connections, but it is good
    to have a knowledge of how data can be exchanged by broadcasting. Therefore, we
    will cover it in this introduction section.
  prefs: []
  type: TYPE_NORMAL
- en: Bluetooth LE broadcasting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following diagram shows the network topology for a broadcast network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2d70c18-31f7-4ee3-81a6-61f5c89613ad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are two roles defined when broadcasting:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Broadcaster**: This device sends non-connectable advertising packets at set
    time intervals to any other device that is listening'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Observer**: This device scans the advertising frequencies to receive the
    non-connectable advertising packets that the broadcaster is sending out'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Broadcasting data is the only way that a device can send data to multiple devices.
    The standard broadcasting packet can have a payload of 31 bytes of data, which
    is usually used to describe the broadcaster and its capabilities. However, it
    can also include any custom information that we wish to broadcast to other devices.
    Bluetooth LE also supports an optional second advertising payload called the **scan
    response**, which can include an additional 31 bytes of data.
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting is fast and easy if we wish to transmit small amounts of data to
    multiple devices; however, there is no security or privacy on the data. The security
    is usually the biggest reason to avoid using broadcast packets. However, another
    big reason to avoid using broadcast packets is the observer does not have the
    ability to send any data back to the broadcaster.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at Bluetooth LE connections
  prefs: []
  type: TYPE_NORMAL
- en: Bluetooth LE connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following diagram shows how Bluetooth connections work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6af8d1f-587e-4b46-acd1-fdee12f701af.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As with the Bluetooth LE broadcasting topology, the connection topology also
    defines two roles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Central**: The central is usually a device such as, a laptop, tablet or phone.
    These devices will scan the advertising channels and listen for connectable advertising
    packets. When a device is found, the central may attempt to establish a connection
    to the device. After the connection is established the central manages the timing
    and initiates the data exchanges. The central device can connect to more than
    one peripheral.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Peripheral**: The peripheral is usually a device such as a smartwatch, a
    weather station or medical device. These devices send out periodic connectable
    advertising packets and accept incoming connections. Once a connection is established,
    the peripheral will generally follow the central''s timing and exchange data when
    the central requests it. A peripheral can connect to only one central device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A peripheral will generally advertise until a central device discovers it and
    requests a connection. Once the connection is established, the peripheral will
    stop advertising and then the two devices can exchange data. The data exchange
    in this topology can go both ways, where the peripheral and central can both send
    and receive data.
  prefs: []
  type: TYPE_NORMAL
- en: When a central and a peripheral establish a connection, the data that is transmitted
    and received is organized in units called **services and characteristics**. We
    will look at this more when we look at the **Generic Attribute Profile** (**GATT**)
    a little later in this chapter. The thing to understand now is that a Bluetooth
    LE peripheral can have multiple characteristics, which are used to send and receive
    data. These characteristics are organized or grouped into services.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest advantage with establishing a Bluetooth LE connection is you can
    have multiple characteristics to organize your data, and each of these characteristics
    may have their own access rights and descriptive metadata. Another advantage is
    the ability to establish secure encrypted connections.
  prefs: []
  type: TYPE_NORMAL
- en: With Bluetooth 4.0, a device can act as a central or a peripheral but not both.
    Starting with Bluetooth 4.1, this restriction was removed and with newer versions
    of Bluetooth LE, a device can act as a peripheral, a central or both.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at the Bluetooth LE profiles.
  prefs: []
  type: TYPE_NORMAL
- en: Bluetooth LE profiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bluetooth LE defines two types of profiles. These are profiles that define the
    basic mode of operations required by all Bluetooth LE devices to ensure interoperability
    (Generic Access Profile and GATT) or profiles that are used for specific use cases
    (health device profile and proximity profile). In this chapter, we will not go
    into the specific use cases of these profiles; however, we do want to look at
    both the **Generic Access Profile** (**GAP**) and the Generic Attribute Profile
    (GATT). We will start off by looking at the GAP.
  prefs: []
  type: TYPE_NORMAL
- en: Generic access profile (GAP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GAPÂ defines how devices interact with each other to ensure device interoperability.
    It defines how Bluetooth LE devices discover each other, establish secure connections,
    terminate connections, broadcast data and device configuration. This is the lowest
    level of the Bluetooth LE stack that we will cover in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we saw that a Bluetooth LE device could be in one
    of two states. In the broadcasting topology, a device can be either the broadcaster
    (slave) or observer (master). If a connection between the two devices is established,
    then the devices become either a central (master) or peripheral (slave). We introduced
    the terms master and slave here to illustrate the states that the devices can
    be in. The following diagram shows the different states:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8b6d92a-69ad-48d0-9c56-fe1e34bb3b89.png)'
  prefs: []
  type: TYPE_IMG
- en: Both types of devices start in an idle or standby state. This is the initial
    state when the device is reset. A slave device will then become an advertiser,
    where it is advertising specific data, letting any master device know that it
    is a connectable device and what services it offers. After the idle state, a master
    device will begin scanning for slaves that are advertising. When a master receives
    an advertisement, it will send a scan request to the advertiser, and the slave
    will respond back with a scan response. This is the device discovery process.
  prefs: []
  type: TYPE_NORMAL
- en: After the device discovery process, if the master wishes to connect to the advertising
    device, it will initiate a connection. When initiating the connection, the master
    will specify the connection parameters. Once the connection is made the devices
    will assume their roles as master and slave. With Bluetooth LE 4.0, the slave
    device can have only one master. Also, with Bluetooth LE 4.0, the devices can
    act as either a master or a slave but not both. With later revisions of the Bluetooth
    specifications, these limitations have been removed. I know we have mentioned
    that a couple of times so far in this book, but it is important to keep in mind
    when developing your devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'We mentioned that the master specifies the number of connection parameters
    when initiating the connection. Some of these parameters are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connection Interval**: With Bluetooth LE uses a frequency hopping scheme
    the two devices that are communicating most know which channel to transmit/receive
    on, when to switch channels and when to make the connection. The time interval
    between the connection attempts is known as the connection interval.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Slave Latency**: The slave latency gives the slave device the option to skip
    a certain number of connection events. The slave device must not skip more than
    the number of connection events defined by this parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supervision Time-out**: The supervision time-out is the maximum amount of
    time between two successful connection events. If this time is exceeded, the device
    will terminate the connection, and the slave device will go back to an unconnected
    state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a number of considerations when deciding what to set these parameters
    to. The main consideration is power consumption and data throughput. As the throughput
    increases, the device will use more power. For example, if we lower the connection
    interval, thereby increasing the number of connection attempts per second, the
    power consumption of the device will increase because the radio will be on more
    of the time. By reducing the slave latency, once again the radio will be on more.
    Therefore, it will also increase the power consumption. When working with a Bluetooth
    LE radio, you need to balance the power consumption with the data throughput needs
    for your project. There is no magic ratio that will work for all types of devices;
    it is something you will need to look at on a project-by-project basis.
  prefs: []
  type: TYPE_NORMAL
- en: In the example projects for this chapter, we will show how to AT commands to
    adjust the various settings for the Bluetooth LE module. Now let's look at the
    GATT profile.
  prefs: []
  type: TYPE_NORMAL
- en: Generic attribute (GATT) profile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the GAP profile defines the low-level (advertising and connection) interactions
    of Bluetooth LE devices, the GATT profile defines the details on how the devices
    exchange data. The GATT is also the reference framework for all attribute-based
    profiles that define specific use cases, such as heart rate and blood pressure
    profiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the GAP profile, the GATT profile defines two roles. These roles are
    the client and the server. When you look at the diagram on how this works, the
    roles may seem a little odd at first; however, once we see how Bluetooth LE devices
    exchange data it will make more sense. The client role in the GATT profile corresponds
    to the master role in the GAP profile and the server role in the GATT profile
    corresponds to the slave role. The following diagram illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2a0966f-94dd-45a6-8571-63a78db5595c.png)'
  prefs: []
  type: TYPE_IMG
- en: In this diagram, we can see that one client can have multiple servers; however,
    each server can have only one client. In the GATT profile, the client (central
    role in the GAP) requests information from the server (peripheral in the GAP).
    While we are showing the relationship between the GATT and GAP roles, it is worth
    noting that the GATT and GAP roles are actually independent of each other, and
    in later versions of the Bluetooth LE specifications, a device can act as both
    a central and a peripheral.
  prefs: []
  type: TYPE_NORMAL
- en: The smallest data entity defined by the GATT profile is the attribute. An attribute
    is an addressable piece of information that is located on the server,Â which can
    be accessed and potentially modified by the client. Each attribute is uniquely
    identified by a **UUID** (**universally unique identifier**), which can be either
    a 16-bit or 128-bit number. This identifier is known as the handle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GATT profile defines a set of permissions that are associated with all
    attributes. Permissions specify which operations can be performed on each attribute.
    These permissions are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Access Permissions**: Access permissions specify which actions can be performed
    on the attribute. Each attribute will have one of the following permissions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**None**: The attribute cannot be read or written by the client'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Readable**: The attribute can be read by the client'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Writable**: The attribute can be written to by the client'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Readable and Writable**: The attribute can be read and written to by the
    client'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encryption**: Encryption permission determines the level of encryption that
    is required for a client to access the attribute'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No Encryption** (Security Mode 1, Level 1): No encryption is required'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unauthenticated Encryption** (Security Mode 1, Level 2): The connection must
    be encrypted; however, the encryption keys do not need to be authenticated'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authenticated Encryption** (Security Mode 2, Level 2): The connection must
    be encrypted, and the encryption keys must be authenticated'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization**: Authorization permission determines whether the user needs
    to be authorized to access the attribute'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No Authorization**: No authorization is required to access the attribute'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization Required**: Authorization is required to access the attribute'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The GATT defines a strict hierarchy, which organizes the attributes. The attributes
    are grouped into services, where each service may contain zero or more characteristics.
    These characteristics can include zero or more descriptors. Services, characteristics
    and descriptors are all attributes within the GATT server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b365ec6-1983-4b72-bce7-1e23f75ffc3b.png)'
  prefs: []
  type: TYPE_IMG
- en: Services are used to group related attributes into a common entity. Each service
    is identified by a unique UUID, which can be either 16-bit for officially adopted
    service types or 128-bit for custom service types.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see a list of officially adopted services on the Bluetooth SIG site
    here: [https://www.bluetooth.com/api/silentlogin/login?return=http%3a%2f%2fwww.bluetooth.com%2fspecifications%2fgatt%2fservices](https://www.bluetooth.com/api/silentlogin/login?return=http%3a%2f%2fwww.bluetooth.com%2fspecifications%2fgatt%2fservices).'
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the Heart Rate service, you can see that this service contains
    three characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: Characteristics are containers for the data, where each characteristic encapsulates
    a single data point. As with the services, a characteristic is identified by either
    a 16-bit or 128-bit UUID. Characteristics are the main entry point that a Bluetooth
    LE client interacts with a server.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find a list of officially adopted characteristics on the Bluetooth
    SIG site here: [https://www.bluetooth.com/specifications/gatt/characteristics](https://www.bluetooth.com/specifications/gatt/characteristics).'
  prefs: []
  type: TYPE_NORMAL
- en: Access permissions for each characteristic should be either read-only or write-only.
    It is very rare to have a characteristic that has both read and write permission.
    As an example, if we wanted to create a simple serial interface for our Bluetooth
    LE device, we would create a TX characteristic to transmit data with read-only
    permission for the client and an RX characteristic to receive data with write-only
    permission for the client. We would not want to create a single characteristic
    that had both read and write permission because as the client writes data to it,
    the server could overwrite it.
  prefs: []
  type: TYPE_NORMAL
- en: The descriptors are used to provide the client devices with additional information
    about the characteristics and their values.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find a list of officially adopted descriptors on the Bluetooth SIG
    site here: [https://www.bluetooth.com/specifications/gatt/descriptors](https://www.bluetooth.com/specifications/gatt/descriptors).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, the server simply responds to a client''s request for data from
    a characteristic; however, it is possible for a server to initiate the communication
    by using server-initiated updates. There are two types of server initiated updates,
    which are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Notification**: Characteristic value change notifications are used when the
    server is configured to notify the client that the value of the characteristic
    has changed but does not expect the client to acknowledge the notification. Notification
    is turned on for all projects in this chapter; however, it is only used in the
    first and third projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Indication**: Characteristic value change indications are used when the server
    is configured to indicate to the client that the value of the characteristic has
    changed and expects the client to acknowledge that it has received the indication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a very basic understanding of Bluetooth LE and how it works,
    let's look at the HM-10 Bluetooth module that we will be using in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: HM-10 Bluetooth module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HM-10 is a Bluetooth 4.0 module that is based on the TI CC2530 or CC2541
    Bluetooth **SOC** (**System-on-Chip**). The HM-10 is a very popular Bluetooth
    4 module for the Arduino, mostly due to its cheap cost and ease of use. The HM-10
    provides a standard serial connection to the Bluetooth layer. This allows for
    a very straightforward interface; however, it does hide the actual Bluetooth LE
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 21](7abdb5af-1851-4623-b6a9-996fc6b69694.xhtml), *Bluetooth Classic*,
    when we look at the HC-05 Bluetooth module, you will notice that the interface
    between the HC-05 and HM-10 use the same serial interface; however, understanding
    the difference between Bluetooth LE and Bluetooth Classic technologies will help
    you decide which to use in your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can control the module using AT commands, and we will look at how to do
    that in the project section of this chapter. The following photograph shows what
    the HM-10 Bluetooth module looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25551851-e2eb-476c-b508-0b0296e5ac31.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The HM-10 has six pins. However, we are only interested in the middle four,
    which are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**VCC**: Connected to the 3.3V power out on the Arduino'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GND**: Connected to the ground on the Arduino'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TX**: Transmit pin, connected to one of the digital pins on the Arduino'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RX**: Receive pin, connected to one of the digital pins on the Arduino'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let's look at all of the components that we will need for the projects that
    we will be doing in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Components needed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For these, projects you will need the following items:'
  prefs: []
  type: TYPE_NORMAL
- en: One Arduino Uno or compatible board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One HM-10 Bluetooth 4.0 module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One DHT-11 temperature sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One 4.7K resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One 3.3K resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One 1.1K resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One 330k resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will need a Bluetooth LE app for your phone/tablet or computer. I use the
    *BTCommander â Serial port HM10* ([https://itunes.apple.com/us/app/btcommander-serial-port-hm10/id1312640906?mt=8](https://itunes.apple.com/us/app/btcommander-serial-port-hm10/id1312640906?mt=8))
    app on my phone. There are plenty of other apps, such as the *nRF connect* app
    for Android ([https://play.google.com/store/apps/details?id=no.nordicsemi.android.mcp&hl=en_US](https://play.google.com/store/apps/details?id=no.nordicsemi.android.mcp&hl=en_US))
    and iOS ([https://itunes.apple.com/us/app/nrf-connect/id1054362403?mt=8](https://itunes.apple.com/us/app/nrf-connect/id1054362403?mt=8)).
  prefs: []
  type: TYPE_NORMAL
- en: Circuit diagrams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will be doing three projects. The first project will be
    a simple serial communication project that will send a text to and from the Arduino
    through the Bluetooth radio. We will also show how to configure the Bluetooth
    radio in the first project. For the second project, we will show how to toggle
    a LED on and off remotely. For the final project, we will build a mini weather
    station, which will enable us to read the temperature remotely through the Bluetooth
    radio. Each project will have its own wiring diagram included with it; however,
    if you wish to connect all of the hardware at once, the following diagram shows
    how everything is connected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/efc48632-99e5-4183-aded-76be6a036f9f.png)'
  prefs: []
  type: TYPE_IMG
- en: This diagram may initially look complex compared to earlier diagrams; however,
    if we break it down into three parts, it really is not that complex. The first
    part is the DHT-11 temperature sensor, which is located on the right-hand side
    of the breadboard. The second part is the LED, which is in the center of the breadboard.
    The third and final part is the HM-10 Bluetooth module, which is located on the
    left-hand side of the breadboard.
  prefs: []
  type: TYPE_NORMAL
- en: We have already covered wiring the DHT-11 temperature sensor in [Chapter 9](4334ea1c-5df5-4be7-a7c1-86592cb3aaa6.xhtml),
    *Environment Sensors*, and the LED in [Chapter 4](f0039485-e47c-40c8-9130-fba1e1afd421.xhtml),
    *BasicÂ Prototyping*. Therefore, we will repeat the explanation here.
  prefs: []
  type: TYPE_NORMAL
- en: To connect the HM-10 Bluetooth module to the Arduino, the **VCC** pin is connected
    to the power rail on the breadboard, which is connected to the 5V power out on
    the Arduino. The **GND** pin on the Bluetooth module is connected to the ground
    rail on the breadboard, which is connected to the ground pin on the Arduino. The
    **RX** pin on the Bluetooth module is connected directly to the digital **pin
    10** on the Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the **TX** pin on the Bluetooth module to the Arduino is a little
    different. For this, we want to ensure that the voltage does not exceed 3.3V.
    Therefore, we use a simple voltage divider. A voltage divider is a simple circuit
    that will turn a larger voltage into a smaller one. For this, we use two resistors,
    a 1.1K and a 3.3K. These two resistors are connected in series, where one end
    of the 3.3K resistor is connected to ground, and one end of the 1.1K resistor
    is connected to digital **pin 11** on the Arduino. The **TX** pin is connected
    between the two resistors.
  prefs: []
  type: TYPE_NORMAL
- en: Project 1Â â serial communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this first project, we are only going to use the HM-10 Bluetooth module
    and the Arduino. You will need to connect the Bluetooth module to the Arduino
    as shown in the previous circuit diagram. The following diagram shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21db66c9-e40a-4f30-9da4-44189de605a8.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we need to write the code to access the Bluetooth module. We will be using
    the `SoftwareSerial` library to interface with the HM-10 Bluetooth LE module.
    This library was developed to allow serial communication on digital pins other
    than pins 0 and 1\. There may be limitations to this library if you are using
    a board other than the Uno. You can reference the documentation ([https://www.arduino.cc/en/Reference/softwareSerial](https://www.arduino.cc/en/Reference/softwareSerial))
    to see if your board has any limitations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code will need to start off by including the `SoftwareSerial` header file
    and then initiate an instance of the `SoftwareSerial` type. We also want to add
    a new line whenever a new command is issued from the serial monitor. Therefore,
    we will also define a Boolean variable that will be set to true whenever a new
    command comes in (this will make it easier to read the responses within the serial
    monitor). The following code will do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When creating the instance of the `SoftwareSerial` type, you need to define
    what pins to use for receiving (**RX**) and transmitting (**TX**) data. The first
    value is the `RX` pin and the second value is the `TX` pin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to initialize both the serial monitor and the `SoftwareSerial`
    instance. We will do that within the `setup()` function. We also want to let the
    user know when the application is ready to accept commands or connections. The
    following code shows the code for the `setup()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When we initiate the serial monitor and the `SoftwareSerial` interface, we need
    to define what the baud rate will be. Both the HM-10 Bluetooth module and the
    serial monitor communicate at a baud rate of 9600\. Once everything is initiated,
    a message is displayed to the serial monitor letting the user know that everything
    is good to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `loop()` function, we will need to write anything that the user types
    into the serial monitor to the Bluetooth module and write anything that comes
    in from the Bluetooth module to the serial monitor. The following code shows the
    `loop()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this function, we use the `available()` function on both the serial monitor
    and the instance of the `SoftwareSerial` type to check whether either device has
    data to read. If so, we read the data and write it to the other device. In the
    section that reads the serial monitor and writes to the `SoftwareSerial` instance,
    we set the `addNewLine` Boolean variable to true so the next time we write to
    the serial monitor, we will write a carriage return and new line. In the section
    that reads from the Bluetooth module and writes to the serial monitor, we check
    to see whether the `addNewLine` Boolean variable is `true`, and if so, we write
    a carriage return and new line to the serial monitor before setting the `addNewLine`
    variable to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways that we can use this application. The first is to enter **AT**
    (**ATtention**) commands into the serial monitor, which enables you to get/set
    configuration settings on the Bluetooth module and also control the module. The
    second is to use the Bluetooth LE app on your phone to read and write values to
    the Bluetooth modules. Let's look at the AT commands first.
  prefs: []
  type: TYPE_NORMAL
- en: 'To send an AT command to the Bluetooth LE module, run the preceding code blocks
    and then open the serial monitor, which is part of the Arduino IDE. Once everything
    is initiated, you will see the `Connected to HM-10\. Try connecting from any device
    or issue AT commands`Â message displayed in the monitor. This indicates that the
    module is ready, and everything is initiated. Once you see the message, type `at`
    in the input box and either click the Send button or hit *Enter*. You should see
    an `OK` response from the Bluetooth module. The output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8712490a-c504-4717-807f-d2a8d13e8dd2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To send an AT command, you would use the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To set an item, you type in the letters `AT` followed by the plus sign (`+`),
    the command and the new setting without any spaces. For example, to set the name
    that the Bluetooth module will advertise to "Buddy," we would issue the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Note**: AT commands are case insensitive.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To query the item, we would type in the letters `AT` followed by the plus sign
    (`+`), the command and then a question mark (`?`). For example, to query the name
    that the Bluetooth module is advertising, we would use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the application that we just wrote to set the configuration manually
    from the serial monitor or we can set the configurations from within the application
    by using the `print()` function from the `SoftwareSerial` library like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at some of the commonly used commands. Any of these can be used from
    the serial monitor or within the code as we just showed.
  prefs: []
  type: TYPE_NORMAL
- en: Test command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT` | OK | None | This is a test command that can be used to test theconnection
    to the Bluetooth module. |'
  prefs: []
  type: TYPE_TB
- en: Query software version
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+VERR` | Version number | None | This command will return the versionnumber
    of the firmware for the module. |'
  prefs: []
  type: TYPE_TB
- en: Restore factory default
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+RENEW` | `OK+RENEW` | None | Restore the factory defaults. |'
  prefs: []
  type: TYPE_TB
- en: Restart module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+RESET` | `OK+RESET` | None | Restarts Bluetooth module. |'
  prefs: []
  type: TYPE_TB
- en: Query MAC (Media Access Control) address
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+ADDR?` | `OK+ADDR:{MAC Address}` | None | This command can be used to
    query theMAC address of the Bluetooth radio. |'
  prefs: []
  type: TYPE_TB
- en: Set name
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+NAME{parameter}` | `OK+set{parameter}` | None | This command will set
    the name for the module. |'
  prefs: []
  type: TYPE_TB
- en: Query name
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+NAME?` | `OK+NAME{parameter}` | None | This command will return the name
    of the module. |'
  prefs: []
  type: TYPE_TB
- en: Set the advertising interval
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+ADVI{parameter}` | `OK+Set:{parameter}` | `0`: 100ms`1`: 152.5 ms`2`:
    211.25 ms`3`: 318.75 ms`4`: 417.5 ms`5`: 546.25 ms`6`: 760 ms`7`: 852.5 ms`8`:
    1022.5 ms`9`: 1285 ms`A`: 2000 ms`B`: 3000 ms`C`: 4000 ms`D`: 5000 ms`E`: 6000
    ms`F`: 7000 ms | This command will set the advertising intervalfor the Bluetooth
    LE module. The parametershould be 0-F. |'
  prefs: []
  type: TYPE_TB
- en: Query the advertising interval
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+ADVI?` | `OK+get:{parameter}` | None | This command will retrieve the
    current advertisinginterval and will return a parameter of 0-f. |'
  prefs: []
  type: TYPE_TB
- en: Set advertising type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+ADTY{parameter}` | `OK+set:{parameter}` | `0`: Advertising Scan Response,
    Connectable`1`: Only allow the last device connect in 1.28 seconds`2`: Only allow
    Advertising and Scan Response`3`: Only allow Advertising | This command will set
    the'
  prefs: []
  type: TYPE_NORMAL
- en: advertising type. |
  prefs: []
  type: TYPE_NORMAL
- en: Query advertising type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+ADTY?` | `OK+get:{parameter}` | None | This command will retrieve the
    current advertisingtype and will return a parameter of 0-3. |'
  prefs: []
  type: TYPE_TB
- en: Set baud rate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+BAUD{parameter}` | `OK+set:{parameter}` | `0`: 9600`1`: 19200`2`: 38400`3`:
    57600`4`: 115200`5`: 4800`6`: 2400`7`: 1200`8`: 230400 | This command will set
    the baud rate for the serialinterface of the Bluetooth module. |'
  prefs: []
  type: TYPE_TB
- en: Query baud rate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+BAUD?` | `OK+get:{parameter}` | None | This command will retrieve the
    current baud rate andwill return a parameter of 0-8. |'
  prefs: []
  type: TYPE_TB
- en: Set characteristic id
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+CHAR{parameter}` | `OK+set:{parameter}` | `0x0001` -> `0xFFFe` | This
    command will set the ID for thecharacteristic. |'
  prefs: []
  type: TYPE_TB
- en: Set service id
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+UUID{parameter}` | `OK+set:{parameter}` | `0x0001` -> `0xFFFe` | This
    command will set the ID for the service. |'
  prefs: []
  type: TYPE_TB
- en: Query service id
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+UUID?` | `OK+get:{parameter}` | None | This command will retrieve the
    current service ID. |'
  prefs: []
  type: TYPE_TB
- en: Set role
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+ROLE{parameter}` | `OK+set:{parameter}` | `0`: Peripheral`1`: Central
    | This command will set the role of the Bluetooth module. |'
  prefs: []
  type: TYPE_TB
- en: Query role
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+ROLE?` | `OK+get:{parameter}` | None | This command will return the role
    of the Bluetoothmodule. |'
  prefs: []
  type: TYPE_TB
- en: Clear last connected device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+CLEAR` | `OK+CLEAR` | None | Clears the address of the last connected
    device. |'
  prefs: []
  type: TYPE_TB
- en: '**NOTE**:Â The `at+clear` command is only used when the device is in central
    mode.'
  prefs: []
  type: TYPE_NORMAL
- en: Try to connect to last connected device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+CONNL` | `OK+CONN{parameter}` | `L`: Connecting`E`: Connect Error`F`:
    Connect Fail`N`: No Address | This command will attempt to connect to the devicethat
    last successfully connected to it. |'
  prefs: []
  type: TYPE_TB
- en: '**NOTE**:Â The `at+connl` command is only used when the device is in central
    mode.'
  prefs: []
  type: TYPE_NORMAL
- en: Try to connect to an address
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+CON{parameter}` | `OK+CONN{parameter}` | `A`: Connecting`E`: Connect
    Error`F`: Connect Fail | This command will attempt to connect to a devicewith
    the specified address. |'
  prefs: []
  type: TYPE_TB
- en: '**NOTE**:Â The `at+con` command is only used when the device is in central mode.'
  prefs: []
  type: TYPE_NORMAL
- en: Set pin code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+PASS{parameter}` | `OK+set:{parameter}` | `000000` -> `999999` | Sets
    the pin code for connection. |'
  prefs: []
  type: TYPE_TB
- en: Query pin code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+PASS?` | `OK+get:{parameter}` | None | This command will return the current
    pin code. |'
  prefs: []
  type: TYPE_TB
- en: Set module power
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+POWE{parameter}` | `OK+set:{parameter}` | `0`: -23db`1`: -6db`2`: 0db`3`:
    6db | Sets the power for the module. |'
  prefs: []
  type: TYPE_TB
- en: Query module power
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+POWE?` | `OK+get:{parameter}` | None | This command will return the current
    module power. |'
  prefs: []
  type: TYPE_TB
- en: Set bond mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+TYPE{parameter}` | `OK+set:{parameter}` | `0`: PIN code not needed`1`:
    Auth without PIN code`2`: Auth and PIN`3`: Auth and bond | This command sets the
    authentication neededwhen connecting to this device. |'
  prefs: []
  type: TYPE_TB
- en: Query bond mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+TYPE?` | `OK+get:{parameter}` | None | This command will return the current
    authenticationneeded to connect to this device. |'
  prefs: []
  type: TYPE_TB
- en: Set notify information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+NOTI{parameter}` | `OK+set:{parameter}` | `0`: Don''t Notify`1`: Notify
    | This command enables or disables the notificationwhen a device connects are
    disconnects. |'
  prefs: []
  type: TYPE_TB
- en: Query notify information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| **Command** | **Response** | **Parameters** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `AT+NOTI?` | `OK+get:{parameter}` | None | This command will return if the
    device will send anotification when a device connects or disconnects. |'
  prefs: []
  type: TYPE_TB
- en: We can only issue AT commands to the Bluetooth module when another device is
    not connected to it. Once a device is connected to the application code that we
    wrote takes over, and the data that is typed into the serial console is sent to
    the connected device. Let's see what happens when we connect to the Bluetooth
    module from another device. I will be using the *BTCommander â Serial Port HM10*
    app to show how this works.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the application running on the Arduino, start up the Bluetooth application
    on your phone/tablet or computer. The *BTCommander* app will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06a970b0-493e-4f7f-90ac-eb58809a24df.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To connect to a device, press the blue connection button, which looks like
    an outlet plug, located at the upper right side of the application. Once you press
    the button, you should see a list of devices that the application can connect
    to. This screen looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c2f0fc2a-0414-42cb-8461-e5584fab6a62.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This screen shows all devices that are advertising and are close enough to
    connect. Earlier in this chapter, when we ran the `AT+nameBuddy` command, we renamed
    our device to `Buddy`. Therefore, we know that is the device that we want to connect
    to. If we tap that device and then tap on the Connect button at the upper right
    side of the application, the application will attempt to connect. If the connection
    attempt is successful and the `AT+NOTI` setting on the Bluetooth module has the
    notifications enabled, we should see `OK+CONN` on the serial console as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d17d039f-2ac0-4a3c-a5c5-81b59055c6be.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the connection is successful, the application will go back to the main
    screen. Now let''s type a message in the input box at the bottom of the screen.
    For example, here we will type a simple `hello` message as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/684f46ed-eb2b-41f8-8e81-9cd6f13490b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the message is entered, press the button next to the input box that looks
    like a paper airplane to send the message. If the message was successfully sent,
    we will see it in the serial console as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ecb0e61e-18bf-4aa0-846e-c8dabdddb33a.png)'
  prefs: []
  type: TYPE_IMG
- en: What is happening here is the message that is entered in the application is
    being passed from the phone application to the chrematistic on the HM-10 Bluetooth
    module, so our application can read it. The message is sent one character at a
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To send a message back, type the message in the input box of the serial console
    and press the send button. If the message was sent successfully, we should see
    it in the application as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8511eb14-e1d8-44f2-8055-9e28f76788f5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this screenshot, we can see that the `hello` message was sent from the application
    and the `Hello from Arduino` was received from the connected device. When a message
    is sent from the HM-10 Bluetooth module back to the phone application, the application
    writes the message to the characteristic (one character at a time) and the Bluetooth
    module uses a notification to notify the client (the phone application) that there
    is new data.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we press the connection button again in the *BTCommander* application to
    disconnect, and the `AT+NOTI` configuration is set to notify, we will see anÂ `OK+LOST`
    message in the serial console as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3908f18b-285c-47dc-962f-b2d72076f22a.png)'
  prefs: []
  type: TYPE_IMG
- en: Now let's see how we can use the Bluetooth module to control an LED from our
    phone.
  prefs: []
  type: TYPE_NORMAL
- en: Project 2Â â controlling LED
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this project, we will turn an LED that is connected to the Arduino on or
    off depending on the input from the phone. The first thing we will need to do
    is to add the LED to our circuit. The following diagram shows the new circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3379c415-722f-4de3-b44a-0e0a287bff3c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The LED is connected to the digital 5 pin on the Arduino through a 330-ohm
    resistor. Now we need to write the code to control the LED. We will start by setting
    up the `SoftwareSerial` library for the Bluetooth module and defining the pin
    that the LED is connected to. The following code will do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the Bluetooth module is connected to the same pins as the previous
    example, and the LED is connected to digital pin 5 on the Arduino. In the `setup()`
    function, we will need to configure the `SoftwareSerial` instance and the mode
    of the pin that the LED is connected to. The following code shows the `setup()`
    function for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This code starts off by defining the mode of the pin that the LED is connected
    to. It then configures the serial port for the serial monitor and the `SoftweareSerial`
    instance. We finally print a message to the serial console letting the user know
    that everything is configured and ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `loop()` function, we will need to check the `SoftwareSerial` instance,
    and if a `1` is received from the connected device, it will turn the LED on, and
    if a `0` is received, it will turn the LED off. If neither a `1` or a `0` is received,
    then it will ignore the input. Here is the code for the `loop()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we check to see whether a value is available from the Bluetooth
    module, and if so, we read the device to get the character that was received.
    If the character is equal to `1` (the character 1 and not the number 1), we pull
    the pin that the LED is connected to `HIGH` to turn the LED on. If the character
    is equal to `0` (the character 0 and not the number 0), we pull the pin that the
    LED is connected to `LOW` to turn the LED off.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's run this application and use the *BTCommander* application to connect
    to it. From the *BTCommander* application, if we send a `1`, the LED will light
    up, or if we send a `0`, the LED will go off. This type of example can be used
    when we wish to have a phone application to control something that is connected
    to the Arduino such as an LED, DC Motor or some sensor.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's see how we can retrieve temperature and humidity data from the DHT-11
    sensor via Bluetooth LE.
  prefs: []
  type: TYPE_NORMAL
- en: Project 3Â â environmental sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this project, we will request, from the phone, that the Arduino send temperature
    or humidity information depending on the character sent. We will need to add the
    DHT-11 sensor to our circuit. The following diagram shows how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f841810b-72b2-45c7-a6d1-8c9a758b929b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The DHT-11 temperature sensor is connected to the Arduino exactly as we did
    in [Chapter 9](03634c50-cc88-4b10-8a3a-4054b67f0691.xhtml), *Environment Sensors*.
    If you are unsure how to connect this sensor to the Arduino, please refer back
    to that chapter. Now we will need to write the code, so we can access the data
    from the sensor with Bluetooth LE service. We will start by setting up the `SoftwareSerial`
    library for the Bluetooth module and the DHT-11 temperature sensor. The following
    code will do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This code includes the libraries for the DHT temperature sensor and also the
    `SoftwareSerial` device. It then defines the pin that the temperature sensor is
    connected to and the type of sensor. Finally, it creates instances of the `DHT`
    and the `SoftwareSerial` types.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `setup()` function, we will need to configure the `SoftwareSerial` instance
    and the mode of the pin that the LED is connected to. The following code shows
    the `setup()` function for our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This function configures the `SoftwareSerial` instance and prints a message
    to the serial console when everything is initiated and ready to go. In the `loop()`
    function, we will want to read the input from the device that is connected to
    the service and then respond back with the appropriate information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following chart shows the input and what should be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Input** | **Property Returned** |'
  prefs: []
  type: TYPE_TB
- en: '| `f` | Temperature in Fahrenheit |'
  prefs: []
  type: TYPE_TB
- en: '| `c` | Temperature in Celsius |'
  prefs: []
  type: TYPE_TB
- en: '| `h` | Humidity |'
  prefs: []
  type: TYPE_TB
- en: '| `F` | Heat Index Fahrenheit |'
  prefs: []
  type: TYPE_TB
- en: '| `C` | Heat Index in Celsius |'
  prefs: []
  type: TYPE_TB
- en: 'From the chart, we can see that we will have five inputs and each one will
    return different information back to the remote device. Let''s look at the code
    that will read the input and return the information requested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This code starts by checking the Bluetooth adapter to see whether there is any
    input available, and if so, it reads the character. If the input character is
    one of the characters listed in the previous chart, the code retrieves the appropriate
    value from the DHT-11 sensor and returns the value back to the connected device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from the code in the *BTCommander* iOS app would look similar to
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/547ecbdc-4537-47ac-97d8-85f51efd77da.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Everything we have shown here is compatible with Bluetooth LE 4.0 and above.
    As of the time of writing this book, there really are not that many low-cost Bluetooth
    LE modules for the Arduino that are compatible with the new Bluetooth LE 4.2 and
    5.0 standards, which is why we stuck with 4.0 here. The good news is all of the
    newer standards are backward compatible with the 4.0 standard, so everything we
    talked about in this chapter will work as newer Bluetooth modules are released
    that are compatible with the newer standards. Let's look at what features are
    available with the newer Bluetooth standards.
  prefs: []
  type: TYPE_NORMAL
- en: What is new with Bluetooth 4.1, 4.2 and 5.0?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at what is new with Bluetooth 4.1, 4.2, and 5.0\.
    While these features are not compatible with the Bluetooth LE 4.0 module that
    we used in this chapter, eventually Bluetooth modules for the Arduino that are
    compatible with these standards will be released; therefore, it is good to know
    what features they offer.
  prefs: []
  type: TYPE_NORMAL
- en: Bluetooth 4.1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bluetooth 4.1 mainly offers usability updates. One of the most important updates
    is to allow Bluetooth LE and LTE radios to coexist better. This update allows
    the radios to coordinate transmissions to decrease the chance of interference.
    It also makes the data transfer more efficient and allows for better reconnections
    after connection loss.
  prefs: []
  type: TYPE_NORMAL
- en: The big non-usability change with Bluetooth 4.1 allowed a device to be both
    a peripheral and a central at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Bluetooth 4.2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bluetooth 4.2 offered numerous new features for IoT, security, faster speed
    and more capacity.
  prefs: []
  type: TYPE_NORMAL
- en: For IoT, Bluetooth 4.2 added **Bluetooth Smart Internet gateways**, which enables
    Bluetooth 4.2 devices a bridge to the internet. With the internet gateways, Bluetooth
    4.2 also added IPv6/6LoWPAN, which enables IPv6 support over a Bluetooth connection.
  prefs: []
  type: TYPE_NORMAL
- en: Bluetooth 4.2 also added extra security with LE Privacy 1.2\. The encryption
    standards with Bluetooth 4.2 comply with the **Federal Information Processing
    Standards** (**FIPS**), which is a US Government computer security standard.
  prefs: []
  type: TYPE_NORMAL
- en: The transmission packet size was increased by ten times as well. This allows
    for faster and more reliable data transmissions.
  prefs: []
  type: TYPE_NORMAL
- en: Bluetooth 5.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bluetooth offers a number of enhancements,quadrupling the range and doubling
    the speed. The catch with this is that if a device manufacturer increases the
    range of their device, the speed will go down; and likewise, if the speed increases,
    the range will go down.
  prefs: []
  type: TYPE_NORMAL
- en: Bluetooth mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the latest, and in my opinion, the most exciting, Bluetooth technologies
    is Bluetooth mesh. All previous Bluetooth technologies relied on a one-to-one
    or a one-to-many connection where there was always one master/central device.
    Mesh technology allows Bluetooth devices to establish many-to-many connections,
    which enables large-scale device networks that do not rely on a central controller.
    The Bluetooth mesh technology is still in its infancy at the time we are writing
    this book. However, I believe it is the future of Bluetooth and is a technology
    worth keeping an eye on.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note with Bluetooth standards higher than 4.0 is most of the new
    features are optional and not required to be fully implemented. For example, a
    manufacturer may say that their device meets the Bluetooth 4.2 standard. However,
    IPv6/6LoWPAN may not be implemented in the device. A good example of this is the
    iPhone. My iPhone X is Bluetooth 5.0 compatible; however, it is not capable of
    running Bluetooth mesh or IPv6/6LoWPAN.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the challenge, take the Nokia 5110 LCD display that we used in [Chapter
    13](5daf3c48-d927-436f-81ec-0b04d23d764f.xhtml), *Using LCD Displays*, and the
    serial communication code that we used in the first project of this chapter and
    print any message sent from the phone app to the LCD display. This will require
    some modification to the code in this chapter to use the LCD screen rather than
    the serial console.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned a lot about Bluetooth LE, starting with a brief
    introduction on how the radio works and the network topology for Bluetooth LE
    connections. We learned how the GAP is used by Bluetooth LE devices to discover
    and connect to other devices. We also saw how the GATT uses attributes (services,
    characteristics and descriptors) to enable two Bluetooth LE devices to communicate
    with each other. We finally demonstrated how Bluetooth LE works with three projects
    at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Bluetooth LE is the technology best suited when we wish to use an external device,
    such as a phone, to control the device that we are building, because almost all
    smartphones have Bluetooth LE built in and the technology is easy to use. It is
    also a good technology to use when we wish to send short bursts of data from one
    device to another. If you wish to build a separate device, such as a remote control,
    to control your main device or stream a lot of data, then I would recommend a
    different Bluetooth technology that is known as Bluetooth Classic or Legacy, which
    we will see in the next chapter.
  prefs: []
  type: TYPE_NORMAL
