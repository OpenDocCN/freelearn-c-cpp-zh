<html><head></head><body>
<div id="_idContainer020">
<h1 class="chapter-number" id="_idParaDest-118"><a id="_idTextAnchor314"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-119"><a id="_idTextAnchor315"/><a id="_idTextAnchor316"/><a id="_idTextAnchor317"/><span class="koboSpan" id="kobo.2.1">SFINAE, Concepts, and Overload Resolution Management</span></h1>
<p><span class="koboSpan" id="kobo.3.1">The idiom we study in this chapter, </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">Substitution Failure Is Not An Error</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">SFINAE</span></strong><span class="koboSpan" id="kobo.7.1">), is one of the more complex in terms of the language features it uses. </span><span class="koboSpan" id="kobo.7.2">Thus, it tends to get inordinate amounts of attention from C++ programmers. </span><span class="koboSpan" id="kobo.7.3">There is something in this feature that appeals to the mindset of a typical C++ programmer - a normal person thinks that, if it isn’t broken, don’t mess with it. </span><span class="koboSpan" id="kobo.7.4">A programmer, especially one writing in C++, tends to think that, if it isn’t broken, you’re not using it to its full potential. </span><span class="koboSpan" id="kobo.7.5">Let’s just say that SFINAE has a lot </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">of potential.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">We will cover the following topics in </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">What are function overloading and overload resolution? </span><span class="koboSpan" id="kobo.11.2">What are type deduction </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">and substitution?</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">What is SFINAE, and why was it necessary </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">in C++?</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">How can SFINAE be used to write insanely complex, and sometimes </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">useful, programs?</span></span></li>
</ul>
<h1 id="_idParaDest-120"><a id="_idTextAnchor318"/><span class="koboSpan" id="kobo.17.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.18.1">The example code for this chapter can be found at </span><a href="https://github.com/PacktPublishing/"><span class="No-Break"><span class="koboSpan" id="kobo.19.1">https://github.com/PacktPublishing/</span></span></a><span class="No-Break"> </span><a href="http://Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter07"><span class="No-Break"><span class="koboSpan" id="kobo.20.1">Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter07</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.21.1">.</span></span></p>
<h1 id="_idParaDest-121"><a id="_idTextAnchor319"/><a id="_idTextAnchor320"/><a id="_idTextAnchor321"/><span class="koboSpan" id="kobo.22.1">Overload resolution and overload sets</span></h1>
<p><span class="koboSpan" id="kobo.23.1">This section will test your knowledge of the latest and most advanced additions to the C++ standard. </span><span class="koboSpan" id="kobo.23.2">We will start with one of the most basic features of C++, functions, and </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">their </span><a id="_idTextAnchor322"/><span class="koboSpan" id="kobo.25.1">overloads.</span></span></p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor323"/><span class="koboSpan" id="kobo.26.1">C++ function overloading</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.27.1">Function overloading</span></strong><span class="koboSpan" id="kobo.28.1"> is a very straightforward concept in C++; multiple different functions can have the same name. </span><span class="koboSpan" id="kobo.28.2">That’s it, that is all there is to overloading - when the compiler sees syntax that indicates a function call, formatted as </span><strong class="source-inline"><span class="koboSpan" id="kobo.29.1">f(x)</span></strong><span class="koboSpan" id="kobo.30.1">, then there must be more than one function named </span><strong class="source-inline"><span class="koboSpan" id="kobo.31.1">f</span></strong><span class="koboSpan" id="kobo.32.1">. </span><span class="koboSpan" id="kobo.32.2">If this happens, we are in an overload situation, and overload resolution must take place to find out which of these functions should </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">be called.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">Let’s start with a </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">simple example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.36.1">
// Example 01
void f(int i) { cout &lt;&lt; “f(int)” &lt;&lt; endl; }        // 1
void f(long i) { cout &lt;&lt; “f(long)” &lt;&lt; endl; }    // 2
void f(double i) { cout &lt;&lt; “f(double)” &lt;&lt; endl; }    // 3
f(5);        // 1
f(5l);    // 2
f(5.0);    // 3</span></pre>
<p><span class="koboSpan" id="kobo.37.1">Here, we have three function definitions for the same name, </span><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">f</span></strong><span class="koboSpan" id="kobo.39.1">, and three function calls. </span><span class="koboSpan" id="kobo.39.2">Note that the function signatures are all different (in that the parameter types are different). </span><span class="koboSpan" id="kobo.39.3">This is a requirement - overloaded functions must differ somehow in their parameters. </span><span class="koboSpan" id="kobo.39.4">It is not possible to have two overloads that take the exact same arguments but differ in the return type or the function body. </span><span class="koboSpan" id="kobo.39.5">Also, note that, while the example is for a regular function, the exact same rules apply to the overloaded member functions, so we will not pay special attention to member </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">functions exclusively.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">Back to our example, which of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">f()</span></strong><span class="koboSpan" id="kobo.43.1"> functions is called on each line? </span><span class="koboSpan" id="kobo.43.2">To understand that, we need to know how overloaded functions are resolved in C++. </span><span class="koboSpan" id="kobo.43.3">The exact rules for overload resolution are fairly complex and differ in subtle ways between different versions of the standard, but for the most part, they are designed so that the compiler does what you would expect it to do in the most commonly encountered cases. </span><span class="koboSpan" id="kobo.43.4">We would expect </span><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">f(5)</span></strong><span class="koboSpan" id="kobo.45.1"> to call the overload that accepts an integer argument since </span><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">5</span></strong><span class="koboSpan" id="kobo.47.1"> is an </span><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">int</span></strong><span class="koboSpan" id="kobo.49.1"> variable. </span><span class="koboSpan" id="kobo.49.2">And so it does. </span><span class="koboSpan" id="kobo.49.3">Similarly, </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">5l</span></strong><span class="koboSpan" id="kobo.51.1"> has the long type, and so </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">f(5l)</span></strong><span class="koboSpan" id="kobo.53.1"> calls the second overload. </span><span class="koboSpan" id="kobo.53.2">Finally, </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">5.0</span></strong><span class="koboSpan" id="kobo.55.1"> is a floating-point number, and so the last overload </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">is called.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">That wasn’t so hard, was it? </span><span class="koboSpan" id="kobo.57.2">But what happens if the argument does not match the parameter type exactly? </span><span class="koboSpan" id="kobo.57.3">Then, the compiler has to consider type conversions. </span><span class="koboSpan" id="kobo.57.4">For example, the type of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">5.0</span></strong><span class="koboSpan" id="kobo.59.1"> literal is </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">double</span></strong><span class="koboSpan" id="kobo.61.1">. </span><span class="koboSpan" id="kobo.61.2">Let’s see what happens if we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">f()</span></strong><span class="koboSpan" id="kobo.63.1"> with an argument of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">float</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.65.1"> type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.66.1">
f(5.0f);</span></pre>
<p><span class="koboSpan" id="kobo.67.1">Now we have to convert the argument from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">float</span></strong><span class="koboSpan" id="kobo.69.1"> type to one of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">int</span></strong><span class="koboSpan" id="kobo.71.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">long</span></strong><span class="koboSpan" id="kobo.73.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">double</span></strong><span class="koboSpan" id="kobo.75.1"> types. </span><span class="koboSpan" id="kobo.75.2">Again, the standard has rules, but it should come as no surprise that the conversion to </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">double</span></strong><span class="koboSpan" id="kobo.77.1"> is preferred and that the overload </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">is called.</span></span></p>
<p><span class="koboSpan" id="kobo.79.1">Let’s see what happens with a different integer type, say, </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">unsigned</span></strong></span><span class="No-Break"> </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">int</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.83.1">
f(5u);</span></pre>
<p><span class="koboSpan" id="kobo.84.1">Now we have two options; convert </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">unsigned</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.86.1">int</span></strong><span class="koboSpan" id="kobo.87.1"> to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">signed</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.89.1">int</span></strong><span class="koboSpan" id="kobo.90.1">, or to </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">signed</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.92.1">long</span></strong><span class="koboSpan" id="kobo.93.1">. </span><span class="koboSpan" id="kobo.93.2">While it may be argued that the conversion to </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">long</span></strong><span class="koboSpan" id="kobo.95.1"> is </span><em class="italic"><span class="koboSpan" id="kobo.96.1">safer</span></em><span class="koboSpan" id="kobo.97.1">, and thus better, the two conversions are considered so close by the standard that the compiler cannot choose. </span><span class="koboSpan" id="kobo.97.2">This call does not compile because the overload resolution is considered ambiguous; the error message should say as much. </span><span class="koboSpan" id="kobo.97.3">If you encounter such a problem in your code, you</span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.98.1"> have to help the compiler by casting the arguments to a </span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.99.1">type that makes the resolution unambiguous. </span><span class="koboSpan" id="kobo.99.2">Usually, the simplest way is to cast the type of the parameter for the overload you want </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">to call:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.101.1">
unsigned int i = 5u;
f(static_cast&lt;int&gt;(i));</span></pre>
<p><span class="koboSpan" id="kobo.102.1">So far, we have dealt with a situation where the types of parameters were different, but their number was the same. </span><span class="koboSpan" id="kobo.102.2">Of course, if the number of parameters differs between different function declarations for the same name, only the functions that can accept the required number of arguments need to be considered. </span><span class="koboSpan" id="kobo.102.3">Here is an example of two functions with the same name but a different number </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">of arguments:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.104.1">
void f(int i) { cout &lt;&lt; “f(int)” &lt;&lt; endl; }            // 1
void f(long i, long j) { cout &lt;&lt; “f(long2)” &lt;&lt; endl; }    // 2
f(5.0, 7);</span></pre>
<p><span class="koboSpan" id="kobo.105.1">Here, the overload resolution is very simple - we need a function that can accept two arguments, and there is only one choice. </span><span class="koboSpan" id="kobo.105.2">Both arguments will have to be converted to </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">long</span></strong><span class="koboSpan" id="kobo.107.1">. </span><span class="koboSpan" id="kobo.107.2">But what if there is more than one function with the same number of parameters? </span><span class="koboSpan" id="kobo.107.3">Let’s see what happens in the </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.109.1">
// Example 02
void f(int i, int j) { cout &lt;&lt; “f(int, int)” &lt;&lt; endl; }// 1
void f(long i, long j) { cout &lt;&lt; “f(long2)” &lt;&lt; endl; }    // 2
void f(double i) { cout &lt;&lt; “f(double)” &lt;&lt; endl; }      // 3
f(5, 5);    // 1
f(5l, 5l);    // 2
f(5, 5.0);    // 1
f(5, 5l);    // ?</span></pre>
<p><span class="koboSpan" id="kobo.110.1">First of all, the obvious case - if the types of all arguments match exactly the types of the parameters for one of the overloads, that overload is called. </span><span class="koboSpan" id="kobo.110.2">Next, things start to get interesting - if there</span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.111.1"> is no exact match, we can have conversions on each </span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.112.1">argument. </span><span class="koboSpan" id="kobo.112.2">Let’s consider the third call, </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">f(5, 5.0)</span></strong><span class="koboSpan" id="kobo.114.1">. </span><span class="koboSpan" id="kobo.114.2">The first argument, </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">int</span></strong><span class="koboSpan" id="kobo.116.1">, matches the first overload exactly but could be converted to </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">long</span></strong><span class="koboSpan" id="kobo.118.1"> if necessary. </span><span class="koboSpan" id="kobo.118.2">The second argument, </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">double</span></strong><span class="koboSpan" id="kobo.120.1">, does not match either overload but could be converted to match both. </span><span class="koboSpan" id="kobo.120.2">The first overload is a better match - it requires fewer argument conversions. </span><span class="koboSpan" id="kobo.120.3">Finally, what about the last line? </span><span class="koboSpan" id="kobo.120.4">The first overload can be called, with a conversion on the second argument. </span><span class="koboSpan" id="kobo.120.5">The second overload can also be made to work, with a conversion on the first argument. </span><span class="koboSpan" id="kobo.120.6">Again, this is an ambiguous overload, and this line will not compile. </span><span class="koboSpan" id="kobo.120.7">Note that it is not, in general, true that the overload with the fewer conversions always wins; in more complex cases, it is possible to have ambiguous overloads even if one requires fewer conversions (the general rule is, if there is an overload that has the best conversion on every argument, it wins; otherwise, the call is ambiguous). </span><span class="koboSpan" id="kobo.120.8">To resolve this ambiguity, you have to change the types of some of the arguments (by casting, in general, or by changing the type of the numeric literal, in our case) to make the intended overload be the </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">preferred one.</span></span></p>
<p><span class="koboSpan" id="kobo.122.1">Note how the third overload was completely left out because it has the wrong number of parameters for all function calls. </span><span class="koboSpan" id="kobo.122.2">It’s not always that simple, though - functions can have default arguments, which means the number of arguments does not always have to match the number </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">of parameters.</span></span></p>
<p><span class="koboSpan" id="kobo.124.1">Consider the following </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">code block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.126.1">
// Example 03
void f(int i) { cout &lt;&lt; “f(int)” &lt;&lt; endl; }            // 1
void f(long i, long j) { cout &lt;&lt; “f(long2)” &lt;&lt; endl; }    // 2
void f(double i, double j = 0) {                    // 3
  cout &lt;&lt; “f(double, double = 0)” &lt;&lt; endl;
}
f(5);        // 1
f(5l, 5);    /</span><a id="_idTextAnchor324"/><span class="koboSpan" id="kobo.127.1">/ 2
f(5, 5);    // ?
</span><span class="koboSpan" id="kobo.127.2">f(5.0);    // 3
f(5.0f);    // 3
f(5l);    // ?</span></pre>
<p><span class="koboSpan" id="kobo.128.1">We now have three </span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.129.1">overloads. </span><span class="koboSpan" id="kobo.129.2">The first and the second can never be confused</span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.130.1"> because they have a different number of parameters. </span><span class="koboSpan" id="kobo.130.2">The third overload, however, can be called with either one or two arguments; in the former case, the second argument is assumed to be zero. </span><span class="koboSpan" id="kobo.130.3">The first call is the simplest - one argument, where the type matches the parameter type of the first overload exactly. </span><span class="koboSpan" id="kobo.130.4">The second call reminds us of the case we have seen before - two arguments, where the first is an exact match to one of the overloads, but the second requires a conversion. </span><span class="koboSpan" id="kobo.130.5">The alternative overload needs conversions on both arguments, so the second function definition is the </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">best match.</span></span></p>
<p><span class="koboSpan" id="kobo.132.1">The third call seems straightforward enough with its two integer arguments, but this simplicity is deceptive - there are two overloads that accept two arguments, and in both overload cases, both arguments need conversions. </span><span class="koboSpan" id="kobo.132.2">While the conversion from </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">int</span></strong><span class="koboSpan" id="kobo.134.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">long</span></strong><span class="koboSpan" id="kobo.136.1"> may seem better than the one from </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">int</span></strong><span class="koboSpan" id="kobo.138.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">double</span></strong><span class="koboSpan" id="kobo.140.1">, C++ does not see it this way. </span><span class="koboSpan" id="kobo.140.2">This call is ambiguous. </span><span class="koboSpan" id="kobo.140.3">The next call, </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">f(5.0)</span></strong><span class="koboSpan" id="kobo.142.1">, has only one argument, which can be converted to </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">int</span></strong><span class="koboSpan" id="kobo.144.1">, the type of the parameter in the one-argument overload. </span><span class="koboSpan" id="kobo.144.2">But it is still a better match for the third overload, where it needs no conversion at all. </span><span class="koboSpan" id="kobo.144.3">Change the argument type from </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">double</span></strong><span class="koboSpan" id="kobo.146.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">float</span></strong><span class="koboSpan" id="kobo.148.1">, and we get the next call. </span><span class="koboSpan" id="kobo.148.2">The conversion to </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">double</span></strong><span class="koboSpan" id="kobo.150.1"> is better than that to </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">int</span></strong><span class="koboSpan" id="kobo.152.1">, and utilizing the default argument is not considered a conversion and so does not carry any other </span><em class="italic"><span class="koboSpan" id="kobo.153.1">penalty </span></em><span class="koboSpan" id="kobo.154.1">when overloads are compared. </span><span class="koboSpan" id="kobo.154.2">The last call is again ambiguous - both conversions to </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">double</span></strong><span class="koboSpan" id="kobo.156.1"> and to </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">int</span></strong><span class="koboSpan" id="kobo.158.1"> are considered of equal weight, thus the first and third overloads are equally good. </span><span class="koboSpan" id="kobo.158.2">The second overload offers an exact match to the first parameter; however, there is no way to call that overload without the second argument, so it is not </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">even considered.</span></span></p>
<p><span class="koboSpan" id="kobo.160.1">So far, we have considered only ordinary C++ functions, although everything we have learned</span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.161.1"> applies </span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.162.1">equally to member functions as well. </span><span class="koboSpan" id="kobo.162.2">Now, we need to add template functions to </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">t</span><a id="_idTextAnchor325"/><a id="_idTextAnchor326"/><a id="_idTextAnchor327"/><span class="koboSpan" id="kobo.164.1">he mix.</span></span></p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor328"/><span class="koboSpan" id="kobo.165.1">Template functions</span></h2>
<p><span class="koboSpan" id="kobo.166.1">In addition to </span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.167.1">regular functions, for which the parameter types are </span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.168.1">known, C++ also has </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">template</span></strong><span class="koboSpan" id="kobo.170.1"> functions. </span><span class="koboSpan" id="kobo.170.2">When these functions are called, the parameter types are deduced from the types of the arguments at the call site. </span><span class="koboSpan" id="kobo.170.3">The template functions can have the same name as non-template functions, and several template functions can have the same name as well, so we need to learn about overload resolution in the presence </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">of templates.</span></span></p>
<p><span class="koboSpan" id="kobo.172.1">Consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.174.1">
// Example 04
void f(int i) { cout &lt;&lt; “f(int)” &lt;&lt; endl; }        // 1
void f(long i) { cout &lt;&lt; “f(long)” &lt;&lt; endl; }    // 2
template &lt;typename T&gt;
void f(T i) { cout &lt;&lt; “f(T)” &lt;&lt; endl; }        // 3
f(5);        // 1
f(5l);    // 2
f(5.0);    // 3</span></pre>
<p><span class="koboSpan" id="kobo.175.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">f</span></strong><span class="koboSpan" id="kobo.177.1"> function name can refer to any of the three functions, one of which is a template. </span><span class="koboSpan" id="kobo.177.2">The best overload will be chosen from these three each time. </span><span class="koboSpan" id="kobo.177.3">The set of functions that are considered for the overload resolution of a particular function call is known</span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.178.1"> as the </span><strong class="bold"><span class="koboSpan" id="kobo.179.1">overload set</span></strong><span class="koboSpan" id="kobo.180.1">. </span><span class="koboSpan" id="kobo.180.2">The first call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">f()</span></strong><span class="koboSpan" id="kobo.182.1"> matches exactly the first non-template function in the overload set - the argument type is </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">int</span></strong><span class="koboSpan" id="kobo.184.1">, and the first function is </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">f(int)</span></strong><span class="koboSpan" id="kobo.186.1">. </span><span class="koboSpan" id="kobo.186.2">If an exact match to a non-template function is found in the overload set, it is always considered the </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">best overload.</span></span></p>
<p><span class="koboSpan" id="kobo.188.1">The template function can also be instantiated with an exact match - the process of replacing template parameters with concrete types is known as template argument substitution (or type substitution), and, if </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">int</span></strong><span class="koboSpan" id="kobo.190.1"> is substituted for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">T</span></strong><span class="koboSpan" id="kobo.192.1"> template parameter, then we arrive at another function that exactly matches the call. </span><span class="koboSpan" id="kobo.192.2">However, a non-template function that matches exactly is considered a better overload. </span><span class="koboSpan" id="kobo.192.3">The second call is processed similarly, but it is an exact match to the second function in the overload set, so that is the function that will be called. </span><span class="koboSpan" id="kobo.192.4">The last call has an argument of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">double</span></strong><span class="koboSpan" id="kobo.194.1"> type that can be converted to </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">int</span></strong><span class="koboSpan" id="kobo.196.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">long</span></strong><span class="koboSpan" id="kobo.198.1">, or substituted for </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">T</span></strong><span class="koboSpan" id="kobo.200.1"> to make the template instantiation an exact match. </span><span class="koboSpan" id="kobo.200.2">Since there is no exactly matching non-template function, the template function instantiated to an exact match is the next best overload and </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">is selected.</span></span></p>
<p><span class="koboSpan" id="kobo.202.1">But what happens</span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.203.1"> when there are multiple template functions that can have their template</span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.204.1"> parameters substituted to match the argument types of the call? </span><span class="koboSpan" id="kobo.204.2">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">find out:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.206.1">
// Example 05
void f(int i) { cout &lt;&lt; “f(int)” &lt;&lt; endl; }    // 1
template &lt;typename T&gt;
void f(T i) { cout &lt;&lt; “f(T)” &lt;&lt; endl; }    // 2
template &lt;typename T&gt;
void f(T* i) { cout &lt;&lt; “f(T*)” &lt;&lt; endl; }    // 3
f(5);        // 1
f(5l);    // 2
int i = 0;
f(&amp;i);    // 3</span></pre>
<p><span class="koboSpan" id="kobo.207.1">The first call is again an exact match to the non-template function, and so is resolved. </span><span class="koboSpan" id="kobo.207.2">The second call matches the first, non-template, overload, with a conversion, or the second overload exactly if the right type, </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">long</span></strong><span class="koboSpan" id="kobo.209.1">, is substituted for </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">T</span></strong><span class="koboSpan" id="kobo.211.1">. </span><span class="koboSpan" id="kobo.211.2">The last overload does not match either of these calls - there is no substitution that would make the </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">T*</span></strong><span class="koboSpan" id="kobo.213.1"> parameter type match either </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">int</span></strong><span class="koboSpan" id="kobo.215.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">long</span></strong><span class="koboSpan" id="kobo.217.1">. </span><span class="koboSpan" id="kobo.217.2">The last call, however, can be matched to the third overload if </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">int</span></strong><span class="koboSpan" id="kobo.219.1"> is substituted for </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">T</span></strong><span class="koboSpan" id="kobo.221.1">. </span><span class="koboSpan" id="kobo.221.2">The problem is that it could also match the second overload if </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">int*</span></strong><span class="koboSpan" id="kobo.223.1"> were substituted for </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">T</span></strong><span class="koboSpan" id="kobo.225.1">. </span><span class="koboSpan" id="kobo.225.2">So which template overload is chosen? </span><span class="koboSpan" id="kobo.225.3">The answer is the more specific one - the first overload, </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">f(T)</span></strong><span class="koboSpan" id="kobo.227.1">, can be made to match any one-argument function call, while the second overload, </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">f(T*)</span></strong><span class="koboSpan" id="kobo.229.1">, can only match calls with pointer arguments. </span><span class="koboSpan" id="kobo.229.2">The more specific, narrower overload is considered a better match and is selected. </span><span class="koboSpan" id="kobo.229.3">This is a new notion, specific to templates - instead of choosing better conversions (in general, </span><em class="italic"><span class="koboSpan" id="kobo.230.1">fewer </span></em><span class="koboSpan" id="kobo.231.1">or </span><em class="italic"><span class="koboSpan" id="kobo.232.1">simpler </span></em><span class="koboSpan" id="kobo.233.1">conversions), we select the overload that is </span><em class="italic"><span class="koboSpan" id="kobo.234.1">harder </span></em><span class="No-Break"><span class="koboSpan" id="kobo.235.1">to instantiate.</span></span></p>
<p><span class="koboSpan" id="kobo.236.1">This rule seemingly breaks for null pointers: </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">f(NULL)</span></strong><span class="koboSpan" id="kobo.238.1"> can call either the first or the second overload (</span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">f(int)</span></strong><span class="koboSpan" id="kobo.240.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">f(T)</span></strong><span class="koboSpan" id="kobo.242.1">), and </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">f(nullptr)</span></strong><span class="koboSpan" id="kobo.244.1"> call the second overload, </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">f(T)</span></strong><span class="koboSpan" id="kobo.246.1">. </span><span class="koboSpan" id="kobo.246.2">The pointer overload is never called, even though both </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">NULL</span></strong><span class="koboSpan" id="kobo.248.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">nullptr</span></strong><span class="koboSpan" id="kobo.250.1"> are supposedly null pointers. </span><span class="koboSpan" id="kobo.250.2">However, this is actually the case of the compiler strictly following the rules. </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">NULL</span></strong><span class="koboSpan" id="kobo.252.1"> in C++ is an integer zero, it’s actually </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">a macro:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.254.1">
#define NULL 0 // Or 0L</span></pre>
<p><span class="koboSpan" id="kobo.255.1">Depending on whether it is defined as </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">0</span></strong><span class="koboSpan" id="kobo.257.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">0L</span></strong><span class="koboSpan" id="kobo.259.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">f(int)</span></strong><span class="koboSpan" id="kobo.261.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">f(T)</span></strong><span class="koboSpan" id="kobo.263.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">T==long</span></strong><span class="koboSpan" id="kobo.265.1"> are called. </span><span class="koboSpan" id="kobo.265.2">The constant </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">nullptr</span></strong><span class="koboSpan" id="kobo.267.1">, despite having “ptr” in its name, is actually a constant value of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">nullptr_t</span></strong><span class="koboSpan" id="kobo.269.1">. </span><span class="koboSpan" id="kobo.269.2">It is </span><em class="italic"><span class="koboSpan" id="kobo.270.1">convertible</span></em><span class="koboSpan" id="kobo.271.1"> to any pointer type but it is</span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.272.1"> not of any pointer type. </span><span class="koboSpan" id="kobo.272.2">This is why, when dealing with functions accepting pointers of different types, an overload with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">nullptr_t</span></strong><span class="koboSpan" id="kobo.274.1"> parameter is </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">often declared.</span></span></p>
<p><span class="koboSpan" id="kobo.276.1">Finally, there is one more kind of function that can match just about any function call with the same name, and that is the function that takes </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">variable arguments:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.278.1">
// Example 06
void f(int i) { cout &lt;&lt; “f(int)” &lt;&lt; endl; }    // 1
void f(...) { cout &lt;&lt; “f(...)” &lt;&lt; endl; }    // 2
f(5);        // 1
f(5l);    // 1
f(5.0);    // 1
struct A {};
A a;
f(a);  </span><a id="_idTextAnchor329"/><span class="koboSpan" id="kobo.279.1">  {};    // 2</span></pre>
<p><span class="koboSpan" id="kobo.280.1">The first of the overloads can be used for the first three function calls - it is an exact match for the first call, and conversions exist to make the other two calls fit the signature of the first overload for </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">f()</span></strong><span class="koboSpan" id="kobo.282.1">. </span><span class="koboSpan" id="kobo.282.2">The second function in this example can be called with any number of arguments of any type. </span><span class="koboSpan" id="kobo.282.3">This is considered the choice of last resort - a function with specific arguments that can be made to match the call with the right conversions is preferred. </span><span class="koboSpan" id="kobo.282.4">This includes user-defined conversions, </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.284.1">
struct B {
  operator int() const { return 0; }
};
B b;
f(b);        // 1</span></pre>
<p><span class="koboSpan" id="kobo.285.1">Only if there are no conversions</span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.286.1"> that allow us to avoid calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">f(...)</span></strong><span class="koboSpan" id="kobo.288.1"> variadic </span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.289.1">function, then it has to </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">be called.</span></span></p>
<p><span class="koboSpan" id="kobo.291.1">Now we know the order of the overload resolution - first, a non-template function that matches the arguments exactly is chosen. </span><span class="koboSpan" id="kobo.291.2">If there is no such match in the overload set, then a template function is chosen if its parameters can be substituted with concrete types in a way that gives an exact match. </span><span class="koboSpan" id="kobo.291.3">If there is more than one option for such a template function, then a more specific overload is preferred over the more general one. </span><span class="koboSpan" id="kobo.291.4">If the attempt to match a template function in this manner also fails, then a non-template function is called if the arguments can be converted to its parameter types. </span><span class="koboSpan" id="kobo.291.5">Finally, if everything else fails, but a function with the right name that takes variable arguments is available, then that function is called. </span><span class="koboSpan" id="kobo.291.6">Note that certain conversions are considered </span><em class="italic"><span class="koboSpan" id="kobo.292.1">trivial </span></em><span class="koboSpan" id="kobo.293.1">and are included in the notion of the </span><em class="italic"><span class="koboSpan" id="kobo.294.1">exact </span></em><span class="koboSpan" id="kobo.295.1">match, for example, the conversion from </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">T</span></strong><span class="koboSpan" id="kobo.297.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">const</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.299.1">T</span></strong><span class="koboSpan" id="kobo.300.1">. </span><span class="koboSpan" id="kobo.300.2">At every step, if there is more than one equally good option, the overload is considered ambiguous and the program </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">is ill-formed.</span></span></p>
<p><span class="koboSpan" id="kobo.302.1">The process of type substitution in a template function is what determines the final types of the template function parameters, and how good a match they are to the arguments of the function call. </span><span class="koboSpan" id="kobo.302.2">This process can lead to somewhat unexpected results and must be considered</span><a id="_idTextAnchor330"/><a id="_idTextAnchor331"/><a id="_idTextAnchor332"/><span class="koboSpan" id="kobo.303.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">more detail.</span></span></p>
<h1 id="_idParaDest-124"><a id="_idTextAnchor333"/><span class="koboSpan" id="kobo.305.1">Type substitution in template functions</span></h1>
<p><span class="koboSpan" id="kobo.306.1">We must </span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.307.1">carefully differentiate between the two steps</span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.308.1"> in instantiating a template function to match a particular call - first, the types of the template parameters are deduced from the argument types (a process referred to as type deduction). </span><span class="koboSpan" id="kobo.308.2">Once the types are deduced, the concrete types are substituted for all parameter types (this is a process called </span><strong class="bold"><span class="koboSpan" id="kobo.309.1">type substitution</span></strong><span class="koboSpan" id="kobo.310.1">). </span><span class="koboSpan" id="kobo.310.2">The difference becomes more obvious when the func</span><a id="_idTextAnchor334"/><span class="koboSpan" id="kobo.311.1">tion has </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">mul</span><a id="_idTextAnchor335"/><span class="koboSpan" id="kobo.313.1">tiple parameters.</span></span></p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor336"/><span class="koboSpan" id="kobo.314.1">Type deduction and substitution</span></h2>
<p><span class="koboSpan" id="kobo.315.1">Type deduction </span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.316.1">and substitution</span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.317.1"> are closely related, but not exactly the same. </span><span class="koboSpan" id="kobo.317.2">The deduction is the process of “</span><em class="italic"><span class="koboSpan" id="kobo.318.1">guessing:” </span></em><span class="koboSpan" id="kobo.319.1">what should the template type, or types, be in order to match the call? </span><span class="koboSpan" id="kobo.319.2">Of course, the compiler does not really guess but applies a set of rules defined in the standard. </span><span class="koboSpan" id="kobo.319.3">Consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.321.1">
// Example 07
template &lt;typename T&gt;
void f(T i, T* p) { std::cout &lt;&lt; “f(T, T*)” &lt;&lt; std::endl; }
int i;
f(5, &amp;i);    // T == int
f(5l, &amp;i);    // ?</span></pre>
<p><span class="koboSpan" id="kobo.322.1">When considering the first call, we can deduce from the first argument that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">T</span></strong><span class="koboSpan" id="kobo.324.1"> template parameter should be </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">int</span></strong><span class="koboSpan" id="kobo.326.1">. </span><span class="koboSpan" id="kobo.326.2">Thus, </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">int</span></strong><span class="koboSpan" id="kobo.328.1"> is substituted for </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">T</span></strong><span class="koboSpan" id="kobo.330.1"> in both parameters of the function. </span><span class="koboSpan" id="kobo.330.2">The template is instantiated as </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">f(int, int*)</span></strong><span class="koboSpan" id="kobo.332.1"> and is an exact match for the argument types. </span><span class="koboSpan" id="kobo.332.2">When considering the second call, we could deduce that </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">T</span></strong><span class="koboSpan" id="kobo.334.1"> should be </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">long</span></strong><span class="koboSpan" id="kobo.336.1"> from the first argument. </span><span class="koboSpan" id="kobo.336.2">Alternatively, we could deduce that </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">T</span></strong><span class="koboSpan" id="kobo.338.1"> should be </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">int</span></strong><span class="koboSpan" id="kobo.340.1"> from the second argument. </span><span class="koboSpan" id="kobo.340.2">This ambiguity leads to the failure of the type deduction process. </span><span class="koboSpan" id="kobo.340.3">If this is the only overload available, neither option is chosen, and the program does not compile. </span><span class="koboSpan" id="kobo.340.4">If more overloads exist, they are considered in turn, including possibly the overload of last resort, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">f(...)</span></strong><span class="koboSpan" id="kobo.342.1"> variadic function. </span><span class="koboSpan" id="kobo.342.2">One important detail to note here is that conversions are not considered when deducing template types - the deduction of </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">T</span></strong><span class="koboSpan" id="kobo.344.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">int</span></strong><span class="koboSpan" id="kobo.346.1"> would have yielded </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">f(int, int*)</span></strong><span class="koboSpan" id="kobo.348.1"> for the second call, which is a viable option for calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">f(long, int*)</span></strong><span class="koboSpan" id="kobo.350.1"> with the conversion of the first argument. </span><span class="koboSpan" id="kobo.350.2">However, this option is not considered at all, and instead, type deduction fails </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">as ambiguous.</span></span></p>
<p><span class="koboSpan" id="kobo.352.1">The ambiguous deduction can be resolved by explicitly specifying the template types, which removes the need for </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">type deduction:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.354.1">
f&lt;int&gt;(5l, &amp;i);    // T == int</span></pre>
<p><span class="koboSpan" id="kobo.355.1">Now, type deduction is not done at all: we know what </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">T</span></strong><span class="koboSpan" id="kobo.357.1"> is from the function call, as it is explicitly specified. </span><span class="koboSpan" id="kobo.357.2">Type substitution, on the other hand, still has to happen - the first parameter is of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">int</span></strong><span class="koboSpan" id="kobo.359.1"> type, and the second is of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">int*</span></strong><span class="koboSpan" id="kobo.361.1"> type. </span><span class="koboSpan" id="kobo.361.2">The function call succeeds with a conversion on the first argument. </span><span class="koboSpan" id="kobo.361.3">We could also force deduction the </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">other way:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.363.1">
f&lt;long&gt;(5l, &amp;i);    // T == long</span></pre>
<p><span class="koboSpan" id="kobo.364.1">Again, deduction is not necessary, as we know what </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">T</span></strong><span class="koboSpan" id="kobo.366.1"> is. </span><span class="koboSpan" id="kobo.366.2">Substitution proceeds in a straightforward way, and we end up with </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">f(long, long*)</span></strong><span class="koboSpan" id="kobo.368.1">. </span><span class="koboSpan" id="kobo.368.2">This function cannot be called with </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">int*</span></strong><span class="koboSpan" id="kobo.370.1"> as the second argument since there is no valid conversion from </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">int*</span></strong><span class="koboSpan" id="kobo.372.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">long*</span></strong><span class="koboSpan" id="kobo.374.1">. </span><span class="koboSpan" id="kobo.374.2">Thus, the program does not compile. </span><span class="koboSpan" id="kobo.374.3">Note that, by explicitly specifying the types, we have also specified that </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">f()</span></strong><span class="koboSpan" id="kobo.376.1"> must be a template function. </span><span class="koboSpan" id="kobo.376.2">The non-template overloads for </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">f()</span></strong><span class="koboSpan" id="kobo.378.1"> are no longer considered. </span><span class="koboSpan" id="kobo.378.2">On the other hand, if there is more than one </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">f()</span></strong><span class="koboSpan" id="kobo.380.1"> template function, then these overloads are considered as usual, but this time with the results of the argument deduction forced by our </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">explicit specification.</span></span></p>
<p><span class="koboSpan" id="kobo.382.1">Template functions </span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.383.1">can have default arguments, just like non-template </span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.384.1">functions, however, the values of these arguments are not used to deduce types (in C++11, template functions can have default values for their type parameters, which provides an alternative). </span><span class="koboSpan" id="kobo.384.2">Consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.386.1">
// Example 08
void f(int i, int j = 1) {                      // 1
  cout &lt;&lt; “f(int2)” &lt;&lt; endl;
}
template &lt;typename T&gt; void f(T i, T* p = nullptr) {    // 2
  cout &lt;&lt; “f(T, T*)” &lt;&lt; endl;
}
int i;
f(5);        // 1
f(5l);    // 2</span></pre>
<p><span class="koboSpan" id="kobo.387.1">The first call is an exact match to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">f(int,</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.389.1">int)</span></strong><span class="koboSpan" id="kobo.390.1"> non-template function, with the default value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">1</span></strong><span class="koboSpan" id="kobo.392.1"> for the second argument. </span><span class="koboSpan" id="kobo.392.2">Note that it would have made no difference if we had declared the function as </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">f(int i, int j = 1L)</span></strong><span class="koboSpan" id="kobo.394.1">, with the default value as </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">long</span></strong><span class="koboSpan" id="kobo.396.1">. </span><span class="koboSpan" id="kobo.396.2">The type of the default argument does not matter - if it can be converted to the specified parameter type, then that’s the value that is used, otherwise, the program would not compile from line 1. </span><span class="koboSpan" id="kobo.396.3">The second call is an exact match to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">f(T, T*)</span></strong><span class="koboSpan" id="kobo.398.1"> template function, with </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">T == long</span></strong><span class="koboSpan" id="kobo.400.1"> and the default value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">NULL</span></strong><span class="koboSpan" id="kobo.402.1"> for the second argument. </span><span class="koboSpan" id="kobo.402.2">Again, it does not matter at all that the type of tha</span><a id="_idTextAnchor337"/><span class="koboSpan" id="kobo.403.1">t value is </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">not </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">long*</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.407.1">We now understand the difference between type deduction and type substitution. </span><span class="koboSpan" id="kobo.407.2">Type deduction can be ambiguous when different concrete types can be deduced from different arguments. </span><span class="koboSpan" id="kobo.407.3">If this happens, it means we have failed to deduce the argument types and cannot</span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.408.1"> use</span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.409.1"> this template function. </span><span class="koboSpan" id="kobo.409.2">Type substitution is never ambiguous - once we know what </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">T</span></strong><span class="koboSpan" id="kobo.411.1"> is, we simply substitute that type every time we see </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">T</span></strong><span class="koboSpan" id="kobo.413.1"> in the fu</span><a id="_idTextAnchor338"/><span class="koboSpan" id="kobo.414.1">nction definition. </span><span class="koboSpan" id="kobo.414.2">This process can also fail, </span><a id="_idTextAnchor339"/><span class="koboSpan" id="kobo.415.1">but in a </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">different way.</span></span></p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor340"/><span class="koboSpan" id="kobo.417.1">Substitution failure</span></h2>
<p><span class="koboSpan" id="kobo.418.1">Once we have </span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.419.1">deduced the template parameter types, type substitution is a purely </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">mechanical process:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.421.1">
// Example 09
template &lt;typename T&gt; T* f(T i, T&amp; j) {
  j = 2*i;
  return new T(i);
}
int i = 5, j = 7;
const int* p = f(i, j);</span></pre>
<p><span class="koboSpan" id="kobo.422.1">In this example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">T</span></strong><span class="koboSpan" id="kobo.424.1"> type can be deduced from the first argument as </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">int</span></strong><span class="koboSpan" id="kobo.426.1">. </span><span class="koboSpan" id="kobo.426.2">It can also be deduced from the second argument, also as </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">int</span></strong><span class="koboSpan" id="kobo.428.1">. </span><span class="koboSpan" id="kobo.428.2">Note that the return type is not used for type deduction. </span><span class="koboSpan" id="kobo.428.3">Since there is only one possible deduction for </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">T</span></strong><span class="koboSpan" id="kobo.430.1">, we now proceed to substitute </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">T</span></strong><span class="koboSpan" id="kobo.432.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">int</span></strong><span class="koboSpan" id="kobo.434.1"> every time we see </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">T</span></strong><span class="koboSpan" id="kobo.436.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">function definition:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.438.1">
int* f(int i, int&amp; j) {
  j = 2*i;
  return new int(i);
}</span></pre>
<p><span class="koboSpan" id="kobo.439.1">Not all types</span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.440.1">, however, are created equal, and some allow more liberties than others. </span><span class="koboSpan" id="kobo.440.2">Consider </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">this code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.442.1">
// Example 10
template &lt;typename T&gt;
void f(T i, typename T::t&amp; j) {
  std::cout &lt;&lt; “f(T, T::t)” &lt;&lt; std::endl;
}
template &lt;typename T&gt;
void f(T i, T j) {
  std::cout &lt;&lt; “f(T, T)” &lt;&lt; std::endl;
}
struct A {
struct t { int i; }; t i; };
A a{5};
f(a, a.i);    // T == A
f(5, 7);    // T == int</span></pre>
<p><span class="koboSpan" id="kobo.443.1">When considering the first call, the compiler deduces the </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">T</span></strong><span class="koboSpan" id="kobo.445.1"> template parameter as being of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">A</span></strong><span class="koboSpan" id="kobo.447.1"> type, from both the first and second argument - the first argument is a value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">A</span></strong><span class="koboSpan" id="kobo.449.1"> type, and the second one is a reference to the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">A::t</span></strong><span class="koboSpan" id="kobo.451.1"> nested type, which matches </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">T::t</span></strong><span class="koboSpan" id="kobo.453.1"> if we stick with our original deduction of </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">T</span></strong><span class="koboSpan" id="kobo.455.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">A</span></strong><span class="koboSpan" id="kobo.457.1">. </span><span class="koboSpan" id="kobo.457.2">The second overload yields conflicting values for </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">T</span></strong><span class="koboSpan" id="kobo.459.1"> from the two arguments and, therefore, cannot be used. </span><span class="koboSpan" id="kobo.459.2">Thus, the first overload </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">is called.</span></span></p>
<p><span class="koboSpan" id="kobo.461.1">Now, look closely at the second call. </span><span class="koboSpan" id="kobo.461.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">T</span></strong><span class="koboSpan" id="kobo.463.1"> type can be deduced as </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">int</span></strong><span class="koboSpan" id="kobo.465.1"> from the first argument for both overloads. </span><span class="koboSpan" id="kobo.465.2">Substituting </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">int</span></strong><span class="koboSpan" id="kobo.467.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">T</span></strong><span class="koboSpan" id="kobo.469.1">, however, yields something strange in the second argument of the first overload - </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">int::t</span></strong><span class="koboSpan" id="kobo.471.1">. </span><span class="koboSpan" id="kobo.471.2">This, of course, would not compile - </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">int</span></strong><span class="koboSpan" id="kobo.473.1"> is not a class and does not have any nested types. </span><span class="koboSpan" id="kobo.473.2">In fact, we could expect that the first template overload will fail to compile for every </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">T</span></strong><span class="koboSpan" id="kobo.475.1"> type that is not a class, or that does not have a nested type called </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">t</span></strong><span class="koboSpan" id="kobo.477.1">. </span><span class="koboSpan" id="kobo.477.2">Indeed, the attempt to substitute </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">int</span></strong><span class="koboSpan" id="kobo.479.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">T</span></strong><span class="koboSpan" id="kobo.481.1"> in the first template function fails with an invalid type for the second argument. </span><span class="koboSpan" id="kobo.481.2">However, this substitution failure does not mean that the entire program cannot compile. </span><span class="koboSpan" id="kobo.481.3">Instead, it is silently ignored, and the overload that would otherwise be ill-formed is removed from the overload set. </span><span class="koboSpan" id="kobo.481.4">The overload resolution then continues as usual. </span><span class="koboSpan" id="kobo.481.5">Of course, we could discover that none of the overloads match the function call, and the program will still not compile, but the error message will not mention anything about </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">int::t</span></strong><span class="koboSpan" id="kobo.483.1"> being invalid; it’ll just say that there are no functions that can </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">be called.</span></span></p>
<p><span class="koboSpan" id="kobo.485.1">Again, it is important to differentiate between type deduction failure and type substitution failure. </span><span class="koboSpan" id="kobo.485.2">We can remove the former from </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">consideration entirely:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.487.1">
f&lt;int&gt;(5, 7);    // T == int</span></pre>
<p><span class="koboSpan" id="kobo.488.1">Now, the deduction is unnecessary, but the substitution of </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">int</span></strong><span class="koboSpan" id="kobo.490.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">T</span></strong><span class="koboSpan" id="kobo.492.1"> must still take place, and this substitution yields an invalid expression in the first overload. </span><span class="koboSpan" id="kobo.492.2">Again, this substitution failure drops this candidate for </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">f()</span></strong><span class="koboSpan" id="kobo.494.1"> from the overload set, and the overload resolution continues (in this case, successfully) with the remaining candidates. </span><span class="koboSpan" id="kobo.494.2">Ordinarily, this</span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.495.1"> would be the end of our exercise in overloading: the template produces code that can’t compile, so the entire program should not compile either. </span><span class="koboSpan" id="kobo.495.2">Fortunately, C++ is more forgiving in this one situation and has a special exception t</span><a id="_idTextAnchor341"/><a id="_idTextAnchor342"/><span class="koboSpan" id="kobo.496.1">hat we need to </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">know about.</span></span></p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor343"/><span class="koboSpan" id="kobo.498.1">Substitution Failure Is Not An Error</span></h2>
<p><span class="koboSpan" id="kobo.499.1">The rule that a </span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.500.1">substitution failure arising from an expression that would be invalid with the specified or deduced types does not make the whole program invalid is known as </span><strong class="bold"><span class="koboSpan" id="kobo.501.1">Substitution Failure Is Not An Error</span></strong><span class="koboSpan" id="kobo.502.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.503.1">SFINAE</span></strong><span class="koboSpan" id="kobo.504.1">). </span><span class="koboSpan" id="kobo.504.2">This rule is essential for using template functions in C++; without SFINAE, it would be impossible to write many otherwise perfectly valid programs. </span><span class="koboSpan" id="kobo.504.3">Consider the following template overload, which differentiates between regular pointers and </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">member pointers:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.506.1">
// Example 11
template &lt;typename T&gt; void f(T* i) {        // 1
  std::cout &lt;&lt; “f(T*)” &lt;&lt; std::endl;
}
template &lt;typename T&gt; void f(int T::* p) {    // 2
  std::cout &lt;&lt; “f(T::*)” &lt;&lt; std::endl;
}
struct A { int i; };
A a;
f(&amp;a.i);    // 1
f(&amp;A::i);    // 2</span></pre>
<p><span class="koboSpan" id="kobo.507.1">So far, so good - the first time, the function is called with a pointer to a specific variable, </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">a.i</span></strong><span class="koboSpan" id="kobo.509.1">, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">T</span></strong><span class="koboSpan" id="kobo.511.1"> type is deduced as </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">int</span></strong><span class="koboSpan" id="kobo.513.1">. </span><span class="koboSpan" id="kobo.513.2">The second call is with a pointer to a data member of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">A</span></strong><span class="koboSpan" id="kobo.515.1"> class, where </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">T</span></strong><span class="koboSpan" id="kobo.517.1"> is </span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.518.1">deduced as </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">A</span></strong><span class="koboSpan" id="kobo.520.1">. </span><span class="koboSpan" id="kobo.520.2">But now, let’s call </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">f()</span></strong><span class="koboSpan" id="kobo.522.1"> with a pointer to a </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">different type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.524.1">
int i;
f(&amp;i);    // 1</span></pre>
<p><span class="koboSpan" id="kobo.525.1">The first overload still works fine and is what we want to call. </span><span class="koboSpan" id="kobo.525.2">But the second overload isn’t just less suitable, it is altogether invalid - it would cause a syntax error if we tried to substitute </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">int</span></strong><span class="koboSpan" id="kobo.527.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">T</span></strong><span class="koboSpan" id="kobo.529.1">. </span><span class="koboSpan" id="kobo.529.2">This syntax error is observed by the compiler and silently ignored, together with the </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">overload itself.</span></span></p>
<p><span class="koboSpan" id="kobo.531.1">Note that the SFINAE rule is not limited to invalid types, such as references to non-existing class members. </span><span class="koboSpan" id="kobo.531.2">There are many ways in which substitution </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">can fail:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.533.1">
// Example 12
template &lt;size_t N&gt;
void f(char(*)[N % 2] = nullptr) {    // 1
  std::cout &lt;&lt; “N=” &lt;&lt; N &lt;&lt; “ is odd” &lt;&lt; std::endl;
}
template &lt;size_t N&gt;
void f(char(*)[1 - N % 2] = nullptr) { // 2
  std::cout &lt;&lt; “N=” &lt;&lt; N &lt;</span><a id="_idTextAnchor344"/><span class="koboSpan" id="kobo.534.1">&lt; “ is even” &lt;&lt; std::endl;
}
f&lt;5&gt;();
f&lt;8&gt;();</span></pre>
<p><span class="koboSpan" id="kobo.535.1">Here, the template parameter is a value, not a type. </span><span class="koboSpan" id="kobo.535.2">We have two template overloads that both take a pointer to an array of characters, and array size expressions are valid only for some values of </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">N</span></strong><span class="koboSpan" id="kobo.537.1">. </span><span class="koboSpan" id="kobo.537.2">Specifically, a zero-size array is invalid in C++. </span><span class="koboSpan" id="kobo.537.3">Therefore, the first overload is valid only if </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">N</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.539.1">%</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.540.1">2</span></strong><span class="koboSpan" id="kobo.541.1"> is non-zero, that is, if </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">N</span></strong><span class="koboSpan" id="kobo.543.1"> is odd. </span><span class="koboSpan" id="kobo.543.2">Similarly, the second overload is valid only if </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">N</span></strong><span class="koboSpan" id="kobo.545.1"> is even. </span><span class="koboSpan" id="kobo.545.2">No arguments are given to the function, so we intend to use the default arguments. </span><span class="koboSpan" id="kobo.545.3">The two overloads would have been ambiguous in every way, were it not for the fact that, for both calls, one of the overloads fails during template argument substitution and is </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">silently removed.</span></span></p>
<p><span class="koboSpan" id="kobo.547.1">The preceding example is very condensed - in particular, the template parameter value deduction, the equivalent of type deduction for numeric parameters is disabled by the explicit</span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.548.1"> specification. </span><span class="koboSpan" id="kobo.548.2">We can bring the deduction back and still have the substitution fail, or not, depending on whether an expression </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">is valid:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.550.1">
// Example 13
template &lt;typename T, size_t N = T::N&gt;
void f(T t, char(*)[N % 2] = NULL) {
  std::cout &lt;&lt; “N=” &lt;&lt; N &lt;&lt; “ is odd” &lt;&lt; std::endl;
}
template &lt;typename T, size_t N = T::N&gt;
void f(T t, char(*)[1 - N % 2] = NULL) {
  std::cout &lt;&lt; “N=” &lt;&lt; N &lt;&lt; “ is even” &lt;&lt; std::endl;
}
struct A { enum {N = 5}; };
struct B { enum {N = 8}; };
A a;
B b;
f(a);
f(b);</span></pre>
<p><span class="koboSpan" id="kobo.551.1">Now, the compiler has to deduce the type from the first argument. </span><span class="koboSpan" id="kobo.551.2">For the first call, </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">f(a)</span></strong><span class="koboSpan" id="kobo.553.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">A</span></strong><span class="koboSpan" id="kobo.555.1"> type is easily deduced. </span><span class="koboSpan" id="kobo.555.2">There is no way to deduce the second template parameter, </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">N</span></strong><span class="koboSpan" id="kobo.557.1">, so the default value is used (we are now in C++11 territory). </span><span class="koboSpan" id="kobo.557.2">Having deduced both template parameters, we now proceed to the substitution, where </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">T</span></strong><span class="koboSpan" id="kobo.559.1"> is replaced by </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">A</span></strong><span class="koboSpan" id="kobo.561.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">N</span></strong><span class="koboSpan" id="kobo.563.1"> is replaced by </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">5</span></strong><span class="koboSpan" id="kobo.565.1">. </span><span class="koboSpan" id="kobo.565.2">This substitution fails for the second overload but succeeds for the first one. </span><span class="koboSpan" id="kobo.565.3">With only one remaining candidate in the overload set, the overload resolution concludes. </span><span class="koboSpan" id="kobo.565.4">Similarly, the second call, </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">f(b)</span></strong><span class="koboSpan" id="kobo.567.1">, ends up calling the </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">second overload.</span></span></p>
<p><span class="koboSpan" id="kobo.569.1">Note that there is a subtle but very important difference between the preceding example and the earlier example where we had </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">this function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.571.1">
template &lt;typename T&gt; void f(T i, typename T::t&amp; j);</span></pre>
<p><span class="koboSpan" id="kobo.572.1">In this template, the substitution failure is “</span><em class="italic"><span class="koboSpan" id="kobo.573.1">natural:</span></em><span class="koboSpan" id="kobo.574.1">” the parameter that may cause the failure is needed and is intended to be of a pointer to member type. </span><span class="koboSpan" id="kobo.574.2">In the previous case, the template parameter </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">N</span></strong><span class="koboSpan" id="kobo.576.1"> is gratuitous: it is not needed for anything other than artificially causing substitution failures and disabling some overloads. </span><span class="koboSpan" id="kobo.576.2">Why would you ever want to </span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.577.1">cause an artificial substitution failure? </span><span class="koboSpan" id="kobo.577.2">We have seen one reason, forcing the selection of otherwise ambiguous overloads. </span><span class="koboSpan" id="kobo.577.3">The more general reason has to do with the fact that type substitution sometimes can lead </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">to errors.</span></span></p>
<h2 id="_idParaDest-128"><span class="koboSpan" id="kobo.579.1">When substitu</span><a id="_idTextAnchor345"/><span class="koboSpan" id="kobo.580.1">tion failure is still an error</span></h2>
<p><span class="koboSpan" id="kobo.581.1">Note that SFINAE does</span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.582.1"> not protect us from any and all syntax errors that might happen during template instantiation. </span><span class="koboSpan" id="kobo.582.2">For example, if the template parameters are deduced, and the template arguments are substituted, we may still end up with an ill-formed </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">template function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.584.1">
// Example 14
template &lt;typename T&gt; void f(T) {
  std::cout &lt;&lt; sizeof(T::i) &lt;&lt; std::endl;
}
void f(...) { std::cout &lt;&lt; “f(...)” &lt;&lt; std::endl; }
f(0);</span></pre>
<p><span class="koboSpan" id="kobo.585.1">This code fragment is very similar to those we considered earlier, with one exception - we do not learn that the template overload presupposes that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">T</span></strong><span class="koboSpan" id="kobo.587.1"> type is a class, and has a data member named </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">T::i</span></strong><span class="koboSpan" id="kobo.589.1">, until we examine the function body. </span><span class="koboSpan" id="kobo.589.2">By then, it is too late, as the overload resolution is done only on the basis of the function declaration - the parameters, the default arguments, and the return type (the latter is not used to deduce types or select a better overload, but still undergoes type substitution and is covered by SFINAE). </span><span class="koboSpan" id="kobo.589.3">Once the template is instantiated and chosen by the overload resolution, any syntax errors, such as an invalid expression in the body of the function, are not ignored - such a failure is very much an error. </span><span class="koboSpan" id="kobo.589.4">The exact list of contexts where a substitution failure is, or is not, ignored, is defined in the standard; it was significantly expanded in C++11, with subsequent standards making a few </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">subtle tweaks.</span></span></p>
<p><span class="koboSpan" id="kobo.591.1">There is another case</span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.592.1"> where an attempt to use SFINAE leads to an error instead. </span><span class="koboSpan" id="kobo.592.2">Here is </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.594.1">
// Example 15a
template &lt;typename T&gt; struct S {
  typename T::value_type f();
};</span></pre>
<p><span class="koboSpan" id="kobo.595.1">Here we have a class template. </span><span class="koboSpan" id="kobo.595.2">If the type </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">T</span></strong><span class="koboSpan" id="kobo.597.1"> does not have a nested type </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">value_type</span></strong><span class="koboSpan" id="kobo.599.1">, type substitution leads to an error, and this is a real error, it is not ignored. </span><span class="koboSpan" id="kobo.599.2">You can’t even instantiate this class template with a type that does not have </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">value_type</span></strong><span class="koboSpan" id="kobo.601.1">. </span><span class="koboSpan" id="kobo.601.2">Making the function into a template does not solve </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">the problem:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.603.1">
template &lt;typename T&gt; struct S {
  template &lt;typename U&gt; typename T::value_type f();
};</span></pre>
<p><span class="koboSpan" id="kobo.604.1">It is very important to remember that SFINAE applies only when the error occurs during the substitution of the types that were deduced for the template function. </span><span class="koboSpan" id="kobo.604.2">In the last example, the substitution error does not depend on the template type parameter </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">U</span></strong><span class="koboSpan" id="kobo.606.1">, so it is always going to be an error. </span><span class="koboSpan" id="kobo.606.2">If you really need to work around this, you have to use a member function template and use a template type parameter to trigger the substitution error. </span><span class="koboSpan" id="kobo.606.3">Since we do not need an additional template parameter, we can default it to be the same as the class template type </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">parameter </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">T</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.610.1">
// Example 15b
template &lt;typename T&gt; struct S {
  template &lt;typename U = T&gt;
  std::enable_if_t&lt;std::is_same_v&lt;U, T&gt;
  typename U::value_type f();
};</span></pre>
<p><span class="koboSpan" id="kobo.611.1">Now the substitution error, if any, will happen with a type dependent on the template type parameter </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">U::value_type</span></strong><span class="koboSpan" id="kobo.613.1">. </span><span class="koboSpan" id="kobo.613.2">We do not need to specify type </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">U</span></strong><span class="koboSpan" id="kobo.615.1"> since it is defaulted to </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">T</span></strong><span class="koboSpan" id="kobo.617.1">, and it can’t be anything else because of the requirement that types </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">U</span></strong><span class="koboSpan" id="kobo.619.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">T</span></strong><span class="koboSpan" id="kobo.621.1"> are the same (otherwise the return type of the function is invalid, which is a SFINAE error). </span><span class="koboSpan" id="kobo.621.2">Thus, our template member function </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">f()</span></strong><span class="koboSpan" id="kobo.623.1"> does (almost) exactly what the original non-template function </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">f()</span></strong><span class="koboSpan" id="kobo.625.1"> did (there are subtle differences if the function has overloads within the class). </span><span class="koboSpan" id="kobo.625.2">So, if you really need to “hide” a substitution error caused by a class template parameter, you can do so by introducing a redundant function template parameter and</span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.626.1"> restricting the two to always be </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">the same.</span></span></p>
<p><span class="koboSpan" id="kobo.628.1">Before continuing, let’s review the three kinds of substitution failures </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">we encountered.</span></span></p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor346"/><span class="koboSpan" id="kobo.630.1">Where and why does substitution failure happen?</span></h2>
<p><span class="koboSpan" id="kobo.631.1">To understand the rest </span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.632.1">of this chapter, it is essential that we clearly differentiate between several kinds of substitution failures that can occur in </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">template functions.</span></span></p>
<p><span class="koboSpan" id="kobo.634.1">The first kind happens when the template declaration uses dependent types or other constructs that can cause a failure, and their use is necessary to declare the template properly. </span><span class="koboSpan" id="kobo.634.2">Here is a template function that is intended to be called with a container argument (all STL containers have a nested </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">type </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">value_type</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.638.1">
// Example 16
template &lt;typename T&gt;
bool find(const T&amp; cont, typename T::value_type val);</span></pre>
<p><span class="koboSpan" id="kobo.639.1">If we try to call this function with an argument that does not define the nested type, </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">value_type</span></strong><span class="koboSpan" id="kobo.641.1">, the function call will not compile (assuming we have no other overloads). </span><span class="koboSpan" id="kobo.641.2">There are many more examples where we naturally use dependent types and other expressions that may be invalid for some values of template parameters. </span><span class="koboSpan" id="kobo.641.3">Such invalid expressions cause a substitution failure. </span><span class="koboSpan" id="kobo.641.4">It does not have to happen in the argument declaration. </span><span class="koboSpan" id="kobo.641.5">Here is a template whose return type may </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">be undefined:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.643.1">
// Example 16
template &lt;typename U, typename V&gt;
std::common_type_t&lt;U, V&gt; compute(U u, V v);</span></pre>
<p><span class="koboSpan" id="kobo.644.1">In this template, the return type is the common type of the two template parameter types. </span><span class="koboSpan" id="kobo.644.2">But what if the template arguments are such that the types </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">U</span></strong><span class="koboSpan" id="kobo.646.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">V</span></strong><span class="koboSpan" id="kobo.648.1"> have no common type? </span><span class="koboSpan" id="kobo.648.2">Then the type expression </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">std::common_type_t&lt;U, V&gt;</span></strong><span class="koboSpan" id="kobo.650.1"> is invalid and the type substitution fails. </span><span class="koboSpan" id="kobo.650.2">Here is yet </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">another example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.652.1">
// Example 15
template &lt;typename T&gt;
auto process(T p) -&gt; decltype(*p);</span></pre>
<p><span class="koboSpan" id="kobo.653.1">Here, again, the</span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.654.1"> substitution failure may occur in the return type, but we use the trailing return type so that we can directly check whether the expression </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">*p</span></strong><span class="koboSpan" id="kobo.656.1"> compiles (or, more formally, is valid). </span><span class="koboSpan" id="kobo.656.2">If it is, the type of the result is the return type. </span><span class="koboSpan" id="kobo.656.3">Otherwise, the substitution fails. </span><span class="koboSpan" id="kobo.656.4">Note that there is a difference between this declaration and something </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.658.1">
template &lt;typename T&gt; T process(T* p);</span></pre>
<p><span class="koboSpan" id="kobo.659.1">If the function argument is a raw pointer, both versions amount to the same thing. </span><span class="koboSpan" id="kobo.659.2">But the first variant also compiles for any type that can be dereferenced, such as container iterators and smart pointers, while the second version works only for </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">raw pointers.</span></span></p>
<p><span class="koboSpan" id="kobo.661.1">The second kind of substitution failure happens when the function declaration compiles successfully, including the type substitution, and then we get a syntax error in the function body. </span><span class="koboSpan" id="kobo.661.2">We can easily modify each of these examples to see how this might have happened. </span><span class="koboSpan" id="kobo.661.3">Let’s start with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">find()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.663.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.664.1">
// Example 17
template &lt;typename T, typename V&gt;
bool find(const T&amp; cont, V val) {
  for (typename T::value_type x : cont) {
    if (x == val) return true;
  }
  return false;
}</span></pre>
<p><span class="koboSpan" id="kobo.665.1">This time, we decided to accept a value of any type. </span><span class="koboSpan" id="kobo.665.2">This is not necessarily wrong in itself, but the body of our template function is written in the assumption that the container type </span><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">T</span></strong><span class="koboSpan" id="kobo.667.1"> has the nested type </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">value_type</span></strong><span class="koboSpan" id="kobo.669.1"> and that this type is comparable with the type </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">V</span></strong><span class="koboSpan" id="kobo.671.1">. </span><span class="koboSpan" id="kobo.671.2">If we call the function with a wrong argument, the call will still compile because nothing particular is required of the argument types by the substitution that happens in the declaration of the template. </span><span class="koboSpan" id="kobo.671.3">But then we get a syntax error in the body of the template itself, rather than at the </span><span class="No-Break"><span class="koboSpan" id="kobo.672.1">call site.</span></span></p>
<p><span class="koboSpan" id="kobo.673.1">Here is how a similar</span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.674.1"> thing can happen with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">compute()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.676.1"> template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.677.1">
// Example 17
template &lt;typename U, typename V&gt;
auto compute(U u, V v) {
  std::common_type_t&lt;U, V&gt; res = (u &gt; v) ? </span><span class="koboSpan" id="kobo.677.2">u : v;
  return res;
}</span></pre>
<p><span class="koboSpan" id="kobo.678.1">This template function can be called for any two arguments, but then it won’t compile unless there is a common type </span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">for both.</span></span></p>
<p><span class="koboSpan" id="kobo.680.1">Note the very significant difference between the two kinds of substitution failures: if the failure happens in SFINAE context, the function is removed from the overload resolution as if it does not exist. </span><span class="koboSpan" id="kobo.680.2">If there is another overload (a function with the same name), it will be considered and may end up being called. </span><span class="koboSpan" id="kobo.680.3">If there is not, we will get a syntax error at the call site that boils down to “there is no such function.” </span><span class="koboSpan" id="kobo.680.4">On the other hand, if the failure happens in the body of the template (or in some other place not covered by SFINAE rules) then, assuming the function is the best, or the only, overload, it will be called. </span><span class="koboSpan" id="kobo.680.5">The client’s code – the call itself – will compile fine, but the template </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">will not.</span></span></p>
<p><span class="koboSpan" id="kobo.682.1">There are several reasons why the first option is preferable. </span><span class="koboSpan" id="kobo.682.2">First of all, the caller may have wanted to call a different overload, the one that would have compiled fine, but the rules for overload resolution among templates are complex and the wrong overload was chosen. </span><span class="koboSpan" id="kobo.682.3">It may be very difficult for the caller to fix this error and force the choice of the intended overload. </span><span class="koboSpan" id="kobo.682.4">Second, the error messages you get when the body of the template fails compilation are often incomprehensible. </span><span class="koboSpan" id="kobo.682.5">Our examples were simple, but in a more realistic case, you may see an error that involves some internal types and objects that you know nothing about. </span><span class="koboSpan" id="kobo.682.6">The last reason is more of a conceptual statement: the interface of the template function, like any other interface, should describe the requirements on the caller as completely as possible. </span><span class="koboSpan" id="kobo.682.7">An interface is a contract; if the caller has complied with it, the implementer of the function must deliver </span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">as promised.</span></span></p>
<p><span class="koboSpan" id="kobo.684.1">Let’s assume that we have a template function whose body has some requirements on the type parameters and that these requirements are not captured by the interface written in a natural, straightforward way (the type substitution succeeds but the template does not compile). </span><span class="koboSpan" id="kobo.684.2">The only way to convert the hard substitution failure into an SFINAE failure is to make it happen in SFINAE context. </span><span class="koboSpan" id="kobo.684.3">To do this, we need to add something to the interface that is not necessary to declare the function. </span><span class="koboSpan" id="kobo.684.4">The only purpose of this </span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.685.1">addition is to trigger a substitution failure and remove the function from the overload resolution set before it could lead to a compilation error in the body of the function. </span><span class="koboSpan" id="kobo.685.2">Such “artificial” failure is the third kind of substitution failure. </span><span class="koboSpan" id="kobo.685.3">Here is an example where we enforce the requirement that the types are pointers even though the interface itself would be just fine </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">without it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.687.1">
// Example 18
template &lt;typename U, typename V&gt;
auto compare(U pu, V pv) -&gt; decltype(bool(*pu == *pv)) {
  return *pu &lt; *pv;
}</span></pre>
<p><span class="koboSpan" id="kobo.688.1">This function takes two pointers (or any other pointer-like objects that can be dereferenced) and returns the Boolean result of comparing the values they point to. </span><span class="koboSpan" id="kobo.688.2">In order for the body of the function to compile, both arguments must be something that can be dereferenced. </span><span class="koboSpan" id="kobo.688.3">Furthermore, the results of dereferencing them must be comparable for equality. </span><span class="koboSpan" id="kobo.688.4">Finally, the result of the comparison must be convertible to bool. </span><span class="koboSpan" id="kobo.688.5">The trailing return type declaration is unnecessary: we could have just declared the function to return </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">bool</span></strong><span class="koboSpan" id="kobo.690.1">. </span><span class="koboSpan" id="kobo.690.2">But it does have an effect: it moves a possible substitution failure from the body of the function to its declaration, where it becomes an SFINAE failure. </span><span class="koboSpan" id="kobo.690.3">The return type is always </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">bool</span></strong><span class="koboSpan" id="kobo.692.1"> unless the expression inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">decltype()</span></strong><span class="koboSpan" id="kobo.694.1"> is invalid. </span><span class="koboSpan" id="kobo.694.2">That could happen for any of the same reasons the function body would not compile: one of the arguments cannot be dereferenced, the values are not comparable, or the result of the comparison is not convertible to </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">bool</span></strong><span class="koboSpan" id="kobo.696.1"> (the latter is usually redundant, but we might as well enforce the </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">entire contract).</span></span></p>
<p><span class="koboSpan" id="kobo.698.1">Notice that the line between the “natural” and “artificial” substitution failures is not always clear. </span><span class="koboSpan" id="kobo.698.2">For example, one could have argued that using </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">std::common_type_t&lt;U, V&gt;</span></strong><span class="koboSpan" id="kobo.700.1"> as the return type earlier was artificial (the third kind of substitution failure, not the first kind) and that the “natural” way would be to declare the return type as </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">auto</span></strong><span class="koboSpan" id="kobo.702.1"> and let the function body fail if the common type could not be deduced. </span><span class="koboSpan" id="kobo.702.2">Indeed, the difference often boils down to the programmer’s style and intent: if it wasn’t for the need to enforce the type restriction, would the programmer have written the type expression in the template </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">declaration anyway?</span></span></p>
<p><span class="koboSpan" id="kobo.704.1">The failures of the first kind are straightforward: the template interface itself forms a contract, the attempted call violated the contract, and the function wasn’t called. </span><span class="koboSpan" id="kobo.704.2">The failures of the second kind are, ideally, to be avoided altogether. </span><span class="koboSpan" id="kobo.704.3">But to do that, we have to employ the failures of the third kind, the artificial substitution failures in SFINAE context. </span><span class="koboSpan" id="kobo.704.4">The rest of this chapter deals with the ways to code such interface-limiting template contracts. </span><span class="koboSpan" id="kobo.704.5">Since the first days of C++, SFINAE techniques were used to artificially cause a</span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.705.1"> substitution failure that would remove such functions from the overload set. </span><span class="koboSpan" id="kobo.705.2">C++20 added a totally different mechanism for solving this problem: concepts. </span><span class="koboSpan" id="kobo.705.3">Before we discuss controlling overload resolution with SFINAE, we need to learn more about</span><a id="_idTextAnchor347"/><span class="koboSpan" id="kobo.706.1"> this latest addition to </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">the language.</span></span></p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor348"/><span class="koboSpan" id="kobo.708.1">Concepts and constraints in C++20</span></h1>
<p><span class="koboSpan" id="kobo.709.1">The rest of this chapter is all about the “artificial” substitution failures that are added to the template declaration to impose restrictions on the template arguments. </span><span class="koboSpan" id="kobo.709.2">In this section, we are going to learn about the new, C++20, way of coding these restrictions. </span><span class="koboSpan" id="kobo.709.3">In the next section, we will show what you can do if you can’t use C++20 but still want to constrain </span><span class="No-Break"><span class="koboSpan" id="kobo.710.1">your templates.</span></span></p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor349"/><span class="koboSpan" id="kobo.711.1">Constraints in C++20</span></h2>
<p><span class="koboSpan" id="kobo.712.1">C++20 changed the</span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.713.1"> way we are using SFINAE to restrict template arguments by introducing concepts and constraints. </span><span class="koboSpan" id="kobo.713.2">Even though the overall feature is usually referred to as “concepts,” it is the constraints that are the most important part. </span><span class="koboSpan" id="kobo.713.3">What follows is not a complete or formal description of these features, but rather a demonstration of the best practices (it may be too early to say “patterns” since the community is still in the process of establishing what is and isn’t sufficiently </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">widely accepted).</span></span></p>
<p><span class="koboSpan" id="kobo.715.1">The first way to specify a constraint is by writing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">requires</span></strong><span class="koboSpan" id="kobo.717.1"> clause that has </span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">the form:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.719.1">
requires(constant-boolean-expression)</span></pre>
<p><span class="koboSpan" id="kobo.720.1">The keyword </span><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">requires</span></strong><span class="koboSpan" id="kobo.722.1"> and the constant (compile-time) expression in parentheses must appear either immediately after the template parameters or as the last element of the </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">function declaration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.724.1">
// Example 19
template &lt;typename T&gt; requires(sizeof(T) == 8) void f();
template &lt;typename T&gt; void g(T p) requires(sizeof(*p) &lt; 8);</span></pre>
<p><span class="koboSpan" id="kobo.725.1">Just like in the last section, the constraint written at the end of the declaration can refer to the function arguments by name, while the constraint written after the parameter list can refer only to the template parameters (other, more subtle differences between the two syntaxes are outside of the scope of this chapter). </span><span class="koboSpan" id="kobo.725.2">Unlike the last section, if a constraint fails, the compiler usually issues a clear diagnostic instead of simply reporting that “no function f was found” and template </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">deduction failed.</span></span></p>
<p><span class="koboSpan" id="kobo.727.1">What can be used in the constant expression in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">requires</span></strong><span class="koboSpan" id="kobo.729.1"> clause? </span><span class="koboSpan" id="kobo.729.2">Anything that can be computed at compile time, really, as long as the overall result is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">bool</span></strong><span class="koboSpan" id="kobo.731.1">. </span><span class="koboSpan" id="kobo.731.2">Type traits such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">std::is_convertible_v</span></strong><span class="koboSpan" id="kobo.733.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">std::is_default_constructible_v</span></strong><span class="koboSpan" id="kobo.735.1"> are often used to restrict types. </span><span class="koboSpan" id="kobo.735.2">If the expressions are complex, </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">constexpr</span></strong><span class="koboSpan" id="kobo.737.1"> functions can help to </span><span class="No-Break"><span class="koboSpan" id="kobo.738.1">simplify them:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.739.1">
template &lt;typename V&gt; constexpr bool valid_type() {
  return sizeof(T) == 8 &amp;&amp; alignof(T) == 8 &amp;&amp;
    std::is_default_constructible_v&lt;T&gt;;
}
template &lt;typename T&gt; requires(valid_type&lt;T&gt;()) void f();</span></pre>
<p><span class="koboSpan" id="kobo.740.1">But there is one special expression that we have not seen before – the </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">requires</span></strong><span class="koboSpan" id="kobo.742.1"> expression. </span><span class="koboSpan" id="kobo.742.2">This expression can be used to check if some arbitrary expression compiles (technically, it “</span><span class="No-Break"><span class="koboSpan" id="kobo.743.1">is valid”):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.744.1">
requires { a + b; }</span></pre>
<p><span class="koboSpan" id="kobo.745.1">Assuming the values </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">a</span></strong><span class="koboSpan" id="kobo.747.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">b</span></strong><span class="koboSpan" id="kobo.749.1"> are defined in the context where the expression is used, this expression evaluates to </span><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">true</span></strong><span class="koboSpan" id="kobo.751.1"> if the expression </span><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">a + b</span></strong><span class="koboSpan" id="kobo.753.1"> is valid. </span><span class="koboSpan" id="kobo.753.2">What if we know the types we want to test but don’t have the variables? </span><span class="koboSpan" id="kobo.753.3">Then we can use the second form of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">requires</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.755.1"> expression:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.756.1">
requires(A a, B b) { a + b; }</span></pre>
<p><span class="koboSpan" id="kobo.757.1">The types </span><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">A</span></strong><span class="koboSpan" id="kobo.759.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">B</span></strong><span class="koboSpan" id="kobo.761.1"> usually refer to the template parameters or some </span><span class="No-Break"><span class="koboSpan" id="kobo.762.1">dependent types.</span></span></p>
<p><span class="koboSpan" id="kobo.763.1">Note that we said “arbitrary expression is valid” and not “arbitrary code is valid.” </span><span class="koboSpan" id="kobo.763.2">This is an important difference. </span><span class="koboSpan" id="kobo.763.3">For example, you </span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">can’t write</span></span><a id="_idIndexMarker350"/></p>
<pre class="source-code"><span class="koboSpan" id="kobo.765.1">
requires(C cont) { for (auto x: cont) {}; }</span></pre>
<p><span class="koboSpan" id="kobo.766.1">And require that the type </span><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">C</span></strong><span class="koboSpan" id="kobo.768.1"> meets all requirements for a range-for loop. </span><span class="koboSpan" id="kobo.768.2">Most of the time, you test expressions such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">cont.begin()</span></strong><span class="koboSpan" id="kobo.770.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">cont.end()</span></strong><span class="koboSpan" id="kobo.772.1"> instead. </span><span class="koboSpan" id="kobo.772.2">However, you can also come up with a more complex requirement by hiding the code in a </span><span class="No-Break"><span class="koboSpan" id="kobo.773.1">lambda expression:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.774.1">
requires(C cont) {
  [](auto&amp;&amp; c) {
    for (auto x: cont) { return x; };
  }(cont);
}</span></pre>
<p><span class="koboSpan" id="kobo.775.1">Woe is you if such code ever fails and you have to figure out the </span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">error message.</span></span></p>
<p><span class="koboSpan" id="kobo.777.1">When a </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">requires</span></strong><span class="koboSpan" id="kobo.779.1"> expression is used in a template constraint, the template is restricted not by a specific trait but by the required behavior of </span><span class="No-Break"><span class="koboSpan" id="kobo.780.1">the types:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.781.1">
// Example 20
template &lt;typename T, typename P&gt;
void f(T i, P p) requires( requires { i = *p; } );
template &lt;typename T, typename P&gt;
void f(T i, P p) requires( requires { i.*p; } );</span></pre>
<p><span class="koboSpan" id="kobo.782.1">First of all, yes, there are two keywords </span><strong class="source-inline"><span class="koboSpan" id="kobo.783.1">requires</span></strong><span class="koboSpan" id="kobo.784.1"> (by the way, parentheses are optional in this case and you can find this constraint written as </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">requires requires</span></strong><span class="koboSpan" id="kobo.786.1"> ). </span><span class="koboSpan" id="kobo.786.2">The first </span><strong class="source-inline"><span class="koboSpan" id="kobo.787.1">requires</span></strong><span class="koboSpan" id="kobo.788.1"> introduces a constraint, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.789.1">requires</span></strong><span class="koboSpan" id="kobo.790.1"> clause. </span><span class="koboSpan" id="kobo.790.2">The second </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">requires</span></strong><span class="koboSpan" id="kobo.792.1"> begins the </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">requires</span></strong><span class="koboSpan" id="kobo.794.1"> expression. </span><span class="koboSpan" id="kobo.794.2">The expression in the first function </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">f()</span></strong><span class="koboSpan" id="kobo.796.1"> is valid if the second template argument </span><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">p</span></strong><span class="koboSpan" id="kobo.798.1"> can be dereferenced (it can be a pointer, but it doesn’t have to be) and the result can be assigned to the first argument </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">i</span></strong><span class="koboSpan" id="kobo.800.1">. </span><span class="koboSpan" id="kobo.800.2">We don’t require that the types on both sides of the assignment be the same or even that </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">*p</span></strong><span class="koboSpan" id="kobo.802.1"> can be convertible to </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">T</span></strong><span class="koboSpan" id="kobo.804.1"> (usually it would be, but it’s not required). </span><span class="koboSpan" id="kobo.804.2">We just need the expression </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">i = *p</span></strong><span class="koboSpan" id="kobo.806.1"> to compile. </span><span class="koboSpan" id="kobo.806.2">Finally, if we did not have the right variables readily available, we could have declared them as parameters to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">requires</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.808.1"> expression:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.809.1">
// Example 20
template &lt;typename T, typename P&gt;
requires(requires(T t, P p) { t = *p; }) void f(T i, P p);
template &lt;typename T, typename P&gt;
requires(requires(T t, P p) { t.*p; }) void f(T i, P p);</span></pre>
<p><span class="koboSpan" id="kobo.810.1">These two examples </span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.811.1">also demonstrate that we can do SFINAE overload control with constraints: if a constraint fails, the template function is removed from the overload resolution set and the </span><span class="No-Break"><span class="koboSpan" id="kobo.812.1">resolution continues.</span></span></p>
<p><span class="koboSpan" id="kobo.813.1">As we have seen already, sometimes we need to check not an expression but a dependent type; we can do that inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">requires</span></strong><span class="koboSpan" id="kobo.815.1"> expression </span><span class="No-Break"><span class="koboSpan" id="kobo.816.1">as well:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.817.1">
requires { typename T::value_type; }</span></pre>
<p><span class="koboSpan" id="kobo.818.1">A requires expression evaluates to bool, so it can be used in a </span><span class="No-Break"><span class="koboSpan" id="kobo.819.1">logical expression:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.820.1">
requires(
  requires { typename T::value_type; } &amp;&amp;
  sizeof(T) &lt;= 32
)</span></pre>
<p><span class="koboSpan" id="kobo.821.1">We could combine multiple requires expressions this way, but we can also write more code inside a </span><span class="No-Break"><span class="koboSpan" id="kobo.822.1">single expression:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.823.1">
requires(T t) { typename T::value_type; t[0]; }</span></pre>
<p><span class="koboSpan" id="kobo.824.1">Here we require that the type </span><strong class="source-inline"><span class="koboSpan" id="kobo.825.1">T</span></strong><span class="koboSpan" id="kobo.826.1"> has a nested type </span><strong class="source-inline"><span class="koboSpan" id="kobo.827.1">value_type</span></strong><span class="koboSpan" id="kobo.828.1"> and an index operator that accepts </span><span class="No-Break"><span class="koboSpan" id="kobo.829.1">integer indices.</span></span></p>
<p><span class="koboSpan" id="kobo.830.1">Finally, sometimes we need to check not just that some expression compiles but that its result has a certain type (or satisfies some type requirements). </span><span class="koboSpan" id="kobo.830.2">This can be done with the compound form of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">requires</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.832.1"> expression:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.833.1">
requires(T t) { { t + 1 } -&gt; std::same_as&lt;T&gt;; }</span></pre>
<p><span class="koboSpan" id="kobo.834.1">Here we require that the expression </span><strong class="source-inline"><span class="koboSpan" id="kobo.835.1">t + 1</span></strong><span class="koboSpan" id="kobo.836.1"> compiles and yields the result of the same type as the variable </span><strong class="source-inline"><span class="koboSpan" id="kobo.837.1">t</span></strong><span class="koboSpan" id="kobo.838.1"> itself. </span><span class="koboSpan" id="kobo.838.2">The last part is done using a concept; you will read about them in the next section, but for now, think of it as an alternative way to write the </span><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">std::is_same_v</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.840.1">type trait.</span></span></p>
<p><span class="koboSpan" id="kobo.841.1">Speaking of </span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.842.1">concepts… Everything we have described so far can be found under the heading of “concepts” in any C++20 book, except we have not mentioned the concepts themselves. </span><span class="koboSpan" id="kobo.842.2">That is about </span><span class="No-Break"><span class="koboSpan" id="kobo.843.1">to change.</span></span></p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor350"/><span class="koboSpan" id="kobo.844.1">Concepts in C++20</span></h2>
<p><span class="koboSpan" id="kobo.845.1">Concepts are simply </span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.846.1">a named set of requirements – the same requirements we were just learning about. </span><span class="koboSpan" id="kobo.846.2">In a way, they are similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">constexpr</span></strong><span class="koboSpan" id="kobo.848.1"> functions, except they operate on types, </span><span class="No-Break"><span class="koboSpan" id="kobo.849.1">not values.</span></span></p>
<p><span class="koboSpan" id="kobo.850.1">You use a concept when there is a set of requirements that you refer to often, or one that you want to give a meaningful name to. </span><span class="koboSpan" id="kobo.850.2">For example, a range is defined by a very simple requirement: it must have a begin iterator and an end iterator. </span><span class="koboSpan" id="kobo.850.3">We can write a simple requires expression every time we declare a function template that accepts a range argument, but it is both more convenient and more readable to give this requirement </span><span class="No-Break"><span class="koboSpan" id="kobo.851.1">a name:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.852.1">
// Example 21
template &lt;typename R&gt; concept Range = requires(R r) {
  std::begin(r);
  std::end(r);
};</span></pre>
<p><span class="koboSpan" id="kobo.853.1">We have just introduced a concept named </span><strong class="source-inline"><span class="koboSpan" id="kobo.854.1">Range</span></strong><span class="koboSpan" id="kobo.855.1"> with one template type parameter </span><strong class="source-inline"><span class="koboSpan" id="kobo.856.1">R</span></strong><span class="koboSpan" id="kobo.857.1">; this type must have begin and end iterators (the reason we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.858.1">std::begin()</span></strong><span class="koboSpan" id="kobo.859.1"> instead of the member function </span><strong class="source-inline"><span class="koboSpan" id="kobo.860.1">begin()</span></strong><span class="koboSpan" id="kobo.861.1"> is that C arrays are also ranges but they have no </span><span class="No-Break"><span class="koboSpan" id="kobo.862.1">member functions).</span></span></p>
<p><span class="koboSpan" id="kobo.863.1">Note that C++20 has a ranges library and a corresponding set of concepts (including </span><strong class="source-inline"><span class="koboSpan" id="kobo.864.1">std::ranges::range</span></strong><span class="koboSpan" id="kobo.865.1"> that should be used instead of our homemade </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">Range</span></strong><span class="koboSpan" id="kobo.867.1"> in any real code) but the idea of ranges makes for convenient teaching material and we will use it to drive </span><span class="No-Break"><span class="koboSpan" id="kobo.868.1">the examples.</span></span></p>
<p><span class="koboSpan" id="kobo.869.1">Once we have a named concept, we can use it instead of spelling out the requirements in any </span><span class="No-Break"><span class="koboSpan" id="kobo.870.1">template constraint:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.871.1">
// Example 21
template &lt;typename R&gt; requires(Range&lt;R&gt;) void sort(R&amp;&amp; r);</span></pre>
<p><span class="koboSpan" id="kobo.872.1">As you can see, the concept can be used inside a </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">requires</span></strong><span class="koboSpan" id="kobo.874.1"> clause as if it was a </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">constexpr</span></strong><span class="koboSpan" id="kobo.876.1"> variable of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.877.1">bool</span></strong><span class="koboSpan" id="kobo.878.1">. </span><span class="koboSpan" id="kobo.878.2">Indeed, a concept can also be used in contexts such as </span><span class="No-Break"><span class="koboSpan" id="kobo.879.1">static assert:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.880.1">
static_assert(Range&lt;std::vector&lt;int&gt;&gt;);
static_assert(!Range&lt;int&gt;);</span></pre>
<p><span class="koboSpan" id="kobo.881.1">For simple template </span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.882.1">declarations where the concept is the whole requirement, the language provides a much simpler way to </span><span class="No-Break"><span class="koboSpan" id="kobo.883.1">state it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.884.1">
// Example 21
template &lt;Range R&gt; void sort(R&amp;&amp; r);</span></pre>
<p><span class="koboSpan" id="kobo.885.1">In other words, the concept name can be used instead of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.886.1">typename</span></strong><span class="koboSpan" id="kobo.887.1"> keyword in a template declaration. </span><span class="koboSpan" id="kobo.887.2">Doing so automatically restricts the corresponding type parameter to types that satisfy the concept. </span><span class="koboSpan" id="kobo.887.3">If necessary, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.888.1">requires</span></strong><span class="koboSpan" id="kobo.889.1"> clause can still be used to define additional constraints. </span><span class="koboSpan" id="kobo.889.2">Finally, the concepts can also be used with the new C++20 </span><span class="No-Break"><span class="koboSpan" id="kobo.890.1">template syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.891.1">
// Example 21
void sort(Range auto&amp;&amp; r);</span></pre>
<p><span class="koboSpan" id="kobo.892.1">All three</span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.893.1"> declarations have the same effect and the choice is largely a matter of style </span><span class="No-Break"><span class="koboSpan" id="kobo.894.1">and convenience.</span></span></p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor351"/><span class="koboSpan" id="kobo.895.1">Concepts and type restrictions</span></h2>
<p><span class="koboSpan" id="kobo.896.1">We have already </span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.897.1">seen how concepts and constraints are used to impose restrictions </span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.898.1">on the parameters of function templates. </span><span class="koboSpan" id="kobo.898.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">requires</span></strong><span class="koboSpan" id="kobo.900.1"> clauses can appear after the template parameters or at the end of the function declaration; both places are SFINAE contexts and a substitution failure in either location does not stop the compilation of the entire program. </span><span class="koboSpan" id="kobo.900.2">In this regard, concepts are not fundamentally different from substitution failures: while you can use a constraint outside of an SFINAE context, a substitution failure would still be an error. </span><span class="koboSpan" id="kobo.900.3">For example, you cannot assert that a type does not have a nested type </span><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">value_type</span></strong><span class="koboSpan" id="kobo.902.1"> by using </span><span class="No-Break"><span class="koboSpan" id="kobo.903.1">a constraint:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.904.1">
static_assert(!requires{ typename T::value_type; });</span></pre>
<p><span class="koboSpan" id="kobo.905.1">You may expect that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.906.1">requires</span></strong><span class="koboSpan" id="kobo.907.1"> expression evaluates to false if the requirement is not met, but in this case, it simply does not compile (you get the error that </span><strong class="source-inline"><span class="koboSpan" id="kobo.908.1">T::value_type</span></strong><span class="koboSpan" id="kobo.909.1"> does not refer to a </span><span class="No-Break"><span class="koboSpan" id="kobo.910.1">valid type).</span></span></p>
<p><span class="koboSpan" id="kobo.911.1">However, there are restrictions you can enforce with concepts that were impossible to implement before. </span><span class="koboSpan" id="kobo.911.2">These are requirements for class templates. </span><span class="koboSpan" id="kobo.911.3">In the simplest form, we can use a concept to restrict class template </span><span class="No-Break"><span class="koboSpan" id="kobo.912.1">type parameters:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.913.1">
// Example 21
template &lt;Range R&gt; class C { … };</span></pre>
<p><span class="koboSpan" id="kobo.914.1">This class template can only be instantiated with types that satisfy the </span><span class="No-Break"><span class="koboSpan" id="kobo.915.1">concept </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.916.1">Range</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.917.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.918.1">Then, we can constrain individual member functions, whether they are templates </span><span class="No-Break"><span class="koboSpan" id="kobo.919.1">or not:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.920.1">
// Example 21
template &lt;typename T&gt; struct holder {
  T&amp; value;
  holder(T&amp; t) : value(t) {}
  void sort() requires(Range&lt;T&gt;) {
    std::sort(std::begin(value), std::end(value));
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.921.1">Now the class template itself can be instantiated on any type. </span><span class="koboSpan" id="kobo.921.2">However, its interface includes a member function </span><strong class="source-inline"><span class="koboSpan" id="kobo.922.1">sort()</span></strong><span class="koboSpan" id="kobo.923.1"> only if the type satisfies the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.924.1">Range</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.925.1"> constraint.</span></span></p>
<p><span class="koboSpan" id="kobo.926.1">This is a very important difference between constraints and the old SFINAE: the artificial substitution failure helps only if it happens when substituting deduced type parameters in function templates. </span><span class="koboSpan" id="kobo.926.2">Earlier in this chapter, we had to add a dummy template type parameter to a member function just so we could create an SFINAE failure. </span><span class="koboSpan" id="kobo.926.3">With concepts, there is no need for any </span><span class="No-Break"><span class="koboSpan" id="kobo.927.1">of that.</span></span></p>
<p><span class="koboSpan" id="kobo.928.1">Concepts and constraints are the best way to specify restrictions on template parameters. </span><span class="koboSpan" id="kobo.928.2">They make a lot of the SFINAE tricks invented over the years obsolete. </span><span class="koboSpan" id="kobo.928.3">But not </span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.929.1">everyone has access to C++20 yet. </span><span class="koboSpan" id="kobo.929.2">Also, some of the SFINAE </span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.930.1">techniques are still used even with concepts. </span><span class="koboSpan" id="kobo.930.2">In the last section, we will learn about these techniques as well as see what can be done if you do not have C++20 but still want to constraint </span><span class="No-Break"><span class="koboSpan" id="kobo.931.1">template types.</span></span></p>
<h1 id="_idParaDest-134"><a id="_idTextAnchor352"/><span class="koboSpan" id="kobo.932.1">SFINAE techniques</span></h1>
<p><span class="koboSpan" id="kobo.933.1">The rule that a</span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.934.1"> failure of the template argument substitution is not an error - the SFINAE rule - had to be added to the language simply to make certain narrowly defined template functions possible. </span><span class="koboSpan" id="kobo.934.2">But the ingenuity of a C++ programmer knows no bounds, and so SFINAE was repurposed and exploited to manually control the overload set by intentionally causing substitution failures. </span><span class="koboSpan" id="kobo.934.3">A huge variety of SFINAE-based techniques were invented over the years until the C++20 concepts made most of </span><span class="No-Break"><span class="koboSpan" id="kobo.935.1">them obsolete.</span></span></p>
<p><span class="koboSpan" id="kobo.936.1">Still, some use of SFINAE remains even in C++20, and then there is the vast body of pre-C++20 code that you may need to read, understand, </span><span class="No-Break"><span class="koboSpan" id="kobo.937.1">and maintain.</span></span></p>
<p><span class="koboSpan" id="kobo.938.1">Let’s start with the applications of SFINAE that are still useful even when concepts </span><span class="No-Break"><span class="koboSpan" id="kobo.939.1">are available.</span></span></p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor353"/><span class="koboSpan" id="kobo.940.1">SFINAE in C++20</span></h2>
<p><span class="koboSpan" id="kobo.941.1">First of all, even </span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.942.1">in C++20, there are still “natural” type </span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.943.1">substitution failures. </span><span class="koboSpan" id="kobo.943.2">For example, you may want to write </span><span class="No-Break"><span class="koboSpan" id="kobo.944.1">this function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.945.1">
template &lt;typename T&gt; typename T::value_type f(T&amp;&amp; t);</span></pre>
<p><span class="koboSpan" id="kobo.946.1">This is still fine, assuming you really want to return a value of the type given by the nested </span><strong class="source-inline"><span class="koboSpan" id="kobo.947.1">value_type</span></strong><span class="koboSpan" id="kobo.948.1">. </span><span class="koboSpan" id="kobo.948.2">However, before you rush to answer “yes” you should examine closely what is the type you really want to return. </span><span class="koboSpan" id="kobo.948.3">What is the contract with the caller that you want to enforce? </span><span class="koboSpan" id="kobo.948.4">Maybe the existence of </span><strong class="source-inline"><span class="koboSpan" id="kobo.949.1">value_type</span></strong><span class="koboSpan" id="kobo.950.1"> was used as a proxy for the real requirements, such as the type T has the index operator or can be used as a range to iterate over. </span><span class="koboSpan" id="kobo.950.2">In this case, you can now state the requirements directly, </span><span class="No-Break"><span class="koboSpan" id="kobo.951.1">for example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.952.1">
template &lt;typename T&gt; auto f(T&amp;&amp; t)
requires( requires { *t.begin(); t.begin() != t.end(); } );</span></pre>
<p><span class="koboSpan" id="kobo.953.1">This says that what you really need is a type with member functions </span><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">begin()</span></strong><span class="koboSpan" id="kobo.955.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.956.1">end()</span></strong><span class="koboSpan" id="kobo.957.1">. </span><span class="koboSpan" id="kobo.957.2">The values returned by these functions (presumably, the iterators) are dereferenced and compared; if these operations are supported, the return values are close enough to iterators for our purposes. </span><span class="koboSpan" id="kobo.957.3">Finally, in the preceding example, we let the compiler determine the return type. </span><span class="koboSpan" id="kobo.957.4">This is often convenient, but the downside is that the interface – our contract – does not say what the return type is; the client of our code must read the implementation. </span><span class="koboSpan" id="kobo.957.5">Assuming we return a value we get by dereferencing an</span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.958.1"> iterator, we can be explicit </span><span class="No-Break"><span class="koboSpan" id="kobo.959.1">about it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.960.1">
template &lt;typename T&gt; auto f(T&amp;&amp; t)-&gt;decltype(*t.begin())
requires( requires {
  *t.begin();
  t.begin() != t.end();
  ++t.begin();
} );</span></pre>
<p><span class="koboSpan" id="kobo.961.1">This is a very comprehensive contract with the client, assuming, of course, that we as implementers guarantee that the body of the function will compile if the stated requirements are met. </span><span class="koboSpan" id="kobo.961.2">Otherwise, the contract is incomplete: for example, if we do use </span><strong class="source-inline"><span class="koboSpan" id="kobo.962.1">T::value_type</span></strong><span class="koboSpan" id="kobo.963.1"> in the body of the function, we should add </span><strong class="source-inline"><span class="koboSpan" id="kobo.964.1">typename T::value_type</span></strong><span class="koboSpan" id="kobo.965.1"> to the list of requirements, whether or not this is the type we eventually return (if it is, we could still use SFINAE for the return type, nothing wrong </span><span class="No-Break"><span class="koboSpan" id="kobo.966.1">with that).</span></span></p>
<p><span class="koboSpan" id="kobo.967.1">Similar considerations exist when a dependent type is used to declare a template function argument, </span><span class="No-Break"><span class="koboSpan" id="kobo.968.1">for example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.969.1">
template &lt;typename T&gt;
bool find(const T&amp; t, typename T::value_type x);</span></pre>
<p><span class="koboSpan" id="kobo.970.1">Again, we should ask ourselves if these really are the requirements we want to impose. </span><span class="koboSpan" id="kobo.970.2">Assuming the function is looking for the value </span><strong class="source-inline"><span class="koboSpan" id="kobo.971.1">x</span></strong><span class="koboSpan" id="kobo.972.1"> in the container </span><strong class="source-inline"><span class="koboSpan" id="kobo.973.1">t</span></strong><span class="koboSpan" id="kobo.974.1">, do we really care what the type of </span><strong class="source-inline"><span class="koboSpan" id="kobo.975.1">x</span></strong><span class="koboSpan" id="kobo.976.1"> is as long as it can be compared with the values stored in the container? </span><span class="koboSpan" id="kobo.976.2">Consider </span><span class="No-Break"><span class="koboSpan" id="kobo.977.1">this alternative:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.978.1">
template &lt;typename T, typename X&gt;
bool find(const T&amp; t, X x)
requires( requires {
  *t.begin() == x;
  t.begin() == t.end();
  ++t.begin();
} );</span></pre>
<p><span class="koboSpan" id="kobo.979.1">Now we require that the container has everything needed for a range-for loop and that the values stored in the</span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.980.1"> container can be compared with </span><strong class="source-inline"><span class="koboSpan" id="kobo.981.1">x</span></strong><span class="koboSpan" id="kobo.982.1"> for equality. </span><span class="koboSpan" id="kobo.982.2">Assuming that all we do is iterate over the container and return true if a value equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.983.1">x</span></strong><span class="koboSpan" id="kobo.984.1"> is found, this is all we need to require from </span><span class="No-Break"><span class="koboSpan" id="kobo.985.1">the caller.</span></span></p>
<p><span class="koboSpan" id="kobo.986.1">You should not infer that the “natural” SFINAE should no longer be used in C++20 and be replaced by independent template parameters bound together by constraints. </span><span class="koboSpan" id="kobo.986.2">All we suggest is that you examine your code to determine whether the contract expressed by the interface and enforced through SFINAE is really what you want, or merely what was convenient to code. </span><span class="koboSpan" id="kobo.986.3">In the latter case, concepts offer a way to express what you really wanted to require but could not (but do read on, because there are concept-inspired techniques that can be used before C++20 and meet the same need). </span><span class="koboSpan" id="kobo.986.4">On the other</span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.987.1"> hand, if the template function is best written in a way that triggers a substitution</span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.988.1"> failure when the client supplies an invalid argument, then, by all means, continue to use </span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.989.1">SFINAE – there is no need to rewrite everything to </span><span class="No-Break"><span class="koboSpan" id="kobo.990.1">use concepts.</span></span></p>
<p><span class="koboSpan" id="kobo.991.1">Even the “artificial” SFINAE still has uses in C++20, as we are about </span><span class="No-Break"><span class="koboSpan" id="kobo.992.1">to see.</span></span></p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor354"/><span class="koboSpan" id="kobo.993.1">SFINAE and type traits</span></h2>
<p><span class="koboSpan" id="kobo.994.1">The most important </span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.995.1">application of “artificial” SFINAE in C++20 is </span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.996.1">writing type traits. </span><span class="koboSpan" id="kobo.996.2">Type traits are not going anywhere: even if you replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.997.1">std::is_same_v</span></strong><span class="koboSpan" id="kobo.998.1"> (trait) with </span><strong class="source-inline"><span class="koboSpan" id="kobo.999.1">std::same_as</span></strong><span class="koboSpan" id="kobo.1000.1"> (concept) in your code, you should know that the concept’s implementation uses the very trait </span><span class="No-Break"><span class="koboSpan" id="kobo.1001.1">it replaces.</span></span></p>
<p><span class="koboSpan" id="kobo.1002.1">Not all type traits require the use of SFINAE, but many do. </span><span class="koboSpan" id="kobo.1002.2">These are the traits that check for the presence of some syntactic feature, such as the existence of a nested type. </span><span class="koboSpan" id="kobo.1002.3">The implementation of these traits faces a common problem: if the type does not have the required feature, some code does not compile. </span><span class="koboSpan" id="kobo.1002.4">But we don’t want a compilation error. </span><span class="koboSpan" id="kobo.1002.5">We want an expression that evaluates to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1003.1">false</span></strong><span class="koboSpan" id="kobo.1004.1">. </span><span class="koboSpan" id="kobo.1004.2">So how do we get the compiler to ignore an error? </span><span class="koboSpan" id="kobo.1004.3">By making it occur in an SFINAE context, </span><span class="No-Break"><span class="koboSpan" id="kobo.1005.1">of course.</span></span></p>
<p><span class="koboSpan" id="kobo.1006.1">Let’s start with an example that was getting in our way throughout the entire chapter: we are going to write a trait to check whether a type has the nested type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1007.1">value_type</span></strong><span class="koboSpan" id="kobo.1008.1">. </span><span class="koboSpan" id="kobo.1008.2">We are going to use SFINAE, so we need a template function. </span><span class="koboSpan" id="kobo.1008.3">This function must use the nested type in an SFINAE context. </span><span class="koboSpan" id="kobo.1008.4">There are several options for that. </span><span class="koboSpan" id="kobo.1008.5">Often, it is convenient to add a template argument that depends on the expression that may fail, </span><span class="No-Break"><span class="koboSpan" id="kobo.1009.1">for example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1010.1">
template &lt;typename T, typename = T::value_type&gt; void f();</span></pre>
<p><span class="koboSpan" id="kobo.1011.1">Note that the second parameter has no name – we never use it. </span><span class="koboSpan" id="kobo.1011.2">If we attempt to instantiate this template with any type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1012.1">T</span></strong><span class="koboSpan" id="kobo.1013.1"> that does not have a nested </span><strong class="source-inline"><span class="koboSpan" id="kobo.1014.1">value_type</span></strong><span class="koboSpan" id="kobo.1015.1">, for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1016.1">f&lt;int&gt;()</span></strong><span class="koboSpan" id="kobo.1017.1">, the substitution will fail, but this is not an error (SFINAE!). </span><span class="koboSpan" id="kobo.1017.2">Of course, not having a function to call when we write </span><strong class="source-inline"><span class="koboSpan" id="kobo.1018.1">f(ptr)</span></strong><span class="koboSpan" id="kobo.1019.1"> is an error, so we must provide a </span><span class="No-Break"><span class="koboSpan" id="kobo.1020.1">fallback overload:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1021.1">
template &lt;typename T&gt; void f(…);</span></pre>
<p><span class="koboSpan" id="kobo.1022.1">You may find the notion of the “doubly universal” </span><strong class="source-inline"><span class="koboSpan" id="kobo.1023.1">template f(...)</span></strong><span class="koboSpan" id="kobo.1024.1"> function curious - it takes any arguments of any type, even without the template, so why use the template? </span><span class="koboSpan" id="kobo.1024.2">Of course, it is so a call with an explicitly specified type, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1025.1">f&lt;int&gt;()</span></strong><span class="koboSpan" id="kobo.1026.1">, considers this function as a possible overload (remember that, by specifying the template parameter type, we also exclude all non-template functions from consideration). </span><span class="koboSpan" id="kobo.1026.2">However, we want the priority of this overload to be as low as possible, so the first overload is preferred as long as it exists. </span><span class="koboSpan" id="kobo.1026.3">That’s why we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1027.1">f(…)</span></strong><span class="koboSpan" id="kobo.1028.1"> which is the “overload of the last resort.” </span><span class="koboSpan" id="kobo.1028.2">Alas, the overload of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1029.1">f()</span></strong><span class="koboSpan" id="kobo.1030.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1031.1">f(…)</span></strong><span class="koboSpan" id="kobo.1032.1"> is still considered ambiguous, so we need to have at least one argument. </span><span class="koboSpan" id="kobo.1032.2">The type of the argument doesn’t matter as long as we can readily construct an object of </span><span class="No-Break"><span class="koboSpan" id="kobo.1033.1">that type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1034.1">
template &lt;typename T, typename = T::value_type&gt;
void f(int);
template &lt;typename T&gt; void f(…);</span></pre>
<p><span class="koboSpan" id="kobo.1035.1">Now a call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1036.1">f&lt;T&gt;(0)</span></strong><span class="koboSpan" id="kobo.1037.1"> will choose the first overload if </span><strong class="source-inline"><span class="koboSpan" id="kobo.1038.1">T::value_type</span></strong><span class="koboSpan" id="kobo.1039.1"> is a valid type. </span><span class="koboSpan" id="kobo.1039.2">Otherwise, there is only one overload to choose from, the second one. </span><span class="koboSpan" id="kobo.1039.3">All we need is a way to figure out which overload would be chosen if we made the call, without actually </span><span class="No-Break"><span class="koboSpan" id="kobo.1040.1">making it.</span></span></p>
<p><span class="koboSpan" id="kobo.1041.1">This turns out to be pretty easy: we can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1042.1">decltype()</span></strong><span class="koboSpan" id="kobo.1043.1"> to check the type of the result of the function (prior to C++11, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1044.1">sizeof()</span></strong><span class="koboSpan" id="kobo.1045.1"> was used instead). </span><span class="koboSpan" id="kobo.1045.2">Now, all we need is to give the two overloads different return types. </span><span class="koboSpan" id="kobo.1045.3">Any two different types can be used. </span><span class="koboSpan" id="kobo.1045.4">We can then write some conditional code on these types. </span><span class="koboSpan" id="kobo.1045.5">However, remember that we are writing a type trait, and the traits that check for the existence of something usually end up being </span><strong class="source-inline"><span class="koboSpan" id="kobo.1046.1">std::true_type</span></strong><span class="koboSpan" id="kobo.1047.1"> if the value exists and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1048.1">std::false_type</span></strong><span class="koboSpan" id="kobo.1049.1"> if it does not. </span><span class="koboSpan" id="kobo.1049.2">There’s no reason to overcomplicate our implementation – we can just return the desired type</span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.1050.1"> from </span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.1051.1">both overloads and use it as </span><span class="No-Break"><span class="koboSpan" id="kobo.1052.1">the trait:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1053.1">
// Example 22
namespace detail {
template &lt;typename T, typename = T::value_type&gt;
void test_value_type(int);
template &lt;typename T&gt; void test_value_type (…);
}
template &lt;typename T&gt; using has_value_type =
  decltype(detail::test_value_type &lt;T&gt;(0));</span></pre>
<p><span class="koboSpan" id="kobo.1054.1">Since the functions are never called but used only inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.1055.1">decltype()</span></strong><span class="koboSpan" id="kobo.1056.1">, we do not need to provide the definition of the functions, only their declarations (but see the next section for a more complete and nuanced explanation). </span><span class="koboSpan" id="kobo.1056.2">To avoid polluting the global namespace with the test functions that the client should not ever have to worry about, it is customary to hide them in a namespace such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1057.1">detail</span></strong><span class="koboSpan" id="kobo.1058.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1059.1">internal</span></strong><span class="koboSpan" id="kobo.1060.1">. </span><span class="koboSpan" id="kobo.1060.2">Speaking of customary, we should define the </span><span class="No-Break"><span class="koboSpan" id="kobo.1061.1">two aliases:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1062.1">
template &lt;typename T&gt;
using has_value_type_t = has_value_type&lt;T&gt;::type;
template &lt;typename T&gt; inline constexpr
bool has_value_type_v = has_value_type&lt;T&gt;::value;</span></pre>
<p><span class="koboSpan" id="kobo.1063.1">Now we can use our trait like any standard trait, </span><span class="No-Break"><span class="koboSpan" id="kobo.1064.1">for example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1065.1">
static_assert(has_value_type_v&lt;T&gt;, “I require value_type”);</span></pre>
<p><span class="koboSpan" id="kobo.1066.1">As we have seen earlier, there are several other SFINAE contexts we could have used to “hide” the potential error arising from using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1067.1">T::value_type</span></strong><span class="koboSpan" id="kobo.1068.1">. </span><span class="koboSpan" id="kobo.1068.2">The trailing return type could be used but is not convenient since we already have a return type we need (there is a way around that, but it’s more complex than the alternatives). </span><span class="koboSpan" id="kobo.1068.3">Also, if we ever need to use SFINAE with a constructor, the return type is not an </span><span class="No-Break"><span class="koboSpan" id="kobo.1069.1">option there.</span></span></p>
<p><span class="koboSpan" id="kobo.1070.1">The other common technique is adding extra arguments to the function; the substitution error occurs in the argument type and the arguments must have default values so the caller doesn’t even know they exist. </span><span class="koboSpan" id="kobo.1070.2">This used to be more popular in the past, but we are moving away from this practice: the dummy arguments can interfere with the overload resolution and it may be hard to come up with a reliable default value for </span><span class="No-Break"><span class="koboSpan" id="kobo.1071.1">such arguments.</span></span></p>
<p><span class="koboSpan" id="kobo.1072.1">The one </span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.1073.1">other</span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.1074.1"> technique that is becoming standard practice is to have the substitution failure occur in an optional non-type </span><span class="No-Break"><span class="koboSpan" id="kobo.1075.1">template parameter:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1076.1">
// Example 22a
template &lt;typename T, std::enable_if_t&lt;
  sizeof(typename T::value_type) !=0, bool&gt; = true&gt;
std::true_type test_value_type(int);</span></pre>
<p><span class="koboSpan" id="kobo.1077.1">Here we have a non-type template parameter (a value of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1078.1">bool</span></strong><span class="koboSpan" id="kobo.1079.1">) with a default value </span><strong class="source-inline"><span class="koboSpan" id="kobo.1080.1">true</span></strong><span class="koboSpan" id="kobo.1081.1">. </span><span class="koboSpan" id="kobo.1081.2">The substitution of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1082.1">T</span></strong><span class="koboSpan" id="kobo.1083.1"> in this parameter can fail in the same way all the earlier failures in this section occurred: if the nested type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1084.1">T::value_type</span></strong><span class="koboSpan" id="kobo.1085.1"> does not exist (if it does, the logical expression </span><strong class="source-inline"><span class="koboSpan" id="kobo.1086.1">sizeof(…) != 0</span></strong><span class="koboSpan" id="kobo.1087.1"> never fails since the size of any type is non-negative). </span><span class="koboSpan" id="kobo.1087.2">The advantage of this approach is that it’s easier to combine multiple expressions if we need to check for several failures at once, </span><span class="No-Break"><span class="koboSpan" id="kobo.1088.1">for example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1089.1">
template &lt;typename T, std::enable_if_t&lt;
  sizeof(typename T::value_type) !=0 &amp;&amp;
  sizeof(typename T::size_type) !=0, bool&gt; = true&gt;
std::true_type test_value_type(int);</span></pre>
<p><span class="koboSpan" id="kobo.1090.1">This technique is sometimes used with the failing expression in the default value instead of </span><span class="No-Break"><span class="koboSpan" id="kobo.1091.1">the type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1092.1">
template &lt;typename T,
          bool = sizeof(typename T::value_type)&gt;
std::true_type test_value_type(int);</span></pre>
<p><span class="koboSpan" id="kobo.1093.1">This is a bad habit to get into: while it sometimes works and may seem easier to write, it has a major drawback. </span><span class="koboSpan" id="kobo.1093.2">Often, you need to declare several overloads with different conditions such that only one of these succeeds. </span><span class="koboSpan" id="kobo.1093.3">You can do so using the </span><span class="No-Break"><span class="koboSpan" id="kobo.1094.1">earlier approach:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1095.1">
template &lt;typename T, std::enable_if_t&lt;cond1, bool&gt; = true&gt;
res_t func();
template &lt;typename T, std::enable_if_t&lt;cond2, bool&gt; = true&gt;
res_t func(); // OK as long as only one cond1,2 is true</span></pre>
<p><span class="koboSpan" id="kobo.1096.1">But you</span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.1097.1"> cannot </span><a id="_idIndexMarker375"/><span class="No-Break"><span class="koboSpan" id="kobo.1098.1">do this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1099.1">
template &lt;typename T, bool = cond1&gt; = true&gt;
res_t func();
template &lt;typename T, bool = cond2 &gt; = true&gt;
res_t func();</span></pre>
<p><span class="koboSpan" id="kobo.1100.1">Two templates that have the same parameters but different default values are considered duplicate declarations, even if one of the conditions </span><strong class="source-inline"><span class="koboSpan" id="kobo.1101.1">cond1</span></strong><span class="koboSpan" id="kobo.1102.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1103.1">cond2</span></strong><span class="koboSpan" id="kobo.1104.1"> always causes a substitution failure. </span><span class="koboSpan" id="kobo.1104.2">It is better to get into the habit of writing such code with the (possibly failing) condition in the type of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1105.1">non-type parameter.</span></span></p>
<p><span class="koboSpan" id="kobo.1106.1">To review everything we have learned about SFINAE, let’s write another trait. </span><span class="koboSpan" id="kobo.1106.2">This time, we are going to check whether a type is </span><span class="No-Break"><span class="koboSpan" id="kobo.1107.1">a class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1108.1">
// Example 23
namespace detail {
template &lt;typename T&gt; std::true_type test(int T::*);
template &lt;typename T&gt; std::false_type test(...);
}
template &lt;typename T&gt;
using is_class = decltype(detail::test&lt;T&gt;(nullptr));</span></pre>
<p><span class="koboSpan" id="kobo.1109.1">The key difference between a class and not a class is that a class has members and, thus, member pointers. </span><span class="koboSpan" id="kobo.1109.2">This time the easiest way is to declare a member function argument that is a member pointer (doesn’t matter what kind of member, we’re not going to call the function). </span><span class="koboSpan" id="kobo.1109.3">The substitution failure occurs in the parameter type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1110.1">T::*</span></strong><span class="koboSpan" id="kobo.1111.1"> if the type T does not have </span><span class="No-Break"><span class="koboSpan" id="kobo.1112.1">any members.</span></span></p>
<p><span class="koboSpan" id="kobo.1113.1">This is almost exactly how the standard trait </span><strong class="source-inline"><span class="koboSpan" id="kobo.1114.1">std::is_class</span></strong><span class="koboSpan" id="kobo.1115.1"> is defined except it also checks for unions: unions are not considered classes by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1116.1">std::is_class</span></strong><span class="koboSpan" id="kobo.1117.1">, but implementing </span><strong class="source-inline"><span class="koboSpan" id="kobo.1118.1">std::is_union</span></strong><span class="koboSpan" id="kobo.1119.1"> requires compiler support, </span><span class="No-Break"><span class="koboSpan" id="kobo.1120.1">not SFINAE.</span></span></p>
<p><span class="koboSpan" id="kobo.1121.1">The techniques we have learned allow us to write any trait that checks for a particular property of a type: whether it is a pointer, whether it has a nested type or a member, etc. </span><span class="koboSpan" id="kobo.1121.2">On the other hand, the concepts make it easy to check for behaviors: can a type be dereferenced, can two types be compared, etc? </span><span class="koboSpan" id="kobo.1121.3">Note that I said “easy” not “possible:” you can use concepts to check for very narrowly defined features, and you can use traits to detect behaviors, but it is not </span><span class="No-Break"><span class="koboSpan" id="kobo.1122.1">as straightforward.</span></span></p>
<p><span class="koboSpan" id="kobo.1123.1">This chapter mainly targets a programmer who writes templates and template libraries in application </span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.1124.1">code: if</span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.1125.1"> you write a library with the complexity and rigor of STL, you need to be very precise in your definitions (you also need a standard committee to debate and hash out those definitions to the necessary degree of precision). </span><span class="koboSpan" id="kobo.1125.2">For the rest of us, the degree of formality provided by “call </span><strong class="source-inline"><span class="koboSpan" id="kobo.1126.1">f(p)</span></strong><span class="koboSpan" id="kobo.1127.1"> if </span><strong class="source-inline"><span class="koboSpan" id="kobo.1128.1">*p</span></strong><span class="koboSpan" id="kobo.1129.1"> compiles” is usually sufficient. </span><span class="koboSpan" id="kobo.1129.2">In C++20, we can do this with concepts. </span><span class="koboSpan" id="kobo.1129.3">If you do not use C++20 yet, you have to use one of the SFINAE techniques. </span><span class="koboSpan" id="kobo.1129.4">Several such were discussed in this chapter; the community has developed many more over the years. </span><span class="koboSpan" id="kobo.1129.5">However, the development of concepts had an interesting effect on these practices: in addition to the tools we can use directly in C++20, the standard offers us a way of thinking about this problem that is applicable much more broadly. </span><span class="koboSpan" id="kobo.1129.6">Thus, several SFINAE techniques that somewhat resemble the concepts (for example, testing behaviors in a trailing </span><strong class="source-inline"><span class="koboSpan" id="kobo.1130.1">decltype()</span></strong><span class="koboSpan" id="kobo.1131.1">) are becoming more popular, while other practices are falling out of favor. </span><span class="koboSpan" id="kobo.1131.2">There have even been several attempts to implement a concept library using pre-C++20 language features. </span><span class="koboSpan" id="kobo.1131.3">Of course, it is not possible to replicate concepts; in many ways, we can’t even get close. </span><span class="koboSpan" id="kobo.1131.4">However, we can still benefit from the thinking that went into developing the concepts language even if we cannot use the language itself. </span><span class="koboSpan" id="kobo.1131.5">Thus, we can use SFINAE “in the spirit” of concepts, which provides a consistent way to implement SFINAE-based restrictions instead of an ad hoc </span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.1132.1">collection of </span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.1133.1">techniques. </span><span class="koboSpan" id="kobo.1133.2">What follows is one such approach to implementing concept-like restrictions without the use </span><span class="No-Break"><span class="koboSpan" id="kobo.1134.1">of C++20.</span></span></p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor355"/><span class="koboSpan" id="kobo.1135.1">Concepts before concepts</span></h2>
<p><span class="koboSpan" id="kobo.1136.1">Our goal is not so</span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.1137.1"> much to implement a full concept library here: you can find such libraries online, and this book is about design patterns and best practices, not writing specific libraries. </span><span class="koboSpan" id="kobo.1137.2">The aim of this section is to select the few best SFINAE-based techniques among the multitude of available options. </span><span class="koboSpan" id="kobo.1137.3">These techniques also fit the concept-based mindset, as much as possible anyway. </span><span class="koboSpan" id="kobo.1137.4">The methods and tricks we have not chosen are not necessarily inferior, but this section offers a set of SFINAE tools and practices that is consistent, uniform, and sufficient for the absolute majority of an application </span><span class="No-Break"><span class="koboSpan" id="kobo.1138.1">programmer’s needs.</span></span></p>
<p><span class="koboSpan" id="kobo.1139.1">Just like with real concepts, we will need two kinds of entities: concepts </span><span class="No-Break"><span class="koboSpan" id="kobo.1140.1">and restrictions.</span></span></p>
<p><span class="koboSpan" id="kobo.1141.1">If you look at the way concepts are used, they strongly resemble constant </span><span class="No-Break"><span class="koboSpan" id="kobo.1142.1">Boolean variables:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1143.1">
template &lt;typename R&gt; concept Range = …;
template &lt;typename R&gt; requires(Range&lt;R&gt;) void sort(…);</span></pre>
<p><span class="koboSpan" id="kobo.1144.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1145.1">requires()</span></strong><span class="koboSpan" id="kobo.1146.1"> clause needs a Boolean value, it is not restricted to concepts (consider the expression </span><strong class="source-inline"><span class="koboSpan" id="kobo.1147.1">requires(std::is_class_v&lt;T&gt;)</span></strong><span class="koboSpan" id="kobo.1148.1">). </span><span class="koboSpan" id="kobo.1148.2">The concept </span><strong class="source-inline"><span class="koboSpan" id="kobo.1149.1">Range&lt;R&gt;</span></strong><span class="koboSpan" id="kobo.1150.1"> thus acts like a Boolean value. </span><span class="koboSpan" id="kobo.1150.2">Perforce, we are going to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1151.1">constexpr bool</span></strong><span class="koboSpan" id="kobo.1152.1"> variables instead of concepts in our attempt to emulate their behavior. </span><span class="koboSpan" id="kobo.1152.2">From the comparison of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1153.1">Range&lt;R&gt;</span></strong><span class="koboSpan" id="kobo.1154.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1155.1">std::is_class_v&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1156.1"> we can also deduce that a trait-like mechanism is probably our best bet to implement concepts: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1157.1">std::is_class_v</span></strong><span class="koboSpan" id="kobo.1158.1"> is also a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1159.1">constexpr bool</span></strong><span class="koboSpan" id="kobo.1160.1"> variable, </span><span class="No-Break"><span class="koboSpan" id="kobo.1161.1">after all.</span></span></p>
<p><span class="koboSpan" id="kobo.1162.1">From the implementations of the traits we learned in the last section, we know that we are going to need </span><span class="No-Break"><span class="koboSpan" id="kobo.1163.1">two overloads:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1164.1">
template &lt;typename R&gt; constexpr yes_t RangeTest(some-args);
template &lt;typename R&gt; constexpr no_t RangeTest(...);</span></pre>
<p><span class="koboSpan" id="kobo.1165.1">The first overload is going to be valid and preferred for any type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1166.1">R</span></strong><span class="koboSpan" id="kobo.1167.1"> that satisfies the requirements of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1168.1">Range</span></strong><span class="koboSpan" id="kobo.1169.1"> (once we figure out how to do it). </span><span class="koboSpan" id="kobo.1169.2">The second overload is always available but never preferred, so it is called only if this is the only </span><span class="No-Break"><span class="koboSpan" id="kobo.1170.1">overload left.</span></span></p>
<p><span class="koboSpan" id="kobo.1171.1">We can figure out which overload was called from the return types (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1172.1">yes_t</span></strong><span class="koboSpan" id="kobo.1173.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1174.1">no_t</span></strong><span class="koboSpan" id="kobo.1175.1"> are just placeholders for some types we haven’t chosen yet). </span><span class="koboSpan" id="kobo.1175.2">But there is a much simpler way; all we need for our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1176.1">Range</span></strong><span class="koboSpan" id="kobo.1177.1"> “concept” is a constant Boolean value, so why not let the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1178.1">constexpr</span></strong><span class="koboSpan" id="kobo.1179.1"> function return the right value directly, </span><span class="No-Break"><span class="koboSpan" id="kobo.1180.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1181.1">
template &lt;typename R&gt; constexpr bool RangeTest(some-args) {
  return true;
}
template &lt;typename R&gt; constexpr bool RangeTest(...) {
  return false;
}
template &lt;typename R&gt;
constexpr inline bool Range = RangeTest&lt;R&gt;(0);</span></pre>
<p><span class="koboSpan" id="kobo.1182.1">The last two statements (the variable and the fallback overload) are complete. </span><span class="koboSpan" id="kobo.1182.2">“All” we need is to make it so the first overload suffers a substitution failure when </span><strong class="source-inline"><span class="koboSpan" id="kobo.1183.1">R</span></strong><span class="koboSpan" id="kobo.1184.1"> is not a range. </span><span class="koboSpan" id="kobo.1184.2">So, what is a range for our purposes? </span><span class="koboSpan" id="kobo.1184.3">Just like we did in the section </span><em class="italic"><span class="koboSpan" id="kobo.1185.1">Concepts in C++20</span></em><span class="koboSpan" id="kobo.1186.1">, we are </span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.1187.1">going to define a range as any type that has </span><strong class="source-inline"><span class="koboSpan" id="kobo.1188.1">begin()</span></strong><span class="koboSpan" id="kobo.1189.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1190.1">end()</span></strong><span class="koboSpan" id="kobo.1191.1">. </span><span class="koboSpan" id="kobo.1191.2">Since we are testing for a specific behavior, which may fail to compile but should not cause an error, we should trigger this failure in an SFINAE context. </span><span class="koboSpan" id="kobo.1191.3">As we have seen already, the easiest place for this possibly invalid code is the trailing </span><span class="No-Break"><span class="koboSpan" id="kobo.1192.1">return type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1193.1">
template &lt;typename R&gt;
constexpr auto RangeTest(??? </span><span class="koboSpan" id="kobo.1193.2">r) -&gt; decltype(
  std::begin(r),        // Ranges have begin()
  std::end(r),         // Ranges have end()
  bool{}            // But return type should be bool
) { return true; }</span></pre>
<p><span class="koboSpan" id="kobo.1194.1">The trailing return type lets us write code that uses parameter names. </span><span class="koboSpan" id="kobo.1194.2">All we need is a parameter </span><strong class="source-inline"><span class="koboSpan" id="kobo.1195.1">r</span></strong><span class="koboSpan" id="kobo.1196.1"> of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1197.1">R</span></strong><span class="koboSpan" id="kobo.1198.1">. </span><span class="koboSpan" id="kobo.1198.2">This is easy to do when using SFINAE in any template function that is meant to be called. </span><span class="koboSpan" id="kobo.1198.3">But this function is never going to be called with an actual range. </span><span class="koboSpan" id="kobo.1198.4">We could try to declare an argument of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1199.1">R&amp;</span></strong><span class="koboSpan" id="kobo.1200.1"> and then call the function with a default-constructed range </span><strong class="source-inline"><span class="koboSpan" id="kobo.1201.1">R{}</span></strong><span class="koboSpan" id="kobo.1202.1">, but this is not going to work because </span><strong class="source-inline"><span class="koboSpan" id="kobo.1203.1">constexpr</span></strong><span class="koboSpan" id="kobo.1204.1"> functions must have </span><strong class="source-inline"><span class="koboSpan" id="kobo.1205.1">constexpr</span></strong><span class="koboSpan" id="kobo.1206.1"> arguments (otherwise they can still be called but not in a constant expression, i.e. </span><span class="koboSpan" id="kobo.1206.2">not at compile time), and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1207.1">R{}</span></strong><span class="koboSpan" id="kobo.1208.1"> is not going to be a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1209.1">constexpr</span></strong><span class="koboSpan" id="kobo.1210.1"> value for </span><span class="No-Break"><span class="koboSpan" id="kobo.1211.1">most ranges.</span></span></p>
<p><span class="koboSpan" id="kobo.1212.1">We could give </span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.1213.1">up on using references altogether and use </span><span class="No-Break"><span class="koboSpan" id="kobo.1214.1">pointers instead:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1215.1">
// Example 24
template &lt;typename R&gt;
constexpr auto RangeTest(R* r) -&gt; decltype(
  std::begin(*r),    // Ranges have begin()
  std::end(*r),         // Ranges have end()
  bool{}            // But return type should be bool
) { return true; }
template &lt;typename R&gt; constexpr bool RangeTest(...) {
  return false;
}
template &lt;typename R&gt;
constexpr inline bool Range = RangeTest&lt;R&gt;(nullptr);</span></pre>
<p><span class="koboSpan" id="kobo.1216.1">While you may have expected that “concept-like” SFINAE is going to be incredibly complex, this is actually all you need to define a concept such </span><span class="No-Break"><span class="koboSpan" id="kobo.1217.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1218.1">Range</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1219.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1220.1">
static_assert(Range&lt;std::vector&lt;int&gt;&gt;);
static_assert(!Range&lt;int&gt;);</span></pre>
<p><span class="koboSpan" id="kobo.1221.1">These two statements look exactly like their C++20 equivalents! </span><span class="koboSpan" id="kobo.1221.2">Our “concept” even works in C++14 except there are no </span><strong class="source-inline"><span class="koboSpan" id="kobo.1222.1">inline</span></strong><span class="koboSpan" id="kobo.1223.1"> variables there so we have to use </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1224.1">static</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1225.1"> instead.</span></span></p>
<p><span class="koboSpan" id="kobo.1226.1">Having finished with concepts for now, we also need to do something about constraints. </span><span class="koboSpan" id="kobo.1226.2">Here our success is going to be much more limited. </span><span class="koboSpan" id="kobo.1226.3">First of all, since we are using SFINAE, we can apply restrictions only to template function parameters (as we have seen, the C++20 constraints can apply even to non-template functions, such as member functions of class templates). </span><span class="koboSpan" id="kobo.1226.4">Also, we are very limited in where we can write these constraints. </span><span class="koboSpan" id="kobo.1226.5">The most universal way is to add a non-template parameter to the template and test the</span><a id="_idIndexMarker383"/> <span class="No-Break"><span class="koboSpan" id="kobo.1227.1">constraint there:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1228.1">
template &lt;typename R,
    std::enable_if_t&lt;Range&lt;R&gt;, bool&gt; = true&gt;
void sort(R&amp;&amp; r);</span></pre>
<p><span class="koboSpan" id="kobo.1229.1">We can hide the boilerplate code in </span><span class="No-Break"><span class="koboSpan" id="kobo.1230.1">a macro:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1231.1">
// Example 24
#define REQUIRES(...) \
  std::enable_if_t&lt;(__VA_ARGS__), bool&gt; = true
template &lt;typename R, REQUIRES(Range&lt;R&gt;)&gt; void sort(R&amp;&amp; r);</span></pre>
<p><span class="koboSpan" id="kobo.1232.1">The variadic macro neatly solves the common problem macros have when their arguments are code: commas are interpreted as separators between arguments. </span><span class="koboSpan" id="kobo.1232.2">This is by no means as convenient as C++20 constraints, but it’s as close as you’re going </span><span class="No-Break"><span class="koboSpan" id="kobo.1233.1">to get.</span></span></p>
<p><span class="koboSpan" id="kobo.1234.1">Now let us come back to the concepts. </span><span class="koboSpan" id="kobo.1234.2">What we wrote earlier works, but has two problems: first, there is a lot of boilerplate code there too. </span><span class="koboSpan" id="kobo.1234.3">Second, we had to use pointers to introduce function parameter names we could later use to test the required behaviors. </span><span class="koboSpan" id="kobo.1234.4">This limits what behaviors we can require because functions can pass arguments by reference and the behavior can depend on what type of reference is used, while we cannot form pointers to references. </span><span class="koboSpan" id="kobo.1234.5">In fact, the code we just wrote won’t compile in many cases because the type of the argument </span><strong class="source-inline"><span class="koboSpan" id="kobo.1235.1">R</span></strong><span class="koboSpan" id="kobo.1236.1"> to the template function </span><strong class="source-inline"><span class="koboSpan" id="kobo.1237.1">sort()</span></strong><span class="koboSpan" id="kobo.1238.1"> is deduced as a reference. </span><span class="koboSpan" id="kobo.1238.2">To use it reliably, we have to check the underlying </span><span class="No-Break"><span class="koboSpan" id="kobo.1239.1">type instead:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1240.1">
// Example 24
template &lt;typename R, REQUIRES(Range&lt;std::decay_t&lt;R&gt;&gt;)&gt;
void sort(R&amp;&amp; r);</span></pre>
<p><span class="koboSpan" id="kobo.1241.1">It would be much more convenient if we could use reference arguments, but then we are back to the problem we already faced: how to invoke such a function? </span><span class="koboSpan" id="kobo.1241.2">We can’t use a value of the corresponding type, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1242.1">R{}</span></strong><span class="koboSpan" id="kobo.1243.1"> because it is not a constant expression. </span><span class="koboSpan" id="kobo.1243.2">The same problem happens if we try to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1244.1">R{}</span></strong><span class="koboSpan" id="kobo.1245.1"> as the default argument value – it is still not a </span><span class="No-Break"><span class="koboSpan" id="kobo.1246.1">constant expression.</span></span></p>
<p><span class="koboSpan" id="kobo.1247.1">As with most problems in software engineering, this one can be solved by adding another level </span><span class="No-Break"><span class="koboSpan" id="kobo.1248.1">of indirection:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1249.1">
template &lt;typename R&gt;
constexpr static auto RangeTest(R&amp; r = ???) -&gt;
  decltype(std::begin(r), std::end(r));
template &lt;typename R&gt;        // Overload for success
constexpr static auto RangeTest(int) -&gt;
  decltype(RangeTest&lt;R&gt;(), bool{}) { return true; }
template &lt;typename R&gt;        // Fallback overload
constexpr bool RangeTest(...) { return false; }
template &lt;typename R&gt;
constexpr static bool Range = RangeTest&lt;R&gt;(0);</span></pre>
<p><span class="koboSpan" id="kobo.1250.1">Our fallback overload </span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.1251.1">remains the same, but the overload that is going to be called if the SFINAE test succeeds now attempts to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.1252.1">RangeTest(r)</span></strong><span class="koboSpan" id="kobo.1253.1"> in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1254.1">decltype</span></strong><span class="koboSpan" id="kobo.1255.1"> context (also, we are back to using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1256.1">int</span></strong><span class="koboSpan" id="kobo.1257.1"> instead of a pointer as the dummy argument). </span><span class="koboSpan" id="kobo.1257.2">The last problem is what to use as the default value for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1258.1">argument </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1259.1">r</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1260.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1261.1">The usual way of getting references to objects in code that is never going to be called is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1262.1">std::declval</span></strong><span class="koboSpan" id="kobo.1263.1">, so we might want to </span><span class="No-Break"><span class="koboSpan" id="kobo.1264.1">write this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1265.1">
template &lt;typename R&gt;
constexpr static auto RangeTest(R&amp; r=std::declval&lt;R&gt;()) -&gt;
  decltype(std::begin(r), std::end(r));</span></pre>
<p><span class="koboSpan" id="kobo.1266.1">Unfortunately, this is not going to compile, and the error message is going to be something like “</span><strong class="source-inline"><span class="koboSpan" id="kobo.1267.1">std::declval</span></strong><span class="koboSpan" id="kobo.1268.1"> must not be used.” </span><span class="koboSpan" id="kobo.1268.2">This is strange, we are not really using it (the entire function is used only inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.1269.1">decltype()</span></strong><span class="koboSpan" id="kobo.1270.1">) but let’s try to work around it. </span><span class="koboSpan" id="kobo.1270.2">After all, there is no magic in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1271.1">std::declval</span></strong><span class="koboSpan" id="kobo.1272.1">, we just need a function that returns a reference to </span><span class="No-Break"><span class="koboSpan" id="kobo.1273.1">our object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1274.1">
template &lt;typename T&gt; constexpr T&amp; lvalue();
template &lt;typename R&gt;
constexpr static auto RangeTest(R&amp; r = lvalue&lt;R&gt;()) -&gt;
  decltype(std::begin(r), std::end(r));</span></pre>
<p><span class="koboSpan" id="kobo.1275.1">On a standard-compliant compiler, this is not going to compile either, but the error is going to be different, this time the compiler will say something </span><span class="No-Break"><span class="koboSpan" id="kobo.1276.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1277.1">
inline function 'lvalue&lt;std::vector&lt;int&gt;&gt;' is used but not defined."</span></pre>
<p><span class="koboSpan" id="kobo.1278.1">OK, we can define the function but make sure it is </span><span class="No-Break"><span class="koboSpan" id="kobo.1279.1">never called:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1280.1">
template &lt;typename T&gt; constexpr T&amp; lvalue() { abort(); }
template &lt;typename R&gt;
constexpr static auto RangeTest(R&amp; r = lvalue&lt;R&gt;()) -&gt;
  decltype(std::begin(r), std::end(r));</span></pre>
<p><span class="koboSpan" id="kobo.1281.1">Adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.1282.1">{ abort(); }</span></strong><span class="koboSpan" id="kobo.1283.1"> makes all the difference – the program now compiles and (after you add the rest of </span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.1284.1">the missing pieces) it runs without aborting. </span><span class="koboSpan" id="kobo.1284.2">That is as it should be: the function </span><strong class="source-inline"><span class="koboSpan" id="kobo.1285.1">lvalue()</span></strong><span class="koboSpan" id="kobo.1286.1"> is used only inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.1287.1">decltype</span></strong><span class="koboSpan" id="kobo.1288.1">, and its implementation should not matter at all. </span><span class="koboSpan" id="kobo.1288.2">I’m not going to keep you in suspense any longer, this is an issue with the standard itself; if you want to want to dive into the thorny details, you can follow </span><em class="italic"><span class="koboSpan" id="kobo.1289.1">Core Issue 1581</span></em><span class="koboSpan" id="kobo.1290.1"> here: </span><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0859r0.html"><span class="koboSpan" id="kobo.1291.1">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0859r0.html</span></a><span class="koboSpan" id="kobo.1292.1">. </span><span class="koboSpan" id="kobo.1292.2">For now, we will just have to keep the useless function body (it doesn’t hurt anything). </span><span class="koboSpan" id="kobo.1292.3">Of course, we can define similar functions for initializing default rvalue arguments as well as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1293.1">const</span></strong><span class="koboSpan" id="kobo.1294.1"> lvalue references, and contain them in some </span><span class="No-Break"><span class="koboSpan" id="kobo.1295.1">implementation-only namespace:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1296.1">
namespace concept_detail {
template &lt;typename T&gt;
  constexpr const T&amp; clvalue() { abort(); }
template &lt;typename T&gt; constexpr T&amp; lvalue() { abort(); }
template &lt;typename T&gt; constexpr T&amp;&amp; rvalue() { abort(); }
}</span></pre>
<p><span class="koboSpan" id="kobo.1297.1">Now we can define concepts that test behaviors for the type of reference </span><span class="No-Break"><span class="koboSpan" id="kobo.1298.1">we want:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1299.1">
// Example 24a
template &lt;typename R&gt;
constexpr static auto RangeTest(
  R&amp; r = concept_detail::lvalue&lt;R&gt;()) -&gt;
  decltype(std::begin(r), std::end(r));
template &lt;typename R&gt;
constexpr static auto RangeTest(int) -&gt;
  decltype(RangeTest&lt;R&gt;(), bool{}) { return true; }
template &lt;typename R&gt;
constexpr bool RangeTest(...) { return false; }
template &lt;typename R&gt;
constexpr static bool Range = RangeTest&lt;R&gt;(0);</span></pre>
<p><span class="koboSpan" id="kobo.1300.1">The</span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.1301.1"> constraints, including our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1302.1">REQUIRES</span></strong><span class="koboSpan" id="kobo.1303.1"> macro, still work exactly the same way (after all, the concept itself did not change – </span><strong class="source-inline"><span class="koboSpan" id="kobo.1304.1">Range</span></strong><span class="koboSpan" id="kobo.1305.1"> is still a constant </span><span class="No-Break"><span class="koboSpan" id="kobo.1306.1">Boolean variable).</span></span></p>
<p><span class="koboSpan" id="kobo.1307.1">There is still the issue of the boilerplate; in fact, we have even more of it with the unwieldy default argument values. </span><span class="koboSpan" id="kobo.1307.2">That’s the easiest to take care of, though, with the help of </span><span class="No-Break"><span class="koboSpan" id="kobo.1308.1">some macros:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1309.1">
// Example 25
#define CLVALUE(TYPE, NAME) const TYPE&amp; NAME = \
  Concepts::concept_detail::clvalue&lt;TYPE&gt;()
#define LVALUE(TYPE, NAME) TYPE&amp; NAME = \
  Concepts::concept_detail::lvalue&lt;TYPE&gt;()
#define RVALUE(TYPE, NAME) TYPE&amp;&amp; NAME = \
  Concepts::concept_detail::rvalue&lt;TYPE&gt;()</span></pre>
<p><span class="koboSpan" id="kobo.1310.1">Of the three template functions (such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1311.1">RangeTest</span></strong><span class="koboSpan" id="kobo.1312.1">), the first function is the equivalent of the C++20 </span><strong class="source-inline"><span class="koboSpan" id="kobo.1313.1">concept</span></strong><span class="koboSpan" id="kobo.1314.1"> declaration – that’s where the behaviors we want to require are coded. </span><span class="koboSpan" id="kobo.1314.2">Other than these macros, it can’t really be made </span><span class="No-Break"><span class="koboSpan" id="kobo.1315.1">any shorter:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1316.1">
// Example 25
template &lt;typename R&gt; CONCEPT RangeTest(RVALUE(R, r)) -&gt;
  decltype(std::begin(r), std::end(r));</span></pre>
<p><span class="koboSpan" id="kobo.1317.1">Here we also defined </span><span class="No-Break"><span class="koboSpan" id="kobo.1318.1">a macro:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1319.1">
#define CONCEPT constexpr inline auto</span></pre>
<p><span class="koboSpan" id="kobo.1320.1">This is done not so much to shorten the code but to make it clear to the reader (if not the compiler) that we are defining a concept. </span><span class="koboSpan" id="kobo.1320.2">Compare it with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1321.1">C++20 statement:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1322.1">
template &lt;typename R&gt; concept Range =
  requires(R r) { std::begin(r); std::end(r); };</span></pre>
<p><span class="koboSpan" id="kobo.1323.1">The other two</span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.1324.1"> overloads (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1325.1">RangeTest(int)</span></strong><span class="koboSpan" id="kobo.1326.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1327.1">RangeTest(…)</span></strong><span class="koboSpan" id="kobo.1328.1">), as well as the definition of the concept variable itself, can easily be made universal for any concept (except for the name, of course). </span><span class="koboSpan" id="kobo.1328.2">In fact, the only declaration that varies from one concept to another is the </span><span class="No-Break"><span class="koboSpan" id="kobo.1329.1">first one:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1330.1">
template &lt;typename R&gt;
constexpr static auto RangeTest(int) -&gt;
  decltype(RangeTest&lt;R&gt;(), bool{}) { return true; }</span></pre>
<p><span class="koboSpan" id="kobo.1331.1">We can make it work for any concept-testing function if we use a </span><span class="No-Break"><span class="koboSpan" id="kobo.1332.1">variadic template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1333.1">
// Example 25
template &lt;typename… T&gt;
constexpr static auto RangeTest(int) -&gt;
  decltype(RangeTest&lt;T…&gt;(), bool{}) { return true; }</span></pre>
<p><span class="koboSpan" id="kobo.1334.1">Since all of our argument macros, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1335.1">LVALUE()</span></strong><span class="koboSpan" id="kobo.1336.1">, include the default value for each argument, the function can always be called without arguments. </span><span class="koboSpan" id="kobo.1336.2">We have to be mindful of the possibility that the test function we define conflicts with the function </span><strong class="source-inline"><span class="koboSpan" id="kobo.1337.1">RangeTest(int)</span></strong><span class="koboSpan" id="kobo.1338.1">. </span><span class="koboSpan" id="kobo.1338.2">This does not happen here because </span><strong class="source-inline"><span class="koboSpan" id="kobo.1339.1">int</span></strong><span class="koboSpan" id="kobo.1340.1"> is not a valid range, but it could happen for other arguments. </span><span class="koboSpan" id="kobo.1340.2">Since we control these common overloads and the definition of the concept variable itself, we could make sure that they use an argument that will not conflict with anything we could ever write in </span><span class="No-Break"><span class="koboSpan" id="kobo.1341.1">regular code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1342.1">
// Example 25
struct ConceptArg {};
template &lt;typename… T&gt;
constexpr static auto RangeTest(ConceptArg, int) -&gt;
  decltype(RangeTest&lt;T…&gt;(), bool{}) { return true; }
template &lt;typename T&gt;
constexpr bool RangeTest(ConceptArg, ...) { return false; }
template &lt;typename R&gt;
constexpr static bool Range = RangeTest&lt;R&gt;(ConceptArg{},0);</span></pre>
<p><span class="koboSpan" id="kobo.1343.1">This code is going to</span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.1344.1"> be the same for all concepts, except for the names such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1345.1">Range</span></strong><span class="koboSpan" id="kobo.1346.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1347.1">RangeTest</span></strong><span class="koboSpan" id="kobo.1348.1">. </span><span class="koboSpan" id="kobo.1348.2">A single macro can generate all these lines from just two </span><span class="No-Break"><span class="koboSpan" id="kobo.1349.1">naming arguments:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1350.1">
// Example 25
#define DECLARE_CONCEPT(NAME, SUFFIX) \
template &lt;typename... </span><span class="koboSpan" id="kobo.1350.2">T&gt; constexpr inline auto     \
  NAME ## SUFFIX(ConceptArg, int) -&gt; \
  decltype(NAME ## SUFFIX&lt;T...&gt;(), bool{}){return true;} \
template &lt;typename... </span><span class="koboSpan" id="kobo.1350.3">T&gt; constexpr inline bool \
  NAME ## SUFFIX(ConceptArg, ...) { return false; } \
template &lt;typename... </span><span class="koboSpan" id="kobo.1350.4">T&gt; constexpr static bool NAME = \
  NAME ## SUFFIX&lt;T...&gt;(ConceptArg{}, 0)</span></pre>
<p><span class="koboSpan" id="kobo.1351.1">We did not do so for brevity, but if you want to use these concept-like utilities in your code, you should hide all the implementation details in </span><span class="No-Break"><span class="koboSpan" id="kobo.1352.1">a namespace.</span></span></p>
<p><span class="koboSpan" id="kobo.1353.1">Now we can define our range concept </span><span class="No-Break"><span class="koboSpan" id="kobo.1354.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1355.1">
// Example 25
template &lt;typename R&gt; CONCEPT RangeTest(RVALUE(R, r)) -&gt;
  decltype(std::begin(r), std::end(r));
DECLARE_CONCEPT(Range, Test);</span></pre>
<p><span class="koboSpan" id="kobo.1356.1">Thanks to the variadic template, we are not limited to concepts with just one template parameter. </span><span class="koboSpan" id="kobo.1356.2">Here is a concept for two types that can be </span><span class="No-Break"><span class="koboSpan" id="kobo.1357.1">added together:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1358.1">
// Example 25
template &lt;typename U, typename V&gt; CONCEPT
  AddableTest(CLVALUE(U, u), CLVALUE(V, v)) -&gt;
  decltype(u + v);
DECLARE_CONCEPT(Addable, Test);</span></pre>
<p><span class="koboSpan" id="kobo.1359.1">For comparison, this is what the C++20 version </span><span class="No-Break"><span class="koboSpan" id="kobo.1360.1">looks like:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1361.1">
template &lt;typename U, typename V&gt; concept Addable =
  require(U u, V v) { u + v; }</span></pre>
<p><span class="koboSpan" id="kobo.1362.1">Of course, it is</span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.1363.1"> much shorter and more powerful. </span><span class="koboSpan" id="kobo.1363.2">But the C++14 version is about as close as you can get (this is not the only approach but they all yield </span><span class="No-Break"><span class="koboSpan" id="kobo.1364.1">similar results).</span></span></p>
<p><span class="koboSpan" id="kobo.1365.1">These “fake concepts” can be used to constrain templates, just like </span><span class="No-Break"><span class="koboSpan" id="kobo.1366.1">C++20 concepts:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1367.1">
 // Example 25
template &lt;typename R, REQUIRES(Range&lt;R&gt;)&gt; void sort(R&amp;&amp; r);</span></pre>
<p><span class="koboSpan" id="kobo.1368.1">OK, not quite like the C++20 concepts – we are limited to template functions, and any requirement must involve at least one template parameter. </span><span class="koboSpan" id="kobo.1368.2">So, if you want to restrict a non-template member function of a template class, you have to play the </span><span class="No-Break"><span class="koboSpan" id="kobo.1369.1">template game:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1370.1">
template &lt;typename T&gt; class C {
  template &lt;typename U = T, REQUIRE(Range&lt;U&gt;)&gt; void f(T&amp;);
  …
};</span></pre>
<p><span class="koboSpan" id="kobo.1371.1">But we do get the same result in the end: a call to sort with a vector compiles and sort of something that is not a range </span><span class="No-Break"><span class="koboSpan" id="kobo.1372.1">does not:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1373.1">
std::vector&lt;int&gt; v = …;
sort(v);         // OK
sort(0);        // Does not compile</span></pre>
<p><span class="koboSpan" id="kobo.1374.1">Unfortunately, one place where our pseudo-concepts really come up short is the error messages – a C++20 compiler would usually tell us which concept was not satisfied and why, while the template substitution error messages are not easy </span><span class="No-Break"><span class="koboSpan" id="kobo.1375.1">to decipher.</span></span></p>
<p><span class="koboSpan" id="kobo.1376.1">By the way, when you write a test to make sure that something does not compile, you can now use a concept (or a pseudo-concept) to </span><span class="No-Break"><span class="koboSpan" id="kobo.1377.1">do that:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1378.1">
// Example 25
template &lt;typename R&gt;
CONCEPT SortCompilesTest(RVALUE(R, r))-&gt;decltype(sort(r));
DECLARE_CONCEPT(SortCompiles, Test);
static_assert(SortCompiles&lt;std::vector&lt;int&gt;&gt;);
static_assert(!SortCompiles&lt;int&gt;);</span></pre>
<p><span class="koboSpan" id="kobo.1379.1">The C++20 version is left as an exercise </span><span class="No-Break"><span class="koboSpan" id="kobo.1380.1">for you.</span></span></p>
<p><span class="koboSpan" id="kobo.1381.1">Before we end this </span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.1382.1">chapter, let’s look at the recommendations and the best practices for use of SFINAE and concepts </span><span class="No-Break"><span class="koboSpan" id="kobo.1383.1">in templates.</span></span></p>
<h1 id="_idParaDest-138"><a id="_idTextAnchor356"/><span class="koboSpan" id="kobo.1384.1">Constrained templates – the best practices</span></h1>
<p><span class="koboSpan" id="kobo.1385.1">We have recommended</span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.1386.1"> the most useful SFINAE and concept-based techniques as we encountered them throughout the chapter, but we had a lot of material to cover, so it may be helpful to concisely restate these guidelines. </span><span class="koboSpan" id="kobo.1386.2">These guidelines are here mainly for a programmer who uses templates in their application code. </span><span class="koboSpan" id="kobo.1386.3">That includes the foundational code such as core template libraries of the applications, but a programmer writing a library such as STL, written for the widest possible use under extremely varied conditions and documented very precisely in a formal standard, would find these guidelines lacking in precision </span><span class="No-Break"><span class="koboSpan" id="kobo.1387.1">and formality:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1388.1">Learn the basic rules of SFINAE: in which contexts it applies (declarations) and in which it does not (</span><span class="No-Break"><span class="koboSpan" id="kobo.1389.1">function body).</span></span></li>
<li><span class="koboSpan" id="kobo.1390.1">The “natural” use of SFINAE that arises from using parameter-dependent types in the template declarations and argument-dependent expressions in the trailing return type is almost always the simplest way to express constraints on the template parameters (but see the </span><span class="No-Break"><span class="koboSpan" id="kobo.1391.1">next guideline).</span></span></li>
<li><span class="koboSpan" id="kobo.1392.1">Ask yourself whether you use a dependent type such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1393.1">T::value_type</span></strong><span class="koboSpan" id="kobo.1394.1"> because this is precisely the right type for the context where you use it, or is it just simpler than writing the real constraint on the interface (such as “any type that converts to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1395.1">T::value_type</span></strong><span class="koboSpan" id="kobo.1396.1"> )? </span><span class="koboSpan" id="kobo.1396.2">In the latter case, this chapter should have convinced you that such restrictions are not that hard </span><span class="No-Break"><span class="koboSpan" id="kobo.1397.1">to express.</span></span></li>
<li><span class="koboSpan" id="kobo.1398.1">Whenever it makes</span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.1399.1"> sense, make your templates more general by using additional template parameters and necessary constraints on them (instead of using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1400.1">T::value_type</span></strong><span class="koboSpan" id="kobo.1401.1"> as an argument type, use another template parameter and constrain it to be convertible </span><span class="No-Break"><span class="koboSpan" id="kobo.1402.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1403.1">T::value_type</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1404.1">).</span></span></li>
<li><span class="koboSpan" id="kobo.1405.1">If you use C++20 and have access to concepts, avoid using “artificial” SFINAE, i.e. </span><span class="koboSpan" id="kobo.1405.2">do not create substitution failures whose only purpose is to constrain the template. </span><span class="koboSpan" id="kobo.1405.3">Use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1406.1">requires</span></strong><span class="koboSpan" id="kobo.1407.1"> clauses, with or without concepts, </span><span class="No-Break"><span class="koboSpan" id="kobo.1408.1">as needed.</span></span></li>
<li><span class="koboSpan" id="kobo.1409.1">If you can’t use C++20 concepts, choose a common uniform approach to SFINAE-based constraints and follow it. </span><span class="koboSpan" id="kobo.1409.2">Take advantage of the concept-based approach developed for C++20 even if you can’t use the language tools: follow the same style and patterns when applying SFINAE-based techniques. </span><span class="koboSpan" id="kobo.1409.3">The previous section presented one </span><span class="No-Break"><span class="koboSpan" id="kobo.1410.1">such approach.</span></span></li>
<li><span class="koboSpan" id="kobo.1411.1">Ideally, if a template declaration meets all specified restrictions, there should be no substitution errors in the body of the template (i.e. </span><span class="koboSpan" id="kobo.1411.2">if the function invokes, it compiles). </span><span class="koboSpan" id="kobo.1411.3">This is a difficult goal in practice: the restrictions may end up being verbose and sometimes difficult to write up, and you may not even be aware of all the constraints your implementation implicitly demands. </span><span class="koboSpan" id="kobo.1411.4">Even STL, designed with the benefit of the committee scrutinizing every word in its requirements, does not fully meet this goal. </span><span class="koboSpan" id="kobo.1411.5">Nonetheless, it is a good practice to aim for. </span><span class="koboSpan" id="kobo.1411.6">Also, if you must allow a function to be invoked but not compile, at least have the requirements codified by static asserts in the body of the function – they are much easier for your users to understand than the strange substitution errors </span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.1412.1">in types they never even </span><span class="No-Break"><span class="koboSpan" id="kobo.1413.1">heard of.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1414.1">After reading this chapter, these guidelines should not be too daunting </span><span class="No-Break"><span class="koboSpan" id="kobo.1415.1">for you.</span></span></p>
<h1 id="_idParaDest-139"><a id="_idTextAnchor357"/><span class="koboSpan" id="kobo.1416.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1417.1">SFINAE is a somewhat esoteric feature of the C++ standard - it is complex and has many subtle details. </span><span class="koboSpan" id="kobo.1417.2">While it is usually mentioned in the context of </span><em class="italic"><span class="koboSpan" id="kobo.1418.1">manual control of the overload resolution</span></em><span class="koboSpan" id="kobo.1419.1">, its main purpose is actually not to enable very elaborate guru-level code but to make the regular (automatic) overload resolution work the way the programmer intended. </span><span class="koboSpan" id="kobo.1419.2">In this role, it usually works exactly as desired and with no additional effort - in fact, the programmer usually does not need to even be aware of this feature. </span><span class="koboSpan" id="kobo.1419.3">Most of the time, when you write a generic overload and a special overload for the pointers, you expect the latter not to be called for types that are not pointers. </span><span class="koboSpan" id="kobo.1419.4">Most of the time, you probably don’t even pause to notice that the rejected overload would be ill-formed - who cares, it’s not supposed to be used. </span><span class="koboSpan" id="kobo.1419.5">But to find out that it’s not supposed to be used, the type has to be substituted, which would result in an invalid code. </span><span class="koboSpan" id="kobo.1419.6">SFINAE breaks this chicken-and-egg problem - to find out that the overload should be rejected, we have to substitute types, but that would create code that should not compile, which should not be a problem, because the overload should be rejected in the first place, but we do not know that until we substitute the types, and so on. </span><span class="koboSpan" id="kobo.1419.7">This is what we call “</span><span class="No-Break"><span class="koboSpan" id="kobo.1420.1">natural” SFINAE.</span></span></p>
<p><span class="koboSpan" id="kobo.1421.1">Of course, we did not go through a few dozen pages just to learn that the compiler magically does the right thing and you don’t have to worry about it. </span><span class="koboSpan" id="kobo.1421.2">The more elaborate use of SFINAE is to create an artificial substitution failure, and thus take control of the overload resolution by removing some of the overloads. </span><span class="koboSpan" id="kobo.1421.3">In this chapter, we learned the </span><em class="italic"><span class="koboSpan" id="kobo.1422.1">safe </span></em><span class="koboSpan" id="kobo.1423.1">contexts for these </span><em class="italic"><span class="koboSpan" id="kobo.1424.1">temporary </span></em><span class="koboSpan" id="kobo.1425.1">errors that are eventually suppressed by SFINAE. </span><span class="koboSpan" id="kobo.1425.2">With careful application, this technique can be used to inspect and differentiate, at compile time, anything from the simple features of different types (</span><em class="italic"><span class="koboSpan" id="kobo.1426.1">is this a class?</span></em><span class="koboSpan" id="kobo.1427.1">) to complex behaviors that can be provided by any number of C++ language features (</span><em class="italic"><span class="koboSpan" id="kobo.1428.1">is there any way to add these two types?</span></em><span class="koboSpan" id="kobo.1429.1">). </span><span class="koboSpan" id="kobo.1429.2">In C++20, such code is greatly simplified by introducing constraints and concepts. </span><span class="koboSpan" id="kobo.1429.3">However, we can apply concept-inspired thinking even to the code written for </span><span class="No-Break"><span class="koboSpan" id="kobo.1430.1">earlier standards.</span></span></p>
<p><span class="koboSpan" id="kobo.1431.1">In the next chapter, we will introduce another advanced template pattern that is used to greatly increase the power of class hierarchies in C++: class inheritance lets us pass information from the base class to the derived, and the Curiously Recurring Template Pattern does the opposite, it makes the base class aware of </span><span class="No-Break"><span class="koboSpan" id="kobo.1432.1">the derived.</span></span></p>
<h1 id="_idParaDest-140"><a id="_idTextAnchor358"/><span class="koboSpan" id="kobo.1433.1">Questions</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1434.1">What is an </span><span class="No-Break"><span class="koboSpan" id="kobo.1435.1">overload set?</span></span></li>
<li><span class="koboSpan" id="kobo.1436.1">What is </span><span class="No-Break"><span class="koboSpan" id="kobo.1437.1">overload resolution?</span></span></li>
<li><span class="koboSpan" id="kobo.1438.1">What are type deduction and </span><span class="No-Break"><span class="koboSpan" id="kobo.1439.1">type substitution?</span></span></li>
<li><span class="koboSpan" id="kobo.1440.1">What </span><span class="No-Break"><span class="koboSpan" id="kobo.1441.1">is SFINAE?</span></span></li>
<li><span class="koboSpan" id="kobo.1442.1">In what contexts can potentially invalid code be present and not trigger a compilation error, unless that code is </span><span class="No-Break"><span class="koboSpan" id="kobo.1443.1">actually needed?</span></span></li>
<li><span class="koboSpan" id="kobo.1444.1">How can we determine which overload was chosen without actually </span><span class="No-Break"><span class="koboSpan" id="kobo.1445.1">calling it?</span></span></li>
<li><span class="koboSpan" id="kobo.1446.1">How is SFINAE used to control </span><span class="No-Break"><span class="koboSpan" id="kobo.1447.1">conditional compilation?</span></span></li>
<li><span class="koboSpan" id="kobo.1448.1">Why are C++20 constraints superior to SFINAE for </span><span class="No-Break"><span class="koboSpan" id="kobo.1449.1">constraining templates?</span></span></li>
<li><span class="koboSpan" id="kobo.1450.1">How does the C++20 concepts standard benefit the programmers using earlier </span><span class="No-Break"><span class="koboSpan" id="kobo.1451.1">language versions?</span></span></li>
</ol>
</div>


<div class="Content" id="_idContainer021">
<h1 id="_idParaDest-141"><a id="_idTextAnchor359"/><span class="koboSpan" id="kobo.1.1">Part 3: C++ Design Patterns</span></h1>
<p><span class="koboSpan" id="kobo.2.1">This part begins with the main portion of the book. </span><span class="koboSpan" id="kobo.2.2">It introduces the most important, frequently used C++ design patterns. </span><span class="koboSpan" id="kobo.2.3">Each pattern is generally used as a commonly accepted approach to solving a certain type of problem. </span><span class="koboSpan" id="kobo.2.4">Exactly what the problem is, varies a great deal: some are system architecture challenges, others are interface design problems, yet others deal with </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">program performance.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B19262_08.xhtml#_idTextAnchor360"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 8</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">The Curiously Recurring Template Pattern</span></em></li>
<li><a href="B19262_09.xhtml#_idTextAnchor406"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">Named Arguments, Method Chaining, and Builder Pattern</span></em></li>
<li><a href="B19262_10.xhtml#_idTextAnchor453"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 10</span></em></a><span class="koboSpan" id="kobo.13.1">, </span><em class="italic"><span class="koboSpan" id="kobo.14.1">Local Buffer Optimization</span></em></li>
<li><a href="B19262_11.xhtml#_idTextAnchor509"><em class="italic"><span class="koboSpan" id="kobo.15.1">Chapter 11</span></em></a><span class="koboSpan" id="kobo.16.1">, </span><em class="italic"><span class="koboSpan" id="kobo.17.1">Scopeguard</span></em></li>
<li><a href="B19262_12.xhtml#_idTextAnchor562"><em class="italic"><span class="koboSpan" id="kobo.18.1">Chapter 12</span></em></a><span class="koboSpan" id="kobo.19.1">, </span><em class="italic"><span class="koboSpan" id="kobo.20.1">Friend Factory</span></em></li>
<li><a href="B19262_13.xhtml#_idTextAnchor596"><em class="italic"><span class="koboSpan" id="kobo.21.1">Chapter 13</span></em></a><span class="koboSpan" id="kobo.22.1">, </span><em class="italic"><span class="koboSpan" id="kobo.23.1">Virtual Constructors and Factories</span></em></li>
<li><a href="B19262_14.xhtml#_idTextAnchor640"><em class="italic"><span class="koboSpan" id="kobo.24.1">Chapter 14</span></em></a><span class="koboSpan" id="kobo.25.1">, </span><em class="italic"><span class="koboSpan" id="kobo.26.1">The Template Method Pattern and the Non-Virtual Idiom</span></em></li>
</ul>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer022">
</div>
</div>
<div>
<div id="_idContainer023">
</div>
</div>
</body></html>