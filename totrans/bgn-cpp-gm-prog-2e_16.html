<html><head></head><body>
		<div><h1 id="_idParaDest-297"><a id="_idTextAnchor306"/><em class="italic">Chapter 15</em>: Advanced OOP – Inheritance and Polymorphism</h1>
			<p>In this chapter, we will further extend our knowledge of OOP by looking at the slightly more advanced concepts of <strong class="bold">inheritance</strong> and <strong class="bold">polymorphism</strong>. We will then be able to use this new knowledge to implement the star characters of our game, Thomas and Bob. Here is what we will cover in this chapter:</p>
			<ul>
				<li>Learn how to extend and modify a class using inheritance</li>
				<li>Treat an object of a class as if it is more than one type of class by using polymorphism </li>
				<li>Learn about abstract classes and how designing classes that are never instantiated can actually be useful</li>
				<li>Build an abstract <code>PlayableCharacter</code> class</li>
				<li>Put inheritance to work with the <code>Thomas</code> and <code>Bob</code> classes</li>
				<li>Add Thomas and Bob to the game project</li>
			</ul>
			<h1 id="_idParaDest-298"><a id="_idTextAnchor307"/>Inheritance</h1>
			<p>We have already seen how we can use other people's hard work by instantiating objects from the classes of the SFML library. But this whole OOP thing goes even further than that.</p>
			<p>What if there is a class that has loads of useful functionality in it, but is not quite what we want? In this situation, we can <strong class="bold">inherit </strong>from the other class. Just like it sounds, <strong class="bold">inheritance </strong>means we can harness all the features and benefits of other people's classes, including the encapsulation, while further refining or extending the code specifically to our situation. In this project, we will inherit from and extend some SFML classes; we will also do so with our own classes.</p>
			<p>Let's look at some code that uses inheritance.</p>
			<h2 id="_idParaDest-299"><a id="_idTextAnchor308"/>Extending a class</h2>
			<p>With all this in mind, let's look at an example class and see how we can extend it, just to see the syntax and as a first step.</p>
			<p>First, we define a class to inherit from. This is no different from how we created any of our other classes. Take a look at this hypothetical <code>Soldier</code> class declaration:</p>
			<pre>class Soldier
{
    private:
        // How much damage can the soldier take
        int m_Health;
        int m_Armour;
        int m_Range;
        int m_ShotPower;
        
    
    Public:
        void setHealth(int h);
        void setArmour(int a);    
        void setRange(int r);
        void setShotPower(int p);
};</pre>
			<p>In the previous code, we define a <code>Soldier</code> class. It has four private variables: <code>m_Health</code>, <code>m_Armour</code>, <code>m_Range</code>, and <code>m_ShotPower</code>. It has also four public functions: <code>setHealth</code>, <code>setArmour, setRange</code>, and<code> setShotPower</code>. We don't need to see the definitions of these functions; they will simply initialize the appropriate variable that their name makes obvious. </p>
			<p>We can also imagine that a fully implemented <code>Soldier</code> class would be much more in-depth than this. It would probably have functions such as <code>shoot</code>, <code>goProne</code>, and so on. If we implemented a <code>Soldier</code> class in an SFML project, it would likely have a <code>Sprite</code> object, as well as an <code>update</code> and a <code>getPostion</code> function. </p>
			<p>The simple scenario that we've presented here is suitable if we wish to learn about inheritance. Now, let's look at something new: inheriting from the <code>Soldier</code> class. Look at the following code, especially the highlighted part:</p>
			<pre>class Sniper <strong class="bold">: public Soldier</strong>
{
public:
    // A constructor specific to Sniper
    Sniper::Sniper();
};</pre>
			<p>By adding <code>: public Soldier</code> to the <code>Sniper</code> class declaration, <code>Sniper</code> inherits from <code>Soldier</code>. But what does this mean, exactly? <code>Sniper</code> <code>Soldier</code>. It has all the variables and functions of <code>Soldier</code>. Inheritance is even more than this, however. </p>
			<p>Also note that, in the previous code, we declare a <code>Sniper</code> constructor. This constructor is unique to <code>Sniper</code>. We have not only inherited from <code>Soldier</code>; we have <code>Soldier</code>. All the functionality (definitions) of the <code>Soldier</code> class would be handled by the <code>Soldier</code> class, but the definition of the <code>Sniper</code> constructor must be handled by the <code>Sniper</code> class.</p>
			<p>Here is what the hypothetical <code>Sniper</code> constructor definition might look like:</p>
			<pre>// In Sniper.cpp
Sniper::Sniper()
{
    setHealth(10);
    setArmour(10);    
    setRange(1000);
    setShotPower(100);
}</pre>
			<p>We could go ahead and write a bunch of other classes that are extensions of the <code>Soldier</code> class, perhaps <code>Commando</code> and <code>Infantryman</code>. Each would have the exact same variables and functions, but each could also have a unique constructor that initializes those variables appropriate to the specific type of <code>Soldier</code>. <code>Commando</code> might have very high <code>m_Health</code> and <code>m_ShotPower</code> but really puny <code>m_Range</code>. <code>Infantryman</code> might be in between <code>Commando</code> and <code>Sniper</code> with mediocre values for each variable.</p>
			<p>As if OOP wasn't useful enough already, we can now model real-world objects, including their hierarchies. We can achieve this by sub-classing/extending/inheriting from other classes. </p>
			<p>The terminology we might like to learn here is that the class that is extended from is the <strong class="bold">super-class</strong>, and the class that inherits from the super-class is the <strong class="bold">sub-class</strong>. We can also say <strong class="bold">parent</strong> and <strong class="bold">child</strong> class.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">You might find yourself asking this question about inheritance: why? The reason is something like this: we can write common code once; in the parent class, we can update that common code and all the classes that inherit from it are also updated. Furthermore, a sub-class only gets to use public and <strong class="bold">protected</strong> instance variables and functions. So, designed properly, this also enhances the goals of encapsulation.</p>
			<p>Did you say protected? Yes. There is an access specifier for class variables and functions called <code>protected</code> specifier:</p>
			<ul>
				<li><code>Public</code> variables and functions can be accessed and used by anyone with an instance of the class.</li>
				<li><code>Private</code> variables and functions can only accessed/used by the internal code of the class, and not directly from an instance. This is good for encapsulation and when we need to access/change private variables, since we can provide public getter and setter functions (such as <code>getSprite</code>). If we extend a class that has <code>private</code> variables and functions, that child class <strong class="bold">cannot</strong> directly access the private data of its parent.</li>
				<li><code>Protected</code> variables and functions are almost the same as private. They cannot be accessed/used directly by an instance of the class. However, they <strong class="bold">can</strong> be used directly by any class that extends the class they are declared in. So, it is like they are private, except to child classes. </li>
			</ul>
			<p>To fully understand what protected variables and functions are and how they can be useful, let's look at another topic first. Then, we will see them in action.</p>
			<h1 id="_idParaDest-300"><a id="_idTextAnchor309"/>Polymorphism</h1>
			<p><strong class="bold">Polymorphism</strong> allows us to write code that is less dependent on the types we are trying to manipulate. This can make our code clearer and more efficient. Polymorphism means many forms. If the objects that we code can be more than one type of thing, then we can take advantage of this.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">But what does polymorphism mean to us? Boiled down to its simplest definition, polymorphism means the following: any sub-class can be used as part of the code that uses the super-class. This means we can write code that is simpler and easier to understand and also easier to modify or change. Also, we can write code for the super-class and rely on the fact that no matter how many times it is sub-classed, within certain parameters, the code will still work.</p>
			<p>Let's discuss an example. </p>
			<p>Suppose we want to use polymorphism to help write a zoo management game where we must feed and tend to the needs of animals. We will probably want to have a function such as <code>feed</code>. We will also probably want to pass an instance of the animal to be fed into the <code>feed</code> function. </p>
			<p>A zoo, of course, has lots of animals, such as Lion, Elephant, and Three-toed Sloth. With our new knowledge of C++ inheritance, it makes sense to code an <code>Animal</code> class and have all the different types of animal inherit from it.</p>
			<p>If we want to write a function (<code>feed</code>) that we can pass <code>Lion</code>, <code>Elephant</code>, and <code>ThreeToedSloth</code> into as a parameter, it might seem like we need to write a <code>feed</code> function for each type of <code>Animal</code>. However, we can write polymorphic functions with polymorphic return types and arguments. Take a look at the following definition of the hypothetical feed function:</p>
			<pre>void feed(Animal&amp; a)
{
    a.decreaseHunger();
}</pre>
			<p>The preceding function has an <code>Animal</code> reference as a parameter, meaning that any object that is built from a class that extends <code>Animal</code> can be passed into it. </p>
			<p>This means you can write code today and make another subclass in a week, month, or year, and the very same functions and data structures will still work. Also, we can enforce a set of rules upon our subclasses regarding what they can and cannot do, as well as how they do it. So, good design in one stage can influence it at other stages. </p>
			<p>But will we ever really want to instantiate an actual Animal?</p>
			<h1 id="_idParaDest-301"><a id="_idTextAnchor310"/>Abstract classes – virtual and pure virtual functions</h1>
			<p>An <strong class="bold">abstract class</strong> is a class that cannot be instantiated and therefore cannot be made into an object.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Some terminology we might like to learn about here is <em class="italic">concrete</em> class. A <strong class="bold">concrete class</strong> is any class that isn't abstract. In other words, all the classes we have written so far have been concrete classes and can be instantiated into usable objects.</p>
			<p>So, it's code that will never be used, then? But that's like paying an architect to design your home and then never building it! </p>
			<p>If we, or the designer of a class, wants to force its users to inherit it before using their class, they can make a class <strong class="bold">abstract</strong>. If this happens, we cannot make an object from it; therefore, we must inherit from it first and make an object from the sub-class.</p>
			<p>To do so, we can make a function <strong class="bold">pure virtual</strong> and not provide any definition. Then, that function must be<strong class="bold"> overridden </strong>(<strong class="bold">rewritten</strong>) in any class that inherits from it.</p>
			<p>Let's look at an example; it will help. We can make a class abstract by adding a pure virtual function such as the abstract <code>Animal</code> class, which can only perform the generic action of <code>makeNoise</code>:</p>
			<pre>Class Animal
    private:
        // Private stuff here
    public:
        void virtual makeNoise() = 0;
        // More public stuff here
};</pre>
			<p>As you can see, we add the C++ keyword <code>virtual, </code>before, and <code>= 0</code> after the function declaration. Now, any class that extends/inherits from <code>Animal</code> must override the <code>makeNoise </code>function. This might make sense since different types of animal make very different types of noise. We could have assumed that anybody who extends the <code>Animal</code> class is smart enough to notice that the <code>Animal</code> class cannot make a noise and that they will need to handle it, but what if they don't notice? The point is that by making a pure virtual function, we guarantee that they will, because they must.</p>
			<p>Abstract classes are also useful because, sometimes, we want a class that can be used as a polymorphic type, but we need to guarantee it can never be used as an object. For example, <code>Animal</code> doesn't really make sense on its own. We don't talk about animals; we talk about types of animals. We don't say, "Ooh, look at that lovely, fluffy, white animal!", or, "Yesterday we went to the pet shop and got an animal and an animal bed." It's just too, well, abstract.</p>
			<p>So, an abstract class is kind of like a <code>Worker</code> class, for example, and extend it to make <code>Miner</code>, <code>Steelworker</code>, <code>OfficeWorker</code>, and, of course, <code>Programmer</code>. But what exactly does a plain <code>Worker</code> do? Why would we ever want to instantiate one?</p>
			<p>The answer is we wouldn't want to instantiate one, but we might want to use it as a polymorphic type so that we can pass multiple <code>Worker</code> sub-classes between functions and have data structures that can hold all types of workers. </p>
			<p>All pure virtual functions must be overridden by any class that extends the parent class that contains the pure virtual function. This means that the abstract class can provide some of the common functionality that would be available in all its subclasses. For example, the <code>Worker</code> class might have the <code>m_AnnualSalary</code>, <code>m_Productivity</code>, and <code>m_Age</code> member variables. It might also have the <code>getPayCheck</code> function, which is not pure virtual and is the same in all the sub-classes, but a <code>doWork</code> function, which is pure virtual and must be overridden, because all the different types of <code>Worker</code> will <code>doWork</code> very differently.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">By the way, <code>= 0</code> off to the end. In the current game project, we will use a pure virtual function.</p>
			<p>If any of this virtual, pure virtual, or abstract stuff is unclear, using it is probably the best way to understand it.</p>
			<h1 id="_idParaDest-302"><a id="_idTextAnchor311"/>Building the PlayableCharacter class</h1>
			<p>Now that we know the basics of inheritance, polymorphism, and pure virtual functions, we will put them to use. We will build a <code>PlayableCharacter</code> class that has most of the functionality that any character from our game is going to need. It will have one pure virtual function, known as <code>handleInput</code>. The <code>handleInput</code> function will need to be quite different in the sub-classes, so this makes sense. </p>
			<p>As <code>PlayableCharacter</code> will have a pure virtual function, it will be an abstract class and no objects of it will be possible. We will then build the <code>Thomas</code> and <code>Bob</code> classes, which will inherit from <code>PlayableCharacter</code>, implement the definition of the pure virtual function, and allow us to instantiate <code>Bob</code> and <code>Thomas</code> objects in our game. It will not be possible to instantiate a <code>PlayableCharacter</code> instance directly, but we wouldn't want to because it is too abstract anyway.</p>
			<h2 id="_idParaDest-303"><a id="_idTextAnchor312"/>Coding PlayableCharacter.h</h2>
			<p>As usual when creating a class, we will start off with the header file that will contain the member variable and function declarations. What is new is that, in this class, we will declare some <strong class="bold">protected</strong> member variables. Remember that protected variables can be used as if they were public in classes that inherit from the class with the protected variables.</p>
			<p>Right-click <code>PlayableCharacter.h</code>. Finally, click the <code>PlayableCharacter</code> class.</p>
			<p>We will add and discuss the contents of the <code>PlayableCharacter.h</code> file in three sections. First will be the <code>protected</code> section, followed by <code>private</code>, and then <code>public</code>.</p>
			<p>Add the following code to the <code>PlayableCharacter.h</code> file:</p>
			<pre>#pragma once
#include &lt;SFML/Graphics.hpp&gt;
using namespace sf;
class PlayableCharacter
{
protected:
    // Of course we will need a sprite
    Sprite m_Sprite;
    // How long does a jump last
    float m_JumpDuration;
    // Is character currently jumping or falling
    bool m_IsJumping;
    bool m_IsFalling;
    // Which directions is the character currently moving in
    bool m_LeftPressed;
    bool m_RightPressed;
    // How long has this jump lasted so far
    float m_TimeThisJump;
    // Has the player just initiated a jump
    bool m_JustJumped = false;
    // Private variables and functions come next</pre>
			<p>The first thing to notice in the code we just wrote is that all the variables are <code>protected</code>. This means that when we inherit from the class, all the variables we just wrote will be accessible to those classes that extend it. We will extend this class with the <code>Thomas</code> and <code>Bob</code> classes.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The terms <em class="italic">inherit from</em> and <em class="italic">extend</em> are virtually synonymous in most contexts in this book. Sometimes, one seems more appropriate than the other, however.</p>
			<p>Apart from the <code>protected</code> access specification, there is nothing new or complicated about the previous code. It is worth paying attention to some of the details, however. If we do, it will be easy to understand how the class works as we progress. So, let's run through those <code>protected</code> variables, one at a time.</p>
			<p>We have our somewhat predictable <code>Sprite</code>, <code>m_Sprite</code>. We have a <code>float</code> variable called <code>m_JumpDuration</code>, which will hold a value representing the time that the character is able to jump for. The greater the value, the further/higher the character will be able to jump.</p>
			<p>Next, we have a Boolean <code>m_IsJumping</code>, which is <code>true</code> when the character is jumping and <code>false</code> otherwise. This will be useful for making sure that the character can't jump while in mid-air.</p>
			<p>The <code>m_IsFalling</code> variable has a similar use to <code>m_IsJumping</code>. It will be used to know when a character is falling.</p>
			<p>Next, we have two Booleans that will be true if the character's left or right keyboard buttons are currently being pressed. These are relatively dependent upon the character (<em class="italic">A</em> and <em class="italic">D</em> for Thomas, and the <em class="italic">Left</em> and <em class="italic">Right</em> arrow keys for Bob, respectively). How we respond to these Booleans will be seen in the <code>Thomas</code> and <code>Bob</code> classes.</p>
			<p>The  <code>m_TimeThisJump</code> float variable is updated each frame that <code>m_IsJumping</code> is <code>true</code>. We can then find out when <code>m_JumpDuration</code> has been reached.</p>
			<p>The final <code>protected</code> variable is the <code>m_JustJumped</code> Boolean. This will be <code>true</code> if a jump was initiated in the current frame. It will be used so that we know when to play a jump sound effect.</p>
			<p>Next, add the following <code>private</code> variables to the <code>PlayableCharacter.h</code> file:</p>
			<pre>private:
    // What is the gravity
    float m_Gravity;
    // How fast is the character
    float m_Speed = 400;
    // Where is the player
    Vector2f m_Position;
    // Where are the characters various body parts?
    FloatRect m_Feet;
    FloatRect m_Head;
    FloatRect m_Right;
    FloatRect m_Left;
    // And a texture
    Texture m_Texture;
    // All our public functions will come next</pre>
			<p>In the previous code, we have some interesting <code>private</code> variables. Remember that these variables will only be directly accessible to the code in the <code>PlayableCharacter</code> class. The <code>Thomas</code> and <code>Bob</code> classes will not be able to access them directly.</p>
			<p>The <code>m_Gravity</code> variable will hold the number of pixels per second that the character will fall. The <code>m_Speed</code> variable will hold the number of pixels per second that the character can move left or right.</p>
			<p>The <code>Vector2f</code>, <code>m_Position</code> variable is the position in the world (not the screen) where the center of the character is.</p>
			<p>The next four <code>FloatRect</code> objects are important to discuss. When we did collision detection in the <em class="italic">Zombie Arena</em> game, we simply checked to see if two <code>FloatRect</code> objects intersected. Each <code>FloatRect</code> object represented an entire character, a pickup, or a bullet. For the non-rectangular shaped objects (zombies and the player), this was a little bit inaccurate.</p>
			<p>In this game, we will need to be more precise. The <code>m_Feet</code>, <code>m_Head</code>, <code>m_Right</code>,  <code>m_Left</code>, and <code>FloatRect</code> objects will hold the coordinates of the different parts of a character's body. These coordinates will be updated each frame. </p>
			<p>Through these coordinates, we will be able to tell exactly when a character lands on a platform, bumps their head during a jump, or rubs shoulders with a tile to their side.</p>
			<p>Lastly, we have a <code>Texture</code>. The <code>Texture</code> is <code>private</code> as it is not used directly by the <code>Thomas</code> or <code>Bob</code> classes. However, as we saw, the <code>Sprite</code> is <code>protected</code> because it is used directly.</p>
			<p>Now, add all the <code>public</code> functions to the <code>PlayableCharacter.h</code> file. Then, we will discuss them:</p>
			<pre>public:
    void spawn(Vector2f startPosition, float gravity);
    // This is a pure virtual function
    bool virtual handleInput() = 0;
    // This class is now abstract and cannot be instantiated
    // Where is the player
    FloatRect getPosition();
    // A rectangle representing the position 
    // of different parts of the sprite
    FloatRect getFeet();
    FloatRect getHead();
    FloatRect getRight();
    FloatRect getLeft();
    // Send a copy of the sprite to main
    Sprite getSprite();
    // Make the character stand firm
    void stopFalling(float position);
    void stopRight(float position);
    void stopLeft(float position);
    void stopJump();
    // Where is the center of the character
    Vector2f getCenter();
    // We will call this function once every frame
    void update(float elapsedTime);
    
};// End of the class</pre>
			<p>Let's talk about each of the function declarations that we just added. This will make coding their definitions easier to follow:</p>
			<ul>
				<li>The <code>spawn</code> function receives a <code>Vector2f</code> called <code>startPosition</code> and a <code>float</code> value called <code>gravity</code>. As the names suggest, <code>startPosition</code> will be the coordinates in the level that the character will start, and <code>gravity</code> will be the number of pixels per second at which the character will fall.</li>
				<li><code>bool virtual handleInput() = 0</code> is, of course our pure virtual function. Since <code>PlayableCharacter</code> has this function, any class that extends it, if we want to instantiate it, must provide a definition for this function. Therefore, when we write all the function definitions for <code>PlayableCharacter</code> in a minute, we will not provide a definition for <code>handleInput</code>. There will need to be definitions in both the <code>Thomas</code> and <code>Bob</code> classes.</li>
				<li>The <code>getPosition</code> function returns a <code>FloatRect</code> object that represents the position of the whole character.</li>
				<li>The <code>getFeet()</code> function, as well as <code>getHead</code>, <code>getRight</code>, and <code>getLeft</code>, return a <code>FloatRect</code> object that represents the location of a specific part of the character's body. This is just what we need for detailed collision detection.</li>
				<li>The <code>getSprite</code> function, as usual, returns a copy of <code>m_Sprite</code> to the calling code.</li>
				<li>The <code>stopFalling</code>, <code>stopRight</code>, <code>stopLeft</code>, and <code>stopJump</code> functions receive a single <code>float</code> value that the function will use to reposition the character and stop it walking or jumping through a solid tile.</li>
				<li>The <code>getCenter</code> function returns a <code>Vector2f</code> object to the calling code to let it know exactly where the center of the character is. This value is held in <code>m_Position</code>. As we will see later, it is used by the <code>Engine</code> class to center the appropriate <code>View</code> around the appropriate character.</li>
				<li>We have seen the <code>update</code> function many times before and, as usual, it takes a <code>float</code> parameter, which is the fraction of a second the current frame has taken. This <code>update</code> function will need to do more work than previous <code>update</code> functions (from our other projects), however. It will need to handle jumping as well as updating the <code>FloatRect</code> objects that represent the head, feet, and left- and right-hand sides of the character.</li>
			</ul>
			<p>Now, we can write the definitions for all the functions, except, of course, <code>handleInput</code>.</p>
			<h2 id="_idParaDest-304"><a id="_idTextAnchor313"/>Coding PlayableCharacter.cpp</h2>
			<p>Right-click <code>PlayableCharacter.cpp</code>. Finally, click the <code>.cpp</code> file for the <code>PlayableCharacter</code> class.</p>
			<p>We will break up the code and discuss it in several chunks. First, add the include directives and the definition of the <code>spawn</code> function:</p>
			<pre>#include "PlayableCharacter.h"
void PlayableCharacter::spawn(
        Vector2f startPosition, float gravity)
{
    // Place the player at the starting point
    m_Position.x = startPosition.x;
    m_Position.y = startPosition.y;
    // Initialize the gravity
    m_Gravity = gravity;
    // Move the sprite in to position
    m_Sprite.setPosition(m_Position);
}</pre>
			<p>The <code>spawn</code> function initializes <code>m_Position</code> with the passed-in position, and also initializes <code>m_Gravity</code>. The final line of code moves <code>m_Sprite</code> to its starting position.</p>
			<p>Next, add the definition for the <code>update</code> function immediately after the previous code:</p>
			<pre>void PlayableCharacter::update(float elapsedTime)
{
    if (m_RightPressed)
    {
        m_Position.x += m_Speed * elapsedTime;
    }
    if (m_LeftPressed)
    {
        m_Position.x -= m_Speed * elapsedTime;
    }
    // Handle Jumping
    if (m_IsJumping)
    {
        // Update how long the jump has been going
        m_TimeThisJump += elapsedTime;
        // Is the jump going upwards
        if (m_TimeThisJump &lt; m_JumpDuration)
        {
            // Move up at twice gravity
            m_Position.y -= m_Gravity * 2 * elapsedTime;
        }
        else
        {
            m_IsJumping = false;
            m_IsFalling = true;
        }
    }
    // Apply gravity
    if (m_IsFalling)
    {
        m_Position.y += m_Gravity * elapsedTime;
    }
    // Update the rect for all body parts
    FloatRect r = getPosition();
    
    // Feet
    m_Feet.left = r.left + 3;
    m_Feet.top = r.top + r.height - 1;
    m_Feet.width = r.width - 6;
    m_Feet.height = 1;
    // Head
    m_Head.left = r.left;
    m_Head.top = r.top + (r.height * .3);
    m_Head.width = r.width;
    m_Head.height = 1;
    // Right
    m_Right.left = r.left + r.width - 2;
    m_Right.top = r.top + r.height * .35;
    m_Right.width = 1;
    m_Right.height = r.height * .3;
    // Left
    m_Left.left = r.left;
    m_Left.top = r.top + r.height * .5;
    m_Left.width = 1;
    m_Left.height = r.height * .3;
    // Move the sprite into position
    m_Sprite.setPosition(m_Position);
}</pre>
			<p>The first two parts of the code check whether <code>m_RightPressed</code> or <code>m_LeftPressed</code> is <code>true</code>. If either of them is, then <code>m_Position</code> is changed using the same formula as the previous project (elapsed time multiplied by speed).</p>
			<p>Next, we see whether the character is currently executing a jump. We know this from <code>if(m_IsJumping)</code>. If this <code>if</code> statement is <code>true</code>, these are the steps the code takes:</p>
			<ol>
				<li>Updates <code>m_TimeThisJump</code> with <code>elapsedTime</code>.</li>
				<li>Checks if <code>m_TimeThisJump</code> is still less than <code>m_JumpDuration</code>. If it is, it changes the y coordinate of <code>m_Position</code> by 2x gravity, multiplied by the elapsed time.</li>
				<li>In the <code>else</code> clause that executes when <code>m_TimeThisJump</code> is not lower than <code>m_JumpDuration</code>, <code>m_Falling</code> is set to <code>true</code>. The effect of doing this will be seen next. Also, <code>m_Jumping</code> is set to <code>false</code>. This prevents the code we have just been discussing from executing, because <code>if(m_IsJumping)</code> is now false.</li>
			</ol>
			<p>The <code>if(m_IsFalling)</code> block moves <code>m_Position</code> down each frame. It is moved using the current value of <code>m_Gravity</code> and the elapsed time.</p>
			<p>The code that follows (most of the remaining code) updates the "body parts" of the character, relative to the current position of the sprite as a whole. Take a look at the following diagram to see how the code calculates the position of the virtual head, feet, and left- and right-hand sides of the character:</p>
			<div><div><img src="img/B14278_15_01.jpg" alt=""/>
				</div>
			</div>
			<p>The final line of code uses the <code>setPosition</code> function to move the sprite to its correct location after all the possibilities of the <code>update</code> function.</p>
			<p>Now, add the definitions for the <code>getPosition</code>, <code>getCenter</code>, <code>getFeet</code>, <code>getHead</code>, <code>getLeft</code>, <code>getRight</code>, and <code>getSprite</code> functions, immediately after the previous code:</p>
			<pre>FloatRect PlayableCharacter::getPosition()
{
    return m_Sprite.getGlobalBounds();
}
Vector2f PlayableCharacter::getCenter()
{
    return Vector2f(
        m_Position.x + m_Sprite.getGlobalBounds().width / 2,
        m_Position.y + m_Sprite.getGlobalBounds().height / 2
        );
}
FloatRect PlayableCharacter::getFeet()
{
    return m_Feet;
}
FloatRect PlayableCharacter::getHead()
{
    return m_Head;
}
FloatRect PlayableCharacter::getLeft()
{
    return m_Left;
}
FloatRect PlayableCharacter::getRight()
{
    return m_Right;
}
Sprite PlayableCharacter::getSprite()
{
    return m_Sprite;
}</pre>
			<p>The <code>getPosition</code> function returns a <code>FloatRect</code> that wraps the entire sprite, while <code>getCenter</code> returns a <code>Vector2f</code> that contains the center of the sprite. Notice that we divide the height and width of the sprite by 2 in order to dynamically arrive at this result. This is because Thomas and Bob will be of different heights.</p>
			<p>The <code>getFeet</code>, <code>getHead</code>, <code>getLeft</code>, and <code>getRight</code> functions return the <code>FloatRect</code> objects that represent the body parts of the character that we update each frame in the <code>update</code> function. We will write the collision detection code that uses these functions in the next chapter.</p>
			<p>The <code>getSprite</code> function, as usual, returns a copy of <code>m_Sprite</code>.</p>
			<p>Finally, for the <code>PlayableCharacter</code> class, add the definitions for the <code>stopFalling</code>, <code>stopRight</code>, <code>stopLeft</code>, and <code>stopJump</code> functions. Do so immediately after the previous code:</p>
			<pre>void PlayableCharacter::stopFalling(float position)
{
    m_Position.y = position - getPosition().height;
    m_Sprite.setPosition(m_Position);
    m_IsFalling = false;
}
void PlayableCharacter::stopRight(float position)
{
    
    m_Position.x = position - m_Sprite.getGlobalBounds().width;
    m_Sprite.setPosition(m_Position);
}
void PlayableCharacter::stopLeft(float position)
{
    m_Position.x = position + m_Sprite.getGlobalBounds().width;
    m_Sprite.setPosition(m_Position);
}
void PlayableCharacter::stopJump()
{
    // Stop a jump early 
    m_IsJumping = false;
    m_IsFalling = true;
}</pre>
			<p>Each of the previous functions receives a value as a parameter that is used to reposition either the top, bottom, left, or right of the sprite. Exactly what these values are and how they are obtained will be something for the next chapter. Each of the previous functions also repositions the sprite. </p>
			<p>The final function is the <code>stopJump</code> function, which will also be used in collision detection. It sets the necessary values for <code>m_IsJumping</code> and <code>m_IsFalling</code> to end a jump.</p>
			<h1 id="_idParaDest-305"><a id="_idTextAnchor314"/>Building the Thomas and Bob classes</h1>
			<p>Now, we get to use inheritance for real. We will build a class for Thomas and a class for Bob. They will both inherit from the <code>PlayableCharacter</code> class we just coded. They will then have all the functionality of the <code>PlayableCharacter</code> class, including direct access to its <code>protected</code> variables. We will also add the definition for the pure virtual function, <code>handleInput</code>. You will notice that the <code>handleInput</code> functions for <code>Thomas</code> and <code>Bob</code> will be different.</p>
			<h2 id="_idParaDest-306"><a id="_idTextAnchor315"/>Coding Thomas.h </h2>
			<p>Right-click <code>Thomas.h</code>. Finally, click the <code>Thomas</code> class.</p>
			<p>Add the following code to the <code>Thomas.h</code> class:</p>
			<pre>#pragma once
#include "PlayableCharacter.h"
class Thomas : public PlayableCharacter
{
public:
    // A constructor specific to Thomas
    Thomas::Thomas();
    // The overridden input handler for Thomas
    bool virtual handleInput();
};</pre>
			<p>The previous code is very short and sweet. We can see that we have a constructor and that we are going to implement the pure virtual <code>handleInput</code> function. So, let's do that now.</p>
			<h2 id="_idParaDest-307"><a id="_idTextAnchor316"/>Coding Thomas.cpp</h2>
			<p>Right-click <code>Thomas.cpp</code>. Finally, click the <code>.cpp</code> file for the <code>Thomas</code> class.</p>
			<p>Add the <code>Thomas</code> constructor to the <code>Thomas.cpp</code> file, as follows:</p>
			<pre>#include "Thomas.h"
#include "TextureHolder.h"
Thomas::Thomas()
{
    // Associate a texture with the sprite
    m_Sprite = Sprite(TextureHolder::GetTexture(
        "graphics/thomas.png"));
    m_JumpDuration = .45;
}</pre>
			<p>All we need to do is load the <code>thomas.png</code> graphic and set the duration of a jump (<code>m_JumpDuration</code>) to .<code>45 </code>(nearly half a second).</p>
			<p>Add the definition of the <code>handleInput</code> function as follows:</p>
			<pre>// A virtual function
bool Thomas::handleInput()
{
    m_JustJumped = false;
    if (Keyboard::isKeyPressed(Keyboard::W))
    {
        // Start a jump if not already jumping
        // but only if standing on a block (not falling)
        if (!m_IsJumping &amp;&amp; !m_IsFalling)
        {
            m_IsJumping = true;
            m_TimeThisJump = 0;
            m_JustJumped = true;
        }
    }
    else
    {
        m_IsJumping = false;
        m_IsFalling = true;
    }
    if (Keyboard::isKeyPressed(Keyboard::A))
    {
        m_LeftPressed = true;
    }
    else
    {
        m_LeftPressed = false;
    }
    if (Keyboard::isKeyPressed(Keyboard::D))
    {
        m_RightPressed = true;
    }
    else
    {
        m_RightPressed = false;
    }
    return m_JustJumped;
}</pre>
			<p>This code should look quite familiar to you. We are using the SFML <code>isKeyPressed</code> function to see whether any of the <em class="italic">W</em>, <em class="italic">A</em>, or <em class="italic">D</em> keys are being pressed. </p>
			<p>When <em class="italic">W</em> is pressed, the player is attempting to jump. The code then uses the <code>if(!m_IsJumping &amp;&amp; !m_IsFalling)</code> code to check that the character is not already jumping and that it is not falling either. When these tests are both true, <code>m_IsJumping</code> is set to <code>true</code>, <code>m_TimeThisJump</code> is set to 0, and <code>m_JustJumped</code> is set to <code>true</code>.</p>
			<p>When the previous two tests don't evaluate to <code>true</code>, the <code>else</code> clause is executed and <code>m_Jumping</code> is set to <code>false</code>, and <code>m_IsFalling</code> is set to true.</p>
			<p>Handling how the <em class="italic">A</em> and <em class="italic">D</em> keys are being pressed is as simple as setting <code>m_LeftPressed</code> and/or <code>m_RightPressed</code> to <code>true</code> or<code> false</code>. The <code>update</code> function will now be able to handle moving the character.</p>
			<p>The last line of code in the function returns the value of <code>m_JustJumped</code>. This will let the calling code know if it needs to play a jumping sound effect.</p>
			<p>We will now code the <code>Bob</code> class. It is nearly identical to the <code>Thomas</code> class, except it has different jumping abilities and a different <code>Texture</code>, and uses different keys on the keyboard.</p>
			<h2 id="_idParaDest-308"><a id="_idTextAnchor317"/>Coding Bob.h </h2>
			<p>The <code>Bob</code> class is identical in structure to the <code>Thomas</code> class. It inherits from <code>PlayableCharacter</code>, it has a constructor, and it provides the definition of the <code>handleInput</code> function. The difference compared to <code>Thomas</code> is that we initialize some of Bob's member variables differently and we handle input (in the <code>handleInput</code> function) differently as well. Let's code the class and look at the details.</p>
			<p>Right-click <code>Bob.h</code>. Finally, click the <code>Bob</code> class.</p>
			<p>Add the following code to the <code>Bob.h</code> file:</p>
			<pre>#pragma once
#include "PlayableCharacter.h"
class Bob : public PlayableCharacter
{
public:
    // A constructor specific to Bob
    Bob::Bob();
    // The overriden input handler for Bob
    bool virtual handleInput();
};</pre>
			<p>The previous code is identical to the <code>Thomas.h</code> file apart from the class name and therefore the constructor name.</p>
			<h2 id="_idParaDest-309"><a id="_idTextAnchor318"/>Coding Bob.cpp</h2>
			<p>Right-click <code>Bob.cpp</code>. Finally, click the <code>.cpp</code> file for the <code>Bob</code> class.</p>
			<p>Add the following code for the <code>Bob</code> constructor to the <code>Bob.cpp</code> file. Notice that the texture is different (<code>bob.png</code>) and that <code>m_JumpDuration</code> is initialized to a significantly smaller value. Bob is now his own unique self:</p>
			<pre>#include "Bob.h"
#include "TextureHolder.h"
Bob::Bob()
{
    // Associate a texture with the sprite
    m_Sprite = Sprite(TextureHolder::GetTexture(
        "graphics/bob.png"));
    m_JumpDuration = .25;
}</pre>
			<p>Add the <code>handleInput</code> code immediately after the <code>Bob</code> constructor:</p>
			<pre>bool Bob::handleInput()
{
    m_JustJumped = false;
    if (Keyboard::isKeyPressed(Keyboard::Up))
    {
        // Start a jump if not already jumping
        // but only if standing on a block (not falling)
        if (!m_IsJumping &amp;&amp; !m_IsFalling)
        {
            m_IsJumping = true;
            m_TimeThisJump = 0;
            m_JustJumped = true;
        }
    }
    else
    {
        m_IsJumping = false;
        m_IsFalling = true;
    }
    if (Keyboard::isKeyPressed(Keyboard::Left))
    {
        m_LeftPressed = true;
    }
    else
    {
        m_LeftPressed = false;
    }
    if (Keyboard::isKeyPressed(Keyboard::Right))
    {
        m_RightPressed = true;;
    }
    else
    {
        m_RightPressed = false;
    }
    return m_JustJumped;
}</pre>
			<p>Notice that the code is nearly identical to the code in the <code>handleInput</code> function of the <code>Thomas</code> class. The only difference is that we respond to different keys (the <em class="italic">Left </em>arrow key and <em class="italic">Right</em> arrow key for left and right movement, respectively, and the <em class="italic">Up</em> arrow key for jumping).</p>
			<p>Now that we have a <code>PlayableCharacter</code> class that has been extended by the <code>Bob</code> and <code>Thomas</code> classes, we can add a <code>Bob</code> and a <code>Thomas</code> instance to the game.</p>
			<h1 id="_idParaDest-310"><a id="_idTextAnchor319"/>Updating the game engine to use Thomas and Bob</h1>
			<p>In order to be able to run the game and see our new characters, we have to declare instances of them, call their <code>spawn</code> functions, update them each frame, and draw them each frame. Let's do that now.</p>
			<h2 id="_idParaDest-311"><a id="_idTextAnchor320"/>Updating Engine.h to add an instance of Bob and Thomas</h2>
			<p>Open up the <code>Engine.h</code> file and add the following highlighted lines of code:</p>
			<pre>#pragma once
#include &lt;SFML/Graphics.hpp&gt;
#include "TextureHolder.h"
<strong class="bold">#include "Thomas.h"</strong>
<strong class="bold">#include "Bob.h"</strong>
using namespace sf;
class Engine
{
private:
    // The texture holder
    TextureHolder th;
<strong class="bold">    // Thomas and his friend, Bob</strong>
<strong class="bold">    Thomas m_Thomas;</strong>
<strong class="bold">    Bob m_Bob;</strong>
    const int TILE_SIZE = 50;
    const int VERTS_IN_QUAD = 4;
    ...
    ...</pre>
			<p>Now, we have an instance of both <code>Thomas</code> and <code>Bob</code> that are derived from <code>PlayableCharacter</code>.</p>
			<h2 id="_idParaDest-312"><a id="_idTextAnchor321"/>Updating the input function to control Thomas and Bob</h2>
			<p>Now, we will add the ability to control the two characters. This code will go in the input part of the code. Of course, for this project, we have a dedicated <code>input</code> function. Open <code>Input.cpp</code> and add the following highlighted code:</p>
			<pre>void Engine::input()
{
    Event event;
    while (m_Window.pollEvent(event))
    {
        if (event.type == Event::KeyPressed)
        {
            // Handle the player quitting
            if (Keyboard::isKeyPressed(Keyboard::Escape))
            {
                m_Window.close();
            }
            // Handle the player starting the game
            if (Keyboard::isKeyPressed(Keyboard::Return))
            {
                m_Playing = true;
            }
            // Switch between Thomas and Bob
            if (Keyboard::isKeyPressed(Keyboard::Q))
            {
                m_Character1 = !m_Character1;
            }
            // Switch between full and split-screen
            if (Keyboard::isKeyPressed(Keyboard::E))
            {
                m_SplitScreen = !m_SplitScreen;
            }
        }
    }
<strong class="bold">    // Handle input specific to Thomas</strong>
<strong class="bold">    if(m_Thomas.handleInput())</strong>
<strong class="bold">    {</strong>
<strong class="bold">        // Play a jump sound</strong>
<strong class="bold">    }</strong>
<strong class="bold">    // Handle input specific to Bob</strong>
<strong class="bold">    if(m_Bob.handleInput())</strong>
<strong class="bold">    {</strong>
<strong class="bold">        // Play a jump sound</strong>
<strong class="bold">    }</strong>
}</pre>
			<p>Note how simple the previous code is: all the functionality is contained within the <code>Thomas</code> and <code>Bob</code> classes. All the code must do is add an include directive for each of the <code>Thomas</code> and <code>Bob</code> classes. Then, within the <code>input</code> function, the code just calls the pure virtual <code>handleInput</code> functions on <code>m_Thomas</code> and <code>m_Bob</code>. The reason we wrap each of the calls in an <code>if</code> statement is that they return <code>true</code> or <code>false</code> based on whether a new jump has just been successfully initiated. We will handle playing the jump sound effects in <a href="B14278_17_Final_AG_ePub.xhtml#_idTextAnchor340"><em class="italic">Chapter 17</em></a>, <em class="italic">Sound Spatialization and the HUD</em>.</p>
			<h2 id="_idParaDest-313"><a id="_idTextAnchor322"/>Updating the update function to spawn and update the PlayableCharacter instances</h2>
			<p>This is broken into two parts. First, we need to spawn Bob and Thomas at the start of a new level, and second, we need to update them (by calling their <code>update</code> functions) each frame.</p>
			<h3>Spawning Thomas and Bob</h3>
			<p>We need to call the <code>spawn</code> functions of our <code>Thomas</code> and <code>Bob</code> objects in a few different places as the project progresses. Most obviously, we need to spawn the two characters when a new level begins. In the next chapter, as the number of tasks we need to perform at the beginning of a level increases, we will write a <code>loadLevel</code> function. For now, let's just call <code>spawn</code> on <code>m_Thomas</code> and <code>m_Bob</code> in the <code>update</code> function, as highlighted in the following code. Add the following code, but keep in mind that it will eventually be deleted and replaced:</p>
			<pre>void Engine::update(float dtAsSeconds)
{
<strong class="bold">    if (m_NewLevelRequired)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        // These calls to spawn will be moved to a new</strong>
<strong class="bold">        // loadLevel() function soon</strong>
<strong class="bold">        // Spawn Thomas and Bob</strong>
<strong class="bold">        m_Thomas.spawn(Vector2f(0,0), GRAVITY);</strong>
<strong class="bold">        m_Bob.spawn(Vector2f(100, 0), GRAVITY);</strong>
<strong class="bold">        // Make sure spawn is called only once</strong>
<strong class="bold">        m_TimeRemaining = 10;</strong>
<strong class="bold">        m_NewLevelRequired = false;</strong>
<strong class="bold">    }</strong>
    if (m_Playing)
    {
        // Count down the time the player has left
        m_TimeRemaining -= dtAsSeconds;
        // Have Thomas and Bob run out of time?
        if (m_TimeRemaining &lt;= 0)
        {
            m_NewLevelRequired = true;
        }
    }// End if playing
        
}</pre>
			<p>The previous code simply calls <code>spawn</code> and passes in a location in the game world, along with the gravity. The code is wrapped in an <code>if</code> statement that checks whether a new level is required. The spawning code will be moved to a dedicated <code>loadLevel</code> function, but the <code>if</code> condition will be part of the finished project. Also, <code>m_TimeRemaining</code> is set to an arbitrary 10 seconds for now.</p>
			<p>Now, we can update the instances each frame of the game loop.</p>
			<h3>Updating Thomas and Bob each frame</h3>
			<p>Next, we will update Thomas and Bob. All we need to do is call their <code>update</code> functions and pass in the time this frame has taken.</p>
			<p>Add the following highlighted code:</p>
			<pre>void Engine::update(float dtAsSeconds)
{
    if (m_NewLevelRequired)
    {
        // These calls to spawn will be moved to a new
        // LoadLevel function soon
        // Spawn Thomas and Bob
        m_Thomas.spawn(Vector2f(0,0), GRAVITY);
        m_Bob.spawn(Vector2f(100, 0), GRAVITY);
        // Make sure spawn is called only once
        m_NewLevelRequired = false;
    }
    if (m_Playing)
    {
<strong class="bold">        // Update Thomas</strong>
<strong class="bold">        m_Thomas.update(dtAsSeconds);</strong>
<strong class="bold">        // Update Bob</strong>
<strong class="bold">        m_Bob.update(dtAsSeconds);</strong>
        // Count down the time the player has left
        m_TimeRemaining -= dtAsSeconds;
        // Have Thomas and Bob run out of time?
        if (m_TimeRemaining &lt;= 0)
        {
            m_NewLevelRequired = true;
        }
    }// End if playing
        
}</pre>
			<p>Now that the characters can move, we need to update the appropriate <code>View</code> objects to center around the characters and make them the center of attention. Of course, until we have some objects in our game world, the sensation of actual movement will not be achieved.</p>
			<p>Add the following highlighted code:</p>
			<pre>void Engine::update(float dtAsSeconds)
{
    if (m_NewLevelRequired)
    {
        // These calls to spawn will be moved to a new
        // LoadLevel function soon
        // Spawn Thomas and Bob
        m_Thomas.spawn(Vector2f(0,0), GRAVITY);
        m_Bob.spawn(Vector2f(100, 0), GRAVITY);
        // Make sure spawn is called only once
        m_NewLevelRequired = false;
    }
    if (m_Playing)
    {
        // Update Thomas
        m_Thomas.update(dtAsSeconds);
        // Update Bob
        m_Bob.update(dtAsSeconds);
        // Count down the time the player has left
        m_TimeRemaining -= dtAsSeconds;
        // Have Thomas and Bob run out of time?
        if (m_TimeRemaining &lt;= 0)
        {
            m_NewLevelRequired = true;
        }
    }// End if playing
        
<strong class="bold">    // Set the appropriate view around the appropriate character</strong>
<strong class="bold">    if (m_SplitScreen)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        m_LeftView.setCenter(m_Thomas.getCenter());</strong>
<strong class="bold">        m_RightView.setCenter(m_Bob.getCenter());</strong>
<strong class="bold">    }</strong>
<strong class="bold">    else</strong>
<strong class="bold">    {</strong>
<strong class="bold">        // Centre full screen around appropriate character</strong>
<strong class="bold">        if (m_Character1)</strong>
<strong class="bold">        {</strong>
<strong class="bold">            m_MainView.setCenter(m_Thomas.getCenter());</strong>
<strong class="bold">        }</strong>
<strong class="bold">        else</strong>
<strong class="bold">        {</strong>
<strong class="bold">            m_MainView.setCenter(m_Bob.getCenter());</strong>
<strong class="bold">        }</strong>
<strong class="bold">    }</strong>
}</pre>
			<p>The previous code handles the two possible situations. First, the <code>if(mSplitScreen)</code> condition positions the left-hand view around <code>m_Thomas</code> and the right-hand view around <code>m_Bob</code>. The <code>else</code> clause that executes when the game is in full screen mode tests to see if <code>m_Character1</code> is <code>true</code>. If it is, then the full screen view (<code>m_MainView</code>) is centered around Thomas, otherwise it is centered around Bob. You probably remember that the player can use the <em class="italic">E</em> key to toggle split-screen mode and the <em class="italic">Q</em> key to toggle between Bob and Thomas in full screen mode. We coded this in the <code>input</code> function of the <code>Engine</code> class, back in <a href="B14278_12_Final_AG_ePub.xhtml#_idTextAnchor272"><em class="italic">Chapter 12</em></a>, <em class="italic">Layering Views and Implementing the HUD</em>.</p>
			<p>Now, we can draw the graphics for Thomas and Bob to the screen.</p>
			<h2 id="_idParaDest-314"><a id="_idTextAnchor323"/>Drawing Bob and Thomas</h2>
			<p>Make sure the <code>Draw.cpp</code> file is open and add the following highlighted code:</p>
			<pre>void Engine::draw()
{
    // Rub out the last frame
    m_Window.clear(Color::White);
    if (!m_SplitScreen)
    {
        // Switch to background view
        m_Window.setView(m_BGMainView);
        // Draw the background
        m_Window.draw(m_BackgroundSprite);
        // Switch to m_MainView
        m_Window.setView(m_MainView);        
<strong class="bold">        // Draw thomas</strong>
<strong class="bold">        m_Window.draw(m_Thomas.getSprite());</strong>
<strong class="bold">        // Draw bob</strong>
<strong class="bold">        m_Window.draw(m_Bob.getSprite());</strong>
    }
    else
    {
        // Split-screen view is active
        // First draw Thomas' side of the screen
        // Switch to background view
        m_Window.setView(m_BGLeftView);
        // Draw the background
        m_Window.draw(m_BackgroundSprite);
        // Switch to m_LeftView
        m_Window.setView(m_LeftView);
<strong class="bold">        // Draw bob</strong>
<strong class="bold">        m_Window.draw(m_Bob.getSprite());</strong>
<strong class="bold">    </strong>
<strong class="bold">        // Draw thomas</strong>
<strong class="bold">        m_Window.draw(m_Thomas.getSprite());</strong>
        
        // Now draw Bob's side of the screen
        // Switch to background view
        m_Window.setView(m_BGRightView);
        // Draw the background
        m_Window.draw(m_BackgroundSprite);
        // Switch to m_RightView
        m_Window.setView(m_RightView);
<strong class="bold">        // Draw thomas</strong>
<strong class="bold">        m_Window.draw(m_Thomas.getSprite());</strong>
<strong class="bold">        // Draw bob</strong>
<strong class="bold">        m_Window.draw(m_Bob.getSprite());</strong>
                
    }
    // Draw the HUD
    // Switch to m_HudView
    m_Window.setView(m_HudView);
    
    
    // Show everything we have just drawn
    m_Window.display();
}</pre>
			<p>Notice that we draw both Thomas and Bob for full screen, the left, and the right. Also, notice the very subtle difference in the way that we draw the characters in split-screen mode. When drawing the left-hand side of the screen, we switch the order the characters are drawn and draw Thomas after Bob. So, Thomas will always be "on top" on the left and Bob will always be on top on the right. This is because the player controlling Thomas is catered for on the left and Bob the right, respectively.</p>
			<p>You can now run the game and see Thomas and Bob in the center of the screen, as follows: </p>
			<div><div><img src="img/B14278_15_01b.jpg" alt=""/>
				</div>
			</div>
			<p>If you press the <em class="italic">Q</em> key to switch focus from Thomas to Bob, you will see the <code>View</code> make the slight adjustment. If you move either of the characters left or right (Thomas with <em class="italic">A</em> and <em class="italic">D</em>, and Bob with the arrow keys) you will see them move relative to each other.</p>
			<p>Try pressing the <em class="italic">E</em> key to toggle between full screen and split-screen. Then, try moving both characters again to see the effect. In the following screenshot, you can see that Thomas is always centered in the left-hand window and Bob is always centered in the right-hand window:</p>
			<div><div><img src="img/B14278_15_02.jpg" alt=""/>
				</div>
			</div>
			<p>If you leave the game running long enough, the characters will respawn in their original positions every 10 seconds. This is the beginning of the functionality we will need for the finished game. This behavior is caused by <code>m_TimeRemaining</code> going below 0 and then setting the <code>m_NewLevelRequired</code> variable to <code>true</code>.</p>
			<p>Also note that we can't see the full effect of movement until we draw the details of the level. In fact, although it can't be seen, both characters are continuously falling at 300 pixels per second. Since the camera is centering around them every frame and there are no other objects in the game world, we cannot see this downward movement.</p>
			<p>If you want to see this for yourself, just change the call to <code>m_Bob.spawn</code>, as follows:</p>
			<pre>m_Bob.spawn(Vector2f(0,0), 0);</pre>
			<p>Now that Bob has no gravitational effect, Thomas will visibly fall away from him. This is shown in the following screenshot:</p>
			<div><div><img src="img/B14278_15_03.jpg" alt=""/>
				</div>
			</div>
			<p>We <a id="_idTextAnchor324"/>will add some playable levels to interact with in the next chapter.</p>
			<h1 id="_idParaDest-315"><a id="_idTextAnchor325"/>Summary</h1>
			<p>In this chapter, we learned about some new C++ concepts, such as inheritance, which allows us to extend a class and gain all its functionality. We also learned that we can declare variables as protected and that this will give the child class access to them, but they will still be encapsulated (hidden) from all other code. We also used pure virtual functions, which make a class abstract, meaning that the class cannot be instantiated and must therefore be inherited from/extended. We were also introduced to the concept of polymorphism, but will need to wait until the next chapter to use it in our game.</p>
			<p>In the next chapter, we will add some major functionality to the game. By the end of the next chapter, Thomas and Bob will be walking, jumping, and falling. They will even be able to jump on each other's heads, as well as exploring some level designs that have been loaded from a text file.</p>
			<h1 id="_idParaDest-316"><a id="_idTextAnchor326"/>FAQ</h1>
			<p>Q) We learned about Polymorphism, but why didn't I notice anything polymorphic in the game code so far?</p>
			<p>A) We will see polymorphism in action in the next chapter when we write a function that takes <code>PlayerCharacter</code> as a parameter. We will see how we can pass both Bob and Thomas to this new function. It will work the same with both of them.</p>
		</div>
	</body></html>