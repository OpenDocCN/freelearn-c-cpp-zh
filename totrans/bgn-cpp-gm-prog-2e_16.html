<html><head></head><body>
		<div id="_idContainer099">
			<h1 id="_idParaDest-297"><a id="_idTextAnchor306"/><em class="italic">Chapter 15</em>: Advanced OOP – Inheritance and Polymorphism</h1>
			<p>In this chapter, we will further extend our knowledge of OOP by looking at the slightly more advanced concepts of <strong class="bold">inheritance</strong> and <strong class="bold">polymorphism</strong>. We will then be able to use this new knowledge to implement the star characters of our game, Thomas and Bob. Here is what we will cover in this chapter:</p>
			<ul>
				<li>Learn how to extend and modify a class using inheritance</li>
				<li>Treat an object of a class as if it is more than one type of class by using polymorphism </li>
				<li>Learn about abstract classes and how designing classes that are never instantiated can actually be useful</li>
				<li>Build an abstract <strong class="source-inline">PlayableCharacter</strong> class</li>
				<li>Put inheritance to work with the <strong class="source-inline">Thomas</strong> and <strong class="source-inline">Bob</strong> classes</li>
				<li>Add Thomas and Bob to the game project</li>
			</ul>
			<h1 id="_idParaDest-298"><a id="_idTextAnchor307"/>Inheritance</h1>
			<p>We have already seen how we can use other people's hard work by instantiating objects from the classes of the SFML library. But this whole OOP thing goes even further than that.</p>
			<p>What if there is a class that has loads of useful functionality in it, but is not quite what we want? In this situation, we can <strong class="bold">inherit </strong>from the other class. Just like it sounds, <strong class="bold">inheritance </strong>means we can harness all the features and benefits of other people's classes, including the encapsulation, while further refining or extending the code specifically to our situation. In this project, we will inherit from and extend some SFML classes; we will also do so with our own classes.</p>
			<p>Let's look at some code that uses inheritance.</p>
			<h2 id="_idParaDest-299"><a id="_idTextAnchor308"/>Extending a class</h2>
			<p>With all this in mind, let's look at an example class and see how we can extend it, just to see the syntax and as a first step.</p>
			<p>First, we define a class to inherit from. This is no different from how we created any of our other classes. Take a look at this hypothetical <strong class="source-inline">Soldier</strong> class declaration:</p>
			<p class="source-code">class Soldier</p>
			<p class="source-code">{</p>
			<p class="source-code">    private:</p>
			<p class="source-code">        // How much damage can the soldier take</p>
			<p class="source-code">        int m_Health;</p>
			<p class="source-code">        int m_Armour;</p>
			<p class="source-code">        int m_Range;</p>
			<p class="source-code">        int m_ShotPower;</p>
			<p class="source-code">        </p>
			<p class="source-code">    </p>
			<p class="source-code">    Public:</p>
			<p class="source-code">        void setHealth(int h);</p>
			<p class="source-code">        void setArmour(int a);    </p>
			<p class="source-code">        void setRange(int r);</p>
			<p class="source-code">        void setShotPower(int p);</p>
			<p class="source-code">};</p>
			<p>In the previous code, we define a <strong class="source-inline">Soldier</strong> class. It has four private variables: <strong class="source-inline">m_Health</strong>, <strong class="source-inline">m_Armour</strong>, <strong class="source-inline">m_Range</strong>, and <strong class="source-inline">m_ShotPower</strong>. It has also four public functions: <strong class="source-inline">setHealth</strong>, <strong class="source-inline">setArmour, setRange</strong>, and<strong class="source-inline"> setShotPower</strong>. We don't need to see the definitions of these functions; they will simply initialize the appropriate variable that their name makes obvious. </p>
			<p>We can also imagine that a fully implemented <strong class="source-inline">Soldier</strong> class would be much more in-depth than this. It would probably have functions such as <strong class="source-inline">shoot</strong>, <strong class="source-inline">goProne</strong>, and so on. If we implemented a <strong class="source-inline">Soldier</strong> class in an SFML project, it would likely have a <strong class="source-inline">Sprite</strong> object, as well as an <strong class="source-inline">update</strong> and a <strong class="source-inline">getPostion</strong> function. </p>
			<p>The simple scenario that we've presented here is suitable if we wish to learn about inheritance. Now, let's look at something new: inheriting from the <strong class="source-inline">Soldier</strong> class. Look at the following code, especially the highlighted part:</p>
			<p class="source-code">class Sniper <strong class="bold">: public Soldier</strong></p>
			<p class="source-code">{</p>
			<p class="source-code">public:</p>
			<p class="source-code">    // A constructor specific to Sniper</p>
			<p class="source-code">    Sniper::Sniper();</p>
			<p class="source-code">};</p>
			<p>By adding <strong class="source-inline">: public Soldier</strong> to the <strong class="source-inline">Sniper</strong> class declaration, <strong class="source-inline">Sniper</strong> inherits from <strong class="source-inline">Soldier</strong>. But what does this mean, exactly? <strong class="source-inline">Sniper</strong> <strong class="bold">is a</strong> <strong class="source-inline">Soldier</strong>. It has all the variables and functions of <strong class="source-inline">Soldier</strong>. Inheritance is even more than this, however. </p>
			<p>Also note that, in the previous code, we declare a <strong class="source-inline">Sniper</strong> constructor. This constructor is unique to <strong class="source-inline">Sniper</strong>. We have not only inherited from <strong class="source-inline">Soldier</strong>; we have <strong class="bold">extended</strong> <strong class="source-inline">Soldier</strong>. All the functionality (definitions) of the <strong class="source-inline">Soldier</strong> class would be handled by the <strong class="source-inline">Soldier</strong> class, but the definition of the <strong class="source-inline">Sniper</strong> constructor must be handled by the <strong class="source-inline">Sniper</strong> class.</p>
			<p>Here is what the hypothetical <strong class="source-inline">Sniper</strong> constructor definition might look like:</p>
			<p class="source-code">// In Sniper.cpp</p>
			<p class="source-code">Sniper::Sniper()</p>
			<p class="source-code">{</p>
			<p class="source-code">    setHealth(10);</p>
			<p class="source-code">    setArmour(10);    </p>
			<p class="source-code">    setRange(1000);</p>
			<p class="source-code">    setShotPower(100);</p>
			<p class="source-code">}</p>
			<p>We could go ahead and write a bunch of other classes that are extensions of the <strong class="source-inline">Soldier</strong> class, perhaps <strong class="source-inline">Commando</strong> and <strong class="source-inline">Infantryman</strong>. Each would have the exact same variables and functions, but each could also have a unique constructor that initializes those variables appropriate to the specific type of <strong class="source-inline">Soldier</strong>. <strong class="source-inline">Commando</strong> might have very high <strong class="source-inline">m_Health</strong> and <strong class="source-inline">m_ShotPower</strong> but really puny <strong class="source-inline">m_Range</strong>. <strong class="source-inline">Infantryman</strong> might be in between <strong class="source-inline">Commando</strong> and <strong class="source-inline">Sniper</strong> with mediocre values for each variable.</p>
			<p>As if OOP wasn't useful enough already, we can now model real-world objects, including their hierarchies. We can achieve this by sub-classing/extending/inheriting from other classes. </p>
			<p>The terminology we might like to learn here is that the class that is extended from is the <strong class="bold">super-class</strong>, and the class that inherits from the super-class is the <strong class="bold">sub-class</strong>. We can also say <strong class="bold">parent</strong> and <strong class="bold">child</strong> class.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">You might find yourself asking this question about inheritance: why? The reason is something like this: we can write common code once; in the parent class, we can update that common code and all the classes that inherit from it are also updated. Furthermore, a sub-class only gets to use public and <strong class="bold">protected</strong> instance variables and functions. So, designed properly, this also enhances the goals of encapsulation.</p>
			<p>Did you say protected? Yes. There is an access specifier for class variables and functions called <strong class="bold">protected</strong>. You can think of protected variables as being somewhere between public and private. Here is a quick summary of access specifiers, along with more details about the <strong class="source-inline">protected</strong> specifier:</p>
			<ul>
				<li><strong class="source-inline">Public</strong> variables and functions can be accessed and used by anyone with an instance of the class.</li>
				<li><strong class="source-inline">Private</strong> variables and functions can only accessed/used by the internal code of the class, and not directly from an instance. This is good for encapsulation and when we need to access/change private variables, since we can provide public getter and setter functions (such as <strong class="source-inline">getSprite</strong>). If we extend a class that has <strong class="source-inline">private</strong> variables and functions, that child class <strong class="bold">cannot</strong> directly access the private data of its parent.</li>
				<li><strong class="source-inline">Protected</strong> variables and functions are almost the same as private. They cannot be accessed/used directly by an instance of the class. However, they <strong class="bold">can</strong> be used directly by any class that extends the class they are declared in. So, it is like they are private, except to child classes. </li>
			</ul>
			<p>To fully understand what protected variables and functions are and how they can be useful, let's look at another topic first. Then, we will see them in action.</p>
			<h1 id="_idParaDest-300"><a id="_idTextAnchor309"/>Polymorphism</h1>
			<p><strong class="bold">Polymorphism</strong> allows us to write code that is less dependent on the types we are trying to manipulate. This can make our code clearer and more efficient. Polymorphism means many forms. If the objects that we code can be more than one type of thing, then we can take advantage of this.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">But what does polymorphism mean to us? Boiled down to its simplest definition, polymorphism means the following: any sub-class can be used as part of the code that uses the super-class. This means we can write code that is simpler and easier to understand and also easier to modify or change. Also, we can write code for the super-class and rely on the fact that no matter how many times it is sub-classed, within certain parameters, the code will still work.</p>
			<p>Let's discuss an example. </p>
			<p>Suppose we want to use polymorphism to help write a zoo management game where we must feed and tend to the needs of animals. We will probably want to have a function such as <strong class="source-inline">feed</strong>. We will also probably want to pass an instance of the animal to be fed into the <strong class="source-inline">feed</strong> function. </p>
			<p>A zoo, of course, has lots of animals, such as Lion, Elephant, and Three-toed Sloth. With our new knowledge of C++ inheritance, it makes sense to code an <strong class="source-inline">Animal</strong> class and have all the different types of animal inherit from it.</p>
			<p>If we want to write a function (<strong class="source-inline">feed</strong>) that we can pass <strong class="source-inline">Lion</strong>, <strong class="source-inline">Elephant</strong>, and <strong class="source-inline">ThreeToedSloth</strong> into as a parameter, it might seem like we need to write a <strong class="source-inline">feed</strong> function for each type of <strong class="source-inline">Animal</strong>. However, we can write polymorphic functions with polymorphic return types and arguments. Take a look at the following definition of the hypothetical feed function:</p>
			<p class="source-code">void feed(Animal&amp; a)</p>
			<p class="source-code">{</p>
			<p class="source-code">    a.decreaseHunger();</p>
			<p class="source-code">}</p>
			<p>The preceding function has an <strong class="source-inline">Animal</strong> reference as a parameter, meaning that any object that is built from a class that extends <strong class="source-inline">Animal</strong> can be passed into it. </p>
			<p>This means you can write code today and make another subclass in a week, month, or year, and the very same functions and data structures will still work. Also, we can enforce a set of rules upon our subclasses regarding what they can and cannot do, as well as how they do it. So, good design in one stage can influence it at other stages. </p>
			<p>But will we ever really want to instantiate an actual Animal?</p>
			<h1 id="_idParaDest-301"><a id="_idTextAnchor310"/>Abstract classes – virtual and pure virtual functions</h1>
			<p>An <strong class="bold">abstract class</strong> is a class that cannot be instantiated and therefore cannot be made into an object.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Some terminology we might like to learn about here is <em class="italic">concrete</em> class. A <strong class="bold">concrete class</strong> is any class that isn't abstract. In other words, all the classes we have written so far have been concrete classes and can be instantiated into usable objects.</p>
			<p>So, it's code that will never be used, then? But that's like paying an architect to design your home and then never building it! </p>
			<p>If we, or the designer of a class, wants to force its users to inherit it before using their class, they can make a class <strong class="bold">abstract</strong>. If this happens, we cannot make an object from it; therefore, we must inherit from it first and make an object from the sub-class.</p>
			<p>To do so, we can make a function <strong class="bold">pure virtual</strong> and not provide any definition. Then, that function must be<strong class="bold"> overridden </strong>(<strong class="bold">rewritten</strong>) in any class that inherits from it.</p>
			<p>Let's look at an example; it will help. We can make a class abstract by adding a pure virtual function such as the abstract <strong class="source-inline">Animal</strong> class, which can only perform the generic action of <strong class="source-inline">makeNoise</strong>:</p>
			<p class="source-code">Class Animal</p>
			<p class="source-code">    private:</p>
			<p class="source-code">        // Private stuff here</p>
			<p class="source-code">    public:</p>
			<p class="source-code">        void virtual makeNoise() = 0;</p>
			<p class="source-code">        // More public stuff here</p>
			<p class="source-code">};</p>
			<p>As you can see, we add the C++ keyword <strong class="source-inline">virtual, </strong>before, and <strong class="source-inline">= 0</strong> after the function declaration. Now, any class that extends/inherits from <strong class="source-inline">Animal</strong> must override the <strong class="source-inline">makeNoise </strong>function. This might make sense since different types of animal make very different types of noise. We could have assumed that anybody who extends the <strong class="source-inline">Animal</strong> class is smart enough to notice that the <strong class="source-inline">Animal</strong> class cannot make a noise and that they will need to handle it, but what if they don't notice? The point is that by making a pure virtual function, we guarantee that they will, because they must.</p>
			<p>Abstract classes are also useful because, sometimes, we want a class that can be used as a polymorphic type, but we need to guarantee it can never be used as an object. For example, <strong class="source-inline">Animal</strong> doesn't really make sense on its own. We don't talk about animals; we talk about types of animals. We don't say, "Ooh, look at that lovely, fluffy, white animal!", or, "Yesterday we went to the pet shop and got an animal and an animal bed." It's just too, well, abstract.</p>
			<p>So, an abstract class is kind of like a <strong class="bold">template</strong> to be used by any class that extends it (inherits from it). If we were building an <em class="italic">Industrial Empire</em> type game where the player manages businesses and their employees, we might want a <strong class="source-inline">Worker</strong> class, for example, and extend it to make <strong class="source-inline">Miner</strong>, <strong class="source-inline">Steelworker</strong>, <strong class="source-inline">OfficeWorker</strong>, and, of course, <strong class="source-inline">Programmer</strong>. But what exactly does a plain <strong class="source-inline">Worker</strong> do? Why would we ever want to instantiate one?</p>
			<p>The answer is we wouldn't want to instantiate one, but we might want to use it as a polymorphic type so that we can pass multiple <strong class="source-inline">Worker</strong> sub-classes between functions and have data structures that can hold all types of workers. </p>
			<p>All pure virtual functions must be overridden by any class that extends the parent class that contains the pure virtual function. This means that the abstract class can provide some of the common functionality that would be available in all its subclasses. For example, the <strong class="source-inline">Worker</strong> class might have the <strong class="source-inline">m_AnnualSalary</strong>, <strong class="source-inline">m_Productivity</strong>, and <strong class="source-inline">m_Age</strong> member variables. It might also have the <strong class="source-inline">getPayCheck</strong> function, which is not pure virtual and is the same in all the sub-classes, but a <strong class="source-inline">doWork</strong> function, which is pure virtual and must be overridden, because all the different types of <strong class="source-inline">Worker</strong> will <strong class="source-inline">doWork</strong> very differently.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">By the way, <strong class="bold">virtual</strong> as opposed to pure virtual is a function that can be <strong class="bold">optionally overridden</strong>. You declare a virtual function the same way as a pure virtual function but leave the <strong class="source-inline">= 0</strong> off to the end. In the current game project, we will use a pure virtual function.</p>
			<p>If any of this virtual, pure virtual, or abstract stuff is unclear, using it is probably the best way to understand it.</p>
			<h1 id="_idParaDest-302"><a id="_idTextAnchor311"/>Building the PlayableCharacter class</h1>
			<p>Now that we know the basics of inheritance, polymorphism, and pure virtual functions, we will put them to use. We will build a <strong class="source-inline">PlayableCharacter</strong> class that has most of the functionality that any character from our game is going to need. It will have one pure virtual function, known as <strong class="source-inline">handleInput</strong>. The <strong class="source-inline">handleInput</strong> function will need to be quite different in the sub-classes, so this makes sense. </p>
			<p>As <strong class="source-inline">PlayableCharacter</strong> will have a pure virtual function, it will be an abstract class and no objects of it will be possible. We will then build the <strong class="source-inline">Thomas</strong> and <strong class="source-inline">Bob</strong> classes, which will inherit from <strong class="source-inline">PlayableCharacter</strong>, implement the definition of the pure virtual function, and allow us to instantiate <strong class="source-inline">Bob</strong> and <strong class="source-inline">Thomas</strong> objects in our game. It will not be possible to instantiate a <strong class="source-inline">PlayableCharacter</strong> instance directly, but we wouldn't want to because it is too abstract anyway.</p>
			<h2 id="_idParaDest-303"><a id="_idTextAnchor312"/>Coding PlayableCharacter.h</h2>
			<p>As usual when creating a class, we will start off with the header file that will contain the member variable and function declarations. What is new is that, in this class, we will declare some <strong class="bold">protected</strong> member variables. Remember that protected variables can be used as if they were public in classes that inherit from the class with the protected variables.</p>
			<p>Right-click <strong class="bold">Header Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">Header File (.h)</strong> and then, in the <strong class="bold">Name</strong> field, type <strong class="source-inline">PlayableCharacter.h</strong>. Finally, click the <strong class="bold">Add</strong> button. We are now ready to code the header file for the <strong class="source-inline">PlayableCharacter</strong> class.</p>
			<p>We will add and discuss the contents of the <strong class="source-inline">PlayableCharacter.h</strong> file in three sections. First will be the <strong class="source-inline">protected</strong> section, followed by <strong class="source-inline">private</strong>, and then <strong class="source-inline">public</strong>.</p>
			<p>Add the following code to the <strong class="source-inline">PlayableCharacter.h</strong> file:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">class PlayableCharacter</p>
			<p class="source-code">{</p>
			<p class="source-code">protected:</p>
			<p class="source-code">    // Of course we will need a sprite</p>
			<p class="source-code">    Sprite m_Sprite;</p>
			<p class="source-code">    // How long does a jump last</p>
			<p class="source-code">    float m_JumpDuration;</p>
			<p class="source-code">    // Is character currently jumping or falling</p>
			<p class="source-code">    bool m_IsJumping;</p>
			<p class="source-code">    bool m_IsFalling;</p>
			<p class="source-code">    // Which directions is the character currently moving in</p>
			<p class="source-code">    bool m_LeftPressed;</p>
			<p class="source-code">    bool m_RightPressed;</p>
			<p class="source-code">    // How long has this jump lasted so far</p>
			<p class="source-code">    float m_TimeThisJump;</p>
			<p class="source-code">    // Has the player just initiated a jump</p>
			<p class="source-code">    bool m_JustJumped = false;</p>
			<p class="source-code">    // Private variables and functions come next</p>
			<p>The first thing to notice in the code we just wrote is that all the variables are <strong class="source-inline">protected</strong>. This means that when we inherit from the class, all the variables we just wrote will be accessible to those classes that extend it. We will extend this class with the <strong class="source-inline">Thomas</strong> and <strong class="source-inline">Bob</strong> classes.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The terms <em class="italic">inherit from</em> and <em class="italic">extend</em> are virtually synonymous in most contexts in this book. Sometimes, one seems more appropriate than the other, however.</p>
			<p>Apart from the <strong class="source-inline">protected</strong> access specification, there is nothing new or complicated about the previous code. It is worth paying attention to some of the details, however. If we do, it will be easy to understand how the class works as we progress. So, let's run through those <strong class="source-inline">protected</strong> variables, one at a time.</p>
			<p>We have our somewhat predictable <strong class="source-inline">Sprite</strong>, <strong class="source-inline">m_Sprite</strong>. We have a <strong class="source-inline">float</strong> variable called <strong class="source-inline">m_JumpDuration</strong>, which will hold a value representing the time that the character is able to jump for. The greater the value, the further/higher the character will be able to jump.</p>
			<p>Next, we have a Boolean <strong class="source-inline">m_IsJumping</strong>, which is <strong class="source-inline">true</strong> when the character is jumping and <strong class="source-inline">false</strong> otherwise. This will be useful for making sure that the character can't jump while in mid-air.</p>
			<p>The <strong class="source-inline">m_IsFalling</strong> variable has a similar use to <strong class="source-inline">m_IsJumping</strong>. It will be used to know when a character is falling.</p>
			<p>Next, we have two Booleans that will be true if the character's left or right keyboard buttons are currently being pressed. These are relatively dependent upon the character (<em class="italic">A</em> and <em class="italic">D</em> for Thomas, and the <em class="italic">Left</em> and <em class="italic">Right</em> arrow keys for Bob, respectively). How we respond to these Booleans will be seen in the <strong class="source-inline">Thomas</strong> and <strong class="source-inline">Bob</strong> classes.</p>
			<p>The  <strong class="source-inline">m_TimeThisJump</strong> float variable is updated each frame that <strong class="source-inline">m_IsJumping</strong> is <strong class="source-inline">true</strong>. We can then find out when <strong class="source-inline">m_JumpDuration</strong> has been reached.</p>
			<p>The final <strong class="source-inline">protected</strong> variable is the <strong class="source-inline">m_JustJumped</strong> Boolean. This will be <strong class="source-inline">true</strong> if a jump was initiated in the current frame. It will be used so that we know when to play a jump sound effect.</p>
			<p>Next, add the following <strong class="source-inline">private</strong> variables to the <strong class="source-inline">PlayableCharacter.h</strong> file:</p>
			<p class="source-code">private:</p>
			<p class="source-code">    // What is the gravity</p>
			<p class="source-code">    float m_Gravity;</p>
			<p class="source-code">    // How fast is the character</p>
			<p class="source-code">    float m_Speed = 400;</p>
			<p class="source-code">    // Where is the player</p>
			<p class="source-code">    Vector2f m_Position;</p>
			<p class="source-code">    // Where are the characters various body parts?</p>
			<p class="source-code">    FloatRect m_Feet;</p>
			<p class="source-code">    FloatRect m_Head;</p>
			<p class="source-code">    FloatRect m_Right;</p>
			<p class="source-code">    FloatRect m_Left;</p>
			<p class="source-code">    // And a texture</p>
			<p class="source-code">    Texture m_Texture;</p>
			<p class="source-code">    // All our public functions will come next</p>
			<p>In the previous code, we have some interesting <strong class="source-inline">private</strong> variables. Remember that these variables will only be directly accessible to the code in the <strong class="source-inline">PlayableCharacter</strong> class. The <strong class="source-inline">Thomas</strong> and <strong class="source-inline">Bob</strong> classes will not be able to access them directly.</p>
			<p>The <strong class="source-inline">m_Gravity</strong> variable will hold the number of pixels per second that the character will fall. The <strong class="source-inline">m_Speed</strong> variable will hold the number of pixels per second that the character can move left or right.</p>
			<p>The <strong class="source-inline">Vector2f</strong>, <strong class="source-inline">m_Position</strong> variable is the position in the world (not the screen) where the center of the character is.</p>
			<p>The next four <strong class="source-inline">FloatRect</strong> objects are important to discuss. When we did collision detection in the <em class="italic">Zombie Arena</em> game, we simply checked to see if two <strong class="source-inline">FloatRect</strong> objects intersected. Each <strong class="source-inline">FloatRect</strong> object represented an entire character, a pickup, or a bullet. For the non-rectangular shaped objects (zombies and the player), this was a little bit inaccurate.</p>
			<p>In this game, we will need to be more precise. The <strong class="source-inline">m_Feet</strong>, <strong class="source-inline">m_Head</strong>, <strong class="source-inline">m_Right</strong>,  <strong class="source-inline">m_Left</strong>, and <strong class="source-inline">FloatRect</strong> objects will hold the coordinates of the different parts of a character's body. These coordinates will be updated each frame. </p>
			<p>Through these coordinates, we will be able to tell exactly when a character lands on a platform, bumps their head during a jump, or rubs shoulders with a tile to their side.</p>
			<p>Lastly, we have a <strong class="source-inline">Texture</strong>. The <strong class="source-inline">Texture</strong> is <strong class="source-inline">private</strong> as it is not used directly by the <strong class="source-inline">Thomas</strong> or <strong class="source-inline">Bob</strong> classes. However, as we saw, the <strong class="source-inline">Sprite</strong> is <strong class="source-inline">protected</strong> because it is used directly.</p>
			<p>Now, add all the <strong class="source-inline">public</strong> functions to the <strong class="source-inline">PlayableCharacter.h</strong> file. Then, we will discuss them:</p>
			<p class="source-code">public:</p>
			<p class="source-code">    void spawn(Vector2f startPosition, float gravity);</p>
			<p class="source-code">    // This is a pure virtual function</p>
			<p class="source-code">    bool virtual handleInput() = 0;</p>
			<p class="source-code">    // This class is now abstract and cannot be instantiated</p>
			<p class="source-code">    // Where is the player</p>
			<p class="source-code">    FloatRect getPosition();</p>
			<p class="source-code">    // A rectangle representing the position </p>
			<p class="source-code">    // of different parts of the sprite</p>
			<p class="source-code">    FloatRect getFeet();</p>
			<p class="source-code">    FloatRect getHead();</p>
			<p class="source-code">    FloatRect getRight();</p>
			<p class="source-code">    FloatRect getLeft();</p>
			<p class="source-code">    // Send a copy of the sprite to main</p>
			<p class="source-code">    Sprite getSprite();</p>
			<p class="source-code">    // Make the character stand firm</p>
			<p class="source-code">    void stopFalling(float position);</p>
			<p class="source-code">    void stopRight(float position);</p>
			<p class="source-code">    void stopLeft(float position);</p>
			<p class="source-code">    void stopJump();</p>
			<p class="source-code">    // Where is the center of the character</p>
			<p class="source-code">    Vector2f getCenter();</p>
			<p class="source-code">    // We will call this function once every frame</p>
			<p class="source-code">    void update(float elapsedTime);</p>
			<p class="source-code">    </p>
			<p class="source-code">};// End of the class</p>
			<p>Let's talk about each of the function declarations that we just added. This will make coding their definitions easier to follow:</p>
			<ul>
				<li>The <strong class="source-inline">spawn</strong> function receives a <strong class="source-inline">Vector2f</strong> called <strong class="source-inline">startPosition</strong> and a <strong class="source-inline">float</strong> value called <strong class="source-inline">gravity</strong>. As the names suggest, <strong class="source-inline">startPosition</strong> will be the coordinates in the level that the character will start, and <strong class="source-inline">gravity</strong> will be the number of pixels per second at which the character will fall.</li>
				<li><strong class="source-inline">bool virtual handleInput() = 0</strong> is, of course our pure virtual function. Since <strong class="source-inline">PlayableCharacter</strong> has this function, any class that extends it, if we want to instantiate it, must provide a definition for this function. Therefore, when we write all the function definitions for <strong class="source-inline">PlayableCharacter</strong> in a minute, we will not provide a definition for <strong class="source-inline">handleInput</strong>. There will need to be definitions in both the <strong class="source-inline">Thomas</strong> and <strong class="source-inline">Bob</strong> classes.</li>
				<li>The <strong class="source-inline">getPosition</strong> function returns a <strong class="source-inline">FloatRect</strong> object that represents the position of the whole character.</li>
				<li>The <strong class="source-inline">getFeet()</strong> function, as well as <strong class="source-inline">getHead</strong>, <strong class="source-inline">getRight</strong>, and <strong class="source-inline">getLeft</strong>, return a <strong class="source-inline">FloatRect</strong> object that represents the location of a specific part of the character's body. This is just what we need for detailed collision detection.</li>
				<li>The <strong class="source-inline">getSprite</strong> function, as usual, returns a copy of <strong class="source-inline">m_Sprite</strong> to the calling code.</li>
				<li>The <strong class="source-inline">stopFalling</strong>, <strong class="source-inline">stopRight</strong>, <strong class="source-inline">stopLeft</strong>, and <strong class="source-inline">stopJump</strong> functions receive a single <strong class="source-inline">float</strong> value that the function will use to reposition the character and stop it walking or jumping through a solid tile.</li>
				<li>The <strong class="source-inline">getCenter</strong> function returns a <strong class="source-inline">Vector2f</strong> object to the calling code to let it know exactly where the center of the character is. This value is held in <strong class="source-inline">m_Position</strong>. As we will see later, it is used by the <strong class="source-inline">Engine</strong> class to center the appropriate <strong class="source-inline">View</strong> around the appropriate character.</li>
				<li>We have seen the <strong class="source-inline">update</strong> function many times before and, as usual, it takes a <strong class="source-inline">float</strong> parameter, which is the fraction of a second the current frame has taken. This <strong class="source-inline">update</strong> function will need to do more work than previous <strong class="source-inline">update</strong> functions (from our other projects), however. It will need to handle jumping as well as updating the <strong class="source-inline">FloatRect</strong> objects that represent the head, feet, and left- and right-hand sides of the character.</li>
			</ul>
			<p>Now, we can write the definitions for all the functions, except, of course, <strong class="source-inline">handleInput</strong>.</p>
			<h2 id="_idParaDest-304"><a id="_idTextAnchor313"/>Coding PlayableCharacter.cpp</h2>
			<p>Right-click <strong class="bold">Source Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">C++ File (.cpp)</strong> and then, in the <strong class="bold">Name</strong> field, type <strong class="source-inline">PlayableCharacter.cpp</strong>. Finally, click the <strong class="bold">Add</strong> button. We are now ready to code the <strong class="source-inline">.cpp</strong> file for the <strong class="source-inline">PlayableCharacter</strong> class.</p>
			<p>We will break up the code and discuss it in several chunks. First, add the include directives and the definition of the <strong class="source-inline">spawn</strong> function:</p>
			<p class="source-code">#include "PlayableCharacter.h"</p>
			<p class="source-code">void PlayableCharacter::spawn(</p>
			<p class="source-code">        Vector2f startPosition, float gravity)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Place the player at the starting point</p>
			<p class="source-code">    m_Position.x = startPosition.x;</p>
			<p class="source-code">    m_Position.y = startPosition.y;</p>
			<p class="source-code">    // Initialize the gravity</p>
			<p class="source-code">    m_Gravity = gravity;</p>
			<p class="source-code">    // Move the sprite in to position</p>
			<p class="source-code">    m_Sprite.setPosition(m_Position);</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">spawn</strong> function initializes <strong class="source-inline">m_Position</strong> with the passed-in position, and also initializes <strong class="source-inline">m_Gravity</strong>. The final line of code moves <strong class="source-inline">m_Sprite</strong> to its starting position.</p>
			<p>Next, add the definition for the <strong class="source-inline">update</strong> function immediately after the previous code:</p>
			<p class="source-code">void PlayableCharacter::update(float elapsedTime)</p>
			<p class="source-code">{</p>
			<p class="source-code">    if (m_RightPressed)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_Position.x += m_Speed * elapsedTime;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    if (m_LeftPressed)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_Position.x -= m_Speed * elapsedTime;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    // Handle Jumping</p>
			<p class="source-code">    if (m_IsJumping)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Update how long the jump has been going</p>
			<p class="source-code">        m_TimeThisJump += elapsedTime;</p>
			<p class="source-code">        // Is the jump going upwards</p>
			<p class="source-code">        if (m_TimeThisJump &lt; m_JumpDuration)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            // Move up at twice gravity</p>
			<p class="source-code">            m_Position.y -= m_Gravity * 2 * elapsedTime;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        else</p>
			<p class="source-code">        {</p>
			<p class="source-code">            m_IsJumping = false;</p>
			<p class="source-code">            m_IsFalling = true;</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    // Apply gravity</p>
			<p class="source-code">    if (m_IsFalling)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_Position.y += m_Gravity * elapsedTime;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    // Update the rect for all body parts</p>
			<p class="source-code">    FloatRect r = getPosition();</p>
			<p class="source-code">    </p>
			<p class="source-code">    // Feet</p>
			<p class="source-code">    m_Feet.left = r.left + 3;</p>
			<p class="source-code">    m_Feet.top = r.top + r.height - 1;</p>
			<p class="source-code">    m_Feet.width = r.width - 6;</p>
			<p class="source-code">    m_Feet.height = 1;</p>
			<p class="source-code">    // Head</p>
			<p class="source-code">    m_Head.left = r.left;</p>
			<p class="source-code">    m_Head.top = r.top + (r.height * .3);</p>
			<p class="source-code">    m_Head.width = r.width;</p>
			<p class="source-code">    m_Head.height = 1;</p>
			<p class="source-code">    // Right</p>
			<p class="source-code">    m_Right.left = r.left + r.width - 2;</p>
			<p class="source-code">    m_Right.top = r.top + r.height * .35;</p>
			<p class="source-code">    m_Right.width = 1;</p>
			<p class="source-code">    m_Right.height = r.height * .3;</p>
			<p class="source-code">    // Left</p>
			<p class="source-code">    m_Left.left = r.left;</p>
			<p class="source-code">    m_Left.top = r.top + r.height * .5;</p>
			<p class="source-code">    m_Left.width = 1;</p>
			<p class="source-code">    m_Left.height = r.height * .3;</p>
			<p class="source-code">    // Move the sprite into position</p>
			<p class="source-code">    m_Sprite.setPosition(m_Position);</p>
			<p class="source-code">}</p>
			<p>The first two parts of the code check whether <strong class="source-inline">m_RightPressed</strong> or <strong class="source-inline">m_LeftPressed</strong> is <strong class="source-inline">true</strong>. If either of them is, then <strong class="source-inline">m_Position</strong> is changed using the same formula as the previous project (elapsed time multiplied by speed).</p>
			<p>Next, we see whether the character is currently executing a jump. We know this from <strong class="source-inline">if(m_IsJumping)</strong>. If this <strong class="source-inline">if</strong> statement is <strong class="source-inline">true</strong>, these are the steps the code takes:</p>
			<ol>
				<li>Updates <strong class="source-inline">m_TimeThisJump</strong> with <strong class="source-inline">elapsedTime</strong>.</li>
				<li>Checks if <strong class="source-inline">m_TimeThisJump</strong> is still less than <strong class="source-inline">m_JumpDuration</strong>. If it is, it changes the y coordinate of <strong class="source-inline">m_Position</strong> by 2x gravity, multiplied by the elapsed time.</li>
				<li>In the <strong class="source-inline">else</strong> clause that executes when <strong class="source-inline">m_TimeThisJump</strong> is not lower than <strong class="source-inline">m_JumpDuration</strong>, <strong class="source-inline">m_Falling</strong> is set to <strong class="source-inline">true</strong>. The effect of doing this will be seen next. Also, <strong class="source-inline">m_Jumping</strong> is set to <strong class="source-inline">false</strong>. This prevents the code we have just been discussing from executing, because <strong class="source-inline">if(m_IsJumping)</strong> is now false.</li>
			</ol>
			<p>The <strong class="source-inline">if(m_IsFalling)</strong> block moves <strong class="source-inline">m_Position</strong> down each frame. It is moved using the current value of <strong class="source-inline">m_Gravity</strong> and the elapsed time.</p>
			<p>The code that follows (most of the remaining code) updates the "body parts" of the character, relative to the current position of the sprite as a whole. Take a look at the following diagram to see how the code calculates the position of the virtual head, feet, and left- and right-hand sides of the character:</p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/B14278_15_01.jpg" alt=""/>
				</div>
			</div>
			<p>The final line of code uses the <strong class="source-inline">setPosition</strong> function to move the sprite to its correct location after all the possibilities of the <strong class="source-inline">update</strong> function.</p>
			<p>Now, add the definitions for the <strong class="source-inline">getPosition</strong>, <strong class="source-inline">getCenter</strong>, <strong class="source-inline">getFeet</strong>, <strong class="source-inline">getHead</strong>, <strong class="source-inline">getLeft</strong>, <strong class="source-inline">getRight</strong>, and <strong class="source-inline">getSprite</strong> functions, immediately after the previous code:</p>
			<p class="source-code">FloatRect PlayableCharacter::getPosition()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_Sprite.getGlobalBounds();</p>
			<p class="source-code">}</p>
			<p class="source-code">Vector2f PlayableCharacter::getCenter()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return Vector2f(</p>
			<p class="source-code">        m_Position.x + m_Sprite.getGlobalBounds().width / 2,</p>
			<p class="source-code">        m_Position.y + m_Sprite.getGlobalBounds().height / 2</p>
			<p class="source-code">        );</p>
			<p class="source-code">}</p>
			<p class="source-code">FloatRect PlayableCharacter::getFeet()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_Feet;</p>
			<p class="source-code">}</p>
			<p class="source-code">FloatRect PlayableCharacter::getHead()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_Head;</p>
			<p class="source-code">}</p>
			<p class="source-code">FloatRect PlayableCharacter::getLeft()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_Left;</p>
			<p class="source-code">}</p>
			<p class="source-code">FloatRect PlayableCharacter::getRight()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_Right;</p>
			<p class="source-code">}</p>
			<p class="source-code">Sprite PlayableCharacter::getSprite()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_Sprite;</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">getPosition</strong> function returns a <strong class="source-inline">FloatRect</strong> that wraps the entire sprite, while <strong class="source-inline">getCenter</strong> returns a <strong class="source-inline">Vector2f</strong> that contains the center of the sprite. Notice that we divide the height and width of the sprite by 2 in order to dynamically arrive at this result. This is because Thomas and Bob will be of different heights.</p>
			<p>The <strong class="source-inline">getFeet</strong>, <strong class="source-inline">getHead</strong>, <strong class="source-inline">getLeft</strong>, and <strong class="source-inline">getRight</strong> functions return the <strong class="source-inline">FloatRect</strong> objects that represent the body parts of the character that we update each frame in the <strong class="source-inline">update</strong> function. We will write the collision detection code that uses these functions in the next chapter.</p>
			<p>The <strong class="source-inline">getSprite</strong> function, as usual, returns a copy of <strong class="source-inline">m_Sprite</strong>.</p>
			<p>Finally, for the <strong class="source-inline">PlayableCharacter</strong> class, add the definitions for the <strong class="source-inline">stopFalling</strong>, <strong class="source-inline">stopRight</strong>, <strong class="source-inline">stopLeft</strong>, and <strong class="source-inline">stopJump</strong> functions. Do so immediately after the previous code:</p>
			<p class="source-code">void PlayableCharacter::stopFalling(float position)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Position.y = position - getPosition().height;</p>
			<p class="source-code">    m_Sprite.setPosition(m_Position);</p>
			<p class="source-code">    m_IsFalling = false;</p>
			<p class="source-code">}</p>
			<p class="source-code">void PlayableCharacter::stopRight(float position)</p>
			<p class="source-code">{</p>
			<p class="source-code">    </p>
			<p class="source-code">    m_Position.x = position - m_Sprite.getGlobalBounds().width;</p>
			<p class="source-code">    m_Sprite.setPosition(m_Position);</p>
			<p class="source-code">}</p>
			<p class="source-code">void PlayableCharacter::stopLeft(float position)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Position.x = position + m_Sprite.getGlobalBounds().width;</p>
			<p class="source-code">    m_Sprite.setPosition(m_Position);</p>
			<p class="source-code">}</p>
			<p class="source-code">void PlayableCharacter::stopJump()</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Stop a jump early </p>
			<p class="source-code">    m_IsJumping = false;</p>
			<p class="source-code">    m_IsFalling = true;</p>
			<p class="source-code">}</p>
			<p>Each of the previous functions receives a value as a parameter that is used to reposition either the top, bottom, left, or right of the sprite. Exactly what these values are and how they are obtained will be something for the next chapter. Each of the previous functions also repositions the sprite. </p>
			<p>The final function is the <strong class="source-inline">stopJump</strong> function, which will also be used in collision detection. It sets the necessary values for <strong class="source-inline">m_IsJumping</strong> and <strong class="source-inline">m_IsFalling</strong> to end a jump.</p>
			<h1 id="_idParaDest-305"><a id="_idTextAnchor314"/>Building the Thomas and Bob classes</h1>
			<p>Now, we get to use inheritance for real. We will build a class for Thomas and a class for Bob. They will both inherit from the <strong class="source-inline">PlayableCharacter</strong> class we just coded. They will then have all the functionality of the <strong class="source-inline">PlayableCharacter</strong> class, including direct access to its <strong class="source-inline">protected</strong> variables. We will also add the definition for the pure virtual function, <strong class="source-inline">handleInput</strong>. You will notice that the <strong class="source-inline">handleInput</strong> functions for <strong class="source-inline">Thomas</strong> and <strong class="source-inline">Bob</strong> will be different.</p>
			<h2 id="_idParaDest-306"><a id="_idTextAnchor315"/>Coding Thomas.h </h2>
			<p>Right-click <strong class="bold">Header Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">Header File (.h)</strong> and then, in the <strong class="bold">Name</strong> field, type <strong class="source-inline">Thomas.h</strong>. Finally, click the <strong class="bold">Add</strong> button. We are now ready to code the header file for the <strong class="source-inline">Thomas</strong> class.</p>
			<p>Add the following code to the <strong class="source-inline">Thomas.h</strong> class:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include "PlayableCharacter.h"</p>
			<p class="source-code">class Thomas : public PlayableCharacter</p>
			<p class="source-code">{</p>
			<p class="source-code">public:</p>
			<p class="source-code">    // A constructor specific to Thomas</p>
			<p class="source-code">    Thomas::Thomas();</p>
			<p class="source-code">    // The overridden input handler for Thomas</p>
			<p class="source-code">    bool virtual handleInput();</p>
			<p class="source-code">};</p>
			<p>The previous code is very short and sweet. We can see that we have a constructor and that we are going to implement the pure virtual <strong class="source-inline">handleInput</strong> function. So, let's do that now.</p>
			<h2 id="_idParaDest-307"><a id="_idTextAnchor316"/>Coding Thomas.cpp</h2>
			<p>Right-click <strong class="bold">Source Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">C++ File (.cpp)</strong> and then, in the <strong class="bold">Name</strong> field, type <strong class="source-inline">Thomas.cpp</strong>. Finally, click the <strong class="bold">Add</strong> button. We are now ready to code the <strong class="source-inline">.cpp</strong> file for the <strong class="source-inline">Thomas</strong> class.</p>
			<p>Add the <strong class="source-inline">Thomas</strong> constructor to the <strong class="source-inline">Thomas.cpp</strong> file, as follows:</p>
			<p class="source-code">#include "Thomas.h"</p>
			<p class="source-code">#include "TextureHolder.h"</p>
			<p class="source-code">Thomas::Thomas()</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Associate a texture with the sprite</p>
			<p class="source-code">    m_Sprite = Sprite(TextureHolder::GetTexture(</p>
			<p class="source-code">        "graphics/thomas.png"));</p>
			<p class="source-code">    m_JumpDuration = .45;</p>
			<p class="source-code">}</p>
			<p>All we need to do is load the <strong class="source-inline">thomas.png</strong> graphic and set the duration of a jump (<strong class="source-inline">m_JumpDuration</strong>) to .<strong class="source-inline">45 </strong>(nearly half a second).</p>
			<p>Add the definition of the <strong class="source-inline">handleInput</strong> function as follows:</p>
			<p class="source-code">// A virtual function</p>
			<p class="source-code">bool Thomas::handleInput()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_JustJumped = false;</p>
			<p class="source-code">    if (Keyboard::isKeyPressed(Keyboard::W))</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Start a jump if not already jumping</p>
			<p class="source-code">        // but only if standing on a block (not falling)</p>
			<p class="source-code">        if (!m_IsJumping &amp;&amp; !m_IsFalling)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            m_IsJumping = true;</p>
			<p class="source-code">            m_TimeThisJump = 0;</p>
			<p class="source-code">            m_JustJumped = true;</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_IsJumping = false;</p>
			<p class="source-code">        m_IsFalling = true;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    if (Keyboard::isKeyPressed(Keyboard::A))</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_LeftPressed = true;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_LeftPressed = false;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    if (Keyboard::isKeyPressed(Keyboard::D))</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_RightPressed = true;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_RightPressed = false;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return m_JustJumped;</p>
			<p class="source-code">}</p>
			<p>This code should look quite familiar to you. We are using the SFML <strong class="source-inline">isKeyPressed</strong> function to see whether any of the <em class="italic">W</em>, <em class="italic">A</em>, or <em class="italic">D</em> keys are being pressed. </p>
			<p>When <em class="italic">W</em> is pressed, the player is attempting to jump. The code then uses the <strong class="source-inline">if(!m_IsJumping &amp;&amp; !m_IsFalling)</strong> code to check that the character is not already jumping and that it is not falling either. When these tests are both true, <strong class="source-inline">m_IsJumping</strong> is set to <strong class="source-inline">true</strong>, <strong class="source-inline">m_TimeThisJump</strong> is set to 0, and <strong class="source-inline">m_JustJumped</strong> is set to <strong class="source-inline">true</strong>.</p>
			<p>When the previous two tests don't evaluate to <strong class="source-inline">true</strong>, the <strong class="source-inline">else</strong> clause is executed and <strong class="source-inline">m_Jumping</strong> is set to <strong class="source-inline">false</strong>, and <strong class="source-inline">m_IsFalling</strong> is set to true.</p>
			<p>Handling how the <em class="italic">A</em> and <em class="italic">D</em> keys are being pressed is as simple as setting <strong class="source-inline">m_LeftPressed</strong> and/or <strong class="source-inline">m_RightPressed</strong> to <strong class="source-inline">true</strong> or<strong class="source-inline"> false</strong>. The <strong class="source-inline">update</strong> function will now be able to handle moving the character.</p>
			<p>The last line of code in the function returns the value of <strong class="source-inline">m_JustJumped</strong>. This will let the calling code know if it needs to play a jumping sound effect.</p>
			<p>We will now code the <strong class="source-inline">Bob</strong> class. It is nearly identical to the <strong class="source-inline">Thomas</strong> class, except it has different jumping abilities and a different <strong class="source-inline">Texture</strong>, and uses different keys on the keyboard.</p>
			<h2 id="_idParaDest-308"><a id="_idTextAnchor317"/>Coding Bob.h </h2>
			<p>The <strong class="source-inline">Bob</strong> class is identical in structure to the <strong class="source-inline">Thomas</strong> class. It inherits from <strong class="source-inline">PlayableCharacter</strong>, it has a constructor, and it provides the definition of the <strong class="source-inline">handleInput</strong> function. The difference compared to <strong class="source-inline">Thomas</strong> is that we initialize some of Bob's member variables differently and we handle input (in the <strong class="source-inline">handleInput</strong> function) differently as well. Let's code the class and look at the details.</p>
			<p>Right-click <strong class="bold">Header Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">Header File (.h)</strong> and then, in the <strong class="bold">Name</strong> field, type <strong class="source-inline">Bob.h</strong>. Finally, click the <strong class="bold">Add</strong> button. We are now ready to code the header file for the <strong class="source-inline">Bob</strong> class.</p>
			<p>Add the following code to the <strong class="source-inline">Bob.h</strong> file:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include "PlayableCharacter.h"</p>
			<p class="source-code">class Bob : public PlayableCharacter</p>
			<p class="source-code">{</p>
			<p class="source-code">public:</p>
			<p class="source-code">    // A constructor specific to Bob</p>
			<p class="source-code">    Bob::Bob();</p>
			<p class="source-code">    // The overriden input handler for Bob</p>
			<p class="source-code">    bool virtual handleInput();</p>
			<p class="source-code">};</p>
			<p>The previous code is identical to the <strong class="source-inline">Thomas.h</strong> file apart from the class name and therefore the constructor name.</p>
			<h2 id="_idParaDest-309"><a id="_idTextAnchor318"/>Coding Bob.cpp</h2>
			<p>Right-click <strong class="bold">Source Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">C++ File (.cpp)</strong> and then, in the <strong class="bold">Name</strong> field, type <strong class="source-inline">Bob.cpp</strong>. Finally, click the <strong class="bold">Add</strong> button. We are now ready to code the <strong class="source-inline">.cpp</strong> file for the <strong class="source-inline">Bob</strong> class.</p>
			<p>Add the following code for the <strong class="source-inline">Bob</strong> constructor to the <strong class="source-inline">Bob.cpp</strong> file. Notice that the texture is different (<strong class="source-inline">bob.png</strong>) and that <strong class="source-inline">m_JumpDuration</strong> is initialized to a significantly smaller value. Bob is now his own unique self:</p>
			<p class="source-code">#include "Bob.h"</p>
			<p class="source-code">#include "TextureHolder.h"</p>
			<p class="source-code">Bob::Bob()</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Associate a texture with the sprite</p>
			<p class="source-code">    m_Sprite = Sprite(TextureHolder::GetTexture(</p>
			<p class="source-code">        "graphics/bob.png"));</p>
			<p class="source-code">    m_JumpDuration = .25;</p>
			<p class="source-code">}</p>
			<p>Add the <strong class="source-inline">handleInput</strong> code immediately after the <strong class="source-inline">Bob</strong> constructor:</p>
			<p class="source-code">bool Bob::handleInput()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_JustJumped = false;</p>
			<p class="source-code">    if (Keyboard::isKeyPressed(Keyboard::Up))</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Start a jump if not already jumping</p>
			<p class="source-code">        // but only if standing on a block (not falling)</p>
			<p class="source-code">        if (!m_IsJumping &amp;&amp; !m_IsFalling)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            m_IsJumping = true;</p>
			<p class="source-code">            m_TimeThisJump = 0;</p>
			<p class="source-code">            m_JustJumped = true;</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_IsJumping = false;</p>
			<p class="source-code">        m_IsFalling = true;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    if (Keyboard::isKeyPressed(Keyboard::Left))</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_LeftPressed = true;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_LeftPressed = false;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    if (Keyboard::isKeyPressed(Keyboard::Right))</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_RightPressed = true;;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_RightPressed = false;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return m_JustJumped;</p>
			<p class="source-code">}</p>
			<p>Notice that the code is nearly identical to the code in the <strong class="source-inline">handleInput</strong> function of the <strong class="source-inline">Thomas</strong> class. The only difference is that we respond to different keys (the <em class="italic">Left </em>arrow key and <em class="italic">Right</em> arrow key for left and right movement, respectively, and the <em class="italic">Up</em> arrow key for jumping).</p>
			<p>Now that we have a <strong class="source-inline">PlayableCharacter</strong> class that has been extended by the <strong class="source-inline">Bob</strong> and <strong class="source-inline">Thomas</strong> classes, we can add a <strong class="source-inline">Bob</strong> and a <strong class="source-inline">Thomas</strong> instance to the game.</p>
			<h1 id="_idParaDest-310"><a id="_idTextAnchor319"/>Updating the game engine to use Thomas and Bob</h1>
			<p>In order to be able to run the game and see our new characters, we have to declare instances of them, call their <strong class="source-inline">spawn</strong> functions, update them each frame, and draw them each frame. Let's do that now.</p>
			<h2 id="_idParaDest-311"><a id="_idTextAnchor320"/>Updating Engine.h to add an instance of Bob and Thomas</h2>
			<p>Open up the <strong class="source-inline">Engine.h</strong> file and add the following highlighted lines of code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">#include "TextureHolder.h"</p>
			<p class="source-code"><strong class="bold">#include "Thomas.h"</strong></p>
			<p class="source-code"><strong class="bold">#include "Bob.h"</strong></p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">class Engine</p>
			<p class="source-code">{</p>
			<p class="source-code">private:</p>
			<p class="source-code">    // The texture holder</p>
			<p class="source-code">    TextureHolder th;</p>
			<p class="source-code"><strong class="bold">    // Thomas and his friend, Bob</strong></p>
			<p class="source-code"><strong class="bold">    Thomas m_Thomas;</strong></p>
			<p class="source-code"><strong class="bold">    Bob m_Bob;</strong></p>
			<p class="source-code">    const int TILE_SIZE = 50;</p>
			<p class="source-code">    const int VERTS_IN_QUAD = 4;</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    ...</p>
			<p>Now, we have an instance of both <strong class="source-inline">Thomas</strong> and <strong class="source-inline">Bob</strong> that are derived from <strong class="source-inline">PlayableCharacter</strong>.</p>
			<h2 id="_idParaDest-312"><a id="_idTextAnchor321"/>Updating the input function to control Thomas and Bob</h2>
			<p>Now, we will add the ability to control the two characters. This code will go in the input part of the code. Of course, for this project, we have a dedicated <strong class="source-inline">input</strong> function. Open <strong class="source-inline">Input.cpp</strong> and add the following highlighted code:</p>
			<p class="source-code">void Engine::input()</p>
			<p class="source-code">{</p>
			<p class="source-code">    Event event;</p>
			<p class="source-code">    while (m_Window.pollEvent(event))</p>
			<p class="source-code">    {</p>
			<p class="source-code">        if (event.type == Event::KeyPressed)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            // Handle the player quitting</p>
			<p class="source-code">            if (Keyboard::isKeyPressed(Keyboard::Escape))</p>
			<p class="source-code">            {</p>
			<p class="source-code">                m_Window.close();</p>
			<p class="source-code">            }</p>
			<p class="source-code">            // Handle the player starting the game</p>
			<p class="source-code">            if (Keyboard::isKeyPressed(Keyboard::Return))</p>
			<p class="source-code">            {</p>
			<p class="source-code">                m_Playing = true;</p>
			<p class="source-code">            }</p>
			<p class="source-code">            // Switch between Thomas and Bob</p>
			<p class="source-code">            if (Keyboard::isKeyPressed(Keyboard::Q))</p>
			<p class="source-code">            {</p>
			<p class="source-code">                m_Character1 = !m_Character1;</p>
			<p class="source-code">            }</p>
			<p class="source-code">            // Switch between full and split-screen</p>
			<p class="source-code">            if (Keyboard::isKeyPressed(Keyboard::E))</p>
			<p class="source-code">            {</p>
			<p class="source-code">                m_SplitScreen = !m_SplitScreen;</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code"><strong class="bold">    // Handle input specific to Thomas</strong></p>
			<p class="source-code"><strong class="bold">    if(m_Thomas.handleInput())</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        // Play a jump sound</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code"><strong class="bold">    // Handle input specific to Bob</strong></p>
			<p class="source-code"><strong class="bold">    if(m_Bob.handleInput())</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        // Play a jump sound</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">}</p>
			<p>Note how simple the previous code is: all the functionality is contained within the <strong class="source-inline">Thomas</strong> and <strong class="source-inline">Bob</strong> classes. All the code must do is add an include directive for each of the <strong class="source-inline">Thomas</strong> and <strong class="source-inline">Bob</strong> classes. Then, within the <strong class="source-inline">input</strong> function, the code just calls the pure virtual <strong class="source-inline">handleInput</strong> functions on <strong class="source-inline">m_Thomas</strong> and <strong class="source-inline">m_Bob</strong>. The reason we wrap each of the calls in an <strong class="source-inline">if</strong> statement is that they return <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong> based on whether a new jump has just been successfully initiated. We will handle playing the jump sound effects in <a href="B14278_17_Final_AG_ePub.xhtml#_idTextAnchor340"><em class="italic">Chapter 17</em></a>, <em class="italic">Sound Spatialization and the HUD</em>.</p>
			<h2 id="_idParaDest-313"><a id="_idTextAnchor322"/>Updating the update function to spawn and update the PlayableCharacter instances</h2>
			<p>This is broken into two parts. First, we need to spawn Bob and Thomas at the start of a new level, and second, we need to update them (by calling their <strong class="source-inline">update</strong> functions) each frame.</p>
			<h3>Spawning Thomas and Bob</h3>
			<p>We need to call the <strong class="source-inline">spawn</strong> functions of our <strong class="source-inline">Thomas</strong> and <strong class="source-inline">Bob</strong> objects in a few different places as the project progresses. Most obviously, we need to spawn the two characters when a new level begins. In the next chapter, as the number of tasks we need to perform at the beginning of a level increases, we will write a <strong class="source-inline">loadLevel</strong> function. For now, let's just call <strong class="source-inline">spawn</strong> on <strong class="source-inline">m_Thomas</strong> and <strong class="source-inline">m_Bob</strong> in the <strong class="source-inline">update</strong> function, as highlighted in the following code. Add the following code, but keep in mind that it will eventually be deleted and replaced:</p>
			<p class="source-code">void Engine::update(float dtAsSeconds)</p>
			<p class="source-code">{</p>
			<p class="source-code"><strong class="bold">    if (m_NewLevelRequired)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        // These calls to spawn will be moved to a new</strong></p>
			<p class="source-code"><strong class="bold">        // loadLevel() function soon</strong></p>
			<p class="source-code"><strong class="bold">        // Spawn Thomas and Bob</strong></p>
			<p class="source-code"><strong class="bold">        m_Thomas.spawn(Vector2f(0,0), GRAVITY);</strong></p>
			<p class="source-code"><strong class="bold">        m_Bob.spawn(Vector2f(100, 0), GRAVITY);</strong></p>
			<p class="source-code"><strong class="bold">        // Make sure spawn is called only once</strong></p>
			<p class="source-code"><strong class="bold">        m_TimeRemaining = 10;</strong></p>
			<p class="source-code"><strong class="bold">        m_NewLevelRequired = false;</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">    if (m_Playing)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Count down the time the player has left</p>
			<p class="source-code">        m_TimeRemaining -= dtAsSeconds;</p>
			<p class="source-code">        // Have Thomas and Bob run out of time?</p>
			<p class="source-code">        if (m_TimeRemaining &lt;= 0)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            m_NewLevelRequired = true;</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }// End if playing</p>
			<p class="source-code">        </p>
			<p class="source-code">}</p>
			<p>The previous code simply calls <strong class="source-inline">spawn</strong> and passes in a location in the game world, along with the gravity. The code is wrapped in an <strong class="source-inline">if</strong> statement that checks whether a new level is required. The spawning code will be moved to a dedicated <strong class="source-inline">loadLevel</strong> function, but the <strong class="source-inline">if</strong> condition will be part of the finished project. Also, <strong class="source-inline">m_TimeRemaining</strong> is set to an arbitrary 10 seconds for now.</p>
			<p>Now, we can update the instances each frame of the game loop.</p>
			<h3>Updating Thomas and Bob each frame</h3>
			<p>Next, we will update Thomas and Bob. All we need to do is call their <strong class="source-inline">update</strong> functions and pass in the time this frame has taken.</p>
			<p>Add the following highlighted code:</p>
			<p class="source-code">void Engine::update(float dtAsSeconds)</p>
			<p class="source-code">{</p>
			<p class="source-code">    if (m_NewLevelRequired)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // These calls to spawn will be moved to a new</p>
			<p class="source-code">        // LoadLevel function soon</p>
			<p class="source-code">        // Spawn Thomas and Bob</p>
			<p class="source-code">        m_Thomas.spawn(Vector2f(0,0), GRAVITY);</p>
			<p class="source-code">        m_Bob.spawn(Vector2f(100, 0), GRAVITY);</p>
			<p class="source-code">        // Make sure spawn is called only once</p>
			<p class="source-code">        m_NewLevelRequired = false;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    if (m_Playing)</p>
			<p class="source-code">    {</p>
			<p class="source-code"><strong class="bold">        // Update Thomas</strong></p>
			<p class="source-code"><strong class="bold">        m_Thomas.update(dtAsSeconds);</strong></p>
			<p class="source-code"><strong class="bold">        // Update Bob</strong></p>
			<p class="source-code"><strong class="bold">        m_Bob.update(dtAsSeconds);</strong></p>
			<p class="source-code">        // Count down the time the player has left</p>
			<p class="source-code">        m_TimeRemaining -= dtAsSeconds;</p>
			<p class="source-code">        // Have Thomas and Bob run out of time?</p>
			<p class="source-code">        if (m_TimeRemaining &lt;= 0)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            m_NewLevelRequired = true;</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }// End if playing</p>
			<p class="source-code">        </p>
			<p class="source-code">}</p>
			<p>Now that the characters can move, we need to update the appropriate <strong class="source-inline">View</strong> objects to center around the characters and make them the center of attention. Of course, until we have some objects in our game world, the sensation of actual movement will not be achieved.</p>
			<p>Add the following highlighted code:</p>
			<p class="source-code">void Engine::update(float dtAsSeconds)</p>
			<p class="source-code">{</p>
			<p class="source-code">    if (m_NewLevelRequired)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // These calls to spawn will be moved to a new</p>
			<p class="source-code">        // LoadLevel function soon</p>
			<p class="source-code">        // Spawn Thomas and Bob</p>
			<p class="source-code">        m_Thomas.spawn(Vector2f(0,0), GRAVITY);</p>
			<p class="source-code">        m_Bob.spawn(Vector2f(100, 0), GRAVITY);</p>
			<p class="source-code">        // Make sure spawn is called only once</p>
			<p class="source-code">        m_NewLevelRequired = false;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    if (m_Playing)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Update Thomas</p>
			<p class="source-code">        m_Thomas.update(dtAsSeconds);</p>
			<p class="source-code">        // Update Bob</p>
			<p class="source-code">        m_Bob.update(dtAsSeconds);</p>
			<p class="source-code">        // Count down the time the player has left</p>
			<p class="source-code">        m_TimeRemaining -= dtAsSeconds;</p>
			<p class="source-code">        // Have Thomas and Bob run out of time?</p>
			<p class="source-code">        if (m_TimeRemaining &lt;= 0)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            m_NewLevelRequired = true;</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }// End if playing</p>
			<p class="source-code">        </p>
			<p class="source-code"><strong class="bold">    // Set the appropriate view around the appropriate character</strong></p>
			<p class="source-code"><strong class="bold">    if (m_SplitScreen)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        m_LeftView.setCenter(m_Thomas.getCenter());</strong></p>
			<p class="source-code"><strong class="bold">        m_RightView.setCenter(m_Bob.getCenter());</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code"><strong class="bold">    else</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        // Centre full screen around appropriate character</strong></p>
			<p class="source-code"><strong class="bold">        if (m_Character1)</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            m_MainView.setCenter(m_Thomas.getCenter());</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">        else</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            m_MainView.setCenter(m_Bob.getCenter());</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">}</p>
			<p>The previous code handles the two possible situations. First, the <strong class="source-inline">if(mSplitScreen)</strong> condition positions the left-hand view around <strong class="source-inline">m_Thomas</strong> and the right-hand view around <strong class="source-inline">m_Bob</strong>. The <strong class="source-inline">else</strong> clause that executes when the game is in full screen mode tests to see if <strong class="source-inline">m_Character1</strong> is <strong class="source-inline">true</strong>. If it is, then the full screen view (<strong class="source-inline">m_MainView</strong>) is centered around Thomas, otherwise it is centered around Bob. You probably remember that the player can use the <em class="italic">E</em> key to toggle split-screen mode and the <em class="italic">Q</em> key to toggle between Bob and Thomas in full screen mode. We coded this in the <strong class="source-inline">input</strong> function of the <strong class="source-inline">Engine</strong> class, back in <a href="B14278_12_Final_AG_ePub.xhtml#_idTextAnchor272"><em class="italic">Chapter 12</em></a>, <em class="italic">Layering Views and Implementing the HUD</em>.</p>
			<p>Now, we can draw the graphics for Thomas and Bob to the screen.</p>
			<h2 id="_idParaDest-314"><a id="_idTextAnchor323"/>Drawing Bob and Thomas</h2>
			<p>Make sure the <strong class="source-inline">Draw.cpp</strong> file is open and add the following highlighted code:</p>
			<p class="source-code">void Engine::draw()</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Rub out the last frame</p>
			<p class="source-code">    m_Window.clear(Color::White);</p>
			<p class="source-code">    if (!m_SplitScreen)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Switch to background view</p>
			<p class="source-code">        m_Window.setView(m_BGMainView);</p>
			<p class="source-code">        // Draw the background</p>
			<p class="source-code">        m_Window.draw(m_BackgroundSprite);</p>
			<p class="source-code">        // Switch to m_MainView</p>
			<p class="source-code">        m_Window.setView(m_MainView);        </p>
			<p class="source-code"><strong class="bold">        // Draw thomas</strong></p>
			<p class="source-code"><strong class="bold">        m_Window.draw(m_Thomas.getSprite());</strong></p>
			<p class="source-code"><strong class="bold">        // Draw bob</strong></p>
			<p class="source-code"><strong class="bold">        m_Window.draw(m_Bob.getSprite());</strong></p>
			<p class="source-code">    }</p>
			<p class="source-code">    else</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Split-screen view is active</p>
			<p class="source-code">        // First draw Thomas' side of the screen</p>
			<p class="source-code">        // Switch to background view</p>
			<p class="source-code">        m_Window.setView(m_BGLeftView);</p>
			<p class="source-code">        // Draw the background</p>
			<p class="source-code">        m_Window.draw(m_BackgroundSprite);</p>
			<p class="source-code">        // Switch to m_LeftView</p>
			<p class="source-code">        m_Window.setView(m_LeftView);</p>
			<p class="source-code"><strong class="bold">        // Draw bob</strong></p>
			<p class="source-code"><strong class="bold">        m_Window.draw(m_Bob.getSprite());</strong></p>
			<p class="source-code"><strong class="bold">    </strong></p>
			<p class="source-code"><strong class="bold">        // Draw thomas</strong></p>
			<p class="source-code"><strong class="bold">        m_Window.draw(m_Thomas.getSprite());</strong></p>
			<p class="source-code">        </p>
			<p class="source-code">        // Now draw Bob's side of the screen</p>
			<p class="source-code">        // Switch to background view</p>
			<p class="source-code">        m_Window.setView(m_BGRightView);</p>
			<p class="source-code">        // Draw the background</p>
			<p class="source-code">        m_Window.draw(m_BackgroundSprite);</p>
			<p class="source-code">        // Switch to m_RightView</p>
			<p class="source-code">        m_Window.setView(m_RightView);</p>
			<p class="source-code"><strong class="bold">        // Draw thomas</strong></p>
			<p class="source-code"><strong class="bold">        m_Window.draw(m_Thomas.getSprite());</strong></p>
			<p class="source-code"><strong class="bold">        // Draw bob</strong></p>
			<p class="source-code"><strong class="bold">        m_Window.draw(m_Bob.getSprite());</strong></p>
			<p class="source-code">                </p>
			<p class="source-code">    }</p>
			<p class="source-code">    // Draw the HUD</p>
			<p class="source-code">    // Switch to m_HudView</p>
			<p class="source-code">    m_Window.setView(m_HudView);</p>
			<p class="source-code">    </p>
			<p class="source-code">    </p>
			<p class="source-code">    // Show everything we have just drawn</p>
			<p class="source-code">    m_Window.display();</p>
			<p class="source-code">}</p>
			<p>Notice that we draw both Thomas and Bob for full screen, the left, and the right. Also, notice the very subtle difference in the way that we draw the characters in split-screen mode. When drawing the left-hand side of the screen, we switch the order the characters are drawn and draw Thomas after Bob. So, Thomas will always be "on top" on the left and Bob will always be on top on the right. This is because the player controlling Thomas is catered for on the left and Bob the right, respectively.</p>
			<p>You can now run the game and see Thomas and Bob in the center of the screen, as follows: </p>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="image/B14278_15_01b.jpg" alt=""/>
				</div>
			</div>
			<p>If you press the <em class="italic">Q</em> key to switch focus from Thomas to Bob, you will see the <strong class="source-inline">View</strong> make the slight adjustment. If you move either of the characters left or right (Thomas with <em class="italic">A</em> and <em class="italic">D</em>, and Bob with the arrow keys) you will see them move relative to each other.</p>
			<p>Try pressing the <em class="italic">E</em> key to toggle between full screen and split-screen. Then, try moving both characters again to see the effect. In the following screenshot, you can see that Thomas is always centered in the left-hand window and Bob is always centered in the right-hand window:</p>
			<div>
				<div id="_idContainer097" class="IMG---Figure">
					<img src="image/B14278_15_02.jpg" alt=""/>
				</div>
			</div>
			<p>If you leave the game running long enough, the characters will respawn in their original positions every 10 seconds. This is the beginning of the functionality we will need for the finished game. This behavior is caused by <strong class="source-inline">m_TimeRemaining</strong> going below 0 and then setting the <strong class="source-inline">m_NewLevelRequired</strong> variable to <strong class="source-inline">true</strong>.</p>
			<p>Also note that we can't see the full effect of movement until we draw the details of the level. In fact, although it can't be seen, both characters are continuously falling at 300 pixels per second. Since the camera is centering around them every frame and there are no other objects in the game world, we cannot see this downward movement.</p>
			<p>If you want to see this for yourself, just change the call to <strong class="source-inline">m_Bob.spawn</strong>, as follows:</p>
			<p class="source-code">m_Bob.spawn(Vector2f(0,0), 0);</p>
			<p>Now that Bob has no gravitational effect, Thomas will visibly fall away from him. This is shown in the following screenshot:</p>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="image/B14278_15_03.jpg" alt=""/>
				</div>
			</div>
			<p>We <a id="_idTextAnchor324"/>will add some playable levels to interact with in the next chapter.</p>
			<h1 id="_idParaDest-315"><a id="_idTextAnchor325"/>Summary</h1>
			<p>In this chapter, we learned about some new C++ concepts, such as inheritance, which allows us to extend a class and gain all its functionality. We also learned that we can declare variables as protected and that this will give the child class access to them, but they will still be encapsulated (hidden) from all other code. We also used pure virtual functions, which make a class abstract, meaning that the class cannot be instantiated and must therefore be inherited from/extended. We were also introduced to the concept of polymorphism, but will need to wait until the next chapter to use it in our game.</p>
			<p>In the next chapter, we will add some major functionality to the game. By the end of the next chapter, Thomas and Bob will be walking, jumping, and falling. They will even be able to jump on each other's heads, as well as exploring some level designs that have been loaded from a text file.</p>
			<h1 id="_idParaDest-316"><a id="_idTextAnchor326"/>FAQ</h1>
			<p>Q) We learned about Polymorphism, but why didn't I notice anything polymorphic in the game code so far?</p>
			<p>A) We will see polymorphism in action in the next chapter when we write a function that takes <strong class="source-inline">PlayerCharacter</strong> as a parameter. We will see how we can pass both Bob and Thomas to this new function. It will work the same with both of them.</p>
		</div>
	</body></html>