- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: SFINAE, Concepts, and Overload Resolution Management
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SFINAE、概念和重载解析管理
- en: The idiom we study in this chapter, **Substitution Failure Is Not An Error**
    (**SFINAE**), is one of the more complex in terms of the language features it
    uses. Thus, it tends to get inordinate amounts of attention from C++ programmers.
    There is something in this feature that appeals to the mindset of a typical C++
    programmer - a normal person thinks that, if it isn’t broken, don’t mess with
    it. A programmer, especially one writing in C++, tends to think that, if it isn’t
    broken, you’re not using it to its full potential. Let’s just say that SFINAE
    has a lot of potential.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们研究的惯用表达式**替换失败不是错误**（**SFINAE**）在使用的语言特性方面更为复杂。因此，它往往吸引大量的C++程序员的关注。这个特性中有些东西符合典型C++程序员的思维方式——普通人认为，如果它没有坏，就不要去动它。程序员，尤其是C++程序员，往往认为，如果它没有坏，你就没有充分利用它。我们只能说，SFINAE有很大的潜力。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What are function overloading and overload resolution? What are type deduction
    and substitution?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数重载和重载解析是什么？类型推导和替换是什么？
- en: What is SFINAE, and why was it necessary in C++?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SFINAE是什么，为什么它在C++中是必要的？
- en: How can SFINAE be used to write insanely complex, and sometimes useful, programs?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用SFINAE编写极其复杂，有时有用的程序？
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The example code for this chapter can be found at [https://github.com/PacktPublishing/](https://github.com/PacktPublishing/)
    [Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter07](http://Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter07).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可以在[https://github.com/PacktPublishing/](https://github.com/PacktPublishing/)
    [Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter07](http://Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter07)找到。
- en: Overload resolution and overload sets
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重载解析和重载集
- en: This section will test your knowledge of the latest and most advanced additions
    to the C++ standard. We will start with one of the most basic features of C++,
    functions, and their overloads.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将测试你对C++标准最新和最先进补充的了解。我们将从C++最基本的功能之一——函数及其重载开始。
- en: C++ function overloading
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++函数重载
- en: '`f(x)`, then there must be more than one function named `f`. If this happens,
    we are in an overload situation, and overload resolution must take place to find
    out which of these functions should be called.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`f(x)`，那么必须存在多个名为`f`的函数。如果出现这种情况，我们就处于一个重载情况，必须进行重载解析以确定应该调用这些函数中的哪一个。'
- en: 'Let’s start with a simple example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的例子开始：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we have three function definitions for the same name, `f`, and three function
    calls. Note that the function signatures are all different (in that the parameter
    types are different). This is a requirement - overloaded functions must differ
    somehow in their parameters. It is not possible to have two overloads that take
    the exact same arguments but differ in the return type or the function body. Also,
    note that, while the example is for a regular function, the exact same rules apply
    to the overloaded member functions, so we will not pay special attention to member
    functions exclusively.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有三个名为`f`的函数定义和三个函数调用。请注意，函数签名都是不同的（参数类型不同）。这是一个要求——重载函数必须在参数上有所不同。不可能有两个重载接受完全相同的参数，但返回类型或函数体不同。此外，请注意，虽然这个例子是针对常规函数的，但相同的规则也适用于重载成员函数，因此我们不会特别关注成员函数。
- en: Back to our example, which of the `f()` functions is called on each line? To
    understand that, we need to know how overloaded functions are resolved in C++.
    The exact rules for overload resolution are fairly complex and differ in subtle
    ways between different versions of the standard, but for the most part, they are
    designed so that the compiler does what you would expect it to do in the most
    commonly encountered cases. We would expect `f(5)` to call the overload that accepts
    an integer argument since `5` is an `int` variable. And so it does. Similarly,
    `5l` has the long type, and so `f(5l)` calls the second overload. Finally, `5.0`
    is a floating-point number, and so the last overload is called.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的例子，每一行调用的是哪个`f()`函数？为了理解这一点，我们需要知道C++中重载函数是如何解析的。重载解析的确切规则相当复杂，并且在不同版本的规范中存在细微的差异，但大部分情况下，它们被设计成编译器会做你期望它在最常见情况下做的事情。我们预计`f(5)`会调用接受整数参数的重载，因为`5`是一个`int`变量。确实如此。同样，`5l`具有长类型，因此`f(5l)`调用第二个重载。最后，`5.0`是一个浮点数，因此调用最后一个重载。
- en: 'That wasn’t so hard, was it? But what happens if the argument does not match
    the parameter type exactly? Then, the compiler has to consider type conversions.
    For example, the type of the `5.0` literal is `double`. Let’s see what happens
    if we call `f()` with an argument of the `float` type:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不难，对吧？但如果参数与参数类型不完全匹配会发生什么？那么，编译器必须考虑类型转换。例如，`5.0`字面量的类型是`double`。让我们看看如果我们用`float`类型的参数调用`f()`会发生什么：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we have to convert the argument from the `float` type to one of the `int`,
    `long`, or `double` types. Again, the standard has rules, but it should come as
    no surprise that the conversion to `double` is preferred and that the overload
    is called.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须将参数从`float`类型转换为`int`、`long`或`double`类型之一。同样，标准有规则，但将转换为`double`视为首选并且调用重载应该不会令人感到意外。
- en: 'Let’s see what happens with a different integer type, say, `unsigned` `int`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看不同整数类型会发生什么，比如说，`unsigned int`：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now we have two options; convert `unsigned` `int` to a `signed` `int`, or to
    `signed` `long`. While it may be argued that the conversion to `long` is *safer*,
    and thus better, the two conversions are considered so close by the standard that
    the compiler cannot choose. This call does not compile because the overload resolution
    is considered ambiguous; the error message should say as much. If you encounter
    such a problem in your code, you have to help the compiler by casting the arguments
    to a type that makes the resolution unambiguous. Usually, the simplest way is
    to cast the type of the parameter for the overload you want to call:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个选择；将`unsigned int`转换为`signed int`，或者转换为`signed long`。虽然可以争论转换为`long`更安全，因此更好，但标准认为这两种转换非常接近，以至于编译器无法选择。这个调用无法编译，因为重载解析被认为是模糊的；错误信息应该说明这一点。如果你在代码中遇到这样的问题，你必须通过将参数转换为使解析无歧义的类型来帮助编译器。通常，最简单的方法是将重载函数所需参数的类型进行转换：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So far, we have dealt with a situation where the types of parameters were different,
    but their number was the same. Of course, if the number of parameters differs
    between different function declarations for the same name, only the functions
    that can accept the required number of arguments need to be considered. Here is
    an example of two functions with the same name but a different number of arguments:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经处理了参数类型不同但数量相同的情况。当然，如果不同名称的函数声明中参数的数量不同，只需要考虑可以接受所需数量参数的函数。以下是一个具有相同名称但参数数量不同的两个函数的示例：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, the overload resolution is very simple - we need a function that can
    accept two arguments, and there is only one choice. Both arguments will have to
    be converted to `long`. But what if there is more than one function with the same
    number of parameters? Let’s see what happens in the following example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，重载解析非常简单——我们需要一个可以接受两个参数的函数，而且只有一个选择。两个参数都将必须转换为`long`。但如果存在多个具有相同参数数量的函数，会怎样呢？让我们看看以下示例：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First of all, the obvious case - if the types of all arguments match exactly
    the types of the parameters for one of the overloads, that overload is called.
    Next, things start to get interesting - if there is no exact match, we can have
    conversions on each argument. Let’s consider the third call, `f(5, 5.0)`. The
    first argument, `int`, matches the first overload exactly but could be converted
    to `long` if necessary. The second argument, `double`, does not match either overload
    but could be converted to match both. The first overload is a better match - it
    requires fewer argument conversions. Finally, what about the last line? The first
    overload can be called, with a conversion on the second argument. The second overload
    can also be made to work, with a conversion on the first argument. Again, this
    is an ambiguous overload, and this line will not compile. Note that it is not,
    in general, true that the overload with the fewer conversions always wins; in
    more complex cases, it is possible to have ambiguous overloads even if one requires
    fewer conversions (the general rule is, if there is an overload that has the best
    conversion on every argument, it wins; otherwise, the call is ambiguous). To resolve
    this ambiguity, you have to change the types of some of the arguments (by casting,
    in general, or by changing the type of the numeric literal, in our case) to make
    the intended overload be the preferred one.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，最明显的情况 - 如果所有参数的类型与某个重载的参数类型完全匹配，则调用该重载。接下来，事情开始变得有趣 - 如果没有完全匹配，我们可以在每个参数上进行转换。让我们考虑第三次调用，`f(5,
    5.0)`。第一个参数，`int`，与第一个重载完全匹配，但在必要时可以转换为`long`。第二个参数，`double`，与任何重载都不匹配，但可以转换为匹配两者。第一个重载是更好的匹配
    - 它需要的参数转换更少。最后，关于最后一行呢？第一个重载可以通过对第二个参数进行转换来调用。第二个重载也可以通过在第一个参数上进行转换来工作。这又是一个模糊的重载，并且这一行将无法编译。请注意，通常情况下，转换较少的重载并不总是获胜；在更复杂的情况下，即使一个重载需要的转换较少，也可能有模糊的重载（一般规则是，如果有一个重载在所有参数上都有最佳的转换，则获胜；否则，调用是模糊的）。为了解决这种歧义，你必须通过类型转换（通常是通过类型转换，在我们的例子中是通过改变数字字面量的类型）来改变一些参数的类型，以便使预期的重载成为首选的重载。
- en: Note how the third overload was completely left out because it has the wrong
    number of parameters for all function calls. It’s not always that simple, though
    - functions can have default arguments, which means the number of arguments does
    not always have to match the number of parameters.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第三个重载是如何完全被忽略的，因为它对于所有函数调用都具有错误的参数数量。但这并不总是那么简单 - 函数可以有默认参数，这意味着参数的数量并不总是必须与参数的数量匹配。
- en: 'Consider the following code block:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码块：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We now have three overloads. The first and the second can never be confused
    because they have a different number of parameters. The third overload, however,
    can be called with either one or two arguments; in the former case, the second
    argument is assumed to be zero. The first call is the simplest - one argument,
    where the type matches the parameter type of the first overload exactly. The second
    call reminds us of the case we have seen before - two arguments, where the first
    is an exact match to one of the overloads, but the second requires a conversion.
    The alternative overload needs conversions on both arguments, so the second function
    definition is the best match.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有三个重载。第一个和第二个永远不会混淆，因为它们具有不同数量的参数。然而，第三个重载可以用一个或两个参数调用；在前一种情况下，第二个参数被假定为零。第一次调用是最简单的
    - 一个参数，其中类型与第一个重载的参数类型完全匹配。第二次调用让我们想起了之前见过的案例 - 两个参数，其中第一个与某个重载完全匹配，但第二个需要转换。替代重载需要在两个参数上执行转换，因此第二个函数定义是最好的匹配。
- en: The third call seems straightforward enough with its two integer arguments,
    but this simplicity is deceptive - there are two overloads that accept two arguments,
    and in both overload cases, both arguments need conversions. While the conversion
    from `int` to `long` may seem better than the one from `int` to `double`, C++
    does not see it this way. This call is ambiguous. The next call, `f(5.0)`, has
    only one argument, which can be converted to `int`, the type of the parameter
    in the one-argument overload. But it is still a better match for the third overload,
    where it needs no conversion at all. Change the argument type from `double` to
    `float`, and we get the next call. The conversion to `double` is better than that
    to `int`, and utilizing the default argument is not considered a conversion and
    so does not carry any other *penalty* when overloads are compared. The last call
    is again ambiguous - both conversions to `double` and to `int` are considered
    of equal weight, thus the first and third overloads are equally good. The second
    overload offers an exact match to the first parameter; however, there is no way
    to call that overload without the second argument, so it is not even considered.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个调用似乎足够简单，因为它有两个整数参数，但这种简单性具有欺骗性——存在两个接受两个参数的重载版本，并且在两种重载情况下，两个参数都需要转换。虽然从`int`到`long`的转换可能看起来比从`int`到`double`的转换更好，但C++并不这样认为。这个调用是模糊的。下一个调用`f(5.0)`只有一个参数，它可以转换为`int`，这是单参数重载中参数的类型。但它仍然更适合第三个重载，在那里它根本不需要转换。将参数类型从`double`改为`float`，我们得到下一个调用。转换为`double`比转换为`int`更好，并且利用默认参数不被视为转换，因此在重载比较时不会带来任何其他*惩罚*。最后一个调用再次是模糊的——转换为`double`和转换为`int`都被认为是同等重要的，因此第一个和第三个重载同样好。第二个重载提供了对第一个参数的精确匹配；然而，没有方法可以不提供第二个参数就调用该重载，因此它甚至没有被考虑。
- en: So far, we have considered only ordinary C++ functions, although everything
    we have learned applies equally to member functions as well. Now, we need to add
    template functions to the mix.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只考虑了普通的C++函数，尽管我们所学的所有内容同样适用于成员函数。现在，我们需要将模板函数也加入其中。
- en: Template functions
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板函数
- en: In addition to regular functions, for which the parameter types are known, C++
    also has `template` functions. When these functions are called, the parameter
    types are deduced from the types of the arguments at the call site. The template
    functions can have the same name as non-template functions, and several template
    functions can have the same name as well, so we need to learn about overload resolution
    in the presence of templates.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常规函数之外，对于参数类型已知的函数，C++还有`template`函数。当调用这些函数时，参数类型是从调用位置的参数类型中推断出来的。模板函数可以与非模板函数具有相同的名称，也可以有多个模板函数具有相同的名称，因此我们需要了解在模板存在的情况下如何进行重载解析。
- en: 'Consider the following example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `f` function name can refer to any of the three functions, one of which
    is a template. The best overload will be chosen from these three each time. The
    set of functions that are considered for the overload resolution of a particular
    function call is known as the `f()` matches exactly the first non-template function
    in the overload set - the argument type is `int`, and the first function is `f(int)`.
    If an exact match to a non-template function is found in the overload set, it
    is always considered the best overload.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`f`函数名可以指代这三个函数中的任何一个，其中一个是一个模板。每次都会从这三个中选择最佳的重载。考虑特定函数调用重载解析的函数集合被称为`f()`匹配正好与重载集中第一个非模板函数相匹配——参数类型是`int`，第一个函数是`f(int)`。如果在重载集中找到了与非模板函数的精确匹配，它总是被认为是最佳的重载。'
- en: The template function can also be instantiated with an exact match - the process
    of replacing template parameters with concrete types is known as template argument
    substitution (or type substitution), and, if `int` is substituted for the `T`
    template parameter, then we arrive at another function that exactly matches the
    call. However, a non-template function that matches exactly is considered a better
    overload. The second call is processed similarly, but it is an exact match to
    the second function in the overload set, so that is the function that will be
    called. The last call has an argument of the `double` type that can be converted
    to `int` or `long`, or substituted for `T` to make the template instantiation
    an exact match. Since there is no exactly matching non-template function, the
    template function instantiated to an exact match is the next best overload and
    is selected.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'But what happens when there are multiple template functions that can have their
    template parameters substituted to match the argument types of the call? Let’s
    find out:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first call is again an exact match to the non-template function, and so
    is resolved. The second call matches the first, non-template, overload, with a
    conversion, or the second overload exactly if the right type, `long`, is substituted
    for `T`. The last overload does not match either of these calls - there is no
    substitution that would make the `T*` parameter type match either `int` or `long`.
    The last call, however, can be matched to the third overload if `int` is substituted
    for `T`. The problem is that it could also match the second overload if `int*`
    were substituted for `T`. So which template overload is chosen? The answer is
    the more specific one - the first overload, `f(T)`, can be made to match any one-argument
    function call, while the second overload, `f(T*)`, can only match calls with pointer
    arguments. The more specific, narrower overload is considered a better match and
    is selected. This is a new notion, specific to templates - instead of choosing
    better conversions (in general, *fewer* or *simpler* conversions), we select the
    overload that is *harder* to instantiate.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'This rule seemingly breaks for null pointers: `f(NULL)` can call either the
    first or the second overload (`f(int)` or `f(T)`), and `f(nullptr)` call the second
    overload, `f(T)`. The pointer overload is never called, even though both `NULL`
    and `nullptr` are supposedly null pointers. However, this is actually the case
    of the compiler strictly following the rules. `NULL` in C++ is an integer zero,
    it’s actually a macro:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Depending on whether it is defined as `0` or `0L`, `f(int)` or `f(T)` with `T==long`
    are called. The constant `nullptr`, despite having “ptr” in its name, is actually
    a constant value of type `nullptr_t`. It is *convertible* to any pointer type
    but it is not of any pointer type. This is why, when dealing with functions accepting
    pointers of different types, an overload with a `nullptr_t` parameter is often
    declared.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, there is one more kind of function that can match just about any function
    call with the same name, and that is the function that takes variable arguments:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一种函数可以匹配几乎任何具有相同名称的函数调用，那就是接受可变参数的函数：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The first of the overloads can be used for the first three function calls -
    it is an exact match for the first call, and conversions exist to make the other
    two calls fit the signature of the first overload for `f()`. The second function
    in this example can be called with any number of arguments of any type. This is
    considered the choice of last resort - a function with specific arguments that
    can be made to match the call with the right conversions is preferred. This includes
    user-defined conversions, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 重载中的第一个可以用于前三个函数调用 - 它是第一个调用的精确匹配，并且存在转换可以使其他两个调用适合`f()`的第一个重载的签名。在这个示例中的第二个函数可以用任何数量和类型的参数调用。这被认为是最后的手段
    - 具有可以转换为正确转换以匹配调用的特定参数的函数更受欢迎。这包括用户定义的转换，如下所示：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Only if there are no conversions that allow us to avoid calling the `f(...)`
    variadic function, then it has to be called.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在没有转换可以让我们避免调用`f(...)`可变函数的情况下，才必须调用它。
- en: Now we know the order of the overload resolution - first, a non-template function
    that matches the arguments exactly is chosen. If there is no such match in the
    overload set, then a template function is chosen if its parameters can be substituted
    with concrete types in a way that gives an exact match. If there is more than
    one option for such a template function, then a more specific overload is preferred
    over the more general one. If the attempt to match a template function in this
    manner also fails, then a non-template function is called if the arguments can
    be converted to its parameter types. Finally, if everything else fails, but a
    function with the right name that takes variable arguments is available, then
    that function is called. Note that certain conversions are considered *trivial*
    and are included in the notion of the *exact* match, for example, the conversion
    from `T` to `const` `T`. At every step, if there is more than one equally good
    option, the overload is considered ambiguous and the program is ill-formed.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了重载解析的顺序 - 首先选择一个与参数完全匹配的非模板函数。如果在重载集中没有这样的匹配，则选择一个模板函数，如果其参数可以用具体类型替换以给出精确匹配。如果有多个这样的模板函数选项，则更具体的重载优先于更一般的一个。如果以这种方式尝试匹配模板函数也失败，则如果参数可以转换为参数类型，则调用非模板函数。最后，如果所有其他方法都失败，但有一个接受可变参数的正确名称的函数可用，则调用该函数。请注意，某些转换被认为是*平凡的*，并包含在*精确匹配*的概念中，例如，从`T`到`const`
    `T`的转换。在每一步中，如果存在多个同样好的选项，则重载被认为是模糊的，程序是不良的。
- en: The process of type substitution in a template function is what determines the
    final types of the template function parameters, and how good a match they are
    to the arguments of the function call. This process can lead to somewhat unexpected
    results and must be considered in more detail.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 模板函数中的类型替换过程决定了模板函数参数的最终类型，以及它们与函数调用参数的匹配程度。这个过程可能会导致一些意想不到的结果，必须更详细地考虑。
- en: Type substitution in template functions
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板函数中的类型替换
- en: We must carefully differentiate between the two steps in instantiating a template
    function to match a particular call - first, the types of the template parameters
    are deduced from the argument types (a process referred to as type deduction).
    Once the types are deduced, the concrete types are substituted for all parameter
    types (this is a process called **type substitution**). The difference becomes
    more obvious when the function has multiple parameters.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化模板函数以匹配特定调用时，我们必须仔细区分两个步骤 - 首先，从参数类型推导出模板参数的类型（这个过程称为类型推导）。一旦推导出类型，就用具体类型替换所有参数类型（这个过程称为**类型替换**）。当函数有多个参数时，这种差异变得更加明显。
- en: Type deduction and substitution
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型推导和替换
- en: 'Type deduction and substitution are closely related, but not exactly the same.
    The deduction is the process of “*guessing:”* what should the template type, or
    types, be in order to match the call? Of course, the compiler does not really
    guess but applies a set of rules defined in the standard. Consider the following
    example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推导和替换密切相关，但并不完全相同。推导是“*猜测：*”为了匹配调用，模板类型或类型应该是什么的过程？当然，编译器并不是真的猜测，而是应用标准中定义的一组规则。考虑以下示例：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When considering the first call, we can deduce from the first argument that
    the `T` template parameter should be `int`. Thus, `int` is substituted for `T`
    in both parameters of the function. The template is instantiated as `f(int, int*)`
    and is an exact match for the argument types. When considering the second call,
    we could deduce that `T` should be `long` from the first argument. Alternatively,
    we could deduce that `T` should be `int` from the second argument. This ambiguity
    leads to the failure of the type deduction process. If this is the only overload
    available, neither option is chosen, and the program does not compile. If more
    overloads exist, they are considered in turn, including possibly the overload
    of last resort, the `f(...)` variadic function. One important detail to note here
    is that conversions are not considered when deducing template types - the deduction
    of `T` as `int` would have yielded `f(int, int*)` for the second call, which is
    a viable option for calling `f(long, int*)` with the conversion of the first argument.
    However, this option is not considered at all, and instead, type deduction fails
    as ambiguous.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑第一次调用时，我们可以从第一个参数推导出`T`模板参数应该是`int`。因此，`int`被替换为函数的两个参数中的`T`。模板被实例化为`f(int,
    int*)`，与参数类型完全匹配。在考虑第二次调用时，我们可以从第一个参数推导出`T`应该是`long`，或者我们可以从第二个参数推导出`T`应该是`int`。这种歧义导致类型推导过程失败。如果这是唯一可用的重载，则不会选择任何选项，程序无法编译。如果存在更多重载，它们将依次考虑，包括可能是最后的手段，即`f(...)`可变函数的重载。在这里需要注意的一个重要细节是，在推导模板类型时不会考虑转换——将`T`推导为`int`将为第二次调用产生`f(int,
    int*)`，这是调用`f(long, int*)`时转换第一个参数的一个可行选项。然而，这个选项根本没有被考虑，并且类型推导因为歧义而失败。
- en: 'The ambiguous deduction can be resolved by explicitly specifying the template
    types, which removes the need for type deduction:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过明确指定模板类型来解决模糊的推导，从而消除类型推导的需要：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, type deduction is not done at all: we know what `T` is from the function
    call, as it is explicitly specified. Type substitution, on the other hand, still
    has to happen - the first parameter is of the `int` type, and the second is of
    the `int*` type. The function call succeeds with a conversion on the first argument.
    We could also force deduction the other way:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，类型推导根本就没有进行：我们从函数调用中知道`T`是什么，因为它被明确指定了。另一方面，类型替换仍然必须发生——第一个参数是`int`类型，第二个是`int*`类型。函数调用通过转换第一个参数而成功。我们也可以强制进行反向推导：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Again, deduction is not necessary, as we know what `T` is. Substitution proceeds
    in a straightforward way, and we end up with `f(long, long*)`. This function cannot
    be called with `int*` as the second argument since there is no valid conversion
    from `int*` to `long*`. Thus, the program does not compile. Note that, by explicitly
    specifying the types, we have also specified that `f()` must be a template function.
    The non-template overloads for `f()` are no longer considered. On the other hand,
    if there is more than one `f()` template function, then these overloads are considered
    as usual, but this time with the results of the argument deduction forced by our
    explicit specification.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，由于我们知道`T`是什么，所以不需要推导。替换过程是直接的，我们最终得到`f(long, long*)`。由于没有从`int*`到`long*`的有效转换，这个函数不能使用`int*`作为第二个参数来调用。因此，程序无法编译。请注意，通过明确指定类型，我们也指定了`f()`必须是一个模板函数。对于`f()`的非模板重载不再考虑。另一方面，如果有多个`f()`模板函数，那么这些重载将按常规考虑，但这次是使用我们通过明确指定强制进行的参数推导的结果。
- en: 'Template functions can have default arguments, just like non-template functions,
    however, the values of these arguments are not used to deduce types (in C++11,
    template functions can have default values for their type parameters, which provides
    an alternative). Consider the following example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 模板函数可以有默认参数，就像非模板函数一样，然而，这些参数的值并不用于推导类型（在C++11中，模板函数可以为它们的类型参数提供默认值，这提供了一种替代方案）。考虑以下示例：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first call is an exact match to the `f(int,` `int)` non-template function,
    with the default value of `1` for the second argument. Note that it would have
    made no difference if we had declared the function as `f(int i, int j = 1L)`,
    with the default value as `long`. The type of the default argument does not matter
    - if it can be converted to the specified parameter type, then that’s the value
    that is used, otherwise, the program would not compile from line 1\. The second
    call is an exact match to the `f(T, T*)` template function, with `T == long` and
    the default value of `NULL` for the second argument. Again, it does not matter
    at all that the type of that value is not `long*`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用与`f(int, int)`非模板函数完全匹配，第二个参数的默认值为`1`。请注意，如果我们将函数声明为`f(int i, int j = 1L)`，默认值作为`long`，这也不会有任何区别。默认参数的类型并不重要——如果它可以转换为指定的参数类型，那么就使用那个值，否则，程序将从第一行开始就无法编译。第二次调用与`f(T,
    T*)`模板函数完全匹配，`T == long`，第二个参数的默认值为`NULL`。同样，那个值的类型不是`long*`并不重要。
- en: We now understand the difference between type deduction and type substitution.
    Type deduction can be ambiguous when different concrete types can be deduced from
    different arguments. If this happens, it means we have failed to deduce the argument
    types and cannot use this template function. Type substitution is never ambiguous
    - once we know what `T` is, we simply substitute that type every time we see `T`
    in the function definition. This process can also fail, but in a different way.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在理解了类型推导和类型替换之间的区别。当可以从不同的参数推导出不同的具体类型时，类型推导可能会产生歧义。如果发生这种情况，这意味着我们没有推导出参数类型，无法使用此模板函数。类型替换永远不会产生歧义——一旦我们知道`T`是什么，我们每次在函数定义中看到`T`时，就简单地替换那个类型。这个过程也可能失败，但方式不同。
- en: Substitution failure
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换失败
- en: 'Once we have deduced the template parameter types, type substitution is a purely
    mechanical process:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们推导出模板参数类型，类型替换就是一个纯粹机械的过程：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this example, the `T` type can be deduced from the first argument as `int`.
    It can also be deduced from the second argument, also as `int`. Note that the
    return type is not used for type deduction. Since there is only one possible deduction
    for `T`, we now proceed to substitute `T` with `int` every time we see `T` in
    the function definition:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`T`类型可以从第一个参数推导为`int`。它也可以从第二个参数推导为`int`。请注意，返回类型不用于类型推导。由于对`T`只有一个可能的推导，我们现在在函数定义中每次看到`T`时，都将其替换为`int`：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Not all types, however, are created equal, and some allow more liberties than
    others. Consider this code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有类型都是平等的，有些类型比其他类型允许更多的自由度。考虑以下代码：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When considering the first call, the compiler deduces the `T` template parameter
    as being of the `A` type, from both the first and second argument - the first
    argument is a value of the `A` type, and the second one is a reference to the
    value of the `A::t` nested type, which matches `T::t` if we stick with our original
    deduction of `T` as `A`. The second overload yields conflicting values for `T`
    from the two arguments and, therefore, cannot be used. Thus, the first overload
    is called.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑第一次调用时，编译器从第一个和第二个参数推导出`T`模板参数为`A`类型——第一个参数是`A`类型的值，第二个参数是`A::t`嵌套类型的引用，如果我们坚持我们最初对`T`作为`A`的推导，它匹配`T::t`。第二个重载从两个参数中为`T`提供冲突的值，因此不能使用。因此，调用第一个重载。
- en: Now, look closely at the second call. The `T` type can be deduced as `int` from
    the first argument for both overloads. Substituting `int` for `T`, however, yields
    something strange in the second argument of the first overload - `int::t`. This,
    of course, would not compile - `int` is not a class and does not have any nested
    types. In fact, we could expect that the first template overload will fail to
    compile for every `T` type that is not a class, or that does not have a nested
    type called `t`. Indeed, the attempt to substitute `int` for `T` in the first
    template function fails with an invalid type for the second argument. However,
    this substitution failure does not mean that the entire program cannot compile.
    Instead, it is silently ignored, and the overload that would otherwise be ill-formed
    is removed from the overload set. The overload resolution then continues as usual.
    Of course, we could discover that none of the overloads match the function call,
    and the program will still not compile, but the error message will not mention
    anything about `int::t` being invalid; it’ll just say that there are no functions
    that can be called.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, it is important to differentiate between type deduction failure and
    type substitution failure. We can remove the former from consideration entirely:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, the deduction is unnecessary, but the substitution of `int` for `T` must
    still take place, and this substitution yields an invalid expression in the first
    overload. Again, this substitution failure drops this candidate for `f()` from
    the overload set, and the overload resolution continues (in this case, successfully)
    with the remaining candidates. Ordinarily, this would be the end of our exercise
    in overloading: the template produces code that can’t compile, so the entire program
    should not compile either. Fortunately, C++ is more forgiving in this one situation
    and has a special exception that we need to know about.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Substitution Failure Is Not An Error
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The rule that a substitution failure arising from an expression that would
    be invalid with the specified or deduced types does not make the whole program
    invalid is known as **Substitution Failure Is Not An Error** (**SFINAE**). This
    rule is essential for using template functions in C++; without SFINAE, it would
    be impossible to write many otherwise perfectly valid programs. Consider the following
    template overload, which differentiates between regular pointers and member pointers:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'So far, so good - the first time, the function is called with a pointer to
    a specific variable, `a.i`, and the `T` type is deduced as `int`. The second call
    is with a pointer to a data member of the `A` class, where `T` is deduced as `A`.
    But now, let’s call `f()` with a pointer to a different type:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first overload still works fine and is what we want to call. But the second
    overload isn’t just less suitable, it is altogether invalid - it would cause a
    syntax error if we tried to substitute `int` for `T`. This syntax error is observed
    by the compiler and silently ignored, together with the overload itself.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个重载仍然工作得很好，这正是我们想要调用的。但第二个重载不仅不太合适，它完全是无效的——如果我们尝试用 `int` 替换 `T`，它将导致语法错误。这个语法错误被编译器观察到并被静默忽略，连同重载本身。
- en: 'Note that the SFINAE rule is not limited to invalid types, such as references
    to non-existing class members. There are many ways in which substitution can fail:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，SFINAE 规则不仅限于无效类型，例如对不存在类成员的引用。有几种方式可能导致替换失败：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, the template parameter is a value, not a type. We have two template overloads
    that both take a pointer to an array of characters, and array size expressions
    are valid only for some values of `N`. Specifically, a zero-size array is invalid
    in C++. Therefore, the first overload is valid only if `N` `%` `2` is non-zero,
    that is, if `N` is odd. Similarly, the second overload is valid only if `N` is
    even. No arguments are given to the function, so we intend to use the default
    arguments. The two overloads would have been ambiguous in every way, were it not
    for the fact that, for both calls, one of the overloads fails during template
    argument substitution and is silently removed.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，模板参数是一个值，而不是一个类型。我们有两个模板重载，它们都接受字符数组指针，并且数组大小表达式仅对 `N` 的某些值有效。具体来说，零大小数组在
    C++ 中是无效的。因此，第一个重载仅在 `N` `%` `2` 非零时有效，即 `N` 是奇数。同样，第二个重载仅在 `N` 是偶数时有效。没有给函数提供任何参数，所以我们打算使用默认参数。如果没有这两个重载在所有方面都是模糊的，那么在两次调用中，其中一个重载在模板参数替换期间失败并被静默移除。
- en: 'The preceding example is very condensed - in particular, the template parameter
    value deduction, the equivalent of type deduction for numeric parameters is disabled
    by the explicit specification. We can bring the deduction back and still have
    the substitution fail, or not, depending on whether an expression is valid:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例非常简洁——特别是模板参数值推断，相当于数值参数的类型推断被显式指定禁用。我们可以恢复推断，并且替换可能成功或失败，这取决于表达式是否有效：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, the compiler has to deduce the type from the first argument. For the first
    call, `f(a)`, the `A` type is easily deduced. There is no way to deduce the second
    template parameter, `N`, so the default value is used (we are now in C++11 territory).
    Having deduced both template parameters, we now proceed to the substitution, where
    `T` is replaced by `A`, and `N` is replaced by `5`. This substitution fails for
    the second overload but succeeds for the first one. With only one remaining candidate
    in the overload set, the overload resolution concludes. Similarly, the second
    call, `f(b)`, ends up calling the second overload.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编译器必须从第一个参数中推断类型。对于第一次调用，`f(a)`，`A` 类型很容易推断出来。无法推断第二个模板参数，`N`，因此使用默认值（我们现在处于
    C++11 领域）。推断出两个模板参数后，我们现在进行替换，其中 `T` 被替换为 `A`，`N` 被替换为 `5`。这种替换在第二个重载中失败，但在第一个重载中成功。在重载集中只剩下一个候选者时，重载解析结束。同样，第二次调用
    `f(b)` 最终调用的是第二个重载。
- en: 'Note that there is a subtle but very important difference between the preceding
    example and the earlier example where we had this function:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前一个示例和更早的示例之间存在一个微妙但非常重要的区别，其中我们有了这个函数：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this template, the substitution failure is “*natural:*” the parameter that
    may cause the failure is needed and is intended to be of a pointer to member type.
    In the previous case, the template parameter `N` is gratuitous: it is not needed
    for anything other than artificially causing substitution failures and disabling
    some overloads. Why would you ever want to cause an artificial substitution failure?
    We have seen one reason, forcing the selection of otherwise ambiguous overloads.
    The more general reason has to do with the fact that type substitution sometimes
    can lead to errors.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模板中，替换失败是“*自然的*”：可能引起失败的参数是必需的，并且意图是成员指针类型。在前一个情况下，模板参数 `N` 是多余的：它除了人为地导致替换失败和禁用一些重载之外，对任何其他事情都不需要。你为什么要人为地造成替换失败呢？我们已经看到了一个原因，即强制选择其他情况下模糊的重载。更普遍的原因与这样一个事实有关，即类型替换有时可能导致错误。
- en: When substitution failure is still an error
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当替换失败仍然是一个错误时
- en: 'Note that SFINAE does not protect us from any and all syntax errors that might
    happen during template instantiation. For example, if the template parameters
    are deduced, and the template arguments are substituted, we may still end up with
    an ill-formed template function:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，SFINAE并不能保护我们免受在模板实例化过程中可能发生的任何语法错误。例如，如果模板参数被推导，并且模板参数被替换，我们仍然可能得到一个无效的模板函数：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This code fragment is very similar to those we considered earlier, with one
    exception - we do not learn that the template overload presupposes that the `T`
    type is a class, and has a data member named `T::i`, until we examine the function
    body. By then, it is too late, as the overload resolution is done only on the
    basis of the function declaration - the parameters, the default arguments, and
    the return type (the latter is not used to deduce types or select a better overload,
    but still undergoes type substitution and is covered by SFINAE). Once the template
    is instantiated and chosen by the overload resolution, any syntax errors, such
    as an invalid expression in the body of the function, are not ignored - such a
    failure is very much an error. The exact list of contexts where a substitution
    failure is, or is not, ignored, is defined in the standard; it was significantly
    expanded in C++11, with subsequent standards making a few subtle tweaks.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段与我们之前考虑的代码片段非常相似，只有一个例外——我们直到检查函数体时才知道模板重载假设`T`类型是一个类，并且有一个名为`T::i`的数据成员。到那时，已经太晚了，因为重载解析仅基于函数声明——参数、默认参数和返回类型（后者不用于推导类型或选择更好的重载，但仍会进行类型替换并受SFINAE覆盖）。一旦模板被实例化并被重载解析选择，任何语法错误，如函数体内的无效表达式，都不会被忽略——这种失败是一个非常严重的错误。替换失败是否被忽略的确切上下文列表由标准定义；它在C++11中得到了显著扩展，后续标准进行了一些细微的调整。
- en: 'There is another case where an attempt to use SFINAE leads to an error instead.
    Here is an example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一种情况，尝试使用SFINAE会导致错误。以下是一个例子：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here we have a class template. If the type `T` does not have a nested type
    `value_type`, type substitution leads to an error, and this is a real error, it
    is not ignored. You can’t even instantiate this class template with a type that
    does not have `value_type`. Making the function into a template does not solve
    the problem:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个类模板。如果类型`T`没有嵌套类型`value_type`，类型替换会导致错误，这是一个真正的错误，不会被忽略。你甚至不能使用没有`value_type`的类型实例化这个类模板。将函数变成模板并不能解决这个问题：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'It is very important to remember that SFINAE applies only when the error occurs
    during the substitution of the types that were deduced for the template function.
    In the last example, the substitution error does not depend on the template type
    parameter `U`, so it is always going to be an error. If you really need to work
    around this, you have to use a member function template and use a template type
    parameter to trigger the substitution error. Since we do not need an additional
    template parameter, we can default it to be the same as the class template type
    parameter `T`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这一点非常重要，即SFINAE仅在模板函数推导的类型替换过程中发生错误时才适用。在上一个例子中，替换错误并不依赖于模板类型参数`U`，因此它始终会是一个错误。如果你真的需要解决这个问题，你必须使用成员函数模板，并使用模板类型参数来触发替换错误。由于我们不需要额外的模板参数，我们可以将其默认为与类模板类型参数`T`相同：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now the substitution error, if any, will happen with a type dependent on the
    template type parameter `U::value_type`. We do not need to specify type `U` since
    it is defaulted to `T`, and it can’t be anything else because of the requirement
    that types `U` and `T` are the same (otherwise the return type of the function
    is invalid, which is a SFINAE error). Thus, our template member function `f()`
    does (almost) exactly what the original non-template function `f()` did (there
    are subtle differences if the function has overloads within the class). So, if
    you really need to “hide” a substitution error caused by a class template parameter,
    you can do so by introducing a redundant function template parameter and restricting
    the two to always be the same.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果存在替换错误，它将发生在依赖于模板类型参数`U::value_type`的类型上。我们不需要指定类型`U`，因为它默认为`T`，并且由于类型`U`和`T`必须相同的要求（否则函数的返回类型无效，这是一个SFINAE错误），它不能是其他任何东西。因此，我们的模板成员函数`f()`（几乎）完全做了原始非模板函数`f()`所做的事情（如果函数在类中有重载，则存在细微的差异）。所以，如果你真的需要“隐藏”由类模板参数引起的替换错误，你可以通过引入冗余的函数模板参数并将这两个参数限制为始终相同来实现。
- en: Before continuing, let’s review the three kinds of substitution failures we
    encountered.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们回顾一下我们遇到的三种替换失败类型。
- en: Where and why does substitution failure happen?
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换失败发生在哪里？为什么会发生？
- en: To understand the rest of this chapter, it is essential that we clearly differentiate
    between several kinds of substitution failures that can occur in template functions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解本章的其余部分，我们必须清楚地区分在模板函数中可能发生的几种替换失败类型。
- en: 'The first kind happens when the template declaration uses dependent types or
    other constructs that can cause a failure, and their use is necessary to declare
    the template properly. Here is a template function that is intended to be called
    with a container argument (all STL containers have a nested type `value_type`):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种发生在模板声明使用依赖类型或其他可能导致失败的构造时，并且它们的使用对于正确声明模板是必要的。以下是一个旨在使用容器参数调用的模板函数（所有 STL
    容器都有一个嵌套类型 `value_type`）：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we try to call this function with an argument that does not define the nested
    type, `value_type`, the function call will not compile (assuming we have no other
    overloads). There are many more examples where we naturally use dependent types
    and other expressions that may be invalid for some values of template parameters.
    Such invalid expressions cause a substitution failure. It does not have to happen
    in the argument declaration. Here is a template whose return type may be undefined:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试用没有定义嵌套类型 `value_type` 的参数调用这个函数，函数调用将无法编译（假设我们没有其他重载）。还有许多其他例子，我们自然使用依赖类型和其他可能对某些模板参数值无效的表达式。这些无效表达式会导致替换失败。它不必发生在参数声明中。以下是一个返回类型可能未定义的模板：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this template, the return type is the common type of the two template parameter
    types. But what if the template arguments are such that the types `U` and `V`
    have no common type? Then the type expression `std::common_type_t<U, V>` is invalid
    and the type substitution fails. Here is yet another example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模板中，返回类型是两个模板参数类型的公共类型。但如果模板参数的类型 `U` 和 `V` 没有公共类型，会发生什么？那么类型表达式 `std::common_type_t<U,
    V>` 是无效的，类型替换失败。以下又是另一个例子：
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here, again, the substitution failure may occur in the return type, but we
    use the trailing return type so that we can directly check whether the expression
    `*p` compiles (or, more formally, is valid). If it is, the type of the result
    is the return type. Otherwise, the substitution fails. Note that there is a difference
    between this declaration and something like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，再次，替换失败可能发生在返回类型中，但我们使用尾随返回类型，这样我们可以直接检查表达式 `*p` 是否可以编译（或者更正式地说，是否有效）。如果是，结果类型就是返回类型。否则，替换失败。请注意，这种声明与以下类似的东西之间有一个区别：
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If the function argument is a raw pointer, both versions amount to the same
    thing. But the first variant also compiles for any type that can be dereferenced,
    such as container iterators and smart pointers, while the second version works
    only for raw pointers.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数参数是一个原始指针，两种版本都相当于同一件事。但第一种变体也可以为任何可以解引用的类型编译，例如容器迭代器和智能指针，而第二种版本仅适用于原始指针。
- en: 'The second kind of substitution failure happens when the function declaration
    compiles successfully, including the type substitution, and then we get a syntax
    error in the function body. We can easily modify each of these examples to see
    how this might have happened. Let’s start with the `find()` function:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种替换失败发生在函数声明成功编译，包括类型替换，然后我们在函数体中得到语法错误。我们可以轻松地修改这些示例，看看这种情况是如何发生的。让我们从 `find()`
    函数开始：
- en: '[PRE33]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This time, we decided to accept a value of any type. This is not necessarily
    wrong in itself, but the body of our template function is written in the assumption
    that the container type `T` has the nested type `value_type` and that this type
    is comparable with the type `V`. If we call the function with a wrong argument,
    the call will still compile because nothing particular is required of the argument
    types by the substitution that happens in the declaration of the template. But
    then we get a syntax error in the body of the template itself, rather than at
    the call site.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们决定接受任何类型的值。这本身并不一定错误，但我们的模板函数的主体是在假设容器类型 `T` 有嵌套类型 `value_type`，并且这个类型可以与类型
    `V` 相比较的情况下编写的。如果我们用错误的参数调用函数，调用仍然可以编译，因为模板声明中的替换对参数类型没有特别的要求。但然后我们在模板本身的主体中得到语法错误，而不是在调用位置。
- en: 'Here is how a similar thing can happen with the `compute()` template:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的情况也可能发生在`compute()`模板中：
- en: '[PRE34]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This template function can be called for any two arguments, but then it won’t
    compile unless there is a common type for both.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板函数可以对任何两个参数进行调用，但如果没有为两者提供一个共同类型，那么它将无法编译。
- en: 'Note the very significant difference between the two kinds of substitution
    failures: if the failure happens in SFINAE context, the function is removed from
    the overload resolution as if it does not exist. If there is another overload
    (a function with the same name), it will be considered and may end up being called.
    If there is not, we will get a syntax error at the call site that boils down to
    “there is no such function.” On the other hand, if the failure happens in the
    body of the template (or in some other place not covered by SFINAE rules) then,
    assuming the function is the best, or the only, overload, it will be called. The
    client’s code – the call itself – will compile fine, but the template will not.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意两种替换失败之间的非常显著的区别：如果失败发生在SFINAE上下文中，函数将从重载解析中移除，就像它不存在一样。如果有另一个重载（具有相同名称的函数），它将被考虑，并最终可能被调用。如果没有，我们将在调用位置得到一个语法错误，这归结为“没有这样的函数。”另一方面，如果失败发生在模板的主体中（或在SFINAE规则未覆盖的其他地方），假设函数是最好的或唯一的重载，它将被调用。客户端代码——调用本身——将编译正常，但模板将不会。
- en: 'There are several reasons why the first option is preferable. First of all,
    the caller may have wanted to call a different overload, the one that would have
    compiled fine, but the rules for overload resolution among templates are complex
    and the wrong overload was chosen. It may be very difficult for the caller to
    fix this error and force the choice of the intended overload. Second, the error
    messages you get when the body of the template fails compilation are often incomprehensible.
    Our examples were simple, but in a more realistic case, you may see an error that
    involves some internal types and objects that you know nothing about. The last
    reason is more of a conceptual statement: the interface of the template function,
    like any other interface, should describe the requirements on the caller as completely
    as possible. An interface is a contract; if the caller has complied with it, the
    implementer of the function must deliver as promised.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个原因使得第一个选项更可取。首先，调用者可能想要调用一个不同的重载版本，这个版本可以正常编译，但由于模板重载解析的规则复杂，错误地选择了错误的重载。调用者可能很难修复这个错误并强制选择预期的重载。其次，当模板的主体在编译失败时，你收到的错误信息通常难以理解。我们的例子很简单，但在更现实的情况下，你可能会看到一个涉及一些你一无所知的内部类型和对象的错误。最后一个原因是更概念性的陈述：模板函数的接口，就像任何其他接口一样，应该尽可能完整地描述对调用者的要求。接口是一个合同；如果调用者遵守了它，函数的实现者必须履行承诺。
- en: 'Let’s assume that we have a template function whose body has some requirements
    on the type parameters and that these requirements are not captured by the interface
    written in a natural, straightforward way (the type substitution succeeds but
    the template does not compile). The only way to convert the hard substitution
    failure into an SFINAE failure is to make it happen in SFINAE context. To do this,
    we need to add something to the interface that is not necessary to declare the
    function. The only purpose of this addition is to trigger a substitution failure
    and remove the function from the overload resolution set before it could lead
    to a compilation error in the body of the function. Such “artificial” failure
    is the third kind of substitution failure. Here is an example where we enforce
    the requirement that the types are pointers even though the interface itself would
    be just fine without it:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个模板函数，其主体对类型参数有一些要求，而这些要求没有以自然、直接的方式（类型替换成功但模板无法编译）被接口捕获。将硬替换失败转换为SFINAE失败的唯一方法是在SFINAE上下文中使其发生。为此，我们需要在接口中添加一些不是声明函数所必需的东西。这种添加的唯一目的是触发替换失败，并在函数主体中导致编译错误之前，将函数从重载解析集中移除。这种“人工”的失败是第三种替换失败。以下是一个例子，我们强制要求类型是指针，尽管接口本身即使没有这个要求也可以正常工作：
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This function takes two pointers (or any other pointer-like objects that can
    be dereferenced) and returns the Boolean result of comparing the values they point
    to. In order for the body of the function to compile, both arguments must be something
    that can be dereferenced. Furthermore, the results of dereferencing them must
    be comparable for equality. Finally, the result of the comparison must be convertible
    to bool. The trailing return type declaration is unnecessary: we could have just
    declared the function to return `bool`. But it does have an effect: it moves a
    possible substitution failure from the body of the function to its declaration,
    where it becomes an SFINAE failure. The return type is always `bool` unless the
    expression inside `decltype()` is invalid. That could happen for any of the same
    reasons the function body would not compile: one of the arguments cannot be dereferenced,
    the values are not comparable, or the result of the comparison is not convertible
    to `bool` (the latter is usually redundant, but we might as well enforce the entire
    contract).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受两个指针（或任何其他可以解引用的指针类对象）并返回比较它们指向的值的布尔结果。为了使函数体能够编译，两个参数都必须是可以解引用的。此外，解引用它们的结果必须可以比较相等。最后，比较的结果必须可以转换为
    bool。尾随的返回类型声明是不必要的：我们本来可以直接声明函数返回 `bool`。但它确实有影响：它将可能的替换失败从函数体移动到其声明中，在那里它成为了一个SFINAE失败。除非
    `decltype()` 内部的表达式无效，否则返回类型始终是 `bool`。这可能会发生的原因与函数体无法编译的原因相同：其中一个参数无法解引用，值不可比较，或者比较的结果无法转换为
    `bool`（后者通常是多余的，但我们还是应该强制整个合同）。
- en: 'Notice that the line between the “natural” and “artificial” substitution failures
    is not always clear. For example, one could have argued that using `std::common_type_t<U,
    V>` as the return type earlier was artificial (the third kind of substitution
    failure, not the first kind) and that the “natural” way would be to declare the
    return type as `auto` and let the function body fail if the common type could
    not be deduced. Indeed, the difference often boils down to the programmer’s style
    and intent: if it wasn’t for the need to enforce the type restriction, would the
    programmer have written the type expression in the template declaration anyway?'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到“自然”和“人工”替换失败之间的界限并不总是清晰的。例如，有人可能会争论，之前使用 `std::common_type_t<U, V>` 作为返回类型是人工的（第三种替换失败，而不是第一种），“自然”的方式应该是声明返回类型为
    `auto`，并让函数体在无法推导出公共类型时失败。确实，这种差异通常归结为程序员的风格和意图：如果不是因为需要强制类型限制，程序员是否仍然会在模板声明中写出类型表达式？
- en: 'The failures of the first kind are straightforward: the template interface
    itself forms a contract, the attempted call violated the contract, and the function
    wasn’t called. The failures of the second kind are, ideally, to be avoided altogether.
    But to do that, we have to employ the failures of the third kind, the artificial
    substitution failures in SFINAE context. The rest of this chapter deals with the
    ways to code such interface-limiting template contracts. Since the first days
    of C++, SFINAE techniques were used to artificially cause a substitution failure
    that would remove such functions from the overload set. C++20 added a totally
    different mechanism for solving this problem: concepts. Before we discuss controlling
    overload resolution with SFINAE, we need to learn more about this latest addition
    to the language.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第一类失败的解决方法是直接的：模板接口本身形成一个合同，尝试调用违反了合同，并且函数没有被调用。理想情况下，应完全避免第二类失败。但为了做到这一点，我们必须使用第三类失败，即SFINAE上下文中的人工替换失败。本章的其余部分将讨论编码此类接口限制模板合同的方法。自从C++的第一天起，SFINAE技术就被用来人为地引起替换失败，从而将这些函数从重载集中删除。C++20为解决这个问题添加了一种全新的机制：概念。在我们讨论使用SFINAE控制重载解析之前，我们需要更多地了解这种语言最新的补充。
- en: Concepts and constraints in C++20
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++20中的概念和约束
- en: The rest of this chapter is all about the “artificial” substitution failures
    that are added to the template declaration to impose restrictions on the template
    arguments. In this section, we are going to learn about the new, C++20, way of
    coding these restrictions. In the next section, we will show what you can do if
    you can’t use C++20 but still want to constrain your templates.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分都是关于添加到模板声明中用于对模板参数施加限制的“人工”替换失败。在本节中，我们将了解C++20中编码这些限制的新方法。在下一节中，我们将展示如果你不能使用C++20但仍想约束你的模板，你可以做什么。
- en: Constraints in C++20
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++20中的约束
- en: C++20 changed the way we are using SFINAE to restrict template arguments by
    introducing concepts and constraints. Even though the overall feature is usually
    referred to as “concepts,” it is the constraints that are the most important part.
    What follows is not a complete or formal description of these features, but rather
    a demonstration of the best practices (it may be too early to say “patterns” since
    the community is still in the process of establishing what is and isn’t sufficiently
    widely accepted).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: C++20 通过引入概念和约束来改变我们使用 SFINAE 限制模板参数的方式。尽管整体特性通常被称为“概念”，但约束才是最重要的部分。以下内容不是这些特性的完整或正式描述，而是一种最佳实践的演示（由于社区仍在确定哪些是足够广泛接受的，因此说“模式”可能还为时过早）。
- en: 'The first way to specify a constraint is by writing a `requires` clause that
    has the form:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 指定约束的第一种方式是通过编写一个具有以下形式的 `requires` 子句：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The keyword `requires` and the constant (compile-time) expression in parentheses
    must appear either immediately after the template parameters or as the last element
    of the function declaration:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字 `requires` 和括号中的常量（编译时）表达式必须出现在模板参数之后，或者作为函数声明的最后一个元素：
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Just like in the last section, the constraint written at the end of the declaration
    can refer to the function arguments by name, while the constraint written after
    the parameter list can refer only to the template parameters (other, more subtle
    differences between the two syntaxes are outside of the scope of this chapter).
    Unlike the last section, if a constraint fails, the compiler usually issues a
    clear diagnostic instead of simply reporting that “no function f was found” and
    template deduction failed.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在上一节中一样，声明末尾的约束可以按名称引用函数参数，而参数列表之后的约束只能引用模板参数（这两种语法之间的其他，更微妙的不同超出了本章的范围）。与上一节不同的是，如果约束失败，编译器通常会提供一个清晰的诊断信息，而不是简单地报告“找不到函数
    f”和模板推导失败。
- en: 'What can be used in the constant expression in a `requires` clause? Anything
    that can be computed at compile time, really, as long as the overall result is
    a `bool`. Type traits such as `std::is_convertible_v` or `std::is_default_constructible_v`
    are often used to restrict types. If the expressions are complex, `constexpr`
    functions can help to simplify them:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `requires` 子句中的常量表达式中可以使用什么？实际上，任何可以在编译时计算的表达式都可以，只要整体结果是 `bool`。例如，可以使用类型特性如
    `std::is_convertible_v` 或 `std::is_default_constructible_v` 来限制类型。如果表达式复杂，`constexpr`
    函数可以帮助简化它们：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'But there is one special expression that we have not seen before – the `requires`
    expression. This expression can be used to check if some arbitrary expression
    compiles (technically, it “is valid”):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 但有一个我们之前没有见过的特殊表达式——`requires` 表达式。这个表达式可以用来检查某个任意表达式是否可以编译（技术上，它“是有效的”）：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Assuming the values `a` and `b` are defined in the context where the expression
    is used, this expression evaluates to `true` if the expression `a + b` is valid.
    What if we know the types we want to test but don’t have the variables? Then we
    can use the second form of the `requires` expression:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `a` 和 `b` 的值是在表达式使用的上下文中定义的，如果表达式 `a + b` 是有效的，则此表达式评估为 `true`。如果我们知道我们想要测试的类型，但没有变量怎么办？那么我们可以使用
    `requires` 表达式的第二种形式：
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The types `A` and `B` usually refer to the template parameters or some dependent
    types.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 `A` 和 `B` 通常指的是模板参数或某些依赖类型。
- en: Note that we said “arbitrary expression is valid” and not “arbitrary code is
    valid.” This is an important difference. For example, you can’t write
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们说的是“任意表达式是有效的”，而不是“任意代码是有效的”。这是一个重要的区别。例如，你不能写
- en: '[PRE41]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And require that the type `C` meets all requirements for a range-for loop.
    Most of the time, you test expressions such as `cont.begin()` and `cont.end()`
    instead. However, you can also come up with a more complex requirement by hiding
    the code in a lambda expression:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 并要求类型 `C` 满足范围-for 循环的所有要求。大多数时候，你测试的是像 `cont.begin()` 和 `cont.end()` 这样的表达式。然而，你也可以通过在
    lambda 表达式中隐藏代码来提出更复杂的要求：
- en: '[PRE42]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Woe is you if such code ever fails and you have to figure out the error message.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这样的代码失败，你必须找出错误信息，那可就糟糕了。
- en: 'When a `requires` expression is used in a template constraint, the template
    is restricted not by a specific trait but by the required behavior of the types:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当在模板约束中使用 `requires` 表达式时，模板的限制不是由特定的特性，而是由类型所需的行为来决定的：
- en: '[PRE43]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'First of all, yes, there are two keywords `requires` (by the way, parentheses
    are optional in this case and you can find this constraint written as `requires
    requires` ). The first `requires` introduces a constraint, a `requires` clause.
    The second `requires` begins the `requires` expression. The expression in the
    first function `f()` is valid if the second template argument `p` can be dereferenced
    (it can be a pointer, but it doesn’t have to be) and the result can be assigned
    to the first argument `i`. We don’t require that the types on both sides of the
    assignment be the same or even that `*p` can be convertible to `T` (usually it
    would be, but it’s not required). We just need the expression `i = *p` to compile.
    Finally, if we did not have the right variables readily available, we could have
    declared them as parameters to the `requires` expression:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，是的，有两个关键字 `requires`（顺便说一句，在这种情况下括号是可选的，你可以找到这个约束被写成 `requires requires`）。第一个
    `requires` 引入了一个约束，一个 `requires` 子句。第二个 `requires` 开始了 `requires` 表达式。第一个函数 `f()`
    中的表达式在第二个模板参数 `p` 可以解引用（它可以是一个指针，但不一定必须是）并且结果可以赋值给第一个参数 `i` 时是有效的。我们不需要要求赋值两边的类型相同，甚至不需要
    `*p` 可以转换为 `T`（通常是这样的，但不是必需的）。我们只需要 `i = *p` 这个表达式能够编译。最后，如果我们没有现成的正确变量，我们可以将它们声明为
    `requires` 表达式的参数：
- en: '[PRE44]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'These two examples also demonstrate that we can do SFINAE overload control
    with constraints: if a constraint fails, the template function is removed from
    the overload resolution set and the resolution continues.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个例子还表明，我们可以使用约束来进行 SFINAE 覆盖控制：如果约束失败，模板函数将从重载解析集中移除，并且解析继续。
- en: 'As we have seen already, sometimes we need to check not an expression but a
    dependent type; we can do that inside the `requires` expression as well:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，有时我们需要检查的不是表达式，而是一个依赖类型；我们也可以在 `requires` 表达式中这样做：
- en: '[PRE45]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'A requires expression evaluates to bool, so it can be used in a logical expression:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`requires` 表达式计算结果为 bool，因此它可以用在逻辑表达式中：'
- en: '[PRE46]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We could combine multiple requires expressions this way, but we can also write
    more code inside a single expression:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过这种方式组合多个 `requires` 表达式，但也可以在单个表达式中编写更多的代码：
- en: '[PRE47]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here we require that the type `T` has a nested type `value_type` and an index
    operator that accepts integer indices.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们要求类型 `T` 有一个嵌套类型 `value_type` 和一个接受整数索引的索引运算符。
- en: 'Finally, sometimes we need to check not just that some expression compiles
    but that its result has a certain type (or satisfies some type requirements).
    This can be done with the compound form of the `requires` expression:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有时我们需要检查的不仅仅是某个表达式能否编译，还要检查它的结果是否具有某种类型（或满足某些类型要求）。这可以通过 `requires` 表达式的复合形式来完成：
- en: '[PRE48]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here we require that the expression `t + 1` compiles and yields the result of
    the same type as the variable `t` itself. The last part is done using a concept;
    you will read about them in the next section, but for now, think of it as an alternative
    way to write the `std::is_same_v` type trait.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们要求表达式 `t + 1` 能够编译，并且产生与变量 `t` 本身相同类型的结果。最后一部分是通过一个概念完成的；你将在下一节中了解到它们，但现在是把它看作是编写
    `std::is_same_v` 类型特性的一种替代方法。
- en: Speaking of concepts… Everything we have described so far can be found under
    the heading of “concepts” in any C++20 book, except we have not mentioned the
    concepts themselves. That is about to change.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 说到概念……到目前为止我们所描述的一切都可以在任何 C++20 书籍的“概念”标题下找到，但我们还没有提到概念本身。这即将改变。
- en: Concepts in C++20
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++20 中的概念
- en: Concepts are simply a named set of requirements – the same requirements we were
    just learning about. In a way, they are similar to `constexpr` functions, except
    they operate on types, not values.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 概念只是对一组要求的命名集合——就是我们刚刚学习到的那些要求。从某种意义上说，它们类似于 `constexpr` 函数，除了它们操作的是类型，而不是值。
- en: 'You use a concept when there is a set of requirements that you refer to often,
    or one that you want to give a meaningful name to. For example, a range is defined
    by a very simple requirement: it must have a begin iterator and an end iterator.
    We can write a simple requires expression every time we declare a function template
    that accepts a range argument, but it is both more convenient and more readable
    to give this requirement a name:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当有一组经常引用的要求，或者你想要给它们一个有意义的名称时，你会使用概念。例如，范围由一个非常简单的要求定义：它必须有一个开始迭代器和结束迭代器。每次我们声明一个接受范围参数的函数模板时，我们都可以写一个简单的
    `requires` 表达式，但这既方便又易于阅读，给这个要求一个名称：
- en: '[PRE49]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We have just introduced a concept named `Range` with one template type parameter
    `R`; this type must have begin and end iterators (the reason we use `std::begin()`
    instead of the member function `begin()` is that C arrays are also ranges but
    they have no member functions).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚介绍了一个名为`Range`的概念，它有一个模板类型参数`R`；此类型必须具有开始和结束迭代器（我们使用`std::begin()`而不是成员函数`begin()`的原因是C数组也是范围，但没有成员函数）。
- en: Note that C++20 has a ranges library and a corresponding set of concepts (including
    `std::ranges::range` that should be used instead of our homemade `Range` in any
    real code) but the idea of ranges makes for convenient teaching material and we
    will use it to drive the examples.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，C++20有一个范围库和相应的一组概念（包括`std::ranges::range`，在任何实际代码中应使用它而不是我们自制的`Range`），但范围的概念是方便的教学材料，我们将用它来驱动示例。
- en: 'Once we have a named concept, we can use it instead of spelling out the requirements
    in any template constraint:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个命名的概念，我们就可以用它来代替在模板约束中详细说明的要求：
- en: '[PRE50]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As you can see, the concept can be used inside a `requires` clause as if it
    was a `constexpr` variable of type `bool`. Indeed, a concept can also be used
    in contexts such as static assert:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，概念可以在`requires`子句中使用，就像它是一个类型为`bool`的`constexpr`变量一样。确实，概念也可以在静态断言等上下文中使用：
- en: '[PRE51]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'For simple template declarations where the concept is the whole requirement,
    the language provides a much simpler way to state it:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于概念是整个要求的简单模板声明，语言提供了一种更简单的方式来表述它：
- en: '[PRE52]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In other words, the concept name can be used instead of the `typename` keyword
    in a template declaration. Doing so automatically restricts the corresponding
    type parameter to types that satisfy the concept. If necessary, a `requires` clause
    can still be used to define additional constraints. Finally, the concepts can
    also be used with the new C++20 template syntax:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，可以在模板声明中使用概念名称代替`typename`关键字。这样做会自动将相应的类型参数限制为满足该概念的类型。如果需要，仍然可以使用`requires`子句来定义额外的约束。最后，概念也可以与新的C++20模板语法一起使用：
- en: '[PRE53]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: All three declarations have the same effect and the choice is largely a matter
    of style and convenience.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个声明具有相同的效果，选择主要取决于风格和便利性。
- en: Concepts and type restrictions
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概念和类型限制
- en: 'We have already seen how concepts and constraints are used to impose restrictions
    on the parameters of function templates. The `requires` clauses can appear after
    the template parameters or at the end of the function declaration; both places
    are SFINAE contexts and a substitution failure in either location does not stop
    the compilation of the entire program. In this regard, concepts are not fundamentally
    different from substitution failures: while you can use a constraint outside of
    an SFINAE context, a substitution failure would still be an error. For example,
    you cannot assert that a type does not have a nested type `value_type` by using
    a constraint:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用概念和约束来对函数模板的参数施加限制。`requires`子句可以出现在模板参数之后或函数声明的末尾；这两个地方都是SFINAE上下文，任一位置的替换失败都不会停止整个程序的编译。在这方面，概念与替换失败没有本质的不同：虽然你可以在SFINAE上下文之外使用约束，但替换失败仍然是一个错误。例如，你不能通过使用约束来断言一个类型没有嵌套类型`value_type`：
- en: '[PRE54]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You may expect that the `requires` expression evaluates to false if the requirement
    is not met, but in this case, it simply does not compile (you get the error that
    `T::value_type` does not refer to a valid type).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能期望如果未满足要求，`requires`表达式将评估为假，但在此情况下，它根本无法编译（你会得到错误信息，即`T::value_type`未引用一个有效的类型）。
- en: 'However, there are restrictions you can enforce with concepts that were impossible
    to implement before. These are requirements for class templates. In the simplest
    form, we can use a concept to restrict class template type parameters:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用概念可以实施一些以前无法实现的限制。这些是针对类模板的要求。在最简单的情况下，我们可以使用一个概念来限制类模板的类型参数：
- en: '[PRE55]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This class template can only be instantiated with types that satisfy the concept
    `Range`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此类模板只能用满足`Range`概念的类型实例化。
- en: 'Then, we can constrain individual member functions, whether they are templates
    or not:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以约束单个成员函数，无论它们是否是模板：
- en: '[PRE56]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now the class template itself can be instantiated on any type. However, its
    interface includes a member function `sort()` only if the type satisfies the `Range`
    constraint.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在类模板本身可以在任何类型上实例化。然而，如果类型满足`Range`约束，其接口才包括一个成员函数`sort()`。
- en: 'This is a very important difference between constraints and the old SFINAE:
    the artificial substitution failure helps only if it happens when substituting
    deduced type parameters in function templates. Earlier in this chapter, we had
    to add a dummy template type parameter to a member function just so we could create
    an SFINAE failure. With concepts, there is no need for any of that.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在约束和旧SFINAE之间的一个非常重要的区别：人工替换失败只有在替换函数模板中推导出的类型参数时才会起到帮助作用。在本章的早期，我们不得不向一个成员函数添加一个虚拟模板类型参数，只是为了能够创建一个SFINAE失败。有了概念，就无需做这些了。
- en: Concepts and constraints are the best way to specify restrictions on template
    parameters. They make a lot of the SFINAE tricks invented over the years obsolete.
    But not everyone has access to C++20 yet. Also, some of the SFINAE techniques
    are still used even with concepts. In the last section, we will learn about these
    techniques as well as see what can be done if you do not have C++20 but still
    want to constraint template types.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 概念和约束是指定模板参数限制的最佳方式。它们使多年来发明的许多SFINAE技巧变得过时。但并非每个人都能访问C++20。此外，即使有概念，一些SFINAE技术仍然在使用。在最后一节中，我们将学习这些技术，并了解如果你没有C++20但仍然想要约束模板类型，可以做什么。
- en: SFINAE techniques
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SFINAE技术
- en: The rule that a failure of the template argument substitution is not an error
    - the SFINAE rule - had to be added to the language simply to make certain narrowly
    defined template functions possible. But the ingenuity of a C++ programmer knows
    no bounds, and so SFINAE was repurposed and exploited to manually control the
    overload set by intentionally causing substitution failures. A huge variety of
    SFINAE-based techniques were invented over the years until the C++20 concepts
    made most of them obsolete.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 模板参数替换失败不是错误——SFINAE规则——必须添加到语言中，只是为了使某些狭窄定义的模板函数成为可能。但是，C++程序员的独创性没有界限，因此SFINAE被重新定位并利用来通过故意造成替换失败来手动控制重载集。多年来，发明了大量的基于SFINAE的技术，直到C++20的概念使其中大多数变得过时。
- en: Still, some use of SFINAE remains even in C++20, and then there is the vast
    body of pre-C++20 code that you may need to read, understand, and maintain.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，即使在C++20中，一些SFINAE的使用仍然存在，而且还有大量的C++20之前的代码，你可能需要阅读、理解和维护。
- en: Let’s start with the applications of SFINAE that are still useful even when
    concepts are available.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从SFINAE的应用开始，即使有概念可用，这些应用仍然是有用的。
- en: SFINAE in C++20
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++20中的SFINAE
- en: 'First of all, even in C++20, there are still “natural” type substitution failures.
    For example, you may want to write this function:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，即使在C++20中，仍然存在“自然”的类型替换失败。例如，你可能想编写这个函数：
- en: '[PRE57]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This is still fine, assuming you really want to return a value of the type
    given by the nested `value_type`. However, before you rush to answer “yes” you
    should examine closely what is the type you really want to return. What is the
    contract with the caller that you want to enforce? Maybe the existence of `value_type`
    was used as a proxy for the real requirements, such as the type T has the index
    operator or can be used as a range to iterate over. In this case, you can now
    state the requirements directly, for example:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然是可行的，假设你真的想返回由嵌套的`value_type`给出的类型。然而，在你匆忙回答“是的”之前，你应该仔细检查你真正想要返回的类型是什么。你想要强制执行与调用者的哪种契约？也许`value_type`的存在被用作真实要求的代理，例如类型T具有索引操作符或可以用作迭代范围。在这种情况下，你现在可以直接声明这些要求，例如：
- en: '[PRE58]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This says that what you really need is a type with member functions `begin()`
    and `end()`. The values returned by these functions (presumably, the iterators)
    are dereferenced and compared; if these operations are supported, the return values
    are close enough to iterators for our purposes. Finally, in the preceding example,
    we let the compiler determine the return type. This is often convenient, but the
    downside is that the interface – our contract – does not say what the return type
    is; the client of our code must read the implementation. Assuming we return a
    value we get by dereferencing an iterator, we can be explicit about it:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你真正需要的是一个具有成员函数`begin()`和`end()`的类型。这些函数返回的值（假设是迭代器）被解引用并比较；如果这些操作受支持，返回值对我们来说足够接近迭代器。最后，在前面的例子中，我们让编译器确定返回类型。这通常很方便，但缺点是接口——我们的契约——没有说明返回类型是什么；我们的代码的客户必须阅读实现。假设我们返回通过解引用迭代器得到的值，我们可以明确地指出这一点：
- en: '[PRE59]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This is a very comprehensive contract with the client, assuming, of course,
    that we as implementers guarantee that the body of the function will compile if
    the stated requirements are met. Otherwise, the contract is incomplete: for example,
    if we do use `T::value_type` in the body of the function, we should add `typename
    T::value_type` to the list of requirements, whether or not this is the type we
    eventually return (if it is, we could still use SFINAE for the return type, nothing
    wrong with that).'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常全面的客户合同，当然，前提是我们作为实施者保证如果满足所列要求，函数的主体将能够编译。否则，合同是不完整的：例如，如果我们确实在函数的主体中使用了`T::value_type`，我们应该将`typename
    T::value_type`添加到要求列表中，无论这最终返回的类型是什么（如果是，我们仍然可以使用SFINAE来处理返回类型，这没有问题）。
- en: 'Similar considerations exist when a dependent type is used to declare a template
    function argument, for example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用依赖类型声明模板函数参数时，也存在类似的考虑，例如：
- en: '[PRE60]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Again, we should ask ourselves if these really are the requirements we want
    to impose. Assuming the function is looking for the value `x` in the container
    `t`, do we really care what the type of `x` is as long as it can be compared with
    the values stored in the container? Consider this alternative:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们应该问自己这些是否真的是我们想要施加的要求。假设函数正在查找容器`t`中的值`x`，只要它可以与容器中存储的值进行比较，我们是否真的关心`x`的类型？考虑这个替代方案：
- en: '[PRE61]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Now we require that the container has everything needed for a range-for loop
    and that the values stored in the container can be compared with `x` for equality.
    Assuming that all we do is iterate over the container and return true if a value
    equal to `x` is found, this is all we need to require from the caller.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要求容器具有范围-for循环所需的一切，并且容器中存储的值可以与`x`进行比较以实现相等。假设我们只是迭代容器，如果找到等于`x`的值则返回true，这就是我们从调用者那里需要的要求。
- en: You should not infer that the “natural” SFINAE should no longer be used in C++20
    and be replaced by independent template parameters bound together by constraints.
    All we suggest is that you examine your code to determine whether the contract
    expressed by the interface and enforced through SFINAE is really what you want,
    or merely what was convenient to code. In the latter case, concepts offer a way
    to express what you really wanted to require but could not (but do read on, because
    there are concept-inspired techniques that can be used before C++20 and meet the
    same need). On the other hand, if the template function is best written in a way
    that triggers a substitution failure when the client supplies an invalid argument,
    then, by all means, continue to use SFINAE – there is no need to rewrite everything
    to use concepts.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该推断出在C++20中“自然”的SFINAE不再使用，而是被独立的模板参数和约束绑定所取代。我们建议的只是检查你的代码，以确定接口表达并通过SFINAE执行的合同是否真的是你想要的，或者仅仅是编写代码方便的。在后一种情况下，概念提供了一种表达你真正想要要求但无法（但请继续阅读，因为有一些受概念启发的技术可以在C++20之前使用并满足相同需求）的方法。另一方面，如果模板函数最好以在客户端提供无效参数时触发替换失败的方式编写，那么，无论如何，继续使用SFINAE——没有必要重写一切以使用概念。
- en: Even the “artificial” SFINAE still has uses in C++20, as we are about to see.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是“人工”的SFINAE在C++20中仍然有用途，正如我们即将看到的。
- en: SFINAE and type traits
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SFINAE和类型特性
- en: 'The most important application of “artificial” SFINAE in C++20 is writing type
    traits. Type traits are not going anywhere: even if you replace `std::is_same_v`
    (trait) with `std::same_as` (concept) in your code, you should know that the concept’s
    implementation uses the very trait it replaces.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++20中，“人工”SFINAE最重要的应用是编写类型特性。类型特性不会消失：即使你在代码中将`std::is_same_v`（特性）替换为`std::same_as`（概念），你应该知道概念的实现使用了它所取代的特性。
- en: 'Not all type traits require the use of SFINAE, but many do. These are the traits
    that check for the presence of some syntactic feature, such as the existence of
    a nested type. The implementation of these traits faces a common problem: if the
    type does not have the required feature, some code does not compile. But we don’t
    want a compilation error. We want an expression that evaluates to `false`. So
    how do we get the compiler to ignore an error? By making it occur in an SFINAE
    context, of course.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有类型特性都需要使用SFINAE，但许多确实需要。这些特性检查某些语法特征的存在，例如嵌套类型的存在。这些特性的实现面临一个共同问题：如果类型没有所需的功能，某些代码将无法编译。但我们不希望出现编译错误。我们希望表达式评估为`false`。那么我们如何让编译器忽略错误呢？当然是通过使其在SFINAE上下文中发生。
- en: 'Let’s start with an example that was getting in our way throughout the entire
    chapter: we are going to write a trait to check whether a type has the nested
    type `value_type`. We are going to use SFINAE, so we need a template function.
    This function must use the nested type in an SFINAE context. There are several
    options for that. Often, it is convenient to add a template argument that depends
    on the expression that may fail, for example:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从整个章节中一直阻碍我们的一个例子开始：我们将编写一个特性来检查一个类型是否有嵌套类型 `value_type`。我们将使用 SFINAE，因此需要一个模板函数。这个函数必须在一个
    SFINAE 上下文中使用嵌套类型。有几个选择。通常，添加一个依赖于可能失败的表达式的模板参数是很方便的，例如：
- en: '[PRE62]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Note that the second parameter has no name – we never use it. If we attempt
    to instantiate this template with any type `T` that does not have a nested `value_type`,
    for example, `f<int>()`, the substitution will fail, but this is not an error
    (SFINAE!). Of course, not having a function to call when we write `f(ptr)` is
    an error, so we must provide a fallback overload:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第二个参数没有名字——我们从未使用过它。如果我们尝试用任何没有嵌套 `value_type` 的类型 `T` 实例化这个模板，例如 `f<int>()`，替换将失败，但这不是错误（SFINAE！）。当然，当我们写
    `f(ptr)` 时没有函数可以调用是一个错误，所以我们必须提供一个后备的重载：
- en: '[PRE63]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You may find the notion of the “doubly universal” `template f(...)` function
    curious - it takes any arguments of any type, even without the template, so why
    use the template? Of course, it is so a call with an explicitly specified type,
    such as `f<int>()`, considers this function as a possible overload (remember that,
    by specifying the template parameter type, we also exclude all non-template functions
    from consideration). However, we want the priority of this overload to be as low
    as possible, so the first overload is preferred as long as it exists. That’s why
    we use `f(…)` which is the “overload of the last resort.” Alas, the overload of
    `f()` and `f(…)` is still considered ambiguous, so we need to have at least one
    argument. The type of the argument doesn’t matter as long as we can readily construct
    an object of that type:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得“双重通用”的 `template f(...)` 函数的概念很奇特——它可以接受任何类型的任何参数，甚至在没有模板的情况下，那么为什么还要使用模板呢？当然，如果一个显式指定类型的调用，例如
    `f<int>()`，会把这个函数视为一个可能的重载（记住，通过指定模板参数类型，我们也排除了所有非模板函数的考虑）。然而，我们希望这个重载的优先级尽可能低，只要存在，就优先选择第一个重载。这就是为什么我们使用
    `f(…)`，这是“最后的手段”的重载。唉，`f()` 和 `f(…)` 的重载仍然被认为是模糊的，所以我们需要至少有一个参数。只要我们能轻松地构造出该类型的对象，参数的类型就无关紧要：
- en: '[PRE64]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Now a call to `f<T>(0)` will choose the first overload if `T::value_type` is
    a valid type. Otherwise, there is only one overload to choose from, the second
    one. All we need is a way to figure out which overload would be chosen if we made
    the call, without actually making it.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果 `T::value_type` 是一个有效的类型，调用 `f<T>(0)` 将选择第一个重载。否则，只有一个重载可供选择，即第二个。我们需要的只是一个方法来确定如果进行调用，会选择哪个重载，而不必实际进行调用。
- en: 'This turns out to be pretty easy: we can use `decltype()` to check the type
    of the result of the function (prior to C++11, `sizeof()` was used instead). Now,
    all we need is to give the two overloads different return types. Any two different
    types can be used. We can then write some conditional code on these types. However,
    remember that we are writing a type trait, and the traits that check for the existence
    of something usually end up being `std::true_type` if the value exists and `std::false_type`
    if it does not. There’s no reason to overcomplicate our implementation – we can
    just return the desired type from both overloads and use it as the trait:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上非常简单：我们可以使用 `decltype()` 来检查函数的结果类型（在 C++11 之前，使用 `sizeof()`）。现在，我们只需要给这两个重载不同的返回类型。可以使用任何两种不同的类型。然后，我们可以根据这些类型编写一些条件代码。然而，记住我们正在编写一个类型特性，检查存在性的特性通常会在存在时结束为
    `std::true_type`，不存在时为 `std::false_type`。我们没有理由使我们的实现过于复杂——我们只需从两个重载中返回所需类型，并将其用作特性：
- en: '[PRE65]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Since the functions are never called but used only inside `decltype()`, we
    do not need to provide the definition of the functions, only their declarations
    (but see the next section for a more complete and nuanced explanation). To avoid
    polluting the global namespace with the test functions that the client should
    not ever have to worry about, it is customary to hide them in a namespace such
    as `detail` or `internal`. Speaking of customary, we should define the two aliases:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now we can use our trait like any standard trait, for example:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As we have seen earlier, there are several other SFINAE contexts we could have
    used to “hide” the potential error arising from using `T::value_type`. The trailing
    return type could be used but is not convenient since we already have a return
    type we need (there is a way around that, but it’s more complex than the alternatives).
    Also, if we ever need to use SFINAE with a constructor, the return type is not
    an option there.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'The other common technique is adding extra arguments to the function; the substitution
    error occurs in the argument type and the arguments must have default values so
    the caller doesn’t even know they exist. This used to be more popular in the past,
    but we are moving away from this practice: the dummy arguments can interfere with
    the overload resolution and it may be hard to come up with a reliable default
    value for such arguments.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'The one other technique that is becoming standard practice is to have the substitution
    failure occur in an optional non-type template parameter:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Here we have a non-type template parameter (a value of type `bool`) with a
    default value `true`. The substitution of type `T` in this parameter can fail
    in the same way all the earlier failures in this section occurred: if the nested
    type `T::value_type` does not exist (if it does, the logical expression `sizeof(…)
    != 0` never fails since the size of any type is non-negative). The advantage of
    this approach is that it’s easier to combine multiple expressions if we need to
    check for several failures at once, for example:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This technique is sometimes used with the failing expression in the default
    value instead of the type:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This is a bad habit to get into: while it sometimes works and may seem easier
    to write, it has a major drawback. Often, you need to declare several overloads
    with different conditions such that only one of these succeeds. You can do so
    using the earlier approach:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'But you cannot do this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Two templates that have the same parameters but different default values are
    considered duplicate declarations, even if one of the conditions `cond1` or `cond2`
    always causes a substitution failure. It is better to get into the habit of writing
    such code with the (possibly failing) condition in the type of the non-type parameter.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'To review everything we have learned about SFINAE, let’s write another trait.
    This time, we are going to check whether a type is a class:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The key difference between a class and not a class is that a class has members
    and, thus, member pointers. This time the easiest way is to declare a member function
    argument that is a member pointer (doesn’t matter what kind of member, we’re not
    going to call the function). The substitution failure occurs in the parameter
    type `T::*` if the type T does not have any members.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 类与不是类之间的关键区别在于，类有成员，因此有成员指针。这次最简单的方法是声明一个成员函数参数，该参数是成员指针（无论是什么类型的成员，我们都不会调用该函数）。如果类型T没有任何成员，则在参数类型`T::*`中发生替换失败。
- en: 'This is almost exactly how the standard trait `std::is_class` is defined except
    it also checks for unions: unions are not considered classes by `std::is_class`,
    but implementing `std::is_union` requires compiler support, not SFINAE.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎与标准特质`std::is_class`的定义完全相同，但它还检查了联合：联合不被`std::is_class`视为类，但实现`std::is_union`需要编译器支持，而不是SFINAE。
- en: 'The techniques we have learned allow us to write any trait that checks for
    a particular property of a type: whether it is a pointer, whether it has a nested
    type or a member, etc. On the other hand, the concepts make it easy to check for
    behaviors: can a type be dereferenced, can two types be compared, etc? Note that
    I said “easy” not “possible:” you can use concepts to check for very narrowly
    defined features, and you can use traits to detect behaviors, but it is not as
    straightforward.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学到的技术使我们能够编写任何检查类型特定属性的特质：它是否是一个指针，它是否有嵌套类型或成员等。另一方面，概念使得检查行为变得容易：类型是否可以被解引用，两个类型是否可以比较等？请注意，我说的是“容易”而不是“可能”：你可以使用概念来检查非常狭窄定义的特征，你可以使用特质来检测行为，但这并不直接。
- en: 'This chapter mainly targets a programmer who writes templates and template
    libraries in application code: if you write a library with the complexity and
    rigor of STL, you need to be very precise in your definitions (you also need a
    standard committee to debate and hash out those definitions to the necessary degree
    of precision). For the rest of us, the degree of formality provided by “call `f(p)`
    if `*p` compiles” is usually sufficient. In C++20, we can do this with concepts.
    If you do not use C++20 yet, you have to use one of the SFINAE techniques. Several
    such were discussed in this chapter; the community has developed many more over
    the years. However, the development of concepts had an interesting effect on these
    practices: in addition to the tools we can use directly in C++20, the standard
    offers us a way of thinking about this problem that is applicable much more broadly.
    Thus, several SFINAE techniques that somewhat resemble the concepts (for example,
    testing behaviors in a trailing `decltype()`) are becoming more popular, while
    other practices are falling out of favor. There have even been several attempts
    to implement a concept library using pre-C++20 language features. Of course, it
    is not possible to replicate concepts; in many ways, we can’t even get close.
    However, we can still benefit from the thinking that went into developing the
    concepts language even if we cannot use the language itself. Thus, we can use
    SFINAE “in the spirit” of concepts, which provides a consistent way to implement
    SFINAE-based restrictions instead of an ad hoc collection of techniques. What
    follows is one such approach to implementing concept-like restrictions without
    the use of C++20.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要面向那些在应用代码中编写模板和模板库的程序员：如果你编写了一个具有STL复杂性和严谨性的库，你需要在你的定义上非常精确（你还需要一个标准委员会来辩论并精确到必要的程度）。对于我们其他人来说，“如果`*p`可以编译，则调用`f(p)`”提供的正式程度通常足够。在C++20中，我们可以使用概念来实现这一点。如果你还没有使用C++20，你必须使用SFINAE技术之一。本章讨论了几种这样的技术；社区在多年中发展了更多。然而，概念的发展对这些实践产生了有趣的影响：除了我们可以在C++20中直接使用的工具外，标准还提供了一种思考这个问题的方法，这种方法的应用范围更广。因此，一些与概念相似的技术（例如，在尾随的`decltype()`中测试行为）变得越来越受欢迎，而其他实践则不再受欢迎。甚至有人尝试使用C++20之前的语言特性来实现一个概念库。当然，不可能复制概念；在许多方面，我们甚至无法接近。然而，即使我们不能使用该语言本身，我们仍然可以从开发概念语言所投入的思维中受益。因此，我们可以“在精神上”使用SFINAE，这提供了一种一致的方式来实现基于SFINAE的限制，而不是一个临时的技术集合。以下是一种在不使用C++20的情况下实现类似概念限制的方法。
- en: Concepts before concepts
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概念之前的技术
- en: 'Our goal is not so much to implement a full concept library here: you can find
    such libraries online, and this book is about design patterns and best practices,
    not writing specific libraries. The aim of this section is to select the few best
    SFINAE-based techniques among the multitude of available options. These techniques
    also fit the concept-based mindset, as much as possible anyway. The methods and
    tricks we have not chosen are not necessarily inferior, but this section offers
    a set of SFINAE tools and practices that is consistent, uniform, and sufficient
    for the absolute majority of an application programmer’s needs.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标并不是在这里实现一个完整的概念库：你可以在网上找到这样的库，这本书是关于设计模式和最佳实践的，而不是编写特定的库。本节的目标是从众多可用的选项中挑选出一些最佳的基于SFINAE的技术。这些技术尽可能符合基于概念的心态。我们没有选择的方法和技巧并不一定比其他方法差，但本节提供了一套SFINAE工具和实践，它是一致的、统一的，并且足以满足绝大多数应用程序开发者的需求。
- en: 'Just like with real concepts, we will need two kinds of entities: concepts
    and restrictions.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 正如与真实的概念一样，我们需要两种类型的实体：概念和限制。
- en: 'If you look at the way concepts are used, they strongly resemble constant Boolean
    variables:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看看概念的使用方式，它们强烈地类似于常量布尔变量：
- en: '[PRE74]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The `requires()` clause needs a Boolean value, it is not restricted to concepts
    (consider the expression `requires(std::is_class_v<T>)`). The concept `Range<R>`
    thus acts like a Boolean value. Perforce, we are going to use `constexpr bool`
    variables instead of concepts in our attempt to emulate their behavior. From the
    comparison of `Range<R>` with `std::is_class_v<T>` we can also deduce that a trait-like
    mechanism is probably our best bet to implement concepts: `std::is_class_v` is
    also a `constexpr bool` variable, after all.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`requires()`子句需要一个布尔值，它不仅限于概念（考虑表达式`requires(std::is_class_v<T>)`）。因此，`Range<R>`概念就像一个布尔值。不可避免地，我们将使用`constexpr
    bool`变量来代替概念以模拟它们的行为。从`Range<R>`与`std::is_class_v<T>`的比较中，我们还可以推断出，类似于特质的机制可能是实现概念的最佳选择：毕竟`std::is_class_v`也是一个`constexpr
    bool`变量。'
- en: 'From the implementations of the traits we learned in the last section, we know
    that we are going to need two overloads:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一节中我们学习的特质的实现中，我们知道我们需要两个重载：
- en: '[PRE75]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The first overload is going to be valid and preferred for any type `R` that
    satisfies the requirements of `Range` (once we figure out how to do it). The second
    overload is always available but never preferred, so it is called only if this
    is the only overload left.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个重载对于满足`Range`要求的任何类型`R`都是有效且首选的（一旦我们弄清楚如何实现）。第二个重载始终可用但不是首选的，因此只有在没有其他重载可用时才会调用。
- en: 'We can figure out which overload was called from the return types (`yes_t`
    and `no_t` are just placeholders for some types we haven’t chosen yet). But there
    is a much simpler way; all we need for our `Range` “concept” is a constant Boolean
    value, so why not let the `constexpr` function return the right value directly,
    like so:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过返回类型（`yes_t`和`no_t`只是对我们尚未选择的某些类型的占位符）来确定调用了哪个重载。但有一个更简单的方法；我们需要的只是`Range`“概念”的一个常量布尔值，所以为什么不直接让`constexpr`函数返回正确的值，如下所示：
- en: '[PRE76]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The last two statements (the variable and the fallback overload) are complete.
    “All” we need is to make it so the first overload suffers a substitution failure
    when `R` is not a range. So, what is a range for our purposes? Just like we did
    in the section *Concepts in C++20*, we are going to define a range as any type
    that has `begin()` and `end()`. Since we are testing for a specific behavior,
    which may fail to compile but should not cause an error, we should trigger this
    failure in an SFINAE context. As we have seen already, the easiest place for this
    possibly invalid code is the trailing return type:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个语句（变量和后备重载）已经完成。“所有”我们需要的只是确保当`R`不是范围时，第一个重载会因替换失败而失败。那么，在我们的目的中，什么是范围呢？就像我们在*Concepts
    in C++20*这一节中所做的那样，我们将定义范围为任何具有`begin()`和`end()`方法的类型。由于我们正在测试特定的行为，这可能会失败编译，但不应导致错误，因此我们应该在SFINAE上下文中触发这种失败。正如我们已经看到的，这种可能无效的代码的最容易放置位置是尾随返回类型：
- en: '[PRE77]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The trailing return type lets us write code that uses parameter names. All we
    need is a parameter `r` of type `R`. This is easy to do when using SFINAE in any
    template function that is meant to be called. But this function is never going
    to be called with an actual range. We could try to declare an argument of type
    `R&` and then call the function with a default-constructed range `R{}`, but this
    is not going to work because `constexpr` functions must have `constexpr` arguments
    (otherwise they can still be called but not in a constant expression, i.e. not
    at compile time), and `R{}` is not going to be a `constexpr` value for most ranges.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 后置返回类型让我们能够编写使用参数名称的代码。我们只需要一个类型为`R`的参数`r`。当使用SFINAE调用任何预期被调用的模板函数时，这很容易做到。但这个函数永远不会用实际的范围来调用。我们可以尝试声明一个类型为`R&`的参数，然后用默认构造的范围`R{}`来调用该函数，但这不会起作用，因为`constexpr`函数必须具有`constexpr`参数（否则它们仍然可以被调用，但不是在常量表达式中，即在编译时），而`R{}`对于大多数范围来说不会是一个`constexpr`值。
- en: 'We could give up on using references altogether and use pointers instead:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以完全放弃使用引用，改用指针：
- en: '[PRE78]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'While you may have expected that “concept-like” SFINAE is going to be incredibly
    complex, this is actually all you need to define a concept such as `Range`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能预计“概念类似”的SFINAE将会非常复杂，但实际上这正是你需要定义一个如`Range`这样的概念：
- en: '[PRE79]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: These two statements look exactly like their C++20 equivalents! Our “concept”
    even works in C++14 except there are no `inline` variables there so we have to
    use `static` instead.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个语句看起来与它们的C++20等价物完全一样！我们的“概念”甚至在C++14中也能工作，只是那里没有`inline`变量，所以我们必须使用`static`代替。
- en: 'Having finished with concepts for now, we also need to do something about constraints.
    Here our success is going to be much more limited. First of all, since we are
    using SFINAE, we can apply restrictions only to template function parameters (as
    we have seen, the C++20 constraints can apply even to non-template functions,
    such as member functions of class templates). Also, we are very limited in where
    we can write these constraints. The most universal way is to add a non-template
    parameter to the template and test the constraint there:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在现在完成概念之后，我们还需要对约束做一些处理。在这里，我们的成功将受到很大的限制。首先，由于我们正在使用SFINAE，我们只能对模板函数参数施加限制（正如我们所见，C++20约束甚至可以应用于非模板函数，例如类模板的成员函数）。此外，我们在哪里可以编写这些约束也非常有限。最通用的方法是将非模板参数添加到模板中并在那里测试约束：
- en: '[PRE80]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We can hide the boilerplate code in a macro:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在宏中隐藏模板代码：
- en: '[PRE81]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The variadic macro neatly solves the common problem macros have when their
    arguments are code: commas are interpreted as separators between arguments. This
    is by no means as convenient as C++20 constraints, but it’s as close as you’re
    going to get.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 可变参数宏巧妙地解决了宏在参数为代码时常见的难题：逗号被解释为参数之间的分隔符。这当然没有C++20约束那么方便，但几乎是最接近的方法了。
- en: 'Now let us come back to the concepts. What we wrote earlier works, but has
    two problems: first, there is a lot of boilerplate code there too. Second, we
    had to use pointers to introduce function parameter names we could later use to
    test the required behaviors. This limits what behaviors we can require because
    functions can pass arguments by reference and the behavior can depend on what
    type of reference is used, while we cannot form pointers to references. In fact,
    the code we just wrote won’t compile in many cases because the type of the argument
    `R` to the template function `sort()` is deduced as a reference. To use it reliably,
    we have to check the underlying type instead:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到概念上来。我们之前写的内容是有效的，但有两个问题：首先，那里也有大量的模板代码。其次，我们必须使用指针来引入我们稍后可以用来测试所需行为的函数参数名称。这限制了我们可以要求的行为，因为函数可以通过引用传递参数，行为可能依赖于所使用的引用类型，而我们无法形成引用的指针。实际上，我们刚才写的代码在许多情况下是无法编译的，因为模板函数`sort()`的参数`R`的类型被推断为引用。为了可靠地使用它，我们必须检查其底层类型：
- en: '[PRE82]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'It would be much more convenient if we could use reference arguments, but then
    we are back to the problem we already faced: how to invoke such a function? We
    can’t use a value of the corresponding type, such as `R{}` because it is not a
    constant expression. The same problem happens if we try to use `R{}` as the default
    argument value – it is still not a constant expression.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以使用引用参数，那将更加方便，但这样我们又回到了之前遇到的问题：如何调用这样的函数？我们不能使用对应类型的值，例如`R{}`，因为它不是一个常量表达式。如果我们尝试将`R{}`用作默认参数值，也会出现同样的问题——它仍然不是一个常量表达式。
- en: 'As with most problems in software engineering, this one can be solved by adding
    another level of indirection:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 就像软件工程中的大多数问题一样，这个问题可以通过添加另一个间接层来解决：
- en: '[PRE83]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Our fallback overload remains the same, but the overload that is going to be
    called if the SFINAE test succeeds now attempts to call `RangeTest(r)` in a `decltype`
    context (also, we are back to using `int` instead of a pointer as the dummy argument).
    The last problem is what to use as the default value for the argument `r`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的后备重载保持不变，但如果 SFINAE 测试成功，将要被调用的重载现在尝试在 `decltype` 上下文中调用 `RangeTest(r)`（此外，我们回到了使用
    `int` 而不是指针作为占位参数）。最后一个问题是使用什么作为参数 `r` 的默认值。
- en: 'The usual way of getting references to objects in code that is never going
    to be called is `std::declval`, so we might want to write this:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中获取永远不会被调用的对象的引用的常用方法是 `std::declval`，因此我们可能想要这样写：
- en: '[PRE84]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Unfortunately, this is not going to compile, and the error message is going
    to be something like “`std::declval` must not be used.” This is strange, we are
    not really using it (the entire function is used only inside `decltype()`) but
    let’s try to work around it. After all, there is no magic in `std::declval`, we
    just need a function that returns a reference to our object:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这不会编译，错误信息可能类似于“`std::declval` 不能使用。”这很奇怪，我们实际上并没有使用它（整个函数仅在 `decltype()`
    内部使用），但让我们尝试解决这个问题。毕竟，`std::declval` 中没有魔法，我们只需要一个返回我们对象引用的函数：
- en: '[PRE85]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'On a standard-compliant compiler, this is not going to compile either, but
    the error is going to be different, this time the compiler will say something
    like this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个符合标准的编译器上，这同样不会编译，但错误将不同，这次编译器会说出类似这样的话：
- en: '[PRE86]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'OK, we can define the function but make sure it is never called:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们可以定义这个函数，但请确保它永远不会被调用：
- en: '[PRE87]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Adding `{ abort(); }` makes all the difference – the program now compiles and
    (after you add the rest of the missing pieces) it runs without aborting. That
    is as it should be: the function `lvalue()` is used only inside `decltype`, and
    its implementation should not matter at all. I’m not going to keep you in suspense
    any longer, this is an issue with the standard itself; if you want to want to
    dive into the thorny details, you can follow *Core Issue 1581* here: [https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0859r0.html](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0859r0.html).
    For now, we will just have to keep the useless function body (it doesn’t hurt
    anything). Of course, we can define similar functions for initializing default
    rvalue arguments as well as `const` lvalue references, and contain them in some
    implementation-only namespace:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 `{ abort(); }` 会带来很大的不同——程序现在可以编译了，并且在添加了其余缺失的部分之后，它可以在不终止的情况下运行。这正是应该的：函数
    `lvalue()` 仅在 `decltype` 内部使用，其实现根本无关紧要。我不会再让你悬着了，这是一个与标准本身相关的问题；如果你想要深入了解棘手细节，可以在这里跟随
    *核心问题 1581*：[https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0859r0.html](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0859r0.html)。现在，我们只能保留这个无用的函数体（这不会伤害到任何东西）。当然，我们也可以为初始化默认的右值参数以及
    `const` 左值引用定义类似的函数，并将它们包含在某个仅用于实现的命名空间中：
- en: '[PRE88]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now we can define concepts that test behaviors for the type of reference we
    want:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以定义测试我们想要的引用类型的行为的概念：
- en: '[PRE89]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The constraints, including our `REQUIRES` macro, still work exactly the same
    way (after all, the concept itself did not change – `Range` is still a constant
    Boolean variable).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 包括我们的 `REQUIRES` 宏在内的约束仍然以完全相同的方式工作（毕竟，概念本身并没有改变——`Range` 仍然是一个常量布尔变量）。
- en: 'There is still the issue of the boilerplate; in fact, we have even more of
    it with the unwieldy default argument values. That’s the easiest to take care
    of, though, with the help of some macros:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然存在样板代码的问题；实际上，我们有了更多难以处理的默认参数值。不过，借助一些宏，这最容易处理：
- en: '[PRE90]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Of the three template functions (such as `RangeTest`), the first function is
    the equivalent of the C++20 `concept` declaration – that’s where the behaviors
    we want to require are coded. Other than these macros, it can’t really be made
    any shorter:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三个模板函数（如 `RangeTest`）中，第一个函数相当于 C++20 的 `concept` 声明——这就是我们想要要求的行为被编码的地方。除了这些宏之外，实际上无法再缩短它：
- en: '[PRE91]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Here we also defined a macro:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们也定义了一个宏：
- en: '[PRE92]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This is done not so much to shorten the code but to make it clear to the reader
    (if not the compiler) that we are defining a concept. Compare it with the C++20
    statement:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做并不是为了缩短代码，而是为了让读者（如果不是编译器）清楚地知道我们正在定义一个概念。将其与 C++20 的语句进行比较：
- en: '[PRE93]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The other two overloads (`RangeTest(int)` and `RangeTest(…)`), as well as the
    definition of the concept variable itself, can easily be made universal for any
    concept (except for the name, of course). In fact, the only declaration that varies
    from one concept to another is the first one:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 其他两个重载（`RangeTest(int)`和`RangeTest(…)`），以及概念变量的定义本身，可以很容易地使任何概念通用（当然，除了名称之外）。事实上，唯一从一个概念到另一个概念有所不同的声明是第一个：
- en: '[PRE94]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We can make it work for any concept-testing function if we use a variadic template:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用变长模板，我们可以使它适用于任何概念测试函数：
- en: '[PRE95]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Since all of our argument macros, such as `LVALUE()`, include the default value
    for each argument, the function can always be called without arguments. We have
    to be mindful of the possibility that the test function we define conflicts with
    the function `RangeTest(int)`. This does not happen here because `int` is not
    a valid range, but it could happen for other arguments. Since we control these
    common overloads and the definition of the concept variable itself, we could make
    sure that they use an argument that will not conflict with anything we could ever
    write in regular code:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们所有的参数宏，例如`LVALUE()`，都包含了每个参数的默认值，所以函数总是可以在没有参数的情况下调用。我们必须注意我们定义的测试函数可能与`RangeTest(int)`函数冲突的可能性。这里不会发生这种情况，因为`int`不是一个有效的范围，但对于其他参数可能会发生。由于我们控制这些常见的重载以及概念变量的定义本身，我们可以确保它们使用一个不会与我们在常规代码中可能编写的任何内容冲突的参数：
- en: '[PRE96]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'This code is going to be the same for all concepts, except for the names such
    as `Range` and `RangeTest`. A single macro can generate all these lines from just
    two naming arguments:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码对于所有概念都是相同的，除了像`Range`和`RangeTest`这样的名称。一个宏可以仅通过两个命名参数生成所有这些行：
- en: '[PRE97]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: We did not do so for brevity, but if you want to use these concept-like utilities
    in your code, you should hide all the implementation details in a namespace.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有这样做是为了简洁，但如果你想在代码中使用这些类似概念的工具，你应该将这些所有实现细节隐藏在一个命名空间中。
- en: 'Now we can define our range concept as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以如下定义我们的范围概念：
- en: '[PRE98]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Thanks to the variadic template, we are not limited to concepts with just one
    template parameter. Here is a concept for two types that can be added together:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了变长模板，我们不仅限于只有一个模板参数的概念。这是一个可以相加的两个类型的概念：
- en: '[PRE99]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'For comparison, this is what the C++20 version looks like:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 作为比较，这是C++20版本的样子：
- en: '[PRE100]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Of course, it is much shorter and more powerful. But the C++14 version is about
    as close as you can get (this is not the only approach but they all yield similar
    results).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，它要短得多，也强大得多。但C++14版本几乎是最接近的（这不是唯一的方法，但它们都产生类似的结果）。
- en: 'These “fake concepts” can be used to constrain templates, just like C++20 concepts:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这些“假概念”可以用来约束模板，就像C++20概念一样：
- en: '[PRE101]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'OK, not quite like the C++20 concepts – we are limited to template functions,
    and any requirement must involve at least one template parameter. So, if you want
    to restrict a non-template member function of a template class, you have to play
    the template game:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，并不完全像C++20的概念——我们限制在模板函数中，任何要求都必须至少涉及一个模板参数。所以，如果你想限制模板类的非模板成员函数，你必须玩模板游戏：
- en: '[PRE102]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'But we do get the same result in the end: a call to sort with a vector compiles
    and sort of something that is not a range does not:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们最终确实得到了相同的结果：对向量的排序调用可以编译，而对非范围对象的排序调用则不行：
- en: '[PRE103]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Unfortunately, one place where our pseudo-concepts really come up short is the
    error messages – a C++20 compiler would usually tell us which concept was not
    satisfied and why, while the template substitution error messages are not easy
    to decipher.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们的伪概念在错误信息方面确实存在不足——一个C++20编译器通常会告诉我们哪个概念没有满足以及原因，而模板替换错误信息并不容易解读。
- en: 'By the way, when you write a test to make sure that something does not compile,
    you can now use a concept (or a pseudo-concept) to do that:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，当你编写测试以确保某些内容无法编译时，你现在可以使用一个概念（或伪概念）来做这件事：
- en: '[PRE104]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The C++20 version is left as an exercise for you.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: C++20版本留给你作为练习。
- en: Before we end this chapter, let’s look at the recommendations and the best practices
    for use of SFINAE and concepts in templates.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束这一章之前，让我们看看SFINAE和概念在模板中使用时的推荐和最佳实践。
- en: Constrained templates – the best practices
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制模板——最佳实践
- en: 'We have recommended the most useful SFINAE and concept-based techniques as
    we encountered them throughout the chapter, but we had a lot of material to cover,
    so it may be helpful to concisely restate these guidelines. These guidelines are
    here mainly for a programmer who uses templates in their application code. That
    includes the foundational code such as core template libraries of the applications,
    but a programmer writing a library such as STL, written for the widest possible
    use under extremely varied conditions and documented very precisely in a formal
    standard, would find these guidelines lacking in precision and formality:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在整章中遇到了最有用的SFINAE和概念化技术，并推荐了它们，但由于要覆盖的材料很多，因此简要重申这些指南可能是有帮助的。这些指南主要针对在应用程序代码中使用模板的程序员。这包括基础代码，如应用程序的核心模板库，但编写库（如STL）的程序员，该库旨在在极端多变的情况下尽可能广泛地使用，并在正式标准中非常精确地记录，会发现这些指南在精确性和形式上有所欠缺：
- en: 'Learn the basic rules of SFINAE: in which contexts it applies (declarations)
    and in which it does not (function body).'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习SFINAE的基本规则：它在哪些上下文中适用（声明）以及在哪些上下文中不适用（函数体）。
- en: The “natural” use of SFINAE that arises from using parameter-dependent types
    in the template declarations and argument-dependent expressions in the trailing
    return type is almost always the simplest way to express constraints on the template
    parameters (but see the next guideline).
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从在模板声明中使用参数依赖类型和在尾随返回类型中使用参数依赖表达式产生的SFINAE的“自然”使用几乎总是表达模板参数约束的最简单方式（但请参见下一条指南）。
- en: Ask yourself whether you use a dependent type such as `T::value_type` because
    this is precisely the right type for the context where you use it, or is it just
    simpler than writing the real constraint on the interface (such as “any type that
    converts to `T::value_type` )? In the latter case, this chapter should have convinced
    you that such restrictions are not that hard to express.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反问自己你是否使用了依赖类型，例如`T::value_type`，因为这正是你在使用它的上下文中正确的类型，或者它只是比在接口上编写真实约束（例如“任何可以转换为`T::value_type`的类型”）更简单？在后一种情况下，这一章应该已经说服你，这样的限制并不难表达。
- en: Whenever it makes sense, make your templates more general by using additional
    template parameters and necessary constraints on them (instead of using `T::value_type`
    as an argument type, use another template parameter and constrain it to be convertible
    to `T::value_type`).
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在合理的情况下，通过使用额外的模板参数及其必要的约束来使你的模板更通用（而不是使用`T::value_type`作为参数类型，使用另一个模板参数并将其约束为可转换为`T::value_type`）。
- en: If you use C++20 and have access to concepts, avoid using “artificial” SFINAE,
    i.e. do not create substitution failures whose only purpose is to constrain the
    template. Use the `requires` clauses, with or without concepts, as needed.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用C++20并且可以访问概念，请避免使用“人工”的SFINAE，即不要创建仅用于约束模板的替换失败。根据需要使用`requires`子句，无论是否使用概念。
- en: 'If you can’t use C++20 concepts, choose a common uniform approach to SFINAE-based
    constraints and follow it. Take advantage of the concept-based approach developed
    for C++20 even if you can’t use the language tools: follow the same style and
    patterns when applying SFINAE-based techniques. The previous section presented
    one such approach.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你不能使用C++20的概念，选择一个通用的统一方法来处理基于SFINAE的约束，并遵循它。即使你不能使用语言工具，也要利用为C++20开发的概念化方法：在应用基于SFINAE的技术时，遵循相同的风格和模式。上一节介绍了一种这样的方法。
- en: 'Ideally, if a template declaration meets all specified restrictions, there
    should be no substitution errors in the body of the template (i.e. if the function
    invokes, it compiles). This is a difficult goal in practice: the restrictions
    may end up being verbose and sometimes difficult to write up, and you may not
    even be aware of all the constraints your implementation implicitly demands. Even
    STL, designed with the benefit of the committee scrutinizing every word in its
    requirements, does not fully meet this goal. Nonetheless, it is a good practice
    to aim for. Also, if you must allow a function to be invoked but not compile,
    at least have the requirements codified by static asserts in the body of the function
    – they are much easier for your users to understand than the strange substitution
    errors in types they never even heard of.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理想情况下，如果一个模板声明满足所有指定的限制，模板体中不应出现替换错误（即如果函数被调用，则可以编译）。在实践中，这是一个难以实现的目标：限制条件可能变得冗长，有时难以编写，你可能甚至没有意识到你的实现隐式地要求的所有约束。即使是设计时受益于委员会审查其要求的每个词的
    STL，也没有完全达到这个目标。尽管如此，这是一个好的实践目标。此外，如果你必须允许函数被调用但不能编译，至少在函数体中将要求编码为静态断言——它们比用户从未听说过的类型中的奇怪替换错误更容易理解。
- en: After reading this chapter, these guidelines should not be too daunting for
    you.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，这些指南对你来说不应太过令人畏惧。
- en: Summary
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: SFINAE is a somewhat esoteric feature of the C++ standard - it is complex and
    has many subtle details. While it is usually mentioned in the context of *manual
    control of the overload resolution*, its main purpose is actually not to enable
    very elaborate guru-level code but to make the regular (automatic) overload resolution
    work the way the programmer intended. In this role, it usually works exactly as
    desired and with no additional effort - in fact, the programmer usually does not
    need to even be aware of this feature. Most of the time, when you write a generic
    overload and a special overload for the pointers, you expect the latter not to
    be called for types that are not pointers. Most of the time, you probably don’t
    even pause to notice that the rejected overload would be ill-formed - who cares,
    it’s not supposed to be used. But to find out that it’s not supposed to be used,
    the type has to be substituted, which would result in an invalid code. SFINAE
    breaks this chicken-and-egg problem - to find out that the overload should be
    rejected, we have to substitute types, but that would create code that should
    not compile, which should not be a problem, because the overload should be rejected
    in the first place, but we do not know that until we substitute the types, and
    so on. This is what we call “natural” SFINAE.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: SFINAE 是 C++ 标准中的一种较为晦涩的特性——它复杂且有许多细微之处。虽然它通常在 *手动控制重载解析* 的上下文中被提及，但它的主要目的实际上并不是为了允许非常复杂的专家级代码，而是为了让常规（自动）的重载解析按照程序员期望的方式工作。在这个角色中，它通常能如预期般工作，且无需额外努力——实际上，程序员通常甚至不需要意识到这个特性。大多数时候，当你编写一个泛型重载和一个针对指针的特殊重载时，你期望后者在非指针类型上不会被调用。大多数时候，你可能甚至不会停下来注意到被拒绝的重载会是无效的——谁在乎呢，它本就不应该被使用。但为了找出它不应该被使用，必须替换类型，这会导致无效的代码。SFINAE
    打破了这种“先有鸡还是先有蛋”的问题——为了找出重载应该被拒绝，我们必须替换类型，但那样会创建不应该编译的代码，这不应该是一个问题，因为重载最初就应该被拒绝，但我们直到替换了类型才知道这一点，如此循环。这就是我们所说的“自然”SFINAE。
- en: Of course, we did not go through a few dozen pages just to learn that the compiler
    magically does the right thing and you don’t have to worry about it. The more
    elaborate use of SFINAE is to create an artificial substitution failure, and thus
    take control of the overload resolution by removing some of the overloads. In
    this chapter, we learned the *safe* contexts for these *temporary* errors that
    are eventually suppressed by SFINAE. With careful application, this technique
    can be used to inspect and differentiate, at compile time, anything from the simple
    features of different types (*is this a class?*) to complex behaviors that can
    be provided by any number of C++ language features (*is there any way to add these
    two types?*). In C++20, such code is greatly simplified by introducing constraints
    and concepts. However, we can apply concept-inspired thinking even to the code
    written for earlier standards.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will introduce another advanced template pattern that
    is used to greatly increase the power of class hierarchies in C++: class inheritance
    lets us pass information from the base class to the derived, and the Curiously
    Recurring Template Pattern does the opposite, it makes the base class aware of
    the derived.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is an overload set?
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is overload resolution?
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are type deduction and type substitution?
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is SFINAE?
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In what contexts can potentially invalid code be present and not trigger a compilation
    error, unless that code is actually needed?
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we determine which overload was chosen without actually calling it?
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is SFINAE used to control conditional compilation?
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are C++20 constraints superior to SFINAE for constraining templates?
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the C++20 concepts standard benefit the programmers using earlier language
    versions?
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Part 3: C++ Design Patterns'
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This part begins with the main portion of the book. It introduces the most
    important, frequently used C++ design patterns. Each pattern is generally used
    as a commonly accepted approach to solving a certain type of problem. Exactly
    what the problem is, varies a great deal: some are system architecture challenges,
    others are interface design problems, yet others deal with program performance.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B19262_08.xhtml#_idTextAnchor360), *The Curiously Recurring Template
    Pattern*'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B19262_09.xhtml#_idTextAnchor406), *Named Arguments, Method Chaining,
    and Builder Pattern*'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B19262_10.xhtml#_idTextAnchor453), *Local Buffer Optimization*'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B19262_11.xhtml#_idTextAnchor509), *Scopeguard*'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B19262_12.xhtml#_idTextAnchor562), *Friend Factory*'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B19262_13.xhtml#_idTextAnchor596), *Virtual Constructors and
    Factories*'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B19262_14.xhtml#_idTextAnchor640), *The Template Method Pattern
    and the Non-Virtual Idiom*'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
