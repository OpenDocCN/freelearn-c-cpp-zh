- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SFINAE, Concepts, and Overload Resolution Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idiom we study in this chapter, **Substitution Failure Is Not An Error**
    (**SFINAE**), is one of the more complex in terms of the language features it
    uses. Thus, it tends to get inordinate amounts of attention from C++ programmers.
    There is something in this feature that appeals to the mindset of a typical C++
    programmer - a normal person thinks that, if it isn’t broken, don’t mess with
    it. A programmer, especially one writing in C++, tends to think that, if it isn’t
    broken, you’re not using it to its full potential. Let’s just say that SFINAE
    has a lot of potential.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What are function overloading and overload resolution? What are type deduction
    and substitution?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is SFINAE, and why was it necessary in C++?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can SFINAE be used to write insanely complex, and sometimes useful, programs?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example code for this chapter can be found at [https://github.com/PacktPublishing/](https://github.com/PacktPublishing/)
    [Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter07](http://Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: Overload resolution and overload sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will test your knowledge of the latest and most advanced additions
    to the C++ standard. We will start with one of the most basic features of C++,
    functions, and their overloads.
  prefs: []
  type: TYPE_NORMAL
- en: C++ function overloading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`f(x)`, then there must be more than one function named `f`. If this happens,
    we are in an overload situation, and overload resolution must take place to find
    out which of these functions should be called.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have three function definitions for the same name, `f`, and three function
    calls. Note that the function signatures are all different (in that the parameter
    types are different). This is a requirement - overloaded functions must differ
    somehow in their parameters. It is not possible to have two overloads that take
    the exact same arguments but differ in the return type or the function body. Also,
    note that, while the example is for a regular function, the exact same rules apply
    to the overloaded member functions, so we will not pay special attention to member
    functions exclusively.
  prefs: []
  type: TYPE_NORMAL
- en: Back to our example, which of the `f()` functions is called on each line? To
    understand that, we need to know how overloaded functions are resolved in C++.
    The exact rules for overload resolution are fairly complex and differ in subtle
    ways between different versions of the standard, but for the most part, they are
    designed so that the compiler does what you would expect it to do in the most
    commonly encountered cases. We would expect `f(5)` to call the overload that accepts
    an integer argument since `5` is an `int` variable. And so it does. Similarly,
    `5l` has the long type, and so `f(5l)` calls the second overload. Finally, `5.0`
    is a floating-point number, and so the last overload is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'That wasn’t so hard, was it? But what happens if the argument does not match
    the parameter type exactly? Then, the compiler has to consider type conversions.
    For example, the type of the `5.0` literal is `double`. Let’s see what happens
    if we call `f()` with an argument of the `float` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now we have to convert the argument from the `float` type to one of the `int`,
    `long`, or `double` types. Again, the standard has rules, but it should come as
    no surprise that the conversion to `double` is preferred and that the overload
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what happens with a different integer type, say, `unsigned` `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have two options; convert `unsigned` `int` to a `signed` `int`, or to
    `signed` `long`. While it may be argued that the conversion to `long` is *safer*,
    and thus better, the two conversions are considered so close by the standard that
    the compiler cannot choose. This call does not compile because the overload resolution
    is considered ambiguous; the error message should say as much. If you encounter
    such a problem in your code, you have to help the compiler by casting the arguments
    to a type that makes the resolution unambiguous. Usually, the simplest way is
    to cast the type of the parameter for the overload you want to call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we have dealt with a situation where the types of parameters were different,
    but their number was the same. Of course, if the number of parameters differs
    between different function declarations for the same name, only the functions
    that can accept the required number of arguments need to be considered. Here is
    an example of two functions with the same name but a different number of arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the overload resolution is very simple - we need a function that can
    accept two arguments, and there is only one choice. Both arguments will have to
    be converted to `long`. But what if there is more than one function with the same
    number of parameters? Let’s see what happens in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: First of all, the obvious case - if the types of all arguments match exactly
    the types of the parameters for one of the overloads, that overload is called.
    Next, things start to get interesting - if there is no exact match, we can have
    conversions on each argument. Let’s consider the third call, `f(5, 5.0)`. The
    first argument, `int`, matches the first overload exactly but could be converted
    to `long` if necessary. The second argument, `double`, does not match either overload
    but could be converted to match both. The first overload is a better match - it
    requires fewer argument conversions. Finally, what about the last line? The first
    overload can be called, with a conversion on the second argument. The second overload
    can also be made to work, with a conversion on the first argument. Again, this
    is an ambiguous overload, and this line will not compile. Note that it is not,
    in general, true that the overload with the fewer conversions always wins; in
    more complex cases, it is possible to have ambiguous overloads even if one requires
    fewer conversions (the general rule is, if there is an overload that has the best
    conversion on every argument, it wins; otherwise, the call is ambiguous). To resolve
    this ambiguity, you have to change the types of some of the arguments (by casting,
    in general, or by changing the type of the numeric literal, in our case) to make
    the intended overload be the preferred one.
  prefs: []
  type: TYPE_NORMAL
- en: Note how the third overload was completely left out because it has the wrong
    number of parameters for all function calls. It’s not always that simple, though
    - functions can have default arguments, which means the number of arguments does
    not always have to match the number of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We now have three overloads. The first and the second can never be confused
    because they have a different number of parameters. The third overload, however,
    can be called with either one or two arguments; in the former case, the second
    argument is assumed to be zero. The first call is the simplest - one argument,
    where the type matches the parameter type of the first overload exactly. The second
    call reminds us of the case we have seen before - two arguments, where the first
    is an exact match to one of the overloads, but the second requires a conversion.
    The alternative overload needs conversions on both arguments, so the second function
    definition is the best match.
  prefs: []
  type: TYPE_NORMAL
- en: The third call seems straightforward enough with its two integer arguments,
    but this simplicity is deceptive - there are two overloads that accept two arguments,
    and in both overload cases, both arguments need conversions. While the conversion
    from `int` to `long` may seem better than the one from `int` to `double`, C++
    does not see it this way. This call is ambiguous. The next call, `f(5.0)`, has
    only one argument, which can be converted to `int`, the type of the parameter
    in the one-argument overload. But it is still a better match for the third overload,
    where it needs no conversion at all. Change the argument type from `double` to
    `float`, and we get the next call. The conversion to `double` is better than that
    to `int`, and utilizing the default argument is not considered a conversion and
    so does not carry any other *penalty* when overloads are compared. The last call
    is again ambiguous - both conversions to `double` and to `int` are considered
    of equal weight, thus the first and third overloads are equally good. The second
    overload offers an exact match to the first parameter; however, there is no way
    to call that overload without the second argument, so it is not even considered.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have considered only ordinary C++ functions, although everything
    we have learned applies equally to member functions as well. Now, we need to add
    template functions to the mix.
  prefs: []
  type: TYPE_NORMAL
- en: Template functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to regular functions, for which the parameter types are known, C++
    also has `template` functions. When these functions are called, the parameter
    types are deduced from the types of the arguments at the call site. The template
    functions can have the same name as non-template functions, and several template
    functions can have the same name as well, so we need to learn about overload resolution
    in the presence of templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `f` function name can refer to any of the three functions, one of which
    is a template. The best overload will be chosen from these three each time. The
    set of functions that are considered for the overload resolution of a particular
    function call is known as the `f()` matches exactly the first non-template function
    in the overload set - the argument type is `int`, and the first function is `f(int)`.
    If an exact match to a non-template function is found in the overload set, it
    is always considered the best overload.
  prefs: []
  type: TYPE_NORMAL
- en: The template function can also be instantiated with an exact match - the process
    of replacing template parameters with concrete types is known as template argument
    substitution (or type substitution), and, if `int` is substituted for the `T`
    template parameter, then we arrive at another function that exactly matches the
    call. However, a non-template function that matches exactly is considered a better
    overload. The second call is processed similarly, but it is an exact match to
    the second function in the overload set, so that is the function that will be
    called. The last call has an argument of the `double` type that can be converted
    to `int` or `long`, or substituted for `T` to make the template instantiation
    an exact match. Since there is no exactly matching non-template function, the
    template function instantiated to an exact match is the next best overload and
    is selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what happens when there are multiple template functions that can have their
    template parameters substituted to match the argument types of the call? Let’s
    find out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first call is again an exact match to the non-template function, and so
    is resolved. The second call matches the first, non-template, overload, with a
    conversion, or the second overload exactly if the right type, `long`, is substituted
    for `T`. The last overload does not match either of these calls - there is no
    substitution that would make the `T*` parameter type match either `int` or `long`.
    The last call, however, can be matched to the third overload if `int` is substituted
    for `T`. The problem is that it could also match the second overload if `int*`
    were substituted for `T`. So which template overload is chosen? The answer is
    the more specific one - the first overload, `f(T)`, can be made to match any one-argument
    function call, while the second overload, `f(T*)`, can only match calls with pointer
    arguments. The more specific, narrower overload is considered a better match and
    is selected. This is a new notion, specific to templates - instead of choosing
    better conversions (in general, *fewer* or *simpler* conversions), we select the
    overload that is *harder* to instantiate.
  prefs: []
  type: TYPE_NORMAL
- en: 'This rule seemingly breaks for null pointers: `f(NULL)` can call either the
    first or the second overload (`f(int)` or `f(T)`), and `f(nullptr)` call the second
    overload, `f(T)`. The pointer overload is never called, even though both `NULL`
    and `nullptr` are supposedly null pointers. However, this is actually the case
    of the compiler strictly following the rules. `NULL` in C++ is an integer zero,
    it’s actually a macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Depending on whether it is defined as `0` or `0L`, `f(int)` or `f(T)` with `T==long`
    are called. The constant `nullptr`, despite having “ptr” in its name, is actually
    a constant value of type `nullptr_t`. It is *convertible* to any pointer type
    but it is not of any pointer type. This is why, when dealing with functions accepting
    pointers of different types, an overload with a `nullptr_t` parameter is often
    declared.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, there is one more kind of function that can match just about any function
    call with the same name, and that is the function that takes variable arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The first of the overloads can be used for the first three function calls -
    it is an exact match for the first call, and conversions exist to make the other
    two calls fit the signature of the first overload for `f()`. The second function
    in this example can be called with any number of arguments of any type. This is
    considered the choice of last resort - a function with specific arguments that
    can be made to match the call with the right conversions is preferred. This includes
    user-defined conversions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Only if there are no conversions that allow us to avoid calling the `f(...)`
    variadic function, then it has to be called.
  prefs: []
  type: TYPE_NORMAL
- en: Now we know the order of the overload resolution - first, a non-template function
    that matches the arguments exactly is chosen. If there is no such match in the
    overload set, then a template function is chosen if its parameters can be substituted
    with concrete types in a way that gives an exact match. If there is more than
    one option for such a template function, then a more specific overload is preferred
    over the more general one. If the attempt to match a template function in this
    manner also fails, then a non-template function is called if the arguments can
    be converted to its parameter types. Finally, if everything else fails, but a
    function with the right name that takes variable arguments is available, then
    that function is called. Note that certain conversions are considered *trivial*
    and are included in the notion of the *exact* match, for example, the conversion
    from `T` to `const` `T`. At every step, if there is more than one equally good
    option, the overload is considered ambiguous and the program is ill-formed.
  prefs: []
  type: TYPE_NORMAL
- en: The process of type substitution in a template function is what determines the
    final types of the template function parameters, and how good a match they are
    to the arguments of the function call. This process can lead to somewhat unexpected
    results and must be considered in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Type substitution in template functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We must carefully differentiate between the two steps in instantiating a template
    function to match a particular call - first, the types of the template parameters
    are deduced from the argument types (a process referred to as type deduction).
    Once the types are deduced, the concrete types are substituted for all parameter
    types (this is a process called **type substitution**). The difference becomes
    more obvious when the function has multiple parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Type deduction and substitution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Type deduction and substitution are closely related, but not exactly the same.
    The deduction is the process of “*guessing:”* what should the template type, or
    types, be in order to match the call? Of course, the compiler does not really
    guess but applies a set of rules defined in the standard. Consider the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When considering the first call, we can deduce from the first argument that
    the `T` template parameter should be `int`. Thus, `int` is substituted for `T`
    in both parameters of the function. The template is instantiated as `f(int, int*)`
    and is an exact match for the argument types. When considering the second call,
    we could deduce that `T` should be `long` from the first argument. Alternatively,
    we could deduce that `T` should be `int` from the second argument. This ambiguity
    leads to the failure of the type deduction process. If this is the only overload
    available, neither option is chosen, and the program does not compile. If more
    overloads exist, they are considered in turn, including possibly the overload
    of last resort, the `f(...)` variadic function. One important detail to note here
    is that conversions are not considered when deducing template types - the deduction
    of `T` as `int` would have yielded `f(int, int*)` for the second call, which is
    a viable option for calling `f(long, int*)` with the conversion of the first argument.
    However, this option is not considered at all, and instead, type deduction fails
    as ambiguous.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ambiguous deduction can be resolved by explicitly specifying the template
    types, which removes the need for type deduction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, type deduction is not done at all: we know what `T` is from the function
    call, as it is explicitly specified. Type substitution, on the other hand, still
    has to happen - the first parameter is of the `int` type, and the second is of
    the `int*` type. The function call succeeds with a conversion on the first argument.
    We could also force deduction the other way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Again, deduction is not necessary, as we know what `T` is. Substitution proceeds
    in a straightforward way, and we end up with `f(long, long*)`. This function cannot
    be called with `int*` as the second argument since there is no valid conversion
    from `int*` to `long*`. Thus, the program does not compile. Note that, by explicitly
    specifying the types, we have also specified that `f()` must be a template function.
    The non-template overloads for `f()` are no longer considered. On the other hand,
    if there is more than one `f()` template function, then these overloads are considered
    as usual, but this time with the results of the argument deduction forced by our
    explicit specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Template functions can have default arguments, just like non-template functions,
    however, the values of these arguments are not used to deduce types (in C++11,
    template functions can have default values for their type parameters, which provides
    an alternative). Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The first call is an exact match to the `f(int,` `int)` non-template function,
    with the default value of `1` for the second argument. Note that it would have
    made no difference if we had declared the function as `f(int i, int j = 1L)`,
    with the default value as `long`. The type of the default argument does not matter
    - if it can be converted to the specified parameter type, then that’s the value
    that is used, otherwise, the program would not compile from line 1\. The second
    call is an exact match to the `f(T, T*)` template function, with `T == long` and
    the default value of `NULL` for the second argument. Again, it does not matter
    at all that the type of that value is not `long*`.
  prefs: []
  type: TYPE_NORMAL
- en: We now understand the difference between type deduction and type substitution.
    Type deduction can be ambiguous when different concrete types can be deduced from
    different arguments. If this happens, it means we have failed to deduce the argument
    types and cannot use this template function. Type substitution is never ambiguous
    - once we know what `T` is, we simply substitute that type every time we see `T`
    in the function definition. This process can also fail, but in a different way.
  prefs: []
  type: TYPE_NORMAL
- en: Substitution failure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we have deduced the template parameter types, type substitution is a purely
    mechanical process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `T` type can be deduced from the first argument as `int`.
    It can also be deduced from the second argument, also as `int`. Note that the
    return type is not used for type deduction. Since there is only one possible deduction
    for `T`, we now proceed to substitute `T` with `int` every time we see `T` in
    the function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Not all types, however, are created equal, and some allow more liberties than
    others. Consider this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When considering the first call, the compiler deduces the `T` template parameter
    as being of the `A` type, from both the first and second argument - the first
    argument is a value of the `A` type, and the second one is a reference to the
    value of the `A::t` nested type, which matches `T::t` if we stick with our original
    deduction of `T` as `A`. The second overload yields conflicting values for `T`
    from the two arguments and, therefore, cannot be used. Thus, the first overload
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: Now, look closely at the second call. The `T` type can be deduced as `int` from
    the first argument for both overloads. Substituting `int` for `T`, however, yields
    something strange in the second argument of the first overload - `int::t`. This,
    of course, would not compile - `int` is not a class and does not have any nested
    types. In fact, we could expect that the first template overload will fail to
    compile for every `T` type that is not a class, or that does not have a nested
    type called `t`. Indeed, the attempt to substitute `int` for `T` in the first
    template function fails with an invalid type for the second argument. However,
    this substitution failure does not mean that the entire program cannot compile.
    Instead, it is silently ignored, and the overload that would otherwise be ill-formed
    is removed from the overload set. The overload resolution then continues as usual.
    Of course, we could discover that none of the overloads match the function call,
    and the program will still not compile, but the error message will not mention
    anything about `int::t` being invalid; it’ll just say that there are no functions
    that can be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, it is important to differentiate between type deduction failure and
    type substitution failure. We can remove the former from consideration entirely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the deduction is unnecessary, but the substitution of `int` for `T` must
    still take place, and this substitution yields an invalid expression in the first
    overload. Again, this substitution failure drops this candidate for `f()` from
    the overload set, and the overload resolution continues (in this case, successfully)
    with the remaining candidates. Ordinarily, this would be the end of our exercise
    in overloading: the template produces code that can’t compile, so the entire program
    should not compile either. Fortunately, C++ is more forgiving in this one situation
    and has a special exception that we need to know about.'
  prefs: []
  type: TYPE_NORMAL
- en: Substitution Failure Is Not An Error
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The rule that a substitution failure arising from an expression that would
    be invalid with the specified or deduced types does not make the whole program
    invalid is known as **Substitution Failure Is Not An Error** (**SFINAE**). This
    rule is essential for using template functions in C++; without SFINAE, it would
    be impossible to write many otherwise perfectly valid programs. Consider the following
    template overload, which differentiates between regular pointers and member pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, so good - the first time, the function is called with a pointer to
    a specific variable, `a.i`, and the `T` type is deduced as `int`. The second call
    is with a pointer to a data member of the `A` class, where `T` is deduced as `A`.
    But now, let’s call `f()` with a pointer to a different type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first overload still works fine and is what we want to call. But the second
    overload isn’t just less suitable, it is altogether invalid - it would cause a
    syntax error if we tried to substitute `int` for `T`. This syntax error is observed
    by the compiler and silently ignored, together with the overload itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the SFINAE rule is not limited to invalid types, such as references
    to non-existing class members. There are many ways in which substitution can fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, the template parameter is a value, not a type. We have two template overloads
    that both take a pointer to an array of characters, and array size expressions
    are valid only for some values of `N`. Specifically, a zero-size array is invalid
    in C++. Therefore, the first overload is valid only if `N` `%` `2` is non-zero,
    that is, if `N` is odd. Similarly, the second overload is valid only if `N` is
    even. No arguments are given to the function, so we intend to use the default
    arguments. The two overloads would have been ambiguous in every way, were it not
    for the fact that, for both calls, one of the overloads fails during template
    argument substitution and is silently removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example is very condensed - in particular, the template parameter
    value deduction, the equivalent of type deduction for numeric parameters is disabled
    by the explicit specification. We can bring the deduction back and still have
    the substitution fail, or not, depending on whether an expression is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now, the compiler has to deduce the type from the first argument. For the first
    call, `f(a)`, the `A` type is easily deduced. There is no way to deduce the second
    template parameter, `N`, so the default value is used (we are now in C++11 territory).
    Having deduced both template parameters, we now proceed to the substitution, where
    `T` is replaced by `A`, and `N` is replaced by `5`. This substitution fails for
    the second overload but succeeds for the first one. With only one remaining candidate
    in the overload set, the overload resolution concludes. Similarly, the second
    call, `f(b)`, ends up calling the second overload.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that there is a subtle but very important difference between the preceding
    example and the earlier example where we had this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In this template, the substitution failure is “*natural:*” the parameter that
    may cause the failure is needed and is intended to be of a pointer to member type.
    In the previous case, the template parameter `N` is gratuitous: it is not needed
    for anything other than artificially causing substitution failures and disabling
    some overloads. Why would you ever want to cause an artificial substitution failure?
    We have seen one reason, forcing the selection of otherwise ambiguous overloads.
    The more general reason has to do with the fact that type substitution sometimes
    can lead to errors.'
  prefs: []
  type: TYPE_NORMAL
- en: When substitution failure is still an error
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Note that SFINAE does not protect us from any and all syntax errors that might
    happen during template instantiation. For example, if the template parameters
    are deduced, and the template arguments are substituted, we may still end up with
    an ill-formed template function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This code fragment is very similar to those we considered earlier, with one
    exception - we do not learn that the template overload presupposes that the `T`
    type is a class, and has a data member named `T::i`, until we examine the function
    body. By then, it is too late, as the overload resolution is done only on the
    basis of the function declaration - the parameters, the default arguments, and
    the return type (the latter is not used to deduce types or select a better overload,
    but still undergoes type substitution and is covered by SFINAE). Once the template
    is instantiated and chosen by the overload resolution, any syntax errors, such
    as an invalid expression in the body of the function, are not ignored - such a
    failure is very much an error. The exact list of contexts where a substitution
    failure is, or is not, ignored, is defined in the standard; it was significantly
    expanded in C++11, with subsequent standards making a few subtle tweaks.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another case where an attempt to use SFINAE leads to an error instead.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have a class template. If the type `T` does not have a nested type
    `value_type`, type substitution leads to an error, and this is a real error, it
    is not ignored. You can’t even instantiate this class template with a type that
    does not have `value_type`. Making the function into a template does not solve
    the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'It is very important to remember that SFINAE applies only when the error occurs
    during the substitution of the types that were deduced for the template function.
    In the last example, the substitution error does not depend on the template type
    parameter `U`, so it is always going to be an error. If you really need to work
    around this, you have to use a member function template and use a template type
    parameter to trigger the substitution error. Since we do not need an additional
    template parameter, we can default it to be the same as the class template type
    parameter `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now the substitution error, if any, will happen with a type dependent on the
    template type parameter `U::value_type`. We do not need to specify type `U` since
    it is defaulted to `T`, and it can’t be anything else because of the requirement
    that types `U` and `T` are the same (otherwise the return type of the function
    is invalid, which is a SFINAE error). Thus, our template member function `f()`
    does (almost) exactly what the original non-template function `f()` did (there
    are subtle differences if the function has overloads within the class). So, if
    you really need to “hide” a substitution error caused by a class template parameter,
    you can do so by introducing a redundant function template parameter and restricting
    the two to always be the same.
  prefs: []
  type: TYPE_NORMAL
- en: Before continuing, let’s review the three kinds of substitution failures we
    encountered.
  prefs: []
  type: TYPE_NORMAL
- en: Where and why does substitution failure happen?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand the rest of this chapter, it is essential that we clearly differentiate
    between several kinds of substitution failures that can occur in template functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first kind happens when the template declaration uses dependent types or
    other constructs that can cause a failure, and their use is necessary to declare
    the template properly. Here is a template function that is intended to be called
    with a container argument (all STL containers have a nested type `value_type`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to call this function with an argument that does not define the nested
    type, `value_type`, the function call will not compile (assuming we have no other
    overloads). There are many more examples where we naturally use dependent types
    and other expressions that may be invalid for some values of template parameters.
    Such invalid expressions cause a substitution failure. It does not have to happen
    in the argument declaration. Here is a template whose return type may be undefined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In this template, the return type is the common type of the two template parameter
    types. But what if the template arguments are such that the types `U` and `V`
    have no common type? Then the type expression `std::common_type_t<U, V>` is invalid
    and the type substitution fails. Here is yet another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, again, the substitution failure may occur in the return type, but we
    use the trailing return type so that we can directly check whether the expression
    `*p` compiles (or, more formally, is valid). If it is, the type of the result
    is the return type. Otherwise, the substitution fails. Note that there is a difference
    between this declaration and something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If the function argument is a raw pointer, both versions amount to the same
    thing. But the first variant also compiles for any type that can be dereferenced,
    such as container iterators and smart pointers, while the second version works
    only for raw pointers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second kind of substitution failure happens when the function declaration
    compiles successfully, including the type substitution, and then we get a syntax
    error in the function body. We can easily modify each of these examples to see
    how this might have happened. Let’s start with the `find()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This time, we decided to accept a value of any type. This is not necessarily
    wrong in itself, but the body of our template function is written in the assumption
    that the container type `T` has the nested type `value_type` and that this type
    is comparable with the type `V`. If we call the function with a wrong argument,
    the call will still compile because nothing particular is required of the argument
    types by the substitution that happens in the declaration of the template. But
    then we get a syntax error in the body of the template itself, rather than at
    the call site.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how a similar thing can happen with the `compute()` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This template function can be called for any two arguments, but then it won’t
    compile unless there is a common type for both.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the very significant difference between the two kinds of substitution
    failures: if the failure happens in SFINAE context, the function is removed from
    the overload resolution as if it does not exist. If there is another overload
    (a function with the same name), it will be considered and may end up being called.
    If there is not, we will get a syntax error at the call site that boils down to
    “there is no such function.” On the other hand, if the failure happens in the
    body of the template (or in some other place not covered by SFINAE rules) then,
    assuming the function is the best, or the only, overload, it will be called. The
    client’s code – the call itself – will compile fine, but the template will not.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several reasons why the first option is preferable. First of all,
    the caller may have wanted to call a different overload, the one that would have
    compiled fine, but the rules for overload resolution among templates are complex
    and the wrong overload was chosen. It may be very difficult for the caller to
    fix this error and force the choice of the intended overload. Second, the error
    messages you get when the body of the template fails compilation are often incomprehensible.
    Our examples were simple, but in a more realistic case, you may see an error that
    involves some internal types and objects that you know nothing about. The last
    reason is more of a conceptual statement: the interface of the template function,
    like any other interface, should describe the requirements on the caller as completely
    as possible. An interface is a contract; if the caller has complied with it, the
    implementer of the function must deliver as promised.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume that we have a template function whose body has some requirements
    on the type parameters and that these requirements are not captured by the interface
    written in a natural, straightforward way (the type substitution succeeds but
    the template does not compile). The only way to convert the hard substitution
    failure into an SFINAE failure is to make it happen in SFINAE context. To do this,
    we need to add something to the interface that is not necessary to declare the
    function. The only purpose of this addition is to trigger a substitution failure
    and remove the function from the overload resolution set before it could lead
    to a compilation error in the body of the function. Such “artificial” failure
    is the third kind of substitution failure. Here is an example where we enforce
    the requirement that the types are pointers even though the interface itself would
    be just fine without it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes two pointers (or any other pointer-like objects that can
    be dereferenced) and returns the Boolean result of comparing the values they point
    to. In order for the body of the function to compile, both arguments must be something
    that can be dereferenced. Furthermore, the results of dereferencing them must
    be comparable for equality. Finally, the result of the comparison must be convertible
    to bool. The trailing return type declaration is unnecessary: we could have just
    declared the function to return `bool`. But it does have an effect: it moves a
    possible substitution failure from the body of the function to its declaration,
    where it becomes an SFINAE failure. The return type is always `bool` unless the
    expression inside `decltype()` is invalid. That could happen for any of the same
    reasons the function body would not compile: one of the arguments cannot be dereferenced,
    the values are not comparable, or the result of the comparison is not convertible
    to `bool` (the latter is usually redundant, but we might as well enforce the entire
    contract).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the line between the “natural” and “artificial” substitution failures
    is not always clear. For example, one could have argued that using `std::common_type_t<U,
    V>` as the return type earlier was artificial (the third kind of substitution
    failure, not the first kind) and that the “natural” way would be to declare the
    return type as `auto` and let the function body fail if the common type could
    not be deduced. Indeed, the difference often boils down to the programmer’s style
    and intent: if it wasn’t for the need to enforce the type restriction, would the
    programmer have written the type expression in the template declaration anyway?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The failures of the first kind are straightforward: the template interface
    itself forms a contract, the attempted call violated the contract, and the function
    wasn’t called. The failures of the second kind are, ideally, to be avoided altogether.
    But to do that, we have to employ the failures of the third kind, the artificial
    substitution failures in SFINAE context. The rest of this chapter deals with the
    ways to code such interface-limiting template contracts. Since the first days
    of C++, SFINAE techniques were used to artificially cause a substitution failure
    that would remove such functions from the overload set. C++20 added a totally
    different mechanism for solving this problem: concepts. Before we discuss controlling
    overload resolution with SFINAE, we need to learn more about this latest addition
    to the language.'
  prefs: []
  type: TYPE_NORMAL
- en: Concepts and constraints in C++20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The rest of this chapter is all about the “artificial” substitution failures
    that are added to the template declaration to impose restrictions on the template
    arguments. In this section, we are going to learn about the new, C++20, way of
    coding these restrictions. In the next section, we will show what you can do if
    you can’t use C++20 but still want to constrain your templates.
  prefs: []
  type: TYPE_NORMAL
- en: Constraints in C++20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++20 changed the way we are using SFINAE to restrict template arguments by
    introducing concepts and constraints. Even though the overall feature is usually
    referred to as “concepts,” it is the constraints that are the most important part.
    What follows is not a complete or formal description of these features, but rather
    a demonstration of the best practices (it may be too early to say “patterns” since
    the community is still in the process of establishing what is and isn’t sufficiently
    widely accepted).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first way to specify a constraint is by writing a `requires` clause that
    has the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The keyword `requires` and the constant (compile-time) expression in parentheses
    must appear either immediately after the template parameters or as the last element
    of the function declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Just like in the last section, the constraint written at the end of the declaration
    can refer to the function arguments by name, while the constraint written after
    the parameter list can refer only to the template parameters (other, more subtle
    differences between the two syntaxes are outside of the scope of this chapter).
    Unlike the last section, if a constraint fails, the compiler usually issues a
    clear diagnostic instead of simply reporting that “no function f was found” and
    template deduction failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'What can be used in the constant expression in a `requires` clause? Anything
    that can be computed at compile time, really, as long as the overall result is
    a `bool`. Type traits such as `std::is_convertible_v` or `std::is_default_constructible_v`
    are often used to restrict types. If the expressions are complex, `constexpr`
    functions can help to simplify them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'But there is one special expression that we have not seen before – the `requires`
    expression. This expression can be used to check if some arbitrary expression
    compiles (technically, it “is valid”):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming the values `a` and `b` are defined in the context where the expression
    is used, this expression evaluates to `true` if the expression `a + b` is valid.
    What if we know the types we want to test but don’t have the variables? Then we
    can use the second form of the `requires` expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The types `A` and `B` usually refer to the template parameters or some dependent
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we said “arbitrary expression is valid” and not “arbitrary code is
    valid.” This is an important difference. For example, you can’t write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'And require that the type `C` meets all requirements for a range-for loop.
    Most of the time, you test expressions such as `cont.begin()` and `cont.end()`
    instead. However, you can also come up with a more complex requirement by hiding
    the code in a lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Woe is you if such code ever fails and you have to figure out the error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a `requires` expression is used in a template constraint, the template
    is restricted not by a specific trait but by the required behavior of the types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'First of all, yes, there are two keywords `requires` (by the way, parentheses
    are optional in this case and you can find this constraint written as `requires
    requires` ). The first `requires` introduces a constraint, a `requires` clause.
    The second `requires` begins the `requires` expression. The expression in the
    first function `f()` is valid if the second template argument `p` can be dereferenced
    (it can be a pointer, but it doesn’t have to be) and the result can be assigned
    to the first argument `i`. We don’t require that the types on both sides of the
    assignment be the same or even that `*p` can be convertible to `T` (usually it
    would be, but it’s not required). We just need the expression `i = *p` to compile.
    Finally, if we did not have the right variables readily available, we could have
    declared them as parameters to the `requires` expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'These two examples also demonstrate that we can do SFINAE overload control
    with constraints: if a constraint fails, the template function is removed from
    the overload resolution set and the resolution continues.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have seen already, sometimes we need to check not an expression but a
    dependent type; we can do that inside the `requires` expression as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'A requires expression evaluates to bool, so it can be used in a logical expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We could combine multiple requires expressions this way, but we can also write
    more code inside a single expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Here we require that the type `T` has a nested type `value_type` and an index
    operator that accepts integer indices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, sometimes we need to check not just that some expression compiles
    but that its result has a certain type (or satisfies some type requirements).
    This can be done with the compound form of the `requires` expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Here we require that the expression `t + 1` compiles and yields the result of
    the same type as the variable `t` itself. The last part is done using a concept;
    you will read about them in the next section, but for now, think of it as an alternative
    way to write the `std::is_same_v` type trait.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of concepts… Everything we have described so far can be found under
    the heading of “concepts” in any C++20 book, except we have not mentioned the
    concepts themselves. That is about to change.
  prefs: []
  type: TYPE_NORMAL
- en: Concepts in C++20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Concepts are simply a named set of requirements – the same requirements we were
    just learning about. In a way, they are similar to `constexpr` functions, except
    they operate on types, not values.
  prefs: []
  type: TYPE_NORMAL
- en: 'You use a concept when there is a set of requirements that you refer to often,
    or one that you want to give a meaningful name to. For example, a range is defined
    by a very simple requirement: it must have a begin iterator and an end iterator.
    We can write a simple requires expression every time we declare a function template
    that accepts a range argument, but it is both more convenient and more readable
    to give this requirement a name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We have just introduced a concept named `Range` with one template type parameter
    `R`; this type must have begin and end iterators (the reason we use `std::begin()`
    instead of the member function `begin()` is that C arrays are also ranges but
    they have no member functions).
  prefs: []
  type: TYPE_NORMAL
- en: Note that C++20 has a ranges library and a corresponding set of concepts (including
    `std::ranges::range` that should be used instead of our homemade `Range` in any
    real code) but the idea of ranges makes for convenient teaching material and we
    will use it to drive the examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have a named concept, we can use it instead of spelling out the requirements
    in any template constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the concept can be used inside a `requires` clause as if it
    was a `constexpr` variable of type `bool`. Indeed, a concept can also be used
    in contexts such as static assert:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'For simple template declarations where the concept is the whole requirement,
    the language provides a much simpler way to state it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In other words, the concept name can be used instead of the `typename` keyword
    in a template declaration. Doing so automatically restricts the corresponding
    type parameter to types that satisfy the concept. If necessary, a `requires` clause
    can still be used to define additional constraints. Finally, the concepts can
    also be used with the new C++20 template syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: All three declarations have the same effect and the choice is largely a matter
    of style and convenience.
  prefs: []
  type: TYPE_NORMAL
- en: Concepts and type restrictions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already seen how concepts and constraints are used to impose restrictions
    on the parameters of function templates. The `requires` clauses can appear after
    the template parameters or at the end of the function declaration; both places
    are SFINAE contexts and a substitution failure in either location does not stop
    the compilation of the entire program. In this regard, concepts are not fundamentally
    different from substitution failures: while you can use a constraint outside of
    an SFINAE context, a substitution failure would still be an error. For example,
    you cannot assert that a type does not have a nested type `value_type` by using
    a constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: You may expect that the `requires` expression evaluates to false if the requirement
    is not met, but in this case, it simply does not compile (you get the error that
    `T::value_type` does not refer to a valid type).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are restrictions you can enforce with concepts that were impossible
    to implement before. These are requirements for class templates. In the simplest
    form, we can use a concept to restrict class template type parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This class template can only be instantiated with types that satisfy the concept
    `Range`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can constrain individual member functions, whether they are templates
    or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Now the class template itself can be instantiated on any type. However, its
    interface includes a member function `sort()` only if the type satisfies the `Range`
    constraint.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a very important difference between constraints and the old SFINAE:
    the artificial substitution failure helps only if it happens when substituting
    deduced type parameters in function templates. Earlier in this chapter, we had
    to add a dummy template type parameter to a member function just so we could create
    an SFINAE failure. With concepts, there is no need for any of that.'
  prefs: []
  type: TYPE_NORMAL
- en: Concepts and constraints are the best way to specify restrictions on template
    parameters. They make a lot of the SFINAE tricks invented over the years obsolete.
    But not everyone has access to C++20 yet. Also, some of the SFINAE techniques
    are still used even with concepts. In the last section, we will learn about these
    techniques as well as see what can be done if you do not have C++20 but still
    want to constraint template types.
  prefs: []
  type: TYPE_NORMAL
- en: SFINAE techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The rule that a failure of the template argument substitution is not an error
    - the SFINAE rule - had to be added to the language simply to make certain narrowly
    defined template functions possible. But the ingenuity of a C++ programmer knows
    no bounds, and so SFINAE was repurposed and exploited to manually control the
    overload set by intentionally causing substitution failures. A huge variety of
    SFINAE-based techniques were invented over the years until the C++20 concepts
    made most of them obsolete.
  prefs: []
  type: TYPE_NORMAL
- en: Still, some use of SFINAE remains even in C++20, and then there is the vast
    body of pre-C++20 code that you may need to read, understand, and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the applications of SFINAE that are still useful even when
    concepts are available.
  prefs: []
  type: TYPE_NORMAL
- en: SFINAE in C++20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, even in C++20, there are still “natural” type substitution failures.
    For example, you may want to write this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This is still fine, assuming you really want to return a value of the type
    given by the nested `value_type`. However, before you rush to answer “yes” you
    should examine closely what is the type you really want to return. What is the
    contract with the caller that you want to enforce? Maybe the existence of `value_type`
    was used as a proxy for the real requirements, such as the type T has the index
    operator or can be used as a range to iterate over. In this case, you can now
    state the requirements directly, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This says that what you really need is a type with member functions `begin()`
    and `end()`. The values returned by these functions (presumably, the iterators)
    are dereferenced and compared; if these operations are supported, the return values
    are close enough to iterators for our purposes. Finally, in the preceding example,
    we let the compiler determine the return type. This is often convenient, but the
    downside is that the interface – our contract – does not say what the return type
    is; the client of our code must read the implementation. Assuming we return a
    value we get by dereferencing an iterator, we can be explicit about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very comprehensive contract with the client, assuming, of course,
    that we as implementers guarantee that the body of the function will compile if
    the stated requirements are met. Otherwise, the contract is incomplete: for example,
    if we do use `T::value_type` in the body of the function, we should add `typename
    T::value_type` to the list of requirements, whether or not this is the type we
    eventually return (if it is, we could still use SFINAE for the return type, nothing
    wrong with that).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar considerations exist when a dependent type is used to declare a template
    function argument, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we should ask ourselves if these really are the requirements we want
    to impose. Assuming the function is looking for the value `x` in the container
    `t`, do we really care what the type of `x` is as long as it can be compared with
    the values stored in the container? Consider this alternative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Now we require that the container has everything needed for a range-for loop
    and that the values stored in the container can be compared with `x` for equality.
    Assuming that all we do is iterate over the container and return true if a value
    equal to `x` is found, this is all we need to require from the caller.
  prefs: []
  type: TYPE_NORMAL
- en: You should not infer that the “natural” SFINAE should no longer be used in C++20
    and be replaced by independent template parameters bound together by constraints.
    All we suggest is that you examine your code to determine whether the contract
    expressed by the interface and enforced through SFINAE is really what you want,
    or merely what was convenient to code. In the latter case, concepts offer a way
    to express what you really wanted to require but could not (but do read on, because
    there are concept-inspired techniques that can be used before C++20 and meet the
    same need). On the other hand, if the template function is best written in a way
    that triggers a substitution failure when the client supplies an invalid argument,
    then, by all means, continue to use SFINAE – there is no need to rewrite everything
    to use concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Even the “artificial” SFINAE still has uses in C++20, as we are about to see.
  prefs: []
  type: TYPE_NORMAL
- en: SFINAE and type traits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most important application of “artificial” SFINAE in C++20 is writing type
    traits. Type traits are not going anywhere: even if you replace `std::is_same_v`
    (trait) with `std::same_as` (concept) in your code, you should know that the concept’s
    implementation uses the very trait it replaces.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Not all type traits require the use of SFINAE, but many do. These are the traits
    that check for the presence of some syntactic feature, such as the existence of
    a nested type. The implementation of these traits faces a common problem: if the
    type does not have the required feature, some code does not compile. But we don’t
    want a compilation error. We want an expression that evaluates to `false`. So
    how do we get the compiler to ignore an error? By making it occur in an SFINAE
    context, of course.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with an example that was getting in our way throughout the entire
    chapter: we are going to write a trait to check whether a type has the nested
    type `value_type`. We are going to use SFINAE, so we need a template function.
    This function must use the nested type in an SFINAE context. There are several
    options for that. Often, it is convenient to add a template argument that depends
    on the expression that may fail, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the second parameter has no name – we never use it. If we attempt
    to instantiate this template with any type `T` that does not have a nested `value_type`,
    for example, `f<int>()`, the substitution will fail, but this is not an error
    (SFINAE!). Of course, not having a function to call when we write `f(ptr)` is
    an error, so we must provide a fallback overload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You may find the notion of the “doubly universal” `template f(...)` function
    curious - it takes any arguments of any type, even without the template, so why
    use the template? Of course, it is so a call with an explicitly specified type,
    such as `f<int>()`, considers this function as a possible overload (remember that,
    by specifying the template parameter type, we also exclude all non-template functions
    from consideration). However, we want the priority of this overload to be as low
    as possible, so the first overload is preferred as long as it exists. That’s why
    we use `f(…)` which is the “overload of the last resort.” Alas, the overload of
    `f()` and `f(…)` is still considered ambiguous, so we need to have at least one
    argument. The type of the argument doesn’t matter as long as we can readily construct
    an object of that type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Now a call to `f<T>(0)` will choose the first overload if `T::value_type` is
    a valid type. Otherwise, there is only one overload to choose from, the second
    one. All we need is a way to figure out which overload would be chosen if we made
    the call, without actually making it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This turns out to be pretty easy: we can use `decltype()` to check the type
    of the result of the function (prior to C++11, `sizeof()` was used instead). Now,
    all we need is to give the two overloads different return types. Any two different
    types can be used. We can then write some conditional code on these types. However,
    remember that we are writing a type trait, and the traits that check for the existence
    of something usually end up being `std::true_type` if the value exists and `std::false_type`
    if it does not. There’s no reason to overcomplicate our implementation – we can
    just return the desired type from both overloads and use it as the trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the functions are never called but used only inside `decltype()`, we
    do not need to provide the definition of the functions, only their declarations
    (but see the next section for a more complete and nuanced explanation). To avoid
    polluting the global namespace with the test functions that the client should
    not ever have to worry about, it is customary to hide them in a namespace such
    as `detail` or `internal`. Speaking of customary, we should define the two aliases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use our trait like any standard trait, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: As we have seen earlier, there are several other SFINAE contexts we could have
    used to “hide” the potential error arising from using `T::value_type`. The trailing
    return type could be used but is not convenient since we already have a return
    type we need (there is a way around that, but it’s more complex than the alternatives).
    Also, if we ever need to use SFINAE with a constructor, the return type is not
    an option there.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other common technique is adding extra arguments to the function; the substitution
    error occurs in the argument type and the arguments must have default values so
    the caller doesn’t even know they exist. This used to be more popular in the past,
    but we are moving away from this practice: the dummy arguments can interfere with
    the overload resolution and it may be hard to come up with a reliable default
    value for such arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The one other technique that is becoming standard practice is to have the substitution
    failure occur in an optional non-type template parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have a non-type template parameter (a value of type `bool`) with a
    default value `true`. The substitution of type `T` in this parameter can fail
    in the same way all the earlier failures in this section occurred: if the nested
    type `T::value_type` does not exist (if it does, the logical expression `sizeof(…)
    != 0` never fails since the size of any type is non-negative). The advantage of
    this approach is that it’s easier to combine multiple expressions if we need to
    check for several failures at once, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'This technique is sometimes used with the failing expression in the default
    value instead of the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a bad habit to get into: while it sometimes works and may seem easier
    to write, it has a major drawback. Often, you need to declare several overloads
    with different conditions such that only one of these succeeds. You can do so
    using the earlier approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'But you cannot do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Two templates that have the same parameters but different default values are
    considered duplicate declarations, even if one of the conditions `cond1` or `cond2`
    always causes a substitution failure. It is better to get into the habit of writing
    such code with the (possibly failing) condition in the type of the non-type parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To review everything we have learned about SFINAE, let’s write another trait.
    This time, we are going to check whether a type is a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The key difference between a class and not a class is that a class has members
    and, thus, member pointers. This time the easiest way is to declare a member function
    argument that is a member pointer (doesn’t matter what kind of member, we’re not
    going to call the function). The substitution failure occurs in the parameter
    type `T::*` if the type T does not have any members.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is almost exactly how the standard trait `std::is_class` is defined except
    it also checks for unions: unions are not considered classes by `std::is_class`,
    but implementing `std::is_union` requires compiler support, not SFINAE.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The techniques we have learned allow us to write any trait that checks for
    a particular property of a type: whether it is a pointer, whether it has a nested
    type or a member, etc. On the other hand, the concepts make it easy to check for
    behaviors: can a type be dereferenced, can two types be compared, etc? Note that
    I said “easy” not “possible:” you can use concepts to check for very narrowly
    defined features, and you can use traits to detect behaviors, but it is not as
    straightforward.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter mainly targets a programmer who writes templates and template
    libraries in application code: if you write a library with the complexity and
    rigor of STL, you need to be very precise in your definitions (you also need a
    standard committee to debate and hash out those definitions to the necessary degree
    of precision). For the rest of us, the degree of formality provided by “call `f(p)`
    if `*p` compiles” is usually sufficient. In C++20, we can do this with concepts.
    If you do not use C++20 yet, you have to use one of the SFINAE techniques. Several
    such were discussed in this chapter; the community has developed many more over
    the years. However, the development of concepts had an interesting effect on these
    practices: in addition to the tools we can use directly in C++20, the standard
    offers us a way of thinking about this problem that is applicable much more broadly.
    Thus, several SFINAE techniques that somewhat resemble the concepts (for example,
    testing behaviors in a trailing `decltype()`) are becoming more popular, while
    other practices are falling out of favor. There have even been several attempts
    to implement a concept library using pre-C++20 language features. Of course, it
    is not possible to replicate concepts; in many ways, we can’t even get close.
    However, we can still benefit from the thinking that went into developing the
    concepts language even if we cannot use the language itself. Thus, we can use
    SFINAE “in the spirit” of concepts, which provides a consistent way to implement
    SFINAE-based restrictions instead of an ad hoc collection of techniques. What
    follows is one such approach to implementing concept-like restrictions without
    the use of C++20.'
  prefs: []
  type: TYPE_NORMAL
- en: Concepts before concepts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our goal is not so much to implement a full concept library here: you can find
    such libraries online, and this book is about design patterns and best practices,
    not writing specific libraries. The aim of this section is to select the few best
    SFINAE-based techniques among the multitude of available options. These techniques
    also fit the concept-based mindset, as much as possible anyway. The methods and
    tricks we have not chosen are not necessarily inferior, but this section offers
    a set of SFINAE tools and practices that is consistent, uniform, and sufficient
    for the absolute majority of an application programmer’s needs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like with real concepts, we will need two kinds of entities: concepts
    and restrictions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the way concepts are used, they strongly resemble constant Boolean
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The `requires()` clause needs a Boolean value, it is not restricted to concepts
    (consider the expression `requires(std::is_class_v<T>)`). The concept `Range<R>`
    thus acts like a Boolean value. Perforce, we are going to use `constexpr bool`
    variables instead of concepts in our attempt to emulate their behavior. From the
    comparison of `Range<R>` with `std::is_class_v<T>` we can also deduce that a trait-like
    mechanism is probably our best bet to implement concepts: `std::is_class_v` is
    also a `constexpr bool` variable, after all.'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the implementations of the traits we learned in the last section, we know
    that we are going to need two overloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The first overload is going to be valid and preferred for any type `R` that
    satisfies the requirements of `Range` (once we figure out how to do it). The second
    overload is always available but never preferred, so it is called only if this
    is the only overload left.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can figure out which overload was called from the return types (`yes_t`
    and `no_t` are just placeholders for some types we haven’t chosen yet). But there
    is a much simpler way; all we need for our `Range` “concept” is a constant Boolean
    value, so why not let the `constexpr` function return the right value directly,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The last two statements (the variable and the fallback overload) are complete.
    “All” we need is to make it so the first overload suffers a substitution failure
    when `R` is not a range. So, what is a range for our purposes? Just like we did
    in the section *Concepts in C++20*, we are going to define a range as any type
    that has `begin()` and `end()`. Since we are testing for a specific behavior,
    which may fail to compile but should not cause an error, we should trigger this
    failure in an SFINAE context. As we have seen already, the easiest place for this
    possibly invalid code is the trailing return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The trailing return type lets us write code that uses parameter names. All we
    need is a parameter `r` of type `R`. This is easy to do when using SFINAE in any
    template function that is meant to be called. But this function is never going
    to be called with an actual range. We could try to declare an argument of type
    `R&` and then call the function with a default-constructed range `R{}`, but this
    is not going to work because `constexpr` functions must have `constexpr` arguments
    (otherwise they can still be called but not in a constant expression, i.e. not
    at compile time), and `R{}` is not going to be a `constexpr` value for most ranges.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could give up on using references altogether and use pointers instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'While you may have expected that “concept-like” SFINAE is going to be incredibly
    complex, this is actually all you need to define a concept such as `Range`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: These two statements look exactly like their C++20 equivalents! Our “concept”
    even works in C++14 except there are no `inline` variables there so we have to
    use `static` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having finished with concepts for now, we also need to do something about constraints.
    Here our success is going to be much more limited. First of all, since we are
    using SFINAE, we can apply restrictions only to template function parameters (as
    we have seen, the C++20 constraints can apply even to non-template functions,
    such as member functions of class templates). Also, we are very limited in where
    we can write these constraints. The most universal way is to add a non-template
    parameter to the template and test the constraint there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'We can hide the boilerplate code in a macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The variadic macro neatly solves the common problem macros have when their
    arguments are code: commas are interpreted as separators between arguments. This
    is by no means as convenient as C++20 constraints, but it’s as close as you’re
    going to get.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us come back to the concepts. What we wrote earlier works, but has
    two problems: first, there is a lot of boilerplate code there too. Second, we
    had to use pointers to introduce function parameter names we could later use to
    test the required behaviors. This limits what behaviors we can require because
    functions can pass arguments by reference and the behavior can depend on what
    type of reference is used, while we cannot form pointers to references. In fact,
    the code we just wrote won’t compile in many cases because the type of the argument
    `R` to the template function `sort()` is deduced as a reference. To use it reliably,
    we have to check the underlying type instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'It would be much more convenient if we could use reference arguments, but then
    we are back to the problem we already faced: how to invoke such a function? We
    can’t use a value of the corresponding type, such as `R{}` because it is not a
    constant expression. The same problem happens if we try to use `R{}` as the default
    argument value – it is still not a constant expression.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As with most problems in software engineering, this one can be solved by adding
    another level of indirection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Our fallback overload remains the same, but the overload that is going to be
    called if the SFINAE test succeeds now attempts to call `RangeTest(r)` in a `decltype`
    context (also, we are back to using `int` instead of a pointer as the dummy argument).
    The last problem is what to use as the default value for the argument `r`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The usual way of getting references to objects in code that is never going
    to be called is `std::declval`, so we might want to write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, this is not going to compile, and the error message is going
    to be something like “`std::declval` must not be used.” This is strange, we are
    not really using it (the entire function is used only inside `decltype()`) but
    let’s try to work around it. After all, there is no magic in `std::declval`, we
    just need a function that returns a reference to our object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'On a standard-compliant compiler, this is not going to compile either, but
    the error is going to be different, this time the compiler will say something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, we can define the function but make sure it is never called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding `{ abort(); }` makes all the difference – the program now compiles and
    (after you add the rest of the missing pieces) it runs without aborting. That
    is as it should be: the function `lvalue()` is used only inside `decltype`, and
    its implementation should not matter at all. I’m not going to keep you in suspense
    any longer, this is an issue with the standard itself; if you want to want to
    dive into the thorny details, you can follow *Core Issue 1581* here: [https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0859r0.html](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0859r0.html).
    For now, we will just have to keep the useless function body (it doesn’t hurt
    anything). Of course, we can define similar functions for initializing default
    rvalue arguments as well as `const` lvalue references, and contain them in some
    implementation-only namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can define concepts that test behaviors for the type of reference we
    want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: The constraints, including our `REQUIRES` macro, still work exactly the same
    way (after all, the concept itself did not change – `Range` is still a constant
    Boolean variable).
  prefs: []
  type: TYPE_NORMAL
- en: 'There is still the issue of the boilerplate; in fact, we have even more of
    it with the unwieldy default argument values. That’s the easiest to take care
    of, though, with the help of some macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Of the three template functions (such as `RangeTest`), the first function is
    the equivalent of the C++20 `concept` declaration – that’s where the behaviors
    we want to require are coded. Other than these macros, it can’t really be made
    any shorter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we also defined a macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'This is done not so much to shorten the code but to make it clear to the reader
    (if not the compiler) that we are defining a concept. Compare it with the C++20
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The other two overloads (`RangeTest(int)` and `RangeTest(…)`), as well as the
    definition of the concept variable itself, can easily be made universal for any
    concept (except for the name, of course). In fact, the only declaration that varies
    from one concept to another is the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make it work for any concept-testing function if we use a variadic template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Since all of our argument macros, such as `LVALUE()`, include the default value
    for each argument, the function can always be called without arguments. We have
    to be mindful of the possibility that the test function we define conflicts with
    the function `RangeTest(int)`. This does not happen here because `int` is not
    a valid range, but it could happen for other arguments. Since we control these
    common overloads and the definition of the concept variable itself, we could make
    sure that they use an argument that will not conflict with anything we could ever
    write in regular code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is going to be the same for all concepts, except for the names such
    as `Range` and `RangeTest`. A single macro can generate all these lines from just
    two naming arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: We did not do so for brevity, but if you want to use these concept-like utilities
    in your code, you should hide all the implementation details in a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can define our range concept as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Thanks to the variadic template, we are not limited to concepts with just one
    template parameter. Here is a concept for two types that can be added together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'For comparison, this is what the C++20 version looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Of course, it is much shorter and more powerful. But the C++14 version is about
    as close as you can get (this is not the only approach but they all yield similar
    results).
  prefs: []
  type: TYPE_NORMAL
- en: 'These “fake concepts” can be used to constrain templates, just like C++20 concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, not quite like the C++20 concepts – we are limited to template functions,
    and any requirement must involve at least one template parameter. So, if you want
    to restrict a non-template member function of a template class, you have to play
    the template game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'But we do get the same result in the end: a call to sort with a vector compiles
    and sort of something that is not a range does not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, one place where our pseudo-concepts really come up short is the
    error messages – a C++20 compiler would usually tell us which concept was not
    satisfied and why, while the template substitution error messages are not easy
    to decipher.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way, when you write a test to make sure that something does not compile,
    you can now use a concept (or a pseudo-concept) to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The C++20 version is left as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: Before we end this chapter, let’s look at the recommendations and the best practices
    for use of SFINAE and concepts in templates.
  prefs: []
  type: TYPE_NORMAL
- en: Constrained templates – the best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have recommended the most useful SFINAE and concept-based techniques as
    we encountered them throughout the chapter, but we had a lot of material to cover,
    so it may be helpful to concisely restate these guidelines. These guidelines are
    here mainly for a programmer who uses templates in their application code. That
    includes the foundational code such as core template libraries of the applications,
    but a programmer writing a library such as STL, written for the widest possible
    use under extremely varied conditions and documented very precisely in a formal
    standard, would find these guidelines lacking in precision and formality:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Learn the basic rules of SFINAE: in which contexts it applies (declarations)
    and in which it does not (function body).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The “natural” use of SFINAE that arises from using parameter-dependent types
    in the template declarations and argument-dependent expressions in the trailing
    return type is almost always the simplest way to express constraints on the template
    parameters (but see the next guideline).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ask yourself whether you use a dependent type such as `T::value_type` because
    this is precisely the right type for the context where you use it, or is it just
    simpler than writing the real constraint on the interface (such as “any type that
    converts to `T::value_type` )? In the latter case, this chapter should have convinced
    you that such restrictions are not that hard to express.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever it makes sense, make your templates more general by using additional
    template parameters and necessary constraints on them (instead of using `T::value_type`
    as an argument type, use another template parameter and constrain it to be convertible
    to `T::value_type`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you use C++20 and have access to concepts, avoid using “artificial” SFINAE,
    i.e. do not create substitution failures whose only purpose is to constrain the
    template. Use the `requires` clauses, with or without concepts, as needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you can’t use C++20 concepts, choose a common uniform approach to SFINAE-based
    constraints and follow it. Take advantage of the concept-based approach developed
    for C++20 even if you can’t use the language tools: follow the same style and
    patterns when applying SFINAE-based techniques. The previous section presented
    one such approach.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ideally, if a template declaration meets all specified restrictions, there
    should be no substitution errors in the body of the template (i.e. if the function
    invokes, it compiles). This is a difficult goal in practice: the restrictions
    may end up being verbose and sometimes difficult to write up, and you may not
    even be aware of all the constraints your implementation implicitly demands. Even
    STL, designed with the benefit of the committee scrutinizing every word in its
    requirements, does not fully meet this goal. Nonetheless, it is a good practice
    to aim for. Also, if you must allow a function to be invoked but not compile,
    at least have the requirements codified by static asserts in the body of the function
    – they are much easier for your users to understand than the strange substitution
    errors in types they never even heard of.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After reading this chapter, these guidelines should not be too daunting for
    you.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SFINAE is a somewhat esoteric feature of the C++ standard - it is complex and
    has many subtle details. While it is usually mentioned in the context of *manual
    control of the overload resolution*, its main purpose is actually not to enable
    very elaborate guru-level code but to make the regular (automatic) overload resolution
    work the way the programmer intended. In this role, it usually works exactly as
    desired and with no additional effort - in fact, the programmer usually does not
    need to even be aware of this feature. Most of the time, when you write a generic
    overload and a special overload for the pointers, you expect the latter not to
    be called for types that are not pointers. Most of the time, you probably don’t
    even pause to notice that the rejected overload would be ill-formed - who cares,
    it’s not supposed to be used. But to find out that it’s not supposed to be used,
    the type has to be substituted, which would result in an invalid code. SFINAE
    breaks this chicken-and-egg problem - to find out that the overload should be
    rejected, we have to substitute types, but that would create code that should
    not compile, which should not be a problem, because the overload should be rejected
    in the first place, but we do not know that until we substitute the types, and
    so on. This is what we call “natural” SFINAE.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we did not go through a few dozen pages just to learn that the compiler
    magically does the right thing and you don’t have to worry about it. The more
    elaborate use of SFINAE is to create an artificial substitution failure, and thus
    take control of the overload resolution by removing some of the overloads. In
    this chapter, we learned the *safe* contexts for these *temporary* errors that
    are eventually suppressed by SFINAE. With careful application, this technique
    can be used to inspect and differentiate, at compile time, anything from the simple
    features of different types (*is this a class?*) to complex behaviors that can
    be provided by any number of C++ language features (*is there any way to add these
    two types?*). In C++20, such code is greatly simplified by introducing constraints
    and concepts. However, we can apply concept-inspired thinking even to the code
    written for earlier standards.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will introduce another advanced template pattern that
    is used to greatly increase the power of class hierarchies in C++: class inheritance
    lets us pass information from the base class to the derived, and the Curiously
    Recurring Template Pattern does the opposite, it makes the base class aware of
    the derived.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is an overload set?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is overload resolution?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are type deduction and type substitution?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is SFINAE?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In what contexts can potentially invalid code be present and not trigger a compilation
    error, unless that code is actually needed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we determine which overload was chosen without actually calling it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is SFINAE used to control conditional compilation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are C++20 constraints superior to SFINAE for constraining templates?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the C++20 concepts standard benefit the programmers using earlier language
    versions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Part 3: C++ Design Patterns'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This part begins with the main portion of the book. It introduces the most
    important, frequently used C++ design patterns. Each pattern is generally used
    as a commonly accepted approach to solving a certain type of problem. Exactly
    what the problem is, varies a great deal: some are system architecture challenges,
    others are interface design problems, yet others deal with program performance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B19262_08.xhtml#_idTextAnchor360), *The Curiously Recurring Template
    Pattern*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B19262_09.xhtml#_idTextAnchor406), *Named Arguments, Method Chaining,
    and Builder Pattern*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B19262_10.xhtml#_idTextAnchor453), *Local Buffer Optimization*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B19262_11.xhtml#_idTextAnchor509), *Scopeguard*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B19262_12.xhtml#_idTextAnchor562), *Friend Factory*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B19262_13.xhtml#_idTextAnchor596), *Virtual Constructors and
    Factories*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B19262_14.xhtml#_idTextAnchor640), *The Template Method Pattern
    and the Non-Virtual Idiom*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
