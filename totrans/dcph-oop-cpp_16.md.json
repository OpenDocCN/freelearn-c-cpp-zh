["```cpp\n#include <list>    // partial list of #includes\n#include <iterator>\nusing std::cout;   // prefered to: using namespace std;\nusing std::endl;\nusing std::setprecision;\nusing std::string;\nusing std::to_string;\nusing std::list;\nconstexpr int MAXCOURSES = 5, MAXSTUDENTS = 5;\n// Simple enums for states; we could have also made a\n// hierarchy of states, but let's keep it simple\nenum State { Initial = 0, Success = 1, Failure = 2 };\n// More specific states for readability in subsequent code\nenum StudentState { AddSuccess = State::Success, \n                    AddFailure = State::Failure };\nenum CourseState { OpenForEnrollment = State::Success,\n                   NewSpaceAvailable = State::Success, \n                   Full = State::Failure };\nclass Subject;  // forward declarations\nclass Student;\nclass Observer  // Observer is an abstract class\n{\nprivate:\n    // Represent a state as an int, to eliminate type\n    // conversions between specific and basic states\n    int observerState = State::Initial;  // in-class init.\nprotected:\n    Observer() = default;\n    Observer(int s): observerState(s) { }\n    void SetState(int s) { observerState = s; }\npublic:\n    int GetState() const { return observerState; }\n    virtual ~Observer() = default;\n    virtual void Update() = 0;\n};\n```", "```cpp\nclass Subject   // Treated as an abstract class, due to\n{               // protected constructors. However, there's \nprivate:        // no pure virtual function\n    list<class Observer *> observers;\n    int numObservers = 0;\n    // Represent a state as an int, to eliminate\n    // type conversions between specific and basic states\n    int subjectState = State::Initial;\n    list<Observer *>::iterator newIter;\nprotected:\n    Subject() = default;\n    Subject(int s): subjectState(s) { } // note in-class\n                                        // init. above\n    void SetState(int s) { subjectState = s; }\npublic:\n    int GetState() const { return subjectState; }\n    int GetNumObservers() const { return numObservers; }\n    virtual ~Subject() = default;\n    virtual void Register(Observer *);\n    virtual void Release(Observer *);\n    virtual void Notify();\n};\n```", "```cpp\nvoid Subject::Register(Observer *ob)\n{\n    observers.push_back(ob); // Add an Observer to the list\n    numObservers++;\n}\nvoid Subject::Release(Observer *ob) // Remove an Observer \n{                                   // from the list\n    bool found = false;\n    // loop until we find the desired Observer\n    // Note auto iter will be: list<Observer *>::iterator\n    for (auto iter = observers.begin();\n         iter != observers.end() && !found; ++iter)\n    {\n        if (*iter == ob)// if we find observer that we seek\n        {\n            // erase() element, iterator is now corrupt.\n            // Save returned (good) iterator; \n            // we'll need it later\n            newIter = observers.erase(iter);\n            found = true;  // exit loop after found\n            numObservers--;\n        }\n    }\n}\nvoid Subject::Notify()\n{   // Notify all Observers\n    // Note auto iter will be: list<Observer *>::iterator\n    for (auto iter = observers.begin(); \n         iter != observers.end(); ++iter)\n    {\n        (*iter)->Update(); // AddCourse, then Release   \n        // Observer. State 'Success' is represented\n        // generally for Observer (at this level we have \n        // no knowledge of how Subject and Observer have\n        // been specialized). In our application, this\n        // means a Student (observer) added a course,\n        // got off waitlist (so waitlist had a Release),\n        // so we update the iterator\n        if ((*iter)->GetState() == State::Success)\n            iter = newIter; // update the iterator since\n    }                       // erase() invalidated this one\n    if (!observers.empty())\n    {   // Update last item on waitlist\n        Observer *last = *newIter; \n        last->Update();\n    }\n}\n```", "```cpp\nclass Course: public Subject  \n{   // inherits Observer list; \n    // Observer list represents Students on waitlist\nprivate:\n    string title;\n    int number = 0;  // course num, total num students set\n    int totalStudents = 0; // using in-class initialization\n    Student *students[MAXSTUDENTS] = { }; // initialize to\n                                          // nullptrs\npublic:                             \n    Course(const string &title, int num): number(num)\n    {\n        this->title = title;  // or rename parameter\n        // Note: in-class init. is in-lieu of below:\n        // for (int i = 0; i < MAXSTUDENTS; i++)\n            // students[i] = nullptr; \n    }\n    // destructor body shown as place holder to add more\n    // work that will be necessary\n    ~Course() override \n    {     /* There's more work to add here! */    }\n    int GetCourseNum() const { return number; }\n    const string &GetTitle() const { return title; }\n    const AddStudent(Student *);\n    void Open() \n{    SetState(CourseState::OpenForEnrollment); \nNotify(); \n    } \n    void PrintStudents() const;\n};\nbool Course::AddStudent(Student *s)\n{  // Should also check Student hasn't been added to Course\n    if (totalStudents < MAXSTUDENTS)  // course not full\n    {\n        students[totalStudents++] = s;\n        return true;\n    }\n    else return false;\n}\nvoid Course::PrintStudents() const\n{\n    cout << \"Course: (\" << GetTitle() << \n            \") has the following students: \" << endl;\n    for (int i = 0; i < MAXSTUDENTS && \n                        students[i] != nullptr; i++)\n    {\n        cout << \"\\t\" << students[i]->GetFirstName() << \" \";\n        cout << students[i]->GetLastName() << endl;\n    }\n}\n```", "```cpp\nclass Person { }; // Assume our typical Person class here\nclass Student: public Person, public Observer\n{\nprivate:\n    float gpa = 0.0;     // in-class initialization\n    const string studentId;\n    int currentNumCourses = 0;\n    Course *courses[MAXCOURSES] = { }; // set to nullptrs\n    // Course we'd like to take - we're on the waitlist. \n    Course *waitListedCourse = nullptr;  // Our Subject\n                                // (in specialized form)\n    static int numStudents;\npublic:\n    Student();  // default constructor\n    Student(const string &, const string &, char, \n            const string &, float, const string &, Course *);\n    Student(const string &, const string &, char, \n            const string &, float, const string &);\n    Student(const Student &) = delete; // Copies disallowed\n    ~Student() override;   // virtual destructor\n    void EarnPhD();\n    float GetGpa() const { return gpa; }\n    const string &GetStudentId() const \n       { return studentId; }\n    void Print() const override;  // from Person\n    void IsA() const override;  // from Person\n    void Update() override;     // from Observer\n    virtual void Graduate(); // newly introduced virtual fn\n    bool AddCourse(Course *);\n    void PrintCourses() const;\n    static int GetNumberStudents() { return numStudents; } \n};\n```", "```cpp\n// Assume most Student member functions are as we are\n// accustomed to seeing. All are available online.\n// Let's look at ONLY those that may differ:\n// Note that the default constructor for Observer() will be\n// invoked implicitly, thus it is not needed in init list\n// below (it is shown in comment as a reminder it's called)\nStudent::Student(const string &fn, const string &ln, \n    char mi, const string &t, float avg, const string &id,\n    Course *c): Person(fn, ln, mi, t), // Observer(),\n    gpa(avg), studentId(id), currentNumCourses(0)\n{ \n    // Below nullptr assignment is no longer needed with\n    // above in-class initialization; otherwise, add here:\n    // for (int i = 0; i < MAXCOURSES; i++)\n        // courses[i] = nullptr;\n    waitListedCourse = c;  // set initial waitlisted Course\n                           // (Subject)\n    c->Register(this); // Add the Student (Observer) to \n                       // the Subject's list of Observers\n    numStudents++;\n}\nbool Student::AddCourse(Course *c)\n{ \n    // Should also check Student isn't already in Course\n    if (currentNumCourses < MAXCOURSES)\n    {\n        courses[currentNumCourses++] = c;  // set assoc.\n        c->AddStudent(this);               // set back-link\n        return true;\n    }\n    else  // if we can't add the course,\n    {   // add Student (Observer) to the Course's Waitlist, \n        c->Register(this);  // stored in Subject base class\n        waitListedCourse = c; // set Student (Observer) \n                              // link to Subject\n        return false;\n    }\n}\n```", "```cpp\nvoid Student::Update()\n{   // Course state changed to 'Open For Enrollment', etc.\n    // so we can now add it.\n    if ((waitListedCourse->GetState() == \n         CourseState::OpenForEnrollment) ||\n        (waitListedCourse->GetState() == \n         CourseState::NewSpaceAvailable))\n    {\n        if (AddCourse(waitListedCourse)) // success Adding \n        {\n            cout << GetFirstName() << \" \" << GetLastName();\n            cout << \" removed from waitlist and added to \";\n            cout << waitListedCourse->GetTitle() << endl;\n            // Set observer's state to AddSuccess\n            SetState(StudentState::AddSuccess); \n            // Remove Student from Course's waitlist\n            waitListedCourse->Release(this); // Remove Obs.\n                                            // from Subject\n            waitListedCourse = nullptr; // Set Subject link \n        }                               // to null\n    }\n}\nvoid Student::PrintCourses() const\n{\n    cout << \"Student: (\" << GetFirstName() << \" \";\n    cout << GetLastName() << \") enrolled in: \" << endl;\n    for (int i = 0; i < MAXCOURSES && \n                    courses[i] != nullptr; i++)\n        cout << \"\\t\" << courses[i]->GetTitle() << endl;\n}\n```", "```cpp\nint main()\n{   // Instantiate several courses\n    Course *c1 = new Course(\"C++\", 230);  \n    Course *c2 = new Course(\"Advanced C++\", 430);\n    Course *c3 = new Course(\"C++ Design Patterns\", 550);\n    // Instantiate Students, select a course to be on the \n    // waitlist for -- to be added when registration starts\n    Student s1(\"Anne\", \"Chu\", 'M', \"Ms.\", 3.9, \"66CU\", c1);\n    Student s2(\"Joley\", \"Putt\", 'I', \"Ms.\", 3.1, \n               \"585UD\", c1);\n    Student s3(\"Geoff\", \"Curt\", 'K', \"Mr.\", 3.1, \n               \"667UD\", c1);\n    Student s4(\"Ling\", \"Mau\", 'I', \"Ms.\", 3.1, \"55TU\", c1);\n    Student s5(\"Jiang\", \"Wu\", 'Q', \"Dr.\", 3.8, \"88TU\", c1);\n    cout << \"Registration is Open\" << \"\\n\";\n    cout << \"Waitlist Students to be added to Courses\"; \n    cout << endl;\n    // Sends a message to Students that Course is Open. \n    c1->Open(); // Students on waitlist will automatically\n    c2->Open(); // be Added (as room allows)\n    c3->Open();\n    // Now that registration is open, add more courses \n    cout << \"During open registration, Students now adding\n             additional courses\" << endl;\n    s1.AddCourse(c2);  // Try to add more courses\n    s2.AddCourse(c2);  // If full, we'll be added to \n    s4.AddCourse(c2);  // a waitlist\n    s5.AddCourse(c2);  \n    s1.AddCourse(c3);  \n    s3.AddCourse(c3);  \n    s5.AddCourse(c3);\n    cout << \"Registration complete\\n\" << endl;\n    c1->PrintStudents();   // print each Course's roster\n    c2->PrintStudents();\n    c3->PrintStudents();\n    s1.PrintCourses();  // print each Student's course list\n    s2.PrintCourses();\n    s3.PrintCourses();\n    s4.PrintCourses();\n    s5.PrintCourses();\n    return 0;\n}\n```", "```cpp\nRegistration is Open \nWaitlist Students to be added to Courses\nAnne Chu removed from waitlist and added to C++\nGoeff Curt removed from waitlist and added to C++\nJiang Wu removed from waitlist and added to C++\nJoley Putt removed from waitlist and added to C++\nLing Mau removed from waitlist and added to C++\nDuring open registration, Students now adding more courses\nRegistration complete\nCourse: (C++) has the following students:\n        Anne Chu\n        Goeff Curt\n        Jiang Wu\n        Joley Putt\n        Ling Mau\nCourse: (Advanced C++) has the following students:\n        Anne Chu\n        Joley Putt\n        Ling Mau\n        Jiang Wu\nCourse: (C++ Design Patterns) has the following students:\n        Anne Chu\n        Goeff Curt\n        Jiang Wu\nStudent: (Anne Chu) enrolled in:\n        C++\n        Advanced C++\n        C++ Design Patterns\nStudent: (Joley Putt) enrolled in:\n        C++\n        Advanced C++\nStudent: (Goeff Curt) enrolled in:\n        C++\n        C++ Design Patterns\nStudent: (Ling Mau) enrolled in:\n        C++\n        Advanced C++\nStudent: (Jiang Wu) enrolled in:\n        C++\n        Advanced C++\n        C++ Design Patterns\n```"]