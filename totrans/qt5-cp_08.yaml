- en: Chapter 8. Enabling Your Qt Application to Support Other Languages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章：使您的Qt应用程序支持其他语言
- en: 'In this era of globalization, the internationalization and localization of
    applications is almost inevitable. Fortunately, Qt provides relevant classes,
    along with some handy tools such as **Qt Linguist** to ease the burden of developers
    and translators. In this chapter, we will use two example applications to demonstrate
    the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个全球化的时代，应用程序的国际化与本地化几乎是不可避免的。幸运的是，Qt提供了相关的类，以及一些实用的工具，如**Qt Linguist**，以减轻开发者和翻译者的负担。在本章中，我们将使用两个示例应用程序来展示以下主题：
- en: Internationalization of Qt applications
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt应用程序的国际化
- en: Translating Qt Widgets applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 翻译Qt Widgets应用程序
- en: Disambiguating identical texts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区分相同的文本
- en: Changing languages dynamically
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态更改语言
- en: Translating Qt Quick applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 翻译Qt Quick应用程序
- en: Internationalization of Qt applications
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt应用程序的国际化
- en: Internationalization and localization are the processes of adapting the application
    to other locales, which might include different languages and regional differences.
    In software development, internationalization refers to designing an application
    in such a way that it can be adapted to various languages and regions without
    code changes. On the other hand, localization means adapting internationalized
    software for a specific language or region. This usually involves locale-specific
    components and translating text.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 国际化和本地化是将应用程序适应其他地区的过程，这可能包括不同的语言和区域差异。在软件开发中，国际化是指以这种方式设计应用程序，使其可以适应各种语言和地区，而无需更改代码。另一方面，本地化是指为特定语言或地区调整国际化软件。这通常涉及特定于区域的组件和翻译文本。
- en: Qt has done a lot to free developers from different writing systems. We don't
    need to worry about how different languages display and input, as long as we use
    Qt's input and display controls or their subclasses.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Qt已经做了很多工作，让开发者摆脱了不同的书写系统。只要我们使用Qt的输入和显示控件或它们的子类，我们就不必担心不同语言如何显示和输入。
- en: 'In most cases, what we need to do is to produce translations and enable them
    in the application. Qt offers the `QTranslator` class, which loads the translation
    file and displays the corresponding language on the screen. The procedure is concluded
    in the following diagram:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们需要做的是生成翻译并在应用程序中启用它们。Qt提供了`QTranslator`类，该类加载翻译文件并在屏幕上显示相应的语言。整个过程总结在以下图中：
- en: '![Internationalization of Qt applications](img/4615OS_08_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![Qt应用程序国际化](img/4615OS_08_01.jpg)'
- en: 'First of all, Qt won''t just make all the strings translatable, because that
    would obviously be a disaster. Instead, you need to explicitly set whether the
    string is translatable in code or in the **Design** mode. In the Qt/C++ code,
    use the `tr()` function to enclose all the strings that can be translated. We
    use the `qsTr()` function to do this job in the Qt Quick/QML code. Let me show
    you an example. Here is a demonstration of the normal usage of a string:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Qt不会自动将所有字符串都设置为可翻译的，因为这显然会是一场灾难。相反，您需要在代码或**设计**模式中显式设置字符串是否可翻译。在Qt/C++代码中，使用`tr()`函数将所有可翻译的字符串括起来。在Qt
    Quick/QML代码中，我们使用`qsTr()`函数来完成这项工作。让我给您举一个例子。以下是一个字符串正常使用的演示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will output `Hello World` to the standard output stream, which is your
    command prompt or shell in general cases. If we want to make `Hello World` translatable,
    we need to use a `tr()` function to enclose the string, as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在标准输出流中输出`Hello World`，在一般情况下，这是您的命令提示符或shell。如果我们想使`Hello World`可翻译，我们需要使用`tr()`函数将字符串括起来，如下所示：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since `tr()` is a static public member function of the `QObject` class, you
    can still use it even for a non `QObject` class.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`tr()`是`QObject`类的静态公共成员函数，因此即使是非`QObject`类，您仍然可以使用它。
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Then, we need to use the `lupdate` command, which is located in **Tools** |
    **External** | **Linguist** | **Update Translations (lupdate)** in Qt Creator.
    This will update, or create if the **translation source** (**TS**) file doesn't
    exist. You can then use Qt Linguist to translate the strings. Before you release
    your application, run the `lrelease` command, which is located in **Tools** |
    **External** | **Linguist** | **Release Translations (lrelease)**, to generate
    the **Qt message** (**QM**) files that can be loaded by an application dynamically.
    Don't worry if it confuses you; we'll use two examples to walk you through these
    procedures.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要使用`lupdate`命令，该命令位于 Qt Creator 的**工具** | **外部** | **Linguist** | **更新翻译（lupdate）**。这将更新（如果翻译源文件不存在则创建）。然后，您可以使用
    Qt Linguist 翻译字符串。在您发布应用程序之前，运行**工具** | **外部** | **Linguist** | **发布翻译（lrelease）**中的`lrelease`命令，以生成应用程序可以动态加载的**Qt
    消息（QM）**文件。不用担心它会让您感到困惑；我们将使用两个示例来引导您完成这些步骤。
- en: Translating Qt Widgets applications
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 翻译 Qt 小部件应用程序
- en: First, let's create a new Qt Widget project, whose name is `Internationalization`.
    Then, edit `mainwindow.ui` in the **Design** mode.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个新的 Qt Widget 项目，其名称为`Internationalization`。然后，在**设计**模式下编辑`mainwindow.ui`。
- en: As usual, remove the status bar, menu bar, and tool bar.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如同往常，移除状态栏、菜单栏和工具栏。
- en: Add **Label** into `centralWidget` and change its object name to `nonTransLabel`.
    Then, change its text to `This is a non-translatable label` and uncheck `translatable`
    under `text` in **Property Editor**.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**标签**添加到`centralWidget`中，并将其对象名更改为`nonTransLabel`。然后，将其文本更改为`这是一个不可翻译的标签`，并在**属性编辑器**中取消选中`text`下的`translatable`。
- en: Drag a **Push Button** just beneath `nonTransLabel` with `transButton` as its
    object name. Change its text to `This is a translatable button`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个**按钮**拖到`nonTransLabel`下方，其对象名为`transButton`。将其文本更改为`这是一个可翻译的按钮`。
- en: Change **Lay out** to **Lay Out Vertically** in **MainWindow**.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**MainWindow**中将**布局**更改为**垂直布局**。
- en: Resize the frame to a comfortable size.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整框架大小到一个舒适的大小。
- en: 'Go back to editing the `Internationalization.pro` project file in the **Edit**
    mode. Add a line indicating the translation source file, which is shown as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到**编辑**模式下编辑`Internationalization.pro`项目文件。添加一行指示翻译源文件，如下所示：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `_de` suffix is a locale code, indicating that this is a German translation
    source file. The locale codes are defined by **Internet Engineering Task Force**
    in the **BCP 47** document series. Historically, Qt follows the POSIX definition,
    which is slightly different from BCP 47\. In this, it uses underscores (`_`) instead
    of hyphens (`-`) to separate subtags. In other words, Brazilian Portuguese is
    expressed as `pt_BR` instead of `pt-BR`. Meanwhile, Qt has provided some APIs
    to conform the locale name to a BCP 47 definition since the Qt 4.8 version.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`_de`后缀是一个区域设置代码，表示这是一个德语翻译源文件。区域设置代码由**互联网工程任务组**在**BCP 47**文档系列中定义。历史上，Qt
    遵循 POSIX 定义，这与 BCP 47 略有不同。在这个中，它使用下划线（`_`）而不是连字符（`-`）来分隔子标签。换句话说，巴西葡萄牙语表示为`pt_BR`而不是`pt-BR`。同时，Qt
    从 Qt 4.8 版本开始提供了一些 API 来使区域名称符合 BCP 47 定义。'
- en: 'To ensure this change is valid, save the project file and right-click on the
    project and select **Run qmake**. After this, we can generate the translation
    source file, which is exactly `Internationalization_de.ts`, by executing the `lupdate`
    command. The results will be printed in the **General Messages** panel, which
    contains the strings added to the TS file, as shown here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保此更改有效，保存项目文件，然后在项目上右键单击并选择**运行 qmake**。之后，我们可以通过执行`lupdate`命令生成翻译源文件，该文件正好是`Internationalization_de.ts`。结果将打印在**常规消息**面板中，其中包含添加到
    TS 文件中的字符串，如下所示：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, open the `Internationalization_de.ts` file in Qt Linguist. The overview
    UI of Qt Linguist is displayed in the following screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 Qt Linguist 中打开`Internationalization_de.ts`文件。以下截图显示了 Qt Linguist 的概览 UI：
- en: '![Translating Qt Widgets applications](img/4615OS_08_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![翻译 Qt 小部件应用程序](img/4615OS_08_02.jpg)'
- en: '**Context** lists the source text context, which is the class name in most
    cases, while **Strings** contains all the translatable strings. **Sources and
    Forms** displays the corresponding location of the string, either as a piece of
    code or a UI form. Beneath them is the translation area, which lets you input
    the translation and comments, if there are any.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**上下文**列出源文本上下文，在大多数情况下是类名，而**字符串**包含所有可翻译的字符串。**源和形式**显示字符串的对应位置，可以是代码片段或
    UI 表单。在其下方是翻译区域，允许您输入翻译和注释（如果有）。'
- en: In addition to the overview, the icon in front of each entry is noteworthy.
    A yellow question mark (**?**) simply means there is no translation currently,
    while a green checkmark means accepted/correct, and a yellow checkmark stands
    for accepted/warnings. You may also encounter a red exclamation mark (**!**),
    which indicates warnings. The sharp symbol (**#**) in front of a button's text
    in the **Sources and Forms** pane indicates untranslated, and possibly translatable,
    strings. Qt Linguist checks string translations automatically according to its
    own algorithm, which means that it may give a false warning. In this case, simply
    ignore the warning and accept the translation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 除了概述之外，每个条目前面的图标也值得关注。一个黄色的问号（**?**）简单地表示目前没有翻译，而绿色的勾号表示已接受/正确，黄色的勾号则表示已接受/有警告。您还可能遇到红色的感叹号（**!**），这表示警告。在“来源和形式”面板中按钮文本前面的尖锐符号（**#**）表示未翻译，可能可翻译的字符串。Qt
    Linguist会根据其自己的算法自动检查字符串翻译，这意味着它可能会给出错误的警告。在这种情况下，只需忽略警告并接受翻译。
- en: You'll find that the label text isn't among **Source text**. This is because
    we unchecked the `translatable` property. Now, input German translations in the
    translation area and click on the **Done and Next** button in the tool bar, then
    navigate to **Translation** | **Done and Next**. Or, even quicker, press *Ctrl*
    + *Enter* to accept the translation. When you've finished, click on the **Save**
    button, and then exit Qt Linguist.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现标签文本不在**源文本**中。这是因为我们没有勾选`translatable`属性。现在，在翻译区域输入德语翻译，然后在工具栏中单击**完成并下一步**按钮，然后导航到**翻译**
    | **完成并下一步**。或者，更快的方法是按*Ctrl* + *Enter*来接受翻译。完成翻译后，单击**保存**按钮，然后退出Qt Linguist。
- en: Although it's recommended to use Qt Linguist for translation tasks, it's viable
    to use a normal text editor to edit the TS file directly. The TS file is XML-formatted
    and should be supported well by other editors.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然推荐使用Qt Linguist进行翻译任务，但直接使用普通文本编辑器编辑TS文件也是可行的。TS文件是XML格式的，应该被其他编辑器很好地支持。
- en: 'After translating, return to Qt Creator and run the `lrelease` command to generate
    the `Internationalization_de.qm` file. At the current stage, your project folder
    should contain both the TS and QM files, as shown in the following screenshot:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译后，返回Qt Creator并运行`lrelease`命令以生成`Internationalization_de.qm`文件。在当前阶段，您的项目文件夹应包含TS和QM文件，如下面的截图所示：
- en: '![Translating Qt Widgets applications](img/4615OS_08_03.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![翻译Qt小部件应用程序](img/4615OS_08_03.jpg)'
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that file icons may differ slightly on your computers because of different
    operating system and (or) software installations.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于操作系统和（或）软件安装的不同，您的计算机上的文件图标可能会有所不同。
- en: We already produced the QM file; it's now time to modify the `main.cpp` file
    in order to load the translation into this application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经生成了QM文件；现在是时候修改`main.cpp`文件，以便将翻译加载到这个应用程序中。
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, `QTranslator` is used to load the German translation. Before we install
    translator into `QApplication`, we have to load a QM file by calling the `load`
    function. This will load the translation file whose filename consists of `Internationalization`
    followed by `_` and the UI language name (which is `de` in this case) and `.qm`
    (the default value). There is a simplified overloaded `load` function. Our equivalent
    is as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用`QTranslator`来加载德语翻译。在我们将翻译器安装到`QApplication`之前，我们必须通过调用`load`函数来加载一个QM文件。这将加载一个翻译文件，其文件名由`Internationalization`后跟`_`和UI语言名称（在这种情况下是`de`）以及`.qm`（默认值）组成。有一个简化的重载`load`函数。我们的等效函数如下：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Usually, it would be better to call the previous `load` function because it
    uses `QLocale::uiLanguages()`, and it will also format dates and numbers if they're
    necessary for the new locale. Whichever you choose, always remember that if you
    load the translation after the `MainWindow w;` line, `MainWindow` won't be able
    to use the translation at all.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，调用前面的`load`函数会更好，因为它使用`QLocale::uiLanguages()`，如果新区域需要，它还会格式化日期和数字。无论您选择哪种方式，都请记住，如果您在`MainWindow
    w;`行之后加载翻译，`MainWindow`将无法使用该翻译。
- en: If you run the application now, the application won't display German yet. Why?
    This is simply because `QTranslator` can't find the `Internationalization_de.qm`
    file. There are lots of ways to solve this problem. The neatest way is to change
    the working directory, while running the application in Qt Creator.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在运行应用程序，应用程序不会显示德语。为什么？这仅仅是因为`QTranslator`找不到`Internationalization_de.qm`文件。有很多方法可以解决这个问题。最干净的方法是在Qt
    Creator中运行应用程序时更改工作目录。
- en: Switch to the **Projects** mode.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到**项目**模式。
- en: Switch to **Run Settings**.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到**运行设置**。
- en: Change **Working directory** to your project source directory where you put
    the `Internationalization_de.qm` file.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**工作目录**更改为包含`Internationalization_de.qm`文件的项目源目录。
- en: 'Now, run it again; you''ll see German text on the screen, as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行它；你会在屏幕上看到德语文本，如下所示：
- en: '![Translating Qt Widgets applications](img/4615OS_08_04.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![翻译 Qt 小部件应用程序](img/4615OS_08_04.jpg)'
- en: The label is displayed in English as we expected, whereas the window title and
    button text are displayed in German.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 标签以我们预期的英语显示，而窗口标题和按钮文本则以德语显示。
- en: 'You may think this solution pointless, since the German translation is loaded
    despite the system locale setting. Well, the application can load the translation
    according to the system locale with only one modification; that is, changing the
    translator load line to the one shown here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为这个解决方案毫无意义，因为尽管系统语言环境设置已经加载，德语翻译仍然可用。然而，只需进行一项修改，应用程序就可以根据系统语言环境加载翻译；那就是，将翻译器加载行更改为以下所示：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, `system()` is a static member function of the `QLocale` class, which returns
    a `QLocale` object that initialized with the system locale. We then call the `language()`
    function to get the language of the current locale.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`system()`是`QLocale`类的静态成员函数，它返回一个用系统语言环境初始化的`QLocale`对象。然后我们调用`language()`函数来获取当前语言环境的语言。
- en: Disambiguating identical texts
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区分相同文本
- en: If there are identical texts, the default behavior is to treat them as the texts
    with the same meaning. This could effectively save translators from translating
    the same texts. Meanwhile, this doesn't hold true all the time. For instance,
    the word `open` can be used as a noun or an adjective, which may be different
    words in other languages. Thankfully, it's possible and easy to disambiguate identical
    texts in Qt.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在相同的文本，默认行为是将它们视为具有相同意义的文本。这可以有效地避免翻译员翻译相同的文本。然而，这并不总是正确的。例如，单词“open”可以用作名词或形容词，在其他语言中可能是不同的单词。幸运的是，在
    Qt 中区分相同的文本是可能且容易的。
- en: 'Now, let''s add a `PushButton` and `openButton` between `transButton` and `nonTransLabel`.
    Use `Open` as its text, and then edit `mainwindow.h`. Add a new private slot named
    `onOpenButtonClicked()`, which is used to handle the event when `openButton` gets
    clicked. The relevant source file, `mainwindow.cpp`, is pasted as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`transButton`和`nonTransLabel`之间添加一个`PushButton`和`openButton`。使用`Open`作为其文本，然后编辑`mainwindow.h`。添加一个名为`onOpenButtonClicked()`的新私有槽，用于处理`openButton`被点击的事件。相关的源文件`mainwindow.cpp`如下所示：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First, we connect the clicked signal of `openButton` to the `onOpenButtonClicked`
    slot of `MainWindow` in the constructor of `MainWindow`. Then, we simply use the
    static member function, `information`, of `QMessageBox` to pop-up an information
    dialog, using `Dialog` as the title and `Open` as its context. Don't forget to
    use the `tr()` function to make these strings translatable.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`MainWindow`的构造函数中将`openButton`的点击信号连接到`MainWindow`的`onOpenButtonClicked`槽。然后，我们简单地使用`QMessageBox`的静态成员函数`information`弹出信息对话框，使用`Dialog`作为标题，`Open`作为上下文。别忘了使用`tr()`函数使这些字符串可翻译。
- en: 'Now, run `lupdate` and open the TS file in Qt Linguist. There is only one **Open**
    string in the **Strings** panel, as shown here:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行`lupdate`并打开 Qt Linguist 中的 TS 文件。在**字符串**面板中只有一个**Open**字符串，如图所示：
- en: '![Disambiguating identical texts](img/4615OS_08_05.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![区分相同文本](img/4615OS_08_05.jpg)'
- en: 'However, **Open** in the information dialog is supposed to have an adjective,
    which shouldn''t be mixed up with the text in `openButton`. It''s a comment that
    we need to separate this **Open** from the other `Open`. Modify the `onOpenButtonClicked`
    function in `mainwindow.cpp`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，信息对话框中的**Open**应该有一个形容词，它不应该与`openButton`中的文本混淆。这是一个我们需要将这个**Open**与其他`Open`区分开来的注释。修改`mainwindow.cpp`中的`onOpenButtonClicked`函数：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, the second argument of the `tr()` function is the comment. Different comments
    stand for different texts. In this way, `lupdate` will treat them as nonidentical
    texts. Rerun `lupdate`, and you're able to translate two `Open` strings in Qt
    Linguist. The **Developer comments** column in the translation area is shown here.
    Qt Linguist will also show two translatable `Open` strings.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`tr()`函数的第二个参数是注释。不同的注释代表不同的文本。这样，`lupdate`会将它们视为非相同文本。重新运行`lupdate`，你就能在
    Qt Linguist 中翻译两个`Open`字符串。翻译区域中的**开发者注释**列如图所示。Qt Linguist 也会显示两个可翻译的**Open**字符串。
- en: '![Disambiguating identical texts](img/4615OS_08_06.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![区分相同文本](img/4615OS_08_06.jpg)'
- en: 'The equivalent property in the **Design** mode for `openButton` is disambiguation
    under the `text` property. After translation, execute `lrelease`, and then rerun
    the application and the two `Open` strings should have two different translations,
    which is demonstrated here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **设计** 模式下，`openButton` 的等效属性是在 `text` 属性下的 `text` 属性的区分。翻译后执行 `lrelease`，然后重新运行应用程序，两个
    `Open` 字符串应该有两个不同的翻译，如下所示演示：
- en: '![Disambiguating identical texts](img/4615OS_08_07.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![区分相同文本](img/4615OS_08_07.jpg)'
- en: Changing languages dynamically
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态更改语言
- en: Sometimes, people want to use languages other than the one specified by the
    system locale. This is a matter of application of the customized settings. This
    usually means restarting the application in order to load the corresponding translation
    file. This is partly because changing the language dynamically requires additional
    work. However, it's feasible and can be done with some lines. What's more important
    is that it delivers a better user experience!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，人们想使用除系统区域设置指定的语言之外的语言。这是一个应用自定义设置的问题。这通常意味着重新启动应用程序以加载相应的翻译文件。这部分的理由是动态更改语言需要额外的工作。然而，这是可行的，并且可以通过几行代码实现。更重要的是，它提供了更好的用户体验！
- en: 'Let''s add a new `push` button to `MainWindow`. Name it `loadButton` and change
    its text to `Load/Unload Translation`. Then, edit the `main.cpp` file in the **Edit**
    mode. Remove all `QTranslator` related lines, as we''ll be implementing this dynamic
    language switch in the `MainWindow` class. The `main.cpp` file should look like
    the originally generated one as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `MainWindow` 中添加一个新的 `push` 按钮。将其命名为 `loadButton` 并更改其文本为 `Load/Unload
    Translation`。然后，以 **编辑** 模式编辑 `main.cpp` 文件。删除所有与 `QTranslator` 相关的行，因为我们将在 `MainWindow`
    类中实现这种动态语言切换。`main.cpp` 文件应看起来与最初生成的文件一样，如下所示：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, edit `mainwindow.h`, as we need to declare some members here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编辑 `mainwindow.h`，因为我们需要在这里声明一些成员：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can tell, we moved `QTranslator` here, named it `deTranslator`, and
    used it as a pointer with the `deLoaded` variable to suggest whether or not we''ve
    already loaded the German translation. The following `onLoadButtonClicked` is
    a `private` slot function, which will be connected to the clicked signal of `loadButton`.
    Last but not least, we reimplement `changeEvent`, so that we can translate the
    entire user interface on the fly. It''ll be clear in the `mainwindow.cpp` source
    file, where it is pasted as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，我们将 `QTranslator` 移到这里，命名为 `deTranslator`，并将其用作 `deLoaded` 变量的指针，以表示我们是否已经加载了德语翻译。下面的
    `onLoadButtonClicked` 是一个 `private` 插槽函数，它将被连接到 `loadButton` 的点击信号。最后但同样重要的是，我们重写了
    `changeEvent`，这样我们就可以在飞行中翻译整个用户界面。它将在 `mainwindow.cpp` 源文件中变得清晰，如下所示粘贴：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the constructor, we initialize `deTranslator` and load the German translation,
    which is almost identical to what we did in `main.cpp` before. Then, we set `deLoaded`
    to `false`, indicating that the German translation is not installed yet. Next,
    this is followed by a `connect` statement.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们初始化 `deTranslator` 并加载德语翻译，这与我们在之前的 `main.cpp` 中所做几乎相同。然后，我们将 `deLoaded`
    设置为 `false`，表示德语翻译尚未安装。接下来，这是一个 `connect` 语句。
- en: Now, let's look into the `onLoadButtonClicked` function to see what will happen
    if the `loadButton` gets clicked. We set `deLoaded` to `false` and remove `deTranslator`
    if it's already loaded. Otherwise, we install `deTranslator` and set `deLoaded`
    to `true`. Remember that `qApp` is a predefined macro that simply refers to the
    current instance of `QCoreApplication`. Both `installTranslator` and `removeTranslator`
    will propagate the event to all the top-level windows, that is to say, `changeEvent`
    of `MainWindow` will be triggered in this case.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `onLoadButtonClicked` 函数，看看如果点击 `loadButton` 会发生什么。我们将 `deLoaded` 设置为
    `false` 并删除已加载的 `deTranslator`。否则，我们安装 `deTranslator` 并将 `deLoaded` 设置为 `true`。请记住，`qApp`
    是一个预定义的宏，它简单地指向当前的 `QCoreApplication` 实例。`installTranslator` 和 `removeTranslator`
    都会将事件传播到所有顶级窗口，也就是说，在这种情况下将触发 `MainWindow` 的 `changeEvent`。
- en: In order to update all the text according to the translator, we have to `reimplement`
    `changeEvent`. In this `reimplemented` function, we call the `retranslateUi` function
    to retranslate `MainWindow` if the event is `languageChange`. Otherwise, we simply
    call the inherited and default `QMainWindow::changeEvent` function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了根据翻译器更新所有文本，我们必须 `重写` `changeEvent`。在这个 `重写` 的函数中，如果事件是 `languageChange`，我们调用
    `retranslateUi` 函数来重新翻译 `MainWindow`。否则，我们简单地调用继承的默认 `QMainWindow::changeEvent`
    函数。
- en: When you firstly start the application, it'll display English text.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次启动应用程序时，它将显示英文文本。
- en: '![Changing languages dynamically](img/4615OS_08_08.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![动态更改语言](img/4615OS_08_08.jpg)'
- en: Once you click on the **Load/Unload Translation** button, all translatable and
    translated text will show in German.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你点击 **加载/卸载翻译** 按钮，所有可翻译和已翻译的文本将显示为德语。
- en: '![Changing languages dynamically](img/4615OS_08_09.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![动态更改语言](img/4615OS_08_09.jpg)'
- en: It'll display in English if you click the button again. In addition to a nontranslatable
    label, `loadButton` will not be not translated either. This is because we didn't
    translate the button at all. However, as you can see, the lack of some translations
    won't prevent the application from loading other translated texts.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次点击按钮，它将显示英文。除了不可翻译的标签外，`loadButton` 也不会被翻译。这是因为我们根本就没有翻译按钮。然而，正如你所看到的，缺少一些翻译不会阻止应用程序加载其他翻译文本。
- en: Translating Qt Quick applications
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 翻译 Qt Quick 应用程序
- en: The procedure of translating a Qt Quick application is similar to a Qt Widgets
    application. We'll walk through the process with another example application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译 Qt Quick 应用程序的过程与 Qt Widgets 应用程序类似。我们将通过另一个示例应用程序来介绍这个过程。
- en: 'Create a new Qt Quick application project and name it `Internationalization_QML`.
    The generated `main.qml` file has already added a `qsTr()` function for us. The
    contents may differ slightly in a later version of Qt Creator and (or) Qt Library.
    However, it should look similar to this one:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 Qt Quick 应用程序项目，并将其命名为 `Internationalization_QML`。生成的 `main.qml` 文件已经为我们添加了
    `qsTr()` 函数。在 Qt Creator 和（或）Qt 库的后续版本中，内容可能会有所不同。然而，它应该看起来与这个类似：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let''s edit the `Internationalization_QML.pro` project file, whose modified
    version is pasted as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编辑 `Internationalization_QML.pro` 项目文件，其修改后的版本如下粘贴：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In addition to the `TRANSLATIONS` line, we also add a `lupdate_only` block.
    It is crucial in this case.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `TRANSLATIONS` 行之外，我们还添加了一个 `lupdate_only` 块。在这种情况下，这是至关重要的。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We probably don't need this block in the Qt/C++ projects because the `lupdate`
    tool extracts the translatable strings from `SOURCES`, `HEADERS`, and `FORMS`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能不需要在 Qt/C++ 项目中此块，因为 `lupdate` 工具从 `SOURCES`、`HEADERS` 和 `FORMS` 中提取可翻译的字符串。
- en: However, this means that all the strings located elsewhere won't be found, not
    even saying translating. On the other hand, the `qml` files are not the C++ source
    files that are going to be compiled by the C++ compiler. In this case, we use
    `lupdate_only` to restrict those `SOURCES`, which are only available for `lupdate`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这意味着所有位于其他位置的字串都不会被找到，更不用说翻译了。另一方面，`qml` 文件不是将被 C++ 编译器编译的 C++ 源文件。在这种情况下，我们使用
    `lupdate_only` 来限制那些仅对 `lupdate` 可用的 `SOURCES`。
- en: Now, executing `lupdate` can generate the translation source file for us. Similarly,
    we use Qt Linguist to translate the `Internationalization_QML_de.ts` file. Then,
    execute `lrelease` to generate the QM file.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行 `lupdate` 可以为我们生成翻译源文件。同样，我们使用 Qt Linguist 来翻译 `Internationalization_QML_de.ts`
    文件。然后，执行 `lrelease` 来生成 QM 文件。
- en: 'To load the translation, we need to modify `main.cpp` into the one shown here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载翻译，我们需要将 `main.cpp` 修改为以下所示：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Also, we need to change **Working directory** to this project''s directory
    in **Run Settings** in the **Projects** mode. Now, run the application again;
    we should be able to see German text on the screen, as we can in the following
    screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要将**工作目录**在**项目**模式下的**运行设置**中更改为该项目的目录。现在，再次运行应用程序；我们应该能够在屏幕上看到德语文本，就像以下截图所示：
- en: '![Translating Qt Quick applications](img/4615OS_08_10.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![翻译 Qt Quick 应用程序](img/4615OS_08_10.jpg)'
- en: 'There is an alternative way to load the translations file, which doesn''t need
    to change **Working directory**. Firstly, change the `translator.load` line in
    `main.cpp` to the following one:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种加载翻译文件的方法，不需要更改**工作目录**。首先，将 `main.cpp` 中的 `translator.load` 行更改为以下内容：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We specify the directory that the translator should search. In this case, it's
    `":/"`, which is the top directory inside **Resources**. Please don't prepend
    `qrc` to the directory string; this will cause `translator` to be unable to find
    the QM file. A colon (`:`) is sufficient here to indicate that there is a `qrc`
    path inside **Resources**.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定了翻译者应该搜索的目录。在这种情况下，它是 `":/"`，这是 **Resources** 中的顶级目录。请勿在目录字符串前添加 `qrc`；这将导致
    `translator` 无法找到 QM 文件。在这里，一个冒号（`:`）就足够了，以表示 **Resources** 中有一个 `qrc` 路径。
- en: You can either create a new `qrc` file, or similar to what we do, add `Internationalization_QML_de.qm`
    to the current `qml.qrc` file.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建一个新的 `qrc` 文件，或者类似我们这样做，将 `Internationalization_QML_de.qm` 添加到当前的 `qml.qrc`
    文件中。
- en: Right-click on the `qml.qrc` file under **Resources** in **Projects Editor**.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **项目编辑器** 下的 **资源** 中的 `qml.qrc` 文件上右键单击。
- en: Select **Open** in **Editor**.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **编辑器** 中选择 **打开**。
- en: Navigate to **Add** | **Add Files** on the lower-right panel.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右下角的面板上导航到 **添加** | **添加文件**。
- en: Select the `Internationalization_QML_de.qm` file and click on **Open**.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `Internationalization_QML_de.qm` 文件，并单击 **打开**。
- en: 'Now, the `Internationalization_QML_de.qm` file should display on both **Editor**
    and the **Projects** tree like the following screenshot:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Internationalization_QML_de.qm` 文件应该在 **编辑器** 和 **项目** 树中同时显示，如下面的截图所示：
- en: '![Translating Qt Quick applications](img/4615OS_08_11.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![翻译 Qt Quick 应用程序](img/4615OS_08_11.jpg)'
- en: Go to the **Projects** mode and reset **Working directory** in **Run Settings**.
    Then, run the application again; the German translation should still load successfully.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到 **项目** 模式，并在 **运行设置** 中重置 **工作目录**。然后再次运行应用程序；德语翻译应该仍然可以成功加载。
- en: So far, there is no huge difference between Qt and Qt Quick. However, it's tedious
    to achieve dynamic translation installation and removal in Qt Quick. You have
    to write a C++ class that installs and remove the translator, which then emits
    a signal indicating that there is a change to the text. Therefore, the best practice
    for the Qt Quick application is to make language a setting. The user can then
    load different translations. It needs a restart of the application, though.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Qt 和 Qt Quick 之间没有太大的区别。然而，在 Qt Quick 中实现动态翻译的安装和删除是繁琐的。您必须编写一个 C++ 类来安装和删除翻译器，然后它发出一个信号，指示文本有变化。因此，Qt
    Quick 应用程序的最佳实践是将语言作为一个设置。用户可以加载不同的翻译。尽管如此，这需要重新启动应用程序。
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You're now able to make your application more competitive by adding support
    for other languages now. Besides, the super easy to use Qt Linguist, which is
    also a cross-platform tool provided by Qt, is also covered in this chapter. In
    addition to the skills you learnt, you can also tell that Qt/C++ still holds a
    great advantage over Qt Quick/QML in terms of APIs and features.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过添加对其他语言的支持来使您的应用程序更具竞争力。此外，Qt Linguist，这是一个由 Qt 提供的跨平台工具，也非常易于使用，也包含在本章中。除了您学到的技能外，您还可以看出
    Qt/C++ 在 API 和功能方面仍然比 Qt Quick/QML 具有巨大优势。
- en: In the next chapter, we're going to make our Qt applications redistributable
    and deploy them on other devices.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使我们的 Qt 应用程序可重新分发，并将它们部署到其他设备上。
