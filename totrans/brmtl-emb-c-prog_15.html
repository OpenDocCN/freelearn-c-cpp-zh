<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer127">
			<h1 id="_idParaDest-245" class="chapter-number"><a id="_idTextAnchor417"/>15</h1>
			<h1 id="_idParaDest-246"><a id="_idTextAnchor418"/>The Real-Time Clock (RTC)</h1>
			<p>In this chapter, we will explore the <strong class="bold">Real-Time Clock</strong> (<strong class="bold">RTC</strong>) peripheral, an essential component for timekeeping in embedded systems. This peripheral is crucial for applications that require accurate time and date maintenance, making it fundamental for a wide range of <span class="No-Break">embedded applications.</span></p>
			<p>We will start by introducing RTCs and understanding how they function. Following this, we will delve into the STM32 RTC module, examining its features and capabilities. Next, we will analyze the relevant registers from the STM32 reference manual, providing a detailed understanding of the configuration and operation of the RTC. Finally, we will apply this knowledge to develop an RTC driver, enabling precise timekeeping in your <span class="No-Break">embedded projects.</span></p>
			<p>In this chapter, we will cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li><a id="_idTextAnchor419"/><span class="No-Break">Understanding RTCs</span></li>
				<li><a id="_idTextAnchor420"/>The STM32 <span class="No-Break">RTC module</span></li>
				<li><a id="_idTextAnchor421"/>Some key <span class="No-Break">RTC registers</span></li>
				<li>Developing the <span class="No-Break">RTC driver</span></li>
			</ul>
			<p>By the end of this chapter, you will have a solid understanding of how RTCs work and will be equipped with the skills to develop bare-metal RTC drivers, allowing you to implement accurate timekeeping in your embedded <span class="No-Break">systems projects.</span></p>
			<h1 id="_idParaDest-247"><a id="_idTextAnchor422"/>Technical requirements</h1>
			<p>All the code examples for this chapter can be found on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming"><span class="No-Break">https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-248"><a id="_idTextAnchor423"/>Understanding RTCs</h1>
			<p>In this section, we will enter the world of RTCs, understanding what they are and how they work before exploring common use cases through a few interesting case studies. Let’s <span class="No-Break">get started!</span></p>
			<p>RTCs are specialized hardware devices<a id="_idIndexMarker1038"/> found in many microcontrollers and embedded systems. Their primary function is to keep track of the current time and date, even when the main power supply is turned off. Imagine them as the little timekeepers of the digital world, ensuring that the clock never stops ticking, no <span class="No-Break">matter what.</span></p>
			<p>RTCs are crucial in applications where timekeeping is essential. This includes everything from simple alarm clocks to complex data logging systems, where accurate timestamps are necessary. An RTC continues to operate on a small battery when the main system is powered down, maintaining accurate time and date information. Let’s see how <span class="No-Break">they work.</span></p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor424"/>How do RTCs work?</h2>
			<p>At the heart of an RTC is a crystal oscillator, which<a id="_idIndexMarker1039"/> provides a stable clock signal. This oscillator typically runs at <strong class="bold">32.768 kHz</strong>, a frequency chosen because it is easily divisible by powers of two, making it convenient for <span class="No-Break">binary counting.</span></p>
			<p>Here’s a simplified breakdown of how an <span class="No-Break">RTC works:</span></p>
			<ul>
				<li><strong class="bold">Crystal oscillator</strong>: The RTC contains a crystal oscillator that generates a precise <span class="No-Break">clock signal.</span></li>
				<li><strong class="bold">Counter</strong>: This clock signal drives a counter. The counter increments at a rate determined by the <span class="No-Break">oscillator’s frequency.</span></li>
				<li><strong class="bold">Time and date registers</strong>: The counter’s value is used to update time and date registers, which hold the current time (hours, minutes, seconds) and date (day, <span class="No-Break">month, year).</span></li>
				<li><strong class="bold">Battery backup</strong>: To ensure continuous operation, RTCs often have a battery backup. This keeps the oscillator running and the counter active even when the main power <span class="No-Break">is off.</span></li>
			</ul>
			<p>Let’s consider some <a id="_idIndexMarker1040"/>common use cases <span class="No-Break">for RTCs.</span></p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor425"/>Common use cases for RTCs</h2>
			<p>RTCs are incredibly <a id="_idIndexMarker1041"/>versatile and are used in a wide variety of applications. Let’s explore some of the common use cases through a few <span class="No-Break">case studies.</span></p>
			<h4>Case study 1 – data logging</h4>
			<p>One of the most common applications of RTCs is in data logging. Imagine that you’re designing a weather station that collects temperature, humidity, and pressure data. Accurate timestamps are crucial for<a id="_idIndexMarker1042"/> analyzing trends and patterns over time. Here’s how an RTC plays a vital role in <span class="No-Break">this scenario:</span></p>
			<ul>
				<li><strong class="bold">Initialization</strong>: The RTC is initialized and set to the current time <span class="No-Break">and date</span></li>
				<li><strong class="bold">Data collection</strong>: Every time a sensor reading is taken, the RTC provides <span class="No-Break">a timestamp</span></li>
				<li><strong class="bold">Storage</strong>: The sensor data, along with the timestamp, is stored <span class="No-Break">in memory</span></li>
				<li><strong class="bold">Analysis</strong>: When the data is retrieved for analysis, the timestamps ensure that each reading can be accurately placed on <span class="No-Break">a timeline</span></li>
			</ul>
			<p>In this case, the RTC ensures that every piece of data is accurately timestamped, making it possible to track changes and trends <span class="No-Break">with precision.</span></p>
			<h4>Case study 2 – alarm clocks</h4>
			<p>RTCs are also fundamental in<a id="_idIndexMarker1043"/> designing alarm clocks. Be it a simple bedside alarm clock or a complex scheduling system, the RTC provides the accurate timekeeping needed to trigger events at the right moment. Let’s look at a typical alarm <span class="No-Break">clock scenario:</span></p>
			<ul>
				<li><strong class="bold">Timekeeping</strong>: The RTC keeps track of the current time, continuously updating the <span class="No-Break">time registers.</span></li>
				<li><strong class="bold">Alarm setting</strong>: The user sets an alarm for a specific time. This information is stored in the RTC <span class="No-Break">alarm registers.</span></li>
				<li><strong class="bold">Alarm trigger</strong>: When the RTC time matches the alarm time, an interrupt is triggered, activating the alarm mechanism (such as sounding a buzzer or turning on <span class="No-Break">a light).</span></li>
			</ul>
			<p>In this case, the RTC ensures that<a id="_idIndexMarker1044"/> the alarm goes off at the precise time set by the user, making it an essential component for reliable time-based alerts. At this point, your next question might be, “<em class="italic">What’s so special </em><span class="No-Break"><em class="italic">about RTCs?</em></span><span class="No-Break">”</span></p>
			<h3>Why are RTCs important?</h3>
			<p>You might be wondering why we can’t just use the system clock or general-purpose timers for timekeeping. The<a id="_idIndexMarker1045"/> answer lies in the RTC’s ability to keep accurate time, even when the main system is powered down. Here are some key reasons why RTCs <span class="No-Break">are indispensable:</span></p>
			<ul>
				<li><strong class="bold">Accuracy</strong>: RTCs use crystal oscillators, which provide highly <span class="No-Break">accurate timekeeping</span></li>
				<li><strong class="bold">Low power consumption</strong>: RTCs are designed to operate on very low power, often running for years on a <span class="No-Break">small battery</span></li>
				<li><strong class="bold">Battery backup</strong>: RTCs continue to keep time even when the main power is off, thanks to their <span class="No-Break">battery backup</span></li>
				<li><strong class="bold">Independence from the main system</strong>: RTCs operate independently of the main microcontroller, ensuring <span class="No-Break">continuous timekeeping</span></li>
			</ul>
			<p>By understanding how RTCs work and their common use cases, we can appreciate their importance and effectively incorporate them into our embedded projects. Whether you’re building a simple alarm clock or a complex data logging system, the RTC is an important component that ensures your system always knows the right time. In the next section, we will explore the RTC peripheral in our <span class="No-Break">STM32F411 microcontroller.</span></p>
			<h1 id="_idParaDest-251"><a id="_idTextAnchor426"/>The STM32 RTC module</h1>
			<p>In this section, we will <a id="_idIndexMarker1046"/>explore the RTC module in the STM32F4 microcontroller family. Let’s start by looking at <span class="No-Break">its features.</span></p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor427"/>The main features of the STM32F4 RTC module</h2>
			<p>The STM32F4 RTC module is like the <a id="_idIndexMarker1047"/>Swiss Army knife of timekeeping, offering a rich set of features designed to meet the needs of numerous applications. Here are some of the <span class="No-Break">standout features:</span></p>
			<ul>
				<li><strong class="bold">Calendar with sub-seconds</strong>: The RTC module doesn’t just keep track of hours, minutes, and seconds; it also maintains sub-second accuracy. This is particularly useful for applications that require precise <span class="No-Break">time measurements.</span></li>
				<li><strong class="bold">Alarm functionality</strong>: Imagine that you have two alarm clocks within your microcontroller. The STM32F4 RTC module provides two programmable alarms, <strong class="bold">Alarm A</strong> and <strong class="bold">Alarm B</strong>, which can trigger events at specific times. This is perfect for tasks that need to be performed at regular intervals or at a specific time <span class="No-Break">of day.</span></li>
				<li><strong class="bold">Low power consumption</strong>: One of the biggest advantages of the RTC module is its low power usage. This makes it ideal for battery-operated devices, where conserving power <span class="No-Break">is paramount.</span></li>
				<li><strong class="bold">Backup domain</strong>: The RTC can operate independently of the main power supply thanks to a backup battery. This means that even if your device loses power, the RTC keeps running, maintaining <span class="No-Break">accurate time.</span></li>
				<li><strong class="bold">Daylight saving time</strong>: With the RTC module, you can program adjustments for daylight saving time automatically. No more manual resets twice <span class="No-Break">a year!</span></li>
				<li><strong class="bold">Automatic wakeup</strong>: The RTC can generate periodic wakeup signals, bringing your system out of low-power modes at preset intervals. This feature is invaluable for applications that need to perform regular checks <span class="No-Break">or updates.</span></li>
				<li><strong class="bold">Tamper detection</strong>: Security is a critical aspect of many applications, and the RTC module has you covered with tamper detection. It can log tamper events, providing an added layer of security for <span class="No-Break">your system.</span></li>
				<li><strong class="bold">Digital calibration</strong>: Accuracy is king when it comes to timekeeping. The RTC module includes a digital calibration feature to compensate for deviations in the crystal oscillator frequency, ensuring your timekeeping <span class="No-Break">remains spot-on.</span></li>
				<li><strong class="bold">Synchronization with external clocks</strong>: To enhance precision, the RTC can synchronize with an external clock source. This is great for applications that need to maintain very <a id="_idIndexMarker1048"/>high accuracy over <span class="No-Break">long periods.</span></li>
			</ul>
			<p>Now, let’s analyze some of the key components of the STM32F4 <span class="No-Break">RTC module.</span></p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor428"/>The key components of the STM32F4 RTC module</h2>
			<p>Let’s take a closer look at the<a id="_idIndexMarker1049"/> key components of the RTC module in the STM32F4 microcontroller family. We’ll break down each part to understand how they work together to provide accurate timekeeping and versatile functionality, starting with the <span class="No-Break">clock sources.</span></p>
			<h3>Clock sources</h3>
			<p>The driver of the RTC module is its clock <a id="_idIndexMarker1050"/>sources. <span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.1</em> presents a detailed block diagram of the RTC<a id="_idIndexMarker1051"/> module, highlighting the RTC clock sources. This diagram, sourced from the reference manual, provides a clear visual representation of the various components and their interactions within the <span class="No-Break">RTC module:</span></p>
			<div>
				<div id="_idContainer119" class="IMG---Figure">
					<img src="image/B21914_15_1.jpg" alt="Figure 15.1: RTC block diagram with clock sources highlighted" width="1650" height="926"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.1: RTC block diagram with clock sources highlighted</p>
			<p>The STM32F4 RTC can use<a id="_idIndexMarker1052"/> multiple <span class="No-Break">clock sources:</span></p>
			<ul>
				<li><strong class="bold">Low-speed external (LSE)</strong>: A 32.768 kHz crystal oscillator known for its stability and low power consumption. This is<a id="_idIndexMarker1053"/> typically the preferred clock source for <span class="No-Break">accurate timekeeping.</span></li>
				<li><strong class="bold">Low-speed internal (LSI)</strong>: An internal RC<a id="_idIndexMarker1054"/> oscillator that provides a less accurate but convenient option when an external crystal is <span class="No-Break">not available.</span></li>
				<li><strong class="bold">High-speed external (HSI)</strong>: A high-speed <a id="_idIndexMarker1055"/>clock source that can be used but is less common for RTC applications due to its higher <span class="No-Break">power consumption.</span></li>
			</ul>
			<p>The selected clock source<a id="_idIndexMarker1056"/> feeds into the RTC’s prescalers, which are responsible for dividing the clock frequency into suitable levels <span class="No-Break">for timekeeping:</span></p>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="image/B21914_15_2.jpg" alt="Figure 15.2: RTC block diagram – asynchronous and synchronous prescalers" width="1650" height="926"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.2: RTC block diagram – asynchronous and synchronous prescalers</p>
			<h3>Prescalers</h3>
			<p>The RTC module employs two types <span class="No-Break">of </span><span class="No-Break"><a id="_idIndexMarker1057"/></span><span class="No-Break">prescalers:</span></p>
			<ul>
				<li><strong class="bold">Asynchronous prescaler</strong>: This prescaler, typically set to divide by <strong class="bold">128</strong>, reduces the clock frequency to a lower <a id="_idIndexMarker1058"/>rate that can be managed by<a id="_idIndexMarker1059"/> the synchronous prescaler. It helps balance power consumption <span class="No-Break">and accuracy.</span></li>
				<li><strong class="bold">Synchronous prescaler</strong>: Often configured to divide by <strong class="bold">256</strong>, this prescaler further reduces the clock frequency to<a id="_idIndexMarker1060"/> generate a precise <strong class="bold">1 Hz clock</strong>, which is essential for updating the time and date <span class="No-Break">registers accurately.</span></li>
			</ul>
			<p>These prescalers ensure the RTC can operate efficiently, providing the necessary timekeeping precision while conserving power. Next, we have the time and <span class="No-Break">date registers.</span></p>
			<h3>Time and date registers</h3>
			<p><span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.3</em> highlights the time and date registers of the <span class="No-Break">RTC block:</span></p>
			<div>
				<div id="_idContainer121" class="IMG---Figure">
					<img src="image/B21914_15_3.jpg" alt="Figure 15.3: RTC block diagram – time and date registers" width="1650" height="926"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.3: RTC block diagram – time and date registers</p>
			<p>At the core of the RTC’s<a id="_idIndexMarker1061"/> functionality are the time and <span class="No-Break">date registers:</span></p>
			<ul>
				<li><strong class="bold">Time register (RTC_TR)</strong>: This register <a id="_idIndexMarker1062"/>holds the current time in hours, minutes, and seconds, stored in <strong class="bold">Binary-Coded Decimal</strong> (<strong class="bold">BCD</strong>) format. It is updated every second by the 1 Hz<a id="_idIndexMarker1063"/> clock from <span class="No-Break">the prescalers.</span></li>
				<li><strong class="bold">Date register (RTC_DR)</strong>: This register <a id="_idIndexMarker1064"/>maintains the current date, including the year, month, and day, also in <span class="No-Break">BCD format.</span></li>
			</ul>
			<p>These registers are crucial for maintaining accurate time and date information, which can be read and adjusted as needed. The next key component is the <span class="No-Break">RTC alarm.</span></p>
			<h3>Alarms</h3>
			<p>The RTC module features two programmable alarms, Alarm A and Alarm B. These alarms can be set to trigger at specific times, providing a powerful tool for <span class="No-Break">scheduling tasks:</span></p>
			<ul>
				<li><strong class="bold">Alarm registers</strong>: Each alarm has its own<a id="_idIndexMarker1065"/> set of registers (<strong class="source-inline">RTC_ALRMAR</strong> and <strong class="source-inline">RTC_ALRMBR</strong>) to store the alarm time <span class="No-Break">and date.</span></li>
				<li><strong class="bold">Interrupts</strong>: When an alarm is <a id="_idIndexMarker1066"/>triggered, it can generate an interrupt, waking <a id="_idIndexMarker1067"/>up the microcontroller from a low-power state or initiating a <span class="No-Break">specific function.</span></li>
			</ul>
			<p>The alarm modules are indicated in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="image/B21914_15_4.jpg" alt="Figure 15.4: RTC block diagram – alarms" width="1650" height="926"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.4: RTC block diagram – alarms</p>
			<p>Next, we have the <a id="_idIndexMarker1068"/><span class="No-Break">wakeup timer.</span></p>
			<h3>Wakeup timer</h3>
			<p>Another key feature of the RTC module is <a id="_idIndexMarker1069"/>the wakeup timer, which is managed by the <span class="No-Break"><strong class="source-inline">RTC_WUTR</strong></span><span class="No-Break"> register:</span></p>
			<div>
				<div id="_idContainer123" class="IMG---Figure">
					<img src="image/B21914_15_5.jpg" alt="Figure 15.5: RTC block diagram – wakeup timer" width="1636" height="919"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.5: RTC block diagram – wakeup timer</p>
			<p>This <strong class="bold">16-bit</strong> auto-reload timer can generate<a id="_idIndexMarker1070"/> periodic wakeup events, bringing <a id="_idIndexMarker1071"/>the system out of low-power modes at regular intervals. It’s ideal for tasks such as sensor readings or system checks, ensuring efficient <span class="No-Break">power usage.</span></p>
			<p>There’s also the tamper detection module. Let’s take <span class="No-Break">a look.</span></p>
			<h3>Tamper detection</h3>
			<p>Security is a vital aspect of many <a id="_idIndexMarker1072"/>applications, and the RTC module includes tamper detection features. The tamper detection circuitry can log events when a tamper attempt is detected, using the timestamp registers to record the exact time and date. This adds an extra layer of security, especially in applications requiring reliable timekeeping and event logging. Next, we have the calibration <span class="No-Break">register features.</span></p>
			<h3>Calibration and synchronization</h3>
			<p>To maintain high accuracy, the RTC module includes <span class="No-Break">calibration features:</span></p>
			<ul>
				<li><strong class="bold">Digital calibration</strong>: The <strong class="source-inline">RTC_CALR</strong> register allows for fine adjustments to the clock frequency, compensating<a id="_idIndexMarker1073"/> for any deviations in the <span class="No-Break">crystal oscillator</span></li>
				<li><strong class="bold">External clock synchronization</strong>: The RTC can synchronize with an external clock source, enhancing accuracy by periodically adjusting the internal clock so that it matches the <span class="No-Break">external reference</span></li>
			</ul>
			<p>These features ensure the RTC maintains precise timekeeping, even in varying environmental conditions. We also have the backup and control <span class="No-Break">registers module.</span></p>
			<h3>Backup and control registers</h3>
			<p>The RTC module includes several backup<a id="_idIndexMarker1074"/> and <span class="No-Break">control registers:</span></p>
			<ul>
				<li><strong class="bold">Backup registers</strong>: These registers <a id="_idIndexMarker1075"/>store critical data that must be retained even when the main power <a id="_idIndexMarker1076"/>supply <span class="No-Break">is off</span></li>
				<li><strong class="bold">Control registers</strong>: These registers (such as <strong class="source-inline">RTC_CR</strong>) manage the configuration and operation<a id="_idIndexMarker1077"/> of the RTC, including enabling the clock, setting alarms, and configuring <span class="No-Break">wakeup events</span></li>
			</ul>
			<p>The backup and control registers module is indicated in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer124" class="IMG---Figure">
					<img src="image/B21914_15_6.jpg" alt="Figure 15.6: RTC block diagram – backup and control registers" width="1650" height="926"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.6: RTC block diagram – backup and control registers</p>
			<p>Finally, there is the output<a id="_idIndexMarker1078"/> <span class="No-Break">control block.</span></p>
			<h3>Output control</h3>
			<p>The RTC module can output specific signals, such<a id="_idIndexMarker1079"/> as a calibration clock or alarm outputs, through the <strong class="source-inline">RTC_AF1</strong> pin. This allows the RTC module to interact with other components or systems, providing synchronized signals or triggering <span class="No-Break">external events.</span></p>
			<p>In the next section, we will analyze some of the key registers for configuring the <span class="No-Break">RTC peripheral.</span></p>
			<h1 id="_idParaDest-254"><a id="_idTextAnchor429"/>Some key RTC registers</h1>
			<p>In this section, we will explore the <a id="_idIndexMarker1080"/>characteristics and functions of some of the important registers within the RTC module. These registers are the building blocks that allow us to configure, control, and utilize the RTC’s features effectively. Let’s start with the <strong class="bold">RTC Time </strong><span class="No-Break"><strong class="bold">Register</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">RTC_TR</strong></span><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor430"/>RTC Time Register (RTC_TR)</h2>
			<p>The <strong class="source-inline">RTC_TR</strong> register is responsible<a id="_idIndexMarker1081"/> for keeping track of the current time. It maintains the hours, minutes, and seconds in BCD format, ensuring that time is easily readable and manipulable. Here are some of the key fields in <span class="No-Break">this register:</span></p>
			<ul>
				<li><strong class="bold">Hour tens (HT) and hour units (HU)</strong>: These bits represent the tens and units of the hour, respectively. They can handle both <strong class="bold">24-hour</strong> and <span class="No-Break"><strong class="bold">12-hour</strong></span><span class="No-Break"> formats.</span></li>
				<li><strong class="bold">Minute tens (MNT) and minute units (MNU)</strong>: These bits represent the tens and units of <span class="No-Break">the minutes.</span></li>
				<li><strong class="bold">Second tens (ST) and second units (SU)</strong>: These bits represent the tens and units of <span class="No-Break">the seconds.</span></li>
				<li><strong class="bold">PM</strong>: This bit indicates the <strong class="bold">AM/PM</strong> notation when in <span class="No-Break"><strong class="bold">12-hour</strong></span><span class="No-Break"> format.</span></li>
			</ul>
			<p>Further information about this register can be found on <em class="italic">page 450</em> of the <em class="italic">reference manual</em>. Let’s move on to the <strong class="bold">RTC Date </strong><span class="No-Break"><strong class="bold">Register</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">RTC_DR</strong></span><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor431"/>RTC Date Register (RTC_DR)</h2>
			<p>The <strong class="source-inline">RTC_DR</strong> register is responsible for maintaining the current date. It keeps track of the year, month, day of the month, and day <a id="_idIndexMarker1082"/>of the week, all in <span class="No-Break">BCD format.</span></p>
			<p>The following are the key fields in <span class="No-Break">this register:</span></p>
			<ul>
				<li><strong class="bold">Year tens (YT) and year units YU)</strong>: These bits represent the tens and units of <span class="No-Break">the year</span></li>
				<li><strong class="bold">Month tens (MT) and month units (MU)</strong>: These bits represent the tens and units of <span class="No-Break">the month</span></li>
				<li><strong class="bold">Date tens (DT) and date units (DU)</strong>: These bits represent the tens and units of the day of <span class="No-Break">the month</span></li>
				<li><strong class="bold">Week day units (WDU)</strong>: This bit represents the day of the week (1 <span class="No-Break">to 7)</span></li>
			</ul>
			<p>You can read more about this register on <em class="italic">page 451</em> of the <em class="italic">reference manual</em>. The next crucial register is the <strong class="bold">RTC Control </strong><span class="No-Break"><strong class="bold">Register</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">RTC_CR</strong></span><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor432"/>RTC Control Register (RTC_CR)</h2>
			<p>The <strong class="source-inline">RTC_CR</strong> register is<a id="_idIndexMarker1083"/> where we control the various operational modes and features of the RTC. This register allows us to enable the RTC, configure alarms, and set up the <span class="No-Break">wakeup timer.</span></p>
			<p>Let’s consider the key bits in <span class="No-Break">this register:</span></p>
			<ul>
				<li><strong class="bold">WUTE</strong>: Enable the wakeup timer. This bit enables the RTC <span class="No-Break">wakeup timer.</span></li>
				<li><strong class="bold">TSE</strong>: Enable a timestamp event. This bit enables the timestamping <span class="No-Break">of events.</span></li>
				<li><strong class="bold">ALRAE and ALRBE</strong>: Enable Alarm A and Alarm B. These bits enable the <span class="No-Break">respective alarms.</span></li>
				<li><strong class="bold">DCE</strong>: Enable digital calibration. This bit enables digital calibration of the <span class="No-Break">RTC clock.</span></li>
				<li><strong class="bold">FMT</strong>: Hour format. This bit sets the hour format to either 24-hour or <span class="No-Break">12-hour (AM/PM).</span></li>
			</ul>
			<p>Further details about this register can be fou<a id="_idTextAnchor433"/>nd on <em class="italic">page 453</em> of the <em class="italic">reference manual</em>. Next, we have the <strong class="bold">RTC Initialization and Status </strong><span class="No-Break"><strong class="bold">Register</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">RTC_ISR</strong></span><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor434"/>RTC Initialization and Status Register (RTC_ISR)</h2>
			<p>The <strong class="source-inline">RTC_ISR</strong> register plays a dual <a id="_idIndexMarker1084"/>role in both initializing the RTC and monitoring its status. This register is crucial during the setup process and for checking the RTC’s current state. Here are the key bits in <span class="No-Break">this register:</span></p>
			<ul>
				<li><strong class="bold">INIT</strong>: Initialization mode. Setting this bit puts RTC into <span class="No-Break">initialization mode.</span></li>
				<li><strong class="bold">RSF</strong>: Registers synchronization flag. This bit indicates that the calendar registers <span class="No-Break">are synchronized.</span></li>
				<li><strong class="bold">INITS</strong>: Initialization status flag. This bit indicates whether the RTC calendar has <span class="No-Break">been initialized.</span></li>
				<li><strong class="bold">ALRAF and ALRBF</strong>: Alarm A and Alarm B flags. These bits indicate whether an alarm has <span class="No-Break">been triggered.</span></li>
			</ul>
			<p>Next, we<a id="_idIndexMarker1085"/> ha<a id="_idTextAnchor435"/>ve the <strong class="bold">RTC Prescaler </strong><span class="No-Break"><strong class="bold">Register</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">RTC_PRER</strong></span><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor436"/>RTC Prescaler Register (RTC_PRER)</h2>
			<p>The <strong class="source-inline">RTC_PRER</strong> register manages the<a id="_idIndexMarker1086"/> prescalers that divide the RTC clock source to produce the 1 Hz clock necessary for accurate timekeeping. There are two key fields in <span class="No-Break">this register:</span></p>
			<ul>
				<li><strong class="bold">PREDIV_A</strong>: Asynchronous prescaler. This field sets the value for the <span class="No-Break">asynchronous prescaler.</span></li>
				<li><strong class="bold">PREDIV_S</strong>: Synchronous prescaler. This field sets the value for the <span class="No-Break">synchronous prescaler.</span></li>
			</ul>
			<p>Configuring the <strong class="source-inline">RTC_PRER</strong> register properly is vital for maintaining the accuracy of <span class="No-Break">the RTC.</span></p>
			<p>Next, we’ll look at the RTC Alarm Registers, <strong class="source-inline">RTC_ALRMAR</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">RTC_ALRMBR</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor437"/>RTC Alarm Registers (RTC_ALRMAR and RTC_ALRMBR)</h2>
			<p>These registers handle the configuration of Alarms A and B. They allow us to set specific times when the alarms should trigger. Here are<a id="_idIndexMarker1087"/> the key fields in <span class="No-Break">these registers:</span></p>
			<ul>
				<li><strong class="bold">ALRMASK</strong>: Alarm mask bits. These bits allow you to mask certain parts of the alarm time, providing flexibility in how and when the <span class="No-Break">alarms trigger.</span></li>
				<li><strong class="bold">ALRH, ALRMN, and ALRS</strong>: Hour, minute, and second fields. These fields set the specific time for <span class="No-Break">the alarm.</span></li>
			</ul>
			<p>The <strong class="source-inline">RTC_ALRMAR</strong> and <strong class="source-inline">RTC_ALRMBR</strong> registers are vital for applications requiring reliable, time-based event triggering. Lastly, let’s explore the <strong class="bold">RTC Wakeup Timer </strong><span class="No-Break"><strong class="bold">Register</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">RTC_WUTR</strong></span><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor438"/>RTC Wakeup Timer Register (RTC_WUTR)</h2>
			<p>The <strong class="source-inline">RTC_WUTR</strong> register configures the wakeup timer, enabling the RTC to periodically wake the system from low-power <a id="_idIndexMarker1088"/>modes. The key field in this register is the <strong class="bold">wakeup auto-reload value</strong> (<strong class="bold">WUT</strong>). This field sets the interval for the <span class="No-Break">wakeup timer.</span></p>
			<p>In the next section, we will apply everything we’ve learned in this section to develop a driver for the <span class="No-Break">RTC peripheral.</span></p>
			<h1 id="_idParaDest-262"><a id="_idTextAnchor439"/>Developing the RTC driver</h1>
			<p>In this section, we will develop the RTC calendar driver so that we can configure and keep track of the time <span class="No-Break">and </span><span class="No-Break"><a id="_idIndexMarker1089"/></span><span class="No-Break">date.</span></p>
			<p>As always, we will create a copy of our previous project while following the steps outlined in earlier chapters. We rename this copied project to <strong class="source-inline">RTC_Calendar</strong>. Next, create a new file named <strong class="source-inline">rtc.c</strong> in the <strong class="source-inline">Src</strong> folder and another file named <strong class="source-inline">rtc.h</strong> in the <strong class="source-inline">Inc</strong> folder. The RTC configuration can be quite elaborate, so we will create several helper functions to modularize the <span class="No-Break">initialization process.</span></p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor440"/>The RTC implementation file</h2>
			<p>Let’s begin by <a id="_idIndexMarker1090"/>populating the <strong class="source-inline">rtc.c</strong> file, starting with the helper functions necessary for the initialization function. Here are the macro definitions that we will use in the <span class="No-Break">RTC configuration:</span></p>
			<pre class="source-code">
#include "rtc.h"
#define PWREN        (1U &lt;&lt; 28)
#define CR_DBP       (1U &lt;&lt; 8)
#define CSR_LSION    (1U &lt;&lt; 0)
#define CSR_LSIRDY   (1U &lt;&lt; 1)
#define BDCR_BDRST   (1U &lt;&lt; 16)
#define BDCR_RTCEN   (1U &lt;&lt; 15)
#define RTC_WRITE_PROTECTION_KEY_1 ((uint8_t)0xCAU)
#define RTC_WRITE_PROTECTION_KEY_2 ((uint8_t)0x53U)
#define RTC_INIT_MASK               0xFFFFFFFFU
#define ISR_INITF                   (1U &lt;&lt; 6)
#define WEEKDAY_FRIDAY              ((uint8_t)0x05U)
#define MONTH_DECEMBER              ((uint8_t)0x12U)
#define TIME_FORMAT_PM              (1U &lt;&lt; 22)
#define CR_FMT                      (1U &lt;&lt; 6)
#define ISR_RSF                     (1U &lt;&lt; 5)
#define RTC_ASYNCH_PREDIV           ((uint32_t)0x7F)
#define RTC_SYNCH_PREDIV            ((uint32_t)0x00F9)</pre>			<p>Let’s break <span class="No-Break">them down:</span></p>
			<ul>
				<li><strong class="source-inline">PWREN</strong> (<strong class="source-inline">1U &lt;&lt; 28</strong>): This macro enables the clock for the PWR module by setting bit 28 in the APB1 peripheral clock <span class="No-Break">enable register.</span></li>
				<li><strong class="source-inline">CR_DBP</strong> (<strong class="source-inline">1U &lt;&lt; 8</strong>): This <a id="_idIndexMarker1091"/>enables access to the backup domain by setting bit 8 in the <span class="No-Break">PWR register.</span></li>
				<li><strong class="source-inline">CSR_LSION</strong> (<strong class="source-inline">1U &lt;&lt; 0</strong>): This macro enables the LSI oscillator by setting bi<a id="_idTextAnchor441"/>t 0 in the Clock Control &amp; <span class="No-Break">Status Register.</span></li>
				<li><strong class="source-inline">CSR_LSIRDY</strong> (<strong class="source-inline">1U &lt;&lt; 1</strong>): This macro is used to read the state of the <strong class="source-inline">LSI</strong> register. The LSIRDY bit is set to 1 when the LSI is stable and ready to <span class="No-Break">be used.</span></li>
				<li><strong class="source-inline">BDCR_BDRST</strong> (<strong class="source-inline">1U &lt;&lt; 16</strong>): This macro forces a reset of the backup domain by setting bit 16 in the Backup Domain <span class="No-Break">Control Register.</span></li>
				<li><strong class="source-inline">BDCR_RTCEN</strong> (<strong class="source-inline">1U &lt;&lt; 15</strong>): This enables RTC by setting bit 15 in the Backup Domain <span class="No-Break">Control Register.</span></li>
				<li><strong class="source-inline">RTC_WRITE_PROTECTION_KEY_1</strong> (<strong class="source-inline">(uint8_t)0xCAU</strong>): This key is used to disable write protection on the <span class="No-Break">RTC registers.</span></li>
				<li><strong class="source-inline">RTC_WRITE_PROTECTION_KEY_2</strong> (<strong class="source-inline">(uint8_t)0x53U</strong>): This is the second key needed to disable write protection on the <span class="No-Break">RTC registers.</span></li>
				<li><strong class="source-inline">RTC_INIT_MASK</strong> (<strong class="source-inline">0xFFFFFFFFU</strong>): This mask is used to enter initialization mode in the <span class="No-Break">RTC peripheral.</span></li>
				<li><strong class="source-inline">ISR_INITF</strong> (<strong class="source-inline">1U &lt;&lt; 6</strong>): This bit in the <strong class="source-inline">ISR</strong> register indicates that the RTC peripheral is in <span class="No-Break">initialization mode.</span></li>
				<li><strong class="source-inline">WEEKDAY_FRIDAY</strong> (<strong class="source-inline">(uint8_t)0x05U</strong>): This macro is used to configure the weekday of the calendar <span class="No-Break">to Friday.</span></li>
				<li><strong class="source-inline">MONTH_DECEMBER</strong> (<strong class="source-inline">(uint8_t)0x12U</strong>): This macro is used to configure the month of the calendar <span class="No-Break">to </span><span class="No-Break"><a id="_idIndexMarker1092"/></span><span class="No-Break">December.</span></li>
				<li><strong class="source-inline">TIME_FORMAT_PM</strong> (<strong class="source-inline">1U &lt;&lt; 22</strong>): This macro sets the time format to PM in the <span class="No-Break">12-hour format.</span></li>
				<li><strong class="source-inline">CR_FMT</strong> (<strong class="source-inline">1U &lt;&lt; 6</strong>): This macro sets the hour format to 24-hour format in the RTC control <span class="No-Break">register (</span><span class="No-Break"><strong class="source-inline">RTC-&gt;CR</strong></span><span class="No-Break">).</span></li>
				<li><strong class="source-inline">ISR_RSF</strong> (<strong class="source-inline">1U &lt;&lt; 5</strong>): This bit in the <strong class="source-inline">ISR</strong> register indicates that the RTC registers <span class="No-Break">are synchronized.</span></li>
				<li><strong class="source-inline">RTC_ASYNCH_PREDIV</strong> (<strong class="source-inline">(uint32_t)0x7F</strong>): This value sets the asynchronous prescaler for the RTC peripheral and is used to divide the <span class="No-Break">clock frequency.</span></li>
				<li><strong class="source-inline">RTC_SYNCH_PREDIV</strong> (<strong class="source-inline">(uint32_t)0x00F9</strong>): This value sets the synchronous prescaler for the RTC peripheral and is used to further divide the clock frequency for <span class="No-Break">timekeeping accuracy.</span></li>
			</ul>
			<p>Let’s examine the two functions responsible for setting the prescaler values for the <span class="No-Break">RTC peripheral.</span></p>
			<p>First, we <span class="No-Break">have </span><span class="No-Break"><strong class="source-inline">rtc_set_asynch_prescaler</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
static void rtc_set_asynch_prescaler(uint32_t AsynchPrescaler)
{
  MODIFY_REG(RTC-&gt;PRER, RTC_PRER_PREDIV_A, AsynchPrescaler &lt;&lt; RTC_
  PRER_PREDIV_A_Pos);
}</pre>			<p>This function sets the<a id="_idIndexMarker1093"/> asynchronous prescaler value for the RTC peripheral. Let’s break <span class="No-Break">it down:</span></p>
			<ul>
				<li><strong class="source-inline">MODIFY_REG</strong>: This macro modifies specific bits in a register. It is defined in the <strong class="source-inline">stm32f4xx.h</strong> <span class="No-Break">header file.</span></li>
				<li><strong class="source-inline">RTC-&gt;PRER</strong>: The <strong class="source-inline">PRER</strong> register of <span class="No-Break">the RTC.</span></li>
				<li><strong class="source-inline">RTC_PRER_PREDIV_A</strong>: The mask for the asynchronous prescaler bits in the <span class="No-Break"><strong class="source-inline">PRER</strong></span><span class="No-Break"> register.</span></li>
				<li><strong class="source-inline">AsynchPrescaler &lt;&lt; RTC_PRER_PREDIV_A_Pos</strong>: This snippet shifts the <strong class="source-inline">AsynchPrescaler</strong> value to the correct position within the <span class="No-Break"><strong class="source-inline">PRER</strong></span><span class="No-Break"> register.</span></li>
			</ul>
			<p>In short, this function configures the asynchronous prescaler by updating the appropriate bits in the <strong class="source-inline">PRER</strong> register. Next, we have the function for setting the synchronous prescaler – that <span class="No-Break">is, </span><span class="No-Break"><strong class="source-inline">rtc_set_synch_prescaler</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
static void rtc_set_synch_prescaler(uint32_t SynchPrescaler)
{
  MODIFY_REG(RTC-&gt;PRER, RTC_PRER_PREDIV_S, SynchPrescaler);
}</pre>			<p>This function configures the synchronous prescaler by updating the appropriate bits in the <span class="No-Break"><strong class="source-inline">PRER</strong></span><span class="No-Break"> register:</span></p>
			<ul>
				<li><strong class="source-inline">RTC-&gt;PRER</strong>: The <strong class="source-inline">PRER</strong> register of <span class="No-Break">the RTC</span></li>
				<li><strong class="source-inline">RTC_PRER_PREDIV_S</strong>: This is the mask for the synchronous prescaler bits in the <span class="No-Break"><strong class="source-inline">PRER</strong></span><span class="No-Break"> register</span></li>
				<li><strong class="source-inline">SynchPrescaler</strong>: This directly sets the synchronous prescaler value in the <span class="No-Break"><strong class="source-inline">PRER</strong></span><span class="No-Break"> register</span></li>
			</ul>
			<p>Next, we must analyze the other RTC initialization helper functions to understand how they work together to <a id="_idIndexMarker1094"/>configure and synchronize the <span class="No-Break">RTC peripheral.</span></p>
			<p>First, we have the <span class="No-Break"><strong class="source-inline">_rtc_enable_init_mode</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
void _rtc_enable_init_mode(void)
{
    RTC-&gt;ISR = RTC_INIT_MASK;
}</pre>			<p>Simply put, this function sets the RTC peripheral to initialization mode by writing the initialization mask to the <span class="No-Break"><strong class="source-inline">ISR</strong></span><span class="No-Break"> register:</span></p>
			<ul>
				<li><strong class="source-inline">RTC-&gt;ISR</strong>: This is the <strong class="source-inline">RTC_ISR</strong> register of <span class="No-Break">the RTC</span></li>
				<li><strong class="source-inline">RTC_INIT_MASK</strong>: This mask is used to enter <span class="No-Break">initialization mode</span></li>
			</ul>
			<p>Next, we <span class="No-Break">have </span><span class="No-Break"><strong class="source-inline">_rtc_disable_init_mode</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
void _rtc_disable_init_mode(void)
{
    RTC-&gt;ISR = ~RTC_INIT_MASK;
}</pre>			<p>This function disables initialization mode by clearing the initialization mask in the ISR register. Here, <strong class="source-inline">~RTC_INIT_MASK</strong> clears the initialization mask, exiting <span class="No-Break">initialization mode.</span></p>
			<p>The next helper function <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">_rtc_isActiveflag_init</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
uint8_t _rtc_isActiveflag_init(void)
{
    return ((RTC-&gt;ISR &amp; ISR_INITF) == ISR_INITF);
}</pre>			<p>This function returns 1 if the RTC peripheral is in initialization mode by checking the <strong class="source-inline">ISR_INITF</strong> bit, which indicates <a id="_idTextAnchor442"/>that the RTC peripheral is in <span class="No-Break">initialization mode.</span></p>
			<p>Next, we <span class="No-Break">have </span><span class="No-Break"><strong class="source-inline">_rtc_isActiveflag_rs</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
uint8_t _rtc_isActiveflag_rs(void)
{
    return ((RTC-&gt;ISR &amp; ISR_RSF) == ISR_RSF);
}</pre>			<p>This function returns 1 if the RTC registers are synchronized by checking the <strong class="source-inline">ISR_RSF</strong> bit, which indicates that the<a id="_idIndexMarker1095"/> RTC registers <span class="No-Break">are synchronized.</span></p>
			<p>There’s also the <span class="No-Break"><strong class="source-inline">rtc_init_seq</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
static uint8_t rtc_init_seq(void)
{
    /* Start init mode */
    _rtc_enable_init_mode();
    /* Wait till we are in init mode */
    while (_rtc_isActiveflag_init() != 1) {}
    return 1;
}</pre>			<p>This function starts the RTC initialization by enabling initialization mode and waiting until the RTC peripheral enters <span class="No-Break">initialization mode:</span></p>
			<ul>
				<li><strong class="source-inline">_rtc_enable_init_mode</strong>: This line puts the RTC peripheral into <span class="No-Break">initialization mode</span></li>
				<li><strong class="source-inline">_rtc_isActiveflag_init</strong>: This line waits until the RTC peripheral is in <span class="No-Break">initialization mode</span></li>
			</ul>
			<p>Next, we have <a id="_idIndexMarker1096"/>the <span class="No-Break"><strong class="source-inline">wait_for_synchro</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
static uint8_t wait_for_synchro(void)
{
    /* Clear RSF */
    RTC-&gt;ISR &amp;= ~ISR_RSF;
    /* Wait for registers to synchronize */
    while (_rtc_isActiveflag_rs() != 1) {}
    return 1;
}</pre>			<p>This function clears the synchronization flag and waits until the RTC registers <span class="No-Break">are synchronized.</span></p>
			<p>We also have the <span class="No-Break"><strong class="source-inline">exit_init_seq</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
static uint8_t exit_init_seq(void)
{
    /* Stop init mode */
    _rtc_disable_init_mode();
    /* Wait for registers to synchronize */
    return (wait_for_synchro());
}</pre>			<p>This function exits the RTC initialization mode and waits for the registers to synchronize to ensure everything is <a id="_idIndexMarker1097"/>set up correctly. Now, let’s see the functions for configuring the date <span class="No-Break">and time.</span></p>
			<p>First, we <span class="No-Break">have </span><span class="No-Break"><strong class="source-inline">rtc_date_config</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
static void rtc_date_config(uint32_t WeekDay, uint32_t Day, uint32_t Month, uint32_t Year)
{
  register uint32_t temp = 0U;
  temp = (WeekDay &lt;&lt; RTC_DR_WDU_Pos) |\
         (((Year &amp; 0xF0U) &lt;&lt; (RTC_DR_YT_Pos - 4U)) | 
         ((Year &amp; 0x0FU) &lt;&lt; RTC_DR_YU_Pos)) |\
         (((Month &amp; 0xF0U) &lt;&lt; (RTC_DR_MT_Pos - 4U)) | 
         ((Month &amp; 0x0FU) &lt;&lt; RTC_DR_MU_Pos)) |\
         (((Day &amp; 0xF0U) &lt;&lt; (RTC_DR_DT_Pos - 4U)) | 
         ((Day &amp; 0x0FU) &lt;&lt; RTC_DR_DU_Pos));
  MODIFY_REG(RTC-&gt;DR, (RTC_DR_WDU | RTC_DR_MT | RTC_DR_MU | RTC_DR_DT 
  | RTC_DR_DU | RTC_DR_YT | RTC_DR_YU), temp);
}</pre>			<p>This function sets the date in the <span class="No-Break">RTC peripheral.</span></p>
			<p>We begin by creating a temporary variable called <strong class="source-inline">temp</strong> to hold the date value. This variable is carefully constructed by shifting and combining the weekday, day, month, and year into the appropriate positions for the RTC’s date register. The <strong class="source-inline">MODIFY_REG</strong> macro is then used to update the RTC’s date register with this new value. Here, we can have the <span class="No-Break">following values:</span></p>
			<ul>
				<li><strong class="source-inline">WeekDay</strong>: Represents the day of <span class="No-Break">the week</span></li>
				<li><strong class="source-inline">Day</strong>: Represents the day of <span class="No-Break">the month</span></li>
				<li><strong class="source-inline">Month</strong>: Represents the month of <span class="No-Break">the year</span></li>
				<li><strong class="source-inline">Year</strong>: Represents <span class="No-Break">the year</span></li>
			</ul>
			<p>In essence, <strong class="source-inline">rtc_date_config</strong> takes the date components, assembles them into a single value, and writes it to the RTC’s date <a id="_idIndexMarker1098"/>register, ensuring the RTC peripheral accurately tracks the <span class="No-Break">current date.</span></p>
			<p>We have the <strong class="source-inline">rtc_time_config</strong> function for configuring <span class="No-Break">the time:</span></p>
			<pre class="source-code">
static void rtc_time_config(uint32_t Format12_24, uint32_t Hours, uint32_t Minutes, uint32_t Seconds)
{
  register uint32_t temp = 0U;
  temp = Format12_24 |\
         (((Hours &amp; 0xF0U) &lt;&lt; (RTC_TR_HT_Pos - 4U)) | 
         ((Hours &amp; 0x0FU) &lt;&lt; RTC_TR_HU_Pos)) |\
         (((Minutes &amp; 0xF0U) &lt;&lt; (RTC_TR_MNT_Pos - 4U)) | 
         ((Minutes &amp; 0x0FU) &lt;&lt; RTC_TR_MNU_Pos)) |\
         (((Seconds &amp; 0xF0U) &lt;&lt; (RTC_TR_ST_Pos - 4U)) | 
         ((Seconds &amp; 0x0FU) &lt;&lt; RTC_TR_SU_Pos));
  MODIFY_REG(RTC-&gt;TR, (RTC_TR_PM | RTC_TR_HT | RTC_TR_HU | RTC_TR_MNT 
  | RTC_TR_MNU | RTC_TR_ST | RTC_TR_SU), temp);
}</pre>			<p>This function sets the time in the RTC peripheral. Much like the date configuration, <strong class="source-inline">rtc_time_config</strong> begins by initializing a temporary variable, <strong class="source-inline">temp</strong>, to hold the time value. The time components – format, hours, minutes, and seconds – are then combined into this variable. The <strong class="source-inline">MODIFY_REG</strong> macro updates the RTC’s time register with the newly constructed time value. Here, we have the following <span class="No-Break">additional values:</span></p>
			<ul>
				<li><strong class="source-inline">Format12_24</strong>: This determines whether the time is in 12-hour or <span class="No-Break">24-hour format</span></li>
				<li><strong class="source-inline">Hours</strong>: Represents the <span class="No-Break">hour value</span></li>
				<li><strong class="source-inline">Minutes</strong>: Represents the <span class="No-Break">minute value</span></li>
				<li><strong class="source-inline">Seconds</strong>: Represents the <span class="No-Break">second value</span></li>
			</ul>
			<p>Now that we’ve implemented<a id="_idIndexMarker1099"/> all the helper functions required for initialization, let’s go ahead and implement the <span class="No-Break"><strong class="source-inline">rtc_init()</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
void rtc_init(void)
{
    /* Enable clock access to PWR */
    RCC-&gt;APB1ENR |= PWREN;
    /* Enable Backup access to config RTC */
    PWR-&gt;CR |= CR_DBP;
    /* Enable Low Speed Internal (LSI) */
    RCC-&gt;CSR |= CSR_LSION;
    /* Wait for LSI to be ready */
    while((RCC-&gt;CSR &amp; CSR_LSIRDY) != CSR_LSIRDY) {}
    /* Force backup domain reset */
    RCC-&gt;BDCR |= BDCR_BDRST;
    /* Release backup domain reset */
    RCC-&gt;BDCR &amp;= ~BDCR_BDRST;
    /* Set RTC clock source to LSI */
    RCC-&gt;BDCR &amp;= ~(1U &lt;&lt; 8);
    RCC-&gt;BDCR |= (1U &lt;&lt; 9);
    /* Enable the RTC */
    RCC-&gt;BDCR |= BDCR_RTCEN;
    /* Disable RTC registers write protection */
    RTC-&gt;WPR = RTC_WRITE_PROTECTION_KEY_1;
    RTC-&gt;WPR = RTC_WRITE_PROTECTION_KEY_2;
    /* Enter the initialization mode */
    if(rtc_init_seq() != 1)
    {
        // Handle initialization failure
    }
    /* Set desired date: Friday, December 29th, 2016 */
    rtc_date_config(WEEKDAY_FRIDAY, 0x29, MONTH_DECEMBER, 0x16);
    /* Set desired time: 11:59:55 PM */
    rtc_time_config(TIME_FORMAT_PM, 0x11, 0x59, 0x55);
    /* Set hour format */
    RTC-&gt;CR |= CR_FMT;
    /* Set Asynchronous prescaler */
    rtc_set_asynch_prescaler(RTC_ASYNCH_PREDIV);
    /* Set Synchronous prescaler */
    rtc_set_synch_prescaler(RTC_SYNCH_PREDIV);
    /* Exit the initialization mode */
    exit_init_seq();
    /* Enable RTC registers write protection */
    RTC-&gt;WPR = 0xFF;
}</pre>			<p>Let’s break <span class="No-Break">it down:</span></p>
			<pre class="source-code">
RCC-&gt;APB1ENR |= PWREN;</pre>			<p>We start by enabling the clock for the PWR module. This is crucial as it allows us to access and configure the <span class="No-Break">RTC peripheral:</span></p>
			<pre class="source-code">
PWR-&gt;CR |= CR_DBP;</pre>			<p>Next, we must enable<a id="_idIndexMarker1100"/> access to the backup domain. This step is necessary to make changes to the <span class="No-Break">RTC configuration:</span></p>
			<pre class="source-code">
RCC-&gt;CSR |= CSR_LSION;</pre>			<p>Then, we enable the LSI oscillator, which serves as the clock source for the <span class="No-Break">RTC peripheral:</span></p>
			<pre class="source-code">
while((RCC-&gt;CSR &amp; CSR_LSIRDY) != CSR_LSIRDY) {}</pre>			<p>We must wait until the LSI oscillator is stable and ready <span class="No-Break">to use:</span></p>
			<pre class="source-code">
RCC-&gt;BDCR |= BDCR_BDRST;</pre>			<p>To ensure a clean configuration, we must force a reset of the <span class="No-Break">backup domain:</span></p>
			<pre class="source-code">
RCC-&gt;BDCR &amp;= ~BDCR_BDRST;</pre>			<p>Then, we must release the reset, allowing the backup domain to <span class="No-Break">function normally:</span></p>
			<pre class="source-code">
RCC-&gt;BDCR &amp;= ~(1U &lt;&lt; 8);
RCC-&gt;BDCR |= (1U &lt;&lt; 9);</pre>			<p>After, we must configure<a id="_idIndexMarker1101"/> the RTC peripheral so that it uses the LSI oscillator as its <span class="No-Break">clock source:</span></p>
			<pre class="source-code">
RCC-&gt;BDCR |= BDCR_RTCEN;</pre>			<p>Then, we must enable the RTC peripheral by setting the appropriate bit in the backup domain <span class="No-Break">control register:</span></p>
			<pre class="source-code">
RTC-&gt;WPR = RTC_WRITE_PROTECTION_KEY_1;
RTC-&gt;WPR = RTC_WRITE_PROTECTION_KEY_2;</pre>			<p>To allow changes to the RTC registers, we must disable <span class="No-Break">write protection:</span></p>
			<pre class="source-code">
if(rtc_init_seq() != 1)
{
    // Handle initialization failure
}</pre>			<p>We can enter initialization mode using our <strong class="source-inline">rtc_init_seq()</strong> helper function. If it fails, we must handle the <span class="No-Break">error appropriately:</span></p>
			<pre class="source-code">
rtc_date_config(WEEKDAY_FRIDAY, 0x29, MONTH_DECEMBER, 0x16);</pre>			<p>At this point, we must configure the RTC peripheral to the desired date using another one of our helper functions. In this example, we will set the date to <em class="italic">Friday, December </em><span class="No-Break"><em class="italic">29, 2016</em></span><span class="No-Break">:</span></p>
			<pre class="source-code">
rtc_time_config(TIME_FORMAT_PM, 0x11, 0x59, 0x55);</pre>			<p>Then, we must set the RTC peripheral to the desired time. In this case, we will set the time to <span class="No-Break"><em class="italic">11:59:55 P.M.</em></span><span class="No-Break">:</span></p>
			<pre class="source-code">
RTC-&gt;CR |= CR_FMT;</pre>			<p>Next, we must configure the RTC peripheral so that it uses a <span class="No-Break">24-hour format:</span></p>
			<pre class="source-code">
rtc_set_asynch_prescaler(RTC_ASYNCH_PREDIV);
rtc_set_synch_prescaler(RTC_SYNCH_PREDIV);</pre>			<p>Then, we must set the asynchronous and synchronous <span class="No-Break">prescaler values:</span></p>
			<pre class="source-code">
exit_init_seq();</pre>			<p>At this point, we can exit initialization mode using the <strong class="source-inline">exit_init_seq()</strong> helper function we <span class="No-Break">created earlier:</span></p>
			<pre class="source-code">
RTC-&gt;WPR = 0xFF;</pre>			<p>Finally, we must re-enable write protection on the RTC registers to prevent <span class="No-Break">accidental changes.</span></p>
			<p>This <strong class="source-inline">rtc_init</strong> function<a id="_idIndexMarker1102"/> meticulously sets up the RTC peripheral by enabling the necessary clock, configuring the backup domain, setting the RTC clock source, and initializing the date <span class="No-Break">and time.</span></p>
			<p>Before moving on to the <strong class="source-inline">main.c</strong> file, let’s implement a few helper functions that are essential for handling various RTC tasks, such as converting values and getting the current date <span class="No-Break">and time.</span></p>
			<p>Let’s start with the <span class="No-Break"><strong class="source-inline">rtc_convert_dec2bcd</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
uint8_t rtc_convert_dec2bcd(uint8_t value)
{
    return (uint8_t)((((value) / 10U) &lt;&lt; 4U) | ((value) % 10U));
}</pre>			<p>This function takes a decimal value and returns its equivalent in BCD format, which is useful for setting <span class="No-Break">RTC values.</span></p>
			<p>Let’s take a closer look at decimal to <span class="No-Break">BCD conversion:</span></p>
			<ul>
				<li>First, <strong class="source-inline">((value) / 10U) &lt;&lt; 4U</strong> shifts the tens digit to the left by <span class="No-Break">4 bits</span></li>
				<li>Then, <strong class="source-inline">((value) % 10U)</strong> gets the <span class="No-Break">units digit</span></li>
				<li>The <strong class="source-inline">OR</strong> operation combines these two to form the <span class="No-Break">BCD value</span></li>
			</ul>
			<p>Before going any further, let’s take a closer look at the BCD format and the <span class="No-Break">conversion process.</span></p>
			<h2 id="_idParaDest-264"><a id="_idTextAnchor443"/>Understanding BCD format</h2>
			<p>BCD is a way of representing <a id="_idIndexMarker1103"/>decimal numbers in binary form. But here’s the twist: instead of <a id="_idIndexMarker1104"/>converting the whole number into a single binary value, each decimal digit is represented by its own <span class="No-Break">binary sequence.</span></p>
			<h3>How does BCD work?</h3>
			<p>In BCD, each digit of a decimal number is encoded <a id="_idIndexMarker1105"/>separately as a 4-bit binary number. Let’s break it down with an example to make <span class="No-Break">it clearer.</span></p>
			<p>Say you have the decimal number <em class="italic">42</em>. In BCD, this would be represented <span class="No-Break">as follows:</span></p>
			<ul>
				<li><em class="italic">4</em> in decimal is <em class="italic">0100</em> <span class="No-Break">in binary</span></li>
				<li><em class="italic">2</em> in decimal is <em class="italic">0010</em> <span class="No-Break">in binary</span></li>
			</ul>
			<p>So, 42 in BCD is <em class="italic">0100 0010</em>. Notice how each decimal digit is converted into a 4-bit binary form and then combined to represent the <span class="No-Break">entire number.</span></p>
			<h3>Why use BCD?</h3>
			<p>You might be wondering, why not just use regular binary? Well, BCD has its perks, especially in digital systems that need to display numbers or interface with <span class="No-Break">human-readable formats:</span></p>
			<ul>
				<li><strong class="bold">Ease of conversion</strong>: Converting<a id="_idIndexMarker1106"/> between BCD and decimal is straightforward. Each 4-bit group corresponds directly to a decimal digit, making it easy to read <span class="No-Break">and convert.</span></li>
				<li><strong class="bold">Display compatibility</strong>: Devices such as digital clocks, calculators, and other numeric displays often use BCD because it simplifies the process of converting binary values into a form that can be easily shown on <span class="No-Break">a screen.</span></li>
			</ul>
			<p>Now, let’s see how this relates <span class="No-Break">to RTCs.</span></p>
			<h3>BCD in RTC configurations</h3>
			<p>When working with RTCs, BCD is particularly handy. The RTC hardware often uses BCD to store time and date values<a id="_idIndexMarker1107"/> because it simplifies how these values can be displayed and manipulated. For instance, setting the time to <em class="italic">12:34:56</em> in BCD means we have the <span class="No-Break">following representations:</span></p>
			<ul>
				<li><em class="italic">12</em> is <span class="No-Break"><em class="italic">0001 0010</em></span></li>
				<li><em class="italic">34</em> is <span class="No-Break"><em class="italic">0011 0100</em></span></li>
				<li><em class="italic">56</em> is <span class="No-Break"><em class="italic">0101 0110</em></span></li>
			</ul>
			<p>Each of these pairs is easy to interpret and convert back into decimal for display or <span class="No-Break">further processing.</span></p>
			<p>BCD format is a clever way of encoding decimal numbers in a binary system. By handling each decimal digit separately, BCD simplifies many operations, especially when interfacing with human-readable displays or systems that require precise decimal representation. <span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.6</em> illustrates how BCD values can easily be mapped onto <span class="No-Break">digital displays:</span></p>
			<div>
				<div id="_idContainer125" class="IMG---Figure">
					<img src="image/B21914_15_7.jpg" alt="Figure 15.7: Display with BCD format" width="1323" height="802"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.7: Display with BCD format</p>
			<p>Now, let’s analyze the <span class="No-Break"><strong class="source-inline">rtc_convert_bcd2dec</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
uint8_t rtc_convert_bcd2dec(uint8_t value)
{
    return (uint8_t)(((uint8_t)((value) &amp; (uint8_t)0xF0U) &gt;&gt; 
    (uint8_t)0x4U) * 10U + ((value) &amp; (uint8_t)0x0FU));
}</pre>			<p>This function takes a BCD value and returns its decimal equivalent, making it easier to work with RTC data in a <span class="No-Break">decimal format.</span></p>
			<p>Here’s the BCD to decimal conversion <span class="No-Break">for this:</span></p>
			<ul>
				<li>First, <strong class="source-inline">((value) &amp; (uint8_t)0xF0U) &gt;&gt; (uint8_t)0x4U</strong> extracts the <span class="No-Break">tens digit</span></li>
				<li>Then, <strong class="source-inline">((value) &amp; (uint8_t)0x0FU)</strong> extracts the <span class="No-Break">units digit</span></li>
				<li>Multiplication and addition combine these to form the <span class="No-Break">binary value</span></li>
			</ul>
			<p>Next, we have a helper<a id="_idIndexMarker1108"/> function for getting the day – that <span class="No-Break">is, </span><span class="No-Break"><strong class="source-inline">rtc_date_get_day</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
uint32_t rtc_date_get_day(void)
{
    return (uint32_t)((READ_BIT(RTC-&gt;DR, (RTC_DR_DT | RTC_DR_DU))) &gt;&gt; 
    RTC_DR_DU_Pos);
}</pre>			<p>This function reads the RTC date register and returns the current day of <span class="No-Break">the month.</span></p>
			<p>We can read the day by using <strong class="source-inline">READ_BIT(RTC-&gt;DR, (RTC_DR_DT | RTC_DR_DU))</strong>, which reads the day tens and <span class="No-Break">units bits.</span></p>
			<p>Shifting the result to the right positions the <span class="No-Break">value correctly.</span></p>
			<p>We also have a function for the year – that <span class="No-Break">is, </span><span class="No-Break"><strong class="source-inline">rtc_date_get_year</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
uint32_t rtc_date_get_year(void)
{
    return (uint32_t)((READ_BIT(RTC-&gt;DR, (RTC_DR_YT | RTC_DR_YU))) &gt;&gt; 
    RTC_DR_YU_Pos);
}</pre>			<p>This function reads the RTC date register and returns the <span class="No-Break">current year.</span></p>
			<p>Here, <strong class="source-inline">READ_BIT(RTC-&gt;DR, (RTC_DR_YT | RTC_DR_YU))</strong> reads the year tens and <span class="No-Break">units bits.</span></p>
			<p>We also have functions for retrieving the month, second, minute, and hour, all of which are implemented using the <a id="_idIndexMarker1109"/>same approach as the other <span class="No-Break">getter functions:</span></p>
			<ul>
				<li>First, we <span class="No-Break">have</span><span class="No-Break"> </span><span class="No-Break"><strong class="source-inline">rtc_date_get_month</strong></span><span class="No-Break">:</span><pre class="source-code">
uint32_t rtc_date_get_month(void)
{
    return (uint32_t)((READ_BIT(RTC-&gt;DR, (RTC_DR_MT | RTC_DR_
    MU))) &gt;&gt; RTC_DR_MU_Pos);
}</pre></li>				<li>Then, we <span class="No-Break">have </span><span class="No-Break"><strong class="source-inline">rtc_time_get_second</strong></span><span class="No-Break">:</span><pre class="source-code">
uint32_t rtc_time_get_second(void)
{
    return (uint32_t)(READ_BIT(RTC-&gt;TR, (RTC_TR_ST | RTC_TR_SU)) 
    &gt;&gt; RTC_TR_SU_Pos);
}</pre></li>				<li>Next, <span class="No-Break">there’s </span><span class="No-Break"><strong class="source-inline">rtc_time_get_minute</strong></span><span class="No-Break">:</span><pre class="source-code">
uint32_t rtc_time_get_minute(void)
{
    return (uint32_t)(READ_BIT(RTC-&gt;TR, (RTC_TR_MNT | RTC_TR_
    MNU)) &gt;&gt; RTC_TR_MNU_Pos);
}</pre></li>				<li>Finally, <span class="No-Break">there’s </span><span class="No-Break"><strong class="source-inline">rtc_time_get_hour</strong></span><span class="No-Break">:</span><pre class="source-code">
uint32_t rtc_time_get_hour(void)
{
    return (uint32_t)((READ_BIT(RTC-&gt;TR, (RTC_TR_HT | RTC_TR_
    HU))) &gt;&gt; RTC_TR_HU_Pos);
}</pre></li>			</ul>
			<p>With all of these <a id="_idIndexMarker1110"/>functions implemented, our <strong class="source-inline">rtc.c</strong> file is complete. Our next task is to populate the <span class="No-Break"><strong class="source-inline">rtc.h</strong></span><span class="No-Break"> file.</span></p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor444"/>The header file</h2>
			<p>Here’s <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker1111"/></span><span class="No-Break"> code:</span></p>
			<pre class="source-code">
<strong class="bold">#ifndef</strong> RTC_H__
<strong class="bold">#define</strong> RTC_H__
<strong class="bold">#include</strong> &lt;stdint.h&gt;
<strong class="bold">#include</strong> "stm32f4xx.h"
<strong class="bold">void rtc_init</strong>(<strong class="bold">void</strong>);
uint8_t <strong class="source-inline">rtc_convert_bcd2dec</strong>(uint8_t value);
uint32_t <strong class="source-inline">rtc_date_get_day</strong>(<strong class="source-inline">void</strong>);
uint32_t <strong class="source-inline">rtc_date_get_year</strong>(<strong class="source-inline">void</strong>);
uint32_t <strong class="source-inline">rtc_date_get_month</strong>(<strong class="source-inline">void</strong>);
uint32_t <strong class="source-inline">rtc_time_get_second</strong>(<strong class="source-inline">void</strong>);
uint32_t <strong class="source-inline">rtc_time_get_minute</strong>(<strong class="source-inline">void</strong>);
uint32_t <strong class="source-inline">rtc_time_get_hour</strong>(<strong class="source-inline">void</strong>);
<strong class="source-inline">#endif</strong></pre>			<p>Here, we’re simply exposing the functions implemented in <strong class="source-inline">rtc.c</strong>, making them callable from other files. Let’s<a id="_idIndexMarker1112"/> go ahead and test our driver’s <span class="No-Break"><strong class="source-inline">main.c</strong></span><span class="No-Break"> file.</span></p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor445"/>The main file</h2>
			<p>Let’s update the <strong class="source-inline">main.c</strong> file so<a id="_idIndexMarker1113"/> that it looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
#include &lt;stdio.h&gt;
#include "rtc.h"
#include "uart.h"
#define BUFF_LEN        20
uint8_t time_buff[BUFF_LEN] = {0};
uint8_t date_buff[BUFF_LEN] = {0};
static void display_rtc_calendar(void);
int main(void)
{
    /*Initialize debug UART*/
    uart_init();
    /*Initialize rtc*/
    rtc_init();
    while(1)
    {
        display_rtc_calendar();
    }
}
static void display_rtc_calendar(void)
{
    /*Display format :  hh : mm : ss*/
    sprintf((char *)time_buff,"%.2d :%.2d :%.2d",rtc_convert_
    bcd2dec(rtc_time_get_hour()),
            rtc_convert_bcd2dec(rtc_time_get_minute()),
            rtc_convert_bcd2dec(rtc_time_get_second()));
    printf("Time : %.2d :%.2d :%.2d\n\r",rtc_convert_bcd2dec(rtc_time_
    get_hour()),
            rtc_convert_bcd2dec(rtc_time_get_minute()),
            rtc_convert_bcd2dec(rtc_time_get_second()));
    /*Display format :  mm : dd : yy*/
    sprintf((char *)date_buff,"%.2d - %.2d - %.2d",rtc_convert_
    bcd2dec(rtc_date_get_month()),
            rtc_convert_bcd2dec(rtc_date_get_day()),
            rtc_convert_bcd2dec(rtc_date_get_year()));
    printf("Date : %.2d - %.2d - %.2d    ",rtc_convert_bcd2dec(rtc_
    date_get_month()),
            rtc_convert_bcd2dec(rtc_date_get_day()),
            rtc_convert_bcd2dec(rtc_date_get_year()));
}</pre>			<p>Let’s break down the unique aspects of the code, starting with the <strong class="source-inline">display_rtc_calendar</strong> function. This function retrieves the current time and date from the RTC peripheral, formats <a id="_idIndexMarker1114"/>these values, prints them out, and stores them in a buffer for <span class="No-Break">further processing.</span></p>
			<p>The followi<a id="_idTextAnchor446"/>ng are our <span class="No-Break">buffer definitions:</span></p>
			<pre class="source-code">
#define BUFF_LEN 20
uint8_t time_buff[BUFF_LEN] = {0};
uint8_t date_buff[BUFF_LEN] = {0};</pre>			<p>Here, we can see <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">BUFF_LEN</strong>: This defines the length of the buffer for storing the time and <span class="No-Break">date string</span></li>
				<li><span class="No-Break"><strong class="bold">Buffers</strong></span><span class="No-Break">:</span><ul><li><strong class="source-inline">time_buff</strong>: This is an array that holds the formatted <span class="No-Break">time string</span></li><li><strong class="source-inline">date_buff</strong>: This is an array that holds the formatted <span class="No-Break">date string</span></li></ul></li>
			</ul>
			<p>Let’s take a closer look at the time formatting and <span class="No-Break">display block:</span></p>
			<pre class="source-code">
sprintf((char *)time_buff, "%.2d :%.2d :%.2d",
        rtc_convert_bcd2dec(rtc_time_get_hour()),
        rtc_convert_bcd2dec(rtc_time_get_minute()),
        rtc_convert_bcd2dec(rtc_time_get_second()));
printf("Time : %.2d :%.2d :%.2d\n\r",rtc_convert_bcd2dec(rtc_time_get_hour()),
            rtc_convert_bcd2dec(rtc_time_get_minute()),
            rtc_convert_bcd2dec(rtc_time_get_second()));</pre>			<p>Here, we can see <span class="No-Break">the following:</span></p>
			<ul>
				<li> <strong class="source-inline">sprintf</strong>: This is used to format the time string <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">time_buff</strong></span></li>
				<li> <strong class="source-inline">rtc_convert_bcd2dec</strong>: This converts the BCD values from RTC <span class="No-Break">into decimal</span></li>
				<li><strong class="source-inline">rtc_time_get_hour</strong>, <strong class="source-inline">rtc_time_get_minute</strong>, and <strong class="source-inline">rtc_time_get_second</strong>: These retrieve the current hour, minute, and second from the RTC <span class="No-Break">peripheral, respectively</span></li>
				<li><strong class="source-inline">printf</strong>: This function is used to print formatted output to the <span class="No-Break">serial port</span></li>
				<li><strong class="source-inline">%.2d</strong>: This format <a id="_idIndexMarker1115"/>specifier means that the integer will be printed with at least 2 digits, padding with leading zeros <span class="No-Break">if necessary</span></li>
			</ul>
			<p>We’re now ready to test our RTC calendar driver on the microcontroller. We can test the project by following <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Compile and upload the project to <span class="No-Break">your microcontroller.</span></li>
				<li>Launch RealTerm or your preferred serial <span class="No-Break">terminal program.</span></li>
				<li>Configure the appropriate port and <span class="No-Break">baud rate.</span></li>
				<li>You should see the time and date values printed and updating in real time, as shown in <span class="No-Break"><em class="italic">Figure 15</em></span><span class="No-Break"><em class="italic">.7</em></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div id="_idContainer126" class="IMG---Figure">
					<img src="image/B21914_15_8.jpg" alt="Figure 15.8: Expected results" width="1028" height="712"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.8: Expected results</p>
			<h1 id="_idParaDest-267"><a id="_idTextAnchor447"/>Summary</h1>
			<p>In this chapter, we explored the RTC peripheral, a component for timekeeping in embedded systems. This peripheral is essential for applications requiring precise time and date maintenance, making it fundamental for a wide range of <span class="No-Break">embedded applications.</span></p>
			<p>We began by introducing RTCs and understanding their functionality. This included a deep dive into how RTCs operate, which involved focusing on the crystal oscillator, counters, time and date registers, and the importance of battery backup. We illustrated these concepts with case studies, showcasing the practical use of RTCs in data logging, alarm clocks, time-stamping transactions, and <span class="No-Break">calendar functions.</span></p>
			<p>Following this, we examined the STM32 RTC module, highlighting its key features and capabilities. We discussed the calendar in terms of sub-seconds accuracy, dual programmable alarms, low power consumption, backup domain, daylight saving time adjustments, automatic wakeup, tamper detection, digital calibration, and synchronization with external clocks. Each feature was detailed to show its application and importance in maintaining <span class="No-Break">accurate timekeeping.</span></p>
			<p>Next, we analyzed the relevant registers from the STM32 reference manual, providing a detailed understanding of the configuration and operation of the RTC. We covered the <strong class="source-inline">RTC_TR</strong>, <strong class="source-inline">RTC_DR</strong>, <strong class="source-inline">RTC_CR</strong>, <strong class="source-inline">RTC_ISR</strong>, <strong class="source-inline">RTC_PRER</strong>, <strong class="source-inline">RTC_ALRMAR</strong>, <strong class="source-inline">RTC_ALRMBR</strong>, and <strong class="source-inline">RTC_WUTR</strong> registers. Each register’s role and key fields were explained to ensure you have a comprehensive grasp of how they contribute to the <span class="No-Break">RTC’s functionality.</span></p>
			<p>Finally, we applied this knowledge to develop an RTC driver. We walked through the steps to create and configure the RTC driver, starting with the initialization sequence and covering functions to set the date and time. We also implemented helper functions for converting values between decimal and BCD formats, as well as retrieving current time and date values from the <span class="No-Break">RTC peripheral.</span></p>
			<p>In the next chapter, we will delve into another useful peripheral, expanding our knowledge and toolkit for embedded <span class="No-Break">systems development.</span></p>
		</div>
	</div>
</div>
</body></html>