<html><head></head><body>
<div><div><div><h1 id="_idParaDest-245" class="chapter-number"><a id="_idTextAnchor417"/>15</h1>
			<h1 id="_idParaDest-246"><a id="_idTextAnchor418"/>The Real-Time Clock (RTC)</h1>
			<p>In this chapter, we will explore the <strong class="bold">Real-Time Clock</strong> (<strong class="bold">RTC</strong>) peripheral, an essential component for timekeeping in embedded systems. This peripheral is crucial for applications that require accurate time and date maintenance, making it fundamental for a wide range of embedded applications.</p>
			<p>We will start by introducing RTCs and understanding how they function. Following this, we will delve into the STM32 RTC module, examining its features and capabilities. Next, we will analyze the relevant registers from the STM32 reference manual, providing a detailed understanding of the configuration and operation of the RTC. Finally, we will apply this knowledge to develop an RTC driver, enabling precise timekeeping in your embedded projects.</p>
			<p>In this chapter, we will cover the following main topics:</p>
			<ul>
				<li><a id="_idTextAnchor419"/>Understanding RTCs</li>
				<li><a id="_idTextAnchor420"/>The STM32 RTC module</li>
				<li><a id="_idTextAnchor421"/>Some key RTC registers</li>
				<li>Developing the RTC driver</li>
			</ul>
			<p>By the end of this chapter, you will have a solid understanding of how RTCs work and will be equipped with the skills to develop bare-metal RTC drivers, allowing you to implement accurate timekeeping in your embedded systems projects.</p>
			<h1 id="_idParaDest-247"><a id="_idTextAnchor422"/>Technical requirements</h1>
			<p>All the code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming">https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming</a>.</p>
			<h1 id="_idParaDest-248"><a id="_idTextAnchor423"/>Understanding RTCs</h1>
			<p>In this section, we will enter the world of RTCs, understanding what they are and how they work before exploring common use cases through a few interesting case studies. Let’s get started!</p>
			<p>RTCs are specialized hardware devices<a id="_idIndexMarker1038"/> found in many microcontrollers and embedded systems. Their primary function is to keep track of the current time and date, even when the main power supply is turned off. Imagine them as the little timekeepers of the digital world, ensuring that the clock never stops ticking, no matter what.</p>
			<p>RTCs are crucial in applications where timekeeping is essential. This includes everything from simple alarm clocks to complex data logging systems, where accurate timestamps are necessary. An RTC continues to operate on a small battery when the main system is powered down, maintaining accurate time and date information. Let’s see how they work.</p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor424"/>How do RTCs work?</h2>
			<p>At the heart of an RTC is a crystal oscillator, which<a id="_idIndexMarker1039"/> provides a stable clock signal. This oscillator typically runs at <strong class="bold">32.768 kHz</strong>, a frequency chosen because it is easily divisible by powers of two, making it convenient for binary counting.</p>
			<p>Here’s a simplified breakdown of how an RTC works:</p>
			<ul>
				<li><strong class="bold">Crystal oscillator</strong>: The RTC contains a crystal oscillator that generates a precise clock signal.</li>
				<li><strong class="bold">Counter</strong>: This clock signal drives a counter. The counter increments at a rate determined by the oscillator’s frequency.</li>
				<li><strong class="bold">Time and date registers</strong>: The counter’s value is used to update time and date registers, which hold the current time (hours, minutes, seconds) and date (day, month, year).</li>
				<li><strong class="bold">Battery backup</strong>: To ensure continuous operation, RTCs often have a battery backup. This keeps the oscillator running and the counter active even when the main power is off.</li>
			</ul>
			<p>Let’s consider some <a id="_idIndexMarker1040"/>common use cases for RTCs.</p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor425"/>Common use cases for RTCs</h2>
			<p>RTCs are incredibly <a id="_idIndexMarker1041"/>versatile and are used in a wide variety of applications. Let’s explore some of the common use cases through a few case studies.</p>
			<h4>Case study 1 – data logging</h4>
			<p>One of the most common applications of RTCs is in data logging. Imagine that you’re designing a weather station that collects temperature, humidity, and pressure data. Accurate timestamps are crucial for<a id="_idIndexMarker1042"/> analyzing trends and patterns over time. Here’s how an RTC plays a vital role in this scenario:</p>
			<ul>
				<li><strong class="bold">Initialization</strong>: The RTC is initialized and set to the current time and date</li>
				<li><strong class="bold">Data collection</strong>: Every time a sensor reading is taken, the RTC provides a timestamp</li>
				<li><strong class="bold">Storage</strong>: The sensor data, along with the timestamp, is stored in memory</li>
				<li><strong class="bold">Analysis</strong>: When the data is retrieved for analysis, the timestamps ensure that each reading can be accurately placed on a timeline</li>
			</ul>
			<p>In this case, the RTC ensures that every piece of data is accurately timestamped, making it possible to track changes and trends with precision.</p>
			<h4>Case study 2 – alarm clocks</h4>
			<p>RTCs are also fundamental in<a id="_idIndexMarker1043"/> designing alarm clocks. Be it a simple bedside alarm clock or a complex scheduling system, the RTC provides the accurate timekeeping needed to trigger events at the right moment. Let’s look at a typical alarm clock scenario:</p>
			<ul>
				<li><strong class="bold">Timekeeping</strong>: The RTC keeps track of the current time, continuously updating the time registers.</li>
				<li><strong class="bold">Alarm setting</strong>: The user sets an alarm for a specific time. This information is stored in the RTC alarm registers.</li>
				<li><strong class="bold">Alarm trigger</strong>: When the RTC time matches the alarm time, an interrupt is triggered, activating the alarm mechanism (such as sounding a buzzer or turning on a light).</li>
			</ul>
			<p>In this case, the RTC ensures that<a id="_idIndexMarker1044"/> the alarm goes off at the precise time set by the user, making it an essential component for reliable time-based alerts. At this point, your next question might be, “<em class="italic">What’s so special </em><em class="italic">about RTCs?</em>”</p>
			<h3>Why are RTCs important?</h3>
			<p>You might be wondering why we can’t just use the system clock or general-purpose timers for timekeeping. The<a id="_idIndexMarker1045"/> answer lies in the RTC’s ability to keep accurate time, even when the main system is powered down. Here are some key reasons why RTCs are indispensable:</p>
			<ul>
				<li><strong class="bold">Accuracy</strong>: RTCs use crystal oscillators, which provide highly accurate timekeeping</li>
				<li><strong class="bold">Low power consumption</strong>: RTCs are designed to operate on very low power, often running for years on a small battery</li>
				<li><strong class="bold">Battery backup</strong>: RTCs continue to keep time even when the main power is off, thanks to their battery backup</li>
				<li><strong class="bold">Independence from the main system</strong>: RTCs operate independently of the main microcontroller, ensuring continuous timekeeping</li>
			</ul>
			<p>By understanding how RTCs work and their common use cases, we can appreciate their importance and effectively incorporate them into our embedded projects. Whether you’re building a simple alarm clock or a complex data logging system, the RTC is an important component that ensures your system always knows the right time. In the next section, we will explore the RTC peripheral in our STM32F411 microcontroller.</p>
			<h1 id="_idParaDest-251"><a id="_idTextAnchor426"/>The STM32 RTC module</h1>
			<p>In this section, we will <a id="_idIndexMarker1046"/>explore the RTC module in the STM32F4 microcontroller family. Let’s start by looking at its features.</p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor427"/>The main features of the STM32F4 RTC module</h2>
			<p>The STM32F4 RTC module is like the <a id="_idIndexMarker1047"/>Swiss Army knife of timekeeping, offering a rich set of features designed to meet the needs of numerous applications. Here are some of the standout features:</p>
			<ul>
				<li><strong class="bold">Calendar with sub-seconds</strong>: The RTC module doesn’t just keep track of hours, minutes, and seconds; it also maintains sub-second accuracy. This is particularly useful for applications that require precise time measurements.</li>
				<li><strong class="bold">Alarm functionality</strong>: Imagine that you have two alarm clocks within your microcontroller. The STM32F4 RTC module provides two programmable alarms, <strong class="bold">Alarm A</strong> and <strong class="bold">Alarm B</strong>, which can trigger events at specific times. This is perfect for tasks that need to be performed at regular intervals or at a specific time of day.</li>
				<li><strong class="bold">Low power consumption</strong>: One of the biggest advantages of the RTC module is its low power usage. This makes it ideal for battery-operated devices, where conserving power is paramount.</li>
				<li><strong class="bold">Backup domain</strong>: The RTC can operate independently of the main power supply thanks to a backup battery. This means that even if your device loses power, the RTC keeps running, maintaining accurate time.</li>
				<li><strong class="bold">Daylight saving time</strong>: With the RTC module, you can program adjustments for daylight saving time automatically. No more manual resets twice a year!</li>
				<li><strong class="bold">Automatic wakeup</strong>: The RTC can generate periodic wakeup signals, bringing your system out of low-power modes at preset intervals. This feature is invaluable for applications that need to perform regular checks or updates.</li>
				<li><strong class="bold">Tamper detection</strong>: Security is a critical aspect of many applications, and the RTC module has you covered with tamper detection. It can log tamper events, providing an added layer of security for your system.</li>
				<li><strong class="bold">Digital calibration</strong>: Accuracy is king when it comes to timekeeping. The RTC module includes a digital calibration feature to compensate for deviations in the crystal oscillator frequency, ensuring your timekeeping remains spot-on.</li>
				<li><strong class="bold">Synchronization with external clocks</strong>: To enhance precision, the RTC can synchronize with an external clock source. This is great for applications that need to maintain very <a id="_idIndexMarker1048"/>high accuracy over long periods.</li>
			</ul>
			<p>Now, let’s analyze some of the key components of the STM32F4 RTC module.</p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor428"/>The key components of the STM32F4 RTC module</h2>
			<p>Let’s take a closer look at the<a id="_idIndexMarker1049"/> key components of the RTC module in the STM32F4 microcontroller family. We’ll break down each part to understand how they work together to provide accurate timekeeping and versatile functionality, starting with the clock sources.</p>
			<h3>Clock sources</h3>
			<p>The driver of the RTC module is its clock <a id="_idIndexMarker1050"/>sources. <em class="italic">Figure 15</em><em class="italic">.1</em> presents a detailed block diagram of the RTC<a id="_idIndexMarker1051"/> module, highlighting the RTC clock sources. This diagram, sourced from the reference manual, provides a clear visual representation of the various components and their interactions within the RTC module:</p>
			<div><div><img src="img/B21914_15_1.jpg" alt="Figure 15.1: RTC block diagram with clock sources highlighted" width="1650" height="926"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.1: RTC block diagram with clock sources highlighted</p>
			<p>The STM32F4 RTC can use<a id="_idIndexMarker1052"/> multiple clock sources:</p>
			<ul>
				<li><strong class="bold">Low-speed external (LSE)</strong>: A 32.768 kHz crystal oscillator known for its stability and low power consumption. This is<a id="_idIndexMarker1053"/> typically the preferred clock source for accurate timekeeping.</li>
				<li><strong class="bold">Low-speed internal (LSI)</strong>: An internal RC<a id="_idIndexMarker1054"/> oscillator that provides a less accurate but convenient option when an external crystal is not available.</li>
				<li><strong class="bold">High-speed external (HSI)</strong>: A high-speed <a id="_idIndexMarker1055"/>clock source that can be used but is less common for RTC applications due to its higher power consumption.</li>
			</ul>
			<p>The selected clock source<a id="_idIndexMarker1056"/> feeds into the RTC’s prescalers, which are responsible for dividing the clock frequency into suitable levels for timekeeping:</p>
			<div><div><img src="img/B21914_15_2.jpg" alt="Figure 15.2: RTC block diagram – asynchronous and synchronous prescalers" width="1650" height="926"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.2: RTC block diagram – asynchronous and synchronous prescalers</p>
			<h3>Prescalers</h3>
			<p>The RTC module employs two types of <a id="_idIndexMarker1057"/>prescalers:</p>
			<ul>
				<li><strong class="bold">Asynchronous prescaler</strong>: This prescaler, typically set to divide by <strong class="bold">128</strong>, reduces the clock frequency to a lower <a id="_idIndexMarker1058"/>rate that can be managed by<a id="_idIndexMarker1059"/> the synchronous prescaler. It helps balance power consumption and accuracy.</li>
				<li><strong class="bold">Synchronous prescaler</strong>: Often configured to divide by <strong class="bold">256</strong>, this prescaler further reduces the clock frequency to<a id="_idIndexMarker1060"/> generate a precise <strong class="bold">1 Hz clock</strong>, which is essential for updating the time and date registers accurately.</li>
			</ul>
			<p>These prescalers ensure the RTC can operate efficiently, providing the necessary timekeeping precision while conserving power. Next, we have the time and date registers.</p>
			<h3>Time and date registers</h3>
			<p><em class="italic">Figure 15</em><em class="italic">.3</em> highlights the time and date registers of the RTC block:</p>
			<div><div><img src="img/B21914_15_3.jpg" alt="Figure 15.3: RTC block diagram – time and date registers" width="1650" height="926"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.3: RTC block diagram – time and date registers</p>
			<p>At the core of the RTC’s<a id="_idIndexMarker1061"/> functionality are the time and date registers:</p>
			<ul>
				<li><strong class="bold">Time register (RTC_TR)</strong>: This register <a id="_idIndexMarker1062"/>holds the current time in hours, minutes, and seconds, stored in <strong class="bold">Binary-Coded Decimal</strong> (<strong class="bold">BCD</strong>) format. It is updated every second by the 1 Hz<a id="_idIndexMarker1063"/> clock from the prescalers.</li>
				<li><strong class="bold">Date register (RTC_DR)</strong>: This register <a id="_idIndexMarker1064"/>maintains the current date, including the year, month, and day, also in BCD format.</li>
			</ul>
			<p>These registers are crucial for maintaining accurate time and date information, which can be read and adjusted as needed. The next key component is the RTC alarm.</p>
			<h3>Alarms</h3>
			<p>The RTC module features two programmable alarms, Alarm A and Alarm B. These alarms can be set to trigger at specific times, providing a powerful tool for scheduling tasks:</p>
			<ul>
				<li><code>RTC_ALRMAR</code> and <code>RTC_ALRMBR</code>) to store the alarm time and date.</li>
				<li><strong class="bold">Interrupts</strong>: When an alarm is <a id="_idIndexMarker1066"/>triggered, it can generate an interrupt, waking <a id="_idIndexMarker1067"/>up the microcontroller from a low-power state or initiating a specific function.</li>
			</ul>
			<p>The alarm modules are indicated in the following figure:</p>
			<div><div><img src="img/B21914_15_4.jpg" alt="Figure 15.4: RTC block diagram – alarms" width="1650" height="926"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.4: RTC block diagram – alarms</p>
			<p>Next, we have the <a id="_idIndexMarker1068"/>wakeup timer.</p>
			<h3>Wakeup timer</h3>
			<p>Another key feature of the RTC module is <a id="_idIndexMarker1069"/>the wakeup timer, which is managed by the <code>RTC_WUTR</code> register:</p>
			<div><div><img src="img/B21914_15_5.jpg" alt="Figure 15.5: RTC block diagram – wakeup timer" width="1636" height="919"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.5: RTC block diagram – wakeup timer</p>
			<p>This <strong class="bold">16-bit</strong> auto-reload timer can generate<a id="_idIndexMarker1070"/> periodic wakeup events, bringing <a id="_idIndexMarker1071"/>the system out of low-power modes at regular intervals. It’s ideal for tasks such as sensor readings or system checks, ensuring efficient power usage.</p>
			<p>There’s also the tamper detection module. Let’s take a look.</p>
			<h3>Tamper detection</h3>
			<p>Security is a vital aspect of many <a id="_idIndexMarker1072"/>applications, and the RTC module includes tamper detection features. The tamper detection circuitry can log events when a tamper attempt is detected, using the timestamp registers to record the exact time and date. This adds an extra layer of security, especially in applications requiring reliable timekeeping and event logging. Next, we have the calibration register features.</p>
			<h3>Calibration and synchronization</h3>
			<p>To maintain high accuracy, the RTC module includes calibration features:</p>
			<ul>
				<li><code>RTC_CALR</code> register allows for fine adjustments to the clock frequency, compensating<a id="_idIndexMarker1073"/> for any deviations in the crystal oscillator</li>
				<li><strong class="bold">External clock synchronization</strong>: The RTC can synchronize with an external clock source, enhancing accuracy by periodically adjusting the internal clock so that it matches the external reference</li>
			</ul>
			<p>These features ensure the RTC maintains precise timekeeping, even in varying environmental conditions. We also have the backup and control registers module.</p>
			<h3>Backup and control registers</h3>
			<p>The RTC module includes several backup<a id="_idIndexMarker1074"/> and control registers:</p>
			<ul>
				<li><strong class="bold">Backup registers</strong>: These registers <a id="_idIndexMarker1075"/>store critical data that must be retained even when the main power <a id="_idIndexMarker1076"/>supply is off</li>
				<li><code>RTC_CR</code>) manage the configuration and operation<a id="_idIndexMarker1077"/> of the RTC, including enabling the clock, setting alarms, and configuring wakeup events</li>
			</ul>
			<p>The backup and control registers module is indicated in the following figure:</p>
			<div><div><img src="img/B21914_15_6.jpg" alt="Figure 15.6: RTC block diagram – backup and control registers" width="1650" height="926"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.6: RTC block diagram – backup and control registers</p>
			<p>Finally, there is the output<a id="_idIndexMarker1078"/> control block.</p>
			<h3>Output control</h3>
			<p>The RTC module can output specific signals, such<a id="_idIndexMarker1079"/> as a calibration clock or alarm outputs, through the <code>RTC_AF1</code> pin. This allows the RTC module to interact with other components or systems, providing synchronized signals or triggering external events.</p>
			<p>In the next section, we will analyze some of the key registers for configuring the RTC peripheral.</p>
			<h1 id="_idParaDest-254"><a id="_idTextAnchor429"/>Some key RTC registers</h1>
			<p>In this section, we will explore the <a id="_idIndexMarker1080"/>characteristics and functions of some of the important registers within the RTC module. These registers are the building blocks that allow us to configure, control, and utilize the RTC’s features effectively. Let’s start with the <code>RTC_TR</code>).</p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor430"/>RTC Time Register (RTC_TR)</h2>
			<p>The <code>RTC_TR</code> register is responsible<a id="_idIndexMarker1081"/> for keeping track of the current time. It maintains the hours, minutes, and seconds in BCD format, ensuring that time is easily readable and manipulable. Here are some of the key fields in this register:</p>
			<ul>
				<li><strong class="bold">Hour tens (HT) and hour units (HU)</strong>: These bits represent the tens and units of the hour, respectively. They can handle both <strong class="bold">24-hour</strong> and <strong class="bold">12-hour</strong> formats.</li>
				<li><strong class="bold">Minute tens (MNT) and minute units (MNU)</strong>: These bits represent the tens and units of the minutes.</li>
				<li><strong class="bold">Second tens (ST) and second units (SU)</strong>: These bits represent the tens and units of the seconds.</li>
				<li><strong class="bold">PM</strong>: This bit indicates the <strong class="bold">AM/PM</strong> notation when in <strong class="bold">12-hour</strong> format.</li>
			</ul>
			<p>Further information about this register can be found on <em class="italic">page 450</em> of the <em class="italic">reference manual</em>. Let’s move on to the <code>RTC_DR</code>).</p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor431"/>RTC Date Register (RTC_DR)</h2>
			<p>The <code>RTC_DR</code> register is responsible for maintaining the current date. It keeps track of the year, month, day of the month, and day <a id="_idIndexMarker1082"/>of the week, all in BCD format.</p>
			<p>The following are the key fields in this register:</p>
			<ul>
				<li><strong class="bold">Year tens (YT) and year units YU)</strong>: These bits represent the tens and units of the year</li>
				<li><strong class="bold">Month tens (MT) and month units (MU)</strong>: These bits represent the tens and units of the month</li>
				<li><strong class="bold">Date tens (DT) and date units (DU)</strong>: These bits represent the tens and units of the day of the month</li>
				<li><strong class="bold">Week day units (WDU)</strong>: This bit represents the day of the week (1 to 7)</li>
			</ul>
			<p>You can read more about this register on <em class="italic">page 451</em> of the <em class="italic">reference manual</em>. The next crucial register is the <code>RTC_CR</code>).</p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor432"/>RTC Control Register (RTC_CR)</h2>
			<p>The <code>RTC_CR</code> register is<a id="_idIndexMarker1083"/> where we control the various operational modes and features of the RTC. This register allows us to enable the RTC, configure alarms, and set up the wakeup timer.</p>
			<p>Let’s consider the key bits in this register:</p>
			<ul>
				<li><strong class="bold">WUTE</strong>: Enable the wakeup timer. This bit enables the RTC wakeup timer.</li>
				<li><strong class="bold">TSE</strong>: Enable a timestamp event. This bit enables the timestamping of events.</li>
				<li><strong class="bold">ALRAE and ALRBE</strong>: Enable Alarm A and Alarm B. These bits enable the respective alarms.</li>
				<li><strong class="bold">DCE</strong>: Enable digital calibration. This bit enables digital calibration of the RTC clock.</li>
				<li><strong class="bold">FMT</strong>: Hour format. This bit sets the hour format to either 24-hour or 12-hour (AM/PM).</li>
			</ul>
			<p>Further details about this register can be fou<a id="_idTextAnchor433"/>nd on <em class="italic">page 453</em> of the <em class="italic">reference manual</em>. Next, we have the <code>RTC_ISR</code>).</p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor434"/>RTC Initialization and Status Register (RTC_ISR)</h2>
			<p>The <code>RTC_ISR</code> register plays a dual <a id="_idIndexMarker1084"/>role in both initializing the RTC and monitoring its status. This register is crucial during the setup process and for checking the RTC’s current state. Here are the key bits in this register:</p>
			<ul>
				<li><strong class="bold">INIT</strong>: Initialization mode. Setting this bit puts RTC into initialization mode.</li>
				<li><strong class="bold">RSF</strong>: Registers synchronization flag. This bit indicates that the calendar registers are synchronized.</li>
				<li><strong class="bold">INITS</strong>: Initialization status flag. This bit indicates whether the RTC calendar has been initialized.</li>
				<li><strong class="bold">ALRAF and ALRBF</strong>: Alarm A and Alarm B flags. These bits indicate whether an alarm has been triggered.</li>
			</ul>
			<p>Next, we<a id="_idIndexMarker1085"/> ha<a id="_idTextAnchor435"/>ve the <code>RTC_PRER</code>).</p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor436"/>RTC Prescaler Register (RTC_PRER)</h2>
			<p>The <code>RTC_PRER</code> register manages the<a id="_idIndexMarker1086"/> prescalers that divide the RTC clock source to produce the 1 Hz clock necessary for accurate timekeeping. There are two key fields in this register:</p>
			<ul>
				<li><strong class="bold">PREDIV_A</strong>: Asynchronous prescaler. This field sets the value for the asynchronous prescaler.</li>
				<li><strong class="bold">PREDIV_S</strong>: Synchronous prescaler. This field sets the value for the synchronous prescaler.</li>
			</ul>
			<p>Configuring the <code>RTC_PRER</code> register properly is vital for maintaining the accuracy of the RTC.</p>
			<p>Next, we’ll look at the RTC Alarm Registers, <code>RTC_ALRMAR</code> and <code>RTC_ALRMBR</code>.</p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor437"/>RTC Alarm Registers (RTC_ALRMAR and RTC_ALRMBR)</h2>
			<p>These registers handle the configuration of Alarms A and B. They allow us to set specific times when the alarms should trigger. Here are<a id="_idIndexMarker1087"/> the key fields in these registers:</p>
			<ul>
				<li><strong class="bold">ALRMASK</strong>: Alarm mask bits. These bits allow you to mask certain parts of the alarm time, providing flexibility in how and when the alarms trigger.</li>
				<li><strong class="bold">ALRH, ALRMN, and ALRS</strong>: Hour, minute, and second fields. These fields set the specific time for the alarm.</li>
			</ul>
			<p>The <code>RTC_ALRMAR</code> and <code>RTC_ALRMBR</code> registers are vital for applications requiring reliable, time-based event triggering. Lastly, let’s explore the <code>RTC_WUTR</code>).</p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor438"/>RTC Wakeup Timer Register (RTC_WUTR)</h2>
			<p>The <code>RTC_WUTR</code> register configures the wakeup timer, enabling the RTC to periodically wake the system from low-power <a id="_idIndexMarker1088"/>modes. The key field in this register is the <strong class="bold">wakeup auto-reload value</strong> (<strong class="bold">WUT</strong>). This field sets the interval for the wakeup timer.</p>
			<p>In the next section, we will apply everything we’ve learned in this section to develop a driver for the RTC peripheral.</p>
			<h1 id="_idParaDest-262"><a id="_idTextAnchor439"/>Developing the RTC driver</h1>
			<p>In this section, we will develop the RTC calendar driver so that we can configure and keep track of the time and <a id="_idIndexMarker1089"/>date.</p>
			<p>As always, we will create a copy of our previous project while following the steps outlined in earlier chapters. We rename this copied project to <code>RTC_Calendar</code>. Next, create a new file named <code>rtc.c</code> in the <code>Src</code> folder and another file named <code>rtc.h</code> in the <code>Inc</code> folder. The RTC configuration can be quite elaborate, so we will create several helper functions to modularize the initialization process.</p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor440"/>The RTC implementation file</h2>
			<p>Let’s begin by <a id="_idIndexMarker1090"/>populating the <code>rtc.c</code> file, starting with the helper functions necessary for the initialization function. Here are the macro definitions that we will use in the RTC configuration:</p>
			<pre class="source-code">
#include "rtc.h"
#define PWREN        (1U &lt;&lt; 28)
#define CR_DBP       (1U &lt;&lt; 8)
#define CSR_LSION    (1U &lt;&lt; 0)
#define CSR_LSIRDY   (1U &lt;&lt; 1)
#define BDCR_BDRST   (1U &lt;&lt; 16)
#define BDCR_RTCEN   (1U &lt;&lt; 15)
#define RTC_WRITE_PROTECTION_KEY_1 ((uint8_t)0xCAU)
#define RTC_WRITE_PROTECTION_KEY_2 ((uint8_t)0x53U)
#define RTC_INIT_MASK               0xFFFFFFFFU
#define ISR_INITF                   (1U &lt;&lt; 6)
#define WEEKDAY_FRIDAY              ((uint8_t)0x05U)
#define MONTH_DECEMBER              ((uint8_t)0x12U)
#define TIME_FORMAT_PM              (1U &lt;&lt; 22)
#define CR_FMT                      (1U &lt;&lt; 6)
#define ISR_RSF                     (1U &lt;&lt; 5)
#define RTC_ASYNCH_PREDIV           ((uint32_t)0x7F)
#define RTC_SYNCH_PREDIV            ((uint32_t)0x00F9)</pre>			<p>Let’s break them down:</p>
			<ul>
				<li><code>PWREN</code> (<code>1U &lt;&lt; 28</code>): This macro enables the clock for the PWR module by setting bit 28 in the APB1 peripheral clock enable register.</li>
				<li><code>CR_DBP</code> (<code>1U &lt;&lt; 8</code>): This <a id="_idIndexMarker1091"/>enables access to the backup domain by setting bit 8 in the PWR register.</li>
				<li><code>CSR_LSION</code> (<code>1U &lt;&lt; 0</code>): This macro enables the LSI oscillator by setting bi<a id="_idTextAnchor441"/>t 0 in the Clock Control &amp; Status Register.</li>
				<li><code>CSR_LSIRDY</code> (<code>1U &lt;&lt; 1</code>): This macro is used to read the state of the <code>LSI</code> register. The LSIRDY bit is set to 1 when the LSI is stable and ready to be used.</li>
				<li><code>BDCR_BDRST</code> (<code>1U &lt;&lt; 16</code>): This macro forces a reset of the backup domain by setting bit 16 in the Backup Domain Control Register.</li>
				<li><code>BDCR_RTCEN</code> (<code>1U &lt;&lt; 15</code>): This enables RTC by setting bit 15 in the Backup Domain Control Register.</li>
				<li><code>RTC_WRITE_PROTECTION_KEY_1</code> (<code>(uint8_t)0xCAU</code>): This key is used to disable write protection on the RTC registers.</li>
				<li><code>RTC_WRITE_PROTECTION_KEY_2</code> (<code>(uint8_t)0x53U</code>): This is the second key needed to disable write protection on the RTC registers.</li>
				<li><code>RTC_INIT_MASK</code> (<code>0xFFFFFFFFU</code>): This mask is used to enter initialization mode in the RTC peripheral.</li>
				<li><code>ISR_INITF</code> (<code>1U &lt;&lt; 6</code>): This bit in the <code>ISR</code> register indicates that the RTC peripheral is in initialization mode.</li>
				<li><code>WEEKDAY_FRIDAY</code> (<code>(uint8_t)0x05U</code>): This macro is used to configure the weekday of the calendar to Friday.</li>
				<li><code>MONTH_DECEMBER</code> (<code>(uint8_t)0x12U</code>): This macro is used to configure the month of the calendar to <a id="_idIndexMarker1092"/>December.</li>
				<li><code>TIME_FORMAT_PM</code> (<code>1U &lt;&lt; 22</code>): This macro sets the time format to PM in the 12-hour format.</li>
				<li><code>CR_FMT</code> (<code>1U &lt;&lt; 6</code>): This macro sets the hour format to 24-hour format in the RTC control register (<code>RTC-&gt;CR</code>).</li>
				<li><code>ISR_RSF</code> (<code>1U &lt;&lt; 5</code>): This bit in the <code>ISR</code> register indicates that the RTC registers are synchronized.</li>
				<li><code>RTC_ASYNCH_PREDIV</code> (<code>(uint32_t)0x7F</code>): This value sets the asynchronous prescaler for the RTC peripheral and is used to divide the clock frequency.</li>
				<li><code>RTC_SYNCH_PREDIV</code> (<code>(uint32_t)0x00F9</code>): This value sets the synchronous prescaler for the RTC peripheral and is used to further divide the clock frequency for timekeeping accuracy.</li>
			</ul>
			<p>Let’s examine the two functions responsible for setting the prescaler values for the RTC peripheral.</p>
			<p>First, we have <code>rtc_set_asynch_prescaler</code>:</p>
			<pre class="source-code">
static void rtc_set_asynch_prescaler(uint32_t AsynchPrescaler)
{
  MODIFY_REG(RTC-&gt;PRER, RTC_PRER_PREDIV_A, AsynchPrescaler &lt;&lt; RTC_
  PRER_PREDIV_A_Pos);
}</pre>			<p>This function sets the<a id="_idIndexMarker1093"/> asynchronous prescaler value for the RTC peripheral. Let’s break it down:</p>
			<ul>
				<li><code>MODIFY_REG</code>: This macro modifies specific bits in a register. It is defined in the <code>stm32f4xx.h</code> header file.</li>
				<li><code>RTC-&gt;PRER</code>: The <code>PRER</code> register of the RTC.</li>
				<li><code>RTC_PRER_PREDIV_A</code>: The mask for the asynchronous prescaler bits in the <code>PRER</code> register.</li>
				<li><code>AsynchPrescaler &lt;&lt; RTC_PRER_PREDIV_A_Pos</code>: This snippet shifts the <code>AsynchPrescaler</code> value to the correct position within the <code>PRER</code> register.</li>
			</ul>
			<p>In short, this function configures the asynchronous prescaler by updating the appropriate bits in the <code>PRER</code> register. Next, we have the function for setting the synchronous prescaler – that is, <code>rtc_set_synch_prescaler</code>:</p>
			<pre class="source-code">
static void rtc_set_synch_prescaler(uint32_t SynchPrescaler)
{
  MODIFY_REG(RTC-&gt;PRER, RTC_PRER_PREDIV_S, SynchPrescaler);
}</pre>			<p>This function configures the synchronous prescaler by updating the appropriate bits in the <code>PRER</code> register:</p>
			<ul>
				<li><code>RTC-&gt;PRER</code>: The <code>PRER</code> register of the RTC</li>
				<li><code>RTC_PRER_PREDIV_S</code>: This is the mask for the synchronous prescaler bits in the <code>PRER</code> register</li>
				<li><code>SynchPrescaler</code>: This directly sets the synchronous prescaler value in the <code>PRER</code> register</li>
			</ul>
			<p>Next, we must analyze the other RTC initialization helper functions to understand how they work together to <a id="_idIndexMarker1094"/>configure and synchronize the RTC peripheral.</p>
			<p>First, we have the <code>_rtc_enable_init_mode</code> function:</p>
			<pre class="source-code">
void _rtc_enable_init_mode(void)
{
    RTC-&gt;ISR = RTC_INIT_MASK;
}</pre>			<p>Simply put, this function sets the RTC peripheral to initialization mode by writing the initialization mask to the <code>ISR</code> register:</p>
			<ul>
				<li><code>RTC-&gt;ISR</code>: This is the <code>RTC_ISR</code> register of the RTC</li>
				<li><code>RTC_INIT_MASK</code>: This mask is used to enter initialization mode</li>
			</ul>
			<p>Next, we have <code>_rtc_disable_init_mode</code>:</p>
			<pre class="source-code">
void _rtc_disable_init_mode(void)
{
    RTC-&gt;ISR = ~RTC_INIT_MASK;
}</pre>			<p>This function disables initialization mode by clearing the initialization mask in the ISR register. Here, <code>~RTC_INIT_MASK</code> clears the initialization mask, exiting initialization mode.</p>
			<p>The next helper function is <code>_rtc_isActiveflag_init</code>:</p>
			<pre class="source-code">
uint8_t _rtc_isActiveflag_init(void)
{
    return ((RTC-&gt;ISR &amp; ISR_INITF) == ISR_INITF);
}</pre>			<p>This function returns 1 if the RTC peripheral is in initialization mode by checking the <code>ISR_INITF</code> bit, which indicates <a id="_idTextAnchor442"/>that the RTC peripheral is in initialization mode.</p>
			<p>Next, we have <code>_rtc_isActiveflag_rs</code>:</p>
			<pre class="source-code">
uint8_t _rtc_isActiveflag_rs(void)
{
    return ((RTC-&gt;ISR &amp; ISR_RSF) == ISR_RSF);
}</pre>			<p>This function returns 1 if the RTC registers are synchronized by checking the <code>ISR_RSF</code> bit, which indicates that the<a id="_idIndexMarker1095"/> RTC registers are synchronized.</p>
			<p>There’s also the <code>rtc_init_seq</code> function:</p>
			<pre class="source-code">
static uint8_t rtc_init_seq(void)
{
    /* Start init mode */
    _rtc_enable_init_mode();
    /* Wait till we are in init mode */
    while (_rtc_isActiveflag_init() != 1) {}
    return 1;
}</pre>			<p>This function starts the RTC initialization by enabling initialization mode and waiting until the RTC peripheral enters initialization mode:</p>
			<ul>
				<li><code>_rtc_enable_init_mode</code>: This line puts the RTC peripheral into initialization mode</li>
				<li><code>_rtc_isActiveflag_init</code>: This line waits until the RTC peripheral is in initialization mode</li>
			</ul>
			<p>Next, we have <a id="_idIndexMarker1096"/>the <code>wait_for_synchro</code> function:</p>
			<pre class="source-code">
static uint8_t wait_for_synchro(void)
{
    /* Clear RSF */
    RTC-&gt;ISR &amp;= ~ISR_RSF;
    /* Wait for registers to synchronize */
    while (_rtc_isActiveflag_rs() != 1) {}
    return 1;
}</pre>			<p>This function clears the synchronization flag and waits until the RTC registers are synchronized.</p>
			<p>We also have the <code>exit_init_seq</code> function:</p>
			<pre class="source-code">
static uint8_t exit_init_seq(void)
{
    /* Stop init mode */
    _rtc_disable_init_mode();
    /* Wait for registers to synchronize */
    return (wait_for_synchro());
}</pre>			<p>This function exits the RTC initialization mode and waits for the registers to synchronize to ensure everything is <a id="_idIndexMarker1097"/>set up correctly. Now, let’s see the functions for configuring the date and time.</p>
			<p>First, we have <code>rtc_date_config</code>:</p>
			<pre class="source-code">
static void rtc_date_config(uint32_t WeekDay, uint32_t Day, uint32_t Month, uint32_t Year)
{
  register uint32_t temp = 0U;
  temp = (WeekDay &lt;&lt; RTC_DR_WDU_Pos) |\
         (((Year &amp; 0xF0U) &lt;&lt; (RTC_DR_YT_Pos - 4U)) | 
         ((Year &amp; 0x0FU) &lt;&lt; RTC_DR_YU_Pos)) |\
         (((Month &amp; 0xF0U) &lt;&lt; (RTC_DR_MT_Pos - 4U)) | 
         ((Month &amp; 0x0FU) &lt;&lt; RTC_DR_MU_Pos)) |\
         (((Day &amp; 0xF0U) &lt;&lt; (RTC_DR_DT_Pos - 4U)) | 
         ((Day &amp; 0x0FU) &lt;&lt; RTC_DR_DU_Pos));
  MODIFY_REG(RTC-&gt;DR, (RTC_DR_WDU | RTC_DR_MT | RTC_DR_MU | RTC_DR_DT 
  | RTC_DR_DU | RTC_DR_YT | RTC_DR_YU), temp);
}</pre>			<p>This function sets the date in the RTC peripheral.</p>
			<p>We begin by creating a temporary variable called <code>temp</code> to hold the date value. This variable is carefully constructed by shifting and combining the weekday, day, month, and year into the appropriate positions for the RTC’s date register. The <code>MODIFY_REG</code> macro is then used to update the RTC’s date register with this new value. Here, we can have the following values:</p>
			<ul>
				<li><code>WeekDay</code>: Represents the day of the week</li>
				<li><code>Day</code>: Represents the day of the month</li>
				<li><code>Month</code>: Represents the month of the year</li>
				<li><code>Year</code>: Represents the year</li>
			</ul>
			<p>In essence, <code>rtc_date_config</code> takes the date components, assembles them into a single value, and writes it to the RTC’s date <a id="_idIndexMarker1098"/>register, ensuring the RTC peripheral accurately tracks the current date.</p>
			<p>We have the <code>rtc_time_config</code> function for configuring the time:</p>
			<pre class="source-code">
static void rtc_time_config(uint32_t Format12_24, uint32_t Hours, uint32_t Minutes, uint32_t Seconds)
{
  register uint32_t temp = 0U;
  temp = Format12_24 |\
         (((Hours &amp; 0xF0U) &lt;&lt; (RTC_TR_HT_Pos - 4U)) | 
         ((Hours &amp; 0x0FU) &lt;&lt; RTC_TR_HU_Pos)) |\
         (((Minutes &amp; 0xF0U) &lt;&lt; (RTC_TR_MNT_Pos - 4U)) | 
         ((Minutes &amp; 0x0FU) &lt;&lt; RTC_TR_MNU_Pos)) |\
         (((Seconds &amp; 0xF0U) &lt;&lt; (RTC_TR_ST_Pos - 4U)) | 
         ((Seconds &amp; 0x0FU) &lt;&lt; RTC_TR_SU_Pos));
  MODIFY_REG(RTC-&gt;TR, (RTC_TR_PM | RTC_TR_HT | RTC_TR_HU | RTC_TR_MNT 
  | RTC_TR_MNU | RTC_TR_ST | RTC_TR_SU), temp);
}</pre>			<p>This function sets the time in the RTC peripheral. Much like the date configuration, <code>rtc_time_config</code> begins by initializing a temporary variable, <code>temp</code>, to hold the time value. The time components – format, hours, minutes, and seconds – are then combined into this variable. The <code>MODIFY_REG</code> macro updates the RTC’s time register with the newly constructed time value. Here, we have the following additional values:</p>
			<ul>
				<li><code>Format12_24</code>: This determines whether the time is in 12-hour or 24-hour format</li>
				<li><code>Hours</code>: Represents the hour value</li>
				<li><code>Minutes</code>: Represents the minute value</li>
				<li><code>Seconds</code>: Represents the second value</li>
			</ul>
			<p>Now that we’ve implemented<a id="_idIndexMarker1099"/> all the helper functions required for initialization, let’s go ahead and implement the <code>rtc_init()</code> function:</p>
			<pre class="source-code">
void rtc_init(void)
{
    /* Enable clock access to PWR */
    RCC-&gt;APB1ENR |= PWREN;
    /* Enable Backup access to config RTC */
    PWR-&gt;CR |= CR_DBP;
    /* Enable Low Speed Internal (LSI) */
    RCC-&gt;CSR |= CSR_LSION;
    /* Wait for LSI to be ready */
    while((RCC-&gt;CSR &amp; CSR_LSIRDY) != CSR_LSIRDY) {}
    /* Force backup domain reset */
    RCC-&gt;BDCR |= BDCR_BDRST;
    /* Release backup domain reset */
    RCC-&gt;BDCR &amp;= ~BDCR_BDRST;
    /* Set RTC clock source to LSI */
    RCC-&gt;BDCR &amp;= ~(1U &lt;&lt; 8);
    RCC-&gt;BDCR |= (1U &lt;&lt; 9);
    /* Enable the RTC */
    RCC-&gt;BDCR |= BDCR_RTCEN;
    /* Disable RTC registers write protection */
    RTC-&gt;WPR = RTC_WRITE_PROTECTION_KEY_1;
    RTC-&gt;WPR = RTC_WRITE_PROTECTION_KEY_2;
    /* Enter the initialization mode */
    if(rtc_init_seq() != 1)
    {
        // Handle initialization failure
    }
    /* Set desired date: Friday, December 29th, 2016 */
    rtc_date_config(WEEKDAY_FRIDAY, 0x29, MONTH_DECEMBER, 0x16);
    /* Set desired time: 11:59:55 PM */
    rtc_time_config(TIME_FORMAT_PM, 0x11, 0x59, 0x55);
    /* Set hour format */
    RTC-&gt;CR |= CR_FMT;
    /* Set Asynchronous prescaler */
    rtc_set_asynch_prescaler(RTC_ASYNCH_PREDIV);
    /* Set Synchronous prescaler */
    rtc_set_synch_prescaler(RTC_SYNCH_PREDIV);
    /* Exit the initialization mode */
    exit_init_seq();
    /* Enable RTC registers write protection */
    RTC-&gt;WPR = 0xFF;
}</pre>			<p>Let’s break it down:</p>
			<pre class="source-code">
RCC-&gt;APB1ENR |= PWREN;</pre>			<p>We start by enabling the clock for the PWR module. This is crucial as it allows us to access and configure the RTC peripheral:</p>
			<pre class="source-code">
PWR-&gt;CR |= CR_DBP;</pre>			<p>Next, we must enable<a id="_idIndexMarker1100"/> access to the backup domain. This step is necessary to make changes to the RTC configuration:</p>
			<pre class="source-code">
RCC-&gt;CSR |= CSR_LSION;</pre>			<p>Then, we enable the LSI oscillator, which serves as the clock source for the RTC peripheral:</p>
			<pre class="source-code">
while((RCC-&gt;CSR &amp; CSR_LSIRDY) != CSR_LSIRDY) {}</pre>			<p>We must wait until the LSI oscillator is stable and ready to use:</p>
			<pre class="source-code">
RCC-&gt;BDCR |= BDCR_BDRST;</pre>			<p>To ensure a clean configuration, we must force a reset of the backup domain:</p>
			<pre class="source-code">
RCC-&gt;BDCR &amp;= ~BDCR_BDRST;</pre>			<p>Then, we must release the reset, allowing the backup domain to function normally:</p>
			<pre class="source-code">
RCC-&gt;BDCR &amp;= ~(1U &lt;&lt; 8);
RCC-&gt;BDCR |= (1U &lt;&lt; 9);</pre>			<p>After, we must configure<a id="_idIndexMarker1101"/> the RTC peripheral so that it uses the LSI oscillator as its clock source:</p>
			<pre class="source-code">
RCC-&gt;BDCR |= BDCR_RTCEN;</pre>			<p>Then, we must enable the RTC peripheral by setting the appropriate bit in the backup domain control register:</p>
			<pre class="source-code">
RTC-&gt;WPR = RTC_WRITE_PROTECTION_KEY_1;
RTC-&gt;WPR = RTC_WRITE_PROTECTION_KEY_2;</pre>			<p>To allow changes to the RTC registers, we must disable write protection:</p>
			<pre class="source-code">
if(rtc_init_seq() != 1)
{
    // Handle initialization failure
}</pre>			<p>We can enter initialization mode using our <code>rtc_init_seq()</code> helper function. If it fails, we must handle the error appropriately:</p>
			<pre class="source-code">
rtc_date_config(WEEKDAY_FRIDAY, 0x29, MONTH_DECEMBER, 0x16);</pre>			<p>At this point, we must configure the RTC peripheral to the desired date using another one of our helper functions. In this example, we will set the date to <em class="italic">Friday, December </em><em class="italic">29, 2016</em>:</p>
			<pre class="source-code">
rtc_time_config(TIME_FORMAT_PM, 0x11, 0x59, 0x55);</pre>			<p>Then, we must set the RTC peripheral to the desired time. In this case, we will set the time to <em class="italic">11:59:55 P.M.</em>:</p>
			<pre class="source-code">
RTC-&gt;CR |= CR_FMT;</pre>			<p>Next, we must configure the RTC peripheral so that it uses a 24-hour format:</p>
			<pre class="source-code">
rtc_set_asynch_prescaler(RTC_ASYNCH_PREDIV);
rtc_set_synch_prescaler(RTC_SYNCH_PREDIV);</pre>			<p>Then, we must set the asynchronous and synchronous prescaler values:</p>
			<pre class="source-code">
exit_init_seq();</pre>			<p>At this point, we can exit initialization mode using the <code>exit_init_seq()</code> helper function we created earlier:</p>
			<pre class="source-code">
RTC-&gt;WPR = 0xFF;</pre>			<p>Finally, we must re-enable write protection on the RTC registers to prevent accidental changes.</p>
			<p>This <code>rtc_init</code> function<a id="_idIndexMarker1102"/> meticulously sets up the RTC peripheral by enabling the necessary clock, configuring the backup domain, setting the RTC clock source, and initializing the date and time.</p>
			<p>Before moving on to the <code>main.c</code> file, let’s implement a few helper functions that are essential for handling various RTC tasks, such as converting values and getting the current date and time.</p>
			<p>Let’s start with the <code>rtc_convert_dec2bcd</code> function:</p>
			<pre class="source-code">
uint8_t rtc_convert_dec2bcd(uint8_t value)
{
    return (uint8_t)((((value) / 10U) &lt;&lt; 4U) | ((value) % 10U));
}</pre>			<p>This function takes a decimal value and returns its equivalent in BCD format, which is useful for setting RTC values.</p>
			<p>Let’s take a closer look at decimal to BCD conversion:</p>
			<ul>
				<li>First, <code>((value) / 10U) &lt;&lt; 4U</code> shifts the tens digit to the left by 4 bits</li>
				<li>Then, <code>((value) % 10U)</code> gets the units digit</li>
				<li>The <code>OR</code> operation combines these two to form the BCD value</li>
			</ul>
			<p>Before going any further, let’s take a closer look at the BCD format and the conversion process.</p>
			<h2 id="_idParaDest-264"><a id="_idTextAnchor443"/>Understanding BCD format</h2>
			<p>BCD is a way of representing <a id="_idIndexMarker1103"/>decimal numbers in binary form. But here’s the twist: instead of <a id="_idIndexMarker1104"/>converting the whole number into a single binary value, each decimal digit is represented by its own binary sequence.</p>
			<h3>How does BCD work?</h3>
			<p>In BCD, each digit of a decimal number is encoded <a id="_idIndexMarker1105"/>separately as a 4-bit binary number. Let’s break it down with an example to make it clearer.</p>
			<p>Say you have the decimal number <em class="italic">42</em>. In BCD, this would be represented as follows:</p>
			<ul>
				<li><em class="italic">4</em> in decimal is <em class="italic">0100</em> in binary</li>
				<li><em class="italic">2</em> in decimal is <em class="italic">0010</em> in binary</li>
			</ul>
			<p>So, 42 in BCD is <em class="italic">0100 0010</em>. Notice how each decimal digit is converted into a 4-bit binary form and then combined to represent the entire number.</p>
			<h3>Why use BCD?</h3>
			<p>You might be wondering, why not just use regular binary? Well, BCD has its perks, especially in digital systems that need to display numbers or interface with human-readable formats:</p>
			<ul>
				<li><strong class="bold">Ease of conversion</strong>: Converting<a id="_idIndexMarker1106"/> between BCD and decimal is straightforward. Each 4-bit group corresponds directly to a decimal digit, making it easy to read and convert.</li>
				<li><strong class="bold">Display compatibility</strong>: Devices such as digital clocks, calculators, and other numeric displays often use BCD because it simplifies the process of converting binary values into a form that can be easily shown on a screen.</li>
			</ul>
			<p>Now, let’s see how this relates to RTCs.</p>
			<h3>BCD in RTC configurations</h3>
			<p>When working with RTCs, BCD is particularly handy. The RTC hardware often uses BCD to store time and date values<a id="_idIndexMarker1107"/> because it simplifies how these values can be displayed and manipulated. For instance, setting the time to <em class="italic">12:34:56</em> in BCD means we have the following representations:</p>
			<ul>
				<li><em class="italic">12</em> is <em class="italic">0001 0010</em></li>
				<li><em class="italic">34</em> is <em class="italic">0011 0100</em></li>
				<li><em class="italic">56</em> is <em class="italic">0101 0110</em></li>
			</ul>
			<p>Each of these pairs is easy to interpret and convert back into decimal for display or further processing.</p>
			<p>BCD format is a clever way of encoding decimal numbers in a binary system. By handling each decimal digit separately, BCD simplifies many operations, especially when interfacing with human-readable displays or systems that require precise decimal representation. <em class="italic">Figure 15</em><em class="italic">.6</em> illustrates how BCD values can easily be mapped onto digital displays:</p>
			<div><div><img src="img/B21914_15_7.jpg" alt="Figure 15.7: Display with BCD format" width="1323" height="802"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.7: Display with BCD format</p>
			<p>Now, let’s analyze the <code>rtc_convert_bcd2dec</code> function:</p>
			<pre class="source-code">
uint8_t rtc_convert_bcd2dec(uint8_t value)
{
    return (uint8_t)(((uint8_t)((value) &amp; (uint8_t)0xF0U) &gt;&gt; 
    (uint8_t)0x4U) * 10U + ((value) &amp; (uint8_t)0x0FU));
}</pre>			<p>This function takes a BCD value and returns its decimal equivalent, making it easier to work with RTC data in a decimal format.</p>
			<p>Here’s the BCD to decimal conversion for this:</p>
			<ul>
				<li>First, <code>((value) &amp; (uint8_t)0xF0U) &gt;&gt; (uint8_t)0x4U</code> extracts the tens digit</li>
				<li>Then, <code>((value) &amp; (uint8_t)0x0FU)</code> extracts the units digit</li>
				<li>Multiplication and addition combine these to form the binary value</li>
			</ul>
			<p>Next, we have a helper<a id="_idIndexMarker1108"/> function for getting the day – that is, <code>rtc_date_get_day</code>:</p>
			<pre class="source-code">
uint32_t rtc_date_get_day(void)
{
    return (uint32_t)((READ_BIT(RTC-&gt;DR, (RTC_DR_DT | RTC_DR_DU))) &gt;&gt; 
    RTC_DR_DU_Pos);
}</pre>			<p>This function reads the RTC date register and returns the current day of the month.</p>
			<p>We can read the day by using <code>READ_BIT(RTC-&gt;DR, (RTC_DR_DT | RTC_DR_DU))</code>, which reads the day tens and units bits.</p>
			<p>Shifting the result to the right positions the value correctly.</p>
			<p>We also have a function for the year – that is, <code>rtc_date_get_year</code>:</p>
			<pre class="source-code">
uint32_t rtc_date_get_year(void)
{
    return (uint32_t)((READ_BIT(RTC-&gt;DR, (RTC_DR_YT | RTC_DR_YU))) &gt;&gt; 
    RTC_DR_YU_Pos);
}</pre>			<p>This function reads the RTC date register and returns the current year.</p>
			<p>Here, <code>READ_BIT(RTC-&gt;DR, (RTC_DR_YT | RTC_DR_YU))</code> reads the year tens and units bits.</p>
			<p>We also have functions for retrieving the month, second, minute, and hour, all of which are implemented using the <a id="_idIndexMarker1109"/>same approach as the other getter functions:</p>
			<ul>
				<li>First, we have <code>rtc_date_get_month</code>:<pre class="source-code">
uint32_t rtc_date_get_month(void)
{
    return (uint32_t)((READ_BIT(RTC-&gt;DR, (RTC_DR_MT | RTC_DR_
    MU))) &gt;&gt; RTC_DR_MU_Pos);
}</pre></li>				<li>Then, we have <code>rtc_time_get_second</code>:<pre class="source-code">
uint32_t rtc_time_get_second(void)
{
    return (uint32_t)(READ_BIT(RTC-&gt;TR, (RTC_TR_ST | RTC_TR_SU)) 
    &gt;&gt; RTC_TR_SU_Pos);
}</pre></li>				<li>Next, there’s <code>rtc_time_get_minute</code>:<pre class="source-code">
uint32_t rtc_time_get_minute(void)
{
    return (uint32_t)(READ_BIT(RTC-&gt;TR, (RTC_TR_MNT | RTC_TR_
    MNU)) &gt;&gt; RTC_TR_MNU_Pos);
}</pre></li>				<li>Finally, there’s <code>rtc_time_get_hour</code>:<pre class="source-code">
uint32_t rtc_time_get_hour(void)
{
    return (uint32_t)((READ_BIT(RTC-&gt;TR, (RTC_TR_HT | RTC_TR_
    HU))) &gt;&gt; RTC_TR_HU_Pos);
}</pre></li>			</ul>
			<p>With all of these <a id="_idIndexMarker1110"/>functions implemented, our <code>rtc.c</code> file is complete. Our next task is to populate the <code>rtc.h</code> file.</p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor444"/>The header file</h2>
			<p>Here’s the<a id="_idIndexMarker1111"/> code:</p>
			<pre class="source-code">
<strong class="bold">#ifndef</strong> RTC_H__
<strong class="bold">#define</strong> RTC_H__
<strong class="bold">#include</strong> &lt;stdint.h&gt;
<strong class="bold">#include</strong> "stm32f4xx.h"
<strong class="bold">void rtc_init</strong>(<strong class="bold">void</strong>);
uint8_t <code>rtc_convert_bcd2dec</code>(uint8_t value);
uint32_t <code>rtc_date_get_day</code>(<code>void</code>);
uint32_t <code>rtc_date_get_year</code>(<code>void</code>);
uint32_t <code>rtc_date_get_month</code>(<code>void</code>);
uint32_t <code>rtc_time_get_second</code>(<code>void</code>);
uint32_t <code>rtc_time_get_minute</code>(<code>void</code>);
uint32_t <code>rtc_time_get_hour</code>(<code>void</code>);
<code>#endif</code></pre>			<p>Here, we’re simply exposing the functions implemented in <code>rtc.c</code>, making them callable from other files. Let’s<a id="_idIndexMarker1112"/> go ahead and test our driver’s <code>main.c</code> file.</p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor445"/>The main file</h2>
			<p>Let’s update the <code>main.c</code> file so<a id="_idIndexMarker1113"/> that it looks like this:</p>
			<pre class="source-code">
#include &lt;stdio.h&gt;
#include "rtc.h"
#include "uart.h"
#define BUFF_LEN        20
uint8_t time_buff[BUFF_LEN] = {0};
uint8_t date_buff[BUFF_LEN] = {0};
static void display_rtc_calendar(void);
int main(void)
{
    /*Initialize debug UART*/
    uart_init();
    /*Initialize rtc*/
    rtc_init();
    while(1)
    {
        display_rtc_calendar();
    }
}
static void display_rtc_calendar(void)
{
    /*Display format :  hh : mm : ss*/
    sprintf((char *)time_buff,"%.2d :%.2d :%.2d",rtc_convert_
    bcd2dec(rtc_time_get_hour()),
            rtc_convert_bcd2dec(rtc_time_get_minute()),
            rtc_convert_bcd2dec(rtc_time_get_second()));
    printf("Time : %.2d :%.2d :%.2d\n\r",rtc_convert_bcd2dec(rtc_time_
    get_hour()),
            rtc_convert_bcd2dec(rtc_time_get_minute()),
            rtc_convert_bcd2dec(rtc_time_get_second()));
    /*Display format :  mm : dd : yy*/
    sprintf((char *)date_buff,"%.2d - %.2d - %.2d",rtc_convert_
    bcd2dec(rtc_date_get_month()),
            rtc_convert_bcd2dec(rtc_date_get_day()),
            rtc_convert_bcd2dec(rtc_date_get_year()));
    printf("Date : %.2d - %.2d - %.2d    ",rtc_convert_bcd2dec(rtc_
    date_get_month()),
            rtc_convert_bcd2dec(rtc_date_get_day()),
            rtc_convert_bcd2dec(rtc_date_get_year()));
}</pre>			<p>Let’s break down the unique aspects of the code, starting with the <code>display_rtc_calendar</code> function. This function retrieves the current time and date from the RTC peripheral, formats <a id="_idIndexMarker1114"/>these values, prints them out, and stores them in a buffer for further processing.</p>
			<p>The followi<a id="_idTextAnchor446"/>ng are our buffer definitions:</p>
			<pre class="source-code">
#define BUFF_LEN 20
uint8_t time_buff[BUFF_LEN] = {0};
uint8_t date_buff[BUFF_LEN] = {0};</pre>			<p>Here, we can see the following:</p>
			<ul>
				<li><code>BUFF_LEN</code>: This defines the length of the buffer for storing the time and date string</li>
				<li><code>time_buff</code>: This is an array that holds the formatted time string</li><li><code>date_buff</code>: This is an array that holds the formatted date string</li></ul></li>
			</ul>
			<p>Let’s take a closer look at the time formatting and display block:</p>
			<pre class="source-code">
sprintf((char *)time_buff, "%.2d :%.2d :%.2d",
        rtc_convert_bcd2dec(rtc_time_get_hour()),
        rtc_convert_bcd2dec(rtc_time_get_minute()),
        rtc_convert_bcd2dec(rtc_time_get_second()));
printf("Time : %.2d :%.2d :%.2d\n\r",rtc_convert_bcd2dec(rtc_time_get_hour()),
            rtc_convert_bcd2dec(rtc_time_get_minute()),
            rtc_convert_bcd2dec(rtc_time_get_second()));</pre>			<p>Here, we can see the following:</p>
			<ul>
				<li> <code>sprintf</code>: This is used to format the time string into <code>time_buff</code></li>
				<li> <code>rtc_convert_bcd2dec</code>: This converts the BCD values from RTC into decimal</li>
				<li><code>rtc_time_get_hour</code>, <code>rtc_time_get_minute</code>, and <code>rtc_time_get_second</code>: These retrieve the current hour, minute, and second from the RTC peripheral, respectively</li>
				<li><code>printf</code>: This function is used to print formatted output to the serial port</li>
				<li><code>%.2d</code>: This format <a id="_idIndexMarker1115"/>specifier means that the integer will be printed with at least 2 digits, padding with leading zeros if necessary</li>
			</ul>
			<p>We’re now ready to test our RTC calendar driver on the microcontroller. We can test the project by following these steps:</p>
			<ol>
				<li>Compile and upload the project to your microcontroller.</li>
				<li>Launch RealTerm or your preferred serial terminal program.</li>
				<li>Configure the appropriate port and baud rate.</li>
				<li>You should see the time and date values printed and updating in real time, as shown in <em class="italic">Figure 15</em><em class="italic">.7</em>:</li>
			</ol>
			<div><div><img src="img/B21914_15_8.jpg" alt="Figure 15.8: Expected results" width="1028" height="712"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.8: Expected results</p>
			<h1 id="_idParaDest-267"><a id="_idTextAnchor447"/>Summary</h1>
			<p>In this chapter, we explored the RTC peripheral, a component for timekeeping in embedded systems. This peripheral is essential for applications requiring precise time and date maintenance, making it fundamental for a wide range of embedded applications.</p>
			<p>We began by introducing RTCs and understanding their functionality. This included a deep dive into how RTCs operate, which involved focusing on the crystal oscillator, counters, time and date registers, and the importance of battery backup. We illustrated these concepts with case studies, showcasing the practical use of RTCs in data logging, alarm clocks, time-stamping transactions, and calendar functions.</p>
			<p>Following this, we examined the STM32 RTC module, highlighting its key features and capabilities. We discussed the calendar in terms of sub-seconds accuracy, dual programmable alarms, low power consumption, backup domain, daylight saving time adjustments, automatic wakeup, tamper detection, digital calibration, and synchronization with external clocks. Each feature was detailed to show its application and importance in maintaining accurate timekeeping.</p>
			<p>Next, we analyzed the relevant registers from the STM32 reference manual, providing a detailed understanding of the configuration and operation of the RTC. We covered the <code>RTC_TR</code>, <code>RTC_DR</code>, <code>RTC_CR</code>, <code>RTC_ISR</code>, <code>RTC_PRER</code>, <code>RTC_ALRMAR</code>, <code>RTC_ALRMBR</code>, and <code>RTC_WUTR</code> registers. Each register’s role and key fields were explained to ensure you have a comprehensive grasp of how they contribute to the RTC’s functionality.</p>
			<p>Finally, we applied this knowledge to develop an RTC driver. We walked through the steps to create and configure the RTC driver, starting with the initialization sequence and covering functions to set the date and time. We also implemented helper functions for converting values between decimal and BCD formats, as well as retrieving current time and date values from the RTC peripheral.</p>
			<p>In the next chapter, we will delve into another useful peripheral, expanding our knowledge and toolkit for embedded systems development.</p>
		</div>
	</div>
</div>
</body></html>