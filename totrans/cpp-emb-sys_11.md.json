["```cpp\n#include <cstdio>\ntemplate<typename T>\nT add(T a, T b) {\n   return a + b;\n}\nint main() {\n    int result_int = add(1, 4);\n    float result_float = add(1.11f, 1.91f);\n    printf(\"result_int = %d\\r\\n\", result_int);\n    printf(\"result_float = %.2f\\r\\n\", result_float);\n    return 0;\n} \n```", "```cpp\n_Z3addIiET_S0_S0_:\n        push    rbp\n        mov     rbp, rsp\n        mov     DWORD PTR [rbp-4], edi\n        mov     DWORD PTR [rbp-8], esi\n        mov     edx, DWORD PTR [rbp-4]\n        mov     eax, DWORD PTR [rbp-8]\n        add     eax, edx\n        pop     rbp\n        ret\n_Z3addIfET_S0_S0_:\n        push    rbp\n        mov     rbp, rsp\n        movss   DWORD PTR s[rbp-4], xmm0\n        movss   DWORD PTR [rbp-8], xmm1\n        movss   xmm0, DWORD PTR [rbp-4]\n        addss   xmm0, DWORD PTR [rbp-8]\n        pop     rbp\n        ret \n```", "```cpp\nstruct point {\n    int x;\n    int y;\n};\nint main() {\n    point a{1, 2};\n    point b{2, 1};\n    auto c = add(a, b);\n    return 0;\n} \n```", "```cpp\n<source>: In instantiation of 'T add(T, T) [with T = point]':\n<source>:25:17:   required from here\n   25 |     auto c = add(a, b);\n      |              ~~~^~~~~~\n<source>:6:13: error: no match for 'operator+' (operand types are 'point' and 'point')\n    6 |    return a + b;\n      |           ~~^~~ \n```", "```cpp\nstruct point {\n    int x;\n    int y;\n    point operator+(const point& other) const {\n        return point{x + other.x, y + other.y};\n    }\n    void print() {\n        printf(\"x = %d, y = %d\\r\\n\", x, y);\n    }\n}; \n```", "```cpp\ntemplate<>\npoint add<point>(point a, point b) {\n   return point{a.x+b.x+1, a.y+b.y+1};\n} \n```", "```cpp\nint main() {\n    point a{1, 2};\n    point b{2, 1};\n    auto c = add(a, b);\n    c.print();\n    static_assert(std::is_same_v<decltype(c), point>);\n    return 0;\n} \n```", "```cpp\nx = 4, y = 4 \n```", "```cpp\n#include <type_traits>\ntemplate<typename T>\nstd::enable_if<true, T>::type\nadd(T a, T b) {\n   return a + b;\n} \n```", "```cpp\ntemplate<typename T>\nstd::enable_if<std::is_arithmetic<T>::value, T>::type\nadd(T a, T b) {\n   return a + b;\n} \n```", "```cpp\nint main() {\n    auto a = add(1, 2); // OK\n    auto b = add(1.1, 2.1); // OK\n    point p_a{1, 2};\n    point p_b{2, 1}; \n    auto p_c = add(p_a, p_b); // compile-error\n    return 0;\n} \n```", "```cpp\n<source>: In function 'int main()':\n<source>:30:17: error: no matching function for call to 'add(point&, point&)'\n  30 |     auto c = add(p_a, p_b); // compile-error\n     |              ~~~^~~~~~~~~~\n<source>:30:17: note: there is 1 candidate\n<source>:19:1: note: candidate 1: 'template<class T> typename std::enable_if<std::is_arithmetic<_Tp>::value, T>::type add(T, T)'\n  19 | add(T a, T b) {\n     | ^~~\n<source>:19:1: note: template argument deduction/substitution failed:\n<source>: In substitution of 'template<class T> typename std::enable_if<std::is_arithmetic<_Tp>::value, T>::type add(T, T) [with T = point]':\n<source>:30:17:   required from here\n  30 |     auto c = add(p_a, p_b); // compile-error\n     |              ~~~^~~~~~~~~~\n<source>:19:1: error: no type named 'type' in 'struct std::enable_if<false, point>'\n  19 | add(T a, T b) {\n     | ^~~ \n```", "```cpp\ntemplate<typename T>\nstd::enable_if<std::is_integral<T>::value, T>::type\nadd(T a, T b) {\n    T result = a + b;\n    printf(\"%d + %d = %d\\r\\n\", a, b, result);\n    return result;\n}\ntemplate<typename T>\nstd::enable_if<std::is_floating_point<T>::value, T>::type\nadd(T a, T b) {\n    T result = a + b;\n    printf(\"%.2f + %.2f = %.2f\\r\\n\", a, b, result);\n    return result;\n} \n```", "```cpp\nstd::enable_if_t<std::is_arithmetic_v<T>, T>\nadd(T a, T b) {\n    T result = a + b;\n    if constexpr (std::is_integral_v<T>) {\n        printf(\"%d + %d = %d\\r\\n\", a, b, result);\n    } else if constexpr (std::is_floating_point_v<T>) {\n        printf(\"%.2f + %.2f = %.2f\\r\\n\", a, b, result);\n    }\n    return a + b;\n} \n```", "```cpp\ntemplate<typename T>\nconcept Arithmetic = std::is_arithmetic_v<T>;\ntemplate<Arithmetic T>\nT add(T a, T b) {\n    T result = a + b;\n    if constexpr (std::is_integral_v<T>) {\n        printf(\"%d + %d = %d\\r\\n\", a, b, result);\n    } else if constexpr (std::is_floating_point_v<T>) {\n        printf(\"%.2f + %.2f = %.2f\\r\\n\", a, b, result);\n    }\n    return a + b;\n} \n```", "```cpp\n<source>: In function 'int main()':\n<source>:41:17: error: no matching function for call to 'add(point&, point&)'\n  41 |     auto c = add(p_a, p_b); // compile-error\n     |              ~~~^~~~~~~~~~\n<source>:41:17: note: there is 1 candidate\n<source>:22:3: note: candidate 1: 'template<class T>  requires  Arithmetic<T> T add(T, T)'\n  22 | T add(T a, T b) {\n     |   ^~~\n<source>:22:3: note: template argument deduction/substitution failed:\n<source>:22:3: note: constraints not satisfied\n<source>: In substitution of 'template<class T>  requires  Arithmetic<T> T add(T, T) [with T = point]':\n<source>:41:17:   required from here\n  41 |     auto c = add(p_a, p_b); // compile-error\n     |              ~~~^~~~~~~~~~\n<source>:18:9:   required for the satisfaction of 'Arithmetic<T>' [with T = point]\n<source>:18:27: note: the expression 'is_arithmetic_v<T> [with T = point]' evaluated to 'false'\n  18 | concept Arithmetic = std::is_arithmetic_v<T>;\n     |                      ~~~~~^~~~~~~~~~~~~~~~~~ \n```", "```cpp\n#include <span>\n#include <cstdio>\n#include <cstdint>\nclass uart_stm32 {\npublic:\n    void init(std::uint32_t baudrate = 9600) {\n        printf(\"uart_stm32::init: setting baudrate to %d\\r\\n\", baudrate);\n    }\n    void write(std::span<const char> data) {\n        printf(\"uart_stm32::write: \");\n        for(auto ch: data) {\n            putc(ch, stdout);\n        }\n    }\n};\ntemplate<typename T>\nclass gsm_lib{\npublic:\n    gsm_lib(T &u) : uart_(u) {}\n    void init() {\n        printf(\"gsm_lib::init: sending AT command\\r\\n\");\n        uart_.write(\"AT\");\n    }\nprivate:\n    T &uart_;\n};\nint main() {\n    uart_stm32 uart_stm32_obj;\n    uart_stm32_obj.init(115200);\n    gsm_lib gsm(uart_stm32_obj);\n    gsm.init();\n    return 0;\n} \n```", "```cpp\ntemplate<typename U>\nclass uart_interface {\npublic:\n    void init(std::uint32_t baudrate = 9600) {\n       static_cast<U*>(this)->initImpl(baudrate);\n    }\n};\nclass uart_stm32 : public uart_interface<uart_stm32> {\npublic:\n    void initImpl(std::uint32_t baudrate = 9600) {\n        printf(\"uart_stm32::init: setting baudrate to %d\\r\\n\", baudrate);\n    }\n}; \n```", "```cpp\ntemplate<typename T>\nconcept TheUart = std::derived_from<T, uart_interface<T>>; \n```", "```cpp\n#include <span>\n#include <cstdio>\n#include <cstdint>\ntemplate<typename U>\nclass uart_interface {\npublic:\n    void init(std::uint32_t baudrate = 9600) {\n       static_cast<U*>(this)->initImpl(baudrate);\n    }\n    void write(std::span<const char> data) {\n       static_cast<U*>(this)->writeImpl(data);\n    }\n};\nclass uart_stm32 : public uart_interface<uart_stm32> {\npublic:\n    void initImpl(std::uint32_t baudrate = 9600) {\n        printf(\"uart_stm32::init: setting baudrate to %d\\r\\n\", baudrate);\n    }\n    void writeImpl(std::span<const char> data) {\n        printf(\"uart_stm32::write: \");\n        for(auto ch: data) {\n            putc(ch, stdout);\n        }\n    }\n};\ntemplate<typename T>\nconcept TheUart = std::derived_from<T, uart_interface<T>>;\ntemplate<TheUart T>\nclass gsm_lib{\npublic:\n    gsm_lib(T &u) : uart_(u) {}\n    void init() {\n        printf(\"gsm_lib::init: sending AT command\\r\\n\");\n        uart_.write(\"AT\");\n    }\nprivate:\n    T &uart_;\n};\nint main() {\n    uart_stm32 uart_stm32_obj;\n    uart_stm32_obj.init(115200);\n    gsm_lib gsm(uart_stm32_obj);\n    gsm.init();\n    return 0;\n} \n```"]