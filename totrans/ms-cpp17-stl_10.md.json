["```cpp\n    void print_help() {\n      puts(R\"(The regex special characters are:\n      \\ - escaping\n      | - separating alternatives\n      . - match any character\n      [] - character class or set\n      () - capturing parentheses, or lookahead\n      ?*+ - \"zero or one\", \"zero or more\", \"one or more\"\n      {} - \"exactly N\" or \"M to N\" repetitions\n      ^$ - beginning and end of a \"line\"\n      \\b - word boundary\n      \\d \\s \\w - digit, space, and word\n      (?=foo) (?!foo) - lookahead; negative lookahead\n    )\");\n```", "```cpp\n    std::regex rx(\"(left|right) ([0-9]+)\");\n    // Construct the regex object \"rx\" outside the loop.\n    std::string line;\n    while (std::getline(std::cin, line)) {\n      // Inside the loop, use the same \"rx\" over and over.\n      if (std::regex_match(line, rx)) {\n        process_command(line);\n      } else {\n        puts(\"Unrecognized command.\");\n      }\n    }\n```", "```cpp\n    std::regex rx(\"(left|right) ([0-9]+)\");\n    std::string line;\n    while (std::getline(std::cin, line)) {\n      if (std::regex_match(line, rx)) {\n        process_command(line);\n      } else {\n        printf(\"Unrecognized command '%s'.\\n\",\n          line.c_str());\n      }\n    }\n```", "```cpp\n    void parse(const char *p, const char *end)\n    {\n      static std::regex rx(\"(left|right) ([0-9]+)\");\n      if (std::regex_match(p, end, rx)) {\n        process_command(p, end);\n      } else {\n        printf(\"Unrecognized command '%.*s'.\\n\",\n          int(end - p), p);\n      }\n    }\n```", "```cpp\n    std::pair<std::string, std::string>\n    parse_command(const std::string& line)\n    {\n      static std::regex rx(\"(left|right) ([0-9]+)\");\n      std::smatch m;\n      if (std::regex_match(line, m, rx)) {\n        return { m[1], m[2] };\n      } else {\n        throw \"Unrecognized command!\";\n      }\n    }\n\n    void test() {\n      auto [dir, dist] = parse_command(\"right 4\");\n      assert(dir == \"right\" && dist == \"4\");\n    }\n```", "```cpp\n    std::pair<std::string, std::string>\n    parse_command(const char *p, const char *end)\n    {\n      static std::regex rx(\"(left|right) ([0-9]+)\");\n      std::cmatch m;\n      if (std::regex_match(p, end, m, rx)) {\n        return { m[1], m[2] };\n      } else {\n        throw \"Unrecognized command!\";\n      }\n    }\n\n    void test() {\n      char buf[] = \"left 20\";\n      auto [dir, dist] = parse_command(buf, buf + 7);\n      assert(dir == \"left\" && dist == \"20\");\n    }\n```", "```cpp\n    static std::regex rx(\"(left|right) ([0-9]+)\");\n    std::string line = \"left 20\";\n    std::smatch m;\n    std::regex_match(line, m, rx);\n      // m[1] now holds iterators into line\n    line = \"hello world\";\n      // reallocate line's underlying buffer\n    std::string oops = m[1];\n      // this invokes undefined behavior because\n      // of iterator invalidation\nconst char * to std::string) might cause iterator-invalidation bugs in harmless-looking code. Consider the following:\n```", "```cpp\n    static std::regex rx(\"(left|right) ([0-9]+)\");\n    std::smatch m;\n    std::regex_match(\"left 20\", m, rx);\n      // m[1] would hold iterators into a temporary\n      // string, so they would ALREADY be invalid.\n      // Fortunately this overload is deleted.\n```", "```cpp\n    template<class Iter>\n    std::pair<std::string, std::string>\n    parse_command(Iter begin, Iter end) \n    {\n      static std::regex rx(\"(left|right) ([0-9]+)\");\n      std::match_results<Iter> m;\n      if (std::regex_match(begin, end, m, rx)) {\n        return { m.str(1), m.str(2) };\n      } else {\n        throw \"Unrecognized command!\";\n      }\n    }\n\n    void test() {\n      char buf[] = \"left 20\";\n      std::list<char> lst(buf, buf + 7);\n      auto [dir, dist] = parse_command(lst.begin(), lst.end());\n      assert(dir == \"left\" && dist == \"20\");\n    }\n```", "```cpp\n    int main()\n    {\n      std::regex rx(\"(left|right) ([0-9]+)\");\n      int pos = 0;\n      std::string line;\n      while (std::getline(std::cin, line)) {\n        try {\n          std::smatch m;\n          if (!std::regex_match(line, m, rx)) {\n              throw std::runtime_error(\"Failed to lex\");\n          }\n          int how_far = std::stoi(m.str(2));\n          int direction = (m[1] == \"left\") ? -1 : 1;\n          pos += how_far * direction;\n          printf(\"Robot is now at %d.\\n\", pos);\n        } catch (const std::exception& e) {\n          puts(e.what());\n          printf(\"Robot is still at %d.\\n\", pos);\n        }\n      }\n    }\n```", "```cpp\n    int main()\n    {\n      std::regex rx(\"((left)|right) (-?[0-9]+)\", std::regex::icase);\n      int pos = 0;\n      std::string line;\n      while (std::getline(std::cin, line)) {\n        try {\n          std::smatch m;\n          if (!std::regex_match(line, m, rx)) {\n            throw std::runtime_error(\"Failed to lex\");\n          }\n          int how_far = std::stoi(m.str(3));\n          int direction = m[2].matched ? -1 : 1;\n          pos += how_far * direction;\n          printf(\"Robot is now at %d.\\n\", pos);\n        } catch (const std::exception& e) {\n          puts(e.what());\n          printf(\"Robot is still at %d.\\n\", pos);\n        }\n      }\n    }\n```", "```cpp\n    auto get_all_matches(\n      const char *begin, const char *end,\n      const std::regex& rx,\n      bool be_correct)\n    {\n      auto flags = be_correct ?\n      std::regex_constants::match_prev_avail :\n      std::regex_constants::match_default;\n      std::vector<std::string> result;\n      std::cmatch m;\n      std::regex_search(begin, end, m, rx);\n      while (!m.empty()) {\n        result.push_back(m[0]);\n        begin = m[0].second;\n        std::regex_search(begin, end, m, rx, flags);\n      }\n      return result;\n    }\n\n    void test() {\n      char buf[] = \"baby\";\n      std::regex rx(\"\\\\bb.\");\n        // get the first 2 letters of each word starting with \"b\"\n      auto v = get_all_matches(buf, buf+4, rx, false);\n      assert(v.size() == 2);\n        // oops, \"by\" is considered to start on a word boundary! \n\n      v = get_all_matches(buf, buf+4, rx, true);\n      assert(v.size() == 1);\n        // \"by\" is correctly seen as part of the word \"baby\"\n    }\n```", "```cpp\n    while (!m.empty()) {\n      result.push_back(m[0]);\n      begin = m[0].second;\n      if (begin == end) break;\n      if (m[0].length() == 0) ++begin;\n      if (begin == end) break;\n      std::regex_search(begin, end, m, rx, flags);\n    }\n```", "```cpp\n    auto get_all_matches(\n      const char *begin, const char *end,\n      const std::regex& rx)\n    {\n      std::vector<std::string> result;\n      using It = std::cregex_iterator;\n      for (It it(begin, end, rx); it != It{}; ++it) {\n        auto m = *it;\n        result.push_back(m[0]);\n      }\n      return result;\n    }\n```", "```cpp\n    auto get_tokens(const char *begin, const char *end,\n      const std::regex& rx)\n    {\n      std::vector<std::string> result;\n      using It = std::cregex_iterator;\n      std::optional<std::csub_match> opt_suffix;\n      for (It it(begin, end, rx); it != It{}; ++it) {\n        auto m = *it;\n        std::csub_match nonmatching_part = m.prefix();\n        result.push_back(nonmatching_part);\n        std::csub_match matching_part = m[0];\n        result.push_back(matching_part);\n        opt_suffix = m.suffix();\n      }\n      if (opt_suffix.has_value()) {\n        result.push_back(opt_suffix.value());\n      }\n      return result;\n    }\n```", "```cpp\n    auto get_tokens(const char *begin, const char *end,\n      const std::regex& rx)\n    {\n      std::vector<std::string> result;\n      using TokIt = std::cregex_token_iterator;\n      for (TokIt it(begin, end, rx, {-1, 0}); it != TokIt{}; ++it) {\n        std::csub_match some_part = *it;\n        result.push_back(some_part);\n      }\n      return result;\n    }\n```", "```cpp\n    std::string input = \"abc123...456...\";\n    std::vector<std::ssub_match> v;\n    std::regex rx(\"([0-9]+)|([a-z]+)\");\n    using TokIt = std::sregex_token_iterator;\n    std::copy(\n      TokIt(input.begin(), input.end(), rx, {1, 2}),\n      TokIt(),\n      std::back_inserter(v)\n    );\n    assert(!v[0].matched); assert(v[1] == \"abc\");\n    assert(v[2] == \"123\"); assert(!v[3].matched);\n    assert(v[4] == \"456\"); assert(!v[5].matched);\n```", "```cpp\n    std::string s = \"apples and bananas\";\n    std::string t = std::regex_replace(s, std::regex(\"a\"), \"e\");\n    assert(t == \"epples end benenes\");\n    std::string u = std::regex_replace(s, std::regex(\"[ae]\"), \"u\");\n    assert(u == \"upplus und bununus\");\n```", "```cpp\n    auto s = \"std::sort(std::begin(v), std::end(v))\";\n    auto t = std::regex_replace(s, std::regex(\"\\\\bstd::(\\\\w+)\"), \"$1\");\n    assert(t == \"sort(begin(v), end(v))\");\n    auto u = std::regex_replace(s, std::regex(\"\\\\bstd::(\\\\w+)\"), \"my::$1\");\n    assert(u == \"my::sort(my::begin(v), my::end(v))\");\n```", "```cpp\n    template<class F>\n    std::string regex_replace(std::string_view haystack,\n      const std::regex& rx, const F& f)\n    {\n      std::string result;\n      const char *begin = haystack.data();\n      const char *end = begin + haystack.size();\n      std::cmatch m, lastm;\n      if (!std::regex_search(begin, end, m, rx)) {\n        return std::string(haystack);\n      }\n      do {\n        lastm = m;\n        result.append(m.prefix());\n        result.append(f(m));\n        begin = m[0].second;\n        begin += (begin != end && m[0].length() == 0);\n        if (begin == end) break;\n      } while (std::regex_search(begin, end, m, rx,\n        std::regex_constants::match_prev_avail));\n      result.append(lastm.suffix());\n      return result;\n    }\n\n    void test()\n    {\n      auto s = \"std::sort(std::begin(v), std::end(v))\";\n      auto t = regex_replace(s, std::regex(\"\\\\bstd::(\\\\w+)\"),\n        [](auto&& m) {\n          std::string result = m[1].str();\n          std::transform(m[1].first, m[1].second,\n          begin(result), ::toupper);\n          return result;\n        });\n      assert(t == \"SORT(BEGIN(v), END(v))\");\n    }\n```", "```cpp\n    ^ $ \\ . * + ? ( ) [ ] { } |\n```", "```cpp\n    std::string s = \"abcde\";\n    std::smatch m;\n    std::regex_match(s, m, std::regex(\"(a|b)*(.*)e\"));\n    assert(m.size() == 3 && m[2] == \"cd\");\n    std::regex_match(s, m, std::regex(\"(?:a|b)*(.*)e\"));\n    assert(m.size() == 2 && m[1] == \"cd\");\n```", "```cpp\n    std::string s = \"ab\\ncd\";\n    std::regex rx(\"^ab$[^]^cd$\", std::regex::multiline);\n\n    assert(std::regex_match(s, rx));\n```", "```cpp\n    std::string s = \"abcde\";\n    std::smatch m;\n    std::regex_match(s, m, std::regex(\".*([bcd].*)e\"));\n    assert(m[1] == \"d\");\n    std::regex_match(s, m, std::regex(\".*?([bcd].*)e\"));\n    assert(m[1] == \"bcd\");\n```"]