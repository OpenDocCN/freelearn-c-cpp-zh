- en: Chapter 5. Sensing with Digital Inputs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 使用数字输入进行感知
- en: 'Arduino boards have inputs and outputs. Indeed, this is also one of the strengths
    of this platform: to directly provide headers connecting the ATMega chipset legs.
    We can then directly wire an input or output to any other external component or
    circuit without having to solder.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino板具有输入和输出。实际上，这也是这个平台的一个优势：直接提供连接ATMega芯片组引脚的引脚。然后我们可以直接将输入或输出连接到任何其他外部组件或电路，而无需焊接。
- en: 'In case you need it here, I''m reminding you of some points:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要，我在这里提醒你一些要点：
- en: Arduino has digital and analog inputs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arduino具有数字和模拟输入
- en: Arduino has digital outputs that can also be used to mimic analog outputs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arduino具有也可以用于模拟输出的数字输出
- en: We are going to talk about digital inputs in this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中讨论数字输入。
- en: We'll learn about the global concept of sensing the world. We are going to meet
    a new companion named **Processing** because it is a nice way to visualize and
    illustrate all that we are going to do in a more graphical way. It is also a pretext
    to show you this very powerful and open source tool. Then, it will drive us to
    design the first serial communication protocol between the board and a piece of
    software.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习关于感知世界的全局概念。我们将遇到一个名为**Processing**的新伙伴，因为它以图形化的方式可视化和说明我们将要做的一切，这是一个很好的方式。它也是一个展示这个非常强大且开源工具的先导。然后，它将引导我们设计板与软件之间的第一个串行通信协议。
- en: We'll specifically play with switches, but we will also cover some useful hardware
    design patterns.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将特别与开关进行互动，但也会涵盖一些有用的硬件设计模式。
- en: Sensing the world
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 感知世界
- en: In our over-connected world, a lot of systems don't even have sensors. We, humans,
    own a bunch of biological sensors directly in and over our body. We are able to
    feel temperature with our skin, light with our eyes, chemical components with
    both our nose and mouth, and air movement with ears. From a characteristic of
    our world, we are able to sense, integrate this feeling, and eventually to react.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们过度连接的世界中，许多系统甚至没有传感器。我们人类在我们的身体内部和外部拥有大量的生物传感器。我们能够通过皮肤感受温度，通过眼睛感受光线，通过鼻子和嘴巴感受化学成分，以及通过耳朵感受空气流动。从我们世界的特性中，我们能够感知、整合这种感觉，并最终做出反应。
- en: 'If I go a bit further, I can remember a definition for senses from my early
    physiological courses at university (you remember, I was a biologist in one of
    my previous lives):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我进一步思考，我可以回忆起我在大学早期生理学课程中学到的一个关于感官的定义（你还记得，我前生是一名生物学家）：
- en: '"Senses are physiological capacities that provide data for perception"'
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “感官是提供感知数据的生理能力”
- en: This basic physiological model is a nice way to understand how we can work with
    an Arduino board to make it sense the world.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基本的生理模型是理解我们如何与Arduino板合作使其感知世界的一个好方法。
- en: 'Indeed, it introduces three elements we need:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，它引入了我们需要的三个要素：
- en: A capacity
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容量
- en: Some data
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些数据
- en: A perception
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种感知
- en: Sensors provide new capacities
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传感器提供了新的能力
- en: A sensor is a physical converter, able to measure a physical quantity and to
    translate it into a signal understandable directly or indirectly by humans or
    machines.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 传感器是一种物理转换器，能够测量一个物理量并将其转换为人类或机器可以直接或间接理解的信号。
- en: A thermometer, for example, is a sensor. It is able to measure the local temperature
    and to translate it into a signal. Alcohol-based or Mercury-based thermometers
    provide a scale written on them and the contraction/dilatation of the chemical
    matter according to the temperature makes them easy to read.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，温度计是一种传感器。它能够测量局部温度并将其转换为信号。基于酒精或汞的温度计提供了刻度，根据温度的化学物质的收缩/膨胀使得它们易于读取。
- en: In order to make our Arduino able to sense the world, temperature for instance,
    we would have to connect a sensor.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的Arduino能够感知世界，例如温度，我们就需要连接一个传感器。
- en: Some types of sensors
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一些类型的传感器
- en: We can find various types of types of sensors. We often think about environmental
    sensors when we use the term sensor.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以找到各种类型的传感器。当我们使用传感器这个词时，我们经常想到环境传感器。
- en: 'I''ll begin by quoting some environmental quantities:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先引用一些环境量：
- en: Temperature
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 温度
- en: Humidity
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 湿度
- en: Pressure
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压力
- en: Gas sensors (gas-specific or not, smoke)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 气体传感器（特定气体或非特定气体，烟雾）
- en: Electromagnetic fields
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电磁场
- en: Anemometer (wind speed)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 风速计（风速）
- en: Light
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光线
- en: Distance
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 距离
- en: Capacitance
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电容
- en: Motion
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运动
- en: This is a non-exhaustive list. For almost each quantity, we can find a sensor.
    Indeed, for each quantifiable physical or chemical phenomenon, there is a way
    to measure and track it. Each of them provides data related to the quantity measured.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不完整的列表。对于几乎每个数量，我们都可以找到一个传感器。实际上，对于每个可量化的物理或化学现象，都有一种方法可以测量和跟踪它。每个都提供了与测量的数量相关的数据。
- en: Quantity is converted to data
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数量被转换为数据
- en: When we use sensors, the reason is that we need to have a numeric value coming
    from a physical phenomenon, such as temperature or movement. If we could directly
    measure the temperature with our skin's thermal sensors, we would have been able
    to understand the relationship between the volume of chemical components and temperature
    itself. Because we know this relationship from other physical measures or calculations,
    we have been able to design thermometers.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用传感器时，原因是我们需要从物理现象（如温度或运动）中获得一个数值。如果我们能够直接用我们皮肤的热传感器测量温度，我们就能够理解化学成分的体积与温度本身之间的关系。因为我们从其他物理测量或计算中知道了这种关系，所以我们能够设计温度计。
- en: Indeed, thermometers are converting a quantity (here a volume) related to the
    temperature into a value readable on the scale of the thermometer. In fact, we
    have a double conversion here. The volume is a function depending on the temperature.
    The height of the liquid inside the thermometer is a function depending on the
    volume of the liquid. Thus, we can understand that the height and temperature
    are related. This is the double conversion.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，温度计是将与温度相关的数量（在这里是体积）转换为温度计刻度上可读的值的转换。实际上，我们在这里有一个双重转换。体积是温度的函数。温度计内液体的液位是液体积的函数。因此，我们可以理解高度和温度是相关的。这是双重转换。
- en: 'Anyway, the thermometer is a nice module that integrates all this mathematical
    and physical wizardry to provide data, a value: the temperature. As shown in the
    following figure, volume is used to provide a temperature:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 不管怎样，温度计是一个很好的模块，它集成了所有这些数学和物理的奇妙之处，以提供数据，一个值：温度。如图所示，体积被用来提供温度：
- en: '![Quantity is converted to data](img/7584_05_01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![数量转换为数据](img/7584_05_01.jpg)'
- en: All sensors work like that. They are modules measuring physical phenomenon and
    providing a value. We'll see later that those values can be very different, and
    eventually encoded too.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 所有传感器都像这样工作。它们是测量物理现象并提供值的模块。我们稍后会看到这些值可以非常不同，最终也可以编码。
- en: Data has to be perceived
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据必须被感知
- en: The data provided by a sensor makes more sense if it is read. This can be obvious
    but imagine that the reader isn't a human but is instead an instrument, a machine,
    or in our case, an Arduino board.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 传感器提供的数据，如果被读取，就会更有意义。这可能是显而易见的，但想象一下，读者不是一个人类，而是一台仪器、一台机器，或者在我们的例子中，是一块Arduino板。
- en: 'Indeed, let''s take an electronic thermal sensor. At first, this one has to
    be supplied with electricity in order to work. Then, if we are able to supply
    it but unable to physically measure the electric potential generated by it from
    its pins, we couldn''t appreciate the main value it tries to provide us: the temperature.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，让我们以一个电子热传感器为例。首先，这个传感器必须供电才能工作。然后，如果我们能够供电但无法从其引脚物理测量它产生的电势，我们就无法欣赏它试图为我们提供的主要价值：温度。
- en: In our case, the Arduino would be the device that is able to convert the electric
    potential to something readable or at least easier to understand for us, humans.
    This is again a conversion. From the physical phenomenon that we want to translate,
    to the device displaying the value explaining the physical phenomenon, there are
    conversions and perceptions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，Arduino将是能够将电势转换为可读或至少对我们人类来说更容易理解的设备的装置。这又是一个转换。从我们想要翻译的物理现象，到显示解释物理现象的值的设备，有转换和感知。
- en: 'I can simplify the process as shown in the following figure:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以将这个过程简化，如下面的图所示：
- en: '![Data has to be perceived](img/7584_05_02.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![数据必须被感知](img/7584_05_02.jpg)'
- en: What does digital mean?
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字意味着什么？
- en: Let's define precisely what the digital term means here.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们精确地定义这里的数字术语。
- en: Digital and analog concepts
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字和模拟概念
- en: Digital, in the computer and electronic worlds, means discrete, which is the
    opposite of analog/continuous. It is also a mathematical definition. We often
    talk about domains to define the cases for use of digital and analog.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机和电子领域，数字意味着离散的，这是与模拟/连续相反的。它也是一个数学定义。我们经常谈论域来定义数字和模拟的使用情况。
- en: Usually, the analog domain is the domain related to physical measures. Our temperature
    can have all the values that are possible and that exist, even if our measuring
    equipment dosen't have an infinite resolution.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，模拟域是与物理测量相关的域。我们的温度可以具有所有可能和存在的值，即使我们的测量设备没有无限分辨率。
- en: The digital domain is the one of computers. Because of the encoding and finite
    memory size, computers translates analog/continuous values into digital representations.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 数字域是计算机的域。由于编码和有限的内存大小，计算机将模拟/连续值转换为数字表示。
- en: 'On a graph, this could be visualized as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在图表上，这可以表示如下：
- en: '![Digital and analog concepts](img/7584_05_03.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![数字和模拟概念](img/7584_05_03.jpg)'
- en: Inputs and outputs of Arduino
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Arduino的输入和输出
- en: Arduino owns inputs and outputs. We can also distinguish analog and digital
    pins.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino拥有输入和输出。我们还可以区分模拟和数字引脚。
- en: 'You have to remember the following points:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须记住以下要点：
- en: Arduino provides digital pins that can be both an input or an output
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arduino提供了既可以作为输入也可以作为输出的数字引脚。
- en: Arduino provides only analog input, not output
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arduino只提供模拟输入，不提供输出。
- en: Inputs and outputs are pins provided by the board to communicate with external
    peripherals.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 输入和输出是板子提供的引脚，用于与外部外围设备通信。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Inputs provide the ability to feel the world.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 输入提供了感知世界的能力。
- en: Outputs provide the ability to alter the world.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 输出提供了改变世界的能力。
- en: We often talk about *reading pins* for inputs and *writing pins* for outputs.
    Indeed, from the Arduino board point of view, we are reading from the world and
    writing to the world, aren't we?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常谈论“读取引脚”作为输入和“写入引脚”作为输出。确实，从Arduino板的角度来看，我们是从世界读取并写入世界，对吧？
- en: A digital input is a digital pin set up like an input and providing the capacity
    for electrical potential reading and conversion to 0 or 1 to the Arduino board.
    We'll illustrate this very soon using switches.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 数字输入是一个设置为输入的数字引脚，它提供了读取电势和将其转换为0或1到Arduino板的能力。我们将很快使用开关来展示这一点。
- en: But before manipulating this directly, let me introduce a new friend named **Processing**.
    We'll use it to easily illustrate our Arduino tests further in the book.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 但在直接操作之前，让我介绍一位新朋友，名叫**Processing**。我们将使用它来在本书中轻松地展示我们的Arduino测试。
- en: Introducing a new friend – Processing
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍一位新朋友——Processing
- en: Processing is an open source programming language and Integrated Development
    Environment (IDE) for people who want to create images, animations, and interaction.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Processing是一种开源编程语言和集成开发环境（IDE），它为想要创建图像、动画和交互的人提供支持。
- en: This major open source project was initiated in 2001 by Ben Fry and Casey Reas,
    two gurus and former students of John Maeda at the Aesthetics and Computation
    Group at the MIT Media Lab.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主要的开源项目始于2001年，由本·弗瑞（Ben Fry）和凯西·瑞斯（Casey Reas）发起，他们是麻省理工学院媒体实验室美学与计算小组约翰·梅达（John
    Maeda）的前学生和大师。
- en: It is a programming framework most used by non-programmers. Indeed, it has been
    designed primarily for this purpose. One of the first targets of Processing is
    to provide an easy way of programming for non-programmers through the instant
    gratification of visual feedback. Indeed, as we know, programming can be very
    abstract. Processing natively provides a canvas on which we can draw, write, and
    do more. It also provides a very user-friendly IDE that we are going to see on
    the official website at [http://processing.org](http://processing.org).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个大多数非程序员使用的编程框架。确实，它主要是为此目的而设计的。Processing的第一个目标之一就是通过即时满足视觉反馈的快感，为非程序员提供一种简单的编程方式。确实，正如我们所知，编程可以非常抽象。Processing原生提供了一块画布，我们可以在上面绘制、书写和做更多的事情。它还提供了一个非常用户友好的IDE，我们将在官方网站[http://processing.org](http://processing.org)上看到它。
- en: You'll probably also find the term Processing written as **Proce55ing** as the
    domain name `processing.org` was already taken at the time of its inception.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会发现Processing这个术语被写成**Proce55ing**，因为在它的诞生时期，域名`processing.org`已经被占用。
- en: Is Processing a language?
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Processing是一种语言吗？
- en: Processing isn't a language in the strictest sense. It's a subset of Java with
    some external libraries and a custom IDE.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 处理（Processing）在严格意义上来说不是一种语言。它是Java的一个子集，包含一些外部库和自定义的IDE。
- en: Programming with Processing is usually performed using the native IDE comes
    with the download as we will see in this section.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Processing进行编程通常是通过下载时附带的原生IDE来完成的，正如我们将在本节中看到的。
- en: Processing uses the Java language but provides simplified syntax and graphics
    programming. It also simplifies all compilations steps into a one-click action
    like Arduino IDE.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Processing使用Java语言，但提供了简化的语法和图形编程。它还将所有编译步骤简化为一个一键操作，就像Arduino IDE一样。
- en: Like Arduino core, it provides a huge set of ready-to-use functions. You can
    find all references at [http://processing.org/reference](http://processing.org/reference).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Arduino核心一样，它提供了一组庞大的现成函数。您可以在[http://processing.org/reference](http://processing.org/reference)找到所有参考。
- en: There is now more than one way to use Processing. Indeed, because JavaScript
    runtimes integrated in web browsers became more and more powerful, we can use
    a JavaScript derived project. You still continue to code using Java, you include
    this code in your webpage, and as the official website says "*Processing.js does
    the rest. It's not magic, but almost*." The website is [http://processingjs.org](http://processingjs.org).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用Processing的方式不止一种。实际上，由于集成在网页浏览器中的JavaScript运行时变得越来越强大，我们可以使用一个基于JavaScript的项目。您仍然可以使用Java继续编码，将此代码包含在您的网页中，正如官方网站所说，“*Processing.js会完成剩余的工作。这不是魔法，但几乎是的*。”网站是[http://processingjs.org](http://processingjs.org)。
- en: 'There is also something very interesting: You can package applications coded
    using Processing for Android mobile OS. You can read this if you are interested
    at [http://processing.org/learning/android](http://processing.org/learning/android).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 还有非常有趣的一点：您可以使用Processing为Android移动操作系统打包应用程序。如果您感兴趣，可以阅读[http://processing.org/learning/android](http://processing.org/learning/android)。
- en: I will avoid going on a tangent with the JS and Android applications, but I
    felt it was important enough to mention these usages.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我将避免在JS和Android应用程序上跑题，但我认为这些用法很重要，值得提及。
- en: Let's install and launch it
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让我们安装并启动它
- en: Like the Arduino framework, the Processing framework doesn't include installation
    program. You just have to put it somewhere and run it from there.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Arduino框架一样，Processing框架不包含安装程序。您只需将其放在某个位置，然后从那里运行即可。
- en: 'The download URL is: [http://processing.org/download](http://processing.org/download).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下载链接是：[http://processing.org/download](http://processing.org/download)。
- en: First, download the package corresponding to your OS. Please refer to the website
    for the install process for your specific OS.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，下载与您的操作系统对应的软件包。请参考网站了解您特定操作系统的安装过程。
- en: 'On OS X, you have to deflate the zip file and run the resulting file with the
    icon:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在OS X上，您需要解压zip文件，并使用图标运行生成的文件：
- en: '![Let''s install and launch it](img/7584_05_004.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![让我们安装并启动它](img/7584_05_004.jpg)'
- en: Processing icon
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Processing图标
- en: 'Double-click on the icon, and you''ll see a pretty nice splash screen:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 双击图标，您将看到一个相当漂亮的启动画面：
- en: '![Let''s install and launch it](img/7584_05_005.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![让我们安装并启动它](img/7584_05_005.jpg)'
- en: 'Then you''ll see the Processing IDE as shown in the following image:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将看到如下所示的Processing IDE：
- en: '![Let''s install and launch it](img/7584_05_006.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![让我们安装并启动它](img/7584_05_006.jpg)'
- en: Processing's IDE looks like others
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Processing的IDE看起来与其他IDE相似
- en: A very familiar IDE
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个非常熟悉的IDE
- en: Indeed, the Processing IDE looks like the Arduino one. The Processing IDE is
    like the father of the Arduino IDE.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Processing IDE看起来就像Arduino IDE。Processing IDE就像是Arduino IDE的父亲。
- en: This is totally normal because the Arduino IDE has been forked from the Processing
    IDE. Now, we are going to check that we'll be very comfortable with the Processing
    IDE as well.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全正常，因为Arduino IDE是从Processing IDE分叉出来的。现在，我们将检查我们是否也会非常熟悉Processing IDE。
- en: 'Let''s explore it and run a small example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索它并运行一个小示例：
- en: Go to **Files** | **Examples Basics** | **Arrays** | **ArraysObjects**.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**文件** | **示例** | **基础** | **数组** | **数组对象**。
- en: Then, click on the first icon (the play symbol arrow). You should see the following
    screenshot:![A very familiar IDE](img/7584_05_007.jpg)
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击第一个图标（播放符号箭头）。您应该看到以下截图：![一个非常熟悉的IDE](img/7584_05_007.jpg)
- en: Running ArrayObjects native example in Processing
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Processing中运行ArrayObjects原生示例
- en: Now click on the small square (stop symbol). Yes, this new playground is very
    familiar.![A very familiar IDE](img/7584_05_008.jpg)
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击小方块（停止符号）。是的，这个新的游乐场非常熟悉。![一个非常熟悉的IDE](img/7584_05_008.jpg)
- en: Processing IDE with ArrayObjects example opened
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打开包含ArrayObjects示例的Processing IDE
- en: At the top we can see some familiar icons.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，我们可以看到一些熟悉的图标。
- en: 'From left to right, they are as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右，它们如下所示：
- en: '**Run** (small arrow): This is used to compile and run your program'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行**（小箭头）：用于编译和运行您的程序'
- en: '**Stop** (small square): This is used to stop the program when it is running'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止**（小方块）：当程序运行时，用于停止程序'
- en: '**New project** (small page): This is used to open a blank canvas'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**新建项目**（小页面）：这是用来打开空白画布的'
- en: '**Open project** (top arrow): This is used to open an existing project'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打开项目**（顶部箭头）：这是用来打开现有项目的'
- en: '**Save project** (down arrow): This is used to save a project'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保存项目**（向下箭头）：这是用来保存项目的'
- en: '**Export application** (right arrow): This is used to create an application'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导出应用程序**（向右箭头）：这是用来创建应用程序的'
- en: No Upload button of course. There is no need to upload anything here; we are
    on the computer and we only want to code applications, compile them, and run them.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这里没有上传按钮。在这里，你不需要上传任何东西；我们在这里使用电脑，我们只想编写应用程序、编译它们并运行它们。
- en: With Processing, you have everything in hand to code, compile, and run.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Processing，你可以轻松地编写、编译和运行代码。
- en: You can have some tabs if you use more than one file in your project (especially
    if you use some separate Java classes).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个项目中使用多个文件（特别是如果你使用一些独立的Java类），你可以有一些标签页。
- en: Under this tab zone, you have the text area where you type your code. Code is
    colored as in the Arduino IDE, and this is very useful.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个标签区域下，你有文本区域，你可以在这里输入你的代码。代码的颜色与Arduino IDE中的颜色相同，这非常有用。
- en: At last, at the bottom, you have the log console area where all the messages
    can be output, from errors to our own tracer messages.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在底部，你有日志控制台区域，所有消息都可以在这里输出，从错误到我们自己的跟踪消息。
- en: Alternative IDEs and versioning
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替代IDE和版本控制
- en: If you are interested in digging some IDE alternatives, I'd suggest that you
    use the universal and open source software development environment Eclipse. I
    suggest that to all the students I meet who want to go further in pure-development
    fields. This powerful IDE can be easily set up to support versioning.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣，想挖掘一些IDE替代品，我建议你使用通用的开源软件开发环境Eclipse。我向所有想进一步在纯开发领域发展的学生推荐这个强大的IDE。它可以轻松设置以支持版本控制。
- en: Versioning is a very nice concept providing an easy way to track versions of
    your code. You can, for instance, code something, test it, back it up in your
    versioning system, then continue your code design. If you run it and have a nice
    and cute crash at some point, you can easily check the differences between your
    working code and the new non working one and make your troubleshooting much easier!
    I won't describe versioning systems in detail, but I want to introduce you to
    the two main systems that are widely used a
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制是一个非常好的概念，它提供了一种轻松跟踪代码版本的方法。例如，你可以编写一些代码，测试它，然后在版本控制系统中备份，然后继续你的代码设计。如果你运行它，并在某个时刻出现一个漂亮而可爱的崩溃，你可以轻松地检查你的工作代码和新不工作的代码之间的差异，从而使故障排除变得容易得多！我不会详细描述版本控制系统，但我想向你介绍两个广泛使用的系统。
- en: '[http://subversion.apache.org](http://subversion.apache.org)'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Apache Subversion](http://subversion.apache.org)'
- en: '**Git**: [http://git-scm.com](http://git-scm.com)'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Git**: [http://git-scm.com](http://git-scm.com)'
- en: Checking an example
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查一个示例
- en: 'Here is a small piece of code showing some cheap and easy design patterns.
    You can also find this code in the folder `Chapter05` `/p` `rocessingMultipleEasing/`
    in the code bundle:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一小段代码展示了几个简单易行的设计模式。你还可以在代码包中的`Chapter05` `/p` `rocessingMultipleEasing/`
    文件夹中找到这段代码：
- en: '[PRE0]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can run this piece of code. Then, you can move the mouse into the canvas
    and enjoy what is happening.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行这段代码。然后，你可以将鼠标移入画布中，享受正在发生的事情。
- en: '![Checking an example](img/7584_05_010.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![检查示例](img/7584_05_010.jpg)'
- en: processingMultipleEasing code running and showing a strange series of particles
    following the mouse
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: processingMultipleEasing代码正在运行并显示一系列奇怪的粒子，这些粒子跟随鼠标移动
- en: First, check the code. Basically, this is Java. I guess you aren't shocked too
    much, are you? Indeed, Java derives from C.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，检查代码。基本上，这是Java。我想你不会太惊讶，对吧？确实，Java源自C。
- en: 'You can see three main parts in your code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在你的代码中看到三个主要部分：
- en: Variable declarations/definitions
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量声明/定义
- en: The `setup()`function that runs only once at the beginning
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup()`函数只在开始时运行一次'
- en: The `draw()` function that runs infinitely until you press stop
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`draw()`函数会无限运行，直到你按下停止键'
- en: Ok. You can see the `setup()` functions in the Arduino core and Processing have
    similar roles, and `loop()` and `draw()` too.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。你可以看到Arduino核心和Processing中的`setup()`函数具有类似的作用，`loop()`和`draw()`也是如此。
- en: This piece of code shows some usual design patterns with Processing. I first
    initiate a variable storing the global number of particles, then I initiate some
    arrays for each particle I want to create. Please notice all these arrays are
    empty at this step!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了Processing中的一些常用设计模式。我首先初始化一个变量来存储全局粒子数，然后为我想创建的每个粒子初始化一些数组。请注意，所有这些数组在这个步骤都是空的！
- en: This pattern is usual because it offers good readability and works fine too.
    I could have used classes or even multidimensional arrays, but in this latter
    case, I would not even have benefits except a shorter (but less readable) code.
    In all those arrays, the *N*th indexed value represents the particle *N*. In order
    to store/retrieve the parameters of particle *N*, I have to manipulate the *N*th
    value for each array. The parameters are spread inside each array but are easy
    to store and retrieve, aren't they?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式很常见，因为它提供了良好的可读性，并且工作得很好。我本可以使用类或甚至是多维数组，但在后一种情况下，除了代码更短（但可读性更差）之外，我甚至不会得到任何好处。在这些数组中，第*N*个索引值代表第*N*个粒子。为了存储/检索粒子*N*的参数，我必须操纵每个数组中的第*N*个值。参数分布在每个数组中，但存储和检索都很方便，不是吗？
- en: In `setup()`, I define and instantiate the canvas and its size of 600 x 600\.
    Then, I'm defining that there will be no stroke in any of my drawings. The stroke
    of a circle, for instance, is its border.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setup()`中，我定义并实例化了画布及其600 x 600的大小。然后，我定义在所有我的绘画中都不会有线条。例如，圆的线条是其边界。
- en: Then, I'm filling the `easing` and `radii` arrays using a `for` loop structure.
    This is a very usual pattern where we can use `setup()` to initialize a bunch
    of parameters at the beginning. Then we can check the `draw()` loop. I'm defining
    a color for the background. This function also erases the canvas and fills it
    with the color in argument. Check the background function on the reference page
    to understand how we can use it. This erase/fill is a nice way to erase each frame
    and to reset the canvas.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我使用`for`循环结构填充`easing`和`radii`数组。这是一个非常常见的模式，我们可以使用`setup()`在开始时初始化一系列参数。然后我们可以检查`draw()`循环。我定义了一个背景颜色。这个函数也会擦除画布并填充参数中的颜色。查看参考页面上的背景函数，以了解我们如何使用它。这种擦除/填充是一种很好的方式来擦除每一帧并重置画布。
- en: After this erase/fill, I'm storing the current position of the mouse for each
    coordinate in the local variables `targetX` and `targetY`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次擦除/填充之后，我将鼠标的当前位置存储在每个坐标的局部变量`targetX`和`targetY`中。
- en: The core of the program sits in the `for` loop. This loop walks over each particle
    and makes something for each of them. The code is quite self-explanatory. I can
    add here that I'm checking the distance between the mouse and each particle for
    each frame (each run of `draw()`), and I draw each particle by moving them a bit,
    according to its easing.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的核心位于`for`循环中。这个循环遍历每个粒子，并为每个粒子生成一些内容。代码相当直观。我还可以在这里补充说，我正在检查鼠标和每个粒子之间的距离，这是在每一帧（每次`draw()`的运行）中进行的，并且我会根据其缓动效果移动每个粒子来绘制它们。
- en: This is a very simple example but a nice one I used to show to illustrate the
    power of Processing.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的例子，但也是一个很好的例子，我用来展示Processing的强大功能。
- en: Processing and Arduino
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Processing和Arduino
- en: Processing and Arduino are very good friends.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Processing和Arduino是非常好的朋友。
- en: 'Firstly, they are both open source. It is a very friendly characteristic bringing
    a lot of advantages like code source sharing and gigantic communities, among others.
    They are available for all OSes: Windows, OS X, and Linux. We also can download
    them for free and run them in a couple of clicks.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它们都是开源的。这是一个非常友好的特性，带来了许多优势，如代码源共享和庞大的社区等。它们适用于所有操作系统：Windows、OS X和Linux。我们还可以免费下载它们，并点击几下即可运行。
- en: I began to program primarily with Processing, and I use it a lot for some of
    my own data visualization projects and art too. Then, we can illustrate complex
    and abstract data flows by smooth and primitive shapes on a screen.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我最初是用Processing编程的，并且我经常用它来做一些自己的数据可视化项目和艺术作品。然后，我们可以在屏幕上通过平滑和原始的形状来展示复杂和抽象的数据流。
- en: What we are going to do together now is display Arduino activity on the Processing
    canvas. Indeed, this is a common use of Processing as an eye-friendly software
    for Arduino.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要一起做的是在Processing画布上显示Arduino的活动。实际上，这是Processing作为Arduino友好的软件的常见用途。
- en: We are going to design a very trivial and cheap protocol of communication between
    the hardware and the software. This will show you the path that we'll dig further
    in the next chapters of this book. Indeed, if you want to get your Arduino talking
    with another software framework (I'm thinking about Max 6, openFrameworks, Cinder,
    and many others), you'll have to follow the same ways of design.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设计一个非常简单且便宜的硬件和软件之间的通信协议。这将展示我们在本书下一章将进一步深入探讨的路径。确实，如果你想让你的Arduino与另一个软件框架（我想到了Max
    6、openFrameworks、Cinder以及许多其他框架）通信，你必须遵循相同的设计方法。
- en: '![Processing and Arduino](img/7584_05_011.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![Processing和Arduino](img/7584_05_011.jpg)'
- en: Arduino and some software friends
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino和一些软件朋友
- en: I often say Arduino can work as a very smart *organ* of software. If you want
    to connect some software to the real, physical world, Arduino is the way to go.
    Indeed, that way, software can sense the world, providing your computer with new
    features. Let's move on by displaying some physical world events on the computer.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常说Arduino可以作为一个非常智能的*器官*来工作。如果你想将一些软件连接到真实的物理世界，Arduino就是你的选择。确实，通过这种方式，软件可以感知世界，为你的电脑提供新的功能。让我们通过在电脑上显示一些物理世界事件来继续前进。
- en: Pushing the button
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按下按钮
- en: We are going to have fun. Yes, this is the very special moment when we are going
    to link the physical world to the virtual world. Arduino is all about this.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将会有趣。是的，这就是我们将物理世界与虚拟世界连接的特殊时刻。Arduino正是关于这一点。
- en: What is a button, a switch?
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按钮和开关是什么？
- en: A **switch** is an electrical component that is able to break an electrical
    circuit. There are a lot of different types of switches.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**开关**是一种能够断开电路的电气元件。有很多不同类型的开关。'
- en: Different types of switches
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不同类型的开关
- en: Some switches are called **toggles**. Toggles are also named continuous switches.
    In order to act on the circuit, the toggle can be pushed and released each time
    you want to act and when you release it, the action continues.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开关被称为**切换开关**。切换开关也被称为连续开关。为了对电路进行操作，切换开关可以每次按下并释放，以便进行操作，当你释放它时，操作会继续。
- en: Some others are called **momentaries**. Momentaries are named **push for action**
    too. In order to act on the circuit, you have to push and keep the switch pushed
    to continue the action. If you release it, the action stops.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一些被称为**瞬态开关**。瞬态开关也被称为**动作按钮**。为了对电路进行操作，你必须按下并保持开关按下以继续操作。如果你释放它，操作就会停止。
- en: Usually, all our switches at home are toggles. Except the one for the mixer
    that you have to push to cut and release to stop it, which means it is a momentary.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们家里的所有开关都是切换开关。除了你必须按下以切断并释放以停止的混音器开关，这意味着它是一个瞬态开关。
- en: A basic circuit
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本电路
- en: Here is a basic circuit with an Arduino, a momentary switch and a resistor.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个带有Arduino、一个瞬态开关和一个电阻的基本电路。
- en: We want to turn the board's built-in LED ON when we push the momentary switch
    and turn it OFF when we release it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在按下瞬态开关时打开板上的内置LED，并在释放它时关闭LED。
- en: '![A basic circuit](img/7584_05_12.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![基本电路](img/7584_05_12.jpg)'
- en: A small circuit
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 小电路
- en: I'm presenting you with the circuit on which we are going to work right now.
    This is also a nice pretext to make you more familiar with circuit diagrams.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在向您展示的是我们即将要工作的电路。这也是一个很好的理由，让你更熟悉电路图。
- en: Wires
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 电缆
- en: 'Each line represents a link between two components. By definition, a line is
    a wire and there is no electrical potential from one side to the other. It can
    also be defined as follows: a wire has a resistance of 0 ohm. Then we can say
    that two points linked by a wire have the same electrical potential.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 每条线代表两个组件之间的连接。根据定义，一条线是电缆，从一侧到另一侧没有电势。它也可以定义为以下内容：电缆的电阻为0欧姆。然后我们可以这样说，通过电缆连接的两个点具有相同的电势。
- en: The circuit in the real world
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现实世界的电路
- en: Of course, I didn't want to show you the next diagram directly. Now we have
    to build the real circuit, so please take some wires, your breadboard, and the
    momentary switch, and wire the whole circuit as shown in the next diagram.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我不想直接展示下一个图表。现在我们必须构建真实的电路，所以请拿一些电线、你的面包板和瞬态开关，并按照下一个图表所示连接整个电路。
- en: You can take a resistor around 10 Kohms. We'll explain the purpose of the resistor
    in the next pages.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以取一个大约10千欧姆的电阻。我们将在下一页解释电阻的作用。
- en: '![The circuit in the real world](img/7584_05_014.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![现实世界的电路](img/7584_05_014.jpg)'
- en: The momentary switch in a real circuit
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 真实电路中的瞬态开关
- en: Let's explain things a bit more.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释一下。
- en: Let's remember the breadboard wiring; I'm using cold and hot rails at the top
    of the breadboard (cold is blue and means ground, hot is red and means +5 V).
    After I have wired the ground and +5 V from the Arduino to the rails, I'm using
    rails to wire the other parts of the board; it is easier and requires shorter
    cables.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们记住面包板布线；我在面包板顶部使用冷线和热线（冷线是蓝色，表示地线，热线是红色，表示+5 V）。在我将地线和+5 V从Arduino连接到总线之后，我使用总线来布线板的其他部分；这更容易，并且需要更短的电缆。
- en: There is a resistor between the ground and the digital pin 2\. There is a momentary
    switch between the +5 V line and the pin 2 as well. The pin 2 will be set up as
    an input, which means it will be able to sink current.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 地线和数字引脚2之间有一个电阻。+5 V线和引脚2之间有一个瞬态开关。引脚2将被设置为输入，这意味着它能够吸收电流。
- en: Usually, switches are *push-to-on*. Pushing them closes the circuit and lets
    the current flow. So, in that case, if I don't push the switch, there is no current
    from +5 V to the pin 2.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，开关是按下开。按下它们闭合电路并允许电流流动。所以，在这种情况下，如果我不按下开关，就没有从+5 V到引脚2的电流。
- en: For the duration it is pressed, the circuit is closed. Then, current flows from
    the +5 V to the pin 2\. It is a bit metaphoric and abusive, and I should say we
    have created an electrical potential between +5 V and the pin 2, but I need to
    be shorter to hit the point home.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在按下期间，电路闭合。然后，电流从+5 V流向引脚2。这有点比喻和滥用，我应该说我在这+5 V和引脚2之间创建了一个电势，但我需要更简洁地说明这一点。
- en: And this resistor, why is it here?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这个电阻，为什么在这里？
- en: The pull-up and pull-down concept
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上拉和下拉的概念
- en: If the global circuit is easy, the resistor part can be a bit tricky at first
    sight.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果全局电路很简单，那么电阻部分一开始可能会有些棘手。
- en: A digital pin set up as an input provides the ability to *sink* current. This
    means it behaves like the ground. Indeed, and in fact, internally, it works exactly
    as if the concerned pin was connected to the ground.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 将数字引脚设置为输入提供了吸收电流的能力。这意味着它表现得像地线。实际上，内部工作方式确实就像相关的引脚连接到地线一样。
- en: With a properly coded firmware, we would have the ability to check pin 2\. This
    means we could test it and read the value of the electrical potential. Because
    it is a digital input, an electrical potential near +5 V would be translated as
    the value HIGH, and if it is near 0 V, it will be translated as the value LOW.
    Both values are constants defined inside the Arduino core. But if everything seems
    totally perfect in a perfect digital world, it is not true.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正确编码的固件，我们就有能力检查引脚2。这意味着我们可以测试它并读取电势值。因为这是一个数字输入，接近+5 V的电势会被解释为高值，而接近0 V则会被解释为低值。这两个值都是在Arduino核心内部定义的常量。但即使在一个完美的数字世界中一切看起来都完美无缺，这也并不真实。
- en: Indeed, the input signal noise could potentially be read as a button press.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，输入信号噪声可能会被误读为按钮按下。
- en: To be sure and safe, we use what we call a *pull-down resistor*. This is usually
    a high impedance resistance that provides a current sink to the digital pin considered,
    making it safer at the value 0 V if the switch is not pressed. Pull down to be
    more consistently recognized as a LOW value, pull up to be more consistently recognized
    as the HIGH value.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保安全，我们使用所谓的下拉电阻。这通常是一个高阻抗电阻，为考虑的数字引脚提供电流吸收，如果开关未按下，则使其在0 V值时更安全。下拉以更一致地识别为低值，上拉以更一致地识别为高值。
- en: Of course, the global energy consumption increases a bit. In our case, this
    is not important here but you have to know that. On this same concept, a pull-up
    resistor can be used to link the +5 V to the digital output. Generally, you should
    know that a chipset's I/O shouldn't be floating.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，全球能源消耗略有增加。在我们的情况下，这在这里并不重要，但你必须知道这一点。关于这个相同的概念，一个上拉电阻可以用来将+5 V连接到数字输出。一般来说，你应该知道芯片组的I/O不应该悬空。
- en: 'Here is what you have to remember:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是你必须记住的：
- en: '| Type of Digital Pin | Input | Output |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 数字引脚类型 | 输入 | 输出 |'
- en: '| --- | --- | --- |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Pull Resistor | Pull-down resistor | Pull-up resistor |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 上拉电阻 | 下拉电阻 | 上拉电阻 |'
- en: We want to push a switch, and particularly, this action has to turn the LED
    ON. We are going to write a pseudocode first.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要按下开关，特别是这个动作必须使LED点亮。我们首先编写伪代码。
- en: The pseudocode
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 伪代码
- en: 'Here is a possible pseudocode. Following are the steps we want our firmware
    to follow:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个可能的伪代码。以下是我们希望固件遵循的步骤：
- en: Define the pins.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义引脚。
- en: Define a variable for the current switch state.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个变量来表示当前开关状态。
- en: Set up the LED pin as an output.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将LED引脚设置为输出。
- en: Set up the switch pin as an input.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将开关引脚设置为输入。
- en: 'Set up an infinite loop. In the infinite loop do the following:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个无限循环。在无限循环中执行以下操作：
- en: Read the input state and store it.
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取输入状态并存储它。
- en: If the input state is HIGH, turn the LED ON.
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果输入状态是HIGH，则点亮LED。
- en: Else turn the LED OFF.
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则关闭LED。
- en: The code
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码
- en: 'Here is a translation of this pseudocode in valid C code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是将此伪代码翻译成有效C代码的示例：
- en: '[PRE1]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As usual you can also find the code in the `Chapter05/MonoSwitch/` folder available
    for download along with other code files on Packt Publishing's site.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，你还可以在Packt Publishing网站上找到代码，在`Chapter05/MonoSwitch/`文件夹中，以及其他可下载的代码文件。
- en: Upload it and see what happens. You should have a nice system on which you can
    push a switch and turn on an LED. Splendid!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 上传它并看看会发生什么。你应该有一个很好的系统，你可以按下一个开关并点亮一个LED。太棒了！
- en: Now let's make the Arduino board and Processing communicate with each other.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们让Arduino板和Processing相互通信。
- en: Making Arduino and Processing talk
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让Arduino和Processing进行对话
- en: Let's say we want to visualize our switch's manipulations on the computer.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在计算机上可视化我们的开关操作。
- en: We have to define a small communication protocol between Arduino and Processing.
    Of course, we'll use a serial communication protocol because it is quite easy
    to set it up and it is light.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在Arduino和Processing之间定义一个小型的通信协议。当然，我们会使用串行通信协议，因为它设置起来相当简单，而且很轻量。
- en: We could design a protocol as a library of communication. We only design a protocol
    using the native Arduino core at the moment. Then, later in this book, we will
    design a library.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将协议设计为一个通信库。目前，我们只使用本地的Arduino核心来设计协议。然后，在本书的后面部分，我们将设计一个库。
- en: The communication protocol
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通信协议
- en: A communication protocol is a system of rules and formats designed for exchanging
    messages between two entities. Those entities can be humans, computers and maybe
    more.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 通信协议是一套规则和格式，用于在两个实体之间交换消息。这些实体可以是人类、计算机，也许还有更多。
- en: 'Indeed, I''d use a basic analogy with our language. In order to understand
    each other, we have to follow some rules:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我会用一个基本的类比来解释我们的语言。为了相互理解，我们必须遵循一些规则：
- en: Syntactic and grammatical rules (I have to use words that you know)
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法和语法规则（我必须使用你知道的单词）
- en: Physical rules (I have to talk loud enough)
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理规则（我必须说得足够大声）
- en: Social rules (I shouldn't insult you just before asking you for the time)
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社交规则（我不应该在向你询问时间之前侮辱你）
- en: I could quote many other rules like the speed of talking, the distance between
    the two entities, and so on. If each rule is agreed upon and verified, we can
    talk together. Before designing a protocol, we have to define our requirements.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以引用许多其他规则，比如说话的速度、两个实体之间的距离等等。如果每个规则都被同意并验证，我们就可以一起交流。在设计协议之前，我们必须定义我们的要求。
- en: Protocol requirements
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 协议要求
- en: What do we want to do?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做什么？
- en: We need a communication protocol between our Arduino and Processing inside the
    computer. Right! These requirements are usually the same for a lot of communication
    protocols you'll design.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在计算机内部的Arduino和Processing之间建立一个通信协议。对！这些要求对于你将要设计的许多通信协议通常是相同的。
- en: 'Here is a short list of very important ones:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个非常重要的简短列表：
- en: The protocol must be expandable without having to rewrite everything each time
    I want to add new message types
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议必须能够在不重写一切的情况下扩展，每次我想添加新的消息类型时。
- en: The protocol must be able to send enough data quite quickly
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议必须能够快速发送足够的数据
- en: The protocol must be easy to understand and well commented, especially for open
    source and collaborative projects
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议必须易于理解，并且有良好的注释，特别是对于开源和协作项目。
- en: Protocol design
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 协议设计
- en: 'Each message will be 2 bytes in size. This is a common data packet size and
    I propose to organize data like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 每条消息的大小为2字节。这是一个常见的数据包大小，我建议这样组织数据：
- en: '**Byte 1**: switch number'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字节1**：开关编号'
- en: '**Byte 2**: switch state'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字节2**：开关状态'
- en: The fact that I defined byte 1 as a representation of the switch number is typically
    because of the requirement of expandability. With one switch, the number will
    be 0.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我将字节1定义为开关编号的表示，通常是因为扩展性的要求。对于一个开关，数字将是0。
- en: I can easily instantiate serial communication between the board and the computer.
    Indeed, we already made that when we used Serial Monitoring at least on the Arduino
    side.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以轻松地在板和计算机之间实例化串行通信。实际上，当我们使用串行监控时，至少在Arduino一侧我们已经做到了这一点。
- en: How can we do that using Processing?
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用Processing来实现这一点？
- en: The Processing code
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: The Processing code
- en: Processing comes with very useful set of libraries already integrated into its
    core. Specifically, we are going to use the serial library.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Processing已经内置了一个非常有用的库集。具体来说，我们将使用串行库。
- en: Let's sketch a pseudocode first, as usual.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先画一个伪代码，就像往常一样。
- en: Sketching a pseudocode
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制伪代码
- en: What do we want the program to do?
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望程序做什么？
- en: I propose to have a big circle. Its color will represent the switch's state.
    *Dark* will mean released, and *green* will mean pushed.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议有一个大圆圈。它的颜色将代表开关的状态。*深色*表示未释放，而*绿色*表示按下。
- en: 'The pseudocode can be created as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 可以如下创建伪代码：
- en: Define and instantiate the serial port.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义并实例化串行端口。
- en: Define a current drawing color to dark.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个当前绘图颜色为深色。
- en: 'In the infinite loop, do the following:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在无限循环中，执行以下操作：
- en: Check if the serial port and grab data have been received.
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查串行端口和抓取数据是否已接收。
- en: If data indicates that state is off, change current drawing from color to dark.
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果数据指示状态是关闭的，将当前绘图颜色从颜色更改为深色。
- en: Else, change current drawing color to green.
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，将当前绘图颜色更改为绿色。
- en: Draw the circle with the current drawing color.
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用当前绘图颜色绘制圆圈。
- en: Let's write that code
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 让我们写下这段代码
- en: Let's open a new processing canvas.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开一个新的Processing画布。
- en: Because the Processing IDE works like the Arduino IDE and needs to create all
    saved project files in a folder, I'd suggest that you directly save the canvas,
    even empty, in the right place on your disk. Call it `processingOneButtonDisplay`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Processing IDE的工作方式类似于Arduino IDE，需要在一个文件夹中创建所有保存的项目文件，所以我建议您直接在磁盘上的正确位置保存画布，即使它是空的。命名为`processingOneButtonDisplay`。
- en: You can find the code in the `Chapter05/processingOneButtonDisplay/` folder
    available for download along with other code files on Packt's site.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Packt网站上找到代码，位于`Chapter05/processingOneButtonDisplay/`文件夹中，可供下载，以及其他代码文件。
- en: '![Let''s write that code](img/7584_05_015.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![让我们写下这段代码](img/7584_05_015.jpg)'
- en: Making a library inclusion in your code
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的代码中包含库
- en: 'To include the serial library from the Processing core, you can go to **Sketch
    | Import Library… | serial**. It adds this row to your code: `processing.serial.*;`'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Processing核心包含串行库，您可以转到**草图 | 导入库… | 串行**。这将在您的代码中添加这一行：`processing.serial.*;`
- en: You could also type this statement by yourself.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以自己输入这个语句。
- en: 'Following is the code, with a lot of comments:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一段带有许多注释的代码：
- en: '[PRE2]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Variable definitions
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 变量定义
- en: '`theSerialPort` is an object of the `Serial` library. I have to create it first.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`theSerialPort`是`Serial`库的对象。我必须首先创建它。'
- en: '`serialBytesArray` is an array of two integers used to store messages coming
    from Arduino. Do you remember? When we designed the protocol, we talked about
    2 byte messages.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`serialBytesArray`是一个包含两个整数的数组，用于存储来自Arduino的消息。您还记得吗？当我们设计协议时，我们谈到了2字节消息。'
- en: '`switchState` and `switchID` are global but temporary variables used to store
    the switch state and the switch ID corresponding to the message coming from the
    board. Switch ID has been put there for (close) future implementation to distinguish
    the different switches in case we use more than one.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`switchState`和`switchID`是全局但临时变量，用于存储来自板子的开关状态和开关ID。开关ID被放置在那里，以便（接近）未来的实现，以便在我们要使用多个开关的情况下区分不同的开关。'
- en: '`bytesCount` is a useful variable tracking the current position in our message
    reading.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`bytesCount`是一个有用的变量，用于跟踪我们的消息读取中的当前位置。'
- en: '`init` is defined to `false` at the beginning and becomes `true` when the first
    byte from the Arduino (and a special one, `Z`) has been received for the first
    time. It is a kind of first-contact purpose.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`在开始时定义为`false`，当第一次接收到来自Arduino的第一个字节（以及一个特殊的字节，`Z`）时变为`true`。这是一种首次接触的目的。'
- en: Then, we keep a trace of the fill color and the initial one is `40`. `40` is
    only an integer and will be used a bit further as an argument of the function
    `fill()`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们跟踪填充颜色和初始颜色是`40`。`40`只是一个整数，并将稍后用作函数`fill()`的参数。
- en: setup()
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: setup()
- en: We define the canvas (size, background color, and no stroke).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义画布（大小、背景颜色和没有轮廓）。
- en: We print a list of all the serial ports available on your computer. This is
    debug information for the next statement where we store the name of the first
    serial port into a String. Indeed, you could be led to change the array element
    from 0 to the correct one according to the position of your Arduino's port in
    the printed list.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打印出计算机上可用的所有串行端口的列表。这是下一个语句的调试信息，我们将第一个串行端口的名称存储到一个String中。实际上，您可能需要根据打印列表中Arduino端口的定位将数组元素从0更改为正确的位置。
- en: This String is then used in the very important statement that instantiates serial
    communication at 9600 bauds.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字符串随后被用于一个非常重要的语句，该语句在 9600 波特率下实例化串行通信。
- en: This `setup()` function, of course, runs only once.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个 `setup()` 函数只运行一次。
- en: draw()
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: draw()
- en: The draw function is very light here.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，draw 函数非常简单。
- en: We pass the variable `fillColor` to the `fill()` function, setting up the color
    with which all further shapes will be filled.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将变量 `fillColor` 传递给 `fill()` 函数，设置所有后续形状填充的颜色。
- en: 'Then, we draw the circle with the ellipse function. This function takes four
    arguments:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用椭圆函数绘制圆形。这个函数接受四个参数：
- en: x coordinates of the center of the ellipse (here `width/2`)
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 椭圆中心的 x 坐标（这里 `width/2`）
- en: y coordinates of the center of the ellipse (here `height/2`)
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 椭圆中心的 y 坐标（这里 `height/2`）
- en: Width of the ellipse (here `230`)
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 椭圆的宽度（这里 `230`）
- en: Height of the ellipse (here `230`)
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 椭圆的高度（这里 `230`）
- en: '`width` and `height` colored in blue in the Processing IDE are the current
    width and height of the canvas. It is very useful to use them because if you change
    the `setup()` statement by choosing a new size for the canvas, all `width` and
    `height` in your code will be updated automatically without needing to change
    them all manually.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Processing IDE 中用蓝色标注的 `width` 和 `height` 是画布的当前宽度和高度。使用它们非常有用，因为如果你通过选择新的画布大小更改
    `setup()` 语句，你的代码中所有的 `width` 和 `height` 都会自动更新，而无需手动更改它们。
- en: Please keep in mind that an ellipse with same values for `width` and `height`
    is a circle (!). Ok. But where is the magic here? It will only draw a circle,
    every time the same one (size and position). `fillColor` is the only variable
    of the `draw()` function. Let's see that strange callback named `serialEvent()`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，宽度和高度相同的椭圆是一个圆（！）！好的。但是这里的魔法在哪里？它只会绘制一个圆形，每次都是同一个（大小和位置）。`fillColor` 是 `draw()`
    函数的唯一变量。让我们看看那个奇怪的回调 `serialEvent()`。
- en: The serialEvent() callback
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: serialEvent() 回调
- en: We talked about callbacks in [Chapter 4](ch04.html "Chapter 4. Improve Programming
    with Functions, Math, and Timing"), *Improve Programming with Functions, Math,
    and Timing*.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 4 章](ch04.html "第 4 章。通过函数、数学和计时改进编程") 中讨论了回调，*通过函数、数学和计时改进编程*。
- en: Here, we have a pure callback method in Processing. This is an event-driven
    callback. It is useful and efficient not to have to poll every time our serial
    port wants to know if there is something to read. Indeed, user interfaces related
    events are totally less numerous than the number of Arduino board's processor
    cycles. It is smarter to implement a callback in that case; as soon as a serial
    event occurs (that is, a message is received), we execute a series of statements.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们在 Processing 中有一个纯回调方法。这是一个事件驱动的回调。在这种情况下，不必每次轮询我们的串行端口是否需要读取数据是有用且高效的。确实，与用户界面相关的事件数量远少于
    Arduino 板的处理器周期数。在这种情况下实现回调更聪明；一旦发生串行事件（即接收到消息），我们就执行一系列语句。
- en: '`myPort.read()` will first read the bytes received. Then we make the test with
    the `init` variable. Indeed, if this is the very first message, we want to check
    if the communication has already begun.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`myPort.read()` 首先读取接收到的字节。然后我们使用 `init` 变量进行测试。实际上，如果是第一条消息，我们想检查通信是否已经启动。'
- en: In the case where it is the first hello (`init == false`), if the message coming
    from the Arduino Board is `Z`, Processing program clear its own serial port, stores
    the fact the communication has just started, and resends back `Z` to the Arduino
    board. It is not so tricky.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次“你好”（`init == false`）的情况下，如果来自 Arduino 板的消息是 `Z`，Processing 程序会清除自己的串行端口，存储通信刚刚开始的事实，并将
    `Z` 重新发送回 Arduino 板。这并不复杂。
- en: 'It can be illustrated as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以如下说明：
- en: Imagine we can begin to talk only if we begin by saying "hello" to each other.
    We aren't watching each other (no event). Then I begin to talk. You turn your
    head to me (serial event occurs) and listen. Am I saying "hello" to you? (whether
    the message is `Z`?). If I'm not, you just turn your head back (no `else` statement).
    If I am, you answer "hello" (sending back `Z`) and the communication begins.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们只有通过先互相说“你好”才能开始交谈。我们并没有互相观察（没有事件）。然后我开始说话。你转向我（串行事件发生）并倾听。我是不是在对你说“你好”？（消息是否为
    `Z`？）。如果不是，你只需转回你的头（没有 `else` 语句）。如果是，你回答“你好”（发送回 `Z`），通信就开始了。
- en: What happens then?
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，接下来会发生什么呢？
- en: If communication has already begun, we have to store bytes read into the `serialBytesArray`
    and increment the `bytesCount`. While bytes are being received and `bytesCount`
    is smaller or equal to 1, this means we don't have a complete message (a complete
    message is two bytes) and we store more bytes in the array.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通信已经开始，我们必须将读取的字节存储到`serialBytesArray`中，并增加`bytesCount`。当字节正在接收且`bytesCount`小于或等于1时，这意味着我们没有完整的消息（一个完整的消息是两个字节），因此我们在数组中存储更多的字节。
- en: 'As soon as the bytes count equals `2`, we have a complete message and we can
    "split" it into the variables `switchID` and `switchState`. Here''s how we do
    that:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当字节计数等于`2`时，我们就有了完整的消息，我们可以将其“分割”成变量`switchID`和`switchState`。我们是这样做的：
- en: '[PRE3]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This next statement is a debug one: we print each variable. Then, the core
    of the method is the test of the `switchState` variable. If it is `0`, it means
    the switch is released, and we modify the `fillColor` to `40` (dark color, `40`
    means the value 40 for each RGB component; check `color()` method in Processing
    reference at [http://processing.org/reference/color_.html](http://processing.org/reference/color_.html)).
    If it isn''t `0`, we modify the `fillColor` to `255`, which means white. We could
    be a bit safer by not using only `else`, but `else if (switchState ==1)` also.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个语句是一个调试语句：我们打印每个变量。然后，方法的核心是测试`switchState`变量。如果它是`0`，这意味着开关被释放，我们将`fillColor`修改为`40`（深色，`40`表示每个RGB组件的值40；请查看Processing参考中的`color()`方法[http://processing.org/reference/color_.html](http://processing.org/reference/color_.html)）。如果不是`0`，我们将`fillColor`修改为`255`，这意味着白色。我们可以通过不只用`else`，而是用`else
    if (switchState ==1)`来更安全一些。
- en: Why? Because if we are not sure about all the messages that can be sent (lack
    of documentation or whatever else making us unsure), we can modify the color to
    white *only* if `switchState` equals `1`. This concept can be done at the optimization
    state too, but here, it is quite light so we can leave it like that.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？因为我们不确定可以发送的所有消息（缺乏文档或其他使我们不确定的原因），只有当`switchState`等于`1`时，我们才能将颜色修改为白色。这个概念也可以在优化状态下完成，但在这里，它相当简单，所以我们可以保持原样。
- en: Ok. It is a nice, heavy piece, right? Now, let's see how we have to modify the
    Arduino code. Do you remember? It isn't communication ready yet.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。这是一件既好又重的东西，对吧？现在，让我们看看我们如何修改Arduino代码。你还记得吗？它还没有准备好通信。
- en: The new Arduino firmware talk-ready
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的Arduino固件已准备好进行通信
- en: 'Because we now have a nice way to display our switch state, I''ll remove all
    things related to the built-in LED of the board and following is the result:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们现在有了一种很好的方式来显示开关状态，所以我将移除与板载内置LED相关的一切，以下是结果：
- en: '[PRE4]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What do we have to add? All the `Serial` stuff. I also want to add a small function
    dedicated to the first "hello".
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加什么？所有的`Serial`相关内容。我还想添加一个专门用于第一个“hello”的小函数。
- en: 'Here is the result, then we will see the explanations:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果，然后我们将看到解释：
- en: '[PRE5]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'I''m defining one new variable first: `inByte`. This stores the bytes read.
    Then inside the `setup()` method, I''m instantiating serial communication as we
    already learned to do with Arduino. I''m setting up the `pinMode` method of the
    switch pin then, I''m calling `sayHello()`.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先定义了一个新变量：`inByte`。它存储读取的字节。然后，在`setup()`方法中，我实例化了串行通信，就像我们之前学习的那样使用Arduino。然后，我设置了开关引脚的`pinMode`方法，然后调用`sayHello()`。
- en: This function just waits for something. Please focus on this.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数只是等待某事发生。请集中注意这一点。
- en: I'm calling this function in `setup()`. This is a *simple* call, not a callback
    or whatever else. This function contains a `while` loop while `Serial.available()`
    is smaller or equal to zero. What does this mean? It means this function pauses
    the `setup()` method while the first byte comes to the serial port of the Arduino
    board. The `loop()` done doesn't run while the `setup()` done has finished, so
    this is a nice trick to wait for the first external event; in this case, the first
    communication. Indeed, the board is sending the message `Z` (that is, the "hello")
    while Processing doesn't answer.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我在`setup()`中调用这个函数。这是一个简单的调用，不是一个回调或其他任何东西。这个函数包含一个`while`循环，当`Serial.available()`小于或等于零时。这意味着什么？这意味着这个函数在第一个字节到达Arduino板的串行端口时暂停`setup()`方法。`loop()`在`setup()`完成之前不会运行，所以这是一个很好的技巧来等待第一个外部事件；在这种情况下，第一次通信。实际上，当Processing没有回答时，板正在发送消息`Z`（即，“hello”）。
- en: 'The consequence is that when you can plug in your board, it sends `Z` continuously
    while you run your Processing program. Then the communication begins and you can
    push the switch and see what is happening. Indeed, as soon as the communication
    begins, `loop()` begins its infinite loop. At first a test is made at each cycle
    and we only test if a byte is being received. Whatever the byte received (Processing
    only sends `Z` to the board), we read the digital pin of the switch and send back
    two bytes. Here too, pay attention please: each byte is written to the serial
    port using `Serial.write()`. You have to send 2 bytes, so you stack two `Serial.write()`.
    The first byte is the number (ID) of the switch that is pushed/released; here,
    it is not a variable because we have one and only one switch, so it is an integer
    0\. The second byte is the switch state. We just saw here a nice design pattern
    involving the board, an external program running on a computer and a communication
    between both of them.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，当你插入你的板时，它会在你运行Processing程序时连续发送`Z`。然后开始通信，你可以按开关并查看发生了什么。实际上，一旦通信开始，`loop()`就开始它的无限循环。首先在每个周期进行测试，我们只测试是否有字节被接收。无论接收到的字节是什么（Processing只向板发送`Z`），我们都读取开关的数字引脚并发送两个字节。请注意：每个字节都是使用`Serial.write()`写入串行端口的。你必须发送2个字节，所以你需要堆叠两个`Serial.write()`。第一个字节是按下的/释放的开关的编号（ID）；在这里，它不是一个变量，因为我们只有一个开关，所以它是一个整数0。第二个字节是开关状态。我们刚才看到了一个很好的设计模式，涉及板、在计算机上运行的外部程序以及两者之间的通信。
- en: Now, let's go further and play with more than one switch.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更进一步，玩转一个以上的开关。
- en: Playing with multiple buttons
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩转多个按钮
- en: We can extrapolate our previously designed logic with more than one switch.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用一个以上的开关来扩展我们之前设计的逻辑。
- en: There are many ways to use multiple switches, and, in general, multiple inputs
    on the Arduino. We're going to see a cheap and easy first way right now. This
    way doesn't involve multiplexing a lot of inputs on only a couple of Arduino inputs
    but a basic one to one wiring where each switch is wired to one input. We'll learn
    multiplexing a bit later (in the next chapter).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个开关的方法有很多，通常在Arduino上也有多个输入。我们现在将看到一种既便宜又简单的方法。这种方法不涉及在仅几个Arduino输入上复用大量输入，而是一种基本的点对点连接，其中每个开关都连接到一个输入。我们将在稍后学习复用（在下一章中）。
- en: The circuit
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电路
- en: 'Following is the circuit diagram required to work with multiple switches:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是与多个开关一起工作所需的电路图：
- en: '![The circuit](img/7584_05_16.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![电路图](img/7584_05_16.jpg)'
- en: Wiring three momentary switches to the Arduino board
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 将三个瞬态开关连接到Arduino板
- en: The schematic is an extrapolation of the previous one that showed only one switch.
    We can see the three switches between the +5 V and the three pull-down resistors.
    Then we can also see the three wires going to digital inputs 2 to 4 again.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 电路图是对之前只显示一个开关的电路图的扩展。我们可以看到三个开关位于+5V和三个下拉电阻之间。然后我们还可以看到连接到数字输入2到4的三根线。
- en: 'Here is a small memory refresh: Why didn''t I use the digital pins 0 or 1?'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个小的记忆刷新：为什么我没有使用数字引脚0或1？
- en: Because I'm using serial communication from the Arduino, we cannot use the digital
    pins 0 and 1 (each one respectively corresponding to RX and TX used in serial
    communication). Even if we are using the USB link as the physical support for
    our serial messages, the Arduino board is designed like that and we have to be
    very careful with it.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我在Arduino中使用串行通信，所以我们不能使用数字引脚0和1（每个分别对应于串行通信中使用的RX和TX）。即使我们使用USB链路作为我们串行消息的物理支持，Arduino板也是这样设计的，我们必须非常小心。
- en: Here is the circuit view with the breadboard. I voluntarily didn't align every
    wire. Why? Don't you remember that I want you to be totally autonomous after reading
    this book and yes, you'll find many schematics in the real world made sometimes
    like that. You have to become familiar with them too. It could be an (easy) homework
    assignment.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这是带有面包板的电路视图。我故意没有对齐每一根线。为什么？你不记得我想要你在阅读这本书后完全自主吗？是的，你会在现实世界中找到很多这样的电路图。你也必须熟悉它们。这可能是一个（简单的）家庭作业。
- en: '![The circuit](img/7584_05_017.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![电路图](img/7584_05_017.jpg)'
- en: The preceding circuit shows the three switches, the three pull-down resistors,
    and the Arduino board.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的电路显示了三个开关、三个下拉电阻和Arduino板。
- en: Both source codes have to be modified to provide a support for the new circuit.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 必须修改两个源代码以提供对新电路的支持。
- en: Let's add things there.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在那里添加一些内容。
- en: The Arduino code
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Arduino代码
- en: 'Here is the new code; of course, you can find it in the `Chapter05/MultipleSwitchesWithProcessing/`
    folder available for download along with other code files on Packt''s site:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是新的代码；当然，你可以在 Packt 网站上找到它，在 `Chapter05/MultipleSwitchesWithProcessing/` 文件夹中，与其他代码文件一起可供下载：
- en: '[PRE6]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let's explain this code.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来解释这段代码。
- en: At first, I defined a constant `switchesNumber` to the number `3`. This number
    can be changed to any other number from `1` to `12`. This number represents the
    current number of switches wired to the board from digital pin 2 to digital pin
    14\. All switches have to be linked without an empty pin between them.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将一个常量 `switchesNumber` 定义为数字 `3`。这个数字可以从 `1` 到 `12` 中的任何其他数字更改。这个数字代表当前连接到板上的开关数量，从数字引脚
    2 到数字引脚 14。所有开关都必须相互连接，中间不能有空引脚。
- en: Then, I defined an array to store the switch's states. I declared it using the
    `switchesNumber` constant as the length. I have to fill this array with zeroes
    in the `setup()` method, that I made with a `for` loop. It provides a safe way
    to be sure that all switches have a release state in the code.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我定义了一个数组来存储开关的状态。我使用 `switchesNumber` 常量作为长度来声明它。我必须在 `setup()` 方法中用 `for`
    循环填充这个数组，我创建了一个 `for` 循环。这提供了一种安全的方式，确保代码中所有开关都有一个释放状态。
- en: I still use the `sayHello()` function, to set up the communication start with
    Processing.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我仍然使用 `sayHello()` 函数来设置与 Processing 的通信开始。
- en: Indeed, I have to fill each switch state in the array `switchesStates` so I
    added the `for` loop. Please notice the index trick in each `for` loop. Indeed,
    because it seems to be more convenient to start from 0 and because in the real
    world we mustn't use digital pins 0 and 1 while using serial communications, I
    added `2` as soon as I dealt with the real number of the digital pin, that is,
    with the two functions `pinMode()` and `digitalRead()`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，我必须填充数组 `switchesStates` 中的每个开关状态，所以我添加了 `for` 循环。请注意每个 `for` 循环中的索引技巧。实际上，因为从
    0 开始似乎更方便，而且在现实世界中，在使用串行通信时我们绝对不能使用数字引脚 0 和 1，所以我一处理实际的数字引脚数量，也就是使用 `pinMode()`
    和 `digitalRead()` 这两个函数时，就立即添加了 `2`。
- en: Now, let's upgrade the Processing code too.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们也升级一下 Processing 代码。
- en: The Processing code
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Processing 代码
- en: 'Here is the new code; you can find it in the `Chapter05/MultipleSwitchesWithProcessing/`
    folder available for download along with other code files on Packt''s site:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是新的代码；你可以在 Packt 网站的 `Chapter05/MultipleSwitchesWithProcessing/` 文件夹中找到它，与其他代码文件一起可供下载：
- en: '[PRE7]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Following is a screenshot of the render of this code used with five switches
    while I was pushing on the fourth button:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用五个开关并按下第四个按钮时此代码渲染的截图：
- en: '![The Processing code](img/7584_05_020.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![Processing 代码](img/7584_05_020.jpg)'
- en: So, what did I alter?
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我改变了什么？
- en: Following the same concept as with the Arduino code, I added a variable (not
    a constant here), named `switchesNumber`. A nice evolution could be to add something
    to the protocol about the number of the switch. For instance, the Arduino board
    could inform Processing about the switch's number according to only one constant
    defined in the Arduino firmware. This would save the manual update of the processing
    code when we change this number.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Arduino 代码中的概念相同，我添加了一个变量（不是一个常量），命名为 `switchesNumber`。一个很好的进化可能是向协议中添加有关开关数量的内容。例如，Arduino
    板可以根据 Arduino 固件中定义的一个常量来通知 Processing 开关的编号。这将节省我们在更改此数字时手动更新 processing 代码的时间。
- en: 'I also transformed the variable `switchState` into an array of integers `switchesStates`.
    This one stores all the switches'' states. I added two variables related to the
    display: `distanceCircles` and `radii`. Those are used for dynamically displaying
    the position of circles according to the number of switches. Indeed, we want one
    circle per switch.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将变量 `switchState` 转换成了一个整数数组 `switchesStates`。这个数组存储了所有开关的状态。我添加了两个与显示相关的变量：`distanceCircles`
    和 `radii`。这些用于根据开关的数量动态显示圆的位置。实际上，我们希望每个开关对应一个圆。
- en: The `setup()` function is almost the same as before.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup()` 函数几乎和之前一样。'
- en: I'm calculating here the distance between two circles by dividing the width
    of the canvas by the number of circles. Then, I'm calculating the radii of each
    circle by using the distance between them divided by 2\. These numbers can be
    changed. You could have a very different aesthetical choice.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里通过将画布宽度除以圆的数量来计算两个圆之间的距离。然后，我通过将它们之间的距离除以 2 来计算每个圆的半径。这些数字可以更改。你可以有非常不同的审美选择。
- en: Then the big difference here is also the `for` loop. I'm filling the whole `switchesStates`
    array with zeroes to initialize it. At the beginning, none of the switches are
    pushed. The `draw()` function now also includes a `for` loop. Pay attention here.
    I removed the `fillColor` method because I moved the fill color choice to the
    draw. This is an alternative, showing you the flexibility of the code.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的大不同之处也是`for`循环。我在整个`switchesStates`数组中填充零以初始化它。一开始，没有任何开关被按下。现在的`draw()`函数也包括一个`for`循环。请注意这里。我移除了`fillColor`方法，因为我将填充颜色的选择移到了`draw`中。这是一个替代方案，向你展示代码的灵活性。
- en: In the same for loop, I'm drawing the circle number *i*. I will let you check
    for yourself how I have placed the circles. The `serialEvent()` method doesn't
    change a lot either. I removed the fill color change as I wrote before. I also
    used the `switchesStates` array, and the index provided by the first byte of the
    message that I stored in `switchID`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个`for`循环中，我在绘制圆号*i*。我将让你自己检查我是如何放置这些圆圈的。`serialEvent()`方法也没有太多变化。正如我之前写的，我移除了填充颜色的变化。我还使用了`switchesStates`数组，以及存储在`switchID`中的消息的第一个字节的索引。
- en: Now, you can run the code on each side after you have uploaded the firmware
    on the Arduino board.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你在Arduino板上上传了固件后，可以在每一侧运行代码。
- en: Magic? I guess you now know that it isn't magic at all, but beautiful, maybe.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法？我想你现在知道这根本不是魔法，而是美丽的，也许吧。
- en: Let's go a bit further talking about something important about switches, but
    also related to other switches.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步讨论关于开关的一些重要内容，同时也与其他开关相关。
- en: Understanding the debounce concept
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解去抖动概念
- en: Now here is a small section that is quite cool and light compared to analog
    inputs, which we will dive into in the next chapter.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有一个小节，与模拟输入相比，它相当酷且轻巧，我们将在下一章深入探讨。
- en: We are going to talk about something that happens when someone pushes a button.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论当有人按下按钮时发生的事情。
- en: What? Who is bouncing?
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么？谁在弹跳？
- en: Now, we have to take our microscopic biocybernetic eyes to zoom into the switch's
    structure.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须用我们的微观生物控制论眼睛来放大开关的结构。
- en: A switch is made with pieces of metal and plastic. When you push the cap, a
    piece of metal moves and comes into contact with another piece of metal, closing
    the circuit. Microscopically and during a very small time interval, things aren't
    that clean. Indeed, the moving piece of metal bounces against the other part.
    With an oscilloscope measuring the electrical potential at the digital pin of
    the Arduino, we can see some noise in the voltage curve around 1 ms after the
    push.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 开关是由金属和塑料制成的。当你按下盖子时，一块金属移动并接触到另一块金属，闭合电路。在微观层面和非常短的时间间隔内，事情并不那么干净。实际上，移动的金属片会弹跳到另一部分。通过使用示波器测量Arduino数字引脚上的电势，我们可以在按下后大约1毫秒的电压曲线上看到一些噪声。
- en: These oscillations could generate incorrect inputs in some programs. Imagine,
    that you want to count the states transitions in order, for instance, to run something
    when the user pushed the switch seven times. If you have a bouncing system, by
    pushing only once, the program could count a lot of transitions even if the user
    pushed the switch only once.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这些振荡可能会在某些程序中生成错误的输入。想象一下，你想要按顺序计数状态转换，例如，当用户按下开关七次时运行某些操作。如果你有一个弹跳系统，通过只按一次，程序可能会计数很多转换，即使用户只按了一次开关。
- en: 'Check the next graph. It represents the voltage in relation to time. The small
    arrows on the time axis show the moment when the switch has been pushed:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 查看下一个图表。它表示电压与时间的关系。时间轴上的小箭头显示了开关被按下的时刻：
- en: '![What? Who is bouncing?](img/7584_05_18.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![什么？谁在弹跳？](img/7584_05_18.jpg)'
- en: How can we deal with these oscillations?
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何处理这些振荡？
- en: How to debounce
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何去抖动
- en: 'We have two distinct elements on which we can act:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个不同的元素，我们可以对其施加作用：
- en: The circuit itself
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电路本身
- en: The firmware
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固件
- en: The circuit itself can be modified. I could quote some solutions such as adding
    diodes, capacitors, and some Schmitt trigger inverters. I won't explain that solution
    in detail because we are going to do that in software, but I can explain the global
    concept. The capacitor in that case will be charged and discharged while the switch
    will be bouncing, smoothing those peaks of noise. Of course, some tests are needed
    in order to find the perfect components fitting your precise needs.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 电路本身可以进行修改。我可以引用一些解决方案，例如添加二极管、电容器和一些施密特触发器反相器。我不会详细解释这个解决方案，因为我们将在软件中实现它，但我可以解释全局概念。在这种情况下，电容器将在开关弹跳时充电和放电，从而平滑噪声的峰值。当然，需要进行一些测试，以找到适合您精确需求的完美组件。
- en: The firmware can also be modified.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 固件也可以进行修改。
- en: Basically, we can use a time-based filter, because the bounce occurs during
    a particular amount of time.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们可以使用基于时间的过滤器，因为弹跳发生在特定的时间段内。
- en: 'Following is the code, then will come explanations:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是代码，然后是解释：
- en: '[PRE8]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Following is an example of the debouncing cycle.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是去抖动周期的示例。
- en: 'At the beginning, I defined some variables:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，我定义了一些变量：
- en: '`lastSwitchState`: This stores the last read state'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lastSwitchState`：此变量存储最后一个读取的状态'
- en: '`lastDebounceTime`: This stores the moment when the last debounce occurred'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lastDebounceTime`：此变量存储上次去抖动发生的时间'
- en: '`debounceDelay`: This is the value during which nothing is taken as a safe
    value'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debounceDelay`：这是在此期间被视为安全值的值'
- en: We are using `millis()` here in order to measure the time. We already talked
    about this time function in [Chapter 4](ch04.html "Chapter 4. Improve Programming
    with Functions, Math, and Timing"), *Improve Programming with Functions, Math,
    and Timing*.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用`millis()`来测量时间。我们已经在[第4章](ch04.html "第4章。使用函数、数学和定时改进编程")中讨论了此时间函数，*使用函数、数学和定时改进编程*。
- en: Then, at each `loop()` cycle, I read the input but basically I don't store it
    in the `switchState` variable that is used to the test to turning ON or OFF the
    LED. Basically, I used to say that `switchState` is the official variable that
    I don't want to modify before the debounce process. Using other terms, I can say
    that I'm storing something in `switchState` only when I'm sure about the state,
    not before.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在每次`loop()`周期中，我读取输入，但基本上我不将其存储在用于测试LED开关的`switchState`变量中。基本上，我过去常说`switchState`是官方变量，我不希望在去抖动过程之前修改它。用其他话说，我只有在确定状态时才将东西存储在`switchState`中，而不是在此之前。
- en: So I read the input at each cycle and I store it in `readInput`. I compare `readInput`
    to the `lastSwitchState` variable that is the last read value. If both variables
    are different, what does it mean? It means a change occurs, but it can be a bounce
    (unwanted event) or a real push. Anyway, in that case, we reset the counter by
    putting the current time provided by `millis()` to `lastDebounceTime`.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我在每个周期读取输入并将其存储在`readInput`中。我将`readInput`与最后一个读取的值`lastSwitchState`变量进行比较。如果这两个变量都不同，这意味着什么？这意味着发生了变化，但可能是弹跳（不希望的事件）或真实的推动。无论如何，在这种情况下，我们将通过将`millis()`提供的当前时间放入`lastDebounceTime`来重置计数器。
- en: Then, we check if the time since the last debounce is greater than our delay.
    If it is, then we can consider the last `readInput` in this cycle as the real
    switch state and we can store it into the corresponding variable. In the other
    case, we store the last read value into `lastSwitchState` to keep it for the next
    cycle comparison.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查自上次去抖动以来经过的时间是否大于我们的延迟。如果是，那么我们可以考虑在这个周期中的最后一个`readInput`作为实际的开关状态，并将其存储到相应的变量中。在另一种情况下，我们将最后一个读取的值存储到`lastSwitchState`中，以供下一个周期的比较。
- en: This method is a general concept used to smooth inputs.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法是一个用于平滑输入的一般概念。
- en: We can find here and there some examples of software debouncing used not only
    for switches but also for noisy inputs. In everything related to a user-driven
    event, I would advise using this kind of debouncer. But for everything related
    to system communication, debounce can be very useless and even a problem, because
    we can ignore some important messages and data. Why? Because a communication system
    is much faster than any user, and if we can use 50 ms as the time during which
    nothing is considered as a real push or a real release with users, we cannot do
    that for very fast chipset signals and other events that could occurs between
    systems themselves.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在各个地方找到一些软件去抖动的例子，这些例子不仅用于开关，也用于噪声输入。在所有与用户驱动事件相关的内容中，我都会建议使用这种去抖动器。但对于所有与系统通信相关的内容，去抖动可能非常无用，甚至可能成为问题，因为我们可能会忽略一些重要的消息和数据。为什么？因为通信系统比任何用户都要快得多，如果我们可以将50毫秒作为用户认为真实推动或释放的时间，那么我们无法将这个时间应用于非常快速的芯片信号和其他系统之间可能发生的事件。
- en: Summary
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have learnt a bit more about digital inputs. Digital inputs can be used *directly*,
    as we just did, or also *indirectly*. I'm using this term because indeed, we can
    use other peripherals for encoding data before sending them to digital inputs.
    I used some distance sensors that worked like that, using digital inputs and not
    analog inputs. They encoded distance and popped it out using the I2C protocol.
    Some specific operations were required to extract and use the distance. In this
    way, we are making an indirect use of digital inputs.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对数字输入的了解又深入了一些。数字输入可以直接使用，就像我们刚才做的那样，也可以间接使用。我使用这个术语是因为确实，我们可以在将数据发送到数字输入之前使用其他外围设备对数据进行编码。我使用了一些类似这样的距离传感器，使用数字输入而不是模拟输入。它们通过I2C协议编码距离并将数据输出。提取和使用距离需要一些特定的操作。这样，我们就是在间接使用数字输入。
- en: Another nice way to sense the world is the use of analog inputs. Indeed, this
    opens a new world of continuous values. Let's move on.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种感知世界的好方法是使用模拟输入。确实，这开启了一个连续值的新世界。让我们继续前进。
