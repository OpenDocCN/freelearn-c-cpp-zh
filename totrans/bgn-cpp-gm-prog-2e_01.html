<html><head></head><body>
		<div id="_idContainer006">
			<h1 id="_idParaDest-7"><a id="_idTextAnchor007"/>Preface</h1>
			<p>This book is all about offering you a fun introduction to the world of game programming, C++, and the OpenGL-powered SFML using five fun, fully playable games of increasing difficulty and advancing features. These games are an addictive, frantic two-button tapper, a Pong game, a multilevel zombie survival shooter, a split-screen multiplayer puzzle platformer, and a shooter game.</p>
			<p>With this improved and extended second edition, we will start with the very basics of programming, such as variables, loops, and conditions, and you will become more skillful with each game as you move through the key C++ topics, such as <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>), C++ pointers, and an introduction to the <strong class="bold">Standard Template Library</strong> (<strong class="bold">STL</strong>). While building these games, you will also learn exciting game programming concepts, such as particle effects, directional sound (spatialization), OpenGL programmable Shaders, how to spawn thousands of objects, and more.</p>
			<h1 id="_idParaDest-8"><a id="_idTextAnchor008"/>Who this book is for</h1>
			<p>This book is perfect for you if any of the following describes you: You have no C++ programming knowledge whatsoever, or need a beginner level refresher course, if you want to learn to build games or just use games as an engaging way to learn C++, if you have aspirations to publish a game one day, perhaps on Steam, or if you just want to have loads of fun and impress friends with your creations.</p>
			<h1 id="_idParaDest-9"><a id="_idTextAnchor009"/>What this book covers</h1>
			<p><a href="B14278_01_Final_AG_ePub.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">C++, SFML, Visual Studio, and Starting the First Game</em>, represents quite a hefty first chapter, but we will learn absolutely everything we need in order to have the first part of our first game up and running. Here is what we will do: Find out about the games we will build, discover C++, find out about Microsoft Visual C++, explore SFML and its relationship with C++, set up the development environment, plan and prepare for the first game project, Timber!!!, write the first C++ code in the book, and make a runnable game that draws a background.</p>
			<p><a href="B14278_02_Final_AG_ePub.xhtml#_idTextAnchor070"><em class="italic">Chapter </em><em class="italic">2</em></a>, <em class="italic">Variables, Operators, and Decisions – Animating Sprites</em>, covers quite a bit more drawing on screen and, in order to achieve this, we will need to learn some of the basics of C++. We will learn how to use variables to remember and manipulate values, and we will also begin to add more graphics to the game. As the chapter progresses, we will see how we can manipulate these values to animate the graphics. These values are known as variables.</p>
			<p><a href="B14278_03_Final_AG_ePub.xhtml#_idTextAnchor098"><em class="italic">Chapter 3</em></a>, <em class="italic">C++ Strings and SFML Time – Player Input and HUD</em>, continues with the Timber!!! game. We will spend half the chapter learning how to manipulate text and display it on the screen, and the other half looking at timing and how a visual time bar can inform the player and create a sense of urgency in the game. We will cover the following: Pausing and restarting the game, C++ Strings, SFML Text and SFML Font classes, adding an HUD to Timber!!!, and adding a time bar to Timber!!!.</p>
			<p><a href="B14278_04_Final_AG_ePub.xhtml#_idTextAnchor110"><em class="italic">Chapter 4</em></a><em class="italic">, Loops, Arrays, Switches, Enumerations, and Functions – Implementing Game Mechanics</em>, probably has more C++ information than any other chapter in the book. It is packed with fundamental concepts that will improve our understanding enormously. It will also begin to shed light on some of the murky areas we have been skipping over a little bit, such as functions and the game loop. Once we have explored a whole list of C++ language necessities, we will then use everything we know to make the main game mechanics—the tree branches—move. By the end of this chapter, we will be ready for the final phase and the completion of Timber!!!. This is what we will explore in this chapter: Loops, arrays, making decisions with switches, enumerations, getting started with functions, and creating and moving the tree branches.</p>
			<p><a href="B14278_05_Final_AG_ePub.xhtml#_idTextAnchor138"><em class="italic">Chapter 5</em></a>, <em class="italic">Collisions, Sound, and End Conditions – Making the Game Playable</em>, constitutes the final phase of the first project. By the end of this chapter, you will have your first completed game. Once you have Timber!!! up and running, be sure to read the final section of this chapter as it will suggest ways to make the game better. In this chapter, we will cover the following topics: Adding the remainder of the sprites, handling the player input, animating the flying log, handling death, adding sound effects, adding features, and improving Timber!!!.</p>
			<p><a href="B14278_06_Final_AG_ePub.xhtml#_idTextAnchor154"><em class="italic">Chapter 6</em></a>, <em class="italic">Object-Oriented Programming – Starting the Pong Game</em>, contains quite a large amount of theory, but the theory will give us the knowledge to start using OOP to powerful effect. Furthermore, we will not waste any time in putting that theory to good use coding the next project, a Pong game. We get to look behind the scenes at how we can create new types that we use as objects by coding a class. We will first look at a simplified Pong scenario to learn some class basics, and then we will start again and code a Pong game for real using the principles we have learned.</p>
			<p><a href="B14278_07_Final_AG_ePub.xhtml#_idTextAnchor175"><em class="italic">Chapter 7</em></a>, <em class="italic">Dynamic Collision Detection and Physics – Finishing the Pong Game</em>, explains how to code our second class. We will see that although the ball is obviously quite different from the bat, we will use the exact same techniques to encapsulate the appearance and functionality of a ball inside a <strong class="source-inline">Ball</strong> class, as we did with the bat and the <strong class="source-inline">Bat</strong> class. We will then add the finishing touches to the Pong game by coding some dynamic collision detection and score keeping. This may sound complicated, but, as we are coming to expect, SFML will make things much easier than they otherwise would be.</p>
			<p><a href="B14278_08_Final_AG_ePub.xhtml#_idTextAnchor183"><em class="italic">Chapter 8</em></a><em class="italic">, SFML Views – Starting the Zombie Shooter Game</em>, explains how this project makes even more use of OOP, and to a powerful effect. We will also be exploring the SFML <strong class="source-inline">View</strong> class. This versatile class will enable us to easily divide our game up into layers for different aspects of the game. In the Zombie Shooter project, we will have a layer for the HUD and a layer for the main game. This will be necessary because, as the game world expands each time the player clears a wave of zombies, eventually, the game world will be bigger than the screen and will need to scroll. The use of the View class will prevent the text from the HUD from scrolling with the background. In the next project, we will take things even further and create a co-op split-screen game with the SFML View class doing most of the hard work. This is what we will do in this chapter: Plan the Zombie Arena game, code the <strong class="source-inline">Player</strong> class, learn about the SFML View class, and build the Zombie Arena game engine, putting the player class to work.</p>
			<p><a href="B14278_09_Final_AG_ePub.xhtml#_idTextAnchor200"><em class="italic">Chapter 9</em></a>, <em class="italic">C++ References, Sprite Sheets, and Vertex Arrays</em>, explores C++ references, which allow us to work on variables and objects that are otherwise out of scope. In addition, references will help us to avoid having to pass large objects between functions, which is a slow process. It is a slow process because each time we do this, a copy of the variable or object must be made. Armed with this new knowledge about references, we will look at the SFML <strong class="source-inline">VertexArray</strong> class, which allows us to build up a large image that can be very quickly and efficiently drawn to the screen using multiple parts in a single image file. By the end of the chapter, we will have a scalable, random, scrolling background, using references and a <strong class="source-inline">VertexArray</strong> object.</p>
			<p><a href="B14278_10_Final_AG_ePub.xhtml#_idTextAnchor214"><em class="italic">Chapter 10</em></a>, <em class="italic">Pointers, the Standard Template Library, and Texture Management</em>, first covers the fundamental C++ topic of pointers. Pointers are variables that hold a memory address. Typically, a pointer will hold the memory address of another variable. This sounds a bit like a reference, but we will see how they are much more powerful, and we will use a pointer to handle an ever-expanding horde of zombies. We will also learn about the STL, which is a collection of classes that allow us to quickly and easily implement common data management techniques. Once we understand the basics of the STL, we will be able to use that newly acquired knowledge to manage all the textures from the game, because if we have 1,000 zombies, we don't really want to load a copy of a zombie graphic into the GPU for each and every one. We will also dig a little deeper into OOP and use a static function, which is a function of a class that can be called without an instance of the class. At the same time, we will see how we can design a class to ensure that only one instance can ever exist. This is ideal when we need to guarantee that different parts of our code will use the same data.</p>
			<p><a href="B14278_11_Final_AG_ePub.xhtml#_idTextAnchor249"><em class="italic">Chapter 11</em></a>, <em class="italic">Collision Detection, Pickups, and Bullets</em>, explains how we have implemented the main visual aspects of our game so far. We have a controllable character running around in an arena full of zombies that chase him. The problem is that they don't interact with one another. A zombie can wonder right through the player without leaving a scratch. We need to detect collisions between the zombies and the player. If the zombies are going to be able to injure and eventually kill the player, it is only fair that we give the player some bullets for his gun. We will then need to make sure that the bullets can hit and kill the zombies. At the same time, if we are writing collision detection code for bullets, zombies, and the player, it would be a good time to add a class for health and ammo pickups as well.</p>
			<p><a href="B14278_12_Final_AG_ePub.xhtml#_idTextAnchor272"><em class="italic">Chapter 12</em></a>, <em class="italic">Layering Views and Implementing the HUD</em>, is the chapter where we will get to see the real value of SFML Views. We will add a large array of SFML <strong class="source-inline">Text</strong> objects and manipulate them, as we did before in the Timber project and the Pong project. What is new is that we will draw the HUD using a second View instance. This way, the HUD will stay neatly positioned over the top of the main game action, regardless of what the background, player, zombies, and other game objects are doing.</p>
			<p><a href="B14278_13_Final_AG_ePub.xhtml#_idTextAnchor279"><em class="italic">Chapter 13</em></a>, <em class="italic">Sound Effects, File I/O, and Finishing the Game</em>, demonstrates how we can easily manipulate files stored on the hard drive using the C++ standard library, and we will also add sound effects. Of course, we know how to add sound effects, but we will discuss exactly where in the code the calls to the play function will go. We will also tie up a few loose ends to make the game complete. In this chapter, we will do the following: Save and load the hi-score using file input and file output, add sound effects to allow the player to level up, and create never-ending multiple waves.</p>
			<p><a href="B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292"><em class="italic">Chapter 14</em></a>, <em class="italic">Abstraction and Code Management – Making Better Use of OOP</em>, focuses on getting the Thomas Was Alone project started, especially exploring how the code will be structured to make better use of OOP. Here are the details of the topics that will be covered in this chapter: The final project, Thomas Was Late, is introduced, including the gameplay features and project assets, and a detailed discussion is provided of how we will improve the structure of the code compared to previous projects, code the Thomas Was Late game engine, and implement the split-screen functionality.</p>
			<p><a href="B14278_15_Final_AG_ePub.xhtml#_idTextAnchor306"><em class="italic">Chapter 15</em></a>, <em class="italic">Advanced OOP – Inheritance and Polymorphism</em>, extends our knowledge of OOP further by looking at the slightly more advanced concepts of inheritance and polymorphism. We will then be able to use this new knowledge to implement the star characters of our game, Thomas and Bob. Here is what we will cover in this chapter: Learn how to extend and modify a class using inheritance, treat an object of a class as if it is more than one type of class by using polymorphism, learn about abstract classes and how designing classes that are never instantiated can actually be useful, build an abstract <strong class="source-inline">PlayableCharacter</strong> class, put inheritance to work with the <strong class="source-inline">Thomas</strong> and <strong class="source-inline">Bob</strong> classes, and add Thomas and Bob to the game project.</p>
			<p><a href="B14278_16_Final_AG_ePub.xhtml#_idTextAnchor327"><em class="italic">Chapter 16</em></a>, <em class="italic">Building Playable Levels and Collision Detection</em>, will probably prove to be one of the most satisfying chapters of this project. The reason for this is that by the end of it, we will have a playable game. Although there will still be features to implement (sound, particle effects, HUD, and shader effects), Bob and Thomas will be able to run, jump, and explore the world. Furthermore, you will be able to create your very own level designs of any size or complexity by simply making platforms and obstacles in a text file. We will achieve all this by covering these topics: Exploring how to design levels in a text file, building a <strong class="source-inline">LevelManager</strong> class that will load levels from a text file, convert them into data that our game can use and keep track of the level details, such as spawn position, current level, and allowed time limit, update the game engine to use <strong class="source-inline">LevelManager</strong>, and code a polymorphic function to handle the collision detection for both Bob and Thomas.</p>
			<p><a href="B14278_17_Final_AG_ePub.xhtml#_idTextAnchor340"><em class="italic">Chapter 17</em></a>, <em class="italic">Sound Spatialization and the HUD</em>, adds all the sound effects and the HUD. We have done this in both previous projects, but we will do things a bit differently this time. We will explore the concept of sound spatialization and how SFML makes this otherwise complicated concept nice and easy. In addition, we will build an HUD class to encapsulate our code that draws information to the screen. We will complete the tasks in the following order: What spatialization is, how SFML handles spatialization, building a <strong class="source-inline">SoundManager</strong> class, deploying emitters, using the <strong class="source-inline">SoundManager</strong> class, and building and then using an HUD class.</p>
			<p><a href="B14278_18_Final_AG_ePub.xhtml#_idTextAnchor356"><em class="italic">Chapter 18</em></a>, <em class="italic">Particle Systems and Shaders</em>, examines what a particle system is and then proceeds to code one into our game. We will scratch the surface of the topic of OpenGL shaders and see how writing code in another language <strong class="bold">OpenGL Shading Language</strong> (<strong class="bold">GLSL</strong>), which can be run directly on the graphics card, can lead to smooth graphical effects that might otherwise be impossible. As usual, we will also use our new skills and knowledge to enhance the current project.</p>
			<p><a href="B14278_19_Final_AG_ePub.xhtml#_idTextAnchor372"><em class="italic">Chapter 19</em></a>, <em class="italic">Game Programming Design Patterns – Starting the Space Invaders ++ Game</em>, introduces the final project. As you have come to expect by now, this project will take a significant step forward in learning new C++ techniques. The next four chapters will look at topics including smart pointers, C++ assertions, using a gamepad controller, debugging using Visual Studio, casting pointers of a base class to become pointers of a specific derived class, debugging, and taking a first look at design patterns. The author is surmising that if you are going to make deep, large-scale games in C++, then design patterns are going to be a big part of your learning agenda in the months and years ahead. In order to introduce this vital topic, I have chosen a relatively simple, but fun, game to serve as an example. Let's find out a bit more about the Space Invaders ++ game, and then we can move on to the topic of design patterns and why we need them. In this hefty chapter, we will cover the following topics: Finding out about Space Invaders ++ and why it has been chosen for the final project, learning what design patterns are and why they matter to game developers, studying the design patterns in the Space Invaders ++ project that will be used over the next four chapters, getting started on the Space Invaders ++ project, and coding numerous classes to begin to flesh out the game.</p>
			<p><a href="B14278_20_Final_AG_ePub.xhtml#_idTextAnchor414"><em class="italic">Chapter 20</em></a>, <em class="italic">Game Objects and Components</em>, covers all the coding related to the Entity-Component pattern we discussed at the beginning of the previous chapter. This means we will code the base component class that all the other components will be derived from. We will also put to good use our new knowledge of smart pointers so that we don't have to concern ourselves with keeping track of the memory we allocate for these components. We will also code the <strong class="source-inline">GameObject</strong> class in this chapter. Here is a list of the sections in this chapter: Preparing to code the components, coding the component base class, coding the collider components, coding the graphics components, coding the update components, and coding the <strong class="source-inline">GameObject</strong> class.</p>
			<p><a href="B14278_21_Final_AG_ePub.xhtml#_idTextAnchor432"><em class="italic">Chapter 21</em></a>, <em class="italic">File I/O and the Game Object Factory</em>, explains how a <strong class="source-inline">GameObject</strong> gets into the <strong class="source-inline">m_GameObjects</strong> vector used in the game. We will see how we can describe individual objects and an entire level in a text file. We will write code to interpret the text and then load up values into a class that will be a blueprint for a game object. We will code a class called <strong class="source-inline">LevelManager</strong> that oversees the whole process, starting from the initial request to load a level sent from an <strong class="source-inline">InputHandler</strong> via the <strong class="source-inline">ScreenManager</strong>, right through to the factory pattern class that assembles a game object from components and delivers it to the <strong class="source-inline">LevelManager</strong> class neatly packed away in the <strong class="source-inline">m_GameObjects</strong> vector.</p>
			<p><a href="B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445"><em class="italic">Chapter 22</em></a>, <em class="italic">Using Game Objects and Building a Game</em>, constitutes the final stage of the Space Invaders ++ project. We will learn how to receive input from a gamepad using SFML to do all the hard work, and we will also code a class that will handle communication between the invaders and the <strong class="source-inline">GameScreen</strong> class, as well as the player and the <strong class="source-inline">GameScreen</strong> class. The class will allow the player and the invaders to spawn bullets, but the exact same technique could be used for any kind of communication that you need between different parts of your own game, so it is useful to know. The final part of the game (as usual) will be collision detection and the logic of the game itself. Once Space Invaders ++ is up and running, we will learn how to use the Visual Studio debugger, which will be invaluable when you are designing your own logic because it allows you to step through your code a line at a time and see the value of variables. It is also a useful tool for studying the flow of execution of the patterns we have assembled over the course of this project.</p>
			<p><a href="B14278_23_Final_AG_ePub.xhtml#_idTextAnchor457"><em class="italic">Chapter 23</em></a>, <em class="italic">Before You Go...</em>, brings our journey to an end. When you first opened this big doorstop of a book, the back page probably seemed like a long way off. But it wasn't too tough, I hope? The point is that you are here now and hopefully, you have a good insight into how to build games using C++. It might surprise you to hear that even after all these hundreds of pages, we have only dipped our toes into C++. Even the topics we did cover could be covered in more depth and there are numerous, some quite significant, topics that we haven't even mentioned. With this in mind, let's take a look at what might be next.</p>
			<h1 id="_idParaDest-10"><a id="_idTextAnchor010"/>To get the most out of this book</h1>
			<p>The following requirements need to be satisfied:</p>
			<ul>
				<li>Windows 7 Service Pack 1, Windows 8, or Windows 10</li>
				<li>1.6 GHz or faster processor</li>
				<li>1 GB of RAM (for x86) or 2 GB of RAM (for x64)</li>
				<li>15 GB of available hard disk space</li>
				<li>5400 RPM hard disk drive</li>
				<li>DirectX 9-capable video card that runs at 1024 x 768 or higher display resolution</li>
			</ul>
			<p>All the software used in this book is free. Obtaining and installing the software is covered step by step within the book. The book uses Visual Studio for Windows throughout, but experienced Linux and Mac users will probably have no trouble running the code and following the instructions using their favorite programming environment.</p>
			<h2 id="_idParaDest-11"><a id="_idTextAnchor011"/>Download the example code files</h2>
			<p>You can download the example code files for this book from your account at <a href="http://www.packt.com">www.packt.com</a>. If you purchased this book elsewhere, you can visit <a href="http://www.packtpub.com/support">www.packtpub.com/support</a> and register to have the files emailed directly to you.</p>
			<p>You can download the code files by following these steps:</p>
			<ol>
				<li>Log in or register at <a href="http://www.packt.com">http://www.packt.com</a>.</li>
				<li>Select the <strong class="bold">Support</strong> tab.</li>
				<li>Click on <strong class="bold">Code Downloads</strong>.</li>
				<li>Enter the name of the book in the <strong class="bold">Search</strong> box and follow the on screen instructions.</li>
			</ol>
			<p>Once the file is downloaded, please make sure that you unzip or extract the folder using the latest version of:</p>
			<ul>
				<li>WinRAR / 7-Zip for Windows</li>
				<li>Zipeg / iZip / UnRarX for Mac</li>
				<li>7-Zip / PeaZip for Linux</li>
			</ul>
			<p>The code bundle for the book is also hosted on GitHub at <a id="_idTextAnchor012"/><a href="https://github.com/PacktPublishing/Beginning-Cpp-Game-Programming-Second-Edition">https://github.com/PacktPublishing/Beginning-Cpp-Game-Programming-Second-Edition</a>. In case there's an update to the code, it will be updated on the existing GitHub repository.</p>
			<p>We also have other code bundles from our rich catalog of books and videos available at <a href="https://github.com/PacktPublishing/">https://github.com/PacktPublishing/</a>. Check them out!</p>
			<h2 id="_idParaDest-12"><a id="_idTextAnchor013"/>Download the color images</h2>
			<p>We also provide a PDF file that has color images of the screenshots/diagrams used in this book. You can download it here: <a href="https://static.packt-cdn.com/downloads/9781838648572_ColorImages.pdf">https://static.packt-cdn.com/downloads/9781838648572_ColorImages.pdf</a>.</p>
			<h2 id="_idParaDest-13"><a id="_idTextAnchor014"/>Conventions used</h2>
			<p>There are a number of text conventions used throughout this book.</p>
			<p><strong class="source-inline">CodeInText</strong>: Indicates code words in text, database table names, folder names, filenames, file extensions, pathnames, dummy URLs, user input, and Twitter handles. For example: "My main project directory is <strong class="source-inline">D:\VS Projects\Timber</strong>."</p>
			<p>A block of code is set as follows:</p>
			<p class="source-code">int main()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return 0;</p>
			<p class="source-code">}</p>
			<p>When we wish to draw your attention to a particular part of a code block, the relevant lines or items are set in bold:</p>
			<p class="source-code">int main()</p>
			<p class="source-code">{</p>
			<p class="source-code">    <strong class="bold">return 0;</strong></p>
			<p class="source-code">}</p>
			<p><strong class="bold">Bold</strong>: Indicates a new term, an important word, or words that you see on screen. For example, words in menus or dialog boxes appear in the text like this. Here is an example: "Click on the <strong class="bold">Create a new project</strong> button."</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Warnings or important notes appear like this.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Tips and tricks appear like this.</p>
			<h1 id="_idParaDest-14"><a id="_idTextAnchor015"/>Get in touch</h1>
			<p>Feedback from our readers is always welcome.</p>
			<p><strong class="bold">General feedback</strong>: If you have questions about any aspect of this book, mention the book title in the subject of your message and email us at <a href="mailto:customercare@packtpub.com">customercare@packtpub.com</a>.</p>
			<p><strong class="bold">Errata</strong>: Although we have taken every care to ensure the accuracy of our content, mistakes do happen. If you have found a mistake in this book, we would be grateful if you would report this to us. Please visit <a href="http://www.packtpub.com/support/errata">www.packtpub.com/support/errata</a>, selecting your book, clicking on the Errata Submission Form link, and entering the details.</p>
			<p><strong class="bold">Piracy</strong>: If you come across any illegal copies of our works in any form on the internet, we would be grateful if you would provide us with the location address or website name. Please contact us at <a href="mailto:copyright@packt.com">copyright@packt.com</a> with a link to the material.</p>
			<p><strong class="bold">If you are interested in becoming an author</strong>: If there is a topic that you have expertise in, and you are interested in either writing or contributing to a book, please visit <a href="http://authors.packtpub.com">authors.packtpub.com</a>.</p>
			<h2 id="_idParaDest-15"><a id="_idTextAnchor016"/>Reviews</h2>
			<p>Please leave a review. Once you have read and used this book, why not leave a review on the site that you purchased it from? Potential readers can then see and use your unbiased opinion to make purchase decisions, we at Packt can understand what you think about our products, and our authors can see your feedback on their book. Thank you!</p>
			<p>For more information about Packt, please visit <a href="http://packt.com">packt.com</a>.</p>
		</div>
	</body></html>