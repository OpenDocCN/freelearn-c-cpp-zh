<html><head></head><body>
		<div id="_idContainer014">
			<h1 id="_idParaDest-93" class="chapter-number"><a id="_idTextAnchor093"/>4</h1>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor094"/>Mastering Algorithms with std::vector</h1>
			<p>In this chapter, we will explore the interaction of <strong class="source-inline">std::vector</strong> with C++ <strong class="bold">Standard Template Library</strong> (<strong class="bold">STL</strong>) algorithms to unlock the potential of the C++ STL. This chapter delineates the process of efficiently sorting, searching, and manipulating vectors, leveraging the algorithms provided in the header. Moreover, focusing on lambda expressions, custom comparators, and predicates establishes a clear path to customizable, concise, and efficient <span class="No-Break">vector operations.</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Sorting <span class="No-Break">a vector</span></li>
				<li><span class="No-Break">Searching elements</span></li>
				<li><span class="No-Break">Manipulating vectors</span></li>
				<li>Custom comparators <span class="No-Break">and predicates</span></li>
				<li>Understanding container invariants and <span class="No-Break">iterator invalidation</span></li>
			</ul>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor095"/>Technical requirements</h1>
			<p>The code in this chapter can be found <span class="No-Break">on GitHub:</span></p>
			<p><a href="https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL"><span class="No-Break">https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL</span></a></p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor096"/>Sorting a vector</h1>
			<p>It’s a<a id="_idIndexMarker174"/> common requirement in software: organizing data. In C++, <strong class="source-inline">std::vector</strong> is frequently the container of choice for many, and quite naturally, one would want to sort its elements. Enter the <strong class="source-inline">std::sort</strong> algorithm, a versatile tool from the <strong class="source-inline">&lt;algorithm&gt;</strong> header that elevates your <strong class="source-inline">std::vector</strong> game to the <span class="No-Break">next level.</span></p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor097"/>Getting started with std::sort</h2>
			<p><strong class="source-inline">std::sort</strong> isn’t just<a id="_idIndexMarker175"/> for vectors; it can sort any sequential <a id="_idIndexMarker176"/>container. However, its symbiotic relationship with <strong class="source-inline">std::vector</strong> is particularly noteworthy. At its simplest, using <strong class="source-inline">std::sort</strong> to sort a vector is a straightforward task, as shown in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
std::vector&lt;int&gt; numbers = {5, 1, 2, 4, 3};
std::sort(std::begin(numbers), std::end(numbers));</pre>			<p>After execution, <strong class="source-inline">numbers</strong> would store <strong class="source-inline">{1, 2, 3, 4, 5}</strong>. The beauty lies in simplicity: pass the start and end iterators of the vector to <strong class="source-inline">std::sort</strong>, and it takes care of <span class="No-Break">the rest.</span></p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor098"/>The engine under the hood – introsort</h2>
			<p>In the vast array of algorithms offered by the C++ STL, one that consistently stands out for its efficacy is <strong class="source-inline">std::sort</strong>. When paired with the dynamic nature of <strong class="source-inline">std::vector</strong>, it becomes an unstoppable force, propelling your code’s efficiency to new heights. But what makes <span class="No-Break">it tick?</span></p>
			<p>To appreciate the genius behind <strong class="source-inline">std::sort</strong>, one must first get acquainted with the introsort algorithm. Introsort <a id="_idIndexMarker177"/>isn’t just any ordinary sorting algorithm. It’s a magnificent hybrid, artfully melding the strengths of three celebrated sorting algorithms: quicksort, heapsort, and insertion sort. This combination ensures that <strong class="source-inline">std::sort</strong> can adapt and perform optimally in <span class="No-Break">myriad scenarios.</span></p>
			<p>While we could plunge deep into algorithmic intricacies, what truly matters for everyday use is this: introsort ensures that <strong class="source-inline">std::sort</strong> remains blazingly fast. The underlying mechanics have been refined and optimized to suit various <span class="No-Break">data patterns.</span></p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor099"/>Efficiency unparalleled – O(n log n)</h2>
			<p>For those not deep into computer science jargon, time complexities might sound like arcane chants. However, there’s a simple beauty to them. When we say that <strong class="source-inline">std::sort</strong> has an average time<a id="_idIndexMarker178"/> complexity of <em class="italic">O(n log n)</em>, we express its commitment <span class="No-Break">to speed.</span></p>
			<p>Think of <em class="italic">O(n log n)</em> as a promise. Even as your vector grows, scaling to vast sizes, <strong class="source-inline">std::sort</strong> ensures that the number of operations doesn’t explode uncontrollably. It strikes a balance, ensuring that the time taken to sort grows at a manageable rate, making it a reliable choice for even the <span class="No-Break">largest vectors.</span></p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor100"/>Sorting in descending order</h2>
			<p>While<a id="_idIndexMarker179"/> ascending order is the default behavior, there are scenarios where you’d want the largest values at the front. C++ has got you covered. With the aid of <strong class="source-inline">std::greater&lt;&gt;()</strong>, a predefined comparator from the <strong class="source-inline">&lt;functional&gt;</strong> header, you can sort your vector in descending order as shown in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
std::sort(numbers.begin(), numbers.end(), std::greater&lt;&gt;());</pre>			<p>After execution, if <strong class="source-inline">numbers</strong> originally had <strong class="source-inline">{1, 2, 3, 4, 5}</strong>, it would now store <strong class="source-inline">{5, 4, 3, </strong><span class="No-Break"><strong class="source-inline">2, 1}</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor101"/>Sorting custom data types</h2>
			<p>Vectors aren’t <a id="_idIndexMarker180"/>limited to primitive types. You might <a id="_idIndexMarker181"/>have vectors of custom objects. To demonstrate this, we will use an example. We will use a <strong class="source-inline">Person</strong> class and a vector of <strong class="source-inline">Person</strong> objects. The goal is to sort the vector first by name (using an inline comparator) and then by age (using a lambda function object as <span class="No-Break">a comparator).</span></p>
			<p>Let’s look at an example of a <span class="No-Break">custom sort:</span></p>
			<pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
struct Person {
  std::string name;
  int age{0};
  Person(std::string n, int a) : name(n), age(a) {}
  friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os,
                                  const Person &amp;p) {
    os &lt;&lt; p.name &lt;&lt; " (" &lt;&lt; p.age &lt;&lt; ")";
    return os;
  }
};
int main() {
  std::vector&lt;Person&gt; people = {Person("Regan", 30),
                                Person("Lisa", 40),
                                Person("Corbin", 45)};
  auto compareByName = [](const Person &amp;a,
                          const Person &amp;b) {
    return a.name &lt; b.name;
  };
  std::sort(people.begin(), people.end(), compareByName);
  std::cout &lt;&lt; "Sorted by name:\n";
  for (const auto &amp;p : people) { std::cout &lt;&lt; p &lt;&lt; "\n"; }
  std::sort(people.begin(), people.end(),
            [](const Person &amp;a, const Person &amp;b) {
              return a.age &lt; b.age;
            });
  std::cout &lt;&lt; "\nSorted by age:\n";
  for (const auto &amp;p : people) { std::cout &lt;&lt; p &lt;&lt; "\n"; }
  return 0;
}</pre>			<p>Here is<a id="_idIndexMarker182"/> the <a id="_idIndexMarker183"/><span class="No-Break">example output:</span></p>
			<pre class="console">
Sorted by name:
Corbin (45)
Lisa (40)
Regan (30)
Sorted by age:
Regan (30)
Lisa (40)
Corbin (45)</pre>			<p>In this example, we do <span class="No-Break">the following:</span></p>
			<ul>
				<li>We define a <strong class="source-inline">Person</strong> class with a name and age <span class="No-Break">as attributes.</span></li>
				<li>We also provide an inline comparator function (<strong class="source-inline">compareByName</strong>) to sort <strong class="source-inline">Person</strong> objects <span class="No-Break">by name.</span></li>
				<li>We then sort the <strong class="source-inline">people</strong> vector using the <span class="No-Break">inline comparator.</span></li>
				<li>Afterward, we sort the <strong class="source-inline">people</strong> vector by age using a lambda function as <span class="No-Break">a comparator.</span></li>
				<li>The <a id="_idIndexMarker184"/>results are displayed to verify that the sorting <a id="_idIndexMarker185"/>operations work <span class="No-Break">as expected.</span></li>
			</ul>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor102"/>Pitfalls and precautions</h2>
			<p>There’s a <a id="_idIndexMarker186"/>temptation to view <strong class="source-inline">std::sort</strong> as a magic wand, but remember that while it is powerful, it is not omniscient. The algorithm assumes that the range <strong class="source-inline">(</strong><strong class="source-inline">begin, end)</strong> is valid; passing invalid iterators can lead to undefined behavior. Additionally, the comparator provided must establish a strict weak ordering; failing to do so might produce <span class="No-Break">unexpected results.</span></p>
			<h3>Strict weak ordering</h3>
			<p>The<a id="_idIndexMarker187"/> term <strong class="bold">strict weak ordering</strong> is a critical concept, especially when dealing with sorting algorithms such as <strong class="source-inline">std::sort</strong>. This concept pertains to the<a id="_idIndexMarker188"/> comparison function that is used to order the elements in a collection. Let’s break it down <span class="No-Break">for clarity:</span></p>
			<ul>
				<li><strong class="bold">Strictness</strong>: This means that for any two distinct elements <em class="italic">a</em> and <em class="italic">b</em>, the comparison function comp must not report both <em class="italic">comp(a, b)</em> and <em class="italic">comp(b, a)</em> as true. In simpler terms, if <em class="italic">a</em> is considered less than <em class="italic">b</em>, then <em class="italic">b</em> cannot be less than <em class="italic">a</em>. This ensures a <span class="No-Break">consistent ordering.</span></li>
				<li><strong class="bold">Weakness</strong>: The term <em class="italic">weak</em> in this context refers to the allowance of equivalence classes. In a strict ordering (such as a strict total ordering), two different elements cannot be equivalent. However, in a strict weak ordering, different elements can be considered equivalent. For example, if you have a list of people sorted by age, two people of the same age are in the same equivalence class even if they are <span class="No-Break">different individuals.</span></li>
				<li><strong class="bold">Transitivity of comparison</strong>: If <em class="italic">comp(a, b)</em> is true and <em class="italic">comp(b, c)</em> is true, then <em class="italic">comp(a, c)</em> must also be true. This ensures that the ordering is consistent across the entire set <span class="No-Break">of elements.</span></li>
				<li><strong class="bold">Transitivity of equivalence</strong>: If <em class="italic">a</em> is not less than <em class="italic">b</em> and <em class="italic">b</em> is not less than <em class="italic">a</em> (meaning they are equivalent in terms of the sorting criteria), and similarly <em class="italic">b</em> and <em class="italic">c</em> are equivalent, then <em class="italic">a</em> and <em class="italic">c</em> must also be <span class="No-Break">considered equivalent.</span></li>
			</ul>
			<p>A comparator <a id="_idIndexMarker189"/>providing a strict weak ordering allows <strong class="source-inline">std::sort</strong> to correctly and efficiently sort elements. It ensures that the order is consistent, allows for the grouping of equivalent elements, and respects the logical transitivity both in terms of comparison and equivalence. Failing to adhere to these rules can lead to unpredictable behavior in <span class="No-Break">sorting algorithms.</span></p>
			<p>Let’s illustrate the concepts mentioned in the text with a code example. We will show what happens when an invalid range is provided to <strong class="source-inline">std::sort</strong>, and what can occur if the comparator doesn’t establish a strict <span class="No-Break">weak ordering:</span></p>
			<pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; numbers = {3, 1, 4, 1, 5, 9};
  // Let's mistakenly provide an end iterator beyond the
  // actual end of the vector.
  std::vector&lt;int&gt;::iterator invalid = numbers.end() + 1;
  // Uncommenting the following line can lead to undefined
  // behavior due to the invalid range.
  // std::sort(numbers.begin(), invalidEnd);
  // This comparator will return true even when both
  // elements are equal. This violates the strict weak
  // ordering.
  auto badComparator = [](int a, int b) { return a &lt;= b; };
  // Using such a comparator can lead to unexpected
  // results.
  std::sort(numbers.begin(), numbers.end(), badComparator);
  // Displaying the sorted array (might be unexpectedly
  // sorted or cause other issues)
  for (int num : numbers) { std::cout &lt;&lt; num &lt;&lt; " "; }
  std::cout &lt;&lt; "\n";
  return 0;
}</pre>			<p>In this example, we<a id="_idIndexMarker190"/> do <span class="No-Break">the following:</span></p>
			<ul>
				<li>We see how mistakenly providing an end iterator beyond the vector’s end can lead to undefined behavior. (This portion is commented out for <span class="No-Break">safety reasons.)</span></li>
				<li>We provide a comparator that does not maintain a strict weak ordering because it returns true even when two numbers are equal. Using such a comparator with <strong class="source-inline">std::sort</strong> can lead to unexpected results or other <span class="No-Break">undefined behaviors.</span></li>
			</ul>
			<p>With <strong class="source-inline">std::sort</strong> at your disposal, you have an efficient and adaptable tool. You can handle a broad spectrum of sorting tasks with confidence and finesse by understanding its default behaviors, harnessing the power of standard comparators, and crafting custom comparators for unique scenarios. As we proceed in this chapter, remember this foundational skill as we delve deeper into the vast landscape of STL algorithms <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">std::vector</strong></span><span class="No-Break">.</span></p>
			<p>In this section, we optimized element sorting in <strong class="source-inline">std::vector</strong> with the <strong class="source-inline">std::sort</strong> algorithm, unpacking its introsort mechanism—a hybrid of quicksort, heapsort, and insertion sort—to ensure top performance, usually with <em class="italic">O(n log n)</em> complexity. This understanding is <a id="_idIndexMarker191"/>pivotal for data processing efficiency in algorithmic design and high-performance <span class="No-Break">application development.</span></p>
			<p>Next, we’ll shift our focus from sorting to searching, contrasting the linear and binary search techniques to effectively find elements in <strong class="source-inline">std::vector</strong>, dissecting their efficiency in various <span class="No-Break">use cases.</span></p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor103"/>Searching elements</h1>
			<p>Finding elements in <a id="_idIndexMarker192"/>a collection is as crucial as storing them. In the C++ STL, there’s a buffet of algorithms tailored for searching. Whether <strong class="source-inline">std::vector</strong> is sorted or unsorted, the STL provides an array of functions that’ll lead you straight to your target using the classic linear or faster binary search. With <strong class="source-inline">std::vector</strong>, these techniques become indispensable in <span class="No-Break">many scenarios.</span></p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor104"/>Linear search with std::find</h2>
			<p>The most <a id="_idIndexMarker193"/>basic and intuitive searching<a id="_idIndexMarker194"/> algorithm is the <strong class="bold">linear search</strong>. If you’re not sure about the order of your vector or it is simply unsorted, this method comes to <span class="No-Break">the rescue.</span></p>
			<p>Consider <strong class="source-inline">std::vector&lt;int&gt; numbers = {21, 12, 46, 2};</strong>. To find the position of the element <strong class="source-inline">46</strong>, we will use the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
auto it = std::find(numbers.begin(), numbers.end(), 46);</pre>			<p>If the element exists, it will point to its location; otherwise, it’ll point to <strong class="source-inline">numbers.end()</strong>. It’s a direct, no-frills approach, checking each element from the beginning to the end. However, the time it takes grows linearly with the size of the vector, making it less ideal for <span class="No-Break">massive datasets.</span></p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor105"/>Binary search techniques</h2>
			<p>Few algorithmic<a id="_idIndexMarker195"/> searching strategies stand out for their <a id="_idIndexMarker196"/>sheer elegance and efficiency, quite like the <strong class="bold">binary search</strong>. When integrated with the dynamic capabilities of <strong class="source-inline">std::vector</strong>, binary search offers a masterclass in how strategic thinking can transform how we tackle problems. Let’s delve deeper into the world of halves to unearth the brilliance behind <span class="No-Break">binary search.</span></p>
			<p>Binary search operates on a beautifully simple principle: divide and conquer. Instead of tediously scanning each element one by one, binary search makes a beeline to the center of the dataset. A quick assessment determines whether the desired element lies in the dataset’s first or second half. This insight allows it to dismiss half of the remaining elements, continually narrowing down the search field until the desired <span class="No-Break">element emerges.</span></p>
			<p>For the binary search to work its magic, there’s one non-negotiable requirement: the dataset, or <strong class="source-inline">std::vector</strong>, must be sorted in our context. This precondition is vital because the efficiency of binary search hinges on predictability. Each decision to halve the search space is made with the confidence that elements are organized in a specific order. This structured arrangement allows the algorithm to confidently exclude large data portions, making the search <span class="No-Break">incredibly efficient.</span></p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor106"/>Using std::lower_bound and std::upper_bound</h2>
			<p>But what if you <a id="_idIndexMarker197"/>want more than just existence? Sometimes, the questions we seek to answer are more nuanced: If this element isn’t in <a id="_idIndexMarker198"/>the vector, where would it fit best based on the current ordering? Or, given multiple occurrences of an element, where <a id="_idIndexMarker199"/>do they commence or conclude? The C++ STL offers two powerful tools to address these queries: <strong class="source-inline">std::lower_bound</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">std::upper_bound</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">std::lower_bound</strong> function plays a pivotal role in the realm of sorted vectors. When presented with a specific element, this function ventures to find the position where this element either first appears in the vector or where it would be rightly placed, ensuring the vector’s order remains intact. It effectively returns an iterator pointing to the first element that is not less than (i.e., greater than or equal to) the <span class="No-Break">specified value.</span></p>
			<p>For instance, if our vector contains <strong class="source-inline">{1, 3, 3, 5, 7}</strong> and we’re seeking <strong class="source-inline">3</strong> using <strong class="source-inline">std::lower_bound</strong>, the function would point to the first occurrence of <strong class="source-inline">3</strong>. However, if we were searching for <strong class="source-inline">4</strong>, the function would indicate the position right before <strong class="source-inline">5</strong>, highlighting where <strong class="source-inline">4</strong> would fit best while preserving the vector’s <span class="No-Break">sorted nature.</span></p>
			<p>On<a id="_idIndexMarker200"/> the <a id="_idIndexMarker201"/>other hand, <strong class="source-inline">std::upper_bound</strong> provides insight into the ending of a sequence. When given an element, it identifies the first position where an element greater than the specified<a id="_idIndexMarker202"/> value resides. Effectively, if you have multiple occurrences of an element, <strong class="source-inline">std::upper_bound</strong> will point just past the <span class="No-Break">last occurrence.</span></p>
			<p>Referring back<a id="_idIndexMarker203"/> to our vector <strong class="source-inline">{1, 3, 3, 5, 7}</strong>, if we employ <strong class="source-inline">std::upper_bound</strong> in search of <strong class="source-inline">3</strong>, it would direct us to the position right before <strong class="source-inline">5</strong>, showcasing the end of the <span class="No-Break"><strong class="source-inline">3</strong></span><span class="No-Break"> sequence.</span></p>
			<p>Let’s look at a complete example of using <strong class="source-inline">std::upper_bound</strong> and <strong class="source-inline">std::lower_bound</strong> with <strong class="source-inline">std::vector</strong> <span class="No-Break">of integers.</span></p>
			<pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; numbers = {1, 3, 3, 5, 7};
  int val1 = 3;
  auto low1 = std::lower_bound(numbers.begin(),
                               numbers.end(), val1);
  std::cout &lt;&lt; "std::lower_bound for value " &lt;&lt; val1
            &lt;&lt; ": " &lt;&lt; (low1 - numbers.begin()) &lt;&lt; "\n";
  int val2 = 4;
  auto low2 = std::lower_bound(numbers.begin(),
                               numbers.end(), val2);
  std::cout &lt;&lt; "std::lower_bound for value " &lt;&lt; val2
            &lt;&lt; ": " &lt;&lt; (low2 - numbers.begin()) &lt;&lt; "\n";
  int val3 = 3;
  auto up1 = std::upper_bound(numbers.begin(),
                              numbers.end(), val3);
  std::cout &lt;&lt; "std::upper_bound for value " &lt;&lt; val3
            &lt;&lt; ": " &lt;&lt; (up1 - numbers.begin()) &lt;&lt; "\n";
  return 0;
}</pre>			<p>When you<a id="_idIndexMarker204"/> run the preceding code, the <a id="_idIndexMarker205"/>following output will be generated for the <span class="No-Break">specified</span><span class="No-Break"><a id="_idIndexMarker206"/></span><span class="No-Break"> values:</span></p>
			<pre class="console">
std::lower_bound for value 3: 1
std::lower_bound for value 4: 3
std::upper_bound for value 3: 3</pre>			<p>The<a id="_idIndexMarker207"/> explanation of the code example is <span class="No-Break">as follows:</span></p>
			<ul>
				<li>For <strong class="source-inline">std::lower_bound</strong> with <strong class="source-inline">3</strong>, it returns an iterator pointing to the first occurrence of <strong class="source-inline">3</strong>, which is at <span class="No-Break">index </span><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">.</span></li>
				<li>For <strong class="source-inline">std::lower_bound</strong> with <strong class="source-inline">4</strong>, it indicates where <strong class="source-inline">4</strong> would fit best, right before <strong class="source-inline">5</strong> (i.e., at <span class="No-Break">index </span><span class="No-Break"><strong class="source-inline">3</strong></span><span class="No-Break">).</span></li>
				<li>For <strong class="source-inline">std::upper_bound</strong> with <strong class="source-inline">3</strong>, it points just past the last occurrence of <strong class="source-inline">3</strong>, right before <strong class="source-inline">5</strong> (i.e., at <span class="No-Break">index </span><span class="No-Break"><strong class="source-inline">3</strong></span><span class="No-Break">).</span></li>
			</ul>
			<p>While confirming the existence of an element is undoubtedly essential, the actual depth of algorithmic exploration with <strong class="source-inline">std::vector</strong> comes when we pose more detailed questions. With the combined capabilities of <strong class="source-inline">std::lower_bound</strong> and <strong class="source-inline">std::upper_bound</strong>, we begin to appreciate the data analysis capabilities supported by <span class="No-Break">the STL.</span></p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor107"/>Binary search versus linear search – efficiency and versatility</h2>
			<p>Within the <a id="_idIndexMarker208"/>realm of algorithmic<a id="_idIndexMarker209"/> searching techniques, both binary and linear search emerge as fundamental strategies. Each has unique strengths and ideal use cases, mainly applied to the versatile <strong class="source-inline">std::vector</strong>. Let’s delve deeper into understanding the nuances of these <span class="No-Break">two approaches.</span></p>
			<h3>Binary search – the speedster with a condition</h3>
			<p>Binary search is a highly efficient method renowned for its logarithmic time complexity. This efficiency translates into significant speed, especially when dealing with large vectors. However, this swiftness has a caveat: <strong class="source-inline">std::vector</strong> must be sorted. The essence of binary search is its ability to eliminate half of the remaining elements with each step, making educated guesses based on the order of <span class="No-Break">the elements.</span></p>
			<p>But what happens if this order isn’t maintained? Simply put, the results become unpredictable. If a vector isn’t sorted, binary search might fail to locate an element even if it exists or return inconsistent results. Thus, it is imperative to ensure a sorted landscape before venturing into a binary search <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">std::vector</strong></span><span class="No-Break">.</span></p>
			<h3>Linear search – the reliable workhorse</h3>
			<p>Linear search, on<a id="_idIndexMarker210"/> the other hand, is characterized by its straightforward approach. It methodically checks each element in the vector until it finds the desired item or concludes it isn’t present. This simplicity is its strength; the method doesn’t require any prior conditions on the arrangement of elements, making it versatile and applicable to sorted and <span class="No-Break">unsorted vectors.</span></p>
			<p>However, this step-by-step examination comes at a cost: linear search has a linear time complexity. While it might be efficient for smaller vectors, its performance can be noticeably slower as the size of the vector increases, especially when compared to the swift binary search in <span class="No-Break">sorted vectors.</span></p>
			<p>Searching is fundamental, and mastering linear and binary techniques amplifies your proficiency with <strong class="source-inline">std::vector</strong>. Whether you’re hunting down a single element, gauging the position of an item in a sorted sequence, or finding the range of an element’s occurrences, the STL grants you robust and efficient tools to accomplish these tasks. As <a id="_idIndexMarker211"/>you venture further into <strong class="source-inline">std::vector</strong> and the STL, understanding these searching methods is a bedrock, ensuring that no element remains elusive in your <span class="No-Break">C++ journey.</span></p>
			<p>This section <a id="_idIndexMarker212"/>honed <a id="_idIndexMarker213"/>our skills in element discovery within <strong class="source-inline">std::vector</strong>, starting with <strong class="source-inline">std::find</strong> for linear searches and advancing to binary searches with <strong class="source-inline">std::lower_bound</strong> and <strong class="source-inline">std::upper_bound</strong> for sorted data. Unlike linear search, we recognized binary search’s speed advantage, though it requires a pre-sorted vector. Choosing the correct search technique is crucial for performance optimization in <span class="No-Break">various applications.</span></p>
			<p>We’ll next explore altering vector contents with methods such as <strong class="source-inline">std::copy</strong>, focusing on practical manipulation techniques and the key considerations for preserving data structure integrity <span class="No-Break">and performance.</span></p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor108"/>Manipulating vectors</h1>
			<p>Vectors in C++ are<a id="_idIndexMarker214"/> dynamic arrays that not only store data but offer a suite of operations to manipulate that data, especially when paired with the algorithms provided by the STL. These algorithms allow developers to optimize data movement and transformation tasks with elegance. Let’s delve into the art of manipulating <strong class="source-inline">std::vector</strong> with some <span class="No-Break">powerful algorithms.</span></p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor109"/>Transforming with std::copy</h2>
			<p>Imagine you’ve<a id="_idIndexMarker215"/> got one vector and wish to copy its<a id="_idIndexMarker216"/> elements to another. Simple looping might come to mind, but there’s a more efficient and expressive <span class="No-Break">way: </span><span class="No-Break"><strong class="source-inline">std::copy</strong></span><span class="No-Break">.</span></p>
			<p>Consider two vectors as shown in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
std::vector&lt;int&gt; source = {1, 2, 3, 4, 5};
std::vector&lt;int&gt; destination(5);</pre>			<p>Copying the elements is as straightforward as shown in <span class="No-Break">the following:</span></p>
			<pre class="source-code">
std::copy(source.begin(), source.end(), destination.begin());</pre>			<p><strong class="source-inline">destination</strong> holds <strong class="source-inline">{1, 2, 3, 4, 5}</strong>. It’s worth noting that the <strong class="source-inline">destination</strong> vector <a id="_idIndexMarker217"/>should have <a id="_idIndexMarker218"/>enough space to accommodate the <span class="No-Break">copied elements.</span></p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor110"/>Reversing elements with std::reverse</h2>
			<p>Often, you <a id="_idIndexMarker219"/>might need to reverse the <a id="_idIndexMarker220"/>elements of a vector. Instead of manually swapping elements, <strong class="source-inline">std::reverse</strong> comes to the rescue, as shown in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
std::vector&lt;int&gt; x = {1, 2, 3, 4, 5};
std::reverse(x.begin(), x.end());</pre>			<p>The vector numbers now read <strong class="source-inline">{5, 4, 3, </strong><span class="No-Break"><strong class="source-inline">2, 1}</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor111"/>Rotating vectors with std::rotate</h2>
			<p>Another <a id="_idIndexMarker221"/>handy algorithm for manipulating vectors is <strong class="source-inline">std::rotate</strong>, which allows you to rotate elements. Let’s say you have a vector<a id="_idIndexMarker222"/> <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
std::vector&lt;int&gt; values = {1, 2, 3, 4, 5};</pre>			<p>If you want to rotate it so that <strong class="source-inline">3</strong> becomes the first element, you will do <span class="No-Break">the following:</span></p>
			<pre class="source-code">
std::rotate(values.begin(), values.begin() + 2, values.end());</pre>			<p>Your vector <strong class="source-inline">values</strong> now hold <strong class="source-inline">{3, 4, 5, 1, 2}</strong>. This shifts the elements, wrapping them around <span class="No-Break">the vector.</span></p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor112"/>Filling a vector with std::fill</h2>
			<p>There <a id="_idIndexMarker223"/>might be <a id="_idIndexMarker224"/>scenarios where you wish to reset or initialize all vector elements to a specific value. <strong class="source-inline">std::fill</strong> is the perfect tool <span class="No-Break">for this:</span></p>
			<pre class="source-code">
std::vector&lt;int&gt; data(5);
std::fill(data.begin(), data.end(), 42);</pre>			<p>Every element in the <strong class="source-inline">data</strong> is <span class="No-Break">now </span><span class="No-Break"><strong class="source-inline">42</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor113"/>Putting manipulation to use</h2>
			<p>A music<a id="_idIndexMarker225"/> streaming service wants to allow users to manage their playlists in the <span class="No-Break">following ways:</span></p>
			<ul>
				<li>At the end of the year, they have a unique feature: users can take their top 10 songs and move them to the beginning of the playlist as a <em class="italic">Year </em><span class="No-Break"><em class="italic">in Review</em></span><span class="No-Break">.</span></li>
				<li>Users can reverse their playlist to rediscover old songs they haven’t listened to in a while for a <span class="No-Break">specific promotion.</span></li>
				<li>Occasionally, when a user buys a new album, they like to insert its tracks in the middle of their current playlist and rotate the old favorites to the end to have a mix of new and <span class="No-Break">old songs.</span></li>
				<li>For a fresh start in spring, users can fill their playlist with calm and refreshing <span class="No-Break">spring-themed music.</span></li>
			</ul>
			<p>The following code shows how users can manage <span class="No-Break">their playlists:</span></p>
			<pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;std::string&gt; playlist = {
      "Song A", "Song B", "Song C", "Song D",
      "Song E", "Song F", "Song G", "Song H",
      "Song I", "Song J", "Song K", "Song L"};
  std::rotate(playlist.rbegin(), playlist.rbegin() + 10,
              playlist.rend());
  std::cout &lt;&lt; "Year in Review playlist: ";
  for (const auto &amp;song : playlist) {
    std::cout &lt;&lt; song &lt;&lt; ", ";
  }
  std::cout &lt;&lt; "\n";
  std::reverse(playlist.begin(), playlist.end());
  std::cout &lt;&lt; "Rediscovery playlist: ";
  for (const auto &amp;song : playlist) {
    std::cout &lt;&lt; song &lt;&lt; ", ";
  }
  std::cout &lt;&lt; "\n";
  std::vector&lt;std::string&gt; newAlbum = {
      "New Song 1", "New Song 2", "New Song 3"};
  playlist.insert(playlist.begin() + playlist.size() / 2,
                  newAlbum.begin(), newAlbum.end());
  std::rotate(playlist.begin() + playlist.size() / 2,
              playlist.end() - newAlbum.size(),
              playlist.end());
  std::cout &lt;&lt; "After new album purchase: ";
  for (const auto &amp;song : playlist) {
    std::cout &lt;&lt; song &lt;&lt; ", ";
  }
  std::cout &lt;&lt; "\n";
  std::vector&lt;std::string&gt; springSongs = {
      "Spring 1", "Spring 2", "Spring 3", "Spring 4"};
  if (playlist.size() &lt; springSongs.size()) {
    playlist.resize(springSongs.size());
  }
  std::fill(playlist.begin(),
            playlist.begin() + springSongs.size(),
            "Spring Song");
  std::cout &lt;&lt; "Spring Refresh: ";
  for (const auto &amp;song : playlist) {
    std::cout &lt;&lt; song &lt;&lt; ", ";
  }
  std::cout &lt;&lt; "\n";
  return 0;
}</pre>			<p>Here is the example <span class="No-Break">output (truncated):</span></p>
			<pre class="console">
Year in Review playlist: Song C, Song D, Song E, Song F, Song G, Song H, [...]
Rediscovery playlist: Song B, Song A, Song L, Song K, Song J, Song I, [...]
After new album purchase: Song B, Song A, Song L, Song K, Song J, Song I, [...]
Spring Refresh: Spring Song, Spring Song, Spring Song, Spring Song, Song J, [...]</pre>			<p>In this example, we<a id="_idIndexMarker226"/> do <span class="No-Break">the following:</span></p>
			<ul>
				<li>The <strong class="source-inline">std::rotate</strong> function brings the user’s top 10 songs to <span class="No-Break">the beginning.</span></li>
				<li>The <strong class="source-inline">std::reverse</strong> function helps rediscover <span class="No-Break">old songs.</span></li>
				<li>The user’s new album purchase demonstrates a more practical use <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">std::rotate.</strong></span></li>
				<li>The <strong class="source-inline">std::fill</strong> function fills the playlist with spring-themed songs for a <span class="No-Break">fresh start.</span></li>
			</ul>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor114"/>Considerations in manipulation</h2>
			<p>While<a id="_idIndexMarker227"/> these functions provide a robust and efficient way to transform vectors, there are a few things to keep <span class="No-Break">in mind:</span></p>
			<ul>
				<li>Ensure that the destination vectors, especially with functions such as <strong class="source-inline">std::copy</strong> have adequate space to accommodate the data. Using <strong class="source-inline">std::back_inserter</strong> can be helpful if you’re unsure about <span class="No-Break">the size.</span></li>
				<li>Algorithms such as <strong class="source-inline">std::rotate</strong> are highly efficient. They minimize the number of element moves. However, the order in which elements are shifted might not be apparent initially. Practicing with different scenarios will instill a more <span class="No-Break">precise understanding.</span></li>
				<li>Functions such as <strong class="source-inline">std::fill</strong> and <strong class="source-inline">std::reverse</strong> work in place, transforming the original vector. Always ensure you won’t need the original order or values before applying these functions or <span class="No-Break">backing up.</span></li>
			</ul>
			<p>Vectors paired<a id="_idIndexMarker228"/> with STL algorithms empower developers to create efficient, expressive, and concise manipulations. Whether you’re copying, rotating, reversing, or filling, there’s an algorithm tailored to the task. As you continue your journey with <strong class="source-inline">std::vector</strong>, embracing these tools ensures you handle data with finesse and speed, crafting efficient code that is a pleasure to read <span class="No-Break">and write.</span></p>
			<p>In this section, we’ve mastered modifying the contents of <strong class="source-inline">std::vector</strong> with STL algorithms, particularly <strong class="source-inline">std::copy</strong>, central to performing secure and efficient data operations. We’ve also covered critical considerations such as avoiding iterator invalidation to maintain data integrity and performance. This expertise is invaluable for C++ developers, as streamlining the execution of complex data manipulations is critical in <span class="No-Break">practical applications.</span></p>
			<p>Moving forward, we’ll delve into customizing STL algorithm behavior using comparators and predicates, enabling the definition of bespoke sorting and searching criteria for user-defined <span class="No-Break">data types.</span></p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor115"/>Custom comparators and predicates</h1>
			<p>When working with <strong class="source-inline">std::vector</strong> and STL algorithms, you’ll often encounter scenarios where the default behavior doesn’t fit the bill. Sometimes, the way two elements are compared or the criteria for selecting elements must deviate from the norm. Here’s where custom comparators and predicates come into play. They are a testament to the power and flexibility of the C++ STL, allowing you to inject your logic seamlessly into <span class="No-Break">established algorithms.</span></p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor116"/>Understanding comparators</h2>
			<p>A <strong class="bold">comparator</strong> is essentially<a id="_idIndexMarker229"/> a callable object that returns a <strong class="source-inline">bool</strong>. It’s used to dictate the order of elements, especially in sorting or searching operations. By default, operations such as <strong class="source-inline">std::sort</strong> use the <strong class="source-inline">(&lt;)</strong> operator to compare elements, but with a custom comparator, you can <span class="No-Break">redefine this.</span></p>
			<p>Imagine a <strong class="source-inline">std::vector</strong> of integers, and you want to sort them in descending order. Instead of writing another algorithm, you can use <strong class="source-inline">std::sort</strong> with <span class="No-Break">a comparator:</span></p>
			<pre class="source-code">
std::vector&lt;int&gt; numbers = {1, 3, 2, 5, 4};
std::sort(numbers.begin(), numbers.end(), [](int a, int b){
    return a &gt; b;
});</pre>			<p>In this example, the lambda expression acts as a comparator, reversing the usual <span class="No-Break">less-than behavior.</span></p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor117"/>The power of predicates</h2>
			<p>While <a id="_idIndexMarker230"/>comparators define ordering, predicates help in making decisions. A <strong class="bold">predicate</strong> is a callable object that returns a <strong class="source-inline">bool</strong> like a comparator. Predicates are commonly used with algorithms that need to make a selection or decision based on <span class="No-Break">some criteria.</span></p>
			<p>For instance, if you wanted to count how many numbers in a vector are even, you could employ <strong class="source-inline">std::count_if</strong> with a predicate as shown in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
std::vector&lt;int&gt; x = {1, 2, 3, 4, 5};
int evens = std::count_if(x.begin(), x.end(), [](int n){
    return n % 2 == 0;
});</pre>			<p>Here, the lambda predicate checks whether a number is even, allowing <strong class="source-inline">std::count_if</strong> to <span class="No-Break">tally accordingly.</span></p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor118"/>Crafting effective comparators and predicates</h2>
			<p>The following are<a id="_idIndexMarker231"/> the best practices to be kept in mind to<a id="_idIndexMarker232"/> craft effective comparators <span class="No-Break">and predicates:</span></p>
			<ul>
				<li><strong class="bold">Clarity</strong>: Ensure that the logic within is clear. The purpose of a comparator or predicate should be evident <span class="No-Break">upon reading.</span></li>
				<li><strong class="bold">Statelessness</strong>: A comparator or predicate should be stateless, meaning it should not have any side effects or change behavior <span class="No-Break">between calls.</span></li>
				<li><strong class="bold">Efficiency</strong>: Since comparators and predicates might be called repeatedly in algorithms, they should be efficient. Avoid unnecessary computations or calls <span class="No-Break">within them.</span></li>
			</ul>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor119"/>User-defined structs and classes</h2>
			<p>While<a id="_idIndexMarker233"/> lambdas are concise and convenient, defining a struct or class allows<a id="_idIndexMarker234"/> us to define behavior that is more complex or better lends itself <span class="No-Break">to reusability.</span></p>
			<p>Consider a vector of students with names and grades. If you want to sort by grade and then by name, use the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
struct Student {
    std::string name;
    int grade;
};
std::vector&lt;Student&gt; students = { ... };
std::sort(students.begin(), students.end(), [](const Student&amp; a, const Student&amp; b) {
    if(a.grade == b.grade){ return (a.name &lt; b.name); }
    return (a.grade &gt; b.grade);
});</pre>			<p>While the lambda approach works, using a struct might be clearer for <span class="No-Break">complex logic:</span></p>
			<pre class="source-code">
struct SortByGradeThenName {
  bool operator()(const Student &amp;first,
                  const Student &amp;second) const {
    if (first.grade == second.grade) {
      return (first.name &lt; second.name);
    }
    return (first.grade &gt; second.grade);
  }
};
std::sort(students.begin(), students.end(), SortByGradeThenName());</pre>			<p>Custom <a id="_idIndexMarker235"/>comparators and predicates are like giving you the keys to the STL’s engine room. They allow you to harness the raw power of the library but tailor it precisely to your needs. This fine-tuned control makes C++ a standout language for algorithmic tasks and <span class="No-Break">data processing.</span></p>
			<p>This section<a id="_idIndexMarker236"/> introduced us to custom comparators and predicates, enhancing our ability to sort and filter elements in <strong class="source-inline">std::vector</strong>. We learned how to define sorting criteria with comparators and set conditions with predicates, particularly for user-defined types, allowing for intricate data organization within algorithms. Understanding and utilizing these tools is crucial for developers to customize and optimize data operations <span class="No-Break">in C++.</span></p>
			<p>Next, we’ll explore container invariants and iterator invalidation, learning to manage container stability and avoid the common issue of invalidation, which is essential for ensuring robustness, especially in <span class="No-Break">multi-threaded contexts.</span></p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor120"/>Understanding container invariants and iterator invalidation</h1>
			<p>Within the C++ STL, there lies a crucial consideration often overlooked by many: <strong class="bold">container invariants</strong>. These<a id="_idIndexMarker237"/> invariants are, essentially, a set of conditions that always hold for a container during its lifecycle. For example, in the case of <strong class="source-inline">std::vector</strong>, one such invariant might be that the elements are stored in contiguous memory locations. However, certain operations can disrupt these invariants, leading to potential pitfalls such as iterator invalidation. Armed with this knowledge, we can craft more resilient and <span class="No-Break">efficient code.</span></p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor121"/>Understanding iterator invalidation</h2>
			<p>A study of <strong class="source-inline">std::vector</strong> is<a id="_idIndexMarker238"/> incomplete without a grasp of <strong class="bold">iterator invalidation</strong>. Iterator invalidation is akin to trying to use a bookmark after someone’s reshuffled the pages in your book. You think you’re pointing to one location, but the data there might have changed or ceased <span class="No-Break">to exist.</span></p>
			<p>For instance, when we push an element to a vector (<strong class="source-inline">push_back</strong>), the element is added without any hitches if there’s enough reserved memory (<strong class="source-inline">capacity</strong>). But, if the vector needs to allocate new memory due to space constraints, it may relocate all its elements to this new memory block. As a result, any iterator, pointer, or reference pointing to an element in the old memory block will now <span class="No-Break">be invalidated.</span></p>
			<p>Similarly, other operations, such as <strong class="source-inline">insert</strong>, <strong class="source-inline">erase</strong>, or <strong class="source-inline">resize</strong>, can also invalidate an iterator. The crux is to recognize when these operations might disrupt the vector’s layout and be prepared to deal with <span class="No-Break">the consequences.</span></p>
			<p>The following is a code example that demonstrates iterator invalidation with <strong class="source-inline">std::vector</strong> and how certain operations might disrupt the <span class="No-Break">container’s layout:</span></p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};
  std::vector&lt;int&gt;::iterator it = numbers.begin() + 2;
  std::cout &lt;&lt; "The element at the iterator before"
               "push_back: "
            &lt;&lt; *it &lt;&lt; "\n";
  for (int i = 6; i &lt;= 1000; i++) { numbers.push_back(i); }
  std::cout &lt;&lt; "The element at the iterator after"
               "push_back: "
            &lt;&lt; *it &lt;&lt; "\n";
  it = numbers.begin() + 2;
  numbers.insert(it, 99);
  it = numbers.begin() + 3;
  numbers.erase(it);
  return 0;
}</pre>			<p>In the<a id="_idIndexMarker239"/> example, we do <span class="No-Break">the following:</span></p>
			<ul>
				<li>We first set an iterator to point to the third element of the <span class="No-Break"><strong class="source-inline">numbers</strong></span><span class="No-Break"> vector.</span></li>
				<li>After pushing many elements to the vector, the original memory block might be reallocated to a new one, causing the iterator to <span class="No-Break">become invalidated.</span></li>
				<li>We further demonstrate how the <strong class="source-inline">insert</strong> and <strong class="source-inline">erase</strong> operations can invalidate <span class="No-Break">an iterator.</span></li>
				<li>It’s emphasized that using an invalidated iterator can lead to undefined behavior, and therefore, one should always re-acquire iterators after modifying <span class="No-Break">a vector.</span></li>
			</ul>
			<p>Always be cautious<a id="_idIndexMarker240"/> after modifying operations on a vector, as they might invalidate your iterators. Re-acquire your iterators after such operations to ensure <span class="No-Break">they’re valid.</span></p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor122"/>Strategies to counteract invalidation</h2>
			<p>Now that we <a id="_idIndexMarker241"/>have a clue about when our iterators might become invalidated, it is time to uncover ways to circumvent or handle these <span class="No-Break">scenarios gracefully.</span></p>
			<ul>
				<li><strong class="bold">Reserve memory in advance</strong>: If you have an estimate of the maximum number of elements your vector might hold, consider using the <strong class="source-inline">reserve</strong> method. This pre-allocates memory, reducing the need for reallocation and subsequent iterator invalidation <span class="No-Break">during additions.</span></li>
				<li><strong class="bold">Prefer positions over iterators</strong>: Consider storing positions (e.g., index values) instead of storing iterators. After an operation that may lead to iterator invalidation, you can easily recreate a valid iterator using <span class="No-Break">the position.</span></li>
				<li><strong class="bold">Refresh iterators post-operation</strong>: After any disruptive operation, avoid using any old iterators, pointers, or references. Instead, obtain fresh iterators to ensure they point to the <span class="No-Break">correct elements.</span></li>
				<li><strong class="bold">Use algorithms that respect invariants</strong>: The <strong class="source-inline">&lt;algorithm&gt;</strong> header offers many algorithms optimized for containers such as <strong class="source-inline">std::vector</strong>. These often handle potential invalidations internally, safeguarding your code against <span class="No-Break">such pitfalls.</span></li>
				<li><strong class="bold">Caution with custom comparators and predicates</strong>: When using algorithms that require comparators or predicates, ensure they don’t internally modify the vector in a way that could cause invalidation. Maintain the principle of separation <span class="No-Break">of concerns.</span></li>
			</ul>
			<p>Let’s look at an example <a id="_idIndexMarker242"/>that integrates key strategies to avoid <span class="No-Break">iterator invalidation:</span></p>
			<pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; numbers;
  numbers.reserve(1000);
  for (int i = 1; i &lt;= 10; ++i) { numbers.push_back(i); }
  // 0-based index for number 5 in our vector 
  size_t positionOfFive = 4;
  std::cout &lt;&lt; "Fifth element: " &lt;&lt; numbers[positionOfFive]
            &lt;&lt; "\n";
  numbers.insert(numbers.begin() + 5, 99);
  std::vector&lt;int&gt;::iterator it =
      numbers.begin() + positionOfFive;
  std::cout &lt;&lt; "Element at the earlier fifth position "
               "after insertion: "
            &lt;&lt; *it &lt;&lt; "\n";
  // After inserting, refresh the iterator
  it = numbers.begin() + 6;
  std::sort(numbers.begin(), numbers.end());
  // Caution with Custom Comparators and Predicates:
  auto isOdd = [](int num) { return num % 2 != 0; };
  auto countOdd =
      std::count_if(numbers.begin(), numbers.end(), isOdd);
  std::cout &lt;&lt; "Number of odd values: " &lt;&lt; countOdd
            &lt;&lt; "\n";
  // Note: The lambda function 'isOdd' is just a read-only
  // operation and doesn't modify the vector, ensuring we
  // don't have to worry about invalidation.
  return 0;
}</pre>			<p>Here is the<a id="_idIndexMarker243"/> <span class="No-Break">example output:</span></p>
			<pre class="console">
Fifth element: 5
Element at the earlier fifth position after insertion: 5
Number of odd values: 6</pre>			<p>This example does <span class="No-Break">the following:</span></p>
			<ul>
				<li>Demonstrates how to use <strong class="source-inline">reserve</strong> to pre-allocate memory, anticipating <span class="No-Break">the size.</span></li>
				<li>Shows positions (index values) instead of iterators to handle <span class="No-Break">potential invalidations.</span></li>
				<li>Refreshes iterators after a disruptive <span class="No-Break">operation (</span><span class="No-Break"><strong class="source-inline">insert</strong></span><span class="No-Break">).</span></li>
				<li>Uses the <strong class="source-inline">&lt;algorithm&gt;</strong> header (i.e., <strong class="source-inline">std::sort</strong> and <strong class="source-inline">std::count_if</strong>) that is optimized for containers and <span class="No-Break">respect invariants.</span></li>
				<li>Emphasizes <a id="_idIndexMarker244"/>the importance of read-only operations (through the <strong class="source-inline">isOdd</strong> lambda) to avoid possible invalidations. (The <strong class="source-inline">isOdd</strong> lambda function is just a read-only operation and doesn’t modify the vector, ensuring we don’t have to worry <span class="No-Break">about invalidation.)</span></li>
			</ul>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor123"/>Dealing with invalidation in multi-threaded scenarios</h2>
			<p>While <a id="_idIndexMarker245"/>iterator invalidation in a single-threaded application is easier to manage, things can get trickier in multi-threaded contexts. Imagine one thread modifying a vector while another attempts to read from it using an iterator. The chaos! The catastrophe! The following are the ways to tackle invalidation in <span class="No-Break">multi-threaded scenarios:</span></p>
			<ul>
				<li><strong class="bold">Use mutexes and locks</strong>: Safeguard sections of your code that modify the vector with <strong class="bold">mutexes</strong>. This <a id="_idIndexMarker246"/>ensures that only one thread can change the vector at a given time, preventing concurrent operations that might lead to <span class="No-Break">unpredictable invalidations.</span></li>
				<li><strong class="bold">Use atomic operations</strong>: Some operations might be made atomic, ensuring they’re completed fully without interruption, reducing the chances of unsynchronized access <span class="No-Break">and modification.</span></li>
				<li><strong class="bold">Consider thread-safe containers</strong>: If multi-threading is central to your application, consider <a id="_idIndexMarker247"/>using <strong class="bold">thread-safe containers</strong> designed to handle concurrent accesses and modifications without compromising <span class="No-Break">on invariants.</span></li>
			</ul>
			<p class="callout-heading">Mutex</p>
			<p class="callout">A mutex, short<a id="_idIndexMarker248"/> for <strong class="bold">mutual exclusion</strong>, is a synchronization primitive used in concurrent programming to protect shared resources or critical sections of code from being accessed by multiple threads simultaneously. By locking a mutex before accessing a shared resource and unlocking it afterward, a thread ensures that no other thread can access the resource while it’s being used, thus preventing race conditions and ensuring data consistency in <span class="No-Break">multi-threaded applications.</span></p>
			<p class="callout-heading">Thread-safe containers</p>
			<p class="callout">A thread-safe container refers to a data structure that allows multiple threads to access and modify its contents concurrently without causing data corruption or inconsistencies. This is achieved through internal mechanisms such as locking or atomic operations that ensure synchronization and mutual exclusion, thereby maintaining the integrity of the container’s data even in a multi-threaded environment. Such containers are crucial in concurrent programming for safe and efficient data sharing <span class="No-Break">between threads.</span></p>
			<p>Let’s look <a id="_idIndexMarker249"/>at a practical example of multi-threaded access to <strong class="source-inline">std::vector</strong>. This example will demonstrate the use of mutexes to prevent concurrent modifications, ensuring <span class="No-Break">thread safety:</span></p>
			<pre class="source-code">
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
std::mutex vecMutex;
void add_to_vector(std::vector&lt;int&gt; &amp;numbers, int value) {
  std::lock_guard&lt;std::mutex&gt; guard(vecMutex);
  numbers.push_back(value);
}
void print_vector(const std::vector&lt;int&gt; &amp;numbers) {
  std::lock_guard&lt;std::mutex&gt; guard(vecMutex);
  for (int num : numbers) { std::cout &lt;&lt; num &lt;&lt; " "; }
  std::cout &lt;&lt; "\n";
}
int main() {
  std::vector&lt;int&gt; numbers;
  std::thread t1(add_to_vector, std::ref(numbers), 1);
  std::thread t2(add_to_vector, std::ref(numbers), 2);
  t1.join();
  t2.join();
  std::thread t3(print_vector, std::ref(numbers));
  t3.join();
  return 0;
}</pre>			<p>Here is the <a id="_idIndexMarker250"/><span class="No-Break">example output:</span></p>
			<pre class="console">
2 1</pre>			<p>This example illustrates the <span class="No-Break">following concepts:</span></p>
			<ul>
				<li>We use a mutex (<strong class="source-inline">vecMutex</strong>) to protect the shared <strong class="source-inline">std::vector</strong> from concurrent access <span class="No-Break">and modification.</span></li>
				<li>The <strong class="source-inline">add_to_vector</strong> and <strong class="source-inline">print_vector</strong> functions lock the mutex using <strong class="source-inline">std::lock_guard</strong>, ensuring exclusive access to the vector during <span class="No-Break">their scope.</span></li>
				<li>We use <strong class="source-inline">std::thread</strong> to run functions that concurrently modify or read from the vector. The use of mutexes ensures that these operations <span class="No-Break">are thread-safe.</span></li>
			</ul>
			<p>Remember, while<a id="_idIndexMarker251"/> mutexes safeguard against concurrent modifications, they can also introduce potential deadlocks and reduce parallelism. If multi-threading is deeply integrated into your application, you might consider other thread-safe containers or advanced <span class="No-Break">synchronization techniques.</span></p>
			<p>Understanding and respecting container invariants is paramount in harnessing the full power of STL containers and the <strong class="source-inline">&lt;algorithm&gt;</strong> header. Knowing when and why certain invariants might be disrupted allows for the creation of robust, efficient, and reliable code. As we continue our exploration of algorithms beyond <strong class="source-inline">std::vector</strong>, always keep these principles <span class="No-Break">in mind.</span></p>
			<p>In this section, we addressed the importance of preserving <strong class="source-inline">std::vector</strong> stability and the risks of iterator invalidation during container modification. We identified actions that cause invalidation and their potential to disrupt <span class="No-Break">program integrity.</span></p>
			<p>Understanding iterator behavior is vital for bug prevention and ensuring the robustness of our applications. We’ve also learned methods to mitigate invalidation risks, maintaining vector consistency throughout operations that might <span class="No-Break">jeopardize it.</span></p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor124"/>Summary</h1>
			<p>Throughout this chapter, we have deepened our understanding of the STL through the lens of <strong class="source-inline">std::vector</strong> and its interaction with various algorithms. We commenced with sorting vectors, where we explored the <strong class="source-inline">std::sort</strong> algorithm and its underlying engine, introsort, appreciating its <em class="italic">O(n log n)</em> efficiency. We progressed to searching within vectors, contrasting the conditions and efficiencies of linear and binary <span class="No-Break">search techniques.</span></p>
			<p>The chapter then guided us through effective vector manipulation, including transformation with <strong class="source-inline">std::copy</strong> and the considerations necessary to prevent performance degradation or logical errors. We learned to use custom comparators and predicates to extend the functionality of standard algorithms when working with user-defined structs and classes. Finally, we explored container invariants and iterator invalidation, acquiring strategies to maintain data integrity even in complex, <span class="No-Break">multi-threaded environments.</span></p>
			<p>Critically, this information provides us with practical and detailed insights into how to leverage <strong class="source-inline">std::vector</strong> effectively. Mastery of these algorithms allows developers to write efficient, robust, and adaptable code to various <span class="No-Break">programming challenges.</span></p>
			<p>Next, we will shift our focus from the technical intricacies of algorithms to a broader discussion on why <strong class="source-inline">std::vector</strong> should be our default container of choice. We will compare <strong class="source-inline">std::vector</strong> with other containers, dive into its memory advantages, and reflect on practical use cases, from data processing to game development. This will underscore the versatility and efficiency of <strong class="source-inline">std::vector</strong>, solidifying its status as a safe and powerful default choice, yet one among many tools available to the adept <span class="No-Break">C++ programmer.</span></p>
		</div>
	</body></html>