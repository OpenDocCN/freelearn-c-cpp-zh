["```cpp\n    void Context::initializeExtensions() {\n       uint32_t numExtensions = 0;\n      xrEnumerateInstanceExtensionProperties(\n        nullptr, 0, &numExtensions, nullptr);\n      availableExtensions_.resize(\n        numExtensions,\n        {XR_TYPE_EXTENSION_PROPERTIES});\n      xrEnumerateInstanceExtensionProperties(\n        nullptr, numExtensions, &numExtensions,\n        availableExtensions_.data());\n      requestedExtensions_.erase(\n        std::remove_if(\n          requestedExtensions_.begin(),\n          requestedExtensions_.end(),\n          [this](const char *ext) {\n            return std::none_of(\n              availableExtensions_.begin(),\n              availableExtensions_.end(),\n              [ext](\n                const XrExtensionProperties &props) {\n                return strcmp(props.extensionName,\n                              ext) == 0;\n              });\n          }),\n        requestedExtensions_.end());\n    }\n    ```", "```cpp\n    bool Context::createInstance() {\n      const XrApplicationInfo appInfo = {\n        .applicationName = \"OpenXR Example\",\n        .applicationVersion = 0,\n        .engineName = \"OpenXR Example\",\n        .engineVersion = 0,\n        .apiVersion = XR_CURRENT_API_VERSION,\n      };\n      const XrInstanceCreateInfo instanceCreateInfo =\n        {\n          .type = XR_TYPE_INSTANCE_CREATE_INFO,\n          .createFlags = 0,\n          .applicationInfo = appInfo,\n          .enabledApiLayerCount = 0,\n          .enabledApiLayerNames = nullptr,\n          .enabledExtensionCount =\n            static_cast<uint32_t>(\n              requestedExtensions_.size()),\n          .enabledExtensionNames =\n            requestedExtensions_.data(),\n        };\n      XR_CHECK(xrCreateInstance(&instanceCreateInfo,\n                                &instance_));\n      XR_CHECK(xrGetInstanceProperties(\n        instance_, &instanceProps_));\n    }\n    ```", "```cpp\n    void Context::systemInfo() {\n      const XrSystemGetInfo systemGetInfo = {\n        .type = XR_TYPE_SYSTEM_GET_INFO,\n        .formFactor =\n          XR_FORM_FACTOR_HEAD_MOUNTED_DISPLAY,\n      };\n      XR_CHECK(xrGetSystem(instance_, &systemGetInfo,\n                           &systemId_));\n      XR_CHECK(xrGetSystemProperties(\n        instance_, systemId_, &systemProps_));\n    }\n    ```", "```cpp\n    void Context::initGraphics() {\n      uint32_t bufferSize = 0;\n      pfnGetVulkanInstanceExtensionsKHR(\n        instance_, systemId_, 0, &bufferSize, NULL);\n      requiredVkInstanceExtensionsBuffer_.resize(\n        bufferSize);\n      pfnGetVulkanInstanceExtensionsKHR(\n        instance_, systemId_, bufferSize, &bufferSize,\n        requiredVkInstanceExtensionsBuffer_.data());\n      pfnGetVulkanDeviceExtensionsKHR(\n        instance_, systemId_, 0, &bufferSize, NULL);\n      requiredVkDeviceExtensionsBuffer_.resize(\n        bufferSize);\n      pfnGetVulkanDeviceExtensionsKHR(\n        instance_, systemId_, bufferSize, &bufferSize,\n        requiredVkDeviceExtensionsBuffer_.data());\n    }\n    ```", "```cpp\n    bool Context::initializeSession(\n      VkInstance vkInstance,\n      VkPhysicalDevice vkPhysDevice,\n      VkDevice vkDevice, uint32_t queueFamilyIndex) {\n      // Bind Vulkan to XR session\n      const XrGraphicsBindingVulkanKHR\n        graphicsBinding = {\n          XR_TYPE_GRAPHICS_BINDING_VULKAN_KHR,\n          NULL,\n          vkInstance,\n          vkPhysDevice,\n          vkDevice,\n          queueFamilyIndex,\n          0,\n        };\n      const XrSessionCreateInfo sessionCreateInfo = {\n        .type = XR_TYPE_SESSION_CREATE_INFO,\n        .next = &graphicsBinding,\n        .createFlags = 0,\n        .systemId = systemId_,\n      };\n      XR_CHECK(xrCreateSession(\n        instance_, &sessionCreateInfo, &session_));\n      return true;\n    }\n    ```", "```cpp\n    void Context::createSwapchains(\n      VulkanCore::Context &ctx) {\n      const uint32_t numSwapchainProviders =\n        useSinglePassStereo_ ? 1 : kNumViews;\n      const uint32_t numViewsPerSwapchain =\n        useSinglePassStereo_ ? kNumViews : 1;\n      swapchains_.reserve(numSwapchainProviders);\n      for (uint32_t i = 0; i < numSwapchainProviders;\n           i++) {\n        swapchains_.emplace_back(\n          std::make_unique<OXRSwapchain>(\n            ctx, session_, viewports_[i],\n            numViewsPerSwapchain));\n        swapchains_.back()->initialize();\n      }\n    }\n    ```", "```cpp\n    XrFrameState Context::beginFrame() {\n      const XrFrameWaitInfo waitFrameInfo = {\n        XR_TYPE_FRAME_WAIT_INFO};\n      XrFrameState frameState = {XR_TYPE_FRAME_STATE};\n      XR_CHECK(xrWaitFrame(session_, &waitFrameInfo,\n                           &frameState));\n      XrFrameBeginInfo beginFrameInfo = {\n        XR_TYPE_FRAME_BEGIN_INFO};\n      XR_CHECK(\n        xrBeginFrame(session_, &beginFrameInfo));\n      XrSpaceLocation loc = {\n        loc.type = XR_TYPE_SPACE_LOCATION};\n      XR_CHECK(xrLocateSpace(\n        headSpace_, stageSpace_,\n        frameState.predictedDisplayTime, &loc));\n      XrPosef headPose = loc.pose;\n      XrViewState viewState = {XR_TYPE_VIEW_STATE};\n      const XrViewLocateInfo projectionInfo = {\n        .type = XR_TYPE_VIEW_LOCATE_INFO,\n        .viewConfigurationType =\n          viewConfigProps_.viewConfigurationType,\n        .displayTime =\n          frameState.predictedDisplayTime,\n        .space = headSpace_,\n      };\n      uint32_t numViews = views_.size();\n      views_[0].type = XR_TYPE_VIEW;\n      views_[1].type = XR_TYPE_VIEW;\n      XR_CHECK(xrLocateViews(\n        session_, &projectionInfo, &viewState,\n        views_.size(), &numViews, views_.data()));\n    }\n    ```", "```cpp\n    void Context::endFrame(XrFrameState frameState) {\n      const XrFrameEndInfo endFrameInfo = {\n        .type = XR_TYPE_FRAME_END_INFO,\n        .displayTime =\n          frameState.predictedDisplayTime,\n        .environmentBlendMode =\n          XR_ENVIRONMENT_BLEND_MODE_OPAQUE,\n        .layerCount = 1,\n        .layers = layers,\n      };\n      XR_CHECK(xrEndFrame(session_, &endFrameInfo));\n    }\n    ```", "```cpp\n    void android_main(struct android_app *pApp) {\n      OXR::Context oxrContext(pApp);\n      oxrContext.initializeExtensions();\n      oxrContext.createInstance();\n      VulkanCore::Context vkContext(\n        VkApplicationInfo{});\n      vkContext.createVkDevice(\n        oxrContext.findVkGraphicsDevice(\n          vkContext.instance()),\n        oxrContext.vkDeviceExtensions(),\n        VK_QUEUE_GRAPHICS_BIT);\n      oxrContext.initializeSession(\n        vkContext.instance(),\n        vkContext.physicalDevice().vkPhysicalDevice(),\n        vkContext.device(),\n        vkContext.physicalDevice()\n          .graphicsFamilyIndex()\n          .value());\n      oxrContext.createSwapchains(vkContext);\n      auto commandMgr =\n        vkContext.createGraphicsCommandQueue(3, 3);\n      do {\n        auto frameState = oxrContext.beginFrame();\n        if (frameState.shouldRender == XR_FALSE) {\n          oxrContext.endFrame(frameState);\n          continue;\n        }\n        auto commandBuffer =\n          commandMgr.getCmdBufferToBegin();\n        vkCmdDrawIndexedIndirect(\n          commandBuffer, buffers[3]->vkBuffer(), 0,\n          numMeshes,\n          sizeof(EngineCore::\n                   IndirectDrawCommandAndMeshData));\n        commandMgr.submit(\n          &vkContext.swapchain()->createSubmitInfo(\n            &commandBuffer,\n            &VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,\n            false, false));\n        commandMgr.goToNextCmdBuffer();\n        oxrContext.swapchain(0)\n          ->releaseSwapchainImages();\n        oxrContext.endFrame(frameState);\n      } while (!pApp->destroyRequested);\n    }\n    ```", "```cpp\n    const glm::vec2 mapSize = glm::vec2(\n        std::ceilf(\n            oxrContext.swapchain(0)\n                ->viewport()\n                .recommendedImageRectWidth /\n            std::max(\n                32u,\n                vkContext.physicalDevice()\n                    .fragmentDensityMapProperties()\n                    .minFragmentDensityTexelSize.width)),\n        std::ceilf(\n            oxrContext.swapchain(0)\n                ->viewport()\n                .recommendedImageRectHeight /\n            std::max(\n                32u,\n                vkContext.physicalDevice()\n                    .fragmentDensityMapProperties()\n                    .minFragmentDensityTexelSize.height)));\n    ```", "```cpp\n    std::shared_ptr<VulkanCore::Texture> =\n        std::make_shared<VulkanCore::Texture>(\n            vkContext, VK_IMAGE_TYPE_2D,\n            VK_FORMAT_R8G8_UNORM,\n            static_cast<VkImageCreateFlags>(0),\n            VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT,\n            VkExtent3D{static_cast<uint32_t>(mapSize.x),\n                       static_cast<uint32_t>(mapSize.y),\n                       1},\n            1, 2, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,\n            false, VK_SAMPLE_COUNT_1_BIT,\n            \"fragment density map\", true,\n            VK_IMAGE_TILING_LINEAR);\n    ```", "```cpp\n    std::vector<uint8_t> fdmData(mapSize.x *mapSize.y * 2,\n                                 255);\n    constexpr uint16_t high_res_radius = 8;\n    const glm::vec2 center = mapSize / 2.f;\n    for (uint32_t x = 0; x < mapSize.x; ++x) {\n      for (uint32_t y = 0; y < mapSize.y; ++y) {\n        const float length =\n            glm::length(glm::vec2(x, y) - center);\n        if (length < high_res_radius) {\n          const uint32_t index =\n              (y * mapSize.x * 2) + x * 2;\n          fdmData[index] = 255;     // full density\n          fdmData[index + 1] = 255; // full density\n    ```", "```cpp\n    const auto fdmAttachDesc = VkAttachmentDescription{\n        .format = VK_FORMAT_R8G8_UNORM,\n        .samples = VK_SAMPLE_COUNT_1_BIT,\n        .loadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE,\n        .storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE,\n        .initialLayout =\n            VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT,\n        .finalLayout =\n            VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT,\n    };\n    ```", "```cpp\n    const VkRenderPassFragmentDensityMapCreateInfoEXT\n        fdmAttachmentci = {\n            .sType =\n                VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT,\n            .fragmentDensityMapAttachment =\n                {\n                    .attachment =\n                        fragmentDensityAttachmentReference,\n                    .layout =\n                        VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT,\n                },\n    };\n    refers to the *index* of the VkAttachmentDescription structure that mentions the FDM in the attachment description array passed to VkRenderPassCreateInfo::pAttachments.\n    ```", "```cpp\n    const VkRenderPassCreateInfo rpci = {\n        .sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO,\n        .pNext = &fdmAttachmentci,\n        ...\n    };\n    ```", "```cpp\n    <uses-permission android:name=\"com.oculus.permission.EYE_TRACKING\" />\n    <uses-permission android:name=\"oculus.software.eye_tracking\" />\n    <uses-feature android:name=\"oculus.software.eye_tracking\"/>\n    ```", "```cpp\n    adb shell pm grant com.example.openxrsample and you might need to change it to your app’s name.\n    ```", "```cpp\n    const XrApplicationInfo appInfo = {\n        .applicationName = \"OpenXR Example\",\n        .applicationVersion = 0,\n        .engineName = \"OpenXR Example\",\n        .engineVersion = 0,\n        .apiVersion = XR_CURRENT_API_VERSION,\n    };\n    std::vector<const char *> requestedExtensions = {\n        XR_KHR_VULKAN_ENABLE_EXTENSION_NAME,\n       XR_FB_SWAPCHAIN_UPDATE_STATE_VULKAN_EXTENSION_NAME,\n        XR_EXT_EYE_GAZE_INTERACTION_EXTENSION_NAME,\n    };\n    const XrInstanceCreateInfo instanceCreateInfo = {\n        .type = XR_TYPE_INSTANCE_CREATE_INFO,\n        .createFlags = 0,\n        .applicationInfo = appInfo,\n        .enabledApiLayerCount = 0,\n        .enabledApiLayerNames = nullptr,\n        .enabledExtensionCount = static_cast<uint32_t>(\n            requestedExtensions_.size()),\n        .enabledExtensionNames =\n            requestedExtensions_.data(),\n    };\n    XR_CHECK(xrCreateInstance(&instanceCreateInfo,\n                              &instance_));\n    ```", "```cpp\n    XrActionSet eyegazeActionSet_ = XR_NULL_HANDLE;\n    XrAction eyeGazeAction_ = XR_NULL_HANDLE;\n    XrSpace gazeActionSpace_ = XR_NULL_HANDLE;\n    XrSpace localReferenceSpace_ = XR_NULL_HANDLE;\n    ```", "```cpp\n    const XrActionSetCreateInfo actionSetInfo{\n        .type = XR_TYPE_ACTION_SET_CREATE_INFO,\n        .actionSetName = \"gameplay\",\n        .localizedActionSetName = \"Eye Gaze Action Set\",\n        .priority = 0,\n    };\n    XR_CHECK(xrCreateActionSet(instance_, &actionSetInfo,\n                               &eyegazeActionSet_));\n    ```", "```cpp\n    const XrActionCreateInfo actionInfo{\n        .type = XR_TYPE_ACTION_CREATE_INFO,\n        .actionName = \"user_intent\",\n        .actionType = XR_ACTION_TYPE_POSE_INPUT,\n        .localizedActionName = \"Eye Gaze Action\",\n    };\n    XR_CHECK(xrCreateAction(eyegazeActionSet_, &actionInfo,\n                            &eyegazeAction_));\n    ```", "```cpp\n    XrPath eyeGazeInteractionProfilePath;\n    XR_CHECK(xrStringToPath(\n        instance_,\n        \"/interaction_profiles/ext/eye_gaze_interaction\",\n        &eyeGazeInteractionProfilePath));\n    XrPath gazePosePath;\n    XR_CHECK(xrStringToPath(\n        instance_, \"/user/eyes_ext/input/gaze_ext/pose\",\n        &gazePosePath));\n    ```", "```cpp\n    const XrActionSuggestedBinding bindings{\n        .action = eyegazeAction_,\n        .binding = gazePosePath,\n    };\n    const XrInteractionProfileSuggestedBinding\n        suggestedBindings{\n            .type =\n                XR_TYPE_INTERACTION_PROFILE_SUGGESTED_BINDING,\n            .interactionProfile =\n                eyeGazeInteractionProfilePath,\n            .countSuggestedBindings = 1,\n            .suggestedBindings = &bindings,\n        };\n    XR_CHECK(xrSuggestInteractionProfileBindings(\n        instance_, &suggestedBindings));\n    ```", "```cpp\n    const XrSessionActionSetsAttachInfo attachInfo{\n        .type = XR_TYPE_SESSION_ACTION_SETS_ATTACH_INFO,\n        .countActionSets = 1,\n        .actionSets = &eyegazeActionSet_,\n    };\n    XR_CHECK(xrAttachSessionActionSets(session_,\n                                       &attachInfo));\n    ```", "```cpp\n    const XrActionSpaceCreateInfo createActionSpaceInfo{\n        .type = XR_TYPE_ACTION_SPACE_CREATE_INFO,\n        .action = eyegazeAction_,\n        .poseInActionSpace = poseIdentity_,\n    };\n    XR_CHECK(xrCreateActionSpace(session_,\n                                 &createActionSpaceInfo,\n                                 &gazeActionSpace_));\n    ```", "```cpp\n    const XrPosef eyePoseIdentity = {\n      .orientation = {.x = 0,\n                      .y = 0,\n                      .z = 0,\n                      .w = 1.f},\n      .position = {0, 1.8f, 0},\n    };\n    const XrReferenceSpaceCreateInfo\n        createReferenceSpaceInfo{\n            .type = XR_TYPE_REFERENCE_SPACE_CREATE_INFO,\n            .referenceSpaceType =\n                XR_REFERENCE_SPACE_TYPE_VIEW,\n            .poseInReferenceSpace = eyePoseIdentity,\n        };\n    XR_CHECK(xrCreateReferenceSpace(\n        session_, &createReferenceSpaceInfo,\n        &localReferenceSpace_));\n    ```", "```cpp\n    if (currentState_ == XR_SESSION_STATE_FOCUSED) {\n      XrActiveActionSet activeActionSet{\n          .actionSet = eyegazeActionSet_,\n          .subactionPath = XR_NULL_PATH,\n      };\n      const XrActionsSyncInfo syncInfo{\n          .type = XR_TYPE_ACTIONS_SYNC_INFO,\n          .countActiveActionSets = 1,\n          .activeActionSets = &activeActionSet,\n      };\n      XR_CHECK(xrSyncActions(session_, &syncInfo));\n      XrActionStatePose actionStatePose{\n          XR_TYPE_ACTION_STATE_POSE};\n      const XrActionStateGetInfo getActionStateInfo{\n          .type = XR_TYPE_ACTION_STATE_GET_INFO,\n          .action = eyegazeAction_,\n      };\n      XR_CHECK(xrGetActionStatePose(session_,\n                                    &getActionStateInfo,\n                                    &actionStatePose));\n    ```", "```cpp\n      if (actionStatePose.isActive)\n        XrEyeGazeSampleTimeEXT eyeGazeSampleTime{\n            XR_TYPE_EYE_GAZE_SAMPLE_TIME_EXT};\n        XrSpaceLocation gazeLocation{\n            XR_TYPE_SPACE_LOCATION, &eyeGazeSampleTime};\n        XR_CHECK(xrLocateSpace(\n            gazeActionSpace_, localReferenceSpace_,\n            frameState.predictedDisplayTime,\n            &gazeLocation));\n    ```", "```cpp\n        const bool orientationValid =\n            gazeLocation.locationFlags &\n            XR_SPACE_LOCATION_ORIENTATION_VALID_BIT;\n        const bool positionValid =\n            gazeLocation.locationFlags &\n            XR_SPACE_LOCATION_POSITION_VALID_BIT;\n        if (orientationValid && positionValid) {\n          eyeGazePositionScreen_[0] =\n            screenCoordinatesFromEyeGazePose(gazeLocation,\n                                             0, 0);\n          eyeGazePositionScreen_[1] =\n            screenCoordinatesFromEyeGazePose(gazeLocation,\n                                             1, 0);\n        }\n    ```", "```cpp\n    glm::vec3\n    Context::screenCoordinatesFromEyeGazePose(\n      XrSpaceLocation gazeLocation, int eye,\n      float offset) {\n      XrVector3f canonicalViewDirection{0, 0, -1.f};\n      // Reset the position. We won't need it\n      gazeLocation.pose.position = {0, 0, 0};\n      XrVector3f transformedViewDirection;\n      XrPosef_TransformVector3f(\n        &transformedViewDirection, &gazeLocation.pose,\n        &canonicalViewDirection);\n      XrMatrix4x4f proj;\n      XrMatrix4x4f_CreateProjectionFov(\n        &proj, GRAPHICS_OPENGL, views_[eye].fov,\n        near_, far_);\n      const XrVector4f tanAngle = {\n        -transformedViewDirection.x /\n          transformedViewDirection.z,\n        -transformedViewDirection.y /\n          transformedViewDirection.z,\n        -1.f, 0};\n      const auto width = swapchain(0)\n                           ->viewport()\n                           .recommendedImageRectWidth;\n      const auto height =\n        swapchain(0)\n          ->viewport()\n          .recommendedImageRectHeight;\n      XrMatrix4x4f scalem;\n      XrMatrix4x4f_CreateScale(&scalem, 0.5f, 0.5f,\n                               1.f);\n      XrMatrix4x4f biasm;\n      XrMatrix4x4f_CreateTranslation(&biasm, 0.5f,\n                                     0.5f, 0);\n      XrMatrix4x4f rectscalem;\n      XrMatrix4x4f_CreateScale(&rectscalem, width,\n                               height, 1.f);\n      XrMatrix4x4f rectbiasm;\n      XrMatrix4x4f_CreateTranslation(&rectbiasm, 0, 0,\n                                     0);\n      XrMatrix4x4f rectfromclipm;\n      XrMatrix4x4f_Multiply(&rectfromclipm,\n                            &rectbiasm, &rectscalem);\n      XrMatrix4x4f_Multiply(&rectfromclipm,\n                            &rectfromclipm, &biasm);\n      XrMatrix4x4f_Multiply(&rectfromclipm,\n                            &rectfromclipm, &scalem);\n      XrMatrix4x4f rectfromeyem;\n      XrMatrix4x4f_Multiply(&rectfromeyem,\n                            &rectfromclipm, &proj);\n      rectfromeyem.m[11] = -1.f;\n      XrVector4f texCoords;\n      XrMatrix4x4f_TransformVector4f(\n        &texCoords, &rectfromeyem, &tanAngle);\n      return glm::vec3(texCoords.x,\n                       height - texCoords.y - offset,\n                       texCoords.y);\n    }\n    ```", "```cpp\n    const XrVulkanSwapchainCreateInfoMETA\n      vulkanImageAdditionalFlags{\n        .type =\n          XR_TYPE_VULKAN_SWAPCHAIN_CREATE_INFO_META,\n        .next = nullptr,\n        .additionalCreateFlags =\n          VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT |\n          VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM,\n      };\n    Const XrSwapchainCreateInfo swapChainCreateInfo = {\n      .type = XR_TYPE_SWAPCHAIN_CREATE_INFO,\n      .next = &vulkanImageAdditionalFlags,\n      ...\n    };\n    ```", "```cpp\n    const std::array<VkOffset2D, 2> offsets = {\n      leftEyeOffset,\n      rightEyeOffset,\n    };\n    const VkSubpassFragmentDensityMapOffsetEndInfoQCOM\n      offsetInfo = {\n        .sType =\n          VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM,\n        .fragmentDensityOffsetCount =\n          offsets.size(), // 1 for each\n                          // layer/multiview view\n        .pFragmentDensityOffsets =\n          offsets\n            .data(), // aligned to\n                     // fragmentDensityOffsetGranularity\n    };\n    const VkSubpassEndInfo subpassEndInfo = {\n      .sType = VK_STRUCTURE_TYPE_SUBPASS_END_INFO,\n      .pNext = &offsetInfo,\n    };\n    vkCmdEndRenderPass2KHR(commandBuffer,\n                           &subpassEndInfo);\n    ```", "```cpp\n    const glm::vec2 swapchainImageCenter =\n      glm::vec2(oxrContext.swapchain(0)\n                    ->viewport()\n                    .recommendedImageRectWidth /\n                  2.f,\n                oxrContext.swapchain(0)\n                    ->viewport()\n                    .recommendedImageRectHeight /\n                  2.f);\n    const glm::vec2 offsetInPixelsLeft =\n      glm::vec2(eyeGazeScreenPosLeft) -\n      swapchainImageCenter;\n    const glm::vec2 offsetInPixelsRight =\n      glm::vec2(eyeGazeScreenPosRight) -\n      swapchainImageCenter;\n    const glm::vec2 fdmOffsetGranularity = glm::vec2(\n      vkContext.physicalDevice()\n        .fragmentDensityMapOffsetProperties()\n        .fragmentDensityOffsetGranularity.width,\n      vkContext.physicalDevice()\n        .fragmentDensityMapOffsetProperties()\n        .fragmentDensityOffsetGranularity.height);\n    const VkOffset2D leftEyeOffset{\n      offsetInPixelsLeft.x,\n      offsetInPixelsLeft.y,\n    };\n    const VkOffset2D rightEyeOffset{\n      offsetInPixelsRight.x,\n      offsetInPixelsRight.y,\n    };\n    ```", "```cpp\n    void Context::enable16bitFloatFeature() {\n      enable11Features_.storageBuffer16BitAccess = VK_TRUE;\n      enable12Features_.shaderFloat16 = VK_TRUE;\n    }\n    ```", "```cpp\n    #extension GL_EXT_shader_explicit_arithmetic_types_float16 : require\n    #extension GL_EXT_shader_16bit_storage : require\n    struct Vertex {\n      float16_t posX;\n      float16_t posY;\n      float16_t posZ;\n      float16_t normalX;\n      float16_t normalY;\n      float16_t normalZ;\n      float16_t tangentX;\n      float16_t tangentY;\n      float16_t tangentZ;\n      float16_t tangentW;\n      float16_t uvX;\n      float16_t uvY;\n      float16_t uvX2;\n      float16_t uvY2;\n      int material;\n    };\n    ```"]