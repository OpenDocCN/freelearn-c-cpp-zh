- en: Getting Started with OpenGL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous three chapters, we rendered 2D objects called sprites in our
    tiny Bazooka game using the **Simple and Fast Media Library** (**SFML**). At the
    core of SFML is OpenGL; this is used to render anything on screen, including 2D
    objects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: SFML does a great job of putting everything in a nice little package, and this
    allows us to get a 3D game going very quickly. However, in order to understand
    how a graphics library actually works, we need to learn how OpenGL works by delving
    deeper into how to use it so that we can render anything on the screen.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discover how to use a graphics library, such as OpenGL,
    in order to render 3D objects in any scene. We will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: What is OpenGL?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our first OpenGL project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a window and ClearScreen
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a `Mesh` class
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Camera class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Shaderloader class
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Light Renderer class
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing the object
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is OpenGL?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, what is this OpenGL that we speak of? Well, OpenGL is a collection of graphics
    APIs; essentially, this is a collection of code that allows you to gain access
    to the features of your graphics hardware. The current version of OpenGL is 4.6,
    but any graphics hardware that is capable of running OpenGL 4.5 can run 4.6 as
    well.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL is entirely hardware and operating system independent, so it doesn't
    matter if you have a NVIDIA or AMD GPU; it will work the same on both hardware.
    The way in which OpenGL's features work is defined by a specification that is
    used by graphics hardware manufacturers while they're developing the drivers for
    their hardware. This is why we sometimes have to update the graphics hardware
    drivers if something doesn't look right or if the game is not performing well.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, OpenGL runs the same, regardless of whether you are running a Windows
    or a Linux machine. It is, however, deprecated on macOS Mojave, but if you are
    running a macOS version earlier than Mojave, then it is still compatible.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL is only responsible for rendering objects in the scene. Unlike SFML,
    which allows you to create a window and then gain access to the keyboard and mouse
    input, we will need to add a separate library that will handle all of this for
    us.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: So, let's start preparing our project by rendering a 3D OpenGL object in the
    scene.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Creating our first OpenGL project
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have gained an understanding of what OpenGL is, let''s examine
    how to create our first OpenGL project, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Create a new empty C++ project in Visual Studio and call it `OpenGLProject`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, download GLEW; this is a C/C++ extension loader library. OpenGL supports
    extensions that various GPU vendors can use to write and extend the functionality
    of OpenGL. This library will determine what extensions are supported on the platform.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to [http://glew.sourceforge.net/](http://glew.sourceforge.net/) and download
    the Windows 32-bit and 64-bit Binaries:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0ce25f6f-52f8-4912-b6c2-83fcc5d6d88b.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: 'Next, we need to download GLFW; this is a platform-independent API that is
    used for creating a window, reading inputs, and handling events. Go to [https://www.glfw.org/download.html](https://www.glfw.org/download.html)
    and download the 64-bit Windows binary. In this book, we will be primarily looking
    at implementing it on the Windows platform:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f22aa0a8-f6d0-4268-8cc5-ff9c92012def.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: Next, we need to download `glm`, which is used to do all the math for our graphics
    calculations. Go to [https://glm.g-truc.net/0.9.9/index.html](https://glm.g-truc.net/0.9.9/index.html)
    and download GLM from the site.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have downloaded all the required libraries and headers, we can start
    adding them to our project.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the root directory (where the Visual Studio project file is stored) of the
    project, create a new directory called `Dependencies`.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From this directory, extract `glew`, `glfw`, and `glm`; the `Dependencies`
    directory should now look as follows:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ebf9e9ff-bd57-480d-befd-112fa32dbe8d.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: Open the Visual Studio project. We need to set the location of the headers and
    library files. To do this, open the project properties of `OpenGLProject` and
    set Configuration to Release and Platform to x64.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under C/C++ | General, select Additional Include Directories and select the
    following directories for GLEW and GLFW:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1cc6ccbb-4723-4054-a044-cbbc56c15d22.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: 'Next, under Linker |General, select Additional Library Directories, and then
    select the location of the `.lib` files in the `glew` and `glfw` directories,
    as follows:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9d5322e4-665a-459d-91c9-b4b681fed335.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: Next, we have to go to Linker | Input and specify which `.lib` files we are
    using.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under Linker | Input, select Additional Dependencies and then add opengl32.lib,
    glfw3.lib, and glew32.lib, as follows:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e1bdafc5-3f98-4608-a86b-de19c87cccdc.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: Although we didn't specifically download `opengl32.lib`, it is included when
    you update the driver of the graphics hardware. Therefore, make sure that you
    are running the most recent drivers for your GPU; if not, download them from the
    manufacturer's website.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we have to add the `glew32.dll` and `glfw3.dll` files to the root directory
    of the project. `glew32.dll` is inside `glew-2.1.0/ bin/Release/64`, whereas `glfw3.dll`
    is inside `glfw-3.2.1/lib-vc2015`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The root directory of the project file should now look as follows:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/479c3905-64d5-430c-a95b-7fd2f332dd29.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: With this out of the way, we can finally start working on the project.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a window and ClearScreen
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s explore how we can work with the OpenGL project that we created:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we have to do is create a window so that we can start rendering
    the game objects to the screen.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `.cpp` file; Visual Studio will automatically call this `source.cpp`,
    so keep it as it is.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the file, include the `glew` and `glfw` headers. Make sure that
    you include `glew.h` first since it contains the correct OpenGL header files to
    be included:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first thing we need to do here is initialize `glfw` by calling `glfwInit()`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once initialized, we can create the window that our game scene will be rendered
    to. To create a window, we need to create a new instance of `GLFWWindow` called
    window and call `glfwCreateWindow`. This takes five parameters, including the
    width and height of the window, along with the name of the window. The final two
    parameters—`monitor` and `share`—are set to `NULL`. The `monitor` parameter takes
    a specific monitor on which the window will be created. If it is set to `null`,
    then the default monitor is chosen. The `share` parameter will let us share the
    window resource with our users. Here, we set it to `NULL` as we don't want to
    share the window resources.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, run the project; you will see that a window briefly appears before the
    application closes.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Well, that's not very fun. Let's add the rest of the code so that we can see
    something being rendered on the viewport.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first thing we need to do is initialize OpenGL Context. OpenGL Context is
    a collection of all the current states of OpenGL. We will discuss the different
    states in the upcoming sections.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To do this, call `glfwMakeCurrentContext` and pass in the window that we just
    created:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can now initialize GLEW by calling `glewInit()`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will add the following code between `glewInit()` and `return 0` in
    the `main` function:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we are creating a `while` loop, calling `glfwWindowShouldClose`, and then
    passing it in the current window. While the window is open, the `glfwSwapBuffers(window);`
    and `glfwPollEvents();` commands will be executed.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `while` loop, we will render our scene. Then, we will swap display buffers.
    The display buffer is where the current frame is rendered and stored. While the
    current frame is being shown, the next frame is actually being rendered in the
    background, which we don't get to see. When the next frame is ready, the current
    frame is swapped with the new frame. This swapping of frames is done by `glfwSwapBuffer`
    and is managed by OpenGL.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After we swap the display buffer, we need to check for any events that were
    triggered, such as the window being closed in `glfwPollEvents()`. Once the window
    is closed, `glfw` is terminated.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you run the project now, you will see a black window; while it doesn't vanish,
    it is still not very impressive. We can use OpenGL to clear the viewport with
    a color of our choice, so let's do that next.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new function called `void renderScene()`. Whatever we render to the
    scene from now on will also be added to this function. Add a new prototype for
    `void renderScene()` to the top of the `source.cpp` file.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `renderScene` function, add the following lines of code:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the first function, we call `glClear()`. All OpenGL functions start with
    the `gl` prefix; the `glClear` function clears the buffer. In this case, we are
    asking OpenGL to clear the color buffer and the depth buffer. The color buffer
    is where all the color information is stored for the scene. The depth buffer stores
    whichever pixel is in front; this means that if a pixel is behind another pixel,
    then that pixel will not be stored. This is especially important for 3D scenes,
    where some objects can be behind other objects and get occluded by the objects
    that are in front of it. We only require the pixel information regarding the objects
    that are in front as we will only get to see those objects and not the objects
    that are behind them.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Next, we call the `glClearColor` function and pass in an RGBA value; in this
    case, red. The `glCearColor` function clears the color buffer with the specific
    color in every frame. The buffers need to be cleared in every frame; otherwise,
    the previous frame will be overwritten with the image in the current frame. Imagine
    this to be like clearing the blackboard before drawing anything on it in every
    frame.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The depth buffer is also cleared after every frame using a default white color.
    This means that we don't have to clear it manually as this will be done by default.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, call `renderScene` before swapping the buffer and run the project again.
    You should see a nice yellow viewport, as follows:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f1fccce8-99bb-4500-94d0-a0b3602ac427.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: Before drawing the objects, we have to create some additional classes that will
    help us define the shape that we want to draw. We also need to create a camera
    class in order to set up a virtual camera through which we can view the scene.
    Furthermore, we need to write a basic vertex, a `shader` fragment, and a `Shaderloader`
    class, which will create a `shader` program that we can use to render our shape.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: First, let's create the `Mesh` class, which is where we will define the different
    shapes that we want to draw.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Mesh class
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps explain how to create a `Mesh` class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'Create new `.h` and `.cpp` files called `Mesh.h` and `Mesh.cpp`, respectively.
    These will be used to create a new `Mesh` class. In the `Mesh.h` file, add the
    following code:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: At the top of the `Mesh.h` file, we include a vector so that we can store points
    in a vector and include `glm.hpp`. This will help us define points in the space
    using the `vec3` variable.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we create a new `enum` type called `MeshType` and create four types: `Mesh
    Triangle`, `Quad`, `Cube`, and `Sphere`. We've done this so that we can specify
    the kind of mesh we are using and so the data will be populated accordingly.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we create a new `struct` type called `Vertex`, which has `vec3` properties
    called `pos`, `Color`, and `Normal`, and a `vec2` property called `textCoords`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each vertex has certain properties, such as `Position`, `Color`, `Normal`, and
    `Texture Coordinate`. `Position` and `Color` store the position and color information
    for each vertex, respectively. `Normal` specifies which direction the normal attribute is
    pointing to while `Texture Coordinate` specifies how a texture needs to be laid
    out. We will cover the normal and texture coordinate attributes when we cover
    lighting and how to apply textures to our objects.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Then, the `Mesh` class is created. This has four functions, which are for setting
    the vertex and the index data per vertex.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Mesh.cpp` file, we include the `Mesh.h` file and then set the data
    for the four shapes. Here is an example of how `setTriData` sets the values for
    the vertices and indices:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For each of the three vertices of the triangle, we set the position, normal,
    color, and texture coordinate information in the `vertices` vector.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we set the indices in the `indices` vector. For definitions of the other
    functions, you can refer to the project that comes with this book. Then, we set
    the `_vertices` and `_indices` vectors to the reference vertices and indices,
    respectively.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Camera class
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps will help you create a `Camera` class:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Create two files: `Camera.h` and `Camera.cpp`. In the `Camera.h` file, include
    the following code:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, create the `Camera` class itself, as follows:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the constructor and the public region of the `camera` class, we get the **field
    of view** (**FOV**), the width and height of the viewport, the distance to `nearPlane`,
    the distance to `farPlane`, and the position that we want to set the camera at.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also add three getters to get the view matrix, projection matrix, and the
    camera position.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the private section, we create three variables: two 4 x 4 matrices for setting
    the view and projection matrices and a `vec3` property to specify the camera position.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Camera.cpp` file, we include the `Camera.h` file at the top and create
    the `camera` constructor, as follows:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the constructor, we set the camera position to the local variable and set
    up two `vec3` properties called `cameraFront` and `cameraUp`. Our camera is going
    to be a stationary camera that will always be looking toward the center of the
    world coordinates; the `up` vector will always be pointing toward the positive
    y-axis.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To create `viewMatrix`, we call the `glm::lookAt` function and pass in the `cameraPos`,
    `cameraFront`, and `cameraUp` vectors.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create the projection matrix by setting the `FOV` value of the `FOV`; this
    is an aspect ratio that is given by the `width` value over the `height`, `nearPlane`,
    and `farPlane` values.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the view and projection matrices set, we can now create the getter functions,
    as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Next, we'll create the `shaderLoader` class, which will let us create the `shader`
    program.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The ShaderLoader class
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps will show you how to implement the `ShaderLoader` class
    in an OpenGL project:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: In the `ShaderLoader` class, create a public function called `createProgram`
    that takes a vertex and fragment `shader` file.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll also create two private functions: `readShader`, which returns a string,
    and `createShader`, which returns an unsigned GL `int`:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the `ShaderLoader.cpp` file, we include our `ShaderLoader.h` header file,
    the `iostream` system header file, and the `fstream` vector, as follows:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`iostream` is used when you want to print something to the console; `fstream`
    is used for reading a file. We''ll need this as we will be passing in vertex and
    shader files for the `fstream` to read, as well as vectors for storing character
    strings.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create the `readerShader` function; this will be used to read the
    `shader` file that we passed in:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The contents of the `shader` file are then stored in a string and returned.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create the `createShader` function, which will actually compile the
    shader, as follows:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `CreateShader` function takes the following three parameters:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first parameter is the `enum` parameter, called `shaderType`, which specifies
    the type of `shader` being sent to be compiled. In this case, it could be a vertex
    shader or a fragment shader.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter is the string that contains the shader code.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final parameter is a string with the `shader` type, which will be used to
    specify whether there is a problem compiling the `shader` type.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `CreateShader` function, we call `glCreateShader` in order to specify
    the type of shader that is being created; then, `glCompileShader` is called to
    compile the shader. Afterward, we get the compiled result of the shader.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there is a problem with compiling the shader, then we send out a message
    stating that there is an error compiling the shader alongside `shaderLog`, which
    will detail the compilation error. If there are no errors during compilation,
    then the shader is returned.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final function is the `createProgram` function, which takes the `vertex`
    and `fragment` shaders:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This function takes the vertex and fragment shader files, reads them, and then
    compiles both files.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we create a new `shaderProgram` function by calling `glCreateProgram()` and
    assigned to program.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we have to attach both shaders to the program by calling `glAttachShader`
    and passing the program and the shader.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we link the program by calling `glLinkProgram`. After, we pass in the
    program and check for any linking errors.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there are any linking errors, we send out an error message to the console,
    along with a program log that will detail the linking error. If not, then the
    program is returned.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Light Renderer class
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, it''s time to draw our first object; to do so, perform the following steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: We will draw a basic light source that will appear above the current scene so
    that we can visualize the location of the light source in the scene. We will use
    this location of the light source later to calculate the lighting on our object.
    Note that a flat-shaded object doesn't need to have lighting calculations made
    on it.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, create a `LightRenderer.h` file and a `.cpp` file, and then create the
    `LightRenderer` class.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the `LightRenderer.h` file, include the following headers:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We will need `glew.h` to call the OpenGL commands, while we'll need the `glm`
    headers to define `vec3` and the matrices.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will also need `Mesh.h`, which allows us to define the shape of the light
    in the light source. You can use the `ShaderLoader` class to load in the shaders
    in order to render the object and `Camera.h` to get the camera's location, view,
    and projection matrices onto the scene.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will create the `LightRenderer` class next:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We will add the following `public` section to this class:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the public section, we create the constructor that we pass `MeshType` to;
    this will be used to set the shape of the object that we want to render. Then,
    we have the destructor. Here, we have a function called `draw`, which will be
    used to draw the mesh. Then, we have a couple of setters for setting the position,
    color, and shader program for the object.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After defining the public section, we set the `private` section, as follows:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the private section, we have a `private` variable so that we can store the
    camera locally. We create vectors to store the vertex and index data; we also
    create local variables to store the position and color information. Then, we have `GLuint`,
    which will store `vbo`, `ebo`, `vao`, and the program variable.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program variable will have the shader program that we want to use to draw
    the object. Then, we have `vbo`, which stands for vertex buffer object; `ebo`,
    which stands for Element Buffer Object; and `vao`, which stands for Vertex Array
    Object. Let''s examine each of these buffer objects and find out what they do:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '**Vertex Buffer Object** (**VBO**): This is the geometrical information; it
    includes attributes such as position, color, normal, and texture coordinates.
    These are stored on a per vertex basis on the GPU.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Element Buffer Object** (**EBO**): This is used to store the index of each
    vertex and will be used while drawing the mesh.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vertex Array Object** (**VAO**): This is a helper container object that stores
    all the VBOs and attributes. This is used as you may have more than one VBO per
    object, and it would be tedious to bind the VBOs all over again when you render
    each frame.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buffers are used to store information in the GPU memory for fast and efficient
    access to the data. Modern GPUs have a memory bandwidth of approximately 600 GB/s,
    which is enormous compared to the current high-end CPUs that only have approximately
    12 GB/s.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Buffer objects are used to store, retrieve, and move data. It is very easy to
    generate a buffer object in OpenGL. You can easily generate one by calling `glGenBuffers()`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'That is all for `LightRender.h`; now, let''s move on to `LightRenderer.cpp`,
    as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `LightRenderer.cpp`, include `LightRenderer.h`. Then, add the
    constructor, as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the `LightRenderer` constructor, we start adding the code. First, we initialize
    the local camera, as follows:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we set the shape of the object that we want to draw, depending on the
    `MeshType` type. For this, we will create a `switch` statement and call the appropriate
    `setData` function, depending on the type, as follows:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we will generate and bind the `vao` buffer object, as follows:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `glGenVertexArrays` function takes two parameters; the first parameter is
    the number of vertex array object names that we want to generate. In this case,
    we just want to create one, so it is specified as such. The second parameter takes
    in an array where the vertex array names are stored, so we pass in the `vao` buffer
    object.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The `glBindVertexArray` function is called `next`, and `vao` is passed into
    it in order to bind the `vao` buffer object. The `vao` buffer object will be bound
    for the duration of the application. A buffer is an object that's managing a certain
    piece of memory; buffers can be of different types and, therefore, they need to
    be bound to a specific buffer target so that they can give meaning to the buffer.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the `vao` buffer object has been bound, we can generate the vertex buffer
    object and store the vertex attributes.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To generate the vertex buffer object, we call `glGenBuffers()`; this also takes
    two parameters. The first parameter is the number of buffers that we want to generate,
    while the second is the array of VBOs. In this case, since we have one `vbo` buffer
    object, we will just pass in `1` for the first parameter and pass in the `vbo`
    as the second parameter:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we have to specify the buffer type. This is done by using the `glBindBuffer()` function;
    this takes two parameters again. The first is the buffer type and, in this case,
    it is of the `GL_ARRAY_BUFFER` type, while the second parameter is the name of
    the buffer object, which is `vbo`. Now, add the following line of code:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the next step, we actually pass in the data that we want to store in the
    buffer. This is done by calling `glBufferData`; the `glBufferData` function takes
    four parameters:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first parameter is the buffer type, which, in this case, is `GL_ARRAY_BUFFER`.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter is the size in bytes of the buffer data to store.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third parameter is the pointer to the data, which will be copied.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth parameter is the expected usage of the data being stored.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our case, we will just modify the data once and use it many times, so it
    will be called `GL_STATIC_DRAW`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `glBufferData` function for storing the data, as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, we have to set the vertex attributes that we are going to use. While creating
    the `struct` vertex, we have attributes such as position, color, normal, and texture
    coordinates; however, we may not need all of these attributes all of the time.
    Therefore, we only need to specify the ones that we need. In our case, since we
    are not using any lighting calculation or applying any textures to the object,
    we don't need to specify this – we will just need the position and color attributes
    for now. However, these attributes need to be enabled first.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable these attributes, we''ll call `glEnableVertexAttribArray` and pass
    in the index that we want to enable. The position will be in the 0th index, so
    we will set the value as follows:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we call `glVertexAttribPointer` so that we can set the attribute that
    we want to use. The first attribute will be positioned at the 0th index. This
    takes six parameters, as follows:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first parameter is the index of the vertex attribute, which, in this case,
    is 0.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter is the size of the attribute. Essentially, this is the
    number of components that the vertex attribute has. In this case, it is the position
    of the *x*, *y*, and *z* components, so it is specified as `3`.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third parameter is for the variable types of the components; since they
    are specified in `GLfloat`, we specify `GL_FLOAT`.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth parameter is a Boolean that specifies whether the values should be
    normalized or whether they should be converted into fixed-point values. Since
    we don't want the values to be normalized, we specify `GL_FALSE`.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The fifth parameter is called the stride, which is the offset of consecutive
    vertex attributes. Imagine the vertices being laid out in the memory as follows.
    The stride refers to the blocks of memory that you will have to go through to
    get to the next set of vertex attributes; this is the size of the `struct` vertex:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/351fcc48-0f0d-46fe-871f-6123bdb95baf.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: 'The sixth parameter is the offset of the first component of the vertex attribute
    within the `struct` vertex. The attribute that we are looking at here is the position
    attribute, which is at the start of the `struct` vertex, so we will pass `0`:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/19796af6-4a67-44f2-827d-5abf7621efe9.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
- en: 'Set the `glVertexAttribute` pointer, as follows:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s create one more attribute pointer so that we can color the object. Like
    we did previously, we need to enable the attribute and set the `attrib` pointer,
    as follows:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Since the next attribute index is `1`, we enable the attribute array using `1`.
    While setting the attribute pointer, the first parameter is `1`, since this is
    the first index. `color` has three components – *r*, *g*, and *b –* so the next
    parameter is `3`. Colors are defined as floats, and so we specify `GL_FLOAT` for
    this parameter.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we don't want the fourth parameter to be normalized, we set the parameter
    to `GL_FALSE`. The fifth parameter is the stride and it is still equal to the
    size of the `struct` vertex. Finally, for the offset, we use the `offsetof` function
    to set the offset of `vertex::color` in the `struct` vertex.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we have to set the element buffer object. This is done in the same way
    as setting the vertex buffer object: we need to generate the element, set the
    binding, and then bind the data to the buffer, as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we generate the buffer by calling `glGenBuffers`. This is done by passing
    in the number of buffers that we want to create, which is `1`, and then passing
    in the name of the buffer object to generate it:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Next, we bind the buffer type to the buffer object, which, in this case, is
    `GL_ELEMENT_ARRAY_BUFFER`. It will store the element or index data.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we set the index data itself by calling `glBufferData`. We pass in the
    buffer type first, set the size of the element data, and then pass in the data
    and the usage with `GL_STATIC_DRAW`, like we did previously.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the end of the constructor, we unbind the buffer and the vertex array as
    a precaution:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we will create the `draw` function; this will be used to draw the object
    itself. To do this, add the `draw` function, as follows:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We will use this function to add the code for drawing the object. The first
    thing we will do is create a `glm::mat4` function called `model` and initialize
    it; then, we will use the `glm::translate` function to translate the object to
    the required position:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Next, we will set the model, view, and projection matrices to transform the
    object from its local space. This was covered in [Chapter 2](ee788533-687d-4231-91a4-cb1de9ca01dd.xhtml),
    *Mathematics and Graphics Concepts,* so now is a good time for you to go and refresh
    your memory of graphics concepts.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'The model, view, and projection matrices are set in the vertex shader. Information
    is sent to the shader by calling `glUseProgram`, which takes in a shader program:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, we can send the required information through the uniform variables. We
    will create a uniform data type in the shader using a name. In the `draw` function,
    we need to get the location of this uniform variable by calling `glGetUniformLocation`,
    and then passing in the program and the variable string in the shader that we
    set, as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This will return a `GLuint` value with the location of the variable, which is
    the model matrix here.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can set the value of the model matrix using the `glUniform` function.
    Since we are setting a matrix uniform, we use the `glUniformMatrix3fv` function;
    this takes four parameters. The first parameter is the location that we obtained
    in the previous step, whereas the second parameter is the amount of data that
    we are passing in; in this case, we are just passing in one matrix, so we specify
    this as `1`. The third parameter is a Boolean value, which specifies whether the
    data needs to be transposed. We don't want the matrix to be transposed, so we
    specify it as `GL_FALSE`. The final parameter is the pointer to the data, `gl::ptr_value`;
    we pass this into the model matrix.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the function to set the model matrix, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Similar to the model matrix, we have to pass in the view and projection matrices
    to the shader as well. To do this, we get the view and projection matrices from
    the `camera` class. Then, we get the location of the uniform variable that we
    defined in the shader and set the value of the view and projection matrices using
    the `glUniformMatrix4fv` function:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Once we have all the required data to draw the object, we can finally draw the
    object. At this point, we call `glBindVertexArray`, bind the `vao` buffer object,
    and then call the `glDrawElements` function to draw the object.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: The `glDrawElements` function takes four parameters. The first parameter is
    the mode that we can use to draw the lines by calling `GL_LINES`. Alternatively,
    we can draw triangles by using `GL_TRIANGLES`. There are, in fact, many more types
    of modes that can be specified, but in our case, we will only specify `GL_TRIANGLES`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter is the number of elements or the number of indices that
    need to be drawn. This is specified when we created the object. The third parameter
    is the type of index data that we will be passing, which is of the `GL_UNSIGNED_INT` type.
    The final parameter is the location where the indices are stored – this is set
    to 0.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following lines of code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For safety purposes, we will unbind the vertex array and the program variable
    by setting their values to `0`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This marks the end of the `draw` function.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the destructor and the rest of the setters and getters to finish the class,
    as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Drawing the object
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go back to the `source.cpp` file and render `LightRenderer`, as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the file, include `ShaderLoader.h`, `Camera.h`, and `LightRenderer.h`,
    and then create an instance of the `Camera` and `LightRenderer` classes called
    `camera` and `light`, as follows:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Create a new function called `initGame` and add the prototype for it to the
    top of the file. In the `gameInit` function, load the shader and initialize the
    camera and light.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the new function, as follows:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The first thing we do is enable depth testing so that only the pixels in the
    front are drawn. This is done by calling the `glEnable()` function and passing
    in the `GL_DEPTH_TEST` variable; this will enable the following depth test:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we will create a new instance of `ShaderLoader` called `shader` in the
    `init` function. Then, we need to call the `createProgram` function and pass in
    the vertex and fragment shader files to shade in the light source. The program
    will return a `GLuint` value, which we store in a variable called `flatShaderProgram`,
    as follows:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The vertex and shader files are located in the `Assets` folder under `Shaders`;
    the `FlatModel.vs` file will look as follows:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`#version` specifies the version of GLSL that we are using, which is `450`.
    This stands for OpenGL version 4.50\. Next, `layout (location = 0)` and `layout
    (location = 1)` specify the location of the vertex attributes that are passed
    in; in this case, this is the position and color. The `0` and `1` indices correspond
    to the index numbers while setting `vertexAttribPointer`. In the variables that
    are specified, this data is placed in the shader and stored in shader-specific `vec3`
    data types called `Position` and `Color`.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: The three uniforms that we sent from the `draw` call for storing the model,
    view, and projection matrices are stored in a variable type called `uniform` and
    a `mat4` store data type, both of which are matrices. After this, we create another
    variable of the `out` type, which specifies that this will be sent out of the
    vertex shader; this is of the `vec3` type and is called `outColor`. Next, all
    the actual work is done inside the `main` function. For this, we transform the
    local coordinate system by multiplying the position by the model, view, and projection
    matrices. The result is stored in a GLSL intrinsic variable called `gl_Position`—this
    is the final position of the object. Then, we store the `Color` attribute in the
    `out vec3` variable that we created called `outColor`—that's it for the vertex
    shader!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s take a look at the fragment shader''s `FlatModel.fs` file:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the fragment shader file, we also specify the version of GLSL that we are
    using.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Next, we specify an `in vec3` variable called `outColor`, which will be the
    color that was sent out of the vertex shader. This can be used in the fragment
    shader. We also create an `out vec4` variable called `color`, which will be sent
    out of the fragment shader and will be used to color the object. The color that's
    being sent out of the fragment shader is expected to be a `vec4` variable. Then,
    in the main function, we convert `outColor` from a `vec3` variable into a `vec4` variable,
    and then set it to the `color` variable.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: In the shaders, we can convert a `vec3` variable into a `vec4` variable by simply
    performing the following operation. This may look a bit strange, but for the sake
    of convenience, this unique feature is available in shader programming to make
    our lives a little easier.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to the `source.cpp` file, when we pass in the vertex and fragment
    shader files, they will create `flatShaderProgram`. Next, in the `initGame` function,
    we create and initialize the camera, as follows:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, we create a new camera with an FOV of `45`, a width and height of `800`
    x `600`, a near and far plane of `0.1f` and `100.0f`, as well as a position of
    `0` along the *X*-axis, `4.0` along the Y-axis, and `6.0` along the Z-axis.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create `light`, as follows:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is done with the shape of a triangle, which is then passed to the camera.
    Then, we set the shader to `flatShaderProgram` and set the position to the center
    of the world.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we call the `draw` function of the light in the `renderScene()` function,
    as follows:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'I changed the clear screen color to yellow so that the triangle can be seen
    clearly. Next, call the `initGame` function in the `main` function, as follows:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Delete the camera and light at the end so that the system resource is released.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, run the project to see the glorious triangle that we set as the shape
    of the light source:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7deb66c1-2c3c-4ca6-b00c-931c519ebb61.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
- en: 'Change the `MeshType` type to cube to see a cube being drawn instead:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5dae76b6-4eac-495b-a865-a2d452a444b9.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
- en: If you get an error instead of the colored object as output, then this could
    either mean that you have done something incorrectly or that your drivers haven't
    been updated and that your GPU doesn't support OpenGL 4.5.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure GLFW supports the version of your driver, add the following code,
    which checks for any GLFW errors. Then, run the project and look at the console
    output for any errors:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If you get the following output, then this could mean that the OpenGL version
    you''re using is not supported:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a6a8556-ab34-460b-b184-429841ce741b.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
- en: 'This will be accompanied by the following error, suggesting that the GLSL version
    you''re using is not supported:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/845bccb8-4844-4fee-a27e-fb487739520e.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
- en: In this case, change the version of the shader code at the top of the shader
    to `330` instead of `450`, and then try running the project again.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: This should give you the desired output.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created a new OpenGL project and added the necessary libraries
    to get the project working. Then, we created a new window to work with using GLFW.
    After using a couple more lines of code, we were able to clear the viewport with
    the color of our choice.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Next, we started preparing some classes that could help us draw objects such
    as the `Mesh` class, which defined the shape of the object, and the `Camera` class,
    which we use in order to view the object. Then, we created a `ShaderLoader` class,
    which helped us create the shader program that is used to draw the object.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: With the necessary preparation done, we created a `LightRenderer` class. This
    is used to draw an object that represents a light position that's defined by a
    shape. We used this class to draw our first object.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore how to draw other objects by adding textures
    and physics to the rendering engine.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何通过向渲染引擎添加纹理和物理效果来绘制其他对象。
