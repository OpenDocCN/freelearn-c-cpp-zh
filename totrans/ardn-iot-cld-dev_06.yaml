- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Project #3 – a Remote Asset Tracking Application with LoRaWAN'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is dedicated to **smart transportation** and **smart remote monitoring**
    using low-power and long-range communication technology. The project in this chapter
    will take you through the implementation and deployment of a remote alarming application
    based on **Long Range Wide Area Network** (**LoRaWAN**), connected to the public,
    global, and decentralized The Things Network. The project in this chapter provides
    localization features by using a GPS module. The **Arduino IoT Cloud** will be
    used for data visualization and remote configuration of the device. The application
    will be used in real use cases, showing the benefits offered by LoRaWAN technologies
    compared to other wireless technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will practically explore LoRaWAN technologies, which are very useful
    in remote monitoring and control, whether it’s **asset tracking** or **remote
    operation monitoring**. This project uses the **Arduino MKR WAN 1300** development
    board, which is equipped with the latest communication frequencies, 433/868/915
    MHz US/EU. It is specially designed for **Internet of Things** (**IoT**) and **Industry
    4.0** use cases. This project explains how you can practically develop a tracking
    solution based on LoRaWAN communication for different use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding LoRaWAN and its IoT applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LoRaWAN versus other communication technologies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components of a LoRaWAN IoT application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Essential hardware – sensors and development boards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing the project architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the Thing, adding devices, cloud variables, and code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the The Things Indoor Gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating web and mobile dashboards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following hardware components are required to complete the exercise in
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: MKR WAN 1300 or MKR WAN 1310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Things Indoor Gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The NEO-6M u-blox GPS module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumper cables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To code, we will use the **Arduino Web Editor**, which includes a large collection
    of development boards and sensor libraries, and the Arduino IoT Cloud for the
    Thing and dashboard setup. To develop hardware and sensor designs, we need the
    **Fritzing** desktop software, and we need the **Arduino IDE** for GPS module
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will use the **The Things Indoor Gateway** for LoRaWAN
    communication. The code used in the chapter is available in the book’s official
    GitHub repository by following this link: [https://github.com/PacktPublishing/Arduino-IoT-Cloud-for-Developers](https://github.com/PacktPublishing/Arduino-IoT-Cloud-for-Developers).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding LoRaWAN and its IoT applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LoRaWAN is a wireless communication protocol and network architecture specifically
    designed for **Low-Power Wide Area Networks** (**LPWANs**), enabling long-range
    communication between devices in the context of the IoT. LoRaWAN technology is
    optimized for applications that require low data rates, long battery life, and
    long communication ranges, making it well-suited for various IoT use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Usage in IoT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'LoRaWAN has been widely adopted in various IoT applications due to its unique
    features. Some common use cases include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Smart agriculture**: LoRaWAN can be used for soil moisture monitoring, crop
    health monitoring, livestock tracking, and precision farming, allowing farmers
    to optimize their operations and increase yield'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Smart cities**: LoRaWAN can enable smart street lighting, waste management,
    parking management, and environmental monitoring, helping cities become more efficient
    and sustainable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Industrial monitoring**: LoRaWAN can monitor equipment health, track assets,
    and improve supply chain management in industrial settings, leading to better
    maintenance practices and reduced downtime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utilities**: LoRaWAN can be used for smart meters and to remotely monitor
    utility infrastructure, such as water and gas meters, improving billing accuracy
    and resource management'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Environmental monitoring**: LoRaWAN can support applications such as air
    quality monitoring, water quality monitoring, and wildlife tracking, helping researchers
    and organizations gather valuable environmental data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asset tracking**: LoRaWAN enables real-time tracking of assets, such as shipping
    containers, vehicles, and valuable equipment, ensuring their security and efficient
    utilization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, LoRaWAN’s combination of long communication ranges, low power consumption,
    and scalability makes it a powerful technology to build IoT networks that cover
    large areas and connect a wide range of devices for various applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have discussed the different use cases of LoRaWAN in the
    field of IoT, and in the next section, we will discuss why to choose LoRaWAN over
    other communication technologies.
  prefs: []
  type: TYPE_NORMAL
- en: LoRaWAN versus other communication technologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'LoRaWAN offers several advantages over other communication technologies, making
    it a preferred choice for certain IoT applications. Here are some reasons why
    LoRaWAN might be chosen over other alternatives:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Long range**: LoRaWAN provides exceptional long-range communication capabilities,
    enabling devices to communicate over several kilometers in open areas. This is
    particularly useful for applications that require connectivity over large distances,
    such as agriculture, environmental monitoring, and asset tracking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Low power consumption**: Devices using LoRaWAN can operate on very low power,
    extending battery life for years. This is crucial for remote or hard-to-reach
    locations where changing or recharging batteries is impractical or costly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deep indoor penetration**: LoRaWAN can penetrate buildings and other obstacles
    effectively, ensuring connectivity even in challenging environments. This makes
    it suitable for applications such as smart building management and indoor asset
    tracking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cost-effective**: Implementing and maintaining a LoRaWAN network is often
    more cost-effective than deploying traditional cellular networks. This makes LoRaWAN
    a viable option for businesses and organizations looking to deploy IoT solutions
    on a larger scale.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: LoRaWAN networks can handle a massive number of devices within
    a single network. This scalability is essential for IoT applications that involve
    a high density of devices, such as smart city deployments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Low data rate applications**: LoRaWAN is optimized for applications that
    transmit small amounts of data at low data rates. For IoT use cases involving
    sensor data, meter readings, and periodic updates, LoRaWAN provides a suitable
    and efficient communication solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network flexibility**: LoRaWAN supports both public and private network deployments.
    Organizations can choose to set up their own private LoRaWAN network or use existing
    public networks, giving them flexibility in terms of ownership and control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adaptive data rate**: LoRaWAN devices can adjust their data rate based on
    signal strength and interference, optimizing communication for the current conditions.
    This adaptive feature enhances reliability and ensures the efficient use of available
    resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Global standard**: LoRaWAN is a global standard, and devices designed to
    work with it can operate seamlessly across different regions and countries. This
    standardization simplifies device development and deployment for international
    projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Diverse applications**: LoRaWAN’s versatility enables its use in various
    application domains, from agriculture and industrial monitoring to smart cities
    and environmental sensing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While LoRaWAN offers these advantages, it’s important to note that no single
    communication technology is universally superior. The choice between LoRaWAN and
    other technologies (such as cellular, Wi-Fi, Bluetooth, or Zigbee) depends on
    the specific requirements of the IoT application, including factors such as range,
    power consumption, data rate, cost, and scalability. Each technology has its strengths
    and weaknesses, and the selection should be based on a careful analysis of a project’s
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have discussed the benefits of using LoRaWAN. In the next
    section, we will explore the important components of LoRaWAN.
  prefs: []
  type: TYPE_NORMAL
- en: Components of a LoRaWAN IoT application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LoRaWAN is a wireless communication protocol and network architecture designed
    to enable long-range, low-power communication between IoT devices. It’s specifically
    tailored to connect devices that require extended battery life, reliable long-distance
    communication, and efficient use of the wireless spectrum. LoRaWAN is one of the
    key technologies in the realm of LPWANs. *Figure 6**.1* illustrates the whole
    architecture of the LoRaWAN solution, including the end nodes, gateway, network
    server, and application server.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – The components of a LoRaWAN network](img/B19752_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – The components of a LoRaWAN network
  prefs: []
  type: TYPE_NORMAL
- en: 'The LoRaWAN architecture consists of four main components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**End nodes/devices**: These are the IoT devices that gather data from sensors
    or perform specific tasks. They communicate with gateways using the LoRa modulation
    technique, sending data packets at low data rates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gateways**: Gateways serve as intermediate points that receive data packets
    from end devices and transmit them to a centralized network server. They are typically
    connected to the internet via wired or wireless connections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network server**: The network server manages communication between gateways
    and end devices. It handles functions such as authentication, encryption, and
    the routing of data packets to their respective application servers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application server**: The application server is responsible for processing
    data received from the network server and performing specific actions based on
    the data. It interfaces with an end user’s application or backend system to present
    data, trigger alerts, perform analytics, or control devices. The application server
    can be hosted on the cloud or on-premises.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we have discussed LoRaWAN components in detail, and in the
    next section, we are going to explore the hardware and sensors that are required
    to execute the practical exercise of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Essential hardware – sensors and development boards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Arduino series has a wide collection of development boards that vary in
    size, pins, and communication technologies. In this chapter, we will use the Arduino
    MKR WAN 1300 development board, as it’s compact, battery-enabled, and provides
    support for different frequencies from different regions around the world, including
    433/868/915 MHz. *Figure 6**.2* shows a pinout diagram of the MKR WAN 1300.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Arduino MKR WAN 1300](img/B19752_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Arduino MKR WAN 1300
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino MKR WAN 1300 provides seven analog pins, which start with **A**
    (**A0**, **A1**, and so on), and eight digital input/output pins, which start
    with **D** (**D0**, **D1**, and so on), with built-in battery charging and a **lithium
    polymer** (**LiPo**) battery connector for standby power, which helps developers
    build prototypes and solutions for remote monitoring/operations without worrying
    about power backups. For further updates and the latest product development news,
    please visit the official website at [https://store.arduino.cc/products/arduino-mkr-wan-1300-lora-connectivity](https://store.arduino.cc/products/arduino-mkr-wan-1300-lora-connectivity).
  prefs: []
  type: TYPE_NORMAL
- en: Arduino’s latest development board is the MKR WAN 1310, which contains the same
    processor and module for LoRa communication as the MKR WAN 1300\. However, the
    MKR WAN 1310 has an updated in-battery charger, 2 MB of **Serial Peripheral Interface**
    (**SPI**) flash, and enhanced power consumption. This board is specially designed
    for IoT devices and is quickly growing in popularity in different regions. For
    its complete details and specifications, visit [https://store.arduino.cc/products/arduino-mkr-wan-1310](https://store.arduino.cc/products/arduino-mkr-wan-1310).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will track the device via GPS coordinates. To get the GPS
    coordinates, we will use the GY-GPS6MV2 GPS module, which is based on the NEO-6M
    u-blox chip. The GPS module operates on both a software serial and a hardware
    serial, but the MKR WAN 1300 provides a built-in hardware serial, so we will use
    *ins 13* and *14* to communicate with the GPS module shown in *Figure 6**.3*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GPS module provides latitude, longitude, satellite count, altitude feet,
    and speed-per-mile properties. These properties will be displayed on a dashboard
    for proper asset tracking. This module was developed in China and is available
    at affordable prices, but many other organizations are developing GPS modules
    that are also based on the NEO-6M u-blox chip, such as SparkFun, Seeed Studio,
    and Adafruit. *Figure 6**.3* shows a NEO-6M u-blox GPS module and its pinout diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – The GY-GPS6MV2 NEO6MV2 GPS module and a pinout diagram](img/B19752_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – The GY-GPS6MV2 NEO6MV2 GPS module and a pinout diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding diagram describes the pinout layout of the GPS module. *Pin #1*
    is the **GND** pin that connects with the onboard GND pin of the MKR WAN 1300\.
    *Pin #2* and *Pin #3* are **TX** and **RX**, respectively, and will connect to
    *Pin #13* and *Pin #14* of the MKR WAN 1300, respectively. *Pin #4*, **VCC**,
    works with both an onboard VCC and the 5V pins of the MKR WAN 1300\. You can solder
    the male headers with the GPS module or directly solder the cables without any
    header pins.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The GPS module works best in an outdoor environment. Make sure there are no
    rooftops above during testing and deployment to properly receive a signal from
    satellites.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using the module in the lab, then there will be a chance that the
    GPS module will not work properly. Remember that there is a built-in light on
    the GPS module that starts blinking when you receive signals from satellites.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have discussed the development board and GPS module in detail,
    including their pinout diagrams. In the next section, we will start exploring
    how to connect the GPS module with the MKR WAN 1300.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the project architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding sections, we discussed the module and development board in
    detail. Now, it’s time to cook the recipe. In hardware development, before getting
    to work with sensors and development boards, we need to develop the design concepts
    to get a better understanding of how things will connect. There is a lot of software
    that is available to design and develop design concepts for an electronics project,
    but in this case, we will use Fritzing.
  prefs: []
  type: TYPE_NORMAL
- en: In the following two subsections, we will talk about schematics and designing
    a project, while explaining how to connect pins with a development board and soldering.
    Then, we will do some tests to fetch GPS coordinates, which is very important
    before sending data to the Arduino IoT Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Schematics design and assembly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The purpose of your schematic design is to get a clear understanding of how
    sensors will connect with a development board. This helps engineers develop a
    prototype on a breadboard or Veroboard, as shown in *Figure 6**.4*. Another major
    benefit of designing is that Fritzing builds hardware schematics and PCB design
    in the background according to your design, which can be adjusted according to
    system requirements. *Figure 6**.4* shows a schematic diagram of how to connect
    the MKR WAN 1300 with the NEO-6M u-blox GPS module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – The MKR WAN 1300 and GPS module schematic](img/B19752_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – The MKR WAN 1300 and GPS module schematic
  prefs: []
  type: TYPE_NORMAL
- en: While *Figure 6**.4* illustrates the design of the MKR WAN 1300 and GPS module,
    we have created *Table 6.1* for easier understanding, which illustrates (in row
    format) how to connect pins.
  prefs: []
  type: TYPE_NORMAL
- en: '| **MKR** **WAN 1300** | **NEO-6M u-blox** **GPS module** |'
  prefs: []
  type: TYPE_TB
- en: '| 14 (TX) | RX |'
  prefs: []
  type: TYPE_TB
- en: '| 13 (RX) | TX |'
  prefs: []
  type: TYPE_TB
- en: '| VCC | VCC |'
  prefs: []
  type: TYPE_TB
- en: '| GND | GND |'
  prefs: []
  type: TYPE_TB
- en: Table 6.1 – MKR WAN 1300 to GPS module pinout
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding design provides a full overview of how you can connect a module
    to a development board. According to our design, we have 5V and GND pins going
    from the development board to the GPS module. The GPS module **TX** pin is connected
    to the **RX** pin (*Pin #13*), and the GPS module **RX** pin is connected to the
    **TX** pin (*Pin #14*) of the development board. Finally, we built our prototype
    by using a breadboard, which is shown in *Figure 6**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – The final prototype MKR WAN 1300 and GPS module](img/B19752_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – The final prototype MKR WAN 1300 and GPS module
  prefs: []
  type: TYPE_NORMAL
- en: After soldering the male headers to the GPS module, connect the pins according
    to the schematic diagram. There is only one sensor, so there is no requirement
    for the Veroboard. Next, we will test the GPS module using Arduino’s **Serial
    Monitor** tool to verify that our GPS module works properly and gets values from
    GPS satellites.
  prefs: []
  type: TYPE_NORMAL
- en: Testing GPS module data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before moving toward the Arduino IoT Cloud, firstly, we need to verify that
    our GPS module is working. So, in this section, we will test the GPS module by
    using the Arduino IDE and its Serial Monitor tool to observe the readings from
    the GPS module. The following steps will guide you on how we will set up the testing
    environment:'
  prefs: []
  type: TYPE_NORMAL
- en: For module testing, we need the Serial Monitor tool to verify whether the GPS
    module works properly or not. Click on the **Tools** menu and select **Serial
    Monitor**. Select the Arduino MKR WAN 1300 board from **Tools** | **Board** |
    **Arduino SAMD** | **Arduino MKR WAN 1300** in the Arduino IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the port of the MKR WAN 1300.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to install the library for the GPS module in the Arduino IDE.
    Navigate to `tinygps` into the search bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.6 – The TinyGPSPlus library](img/B19752_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – The TinyGPSPlus library
  prefs: []
  type: TYPE_NORMAL
- en: After searching, the Library Manager brings up a lot of libraries. Select the
    **TinyGPSPlus** library and install its latest version. The library comes with
    a lot of examples, and all of them are based on a software serial. However, Arduino
    SAMD boards provide a hardware serial. Therefore, I’ve modified the code to use
    a hardware serial to communicate with the GPS module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Download the code from the book’s official GitHub repository, and under the
    `chapter#6` folder, open the `MKR-WAN-1300-NEO-6M-GPS-Module` ZIP folder, extract
    it, and upload the code to the development board:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the setup, we have initialized `Serial` and `Serial1`. `Serial` is used to
    display the content to the Serial Monitor (the magnifier icon in the top right
    of the Arduino IDE) on screen, while `Serial1` is the hardware serial that is
    used to communicate with the GPS module. The preceding code belongs to the `loop()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: First, the GPS module will read data from satellites using the `Serial1.read()`
    method and encode it via the `gps.encode()` method. `Serial1` only reads one character
    at a time, so it will take a little bit of time for the updated values. Then,
    we will verify whether there is any update in `Latitude` and `Longitude` coordinates
    by using the `gps.location.isUpdated()` method. If there is a change, then the
    data will be printed on the Serial Monitor.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure your GPS module is placed in an open environment where you have a
    clear sky, without any obstruction such as a roof or anything that stops you from
    receiving proper signals from satellites.
  prefs: []
  type: TYPE_NORMAL
- en: The GPS module has an onboard built-in LED that starts blinking when it starts
    receiving data from GPS satellites.
  prefs: []
  type: TYPE_NORMAL
- en: The same code will work with the MKR WAN 1310 without any modification.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6**.7* shows the Serial Monitor with values from the GPS, which includes
    `Latitude`, `Longitude`, and other parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – The GPS module data on the Serial Monitor](img/B19752_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – The GPS module data on the Serial Monitor
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure shows the data that is received by the GPS module from
    GPS satellites and printed on the Serial Monitor. The data includes the satellite
    count, the latitude and longitude that represent the location coordinates, the
    speed in MPH based on current and previous GPS coordinates, and the altitude in
    feet.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we tested the NEO-6M u-blox GPS module in the Arduino IDE.
    First, we installed the `TinyGPSPlus` library for the module, and later, we used
    the aforementioned code for the development board, which shows the readings on
    the Serial Monitor. In the next section, we will start with the Thing setup in
    the Arduino IoT Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Thing, device association, cloud variables, and code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After setting up the hardware, it’s time to set up the Thing in the Arduino
    IoT Cloud. For this project, we need four cloud variables to fetch different properties
    from the device. The device association settings will be different due to the
    LoRa series board. Also, network configuration will happen automatically when
    we upload the code/sketch to the MKR WAN 1300\. *Figure 6**.8* shows a complete
    overview of the Thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Remote asset tracking using the LoRaWAN Thing setup](img/B19752_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – Remote asset tracking using the LoRaWAN Thing setup
  prefs: []
  type: TYPE_NORMAL
- en: Set up a new Thing with the name **A remote asset tracking using LoRaWAN**,
    and then follow the next steps, which will take you to the next subsections to
    create variables, an associate device network configuration, and finally, code.
    We have marked the preceding figure with red boxes and numbers according to the
    following steps.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we need to set up four cloud variables – `Location`, `AltitudeFeet`,
    `SatelliteCount`, and `Speed`. The complete details regarding cloud variables
    are available in the following subsection.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we need to associate the device with the Thing. In the current project,
    we will use the MKR WAN 1300, so the process will be the same as the one used
    for Arduino boards, but here, we will see some different options due to LoRaWAN.
    The complete details are available in the *Associating a* *device* section.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following table explains all the properties of the variables that we need
    to create. For the location, we need two different variables to store the latitude
    and longitude, but thanks to the Arduino IoT Cloud extended group of variables,
    we have a `Location`-type variable. Then, make sure each variable matches the
    declaration in the table; otherwise, you will need to modify the example code
    according to your naming.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Table 6.2*, when creating the cloud variables, we set the permission
    to **Read-Only**. Although we have the *Read*/*Write* option, in this project,
    we only want to receive data from the device instead of modifying the data via
    the dashboard. That’s why **read-only** mode is used – to avoid issues in data
    consistency. **Update policy** is set to **On Change**, as the device will send
    the data when the GPS module receives new data from satellites.
  prefs: []
  type: TYPE_NORMAL
- en: '| **S#** | **Variable name** | **Variable type** | **Declaration** | **Permission**
    | **Update** **policy** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | `AltitudeFeet` | `Float` | `altitudeFeet` | Read-Only | On Change |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | `Location` | `CloudLocation` | `location` | Read-Only | On Change |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | `SatelliteCount` | `Int` | `satelliteCount` | Read-Only | On Change |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | `Speed` | `Float` | `speed` | Read-Only | On Change |'
  prefs: []
  type: TYPE_TB
- en: Table 6.2 – The cloud variables list for the Thing
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed what type of cloud variables are required for
    this project. Here, we listed four cloud variables of different types but in **read-only**
    mode, as we only want to extract the values from the device. In the next subsection,
    we will associate the MKR WAN 1300 with the Thing.
  prefs: []
  type: TYPE_NORMAL
- en: Associating a device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After creating the variables, it’s time to add the device and associate it
    with the Thing:'
  prefs: []
  type: TYPE_NORMAL
- en: Before adding the device, connect the development board to the computer and
    open the **Arduino Create Agent** application. *Figure 6**.9* shows a popup in
    which we have options to either select the existing device for association or
    set up a new device that is not available on the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Associate device – selecting a device](img/B19752_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – Associate device – selecting a device
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we already have different devices in the portal, but we want to
    add a new one, MKR WAN 1300, so just click on **SET UP NEW DEVICE** to configure
    the new device in the account.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you will see three options in the popup. The first option is **Arduino
    board**, the second option is **Third party device**, and the third option is
    **Any Device**, which is for non-compatible devices. This means you can now use
    all types of Arduino devices as well as third-party devices with the Arduino IoT
    Cloud, which supports Python, MicroPython, and JavaScript.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Choosing a development device](img/B19752_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – Choosing a development device
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Arduino board** (marked with a red box in *Figure 6**.10*) and the
    next step will automatically detect the MKR WAN 1300 board, which we are using
    in this chapter. Before adding the device, make sure that **Arduino Create Agent**
    is running on your machine. *Figure 6**.11* shows that the Arduino IoT Cloud detected
    the MKR WAN 1300.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.11 – The device found](img/B19752_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – The device found
  prefs: []
  type: TYPE_NORMAL
- en: When the popup finds the device, click on the **CONFIGURE** button, which will
    take you to the next screen.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6**.12* shows a screen that provides some details about the **The Things
    Stack** portal link. You will also see a message saying that you need an active
    LoRaWAN gateway for the MKR WAN 1300 to communicate with the Arduino IoT Cloud.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.12 – The active LoRaWAN gateway](img/B19752_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – The active LoRaWAN gateway
  prefs: []
  type: TYPE_NORMAL
- en: If you already have the gateway set up, then that’s fine; otherwise, in the
    *Configuring the The Things Indoor Gateway* section, read up on how to set up
    the The Things Indoor Gateway, which will provide connectivity to your MKR WAN
    1300 development board.
  prefs: []
  type: TYPE_NORMAL
- en: This message also informs you that the Arduino IoT Cloud will automatically
    configure your device in the The Things Stack portal.
  prefs: []
  type: TYPE_NORMAL
- en: After associating the device, you will receive an email with a username and
    password, as well as a URL for the The Things Stack portal login, which contains
    all the information about LoRaWAN nodes. Here, the Arduino IoT Cloud will automatically
    add the MKR WAN 1300 to the The Things Stack portal after the final steps. Next,
    *Figure 6**.13* shows that we need to select a frequency for our device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.13 – The MKR WAN 1300 frequency selection](img/B19752_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.13 – The MKR WAN 1300 frequency selection
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed earlier, LoRaWAN operates on different frequencies according
    to region. So, from the dropdown, select the specific frequency according to your
    region. I selected **Europe 863-870 MHZ (SF9 for RX2 - recommended)** according
    to my LoRaWAN gateway. After selecting the frequency from the dropdown, click
    on the **NEXT** button.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to provide a name for the device, as shown in *Figure 6**.14*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.14 – Assigning a name to the MKR WAN 1300](img/B19752_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.14 – Assigning a name to the MKR WAN 1300
  prefs: []
  type: TYPE_NORMAL
- en: Here, I assigned the name `LoRaWanGPSTracker` to the device, but you can use
    any name related to your project structure. After assigning the name, click on
    the **NEXT** button.
  prefs: []
  type: TYPE_NORMAL
- en: Then, another popup will appear, as shown in *Figure 6**.15*, which will prepare
    your device for the Arduino IoT Cloud.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.15 – MKR WAN 1300 configuration](img/B19752_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.15 – MKR WAN 1300 configuration
  prefs: []
  type: TYPE_NORMAL
- en: Here, the Arduino IoT Cloud configures the MKR WAN 1300 via **Arduino Create
    Agent**. It will take one to two minutes to set up the development board with
    the necessary configuration.
  prefs: []
  type: TYPE_NORMAL
- en: When the device has been configured successfully, you will see the following
    popup. Just click on the **DONE** button and your device will be associated with
    your Thing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.16 – A successful device setup](img/B19752_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.16 – A successful device setup
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have associated the MKR WAN 1300 with our Thing. We have
    also seen a lot of new options regarding LoRaWAN such as frequency, gateway, and
    so on. In the upcoming sections, we will discuss the network and code.
  prefs: []
  type: TYPE_NORMAL
- en: Network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In previous chapters, after associating the device with the Thing, we configured
    the network settings for device communication. However, this time, we don’t need
    to configure any network settings, as the device will be configured automatically
    when we upload the sketch to the MKR WAN 1300 development board. At first, you
    will see an empty area in the **Network** configuration, as shown in *Figure 6**.8*,
    but after the sketch uploads, you will see the LoRaWAN network configuration parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Coding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code for this chapter is available in the book’s official GitHub repository.
    Download the `A_remote_asset_tracking_using_LoRaWAN_aug30a.zip` file and import
    it into your Arduino Web Editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the code and put it into your Thing by navigating to the `setup()`
    method. Remember to never try to use the `delay()` method, as it will block the
    `ArduinoCloud.update()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we declare the `gps` instance and two variables,
    which wait for `30000` milliseconds (30 seconds) before the next readings are
    taken without blocking the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will explore the `loop()` method. Here, we call the `FetchGPS()` method
    every 30 minutes, which will be carried out by comparing `currentMillis` and `previousMillis`
    without the use of `delay()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following snippet, I have just picked a small part of the code from
    the `FetchGPS()` method. Here, I assign the latest values from the GPS module
    to the Arduino cloud variables, which will be used to send data to the cloud as
    well as print it on the Serial Monitor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Upload the code to the device, and open up the Arduino Web Editor Serial Monitor
    to verify the values. After successfully uploading the data to the cloud, it’s
    time to set up a beautiful dashboard for web and mobile for end users.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you used different *naming* when declaring the variables, update the code
    according to your naming scheme. However, it’s recommended to first follow all
    the steps in the book and change the cloud variable names later, modifying your
    code respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Never try to use the `delay()` method, which will create a block for the `ArduinoCloud.update()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino IoT Cloud only updates values on its dashboard whenever the variable
    value changes. For example, if the GPS location is the same after some time, then
    it means an asset has not moved from its original location. Then, the Arduino
    IoT Cloud will not record the value, so don’t get confused if values don’t change
    on the map. Another benefit of this feature is you will not get duplicate data
    when you export the content.
  prefs: []
  type: TYPE_NORMAL
- en: The same code will work with the MKR WAN 1310 without any modification. However,
    in this instance, you need to associate the MKR WAN 1310 device with the Thing
    instead of the MKR WAN 1300.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have explored our code step by step to understand how it
    works. In the next section, we will set up the The Things Indoor Gateway. If you
    already have the gateway in your region/area, then you can skip this, but if you
    don’t have any gateway near your location, then you need to set up the gateway;
    otherwise, your MKR WAN 1300 will not be able to communicate with the Arduino
    IoT Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the The Things Indoor Gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will set up the The Things Indoor Gateway. It is available
    in different frequencies but I have a gateway with the EU868 MHz frequency. If
    you already have the LoRaWAN gateway in your area and want to skip this section,
    you’re good to go, but if you don’t have the gateway in your area, then this section
    is mandatory for MKR WAN 1300 communication. Without the gateway, your module
    will not communicate with the Arduino IoT Cloud. To set up the gateway, please
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your gateway box, set it up with a power cable, and turn on the gateway.
    If you are using a brand-new gateway, then it will be in setup mode; otherwise,
    you can put the gateway into setup mode by pressing the **SETUP** button for a
    few seconds when the orange and green lights start blinking. This means the gateway
    has entered setup mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Wi-Fi network of your the The Things Indoor Gateway, and connect
    to it. The Wi-Fi password is written on the back of the device. *Figure 6**.17*
    shows the **Setup** page for the The Things Indoor Gateway.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.17 – The Things Indoor Gateway setup page](img/B19752_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.17 – The Things Indoor Gateway setup page
  prefs: []
  type: TYPE_NORMAL
- en: After connecting to the indoor gateway, open up your browser and type `http://192.168.4.1`.
    This will open up the **MiniHub Setup** page, as shown in the preceding figure.
    Click on the plus icon (**+**) to select the Wi-Fi network that is connected to
    the internet, and provide its Wi-Fi password. Then, click on the **SAVE & REBOOT**
    button. It will take some seconds to restart, and eventually, your LoRaWAN indoor
    gateway will be connected to the internet via your selected Wi-Fi network.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it’s time to configure the LoRaWAN gateway in the **The Things Stack**
    portal, as shown in *Figure 6**.18*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.18 – LoRaWAN gateway registration – step 1](img/B19752_06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.18 – LoRaWAN gateway registration – step 1
  prefs: []
  type: TYPE_NORMAL
- en: When you associate the MKR WAN 1300 to the Thing in the Arduino IoT Cloud, you
    will receive an email from the The Things Stack Cloud that contains the portal
    URL, along with your username and password details. Log in to the portal, where
    you will be given a clusters list to add your gateway to a recommended cluster.
    In the *Associating a device* section, I chose the **Europe 863-870 MHZ (SF9 for
    RX2 - recommended)** frequency for the MKR WAN 1300, so here, I will choose **Europe
    1** for my gateway. This way, my gateway and MKR WAN 1300 development board both
    sit under the same cluster.
  prefs: []
  type: TYPE_NORMAL
- en: After choosing the cluster, you will be redirected to the main page of the portal.
    From here, we will start adding the gateway, as shown in *Figure 6**.19*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.19 – LoRaWAN gateway registration – step 2](img/B19752_06_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.19 – LoRaWAN gateway registration – step 2
  prefs: []
  type: TYPE_NORMAL
- en: On the main page, we have some menus and two big icons, as shown in the preceding
    figure. From there, click on the **Go to** **gateways** icon.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will be on the page that shows the complete list of gateways, as well
    as the option to register a new gateway, as shown in *Figure 6**.20*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.20 – LoRaWAN gateway registration – step 3](img/B19752_06_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.20 – LoRaWAN gateway registration – step 3
  prefs: []
  type: TYPE_NORMAL
- en: Click on the blue **+ Register** **gateway** button.
  prefs: []
  type: TYPE_NORMAL
- en: This will take us to a new page where we can add a gateway to the the The Things
    Stack network, as shown in *Figure 6**.21*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.21 – LoRaWAN gateway registration – step 4](img/B19752_06_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.21 – LoRaWAN gateway registration – step 4
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we need to select the owner from the **Owner** dropdown. Here, you
    will see two names. One is your personal username, and the other is **arduino-iot-cloud-user**.
    Just select your personal username, as you are the main person adding the gateway.
    In the next field, insert the **Gateway EUI** details. The EUI will be written
    on the back of the gateway. After that, click on the **Confirm** button.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will verify our gateway and select the frequency plan, as shown in *Figure
    6**.22*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.22 – LoRaWAN gateway registration – step 5](img/B19752_06_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.22 – LoRaWAN gateway registration – step 5
  prefs: []
  type: TYPE_NORMAL
- en: You will see the **Claim authentication code** field at the top. Here, we need
    to provide the gateway with a Wi-Fi password for authentication. You can get the
    gateway Wi-Fi password from the back of the gateway, from where you previously
    took it to connect with the device’s Wi-Fi network.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to select the frequency plan for our gateway. We already selected
    **Europe 863-870 MHZ (SF9 for RX2 - recommended)** during the MKR WAN 1300 association,
    so we will select the same frequency from the dropdown. After selecting the frequency,
    click on the **Claim** **gateway** button.
  prefs: []
  type: TYPE_NORMAL
- en: After successfully registering the gateway, we will see a page like the one
    in the following figure, which provides you with the gateway connectivity status,
    as well as **Live data**, **Created at**, **Last updated at**, and lots of other
    information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.23 – The LoRaWAN gateway successfully registered on The Things Network](img/B19752_06_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.23 – The LoRaWAN gateway successfully registered on The Things Network
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we explored how to set up the The Things Indoor Gateway step
    by step. In the next section, we will create a dashboard for our Thing on mobile
    and web to track our assets.
  prefs: []
  type: TYPE_NORMAL
- en: Creating web and mobile dashboards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After uploading the code to the device, it’s time to set up a dashboard for
    web and mobile to visualize data with different widgets. *Figure 6**.24* demonstrates
    the visualization of readings with different widgets.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.24 – The Thing dashboard](img/B19752_06_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.24 – The Thing dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'We have four readings from the GPS module to visualize. Here, I have used four
    widgets: one gauge, two values, and one map. The gauge widget shows `location`
    variable. Currently, the map widget is only capable of displaying the location
    of the asset device based on coordinates; if you have multiple assets to track,
    then you need to set up multiple map widgets according to the number of tracking
    devices.'
  prefs: []
  type: TYPE_NORMAL
- en: Well, this is the last section of our chapter. Here, we created a stunning dashboard
    for GPS tracking that shows **Location** using a map widget on the dashboard,
    **Speed Per Mile**, and some other parameters.
  prefs: []
  type: TYPE_NORMAL
- en: What next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We still have a lot of options available to explore, but now it’s your turn
    to use different sensors and development boards to do some more experiments and
    learn from them. In this chapter, we only used one GPS module, which gave us only
    four parameters, but there are a lot of GPS modules on the market that provide
    a wide variety of functionalities, such as working under a roof and accuracy features.
  prefs: []
  type: TYPE_NORMAL
- en: While monitoring the location of assets, some other parameters are very important
    to monitor in different industries, such as temperature and humidity, which are
    very important in food and medical products. CO2 and **liquefied petroleum gas**
    (**LPG**) gases are very important to monitor during fuel transportation. Try
    using different sensors with a GPS module to set up different tracking prototypes
    for different industries.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored how to develop an asset-tracking system using LoRaWAN
    and a GPS module. We set up the Thing, which included cloud variable creation,
    device association, the The Things Indoor Gateway, and coding a development board.
    Then, we created a dashboard to visualize the Thing readings with different types
    of widgets to display current readings. The most important widget of the chapter
    is the map widget, which is very interesting and important for plotting the current
    location of the device.
  prefs: []
  type: TYPE_NORMAL
- en: GPS tracking is a very important topic that helps us to develop a device for
    our assets, assisting us in asset tracking and monitoring. We can use LoRaWAN
    for a specific region, as it has a longer range, but that range only operates
    in a specific area, unlike other wireless technologies. This chapter demonstrated
    how we can display the location of a device on a dashboard, giving you more confidence
    to build more asset-tracking solutions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, *Enabling Communication between Different Devices*, we
    will explore how the Arduino IoT Cloud makes it easy to send data between devices.
    Using this method, we will sync IoT nodes with each other for seamless operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Exchanging Data between Nodes and Cloud Applications'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This third part of the book describes how to exchange data between IoT nodes
    provisioned on the Arduino IoT Cloud and between the Arduino IoT Cloud and external
    cloud applications.
  prefs: []
  type: TYPE_NORMAL
- en: These functionalities are required in many real cases to build a distributed
    and reliable network, to implement some interdependent visualization and logic
    on the IoT application, and to expand the functionalities of the Arduino IoT Cloud
    with external tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B19752_07.xhtml#_idTextAnchor141), *Enabling Communication between
    Different Devices*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B19752_08.xhtml#_idTextAnchor158), *Working with the Arduino
    IoT Cloud SDK and JavaScript*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B19752_09.xhtml#_idTextAnchor195), *Project #4 – Collecting Data
    from the Soil and Environment for Smart Farming*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B19752_10.xhtml#_idTextAnchor211), *Project #5 – Making Your
    Homes Smarter with a Voice Assistant*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
