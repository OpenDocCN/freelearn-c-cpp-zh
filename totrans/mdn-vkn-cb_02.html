<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-113"><a id="_idTextAnchor126"/>2</h1>
<h1 id="_idParaDest-114"><a id="_idTextAnchor127"/>Working with Modern Vulkan</h1>
<p>The goal of this chapter is to show you how to render a scene that accepts input information, such as textures and uniform data, from the application side. This chapter will cover advanced topics in the Vulkan API that build upon the core concepts discussed in the previous chapter and present all the information you need to render complex scenes, along with newer features of the API. Additionally, the chapter will demonstrate techniques to enhance the rendering speed.</p>
<p>In this chapter, we’re going to cover the following recipes:</p>
<ul>
<li>Understanding Vulkan’s memory model</li>
<li>Instantiating the VMA library</li>
<li>Creating buffers</li>
<li>Uploading data to buffers</li>
<li>Creating a staging buffer</li>
<li>How to avoid data races using ring buffers</li>
<li>Setting up pipeline barriers</li>
<li>Creating images (textures)</li>
<li>Creating an image view</li>
<li>Creating a sampler</li>
<li>Providing shader data</li>
<li>Customizing shader behavior with specialization constants</li>
<li>Implementing MDI and PVP</li>
<li>Adding flexibility to the rendering pipeline using dynamic rendering</li>
<li>Transferring resources between queue families</li>
</ul>
<h1 id="_idParaDest-115"><a id="_idTextAnchor128"/>Technical requirements</h1>
<p>For this chapter, you will need to make sure you have VS 2022 installed along with the Vulkan SDK. Basic familiarity with the C++ programming language and an understanding of OpenGL or any other graphics API will be useful. Please revisit <a href="B18491_01.xhtml#_idTextAnchor019"><em class="italic">Chapter 1</em></a><em class="italic">, Vulkan Core Concepts</em>, under the <em class="italic">Technical requirements</em> section for details on setting up and building executables for this chapter. The recipe for this chapter can be run by launching <code>Chapter02_MultiDrawIndirect.exe</code> executable.</p>
<h1 id="_idParaDest-116"><a id="_idTextAnchor129"/>Understanding Vulkan’s memory model</h1>
<p>Memory allocation <a id="_idIndexMarker140"/>and management are crucial in Vulkan, as almost none of the details of memory usage are managed by Vulkan. Except for deciding the exact memory address where memory should be allocated, all other details are the responsibility of the application. This means the programmer must manage memory types, their sizes, and alignments, as well as any sub-allocations. This approach gives applications more control over memory management and allows developers to optimize their programs for specific uses. This recipe will provide some fundamental information about the types of memory provided by the API as well as a summary of how to allocate and bind that memory to resources.</p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor130"/>Getting ready</h2>
<p>Graphics cards come in two variants, integrated and discrete. Integrated graphics cards share the same memory as the CPU, as shown in <em class="italic">Figure 2</em><em class="italic">.1</em>:</p>
<div><div><img alt="﻿Figure 2.1 – Typical memory architecture for discrete graphics cards" src="img/B18491_02_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor131"/>Figure 2.1 – Typical memory architecture for discrete graphics cards</p>
<p>Discrete graphics cards have their own memory (device memory) separate from the main memory (host memory), as shown in <em class="italic">Figure 2</em><em class="italic">.2</em>:</p>
<div><div><img alt="F﻿igure 2.2 – Typical memory architecture for integrated graphics cards" src="img/B18491_02_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">F<a id="_idTextAnchor132"/>igure 2.2 – Typical memory architecture for integrated graphics cards</p>
<p>Vulkan provides different types of memory:</p>
<ul>
<li><strong class="bold">Device-local memory</strong>: This type<a id="_idIndexMarker141"/> of memory is optimized for use by the GPU and is local to the device. It is typically faster than host-visible memory but is not accessible from the CPU. Usually, resources such as render targets, storage images, and buffers are stored in this memory.</li>
<li><strong class="bold">Host-visible memory</strong>: This type of memory is accessible from both the GPU and the CPU. It is typically slower than device-local memory but allows for efficient data transfer between the GPU and CPU. Reads from GPU to CPU happen <a id="_idIndexMarker142"/>across <strong class="bold">Peripheral Component Interconnect Express</strong> (<strong class="bold">PCI-E</strong>) lanes in the case of non-integrated GPU. It’s typically used to set up staging buffers, where data is stored before being transferred to device-local memory, and uniform buffers, which are constantly updated from the application.</li>
<li><strong class="bold">Host-coherent memory</strong>: This type of memory is like host-visible memory but provides guaranteed memory consistency between the GPU and CPU. This type of memory is typically slower than both device-local and host-visible memory but is useful for storing data that needs to be frequently updated by both the GPU and CPU.</li>
</ul>
<p><em class="italic">Figure 2</em><em class="italic">.3</em> summarizes <a id="_idIndexMarker143"/>the three aforementioned types of memory. Device-local memory is not visible from the host, while host-coherent and host-visible are. Copying data from the CPU to the GPU can be done using mapped memory for those two types of memory allocations. For device-local memory, it’s necessary to copy the data from the CPU to host-visible memory first using mapped memory (the staging buffer), and then perform a copy of the data from the staging buffer to the destination, the device-local memory, using a Vulkan function:</p>
<div><div><img alt="Figure 2.3 – Types of memory and their visibility from the application in Vulkan" src="img/B18491_02_03.jpg"/>
</div>
</div>
<p class="IMG---Figure"><a id="_idTextAnchor133"/></p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Types of memory and their visibility from the application in Vulkan</p>
<p>Images are usually device-local memory, as they have their own layout that isn’t readily interpretable by the application. Buffers can be of any one of the aforementioned types.</p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor134"/>How to do it…</h2>
<p>A typical workflow for <a id="_idIndexMarker144"/>creating and uploading data to a buffer includes the following steps:</p>
<ol>
<li>Create a buffer object of type <code>VkBuffer</code> by using the <code>VkBufferCreateInfo</code> structure and calling <code>vkCreateBuffer</code>.</li>
<li>Retrieve the memory requirements based on the buffer’s properties by calling <code>vkGetBufferMemoryRequirements</code>. The device may require a certain alignment, which could affect the necessary size of the allocation to accommodate the buffer’s contents.</li>
<li>Create a structure of type <code>VkMemoryAllocateInfo</code>, specify the size of the allocation and the type of memory, and call <code>vkAllocateMemory</code>.</li>
<li>Call <code>vkBindBufferMemory</code> to bind the allocation with the buffer object.</li>
<li>If the buffer is visible from the host, map a pointer to the destination with <code>vkMapMemory</code>, copy the data, and unmap the memory with <code>vkUnmapMemory</code>.</li>
<li>If the buffer is a device-local buffer, copy the data to a staging buffer first, then perform the final copy from the staging buffer to the device-local memory using the <code>vkCmdCopyBuffer</code> function.</li>
</ol>
<p>As you can see, that’s a complex procedure that can be simplified by using the VMA library, an open source library that provides a convenient and efficient way to manage memory in Vulkan. It <a id="_idIndexMarker145"/>offers a high-level interface that abstracts the complex details of memory allocation, freeing you from the burden of manual memory management.</p>
<h1 id="_idParaDest-119"><a id="_idTextAnchor135"/>Instantiating the VMA library</h1>
<p>To use VMA, you first <a id="_idIndexMarker146"/>need to create an instance of the library and store a handle in a variable of type <code>VmaAllocator</code>. To create one, you need a Vulkan physical device and a device.</p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor136"/>How to do it…</h2>
<p>Creating a VMA library instance requires instancing two different structures. One stores pointers to API functions that VMA needs to find other function pointers and another structure that provides a physical device, a device, and an instance for creating an allocator:</p>
<pre class="source-code">
VkPhysicalDevice physicalDevice;  // Valid Physical Device
VkDevice device; // Valid Device
VkInstance instance; // Valid Instance
const uint32_t apiVersion = VK_API_VERSION_1_3;
const VmaVulkanFunctions vulkanFunctions = {
    .vkGetInstanceProcAddr = vkGetInstanceProcAddr,
    .vkGetDeviceProcAddr = vkGetDeviceProcAddr,
#if VMA_VULKAN_VERSION &gt;= 1003000
    .vkGetDeviceBufferMemoryRequirements =
        vkGetDeviceBufferMemoryRequirements,
    .vkGetDeviceImageMemoryRequirements =
        vkGetDeviceImageMemoryRequirements,
#endif
};
VmaAllocator allocator = nullptr;
const VmaAllocatorCreateInfo allocInfo = {
    .physicalDevice = physicalDevice,
    .device = device,
    .pVulkanFunctions = &amp;vulkanFunctions,
    .instance = instance,
    .vulkanApiVersion = apiVersion,
};
vmaCreateAllocator(&amp;allocInfo, &amp;allocator);</pre> <p>The allocator needs pointers to a few Vulkan functions so that it can work based on the features you would like to use. In the preceding case, we provide only the bare minimum for<a id="_idIndexMarker147"/> allocating and deallocating memory. The allocator needs to be freed once the context is destroyed with <code>vmaDestroyAllocator</code>.</p>
<h1 id="_idParaDest-121"><a id="_idTextAnchor137"/>Creating buffers</h1>
<p>A buffer in Vulkan is<a id="_idIndexMarker148"/> simply a contiguous block of memory that holds some data. The data can be vertex, index, uniform, and more. A buffer object is just metadata and does not directly contain data. The memory associated with a buffer is allocated after a buffer has been created.</p>
<p><em class="italic">Table 2.1</em> summarizes the most important usage types of buffers and their access type:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-1">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><strong class="bold">Buffer Type</strong></p>
</td>
<td class="No-Table-Style T---Body">
<p><strong class="bold">Access Type</strong></p>
</td>
<td class="No-Table-Style T---Body">
<p><strong class="bold">Uses</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p>Vertex or Index</p>
</td>
<td class="No-Table-Style T---Body">
<p>Read-only</p>
</td>
<td class="No-Table-Style T---Body"/>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p>Uniform</p>
</td>
<td class="No-Table-Style T---Body">
<p>Read-only</p>
</td>
<td class="No-Table-Style T---Body">
<p>Uniform data storage</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p>Storage</p>
</td>
<td class="No-Table-Style T---Body">
<p>Read/write</p>
</td>
<td class="No-Table-Style T---Body">
<p>Generic data storage</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p>Uniform texel</p>
</td>
<td class="No-Table-Style T---Body">
<p>Read/write</p>
</td>
<td class="No-Table-Style T---Body">
<p>Data is interpreted as texels</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p>Storage texel</p>
</td>
<td class="No-Table-Style T---Body">
<p>Read/write</p>
</td>
<td class="No-Table-Style T---Body">
<p>Data is interpreted as texels</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor138"/>Table 2.1 – Buffer types</p>
<p>Creating buffers is easy, but it helps to know what types of buffers exist and what their requirements are before setting out to create them. In this chapter, we will provide a template for creating buffers.</p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor139"/>Getting ready</h2>
<p>In the <a id="_idIndexMarker149"/>repository, Vulkan buffers are managed by the <code>VulkanCore::Buffer</code> class, which provides functions to create and upload data to the device, as well as a utility function to use a staging buffer to upload data to device-only heaps.</p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor140"/>How to do it…</h2>
<p>Creating a buffer using VMA is simple:</p>
<ol>
<li>All you need are buffer creation flags ( –a value of <code>0</code> for the flags is correct for most cases), the size of the buffer in bytes, its usage (this is how you define how the buffer will be used), and assign those values to an instance of the <code>VkBufferCreateInfo</code> structure:<pre class="source-code">
VkDeviceSize size;  // The requested size of the buffer
VmaAllocator allocator;  // valid VMA Allocator
VkUsageBufferFlags use;  // Transfer src/dst/uniform/SSBO
VkBuffer buffer;        // The created buffer
VkBufferCreateInfo createInfo = {
    .sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
    .pNext = nullptr,
    .flags = {},
    .size = size,
    .usage = use,
    .sharingMode = VK_SHARING_MODE_EXCLUSIVE,
    .queueFamilyIndexCount = {},
    .pQueueFamilyIndices = {},
};</pre><p class="list-inset">You will also <a id="_idIndexMarker150"/>need a set of VmaAllocationCreateFlagBits values:</p><pre class="source-code">const VmaAllocationCreateFlagBits allocCreateInfo = {
    VMA_ALLOCATION_CREATE_MAPPED_BIT,
    VMA_MEMORY_USAGE_CPU_ONLY,
};</pre></li> <li>Then, call <code>vmaCreateBuffer</code> to obtain the buffer handle and its allocation:<pre class="source-code">
VmaAllocation allocation;  // Needs to live until the
                           // buffer is destroyed
VK_CHECK(vmaCreateBuffer(allocator, &amp;createInfo,
                         &amp;allocCreateInfo, &amp;buffer,
                         &amp;allocation, nullptr));</pre></li> <li>The next step is optional but useful for debugging and optimization:<pre class="source-code">
VmaAllocationInfo allocationInfo;
vmaGetAllocationInfo(allocator, allocation,
                     &amp;allocationInfo);</pre></li> </ol>
<p>Some creation flags affect how the buffer can be used, so you might need to make adjustments to <a id="_idIndexMarker151"/>the preceding code depending on how you intend to use the buffers you create in your application.</p>
<h1 id="_idParaDest-124"><a id="_idTextAnchor141"/>Uploading data to buffers</h1>
<p>Uploading data<a id="_idIndexMarker152"/> from the application to the GPU depends on the <a id="_idIndexMarker153"/>type of buffer. For host-visible buffers, it’s a direct copy using <code>memcpy</code>. For device-local buffers, we need a staging buffer, which is a buffer that is visible both by the CPU and the GPU. In this recipe, we will demonstrate how to upload data from your application to the device-visible memory (into a buffer’s memory region on the device).</p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor142"/>Getting ready</h2>
<p>If you haven’t already, please refer to the <em class="italic">Understanding Vulkan’s memory </em><em class="italic">model </em>recipe.</p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor143"/>How to do it…</h2>
<p>The upload process depends on the type of buffer:</p>
<ol>
<li>For host-visible memory, it’s enough to retrieve a pointer to the destination using <code>vmaMapMemory</code> and copy the data using <code>memcpy</code>. The operation is synchronous, so the mapped pointer can be unmapped as soon as <code>memcpy</code> returns.<p class="list-inset">It’s fine to map a host-visible buffer as soon as it is created and leave it mapped until its destruction. That is the recommended approach, as you don’t incur the overhead of mapping the memory every time it needs to be updated:</p><pre class="source-code">
VmaAllocator allocator;   // Valid VMA allocator
VmaAllocation allocation; // Valid VMA allocation
void *data;               // Data to be uploaded
size_t size;              // Size of data in bytes
void *map = nullptr;
VK_CHECK(vmaMapMemory(allocator, allocation,
                      &amp;map));
memcpy(map, data, size);
vmaUnmapMemory(allocator_, allocation_);
VK_CHECK(vmaFlushAllocation(allocator_,
                            allocation_, offset,
                            size));</pre></li> <li>Uploading data<a id="_idIndexMarker154"/> to<a id="_idIndexMarker155"/> a device-local memory needs to be (1) copied to a buffer that is visible from the host first (called a staging buffer) and then (2) copied from the staging buffer to the device-local memory using <code>vkCmdCopyBuffer</code>, as depicted in <em class="italic">Figure 2</em><em class="italic">.4</em>. Note that this requires a command buff<a id="_idTextAnchor144"/>er:</li>
</ol>
<div><div><img alt="Figure 2.4 – Staging buffers" src="img/B18491_02_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Staging buffers</p>
<ol>
<li value="3">Once the data is residing on the device (on the host-visible buffer), copying it to the device-only buffer is simple:<pre class="source-code">
VkDeviceSize srcOffset;
VkDeviceSize dstOffset;
VkDeviceSize size;
VkCommandBuffer commandBuffer; // Valid Command Buffer
VkBuffer stagingBuffer; // Valid host-visible buffer
VkBuffer buffer; // Valid device-local buffer
VkBufferCopy region(srcOffset, dstOffset, size);
vkCmdCopyBuffer(commandBuffer, stagingBuffer, buffer, 1, &amp;region);</pre></li> </ol>
<p>Uploading data from your application to a buffer is accomplished either by a direct <code>memcpy</code> operation or<a id="_idIndexMarker156"/> by <a id="_idIndexMarker157"/>means of a staging buffer. We showed how to perform both uploads in this recipe.</p>
<h1 id="_idParaDest-127"><a id="_idTextAnchor145"/>Creating a staging buffer</h1>
<p>Creating a staging <a id="_idIndexMarker158"/>buffer is like creating a regular buffer but requires flags that specify that the buffer is host-visible. In this recipe, we will show how to create a buffer that can be used as a staging buffer – one that can be used as an intermediary destination of the data being uploaded from your application on its way to a device-local memory.</p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor146"/>Getting ready</h2>
<p>The <em class="italic">Creating buffers</em> recipe explains how to create buffers in general, while this recipe shows which flags and parameters you need to create a staging buffer.</p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor147"/>How to do it…</h2>
<p><code>VkBufferCreateInfo::usage</code> needs to contain <code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code> as it will be the source operation for a <code>vkCmdCopyBuffer</code> command:</p>
<pre class="source-code">
const VkBufferCreateInfo stagingBufferInfo = {
    .sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
    .size = size,
    .usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
};
const VmaAllocationCreateInfo
    stagingAllocationCreateInfo = {
        .flags = VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT |
            VMA_ALLOCATION_CREATE_MAPPED_BIT,
        .usage = VMA_MEMORY_USAGE_CPU_ONLY,
};
const VmaAllocationCreateFlagBits allocCreateInfo = {
    VMA_ALLOCATION_CREATE_MAPPED_BIT,
    VMA_MEMORY_USAGE_CPU_ONLY,
};
VmaAllocation allocation;  // Needs to live until the
                           // buffer is destroyed
VK_CHECK(vmaCreateBuffer(allocator, &amp;stagingBufferInfo,
                         &amp;allocCreateInfo, &amp;buffer,
                         &amp;allocation, nullptr));</pre> <p>A staging buffer <a id="_idIndexMarker159"/>may be better implemented using a wrapper in your application. A wrapper can increase or decrease the size of the buffer as needed, for example. One staging buffer may be enough for your application, but you need to watch the requirements imposed by some architectures.</p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor148"/>How to avoid data races using ring buffers</h1>
<p>When a buffer needs to be updated every frame, we run the risk of creating a data race, as shown in <em class="italic">Figure 2</em><em class="italic">.5</em>. A data race is a situation where multiple threads within a program <a id="_idIndexMarker160"/>concurrently access a shared data point, with at <a id="_idIndexMarker161"/>least one thread performing a write operation. This concurrent access can result in unforeseen behavior due to the unpredictable order of operations. Take the example of a uniform buffer that stores the view, model, and viewport matrices and needs to be updated every frame. The buffer is updated while the first command buffer is being recorded, initializing it (version 1). Once the command buffer starts processing on the GPU, the buffer contains the corre<a id="_idTextAnchor149"/>ct data:</p>
<div><div><img alt="Figure 2.5 – Data race when using one buffer" src="img/B18491_02_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – Data race when using one buffer</p>
<p>After the first command buffer starts processing in the GPU, the application may try to update the buffer’s contents to version 2 while the GPU is accessing that data for rendering!</p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor150"/>Getting ready</h2>
<p>Synchronization is by far the hardest aspect of Vulkan. If synchronization elements such as semaphores, fences, and barriers are used too greedily, then your application becomes a series and won’t use the full power of the parallelism between the CPU and the GPU.</p>
<p>Make sure you also read the <em class="italic">Understanding synchronization in the swapchain – fences and semaphores</em> recipe in <a href="B18491_01.xhtml#_idTextAnchor019"><em class="italic">Chapter 1</em></a><em class="italic">, Vulkan Core Concepts</em>. That recipe and this one only scratch the surface of how to tackle synchronization, but are very good starting points.</p>
<p>A ring-buffer implementation is provided in the <code>EngineCore::RingBuffer</code> repository, which has a configurable number of sub-buffers. Its sub-buffers are all host-visible, persistent buffers; that is, they are persistently mapped after creation for ease of access.</p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor151"/>How to do it…</h2>
<p>There are a few ways to avoid this problem, but the easiest one is to create a ring buffer that contains several buffers (or any other resource) equal to the number of frames in flight. <em class="italic">Figure 2</em><em class="italic">.6</em> shows <a id="_idIndexMarker162"/>events when there are two buffers <a id="_idIndexMarker163"/>available. Once the first command buffer is submitted and is being processed in the GPU, the application is free to process copy 1 of the buffer, as it’s not being accessed by th<a id="_idTextAnchor152"/>e device:</p>
<div><div><img alt="Figure 2.6 – A data race is avoided with multiple copies of a resource" src="img/B18491_02_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – A data race is avoided with multiple copies of a resource</p>
<p>Even though this is a simple solution, it has a caveat: if partial updates are allowed, care must be taken when the buffer is updated. Consider <em class="italic">Figure 2</em><em class="italic">.7</em>, in which a ring buffer that contains three sub-allocations is partially updated. The buffer stores the view, model, and viewport matrices. During initialization, all three sub-allocations are initialized to three identity matrices. On <code>(10, 10, 0)</code>. On the next frame, <strong class="bold">Frame 1</strong>, <strong class="bold">Buffer 1</strong> becomes active, and the viewport matrix is updated. Because <strong class="bold">Buffer 1</strong> was initialized to three identity matrices, updating only the viewport matrix makes buffers <strong class="bold">0</strong> and <strong class="bold">1</strong> out of sync (as well as <strong class="bold">Buffer 3</strong>). To guarantee that partial updates work, we need to copy the last active buffer, <strong class="bold">Buffer 0</strong>, into <strong class="bold">Buffer 1</strong> first, and then update the viewport<a id="_idTextAnchor153"/><a id="_idTextAnchor154"/> matrix:</p>
<div><div><img alt="Figure 2.7 – Partial update of a ring buffer makes all sub-allocations out of sync if they are not replicated" src="img/B18491_02_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – Partial update of a ring buffer makes all sub-allocations out of sync if they are not replicated</p>
<p>Synchronization is a delicate topic, and guaranteeing your application behaves correctly with so<a id="_idIndexMarker164"/> many <a id="_idIndexMarker165"/>moving parts is tricky. Hopefully, a ring-buffer implementation that is simple may help you focus on other areas of the code.</p>
<h1 id="_idParaDest-133"><a id="_idTextAnchor155"/>Setting up pipeline barriers</h1>
<p>In Vulkan, commands<a id="_idIndexMarker166"/> may be reordered when a command buffer is being processed, subject to certain restrictions. This is known as command buffer reordering, and it can help to improve performance by allowing the driver to optimize the order in which commands are executed.</p>
<p>The good news is that Vulkan provides a mechanism called pipeline barriers to ensure that dependent commands are executed in the correct order. They are used to explicitly specify dependencies between commands, preventing them from being reordered, and at what stages they might overlap. This recipe will explain what pipeline barriers are and what their properties mean. It will also show you how to create and install pipeline barriers.</p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor156"/>Getting ready</h2>
<p>Consider two draw calls issued in sequence. The first one writes to a color attachment, while the second draw call samples from that attachment in the fragment shader:</p>
<pre class="source-code">
vkCmdDraw(...); // draws into color attachment 0
vkCmdDraw(...); // reads from color attachment 0</pre> <p><em class="italic">Figure 2</em><em class="italic">.8</em> helps visualize how those two commands may be processed by the device. In the diagram, commands are processed from top to bottom and progress on the pipeline from left to right. Clock cycles are a loose term, because processing may take multiple clock cycles, but are used to indicate that – in general – some tasks must happen after others.</p>
<p>In the example, the second <code>vkCmdDraw</code> call starts executing at <strong class="bold">C2</strong>, after the first draw call. This offset is not enough, as the second draw call needs to read the color attachment at the <strong class="bold">Fragment Shader</strong> stage, which is not produced by the first draw call until it<a id="_idIndexMarker167"/> reaches the <strong class="bold">Color Attach Output</strong> stage. Without synchronization, this setup may cause <a id="_idTextAnchor157"/>data races:</p>
<div><div><img alt="Figure 2.8 – Two consecutive commands recorded on the same command buffer being processed without synchronization" src="img/B18491_02_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – Two consecutive commands recorded on the same command buffer being processed without synchronization</p>
<p>A pipeline barrier is a feature that is recorded into the command buffer and that specifies the pipeline stages that need to have been completed for all commands that appear before the barrier and before the command buffer continues processing. Commands recorded before the barrier are said to be in the <em class="italic">first synchronization scope</em> or first scope. Commands recorded after the barrier are said to be part of the <em class="italic">second synchronization scope</em> or second scope.</p>
<p>The barrier also allows fine-grained control to specify at which stage commands after the barrier must wait until commands in the first scope finish processing. That’s because commands in the second scope don’t need to wait until commands in the first scope are done. They can start processing as soon as possible, as long as the conditions specified in the barrier are met.</p>
<p>In the example in <em class="italic">Figure 2</em><em class="italic">.8</em>, the first draw call, in the first scope, needs to write to the attachment before the second draw call can access it. The second draw call does not need to wait until the first draw call finishes processing the <strong class="bold">Color Attach Output</strong> stage. It can start right away, as long as its fragment stage happens after the first draw call is done with<a id="_idIndexMarker168"/> its <strong class="bold">Color Attach Output</strong> stage, as shown in <a id="_idTextAnchor158"/><em class="italic">Figure 2</em><em class="italic">.9</em>:</p>
<div><div><img alt="Figure 2.9 – Two consecutive commands recorded on the same command buffer being processed with synchronization" src="img/B18491_02_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9 – Two consecutive commands recorded on the same command buffer being processed with synchronization</p>
<p>There are three types of barriers:</p>
<ol>
<li><strong class="bold">Memory barriers</strong> are global <a id="_idIndexMarker169"/>barriers and apply to all commands in the first and second scopes.</li>
<li><strong class="bold">Buffer memory barriers</strong> are barriers that apply only to commands that access a portion of the buffer, as it’s possible to specify to which portion of the buffer the barrier applies (offset + range).</li>
<li><code>VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</code> layout, as it will be read from, while the next mip level needs to be in the <code>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</code> layout, as it will be written to.</li>
</ol>
<h2 id="_idParaDest-135"><a id="_idTextAnchor159"/>How to do it…</h2>
<p>Pipeline barriers are recorded with the <code>vkCmdPipelineBarrier</code> command, in which you can provide several barriers of multiple types at the same time. The following code snippet shows how to create a barrier used to create a dependency between the two draw <a id="_idIndexMarker170"/>calls in <em class="italic">Figure 2</em><em class="italic">.9</em>:</p>
<pre class="source-code">
VkCommandBuffer commandBuffer;  // Valid Command Buffer
VkImage image;                  // Valid image
const VkImageSubresourceRange subresource = {
    .aspectMask =.baseMipLevel = 0,
    .levelCount = VK_REMAINING_MIP_LEVELS,
    .baseArrayLayer = 0,
    .layerCount = 1,
};
const VkImageMemoryBarrier imageBarrier = {
    .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
    .srcAccessMask =
        VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR,
    .dstAccessMask = VK_ACCESS_2_SHADER_READ_BIT_KHR,
    .oldLayout = VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL,
    .newLayout = VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL,
    .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
    .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
    .image = image,
    .subresourceRange = &amp;subresource,
};
vkCmdPipelineBarrier(
    commandBuffer,
    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, 0, 0,
    nullptr, 0, nullptr, 1, &amp;memoryBarrier);</pre> <p>The barrier needs to be recorded between the two draw calls:</p>
<pre class="source-code">
vkCmdDraw(...); // draws into color attachment 0
vkCmdPipelineBarrier(...);
vkCmdDraw(...); // reads from color attachment 0</pre> <p>Pipeline barriers <a id="_idIndexMarker171"/>are tricky but absolutely fundamental in Vulkan. Make sure you understand what they offer and how they operate before continuing to read the other recipes.</p>
<h1 id="_idParaDest-136"><a id="_idTextAnchor160"/>Creating images (textures)</h1>
<p>Images are used <a id="_idIndexMarker172"/>for storing 1D, 2D, or 3D data, although they are mostly used for 2D data. Different than buffers, images have the advantage of being optimized for locality in memory layout. This is because most GPUs have a fixed-function texture unit or sampler that reads texel data from an image and applies filtering and other operations to produce a final color value. Images can have different formats, such as RGB, RGBA, BGRA, and so on.</p>
<p>An image object is only metadata in Vulkan. Its data is stored separately and is created in a similar manner to buffers <a id="_idTextAnchor161"/>(<em class="italic">Figure 2</em><em class="italic">.10</em>):</p>
<div><div><img alt="Figure 2.10 – Images" src="img/B18491_02_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10 – Images</p>
<p>Images in Vulkan cannot be accessed directly and need to be accessed only by means of an image view. An image view is a way to access a subset of the image data by specifying the subresource range, which includes the aspect (such as color or depth), the mip level, and the array layer range.</p>
<p>Another <em class="italic">very important</em> aspect of images is their layout. It is used to specify the intended usage of an image resource in Vulkan, such as whether it should be used as a source or destination for a transfer operation, a color or depth attachment for rendering, or as a shader read or write resource. The correct image layout is important because it ensures that the GPU can efficiently access and manipulate the image data in accordance with the intended usage. Using the wrong image layout can lead to performance issues or rendering artifacts and can result in undefined behavior. Therefore, it’s essential to correctly specify the image layout for each usage of an image in a Vulkan application. Common image layouts are undefined (<code>VK_IMAGE_LAYOUT_UNDEFINED</code>) color attachment (<code>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</code>), depth/stencil attachment (<code>VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</code>), and shader read(<code>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code>). Image layout transitions are <a id="_idIndexMarker173"/>done as part of the <code>vkCmdPipelineBarrier</code> command.</p>
<p>In this recipe, you will learn how to create images on a device.</p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor162"/>Getting ready</h2>
<p>In the <code>VulkanCore::Texture</code> class within our repository, we’ve encapsulated the intricate management of images and image views, offering a comprehensive solution for handling Vulkan textures. From facilitating efficient data uploads to handling transitions between image layouts and generating mipmaps, the <code>Texture</code> class equips us with the means to seamlessly integrate textures in the Vulkan examples.</p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor163"/>How to do it…</h2>
<p>Creating an image requires some basic information about it, such as type (1D, 2D, 3D), size, format (RGBA, BGRA, and so on), number of mip levels, number of layers (faces for cubemaps), and <a id="_idIndexMarker174"/>a few others:</p>
<pre class="source-code">
VkFormat format;     // Image format
VkExtents extents;   // Image size
uint32_t mipLevels;  // Number of mip levels
uint32_t layerCount; // Number of layers (sides of cubemap)
const VkImageCreateInfo imageInfo = {
    .sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
    .flags = 0, // optional
    .imageType = VK_IMAGE_TYPE_2D,  // 1D, 2D, 3D
    .format = format,
    .extent = extents,
    .mipLevels = mipLevels,
    .arrayLayers = layerCount,
    .samples = VK_SAMPLE_COUNT_1_BIT,
    .tiling = VK_IMAGE_TILING_OPTIMAL,
    .usage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
    .sharingMode = VK_SHARING_MODE_EXCLUSIVE,
    .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED,
};</pre> <p>The following structure tells VMA that the image will be a device-only image:</p>
<pre class="source-code">
const VmaAllocationCreateInfo allocCreateInfo = {
    .flags = VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT,
    .usage = VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE,
    .priority = 1.0f,
};</pre> <p>The resulting image’s handle will be stored in <code>image</code>:</p>
<pre class="source-code">
VkImage image = VK_NULL_HANDLE;
VK_CHECK(vmaCreateImage(vmaAllocator_, &amp;imageInfo,
                        &amp;allocCreateInfo, &amp;image,
                        &amp;vmaAllocation_, nullptr));</pre> <p>The next step is optional but useful for debugging or optimizing the code:</p>
<pre class="source-code">
VmaAllocationInfo allocationInfo;
vmaGetAllocationInfo(vmaAllocator_, vmaAllocation_,
                     &amp;allocationInfo);</pre> <p>This recipe only showed you how to create an image in Vulkan, not how to upload data to it. Uploading <a id="_idIndexMarker175"/>data to an image is just like uploading data to a buffer.</p>
<h1 id="_idParaDest-139"><a id="_idTextAnchor164"/>Creating an image view</h1>
<p>Image views<a id="_idIndexMarker176"/> provide a way to interpret images in terms of size, location, and format, except in terms of their layout, which needs to be transformed explicitly and transitioned using image barriers. In this recipe, you will learn how to create an image view object in Vulkan.</p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor165"/>Getting ready</h2>
<p>Image views are stored and managed by the <code>VulkanCore::Texture</code> class in the repository.</p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor166"/>How to do it…</h2>
<p>Creating an image view is easy; all you need is the handle of the image it is associated with and the<a id="_idIndexMarker177"/> region of the image that you would like to represent:</p>
<pre class="source-code">
VkDevice device;  // Valid Vulkan Device
VkImage image;    // Valid Image object
VkFormat format;
uint32_t numMipLevels;  // Number of mip levels
uint32_t layers;  // Number of layers (cubemap faces)
const VkImageViewCreateInfo imageViewInfo = {
    .sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
    .image = image,
    .viewType =
        VK_IMAGE_VIEW_TYPE_2D,  // 1D, 2D, 3D, Cubemap
                                // and arrays
    .format = format,
    .components =
        {
            .r = VK_COMPONENT_SWIZZLE_IDENTITY,
            .g = VK_COMPONENT_SWIZZLE_IDENTITY,
            .b = VK_COMPONENT_SWIZZLE_IDENTITY,
            .a = VK_COMPONENT_SWIZZLE_IDENTITY,
        },
    .subresourceRange = {
        .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
        .baseMipLevel = 0,
        .levelCount = numMipLevels,
        .baseArrayLayer = 0,
        .layerCount = layers,
    }};
VkImageView imageView{VK_NULL_HANDLE};
VK_CHECK(vkCreateImageView(device, &amp;imageViewInfo,
                           nullptr, &amp;imageView));</pre> <p>Without an image view, a texture cannot be used by shaders. Even when used as color attachments, images<a id="_idIndexMarker178"/> need image views.</p>
<h1 id="_idParaDest-142"><a id="_idTextAnchor167"/>Creating a sampler</h1>
<p>A sampler in Vulkan <a id="_idIndexMarker179"/>transcends a simple object; it’s a crucial bridge between shader execution and image data. Beyond interpolation, it governs filtering, addressing modes, and mipmapping. Filters dictate interpolation between texels, while addressing modes control how coordinates map to image extents. Anisotropic filtering further enhances sampling fidelity. Mipmapping, a pyramid of downsampled image levels, is another facet managed by samplers. In essence, creating a sampler involves orchestrating these attributes to seamlessly harmonize image data and shader intricacies. In this recipe, you will learn how to create a sampler object in Vulkan.</p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor168"/>Getting ready</h2>
<p>Samplers are implemented by the <code>VulkanCore::Sampler</code> class in the repository.</p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor169"/>How to do it…</h2>
<p>The properties of a sampler define how an image is interpreted in the pipeline, usually in a shader. The process is simple – instantiate a <code>VkSamplerCreateInfo</code> structure and call <code>vkCreateSampler</code>:</p>
<pre class="source-code">
VkDevice device;  // Valid Vulkan Device
VkFilter minFilter;
VkFilter maxFilter;
float maxLod;  // Max mip level
const VkSamplerCreateInfo samplerInfo = {
    .sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
    .magFilter = minFilter,
    .minFilter = magFilter,
    .mipmapMode = maxLod &gt; 0
                      ? VK_SAMPLER_MIPMAP_MODE_LINEAR
                      : VK_SAMPLER_MIPMAP_MODE_NEAREST,
    .addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT,
    .addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT,
    .addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT,
    .mipLodBias = 0,
    .anisotropyEnable = VK_FALSE,
    .minLod = 0,
    .maxLod = maxLod,
};
VkSampler sampler{VK_NULL_HANDLE};
VK_CHECK(vkCreateSampler(device, &amp;samplerInfo, nullptr,
                         &amp;sampler));</pre> <p>A sampler is one of<a id="_idIndexMarker180"/> the simplest objects to create in Vulkan and one of the easiest to understand, as it describes very common computer graphics concepts.</p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor170"/>Providing shader data</h1>
<p>Providing data<a id="_idIndexMarker181"/> from your application that will be used in shaders is one of the most convoluted aspects of Vulkan and requires several steps that need to be accomplished in the right order (and with the right parameters). In this recipe, with many smaller recipes, you will learn how to provide data used in shaders, such as textures, buffers, and samplers.</p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor171"/>Getting ready</h2>
<p>Resources consumed by shaders are specified using the <code>layout</code> keyword, along with <code>set</code> and <code>binding</code> qualifiers:</p>
<pre class="source-code">
layout(set = 0, binding=0) uniform Transforms
{
    mat4 model;
    mat4 view;
    mat4 projection;
} MVP;</pre> <p>Each resource is represented by a binding. A set is a collection of bindings. One binding doesn’t necessarily represent just one resource; it can also represent an array of resources of the <a id="_idIndexMarker182"/>same type.</p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor172"/>How to do it…</h2>
<p>Providing a resource as input to shaders is a multi-step process that involves the following:</p>
<ol>
<li>Specifying sets and their bindings using descriptor set layouts. This step doesn’t associate real resources with sets/bindings. It just specifies the number and types of bindings in a set.</li>
<li>Building a pipeline layout, which describes which sets will be used in a pipeline.</li>
<li>Creating a descriptor pool that will provide instances of descriptor sets. A descriptor pool contains a list of how many bindings it can provide grouped by binding<a id="_idIndexMarker183"/> type (texture, sampler, <strong class="bold">shader storage buffer</strong> (<strong class="bold">SSBO</strong>), uniform buffers).</li>
<li>Allocate descriptor sets from the pool with <code>vkAllocateDescriptorSets</code>.</li>
<li>Bind resources to bindings using <code>vkUpdateDescriptorSets</code>. In this step, we associate a real resource (a buffer, a texture, and so on) with a binding.</li>
<li>Bind descriptor sets and their bindings to a pipeline during rendering using <code>vkCmdBindDescriptorSet</code>. This step makes resources bound to their set/bindings in the previous step available to shaders in the current pipeline.</li>
</ol>
<p>The next recipes <a id="_idIndexMarker184"/>will show you how to perform each one of those steps.</p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor173"/>Specifying descriptor sets with descriptor set layouts</h2>
<p>Consider<a id="_idIndexMarker185"/> the following<a id="_idIndexMarker186"/> GLSL code, which specifies several resources:</p>
<pre class="source-code">
struct Vertex {
    vec3 pos;
    vec2 uv;
    vec3 normal;
};
layout(set = 0, binding=0) uniform Transforms
{
    mat4 model;
    mat4 view;
    mat4 projection;
} MVP;
layout(set = 1, binding = 0) uniform texture2D textures[];
layout(set = 1, binding = 1) uniform sampler   samplers[];
layout(set = 2, binding = 0) readonly buffer VertexBuffer
{
    Vertex vertices[];
} vertexBuffer;</pre> <p>The code requires three sets (0, 1, and 2), so we need to create three descriptor set layouts. In this recipe, you will learn how to create a descriptor set layout for the preceding code.</p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor174"/>Getting ready</h2>
<p>Descriptor sets and bindings are created, stored, and managed by the <code>VulkanCore::Pipeline</code> class in the repository. A descriptor set in Vulkan acts as a container that holds resources, such as buffers, textures, and samplers, for use by shaders. Binding refers to the process of associating these descriptor sets with specific shader stages, enabling seamless interaction between shaders and resources during rendering. These descriptor sets serve as gateways through which resources are seamlessly bound <a id="_idIndexMarker187"/>to shader <a id="_idIndexMarker188"/>stages, orchestrating harmony between data and shader execution. To facilitate this synergy, the class simplifies descriptor set creation and management, complemented by methods for efficient resource binding within the Vulkan rendering pipeline.</p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor175"/>How to do it…</h2>
<p>A descriptor set layout states its bindings (number and types) with the <code>vkDescriptorSetLayout</code> structure. Each binding is described using an instance of the <code>vkDescriptorSetLayoutBinding</code> structure. The relationship between the Vulkan structures needed to create a descriptor set layout for the preceding <a id="_idTextAnchor176"/>code is shown in <em class="italic">Figure 2</em><em class="italic">.11</em>:</p>
<div><div><img alt="Figure 2.11 – Illustrating the configuration of descriptor set layouts for GLSL shaders" src="img/B18491_02_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.11 – Illustrating the configuration of descriptor set layouts for GLSL shaders</p>
<p>The following code <a id="_idIndexMarker189"/>shows<a id="_idIndexMarker190"/> how to specify two bindings for set 1, which are stored in a vector of bindings:</p>
<pre class="source-code">
constexpr uint32_t <strong class="bold">kMaxBindings</strong> = 1000;
const VkDescriptorSetLayoutBinding texBinding = {
    .binding = 0,
    .descriptorType = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
    .descriptorCount = <strong class="bold">kMaxBindings</strong>,
    .stageFlags = VK_SHADER_STAGE_VERTEX_BIT,
};
const VkDescriptorSetLayoutBinding samplerBinding = {
    .binding = 1,
    .descriptorType = VK_DESCRIPTOR_TYPE_SAMPLER,
    .descriptorCount = <strong class="bold">kMaxBindings</strong>,
    .stageFlags = VK_SHADER_STAGE_VERTEX_BIT,
};
struct SetDescriptor {
  uint32_t set_;
  std::vector&lt;VkDescriptorSetLayoutBinding&gt; bindings_;
};
std::vector&lt;SetDescriptor&gt; sets(1);
sets[0].set_ = 1;
sets[0].bindings_.push_back(texBinding);
sets[0].bindings_.push_back(samplerBinding);</pre> <p>Since each binding describes a vector, and the <code>VkDescriptorSetLayoutBinding</code> structure requires the number of descriptors, we are using a large number that hopefully will accommodate all elements we need in the array. The vector of bindings is stored in a structure <a id="_idIndexMarker191"/>that describes<a id="_idIndexMarker192"/> a set with its number and all its bindings. This vector will be used to create a descriptor set layout:</p>
<pre class="source-code">
constexpr VkDescriptorBindingFlags flagsToEnable =
    VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT |
    VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT;
for (size_t setIndex = 0;
     const auto&amp; set : sets) {
  std::vector&lt;VkDescriptorBindingFlags&gt; bindFlags(
      set.bindings_.size(), flagsToEnable);
  const VkDescriptorSetLayoutBindingFlagsCreateInfo
      extendedInfo{
          .sType =
              VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO,
          .pNext = nullptr,
          .bindingCount = static_cast&lt;uint32_t&gt;(
              set.bindings_.size()),
          .pBindingFlags = bindFlags.data(),
      };
  const VkDescriptorSetLayoutCreateInfo dslci = {
      .sType =
          VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
      .pNext = &amp;extendedInfo,
      .flags =
          VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT,
      .bindingCount =
          static_cast&lt;uint32_t&gt;(set.bindings_.size()),
      .pBindings = set.bindings_.data(),
  };
  VkDescriptorSetLayout descSetLayout{VK_NULL_HANDLE};
  VK_CHECK(vkCreateDescriptorSetLayout(
      context_-&gt;device(), &amp;dslci, nullptr,
      &amp;descSetLayout));
}</pre> <p>Each set requires its own descriptor set layout, and the preceding process needs to be repeated for eac<a id="_idIndexMarker193"/>h one. The descriptor<a id="_idIndexMarker194"/> set layout needs to be stored so that it can be referred to in the future.</p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor177"/>Passing data to shaders using push constants</h2>
<p>Push constants <a id="_idIndexMarker195"/>are another way to pass data to<a id="_idIndexMarker196"/> shaders. Although a very performant and easy way to do so, push constants are very limited in size, 128 bytes being the only guaranteed amount by the Vulkan specification.</p>
<p>This recipe will show you how to pass a small amount of data from your application to shaders, using push constants for a simple shader.</p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor178"/>Getting ready</h2>
<p>Push constants are stored and managed by the <code>VulkanCore::Pipeline</code> class.</p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor179"/>How to do it…</h2>
<p>Push constants are recorded directly onto the command buffer and aren’t prone to the same synchronization issues that exist with other resources. They are declared in the shader as follows, with one maximum block per shader:</p>
<pre class="source-code">
layout (<strong class="bold">push_constant</strong>) uniform Transforms {
    mat4 model;
} PushConstants;</pre> <p>The pushed data must be split into the shader stages. Parts of it can be assigned to different shader stages or assigned to one single stage. The important part is that the data cannot be greater than the total amount available for push constants. The limit is provided in <code>VkPhysicalDeviceLimits::maxPushConstantsSize</code>.</p>
<p>Before using push constants, we need to specify how many bytes we are using in each shader stage:</p>
<pre class="source-code">
const VkPushConstantRange range = {
    .stageFlags = VK_SHADER_STAGE_VERTEX_BIT,
    .offset = 0,
    .size = 64,
};
std::vector&lt;VkPushConstantRange&gt; pushConsts;
pushConsts.push_back(range);</pre> <p>The code states that the first (<code>offset == 0</code>) <code>64</code> bytes of the push constant data recorded in the command buffer (the size of a 4x4 matrix of floats) will be used by the vertex shader. This<a id="_idIndexMarker197"/> structure will be used in the<a id="_idIndexMarker198"/> next recipe to create a pipeline layout object.</p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor180"/>Creating a pipeline layout</h2>
<p>A pipeline <a id="_idIndexMarker199"/>layout is an object in Vulkan that needs to be<a id="_idIndexMarker200"/> created and destroyed by the application. The layout is specified using structures that define the layout of bindings and sets. In this recipe, you will learn how to create a pipeline layout.</p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor181"/>Getting ready</h2>
<p>A <code>VkPipelineLayoutCreateInfo</code> instance is created automatically by the <code>VulkanCore::Pipeline</code> class in the repository based on information provided by the application using a vector of <code>VulkanCore::Pipeline::SetDescriptor</code> structures.</p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor182"/>How to do it…</h2>
<p>With all descriptor set layouts for all sets and the push constant information in hand, the next step consists of creating a pipeline layout:</p>
<pre class="source-code">
std::vector&lt;VkDescriptoSetLayout&gt; descLayouts;
const VkPipelineLayoutCreateInfo pipelineLayoutInfo = {
    .sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
    .setLayoutCount = (uint32_t)descLayouts.size(),
    .pSetLayouts = descLayouts.data(),
    .pushConstantRangeCount =
        !pushConsts.empty()
            ? static_cast&lt;uint32_t&gt;(pushConsts.size())
            : 0,
    .pPushConstantRanges = !pushConsts.empty()
                               ? pushConsts.data()
                               : nullptr,
};
VkPipelineLayout pipelineLayout{VK_NULL_HANDLE};
VK_CHECK(vkCreatePipelineLayout(context_-&gt;device(),
                                &amp;pipelineLayoutInfo,
                                nullptr,
                                &amp;pipelineLayout));</pre> <p>Once you have the<a id="_idIndexMarker201"/> descriptor set layout in hand and know<a id="_idIndexMarker202"/> how to use the push constants in your application, creating a pipeline layout is straightforward.</p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor183"/>Creating a descriptor pool</h2>
<p>A descriptor pool <a id="_idIndexMarker203"/>contains a maximum number of <a id="_idIndexMarker204"/>descriptors it can provide (be allocated from), grouped by binding type. For instance, if two bindings of the same set require one image each, the descriptor pool would have to provide at least two descriptors. In this recipe, you will learn how to create a descriptor pool.</p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor184"/>Getting ready</h2>
<p>Descriptor pools are allocated in the <code>VulkanCore::Pipeline:: </code><code>initDescriptorPool()</code> method.</p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor185"/>How to do it…</h2>
<p>Creating a descriptor pool is straightforward. All we need is a list of binding types and the maximum number of resources we’ll allocate for each one:</p>
<pre class="source-code">
constexpr uint32_t swapchainImages = 3;
std::vector&lt;VkDescriptorPoolSize&gt; poolSizes;
poolSizes.emplace_back(VkDescriptorPoolSize{
    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
    swapchainImages* kMaxBindings});
poolSizes.emplace_back(VkDescriptorPoolSize{
    VK_DESCRIPTOR_TYPE_SAMPLER,
    swapchainImages* kMaxBindings});</pre> <p>Since we duplicate the resources based on the number of swapchain images to avoid data races <a id="_idIndexMarker205"/>between the CPU and the GPU, we multiply the <a id="_idIndexMarker206"/>number of bindings we requested before (<code>kMaxBindings = 1000</code>) by the number of swapchain images:</p>
<pre class="source-code">
const VkDescriptorPoolCreateInfo descriptorPoolInfo = {
    .sType =
        VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
    .flags =
        VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT |
        VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT,
    .maxSets = MAX_DESCRIPTOR_SETS,
    .poolSizeCount =
        static_cast&lt;uint32_t&gt;(poolSizes.size()),
    .pPoolSizes = poolSizes.data(),
};
VkDescriptorPool descriptorPool{VK_NULL_HANDLE};
VK_CHECK(vkCreateDescriptorPool(context_-&gt;device(),
                                &amp;descriptorPoolInfo,
                                nullptr,
                                &amp;descriptorPool));</pre> <p>Be careful not to <a id="_idIndexMarker207"/>create pools that are too large. Achieving a<a id="_idIndexMarker208"/> high-performing application means not allocating more resources than you need.</p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor186"/>Allocating descriptor sets</h2>
<p>Once a descriptor <a id="_idIndexMarker209"/>layout and a descriptor pool have been <a id="_idIndexMarker210"/>created, before you can use it, you need to allocate a descriptor set, which is an instance of a set with the layout described by the descriptor layout. In this recipe, you will learn how to allocate a descriptor set.</p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor187"/>Getting ready</h2>
<p>Descriptor set allocations are done in the <code>VulkanCore::Pipeline:: allocateDescriptors()</code> method. Here, developers define the count of descriptor sets required, coupled with binding counts per set. The subsequent <code>bindDescriptorSets()</code> method weaves the descriptors into command buffers, preparing them for shader execution.</p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor188"/>How to do it…</h2>
<p>Allocating a descriptor set (or a number of them) is easy. You need to fill the <code>VkDescriptorSetAllocateInfo</code> structure and call <code>vkAllocateDescriptorSets</code>:</p>
<pre class="source-code">
VkDescriptorSetAllocateInfo allocInfo = {
    .sType =
        VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
    .descriptorPool = descriptorPool,
    .descriptorSetCount = 1,
    .pSetLayouts = &amp;descSetLayout,
};
VkDescriptorSet descriptorSet{VK_NULL_HANDLE};
VK_CHECK(vkAllocateDescriptorSets(context_-&gt;device(),
                                  &amp;allocInfo,
                                  &amp;descriptorSet));</pre> <p>When using multiple copies of a resource to avoid race conditions, there are two approaches:</p>
<ol>
<li>Allocate one descriptor set for each resource. In other words, call the preceding code once for each copy of the resource.</li>
<li>Create one<a id="_idIndexMarker211"/> descriptor set and update it<a id="_idIndexMarker212"/> every time you need to render.</li>
</ol>
<h2 id="_idParaDest-163"><a id="_idTextAnchor189"/>Updating descriptor sets during rendering</h2>
<p>Once a descriptor<a id="_idIndexMarker213"/> set has been allocated, it is<a id="_idIndexMarker214"/> not associated with any resources. This association must happen once (if your descriptor sets are immutable) or every time you need to bind a different resource to a descriptor set. In this recipe, you will learn how to update descriptor sets during rendering and after you have set up the pipeline and its layout.</p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor190"/>Getting ready</h2>
<p>In the repository, <code>VulkanCore::Pipeline</code> provides methods to update different types of resources, as each binding can only be associated with one type of resource (image, sampler, or buffer): <code>updateSamplersDescriptorSets()</code>, <code>updateTexturesDescriptorSets()</code>, and <code>updateBuffersDescriptorSets</code><code>()</code>.</p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor191"/>How to do it…</h2>
<p>Associating a resource with a descriptor set is done with the <code>vkUpdateDescriptorSets</code> function. Each call to <code>vkUpdateDescriptorSets</code> can update one or more bindings of one or more sets. Before updating a descriptor set, let’s look at how to update <em class="italic">one</em> binding.</p>
<p>You can associate either a texture, a texture array, a sampler, a sampler array, a buffer, or a buffer array with one binding. To associate images or samplers, use the <code>VkDescriptorImageInfo</code> structure. To associate buffers, use the <code>VkDescriptorBufferInfo</code> structure. Once one or more of those structures have been instantiated, use the <code>VkWriteDescriptorSet</code> structure to bind them all with a binding. Bindings that represent an array are updated with a vector of <code>VkDescriptor*Info</code>.</p>
<ol>
<li>Consider the bindings declared in the shader code presented next:<pre class="source-code">
layout(set = 1, binding = 0) uniform texture2D textures[];
layout(set = 1, binding = 1) uniform sampler   samplers[];
layout(set = 2, binding = 0) readonly buffer VertexBuffer
{
  Vertex vertices[];
} vertexBuffer;</pre></li> <li>To <a id="_idIndexMarker215"/>update <a id="_idIndexMarker216"/>the <code>textures[]</code> array, we need to create two instances of <code>VkDescriptorImageInfo</code> and record them in the first <code>VkWriteDescriptorSet</code> structure:<pre class="source-code">
VkImageView imageViews[2];  // Valid Image View objects
VkDescriptorImageInfo texInfos[] = {
 VkDescriptorImageInfo{
  .imageView = imageViews[0],
  .imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
    },
 VkDescriptorImageInfo{
  .imageView = imageViews[1],
  .imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
 },
};
const VkWriteDescriptorSet texWriteDescSet = {
    .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
    .dstSet = 1,
    ee,
    .dstArrayElement = 0,
    .descriptorCount = 2,
    .descriptorType = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
    .pImageInfo = &amp;texInfos,
    .pBufferInfo = nullptr,
};</pre></li> <li>The two image views<a id="_idIndexMarker217"/> will be<a id="_idIndexMarker218"/> bound to set 1 (<code>.dstSet = 1</code>) and binding 0 (<code>.dstBinding = 0</code>) as elements 0 and 1 of the array. If you need to bind more objects to the array, all you need are more instances of <code>VkDescriptorImageInfo</code>. The number of objects bound to the current binding is specified by the <code>descriptorCount</code> member of the structure.<p class="list-inset">The process is similar for sampler objects:</p><pre class="source-code">
VkSampler sampler[2];  // Valid Sampler object
VkDescriptorImageInfo samplerInfos[] = {
    VkDescriptorImageInfo{
        .sampler = sampler[0],
    },
    VkDescriptorImageInfo{
        .sampler = sampler[1],
    },
};
const VkWriteDescriptorSet samplerWriteDescSet = {
    .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
    .dstSet = 1,
    .dstBinding = 1,
    .dstArrayElement = 0,
    .descriptorCount = 2,
    .descriptorType = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
    .pImageInfo = &amp;samplerInfos,
    .pBufferInfo = nullptr,
};</pre><p class="list-inset">This time, we <a id="_idIndexMarker219"/>are binding the <a id="_idIndexMarker220"/>sampler objects to set 1, binding 1. Buffers are bound using the <code>VkDescriptorBufferInfo</code> structure:</p><pre class="source-code">VkBuffer buffer;            // Valid Buffer object
VkDeviceSize bufferLength;  // Range of the buffer
const VkDescriptorBufferInfo bufferInfo = {
    .buffer = buffer,
    .offset = 0,
    .range = bufferLength,
};
const VkWriteDescriptorSet bufferWriteDescSet = {
  .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
  <strong class="bold">.dstSet = 2,</strong>
  <strong class="bold">.dstBinding = 0,</strong>
  .dstArrayElement = 0,
  <strong class="bold">.descriptorCount = 1,</strong>
  .descriptorType = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
  .pImageInfo = nullptr,
  .pBufferInfo = &amp;bufferInfo,
};</pre><p class="list-inset">Besides storing the address of the <code>bufferInfo</code> variable to the <code>.pBufferInfo</code> member of <code>VkWriteDescriptorSet</code>, we are binding one buffer (<code>.descriptorCount = 1</code>) to set 2 (<code>.dstSet = 2</code>) and binding <code>0 </code>(<code>.dstBinding = </code><code>0</code>).</p></li> <li>The last<a id="_idIndexMarker221"/> step <a id="_idIndexMarker222"/>consists of storing all <code>VkWriteDescriptorSet</code> instances in a vector and calling <code>vkUpdateDescriptorSets</code>:<pre class="source-code">
VkDevice device; // Valid Vulkan Device
std::vector&lt;VkWriteDescriptorSet&gt; writeDescSets;
writeDescSets.push_back(texWriteDescSet);
writeDescSets.push_back(samplerWriteDescSet);
writeDescSets.push_back(bufferWriteDescSet);
vkUpdateDescriptorSets(device, static_cast&lt;uint32_t&gt;(writeDescSets.size()),
                      writeDescSets.data(), 0, nullptr);</pre></li> </ol>
<p>Encapsulating this task is the best way to avoid repetition and bugs introduced by forgetting a step in<a id="_idIndexMarker223"/> the update <a id="_idIndexMarker224"/>procedure.</p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor192"/>Passing resources to shaders (binding descriptor sets)</h2>
<p>While rendering, we<a id="_idIndexMarker225"/> need to bind the descriptor sets we’d like to use during a draw call.</p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor193"/>Getting ready</h2>
<p>Binding sets is done with the <code>VulkanCore::Pipeline:: </code><code>bindDescriptorSets()</code> method.</p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor194"/>How to do it…</h2>
<p>To bind a descriptor set for rendering, we need to call <code>vkCmdBindDescriptorSets</code>:</p>
<pre class="source-code">
VkCommandBuffer commandBuffer;   // Valid Command Buffer
VkPipelineLayout pipelineLayout; // Valid Pipeline layout
uint32_t set;                    // Set number
VkDescriptorSet descSet;         // Valid Descriptor Set
vkCmdBindDescriptorSets(
    commandBuffer, <strong class="bold">VK_PIPELINE_BIND_POINT_GRAPHICS</strong>,
    pipelineLayout, set, 1u, &amp;descSet, 0, nullptr);</pre> <p>Now that we’ve successfully bound a descriptor set for rendering, let’s turn our attention to another crucial aspect of our graphics pipeline: updating push constants.</p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor195"/>Updating push constants during rendering</h2>
<p>Push constants <a id="_idIndexMarker226"/>are updated during <a id="_idIndexMarker227"/>rendering by recording their values directly into the command buffer being recorded.</p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor196"/>Getting ready</h2>
<p>Updating push constants is done with the <code>VulkanCore::Pipeline:: </code><code>udpatePushConstants()</code> method.</p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor197"/>How to do it…</h2>
<p>Once rendered, updating push constants is straightforward. All you need to do is call <code>vkCmdPushConstants</code>:</p>
<pre class="source-code">
VkCommandBuffer commandBuffer;   // Valid Command Buffer
VkPipelineLayout pipelineLayout; // Valid Pipeline Layout
glm::vec4 mat;                   // Valid matrix
vkCmdPushConstants(commandBuffer, pipelineLayout,
                   VK_SHADER_STAGE_FRAGMENT_BIT, 0,
                   sizeof(glm::vec4), &amp;mat);</pre> <p>This call records the contents of <code>mat</code> into the command buffer, starting at offset 0 and signaling that this data will be used by the vertex shader.</p>
<h1 id="_idParaDest-172"><a id="_idTextAnchor198"/>Customizing shader behavior with specialization constants</h1>
<p>The process of <a id="_idIndexMarker228"/>compiling shader code results in immutability once completed. The compilation procedure carries a substantial time overhead and is generally circumvented during runtime. Even minor adjustments to a shader necessitate recompilation, leading to the creation of a fresh shader module and potentially a new pipeline as well – all entailing significant resource-intensive operations.</p>
<p>In Vulkan, specialization constants allow you to specify constant values for shader parameters at pipeline creation time, instead of having to recompile the shader with new values every time you want to change them. This can be particularly useful when you want to reuse the same shader with different constant values multiple times. In this recipe, we will delve deeper into the practical application of specialization constants in Vulkan to create more efficient and flexible shader programs, allowing you to adjust without the need for resource-intensive recompilations.</p>
<h2 id="_idParaDest-173"><a id="_idTextAnchor199"/>Getting ready</h2>
<p>Specialization constants are available in the repository through the <code>VulkanCore::Pipeline::GraphicsPipelineDescriptor</code> structure. You need to provide a vector of <code>VkSpecializationMapEntry</code> structures for each shader type <a id="_idIndexMarker229"/>you’d like to apply specialization constants to.</p>
<h2 id="_idParaDest-174"><a id="_idTextAnchor200"/>How to do it…</h2>
<p>Specialization constants are declared in GLSL using the <code>constant_id</code> qualifier along with an integer that specifies the constant’s ID:</p>
<pre class="source-code">
layout (<code>VkSpecializationInfo</code> structure that specifies the constant values and their IDs. You then pass this structure to the <code>VkPipelineShaderStageCreateInfo</code> structure when creating a pipeline:</p>
<pre class="source-code">
const bool kUseShaderDebug = false;
const VkSpecializationMapEntry useShaderDebug = {
    .constantID = 0, // matches the <strong class="bold">constant_id</strong> qualifier
    .offset = 0,
    .size = sizeof(bool),
};
const VkSpecializationInfo vertexSpecializationInfo = {
    .mapEntryCount = 1,
    .pMapEntries = &amp;useShaderDebug,
    .dataSize = sizeof(bool),
    .pData = &amp;kUseShaderDebug,
};
const VkPipelineShaderStageCreateInfo shaderStageInfo = {
  ...
  .pSpecializationInfo = &amp;vertexSpecializationInfo,
};</pre> <p>Because specialization constants are real constants, branches that depend on them may be entirely removed during the final compilation of the shader. On the other hand, specialization constants should not be used to control parameters such as uniforms, as they are not as <a id="_idIndexMarker230"/>flexible and require to be known during the construction of the pipeline.</p>
<h1 id="_idParaDest-175"><a id="_idTextAnchor201"/>Implementing MDI and PVP</h1>
<p>MDI and PVP<a id="_idIndexMarker231"/> are features of modern graphics APIs <a id="_idIndexMarker232"/>that allow for greater flexibility and efficiency in vertex processing.</p>
<p>MDI allows issuing multiple draw calls with a single command, each of which derives its parameters from a buffer stored in the device (hence the <em class="italic">indirect</em> term). This is particularly useful because those parameters can be modified in the GPU itself.</p>
<p>With PVP, each shader instance retrieves its vertex data based on its index and instance IDs instead of being initialized with the vertex’s attributes. This allows for flexibility because the vertex attributes and their format are not baked into the pipeline and can be changed solely based on the shader code.</p>
<p>In the first sub-recipe, we will focus on the implementation of <strong class="bold">MDI</strong>, demonstrating how this powerful tool can streamline your graphics operations by allowing multiple draw calls to be issued from a single command, with parameters that can be modified directly in the GPU. In the following sub-recipe, we will guide you through the process of setting up <strong class="bold">PVP</strong>, highlighting how the flexibility of this feature can enhance your shader code by enabling changes <a id="_idIndexMarker233"/>to <a id="_idIndexMarker234"/>vertex attributes without modifying the pipeline.</p>
<h2 id="_idParaDest-176"><a id="_idTextAnchor202"/>Implementing MDI</h2>
<p>For using MDI, we<a id="_idIndexMarker235"/> store all mesh data belonging to the scene in one big buffer for all the meshes’ vertices and another one for the meshes’ indices, with the data for each mesh stored sequentially, as depicted in <em class="italic">Figure 2</em><em class="italic">.12</em>.</p>
<p>The drawing parameters are stored in an extra buffer. They must be stored sequentially, one for each<a id="_idTextAnchor203"/> mesh, although they don’t have to be provided in the same order as the meshes:</p>
<div><div><img alt="Figure 2.12 – MDI data layout" src="img/B18491_02_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.12 – MDI data layout</p>
<p>We will now learn how to implement MDI using the Vulkan API.</p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor204"/>Getting ready</h2>
<p>In the repository, we <a id="_idIndexMarker236"/>provide a utility function to decompose an <code>EngineCore::Model</code> object into multiple buffers suitable for an MDI implementation, called <code>EngineCore::convertModel2OneBuffer()</code>, located in <code>GLBLoader.cpp</code>.</p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor205"/>How to do it…</h2>
<p>Let’s begin by looking at the indirect draw parameters’ buffer.</p>
<p>The commands are stored following the same layout as the <code>VkDrawIndexedIndirectCommand</code> structure:</p>
<pre class="source-code">
typedef struct VkDrawIndexedIndirectCommand {
    uint32_t    indexCount;
    uint32_t    instanceCount;
    uint32_t    firstIndex;
    int32_t     vertexOffset;
    uint32_t    firstInstance;
} VkDrawIndexedIndirectCommand;</pre> <p><code>indexCount</code> specifies how many indices are part of this command and, in our case, is the number of indices for a mesh. One command reflects one mesh, so its <code>instanceCount</code> value is one. The <code>firstVertex</code> member is the index of the first index element in the buffer to use for this mesh, while <code>vertexOffset</code> points to the first vertex element<a id="_idIndexMarker237"/> in the buffer to use. An example with the correct offsets is shown in <em class="italic">Figure 2</em><em class="italic">.12</em>.</p>
<p>Once the vertex, index, and indirect commands buffers are bound, calling <code>vkCmdDrawIndexedIndirect</code> consists of providing the buffer with the indirect commands and an offset into the buffer. The rest is done by the device:</p>
<pre class="source-code">
VkCommandBuffer commandBuffer;  // Valid Command Bufer
VkBuffer indirectCmdBuffer;     // Valid buffer w/
                                // indirect commands
uint32_t meshCount;  // Number of indirect commands in
                     // the buffer
uint32_t offset = 0; // Offset into the indirect commands
                     // buffer
vkCmdDrawIndexedIndirect(
    commandBuffer, indirectCmdBuffer, offset,
    meshCount,
    sizeof(VkDrawIndexedIndirectDrawCommand));</pre> <p>In this recipe, we learned how to utilize <code>vkCmdDrawIndexedIndirect</code>, a key function in <a id="_idIndexMarker238"/>Vulkan that allows for high-efficiency drawing.</p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor206"/>Using PVP</h2>
<p>The PVP technique<a id="_idIndexMarker239"/> allows vertex data and their attributes to be extracted from buffers with custom code instead of relying on the pipeline to provide them to vertex shaders.</p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor207"/>Getting ready</h2>
<p>We will use the following structures to perform the extraction of vertex data – the <code>Vertex</code> structure, which encodes the vertex’s position (<code>pos</code>), <code>normal</code>, UV coordinates (<code>uv</code>), and its material index (<code>material</code>):</p>
<pre class="source-code">
struct Vertex {
    vec3 pos;
    vec3 normal;
    vec2 uv;
    int material;
};</pre> <p>We will also use a buffer object, referred to in the shader as <code>VertexBuffer</code>:</p>
<pre class="source-code">
layout(set = 2, binding = 0) readonly buffer VertexBuffer
{
    Vertex vertices[];
} vertexBuffer;</pre> <p>Next, we will learn how to use the <code>vertexBuffer</code> object to access vertex data.</p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor208"/>How to do it…</h2>
<p>The shader code used to access the vertex data looks like this:</p>
<pre class="source-code">
void main() {
  Vertex vertex = vertexBuffer.vertices[gl_VertexIndex];
}</pre> <p>Note that the vertex and its attributes are not declared as inputs to the shader. <code>gl_VertexIndex</code> is automatically computed and provided to the shader based on the draw call and the parameters recorded in the indirect command retrieved from the indirect command<a id="_idIndexMarker240"/> buffer.</p>
<p class="callout-heading">Index and vertex buffers</p>
<p class="callout">Note that both the index and vertex buffers are still provided and bound to the pipeline before the draw call is issued. The index buffer must have the <code>VK_BUFFER_USAGE_INDEX_BUFFER_BIT</code> flag enabled for the technique to work.</p>
<h1 id="_idParaDest-182"><a id="_idTextAnchor209"/>Adding flexibility to the rendering pipeline using dynamic rendering</h1>
<p>In this recipe, we <a id="_idIndexMarker241"/>will delve into<a id="_idIndexMarker242"/> the practical application of dynamic rendering in Vulkan to enhance the flexibility of the rendering pipeline. We will guide you through the process of creating pipelines without the need for render passes and framebuffers and discuss how to ensure synchronization. By the end of this section, you will have learned how to implement this feature in your projects, thereby simplifying your rendering process by eliminating the need for render passes and framebuffers and giving you more direct control over synchronization.</p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor210"/>Getting ready</h2>
<p>To enable the feature, we must have access to the <code>VK_KHR_get_physical_device_properties2</code> instance extension, instantiate a structure of type <code>VkPhysicalDeviceDynamicRenderingFeatures</code>, and set its <code>dynamicRendering</code> member to <code>true</code>:</p>
<pre class="source-code">
const VkPhysicalDeviceDynamicRenderingFeatures dynamicRenderingFeatures = {
      .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES,
      .dynamicRendering = VK_TRUE,
  };</pre> <p>This structure needs to be plugged into the <code>VkDeviceCreateInfo::pNext</code> member when creating a Vulkan device:</p>
<pre class="source-code">
const VkDeviceCreateInfo dci = {
    .sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
    .pNext = &amp;dynamicRenderingFeatures,
    ...
};</pre> <p>Having grasped<a id="_idIndexMarker243"/> the <a id="_idIndexMarker244"/>concept of enabling dynamic rendering, we will now move forward and explore its implementation using the Vulkan API.</p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor211"/>How to do it…</h2>
<p>Instead of creating render passes and framebuffers, we must call the <code>vkCmdBeginRendering</code> command and provide the attachments and their load and store operations using the <code>VkRenderingInfo</code> structure. Each attachment (colors, depth, and stencil) must be specified with instances of the <code>VkRenderingAttachmentInfo</code> structure. <em class="italic">Figure 2</em><em class="italic">.13</em> <a id="_idTextAnchor212"/>presents a diagram of the structure participating in a call to <code>vkCmdBeginRendering</code>:</p>
<div><div><img alt="Figure 2.13 – Dynamic rendering structure diagram" src="img/B18491_02_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.13 – Dynamic rendering structure diagram</p>
<p>Any one of the attachments, <code>pColorAttachments</code>, <code>pDepthAttachment</code>, and <code>pStencilAttachment</code>, can be <code>null</code>. Shader output written to location <code>x</code> is written to the <a id="_idIndexMarker245"/>color<a id="_idIndexMarker246"/> attachment at <code>pColorAttachment[x]</code>.</p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor213"/>Transferring resources between queue families</h1>
<p>In this recipe, we <a id="_idIndexMarker247"/>will demonstrate <a id="_idIndexMarker248"/>how to transfer resources between queue families by uploading textures to a device from the CPU using a transfer queue and generating mip-level data in a graphics queue. Generating mip levels needs a graphics queue because it utilizes <code>vkCmdBlitImage</code>, supported only by graphics queues.</p>
<h2 id="_idParaDest-186"><a id="_idTextAnchor214"/>Getting ready</h2>
<p>An example is provided in the repository in <code>chapter2/mainMultiDrawIndirect.cpp</code>, which uses the <code>EngineCore::AsyncDataUploader</code> class to perform texture upload and mipmap generation on different queues.</p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor215"/>How to do it…</h2>
<p>In the following diagram, we illustrate the procedure of uploading texture through <a id="_idTextAnchor216"/>a transfer queue, followed<a id="_idIndexMarker249"/> by the utilization of a graphics<a id="_idIndexMarker250"/> queue for mip generation:</p>
<div><div><img alt="Figure 2.14 – Recoding and submitting commands from different threads and transferring a resource between queues from different families" src="img/B18491_02_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.14 – Recoding and submitting commands from different threads and transferring a resource between queues from different families</p>
<p>The process can be summarized as follows:</p>
<ol>
<li>Record the commands to upload the texture to the device and add a barrier to release the texture from the transfer queue using the <code>VkDependencyInfo</code> and <code>VkImageMemoryBarrier2</code> structures, specifying the source queue family as the family of the transfer queue and the destination queue family as the family of the graphics queue.</li>
<li>Create a semaphore and use it to signal when the command buffer finishes, and attach it to the submission of the command buffer.</li>
<li>Create a command buffer for generating mip levels and add a barrier to acquire the texture from the transfer queue into the graphics queue using the <code>VkDependencyInfo</code> and <code>VkImageMemoryBarrier2</code> structures.</li>
<li>Attach the semaphore created in <em class="italic">step 2</em> to the <code>SubmitInfo</code> structure when submitting the command buffer for processing. The semaphore will be signaled when the first command buffer has completed, allowing the mip-level-generation command buffer to start.<p class="list-inset">Two<a id="_idIndexMarker251"/> auxiliary <a id="_idIndexMarker252"/>methods will help us create acquire and release barriers for a texture. They exist in the <code>VulkanCore::Texture</code> class. The first one creates an acquire barrier:</p><pre class="source-code">
void Texture::addAcquireBarrier(
    VkCommandBuffer cmdBuffer,
    uint32_t srcQueueFamilyIndex,
    uint32_t dstQueueFamilyIndex) {
  VkImageMemoryBarrier2 acquireBarrier = {
      .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2,
      .dstStageMask =
          VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,
      .dstAccessMask = VK_ACCESS_2_MEMORY_READ_BIT,
      .srcQueueFamilyIndex = srcQueueFamilyIndex,
      .dstQueueFamilyIndex = dstQueueFamilyIndex,
      .image = image_,
      .subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT,
                           0, mipLevels_, 0, 1},
  };
  VkDependencyInfo dependency_info{
      .sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO,
      .imageMemoryBarrierCount = 1,
      .pImageMemoryBarriers = &amp;acquireBarrier,
  };
  vkCmdPipelineBarrier2(cmdBuffer, &amp;dependency_info);
}</pre><p class="list-inset">Besides the command buffer, this function requires the indices of the source and destination family queues. It also assumes a few things, such as the subresource range spanning the entire image.</p></li> <li>Another<a id="_idIndexMarker253"/> method <a id="_idIndexMarker254"/>records the release barrier:<pre class="source-code">
void Texture::addReleaseBarrier(
    VkCommandBuffer cmdBuffer,
    uint32_t srcQueueFamilyIndex,
    uint32_t dstQueueFamilyIndex) {
  VkImageMemoryBarrier2 releaseBarrier = {
      .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2,
      .srcStageMask = VK_PIPELINE_STAGE_2_TRANSFER_BIT,
      .srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT,
      .dstAccessMask = VK_ACCESS_SHADER_READ_BIT,
      .srcQueueFamilyIndex = srcQueueFamilyIndex,
      .dstQueueFamilyIndex = dstQueueFamilyIndex,
      .image = image_,
      .subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT,
                           0, mipLevels_, 0, 1},
  };
  VkDependencyInfo dependency_info{
      .sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO,
      .imageMemoryBarrierCount = 1,
      .pImageMemoryBarriers = &amp;releaseBarrier,
  };
  vkCmdPipelineBarrier2(cmdBuffer, &amp;dependency_info);
}</pre><p class="list-inset">This method makes the same assumptions as the previous one. The main differences are the source and destination stages and access masks.</p></li> <li>To perform<a id="_idIndexMarker255"/> the<a id="_idIndexMarker256"/> upload and mipmap generation, we create two instances of <code>VulkanCore::CommandQueueManager</code>, one for the transfer queue and another for the graphics queue:<pre class="source-code">
auto transferQueueMgr =
    context.createTransferCommandQueue(
        1, 1, "transfer queue");
auto graphicsQueueMgr =
    context.createGraphicsCommandQueue(
        1, 1, "graphics queue");</pre></li> <li>With valid <code>VulkanCore::Context</code> and <code>VulkanCore::Texture</code> instances in hand, we can upload the texture by retrieving a command buffer from the<a id="_idIndexMarker257"/> transfer<a id="_idIndexMarker258"/> family. We also create a staging buffer for transferring the texture data to device-local memory:<pre class="source-code">
VulkanCore::Context context;  // Valid Context
std::shared_ptr&lt;VulkanCore::Texture&gt;
    texture;        // Valid Texture
void* textureData;  // Valid texture data
// Upload texture
auto textureUploadStagingBuffer =
    context.createStagingBuffer(
        texture-&gt;vkDeviceSize(),
        VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
        "texture upload staging buffer");
const auto commandBuffer =
    transferQueueMgr.getCmdBufferToBegin();
texture-&gt;uploadOnly(commandBuffer,
                    textureUploadStagingBuffer.get(),
                    textureData);
texture-&gt;addReleaseBarrier(
    commandBuffer,
    transferQueueMgr.queueFamilyIndex(),
    graphicsQueueMgr.queueFamilyIndex());
transferQueueMgr.endCmdBuffer(commandBuffer);
transferQueueMgr.disposeWhenSubmitCompletes(
    std::move(textureUploadStagingBuffer));</pre></li> <li>For submitting the command buffer for processing, we create a semaphore to synchronize the<a id="_idIndexMarker259"/> upload<a id="_idIndexMarker260"/> command buffer and the one used for generating mipmaps:<pre class="source-code">
VkSemaphore graphicsSemaphore;
const VkSemaphoreCreateInfo semaphoreInfo{
    .sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
};
VK_CHECK(vkCreateSemaphore(context.device(),
                            &amp;semaphoreInfo, nullptr,
                            &amp;graphicsSemaphore));
VkPipelineStageFlags flags =
    VK_PIPELINE_STAGE_TRANSFER_BIT;
auto submitInfo =
    context.swapchain()-&gt;createSubmitInfo(
        &amp;commandBuffer, &amp;flags, false, false);
submitInfo.signalSemaphoreCount = 1;
submitInfo.pSignalSemaphores = &amp;graphicsSemaphore;
transferQueueMgr.submit(&amp;submitInfo);</pre></li> <li>The next step is to acquire a new command buffer from the graphics queue family for generating mipmaps. We also create an acquire barrier and reuse the semaphore from the previous command buffer submission:<pre class="source-code">
// Generate mip levels
auto commandBuffer =
    graphicsQueueMgr.getCmdBufferToBegin();
texture-&gt;addAcquireBarrier(
    commandBuffer,
    transferCommandQueueMgr_.queueFamilyIndex(),
    graphicsQueueMgr.queueFamilyIndex());
texture-&gt;generateMips(commandBuffer);
graphicsQueueMgr.endCmdBuffer(commandBuffer);
VkPipelineStageFlags flags =
    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
auto submitInfo =
    context_.swapchain()-&gt;createSubmitInfo(
        &amp;commandBuffer, &amp;flags, false, false);
submitInfo.pWaitSemaphores = &amp;graphicsSemaphore;
submitInfo.waitSemaphoreCount = 1;</pre></li> </ol>
<p>In this chapter, we <a id="_idIndexMarker261"/>have<a id="_idIndexMarker262"/> navigated the complex landscape of advanced Vulkan programming, building upon the foundational concepts introduced earlier. Our journey encompassed a diverse range of topics, each contributing crucial insights to the realm of high-performance graphics applications. From mastering Vulkan’s intricate memory model and efficient allocation techniques to harnessing the power of the VMA library, we’ve equipped ourselves with the tools to optimize memory management. We explored the creation and manipulation of buffers and images, uncovering strategies for seamless data uploads, staging buffers, and ring-buffer implementations that circumvent data races. The utilization of pipeline barriers to synchronize data access was demystified, while techniques for rendering pipelines, shader customization via specialization constants, and cutting-edge rendering methodologies such as PVP and MDI were embraced. Additionally, we ventured into dynamic rendering approaches without relying on render passes and addressed the intricacies of <a id="_idIndexMarker263"/>resource<a id="_idIndexMarker264"/> handling across multiple threads and queues. With these profound understandings, you are primed to create graphics applications that harmonize technical prowess with artistic vision using the Vulkan API.</p>
</div>
</body></html>