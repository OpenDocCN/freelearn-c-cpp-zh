<html><head></head><body>
<div id="_idContainer032">
<h1 class="chapter-number" id="_idParaDest-113"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-114"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.2.1">Working with Modern Vulkan</span></h1>
<p><span class="koboSpan" id="kobo.3.1">The goal of this chapter is to show you how to render a scene that accepts input information, such as textures and uniform data, from the application side. </span><span class="koboSpan" id="kobo.3.2">This chapter will cover advanced topics in the Vulkan API that build upon the core concepts discussed in the previous chapter and present all the information you need to render complex scenes, along with newer features of the API. </span><span class="koboSpan" id="kobo.3.3">Additionally, the chapter will demonstrate techniques to enhance the </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">rendering speed.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we’re going to cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">following recipes:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Understanding Vulkan’s </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">memory model</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Instantiating the </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">VMA library</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.11.1">Creating buffers</span></span></li>
<li><span class="koboSpan" id="kobo.12.1">Uploading data </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">to buffers</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Creating a </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">staging buffer</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">How to avoid data races using </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">ring buffers</span></span></li>
<li><span class="koboSpan" id="kobo.18.1">Setting up </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">pipeline barriers</span></span></li>
<li><span class="koboSpan" id="kobo.20.1">Creating </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">images (textures)</span></span></li>
<li><span class="koboSpan" id="kobo.22.1">Creating an </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">image view</span></span></li>
<li><span class="koboSpan" id="kobo.24.1">Creating </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">a sampler</span></span></li>
<li><span class="koboSpan" id="kobo.26.1">Providing </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">shader data</span></span></li>
<li><span class="koboSpan" id="kobo.28.1">Customizing shader behavior with </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">specialization constants</span></span></li>
<li><span class="koboSpan" id="kobo.30.1">Implementing MDI </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">and PVP</span></span></li>
<li><span class="koboSpan" id="kobo.32.1">Adding flexibility to the rendering pipeline using </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">dynamic rendering</span></span></li>
<li><span class="koboSpan" id="kobo.34.1">Transferring resources between </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">queue families</span></span></li>
</ul>
<h1 id="_idParaDest-115"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.36.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.37.1">For this chapter, you will need to make sure you have VS 2022 installed along with the Vulkan SDK. </span><span class="koboSpan" id="kobo.37.2">Basic familiarity with the C++ programming language and an understanding of OpenGL or any other graphics API will be useful. </span><span class="koboSpan" id="kobo.37.3">Please revisit </span><a href="B18491_01.xhtml#_idTextAnchor019"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.38.1">Chapter 1</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.39.1">, Vulkan Core Concepts</span></em><span class="koboSpan" id="kobo.40.1">, under the </span><em class="italic"><span class="koboSpan" id="kobo.41.1">Technical requirements</span></em><span class="koboSpan" id="kobo.42.1"> section for details on setting up and building executables for this chapter. </span><span class="koboSpan" id="kobo.42.2">The recipe for this chapter can be run by launching </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.43.1">Chapter02_MultiDrawIndirect.exe</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.44.1"> executable.</span></span></p>
<h1 id="_idParaDest-116"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.45.1">Understanding Vulkan’s memory model</span></h1>
<p><span class="koboSpan" id="kobo.46.1">Memory allocation </span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.47.1">and management are crucial in Vulkan, as almost none of the details of memory usage are managed by Vulkan. </span><span class="koboSpan" id="kobo.47.2">Except for deciding the exact memory address where memory should be allocated, all other details are the responsibility of the application. </span><span class="koboSpan" id="kobo.47.3">This means the programmer must manage memory types, their sizes, and alignments, as well as any sub-allocations. </span><span class="koboSpan" id="kobo.47.4">This approach gives applications more control over memory management and allows developers to optimize their programs for specific uses. </span><span class="koboSpan" id="kobo.47.5">This recipe will provide some fundamental information about the types of memory provided by the API as well as a summary of how to allocate and bind that memory </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">to resources.</span></span></p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.49.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.50.1">Graphics cards come in two variants, integrated and discrete. </span><span class="koboSpan" id="kobo.50.2">Integrated graphics cards share the same memory as the CPU, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.51.1">Figure 2</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.52.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer018">
<span class="koboSpan" id="kobo.54.1"><img alt="﻿Figure 2.1 – Typical memory architecture for discrete graphics cards" src="image/B18491_02_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.55.1">Figure 2.1 – Typical memory architecture for discrete graphics cards</span></p>
<p><span class="koboSpan" id="kobo.56.1">Discrete graphics cards have their own memory (device memory) separate from the main memory (host memory), as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.57.1">Figure 2</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.58.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer019">
<span class="koboSpan" id="kobo.60.1"><img alt="F﻿igure 2.2 – Typical memory architecture for integrated graphics cards" src="image/B18491_02_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.61.1">F</span><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.62.1">igure 2.2 – Typical memory architecture for integrated graphics cards</span></p>
<p><span class="koboSpan" id="kobo.63.1">Vulkan provides different types </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">of memory:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.65.1">Device-local memory</span></strong><span class="koboSpan" id="kobo.66.1">: This type</span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.67.1"> of memory is optimized for use by the GPU and is local to the device. </span><span class="koboSpan" id="kobo.67.2">It is typically faster than host-visible memory but is not accessible from the CPU. </span><span class="koboSpan" id="kobo.67.3">Usually, resources such as render targets, storage images, and buffers are stored in </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">this memory.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.69.1">Host-visible memory</span></strong><span class="koboSpan" id="kobo.70.1">: This type of memory is accessible from both the GPU and the CPU. </span><span class="koboSpan" id="kobo.70.2">It is typically slower than device-local memory but allows for efficient data transfer between the GPU and CPU. </span><span class="koboSpan" id="kobo.70.3">Reads from GPU to CPU happen </span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.71.1">across </span><strong class="bold"><span class="koboSpan" id="kobo.72.1">Peripheral Component Interconnect Express</span></strong><span class="koboSpan" id="kobo.73.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.74.1">PCI-E</span></strong><span class="koboSpan" id="kobo.75.1">) lanes in the case of non-integrated GPU. </span><span class="koboSpan" id="kobo.75.2">It’s typically used to set up staging buffers, where data is stored before being transferred to device-local memory, and uniform buffers, which are constantly updated from </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">the application.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.77.1">Host-coherent memory</span></strong><span class="koboSpan" id="kobo.78.1">: This type of memory is like host-visible memory but provides guaranteed memory consistency between the GPU and CPU. </span><span class="koboSpan" id="kobo.78.2">This type of memory is typically slower than both device-local and host-visible memory but is useful for storing data that needs to be frequently updated by both the GPU </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">and CPU.</span></span></li>
</ul>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.80.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.81.1">.3</span></em><span class="koboSpan" id="kobo.82.1"> summarizes </span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.83.1">the three aforementioned types of memory. </span><span class="koboSpan" id="kobo.83.2">Device-local memory is not visible from the host, while host-coherent and host-visible are. </span><span class="koboSpan" id="kobo.83.3">Copying data from the CPU to the GPU can be done using mapped memory for those two types of memory allocations. </span><span class="koboSpan" id="kobo.83.4">For device-local memory, it’s necessary to copy the data from the CPU to host-visible memory first using mapped memory (the staging buffer), and then perform a copy of the data from the staging buffer to the destination, the device-local memory, using a </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">Vulkan function:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer020">
<span class="koboSpan" id="kobo.85.1"><img alt="Figure 2.3 – Types of memory and their visibility from the application in Vulkan" src="image/B18491_02_03.jpg"/></span>
</div>
</div>
<p class="IMG---Figure"><a id="_idTextAnchor133"/></p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.86.1">Figure 2.3 – Types of memory and their visibility from the application in Vulkan</span></p>
<p><span class="koboSpan" id="kobo.87.1">Images are usually device-local memory, as they have their own layout that isn’t readily interpretable by the application. </span><span class="koboSpan" id="kobo.87.2">Buffers can be of any one of the </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">aforementioned types.</span></span></p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.89.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.90.1">A typical workflow for </span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.91.1">creating and uploading data to a buffer includes the </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.93.1">Create a buffer object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">VkBuffer</span></strong><span class="koboSpan" id="kobo.95.1"> by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">VkBufferCreateInfo</span></strong><span class="koboSpan" id="kobo.97.1"> structure and </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">calling </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">vkCreateBuffer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.101.1">Retrieve the memory requirements based on the buffer’s properties by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">vkGetBufferMemoryRequirements</span></strong><span class="koboSpan" id="kobo.103.1">. </span><span class="koboSpan" id="kobo.103.2">The device may require a certain alignment, which could affect the necessary size of the allocation to accommodate the </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">buffer’s contents.</span></span></li>
<li><span class="koboSpan" id="kobo.105.1">Create a structure of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">VkMemoryAllocateInfo</span></strong><span class="koboSpan" id="kobo.107.1">, specify the size of the allocation and the type of memory, and </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">call </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">vkAllocateMemory</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.111.1">Call </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">vkBindBufferMemory</span></strong><span class="koboSpan" id="kobo.113.1"> to bind the allocation with the </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">buffer object.</span></span></li>
<li><span class="koboSpan" id="kobo.115.1">If the buffer is visible from the host, map a pointer to the destination with </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">vkMapMemory</span></strong><span class="koboSpan" id="kobo.117.1">, copy the data, and unmap the memory </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">vkUnmapMemory</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.121.1">If the buffer is a device-local buffer, copy the data to a staging buffer first, then perform the final copy from the staging buffer to the device-local memory using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">vkCmdCopyBuffer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.123.1"> function.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.124.1">As you can see, that’s a complex procedure that can be simplified by using the VMA library, an open source library that provides a convenient and efficient way to manage memory in Vulkan. </span><span class="koboSpan" id="kobo.124.2">It </span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.125.1">offers a high-level interface that abstracts the complex details of memory allocation, freeing you from the burden of manual </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">memory management.</span></span></p>
<h1 id="_idParaDest-119"><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.127.1">Instantiating the VMA library</span></h1>
<p><span class="koboSpan" id="kobo.128.1">To use VMA, you first </span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.129.1">need to create an instance of the library and store a handle in a variable of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">VmaAllocator</span></strong><span class="koboSpan" id="kobo.131.1">. </span><span class="koboSpan" id="kobo.131.2">To create one, you need a Vulkan physical device and </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">a device.</span></span></p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.133.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.134.1">Creating a VMA library instance requires instancing two different structures. </span><span class="koboSpan" id="kobo.134.2">One stores pointers to API functions that VMA needs to find other function pointers and another structure that provides a physical device, a device, and an instance for creating </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">an allocator:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.136.1">
VkPhysicalDevice physicalDevice;  // Valid Physical Device
VkDevice device; // Valid Device
VkInstance instance; // Valid Instance
const uint32_t apiVersion = VK_API_VERSION_1_3;
const VmaVulkanFunctions vulkanFunctions = {
    .vkGetInstanceProcAddr = vkGetInstanceProcAddr,
    .vkGetDeviceProcAddr = vkGetDeviceProcAddr,
#if VMA_VULKAN_VERSION &gt;= 1003000
    .vkGetDeviceBufferMemoryRequirements =
        vkGetDeviceBufferMemoryRequirements,
    .vkGetDeviceImageMemoryRequirements =
        vkGetDeviceImageMemoryRequirements,
#endif
};
VmaAllocator allocator = nullptr;
const VmaAllocatorCreateInfo allocInfo = {
    .physicalDevice = physicalDevice,
    .device = device,
    .pVulkanFunctions = &amp;vulkanFunctions,
    .instance = instance,
    .vulkanApiVersion = apiVersion,
};
vmaCreateAllocator(&amp;allocInfo, &amp;allocator);</span></pre> <p><span class="koboSpan" id="kobo.137.1">The allocator needs pointers to a few Vulkan functions so that it can work based on the features you would like to use. </span><span class="koboSpan" id="kobo.137.2">In the preceding case, we provide only the bare minimum for</span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.138.1"> allocating and deallocating memory. </span><span class="koboSpan" id="kobo.138.2">The allocator needs to be freed once the context is destroyed </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">vmaDestroyAllocator</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">.</span></span></p>
<h1 id="_idParaDest-121"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.142.1">Creating buffers</span></h1>
<p><span class="koboSpan" id="kobo.143.1">A buffer in Vulkan is</span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.144.1"> simply a contiguous block of memory that holds some data. </span><span class="koboSpan" id="kobo.144.2">The data can be vertex, index, uniform, and more. </span><span class="koboSpan" id="kobo.144.3">A buffer object is just metadata and does not directly contain data. </span><span class="koboSpan" id="kobo.144.4">The memory associated with a buffer is allocated after a buffer has </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">been created.</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.146.1">Table 2.1</span></em><span class="koboSpan" id="kobo.147.1"> summarizes the most important usage types of buffers and their </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">access type:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-1">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.149.1">Buffer Type</span></strong></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.150.1">Access Type</span></strong></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.151.1">Uses</span></strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.152.1">Vertex </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">or Index</span></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="No-Break"><span class="koboSpan" id="kobo.154.1">Read-only</span></span></p>
</td>
<td class="No-Table-Style T---Body"/>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><span class="No-Break"><span class="koboSpan" id="kobo.155.1">Uniform</span></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="No-Break"><span class="koboSpan" id="kobo.156.1">Read-only</span></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.157.1">Uniform </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">data storage</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><span class="No-Break"><span class="koboSpan" id="kobo.159.1">Storage</span></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="No-Break"><span class="koboSpan" id="kobo.160.1">Read/write</span></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.161.1">Generic </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">data storage</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><span class="No-Break"><span class="koboSpan" id="kobo.163.1">Uniform texel</span></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="No-Break"><span class="koboSpan" id="kobo.164.1">Read/write</span></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.165.1">Data is interpreted </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">as texels</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><span class="No-Break"><span class="koboSpan" id="kobo.167.1">Storage texel</span></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="No-Break"><span class="koboSpan" id="kobo.168.1">Read/write</span></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.169.1">Data is interpreted </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">as texels</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.171.1">Table 2.1 – Buffer types</span></p>
<p><span class="koboSpan" id="kobo.172.1">Creating buffers is easy, but it helps to know what types of buffers exist and what their requirements are before setting out to create them. </span><span class="koboSpan" id="kobo.172.2">In this chapter, we will provide a template for </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">creating buffers.</span></span></p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.174.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.175.1">In the </span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.176.1">repository, Vulkan buffers are managed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">VulkanCore::Buffer</span></strong><span class="koboSpan" id="kobo.178.1"> class, which provides functions to create and upload data to the device, as well as a utility function to use a staging buffer to upload data to </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">device-only heaps.</span></span></p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.180.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.181.1">Creating a buffer using VMA </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">is simple:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.183.1">All you need are buffer creation flags ( –a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">0</span></strong><span class="koboSpan" id="kobo.185.1"> for the flags is correct for most cases), the size of the buffer in bytes, its usage (this is how you define how the buffer will be used), and assign those values to an instance of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">VkBufferCreateInfo</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.187.1"> structure:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.188.1">
VkDeviceSize size;  // The requested size of the buffer
VmaAllocator allocator;  // valid VMA Allocator
VkUsageBufferFlags use;  // Transfer src/dst/uniform/SSBO
VkBuffer buffer;        // The created buffer
VkBufferCreateInfo createInfo = {
    .sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
    .pNext = nullptr,
    .flags = {},
    .size = size,
    .usage = use,
    .sharingMode = VK_SHARING_MODE_EXCLUSIVE,
    .queueFamilyIndexCount = {},
    .pQueueFamilyIndices = {},
};</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.189.1">You will also </span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.190.1">need a set of </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">VmaAllocationCreateFlagBits values:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.192.1">const VmaAllocationCreateFlagBits allocCreateInfo = {
    VMA_ALLOCATION_CREATE_MAPPED_BIT,
    VMA_MEMORY_USAGE_CPU_ONLY,
};</span></pre></li> <li><span class="koboSpan" id="kobo.193.1">Then, call </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">vmaCreateBuffer</span></strong><span class="koboSpan" id="kobo.195.1"> to obtain the buffer handle and </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">its allocation:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.197.1">
VmaAllocation allocation;  // Needs to live until the
                           // buffer is destroyed
VK_CHECK(vmaCreateBuffer(allocator, &amp;createInfo,
                         &amp;allocCreateInfo, &amp;buffer,
                         &amp;allocation, nullptr));</span></pre></li> <li><span class="koboSpan" id="kobo.198.1">The next step is optional but useful for debugging </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">and optimization:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.200.1">
VmaAllocationInfo allocationInfo;
vmaGetAllocationInfo(allocator, allocation,
                     &amp;allocationInfo);</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.201.1">Some creation flags affect how the buffer can be used, so you might need to make adjustments to </span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.202.1">the preceding code depending on how you intend to use the buffers you create in </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">your application.</span></span></p>
<h1 id="_idParaDest-124"><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.204.1">Uploading data to buffers</span></h1>
<p><span class="koboSpan" id="kobo.205.1">Uploading data</span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.206.1"> from the application to the GPU depends on the </span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.207.1">type of buffer. </span><span class="koboSpan" id="kobo.207.2">For host-visible buffers, it’s a direct copy using </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">memcpy</span></strong><span class="koboSpan" id="kobo.209.1">. </span><span class="koboSpan" id="kobo.209.2">For device-local buffers, we need a staging buffer, which is a buffer that is visible both by the CPU and the GPU. </span><span class="koboSpan" id="kobo.209.3">In this recipe, we will demonstrate how to upload data from your application to the device-visible memory (into a buffer’s memory region on </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">the device).</span></span></p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.211.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.212.1">If you haven’t already, please refer to the </span><em class="italic"><span class="koboSpan" id="kobo.213.1">Understanding Vulkan’s memory </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.214.1">model </span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">recipe.</span></span></p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.216.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.217.1">The upload process depends on the type </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">of buffer:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.219.1">For host-visible memory, it’s enough to retrieve a pointer to the destination using </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">vmaMapMemory</span></strong><span class="koboSpan" id="kobo.221.1"> and copy the data using </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">memcpy</span></strong><span class="koboSpan" id="kobo.223.1">. </span><span class="koboSpan" id="kobo.223.2">The operation is synchronous, so the mapped pointer can be unmapped as soon as </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">memcpy</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.225.1"> returns.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.226.1">It’s fine to map a host-visible buffer as soon as it is created and leave it mapped until its destruction. </span><span class="koboSpan" id="kobo.226.2">That is the recommended approach, as you don’t incur the overhead of mapping the memory every time it needs to </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">be updated:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.228.1">
VmaAllocator allocator;   // Valid VMA allocator
VmaAllocation allocation; // Valid VMA allocation
void *data;               // Data to be uploaded
size_t size;              // Size of data in bytes
void *map = nullptr;
VK_CHECK(vmaMapMemory(allocator, allocation,
                      &amp;map));
memcpy(map, data, size);
vmaUnmapMemory(allocator_, allocation_);
VK_CHECK(vmaFlushAllocation(allocator_,
                            allocation_, offset,
                            size));</span></pre></li> <li><span class="koboSpan" id="kobo.229.1">Uploading data</span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.230.1"> to</span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.231.1"> a device-local memory needs to be (1) copied to a buffer that is visible from the host first (called a staging buffer) and then (2) copied from the staging buffer to the device-local memory using </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">vkCmdCopyBuffer</span></strong><span class="koboSpan" id="kobo.233.1">, as depicted in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.234.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.235.1">.4</span></em><span class="koboSpan" id="kobo.236.1">. </span><span class="koboSpan" id="kobo.236.2">Note that this requires a </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">command buff</span><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.238.1">er:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer021">
<span class="koboSpan" id="kobo.239.1"><img alt="Figure 2.4 – Staging buffers" src="image/B18491_02_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.240.1">Figure 2.4 – Staging buffers</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.241.1">Once the data is residing on the device (on the host-visible buffer), copying it to the device-only buffer </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">is simple:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.243.1">
VkDeviceSize srcOffset;
VkDeviceSize dstOffset;
VkDeviceSize size;
VkCommandBuffer commandBuffer; // Valid Command Buffer
VkBuffer stagingBuffer; // Valid host-visible buffer
VkBuffer buffer; // Valid device-local buffer
VkBufferCopy region(srcOffset, dstOffset, size);
vkCmdCopyBuffer(commandBuffer, stagingBuffer, buffer, 1, &amp;region);</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.244.1">Uploading data from your application to a buffer is accomplished either by a direct </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">memcpy</span></strong><span class="koboSpan" id="kobo.246.1"> operation or</span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.247.1"> by </span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.248.1">means of a staging buffer. </span><span class="koboSpan" id="kobo.248.2">We showed how to perform both uploads in </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">this recipe.</span></span></p>
<h1 id="_idParaDest-127"><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.250.1">Creating a staging buffer</span></h1>
<p><span class="koboSpan" id="kobo.251.1">Creating a staging </span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.252.1">buffer is like creating a regular buffer but requires flags that specify that the buffer is host-visible. </span><span class="koboSpan" id="kobo.252.2">In this recipe, we will show how to create a buffer that can be used as a staging buffer – one that can be used as an intermediary destination of the data being uploaded from your application on its way to a </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">device-local memory.</span></span></p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.254.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.255.1">The </span><em class="italic"><span class="koboSpan" id="kobo.256.1">Creating buffers</span></em><span class="koboSpan" id="kobo.257.1"> recipe explains how to create buffers in general, while this recipe shows which flags and parameters you need to create a </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">staging buffer.</span></span></p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.259.1">How to do it…</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">VkBufferCreateInfo::usage</span></strong><span class="koboSpan" id="kobo.261.1"> needs to contain </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">VK_BUFFER_USAGE_TRANSFER_SRC_BIT</span></strong><span class="koboSpan" id="kobo.263.1"> as it will be the source operation for a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">vkCmdCopyBuffer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.265.1"> command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.266.1">
const VkBufferCreateInfo stagingBufferInfo = {
    .sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
    .size = size,
    .usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
};
const VmaAllocationCreateInfo
    stagingAllocationCreateInfo = {
        .flags = VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT |
            VMA_ALLOCATION_CREATE_MAPPED_BIT,
        .usage = VMA_MEMORY_USAGE_CPU_ONLY,
};
const VmaAllocationCreateFlagBits allocCreateInfo = {
    VMA_ALLOCATION_CREATE_MAPPED_BIT,
    VMA_MEMORY_USAGE_CPU_ONLY,
};
VmaAllocation allocation;  // Needs to live until the
                           // buffer is destroyed
VK_CHECK(vmaCreateBuffer(allocator, &amp;stagingBufferInfo,
                         &amp;allocCreateInfo, &amp;buffer,
                         &amp;allocation, nullptr));</span></pre> <p><span class="koboSpan" id="kobo.267.1">A staging buffer </span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.268.1">may be better implemented using a wrapper in your application. </span><span class="koboSpan" id="kobo.268.2">A wrapper can increase or decrease the size of the buffer as needed, for example. </span><span class="koboSpan" id="kobo.268.3">One staging buffer may be enough for your application, but you need to watch the requirements imposed by </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">some architectures.</span></span></p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.270.1">How to avoid data races using ring buffers</span></h1>
<p><span class="koboSpan" id="kobo.271.1">When a buffer needs to be updated every frame, we run the risk of creating a data race, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.272.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.273.1">.5</span></em><span class="koboSpan" id="kobo.274.1">. </span><span class="koboSpan" id="kobo.274.2">A data race is a situation where multiple threads within a program </span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.275.1">concurrently access a shared data point, with at </span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.276.1">least one thread performing a write operation. </span><span class="koboSpan" id="kobo.276.2">This concurrent access can result in unforeseen behavior due to the unpredictable order of operations. </span><span class="koboSpan" id="kobo.276.3">Take the example of a uniform buffer that stores the view, model, and viewport matrices and needs to be updated every frame. </span><span class="koboSpan" id="kobo.276.4">The buffer is updated while the first command buffer is being recorded, initializing it (version 1). </span><span class="koboSpan" id="kobo.276.5">Once the command buffer starts processing on the GPU, the buffer contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">corre</span><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.278.1">ct data:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer022">
<span class="koboSpan" id="kobo.279.1"><img alt="Figure 2.5 – Data race when using one buffer" src="image/B18491_02_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.280.1">Figure 2.5 – Data race when using one buffer</span></p>
<p><span class="koboSpan" id="kobo.281.1">After the first command buffer starts processing in the GPU, the application may try to update the buffer’s contents to version 2 while the GPU is accessing that data </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">for rendering!</span></span></p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.283.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.284.1">Synchronization is by far the hardest aspect of Vulkan. </span><span class="koboSpan" id="kobo.284.2">If synchronization elements such as semaphores, fences, and barriers are used too greedily, then your application becomes a series and won’t use the full power of the parallelism between the CPU and </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">the GPU.</span></span></p>
<p><span class="koboSpan" id="kobo.286.1">Make sure you also read the </span><em class="italic"><span class="koboSpan" id="kobo.287.1">Understanding synchronization in the swapchain – fences and semaphores</span></em><span class="koboSpan" id="kobo.288.1"> recipe in </span><a href="B18491_01.xhtml#_idTextAnchor019"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.289.1">Chapter 1</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.290.1">, Vulkan Core Concepts</span></em><span class="koboSpan" id="kobo.291.1">. </span><span class="koboSpan" id="kobo.291.2">That recipe and this one only scratch the surface of how to tackle synchronization, but are very good </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">starting points.</span></span></p>
<p><span class="koboSpan" id="kobo.293.1">A ring-buffer implementation is provided in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">EngineCore::RingBuffer</span></strong><span class="koboSpan" id="kobo.295.1"> repository, which has a configurable number of sub-buffers. </span><span class="koboSpan" id="kobo.295.2">Its sub-buffers are all host-visible, persistent buffers; that is, they are persistently mapped after creation for ease </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">of access.</span></span></p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.297.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.298.1">There are a few ways to avoid this problem, but the easiest one is to create a ring buffer that contains several buffers (or any other resource) equal to the number of frames in flight. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.299.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.300.1">.6</span></em><span class="koboSpan" id="kobo.301.1"> shows </span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.302.1">events when there are two buffers </span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.303.1">available. </span><span class="koboSpan" id="kobo.303.2">Once the first command buffer is submitted and is being processed in the GPU, the application is free to process copy 1 of the buffer, as it’s not being accessed by </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">th</span><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.305.1">e device:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer023">
<span class="koboSpan" id="kobo.306.1"><img alt="Figure 2.6 – A data race is avoided with multiple copies of a resource" src="image/B18491_02_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.307.1">Figure 2.6 – A data race is avoided with multiple copies of a resource</span></p>
<p><span class="koboSpan" id="kobo.308.1">Even though this is a simple solution, it has a caveat: if partial updates are allowed, care must be taken when the buffer is updated. </span><span class="koboSpan" id="kobo.308.2">Consider </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.309.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.310.1">.7</span></em><span class="koboSpan" id="kobo.311.1">, in which a ring buffer that contains three sub-allocations is partially updated. </span><span class="koboSpan" id="kobo.311.2">The buffer stores the view, model, and viewport matrices. </span><span class="koboSpan" id="kobo.311.3">During initialization, all three sub-allocations are initialized to three identity matrices. </span><span class="koboSpan" id="kobo.311.4">On </span><strong class="bold"><span class="koboSpan" id="kobo.312.1">Frame 0</span></strong><span class="koboSpan" id="kobo.313.1">, while </span><strong class="bold"><span class="koboSpan" id="kobo.314.1">Buffer 0</span></strong><span class="koboSpan" id="kobo.315.1"> is active, the model matrix is updated and now contains a translation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">(10, 10, 0)</span></strong><span class="koboSpan" id="kobo.317.1">. </span><span class="koboSpan" id="kobo.317.2">On the next frame, </span><strong class="bold"><span class="koboSpan" id="kobo.318.1">Frame 1</span></strong><span class="koboSpan" id="kobo.319.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.320.1">Buffer 1</span></strong><span class="koboSpan" id="kobo.321.1"> becomes active, and the viewport matrix is updated. </span><span class="koboSpan" id="kobo.321.2">Because </span><strong class="bold"><span class="koboSpan" id="kobo.322.1">Buffer 1</span></strong><span class="koboSpan" id="kobo.323.1"> was initialized to three identity matrices, updating only the viewport matrix makes buffers </span><strong class="bold"><span class="koboSpan" id="kobo.324.1">0</span></strong><span class="koboSpan" id="kobo.325.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.326.1">1</span></strong><span class="koboSpan" id="kobo.327.1"> out of sync (as well as </span><strong class="bold"><span class="koboSpan" id="kobo.328.1">Buffer 3</span></strong><span class="koboSpan" id="kobo.329.1">). </span><span class="koboSpan" id="kobo.329.2">To guarantee that partial updates work, we need to copy the last active buffer, </span><strong class="bold"><span class="koboSpan" id="kobo.330.1">Buffer 0</span></strong><span class="koboSpan" id="kobo.331.1">, into </span><strong class="bold"><span class="koboSpan" id="kobo.332.1">Buffer 1</span></strong><span class="koboSpan" id="kobo.333.1"> first, and then update the </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">viewport</span><a id="_idTextAnchor153"/><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.335.1"> matrix:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer024">
<span class="koboSpan" id="kobo.336.1"><img alt="Figure 2.7 – Partial update of a ring buffer makes all sub-allocations out of sync if they are not replicated" src="image/B18491_02_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.337.1">Figure 2.7 – Partial update of a ring buffer makes all sub-allocations out of sync if they are not replicated</span></p>
<p><span class="koboSpan" id="kobo.338.1">Synchronization is a delicate topic, and guaranteeing your application behaves correctly with so</span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.339.1"> many </span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.340.1">moving parts is tricky. </span><span class="koboSpan" id="kobo.340.2">Hopefully, a ring-buffer implementation that is simple may help you focus on other areas of </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">the code.</span></span></p>
<h1 id="_idParaDest-133"><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.342.1">Setting up pipeline barriers</span></h1>
<p><span class="koboSpan" id="kobo.343.1">In Vulkan, commands</span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.344.1"> may be reordered when a command buffer is being processed, subject to certain restrictions. </span><span class="koboSpan" id="kobo.344.2">This is known as command buffer reordering, and it can help to improve performance by allowing the driver to optimize the order in which commands </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">are executed.</span></span></p>
<p><span class="koboSpan" id="kobo.346.1">The good news is that Vulkan provides a mechanism called pipeline barriers to ensure that dependent commands are executed in the correct order. </span><span class="koboSpan" id="kobo.346.2">They are used to explicitly specify dependencies between commands, preventing them from being reordered, and at what stages they might overlap. </span><span class="koboSpan" id="kobo.346.3">This recipe will explain what pipeline barriers are and what their properties mean. </span><span class="koboSpan" id="kobo.346.4">It will also show you how to create and install </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">pipeline barriers.</span></span></p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.348.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.349.1">Consider two draw calls issued in sequence. </span><span class="koboSpan" id="kobo.349.2">The first one writes to a color attachment, while the second draw call samples from that attachment in the </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">fragment shader:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.351.1">
vkCmdDraw(...); // draws into color attachment 0
vkCmdDraw(...); // reads from color attachment 0</span></pre> <p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.352.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.353.1">.8</span></em><span class="koboSpan" id="kobo.354.1"> helps visualize how those two commands may be processed by the device. </span><span class="koboSpan" id="kobo.354.2">In the diagram, commands are processed from top to bottom and progress on the pipeline from left to right. </span><span class="koboSpan" id="kobo.354.3">Clock cycles are a loose term, because processing may take multiple clock cycles, but are used to indicate that – in general – some tasks must happen </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">after others.</span></span></p>
<p><span class="koboSpan" id="kobo.356.1">In the example, the second </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">vkCmdDraw</span></strong><span class="koboSpan" id="kobo.358.1"> call starts executing at </span><strong class="bold"><span class="koboSpan" id="kobo.359.1">C2</span></strong><span class="koboSpan" id="kobo.360.1">, after the first draw call. </span><span class="koboSpan" id="kobo.360.2">This offset is not enough, as the second draw call needs to read the color attachment at the </span><strong class="bold"><span class="koboSpan" id="kobo.361.1">Fragment Shader</span></strong><span class="koboSpan" id="kobo.362.1"> stage, which is not produced by the first draw call until it</span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.363.1"> reaches the </span><strong class="bold"><span class="koboSpan" id="kobo.364.1">Color Attach Output</span></strong><span class="koboSpan" id="kobo.365.1"> stage. </span><span class="koboSpan" id="kobo.365.2">Without synchronization, this setup may cause </span><a id="_idTextAnchor157"/><span class="No-Break"><span class="koboSpan" id="kobo.366.1">data races:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer025">
<span class="koboSpan" id="kobo.367.1"><img alt="Figure 2.8 – Two consecutive commands recorded on the same command buffer being processed without synchronization" src="image/B18491_02_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.368.1">Figure 2.8 – Two consecutive commands recorded on the same command buffer being processed without synchronization</span></p>
<p><span class="koboSpan" id="kobo.369.1">A pipeline barrier is a feature that is recorded into the command buffer and that specifies the pipeline stages that need to have been completed for all commands that appear before the barrier and before the command buffer continues processing. </span><span class="koboSpan" id="kobo.369.2">Commands recorded before the barrier are said to be in the </span><em class="italic"><span class="koboSpan" id="kobo.370.1">first synchronization scope</span></em><span class="koboSpan" id="kobo.371.1"> or first scope. </span><span class="koboSpan" id="kobo.371.2">Commands recorded after the barrier are said to be part of the </span><em class="italic"><span class="koboSpan" id="kobo.372.1">second synchronization scope</span></em><span class="koboSpan" id="kobo.373.1"> or </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">second scope.</span></span></p>
<p><span class="koboSpan" id="kobo.375.1">The barrier also allows fine-grained control to specify at which stage commands after the barrier must wait until commands in the first scope finish processing. </span><span class="koboSpan" id="kobo.375.2">That’s because commands in the second scope don’t need to wait until commands in the first scope are done. </span><span class="koboSpan" id="kobo.375.3">They can start processing as soon as possible, as long as the conditions specified in the barrier </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">are met.</span></span></p>
<p><span class="koboSpan" id="kobo.377.1">In the example in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.378.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.379.1">.8</span></em><span class="koboSpan" id="kobo.380.1">, the first draw call, in the first scope, needs to write to the attachment before the second draw call can access it. </span><span class="koboSpan" id="kobo.380.2">The second draw call does not need to wait until the first draw call finishes processing the </span><strong class="bold"><span class="koboSpan" id="kobo.381.1">Color Attach Output</span></strong><span class="koboSpan" id="kobo.382.1"> stage. </span><span class="koboSpan" id="kobo.382.2">It can start right away, as long as its fragment stage happens after the first draw call is done with</span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.383.1"> its </span><strong class="bold"><span class="koboSpan" id="kobo.384.1">Color Attach Output</span></strong><span class="koboSpan" id="kobo.385.1"> stage, as shown in </span><a id="_idTextAnchor158"/><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.386.1">Figure 2</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.387.1">.9</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer026">
<span class="koboSpan" id="kobo.389.1"><img alt="Figure 2.9 – Two consecutive commands recorded on the same command buffer being processed with synchronization" src="image/B18491_02_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.390.1">Figure 2.9 – Two consecutive commands recorded on the same command buffer being processed with synchronization</span></p>
<p><span class="koboSpan" id="kobo.391.1">There are three types </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">of barriers:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.393.1">Memory barriers</span></strong><span class="koboSpan" id="kobo.394.1"> are global </span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.395.1">barriers and apply to all commands in the first and </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">second scopes.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.397.1">Buffer memory barriers</span></strong><span class="koboSpan" id="kobo.398.1"> are barriers that apply only to commands that access a portion of the buffer, as it’s possible to specify to which portion of the buffer the barrier applies (offset + </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">range).</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.400.1">Image memory barriers</span></strong><span class="koboSpan" id="kobo.401.1"> are barriers that apply only to commands that access a subresource of an image. </span><span class="koboSpan" id="kobo.401.2">It’s possible to add barriers based on mip level, sections of the image, or array layers. </span><span class="koboSpan" id="kobo.401.3">This is an especially important barrier as it is also used to transition an image from one layout to another. </span><span class="koboSpan" id="kobo.401.4">For instance, while generating mipmaps and blitting from one mip level to the next, the levels need to be in the correct layout. </span><span class="koboSpan" id="kobo.401.5">The previous level needs to be in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</span></strong><span class="koboSpan" id="kobo.403.1"> layout, as it will be read from, while the next mip level needs to be in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</span></strong><span class="koboSpan" id="kobo.405.1"> layout, as it will be </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">written to.</span></span></li>
</ol>
<h2 id="_idParaDest-135"><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.407.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.408.1">Pipeline barriers are recorded with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">vkCmdPipelineBarrier</span></strong><span class="koboSpan" id="kobo.410.1"> command, in which you can provide several barriers of multiple types at the same time. </span><span class="koboSpan" id="kobo.410.2">The following code snippet shows how to create a barrier used to create a dependency between the two draw </span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.411.1">calls in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.412.1">Figure 2</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.413.1">.9</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.415.1">
VkCommandBuffer commandBuffer;  // Valid Command Buffer
VkImage image;                  // Valid image
const VkImageSubresourceRange subresource = {
    .aspectMask =.baseMipLevel = 0,
    .levelCount = VK_REMAINING_MIP_LEVELS,
    .baseArrayLayer = 0,
    .layerCount = 1,
};
const VkImageMemoryBarrier imageBarrier = {
    .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
    .srcAccessMask =
        VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR,
    .dstAccessMask = VK_ACCESS_2_SHADER_READ_BIT_KHR,
    .oldLayout = VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL,
    .newLayout = VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL,
    .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
    .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
    .image = image,
    .subresourceRange = &amp;subresource,
};
vkCmdPipelineBarrier(
    commandBuffer,
    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, 0, 0,
    nullptr, 0, nullptr, 1, &amp;memoryBarrier);</span></pre> <p><span class="koboSpan" id="kobo.416.1">The barrier needs to be recorded between the two </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">draw calls:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.418.1">
vkCmdDraw(...); // draws into color attachment 0
vkCmdPipelineBarrier(...);
vkCmdDraw(...); // reads from color attachment 0</span></pre> <p><span class="koboSpan" id="kobo.419.1">Pipeline barriers </span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.420.1">are tricky but absolutely fundamental in Vulkan. </span><span class="koboSpan" id="kobo.420.2">Make sure you understand what they offer and how they operate before continuing to read the </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">other recipes.</span></span></p>
<h1 id="_idParaDest-136"><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.422.1">Creating images (textures)</span></h1>
<p><span class="koboSpan" id="kobo.423.1">Images are used </span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.424.1">for storing 1D, 2D, or 3D data, although they are mostly used for 2D data. </span><span class="koboSpan" id="kobo.424.2">Different than buffers, images have the advantage of being optimized for locality in memory layout. </span><span class="koboSpan" id="kobo.424.3">This is because most GPUs have a fixed-function texture unit or sampler that reads texel data from an image and applies filtering and other operations to produce a final color value. </span><span class="koboSpan" id="kobo.424.4">Images can have different formats, such as RGB, RGBA, BGRA, and </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.426.1">An image object is only metadata in Vulkan. </span><span class="koboSpan" id="kobo.426.2">Its data is stored separately and is created in a similar manner to buffers </span><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.427.1">(</span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.428.1">Figure 2</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.429.1">.10</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">):</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer027">
<span class="koboSpan" id="kobo.431.1"><img alt="Figure 2.10 – Images" src="image/B18491_02_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.432.1">Figure 2.10 – Images</span></p>
<p><span class="koboSpan" id="kobo.433.1">Images in Vulkan cannot be accessed directly and need to be accessed only by means of an image view. </span><span class="koboSpan" id="kobo.433.2">An image view is a way to access a subset of the image data by specifying the subresource range, which includes the aspect (such as color or depth), the mip level, and the array </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">layer range.</span></span></p>
<p><span class="koboSpan" id="kobo.435.1">Another </span><em class="italic"><span class="koboSpan" id="kobo.436.1">very important</span></em><span class="koboSpan" id="kobo.437.1"> aspect of images is their layout. </span><span class="koboSpan" id="kobo.437.2">It is used to specify the intended usage of an image resource in Vulkan, such as whether it should be used as a source or destination for a transfer operation, a color or depth attachment for rendering, or as a shader read or write resource. </span><span class="koboSpan" id="kobo.437.3">The correct image layout is important because it ensures that the GPU can efficiently access and manipulate the image data in accordance with the intended usage. </span><span class="koboSpan" id="kobo.437.4">Using the wrong image layout can lead to performance issues or rendering artifacts and can result in undefined behavior. </span><span class="koboSpan" id="kobo.437.5">Therefore, it’s essential to correctly specify the image layout for each usage of an image in a Vulkan application. </span><span class="koboSpan" id="kobo.437.6">Common image layouts are undefined (</span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">VK_IMAGE_LAYOUT_UNDEFINED</span></strong><span class="koboSpan" id="kobo.439.1">) color attachment (</span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</span></strong><span class="koboSpan" id="kobo.441.1">), depth/stencil attachment (</span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL</span></strong><span class="koboSpan" id="kobo.443.1">), and shader read(</span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</span></strong><span class="koboSpan" id="kobo.445.1">). </span><span class="koboSpan" id="kobo.445.2">Image layout transitions are </span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.446.1">done as part of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">vkCmdPipelineBarrier</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.448.1"> command.</span></span></p>
<p><span class="koboSpan" id="kobo.449.1">In this recipe, you will learn how to create images on </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">a device.</span></span></p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor162"/><span class="koboSpan" id="kobo.451.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.452.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">VulkanCore::Texture</span></strong><span class="koboSpan" id="kobo.454.1"> class within our repository, we’ve encapsulated the intricate management of images and image views, offering a comprehensive solution for handling Vulkan textures. </span><span class="koboSpan" id="kobo.454.2">From facilitating efficient data uploads to handling transitions between image layouts and generating mipmaps, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">Texture</span></strong><span class="koboSpan" id="kobo.456.1"> class equips us with the means to seamlessly integrate textures in the </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">Vulkan examples.</span></span></p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor163"/><span class="koboSpan" id="kobo.458.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.459.1">Creating an image requires some basic information about it, such as type (1D, 2D, 3D), size, format (RGBA, BGRA, and so on), number of mip levels, number of layers (faces for cubemaps), and </span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.460.1">a </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">few others:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.462.1">
VkFormat format;     // Image format
VkExtents extents;   // Image size
uint32_t mipLevels;  // Number of mip levels
uint32_t layerCount; // Number of layers (sides of cubemap)
const VkImageCreateInfo imageInfo = {
    .sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
    .flags = 0, // optional
    .imageType = VK_IMAGE_TYPE_2D,  // 1D, 2D, 3D
    .format = format,
    .extent = extents,
    .mipLevels = mipLevels,
    .arrayLayers = layerCount,
    .samples = VK_SAMPLE_COUNT_1_BIT,
    .tiling = VK_IMAGE_TILING_OPTIMAL,
    .usage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
    .sharingMode = VK_SHARING_MODE_EXCLUSIVE,
    .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED,
};</span></pre> <p><span class="koboSpan" id="kobo.463.1">The following structure tells VMA that the image will be a </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">device-only image:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.465.1">
const VmaAllocationCreateInfo allocCreateInfo = {
    .flags = VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT,
    .usage = VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE,
    .priority = 1.0f,
};</span></pre> <p><span class="koboSpan" id="kobo.466.1">The resulting image’s handle will be stored </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">image</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.470.1">
VkImage image = VK_NULL_HANDLE;
VK_CHECK(vmaCreateImage(vmaAllocator_, &amp;imageInfo,
                        &amp;allocCreateInfo, &amp;image,
                        &amp;vmaAllocation_, nullptr));</span></pre> <p><span class="koboSpan" id="kobo.471.1">The next step is optional but useful for debugging or optimizing </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">the code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.473.1">
VmaAllocationInfo allocationInfo;
vmaGetAllocationInfo(vmaAllocator_, vmaAllocation_,
                     &amp;allocationInfo);</span></pre> <p><span class="koboSpan" id="kobo.474.1">This recipe only showed you how to create an image in Vulkan, not how to upload data to it. </span><span class="koboSpan" id="kobo.474.2">Uploading </span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.475.1">data to an image is just like uploading data to </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">a buffer.</span></span></p>
<h1 id="_idParaDest-139"><a id="_idTextAnchor164"/><span class="koboSpan" id="kobo.477.1">Creating an image view</span></h1>
<p><span class="koboSpan" id="kobo.478.1">Image views</span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.479.1"> provide a way to interpret images in terms of size, location, and format, except in terms of their layout, which needs to be transformed explicitly and transitioned using image barriers. </span><span class="koboSpan" id="kobo.479.2">In this recipe, you will learn how to create an image view object </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">in Vulkan.</span></span></p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor165"/><span class="koboSpan" id="kobo.481.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.482.1">Image views are stored and managed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">VulkanCore::Texture</span></strong><span class="koboSpan" id="kobo.484.1"> class in </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">the repository.</span></span></p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor166"/><span class="koboSpan" id="kobo.486.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.487.1">Creating an image view is easy; all you need is the handle of the image it is associated with and the</span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.488.1"> region of the image that you would like </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">to represent:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.490.1">
VkDevice device;  // Valid Vulkan Device
VkImage image;    // Valid Image object
VkFormat format;
uint32_t numMipLevels;  // Number of mip levels
uint32_t layers;  // Number of layers (cubemap faces)
const VkImageViewCreateInfo imageViewInfo = {
    .sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
    .image = image,
    .viewType =
        VK_IMAGE_VIEW_TYPE_2D,  // 1D, 2D, 3D, Cubemap
                                // and arrays
    .format = format,
    .components =
        {
            .r = VK_COMPONENT_SWIZZLE_IDENTITY,
            .g = VK_COMPONENT_SWIZZLE_IDENTITY,
            .b = VK_COMPONENT_SWIZZLE_IDENTITY,
            .a = VK_COMPONENT_SWIZZLE_IDENTITY,
        },
    .subresourceRange = {
        .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
        .baseMipLevel = 0,
        .levelCount = numMipLevels,
        .baseArrayLayer = 0,
        .layerCount = layers,
    }};
VkImageView imageView{VK_NULL_HANDLE};
VK_CHECK(vkCreateImageView(device, &amp;imageViewInfo,
                           nullptr, &amp;imageView));</span></pre> <p><span class="koboSpan" id="kobo.491.1">Without an image view, a texture cannot be used by shaders. </span><span class="koboSpan" id="kobo.491.2">Even when used as color attachments, images</span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.492.1"> need </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">image views.</span></span></p>
<h1 id="_idParaDest-142"><a id="_idTextAnchor167"/><span class="koboSpan" id="kobo.494.1">Creating a sampler</span></h1>
<p><span class="koboSpan" id="kobo.495.1">A sampler in Vulkan </span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.496.1">transcends a simple object; it’s a crucial bridge between shader execution and image data. </span><span class="koboSpan" id="kobo.496.2">Beyond interpolation, it governs filtering, addressing modes, and mipmapping. </span><span class="koboSpan" id="kobo.496.3">Filters dictate interpolation between texels, while addressing modes control how coordinates map to image extents. </span><span class="koboSpan" id="kobo.496.4">Anisotropic filtering further enhances sampling fidelity. </span><span class="koboSpan" id="kobo.496.5">Mipmapping, a pyramid of downsampled image levels, is another facet managed by samplers. </span><span class="koboSpan" id="kobo.496.6">In essence, creating a sampler involves orchestrating these attributes to seamlessly harmonize image data and shader intricacies. </span><span class="koboSpan" id="kobo.496.7">In this recipe, you will learn how to create a sampler object </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">in Vulkan.</span></span></p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor168"/><span class="koboSpan" id="kobo.498.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.499.1">Samplers are implemented by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">VulkanCore::Sampler</span></strong><span class="koboSpan" id="kobo.501.1"> class in </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">the repository.</span></span></p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor169"/><span class="koboSpan" id="kobo.503.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.504.1">The properties of a sampler define how an image is interpreted in the pipeline, usually in a shader. </span><span class="koboSpan" id="kobo.504.2">The process is simple – instantiate a </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">VkSamplerCreateInfo</span></strong><span class="koboSpan" id="kobo.506.1"> structure and </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">call </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">vkCreateSampler</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.510.1">
VkDevice device;  // Valid Vulkan Device
VkFilter minFilter;
VkFilter maxFilter;
float maxLod;  // Max mip level
const VkSamplerCreateInfo samplerInfo = {
    .sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
    .magFilter = minFilter,
    .minFilter = magFilter,
    .mipmapMode = maxLod &gt; 0
                      ? </span><span class="koboSpan" id="kobo.510.2">VK_SAMPLER_MIPMAP_MODE_LINEAR
                      : VK_SAMPLER_MIPMAP_MODE_NEAREST,
    .addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT,
    .addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT,
    .addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT,
    .mipLodBias = 0,
    .anisotropyEnable = VK_FALSE,
    .minLod = 0,
    .maxLod = maxLod,
};
VkSampler sampler{VK_NULL_HANDLE};
VK_CHECK(vkCreateSampler(device, &amp;samplerInfo, nullptr,
                         &amp;sampler));</span></pre> <p><span class="koboSpan" id="kobo.511.1">A sampler is one of</span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.512.1"> the simplest objects to create in Vulkan and one of the easiest to understand, as it describes very common computer </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">graphics concepts.</span></span></p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.514.1">Providing shader data</span></h1>
<p><span class="koboSpan" id="kobo.515.1">Providing data</span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.516.1"> from your application that will be used in shaders is one of the most convoluted aspects of Vulkan and requires several steps that need to be accomplished in the right order (and with the right parameters). </span><span class="koboSpan" id="kobo.516.2">In this recipe, with many smaller recipes, you will learn how to provide data used in shaders, such as textures, buffers, </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">and samplers.</span></span></p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.518.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.519.1">Resources consumed by shaders are specified using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">layout</span></strong><span class="koboSpan" id="kobo.521.1"> keyword, along with </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">set</span></strong><span class="koboSpan" id="kobo.523.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">binding</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.525.1"> qualifiers:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.526.1">
layout(set = 0, binding=0) uniform Transforms
{
    mat4 model;
    mat4 view;
    mat4 projection;
} MVP;</span></pre> <p><span class="koboSpan" id="kobo.527.1">Each resource is represented by a binding. </span><span class="koboSpan" id="kobo.527.2">A set is a collection of bindings. </span><span class="koboSpan" id="kobo.527.3">One binding doesn’t necessarily represent just one resource; it can also represent an array of resources of the </span><a id="_idIndexMarker182"/><span class="No-Break"><span class="koboSpan" id="kobo.528.1">same type.</span></span></p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.529.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.530.1">Providing a resource as input to shaders is a multi-step process that involves </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">the following:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.532.1">Specifying sets and their bindings using descriptor set layouts. </span><span class="koboSpan" id="kobo.532.2">This step doesn’t associate real resources with sets/bindings. </span><span class="koboSpan" id="kobo.532.3">It just specifies the number and types of bindings in </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">a set.</span></span></li>
<li><span class="koboSpan" id="kobo.534.1">Building a pipeline layout, which describes which sets will be used in </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">a pipeline.</span></span></li>
<li><span class="koboSpan" id="kobo.536.1">Creating a descriptor pool that will provide instances of descriptor sets. </span><span class="koboSpan" id="kobo.536.2">A descriptor pool contains a list of how many bindings it can provide grouped by binding</span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.537.1"> type (texture, sampler, </span><strong class="bold"><span class="koboSpan" id="kobo.538.1">shader storage buffer</span></strong><span class="koboSpan" id="kobo.539.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.540.1">SSBO</span></strong><span class="koboSpan" id="kobo.541.1">), </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">uniform buffers).</span></span></li>
<li><span class="koboSpan" id="kobo.543.1">Allocate descriptor sets from the pool </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">vkAllocateDescriptorSets</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.547.1">Bind resources to bindings using </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">vkUpdateDescriptorSets</span></strong><span class="koboSpan" id="kobo.549.1">. </span><span class="koboSpan" id="kobo.549.2">In this step, we associate a real resource (a buffer, a texture, and so on) with </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">a binding.</span></span></li>
<li><span class="koboSpan" id="kobo.551.1">Bind descriptor sets and their bindings to a pipeline during rendering using </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">vkCmdBindDescriptorSet</span></strong><span class="koboSpan" id="kobo.553.1">. </span><span class="koboSpan" id="kobo.553.2">This step makes resources bound to their set/bindings in the previous step available to shaders in the </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">current pipeline.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.555.1">The next recipes </span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.556.1">will show you how to perform each one of </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">those steps.</span></span></p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.558.1">Specifying descriptor sets with descriptor set layouts</span></h2>
<p><span class="koboSpan" id="kobo.559.1">Consider</span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.560.1"> the following</span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.561.1"> GLSL code, which specifies </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">several resources:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.563.1">
struct Vertex {
    vec3 pos;
    vec2 uv;
    vec3 normal;
};
layout(set = 0, binding=0) uniform Transforms
{
    mat4 model;
    mat4 view;
    mat4 projection;
} MVP;
layout(set = 1, binding = 0) uniform texture2D textures[];
layout(set = 1, binding = 1) uniform sampler   samplers[];
layout(set = 2, binding = 0) readonly buffer VertexBuffer
{
    Vertex vertices[];
} vertexBuffer;</span></pre> <p><span class="koboSpan" id="kobo.564.1">The code requires three sets (0, 1, and 2), so we need to create three descriptor set layouts. </span><span class="koboSpan" id="kobo.564.2">In this recipe, you will learn how to create a descriptor set layout for the </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">preceding code.</span></span></p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.566.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.567.1">Descriptor sets and bindings are created, stored, and managed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">VulkanCore::Pipeline</span></strong><span class="koboSpan" id="kobo.569.1"> class in the repository. </span><span class="koboSpan" id="kobo.569.2">A descriptor set in Vulkan acts as a container that holds resources, such as buffers, textures, and samplers, for use by shaders. </span><span class="koboSpan" id="kobo.569.3">Binding refers to the process of associating these descriptor sets with specific shader stages, enabling seamless interaction between shaders and resources during rendering. </span><span class="koboSpan" id="kobo.569.4">These descriptor sets serve as gateways through which resources are seamlessly bound </span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.570.1">to shader </span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.571.1">stages, orchestrating harmony between data and shader execution. </span><span class="koboSpan" id="kobo.571.2">To facilitate this synergy, the class simplifies descriptor set creation and management, complemented by methods for efficient resource binding within the Vulkan </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">rendering pipeline.</span></span></p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor175"/><span class="koboSpan" id="kobo.573.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.574.1">A descriptor set layout states its bindings (number and types) with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">vkDescriptorSetLayout</span></strong><span class="koboSpan" id="kobo.576.1"> structure. </span><span class="koboSpan" id="kobo.576.2">Each binding is described using an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">vkDescriptorSetLayoutBinding</span></strong><span class="koboSpan" id="kobo.578.1"> structure. </span><span class="koboSpan" id="kobo.578.2">The relationship between the Vulkan structures needed to create a descriptor set layout for the preceding </span><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.579.1">code is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.580.1">Figure 2</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.581.1">.11</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer028">
<span class="koboSpan" id="kobo.583.1"><img alt="Figure 2.11 – Illustrating the configuration of descriptor set layouts for GLSL shaders" src="image/B18491_02_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.584.1">Figure 2.11 – Illustrating the configuration of descriptor set layouts for GLSL shaders</span></p>
<p><span class="koboSpan" id="kobo.585.1">The following code </span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.586.1">shows</span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.587.1"> how to specify two bindings for set 1, which are stored in a vector </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">of bindings:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.589.1">
constexpr uint32_t </span><strong class="bold"><span class="koboSpan" id="kobo.590.1">kMaxBindings</span></strong><span class="koboSpan" id="kobo.591.1"> = 1000;
const VkDescriptorSetLayoutBinding texBinding = {
    .binding = 0,
    .descriptorType = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
    .descriptorCount = </span><strong class="bold"><span class="koboSpan" id="kobo.592.1">kMaxBindings</span></strong><span class="koboSpan" id="kobo.593.1">,
    .stageFlags = VK_SHADER_STAGE_VERTEX_BIT,
};
const VkDescriptorSetLayoutBinding samplerBinding = {
    .binding = 1,
    .descriptorType = VK_DESCRIPTOR_TYPE_SAMPLER,
    .descriptorCount = </span><strong class="bold"><span class="koboSpan" id="kobo.594.1">kMaxBindings</span></strong><span class="koboSpan" id="kobo.595.1">,
    .stageFlags = VK_SHADER_STAGE_VERTEX_BIT,
};
struct SetDescriptor {
  uint32_t set_;
  std::vector&lt;VkDescriptorSetLayoutBinding&gt; bindings_;
};
std::vector&lt;SetDescriptor&gt; sets(1);
sets[0].set_ = 1;
sets[0].bindings_.push_back(texBinding);
sets[0].bindings_.push_back(samplerBinding);</span></pre> <p><span class="koboSpan" id="kobo.596.1">Since each binding describes a vector, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">VkDescriptorSetLayoutBinding</span></strong><span class="koboSpan" id="kobo.598.1"> structure requires the number of descriptors, we are using a large number that hopefully will accommodate all elements we need in the array. </span><span class="koboSpan" id="kobo.598.2">The vector of bindings is stored in a structure </span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.599.1">that describes</span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.600.1"> a set with its number and all its bindings. </span><span class="koboSpan" id="kobo.600.2">This vector will be used to create a descriptor </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">set layout:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.602.1">
constexpr VkDescriptorBindingFlags flagsToEnable =
    VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT |
    VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT;
for (size_t setIndex = 0;
     const auto&amp; set : sets) {
  std::vector&lt;VkDescriptorBindingFlags&gt; bindFlags(
      set.bindings_.size(), flagsToEnable);
  const VkDescriptorSetLayoutBindingFlagsCreateInfo
      extendedInfo{
          .sType =
              VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO,
          .pNext = nullptr,
          .bindingCount = static_cast&lt;uint32_t&gt;(
              set.bindings_.size()),
          .pBindingFlags = bindFlags.data(),
      };
  const VkDescriptorSetLayoutCreateInfo dslci = {
      .sType =
          VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
      .pNext = &amp;extendedInfo,
      .flags =
          VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT,
      .bindingCount =
          static_cast&lt;uint32_t&gt;(set.bindings_.size()),
      .pBindings = set.bindings_.data(),
  };
  VkDescriptorSetLayout descSetLayout{VK_NULL_HANDLE};
  VK_CHECK(vkCreateDescriptorSetLayout(
      context_-&gt;device(), &amp;dslci, nullptr,
      &amp;descSetLayout));
}</span></pre> <p><span class="koboSpan" id="kobo.603.1">Each set requires its own descriptor set layout, and the preceding process needs to be repeated for eac</span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.604.1">h one. </span><span class="koboSpan" id="kobo.604.2">The descriptor</span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.605.1"> set layout needs to be stored so that it can be referred to in </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">the future.</span></span></p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.607.1">Passing data to shaders using push constants</span></h2>
<p><span class="koboSpan" id="kobo.608.1">Push constants </span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.609.1">are another way to pass data to</span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.610.1"> shaders. </span><span class="koboSpan" id="kobo.610.2">Although a very performant and easy way to do so, push constants are very limited in size, 128 bytes being the only guaranteed amount by the </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">Vulkan specification.</span></span></p>
<p><span class="koboSpan" id="kobo.612.1">This recipe will show you how to pass a small amount of data from your application to shaders, using push constants for a </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">simple shader.</span></span></p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.614.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.615.1">Push constants are stored and managed by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">VulkanCore::Pipeline</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.617.1"> class.</span></span></p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.618.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.619.1">Push constants are recorded directly onto the command buffer and aren’t prone to the same synchronization issues that exist with other resources. </span><span class="koboSpan" id="kobo.619.2">They are declared in the shader as follows, with one maximum block </span><span class="No-Break"><span class="koboSpan" id="kobo.620.1">per shader:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.621.1">
layout (</span><strong class="bold"><span class="koboSpan" id="kobo.622.1">push_constant</span></strong><span class="koboSpan" id="kobo.623.1">) uniform Transforms {
    mat4 model;
} PushConstants;</span></pre> <p><span class="koboSpan" id="kobo.624.1">The pushed data must be split into the shader stages. </span><span class="koboSpan" id="kobo.624.2">Parts of it can be assigned to different shader stages or assigned to one single stage. </span><span class="koboSpan" id="kobo.624.3">The important part is that the data cannot be greater than the total amount available for push constants. </span><span class="koboSpan" id="kobo.624.4">The limit is provided </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">VkPhysicalDeviceLimits::maxPushConstantsSize</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.628.1">Before using push constants, we need to specify how many bytes we are using in each </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">shader stage:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.630.1">
const VkPushConstantRange range = {
    .stageFlags = VK_SHADER_STAGE_VERTEX_BIT,
    .offset = 0,
    .size = 64,
};
std::vector&lt;VkPushConstantRange&gt; pushConsts;
pushConsts.push_back(range);</span></pre> <p><span class="koboSpan" id="kobo.631.1">The code states that the first (</span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">offset == 0</span></strong><span class="koboSpan" id="kobo.633.1">) </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">64</span></strong><span class="koboSpan" id="kobo.635.1"> bytes of the push constant data recorded in the command buffer (the size of a 4x4 matrix of floats) will be used by the vertex shader. </span><span class="koboSpan" id="kobo.635.2">This</span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.636.1"> structure will be used in the</span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.637.1"> next recipe to create a pipeline </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">layout object.</span></span></p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.639.1">Creating a pipeline layout</span></h2>
<p><span class="koboSpan" id="kobo.640.1">A pipeline </span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.641.1">layout is an object in Vulkan that needs to be</span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.642.1"> created and destroyed by the application. </span><span class="koboSpan" id="kobo.642.2">The layout is specified using structures that define the layout of bindings and sets. </span><span class="koboSpan" id="kobo.642.3">In this recipe, you will learn how to create a </span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">pipeline layout.</span></span></p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.644.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.645.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">VkPipelineLayoutCreateInfo</span></strong><span class="koboSpan" id="kobo.647.1"> instance is created automatically by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">VulkanCore::Pipeline</span></strong><span class="koboSpan" id="kobo.649.1"> class in the repository based on information provided by the application using a vector of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">VulkanCore::Pipeline::SetDescriptor</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.651.1"> structures.</span></span></p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.652.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.653.1">With all descriptor set layouts for all sets and the push constant information in hand, the next step consists of creating a </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">pipeline layout:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.655.1">
std::vector&lt;VkDescriptoSetLayout&gt; descLayouts;
const VkPipelineLayoutCreateInfo pipelineLayoutInfo = {
    .sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
    .setLayoutCount = (uint32_t)descLayouts.size(),
    .pSetLayouts = descLayouts.data(),
    .pushConstantRangeCount =
        !pushConsts.empty()
            ? </span><span class="koboSpan" id="kobo.655.2">static_cast&lt;uint32_t&gt;(pushConsts.size())
            : 0,
    .pPushConstantRanges = !pushConsts.empty()
                               ? </span><span class="koboSpan" id="kobo.655.3">pushConsts.data()
                               : nullptr,
};
VkPipelineLayout pipelineLayout{VK_NULL_HANDLE};
VK_CHECK(vkCreatePipelineLayout(context_-&gt;device(),
                                &amp;pipelineLayoutInfo,
                                nullptr,
                                &amp;pipelineLayout));</span></pre> <p><span class="koboSpan" id="kobo.656.1">Once you have the</span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.657.1"> descriptor set layout in hand and know</span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.658.1"> how to use the push constants in your application, creating a pipeline layout </span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">is straightforward.</span></span></p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.660.1">Creating a descriptor pool</span></h2>
<p><span class="koboSpan" id="kobo.661.1">A descriptor pool </span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.662.1">contains a maximum number of </span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.663.1">descriptors it can provide (be allocated from), grouped by binding type. </span><span class="koboSpan" id="kobo.663.2">For instance, if two bindings of the same set require one image each, the descriptor pool would have to provide at least two descriptors. </span><span class="koboSpan" id="kobo.663.3">In this recipe, you will learn how to create a </span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">descriptor pool.</span></span></p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor184"/><span class="koboSpan" id="kobo.665.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.666.1">Descriptor pools are allocated in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">VulkanCore::Pipeline:: </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">initDescriptorPool()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.669.1"> method.</span></span></p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor185"/><span class="koboSpan" id="kobo.670.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.671.1">Creating a descriptor pool is straightforward. </span><span class="koboSpan" id="kobo.671.2">All we need is a list of binding types and the maximum number of resources we’ll allocate for </span><span class="No-Break"><span class="koboSpan" id="kobo.672.1">each one:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.673.1">
constexpr uint32_t swapchainImages = 3;
std::vector&lt;VkDescriptorPoolSize&gt; poolSizes;
poolSizes.emplace_back(VkDescriptorPoolSize{
    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
    swapchainImages* kMaxBindings});
poolSizes.emplace_back(VkDescriptorPoolSize{
    VK_DESCRIPTOR_TYPE_SAMPLER,
    swapchainImages* kMaxBindings});</span></pre> <p><span class="koboSpan" id="kobo.674.1">Since we duplicate the resources based on the number of swapchain images to avoid data races </span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.675.1">between the CPU and the GPU, we multiply the </span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.676.1">number of bindings we requested before (</span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">kMaxBindings = 1000</span></strong><span class="koboSpan" id="kobo.678.1">) by the number of </span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">swapchain images:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.680.1">
const VkDescriptorPoolCreateInfo descriptorPoolInfo = {
    .sType =
        VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
    .flags =
        VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT |
        VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT,
    .maxSets = MAX_DESCRIPTOR_SETS,
    .poolSizeCount =
        static_cast&lt;uint32_t&gt;(poolSizes.size()),
    .pPoolSizes = poolSizes.data(),
};
VkDescriptorPool descriptorPool{VK_NULL_HANDLE};
VK_CHECK(vkCreateDescriptorPool(context_-&gt;device(),
                                &amp;descriptorPoolInfo,
                                nullptr,
                                &amp;descriptorPool));</span></pre> <p><span class="koboSpan" id="kobo.681.1">Be careful not to </span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.682.1">create pools that are too large. </span><span class="koboSpan" id="kobo.682.2">Achieving a</span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.683.1"> high-performing application means not allocating more resources than </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">you need.</span></span></p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor186"/><span class="koboSpan" id="kobo.685.1">Allocating descriptor sets</span></h2>
<p><span class="koboSpan" id="kobo.686.1">Once a descriptor </span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.687.1">layout and a descriptor pool have been </span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.688.1">created, before you can use it, you need to allocate a descriptor set, which is an instance of a set with the layout described by the descriptor layout. </span><span class="koboSpan" id="kobo.688.2">In this recipe, you will learn how to allocate a </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">descriptor set.</span></span></p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor187"/><span class="koboSpan" id="kobo.690.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.691.1">Descriptor set allocations are done in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">VulkanCore::Pipeline:: allocateDescriptors()</span></strong><span class="koboSpan" id="kobo.693.1"> method. </span><span class="koboSpan" id="kobo.693.2">Here, developers define the count of descriptor sets required, coupled with binding counts per set. </span><span class="koboSpan" id="kobo.693.3">The subsequent </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">bindDescriptorSets()</span></strong><span class="koboSpan" id="kobo.695.1"> method weaves the descriptors into command buffers, preparing them for </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">shader execution.</span></span></p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor188"/><span class="koboSpan" id="kobo.697.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.698.1">Allocating a descriptor set (or a number of them) is easy. </span><span class="koboSpan" id="kobo.698.2">You need to fill the </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">VkDescriptorSetAllocateInfo</span></strong><span class="koboSpan" id="kobo.700.1"> structure and </span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">call </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">vkAllocateDescriptorSets</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.704.1">
VkDescriptorSetAllocateInfo allocInfo = {
    .sType =
        VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
    .descriptorPool = descriptorPool,
    .descriptorSetCount = 1,
    .pSetLayouts = &amp;descSetLayout,
};
VkDescriptorSet descriptorSet{VK_NULL_HANDLE};
VK_CHECK(vkAllocateDescriptorSets(context_-&gt;device(),
                                  &amp;allocInfo,
                                  &amp;descriptorSet));</span></pre> <p><span class="koboSpan" id="kobo.705.1">When using multiple copies of a resource to avoid race conditions, there are </span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">two approaches:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.707.1">Allocate one descriptor set for each resource. </span><span class="koboSpan" id="kobo.707.2">In other words, call the preceding code once for each copy of </span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">the resource.</span></span></li>
<li><span class="koboSpan" id="kobo.709.1">Create one</span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.710.1"> descriptor set and update it</span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.711.1"> every time you need </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">to render.</span></span></li>
</ol>
<h2 id="_idParaDest-163"><a id="_idTextAnchor189"/><span class="koboSpan" id="kobo.713.1">Updating descriptor sets during rendering</span></h2>
<p><span class="koboSpan" id="kobo.714.1">Once a descriptor</span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.715.1"> set has been allocated, it is</span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.716.1"> not associated with any resources. </span><span class="koboSpan" id="kobo.716.2">This association must happen once (if your descriptor sets are immutable) or every time you need to bind a different resource to a descriptor set. </span><span class="koboSpan" id="kobo.716.3">In this recipe, you will learn how to update descriptor sets during rendering and after you have set up the pipeline and </span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">its layout.</span></span></p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor190"/><span class="koboSpan" id="kobo.718.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.719.1">In the repository, </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">VulkanCore::Pipeline</span></strong><span class="koboSpan" id="kobo.721.1"> provides methods to update different types of resources, as each binding can only be associated with one type of resource (image, sampler, or buffer): </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">updateSamplersDescriptorSets()</span></strong><span class="koboSpan" id="kobo.723.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">updateTexturesDescriptorSets()</span></strong><span class="koboSpan" id="kobo.725.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">updateBuffersDescriptorSets</span></strong></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">.</span></span></p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor191"/><span class="koboSpan" id="kobo.730.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.731.1">Associating a resource with a descriptor set is done with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">vkUpdateDescriptorSets</span></strong><span class="koboSpan" id="kobo.733.1"> function. </span><span class="koboSpan" id="kobo.733.2">Each call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">vkUpdateDescriptorSets</span></strong><span class="koboSpan" id="kobo.735.1"> can update one or more bindings of one or more sets. </span><span class="koboSpan" id="kobo.735.2">Before updating a descriptor set, let’s look at how to update </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.736.1">one</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.737.1"> binding.</span></span></p>
<p><span class="koboSpan" id="kobo.738.1">You can associate either a texture, a texture array, a sampler, a sampler array, a buffer, or a buffer array with one binding. </span><span class="koboSpan" id="kobo.738.2">To associate images or samplers, use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">VkDescriptorImageInfo</span></strong><span class="koboSpan" id="kobo.740.1"> structure. </span><span class="koboSpan" id="kobo.740.2">To associate buffers, use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">VkDescriptorBufferInfo</span></strong><span class="koboSpan" id="kobo.742.1"> structure. </span><span class="koboSpan" id="kobo.742.2">Once one or more of those structures have been instantiated, use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">VkWriteDescriptorSet</span></strong><span class="koboSpan" id="kobo.744.1"> structure to bind them all with a binding. </span><span class="koboSpan" id="kobo.744.2">Bindings that represent an array are updated with a vector </span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">VkDescriptor*Info</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.747.1">.</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.748.1">Consider the bindings declared in the shader code </span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">presented next:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.750.1">
layout(set = 1, binding = 0) uniform texture2D textures[];
layout(set = 1, binding = 1) uniform sampler   samplers[];
layout(set = 2, binding = 0) readonly buffer VertexBuffer
{
  Vertex vertices[];
} vertexBuffer;</span></pre></li> <li><span class="koboSpan" id="kobo.751.1">To </span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.752.1">update </span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.753.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">textures[]</span></strong><span class="koboSpan" id="kobo.755.1"> array, we need to create two instances of </span><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">VkDescriptorImageInfo</span></strong><span class="koboSpan" id="kobo.757.1"> and record them in the first </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">VkWriteDescriptorSet</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.759.1"> structure:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.760.1">
VkImageView imageViews[2];  // Valid Image View objects
VkDescriptorImageInfo texInfos[] = {
 VkDescriptorImageInfo{
  .imageView = imageViews[0],
  .imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
    },
 VkDescriptorImageInfo{
  .imageView = imageViews[1],
  .imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
 },
};
const VkWriteDescriptorSet texWriteDescSet = {
    .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
    .dstSet = 1,
    ee,
    .dstArrayElement = 0,
    .descriptorCount = 2,
    .descriptorType = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
    .pImageInfo = &amp;texInfos,
    .pBufferInfo = nullptr,
};</span></pre></li> <li><span class="koboSpan" id="kobo.761.1">The two image views</span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.762.1"> will be</span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.763.1"> bound to set 1 (</span><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">.dstSet = 1</span></strong><span class="koboSpan" id="kobo.765.1">) and binding 0 (</span><strong class="source-inline"><span class="koboSpan" id="kobo.766.1">.dstBinding = 0</span></strong><span class="koboSpan" id="kobo.767.1">) as elements 0 and 1 of the array. </span><span class="koboSpan" id="kobo.767.2">If you need to bind more objects to the array, all you need are more instances of </span><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">VkDescriptorImageInfo</span></strong><span class="koboSpan" id="kobo.769.1">. </span><span class="koboSpan" id="kobo.769.2">The number of objects bound to the current binding is specified by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">descriptorCount</span></strong><span class="koboSpan" id="kobo.771.1"> member of </span><span class="No-Break"><span class="koboSpan" id="kobo.772.1">the structure.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.773.1">The process is similar for </span><span class="No-Break"><span class="koboSpan" id="kobo.774.1">sampler objects:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.775.1">
VkSampler sampler[2];  // Valid Sampler object
VkDescriptorImageInfo samplerInfos[] = {
    VkDescriptorImageInfo{
        .sampler = sampler[0],
    },
    VkDescriptorImageInfo{
        .sampler = sampler[1],
    },
};
const VkWriteDescriptorSet samplerWriteDescSet = {
    .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
    .dstSet = 1,
    .dstBinding = 1,
    .dstArrayElement = 0,
    .descriptorCount = 2,
    .descriptorType = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
    .pImageInfo = &amp;samplerInfos,
    .pBufferInfo = nullptr,
};</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.776.1">This time, we </span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.777.1">are binding the </span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.778.1">sampler objects to set 1, binding 1. </span><span class="koboSpan" id="kobo.778.2">Buffers are bound using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">VkDescriptorBufferInfo</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.780.1"> structure:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.781.1">VkBuffer buffer;            // Valid Buffer object
VkDeviceSize bufferLength;  // Range of the buffer
const VkDescriptorBufferInfo bufferInfo = {
    .buffer = buffer,
    .offset = 0,
    .range = bufferLength,
};
const VkWriteDescriptorSet bufferWriteDescSet = {
  .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
  </span><strong class="bold"><span class="koboSpan" id="kobo.782.1">.dstSet = 2,</span></strong><span class="koboSpan" id="kobo.783.1">
  </span><strong class="bold"><span class="koboSpan" id="kobo.784.1">.dstBinding = 0,</span></strong><span class="koboSpan" id="kobo.785.1">
  .dstArrayElement = 0,
  </span><strong class="bold"><span class="koboSpan" id="kobo.786.1">.descriptorCount = 1,</span></strong><span class="koboSpan" id="kobo.787.1">
  .descriptorType = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
  .pImageInfo = nullptr,
  .pBufferInfo = &amp;bufferInfo,
};</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.788.1">Besides storing the address of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.789.1">bufferInfo</span></strong><span class="koboSpan" id="kobo.790.1"> variable to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">.pBufferInfo</span></strong><span class="koboSpan" id="kobo.792.1"> member of </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">VkWriteDescriptorSet</span></strong><span class="koboSpan" id="kobo.794.1">, we are binding one buffer (</span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">.descriptorCount = 1</span></strong><span class="koboSpan" id="kobo.796.1">) to set 2 (</span><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">.dstSet = 2</span></strong><span class="koboSpan" id="kobo.798.1">) and binding </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">0 </span></strong><span class="koboSpan" id="kobo.800.1">(</span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">.dstBinding = </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.802.1">0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.803.1">).</span></span></p></li> <li><span class="koboSpan" id="kobo.804.1">The last</span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.805.1"> step </span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.806.1">consists of storing all </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">VkWriteDescriptorSet</span></strong><span class="koboSpan" id="kobo.808.1"> instances in a vector and </span><span class="No-Break"><span class="koboSpan" id="kobo.809.1">calling </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">vkUpdateDescriptorSets</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.812.1">
VkDevice device; // Valid Vulkan Device
std::vector&lt;VkWriteDescriptorSet&gt; writeDescSets;
writeDescSets.push_back(texWriteDescSet);
writeDescSets.push_back(samplerWriteDescSet);
writeDescSets.push_back(bufferWriteDescSet);
vkUpdateDescriptorSets(device, static_cast&lt;uint32_t&gt;(writeDescSets.size()),
                      writeDescSets.data(), 0, nullptr);</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.813.1">Encapsulating this task is the best way to avoid repetition and bugs introduced by forgetting a step in</span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.814.1"> the </span><span class="No-Break"><span class="koboSpan" id="kobo.815.1">update </span></span><span class="No-Break"><a id="_idIndexMarker224"/></span><span class="No-Break"><span class="koboSpan" id="kobo.816.1">procedure.</span></span></p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor192"/><span class="koboSpan" id="kobo.817.1">Passing resources to shaders (binding descriptor sets)</span></h2>
<p><span class="koboSpan" id="kobo.818.1">While rendering, we</span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.819.1"> need to bind the descriptor sets we’d like to use during a </span><span class="No-Break"><span class="koboSpan" id="kobo.820.1">draw call.</span></span></p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor193"/><span class="koboSpan" id="kobo.821.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.822.1">Binding sets is done with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">VulkanCore::Pipeline:: </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">bindDescriptorSets()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.825.1"> method.</span></span></p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor194"/><span class="koboSpan" id="kobo.826.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.827.1">To bind a descriptor set for rendering, we need to </span><span class="No-Break"><span class="koboSpan" id="kobo.828.1">call </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.829.1">vkCmdBindDescriptorSets</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.830.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.831.1">
VkCommandBuffer commandBuffer;   // Valid Command Buffer
VkPipelineLayout pipelineLayout; // Valid Pipeline layout
uint32_t set;                    // Set number
VkDescriptorSet descSet;         // Valid Descriptor Set
vkCmdBindDescriptorSets(
    commandBuffer, </span><strong class="bold"><span class="koboSpan" id="kobo.832.1">VK_PIPELINE_BIND_POINT_GRAPHICS</span></strong><span class="koboSpan" id="kobo.833.1">,
    pipelineLayout, set, 1u, &amp;descSet, 0, nullptr);</span></pre> <p><span class="koboSpan" id="kobo.834.1">Now that we’ve successfully bound a descriptor set for rendering, let’s turn our attention to another crucial aspect of our graphics pipeline: updating </span><span class="No-Break"><span class="koboSpan" id="kobo.835.1">push constants.</span></span></p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor195"/><span class="koboSpan" id="kobo.836.1">Updating push constants during rendering</span></h2>
<p><span class="koboSpan" id="kobo.837.1">Push constants </span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.838.1">are updated during </span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.839.1">rendering by recording their values directly into the command buffer </span><span class="No-Break"><span class="koboSpan" id="kobo.840.1">being recorded.</span></span></p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor196"/><span class="koboSpan" id="kobo.841.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.842.1">Updating push constants is done with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">VulkanCore::Pipeline:: </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">udpatePushConstants()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.845.1"> method.</span></span></p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor197"/><span class="koboSpan" id="kobo.846.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.847.1">Once rendered, updating push constants is straightforward. </span><span class="koboSpan" id="kobo.847.2">All you need to do is </span><span class="No-Break"><span class="koboSpan" id="kobo.848.1">call </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">vkCmdPushConstants</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.850.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.851.1">
VkCommandBuffer commandBuffer;   // Valid Command Buffer
VkPipelineLayout pipelineLayout; // Valid Pipeline Layout
glm::vec4 mat;                   // Valid matrix
vkCmdPushConstants(commandBuffer, pipelineLayout,
                   VK_SHADER_STAGE_FRAGMENT_BIT, 0,
                   sizeof(glm::vec4), &amp;mat);</span></pre> <p><span class="koboSpan" id="kobo.852.1">This call records the contents of </span><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">mat</span></strong><span class="koboSpan" id="kobo.854.1"> into the command buffer, starting at offset 0 and signaling that this data will be used by the </span><span class="No-Break"><span class="koboSpan" id="kobo.855.1">vertex shader.</span></span></p>
<h1 id="_idParaDest-172"><a id="_idTextAnchor198"/><span class="koboSpan" id="kobo.856.1">Customizing shader behavior with specialization constants</span></h1>
<p><span class="koboSpan" id="kobo.857.1">The process of </span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.858.1">compiling shader code results in immutability once completed. </span><span class="koboSpan" id="kobo.858.2">The compilation procedure carries a substantial time overhead and is generally circumvented during runtime. </span><span class="koboSpan" id="kobo.858.3">Even minor adjustments to a shader necessitate recompilation, leading to the creation of a fresh shader module and potentially a new pipeline as well – all entailing significant </span><span class="No-Break"><span class="koboSpan" id="kobo.859.1">resource-intensive operations.</span></span></p>
<p><span class="koboSpan" id="kobo.860.1">In Vulkan, specialization constants allow you to specify constant values for shader parameters at pipeline creation time, instead of having to recompile the shader with new values every time you want to change them. </span><span class="koboSpan" id="kobo.860.2">This can be particularly useful when you want to reuse the same shader with different constant values multiple times. </span><span class="koboSpan" id="kobo.860.3">In this recipe, we will delve deeper into the practical application of specialization constants in Vulkan to create more efficient and flexible shader programs, allowing you to adjust without the need for </span><span class="No-Break"><span class="koboSpan" id="kobo.861.1">resource-intensive recompilations.</span></span></p>
<h2 id="_idParaDest-173"><a id="_idTextAnchor199"/><span class="koboSpan" id="kobo.862.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.863.1">Specialization constants are available in the repository through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.864.1">VulkanCore::Pipeline::GraphicsPipelineDescriptor</span></strong><span class="koboSpan" id="kobo.865.1"> structure. </span><span class="koboSpan" id="kobo.865.2">You need to provide a vector of </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">VkSpecializationMapEntry</span></strong><span class="koboSpan" id="kobo.867.1"> structures for each shader type </span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.868.1">you’d like to apply specialization </span><span class="No-Break"><span class="koboSpan" id="kobo.869.1">constants to.</span></span></p>
<h2 id="_idParaDest-174"><a id="_idTextAnchor200"/><span class="koboSpan" id="kobo.870.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.871.1">Specialization constants are declared in GLSL using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.872.1">constant_id</span></strong><span class="koboSpan" id="kobo.873.1"> qualifier along with an integer that specifies the </span><span class="No-Break"><span class="koboSpan" id="kobo.874.1">constant’s ID:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.875.1">
layout (</span><strong class="bold"><span class="koboSpan" id="kobo.876.1">constant_id</span></strong><span class="koboSpan" id="kobo.877.1"> = 0) const bool useShaderDebug = false;</span></pre> <p><span class="koboSpan" id="kobo.878.1">To create a pipeline with specialized constant values, you first need to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">VkSpecializationInfo</span></strong><span class="koboSpan" id="kobo.880.1"> structure that specifies the constant values and their IDs. </span><span class="koboSpan" id="kobo.880.2">You then pass this structure to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">VkPipelineShaderStageCreateInfo</span></strong><span class="koboSpan" id="kobo.882.1"> structure when creating </span><span class="No-Break"><span class="koboSpan" id="kobo.883.1">a pipeline:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.884.1">
const bool kUseShaderDebug = false;
const VkSpecializationMapEntry useShaderDebug = {
    .constantID = 0, // matches the </span><strong class="bold"><span class="koboSpan" id="kobo.885.1">constant_id</span></strong><span class="koboSpan" id="kobo.886.1"> qualifier
    .offset = 0,
    .size = sizeof(bool),
};
const VkSpecializationInfo vertexSpecializationInfo = {
    .mapEntryCount = 1,
    .pMapEntries = &amp;useShaderDebug,
    .dataSize = sizeof(bool),
    .pData = &amp;kUseShaderDebug,
};
const VkPipelineShaderStageCreateInfo shaderStageInfo = {
  ...
</span><span class="koboSpan" id="kobo.886.2">  .pSpecializationInfo = &amp;vertexSpecializationInfo,
};</span></pre> <p><span class="koboSpan" id="kobo.887.1">Because specialization constants are real constants, branches that depend on them may be entirely removed during the final compilation of the shader. </span><span class="koboSpan" id="kobo.887.2">On the other hand, specialization constants should not be used to control parameters such as uniforms, as they are not as </span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.888.1">flexible and require to be known during the construction of </span><span class="No-Break"><span class="koboSpan" id="kobo.889.1">the pipeline.</span></span></p>
<h1 id="_idParaDest-175"><a id="_idTextAnchor201"/><span class="koboSpan" id="kobo.890.1">Implementing MDI and PVP</span></h1>
<p><span class="koboSpan" id="kobo.891.1">MDI and PVP</span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.892.1"> are features of modern graphics APIs </span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.893.1">that allow for greater flexibility and efficiency in </span><span class="No-Break"><span class="koboSpan" id="kobo.894.1">vertex processing.</span></span></p>
<p><span class="koboSpan" id="kobo.895.1">MDI allows issuing multiple draw calls with a single command, each of which derives its parameters from a buffer stored in the device (hence the </span><em class="italic"><span class="koboSpan" id="kobo.896.1">indirect</span></em><span class="koboSpan" id="kobo.897.1"> term). </span><span class="koboSpan" id="kobo.897.2">This is particularly useful because those parameters can be modified in the </span><span class="No-Break"><span class="koboSpan" id="kobo.898.1">GPU itself.</span></span></p>
<p><span class="koboSpan" id="kobo.899.1">With PVP, each shader instance retrieves its vertex data based on its index and instance IDs instead of being initialized with the vertex’s attributes. </span><span class="koboSpan" id="kobo.899.2">This allows for flexibility because the vertex attributes and their format are not baked into the pipeline and can be changed solely based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.900.1">shader code.</span></span></p>
<p><span class="koboSpan" id="kobo.901.1">In the first sub-recipe, we will focus on the implementation of </span><strong class="bold"><span class="koboSpan" id="kobo.902.1">MDI</span></strong><span class="koboSpan" id="kobo.903.1">, demonstrating how this powerful tool can streamline your graphics operations by allowing multiple draw calls to be issued from a single command, with parameters that can be modified directly in the GPU. </span><span class="koboSpan" id="kobo.903.2">In the following sub-recipe, we will guide you through the process of setting up </span><strong class="bold"><span class="koboSpan" id="kobo.904.1">PVP</span></strong><span class="koboSpan" id="kobo.905.1">, highlighting how the flexibility of this feature can enhance your shader code by enabling changes </span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.906.1">to </span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.907.1">vertex attributes without modifying </span><span class="No-Break"><span class="koboSpan" id="kobo.908.1">the pipeline.</span></span></p>
<h2 id="_idParaDest-176"><a id="_idTextAnchor202"/><span class="koboSpan" id="kobo.909.1">Implementing MDI</span></h2>
<p><span class="koboSpan" id="kobo.910.1">For using MDI, we</span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.911.1"> store all mesh data belonging to the scene in one big buffer for all the meshes’ vertices and another one for the meshes’ indices, with the data for each mesh stored sequentially, as depicted in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.912.1">Figure 2</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.913.1">.12</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.914.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.915.1">The drawing parameters are stored in an extra buffer. </span><span class="koboSpan" id="kobo.915.2">They must be stored sequentially, one for each</span><a id="_idTextAnchor203"/><span class="koboSpan" id="kobo.916.1"> mesh, although they don’t have to be provided in the same order as </span><span class="No-Break"><span class="koboSpan" id="kobo.917.1">the meshes:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<span class="koboSpan" id="kobo.918.1"><img alt="Figure 2.12 – MDI data layout" src="image/B18491_02_12.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.919.1">Figure 2.12 – MDI data layout</span></p>
<p><span class="koboSpan" id="kobo.920.1">We will now learn how to implement MDI using the </span><span class="No-Break"><span class="koboSpan" id="kobo.921.1">Vulkan API.</span></span></p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor204"/><span class="koboSpan" id="kobo.922.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.923.1">In the repository, we </span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.924.1">provide a utility function to decompose an </span><strong class="source-inline"><span class="koboSpan" id="kobo.925.1">EngineCore::Model</span></strong><span class="koboSpan" id="kobo.926.1"> object into multiple buffers suitable for an MDI implementation, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.927.1">EngineCore::convertModel2OneBuffer()</span></strong><span class="koboSpan" id="kobo.928.1">, located </span><span class="No-Break"><span class="koboSpan" id="kobo.929.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">GLBLoader.cpp</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.931.1">.</span></span></p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor205"/><span class="koboSpan" id="kobo.932.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.933.1">Let’s begin by looking at the indirect draw </span><span class="No-Break"><span class="koboSpan" id="kobo.934.1">parameters’ buffer.</span></span></p>
<p><span class="koboSpan" id="kobo.935.1">The commands are stored following the same layout as the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.936.1">VkDrawIndexedIndirectCommand</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.937.1"> structure:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.938.1">
typedef struct VkDrawIndexedIndirectCommand {
    uint32_t    indexCount;
    uint32_t    instanceCount;
    uint32_t    firstIndex;
    int32_t     vertexOffset;
    uint32_t    firstInstance;
} VkDrawIndexedIndirectCommand;</span></pre> <p><strong class="source-inline"><span class="koboSpan" id="kobo.939.1">indexCount</span></strong><span class="koboSpan" id="kobo.940.1"> specifies how many indices are part of this command and, in our case, is the number of indices for a mesh. </span><span class="koboSpan" id="kobo.940.2">One command reflects one mesh, so its </span><strong class="source-inline"><span class="koboSpan" id="kobo.941.1">instanceCount</span></strong><span class="koboSpan" id="kobo.942.1"> value is one. </span><span class="koboSpan" id="kobo.942.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.943.1">firstVertex</span></strong><span class="koboSpan" id="kobo.944.1"> member is the index of the first index element in the buffer to use for this mesh, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.945.1">vertexOffset</span></strong><span class="koboSpan" id="kobo.946.1"> points to the first vertex element</span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.947.1"> in the buffer to use. </span><span class="koboSpan" id="kobo.947.2">An example with the correct offsets is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.948.1">Figure 2</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.949.1">.12</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.950.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.951.1">Once the vertex, index, and indirect commands buffers are bound, calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">vkCmdDrawIndexedIndirect</span></strong><span class="koboSpan" id="kobo.953.1"> consists of providing the buffer with the indirect commands and an offset into the buffer. </span><span class="koboSpan" id="kobo.953.2">The rest is done by </span><span class="No-Break"><span class="koboSpan" id="kobo.954.1">the device:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.955.1">
VkCommandBuffer commandBuffer;  // Valid Command Bufer
VkBuffer indirectCmdBuffer;     // Valid buffer w/
                                // indirect commands
uint32_t meshCount;  // Number of indirect commands in
                     // the buffer
uint32_t offset = 0; // Offset into the indirect commands
                     // buffer
vkCmdDrawIndexedIndirect(
    commandBuffer, indirectCmdBuffer, offset,
    meshCount,
    sizeof(VkDrawIndexedIndirectDrawCommand));</span></pre> <p><span class="koboSpan" id="kobo.956.1">In this recipe, we learned how to utilize </span><strong class="source-inline"><span class="koboSpan" id="kobo.957.1">vkCmdDrawIndexedIndirect</span></strong><span class="koboSpan" id="kobo.958.1">, a key function in </span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.959.1">Vulkan that allows for </span><span class="No-Break"><span class="koboSpan" id="kobo.960.1">high-efficiency drawing.</span></span></p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor206"/><span class="koboSpan" id="kobo.961.1">Using PVP</span></h2>
<p><span class="koboSpan" id="kobo.962.1">The PVP technique</span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.963.1"> allows vertex data and their attributes to be extracted from buffers with custom code instead of relying on the pipeline to provide them to </span><span class="No-Break"><span class="koboSpan" id="kobo.964.1">vertex shaders.</span></span></p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor207"/><span class="koboSpan" id="kobo.965.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.966.1">We will use the following structures to perform the extraction of vertex data – the </span><strong class="source-inline"><span class="koboSpan" id="kobo.967.1">Vertex</span></strong><span class="koboSpan" id="kobo.968.1"> structure, which encodes the vertex’s position (</span><strong class="source-inline"><span class="koboSpan" id="kobo.969.1">pos</span></strong><span class="koboSpan" id="kobo.970.1">), </span><strong class="source-inline"><span class="koboSpan" id="kobo.971.1">normal</span></strong><span class="koboSpan" id="kobo.972.1">, UV coordinates (</span><strong class="source-inline"><span class="koboSpan" id="kobo.973.1">uv</span></strong><span class="koboSpan" id="kobo.974.1">), and its material </span><span class="No-Break"><span class="koboSpan" id="kobo.975.1">index (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.976.1">material</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.977.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.978.1">
struct Vertex {
    vec3 pos;
    vec3 normal;
    vec2 uv;
    int material;
};</span></pre> <p><span class="koboSpan" id="kobo.979.1">We will also use a buffer object, referred to in the shader </span><span class="No-Break"><span class="koboSpan" id="kobo.980.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.981.1">VertexBuffer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.982.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.983.1">
layout(set = 2, binding = 0) readonly buffer VertexBuffer
{
    Vertex vertices[];
} vertexBuffer;</span></pre> <p><span class="koboSpan" id="kobo.984.1">Next, we will learn how to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.985.1">vertexBuffer</span></strong><span class="koboSpan" id="kobo.986.1"> object to access </span><span class="No-Break"><span class="koboSpan" id="kobo.987.1">vertex data.</span></span></p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor208"/><span class="koboSpan" id="kobo.988.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.989.1">The shader code used to access the vertex data looks </span><span class="No-Break"><span class="koboSpan" id="kobo.990.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.991.1">
void main() {
  Vertex vertex = vertexBuffer.vertices[gl_VertexIndex];
}</span></pre> <p><span class="koboSpan" id="kobo.992.1">Note that the vertex and its attributes are not declared as inputs to the shader. </span><strong class="source-inline"><span class="koboSpan" id="kobo.993.1">gl_VertexIndex</span></strong><span class="koboSpan" id="kobo.994.1"> is automatically computed and provided to the shader based on the draw call and the parameters recorded in the indirect command retrieved from the indirect </span><span class="No-Break"><span class="koboSpan" id="kobo.995.1">command</span></span><span class="No-Break"><a id="_idIndexMarker240"/></span><span class="No-Break"><span class="koboSpan" id="kobo.996.1"> buffer.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.997.1">Index and vertex buffers</span></p>
<p class="callout"><span class="koboSpan" id="kobo.998.1">Note that both the index and vertex buffers are still provided and bound to the pipeline before the draw call is issued. </span><span class="koboSpan" id="kobo.998.2">The index buffer must have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.999.1">VK_BUFFER_USAGE_INDEX_BUFFER_BIT</span></strong><span class="koboSpan" id="kobo.1000.1"> flag enabled for the technique </span><span class="No-Break"><span class="koboSpan" id="kobo.1001.1">to work.</span></span></p>
<h1 id="_idParaDest-182"><a id="_idTextAnchor209"/><span class="koboSpan" id="kobo.1002.1">Adding flexibility to the rendering pipeline using dynamic rendering</span></h1>
<p><span class="koboSpan" id="kobo.1003.1">In this recipe, we </span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.1004.1">will delve into</span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.1005.1"> the practical application of dynamic rendering in Vulkan to enhance the flexibility of the rendering pipeline. </span><span class="koboSpan" id="kobo.1005.2">We will guide you through the process of creating pipelines without the need for render passes and framebuffers and discuss how to ensure synchronization. </span><span class="koboSpan" id="kobo.1005.3">By the end of this section, you will have learned how to implement this feature in your projects, thereby simplifying your rendering process by eliminating the need for render passes and framebuffers and giving you more direct control </span><span class="No-Break"><span class="koboSpan" id="kobo.1006.1">over synchronization.</span></span></p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor210"/><span class="koboSpan" id="kobo.1007.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.1008.1">To enable the feature, we must have access to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1009.1">VK_KHR_get_physical_device_properties2</span></strong><span class="koboSpan" id="kobo.1010.1"> instance extension, instantiate a structure of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1011.1">VkPhysicalDeviceDynamicRenderingFeatures</span></strong><span class="koboSpan" id="kobo.1012.1">, and set its </span><strong class="source-inline"><span class="koboSpan" id="kobo.1013.1">dynamicRendering</span></strong><span class="koboSpan" id="kobo.1014.1"> member </span><span class="No-Break"><span class="koboSpan" id="kobo.1015.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1016.1">true</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1017.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1018.1">
const VkPhysicalDeviceDynamicRenderingFeatures dynamicRenderingFeatures = {
      .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES,
      .dynamicRendering = VK_TRUE,
  };</span></pre> <p><span class="koboSpan" id="kobo.1019.1">This structure needs to be plugged into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1020.1">VkDeviceCreateInfo::pNext</span></strong><span class="koboSpan" id="kobo.1021.1"> member when creating a </span><span class="No-Break"><span class="koboSpan" id="kobo.1022.1">Vulkan device:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1023.1">
const VkDeviceCreateInfo dci = {
    .sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
    .pNext = &amp;dynamicRenderingFeatures,
    ...
</span><span class="koboSpan" id="kobo.1023.2">};</span></pre> <p><span class="koboSpan" id="kobo.1024.1">Having grasped</span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.1025.1"> the </span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.1026.1">concept of enabling dynamic rendering, we will now move forward and explore its implementation using the </span><span class="No-Break"><span class="koboSpan" id="kobo.1027.1">Vulkan API.</span></span></p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor211"/><span class="koboSpan" id="kobo.1028.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.1029.1">Instead of creating render passes and framebuffers, we must call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1030.1">vkCmdBeginRendering</span></strong><span class="koboSpan" id="kobo.1031.1"> command and provide the attachments and their load and store operations using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1032.1">VkRenderingInfo</span></strong><span class="koboSpan" id="kobo.1033.1"> structure. </span><span class="koboSpan" id="kobo.1033.2">Each attachment (colors, depth, and stencil) must be specified with instances of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1034.1">VkRenderingAttachmentInfo</span></strong><span class="koboSpan" id="kobo.1035.1"> structure. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1036.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1037.1">.13</span></em> <a id="_idTextAnchor212"/><span class="koboSpan" id="kobo.1038.1">presents a diagram of the structure participating in a call </span><span class="No-Break"><span class="koboSpan" id="kobo.1039.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1040.1">vkCmdBeginRendering</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1041.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer030">
<span class="koboSpan" id="kobo.1042.1"><img alt="Figure 2.13 – Dynamic rendering structure diagram" src="image/B18491_02_13.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1043.1">Figure 2.13 – Dynamic rendering structure diagram</span></p>
<p><span class="koboSpan" id="kobo.1044.1">Any one of the attachments, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1045.1">pColorAttachments</span></strong><span class="koboSpan" id="kobo.1046.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1047.1">pDepthAttachment</span></strong><span class="koboSpan" id="kobo.1048.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1049.1">pStencilAttachment</span></strong><span class="koboSpan" id="kobo.1050.1">, can be </span><strong class="source-inline"><span class="koboSpan" id="kobo.1051.1">null</span></strong><span class="koboSpan" id="kobo.1052.1">. </span><span class="koboSpan" id="kobo.1052.2">Shader output written to location </span><strong class="source-inline"><span class="koboSpan" id="kobo.1053.1">x</span></strong><span class="koboSpan" id="kobo.1054.1"> is written to the </span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.1055.1">color</span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.1056.1"> attachment </span><span class="No-Break"><span class="koboSpan" id="kobo.1057.1">at </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1058.1">pColorAttachment[x]</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1059.1">.</span></span></p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor213"/><span class="koboSpan" id="kobo.1060.1">Transferring resources between queue families</span></h1>
<p><span class="koboSpan" id="kobo.1061.1">In this recipe, we </span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.1062.1">will demonstrate </span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.1063.1">how to transfer resources between queue families by uploading textures to a device from the CPU using a transfer queue and generating mip-level data in a graphics queue. </span><span class="koboSpan" id="kobo.1063.2">Generating mip levels needs a graphics queue because it utilizes </span><strong class="source-inline"><span class="koboSpan" id="kobo.1064.1">vkCmdBlitImage</span></strong><span class="koboSpan" id="kobo.1065.1">, supported only by </span><span class="No-Break"><span class="koboSpan" id="kobo.1066.1">graphics queues.</span></span></p>
<h2 id="_idParaDest-186"><a id="_idTextAnchor214"/><span class="koboSpan" id="kobo.1067.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.1068.1">An example is provided in the repository in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1069.1">chapter2/mainMultiDrawIndirect.cpp</span></strong><span class="koboSpan" id="kobo.1070.1">, which uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1071.1">EngineCore::AsyncDataUploader</span></strong><span class="koboSpan" id="kobo.1072.1"> class to perform texture upload and mipmap generation on </span><span class="No-Break"><span class="koboSpan" id="kobo.1073.1">different queues.</span></span></p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor215"/><span class="koboSpan" id="kobo.1074.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.1075.1">In the following diagram, we illustrate the procedure of uploading texture through </span><a id="_idTextAnchor216"/><span class="koboSpan" id="kobo.1076.1">a transfer queue, followed</span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.1077.1"> by the utilization of a graphics</span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.1078.1"> queue for </span><span class="No-Break"><span class="koboSpan" id="kobo.1079.1">mip generation:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer031">
<span class="koboSpan" id="kobo.1080.1"><img alt="Figure 2.14 – Recoding and submitting commands from different threads and transferring a resource between queues from different families" src="image/B18491_02_14.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1081.1">Figure 2.14 – Recoding and submitting commands from different threads and transferring a resource between queues from different families</span></p>
<p><span class="koboSpan" id="kobo.1082.1">The process can be summarized </span><span class="No-Break"><span class="koboSpan" id="kobo.1083.1">as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1084.1">Record the commands to upload the texture to the device and add a barrier to release the texture from the transfer queue using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1085.1">VkDependencyInfo</span></strong><span class="koboSpan" id="kobo.1086.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1087.1">VkImageMemoryBarrier2</span></strong><span class="koboSpan" id="kobo.1088.1"> structures, specifying the source queue family as the family of the transfer queue and the destination queue family as the family of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1089.1">graphics queue.</span></span></li>
<li><span class="koboSpan" id="kobo.1090.1">Create a semaphore and use it to signal when the command buffer finishes, and attach it to the submission of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1091.1">command buffer.</span></span></li>
<li><span class="koboSpan" id="kobo.1092.1">Create a command buffer for generating mip levels and add a barrier to acquire the texture from the transfer queue into the graphics queue using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1093.1">VkDependencyInfo</span></strong><span class="koboSpan" id="kobo.1094.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1095.1">VkImageMemoryBarrier2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1096.1"> structures.</span></span></li>
<li><span class="koboSpan" id="kobo.1097.1">Attach the semaphore created in </span><em class="italic"><span class="koboSpan" id="kobo.1098.1">step 2</span></em><span class="koboSpan" id="kobo.1099.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1100.1">SubmitInfo</span></strong><span class="koboSpan" id="kobo.1101.1"> structure when submitting the command buffer for processing. </span><span class="koboSpan" id="kobo.1101.2">The semaphore will be signaled when the first command buffer has completed, allowing the mip-level-generation command buffer </span><span class="No-Break"><span class="koboSpan" id="kobo.1102.1">to start.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.1103.1">Two</span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.1104.1"> auxiliary </span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.1105.1">methods will help us create acquire and release barriers for a texture. </span><span class="koboSpan" id="kobo.1105.2">They exist in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1106.1">VulkanCore::Texture</span></strong><span class="koboSpan" id="kobo.1107.1"> class. </span><span class="koboSpan" id="kobo.1107.2">The first one creates an </span><span class="No-Break"><span class="koboSpan" id="kobo.1108.1">acquire barrier:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.1109.1">
void Texture::addAcquireBarrier(
    VkCommandBuffer cmdBuffer,
    uint32_t srcQueueFamilyIndex,
    uint32_t dstQueueFamilyIndex) {
  VkImageMemoryBarrier2 acquireBarrier = {
      .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2,
      .dstStageMask =
          VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT,
      .dstAccessMask = VK_ACCESS_2_MEMORY_READ_BIT,
      .srcQueueFamilyIndex = srcQueueFamilyIndex,
      .dstQueueFamilyIndex = dstQueueFamilyIndex,
      .image = image_,
      .subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT,
                           0, mipLevels_, 0, 1},
  };
  VkDependencyInfo dependency_info{
      .sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO,
      .imageMemoryBarrierCount = 1,
      .pImageMemoryBarriers = &amp;acquireBarrier,
  };
  vkCmdPipelineBarrier2(cmdBuffer, &amp;dependency_info);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1110.1">Besides the command buffer, this function requires the indices of the source and destination family queues. </span><span class="koboSpan" id="kobo.1110.2">It also assumes a few things, such as the subresource range spanning the </span><span class="No-Break"><span class="koboSpan" id="kobo.1111.1">entire image.</span></span></p></li> <li><span class="koboSpan" id="kobo.1112.1">Another</span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.1113.1"> method </span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.1114.1">records the </span><span class="No-Break"><span class="koboSpan" id="kobo.1115.1">release barrier:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1116.1">
void Texture::addReleaseBarrier(
    VkCommandBuffer cmdBuffer,
    uint32_t srcQueueFamilyIndex,
    uint32_t dstQueueFamilyIndex) {
  VkImageMemoryBarrier2 releaseBarrier = {
      .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2,
      .srcStageMask = VK_PIPELINE_STAGE_2_TRANSFER_BIT,
      .srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT,
      .dstAccessMask = VK_ACCESS_SHADER_READ_BIT,
      .srcQueueFamilyIndex = srcQueueFamilyIndex,
      .dstQueueFamilyIndex = dstQueueFamilyIndex,
      .image = image_,
      .subresourceRange = {VK_IMAGE_ASPECT_COLOR_BIT,
                           0, mipLevels_, 0, 1},
  };
  VkDependencyInfo dependency_info{
      .sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO,
      .imageMemoryBarrierCount = 1,
      .pImageMemoryBarriers = &amp;releaseBarrier,
  };
  vkCmdPipelineBarrier2(cmdBuffer, &amp;dependency_info);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1117.1">This method makes the same assumptions as the previous one. </span><span class="koboSpan" id="kobo.1117.2">The main differences are the source and destination stages and </span><span class="No-Break"><span class="koboSpan" id="kobo.1118.1">access masks.</span></span></p></li> <li><span class="koboSpan" id="kobo.1119.1">To perform</span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.1120.1"> the</span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.1121.1"> upload and mipmap generation, we create two instances of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1122.1">VulkanCore::CommandQueueManager</span></strong><span class="koboSpan" id="kobo.1123.1">, one for the transfer queue and another for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1124.1">graphics queue:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1125.1">
auto transferQueueMgr =
    context.createTransferCommandQueue(
        1, 1, "transfer queue");
auto graphicsQueueMgr =
    context.createGraphicsCommandQueue(
        1, 1, "graphics queue");</span></pre></li> <li><span class="koboSpan" id="kobo.1126.1">With valid </span><strong class="source-inline"><span class="koboSpan" id="kobo.1127.1">VulkanCore::Context</span></strong><span class="koboSpan" id="kobo.1128.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1129.1">VulkanCore::Texture</span></strong><span class="koboSpan" id="kobo.1130.1"> instances in hand, we can upload the texture by retrieving a command buffer from the</span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.1131.1"> transfer</span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.1132.1"> family. </span><span class="koboSpan" id="kobo.1132.2">We also create a staging buffer for transferring the texture data to </span><span class="No-Break"><span class="koboSpan" id="kobo.1133.1">device-local memory:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1134.1">
VulkanCore::Context context;  // Valid Context
std::shared_ptr&lt;VulkanCore::Texture&gt;
    texture;        // Valid Texture
void* textureData;  // Valid texture data
// Upload texture
auto textureUploadStagingBuffer =
    context.createStagingBuffer(
        texture-&gt;vkDeviceSize(),
        VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
        "texture upload staging buffer");
const auto commandBuffer =
    transferQueueMgr.getCmdBufferToBegin();
texture-&gt;uploadOnly(commandBuffer,
                    textureUploadStagingBuffer.get(),
                    textureData);
texture-&gt;addReleaseBarrier(
    commandBuffer,
    transferQueueMgr.queueFamilyIndex(),
    graphicsQueueMgr.queueFamilyIndex());
transferQueueMgr.endCmdBuffer(commandBuffer);
transferQueueMgr.disposeWhenSubmitCompletes(
    std::move(textureUploadStagingBuffer));</span></pre></li> <li><span class="koboSpan" id="kobo.1135.1">For submitting the command buffer for processing, we create a semaphore to synchronize the</span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.1136.1"> upload</span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.1137.1"> command buffer and the one used for </span><span class="No-Break"><span class="koboSpan" id="kobo.1138.1">generating mipmaps:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1139.1">
VkSemaphore graphicsSemaphore;
const VkSemaphoreCreateInfo semaphoreInfo{
    .sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
};
VK_CHECK(vkCreateSemaphore(context.device(),
                            &amp;semaphoreInfo, nullptr,
                            &amp;graphicsSemaphore));
VkPipelineStageFlags flags =
    VK_PIPELINE_STAGE_TRANSFER_BIT;
auto submitInfo =
    context.swapchain()-&gt;createSubmitInfo(
        &amp;commandBuffer, &amp;flags, false, false);
submitInfo.signalSemaphoreCount = 1;
submitInfo.pSignalSemaphores = &amp;graphicsSemaphore;
transferQueueMgr.submit(&amp;submitInfo);</span></pre></li> <li><span class="koboSpan" id="kobo.1140.1">The next step is to acquire a new command buffer from the graphics queue family for generating mipmaps. </span><span class="koboSpan" id="kobo.1140.2">We also create an acquire barrier and reuse the semaphore from the previous command </span><span class="No-Break"><span class="koboSpan" id="kobo.1141.1">buffer submission:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1142.1">
// Generate mip levels
auto commandBuffer =
    graphicsQueueMgr.getCmdBufferToBegin();
texture-&gt;addAcquireBarrier(
    commandBuffer,
    transferCommandQueueMgr_.queueFamilyIndex(),
    graphicsQueueMgr.queueFamilyIndex());
texture-&gt;generateMips(commandBuffer);
graphicsQueueMgr.endCmdBuffer(commandBuffer);
VkPipelineStageFlags flags =
    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
auto submitInfo =
    context_.swapchain()-&gt;createSubmitInfo(
        &amp;commandBuffer, &amp;flags, false, false);
submitInfo.pWaitSemaphores = &amp;graphicsSemaphore;
submitInfo.waitSemaphoreCount = 1;</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.1143.1">In this chapter, we </span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.1144.1">have</span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.1145.1"> navigated the complex landscape of advanced Vulkan programming, building upon the foundational concepts introduced earlier. </span><span class="koboSpan" id="kobo.1145.2">Our journey encompassed a diverse range of topics, each contributing crucial insights to the realm of high-performance graphics applications. </span><span class="koboSpan" id="kobo.1145.3">From mastering Vulkan’s intricate memory model and efficient allocation techniques to harnessing the power of the VMA library, we’ve equipped ourselves with the tools to optimize memory management. </span><span class="koboSpan" id="kobo.1145.4">We explored the creation and manipulation of buffers and images, uncovering strategies for seamless data uploads, staging buffers, and ring-buffer implementations that circumvent data races. </span><span class="koboSpan" id="kobo.1145.5">The utilization of pipeline barriers to synchronize data access was demystified, while techniques for rendering pipelines, shader customization via specialization constants, and cutting-edge rendering methodologies such as PVP and MDI were embraced. </span><span class="koboSpan" id="kobo.1145.6">Additionally, we ventured into dynamic rendering approaches without relying on render passes and addressed the intricacies of </span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.1146.1">resource</span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.1147.1"> handling across multiple threads and queues. </span><span class="koboSpan" id="kobo.1147.2">With these profound understandings, you are primed to create graphics applications that harmonize technical prowess with artistic vision using the </span><span class="No-Break"><span class="koboSpan" id="kobo.1148.1">Vulkan API.</span></span></p>
</div>
</body></html>