["```cpp\nstd::unique_ptr<lvk::ImGuiRenderer> imgui =\n  std::make_unique<lvk::ImGuiRenderer>(\n    *ctx, “data/OpenSans-Light.ttf”, 30.0f);\n```", "```cpp\nglfwSetCursorPosCallback(window,\n  [](auto* window, double x, double y) {\n    ImGui::GetIO().MousePos = ImVec2(x, y);\n  });\nglfwSetMouseButtonCallback(window,\n  [](auto* window, int button, int action, int mods) {\n    double xpos, ypos;\n    glfwGetCursorPos(window, &xpos, &ypos);\n    const ImGuiMouseButton_ imguiButton =\n     (button==GLFW_MOUSE_BUTTON_LEFT) ?\n       ImGuiMouseButton_Left:(button == GLFW_MOUSE_BUTTON_RIGHT ?\n       ImGuiMouseButton_Right : ImGuiMouseButton_Middle);\n    ImGuiIO& io               = ImGui::GetIO();\n    io.MousePos               = ImVec2((float)xpos, (float)ypos);\n    io.MouseDown[imguiButton] = action == GLFW_PRESS;\n  });\n```", "```cpp\nlvk::ICommandBuffer& buf = ctx->acquireCommandBuffer();\nconst lvk::Framebuffer framebuffer = {\n  .color = {{ .texture = ctx->getCurrentSwapchainTexture() }}};\nbuf.cmdBeginRendering({ .color = { {\n  .loadOp = lvk::LoadOp_Clear,\n  .clearColor = {1.0f, 1.0f, 1.0f, 1.0f} } } }, framebuffer);\nimgui->beginFrame(framebuffer);\n```", "```cpp\nImGui::Begin(“Texture Viewer”, nullptr,\n  ImGuiWindowFlags_AlwaysAutoResize);\nImGui::Image(ImTextureID(texture.indexAsVoid()),\n  ImVec2(512, 512));\nImGui::ShowDemoWindow();\nImGui::End();\n```", "```cpp\nimgui->endFrame(buf);\nbuf.cmdEndRendering();\nctx->submit(buf, ctx->getCurrentSwapchainTexture());\n```", "```cpp\nclass ImGuiRenderer {\n public:\n  explicit ImGuiRenderer(lvk::IContext& ctx,\n    const char* defaultFontTTF = nullptr,\n    float fontSizePixels = 24.0f);\n  ~ImGuiRenderer();\n  void updateFont(const char* defaultFontTTF, float fontSizePixels);\n```", "```cpp\n void beginFrame(const lvk::Framebuffer& desc);\n  void endFrame(lvk::ICommandBuffer& cmdBuffer);\n  void setDisplayScale(float displayScale);\n```", "```cpp\n private:\n  lvk::Holder<lvk::RenderPipelineHandle> createNewPipelineState(\n    const lvk::Framebuffer& desc);\n private:\n  lvk::IContext& ctx_;\n  lvk::Holder<lvk::ShaderModuleHandle> vert_;\n  lvk::Holder<lvk::ShaderModuleHandle> frag_;\n  lvk::Holder<lvk::RenderPipelineHandle> pipeline_;\n  lvk::Holder<lvk::TextureHandle> fontTexture_;\n  float displayScale_ = 1.0f;\n  uint32_t nonLinearColorSpace_ = 0;\n  uint32_t frameIndex_ = 0;\n```", "```cpp\n struct DrawableData {\n    lvk::Holder<BufferHandle> vb_;\n    lvk::Holder<BufferHandle> ib_;\n    uint32_t numAllocatedIndices_ = 0;\n    uint32_t numAllocatedVerteices_ = 0;\n  };\n  static constexpr uint32_t kNumSwapchainImages = 3;\n  DrawableData drawables_[kNumSwapchainImages] = {};\n};\n```", "```cpp\nlayout (location = 0) out vec4 out_color;\nlayout (location = 1) out vec2 out_uv;\nlayout (location = 2) out flat uint out_textureId;\nstruct Vertex {\n  float x, y;\n  float u, v;\n  uint rgba;\n};\nlayout(std430, buffer_reference) readonly buffer VertexBuffer {\n  Vertex vertices[];\n};\n```", "```cpp\nlayout(push_constant) uniform PushConstants {\n  vec4 LRTB;\n  VertexBuffer vb;\n  uint textureId;\n} pc;\nvoid main() {\n  float L = pc.LRTB.x;\n  float R = pc.LRTB.y;\n  float T = pc.LRTB.z;\n  float B = pc.LRTB.w;\n```", "```cpp\n mat4 proj = mat4(\n    2.0 / (R-L),              0.0,  0.0,  0.0,\n    0.0,              2.0 / (T-B),  0.0,  0.0,\n    0.0,                      0.0, -1.0,  0.0,\n    (R+L) / (L-R),  (T+B) / (B-T),  0.0,  1.0);\n```", "```cpp\n Vertex v = pc.vb.vertices[gl_VertexIndex];\n  out_color = unpackUnorm4x8(v.rgba);\n```", "```cpp\n out_uv = vec2(v.u, v.v);\n  out_textureId = pc.textureId;\n  gl_Position = proj * vec4(v.x, v.y, 0, 1);\n}\n```", "```cpp\nlayout (location = 0) in vec4 in_color;\nlayout (location = 1) in vec2 in_uv;\nlayout (location = 2) in flat uint in_textureId;\nlayout (location = 0) out vec4 out_color;\n```", "```cpp\nlayout (constant_id = 0) const bool kNonLinearColorSpace = false;\nvoid main() {\n  vec4 c = in_color * texture(sampler2D(\n    kTextures2D[in_textureId], kSamplers[0]), in_uv);\n```", "```cpp\n out_color = kNonLinearColorSpace ?\n    vec4(pow(c.rgb, vec3(2.2)), c.a) : c;\n}\n```", "```cpp\nHolder<RenderPipelineHandle> ImGuiRenderer::createNewPipelineState(\n  const lvk::Framebuffer& desc)\n{\n  nonLinearColorSpace_ =\n    ctx_.getSwapChainColorSpace() == ColorSpace_SRGB_NONLINEAR ? 1:0;\n  return ctx_.createRenderPipeline({\n    .smVert = vert_,\n    .smFrag = frag_,\n```", "```cpp\n .specInfo = { .entries = {{.constantId = 0,\n                  .size = sizeof(nonLinearColorSpace_)}},\n                  .data = &nonLinearColorSpace_,\n                  .dataSize = sizeof(nonLinearColorSpace_) },\n```", "```cpp\n .color = {{\n      .format = ctx_.getFormat(desc.color[0].texture),\n      .blendEnabled = true,\n      .srcRGBBlendFactor = lvk::BlendFactor_SrcAlpha,\n      .dstRGBBlendFactor = lvk::BlendFactor_OneMinusSrcAlpha,\n    }},\n    .depthFormat = desc.depthStencil.texture ?\n      ctx_.getFormat(desc.depthStencil.texture) :\n      lvk::Format_Invalid,\n    .cullMode = lvk::CullMode_None},\n    nullptr);\n}\n```", "```cpp\nvoid ImGuiRenderer::updateFont(\n  const char* defaultFontTTF, float fontSizePixels)\n{\n  ImGuiIO& io = ImGui::GetIO();\n  ImFontConfig cfg = ImFontConfig();\n  cfg.FontDataOwnedByAtlas = false;\n  cfg.RasterizerMultiply = 1.5f;\n  cfg.SizePixels = ceilf(fontSizePixels);\n  cfg.PixelSnapH = true;\n  cfg.OversampleH = 4;\n  cfg.OversampleV = 4;\n  ImFont* font = nullptr;\n```", "```cpp\n if (defaultFontTTF) {\n    font = io.Fonts->AddFontFromFileTTF(\n      defaultFontTTF, cfg.SizePixels, &cfg);\n  }\n  io.Fonts->Flags |= ImFontAtlasFlags_NoPowerOfTwoHeight;\n```", "```cpp\n unsigned char* pixels;\n  int width, height;\n  io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);\n  fontTexture_ = ctx_.createTexture({\n    .type = lvk::TextureType_2D,\n    .format = lvk::Format_RGBA_UN8,\n    .dimensions = {(uint32_t)width, (uint32_t)height},\n    .usage = lvk::TextureUsageBits_Sampled,\n    .data = pixels }, nullptr);\n  io.Fonts->TexID = ImTextureID(fontTexture_.indexAsVoid());\n  io.FontDefault = font;\n}\n```", "```cpp\nImGuiRenderer::ImGuiRenderer(lvk::IContext& device, const char* defaultFontTTF, float fontSizePixels) : ctx_(device) {\n  ImGui::CreateContext();\n#if defined(LVK_WITH_IMPLOT)\n  ImPlot::CreateContext();\n#endif // LVK_WITH_IMPLOT\n```", "```cpp\n ImGuiIO& io = ImGui::GetIO();\n  io.BackendRendererName = “imgui-lvk”;\n  io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset;\n```", "```cpp\n updateFont(defaultFontTTF, fontSizePixels);\n  vert_ = ctx_.createShaderModule(\n    {codeVS, Stage_Vert, “Shader Module: imgui (vert)”});\n  frag_ = ctx_.createShaderModule(\n    {codeFS, Stage_Frag, “Shader Module: imgui (frag)”});\n}\n```", "```cpp\nImGuiRenderer::~ImGuiRenderer() {\n  ImGuiIO& io = ImGui::GetIO();\n  io.Fonts->TexID = nullptr;\n#if defined(LVK_WITH_IMPLOT)\n  ImPlot::DestroyContext();\n#endif // LVK_WITH_IMPLOT\n  ImGui::DestroyContext();\n}\n```", "```cpp\nvoid ImGuiRenderer::beginFrame(const lvk::Framebuffer& desc) {\n  const lvk::Dimensions dim =\n    ctx_.getDimensions(desc.color[0].texture);\n  ImGuiIO& io = ImGui::GetIO();\n  io.DisplaySize = ImVec2(dim.width / displayScale_,\n                          dim.height / displayScale_);\n  io.DisplayFramebufferScale = ImVec2(displayScale_, displayScale_);\n  io.IniFilename = nullptr;\n  if (pipeline_.empty()) {\n    pipeline_ = createNewPipelineState(desc);\n  }\n  ImGui::NewFrame();\n}\n```", "```cpp\nvoid ImGuiRenderer::endFrame(lvk::ICommandBuffer& cmdBuffer) {\n  ImGui::EndFrame();\n  ImGui::Render();\n  ImDrawData* dd = ImGui::GetDrawData();\n  int fb_width  = (int)(dd->DisplaySize.x * dd->FramebufferScale.x);\n  int fb_height = (int)(dd->DisplaySize.y * dd->FramebufferScale.y);\n```", "```cpp\n cmdBuffer.cmdBindDepthState({});\n  cmdBuffer.cmdBindViewport({\n    .x = 0.0f,\n    .y = 0.0f,\n    .width = (dd->DisplaySize.x * dd->FramebufferScale.x),\n    .height = (dd->DisplaySize.y * dd->FramebufferScale.y),\n  });\n```", "```cpp\n const float L = dd->DisplayPos.x;\n  const float R = dd->DisplayPos.x + dd->DisplaySize.x;\n  const float T = dd->DisplayPos.y;\n  const float B = dd->DisplayPos.y + dd->DisplaySize.y;\n  const ImVec2 clipOff = dd->DisplayPos;\n  const ImVec2 clipScale = dd->FramebufferScale;\n```", "```cpp\n DrawableData& drawableData = drawables_[frameIndex_];\n  frameIndex_ =\n   (frameIndex_ + 1) % LVK_ARRAY_NUM_ELEMENTS(drawables_);\n```", "```cpp\n if (drawableData.numAllocatedIndices_ < dd->TotalIdxCount) {\n    drawableData.ib_ = ctx_.createBuffer({\n        .usage = lvk::BufferUsageBits_Index,\n        .storage = lvk::StorageType_HostVisible,\n        .size = dd->TotalIdxCount * sizeof(ImDrawIdx),\n        .debugName = “ImGui: drawableData.ib_”,\n    });\n    drawableData.numAllocatedIndices_ = dd->TotalIdxCount;\n  }\n```", "```cpp\n if (drawableData.numAllocatedVerteices_ < dd->TotalVtxCount) {\n    drawableData.vb_ = ctx_.createBuffer({\n        .usage = lvk::BufferUsageBits_Storage,\n        .storage = lvk::StorageType_HostVisible,\n        .size = dd->TotalVtxCount * sizeof(ImDrawVert),\n        .debugName = “ImGui: drawableData.vb_”,\n    });\n    drawableData.numAllocatedVerteices_ = dd->TotalVtxCount;\n  }\n```", "```cpp\n ImDrawVert* vtx = (ImDrawVert*)ctx_.getMappedPtr(drawableData.vb_);\n  uint16_t* idx = (uint16_t*)ctx_.getMappedPtr(drawableData.ib_);\n  for (int n = 0; n < dd->CmdListsCount; n++) {\n    const ImDrawList* cmdList = dd->CmdLists[n];\n    memcpy(vtx, cmdList->VtxBuffer.Data,\n      cmdList->VtxBuffer.Size * sizeof(ImDrawVert));\n    memcpy(idx, cmdList->IdxBuffer.Data,\n      cmdList->IdxBuffer.Size * sizeof(ImDrawIdx));\n    vtx += cmdList->VtxBuffer.Size;\n    idx += cmdList->IdxBuffer.Size;\n  }\n```", "```cpp\n ctx_.flushMappedMemory(\n    drawableData.vb_, 0, dd->TotalVtxCount * sizeof(ImDrawVert));\n  ctx_.flushMappedMemory(\n    drawableData.ib_, 0, dd->TotalIdxCount * sizeof(ImDrawIdx));\n  }\n```", "```cpp\n uint32_t idxOffset = 0;\n  uint32_t vtxOffset = 0;\n  cmdBuffer.cmdBindIndexBuffer(\n    drawableData.ib_, lvk::IndexFormat_UI16);\n  cmdBuffer.cmdBindRenderPipeline(pipeline_);\n  for (int n = 0; n < dd->CmdListsCount; n++) {\n    const ImDrawList* cmdList = dd->CmdLists[n];\n    for (int cmd_i = 0; cmd_i < cmdList->CmdBuffer.Size; cmd_i++) {\n      const ImDrawCmd& cmd = cmdList->CmdBuffer[cmd_i];\n```", "```cpp\n ImVec2 clipMin((cmd.ClipRect.x - clipOff.x) * clipScale.x,\n                     (cmd.ClipRect.y - clipOff.y) * clipScale.y);\n      ImVec2 clipMax((cmd.ClipRect.z - clipOff.x) * clipScale.x,\n                     (cmd.ClipRect.w - clipOff.y) * clipScale.y);\n      if (clipMin.x < 0.0f) clipMin.x = 0.0f;\n      if (clipMin.y < 0.0f) clipMin.y = 0.0f;\n      if (clipMax.x > fb_width ) clipMax.x = (float)fb_width;\n      if (clipMax.y > fb_height) clipMax.y = (float)fb_height;\n      if (clipMax.x <= clipMin.x || clipMax.y <= clipMin.y)\n         continue;\n```", "```cpp\n struct VulkanImguiBindData {\n        float LRTB[4];\n        uint64_t vb = 0;\n        uint32_t textureId = 0;\n      } bindData = {\n          .LRTB = {L, R, T, B},\n          .vb = ctx_.gpuAddress(drawableData.vb_),\n          .textureId = static_cast<uint32_t>(\n            reinterpret_cast<ptrdiff_t>(cmd.TextureId)),\n      };\n      cmdBuffer.cmdPushConstants(bindData);\n```", "```cpp\n cmdBuffer.cmdBindScissorRect({\n        uint32_t(clipMin.x),\n        uint32_t(clipMin.y),\n        uint32_t(clipMax.x - clipMin.x),\n        uint32_t(clipMax.y - clipMin.y)});\n```", "```cpp\n cmdBuffer.cmdDrawIndexed(cmd.ElemCount, 1u,\n        idxOffset + cmd.IdxOffset,\n        int32_t(vtxOffset + cmd.VtxOffset));\n    }\n    idxOffset += cmdList->IdxBuffer.Size;\n    vtxOffset += cmdList->VtxBuffer.Size;\n  }\n}\n```", "```cpp\noption(LVK_WITH_TRACY  “Enable Tracy profiler”  ON)\n```", "```cpp\nif(LVK_WITH_TRACY)\n  add_definitions(“-DTRACY_ENABLE=1”)\n  add_subdirectory(third-party/deps/src/tracy)\n  lvk_set_folder(TracyClient “third-party”)\nendif()\n```", "```cpp\nif(LVK_WITH_TRACY)\n  target_compile_definitions(\n    LVKLibrary PUBLIC “LVK_WITH_TRACY=1”)\n  target_link_libraries(LVKLibrary PUBLIC TracyClient)\nendif()\n```", "```cpp\n#if defined(LVK_WITH_TRACY)\n  #include “tracy/Tracy.hpp”\n  #define LVK_PROFILER_COLOR_WAIT    0xff0000\n  #define LVK_PROFILER_COLOR_SUBMIT  0x0000ff\n  #define LVK_PROFILER_COLOR_PRESENT 0x00ff00\n  #define LVK_PROFILER_COLOR_CREATE  0xff6600\n  #define LVK_PROFILER_COLOR_DESTROY 0xffa500\n  #define LVK_PROFILER_COLOR_BARRIER 0xffffff\n```", "```cpp\n #define LVK_PROFILER_FUNCTION() ZoneScoped\n  #define LVK_PROFILER_FUNCTION_COLOR(color) ZoneScopedC(color)\n  #define LVK_PROFILER_ZONE(name, color) { \\\n      ZoneScopedC(color);                  \\\n      ZoneName(name, strlen(name))\n  #define LVK_PROFILER_ZONE_END() }\n```", "```cpp\n #define LVK_PROFILER_THREAD(name) tracy::SetThreadName(name)\n  #define LVK_PROFILER_FRAME(name) FrameMarkNamed(name)\n```", "```cpp\n#else\n  #define LVK_PROFILER_FUNCTION()\n  #define LVK_PROFILER_FUNCTION_COLOR(color)\n  #define LVK_PROFILER_ZONE(name, color) {\n  #define LVK_PROFILER_ZONE_END() }\n  #define LVK_PROFILER_THREAD(name)\n  #define LVK_PROFILER_FRAME(name)\n#endif // LVK_WITH_TRACY\n```", "```cpp\n GLFWwindow* window = nullptr;\n  std::unique_ptr<lvk::IContext> ctx;\n  {\n    LVK_PROFILER_ZONE(“Initialization”, LVK_PROFILER_COLOR_CREATE);\n    int width  = -95;\n    int height = -90;\n    window = lvk::initWindow(“Simple example”, width, height);\n    ctx    = lvk::createVulkanContextWithSwapchain(\n      window, width, height, {});\n    LVK_PROFILER_ZONE_END();\n  }\n```", "```cpp\n lvk::ICommandBuffer& buf = ctx->acquireCommandBuffer();\n  LVK_PROFILER_ZONE(“Fill command buffer”, 0xffffff);\n  …\n  LVK_PROFILER_ZONE_END();\n```", "```cpp\nlvk::Result lvk::compileShader(VkDevice device,\n  VkShaderStageFlagBits stage, const char* code,\n  VkShaderModule* outShaderModule,\n  const glslang_resource_t* glslLangResource) {\n  LVK_PROFILER_FUNCTION();\n  …\n  return Result();\n}\n```", "```cpp\nclass FramesPerSecondCounter {\npublic:\n  float avgInterval_ = 0.5f;\n  unsigned int numFrames_  = 0;\n  double accumulatedTime_  = 0;\n  float currentFPS_        = 0.0f;\n  bool printFPS_ = true;\n```", "```cpp\npublic:\n  explicit FramesPerSecondCounter(float avgInterval = 0.5f)\n  : avgInterval_(avgInterval)\n  { assert(avgInterval > 0.0f); }\n```", "```cpp\n bool tick(float deltaSeconds, bool frameRendered = true) {\n    if (frameRendered) numFrames_++;\n    accumulatedTime_ += deltaSeconds;\n```", "```cpp\n if (accumulatedTime_ > avgInterval_) {\n      currentFPS_ = static_cast<float>(\n        numFrames_ / accumulatedTime_);\n      if (printFPS_) printf(“FPS: %.1f\\n”, currentFPS_);\n      numFrames_       = 0;\n      accumulatedTime_ = 0;\n      return true;\n    }\n    return false;\n  }\n```", "```cpp\n inline float getFPS() const { return currentFPS_; }\n};\n```", "```cpp\n double timeStamp   = glfwGetTime();\n  float deltaSeconds = 0.0f;\n  FramesPerSecondCounter fpsCounter(0.5f);\n```", "```cpp\n while (!glfwWindowShouldClose(window)) {\n    fpsCounter.tick(deltaSeconds);\n    const double newTimeStamp = glfwGetTime();\n    deltaSeconds = static_cast<float>(newTimeStamp - timeStamp);\n    timeStamp    = newTimeStamp;\n    // ...do the rest of your rendering here...\n  }\n```", "```cpp\nFPS: 3924.7\nFPS: 4322.4\nFPS: 4458.9\nFPS: 4445.1\nFPS: 4581.4\n```", "```cpp\nlvk::ICommandBuffer& buf = ctx->acquireCommandBuffer();\nconst lvk::Framebuffer framebuffer =\n  { .color = { { .texture = ctx->getCurrentSwapchainTexture() } } };\nbuf.cmdBeginRendering(\n  { .color = { { .loadOp = lvk::LoadOp_Clear,\n    .clearColor = { 1.0f, 1.0f, 1.0f, 1.0f } } } }, framebuffer);\nimgui->beginFrame(framebuffer);\n```", "```cpp\nif (const ImGuiViewport* v = ImGui::GetMainViewport()) {\n  ImGui::SetNextWindowPos({\n    v->WorkPos.x + v->WorkSize.x - 15.0f,\n    v->WorkPos.y + 15.0f }, ImGuiCond_Always, { 1.0f, 0.0f });\n}\n```", "```cpp\nImGui::SetNextWindowBgAlpha(0.30f);\nImGui::SetNextWindowSize(\n  ImVec2(ImGui::CalcTextSize(“FPS : _______”).x, 0));\n```", "```cpp\nif (ImGui::Begin(“##FPS”, nullptr, \n                 ImGuiWindowFlags_NoDecoration |\n                 ImGuiWindowFlags_AlwaysAutoResize |\n                 ImGuiWindowFlags_NoSavedSettings |\n                 ImGuiWindowFlags_NoFocusOnAppearing |\n                 ImGuiWindowFlags_NoNav |\n                 ImGuiWindowFlags_NoMove))\n{\n  ImGui::Text(“FPS : %i”, (int)fpsCounter.getFPS());\n  ImGui::Text(“ms  : %.1f”, 1000.0 / fpsCounter.getFPS());\n}\nImGui::End();\n```", "```cpp\nImPlot::ShowDemoWindow();\nImGui::ShowDemoWindow();\nimgui->endFrame(buf);\nbuf.cmdEndRendering();\n```", "```cpp\nclass Bitmap {\npublic:\n  Bitmap() = default;\n  Bitmap(int w, int h, int comp, eBitmapFormat fmt);\n  Bitmap(int w, int h, int d, int comp, eBitmapFormat fmt);\n  Bitmap(int w, int h, int comp, eBitmapFormat fmt, const void* ptr);\n```", "```cpp\n int w_ = 0;\n  int h_ = 0;\n  int d_ = 1;\n  int comp_ = 3;\n```", "```cpp\n eBitmapFormat fmt_ = eBitmapFormat_UnsignedByte;\n  eBitmapType type_  = eBitmapType_2D;\n  std::vector<uint8_t> data_;\n```", "```cpp\n static int getBytesPerComponent(eBitmapFormat fmt);\n  void setPixel(int x, int y, const glm::vec4& c);\n  glm::vec4 getPixel(int x, int y) const;\n};\n```", "```cpp\nvec3 faceCoordsToXYZ(int i, int j, int faceID, int faceSize) {\n  const float A = 2.0f * float(i) / faceSize;\n  const float B = 2.0f * float(j) / faceSize;\n  if (faceID == 0) return vec3(   -1.0f, A - 1.0f,  B - 1.0f);\n  if (faceID == 1) return vec3(A - 1.0f,    -1.0f,  1.0f - B);\n  if (faceID == 2) return vec3(    1.0f, A - 1.0f,  1.0f - B);\n  if (faceID == 3) return vec3(1.0f - A,     1.0f,  1.0f - B);\n  if (faceID == 4) return vec3(B - 1.0f, A - 1.0f,  1.0f);\n  if (faceID == 5) return vec3(1.0f - B, A - 1.0f, -1.0f);\n  return vec3();\n}\n```", "```cpp\nBitmap convertEquirectangularMapToVerticalCross(const Bitmap& b) {\n  if (b.type_ != eBitmapType_2D) return Bitmap();\n  const int faceSize = b.w_ / 4;\n  const int w = faceSize * 3;\n  const int h = faceSize * 4;\n  Bitmap result(w, h, 3);\n```", "```cpp\n const ivec2 kFaceOffsets[] = {\n    ivec2(faceSize, faceSize * 3),\n    ivec2(0, faceSize),\n    ivec2(faceSize, faceSize),\n    ivec2(faceSize * 2, faceSize),\n    ivec2(faceSize, 0),\n    ivec2(faceSize, faceSize * 2)\n  };\n```", "```cpp\n const int clampW = b.w_ - 1;\n  const int clampH = b.h_ - 1;\n```", "```cpp\n for (int face = 0; face != 6; face++) {\n    for (int i = 0; i != faceSize; i++) {\n      for (int j = 0; j != faceSize; j++) {\n```", "```cpp\n const vec3  P = faceCoordsToXYZ(i, j, face, faceSize);\n        const float R = hypot(P.x, P.y);\n        const float theta = atan2(P.y, P.x);\n        const float phi   = atan2(P.z, R); \n```", "```cpp\n const float Uf =\n          float(2.0f * faceSize * (theta + M_PI) / M_PI);\n        const float Vf =\n          float(2.0f * faceSize * (M_PI / 2.0f - phi) / M_PI);\n```", "```cpp\n const int U1 = clamp(int(floor(Uf)), 0, clampW);\n        const int V1 = clamp(int(floor(Vf)), 0, clampH);\n        const int U2 = clamp(U1 + 1, 0, clampW);\n        const int V2 = clamp(V1 + 1, 0, clampH);\n```", "```cpp\n const float s = Uf - U1;\n        const float t = Vf - V1;\n        const vec4 A = b.getPixel(U1, V1);\n        const vec4 B = b.getPixel(U2, V1);\n        const vec4 C = b.getPixel(U1, V2);\n        const vec4 D = b.getPixel(U2, V2);\n```", "```cpp\n const vec4 color = A * (1 - s) * (1 - t) + B * (s) * (1 - t) +\n          C * (1 - s) * t + D * (s) * (t);\n        result.setPixel(\n          i + kFaceOffsets[face].x, j + kFaceOffsets[face].y, color);\n      }\n    }\n  }\n  return result;\n}\n```", "```cpp\nBitmap convertVerticalCrossToCubeMapFaces(const Bitmap& b) {\n  const int faceWidth  = b.w_ / 3;\n  const int faceHeight = b.h_ / 4;\n  Bitmap cubemap(faceWidth, faceHeight, 6, b.comp_, b.fmt_);\n```", "```cpp\n const uint8_t* src = b.data_.data();\n  uint8_t* dst = cubemap.data_.data();\n  const int pixelSize = cubemap.comp_ *\n    Bitmap::getBytesPerComponent(cubemap.fmt_);\n```", "```cpp\n for (int face = 0; face != 6; ++face) {\n    for (int j = 0; j != faceHeight; ++j) {\n      for (int i = 0; i != faceWidth; ++i) {\n        int x = 0;\n        int y = 0;\n```", "```cpp\n switch (face) {\n        case 0: // +X\n          x = i;\n          y = faceHeight + j;\n          break;\n        case 1: // -X\n          x = 2 * faceWidth + i;\n          y = 1 * faceHeight + j;\n          break;\n        case 2: // +Y\n          x = 2 * faceWidth - (i + 1);\n          y = 1 * faceHeight - (j + 1);\n          break;\n        case 3: // -Y\n          x = 2 * faceWidth - (i + 1);\n          y = 3 * faceHeight - (j + 1);\n          break;\n        case 4: // +Z\n          x = 2 * faceWidth - (i + 1);\n          y = b.h_ - (j + 1);\n          break;\n        case 5: // -Z\n          x = faceWidth + i;\n          y = faceHeight + j;\n          break;\n        }\n```", "```cpp\n memcpy(dst, src + (y * b.w_ + x) * pixelSize, pixelSize);\n        dst += pixelSize;\n      }\n    }\n  }\n  return cubemap;\n}\n```", "```cpp\nint w, h;\nconst float* img = stbi_loadf(\n  “data/piazza_bologni_1k.hdr”, &w, &h, nullptr, 4);\nBitmap in(w, h, 4, eBitmapFormat_Float, img);\n```", "```cpp\nBitmap out = convertEquirectangularMapToVerticalCross(in);\nstbi_image_free((void*)img);\nstbi_write_hdr(“.cache/screenshot.hdr”, out.w_, out.h_, out.comp_,\n  (const float*)out.data_.data());\n```", "```cpp\nBitmap cubemap = convertVerticalCrossToCubeMapFaces(out);\n```", "```cpp\nlvk::Holder<lvk::TextureHandle> cubemapTex = ctx->createTexture({\n    .type       = lvk::TextureType_Cube,\n    .format     = lvk::Format_RGBA_F32,\n    .dimensions = {(uint32_t)cubemap.w_, (uint32_t)cubemap.h_},\n    .usage      = lvk::TextureUsageBits_Sampled,\n    .data       = cubemap.data_.data(),\n    .debugName  = “data/piazza_bologni_1k.hdr”,\n});\n```", "```cpp\nlayout(std430, buffer_reference) readonly buffer PerFrameData {\n  mat4 model;\n  mat4 view;\n  mat4 proj;\n  vec4 cameraPos;\n  uint tex;\n  uint texCube;\n};\n```", "```cpp\nlayout(push_constant) uniform PushConstants {\n  PerFrameData pc;\n};\n```", "```cpp\nstruct PerVertex {\n  vec2 uv;\n  vec3 worldNormal;\n  vec3 worldPos;\n};\nlayout (location = 0) in vec3 pos;\nlayout (location = 1) in vec3 normal;\nlayout (location = 2) in vec2 uv;\nlayout (location=0) out PerVertex vtx;\nvoid main() {\n  gl_Position = pc.proj * pc.view * pc.model * vec4(pos, 1.0);\n  mat4 model = pc.model;\n  mat3 normalMatrix = transpose( inverse(mat3(pc.model)) );\n  vtx.uv = uv;\n  vtx.worldNormal = normal * normalMatrix;\n  vtx.worldPos = (model * vec4(pos, 1.0)).xyz;\n}\n```", "```cpp\nlayout (location=0) in PerVertex vtx;\nlayout (location=0) out vec4 out_FragColor;\nvoid main() {\n  vec3 n = normalize(vtx.worldNormal);\n  vec3 v = normalize(pc.cameraPos.xyz - vtx.worldPos);\n  vec3 reflection = -normalize(reflect(v, n));\n  vec4 colorRefl = textureBindlessCube(pc.texCube, 0, reflection);\n```", "```cpp\n vec4 Ka = colorRefl * 0.3;\n  float NdotL = clamp(dot(n, normalize(vec3(0,0,-1))), 0.1, 1.0);\n  vec4 Kd = textureBindless2D(pc.tex, 0, vtx.uv) * NdotL;\n  out_FragColor = Ka + Kd;\n};\n```", "```cpp\nclass Camera final {\npublic:\n  explicit Camera(CameraPositionerInterface& positioner)\n    : positioner_(&positioner)  {}\n  Camera(const Camera&) = default;\n  Camera& operator = (const Camera&) = default;\n  mat4 getViewMatrix() const {\n    return positioner_->getViewMatrix();\n  }\n  vec3 getPosition() const {\n    return positioner_->getPosition();\n  }\nprivate:\n      const CameraPositionerInterface* positioner_;\n};\n```", "```cpp\nclass CameraPositionerInterface {\npublic:\n  virtual ~CameraPositionerInterface() = default;\n  virtual mat4 getViewMatrix() const = 0;\n  virtual vec3 getPosition() const = 0;\n};\n```", "```cpp\nclass CameraPositioner_FirstPerson final:\n  public CameraPositionerInterface\n{\npublic:\n  struct Movement {\n    bool forward_   = false;\n    bool backward_  = false;\n    bool left_      = false;\n    bool right_     = false;\n    bool up_        = false;\n    bool down_      = false;\n    bool fastSpeed_ = false;\n  } movement_;\n```", "```cpp\n float mouseSpeed_   = 4.0f;\n  float acceleration_ = 150.0f;\n  float damping_      = 0.2f;\n  float maxSpeed_     = 10.0f;\n  float fastCoef_     = 10.0f;\n```", "```cpp\nprivate:\n  vec2 mousePos_          = vec2(0);\n  vec3 cameraPosition_    = vec3(0.0f, 10.0f, 10.0f);\n  quat cameraOrientation_ = quat(vec3(0));\n  vec3 moveSpeed_         = vec3(0.0f);\n  vec3 up_                = vec3(0.0f, 0.0f, 1.0f);\n```", "```cpp\npublic:\n  CameraPositioner_FirstPerson() = default;\n  CameraPositioner_FirstPerson(const vec3& pos,\n    const vec3& target, const vec3& up)\n  : cameraPosition_(pos)\n  , cameraOrientation_(glm::lookAt(pos, target, up))\n  , up_(up)\n  {}\n```", "```cpp\n void update(double deltaSeconds,\n    const glm::vec2& mousePos, bool mousePressed)\n  {\n    if (mousePressed) {\n      const glm::vec2 delta = mousePos - mousePos_;\n      const glm::quat deltaQuat =\n        glm::quat(glm::vec3(\n        mouseSpeed_ * delta.y, mouseSpeed_ * delta.x, 0.0f));\n      cameraOrientation_ =\n        glm::normalize(deltaQuat * cameraOrientation_);\n      setUpVector(up_);\n    }\n    mousePos_ = mousePos;\n```", "```cpp\n const mat4 v = glm::mat4_cast(cameraOrientation_);\n    const vec3 forward = -vec3(v[0][2], v[1][2], v[2][2]);\n    const vec3 right   =  vec3(v[0][0], v[1][0], v[2][0]);\n    const vec3 up = cross(right, forward);\n```", "```cpp\n vec3 accel(0.0f);\n    if (movement_.forward_) accel += forward;\n    if (movement_.backward_) accel -= forward;\n    if (movement_.left_) accel -= right;\n    if (movement_.right_) accel += right;\n    if (movement_.up_) accel += up;\n    if (movement_.down_) accel -= up;\n    if (movement_.fastSpeed_) accel *= fastCoef_;\n```", "```cpp\n if (accel == vec3(0)) {\n      moveSpeed_ -= moveSpeed_ * std::min((1.0f / damping_) *\n        static_cast<float>(deltaSeconds), 1.0f);\n    }\n    else {\n      moveSpeed_ += accel * acceleration_ *\n        static_cast<float>(deltaSeconds);\n      const float maxSpeed =\n        movement_.fastSpeed_ ? maxSpeed_ * fastCoef_ : maxSpeed_;\n      if (glm::length(moveSpeed_) > maxSpeed)\n        moveSpeed_ = glm::normalize(moveSpeed_) * maxSpeed;\n    }\n    cameraPosition_ += moveSpeed_ *\n      static_cast<float>(deltaSeconds);\n  }\n```", "```cpp\n virtual mat4 getViewMatrix() const override {\n    const mat4 t = glm::translate(mat4(1.0f), -cameraPosition_);\n    const mat4 r = glm::mat4_cast(cameraOrientation_);\n    return r * t;\n  }\n```", "```cpp\n virtual vec3 getPosition() const override {\n    return cameraPosition_;\n  }\n  void setPosition(const vec3& pos) {\n    cameraPosition_ = pos;\n  }\n  void setUpVector(const vec3& up) {\n    const mat4 view = getViewMatrix();\n    const vec3 dir  = -vec3(view[0][2], view[1][2], view[2][2]);\n    cameraOrientation_ =\n      glm::lookAt(cameraPosition_, cameraPosition_ + dir, up);\n  }\n```", "```cpp\n void resetMousePosition(const vec2& p) { mousePos_ = p; };\n};\n```", "```cpp\nstruct MouseState {\n  vec2 pos         = vec2(0.0f);\n  bool pressedLeft = false;\n} mouseState;\nconst vec3 kInitialCameraPos    = vec3(0.0f, 1.0f, -1.5f);\nconst vec3 kInitialCameraTarget = vec3(0.0f, 0.5f,  0.0f);\nCameraPositioner_FirstPerson positioner(\n  kInitialCameraPos,\n  kInitialCameraTarget,\n  vec3(0.0f, 1.0f, 0.0f));\nCamera camera(positioner);\n```", "```cpp\nglfwSetCursorPosCallback(\n  window, [](auto* window, double x, double y) {\n    int width, height;\n    glfwGetFramebufferSize(window, &width, &height);\n    mouseState.pos.x = static_cast<float>(x / width);\n    mouseState.pos.y = 1.0f - static_cast<float>(y / height);\n  }\n);\n```", "```cpp\nglfwSetMouseButtonCallback(\n  window, [](auto* window, int button, int action, int mods) {\n    if (button == GLFW_MOUSE_BUTTON_LEFT)\n      mouseState.pressedLeft = action == GLFW_PRESS;\n    double xpos, ypos;\n    glfwGetCursorPos(window, &xpos, &ypos);\n    const ImGuiMouseButton_ imguiButton =\n     (button == GLFW_MOUSE_BUTTON_LEFT) ?\n       ImGuiMouseButton_Left :\n         (button == GLFW_MOUSE_BUTTON_RIGHT ?\n           ImGuiMouseButton_Right :\n           ImGuiMouseButton_Middle);\n    ImGuiIO& io = ImGui::GetIO();\n    io.MousePos = ImVec2((float)xpos, (float)ypos);\n    io.MouseDown[imguiButton] = action == GLFW_PRESS;\n  });\n```", "```cpp\nglfwSetKeyCallback(window,\n  [](GLFWwindow* window, int key, int, int action, int mods) {\n    const bool press = action != GLFW_RELEASE;\n    if (key == GLFW_KEY_ESCAPE)\n      glfwSetWindowShouldClose(window, GLFW_TRUE);\n    if (key == GLFW_KEY_W) positioner.movement_.forward_ = press;\n    if (key == GLFW_KEY_S) positioner.movement_.backward_= press;\n    if (key == GLFW_KEY_A) positioner.movement_.left_  = press;\n    if (key == GLFW_KEY_D) positioner.movement_.right_ = press;\n    if (key == GLFW_KEY_1) positioner.movement_.up_   = press;\n    if (key == GLFW_KEY_2) positioner.movement_.down_ = press;\n    if (mods & GLFW_MOD_SHIFT)\n      positioner.movement_.fastSpeed_ = press;\n    if (key == GLFW_KEY_SPACE) {\n      positioner.lookAt(kInitialCameraPos,\n        kInitialCameraTarget, vec3(0.0f, 1.0f, 0.0f));\n      positioner.setSpeed(vec3(0));\n    }\n  });\n```", "```cpp\npositioner.update(\n  deltaSeconds, mouseState.pos, mouseState.pressedLeft);\n```", "```cpp\nconst vec4 cameraPos = vec4(camera.getPosition(), 1.0f);\nconst mat4 p  = glm::perspective(\n  glm::radians(60.0f), ratio, 0.1f, 1000.0f);\nconst mat4 m1 = glm::rotate(\n  mat4(1.0f), glm::radians(-90.0f), vec3(1, 0, 0));\nconst mat4 m2 = glm::rotate(\n  mat4(1.0f), (float)glfwGetTime(), vec3(0.0f, 1.0f, 0.0f));\nconst mat4 v  = glm::translate(mat4(1.0f), vec3(cameraPos));\nconst PerFrameData pc = {\n  .model     = m2 * m1,\n  .view      = camera.getViewMatrix(),\n  .proj      = p,\n  .cameraPos = cameraPos,\n  .tex       = texture.index(),\n  .texCube   = cubemapTex.index(),\n};\nctx->upload(bufferPerFrame, &pc, sizeof(pc));\n```", "```cpp\nconst vec3 kInitialCameraPos    = vec3(0.0f, 1.0f, -1.5f);\nconst vec3 kInitialCameraAngles = vec3(-18.5f, 180.0f, 0.0f);\nCameraPositioner_MoveTo positionerMoveTo(\n  kInitialCameraPos, kInitialCameraAngles);\n```", "```cpp\npositioner_moveTo.update(\n  deltaSeconds, mouseState.pos, mouseState.pressedLeft);\n```", "```cpp\nconst char* cameraType = “FirstPerson”;\nconst char* comboBoxItems[] = { “FirstPerson”, “MoveTo” };\nconst char* currentComboBoxItem = cameraType;\n```", "```cpp\nImGui::Begin(“Camera Controls”, nullptr,\n  ImGuiWindowFlags_AlwaysAutoResize);\n{\n```", "```cpp\n if (ImGui::BeginCombo(“##combo”, currentComboBoxItem)) {\n    for (int n = 0; n < IM_ARRAYSIZE(comboBoxItems); n++) {\n      const bool isSelected =\n        currentComboBoxItem == comboBoxItems[n];\n```", "```cpp\n if (ImGui::Selectable(comboBoxItems[n], isSelected))\n        currentComboBoxItem = comboBoxItems[n];\n      if (isSelected)\n        ImGui::SetItemDefaultFocus();\n    }\n```", "```cpp\n ImGui::EndCombo();\n  }\n```", "```cpp\n if (!strcmp(cameraType, “MoveTo”)) {\n    if (ImGui::SliderFloat3(“Position”,\n      glm::value_ptr(cameraPos), -10.0f, +10.0f)) {\n      positionerMoveTo.setDesiredPosition(cameraPos);\n    }\n    if (ImGui::SliderFloat3(“Pitch/Pan/Roll”,\n      glm::value_ptr(cameraAngles), -180.0f, +180.0f)) {\n      positionerMoveTo.setDesiredAngles(cameraAngles);\n    }\n  }\n```", "```cpp\n if (currentComboBoxItem &&\n      strcmp(currentComboBoxItem, cameraType)) {\n    printf(“Selected new camera type: %s\\n”,\n             currentComboBoxItem);\n    cameraType = currentComboBoxItem;\n    reinitCamera(app);\n  }\n```", "```cpp\nclass CameraPositioner_MoveTo final :\n  public CameraPositionerInterface\n{\npublic:\n  float dampingLinear_ = 10.0f;\n  vec3 dampingEulerAngles_ = vec3(5.0f, 5.0f, 5.0f);\n```", "```cpp\nprivate:\n  vec3 positionCurrent_ = vec3(0.0f);\n  vec3 positionDesired_ = vec3(0.0f);\n  vec3 anglesCurrent_ = vec3(0.0f); // pitch, pan, roll\n  vec3 anglesDesired_ = vec3(0.0f);\n  mat4 currentTransform_ = mat4(1.0f);\n```", "```cpp\npublic:\n  CameraPositioner_MoveTo(const vec3& pos, const vec3& angles)\n  : positionCurrent_(pos)\n  , positionDesired_(pos)\n  , anglesCurrent_(angles)\n  , anglesDesired_(angles)\n  {}\n```", "```cpp\n void update(\n    float deltaSeconds, const vec2& mousePos, bool mousePressed)\n  {\n    positionCurrent_ += dampingLinear_ *\n      deltaSeconds * (positionDesired_ - positionCurrent_);\n```", "```cpp\n anglesCurrent_ = clipAngles(anglesCurrent_);\n    anglesDesired_ = clipAngles(anglesDesired_);\n```", "```cpp\n anglesCurrent_ -= angleDelta(anglesCurrent_, anglesDesired_)\n      * dampingEulerAngles_ * deltaSeconds;\n    anglesCurrent_ = clipAngles(anglesCurrent_);\n    const vec3 ang = glm::radians(anglesCurrent_);\n    currentTransform_ = glm::translate(\n      glm::yawPitchRoll(ang.y, ang.x, ang.z), -positionCurrent_);\n  }\n```", "```cpp\nprivate:\n  static inline float clipAngle(float d) {\n    if (d < -180.0f) return d + 360.0f;\n    if (d > +180.0f) return d - 360.f;\n    return d;\n  }\n  static inline vec3 clipAngles(const vec3& angles) {\n    return vec3( std::fmod(angles.x, 360.0f),\n                 std::fmod(angles.y, 360.0f),\n                 std::fmod(angles.z, 360.0f) );\n  }\n```", "```cpp\n static inline vec3 angleDelta( const vec3& anglesCurrent,\n                                 const vec3& anglesDesired )\n  {\n    const vec3 d =\n      clipAngles(anglesCurrent) - clipAngles(anglesDesired);\n    return vec3(\n      clipAngle(d.x), clipAngle(d.y), clipAngle(d.z));\n  }\n};\n```", "```cpp\nstruct LineCanvas3D {\n  mat4 mvp_ = mat4(1.0f);\n  struct LineData {\n    vec4 pos;\n    vec4 color;\n  };\n  std::vector<LineData> lines_;\n```", "```cpp\n lvk::Holder<lvk::ShaderModuleHandle> vert_;\n  lvk::Holder<lvk::ShaderModuleHandle> frag_;\n  lvk::Holder<lvk::RenderPipelineHandle> pipeline_;\n```", "```cpp\n constexpr uint32_t kNumImages = 3;\n  lvk::Holder<lvk::BufferHandle> linesBuffer_[kNumImages] = {};\n  uint32_t currentBufferSize_[kNumImages] = {};\n  uint32_t currentFrame_ = 0;\n  void setMatrix(const mat4& mvp) { mvp_ = mvp; }\n```", "```cpp\n void clear() { lines_.clear(); }\n  void line(const vec3& p1, const vec3& p2, const vec4& c);\n  void plane(vec3& orig, const vec3& v1, const vec3& v2,\n    int n1, int n2, float s1, float s2,\n    const vec4& color, const vec4& outlineColor);\n  void box(const mat4& m, const BoundingBox& box,\n    const vec4& color);\n  void box(const mat4& m, const vec3& size, const vec4& color);\n  void frustum(const mat4& camView, const mat4& camProj,\n    const vec4& color);\n```", "```cpp\n void render(lvk::IContext& ctx, const lvk::Framebuffer& desc,\n    lvk::ICommandBuffer& buf, uint32_t width, uint32_t height);\n};\n```", "```cpp\nvoid LineCanvas3D::line(\n  const vec3& p1, const vec3& p2, const vec4& c) {\n  lines_.push_back({ .pos = vec4(p1, 1.0f), .color = c });\n  lines_.push_back({ .pos = vec4(p2, 1.0f), .color = c });\n}\n```", "```cpp\nvoid LineCanvas3D::plane(\n  const vec3& o, const vec3& v1, const vec3& v2, int n1, int n2,\n  float s1, float s2,\n  const vec4& color, const vec4& outlineColor)\n```", "```cpp\n line(o - s1 / 2.0f * v1 - s2 / 2.0f * v2,\n       o - s1 / 2.0f * v1 + s2 / 2.0f * v2, outlineColor);\n  line(o + s1 / 2.0f * v1 - s2 / 2.0f * v2,\n       o + s1 / 2.0f * v1 + s2 / 2.0f * v2, outlineColor);\n  line(o - s1 / 2.0f * v1 + s2 / 2.0f * v2,\n       o + s1 / 2.0f * v1 + s2 / 2.0f * v2, outlineColor);\n  line(o - s1 / 2.0f * v1 - s2 / 2.0f * v2,\n       o + s1 / 2.0f * v1 - s2 / 2.0f * v2, outlineColor);\n```", "```cpp\n for (int i = 1; i < n1; i++) {\n    float t = ((float)i - (float)n1 / 2.0f) * s1/(float)n1;\n    const vec3 o1 = o + t * v1;\n    line(o1 - s2 / 2.0f * v2, o1 + s2 / 2.0f * v2, color);\n  }\n  for (int i = 1; i < n2; i++) {\n    const float t = ((float)i - (float)n2 / 2.0f) * s2/(float)n2;\n    const vec3 o2 = o + t * v2;\n    line(o2 - s1 / 2.0f * v1, o2 + s1 / 2.0f * v1, color);\n  }\n```", "```cpp\nvoid LineCanvas3D::box(\n  const mat4& m, const vec3& size, const vec4& color)\n{\n  vec3 pts[8] = { vec3(+size.x, +size.y, +size.z),\n                  vec3(+size.x, +size.y, -size.z),\n                  vec3(+size.x, -size.y, +size.z),\n                  vec3(+size.x, -size.y, -size.z),\n                  vec3(-size.x, +size.y, +size.z),\n                  vec3(-size.x, +size.y, -size.z),\n                  vec3(-size.x, -size.y, +size.z),\n                  vec3(-size.x, -size.y, -size.z) };\n  for (auto& p : pts) p = vec3(m * vec4(p, 1.f));\n```", "```cpp\n line(pts[0], pts[1], color);\n  line(pts[2], pts[3], color);\n  line(pts[4], pts[5], color);\n  line(pts[6], pts[7], color);\n  line(pts[0], pts[2], color);\n  line(pts[1], pts[3], color);\n  line(pts[4], pts[6], color);\n  line(pts[5], pts[7], color);\n  line(pts[0], pts[4], color);\n  line(pts[1], pts[5], color);\n  line(pts[2], pts[6], color);\n  line(pts[3], pts[7], color);\n}\n```", "```cpp\nvoid LineCanvas3D::box(const mat4& m,\n  const BoundingBox& box, const vec4& color)\n{\n  this->box(m * glm::translate(mat4(1.f),\n    0.5f * (box.min_ + box.max_)),\n    0.5f * vec3(box.max_ - box.min_), color);\n}\n```", "```cpp\nvoid LineCanvas3D::frustum(\n   const mat4& camView,\n   const mat4& camProj, const vec4& color)\n{\n```", "```cpp\n const vec3 corners[] = { vec3(-1, -1, -1),\n                           vec3(+1, -1, -1),\n                           vec3(+1, +1, -1),\n                           vec3(-1, +1, -1),\n                           vec3(-1, -1, +1),\n                           vec3(+1, -1, +1),\n                           vec3(+1, +1, +1),\n                           vec3(-1, +1, +1) };\n  vec3 pp[8];\n  for (int i = 0; i < 8; i++) {\n    glm::vec4 q = glm::inverse(camView) * glm::inverse(camProj) *\n      glm::vec4(corners[i], 1.0f);\n    pp[i] = glm::vec3(q.x / q.w, q.y / q.w, q.z / q.w);\n  }\n```", "```cpp\n line(pp[0], pp[4], color);\n  line(pp[1], pp[5], color);\n  line(pp[2], pp[6], color);\n  line(pp[3], pp[7], color);\n```", "```cpp\n line(pp[0], pp[1], color);\n  line(pp[1], pp[2], color);\n  line(pp[2], pp[3], color);\n  line(pp[3], pp[0], color);\n  line(pp[0], pp[2], color);\n  line(pp[1], pp[3], color);\n```", "```cpp\n line(pp[4], pp[5], color);\n  line(pp[5], pp[6], color);\n  line(pp[6], pp[7], color);\n  line(pp[7], pp[4], color);\n  line(pp[4], pp[6], color);\n  line(pp[5], pp[7], color);\n```", "```cpp\n const vec4 gridColor = color * 0.7f;\n  const int gridLines  = 100;\n```", "```cpp\n { vec3 p1       = pp[0];\n    vec3 p2       = pp[1];\n    const vec3 s1 = (pp[4] - pp[0]) / float(gridLines);\n    const vec3 s2 = (pp[5] - pp[1]) / float(gridLines);\n    for (int i = 0; i != gridLines; i++, p1 += s1, p2 += s2)\n      line(p1, p2, gridColor); }\n  { vec3 p1       = pp[2];\n    vec3 p2       = pp[3];\n    const vec3 s1 = (pp[6] - pp[2]) / float(gridLines);\n    const vec3 s2 = (pp[7] - pp[3]) / float(gridLines);\n    for (int i = 0; i != gridLines; i++, p1 += s1, p2 += s2)\n      line(p1, p2, gridColor); }\n```", "```cpp\n { vec3 p1       = pp[0];\n    vec3 p2       = pp[3];\n    const vec3 s1 = (pp[4] - pp[0]) / float(gridLines);\n    const vec3 s2 = (pp[7] - pp[3]) / float(gridLines);\n    for (int i = 0; i != gridLines; i++, p1 += s1, p2 += s2)\n      line(p1, p2, gridColor); }\n  { vec3 p1       = pp[1];\n    vec3 p2       = pp[2];\n    const vec3 s1 = (pp[5] - pp[1]) / float(gridLines);\n    const vec3 s2 = (pp[6] - pp[2]) / float(gridLines);\n    for (int i = 0; i != gridLines; i++, p1 += s1, p2 += s2)\n      line(p1, p2, gridColor); }\n}\n```", "```cpp\nvoid LineCanvas3D::render(lvk::IContext& ctx,\n  const lvk::Framebuffer& desc,\n  lvk::ICommandBuffer& buf, uint32_t width, uint32_t height)\n{\n```", "```cpp\n const uint32_t requiredSize = lines_.size() * sizeof(LineData);\n  if (currentBufferSize_[currentFrame_] < requiredSize) {\n    linesBuffer_[currentFrame_] = ctx.createBuffer({\n      .usage = lvk::BufferUsageBits_Storage,\n      .storage = lvk::StorageType_HostVisible,\n      .size = requiredSize, .data = lines_.data() });\n    currentBufferSize_[currentFrame_] = requiredSize;\n  } else {\n    ctx.upload(\n      linesBuffer_[currentFrame_], lines_.data(), requiredSize);\n  }\n```", "```cpp\n if (pipeline_.empty()) {\n    vert_ = ctx.createShaderModule({\n      codeVS, lvk::Stage_Vert, “Shader Module: imgui (vert)” });\n    frag_ = ctx.createShaderModule({\n      codeFS, lvk::Stage_Frag, “Shader Module: imgui (frag)” });\n    pipeline_ = ctx.createRenderPipeline({\n      .topology = lvk::Topology_Line,\n      .smVert   = vert_,\n      .smFrag   = frag_,\n      .color    = { {\n         .format = ctx.getFormat(desc.color[0].texture),\n         .blendEnabled      = true,\n         .srcRGBBlendFactor = lvk::BlendFactor_SrcAlpha,\n         .dstRGBBlendFactor = lvk::BlendFactor_OneMinusSrcAlpha,\n      } },\n      .depthFormat = desc.depthStencil.texture ?\n        ctx.getFormat(desc.depthStencil.texture) :\n        lvk::Format_Invalid,\n      .cullMode = lvk::CullMode_None,\n    }, nullptr);\n  }\n```", "```cpp\n struct {\n    mat4 mvp;\n    uint64_t addr;\n  } pc {\n    .mvp  = mvp_,\n    .addr = ctx.gpuAddress(linesBuffer_[currentFrame_]),\n  };\n  buf.cmdBindRenderPipeline(pipeline_);\n  buf.cmdPushConstants(pc);\n```", "```cpp\n buf.cmdDraw(lines_.size());\n  currentFrame_ =\n    (currentFrame_ + 1) % LVK_ARRAY_NUM_ELEMENTS(linesBuffer_);\n}\n```", "```cpp\nlayout (location = 0) out vec4 out_color;\nlayout (location = 1) out vec2 out_uv;\nstruct Vertex {\n  vec4 pos;\n  vec4 rgba;\n};\nlayout(std430, buffer_reference) readonly buffer VertexBuffer {\n  Vertex vertices[];\n};\nlayout(push_constant) uniform PushConstants {\n  mat4 mvp;\n  VertexBuffer vb;\n};\nvoid main() {\n  Vertex v = vb.vertices[gl_VertexIndex];\n  out_color = v.rgba;\n  gl_Position = mvp * v.pos;\n}\n```", "```cpp\nlayout (location = 0) in vec4 in_color;\nlayout (location = 0) out vec4 out_color;\nvoid main() {\n  out_color = in_color;\n}\n```", "```cpp\nclass LineCanvas2D {\npublic:\n  void clear() { lines_.clear(); }\n  void line(const vec2& p1, const vec2& p2, const vec4& c) {\n    lines_.push_back({ .p1 = p1, .p2 = p2, .color = c }); }\n  void render(const char* name, uint32_t width, uint32_t height);\nprivate:\n  struct LineData {\n    vec2 p1, p2;\n    vec4 color;\n  };\n  std::vector<LineData> lines_;\n};\n```", "```cpp\nvoid LineCanvas2D::render(const char* nameImGuiWindow) {\n  ImGui::SetNextWindowPos(ImVec2(0, 0));\n  ImGui::SetNextWindowSize(ImGui::GetMainViewport()->Size);\n  ImGui::Begin(nameImGuiWindow, nullptr,\n    ImGuiWindowFlags_NoDecoration |\n    ImGuiWindowFlags_AlwaysAutoResize | \n    ImGuiWindowFlags_NoSavedSettings |\n    ImGuiWindowFlags_NoFocusOnAppearing |\n    ImGuiWindowFlags_NoNav |\n    ImGuiWindowFlags_NoBackground |\n    ImGuiWindowFlags_NoInputs);\n```", "```cpp\n ImDrawList* drawList = ImGui::GetBackgroundDrawList();\n  for (const LineData& l : lines_) {\n    drawList->AddLine(\n      ImVec2(l.p1.x, l.p1.y),\n      ImVec2(l.p2.x, l.p2.y),\n      ImColor(l.color.r, l.color.g, l.color.b, l.color.a));\n  }\n  ImGui::End();\n}\n```", "```cpp\ncanvas2d.clear();\ncanvas2d.line({ 100, 300 }, { 100, 400 }, vec4(1, 0, 0, 1));\ncanvas2d.line({ 100, 400 }, { 200, 400 }, vec4(0, 1, 0, 1));\ncanvas2d.line({ 200, 400 }, { 200, 300 }, vec4(0, 0, 1, 1));\ncanvas2d.line({ 200, 300 }, { 100, 300 }, vec4(1, 1, 0, 1));\ncanvas2d.render(“##plane”);\n```", "```cpp\nclass LinearGraph {\n  const char* name_ = nullptr;\n  const size_t maxPoints_ = 0;\n  std::deque<float> graph_;\npublic:\n  explicit LinearGraph(const char* name,\n                       size_t maxGraphPoints = 256)\n  : name_(name)\n  , maxPoints_(maxGraphPoints)\n  {}\n```", "```cpp\n void addPoint(float value) {\n    graph_.push_back(value);\n    if (graph_.size() > maxPoints_) graph_.erase(graph_.begin());\n  }\n```", "```cpp\n void renderGraph(uint32_t x, uint32_t y,\n    uint32_t width, uint32_t height,\n    const vec4& color = vec4(1.0)) const {\n    float minVal = std::numeric_limits<float>::max();\n    float maxVal = std::numeric_limits<float>::min();\n    for (float f : graph_) {\n      if (f < minVal) minVal = f;\n      if (f > maxVal) maxVal = f;\n    }\n    const float range = maxVal - minVal;\n    float valX = 0.0;\n    std::vector<float> dataX_;\n    std::vector<float> dataY_;\n    dataX_.reserve(graph_.size());\n    dataY_.reserve(graph_.size());\n    for (float f : graph_) {\n      const float valY = (f - minVal) / range;\n      valX += 1.0f / maxPoints_;\n      dataX_.push_back(valX);\n      dataY_.push_back(valY);\n    }\n```", "```cpp\n ImGui::SetNextWindowPos(ImVec2(x, y));\n    ImGui::SetNextWindowSize(ImVec2(width, height));\n    ImGui::Begin(_, nullptr,\n      ImGuiWindowFlags_NoDecoration |\n      ImGuiWindowFlags_AlwaysAutoResize |\n      ImGuiWindowFlags_NoSavedSettings |\n      ImGuiWindowFlags_NoFocusOnAppearing |\n      ImGuiWindowFlags_NoNav |\n      ImGuiWindowFlags_NoBackground |\n      ImGuiWindowFlags_NoInputs);\n```", "```cpp\n if (ImPlot::BeginPlot(name_, ImVec2(width, height),\n      ImPlotFlags_CanvasOnly |\n      ImPlotFlags_NoFrame | ImPlotFlags_NoInputs)) {\n      ImPlot::SetupAxes(nullptr, nullptr,\n        ImPlotAxisFlags_NoDecorations,\n        ImPlotAxisFlags_NoDecorations);\n      ImPlot::PushStyleColor(ImPlotCol_Line,\n        ImVec4(color.r, color.g, color.b, color.a));\n      ImPlot::PushStyleColor(ImPlotCol_PlotBg,\n        ImVec4(0, 0, 0, 0));\n```", "```cpp\n ImPlot::PlotLine(“#line”, dataX_.data(), dataY_.data(),\n        (int)graph_.size(), ImPlotLineFlags_None);\n      ImPlot::PopStyleColor(2);\n      ImPlot::EndPlot();\n    }\n    ImGui::End();\n  }\n```", "```cpp\nLinearGraph fpsGraph(“##fpsGraph”, 2048);\nLinearGraph sinGraph(“##sinGraph”, 2048);\n```", "```cpp\nfpsGraph.addPoint(app.fpsCounter_.getFPS());\nsinGraph.addPoint(sinf(glfwGetTime() * 20.0f));\n```", "```cpp\nsinGraph.renderGraph(0, height * 0.7f, width, height * 0.2f,\n  vec4(0.0f, 1.0f, 0.0f, 1.0f));\nfpsGraph.renderGraph(0, height * 0.8f, width, height * 0.2f);\n```", "```cpp\n#include “shared/VulkanApp.h”\n#include <assimp/cimport.h>\n#include <assimp/postprocess.h>\n#include <assimp/scene.h>\n#include “shared/LineCanvas.h”\n```", "```cpp\nconst vec3 kInitialCameraPos    = vec3(0.0f, 1.0f, -1.5f);\nconst vec3 kInitialCameraTarget = vec3(0.0f, 0.5f,  0.0f);\nconst vec3 kInitialCameraAngles = vec3(-18.5f, 180.0f, 0.0f);\nCameraPositioner_MoveTo positionerMoveTo(\n  kInitialCameraPos, kInitialCameraAngles);\nvec3 cameraPos    = kInitialCameraPos;\nvec3 cameraAngles = kInitialCameraAngles;\nconst char* cameraType          = “FirstPerson”;\nconst char* comboBoxItems[]     = { “FirstPerson”, “MoveTo” };\nconst char* currentComboBoxItem = cameraType;\n```", "```cpp\nLinearGraph fpsGraph(“##fpsGraph”, 2048);\nLinearGraph sinGraph(“##sinGraph”, 2048);\n```", "```cpp\nint main()\n{\n  VulkanApp app({\n    .initialCameraPos = kInitialCameraPos,\n    .initialCameraTarget = kInitialCameraTarget });\n  app.fpsCounter_.avgInterval_ = 0.002f;\n  app.fpsCounter_.printFPS_    = false;\n  LineCanvas2D canvas2d;\n  LineCanvas3D canvas3d;\n```", "```cpp\n std::unique_ptr<lvk::IContext> ctx(app.ctx_.get());\n```", "```cpp\n lvk::Holder<lvk::ShaderModuleHandle> vert =\n    loadShaderModule(\n      ctx, “Chapter04/04_CubeMap/src/main.vert”);\n  lvk::Holder<lvk::ShaderModuleHandle> frag =\n    loadShaderModule(\n      ctx, “Chapter04/04_CubeMap/src/main.frag”);\n  lvk::Holder<lvk::ShaderModuleHandle> vertSkybox =\n    loadShaderModule(\n      ctx, “Chapter04/04_CubeMap/src/skybox.vert”);\n  lvk::Holder<lvk::ShaderModuleHandle> fragSkybox =\n    loadShaderModule(\n      ctx, “Chapter04/04_CubeMap/src/skybox.frag”);\n```", "```cpp\n struct VertexData {\n    vec3 pos;\n    vec3 n;\n    vec2 tc;\n  };\n  const lvk::VertexInput vdesc = {\n    .attributes   = {{ .location = 0,\n                       .format = lvk::VertexFormat::Float3,\n                       .offset = offsetof(VertexData, pos) },\n                     { .location = 1,\n                       .format = lvk::VertexFormat::Float3,\n                       .offset = offsetof(VertexData, n) },\n                     { .location = 2,\n                       .format = lvk::VertexFormat::Float2,\n                       .offset = offsetof(VertexData, tc) }, },\n    .inputBindings = { { .stride = sizeof(VertexData) } },\n  };\n  lvk::Holder<lvk::RenderPipelineHandle> pipeline =\n    ctx->createRenderPipeline({\n      .vertexInput = vdesc,\n      .smVert      = vert,\n      .smFrag      = frag,\n      .color       = { {.format = ctx->getSwapchainFormat()} },\n      .depthFormat = app.getDepthFormat(),\n      .cullMode    = lvk::CullMode_Back,\n  });\n```", "```cpp\n lvk::Holder<lvk::RenderPipelineHandle> pipelineSkybox =\n    ctx->createRenderPipeline({\n      .smVert      = vertSkybox,\n      .smFrag      = fragSkybox,\n      .color       = { {.format = ctx->getSwapchainFormat()} },\n      .depthFormat = app.getDepthFormat(),\n  });\n  const lvk::DepthState dState = {\n    .compareOp = lvk::CompareOp_Less,\n    .isDepthWriteEnabled = true };\n```", "```cpp\n const aiScene* scene = aiImportFile(\n    “data/rubber_duck/scene.gltf”, aiProcess_Triangulate);\n  const aiMesh* mesh = scene->mMeshes[0];\n  std::vector<VertexData> vertices;\n  for (uint32_t i = 0; i != mesh->mNumVertices; i++) {\n    const aiVector3D v = mesh->mVertices[i];\n    const aiVector3D n = mesh->mNormals[i];\n    const aiVector3D t = mesh->mTextureCoords[0][i];\n    vertices.push_back({ .pos = vec3(v.x, v.y, v.z),\n                         .n   = vec3(n.x, n.y, n.z),\n                         .tc  = vec2(t.x, t.y) });\n  }\n  std::vector<uint32_t> indices;\n  for (uint32_t i = 0; i != mesh->mNumFaces; i++)\n    for (uint32_t j = 0; j != 3; j++)\n      indices.push_back(mesh->mFaces[i].mIndices[j]);\n  aiReleaseImport(scene);\n```", "```cpp\n size_t kSizeIndices  = sizeof(uint32_t) * indices.size();\n  size_t kSizeVertices = sizeof(VertexData) * vertices.size();\n  lvk::Holder<lvk::BufferHandle> bufferIndices =\n    ctx->createBuffer({\n      .usage     = lvk::BufferUsageBits_Index,\n      .storage   = lvk::StorageType_Device,\n      .size      = kSizeIndices,\n      .data      = indices.data(),\n      .debugName = “Buffer: indices” }, nullptr);\n  lvk::Holder<lvk::BufferHandle> bufferVertices =\n    ctx->createBuffer({\n      .usage     = lvk::BufferUsageBits_Vertex,\n      .storage   = lvk::StorageType_Device,\n      .size      = kSizeVertices,\n      .data      = vertices.data(),\n      .debugName = “Buffer: vertices” }, nullptr);\n```", "```cpp\n struct PerFrameData {\n    mat4 model;\n    mat4 view;\n    mat4 proj;\n    vec4 cameraPos;\n    uint32_t tex     = 0;\n    uint32_t texCube = 0;\n  };\n  lvk::Holder<lvk::BufferHandle> bufferPerFrame =\n    ctx->createBuffer({\n      .usage     = lvk::BufferUsageBits_Uniform,\n      .storage   = lvk::StorageType_Device,\n      .size      = sizeof(PerFrameData),\n      .debugName = “Buffer: per-frame” }, nullptr);\n```", "```cpp\n lvk::Holder<lvk::TextureHandle> texture = loadTexture(\n    ctx, “data/rubber_duck/textures/Duck_baseColor.png”);\n  lvk::Holder<lvk::TextureHandle> cubemapTex;\n  int w, h;\n  const float* img = stbi_loadf(\n    “data/piazza_bologni_1k.hdr”, &w, &h, nullptr, 4);\n  Bitmap in(w, h, 4, eBitmapFormat_Float, img);\n  Bitmap out = convertEquirectangularMapToVerticalCross(in);\n  stbi_image_free((void*)img);\n  stbi_write_hdr(“.cache/screenshot.hdr”, out.w_, out.h_,\n    out.comp_, (const float*)out.data_.data());\n  Bitmap cubemap = convertVerticalCrossToCubeMapFaces(out);\n  cubemapTex = ctx->createTexture({\n    .type       = lvk::TextureType_Cube,\n    .format     = lvk::Format_RGBA_F32,\n    .dimensions = {(uint32_t)cubemap.w_, (uint32_t)cubemap.h_},\n    .usage      = lvk::TextureUsageBits_Sampled,\n    .data       = cubemap.data_.data(),\n    .debugName  = “data/piazza_bologni_1k.hdr” });\n```", "```cpp\n app.run([&](uint32_t width, uint32_t height,\n    float aspectRatio, float deltaSeconds) {\n    positionerMoveTo.update(deltaSeconds, app.mouseState_.pos,\n      ImGui::GetIO().WantCaptureMouse ?\n        false : app.mouseState_.pressedLeft);\n    const mat4 p  = glm::perspective(glm::radians(60.0f),\n      aspectRatio, 0.1f, 1000.0f);\n    const mat4 m1 = glm::rotate(mat4(1.0f),\n      glm::radians(-90.0f), vec3(1, 0, 0));\n    const mat4 m2 = glm::rotate(mat4(1.0f),\n      (float)glfwGetTime(), vec3(0.0f, 1.0f, 0.0f));\n    const mat4 v  = glm::translate(mat4(1.0f),\n      app.camera_.getPosition());\n    const PerFrameData pc = {\n      .model     = m2 * m1,\n      .view      = app.camera_.getViewMatrix(),\n      .proj      = p,\n      .cameraPos = vec4(app.camera_.getPosition(), 1.0f),\n      .tex       = texture.index(),\n      .texCube   = cubemapTex.index(),\n    };\n    ctx->upload(bufferPerFrame, &pc, sizeof(pc));\n```", "```cpp\n const lvk::RenderPass renderPass = {\n      .color = { { .loadOp = lvk::LoadOp_Clear,\n                   .clearColor = {1.0f, 1.0f, 1.0f, 1.0f} } },\n      .depth = { .loadOp = lvk::LoadOp_Clear,\n                 .clearDepth = 1.0f } };\n    const lvk::Framebuffer framebuffer = {\n      .color = {\n        { .texture = ctx->getCurrentSwapchainTexture() } },\n      .depthStencil = { .texture = app.getDepthTexture() } };\n    lvk::ICommandBuffer& buf = ctx->acquireCommandBuffer();\n    buf.cmdBeginRendering(renderPass, framebuffer);\n```", "```cpp\n buf.cmdPushConstants(ctx->gpuAddress(bufferPerFrame));\n    buf.cmdPushDebugGroupLabel(“Skybox”, 0xff0000ff);\n    buf.cmdBindRenderPipeline(pipelineSkybox);\n    buf.cmdDraw(36);\n    buf.cmdPopDebugGroupLabel();\n```", "```cpp\n buf.cmdPushDebugGroupLabel(“Mesh”, 0xff0000ff);\n    buf.cmdBindVertexBuffer(0, bufferVertices);\n    buf.cmdBindRenderPipeline(pipeline);\n    buf.cmdBindDepthState(dState);\n    buf.cmdBindIndexBuffer(bufferIndices, lvk::IndexFormat_UI32);\n    buf.cmdDrawIndexed(indices.size());\n    buf.cmdPopDebugGroupLabel();\n```", "```cpp\n app.imgui_->beginFrame(framebuffer);\n    ImGui::SetNextWindowPos(ImVec2(10, 10));\n    ImGui::Begin(“Keyboard hints:”, nullptr,\n        ImGuiWindowFlags_AlwaysAutoResize |\n        ImGuiWindowFlags_NoFocusOnAppearing |\n        ImGuiWindowFlags_NoInputs |\n        ImGuiWindowFlags_NoCollapse);\n    ImGui::Text(“W/S/A/D - camera movement”);\n    ImGui::Text(“1/2 - camera up/down”);\n    ImGui::Text(“Shift - fast movement”);\n    ImGui::Text(“Space - reset view”);\n    ImGui::End();\n```", "```cpp\n if (const ImGuiViewport* v = ImGui::GetMainViewport()) {\n      ImGui::SetNextWindowPos({\n        v->WorkPos.x + v->WorkSize.x - 15.0f,\n        v->WorkPos.y + 15.0f }, ImGuiCond_Always,\n        { 1.0f, 0.0f });\n    }\n    ImGui::SetNextWindowBgAlpha(0.30f);\n    ImGui::SetNextWindowSize(\n      ImVec2(ImGui::CalcTextSize(“FPS : _______”).x, 0));\n    if (ImGui::Begin(“##FPS”, nullptr,\n          ImGuiWindowFlags_NoDecoration |\n          ImGuiWindowFlags_AlwaysAutoResize | \n          ImGuiWindowFlags_NoSavedSettings |\n          ImGuiWindowFlags_NoFocusOnAppearing | \n          ImGuiWindowFlags_NoNav | ImGuiWindowFlags_NoMove)) {\n      ImGui::Text(“FPS : %i”, (int)app.fpsCounter_.getFPS());\n      ImGui::Text(\n        “Ms  : %.1f”, 1000.0 / app.fpsCounter_.getFPS());\n    }\n    ImGui::End();\n```", "```cpp\n sinGraph.renderGraph(0, height * 0.7f, width,\n      height * 0.2f, vec4(0.0f, 1.0f, 0.0f, 1.0f));\n    fpsGraph.renderGraph(0, height * 0.8f, width, height * 0.2f);\n    canvas2d.clear();\n    canvas2d.line({ 100, 300 }, { 100, 400 }, vec4(1, 0, 0, 1));\n    canvas2d.line({ 100, 400 }, { 200, 400 }, vec4(0, 1, 0, 1));\n    canvas2d.line({ 200, 400 }, { 200, 300 }, vec4(0, 0, 1, 1));\n    canvas2d.line({ 200, 300 }, { 100, 300 }, vec4(1, 1, 0, 1));\n    canvas2d.render(“##plane”);\n```", "```cpp\n canvas3d.clear();\n    canvas3d.setMatrix(pc.proj * pc.view);\n    canvas3d.plane(vec3(0, 0, 0), vec3(1, 0, 0), vec3(0, 0, 1),\n      40, 40, 10.0f, 10.0f, vec4(1, 0, 0, 1), vec4(0, 1, 0, 1));\n    canvas3d.box(mat4(1.0f), BoundingBox(vec3(-2), vec3(+2)),\n      vec4(1, 1, 0, 1));\n    canvas3d.frustum(\n      glm::lookAt(vec3(cos(glfwGetTime()),\n                  kInitialCameraPos.y, sin(glfwGetTime())),\n                  kInitialCameraTarget, vec3(0.0f, 1.0f, 0.0f)),\n      glm::perspective(glm::radians(60.0f), aspectRatio, 0.1f,\n        30.0f), vec4(1, 1, 1, 1));\n    canvas3d.render(*ctx.get(), framebuffer, buf, width, height);\n```", "```cpp\n app.imgui_->endFrame(buf);\n    buf.cmdEndRendering();\n    ctx->submit(buf, ctx->getCurrentSwapchainTexture());\n    fpsGraph.addPoint(app.fpsCounter_.getFPS());\n    sinGraph.addPoint(sinf(glfwGetTime() * 20.0f));\n  });\n  ctx.release();\n  return 0;\n}\n```"]