["```cpp\nlayout (location = 0) in vec3 VertexPosition; \nlayout (location = 1) in vec3 VertexNormal; \n\nout vec3 Color; \n\nuniform struct LightInfo {\n  vec4 Position; // Light position in eye coords.\n  vec3 La;       // Ambient light intesity\n  vec3 L;        // Diffuse and specular light intensity\n} lights[5];\n\n// Material and matrix uniforms omitted...\n\nvec3 phongModel( int light, vec3 position, vec3 n ) { \n  vec3 ambient = lights[light].La * Material.Ka;\n  vec3 s = normalize( lights[light].Position.xyz - position );\n  float sDotN = max( dot(s,n), 0.0 );\n  vec3 diffuse = Material.Kd * sDotN;\n  vec3 spec = vec3(0.0);\n  if( sDotN > 0.0 ) {\n    vec3 v = normalize(-position.xyz);\n    vec3 r = reflect( -s, n );\n    spec = Material.Ks *\n            pow( max( dot(r,v), 0.0 ), Material.Shininess );\n  }\n\n  return ambient + lights[light].L * (diffuse + spec);\n}\nvoid main() {\n  vec3 camNorm = normalize( NormalMatrix * VertexNormal);\n  vec3 camPosition = \n       ModelViewMatrix * vec4(VertexPosition,1.0)).xyz;\n\n  // Evaluate the lighting equation, for each light\n  Color = vec3(0.0);\n  for( int i = 0; i < 5; i++ )\n      Color += phongModel( i, camPosition, camNorm );\n\n  gl_Position = MVP * vec4(VertexPosition,1.0);\n}\n```", "```cpp\nprog.setUniform(\"lights[0].L\", glm::vec3(0.0f,0.8f,0.8f) ); \nprog.setUniform(\"lights[0].La\", glm::vec3(0.0f,0.2f,0.2f) );\nprog.setUniform(\"lights[0].Position\", position );\n```", "```cpp\nvec3 s;\nif( Light.Position.w == 0.0 )\n  s = normalize( Light.Position.xyz );\nelse\n  s = normalize( Light.Position.xyz - position );\n```", "```cpp\nlayout (location = 0) in vec3 VertexPosition;\nlayout (location = 1) in vec3 VertexNormal;\n\nout vec3 Position;\nout vec3 Normal;\n\nuniform mat4 ModelViewMatrix, NormalMatrix, ProjectionMatrix, MVP;\n\nvoid main() {\n  Normal = normalize( NormalMatrix * VertexNormal);\n  Position = ( ModelViewMatrix * vec4(VertexPosition,1.0) ).xyz;\n  gl_Position = MVP * vec4(VertexPosition,1.0);\n}\n```", "```cpp\nin vec3 Position; \nin vec3 Normal; \n// Uniform variables...\n\nlayout( location = 0 ) out vec4 FragColor; \n\nvec3 phongModel( vec3 position, vec3 n ) { \n   // Compute and return Phong reflection model\n} \n\nvoid main() { \n  FragColor = vec4(phongModel(Position, normalize(Normal)), 1);\n} \n```", "```cpp\nvec3 blinnPhong( vec3 position, vec3 n ) { \n  vec3 ambient = Light.La * Material.Ka;\n  vec3 s = normalize( Light.Position.xyz - position );\n  float sDotN = max( dot(s,n), 0.0 );\n  vec3 diffuse = Material.Kd * sDotN;\n  vec3 spec = vec3(0.0);\n  if( sDotN > 0.0 ) {\n    vec3 v = normalize(-position.xyz);\n    vec3 h = normalize( v + s );\n    spec = Material.Ks *\n            pow( max( dot(h,n), 0.0 ), Material.Shininess );\n  }\n  return ambient + Light.L * (diffuse + spec);\n}\n```", "```cpp\nin vec3 Position; \nin vec3 Normal; \n\nuniform struct SpotLightInfo {\n    vec3 Position;  // Position in cam coords\n    vec3 L;         // Diffuse/spec intensity\n    vec3 La;        // Amb intensity\n    vec3 Direction; // Direction of the spotlight in cam coords.\n    float Exponent; // Angular attenuation exponent\n    float Cutoff;   // Cutoff angle (between 0 and pi/2)\n} Spot;\n\n// Material uniforms...\n\nlayout( location = 0 ) out vec4 FragColor; \n\nvec3 blinnPhongSpot( vec3 position, vec3 n ) { \n  vec3 ambient = Spot.La * Material.Ka, \n    diffuse = vec3(0), spec = vec3(0);\n  vec3 s = normalize( Spot.Position - position );\n  float cosAng = dot(-s, normalize(Spot.Direction));\n  float angle = acos( cosAng );\n  float spotScale = 0.0;\n  if(angle < Spot.Cutoff ) {\n    spotScale = pow( cosAng, Spot.Exponent );\n    float sDotN = max( dot(s,n), 0.0 );\n    diffuse = Material.Kd * sDotN;\n    if( sDotN > 0.0 ) {\n      vec3 v = normalize(-position.xyz);\n      vec3 h = normalize( v + s );\n      spec = Material.Ks *\n        pow( max( dot(h,n), 0.0 ), Material.Shininess );\n    }\n  }\n  return ambient + spotScale * Spot.L * (diffuse + spec);\n}\n\nvoid main() {\n  FragColor = vec4(blinnPhongSpot(Position, normalize(Normal)), 1);\n}\n\n```", "```cpp\nin vec3 Position;\nin vec3 Normal;\n\nuniform struct LightInfo {\n  vec4 Position; // Light position in eye coords.\n  vec3 La;       // Ambient light intesity\n  vec3 L;        // Diffuse and specular light intensity\n} Light;\n\nuniform struct MaterialInfo {\n  vec3 Ka; // Ambient reflectivity\n  vec3 Kd; // Diffuse reflectivity\n} Material;\n\nconst int levels = 3;\nconst float scaleFactor = 1.0 / levels;\n\nlayout( location = 0 ) out vec4 FragColor;\n\nvec3 toonShade( ) {\n    vec3 n = normalize( Normal );\n    vec3 s = normalize( Light.Position.xyz - Position );\n    vec3 ambient = Light.La * Material.Ka;\n    float sDotN = max( dot( s, n ), 0.0 );\n    vec3 diffuse = Material.Kd * floor( sDotN * levels ) * scaleFactor;\n\n    return ambient + Light.L * diffuse;\n}\n\nvoid main() {\n    FragColor = vec4(toonShade(), 1.0);\n}\n```", "```cpp\nin vec3 Position; \nin vec3 Normal; \n// Light and material uniforms ...\nuniform struct FogInfo {\n  float MaxDist;\n  float MinDist;\n  vec3 Color;\n} Fog;\n\nlayout( location = 0 ) out vec4 FragColor;\n\nvec3 blinnPhong( vec3 position, vec3 n ) { \n  // Blinn-Phong reflection model ...\n}\n\nvoid main() {\n    float dist = abs( Position.z );\n    float fogFactor = (Fog.MaxDist - dist) /\n                      (Fog.MaxDist - Fog.MinDist);\n    fogFactor = clamp( fogFactor, 0.0, 1.0 );\n    vec3 shadeColor = blinnPhong(Position, normalize(Normal));\n    vec3 color = mix( Fog.Color, shadeColor, fogFactor );\n    FragColor = vec4(color, 1.0);\n}\n```", "```cpp\nfloat dist = abs( Position.z ); \n```", "```cpp\nfloat dist = length( Position.xyz ); \n```", "```cpp\nuniform struct LightInfo {\n  vec4 Position; // Light position in cam. coords.\n  vec3 L;        // Intensity\n} Light[3];\n```", "```cpp\nuniform struct MaterialInfo {\n  float Rough;  // Roughness\n  bool Metal;   // Metallic (true) or dielectric (false)\n  vec3 Color;   // Diffuse color for dielectrics, f0 for metallic\n} Material;\n```", "```cpp\nvec3 schlickFresnel( float lDotH ) {\n  vec3 f0 = vec3(0.04);  // Dielectrics\n  if( Material.Metal ) {\n    f0 = Material.Color;\n  }\n  return f0 + (1 - f0) * pow(1.0 - lDotH, 5);\n}\n```", "```cpp\nfloat geomSmith( float dotProd ) {\n  float k = (Material.Rough + 1.0) * (Material.Rough + 1.0) / 8.0;\n  float denom = dotProd * (1 - k) + k;\n  return 1.0 / denom;\n}\n```", "```cpp\nfloat ggxDistribution( float nDotH ) {\n  float alpha2 = Material.Rough * Material.Rough * Material.Rough * Material.Rough;\n  float d = (nDotH * nDotH) * (alpha2 - 1) + 1;\n  return alpha2 / (PI * d * d);\n}\n```", "```cpp\nvec3 microfacetModel( int lightIdx, vec3 position, vec3 n ) { \n  vec3 diffuseBrdf = vec3(0.0); // Metallic\n  if( !Material.Metal ) {\n    diffuseBrdf = Material.Color;\n  }\n\n  vec3 l = vec3(0.0), \n    lightI = Light[lightIdx].L;\n  if( Light[lightIdx].Position.w == 0.0 ) {  // Directional light\n    l = normalize(Light[lightIdx].Position.xyz);\n  } else {            // Positional light\n    l = Light[lightIdx].Position.xyz - position;\n    float dist = length(l);\n    l = normalize(l);\n    lightI /= (dist * dist);\n  }\n\n  vec3 v = normalize( -position );\n  vec3 h = normalize( v + l );\n  float nDotH = dot( n, h );\n  float lDotH = dot( l, h );\n  float nDotL = max( dot( n, l ), 0.0 );\n  float nDotV = dot( n, v );\n  vec3 specBrdf = 0.25 * ggxDistribution(nDotH) * \n        schlickFresnel(lDotH) * geomSmith(nDotL) * geomSmith(nDotV);\n\n  return (diffuseBrdf + PI * specBrdf) * lightI * nDotL;\n}\n```", "```cpp\nvoid main() {\n  vec3 sum = vec3(0), n = normalize(Normal);\n  for( int i = 0; i < 3; i++ ) {\n    sum += microfacetModel(i, Position, n);\n  }\n\n  // Gamma \n  sum = pow( sum, vec3(1.0/2.2) );\n\n  FragColor = vec4(sum, 1);\n}\n```"]