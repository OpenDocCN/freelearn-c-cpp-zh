- en: Creating and Debugging Application in Functional Approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed some basic techniques to develop functional programming in the
    previous chapters that include a first-class function, a pure function, and an
    immutable object. In this chapter, we will use all the techniques we have learned
    in the previous chapters to produce an application in a functional way. It will
    also explain how to debug an application that is built using the C++ language.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing an imperative code as a base code to be transformed to the functional
    code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the pure function to the base code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the template metaprogramming to the base code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the filtering technique to the base code using the Lambda expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the recursion technique to the base code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the memoization technique to the base code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging the code to solve, if we get an unexpected result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing an imperative class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now develop the functional class so we can consume it to our functional
    program. Before that, let's prepare a new imperative class named `Customer`. The
    class will have an `int` property named `id` as a unique customer ID number. It
    also has four string properties to store the information about our customer--`name`,
    `address`, `phoneNumber`, and `email`. The class also has a flag--`isActive`--to
    indicate whether or not our customer is active. If the customer has signed a contract
    with us, they are regarded as an active customer. Another property is `registeredCustomers`,
    to save all registered customers we have, regardless of the active customer. We
    will make the `registeredCustomers` member become `static` so we can fill it from
    outside the class and can keep the list of the `Customer` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides these properties, our class will also have four methods to access the
    list of our properties. They will be the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetActiveCustomerNames()`: This can be used to get the list of active customer
    names'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetActiveCustomerAddresses()`: This can be used to get the list of active
    customer addresses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetActiveCustomerPhoneNumbers()`: This can be used to get the list of active
    customer phone numbers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetActiveCustomerEmails()`: This can be used to get the list of active customer
    emails'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the following `Customer.h` code that we can find
    in the `Step01` folder to accommodate our preceding scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we have four public methods that haven''t been defined
    yet. Now, let''s define them as we can see in the following `Customer.cpp` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code, we can see the definition of the four methods we have
    in the `Customer` class. For instance, in the `GetActiveCustomerNames()` method,
    the code loops each element in the `registeredCustomers` vector to find out the
    active customer. If it finds them, the code will extract the name of each customer
    and store it to the `returnList` vector. After finishing the method process, the
    method will feed the `returnList` result to the method user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s consume the preceding class using the following `main.cpp` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, in the `main()` method, we can see that we first register
    our customer from the `RegisterCustomers()` method. There, we fill the static
    public property of the `Customer` class, `registeredCustomers`, with a bunch of
    our customer information. After that, the code instances the `Customer` class
    and invokes the method of the class named `GetActiveCustomerNames()`. As we can
    see, the method returns a vector of string that contains the list of active customer
    names that we will then store in the `activeCustomerNames` vector. Now, we can
    iterate the vector to extract the list of the active customer names. The following
    is the output we should see in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c74fd8b-73c6-4039-b261-75edddd462dd.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the `RegisterCustomer()` method, only five from ten customers
    are active, so not all of the names will be listed in the preceding output. We
    can try the remaining three methods to the information about the active customers
    specifically, their addresses, phone numbers, and email addresses. Our goal in
    this chapter is to use the concepts we've learned in the previous chapters and
    make an application using the functional approach. So, let's see how we can achieve
    that.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the imperative class to become a functional class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Indeed, the preceding `Customer` class can work well, and we have successfully
    invoked its methods. However, the class can still be tweaked by transforming it
    into a functional class. As we can see in the preceding code, we can implement
    a pure function, first-class function, higher-order function, and memoization
    to it to make it become functional. So, in this section, we will refactor the
    `Customer` class to become a functional class and use the knowledge we have from
    the previous chapters. In the upcoming section, we will implement the functional
    method that we have discussed in the previous chapter, which is the first-class
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Passing a function as a parameter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed in [Chapter 2](a1baf007-8f40-4616-8718-9887f95120b0.xhtml),
    *Manipulating Functions in Functional Programming*, we can rewrite the function
    to be a first-class function, which means we can pass a function to another function.
    We will simplify the definition of all the four methods we have in the `Step01`
    code, then we will call the function by passing it to another method named `GetActiveCustomerByFunctionField()`.
    We will also create a new method named `GetActiveCustomerByField()` to select
    the correct method we should run. The definition of the `Customer` class is now
    like the following `Customer.h` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding header file, besides the four private methods,
    we add a new public method named `GetActiveCustomerByFunctionField()`, which we
    will invoke when we need a list of one of the properties. Now, let''s define the
    four methods we create in the preceding header file. The code should be as the
    following `Customer.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Comparing with the `Step01` code, the implementation of the `GetActiveCustomerNames()`,
    `GetActiveCustomerAddresses()`, `GetActiveCustomerPhoneNumbers()`, and `GetActiveCustomerEmails()`
    methods is more concise now. They only contain a single line code. However, we
    need a new method to accommodate the process to get a list of the class'' private
    properties, that is the `GetActiveCustomerByField()` method. The method is passed
    to the function to make it a first-class function, as we can see in the preceding
    code. In this `Step02` folder, the `main.cpp` code should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding `main.cpp` code, we will now invoke the `GetActiveCustomerByField()`
    method instead of `GetActiveCustomerNames()`, as we do in `Step01`. We just need
    to pass a field name in string data type to the `GetActiveCustomerNames()` method
    and it will call the appropriate method to retrieve the properties value. For
    instance, we will retrieve the `name` properties value because we pass `name`
    in the `GetActiveCustomerByField()` method. And, if we run the preceding `Step02`
    code, we should see the following screenshot, which is exactly the same as what
    we see in the `Step01` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/793236ef-020b-465c-b392-8edceb8b9408.png)'
  prefs: []
  type: TYPE_IMG
- en: Although we have the code running properly, there's a problem we will face if
    we want to add more fields or properties to the class, and then need to collect
    the list of that new field. By using the preceding code, we have to add a new
    `else` section in the `GetActiveCustomerByFunctionField()` method. Next, we will
    find the solution to counter it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a base class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we want to add more fields in the class and want to access the list of it
    easily every time we add a new field, we have to create a new class that derives
    from a base class containing a virtual function. By doing this, we can derive
    the base class virtual method and implement the correct code to it. We will also
    gain the power of template metaprogramming here, since we will design the base
    class as a template. The declaration of the base class will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can declare four new classes derived from the base class for the four
    methods in the class. The declaration of the classes should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to modify the argument type for the `GetActiveCustomerByFunctionField()`
    method, so the signature of the method should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, the complete header file for this `Step03` code that implements
    the preceding codes should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, each method in each preceding class has a different task and can be identified
    by the class'' name. We will also modify the `GetActiveCustomerByFunctionField()`
    method implementation since it''s now passed a new argument type, which is the
    class name. By passing a class, it''s now easier to pass our desired task that
    lied in the class'' method. The implementation of the `GetActiveCustomerByFunctionField()`
    method should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the preceding method can run the method of the class we have
    passed, which is `classField`. Moreover, since the class we have is derived from
    the `BaseClass` class, we can notify the method to receive the parameter typed
    `BaseClass`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can implement the public method that we have declared in the header
    file-- the `GetActiveCustomerNames()`, `GetActiveCustomerAddresses()`, `GetActiveCustomerPhoneNumbers()`,
    and `GetActiveCustomerEmails()` methods. These four methods will invoke the `GetActiveCustomerByFunctionField()`
    method and pass the definition of the `InvokeFunction()` method. The code should
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will have a complete `Customer.cpp` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'By having the `Customer.h` and `Customer.cpp` code in this `Step03` folder,
    it''s now easier for us to fetch the list of the properties we have in the `Customer`
    class. For instance, if we want to retrieve a list of active customers, we can
    directly invoke the `GetActiveCustomerNames()` method, as we can see in the following
    `main.cpp` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run the program in the `Step03` folder. We should see the following
    screenshot on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5bc3935e-3059-4f30-b414-8e04a2a1086a.png)'
  prefs: []
  type: TYPE_IMG
- en: Again, we've got the exact same output comparing the previous step. We will
    make the `Customer` class become pure in the next section. So, keep going!
  prefs: []
  type: TYPE_NORMAL
- en: Transforming the class to become pure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed in [Chapter 2](a1baf007-8f40-4616-8718-9887f95120b0.xhtml),
    *Manipulating Functions in Functional Programming*, we have to create a pure function
    in functional programming to avoid the side effect. If we come back to the previous
    `GetActiveCustomerByFunctionField()` method definition, it iterates a `registeredCustomers`
    static member that is a global variable. It will be a problem since the `GetActiveCustomerByFunctionField()`
    method will feed a different output, although with the exact same passed as an
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'To counter this problem, we have to abolish this global variable. We then have
    to modify the method definition as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we don''t have the `registeredCustomers` properties anymore, we also
    have to pass a registered customer list to the `GetActiveCustomerByFunctionField()`
    method. The method will then iterate the customer list we pass, to find the active
    customer. Moreover, because we have modified the method signature, we also have
    to modify the method declaration in the `Customer.h` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We discussed that the `GetActiveCustomerByFunctionField()` method is called
    by the other methods in the `Customer` class. As a result, we also have to modify
    the method implementation, as we can see in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to modify the method declarations in the `Customer.h` file, as
    shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `Customer.h` file will contain the following complete code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And, the `Customer.cpp` file will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `Customer` class has been changed and has no `registeredCustomer`
    variable anymore, we also need to modify the `RegisterCustomers()` method in the
    `main.cpp` file. The previous version of the method returns nothing. Now, we will
    make the code return the list of customers. We also need to modify the `main()`
    method since we have to consume the new `RegisterCustomers()` method in the `Main.cpp`
    file. The file will contain the following block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding `main()` method, we invoke the `GetActiveCustomerNames()`
    method and pass the result of the `RegisterCustomers()` method. Now, let''s try
    the code by running the program in the `Step06` folder. We should get the following
    output on the console when we run the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83af4fa6-23aa-4db0-a7a2-860c55bfc133.png)'
  prefs: []
  type: TYPE_IMG
- en: Again, we've got the exact same output we saw in the previous step, but with
    a new approach in functional programming. Next, we will refactor the code to use
    a Lambda expression to ease the filtering task.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering the condition and implementing a Lambda expression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s focus on the `GetActiveCustomerByFunctionField()` method. There, we
    can find an `if` structure to filter the active customer. As we discussed in the
    previous chapters, we can use the `copy_if()` method to filter the condition.
    The following code snippet implements the `copy_if()` method to filter the active
    customer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code snippet, we create an anonymous method
    that returns true if the customer instance we pass is active. Also, we can refactor
    the preceding `GetActiveCustomerByFunctionField()` method so it will use an anonymous
    method again, as we can see in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to implementing the filtering technique using the Lambda expression,
    we will also add a method to the `Customer` class named `CountActiveCustomers()`.
    The method will count the active customers. The definition of this method should
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will have the `Customer.cpp` code in this `Step05` code block as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget to modify the `Customer.h` file as well, since we have added
    a new method to the class. The file should contain the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will invoke the `CountActiveCustomers()` method in our `main()` function.
    We will see how we do that by examining the following `Main.cpp` code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, we invoke the `CountActiveCustomers()`
    method and pass the output of the `RegisterCustomers()` method as the argument.
    We also add a simple stopwatch to calculate how long the code needs to run the
    program. The output of the preceding code should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6c381e2-85f3-4717-9990-031a1a9fb7f3.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, we need `0.997` milliseconds to run the code in this step. However,
    we can optimize the preceding code to run faster by implementing recursion and
    memoization, which we will discuss in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, we can find out the total of the active customers by running the method
    of `activeCustomerNames.size()` to get the number of elements in the vector after
    we run the following code line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`vector<string> activeCustomerNames = customer.GetActiveCustomerNames(RegisterCustomers())`'
  prefs: []
  type: TYPE_NORMAL
- en: However, the preceding code example wants to show us how the `for` loop can
    be transformed into recursion, to optimize the speed of execution. We will discuss
    this in the upcoming
  prefs: []
  type: TYPE_NORMAL
- en: section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing recursion and memoization techniques to the Customer class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we look at the `CountActiveCustomers()` method definition in `Step05`, we
    use the `for` loop to count the active customers. However, we can rewrite the
    method to use the recursion technique. Let''s take a look at the following code,
    which is the new definition for the `CountActiveCustomers()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code snippet, we use tail recursion for the `CountActiveCustomers()`
    method. We just need to increment the `add` variable every time we find an active
    customer in the `customer` vector. The code then removes the first element of
    the `customer` vector and passes it to the `CountActiveCustomers()` method again.
    We recurse this process until the element of the `customer` vector is empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we use the `Memoization` class we discussed in [Chapter 5](aaf78dc0-36c9-41f9-bf10-efcbd979c096.xhtml),
    *Procrastinating the Execution Process Using Lazy Evaluation*, to optimize our
    code. We will modify the `main()` function in the `Main.cpp` file so the `main()`
    function contains the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code snippet, we now run the `GetActiveCustomerNames()`
    method from the `Memoization` instance by calling the `Fetch()` method. If we
    run the `Step06` code, we should see the following output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75cf002b-d6a6-4118-a72b-89ccb548a3d4.png)'
  prefs: []
  type: TYPE_IMG
- en: The code now only needs `0.502` milliseconds to run. Compared to the `Step05`
    code, the speed of code execution is almost twice as fast. It proves that, by
    using the functional approach, we can gain not only a better code structure, but
    also speed optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, in the coding process, when we run the code, we've got an unexpected
    result from one or more variables. It might happen in the middle of the execution.
    To avoid getting stuck in this situation, we can analyze our program by running
    it step-by-step. We can use the debugger tool that is included in the GCC compiler--**GDB**
    (**The GNU Project Debugger**). This tool allows us to figure out what happens
    inside the target program while it executes, or what it was doing at the moment
    it crashed. In this section, we will apply the GDB to ease our programming task
    and find a solution for the problem and deal with it.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the debugging tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s prepare the executable file we will analyze. We will use the code
    from the `Step01` folder since it''s a simple code, and we can learn easily from
    it. We have to recompile the code using the `-g` option and name the executable
    as `customer.exe`. The following are the three commands to compile the code so
    it can be debugged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: GDB can only analyze the executable file that contains the debugging information
    and symbols that are important in the debugging process. We can insert the `-g`
    option when we compile the source so the debugging information and symbol will
    be added to the executable file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typing `gdb customer` on the console will open the debugger tool and load the
    debugger information and symbol from the `customer.exe` file. We will then see
    the following screenshot on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/075cb3bb-6396-46a8-aa8d-6cb3bd8b24b6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see in the preceding screenshot, it has successfully read the symbol
    from the `customer.exe` file. Then, type `start` in the GDB console to start the
    analyzing process. The debugger will create a temporary breakpoint in the first
    line of the `main()` method. We will see the following screenshot on the console
    after starting the GDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1fb49c2-5b72-40fa-9555-4cb2a43d7635.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, the program is in the debugging process. We can continue the process to
    analyze what is going on with the program. In the next section, we can choose
    between continuing step by step or running the program until the next breakpoint
    is found.
  prefs: []
  type: TYPE_NORMAL
- en: To start the debugging process, we can either call the `run` or `start` command.
    The former will start our program under GDB, while the latter will behave similarly
    but will execute the code line by line. The difference is, if we don't have the
    breakpoint yet, the program will run as usual, just like it does when we call
    the `run` command, while the debugger will automatically set the breakpoint in
    the main block of code and the program will stop when it reaches that breakpoint,
    if we start with the `start` command.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing and stepping the debugging process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three commands to continue the step in the preceding section. They
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`continue`: This resumes the execution of the program until our program completes
    normally. If it finds a breakpoint, the execution will stop at the line where
    the breakpoint is set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`step`: This executes just one more step of our program. The step might mean
    either one line of source code or one machine instruction. If it finds the invocation
    of a function, it will come into the function and run one more step inside the
    function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`next`: This continues to the next line in the current stack frame. In other
    words, if the next command finds the invocation of a function, it will not enter
    the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since we haven''t set the breakpoint yet, let''s type the `next` command so
    the debugging pointer goes to the next line of the code. We will run the `next`
    command multiple times until the end of the code is reached (or until we can see
    that the process is exited normally). We should see the following screenshot when
    we apply the `next` command multiple times:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99f37d0c-0b09-4a03-8fe5-dca276cb92e6.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding screenshot, we can analyze our program by running
    it step by step. Next, we will set the breakpoint if we have a suspect object
    to be analyzed.
  prefs: []
  type: TYPE_NORMAL
- en: We just need to press the `Enter` key to run the previous command in GDB. Pressing
    the *Q* key will make the debugging console exit to the window console.
  prefs: []
  type: TYPE_NORMAL
- en: Setting and deleting the breakpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s exit from the debugging console by typing the *Q* key. We need to restart
    the debugging, so we need to type `gdb customer` again on the window console.
    After that, instead of typing the `start` command, let''s set the breakpoint before
    we continue the process. Let''s type `break 68` and `break Customer.cpp:15` respectively
    in the GDB console. The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e49ce2b0-4515-4fe4-bb5a-9b6ad9bd43dc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we have two breakpoint in separate files--`Main.cpp` and `Customer.cpp`.
    We can now start the debugger by typing `run` in GDB console, as we can see in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a98825ab-5bc8-4cdb-8ee1-23f8afd0f400.png)'
  prefs: []
  type: TYPE_IMG
- en: Since the debugger hit the `GetActiveCustomerNames()` method first, it stops
    in the line where we put the breakpoint in that method, which is line `15` in
    the `Customer.cpp` file. Just type the `continue` command and press *Enter* multiple
    times until it hits the breakpoint in the `Main.cpp` file, line `69`.
  prefs: []
  type: TYPE_NORMAL
- en: Printing the object value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s rerun the debugger by setting the breakpoint on line `68` in the `Main.cpp`
    file, then start the debugger until it hits the breakpoint. After the breakpoint
    is hit, type `print name` to see what the value of the name variable is. The following
    screenshot shows the steps of the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a03fa03-bbf0-4f84-bb7c-b253f53ac888.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding screenshot, the value of the `name` variable
    is `Aiden`. We can continue the debugging by typing the `continue` command so
    the debugger hits the breakpoint again in the `for` loop, then typing `print name`
    to find out the next name value.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are so many commands in the GDB that, will be overloaded if they are
    written in this book. If you need to find more commands in the GDB, refer to the
    following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.gnu.org/software/gdb/documentation/](https://www.gnu.org/software/gdb/documentation/)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter of this book, we developed the functional class successfully
    by refactoring it from the imperative class that we can use to create a more complex
    program with. We implemented what we learned in the previous chapters. We also
    discussed the debugging technique, which is a useful weapon when we face an unexpected
    result or get a crash in the middle of the program.
  prefs: []
  type: TYPE_NORMAL
