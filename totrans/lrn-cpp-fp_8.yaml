- en: Creating and Debugging Application in Functional Approach
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以函数式方法创建和调试应用程序
- en: We discussed some basic techniques to develop functional programming in the
    previous chapters that include a first-class function, a pure function, and an
    immutable object. In this chapter, we will use all the techniques we have learned
    in the previous chapters to produce an application in a functional way. It will
    also explain how to debug an application that is built using the C++ language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们讨论了一些开发函数式编程的基本技术，包括一等函数、纯函数和不可变对象。在本章中，我们将使用在前几章中学到的所有技术以函数式方式生成一个应用程序。它还将解释如何调试使用C++语言构建的应用程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Preparing an imperative code as a base code to be transformed to the functional
    code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备一个命令式代码作为基础代码以转换为函数式代码
- en: Implementing the pure function to the base code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将纯函数应用于基础代码
- en: Implementing the template metaprogramming to the base code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将模板元编程应用于基础代码
- en: Implementing the filtering technique to the base code using the Lambda expression
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Lambda表达式将过滤技术应用于基础代码
- en: Implementing the recursion technique to the base code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将递归技术应用于基础代码
- en: Implementing the memoization technique to the base code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将记忆化技术应用于基础代码
- en: Debugging the code to solve, if we get an unexpected result
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试代码以解决，如果我们得到一个意外的结果
- en: Preparing an imperative class
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备一个命令式类
- en: We will now develop the functional class so we can consume it to our functional
    program. Before that, let's prepare a new imperative class named `Customer`. The
    class will have an `int` property named `id` as a unique customer ID number. It
    also has four string properties to store the information about our customer--`name`,
    `address`, `phoneNumber`, and `email`. The class also has a flag--`isActive`--to
    indicate whether or not our customer is active. If the customer has signed a contract
    with us, they are regarded as an active customer. Another property is `registeredCustomers`,
    to save all registered customers we have, regardless of the active customer. We
    will make the `registeredCustomers` member become `static` so we can fill it from
    outside the class and can keep the list of the `Customer` class.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将开发函数式类，以便我们可以在函数式程序中使用它。在此之前，让我们准备一个新的命令式类，命名为`Customer`。该类将有一个名为`id`的`int`属性，作为唯一的客户ID号码。它还有四个字符串属性来存储有关我们客户的信息--`name`、`address`、`phoneNumber`和`email`。该类还有一个标志--`isActive`--用来指示我们的客户是否活跃。如果客户与我们签订了合同，他们被视为活跃客户。另一个属性是`registeredCustomers`，用来保存我们拥有的所有已注册客户，无论他们是否是活跃客户。我们将使`registeredCustomers`成员成为`static`，这样我们就可以从类外填充它，并保持`Customer`类的列表。
- en: 'Besides these properties, our class will also have four methods to access the
    list of our properties. They will be the following methods:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些属性外，我们的类还将有四个方法来访问我们的属性列表。它们将是以下方法：
- en: '`GetActiveCustomerNames()`: This can be used to get the list of active customer
    names'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetActiveCustomerNames()`: 这可以用来获取活动客户名称列表'
- en: '`GetActiveCustomerAddresses()`: This can be used to get the list of active
    customer addresses'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetActiveCustomerAddresses()`: 这可以用来获取活动客户地址列表'
- en: '`GetActiveCustomerPhoneNumbers()`: This can be used to get the list of active
    customer phone numbers'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetActiveCustomerPhoneNumbers()`: 这可以用来获取活动客户电话号码列表'
- en: '`GetActiveCustomerEmails()`: This can be used to get the list of active customer
    emails'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetActiveCustomerEmails()`: 这可以用来获取活动客户电子邮件列表'
- en: 'Now, let''s take a look at the following `Customer.h` code that we can find
    in the `Step01` folder to accommodate our preceding scenario:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下以下位于`Step01`文件夹中的`Customer.h`代码，以适应我们前面的场景：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'From the preceding code, we have four public methods that haven''t been defined
    yet. Now, let''s define them as we can see in the following `Customer.cpp` code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们有四个尚未定义的公共方法。现在，让我们在下面的`Customer.cpp`代码中定义它们，如下所示：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: From the preceding code, we can see the definition of the four methods we have
    in the `Customer` class. For instance, in the `GetActiveCustomerNames()` method,
    the code loops each element in the `registeredCustomers` vector to find out the
    active customer. If it finds them, the code will extract the name of each customer
    and store it to the `returnList` vector. After finishing the method process, the
    method will feed the `returnList` result to the method user.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到`Customer`类中定义的四个方法。例如，在`GetActiveCustomerNames()`方法中，代码遍历`registeredCustomers`向量中的每个元素以找到活跃客户。如果找到，代码将提取每个客户的名称并将其存储到`returnList`向量中。完成方法处理后，该方法将`returnList`结果传递给用户方法。
- en: 'Now, let''s consume the preceding class using the following `main.cpp` code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用下面的`main.cpp`代码来消费前面的类：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'From the preceding code, in the `main()` method, we can see that we first register
    our customer from the `RegisterCustomers()` method. There, we fill the static
    public property of the `Customer` class, `registeredCustomers`, with a bunch of
    our customer information. After that, the code instances the `Customer` class
    and invokes the method of the class named `GetActiveCustomerNames()`. As we can
    see, the method returns a vector of string that contains the list of active customer
    names that we will then store in the `activeCustomerNames` vector. Now, we can
    iterate the vector to extract the list of the active customer names. The following
    is the output we should see in the console:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，在`main()`方法中，我们可以看到我们首先从`RegisterCustomers()`方法注册我们的客户。在那里，我们用我们的一批客户信息填充`Customer`类的静态公共属性`registeredCustomers`。之后，代码实例化`Customer`类并调用名为`GetActiveCustomerNames()`的方法。正如我们所看到的，该方法返回一个包含活跃客户名称列表的字符串向量，然后我们将这些名称存储在`activeCustomerNames`向量中。现在，我们可以遍历这个向量以提取活跃客户名称列表。以下是我们应该在控制台看到的输出：
- en: '![](img/0c74fd8b-73c6-4039-b261-75edddd462dd.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c74fd8b-73c6-4039-b261-75edddd462dd.png)'
- en: As we can see in the `RegisterCustomer()` method, only five from ten customers
    are active, so not all of the names will be listed in the preceding output. We
    can try the remaining three methods to the information about the active customers
    specifically, their addresses, phone numbers, and email addresses. Our goal in
    this chapter is to use the concepts we've learned in the previous chapters and
    make an application using the functional approach. So, let's see how we can achieve
    that.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在`RegisterCustomer()`方法中看到的，只有十个客户中的五个是活跃的，所以前面的输出中不会列出所有名称。我们可以尝试将剩余的三个方法应用于活跃客户的特定信息，即他们的地址、电话号码和电子邮件地址。本章的目标是使用我们在前几章中学到的概念，并使用函数式方法制作一个应用程序。那么，让我们看看我们如何实现这一点。
- en: Refactoring the imperative class to become a functional class
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将命令式类重构为函数式类
- en: Indeed, the preceding `Customer` class can work well, and we have successfully
    invoked its methods. However, the class can still be tweaked by transforming it
    into a functional class. As we can see in the preceding code, we can implement
    a pure function, first-class function, higher-order function, and memoization
    to it to make it become functional. So, in this section, we will refactor the
    `Customer` class to become a functional class and use the knowledge we have from
    the previous chapters. In the upcoming section, we will implement the functional
    method that we have discussed in the previous chapter, which is the first-class
    function.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，前面的`Customer`类可以很好地工作，我们已经成功调用了它的方法。然而，该类仍然可以通过将其转换为函数式类进行微调。正如我们在前面的代码中所看到的，我们可以实现纯函数、一等函数、高阶函数和记忆化来使其成为函数式类。因此，在本节中，我们将重构`Customer`类以成为函数式类，并使用我们之前章节中了解到的知识。在下一节中，我们将实现我们在上一章中讨论的函数式方法，即一等函数。
- en: Passing a function as a parameter
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将函数作为参数传递
- en: 'As we discussed in [Chapter 2](a1baf007-8f40-4616-8718-9887f95120b0.xhtml),
    *Manipulating Functions in Functional Programming*, we can rewrite the function
    to be a first-class function, which means we can pass a function to another function.
    We will simplify the definition of all the four methods we have in the `Step01`
    code, then we will call the function by passing it to another method named `GetActiveCustomerByFunctionField()`.
    We will also create a new method named `GetActiveCustomerByField()` to select
    the correct method we should run. The definition of the `Customer` class is now
    like the following `Customer.h` code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [第2章](a1baf007-8f40-4616-8718-9887f95120b0.xhtml) 中讨论的，*在函数式编程中操作函数*，我们可以将函数重写为一等函数，这意味着我们可以将一个函数传递给另一个函数。我们将简化
    `Step01` 代码中我们拥有的所有四个方法的定义，然后我们将通过将其传递给名为 `GetActiveCustomerByFunctionField()`
    的另一个方法来调用该函数。我们还将创建一个名为 `GetActiveCustomerByField()` 的新方法来选择我们应该运行的正确方法。`Customer`
    类的定义现在如下 `Customer.h` 代码所示：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As we can see in the preceding header file, besides the four private methods,
    we add a new public method named `GetActiveCustomerByFunctionField()`, which we
    will invoke when we need a list of one of the properties. Now, let''s define the
    four methods we create in the preceding header file. The code should be as the
    following `Customer.cpp` file:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的头文件中看到的，除了四个私有方法外，我们还添加了一个名为 `GetActiveCustomerByFunctionField()` 的新公共方法，当我们需要某个属性列表时将调用它。现在，让我们定义我们在前面的头文件中创建的四个方法。代码应该如下
    `Customer.cpp` 文件所示：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Comparing with the `Step01` code, the implementation of the `GetActiveCustomerNames()`,
    `GetActiveCustomerAddresses()`, `GetActiveCustomerPhoneNumbers()`, and `GetActiveCustomerEmails()`
    methods is more concise now. They only contain a single line code. However, we
    need a new method to accommodate the process to get a list of the class'' private
    properties, that is the `GetActiveCustomerByField()` method. The method is passed
    to the function to make it a first-class function, as we can see in the preceding
    code. In this `Step02` folder, the `main.cpp` code should be as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Step01` 代码相比，`GetActiveCustomerNames()`、`GetActiveCustomerAddresses()`、`GetActiveCustomerPhoneNumbers()`
    和 `GetActiveCustomerEmails()` 方法的实现现在更加简洁。它们只包含一行代码。然而，我们需要一个新的方法来适应获取类私有属性列表的过程，即
    `GetActiveCustomerByField()` 方法。该方法被传递到函数中，使其成为一等函数，正如我们前面代码中所看到的。在这个 `Step02`
    文件夹中，`main.cpp` 代码应该如下所示：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As we can see in the preceding `main.cpp` code, we will now invoke the `GetActiveCustomerByField()`
    method instead of `GetActiveCustomerNames()`, as we do in `Step01`. We just need
    to pass a field name in string data type to the `GetActiveCustomerNames()` method
    and it will call the appropriate method to retrieve the properties value. For
    instance, we will retrieve the `name` properties value because we pass `name`
    in the `GetActiveCustomerByField()` method. And, if we run the preceding `Step02`
    code, we should see the following screenshot, which is exactly the same as what
    we see in the `Step01` code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在前面的 `main.cpp` 代码中所见，我们现在将调用 `GetActiveCustomerByField()` 方法，而不是在 `Step01`
    中使用的 `GetActiveCustomerNames()` 方法。我们只需将一个字段名称以字符串数据类型传递给 `GetActiveCustomerNames()`
    方法，它将调用适当的方法来检索属性值。例如，我们将检索 `name` 属性值，因为我们传递了 `name` 到 `GetActiveCustomerByField()`
    方法。此外，如果我们运行前面的 `Step02` 代码，我们应该看到以下截图，它与 `Step01` 代码中看到的是完全相同的：
- en: '![](img/793236ef-020b-465c-b392-8edceb8b9408.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/793236ef-020b-465c-b392-8edceb8b9408.png)'
- en: Although we have the code running properly, there's a problem we will face if
    we want to add more fields or properties to the class, and then need to collect
    the list of that new field. By using the preceding code, we have to add a new
    `else` section in the `GetActiveCustomerByFunctionField()` method. Next, we will
    find the solution to counter it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的代码运行正常，但如果我们想向类中添加更多字段或属性，然后需要收集新字段的列表，我们将会遇到一个问题。通过使用前面的代码，我们必须在 `GetActiveCustomerByFunctionField()`
    方法中添加一个新的 `else` 部分。接下来，我们将找到解决这个问题的方法。
- en: Adding a base class
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加基类
- en: 'If we want to add more fields in the class and want to access the list of it
    easily every time we add a new field, we have to create a new class that derives
    from a base class containing a virtual function. By doing this, we can derive
    the base class virtual method and implement the correct code to it. We will also
    gain the power of template metaprogramming here, since we will design the base
    class as a template. The declaration of the base class will be as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在类中添加更多字段，并且每次添加新字段时都希望轻松访问其列表，我们必须创建一个新的类，该类从包含虚函数的基类派生。通过这样做，我们可以从基类派生虚方法并实现正确的代码。我们还将获得模板元编程的力量，因为我们将会把基类设计为一个模板。基类的声明如下所示：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we can declare four new classes derived from the base class for the four
    methods in the class. The declaration of the classes should be as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以声明四个新的类，这些类从基类派生，用于类中的四个方法。类的声明应该如下所示：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We also need to modify the argument type for the `GetActiveCustomerByFunctionField()`
    method, so the signature of the method should be as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改`GetActiveCustomerByFunctionField()`方法的参数类型，因此该方法的签名应该如下所示：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Additionally, the complete header file for this `Step03` code that implements
    the preceding codes should be as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，实现前面代码的`Step03`代码的完整头文件应该如下所示：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, each method in each preceding class has a different task and can be identified
    by the class'' name. We will also modify the `GetActiveCustomerByFunctionField()`
    method implementation since it''s now passed a new argument type, which is the
    class name. By passing a class, it''s now easier to pass our desired task that
    lied in the class'' method. The implementation of the `GetActiveCustomerByFunctionField()`
    method should be as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个类中的每个方法都有不同的任务，可以通过类的名称来识别。我们还将修改`GetActiveCustomerByFunctionField()`方法实现，因为它现在传递了一个新的参数类型，即类名。通过传递一个类，现在更容易传递我们想要的位于类方法中的任务。`GetActiveCustomerByFunctionField()`方法的实现应该如下所示：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we can see, the preceding method can run the method of the class we have
    passed, which is `classField`. Moreover, since the class we have is derived from
    the `BaseClass` class, we can notify the method to receive the parameter typed
    `BaseClass`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，前面的方法可以运行我们传递的类的`classField`方法。此外，由于我们的类是从`BaseClass`类派生的，我们可以通知方法接收参数类型为`BaseClass`。
- en: 'Now we can implement the public method that we have declared in the header
    file-- the `GetActiveCustomerNames()`, `GetActiveCustomerAddresses()`, `GetActiveCustomerPhoneNumbers()`,
    and `GetActiveCustomerEmails()` methods. These four methods will invoke the `GetActiveCustomerByFunctionField()`
    method and pass the definition of the `InvokeFunction()` method. The code should
    be as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现我们在头文件中声明的公共方法——`GetActiveCustomerNames()`、`GetActiveCustomerAddresses()`、`GetActiveCustomerPhoneNumbers()`和`GetActiveCustomerEmails()`方法。这四个方法将调用`GetActiveCustomerByFunctionField()`方法并传递`InvokeFunction()`方法的定义。代码应该如下所示：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we will have a complete `Customer.cpp` file as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将有一个完整的`Customer.cpp`文件，如下所示：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'By having the `Customer.h` and `Customer.cpp` code in this `Step03` folder,
    it''s now easier for us to fetch the list of the properties we have in the `Customer`
    class. For instance, if we want to retrieve a list of active customers, we can
    directly invoke the `GetActiveCustomerNames()` method, as we can see in the following
    `main.cpp` code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Customer.h`和`Customer.cpp`代码放在这个`Step03`文件夹中，现在我们更容易获取`Customer`类中拥有的属性列表。例如，如果我们想检索活跃客户的列表，我们可以直接调用`GetActiveCustomerNames()`方法，如下面的`main.cpp`代码所示：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let''s run the program in the `Step03` folder. We should see the following
    screenshot on the console:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`Step03`文件夹中运行程序。我们应该在控制台上看到以下截图：
- en: '![](img/5bc3935e-3059-4f30-b414-8e04a2a1086a.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5bc3935e-3059-4f30-b414-8e04a2a1086a.png)'
- en: Again, we've got the exact same output comparing the previous step. We will
    make the `Customer` class become pure in the next section. So, keep going!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，与前一步相比，我们得到了完全相同的结果。在下一节中，我们将使`Customer`类成为纯类。所以，继续前进！
- en: Transforming the class to become pure
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将类转换为纯类
- en: As we discussed in [Chapter 2](a1baf007-8f40-4616-8718-9887f95120b0.xhtml),
    *Manipulating Functions in Functional Programming*, we have to create a pure function
    in functional programming to avoid the side effect. If we come back to the previous
    `GetActiveCustomerByFunctionField()` method definition, it iterates a `registeredCustomers`
    static member that is a global variable. It will be a problem since the `GetActiveCustomerByFunctionField()`
    method will feed a different output, although with the exact same passed as an
    argument.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [第 2 章](a1baf007-8f40-4616-8718-9887f95120b0.xhtml) 中讨论的，*在函数式编程中操作函数*，我们必须在函数式编程中创建一个纯函数来避免副作用。如果我们回到之前的
    `GetActiveCustomerByFunctionField()` 方法定义，它会迭代一个 `registeredCustomers` 静态成员，这是一个全局变量。这将是一个问题，因为
    `GetActiveCustomerByFunctionField()` 方法将提供不同的输出，尽管传递的参数完全相同。
- en: 'To counter this problem, we have to abolish this global variable. We then have
    to modify the method definition as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们必须废除这个全局变量。然后我们必须按照以下方式修改方法定义：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Since we don''t have the `registeredCustomers` properties anymore, we also
    have to pass a registered customer list to the `GetActiveCustomerByFunctionField()`
    method. The method will then iterate the customer list we pass, to find the active
    customer. Moreover, because we have modified the method signature, we also have
    to modify the method declaration in the `Customer.h` file as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有 `registeredCustomers` 属性了，我们还需要将注册客户列表传递给 `GetActiveCustomerByFunctionField()`
    方法。该方法将遍历我们传递的客户列表，以找到活动客户。此外，因为我们已经修改了方法签名，我们还需要按照以下方式修改 `Customer.h` 文件中的方法声明：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We discussed that the `GetActiveCustomerByFunctionField()` method is called
    by the other methods in the `Customer` class. As a result, we also have to modify
    the method implementation, as we can see in the following code snippet:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论过 `GetActiveCustomerByFunctionField()` 方法是由 `Customer` 类中的其他方法调用的。因此，我们还需要修改方法实现，如下面的代码片段所示：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We also need to modify the method declarations in the `Customer.h` file, as
    shown in the following code snippet:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改 `Customer.h` 文件中的方法声明，如下面的代码片段所示：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, the `Customer.h` file will contain the following complete code block:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Customer.h` 文件将包含以下完整的代码块：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And, the `Customer.cpp` file will be as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，`Customer.cpp` 文件将如下所示：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Since the `Customer` class has been changed and has no `registeredCustomer`
    variable anymore, we also need to modify the `RegisterCustomers()` method in the
    `main.cpp` file. The previous version of the method returns nothing. Now, we will
    make the code return the list of customers. We also need to modify the `main()`
    method since we have to consume the new `RegisterCustomers()` method in the `Main.cpp`
    file. The file will contain the following block of code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Customer` 类已经更改并且不再有 `registeredCustomer` 变量，我们还需要修改 `main.cpp` 文件中的 `RegisterCustomers()`
    方法。该方法的前一个版本不返回任何内容。现在，我们将使代码返回客户列表。我们还需要修改 `main()` 方法，因为我们必须在 `Main.cpp` 文件中消费新的
    `RegisterCustomers()` 方法。该文件将包含以下代码块：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As we can see in the preceding `main()` method, we invoke the `GetActiveCustomerNames()`
    method and pass the result of the `RegisterCustomers()` method. Now, let''s try
    the code by running the program in the `Step06` folder. We should get the following
    output on the console when we run the program:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的 `main()` 方法中看到的，我们调用了 `GetActiveCustomerNames()` 方法，并传递了 `RegisterCustomers()`
    方法的返回结果。现在，让我们尝试在 `Step06` 文件夹中运行程序。当我们运行程序时，应该在控制台上得到以下输出：
- en: '![](img/83af4fa6-23aa-4db0-a7a2-860c55bfc133.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83af4fa6-23aa-4db0-a7a2-860c55bfc133.png)'
- en: Again, we've got the exact same output we saw in the previous step, but with
    a new approach in functional programming. Next, we will refactor the code to use
    a Lambda expression to ease the filtering task.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们得到了与上一步完全相同的输出，但采用了新的函数式编程方法。接下来，我们将重构代码以使用 Lambda 表达式来简化过滤任务。
- en: Filtering the condition and implementing a Lambda expression
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤条件和实现 Lambda 表达式
- en: 'Let''s focus on the `GetActiveCustomerByFunctionField()` method. There, we
    can find an `if` structure to filter the active customer. As we discussed in the
    previous chapters, we can use the `copy_if()` method to filter the condition.
    The following code snippet implements the `copy_if()` method to filter the active
    customer:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于 `GetActiveCustomerByFunctionField()` 方法。在那里，我们可以找到一个 `if` 结构来过滤活动客户。正如我们在前面的章节中讨论的，我们可以使用
    `copy_if()` 方法来过滤条件。以下代码片段实现了 `copy_if()` 方法来过滤活动客户：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As we can see in the preceding code snippet, we create an anonymous method
    that returns true if the customer instance we pass is active. Also, we can refactor
    the preceding `GetActiveCustomerByFunctionField()` method so it will use an anonymous
    method again, as we can see in the following code snippet:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，我们创建了一个匿名方法，如果传递的客户实例是活跃的，则返回 true。此外，我们可以重构前面的 `GetActiveCustomerByFunctionField()`
    方法，使其再次使用匿名方法，如以下代码片段所示：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In addition to implementing the filtering technique using the Lambda expression,
    we will also add a method to the `Customer` class named `CountActiveCustomers()`.
    The method will count the active customers. The definition of this method should
    be as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 Lambda 表达式实现过滤技术外，我们还将向 `Customer` 类添加一个名为 `CountActiveCustomers()` 的方法。该方法将计算活跃客户数量。此方法的定义应如下所示：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we will have the `Customer.cpp` code in this `Step05` code block as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将 `Customer.cpp` 代码放在这个 `Step05` 代码块中如下所示：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Don''t forget to modify the `Customer.h` file as well, since we have added
    a new method to the class. The file should contain the following piece of code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记修改 `Customer.h` 文件，因为我们已经向类中添加了一个新方法。该文件应包含以下代码段：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, we will invoke the `CountActiveCustomers()` method in our `main()` function.
    We will see how we do that by examining the following `Main.cpp` code block:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在 `main()` 函数中调用 `CountActiveCustomers()` 方法。我们将通过检查以下 `Main.cpp` 代码块来了解如何实现这一点：
- en: '[PRE26]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As we can see in the preceding code, we invoke the `CountActiveCustomers()`
    method and pass the output of the `RegisterCustomers()` method as the argument.
    We also add a simple stopwatch to calculate how long the code needs to run the
    program. The output of the preceding code should be as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们调用了 `CountActiveCustomers()` 方法，并将 `RegisterCustomers()` 方法的输出作为参数传递。我们还添加了一个简单的计时器来计算代码运行程序所需的时间。前述代码的输出应如下所示：
- en: '![](img/b6c381e2-85f3-4717-9990-031a1a9fb7f3.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b6c381e2-85f3-4717-9990-031a1a9fb7f3.png)'
- en: As we can see, we need `0.997` milliseconds to run the code in this step. However,
    we can optimize the preceding code to run faster by implementing recursion and
    memoization, which we will discuss in the next section.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们在这个步骤中运行代码需要 `0.997` 毫秒。然而，我们可以通过实现递归和记忆化来优化前面的代码，使其运行更快，我们将在下一节讨论这一点。
- en: 'Indeed, we can find out the total of the active customers by running the method
    of `activeCustomerNames.size()` to get the number of elements in the vector after
    we run the following code line:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，我们可以通过运行 `activeCustomerNames.size()` 方法来找出活跃客户总数，该方法在执行以下代码行后获取向量的元素数量：
- en: '`vector<string> activeCustomerNames = customer.GetActiveCustomerNames(RegisterCustomers())`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector<string> activeCustomerNames = customer.GetActiveCustomerNames(RegisterCustomers())`'
- en: However, the preceding code example wants to show us how the `for` loop can
    be transformed into recursion, to optimize the speed of execution. We will discuss
    this in the upcoming
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，前述代码示例旨在向我们展示如何将 `for` 循环转换为递归，以优化执行速度。我们将在接下来的内容中讨论这一点。
- en: section.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: section.
- en: Implementing recursion and memoization techniques to the Customer class
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将递归和记忆化技术应用于客户类
- en: 'If we look at the `CountActiveCustomers()` method definition in `Step05`, we
    use the `for` loop to count the active customers. However, we can rewrite the
    method to use the recursion technique. Let''s take a look at the following code,
    which is the new definition for the `CountActiveCustomers()` method:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 `Step05` 中的 `CountActiveCustomers()` 方法定义，我们使用 `for` 循环来计算活跃客户。然而，我们可以将该方法重写为使用递归技术。让我们看看以下代码，这是
    `CountActiveCustomers()` 方法的新的定义：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As we can see in the preceding code snippet, we use tail recursion for the `CountActiveCustomers()`
    method. We just need to increment the `add` variable every time we find an active
    customer in the `customer` vector. The code then removes the first element of
    the `customer` vector and passes it to the `CountActiveCustomers()` method again.
    We recurse this process until the element of the `customer` vector is empty.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，我们为 `CountActiveCustomers()` 方法使用了尾递归。我们只需在 `customer` 向量中找到活跃客户时增加
    `add` 变量。然后代码移除 `customer` 向量的第一个元素，并将其传递给 `CountActiveCustomers()` 方法。我们递归这个过程，直到
    `customer` 向量的元素为空。
- en: 'Also, we use the `Memoization` class we discussed in [Chapter 5](aaf78dc0-36c9-41f9-bf10-efcbd979c096.xhtml),
    *Procrastinating the Execution Process Using Lazy Evaluation*, to optimize our
    code. We will modify the `main()` function in the `Main.cpp` file so the `main()`
    function contains the following code snippet:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还使用了我们在[第5章](aaf78dc0-36c9-41f9-bf10-efcbd979c096.xhtml)中讨论的`Memoization`类，*使用延迟评估推迟执行过程*，以优化我们的代码。我们将修改`Main.cpp`文件中的`main()`函数，使`main()`函数包含以下代码片段：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As we can see in the preceding code snippet, we now run the `GetActiveCustomerNames()`
    method from the `Memoization` instance by calling the `Fetch()` method. If we
    run the `Step06` code, we should see the following output on the console:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个代码片段所示，我们现在通过调用`Fetch()`方法从`Memoization`实例中运行`GetActiveCustomerNames()`方法。如果我们运行`Step06`代码，我们应该在控制台上看到以下输出：
- en: '![](img/75cf002b-d6a6-4118-a72b-89ccb548a3d4.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75cf002b-d6a6-4118-a72b-89ccb548a3d4.png)'
- en: The code now only needs `0.502` milliseconds to run. Compared to the `Step05`
    code, the speed of code execution is almost twice as fast. It proves that, by
    using the functional approach, we can gain not only a better code structure, but
    also speed optimization.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 代码现在只需`0.502`毫秒即可运行。与`Step05`代码相比，代码执行速度几乎快了两倍。这证明了通过使用函数式方法，我们不仅可以获得更好的代码结构，还可以实现速度优化。
- en: Debugging the code
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试代码
- en: Sometimes, in the coding process, when we run the code, we've got an unexpected
    result from one or more variables. It might happen in the middle of the execution.
    To avoid getting stuck in this situation, we can analyze our program by running
    it step-by-step. We can use the debugger tool that is included in the GCC compiler--**GDB**
    (**The GNU Project Debugger**). This tool allows us to figure out what happens
    inside the target program while it executes, or what it was doing at the moment
    it crashed. In this section, we will apply the GDB to ease our programming task
    and find a solution for the problem and deal with it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在编码过程中，当我们运行代码时，一个或多个变量可能会得到意外的结果。这可能会在执行过程中发生。为了避免陷入这种情况，我们可以通过逐步运行程序来分析我们的程序。我们可以使用GCC编译器中包含的调试工具——**GDB**（**GNU项目调试器**）。此工具允许我们在目标程序执行时了解其内部发生的情况，或者了解它在崩溃时的行为。在本节中，我们将应用GDB以简化编程任务，找到问题的解决方案并处理它。
- en: Starting the debugging tool
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动调试工具
- en: 'Now, let''s prepare the executable file we will analyze. We will use the code
    from the `Step01` folder since it''s a simple code, and we can learn easily from
    it. We have to recompile the code using the `-g` option and name the executable
    as `customer.exe`. The following are the three commands to compile the code so
    it can be debugged:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们准备我们将要分析的可执行文件。我们将使用`Step01`文件夹中的代码，因为它很简单，我们可以从中轻松学习。我们必须使用`-g`选项重新编译代码，并将可执行文件命名为`customer.exe`。以下是将代码编译为可调试格式的三个命令：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: GDB can only analyze the executable file that contains the debugging information
    and symbols that are important in the debugging process. We can insert the `-g`
    option when we compile the source so the debugging information and symbol will
    be added to the executable file.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: GDB只能分析包含调试过程中重要的调试信息和符号的可执行文件。我们可以在编译源代码时插入`-g`选项，这样调试信息和符号就会被添加到可执行文件中。
- en: 'Typing `gdb customer` on the console will open the debugger tool and load the
    debugger information and symbol from the `customer.exe` file. We will then see
    the following screenshot on the console:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中输入`gdb customer`将打开调试工具，并从`customer.exe`文件中加载调试信息和符号。控制台将显示以下屏幕截图：
- en: '![](img/075cb3bb-6396-46a8-aa8d-6cb3bd8b24b6.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/075cb3bb-6396-46a8-aa8d-6cb3bd8b24b6.png)'
- en: 'As we can see in the preceding screenshot, it has successfully read the symbol
    from the `customer.exe` file. Then, type `start` in the GDB console to start the
    analyzing process. The debugger will create a temporary breakpoint in the first
    line of the `main()` method. We will see the following screenshot on the console
    after starting the GDB:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，它已成功从`customer.exe`文件中读取符号。然后，在GDB控制台中输入`start`以启动分析过程。调试器将在`main()`方法的第1行创建一个临时断点。启动GDB后，控制台将显示以下屏幕截图：
- en: '![](img/c1fb49c2-5b72-40fa-9555-4cb2a43d7635.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1fb49c2-5b72-40fa-9555-4cb2a43d7635.png)'
- en: Now, the program is in the debugging process. We can continue the process to
    analyze what is going on with the program. In the next section, we can choose
    between continuing step by step or running the program until the next breakpoint
    is found.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，程序处于调试过程中。我们可以继续这个过程来分析程序正在发生什么。在下文中，我们可以在逐步进行或运行程序直到找到下一个断点之间进行选择。
- en: To start the debugging process, we can either call the `run` or `start` command.
    The former will start our program under GDB, while the latter will behave similarly
    but will execute the code line by line. The difference is, if we don't have the
    breakpoint yet, the program will run as usual, just like it does when we call
    the `run` command, while the debugger will automatically set the breakpoint in
    the main block of code and the program will stop when it reaches that breakpoint,
    if we start with the `start` command.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始调试过程，我们可以调用`run`或`start`命令。前者将在GDB下启动我们的程序，而后者将类似地执行，但会逐行执行代码。区别在于，如果我们还没有设置断点，程序将像调用`run`命令时一样正常运行，而调试器将自动在主代码块中设置断点，如果以`start`命令开始，程序将在到达该断点时停止。
- en: Continuing and stepping the debugging process
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续和逐步调试过程
- en: 'There are three commands to continue the step in the preceding section. They
    are as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个部分中，有三个命令可以继续逐步操作。它们如下所示：
- en: '`continue`: This resumes the execution of the program until our program completes
    normally. If it finds a breakpoint, the execution will stop at the line where
    the breakpoint is set.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`continue`: 这将恢复程序的执行，直到程序正常完成。如果它找到一个断点，执行将在设置断点的行停止。'
- en: '`step`: This executes just one more step of our program. The step might mean
    either one line of source code or one machine instruction. If it finds the invocation
    of a function, it will come into the function and run one more step inside the
    function.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`step`: 这将执行我们程序的下一个步骤。步骤可能意味着一行源代码或一条机器指令。如果它找到函数的调用，它将进入该函数并在函数内部再执行一个步骤。'
- en: '`next`: This continues to the next line in the current stack frame. In other
    words, if the next command finds the invocation of a function, it will not enter
    the function.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next`: 这将继续到当前堆栈帧的下一行。换句话说，如果下一个命令找到函数的调用，它将不会进入该函数。'
- en: 'Since we haven''t set the breakpoint yet, let''s type the `next` command so
    the debugging pointer goes to the next line of the code. We will run the `next`
    command multiple times until the end of the code is reached (or until we can see
    that the process is exited normally). We should see the following screenshot when
    we apply the `next` command multiple times:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还没有设置断点，让我们输入`next`命令，使调试指针移动到代码的下一行。我们将多次运行`next`命令，直到到达代码的末尾（或直到我们可以看到进程已正常退出）。当我们多次应用`next`命令时，我们应该看到以下屏幕截图：
- en: '![](img/99f37d0c-0b09-4a03-8fe5-dca276cb92e6.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/99f37d0c-0b09-4a03-8fe5-dca276cb92e6.png)'
- en: As we can see in the preceding screenshot, we can analyze our program by running
    it step by step. Next, we will set the breakpoint if we have a suspect object
    to be analyzed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，我们可以通过逐步运行程序来分析我们的程序。接下来，如果我们有一个需要分析的可疑对象，我们将设置断点。
- en: We just need to press the `Enter` key to run the previous command in GDB. Pressing
    the *Q* key will make the debugging console exit to the window console.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需按下`Enter`键即可在GDB中运行上一个命令。按下*Q*键将使调试控制台退出到窗口控制台。
- en: Setting and deleting the breakpoint
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置和删除断点
- en: 'Let''s exit from the debugging console by typing the *Q* key. We need to restart
    the debugging, so we need to type `gdb customer` again on the window console.
    After that, instead of typing the `start` command, let''s set the breakpoint before
    we continue the process. Let''s type `break 68` and `break Customer.cpp:15` respectively
    in the GDB console. The output is shown as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过输入*Q*键退出调试控制台。我们需要重新启动调试，因此需要在窗口控制台中再次输入`gdb customer`。之后，在继续过程之前，让我们设置断点。在GDB控制台中分别输入`break
    68`和`break Customer.cpp:15`。输出如下所示：
- en: '![](img/e49ce2b0-4515-4fe4-bb5a-9b6ad9bd43dc.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e49ce2b0-4515-4fe4-bb5a-9b6ad9bd43dc.png)'
- en: 'Now, we have two breakpoint in separate files--`Main.cpp` and `Customer.cpp`.
    We can now start the debugger by typing `run` in GDB console, as we can see in
    the following screenshot:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在两个不同的文件中设置了两个断点--`Main.cpp`和`Customer.cpp`。现在，我们可以在GDB控制台中输入`run`来启动调试器，如下面的屏幕截图所示：
- en: '![](img/a98825ab-5bc8-4cdb-8ee1-23f8afd0f400.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a98825ab-5bc8-4cdb-8ee1-23f8afd0f400.png)'
- en: Since the debugger hit the `GetActiveCustomerNames()` method first, it stops
    in the line where we put the breakpoint in that method, which is line `15` in
    the `Customer.cpp` file. Just type the `continue` command and press *Enter* multiple
    times until it hits the breakpoint in the `Main.cpp` file, line `69`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于调试器首先遇到了`GetActiveCustomerNames()`方法，它停止在该方法中我们放置断点的行，即`Customer.cpp`文件中的第`15`行。只需输入`continue`命令并多次按*Enter*键，直到它再次在`Main.cpp`文件的断点处停止，即第`69`行。
- en: Printing the object value
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印对象值
- en: 'Let''s rerun the debugger by setting the breakpoint on line `68` in the `Main.cpp`
    file, then start the debugger until it hits the breakpoint. After the breakpoint
    is hit, type `print name` to see what the value of the name variable is. The following
    screenshot shows the steps of the process:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在`Main.cpp`文件的第`68`行设置断点来重新运行调试器，然后启动调试器直到它遇到断点。遇到断点后，输入`print name`来查看`name`变量的值。以下截图显示了该过程的步骤：
- en: '![](img/7a03fa03-bbf0-4f84-bb7c-b253f53ac888.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a03fa03-bbf0-4f84-bb7c-b253f53ac888.png)'
- en: As we can see in the preceding screenshot, the value of the `name` variable
    is `Aiden`. We can continue the debugging by typing the `continue` command so
    the debugger hits the breakpoint again in the `for` loop, then typing `print name`
    to find out the next name value.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，`name`变量的值是`Aiden`。我们可以通过输入`continue`命令继续调试，这样调试器就会再次在`for`循环中的断点处停止，然后输入`print
    name`来找出下一个名称值。
- en: 'There are so many commands in the GDB that, will be overloaded if they are
    written in this book. If you need to find more commands in the GDB, refer to the
    following link:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: GDB中有如此多的命令，如果在本书中全部列出，将会过多。如果您需要查找更多GDB命令，请参考以下链接：
- en: '[https://www.gnu.org/software/gdb/documentation/](https://www.gnu.org/software/gdb/documentation/)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[GNU GDB 文档](https://www.gnu.org/software/gdb/documentation/)'
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In the last chapter of this book, we developed the functional class successfully
    by refactoring it from the imperative class that we can use to create a more complex
    program with. We implemented what we learned in the previous chapters. We also
    discussed the debugging technique, which is a useful weapon when we face an unexpected
    result or get a crash in the middle of the program.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一章，我们成功地将功能类从我们可以用它来创建更复杂程序的命令式类重构出来。我们实现了在前几章学到的内容。我们还讨论了调试技术，这在面对意外结果或在程序中间崩溃时是一个有用的武器。
