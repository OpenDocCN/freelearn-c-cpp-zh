- en: Debugging Tools for Real-Time Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Serious debugging tools are incredibly important in serious embedded systems
    development. Complex RTOS-based systems can have many tasks and dozens of ISRs
    that need to be completed in a timely manner. Figuring out whether everything
    is working properly (or *why* it isn't) is way easier with the right tools. If
    you've been troubleshooting with the occasional print statement or blinking LEDs,
    you're in for a treat!
  prefs: []
  type: TYPE_NORMAL
- en: We'll be making heavy use of Ozone and SystemView throughout the remainder of
    this book but first, we'll need to get them set up and look at a quick introduction.
    Toward the end of this chapter, we'll take a look at other debugging tools, as
    well as techniques for reducing the number of bugs that get written in the first
    place.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a nutshell, we will be covering the following in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The importance of excellent debugging tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using SEGGER J-Link
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using SEGGER Ozone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using SEGGER SystemView
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other great tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Several pieces of software will be installed and configured in this chapter.
    Here''s what you should already have on hand:'
  prefs: []
  type: TYPE_NORMAL
- en: A Nucleo F767 development board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A micro-USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Windows PC (the Windows OS is only required by the ST-Link Reflash utility)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: STM32CubeIDE (ST-Link drivers are required for the ST-Link Reflash utility)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All source code for this chapter can be downloaded from [https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapters5_6](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapters5_6).
  prefs: []
  type: TYPE_NORMAL
- en: The importance of excellent debugging tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing any piece of software, it's all too easy to start writing code
    without thinking about all of the details. Thanks to code generation tools and
    third-party libraries, we can very quickly develop a feature-filled application
    and have it running on actual hardware in fairly short order. However, when it
    comes to getting *every* part of a system working 100% of the time, things are
    a bit more difficult. If a system is stood up too quickly and the components weren't
    properly tested before integrating them, there would be pieces that work *most*
    of the time, but not always.
  prefs: []
  type: TYPE_NORMAL
- en: Often with embedded systems, only a few parts of the underlying application
    are visible. It can be challenging to evaluate the overall system health from
    a user's viewpoint. Historically, good debug tooling was less common for embedded
    work than non-embedded. Putting print statements everywhere only gets you so far,
    causes timing problems, and so on. Blinking LEDs is cumbersome and doesn't provide
    much insight. Analyzing signals via hardware can help to verify symptoms but doesn't
    always isolate the root cause of an issue. Trying to figure out what code is actually
    running (and when) in an event-driven system is really challenging without the
    tools to help visualize execution.
  prefs: []
  type: TYPE_NORMAL
- en: This is why having a variety of familiar tools at your disposal is extremely
    helpful. It allows you to focus your efforts on developing small portions of the
    application confidently. Confidence comes from rigorously verifying each piece
    of functionality as it is developed and integrated with the rest of the system.
    However, in order to perform verification, we need to have transparency in different
    portions of the code (not just the parts that are observable from outside the
    system). Many times during verification, situations arise when there is a need
    to observe inter-task execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two important areas that help us achieve the objectives of system
    transparency and observable task relationships: RTOS-aware debugging and RTOS
    visualization.'
  prefs: []
  type: TYPE_NORMAL
- en: RTOS-aware debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With traditional debugging setups used for bare-metal (for example, no OS)
    coding, there was only one stack to observe. Since the programming model was a
    single super loop with some interrupts, this wasn''t much of a problem. At any
    point in time, the state of the system could be discerned by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Knowing which function the **program counter** (**PC**) was in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowing which interrupts were active
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at the value of key global variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observing/unwinding the stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With an RTOS-based system, the basic approach is very similar but the programming
    model is extended to include multiple tasks running in *parallel*. Remember, each
    task is effectively an isolated infinite loop. Since each task has its own stack
    and can be in different operating states, some additional information is required
    to discern the overall system state:'
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the current operational state of each task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowing which task and function the PC was in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowing which interrupts are active
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at the value of key global variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observing/unwinding the stack of each task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to the constrained nature of embedded systems, stack usage is often a concern
    because of the limited RAM of MCUs. In a bare-metal application, there is only
    one stack. In an RTOS application, each task has its own stack, which means we
    have more to monitor. Using a debugging system that provides RTOS-aware stack
    information helps to quickly evaluate the stack usage of each task in the system.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring the worst-case performance of the event response is also a critical
    aspect of real-time systems development. We must ensure that the system will respond
    to critical events in a timely manner.
  prefs: []
  type: TYPE_NORMAL
- en: There are many different ways to approach this problem. Assuming the event originates
    with a hardware signal outside the MCU (which is true most of the time), a logic
    analyzer or oscilloscope can be used to monitor the signal. Code can be inserted
    in the application to toggle a pin on the MCU after that event has been serviced
    and the difference in time can be monitored. Depending on the system, access to
    test equipment, and the events in question, this hardware-centric method may be
    convenient.
  prefs: []
  type: TYPE_NORMAL
- en: Another method is to use software in combination with **instrumentation** in
    the RTOS. With this method, small hooks are added into the RTOS that notify the
    monitoring system when events happen. Those events are then transmitted out of
    the MCU and onto a development PC running a viewing program. This method is what
    we'll be focusing on in this book—using SEGGER SystemView. This allows a tremendous
    amount of information and statistics to be collected with very little development
    effort. The slight downside to this method is that there is a very small amount
    of uncertainty added since it is a purely software/firmware approach. It relies
    on the MCU to record when the events happen, which means if an interrupt is significantly
    delayed in being serviced, it will not be recorded accurately. There is also a
    strong dependency on the availability of RAM or CPU cycles. This approach can
    become inconclusive on heavily loaded systems without adequate RAM. However, these
    downsides have workarounds and aren't encountered on most systems.
  prefs: []
  type: TYPE_NORMAL
- en: RTOS visualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having the ability to see which tasks are running and how they are interacting
    is also important. In a preemptive scheduling environment, complex relationships
    can develop between tasks. For example, in order for an event to be serviced,
    there might be a few tasks that need to interact with one another. On top of that,
    there may be several more tasks all vying for processor time. In this scenario,
    a poorly designed system that is consistently missing deadlines may only be perceived
    as being *sluggish* from the user's perspective. With task visualization, a programmer
    can literally *see* the relationships between all tasks in the system, which helps
    considerably with analysis.
  prefs: []
  type: TYPE_NORMAL
- en: We will work through a real-world example of visualizing scenarios such as this
    one in [Chapter 8](c6d7a0c6-6f18-4e06-a372-cd1605942ecd.xhtml), *Protecting Data
    and Synchronizing Tasks*, with the `mainSemPriorityInversion.c` demo.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to easily discern what state tasks are in over a period of time
    is extremely helpful when unraveling complex inter-task relationships. SEGGER
    SystemView will also be used to visualize inter-task relationships.
  prefs: []
  type: TYPE_NORMAL
- en: In order to perform an in-depth analysis on a running system, we'll need a way
    to attach to the MCU and get information out of it. On Cortex-M MCUs, this is
    most efficiently done with an external debug probe.
  prefs: []
  type: TYPE_NORMAL
- en: Using SEGGER J-Link
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A debug probe is a device that allows a computer to communicate and program
    the non-volatile flash of an MCU. It communicates with special hardware on the
    MCU (called Coresight on ARM Cortex-M processors). The SEGGER J-Link and J-Trace
    family of debug probes are among the most popular in the industry. SEGGER also
    offers useful software that integrates with their tools free of charge. The accessibility
    of these tools and the quality of the accompanying software makes this an excellent
    fit for use in this book.
  prefs: []
  type: TYPE_NORMAL
- en: If you plan on using a paid IDE, the IDE vendor likely has their own proprietary
    debug probes available. Many excellent software features will likely be tied to
    their hardware. For example, ARM Keil uVision MDK integrates with ARM Ulink probes
    and IAR offers their I-Jet debug probes. IDEs such as these also integrate with
    third-party probes but be aware of what trade-offs there may be before making
    a purchasing decision.
  prefs: []
  type: TYPE_NORMAL
- en: There are many options when selecting debug probes from SEGGER —we'll briefly
    go through some of the options currently available and look at the hardware requirements
    for each.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SEGGER has many different hardware options that cover a wide range of pricing
    and capabilities. For a complete and current list, check out their website at [https://www.segger.com/products/debug-probes/j-link/models/model-overview/](https://www.segger.com/products/debug-probes/j-link/models/model-overview/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The models generally fit into two main categories: debuggers with full Cortex-M
    Trace support and those without.'
  prefs: []
  type: TYPE_NORMAL
- en: Segger J-Trace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The debuggers with full trace support are referred to as J-Trace. The **Cortex
    Embedded Trace Macrocell** (**Cortex ETM**) is an extra piece of hardware inside
    the MCU that allows every instruction that has been executed to be recorded. Transmitting
    all of this information off the MCU requires a few extra pins for clocking the
    data out (a clock line and 1-4 data lines). Having the ability to trace every
    instruction the MCU has executed enables functionality such as code coverage,
    which provides insight into how much code has been executed (line by line). Knowing
    exactly which lines of code have been executed and when gives us the opportunity
    to see where a program is spending most of its time. When we know which individual
    lines of code are executed most often, it is possible to optimize that small portion
    of code when improved performance is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to take full advantage of the advanced trace features, all of the
    following is required:'
  prefs: []
  type: TYPE_NORMAL
- en: The MCU must have ETM hardware.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The specific MCU package must bring the ETM signals out to pins.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The peripheral configuration must not share ETM signals with other functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system circuit must be designed to incorporate ETM signals and a connector.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The most common connector used for Debug and ETM signals is a 0.05" pitch header
    with the following pinout (the trace signals are highlighted):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/606fde5a-281e-425d-98da-39ae354e764b.png)'
  prefs: []
  type: TYPE_IMG
- en: All of this functionality comes at a price, of course. The J-Trace models are
    at the high end of SEGGER's spectrum, both in terms of functionality and price
    (typically over USD$1000). Unless you're developing fully custom hardware, also
    expect to pay for a full evaluation board (over USD$200) rather than the low-cost
    development hardware used in this book. While these costs are typically completely
    reasonable for a full-blown engineering budget during new product development,
    they are too expensive to be widely accessible for individuals.
  prefs: []
  type: TYPE_NORMAL
- en: SEGGER J-Link
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SEGGER J-Link has been around in many different forms and has grown to encompass
    several models. Typically, the higher-end models provide faster clock speeds and
    a richer experience (faster downloads, responsive debugging, and so on). A few
    **EDU** models are sold at an extremely large discount for educational purposes
    (thus the **EDU** designation). These models are fully featured but may not be
    used for commercial purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The most common connector used for the Cortex-M is a 0.05" pitch header with
    the following pinout. Notice, this connector's pinout is the same as the first
    10 pins from the Debug+Trace connector (refer to the following diagram).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01e54c91-a4cc-400f-9059-3deda9ecb214.png)'
  prefs: []
  type: TYPE_IMG
- en: SEGGER has done an excellent job designing software interfaces that aren't tied
    to the underlying hardware. Because of this, their software tools work across
    different hardware debugger models without modification. This has also resulted
    in the hardware option we'll be using in this book—the SEGGER J-Link on-board.
  prefs: []
  type: TYPE_NORMAL
- en: SEGGER J-Link on-board
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The specific hardware variant of ST-Link we''ll be using in our exercises isn''t
    actually made by SEGGER. It is the ST-Link circuitry already included on the Nucleo
    development board. Nucleo boards have two separate sub-circuits: programming hardware
    and target hardware.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The programming hardware sub-circuit is generally referred to as an ST-Link.
    This **programming hardware** is actually another STM MCU that is responsible
    for communicating with the PC and programming the **target hardware**—the STM32F767\.
    Since Nucleo hardware is primarily aimed at the ARM Mbed ecosystem, the ST-Link
    MCU is programmed with firmware that implements both the ST-Link and Mbed functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7807694-5d5b-492d-9d3b-4070bf3f9174.png)'
  prefs: []
  type: TYPE_IMG
- en: In order to use the programming hardware on the Nucleo board as a SEGGER JLink,
    we will be replacing its firmware with SEGGER J-Link on-board firmware.
  prefs: []
  type: TYPE_NORMAL
- en: Installing J-Link
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Detailed installation instructions are available from SEGGER at [https://www.segger.com/products/debug-probes/j-link/models/other-j-links/st-link-on-board/](https://www.segger.com/products/debug-probes/j-link/models/other-j-links/st-link-on-board/).
    A few notes are also included here for convenience. In order to convert the on-board
    ST-Link to a J-Link, we''ll be downloading and installing two pieces of software:
    the J-Link tools and the ST-Link re-flashing utility. You should already have
    the necessary ST-Link drivers installed from the STM32CubeIDE installation carried
    out in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A Windows PC is only required for the J-Link Reflash utility (it is distributed
    as `*.exe`). If you're not using a Windows PC for development and STM32CubeIDE
    isn't installed, make sure you install USB drivers for the ST-Link (the optional
    *step 1* in the following list).
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have STM32CubeIDE installed already, download and install the ST-Link
    drivers from [http://www.st.com/en/development-tools/stsw-link009.html](http://www.st.com/en/development-tools/stsw-link009.html) (this
    step is optional).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the appropriate J-Link utilities for your OS from [https://www.segger.com/downloads/jlink](https://www.segger.com/downloads/jlink).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the J-Link utilities— the default options are fine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the SEGGER J-Link Reflash utility (for Windows OS only) from [https://www.segger.com/downloads/jlink#STLink_Reflash](https://www.segger.com/downloads/jlink#STLink_Reflash).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Unzip the contents of `STLinkReflash_<version>.zip`— it will contain two files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`JLinkARM.dll`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STLinkReflash.exe`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we will convert ST-Link to J-Link.
  prefs: []
  type: TYPE_NORMAL
- en: Converting ST-Link to J-Link
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to upload J-Link firmware to the ST-Link on the Nucleo development
    board:'
  prefs: []
  type: TYPE_NORMAL
- en: Plug in a micro USB cable to `CN1` on the Nucleo board and attach it to your
    Windows PC.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `STLinkReflash_<version>.exe`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read through and accept the two license agreements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the first option: Upgrade to J-Link.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The debugging hardware on the Nucleo board is now effectively a SEGGER J-Link!
  prefs: []
  type: TYPE_NORMAL
- en: Now that a J-Link is present, we will be able to use other SEGGER software tools,
    such as Ozone and SystemView, to debug and visualize our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Using SEGGER Ozone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SEGGER Ozone is a piece of software that is meant to debug an already-written
    application. Ozone is independent of the underlying programming environment used
    to create the application. It can be used in many different modes, but we'll focus
    on importing an `*.elf` file and crossreferencing it with source code to provide
    FreeRTOS-aware debugging capability to a project created with any toolchain. Let's
    take a quick look at the various file types we will be working with in Ozone.
  prefs: []
  type: TYPE_NORMAL
- en: File types used in the examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several file types used when programming and debugging embedded systems.
    These files are common across many different processors and software products
    and not exclusive to Cortex-M MCUs or the software used in this book.
  prefs: []
  type: TYPE_NORMAL
- en: '**Executable and Linkable Format** (**ELF**) files are an executable format
    that has the ability to store more than the straight `*.bin` or `*.hex` files
    commonly flashed directly into an MCU''s ROM. The `*.elf` files are similar to
    the `*.hex` files in that they contain all of the binary machine code necessary
    to load a fully functional project onto a target MCU. The `*.elf` files also contain
    links to the original source code filenames and line numbers. Software such as
    Ozone uses these links to display source code while debugging the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*.bin`: A straight binary file (just 1s and 0s). This file format can be directly
    "burned" into an MCU''s internal flash memory, starting at a given address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*.hex`:Usually a variant of Motorolla S-record format. This ASCII-based file
    format contains both absolute memory addresses and their contents.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*.elf`: Contains both the executable code as well as a header that is used
    to cross-reference each memory segment to a source file. This means a single ELF
    file contains enough information to program the target MCU and also cross-reference
    all of the source code used to create the binary memory segments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ELF file does not *contain* the actual source code used, it only contains
    absolute file paths that crossreference memory segments to the original source
    code. This is what allows us to open a `*.elf` file in Ozone and step through
    the C source code while debugging.
  prefs: []
  type: TYPE_NORMAL
- en: '`*.svd`: Contains information that maps registers and descriptions to the memory
    map of the target device. By providing an accurate `*.svd` file, Ozone will be
    able to display peripheral views that are very helpful when troubleshooting MCU
    peripheral code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `*.svd` file is a file that is usually included with an IDE that supports
    your MCU. For example, STM32Cube IDE's location for the `*.svd` files is
  prefs: []
  type: TYPE_NORMAL
- en: '*`C:\ST\STM32CubeIDE_1.2.0\STM32CubeIDE\plugins\com.st.stm32cube.ide.mcu.productdb.debug_1.2.0.201912201802\resources\cmsis\STMicroelectronics_CMSIS_SVD`.*'
  prefs: []
  type: TYPE_NORMAL
- en: There are other file types used in embedded systems' development as well. This
    is by no means an exhaustive list—just the ones we'll be using most in the context
    of the example projects.
  prefs: []
  type: TYPE_NORMAL
- en: Installing SEGGER Ozone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To install SEGGER Ozone, follow these two simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download SEGGER Ozone: [https://www.segger.com/downloads/jlink/](https://www.segger.com/downloads/jlink/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install it using the default options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's cover the necessary steps to create a FreeRTOS-aware Ozone project
    and take a quick look at some of the interesting features.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Ozone projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since Ozone is completely independent of the programming environment, in order
    to debug with it, some configuration is required, which is covered in the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: All projects included in the source tree for this book already have Ozone projects
    created for them. The following steps are for your reference—you'll only need
    to go through these steps for your own future projects. Ozone project files, the `*.jdebug`
    files, are already included for all of the projects in this book.
  prefs: []
  type: TYPE_NORMAL
- en: When first opened, select the Create a New Project prompt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the Device field, select STM32F767ZI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For Peripherals, input the directory and location of the `STM32F7x7.svd` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fd3c1524-135b-4700-b079-ff896763055e.png)'
  prefs: []
  type: TYPE_IMG
- en: On the Connection Settings dialog screen, default values are acceptable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the Program File dialog screen, navigate to the `*.elf` file that is generated
    by TrueStudio. It should be in the Debug folder of your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cfbb146e-e29c-481c-b0d1-f2a8e1ed6ee6.png)'
  prefs: []
  type: TYPE_IMG
- en: Save the `*.jdebug` project file and close Ozone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `*.jdebug` file with a text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a line to the `*.jdebug` project file to enable the FreeRTOS plugin (only
    add the last line in bold):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It is a good idea to copy the `*.svd` file to a location used for storing source
    code or build tools since the installation directory for the IDEs is likely to
    change over time and between machines.
  prefs: []
  type: TYPE_NORMAL
- en: These steps can be adapted to set up Ozone for any other MCU supported by SEGGER
    family debuggers.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching Ozone to the MCU
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Time to roll up our sleeves and get our hands dirty! The next sections will
    make more sense if you''ve got some hardware up and running, so you can follow
    along and do some exploring. Let''s get everything set up:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the STM32Cube IDE and open the `Chapter5_6` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on `Chapter5_6` and select Build. This will compile the project
    into an `*.elf` file (that is, `C:\projects\packtBookRTOS\Chapters5_6\Debug\Chapter5_6.elf`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open Ozone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Open Existing Project from the wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `C:\projects\packtBookRTOS\Chapters5_6\Chapters5_6.jdebug`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use Ozone to download the code to the MCU (click the power button):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2a4459a6-9c8c-4e75-b87f-b2a1f15e4bb7.png)'
  prefs: []
  type: TYPE_IMG
- en: Push the play button to start the application (you should see the red, blue,
    and green LEDs flashing).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If your paths are different from what was used when creating the `*.jdebug`
    files, you'll need to reopen the `.elf` file (go to File | Open and select the
    file built in *step 2*).
  prefs: []
  type: TYPE_NORMAL
- en: Those same six steps can be repeated for any of the projects included in this
    book. You can also create a copy of the `.jdebug` file for other projects by simply
    opening a different `*.elf` file.
  prefs: []
  type: TYPE_NORMAL
- en: You may want to bookmark this page. You'll be following these same steps for
    the 50+ example programs throughout the rest of the book!
  prefs: []
  type: TYPE_NORMAL
- en: Viewing tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A quick view overview of tasks can be seen by enabling the FreeRTOS task view.
    Using these tasks can prove to be very beneficial while developing RTOS applications:'
  prefs: []
  type: TYPE_NORMAL
- en: After the MCU program has been started, pause execution by clicking the *Pause*
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, navigate to View | FreeRTOS Task View:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0a46ef4b-1ae5-47aa-9ddf-7a2fe247262e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This view shows many useful pieces of information at a glance:'
  prefs: []
  type: TYPE_NORMAL
- en: Task names and priorities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Timeout: How many *ticks* a blocked task has until it is forced out of the
    blocked state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each task's stack usage (only the current stack usage is shown by default).
    Maximum stack usage is disabled in the preceding screenshot (seen by N/A)—(details
    on configuring FreeRTOS to monitor maximum stack usage will be covered in [Chapter
    17](50d2b6c3-9a4e-45c3-9bfc-1c7f58de0b98.xhtml), *Troubleshooting Tips and Next
    Steps*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mutex Count: How many mutexes a task currently holds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Notifications: Details on each task''s notifications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having a bird's eye view of all of the tasks in the system can be a huge help
    when developing an RTOS-based application—especially during the initial phases
    of development.
  prefs: []
  type: TYPE_NORMAL
- en: Task-based stack analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the challenges with debugging an RTOS with non-RTOS aware tools is analyzing
    the call stack of each task. When the system halts, each task has its own call
    stack. It is quite common to need to analyze the call stack for multiple tasks
    at a given point in time. Ozone provides this capability by using FreeRTOS Task
    View in conjunction with Call Stack View.
  prefs: []
  type: TYPE_NORMAL
- en: After opening both views, each task in FreeRTOS Task View can be double-clicked
    to reveal the current call stack of that task in Call Stack View. To reveal local
    variables for each task on a function-by-function basis, open Local Data view.
    In this view, local variables for the current function highlighted in the call
    stack will be visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example combining the task-based call stack analysis with a local variable
    view is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/93051213-82ab-47a3-9536-18189311a414.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice the following from this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: When the MCU was stopped, it was in the "IDLE" task (shown by executing in the
    Status column).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-clicking on "task 3" shows the call stack for "task 3". Currently, `vTaskDelay`
    is at the top of the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-clicking on `StartTask3` updates the Local Data window to show values
    for all local variables in `StartTask3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Local Variables for `StartTask3` shows the current values for all local variables
    in `StartTask3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SEGGER Ozone provides both a task-aware call stack view and a heads-up view
    for all running tasks in the system. This combination gives us a powerful tool
    to dive into the most minute details of each task running on the system. But what
    happens when we need a bigger picture view of the system? Instead of looking at
    each task individually, what if we'd prefer to look at the interaction *between*
    tasks in the system? This is an area where SEGGER SystemView can help.
  prefs: []
  type: TYPE_NORMAL
- en: Using SEGGER SystemView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SEGGER SystemView is another software tool that can be used with SEGGER debug
    probes. It provides a means to visualize the flow of tasks and interrupts in a
    system. SystemView works by adding a small amount of code into the project. FreeRTOS
    already has `Trace Hook Macros`, which was specifically designed for adding in
    this type of third-party functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Ozone, SystemView doesn't have any programming or debugging capabilities,
    it is only a **viewer***.*
  prefs: []
  type: TYPE_NORMAL
- en: Installing SystemView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two main steps required for making your system visible with SystemView.
    The software needs to be installed and source code must be instrumented so it
    will communicate its status over the debug interface.
  prefs: []
  type: TYPE_NORMAL
- en: SystemView installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To install SystemView, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download SystemView for your OS. This is the main binary installer ([https://www.segger.com/downloads/free-utilities](https://www.segger.com/downloads/free-utilities)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install using the default options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Source code configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order for SystemView to show a visualization of tasks running on a system,
    it must be provided with information such as task names, priorities, and the current
    state of tasks. There are hooks present in FreeRTOS for nearly everything SystemView
    needs. A few configuration files are used to set up a mapping between the trace
    hooks already present in FreeRTOS and used by SystemView. Information needs to
    be collected, which is where the specific RTOS configuration and SystemView target
    sources come into play:'
  prefs: []
  type: TYPE_NORMAL
- en: The source code included with this book already has all of these modifications
    performed, so these steps are *only necessary* if you'd like to add SystemView
    functionality to *your own FreeRTOS-based projects.*
  prefs: []
  type: TYPE_NORMAL
- en: Download SystemView FreeRTOS V10 Configuration (v 2.52d was used) from [https://www.segger.com/downloads/free-utilities ](https://www.segger.com/downloads/free-utilities)and
    apply `FreeRTOSV10_Core.patch` to the FreeRTOS source tree using your preferred
    diff tool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Download and incorporate SystemView Target Sources (v 2.52h was used) from
    [https://www.segger.com/downloads/free-utilities](https://www.segger.com/downloads/free-utilities):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy all the source files into the `.\SEGGER` folder in your source tree and
    include them for compilation and linking. In our source tree, the `SEGGER` folder
    is located in `.\Middlewares\Third_Party\SEGGER`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy `SystemView Target Sources\Sample\FreeRTOSV10\SEGGER_SYSVIEW_FreeRTOS.c/h` into
    the `SEGGER` folder and include it for compilation and linking.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy `.\Sample\FreeRTOSV10\Config\SEGGER_SYSVIEW_Config_FreeRTOS.c` into the`SEGGER` folder and
    include it for compilation and linking.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make the following changes to `FreeRTOSConfig.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the end of the file, add an include for `SEGGER_SYSVIEW_FreeRTOS.h`: `#include
    "SEGGER_SYSVIEW_FREERTOS.h"`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `#define INCLUDE_xTaskGetIdleTaskHandle 1`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `#define ``INCLUDE_pxTaskGetStackStart 1`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.c` make the following changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include `#include <SEGGER_SYSVIEW.h>`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a call to `SEGGER_SYSVIEW_Conf()` after initialization and before the scheduler
    is started.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Since SystemView is called inside the context of each task, you'll likely find
    that the minimum task stack size will need to be increased to avoid stack overflows.
    This is because the SystemView library requires a small amount of code that runs
    on the target MCU (which increases the call depth and the number of functions
    that are placed on the stack). For all the gory details on how to troubleshoot
    stack overflows (and how to avoid them), see [Chapter 17](50d2b6c3-9a4e-45c3-9bfc-1c7f58de0b98.xhtml),
    *Troubleshooting Tips and Next Steps.*
  prefs: []
  type: TYPE_NORMAL
- en: Using SystemView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After the source-code side of SystemView is straightened out, using the application
    is very straightforward. To start a capture, make sure you have a running target
    and your debugger and MCU are connected to the computer:'
  prefs: []
  type: TYPE_NORMAL
- en: Push the *Play* button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the appropriate target device settings (shown here):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4fc401c7-2698-4f87-99c8-24e6419c5516.png)'
  prefs: []
  type: TYPE_IMG
- en: SystemView requires a *running* target. It will not show any information for
    a halted MCU (there are no events to display since it is not running). Make sure
    the LEDs on the board are blinking; follow the steps from the *Attaching Ozone
    to the MCU* section if they're not.
  prefs: []
  type: TYPE_NORMAL
- en: 'After a second or so, events will be streaming into the log in the top-left
    Events view and you will see a live graphical view of the tasks as they''re currently
    executing in Timeline:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/713ce462-f002-4fb6-a19f-448c610f01f1.png)'
  prefs: []
  type: TYPE_IMG
- en: Timeline shows a visual representation of task execution, including different
    states.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Events view shows a list of events. Selected events are linked to the timeline.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Context viewshows statistics for all events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminal can be used to show printf-like messages from your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many more useful features, which will be covered while exploring code.
  prefs: []
  type: TYPE_NORMAL
- en: We're finally done installing the development software! If you've followed along
    so far, you now have a fully operational IDE, an RTOS visualization solution,
    and an extremely powerful RTOS-aware debugging system at your disposal. Let's
    see what other tools can be useful during the course of embedded systems development.
  prefs: []
  type: TYPE_NORMAL
- en: Other great tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tools covered in this chapter certainly aren't the only ones available for
    debugging and troubleshooting embedded systems. There are many other tools and
    techniques that we simply don't have scope to cover (or that weren't a good fit
    due to the specific constraints placed on the tools used in this book). These
    topics are mentioned in the following section, with additional links in the *Further
    reading *section at the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Test-driven development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given the fact that the title of this chapter starts with the word *debugging,*
    it only seems appropriate to mention the ideal way to *debug* code is to not write
    buggy code in the first place. Unit testing isn't a single piece of software,
    but a component of **Test-Driven Development** (**TDD**)—a development methodology
    that inverts the way embedded engineers traditionally go about developing their
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of writing a bunch of code that doesn't work and then debugging it,
    test-driven development starts out by writing tests. After tests are written,
    production code is written until the tests pass. This approach tends to lead to
    code that is both testable and easily refactored. Since individual functions are
    tested using this approach, the resulting production code is much less tied to
    the underlying hardware (since it isn't easy to test code tied to real hardware).
    Forcing tests to be written at this level tends to lead to loosely coupled architecture,
    which is discussed in [Chapter 13](e728e173-c9b2-4bb8-91c8-ed348ccf9518.xhtml),
    *Creating Loose Coupling with Queues*. Using the techniques in [Chapter 13](e728e173-c9b2-4bb8-91c8-ed348ccf9518.xhtml),
    *Creating Loose Coupling with Queues, *works very well in conjunction with unit
    testing and TDD.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, TDD isn't as popular in embedded systems. But if it is something
    you're interested in learning more about, check out a book written specifically
    on the topic—*Test Driven Development for Embedded C* by J*ames Grenning*.
  prefs: []
  type: TYPE_NORMAL
- en: Static analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static analysis is another way of reducing the number of bugs that creep into
    a code base. *Static* refers to the fact that the code doesn't need to be executing
    for this analysis to take place. A static analyzer looks for common programming
    errors that are syntactically correct (for example, they compile) but are *likely*
    to create buggy code (that is, out-of-bounds array access, and so on) and provides
    relevant warnings.
  prefs: []
  type: TYPE_NORMAL
- en: There are many commercially available packages for static analysis, as well
    as some that are freely available. Cppcheck is included in STM32CubeIDE (simply
    right-click on a project and select Run C/C++ Code Analysis). A link to a **Free
    Open Source Software** (**FOSS**) static analyzer from the Clang project is included
    at the end of this chapter. PVS-Studio Analyzer is an example of a commercial
    package that can be used freely for non-commercial projects.
  prefs: []
  type: TYPE_NORMAL
- en: Percepio Tracealyzer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Percepio Tracealyzer is a tool similar to SEGGER SystemView in that it helps
    the developer to visualize system execution. Tracealyzer takes less effort to
    set up out of the box than SystemView and provides a more aesthetically focused
    user experience than SystemView. However, since it is supplied by a different
    company, the cost of the software is not included with the purchase of a SEGGER
    debug probe. You can find out more about Tracealyzer at [https://percepio.com/tracealyzer/](https://percepio.com/tracealyzer/).
  prefs: []
  type: TYPE_NORMAL
- en: Traditional testing equipment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before all of the attractive pieces of software for visualizing RTOS behavior
    on a computer screen existed, this task would fall to more traditional test equipment.
  prefs: []
  type: TYPE_NORMAL
- en: Logic analyzers have been around since MCUs first came into existence and are
    still among the most versatile tools an embedded system engineer can have in their
    kit. With a logic analyzer, the timing can be directly measured between when an
    input enters the system and when an output is provided by the system, as well
    as the timing between each of the tasks. Looking at the raw low-level signals
    going in and out of an MCU provides a level of visibility and gut feel for when
    something isn't right in a way that hexadecimal digits on a screen simply can't.
    Another advantage of habitually instrumenting at the hardware level - glitches
    in timing and other erratic behaviors are often noticed without directly looking
    for them.
  prefs: []
  type: TYPE_NORMAL
- en: Other tools you'll want to acquire if you're just starting out with embedded
    systems include a handheld **digital multi-meter** (**DMM**) and oscilloscope
    for measuring analog signals.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've covered why having access to excellent debugging tools
    is important. The exact tools we'll be using to analyze system behavior (SEGGER
    Ozone and SystemView) have been introduced. You've also been guided through how
    to get these tools set up for use with future projects. Toward the end, we touched
    on a few other tools that won't be covered in this book just to raise awareness
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've covered MCU and IDE selection, and we have all of our tooling
    squared away, we have enough background to get into the real meat of RTOS application
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Using this toolset will help you gain an in-depth understanding of RTOS behavior
    and programming as we dive into working examples in the upcoming chapters. You'll
    also be able to use this same tooling to create high-performing, custom real-time
    applications in the future.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll get started with writing some code and go into more
    detail regarding the FreeRTOS scheduler.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: J-Link hardware must be purchased to use the tools in this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The only way to evaluate the effectiveness of a real-time system is to wait
    and see whether something breaks because a deadline was missed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Since RTOSes have one stack per task, they are impossible to debug using a debugger
    since only the main system stack is visible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The only way to ensure a system is completely functional is to write all of
    the code and then debug it all at once at the end of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the style of testing called where each individual module is tested?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: System testing
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Black box testing
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the term given for writing tests before developing production code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Test-Driven Development for Embedded C* by *James Grenning*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SEGGER Ozone manual (UM08025): [https://www.segger.com/downloads/jlink/UM08025](https://www.segger.com/downloads/jlink/UM08025)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SEGGER SystemView manual (UM08027): [https://www.segger.com/downloads/jlink/UM08027](https://www.segger.com/downloads/jlink/UM08027)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clang Static Analyzer: [https://clang-analyzer.llvm.org](https://clang-analyzer.llvm.org)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PVS-Studio Analyzer: [https://www.viva64.com/en/pvs-studio/](https://www.viva64.com/en/pvs-studio/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
