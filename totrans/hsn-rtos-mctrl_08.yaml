- en: Debugging Tools for Real-Time Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时系统的调试工具
- en: Serious debugging tools are incredibly important in serious embedded systems
    development. Complex RTOS-based systems can have many tasks and dozens of ISRs
    that need to be completed in a timely manner. Figuring out whether everything
    is working properly (or *why* it isn't) is way easier with the right tools. If
    you've been troubleshooting with the occasional print statement or blinking LEDs,
    you're in for a treat!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在严肃的嵌入式系统开发中，严肃的调试工具至关重要。基于复杂RTOS的系统可能有许多任务和数十个需要及时完成的ISR。有了合适的工具，判断一切是否正常工作（或*为什么*不正常）会容易得多。如果您一直使用偶尔的打印语句或闪烁的LED进行故障排除，那么您将有一个惊喜！
- en: We'll be making heavy use of Ozone and SystemView throughout the remainder of
    this book but first, we'll need to get them set up and look at a quick introduction.
    Toward the end of this chapter, we'll take a look at other debugging tools, as
    well as techniques for reducing the number of bugs that get written in the first
    place.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的剩余部分大量使用Ozone和SystemView，但首先，我们需要设置它们并查看快速介绍。在本章的末尾，我们将探讨其他调试工具，以及减少最初编写时产生的错误数量的技术。
- en: 'In a nutshell, we will be covering the following in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，在本章中我们将涵盖以下内容：
- en: The importance of excellent debugging tools
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优秀调试工具的重要性
- en: Using SEGGER J-Link
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SEGGER J-Link
- en: Using SEGGER Ozone
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SEGGER Ozone
- en: Using SEGGER SystemView
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SEGGER SystemView
- en: Other great tools
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他优秀工具
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Several pieces of software will be installed and configured in this chapter.
    Here''s what you should already have on hand:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将安装和配置几款软件。以下是您应该已经准备好的物品：
- en: A Nucleo F767 development board
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块Nucleo F767开发板
- en: A micro-USB cable
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条micro-USB线
- en: A Windows PC (the Windows OS is only required by the ST-Link Reflash utility)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台Windows PC（ST-Link Reflash实用程序只需要Windows操作系统）
- en: STM32CubeIDE (ST-Link drivers are required for the ST-Link Reflash utility)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STM32CubeIDE（ST-Link Reflash实用程序需要ST-Link驱动程序）
- en: All source code for this chapter can be downloaded from [https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapters5_6](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapters5_6).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有源代码都可以从[https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapters5_6](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapters5_6)下载。
- en: The importance of excellent debugging tools
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优秀调试工具的重要性
- en: When developing any piece of software, it's all too easy to start writing code
    without thinking about all of the details. Thanks to code generation tools and
    third-party libraries, we can very quickly develop a feature-filled application
    and have it running on actual hardware in fairly short order. However, when it
    comes to getting *every* part of a system working 100% of the time, things are
    a bit more difficult. If a system is stood up too quickly and the components weren't
    properly tested before integrating them, there would be pieces that work *most*
    of the time, but not always.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发任何软件时，很容易在不考虑所有细节的情况下开始编写代码。多亏了代码生成工具和第三方库，我们能够非常快速地开发一个功能丰富的应用程序，并在相当短的时间内将其运行在实际硬件上。然而，当涉及到确保系统的每个部分100%正常工作时，事情就变得有点困难了。如果一个系统建立得太快，并且组件在集成之前没有得到适当的测试，那么可能会有一些部分大多数时候都能正常工作，但并不总是如此。
- en: Often with embedded systems, only a few parts of the underlying application
    are visible. It can be challenging to evaluate the overall system health from
    a user's viewpoint. Historically, good debug tooling was less common for embedded
    work than non-embedded. Putting print statements everywhere only gets you so far,
    causes timing problems, and so on. Blinking LEDs is cumbersome and doesn't provide
    much insight. Analyzing signals via hardware can help to verify symptoms but doesn't
    always isolate the root cause of an issue. Trying to figure out what code is actually
    running (and when) in an event-driven system is really challenging without the
    tools to help visualize execution.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式系统中，通常只有底层应用程序的少数部分是可见的。从用户的角度来看，评估整个系统的健康状况可能具有挑战性。历史上，对于嵌入式工作来说，良好的调试工具比非嵌入式工作要少。到处放置打印语句只能走那么远，会导致时序问题，等等。闪烁的LED既麻烦又提供不了太多见解。通过硬件分析信号可以帮助验证症状，但并不总是隔离问题的根本原因。在没有帮助可视化执行的工具的情况下，试图弄清楚在事件驱动系统中实际运行的代码（以及何时运行）是非常具有挑战性的。
- en: This is why having a variety of familiar tools at your disposal is extremely
    helpful. It allows you to focus your efforts on developing small portions of the
    application confidently. Confidence comes from rigorously verifying each piece
    of functionality as it is developed and integrated with the rest of the system.
    However, in order to perform verification, we need to have transparency in different
    portions of the code (not just the parts that are observable from outside the
    system). Many times during verification, situations arise when there is a need
    to observe inter-task execution.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么拥有各种熟悉的工具在您手中极为有用。它允许您自信地专注于开发应用程序的小部分。自信来自于严格验证每个功能，在开发过程中以及与系统其他部分的集成过程中。然而，为了执行验证，我们需要在代码的不同部分保持透明度（而不仅仅是系统外部可观察的部分）。在验证过程中，很多时候会出现需要观察任务间执行的情况。
- en: 'There are two important areas that help us achieve the objectives of system
    transparency and observable task relationships: RTOS-aware debugging and RTOS
    visualization.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个重要的领域有助于我们实现系统透明度和可观察的任务关系目标：基于实时操作系统的调试和实时操作系统可视化。
- en: RTOS-aware debugging
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于实时操作系统的调试
- en: 'With traditional debugging setups used for bare-metal (for example, no OS)
    coding, there was only one stack to observe. Since the programming model was a
    single super loop with some interrupts, this wasn''t much of a problem. At any
    point in time, the state of the system could be discerned by the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在用于裸机（例如，没有操作系统）编码的传统调试设置中，只有一个堆栈可以观察。由于编程模型是一个单超级循环和一些中断，这并不是一个大问题。在任何时候，系统的状态可以通过以下方式识别：
- en: Knowing which function the **program counter** (**PC**) was in
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道程序计数器（**PC**）所在的函数
- en: Knowing which interrupts were active
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道哪些中断是激活的
- en: Looking at the value of key global variables
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看关键全局变量的值
- en: Observing/unwinding the stack
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察和展开堆栈
- en: 'With an RTOS-based system, the basic approach is very similar but the programming
    model is extended to include multiple tasks running in *parallel*. Remember, each
    task is effectively an isolated infinite loop. Since each task has its own stack
    and can be in different operating states, some additional information is required
    to discern the overall system state:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于实时操作系统的系统中，基本方法非常相似，但编程模型扩展到包括多个并行运行的*任务*。记住，每个任务实际上是一个隔离的无穷循环。由于每个任务都有自己的堆栈并且可能处于不同的操作状态，因此需要一些额外的信息来识别整体系统状态：
- en: Knowing the current operational state of each task
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解每个任务当前的运行状态
- en: Knowing which task and function the PC was in
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道PC所在的任务和函数
- en: Knowing which interrupts are active
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解哪些中断是激活的
- en: Looking at the value of key global variables
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看关键全局变量的值
- en: Observing/unwinding the stack of each task
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察和展开每个任务的堆栈
- en: Due to the constrained nature of embedded systems, stack usage is often a concern
    because of the limited RAM of MCUs. In a bare-metal application, there is only
    one stack. In an RTOS application, each task has its own stack, which means we
    have more to monitor. Using a debugging system that provides RTOS-aware stack
    information helps to quickly evaluate the stack usage of each task in the system.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于嵌入式系统的限制性，堆栈使用通常是一个关注点，因为MCU的RAM有限。在裸机应用程序中，只有一个堆栈。在实时操作系统应用程序中，每个任务都有自己的堆栈，这意味着我们有更多要监控的内容。使用提供实时操作系统堆栈信息的调试系统有助于快速评估系统中每个任务的堆栈使用情况。
- en: Monitoring the worst-case performance of the event response is also a critical
    aspect of real-time systems development. We must ensure that the system will respond
    to critical events in a timely manner.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 监控事件响应的最坏情况性能也是实时系统开发的一个关键方面。我们必须确保系统将及时响应关键事件。
- en: There are many different ways to approach this problem. Assuming the event originates
    with a hardware signal outside the MCU (which is true most of the time), a logic
    analyzer or oscilloscope can be used to monitor the signal. Code can be inserted
    in the application to toggle a pin on the MCU after that event has been serviced
    and the difference in time can be monitored. Depending on the system, access to
    test equipment, and the events in question, this hardware-centric method may be
    convenient.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的方法来解决这个问题。假设事件起源于MCU外部的硬件信号（这在大多数情况下是正确的），可以使用逻辑分析仪或示波器来监控该信号。可以在应用程序中插入代码在事件被处理后切换MCU上的引脚，并监控时间差。根据系统、测试设备的访问权限以及相关事件，这种方法可能很方便。
- en: Another method is to use software in combination with **instrumentation** in
    the RTOS. With this method, small hooks are added into the RTOS that notify the
    monitoring system when events happen. Those events are then transmitted out of
    the MCU and onto a development PC running a viewing program. This method is what
    we'll be focusing on in this book—using SEGGER SystemView. This allows a tremendous
    amount of information and statistics to be collected with very little development
    effort. The slight downside to this method is that there is a very small amount
    of uncertainty added since it is a purely software/firmware approach. It relies
    on the MCU to record when the events happen, which means if an interrupt is significantly
    delayed in being serviced, it will not be recorded accurately. There is also a
    strong dependency on the availability of RAM or CPU cycles. This approach can
    become inconclusive on heavily loaded systems without adequate RAM. However, these
    downsides have workarounds and aren't encountered on most systems.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是结合 RTOS 中的 **仪器** 使用软件。使用这种方法时，会在 RTOS 中添加一些小的钩子，当事件发生时通知监控系统。然后，这些事件会被传输出
    MCU 并发送到运行查看程序的开发 PC 上。这本书将重点关注这种方法——使用 SEGGER SystemView。这允许以非常少的开发工作收集大量的信息和统计数据。这种方法的一个小缺点是，由于它是一种纯软件/固件方法，因此增加了一点点不确定性。它依赖于
    MCU 记录事件发生的时间，这意味着如果中断服务被显著延迟，则可能无法准确记录。此外，它还强烈依赖于 RAM 或 CPU 周期的可用性。在没有足够 RAM
    的高负载系统中，这种方法可能会得出不可靠的结论。然而，这些缺点都有解决方案，并且在大多数系统中不会遇到。
- en: RTOS visualization
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RTOS 可视化
- en: Having the ability to see which tasks are running and how they are interacting
    is also important. In a preemptive scheduling environment, complex relationships
    can develop between tasks. For example, in order for an event to be serviced,
    there might be a few tasks that need to interact with one another. On top of that,
    there may be several more tasks all vying for processor time. In this scenario,
    a poorly designed system that is consistently missing deadlines may only be perceived
    as being *sluggish* from the user's perspective. With task visualization, a programmer
    can literally *see* the relationships between all tasks in the system, which helps
    considerably with analysis.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 能够看到哪些任务正在运行以及它们是如何交互的也很重要。在抢占式调度环境中，任务之间可能会形成复杂的关系。例如，为了处理一个事件，可能需要几个任务相互交互。除此之外，可能还有更多任务都在争夺处理器时间。在这种情况下，一个设计不佳且持续错过截止日期的系统可能只会从用户的角度被视为
    *缓慢*。通过任务可视化，程序员可以真正地 *看到* 系统中所有任务之间的关系，这有助于分析。
- en: We will work through a real-world example of visualizing scenarios such as this
    one in [Chapter 8](c6d7a0c6-6f18-4e06-a372-cd1605942ecd.xhtml), *Protecting Data
    and Synchronizing Tasks*, with the `mainSemPriorityInversion.c` demo.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 8 章 [保护数据和同步任务](c6d7a0c6-6f18-4e06-a372-cd1605942ecd.xhtml)中通过 `mainSemPriorityInversion.c`
    演示，通过一个真实世界的例子来可视化此类场景。
- en: The ability to easily discern what state tasks are in over a period of time
    is extremely helpful when unraveling complex inter-task relationships. SEGGER
    SystemView will also be used to visualize inter-task relationships.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在解开复杂的任务间关系时，能够轻松地辨别任务在一段时间内的状态非常有帮助。SEGGER SystemView 也将用于可视化任务间关系。
- en: In order to perform an in-depth analysis on a running system, we'll need a way
    to attach to the MCU and get information out of it. On Cortex-M MCUs, this is
    most efficiently done with an external debug probe.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对运行中的系统进行深入分析，我们需要一种方法来连接 MCU 并从中获取信息。在 Cortex-M MCU 上，这最有效地通过外部调试探针来完成。
- en: Using SEGGER J-Link
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SEGGER J-Link
- en: A debug probe is a device that allows a computer to communicate and program
    the non-volatile flash of an MCU. It communicates with special hardware on the
    MCU (called Coresight on ARM Cortex-M processors). The SEGGER J-Link and J-Trace
    family of debug probes are among the most popular in the industry. SEGGER also
    offers useful software that integrates with their tools free of charge. The accessibility
    of these tools and the quality of the accompanying software makes this an excellent
    fit for use in this book.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 调试探针是一种允许计算机与 MCU 的非易失性闪存进行通信和编程的设备。它与 MCU 上的特殊硬件（在 ARM Cortex-M 处理器上称为 Coresight）进行通信。SEGGER
    J-Link 和 J-Trace 系列调试探针在行业中非常受欢迎。SEGGER 还提供免费集成的有用软件。这些工具的可用性和配套软件的质量使得它们非常适合在本书中使用。
- en: If you plan on using a paid IDE, the IDE vendor likely has their own proprietary
    debug probes available. Many excellent software features will likely be tied to
    their hardware. For example, ARM Keil uVision MDK integrates with ARM Ulink probes
    and IAR offers their I-Jet debug probes. IDEs such as these also integrate with
    third-party probes but be aware of what trade-offs there may be before making
    a purchasing decision.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划使用付费IDE，IDE供应商可能有自己的专有调试探针。许多优秀的软件功能可能与其硬件绑定。例如，ARM Keil uVision MDK与ARM
    Ulink探针集成，IAR提供他们的I-Jet调试探针。此类IDE还与第三方探针集成，但在做出购买决定之前，请注意可能存在的权衡。
- en: There are many options when selecting debug probes from SEGGER —we'll briefly
    go through some of the options currently available and look at the hardware requirements
    for each.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择SEGGER调试探针时有很多选项——我们将简要介绍目前可用的选项，并查看每个选项的硬件要求。
- en: Hardware options
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件选项
- en: SEGGER has many different hardware options that cover a wide range of pricing
    and capabilities. For a complete and current list, check out their website at [https://www.segger.com/products/debug-probes/j-link/models/model-overview/](https://www.segger.com/products/debug-probes/j-link/models/model-overview/).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: SEGGER有许多不同的硬件选项，覆盖了广泛的定价和能力。要获取完整和当前的列表，请访问他们的网站[https://www.segger.com/products/debug-probes/j-link/models/model-overview/](https://www.segger.com/products/debug-probes/j-link/models/model-overview/)。
- en: 'The models generally fit into two main categories: debuggers with full Cortex-M
    Trace support and those without.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 模型通常分为两大类：具备完整Cortex-M迹线支持的调试器和不具备的。
- en: Segger J-Trace
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Segger J-Trace
- en: The debuggers with full trace support are referred to as J-Trace. The **Cortex
    Embedded Trace Macrocell** (**Cortex ETM**) is an extra piece of hardware inside
    the MCU that allows every instruction that has been executed to be recorded. Transmitting
    all of this information off the MCU requires a few extra pins for clocking the
    data out (a clock line and 1-4 data lines). Having the ability to trace every
    instruction the MCU has executed enables functionality such as code coverage,
    which provides insight into how much code has been executed (line by line). Knowing
    exactly which lines of code have been executed and when gives us the opportunity
    to see where a program is spending most of its time. When we know which individual
    lines of code are executed most often, it is possible to optimize that small portion
    of code when improved performance is required.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 具备完整迹线支持的调试器被称为J-Trace。**Cortex嵌入式迹线宏单元**（**Cortex ETM**）是MCU内部的一个额外硬件组件，它允许记录所有已执行的指令。将所有这些信息从MCU传输出去需要一些额外的引脚来时钟数据输出（一个时钟线和1-4个数据线）。能够追踪MCU执行的所有指令使得功能如代码覆盖率成为可能，这提供了关于已执行代码量的洞察（逐行）。确切知道哪些代码行已被执行以及何时执行，这给了我们机会看到程序大部分时间花在了哪里。当我们知道哪些单独的代码行被执行得最频繁时，在需要改进性能时，就有可能优化这部分代码。
- en: 'In order to take full advantage of the advanced trace features, all of the
    following is required:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用高级迹线功能，以下所有条件都是必需的：
- en: The MCU must have ETM hardware.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MCU必须具备ETM硬件。
- en: The specific MCU package must bring the ETM signals out to pins.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定的MCU封装必须将ETM信号引出到引脚上。
- en: The peripheral configuration must not share ETM signals with other functions.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外设配置不得与其他功能共享ETM信号。
- en: The system circuit must be designed to incorporate ETM signals and a connector.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统电路必须设计成包含ETM信号和连接器。
- en: 'The most common connector used for Debug and ETM signals is a 0.05" pitch header
    with the following pinout (the trace signals are highlighted):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 用于调试和ETM信号的常用连接器是一个0.05英寸间距的排针，其引脚配置如下（迹线信号已突出显示）：
- en: '![](img/606fde5a-281e-425d-98da-39ae354e764b.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/606fde5a-281e-425d-98da-39ae354e764b.png)'
- en: All of this functionality comes at a price, of course. The J-Trace models are
    at the high end of SEGGER's spectrum, both in terms of functionality and price
    (typically over USD$1000). Unless you're developing fully custom hardware, also
    expect to pay for a full evaluation board (over USD$200) rather than the low-cost
    development hardware used in this book. While these costs are typically completely
    reasonable for a full-blown engineering budget during new product development,
    they are too expensive to be widely accessible for individuals.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，所有这些功能都需要付出代价。J-Trace 模型在 SEGGER 的产品线中处于高端，无论是在功能还是价格方面（通常超过 1000 美元）。除非你正在开发完全定制的硬件，否则也请预期需要支付一个完整的评估板（超过
    200 美元），而不是本书中使用的低成本开发硬件。虽然这些成本对于新产品开发期间的全额工程预算通常是完全合理的，但对于个人来说过于昂贵，难以广泛获取。
- en: SEGGER J-Link
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SEGGER J-Link
- en: SEGGER J-Link has been around in many different forms and has grown to encompass
    several models. Typically, the higher-end models provide faster clock speeds and
    a richer experience (faster downloads, responsive debugging, and so on). A few
    **EDU** models are sold at an extremely large discount for educational purposes
    (thus the **EDU** designation). These models are fully featured but may not be
    used for commercial purposes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: SEGGER J-Link 在许多不同的形式中存在，并已发展到包括几个型号。通常，高端型号提供更快的时钟速度和更丰富的体验（更快的下载、响应式调试等）。一些**EDU**型号以极低折扣出售，用于教育目的（因此有**EDU**的标识）。这些型号功能齐全，但不能用于商业目的。
- en: The most common connector used for the Cortex-M is a 0.05" pitch header with
    the following pinout. Notice, this connector's pinout is the same as the first
    10 pins from the Debug+Trace connector (refer to the following diagram).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Cortex-M 最常用的连接器是一个 0.05" 前距的排针，具有以下引脚配置。请注意，此连接器的引脚配置与 Debug+Trace 连接器的第一个
    10 个引脚相同（参见图表）。
- en: '![](img/01e54c91-a4cc-400f-9059-3deda9ecb214.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/01e54c91-a4cc-400f-9059-3deda9ecb214.png)'
- en: SEGGER has done an excellent job designing software interfaces that aren't tied
    to the underlying hardware. Because of this, their software tools work across
    different hardware debugger models without modification. This has also resulted
    in the hardware option we'll be using in this book—the SEGGER J-Link on-board.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: SEGGER 在设计不依赖于底层硬件的软件接口方面做得非常出色。正因为如此，他们的软件工具无需修改即可在不同的硬件调试器模型上运行。这也导致了本书中我们将使用的硬件选项——板载
    SEGGER J-Link。
- en: SEGGER J-Link on-board
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 板载 SEGGER J-Link
- en: 'The specific hardware variant of ST-Link we''ll be using in our exercises isn''t
    actually made by SEGGER. It is the ST-Link circuitry already included on the Nucleo
    development board. Nucleo boards have two separate sub-circuits: programming hardware
    and target hardware.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在练习中将使用的 ST-Link 具体硬件变体实际上不是由 SEGGER 制造的。它是 Nucleo 开发板上已经包含的 ST-Link 电路。Nucleo
    板有两个独立的子电路：编程硬件和目标硬件。
- en: 'The programming hardware sub-circuit is generally referred to as an ST-Link.
    This **programming hardware** is actually another STM MCU that is responsible
    for communicating with the PC and programming the **target hardware**—the STM32F767\.
    Since Nucleo hardware is primarily aimed at the ARM Mbed ecosystem, the ST-Link
    MCU is programmed with firmware that implements both the ST-Link and Mbed functionalities:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 编程硬件子电路通常被称为 ST-Link。这个**编程硬件**实际上是一个负责与 PC 通信并编程**目标硬件**（STM32F767）的 STM MCU。由于
    Nucleo 硬件主要针对 ARM Mbed 生态系统，ST-Link MCU 被编程为固件，该固件实现了 ST-Link 和 Mbed 功能：
- en: '![](img/f7807694-5d5b-492d-9d3b-4070bf3f9174.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f7807694-5d5b-492d-9d3b-4070bf3f9174.png)'
- en: In order to use the programming hardware on the Nucleo board as a SEGGER JLink,
    we will be replacing its firmware with SEGGER J-Link on-board firmware.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 Nucleo 板上的编程硬件作为 SEGGER JLink 使用，我们将用 SEGGER J-Link 板载固件替换其固件。
- en: Installing J-Link
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 J-Link
- en: 'Detailed installation instructions are available from SEGGER at [https://www.segger.com/products/debug-probes/j-link/models/other-j-links/st-link-on-board/](https://www.segger.com/products/debug-probes/j-link/models/other-j-links/st-link-on-board/).
    A few notes are also included here for convenience. In order to convert the on-board
    ST-Link to a J-Link, we''ll be downloading and installing two pieces of software:
    the J-Link tools and the ST-Link re-flashing utility. You should already have
    the necessary ST-Link drivers installed from the STM32CubeIDE installation carried
    out in the previous chapter:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 详细安装说明可在SEGGER的[https://www.segger.com/products/debug-probes/j-link/models/other-j-links/st-link-on-board/](https://www.segger.com/products/debug-probes/j-link/models/other-j-links/st-link-on-board/)找到。这里也包含了一些方便的注意事项。为了将板载ST-Link转换为J-Link，我们将下载并安装两个软件：J-Link工具和ST-Link刷新实用程序。您应该已经从上一章中STM32CubeIDE安装中安装了必要的ST-Link驱动程序：
- en: A Windows PC is only required for the J-Link Reflash utility (it is distributed
    as `*.exe`). If you're not using a Windows PC for development and STM32CubeIDE
    isn't installed, make sure you install USB drivers for the ST-Link (the optional
    *step 1* in the following list).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当需要使用J-Link Reflash实用程序（它作为`*.exe`文件分发）时，才需要Windows PC。如果您不使用Windows PC进行开发且未安装STM32CubeIDE，请确保安装ST-Link的USB驱动程序（以下列表中的可选*步骤1*）。
- en: If you don't have STM32CubeIDE installed already, download and install the ST-Link
    drivers from [http://www.st.com/en/development-tools/stsw-link009.html](http://www.st.com/en/development-tools/stsw-link009.html) (this
    step is optional).
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您尚未安装STM32CubeIDE，请从[http://www.st.com/en/development-tools/stsw-link009.html](http://www.st.com/en/development-tools/stsw-link009.html)下载并安装ST-Link驱动程序（此步骤为可选）。
- en: Download the appropriate J-Link utilities for your OS from [https://www.segger.com/downloads/jlink](https://www.segger.com/downloads/jlink).
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://www.segger.com/downloads/jlink](https://www.segger.com/downloads/jlink)下载适合您操作系统的J-Link工具。
- en: Install the J-Link utilities— the default options are fine.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装J-Link工具——默认选项即可。
- en: Download the SEGGER J-Link Reflash utility (for Windows OS only) from [https://www.segger.com/downloads/jlink#STLink_Reflash](https://www.segger.com/downloads/jlink#STLink_Reflash).
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://www.segger.com/downloads/jlink#STLink_Reflash](https://www.segger.com/downloads/jlink#STLink_Reflash)下载SEGGER
    J-Link刷新实用程序（仅适用于Windows操作系统）。
- en: 'Unzip the contents of `STLinkReflash_<version>.zip`— it will contain two files:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压`STLinkReflash_<version>.zip`文件的内容——它将包含两个文件：
- en: '`JLinkARM.dll`'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JLinkARM.dll`'
- en: '`STLinkReflash.exe`'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STLinkReflash.exe`'
- en: Now, we will convert ST-Link to J-Link.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将ST-Link转换为J-Link。
- en: Converting ST-Link to J-Link
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将ST-Link转换为J-Link
- en: 'Follow these steps to upload J-Link firmware to the ST-Link on the Nucleo development
    board:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将J-Link固件上传到Nucleo开发板上的ST-Link：
- en: Plug in a micro USB cable to `CN1` on the Nucleo board and attach it to your
    Windows PC.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将微型USB线插入Nucleo板上的`CN1`并连接到您的Windows PC。
- en: Open `STLinkReflash_<version>.exe`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`STLinkReflash_<version>.exe`。
- en: Read through and accept the two license agreements.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阅读并接受两个许可协议。
- en: 'Select the first option: Upgrade to J-Link.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择第一个选项：升级到J-Link。
- en: The debugging hardware on the Nucleo board is now effectively a SEGGER J-Link!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Nucleo板上的调试硬件现在实际上是SEGGER J-Link！
- en: Now that a J-Link is present, we will be able to use other SEGGER software tools,
    such as Ozone and SystemView, to debug and visualize our applications.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有了J-Link，我们将能够使用其他SEGGER软件工具，如Ozone和SystemView，来调试和可视化我们的应用。
- en: Using SEGGER Ozone
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SEGGER Ozone
- en: SEGGER Ozone is a piece of software that is meant to debug an already-written
    application. Ozone is independent of the underlying programming environment used
    to create the application. It can be used in many different modes, but we'll focus
    on importing an `*.elf` file and crossreferencing it with source code to provide
    FreeRTOS-aware debugging capability to a project created with any toolchain. Let's
    take a quick look at the various file types we will be working with in Ozone.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: SEGGER Ozone是一款用于调试已编写应用的软件。Ozone与创建应用所使用的底层编程环境无关。它可以在许多不同的模式下使用，但我们将重点关注导入`*.elf`文件并与源代码交叉引用，为使用任何工具链创建的项目提供FreeRTOS感知的调试功能。让我们快速了解一下在Ozone中将要处理的文件类型。
- en: File types used in the examples
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例中使用的文件类型
- en: There are several file types used when programming and debugging embedded systems.
    These files are common across many different processors and software products
    and not exclusive to Cortex-M MCUs or the software used in this book.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程和调试嵌入式系统时，会用到几种文件类型。这些文件类型适用于许多不同的处理器和软件产品，并不局限于Cortex-M微控制器或本书中使用的软件。
- en: '**Executable and Linkable Format** (**ELF**) files are an executable format
    that has the ability to store more than the straight `*.bin` or `*.hex` files
    commonly flashed directly into an MCU''s ROM. The `*.elf` files are similar to
    the `*.hex` files in that they contain all of the binary machine code necessary
    to load a fully functional project onto a target MCU. The `*.elf` files also contain
    links to the original source code filenames and line numbers. Software such as
    Ozone uses these links to display source code while debugging the application:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**可执行和链接格式**（**ELF**）文件是一种具有存储比直接 `*.bin` 或 `*.hex` 文件更多内容的执行格式。`*.elf` 文件与
    `*.hex` 文件类似，它们包含加载到目标 MCU 上的完整功能项目所需的全部二进制机器代码。`*.elf` 文件还包含指向原始源代码文件名和行号的链接。Ozone
    等软件使用这些链接在调试应用程序时显示源代码：'
- en: '`*.bin`: A straight binary file (just 1s and 0s). This file format can be directly
    "burned" into an MCU''s internal flash memory, starting at a given address.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*.bin`：一个直接的二进制文件（只有 1 和 0）。这种文件格式可以直接“烧录”到 MCU 的内部闪存中，从指定的地址开始。'
- en: '`*.hex`:Usually a variant of Motorolla S-record format. This ASCII-based file
    format contains both absolute memory addresses and their contents.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*.hex`：通常是摩托罗拉 S-record 格式的变体。这种基于 ASCII 的文件格式包含绝对内存地址及其内容。'
- en: '`*.elf`: Contains both the executable code as well as a header that is used
    to cross-reference each memory segment to a source file. This means a single ELF
    file contains enough information to program the target MCU and also cross-reference
    all of the source code used to create the binary memory segments.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*.elf`：包含可执行代码以及一个用于交叉引用每个内存段到源文件的标题。这意味着单个 ELF 文件包含足够的信息来编程目标 MCU，并且可以交叉引用创建二进制内存段所使用的所有源代码。'
- en: The ELF file does not *contain* the actual source code used, it only contains
    absolute file paths that crossreference memory segments to the original source
    code. This is what allows us to open a `*.elf` file in Ozone and step through
    the C source code while debugging.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ELF 文件不包含实际使用的源代码，它只包含指向内存段与原始源代码交叉引用的绝对文件路径。这就是我们能够在 Ozone 中打开 `*.elf` 文件并在调试时逐步执行
    C 源代码的原因。
- en: '`*.svd`: Contains information that maps registers and descriptions to the memory
    map of the target device. By providing an accurate `*.svd` file, Ozone will be
    able to display peripheral views that are very helpful when troubleshooting MCU
    peripheral code.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*.svd`：包含将寄存器和描述映射到目标设备内存映射的信息。通过提供准确的 `*.svd` 文件，Ozone 将能够显示在调试 MCU 外设代码时非常有用的外设视图。'
- en: A `*.svd` file is a file that is usually included with an IDE that supports
    your MCU. For example, STM32Cube IDE's location for the `*.svd` files is
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`*.svd` 文件是一种通常与支持您的 MCU 的 IDE 一起提供的文件。例如，STM32Cube IDE 中 `*.svd` 文件的位置是'
- en: '*`C:\ST\STM32CubeIDE_1.2.0\STM32CubeIDE\plugins\com.st.stm32cube.ide.mcu.productdb.debug_1.2.0.201912201802\resources\cmsis\STMicroelectronics_CMSIS_SVD`.*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*`C:\ST\STM32CubeIDE_1.2.0\STM32CubeIDE\plugins\com.st.stm32cube.ide.mcu.productdb.debug_1.2.0.201912201802\resources\cmsis\STMicroelectronics_CMSIS_SVD`.*'
- en: There are other file types used in embedded systems' development as well. This
    is by no means an exhaustive list—just the ones we'll be using most in the context
    of the example projects.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式系统开发中，还有其他一些文件类型被使用。这绝对不是一份详尽的列表——只是我们在示例项目中会使用到的一些。
- en: Installing SEGGER Ozone
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 SEGGER Ozone
- en: 'To install SEGGER Ozone, follow these two simple steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 SEGGER Ozone，请按照以下两个简单步骤操作：
- en: 'Download SEGGER Ozone: [https://www.segger.com/downloads/jlink/](https://www.segger.com/downloads/jlink/)'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载 SEGGER Ozone：[https://www.segger.com/downloads/jlink/](https://www.segger.com/downloads/jlink/)
- en: Install it using the default options.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用默认选项进行安装。
- en: Now, let's cover the necessary steps to create a FreeRTOS-aware Ozone project
    and take a quick look at some of the interesting features.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来介绍创建一个支持 FreeRTOS 的 Ozone 项目的必要步骤，并快速浏览一些有趣的功能。
- en: Creating Ozone projects
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Ozone 项目
- en: 'Since Ozone is completely independent of the programming environment, in order
    to debug with it, some configuration is required, which is covered in the following
    steps:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Ozone 完全独立于编程环境，为了使用它进行调试，需要进行一些配置，这些配置将在以下步骤中介绍：
- en: All projects included in the source tree for this book already have Ozone projects
    created for them. The following steps are for your reference—you'll only need
    to go through these steps for your own future projects. Ozone project files, the `*.jdebug`
    files, are already included for all of the projects in this book.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 本书源代码树中包含的所有项目都已为它们创建了Ozone项目。以下步骤仅供参考——您只需为您的未来项目执行这些步骤。本书中所有项目的Ozone项目文件，即`*.jdebug`文件，都已包含。
- en: When first opened, select the Create a New Project prompt.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首次打开时，选择“创建新项目”提示。
- en: For the Device field, select STM32F767ZI.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于“设备”字段，选择STM32F767ZI。
- en: 'For Peripherals, input the directory and location of the `STM32F7x7.svd` file:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于外设，输入`STM32F7x7.svd`文件的目录和位置：
- en: '![](img/fd3c1524-135b-4700-b079-ff896763055e.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fd3c1524-135b-4700-b079-ff896763055e.png)'
- en: On the Connection Settings dialog screen, default values are acceptable.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“连接设置”对话框屏幕上，默认值是可以接受的。
- en: 'On the Program File dialog screen, navigate to the `*.elf` file that is generated
    by TrueStudio. It should be in the Debug folder of your project:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“程序文件”对话框屏幕上，导航到由TrueStudio生成的`.elf`文件。它应该位于您的项目“调试”文件夹中：
- en: '![](img/cfbb146e-e29c-481c-b0d1-f2a8e1ed6ee6.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cfbb146e-e29c-481c-b0d1-f2a8e1ed6ee6.png)'
- en: Save the `*.jdebug` project file and close Ozone.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存`*.jdebug`项目文件并关闭Ozone。
- en: Open the `*.jdebug` file with a text editor.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用文本编辑器打开`*.jdebug`文件。
- en: 'Add a line to the `*.jdebug` project file to enable the FreeRTOS plugin (only
    add the last line in bold):'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`*.jdebug`项目文件中添加一行以启用FreeRTOS插件（仅添加加粗的最后一行）：
- en: '[PRE0]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is a good idea to copy the `*.svd` file to a location used for storing source
    code or build tools since the installation directory for the IDEs is likely to
    change over time and between machines.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将`*.svd`文件复制到用于存储源代码或构建工具的位置是个好主意，因为IDE的安装目录可能会随时间和机器而改变。
- en: These steps can be adapted to set up Ozone for any other MCU supported by SEGGER
    family debuggers.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤可以修改为设置任何由SEGGER系列调试器支持的MCU的Ozone。
- en: Attaching Ozone to the MCU
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Ozone附加到MCU
- en: 'Time to roll up our sleeves and get our hands dirty! The next sections will
    make more sense if you''ve got some hardware up and running, so you can follow
    along and do some exploring. Let''s get everything set up:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候卷起袖子，动手实践了！如果您有一些硬件正在运行，接下来的部分将更有意义，您可以跟随操作并进行一些探索。让我们开始设置一切：
- en: Open the STM32Cube IDE and open the `Chapter5_6` project.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开STM32Cube IDE并打开`Chapter5_6`项目。
- en: Right-click on `Chapter5_6` and select Build. This will compile the project
    into an `*.elf` file (that is, `C:\projects\packtBookRTOS\Chapters5_6\Debug\Chapter5_6.elf`).
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`Chapter5_6`并选择构建。这将编译项目为`*.elf`文件（即`C:\projects\packtBookRTOS\Chapters5_6\Debug\Chapter5_6.elf`）。
- en: Open Ozone.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Ozone。
- en: Select Open Existing Project from the wizard.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从向导中选择“选择打开现有项目”。
- en: Select `C:\projects\packtBookRTOS\Chapters5_6\Chapters5_6.jdebug`.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`C:\projects\packtBookRTOS\Chapters5_6\Chapters5_6.jdebug`。
- en: 'Use Ozone to download the code to the MCU (click the power button):'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Ozone将代码下载到MCU（单击电源按钮）：
- en: '![](img/2a4459a6-9c8c-4e75-b87f-b2a1f15e4bb7.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2a4459a6-9c8c-4e75-b87f-b2a1f15e4bb7.png)'
- en: Push the play button to start the application (you should see the red, blue,
    and green LEDs flashing).
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下播放按钮以启动应用程序（您应该看到红色、蓝色和绿色LED闪烁）。
- en: If your paths are different from what was used when creating the `*.jdebug`
    files, you'll need to reopen the `.elf` file (go to File | Open and select the
    file built in *step 2*).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的路径与创建`*.jdebug`文件时使用的路径不同，您需要重新打开`.elf`文件（转到“文件 | 打开”并选择在*步骤2*中构建的文件）。
- en: Those same six steps can be repeated for any of the projects included in this
    book. You can also create a copy of the `.jdebug` file for other projects by simply
    opening a different `*.elf` file.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些相同的六个步骤可以重复用于本书中包含的任何项目。您也可以通过打开不同的`*.elf`文件为其他项目创建`.jdebug`文件的副本。
- en: You may want to bookmark this page. You'll be following these same steps for
    the 50+ example programs throughout the rest of the book!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想将此页面添加到书签。您将在本书剩余的50多个示例程序中遵循相同的步骤！
- en: Viewing tasks
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看任务
- en: 'A quick view overview of tasks can be seen by enabling the FreeRTOS task view.
    Using these tasks can prove to be very beneficial while developing RTOS applications:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过启用FreeRTOS任务视图，可以快速查看任务概览。在开发RTOS应用程序时，使用这些任务可能非常有益：
- en: After the MCU program has been started, pause execution by clicking the *Pause*
    button.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在MCU程序启动后，通过单击*暂停*按钮暂停执行。
- en: 'Now, navigate to View | FreeRTOS Task View:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，导航到“查看 | FreeRTOS任务视图”：
- en: '![](img/0a46ef4b-1ae5-47aa-9ddf-7a2fe247262e.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a46ef4b-1ae5-47aa-9ddf-7a2fe247262e.png)'
- en: 'This view shows many useful pieces of information at a glance:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此视图可以一目了然地显示许多有用的信息：
- en: Task names and priorities.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务名称和优先级。
- en: 'Timeout: How many *ticks* a blocked task has until it is forced out of the
    blocked state.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超时：一个被阻塞的任务在被强制退出阻塞状态之前有多少个*滴答*。
- en: Each task's stack usage (only the current stack usage is shown by default).
    Maximum stack usage is disabled in the preceding screenshot (seen by N/A)—(details
    on configuring FreeRTOS to monitor maximum stack usage will be covered in [Chapter
    17](50d2b6c3-9a4e-45c3-9bfc-1c7f58de0b98.xhtml), *Troubleshooting Tips and Next
    Steps*).
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个任务的堆栈使用情况（默认情况下只显示当前堆栈使用情况）。在先前的屏幕截图中（通过N/A看到），最大堆栈使用被禁用——（配置FreeRTOS以监控最大堆栈使用的详细信息将在[第17章](50d2b6c3-9a4e-45c3-9bfc-1c7f58de0b98.xhtml)，*故障排除技巧和下一步行动*中介绍）。
- en: 'Mutex Count: How many mutexes a task currently holds.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互斥锁计数：一个任务当前持有的互斥锁数量。
- en: 'Notifications: Details on each task''s notifications.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知：每个任务通知的详细信息。
- en: Having a bird's eye view of all of the tasks in the system can be a huge help
    when developing an RTOS-based application—especially during the initial phases
    of development.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发基于实时操作系统的应用程序时，对系统中所有任务的鸟瞰图可以提供巨大的帮助——尤其是在开发的初期阶段。
- en: Task-based stack analysis
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于任务的堆栈分析
- en: One of the challenges with debugging an RTOS with non-RTOS aware tools is analyzing
    the call stack of each task. When the system halts, each task has its own call
    stack. It is quite common to need to analyze the call stack for multiple tasks
    at a given point in time. Ozone provides this capability by using FreeRTOS Task
    View in conjunction with Call Stack View.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非实时操作系统感知工具调试实时操作系统的一个挑战是分析每个任务的调用堆栈。当系统停止时，每个任务都有自己的调用堆栈。在特定时间点需要分析多个任务的调用堆栈是很常见的。Ozone通过结合使用FreeRTOS任务视图和调用堆栈视图来提供这种功能。
- en: After opening both views, each task in FreeRTOS Task View can be double-clicked
    to reveal the current call stack of that task in Call Stack View. To reveal local
    variables for each task on a function-by-function basis, open Local Data view.
    In this view, local variables for the current function highlighted in the call
    stack will be visible.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开两个视图后，FreeRTOS任务视图中的每个任务都可以双击以在调用堆栈视图中揭示该任务的当前调用堆栈。要按函数逐个揭示每个任务的局部变量，请打开本地数据视图。在此视图中，将显示调用堆栈中当前突出显示的函数的局部变量。
- en: 'An example combining the task-based call stack analysis with a local variable
    view is shown here:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了结合基于任务的调用堆栈分析与局部变量视图的示例：
- en: '![](img/93051213-82ab-47a3-9536-18189311a414.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/93051213-82ab-47a3-9536-18189311a414.png)'
- en: 'Notice the following from this screenshot:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下从该截图中的信息：
- en: When the MCU was stopped, it was in the "IDLE" task (shown by executing in the
    Status column).
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当MCU停止时，它处于“IDLE”任务状态（在状态列中通过执行来显示）。
- en: Double-clicking on "task 3" shows the call stack for "task 3". Currently, `vTaskDelay`
    is at the top of the stack.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击“task 3”显示“task 3”的调用堆栈。目前，`vTaskDelay`位于堆栈顶部。
- en: Double-clicking on `StartTask3` updates the Local Data window to show values
    for all local variables in `StartTask3`.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`StartTask3`会更新本地数据窗口，以显示`StartTask3`中所有局部变量的值。
- en: Local Variables for `StartTask3` shows the current values for all local variables
    in `StartTask3`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`StartTask3`的局部变量显示了`StartTask3`中所有局部变量的当前值。'
- en: SEGGER Ozone provides both a task-aware call stack view and a heads-up view
    for all running tasks in the system. This combination gives us a powerful tool
    to dive into the most minute details of each task running on the system. But what
    happens when we need a bigger picture view of the system? Instead of looking at
    each task individually, what if we'd prefer to look at the interaction *between*
    tasks in the system? This is an area where SEGGER SystemView can help.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: SEGGER Ozone提供了对系统中所有运行任务的基于任务的调用堆栈视图和前瞻视图。这种组合为我们提供了一款强大的工具，可以深入到系统中每个运行任务的细微细节。但当我们需要系统的更大视角时会发生什么？我们不是逐个查看每个任务，而是更愿意查看系统任务之间的交互*。*这是SEGGER
    SystemView可以提供帮助的领域。
- en: Using SEGGER SystemView
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SEGGER SystemView
- en: SEGGER SystemView is another software tool that can be used with SEGGER debug
    probes. It provides a means to visualize the flow of tasks and interrupts in a
    system. SystemView works by adding a small amount of code into the project. FreeRTOS
    already has `Trace Hook Macros`, which was specifically designed for adding in
    this type of third-party functionality.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: SEGGER SystemView是另一个可以与SEGGER调试探针一起使用的软件工具。它提供了一种可视化系统任务和中断流的方法。SystemView通过在项目中添加少量代码来实现。FreeRTOS已经具有`Trace
    Hook Macros`，这是专门为添加此类第三方功能而设计的。
- en: Unlike Ozone, SystemView doesn't have any programming or debugging capabilities,
    it is only a **viewer***.*
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 与Ozone不同，SystemView没有编程或调试功能，它只是一个**查看器**。
- en: Installing SystemView
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装SystemView
- en: There are two main steps required for making your system visible with SystemView.
    The software needs to be installed and source code must be instrumented so it
    will communicate its status over the debug interface.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要使您的系统通过SystemView可见，需要两个主要步骤。软件需要安装，源代码必须被配置，以便它可以通过调试接口通信其状态。
- en: SystemView installation
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SystemView安装
- en: 'To install SystemView, follow these steps:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装SystemView，请按照以下步骤操作：
- en: Download SystemView for your OS. This is the main binary installer ([https://www.segger.com/downloads/free-utilities](https://www.segger.com/downloads/free-utilities)).
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载适用于您的操作系统（OS）的SystemView。这是主要的二进制安装程序（[https://www.segger.com/downloads/free-utilities](https://www.segger.com/downloads/free-utilities)）。
- en: Install using the default options.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用默认选项安装。
- en: Source code configuration
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码配置
- en: 'In order for SystemView to show a visualization of tasks running on a system,
    it must be provided with information such as task names, priorities, and the current
    state of tasks. There are hooks present in FreeRTOS for nearly everything SystemView
    needs. A few configuration files are used to set up a mapping between the trace
    hooks already present in FreeRTOS and used by SystemView. Information needs to
    be collected, which is where the specific RTOS configuration and SystemView target
    sources come into play:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使SystemView能够显示系统上运行的任务的可视化，它必须提供有关任务名称、优先级和任务当前状态等信息。FreeRTOS中存在几乎满足SystemView所需的所有钩子。一些配置文件用于设置FreeRTOS中现有的跟踪钩子和SystemView使用的映射。需要收集信息，这就是特定RTOS配置和SystemView目标源发挥作用的地方：
- en: The source code included with this book already has all of these modifications
    performed, so these steps are *only necessary* if you'd like to add SystemView
    functionality to *your own FreeRTOS-based projects.*
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 本书附带源代码已经执行了所有这些修改，因此，如果您想将SystemView功能添加到**您自己的FreeRTOS项目**中，这些步骤**仅是必要的**。
- en: Download SystemView FreeRTOS V10 Configuration (v 2.52d was used) from [https://www.segger.com/downloads/free-utilities ](https://www.segger.com/downloads/free-utilities)and
    apply `FreeRTOSV10_Core.patch` to the FreeRTOS source tree using your preferred
    diff tool.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://www.segger.com/downloads/free-utilities](https://www.segger.com/downloads/free-utilities)下载SystemView
    FreeRTOS V10配置（使用了v 2.52d版本）并将`FreeRTOSV10_Core.patch`应用到FreeRTOS源树中，使用您首选的diff工具。
- en: 'Download and incorporate SystemView Target Sources (v 2.52h was used) from
    [https://www.segger.com/downloads/free-utilities](https://www.segger.com/downloads/free-utilities):'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://www.segger.com/downloads/free-utilities](https://www.segger.com/downloads/free-utilities)下载并集成SystemView目标源（使用了v
    2.52h版本）。
- en: Copy all the source files into the `.\SEGGER` folder in your source tree and
    include them for compilation and linking. In our source tree, the `SEGGER` folder
    is located in `.\Middlewares\Third_Party\SEGGER`.
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有源文件复制到您的源树中的`.\SEGGER`文件夹，并在编译和链接时包含它们。在我们的源树中，`SEGGER`文件夹位于`.\Middlewares\Third_Party\SEGGER`。
- en: Copy `SystemView Target Sources\Sample\FreeRTOSV10\SEGGER_SYSVIEW_FreeRTOS.c/h` into
    the `SEGGER` folder and include it for compilation and linking.
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`SystemView Target Sources\Sample\FreeRTOSV10\SEGGER_SYSVIEW_FreeRTOS.c/h`复制到`SEGGER`文件夹中，并在编译和链接时包含它。
- en: Copy `.\Sample\FreeRTOSV10\Config\SEGGER_SYSVIEW_Config_FreeRTOS.c` into the`SEGGER` folder and
    include it for compilation and linking.
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`.\Sample\FreeRTOSV10\Config\SEGGER_SYSVIEW_Config_FreeRTOS.c`复制到`SEGGER`文件夹中，并在编译和链接时包含它。
- en: 'Make the following changes to `FreeRTOSConfig.h`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`FreeRTOSConfig.h`做出以下更改：
- en: At the end of the file, add an include for `SEGGER_SYSVIEW_FreeRTOS.h`: `#include
    "SEGGER_SYSVIEW_FREERTOS.h"`.
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件末尾添加对`SEGGER_SYSVIEW_FreeRTOS.h`的包含：`#include "SEGGER_SYSVIEW_FREERTOS.h"`。
- en: Add `#define INCLUDE_xTaskGetIdleTaskHandle 1`.
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`#define INCLUDE_xTaskGetIdleTaskHandle 1`。
- en: Add `#define ``INCLUDE_pxTaskGetStackStart 1`.
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`#define INCLUDE_pxTaskGetStackStart 1`。
- en: 'In `main.c` make the following changes:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.c`中做出以下更改：
- en: Include `#include <SEGGER_SYSVIEW.h>`.
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含`#include <SEGGER_SYSVIEW.h>`。
- en: Add a call to `SEGGER_SYSVIEW_Conf()` after initialization and before the scheduler
    is started.
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始化之后和启动调度器之前添加对`SEGGER_SYSVIEW_Conf()`的调用。
- en: Since SystemView is called inside the context of each task, you'll likely find
    that the minimum task stack size will need to be increased to avoid stack overflows.
    This is because the SystemView library requires a small amount of code that runs
    on the target MCU (which increases the call depth and the number of functions
    that are placed on the stack). For all the gory details on how to troubleshoot
    stack overflows (and how to avoid them), see [Chapter 17](50d2b6c3-9a4e-45c3-9bfc-1c7f58de0b98.xhtml),
    *Troubleshooting Tips and Next Steps.*
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SystemView是在每个任务的上下文中调用的，你可能会发现需要增加最小任务堆栈大小以避免堆栈溢出。这是因为SystemView库需要在目标MCU上运行一小段代码（这增加了调用深度和放置在堆栈上的函数数量）。有关如何调试堆栈溢出（以及如何避免它们）的所有详细信息，请参阅第17章*故障排除技巧和下一步*。
- en: Using SystemView
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SystemView
- en: 'After the source-code side of SystemView is straightened out, using the application
    is very straightforward. To start a capture, make sure you have a running target
    and your debugger and MCU are connected to the computer:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在整理完SystemView的源代码后，使用该应用程序非常简单。要开始捕获，请确保你有运行中的目标，并且你的调试器和MCU连接到计算机：
- en: Push the *Play* button.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击*播放*按钮。
- en: 'Select the appropriate target device settings (shown here):'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择适当的目标设备设置（如下所示）：
- en: '![](img/4fc401c7-2698-4f87-99c8-24e6419c5516.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4fc401c7-2698-4f87-99c8-24e6419c5516.png)'
- en: SystemView requires a *running* target. It will not show any information for
    a halted MCU (there are no events to display since it is not running). Make sure
    the LEDs on the board are blinking; follow the steps from the *Attaching Ozone
    to the MCU* section if they're not.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: SystemView需要一个*运行中的*目标。它不会显示停止的MCU（因为它没有运行，所以没有事件可以显示）。确保板上的LED闪烁；如果它们没有闪烁，请按照*将Ozone连接到MCU*部分的步骤操作。
- en: 'After a second or so, events will be streaming into the log in the top-left
    Events view and you will see a live graphical view of the tasks as they''re currently
    executing in Timeline:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几秒钟后，事件将流进左上角的日志事件视图中，你将看到任务在时间线中当前执行的实时图形视图：
- en: '![](img/713ce462-f002-4fb6-a19f-448c610f01f1.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/713ce462-f002-4fb6-a19f-448c610f01f1.png)'
- en: Timeline shows a visual representation of task execution, including different
    states.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间线显示了任务执行的视觉表示，包括不同的状态。
- en: The Events view shows a list of events. Selected events are linked to the timeline.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件视图显示了事件列表。选中的事件与时间线相链接。
- en: The Context viewshows statistics for all events.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文视图显示了所有事件的统计数据。
- en: Terminal can be used to show printf-like messages from your code.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终端可以用来显示代码中的printf-like消息。
- en: There are many more useful features, which will be covered while exploring code.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多有用的功能，这些功能将在探索代码时介绍。
- en: We're finally done installing the development software! If you've followed along
    so far, you now have a fully operational IDE, an RTOS visualization solution,
    and an extremely powerful RTOS-aware debugging system at your disposal. Let's
    see what other tools can be useful during the course of embedded systems development.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于完成了开发软件的安装！如果你一直跟随着，你现在拥有了一个完全可操作的IDE、一个RTOS可视化解决方案以及一个功能强大的RTOS感知调试系统。让我们看看在嵌入式系统开发过程中还有哪些其他工具可能是有用的。
- en: Other great tools
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他优秀工具
- en: The tools covered in this chapter certainly aren't the only ones available for
    debugging and troubleshooting embedded systems. There are many other tools and
    techniques that we simply don't have scope to cover (or that weren't a good fit
    due to the specific constraints placed on the tools used in this book). These
    topics are mentioned in the following section, with additional links in the *Further
    reading *section at the end of the chapter.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍的工具当然不是调试和故障排除嵌入式系统可用的唯一工具。还有许多其他工具和技术，我们无法涵盖（或者由于本书中使用的工具的具体限制，它们不适合）。这些主题在下一节中提到，并在章节末尾的*进一步阅读*部分提供了额外的链接。
- en: Test-driven development
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: Given the fact that the title of this chapter starts with the word *debugging,*
    it only seems appropriate to mention the ideal way to *debug* code is to not write
    buggy code in the first place. Unit testing isn't a single piece of software,
    but a component of **Test-Driven Development** (**TDD**)—a development methodology
    that inverts the way embedded engineers traditionally go about developing their
    systems.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章的标题以单词 *debugging* 开头，因此提及理想情况下不编写有缺陷代码的调试方式似乎是合适的。单元测试不是一款单独的软件，而是 **测试驱动开发**（**TDD**）——一种开发方法，它颠倒了嵌入式工程师传统上开发系统的方式。
- en: Instead of writing a bunch of code that doesn't work and then debugging it,
    test-driven development starts out by writing tests. After tests are written,
    production code is written until the tests pass. This approach tends to lead to
    code that is both testable and easily refactored. Since individual functions are
    tested using this approach, the resulting production code is much less tied to
    the underlying hardware (since it isn't easy to test code tied to real hardware).
    Forcing tests to be written at this level tends to lead to loosely coupled architecture,
    which is discussed in [Chapter 13](e728e173-c9b2-4bb8-91c8-ed348ccf9518.xhtml),
    *Creating Loose Coupling with Queues*. Using the techniques in [Chapter 13](e728e173-c9b2-4bb8-91c8-ed348ccf9518.xhtml),
    *Creating Loose Coupling with Queues, *works very well in conjunction with unit
    testing and TDD.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 与编写大量无效代码然后进行调试不同，测试驱动开发从编写测试开始。编写测试后，再编写生产代码，直到测试通过。这种方法往往导致代码既可测试又易于重构。由于使用这种方法对单个函数进行测试，因此生成的生产代码与底层硬件的关联性要小得多（因为测试与真实硬件关联的代码并不容易）。强制在这一级别编写测试往往会导致松散耦合的架构，这在第
    13 章[使用队列创建松散耦合](e728e173-c9b2-4bb8-91c8-ed348ccf9518.xhtml)中有详细讨论。第 13 章中提到的[使用队列创建松散耦合](e728e173-c9b2-4bb8-91c8-ed348ccf9518.xhtml)的技术与单元测试和
    TDD 结合使用效果非常好。
- en: Generally, TDD isn't as popular in embedded systems. But if it is something
    you're interested in learning more about, check out a book written specifically
    on the topic—*Test Driven Development for Embedded C* by J*ames Grenning*.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，TDD 在嵌入式系统中并不那么受欢迎。但如果你对这个话题感兴趣并想了解更多，可以查看专门针对该主题编写的书籍——*嵌入式 C 的测试驱动开发*（Test
    Driven Development for Embedded C）由 J*ames Grenning 撰写。
- en: Static analysis
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态分析
- en: Static analysis is another way of reducing the number of bugs that creep into
    a code base. *Static* refers to the fact that the code doesn't need to be executing
    for this analysis to take place. A static analyzer looks for common programming
    errors that are syntactically correct (for example, they compile) but are *likely*
    to create buggy code (that is, out-of-bounds array access, and so on) and provides
    relevant warnings.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析是减少代码库中渗入的缺陷数量的另一种方法。“静态”一词指的是代码不需要执行即可进行此分析。静态分析器寻找常见的编程错误，这些错误在语法上是正确的（例如，它们可以编译），但**可能**会生成有缺陷的代码（例如，越界数组访问等），并提供相关的警告。
- en: There are many commercially available packages for static analysis, as well
    as some that are freely available. Cppcheck is included in STM32CubeIDE (simply
    right-click on a project and select Run C/C++ Code Analysis). A link to a **Free
    Open Source Software** (**FOSS**) static analyzer from the Clang project is included
    at the end of this chapter. PVS-Studio Analyzer is an example of a commercial
    package that can be used freely for non-commercial projects.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 市面上有许多静态分析的商业软件包，以及一些免费提供的软件。Cppcheck 包含在 STM32CubeIDE 中（只需在项目上右键单击并选择运行 C/C++
    代码分析）。本章末尾包含了一个来自 Clang 项目的 **免费开源软件**（**FOSS**）静态分析器的链接。PVS-Studio 分析器是商业软件包的一个例子，它可以免费用于非商业项目。
- en: Percepio Tracealyzer
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Percepio Tracealyzer
- en: Percepio Tracealyzer is a tool similar to SEGGER SystemView in that it helps
    the developer to visualize system execution. Tracealyzer takes less effort to
    set up out of the box than SystemView and provides a more aesthetically focused
    user experience than SystemView. However, since it is supplied by a different
    company, the cost of the software is not included with the purchase of a SEGGER
    debug probe. You can find out more about Tracealyzer at [https://percepio.com/tracealyzer/](https://percepio.com/tracealyzer/).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Percepio Tracealyzer 是一款类似于 SEGGER SystemView 的工具，它帮助开发者可视化系统执行。Tracealyzer
    的设置比 SystemView 更简单，并且提供了比 SystemView 更注重美学的用户体验。然而，由于它由不同的公司提供，因此软件的成本不包括 SEGGER
    调试探头的购买。您可以在[https://percepio.com/tracealyzer/](https://percepio.com/tracealyzer/)了解更多关于
    Tracealyzer 的信息。
- en: Traditional testing equipment
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统测试设备
- en: Before all of the attractive pieces of software for visualizing RTOS behavior
    on a computer screen existed, this task would fall to more traditional test equipment.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有用于在计算机屏幕上可视化RTOS行为的软件出现之前，这项任务将落到更传统的测试设备上。
- en: Logic analyzers have been around since MCUs first came into existence and are
    still among the most versatile tools an embedded system engineer can have in their
    kit. With a logic analyzer, the timing can be directly measured between when an
    input enters the system and when an output is provided by the system, as well
    as the timing between each of the tasks. Looking at the raw low-level signals
    going in and out of an MCU provides a level of visibility and gut feel for when
    something isn't right in a way that hexadecimal digits on a screen simply can't.
    Another advantage of habitually instrumenting at the hardware level - glitches
    in timing and other erratic behaviors are often noticed without directly looking
    for them.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑分析仪自MCU首次出现以来就一直存在，并且仍然是嵌入式系统工程师工具箱中最通用的工具之一。使用逻辑分析仪，可以直接测量输入进入系统时和系统提供输出时的时间，以及每个任务之间的时间。查看进出MCU的原始低级信号提供了一种对系统中的问题时什么不对的直观感受，这是屏幕上的十六进制数字所无法提供的。习惯性地在硬件级别进行仪器化还有另一个优点——时序和其它异常行为往往在直接寻找之前就能被发现。
- en: Other tools you'll want to acquire if you're just starting out with embedded
    systems include a handheld **digital multi-meter** (**DMM**) and oscilloscope
    for measuring analog signals.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您刚开始接触嵌入式系统，您还希望获得手持式**数字多用表**（**DMM**）和示波器来测量模拟信号。
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've covered why having access to excellent debugging tools
    is important. The exact tools we'll be using to analyze system behavior (SEGGER
    Ozone and SystemView) have been introduced. You've also been guided through how
    to get these tools set up for use with future projects. Toward the end, we touched
    on a few other tools that won't be covered in this book just to raise awareness
    of them.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了为什么拥有优秀的调试工具很重要。我们将用于分析系统行为的精确工具（SEGGER Ozone和SystemView）已经介绍。您也被指导如何设置这些工具以供未来项目使用。在最后，我们简要提到了一些本书不会涵盖的其他工具，只是为了提高对这些工具的认识。
- en: Now that we've covered MCU and IDE selection, and we have all of our tooling
    squared away, we have enough background to get into the real meat of RTOS application
    development.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了MCU和IDE的选择，并且我们已经将所有工具整理妥当，我们有了足够的背景知识来进入RTOS应用开发的真正核心。
- en: Using this toolset will help you gain an in-depth understanding of RTOS behavior
    and programming as we dive into working examples in the upcoming chapters. You'll
    also be able to use this same tooling to create high-performing, custom real-time
    applications in the future.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个工具集将帮助您在深入探讨即将到来的章节中的工作示例时，对RTOS的行为和编程有更深入的理解。您还将能够使用这个相同的工具集在未来创建高性能的定制实时应用程序。
- en: In the next chapter, we'll get started with writing some code and go into more
    detail regarding the FreeRTOS scheduler.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始编写一些代码，并更详细地介绍FreeRTOS调度器。
- en: Questions
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: J-Link hardware must be purchased to use the tools in this book.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用本书中的工具需要购买J-Link硬件。
- en: 'True'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: The only way to evaluate the effectiveness of a real-time system is to wait
    and see whether something breaks because a deadline was missed.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估实时系统有效性的唯一方法就是等待并看看是否因为错过截止日期而出现问题。
- en: 'True'
  id: totrans-222
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: Since RTOSes have one stack per task, they are impossible to debug using a debugger
    since only the main system stack is visible.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于RTOS每个任务都有一个堆栈，因此使用调试器进行调试是不可能的，因为只有主系统堆栈是可见的。
- en: 'True'
  id: totrans-225
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: The only way to ensure a system is completely functional is to write all of
    the code and then debug it all at once at the end of the project.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保系统完全功能的方法是在项目结束时一次性编写所有代码并调试。
- en: 'True'
  id: totrans-228
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: What is the style of testing called where each individual module is tested?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被称为每个单独模块都进行测试的测试风格是什么？
- en: Unit testing
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Integration testing
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: System testing
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统测试
- en: Black box testing
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黑盒测试
- en: What is the term given for writing tests before developing production code?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开发生产代码之前编写测试的术语是什么？
- en: Further reading
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Test-Driven Development for Embedded C* by *James Grenning*'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《嵌入式C的测试驱动开发》*James Grenning*著
- en: SEGGER Ozone manual (UM08025): [https://www.segger.com/downloads/jlink/UM08025](https://www.segger.com/downloads/jlink/UM08025)
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SEGGER Ozone 手册 (UM08025): [https://www.segger.com/downloads/jlink/UM08025](https://www.segger.com/downloads/jlink/UM08025)'
- en: 'SEGGER SystemView manual (UM08027): [https://www.segger.com/downloads/jlink/UM08027](https://www.segger.com/downloads/jlink/UM08027)'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SEGGER SystemView 手册 (UM08027): [https://www.segger.com/downloads/jlink/UM08027](https://www.segger.com/downloads/jlink/UM08027)'
- en: Clang Static Analyzer: [https://clang-analyzer.llvm.org](https://clang-analyzer.llvm.org)
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Clang 静态分析器: [https://clang-analyzer.llvm.org](https://clang-analyzer.llvm.org)'
- en: PVS-Studio Analyzer: [https://www.viva64.com/en/pvs-studio/](https://www.viva64.com/en/pvs-studio/)
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'PVS-Studio 分析器: [https://www.viva64.com/en/pvs-studio/](https://www.viva64.com/en/pvs-studio/)'
