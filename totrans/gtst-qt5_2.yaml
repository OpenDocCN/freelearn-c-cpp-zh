- en: Creating Widgets and Layouts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建窗口小部件和布局
- en: In this chapter, we shall take a look at what widgets are and the various kinds
    that are available for creating GUIs. For most GUI applications that you will
    write, Qt is laden with sufficient widgets to implement it. Coupled with widgets
    are layout classes, which help us to arrange and position the widgets for better
    appeal.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨窗口小部件是什么以及可用于创建 GUI 的各种类型。对于你将要编写的绝大多数 GUI 应用程序，Qt 都提供了足够的窗口小部件来实现它。与窗口小部件一起使用的布局类帮助我们安排和定位窗口小部件，以使其更具吸引力。
- en: 'By the end of this chapter, you should be aware of the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该了解以下内容：
- en: Understand and know how to use widgets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解并知道如何使用窗口小部件
- en: Know the classes needed to lay out widgets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解需要用于布局的类
- en: Widgets
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 窗口小部件
- en: '**Widgets** are the graphical components with which we construct user interfaces.
    A familiar example of such a component is a textbox. This is the component that
    is used to capture our email address or last and first names on forms in a GUI
    application.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**窗口小部件**是我们构建用户界面的图形组件。一个熟悉的例子是文本框。这是在 GUI 应用程序表单中用来捕获我们的电子邮件地址或姓氏和名字的组件。'
- en: 'There are a few critical points to note regarding widgets in Qt:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Qt 中关于窗口小部件有几个关键点需要注意：
- en: Information is passed to widgets by way of events. For a textbox, an example
    of an event could be when a user clicks within the textbox or when the `return`
    key has been pressed while a textbox cursor is blinking.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息通过事件传递给窗口小部件。对于文本框，一个事件示例可能是用户在文本框内点击或当文本框光标闪烁时按下 `return` 键。
- en: Every widget can have a parent widget or children widgets.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个窗口小部件都可以有一个父窗口小部件或子窗口小部件。
- en: Widgets that do not have a parent widget become a window when the `show()` function
    is called on them. Such a widget will be enclosed in a window with buttons to
    close, maximize, and minimize it.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有父窗口小部件的窗口小部件在调用`show()`函数时将变成一个窗口。这样的窗口小部件将被包含在一个带有关闭、最大化、最小化按钮的窗口中。
- en: A child widget is displayed within its parent widget.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子窗口小部件在其父窗口小部件内显示。
- en: 'Qt organizes its classes with heavy use of inheritance, and it is very important
    to have a good grasp of this. Consider the following diagram:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 通过大量使用继承来组织其类，因此掌握这一点非常重要。考虑以下图表：
- en: '![](img/992ba93e-5c34-4cfa-b166-bb98ef7c8ca0.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/992ba93e-5c34-4cfa-b166-bb98ef7c8ca0.png)'
- en: At the very top of the hierarchy is the **QObject**. A lot of classes inherit
    from the **QObject** class. The **QObject** class also contains the mechanisms
    of signals and slots and event management, among other things.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在层次结构的顶部是 **QObject**。许多类都继承自 **QObject** 类。**QObject** 类还包含信号和槽以及事件管理的机制，等等。
- en: Furthermore, widgets that share common behavior are grouped together. **QCheckBox**,
    **QPushButton**, and **QRadioButton** are all buttons of the same kind and thus
    inherit from **QAbstractButton**, which holds properties and functions that are
    shared by all buttons. This principle also applies to **QAbstractScrollArea**
    and its children, **QGraphicsView** and **QTextEdit**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，具有共同行为的窗口小部件被分组在一起。**QCheckBox**、**QPushButton** 和 **QRadioButton** 都是同一类型的按钮，因此它们继承自
    **QAbstractButton**，该类包含所有按钮共享的属性和函数。这一原则也适用于 **QAbstractScrollArea** 及其子类，**QGraphicsView**
    和 **QTextEdit**。
- en: To put into practice some of what we have just learned, let's create a simple
    Qt program with only one widget.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们刚刚学到的一些知识付诸实践，让我们创建一个只有一个窗口小部件的简单 Qt 程序。
- en: This Qt application displays only one button. Open a text file and name it how
    you want with the suffix `.cpp`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Qt 应用程序只显示一个按钮。打开一个文本文件，并给它起一个你想要的名称，后缀为 `.cpp`。
- en: Most of the examples will require that you create a new folder where the source
    code will be stored. This will allow for easy compilation of the program as a
    project.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数示例将需要你创建一个新的文件夹，源代码将存储在那里。这将允许你轻松地将程序作为项目编译。
- en: 'Insert the following lines of codes. Create a new folder and move the `.cpp` file
    into it:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 插入以下代码行。创建一个新的文件夹，并将 `.cpp` 文件移动到其中：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The purpose of this application is to show how a widget without a parent object
    becomes the main window when executed. The button that will be created will include
    an icon and a tooltip.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本应用程序的目的是展示一个没有父对象窗口小部件在执行时如何成为主窗口。将要创建的按钮将包括一个图标和工具提示。
- en: For starters, this application looks similar to the one we wrote at the tail
    end of [Chapter 1](a157893d-287f-42c4-8166-a7d414e09035.xhtml), *Introducing Qt
    5*. In this application, a button named `myButton` is declared. An instance of
    `QIcon` is passed as the first argument to the default constructor of `QPushButton`.
    This reads the file named `filesaveas.png` (which, for now, should be in the same
    folder as the source code file on GitHub). The text `"Push Me"` is passed as the
    second argument. This text will be displayed on the button.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这个应用程序看起来与我们写在[第1章](a157893d-287f-42c4-8166-a7d414e09035.xhtml)结尾的部分相似，即*介绍Qt
    5*。在这个应用程序中，声明了一个名为`myButton`的按钮。将`QIcon`的一个实例作为`QPushButton`默认构造函数的第一个参数。这读取名为`filesaveas.png`的文件（目前应该与GitHub上的源代码文件在同一文件夹中）。将文本`"Push
    Me"`作为第二个参数传递。这段文本将显示在按钮上。
- en: The next line, `myButton.setToolTip("Click this to turn back the hands of time");`,
    is used to set a tooltip on the button. A tooltip is a piece of text or a message
    that is displayed when you rest the mouse cursor over a widget. It usually holds
    extra or explanatory information over and above what the widget might be displaying.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个行，`myButton.setToolTip("Click this to turn back the hands of time");`，用于设置按钮的工具提示。工具提示是一段文本或消息，当你在小部件上悬停鼠标光标时显示。它通常包含比小部件可能显示的额外或解释性信息。
- en: Lastly, we call the `show()` function on the `myButton` object to unhide it
    and draw it to the screen. In this application, we only have one widget, `QPushButton`.
    What could be the parent of this widget? Well, if unspecified, the parent defaults
    to `NULL`, which tells Qt that the widget is without a parent. When displaying
    such a widget, it will be enclosed in a window on account of this reasoning.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`myButton`对象上调用`show()`函数来显示它并在屏幕上绘制。在这个应用程序中，我们只有一个小部件，`QPushButton`。这个小部件的父级是什么？好吧，如果没有指定，父级默认为`NULL`，这告诉Qt该小部件没有父级。由于这个原因，显示此类小部件时，它将被包含在一个窗口中。
- en: 'Save the file and run the following commands to compile your application. Change
    directory to the new folder you created that houses the `.cpp` file created:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并运行以下命令以编译你的应用程序。将目录更改到包含`.cpp`文件的新文件夹：
- en: The commands that should be run in a Terminal or on the command line begin with
    a `%` sign, which represents the prompt on the Terminal. Depending on the setup
    of your Terminal, this might be slightly different, but the command is all the
    characters after the `%` sign.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 应在终端或命令行中运行的命令以`%`符号开头，它代表终端上的提示符。根据你的终端设置，这可能会略有不同，但命令是`%`符号后面的所有字符。
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: From the name of the `.pro` file, it tells us that the name of the folder where
    the `.cpp` file is located is called `qbutton`. This name should, therefore, change
    to whichever folder name the `.cpp` file is located in when you issue the preceding
    command.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从`.pro`文件的名字来看，它告诉我们`.cpp`文件所在的文件夹名为`qbutton`。因此，当你发出前面的命令时，这个名称应该更改为`.cpp`文件所在的文件夹名。
- en: 'Now, remember to add the following line to the `qbutton.pro` beneath `INCLUDEPATH
    += .`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请记住在`qbutton.pro`文件中在`INCLUDEPATH += .`下面添加以下行：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Continue with the following commands:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 继续以下命令：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run the application from the command line according to an issue:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 根据问题，从命令行运行应用程序：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You should obtain the following screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该获得以下截图：
- en: '![](img/9f1f9558-204d-4049-9512-730bfa11429f.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9f1f9558-204d-4049-9512-730bfa11429f.png)'
- en: 'The preceding screenshot shows what you will see when the program is run for
    the first time:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个截图显示了程序首次运行时你会看到的内容：
- en: '![](img/da9815e3-7d1d-44d2-9d42-0a610aa3d853.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/da9815e3-7d1d-44d2-9d42-0a610aa3d853.png)'
- en: The tooltip that was specified within the code is displayed when we rest our
    cursor on the button, as seen in the preceding screenshot.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将光标放在按钮上时，会显示在代码中指定的工具提示，如前一个截图所示。
- en: The button also shows the image for those cases when you want to add an image
    to a button in order to improve the intuitiveness of a UI.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮还显示了那些你想在按钮上添加图像以增强UI直观性的情况。
- en: 'A few observations worthy of note are the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些值得注意的观察结果：
- en: The `setToolTip()` function is not found in the `QPushButton` class. Instead,
    it is one of the functions that belongs to the `QWidget` class.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`QPushButton`类中找不到`setToolTip()`函数。相反，它是属于`QWidget`类的一组函数之一。
- en: This highlights the usefulness that classes get by means of inheritance.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这突出了通过继承方式类获得的有用性。
- en: The property or member of the `QWiget` class that stores the value of the tooltip
    is `toolTip`.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储工具提示值的`QWiget`类的属性或成员是`toolTip`。
- en: To cap off this section on widgets, let's customize a `QLabel` and display it.
    This time, an instance of `QLabel` will have its font changed and shall display
    a longer text than usual.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束关于控件的这一部分，让我们自定义一个`QLabel`并显示它。这次，`QLabel`的字体将被更改，并且将显示比通常更长的文本。
- en: 'Create a file named `qlabel_long_text.cpp` in a newly created folder and insert
    the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在新创建的文件夹中创建一个名为`qlabel_long_text.cpp`的文件，并插入以下代码：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The structure of our Qt programs has not changed that much. The first three
    (3) lines have the `include` directives adding the headers for the classes we
    will be using.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们Qt程序的结构并没有发生太大的变化。前三行包含`include`指令，添加了我们将要使用的类的头文件。
- en: As usual, the arguments to the `main()` function are passed to `app()`. The
    `message` variable is a `QString` object that holds a long string. `QString` is
    the class used when working with strings. It has a host of functionalities not
    available in C++ string.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，将`main()`函数的参数传递给`app()`。`message`变量是一个`QString`对象，它包含一个长字符串。`QString`是在处理字符串时使用的类。它具有许多在C++字符串中不可用的功能。
- en: An instance of `QLabel` is created, `label`, and `message` is passed to this.
    To change the style by which the label string is displayed, we pass an instance
    of `QFont` to the `setFont` function. We select the font style *Comic Sans MS*,
    with a point size of *18*, to the constructor of `QFont`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个`QLabel`实例，命名为`label`，并将`message`传递给它。为了改变标签字符串的显示样式，我们向`setFont`函数传递了一个`QFont`实例。我们选择了字体样式*Comic
    Sans MS*，字号为*18*，传递给`QFont`的构造函数。
- en: To align all the text in the middle, we call the `setAlignment` function on
    the `label` object and pass the `Qt::AlignCenter` constant.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使所有文本居中，我们在`label`对象上调用`setAlignment`函数，并传递`Qt::AlignCenter`常量。
- en: Lastly, we display the widget by calling the `show` function on the `label`
    object.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过在`label`对象上调用`show`函数来显示控件。
- en: 'As usual, we shall issue the following codes on the command line to compile
    and run this program:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，我们将在命令行上输入以下代码来编译和运行此程序：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Remember to add `QT += widgets` to the `.pro` file.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在`.pro`文件中添加`QT += widgets`。
- en: 'The output of the program appears as follows. All the text on the lines are
    centered in the middle:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下。所有文本行都居中显示：
- en: '![](img/59ee3589-ee41-4b91-bf76-22e89706f327.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/59ee3589-ee41-4b91-bf76-22e89706f327.png)'
- en: Once again, the only widget within the `label` application becomes the main
    window because it has no parent object associated with it. Secondly, the widget
    becomes a window because the `show()` method was called on `label`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`label`应用程序中唯一的控件成为主窗口，因为它没有与之关联的父对象。其次，控件成为窗口，因为调用了`label`上的`show()`方法。
- en: Layouts
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局
- en: Up to this point, we have been creating applications that only have one widget
    serving as the main component and, by extension, a window too. However, GUI applications
    are usually made up of several widgets that come together to communicate a process
    to the user. One way in which we can make use of multiple widgets is to use layouts
    to serve as the canvas into which we insert our widgets.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们创建的应用程序只有一个控件作为主要组件，并且由此扩展，也是一个窗口。然而，GUI应用程序通常由多个控件组成，这些控件共同向用户传达一个过程。我们可以利用多个控件的一种方法是通过使用布局作为画布，我们将控件插入其中。
- en: 'Consider the following class inheritance diagram:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下类继承关系图：
- en: '![](img/f3ddb47b-3a07-4249-a70e-7db974f170be.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f3ddb47b-3a07-4249-a70e-7db974f170be.png)'
- en: It is important to consider the classes used in laying out widgets. As usual,
    the top class from which the `QLayout` abstract class inherits is `QObject`. Also, `QLayout`
    makes use of multiple inheritances by inheriting from `QLayoutItem`. The concrete
    classes here are `QBoxLayout`, `QFormLayout`, `QGridLayout`, and `QStackedLayout`.
    `QHBoxLayout` and `QVBoxLayout` further refine what the `QBoxLayout` class is
    by adding orientation to how the widgets within a layout might be arranged.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在布局控件时考虑使用的类是很重要的。通常，从`QLayout`抽象类继承的顶级类是`QObject`。此外，`QLayout`通过从`QLayoutItem`继承实现了多重继承。这里的具体类有`QBoxLayout`、`QFormLayout`、`QGridLayout`和`QStackedLayout`。`QHBoxLayout`和`QVBoxLayout`通过添加布局内控件可能排列的方向来进一步细化`QBoxLayout`类。
- en: 'The following table provides a brief description of what the major layouts
    do:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格简要描述了主要布局的功能：
- en: '| **Layout class** | **Description** |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **布局类** | **描述** |'
- en: '| `QFormLayout` | The `QFormLayout` class ([https://doc.qt.io/qt-5/qformlayout.html](https://doc.qt.io/qt-5/qformlayout.html))
    manages forms of input widgets and their associated labels. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `QFormLayout` | `QFormLayout` 类 ([https://doc.qt.io/qt-5/qformlayout.html](https://doc.qt.io/qt-5/qformlayout.html))
    管理输入小部件及其关联的标签。|'
- en: '| `QGridLayout` | The `QGridLayout` class ([https://doc.qt.io/qt-5/qgridlayout.html](https://doc.qt.io/qt-5/qgridlayout.html))
    lays out widgets in a grid. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `QGridLayout` | `QGridLayout` 类 ([https://doc.qt.io/qt-5/qgridlayout.html](https://doc.qt.io/qt-5/qgridlayout.html))
    以网格形式排列小部件。|'
- en: '| `QStackedLayout` | The `QStackedLayout` class ([https://doc.qt.io/qt-5/qstackedlayout.html](https://doc.qt.io/qt-5/qstackedlayout.html))
    provides a stack of widgets where only one widget is visible at a time. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `QStackedLayout` | `QStackedLayout` 类 ([https://doc.qt.io/qt-5/qstackedlayout.html](https://doc.qt.io/qt-5/qstackedlayout.html))
    提供了一个小部件堆栈，一次只显示一个小部件。|'
- en: '| `QVBoxLayout` | The `QVBoxLayout` class ([https://doc.qt.io/qt-5/qvboxlayout.html](https://doc.qt.io/qt-5/qvboxlayout.html))
    lines up widgets vertically. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `QVBoxLayout` | `QVBoxLayout` 类 ([https://doc.qt.io/qt-5/qvboxlayout.html](https://doc.qt.io/qt-5/qvboxlayout.html))
    将小部件垂直排列。|'
- en: '| `QHBoxLayout` | The `QHBoxLayout` class ([https://doc.qt.io/qt-5/qhboxlayout.html](https://doc.qt.io/qt-5/qhboxlayout.html))
    lines up widgets horizontally. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `QHBoxLayout` | `QHBoxLayout` 类 ([https://doc.qt.io/qt-5/qhboxlayout.html](https://doc.qt.io/qt-5/qhboxlayout.html))
    将小部件水平排列。|'
- en: 'We need to lay out the widgets for two main reasons:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要布局小部件有两个主要原因：
- en: To allow us to display more than one widget.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了允许我们显示多个小部件。
- en: To present the many widgets in our interface nicely and intuitively to allow
    the UI to be useful. Not all GUIs allows users to do their work well. Bad layout
    can confuse the users of a system and make them struggle to use it properly.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了将我们界面中的许多小部件以良好且直观的方式呈现，以便使 UI 有用。并非所有 GUI 都允许用户很好地完成工作。糟糕的布局可能会让系统用户感到困惑，并使他们难以正确使用。
- en: Let's create a simple program to illustrate how to use some of the layout classes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的程序来展示如何使用一些布局类。
- en: QGridLayout
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QGridLayout
- en: The `QGridLayout` is used to arrange widgets by specifying the number of rows
    and columns that will be filled up by multiple widgets. A grid-like structure
    mimics a table in that it has rows and columns and widgets are inserted as cells
    where a row and column meet.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`QGridLayout` 通过指定将被多个小部件填满的行数和列数来排列小部件。类似于表格的网格结构，它有行和列，小部件被插入到行和列相交的单元格中。'
- en: 'Create a new folder and, using of any editor, create a file named `main.cpp`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，并使用任何编辑器创建一个名为 `main.cpp` 的文件：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The aim of the program is to illustrate how to use a layout object. To fill
    up the layout, other widgets will be discussed too.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的目的是展示如何使用布局对象。为了填充布局，还将讨论其他小部件。
- en: In the preceding code, `*window` is an instance of `QWidget`. For now, keep
    this object in to see and how we shall turn it into a window.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`*window` 是 `QWidget` 的一个实例。目前，请保留此对象以查看我们将如何将其转换为窗口。
- en: The widgets that we are going to insert into our layout are created thereafter,
    namely `name`, `firstnameLineEdit`, and `lastNameLineEdit`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要插入到布局中的小部件将在之后创建，即 `name`、`firstnameLineEdit` 和 `lastNameLineEdit`。
- en: Some prefer to name their variables by appending the name of the class that
    they are instantiating to it. The CamelCase naming scheme is being used here too.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者喜欢通过在其名称后附加他们实例化的类的名称来命名变量。这里也使用了驼峰命名法。
- en: '`QLineEdit` is essentially the class for creating textboxes. `QSpinbox` is
    a widget that allows for the selection of a value between a given range. In this
    case, `ageSpinBox->setRange(1, 100)` sets the range of possible values between
    `1` and `100`.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`QLineEdit` 是创建文本框的基本类。`QSpinbox` 是一个允许在给定范围内选择值的控件。在这种情况下，`ageSpinBox->setRange(1,
    100)` 设置了可能的值范围在 `1` 到 `100` 之间。'
- en: Next, we instantiate the `QComboBox` class to create a widget with drop-down
    values specified by a list of strings stored in `QStringList`. The list of strings,
    `employmentStatus`, is then passed to `employmentStatusComboBox` by calling its
    `addItems()` method. These will become the options that will be displayed when
    the widget is clicked.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实例化 `QComboBox` 类以创建一个具有由存储在 `QStringList` 中的字符串列表指定的下拉值的控件。然后，通过调用其 `addItems()`
    方法将字符串列表 `employmentStatus` 传递给 `employmentStatusComboBox`。这些将成为当控件被点击时显示的选项。
- en: 'Since we want to layout our widgets in a grid layout, we create an object from
    the `QGridLayout`, `*layout`. To add the widgets to the layout, the `addWIdget()`
    method is called and each time, the widget, along with two (2) numbers that specify
    the row and column where the widget is to be inserted is specified:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要以网格布局排列小部件，因此我们创建了一个`QGridLayout`对象，`*layout`。为了将小部件添加到布局中，我们调用`addWIdget()`方法，并且每次都指定小部件，以及两个（2）数字，这些数字指定了小部件要插入的行和列：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first widget to be inserted into the layout object is the label, `nameLabel`.
    This occupies the first row and first column of the grid. The first row is represented
    by the second parameter `0` while the first column is represented by `0`. This
    resolves to the selection of the first cell of the grid to keep `nameLabel`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先被插入到布局对象中的小部件是标签，`nameLabel`。它占据了网格的第一行和第一列。第一行由第二个参数`0`表示，而第一列由`0`表示。这对应于选择网格的第一个单元格以保留`nameLabel`。
- en: The second widget that is added to the layout is `firstNameLineEdit`. This widget
    will be inserted on the first row, marked by `0`, and on the second column marked
    by `1`. Next to this widget is added the `lastNameLineEdit` widget, also sitting
    on the same row, `0`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 被添加到布局中的第二个小部件是`firstNameLineEdit`。这个小部件将被插入到第一行，标记为`0`，以及第二列，标记为`1`。紧邻此小部件的是添加的`lastNameLineEdit`小部件，它也位于同一行，`0`。
- en: The `ageSpinBox` widget will be fixed on the second row marked by `1` and in
    the first column, marked by `0`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`ageSpinBox`小部件将被固定在第二行，标记为`1`，以及第一列，标记为`0`。'
- en: 'The `employmentStatusComboBox` widget is added to the `layout` object and further
    stretches out by specifying the `rowspan` with the last `(1, 2)` arguments that
    are passed along:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`employmentStatusComboBox`小部件被添加到`layout`对象中，并通过指定最后一个`(1, 2)`参数进一步扩展：'
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `window` object is without a layout. To set the layout of the widget, call
    `setLayout` and pass in the layout object, which holds the other widgets.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`window`对象没有布局。为了设置小部件的布局，调用`setLayout`并传入包含其他小部件的布局对象。'
- en: Because `window`, which is basically a widget, has no parent object, it will
    become a window when we call the `show()` method on it. Also, all the widgets
    that were added to the layout object via the `addWidget()` method are children
    of the `layout` object.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`window`（基本上是一个小部件）没有父对象，因此当我们对其调用`show()`方法时，它将成为一个窗口。此外，通过`addWidget()`方法添加到布局对象的所有小部件都是`layout`对象的子对象。
- en: Run the project by issuing the commands to create the project and compiling
    on the command line.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在命令行中发出创建项目和编译的命令来运行项目。
- en: 'You should see this on successful compilation:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功编译后，你应该会看到以下内容：
- en: '![](img/723bdba6-e78d-41f7-a4e7-52cc22fe88a6.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/723bdba6-e78d-41f7-a4e7-52cc22fe88a6.png)'
- en: Notice how the drop-down widget stretches to fill the third column. The placement
    of the widgets conforms to how we laid out the widgets as we called `addWidget()`.
    Experiment by clicking on the `ageSpinBox` to observe how it behaves.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意下拉小部件如何扩展以填充第三列。小部件的放置符合我们调用`addWidget()`时设置的布局。
- en: In the next section, we shall take a look at a useful layout class called `QFormLayout`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看一个有用的布局类，称为`QFormLayout`。
- en: QFormLayout
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QFormLayout
- en: For those instances when you simply need to place a number of widgets together
    in a two-column layout, the `QFormLayout` is useful. You may choose to construct
    a form using `QGridLayout`, but for form presentation, `QFormLayout` is most suited.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些只需要在两列布局中将多个小部件放在一起的情况，`QFormLayout`非常有用。你可以选择使用`QGridLayout`构建表单，但对于表单的展示，`QFormLayout`最为合适。
- en: 'Take, for instance, the following code. It illustrates a form that has labels
    in the first column and the actual control for taking user input in the second
    column:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下代码为例。它展示了一个表单，其中第一列包含标签，第二列包含用于接收用户输入的实际控件：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The code should look familiar by now. We instantiate objects of the various
    widgets we want to show in the form. Thereafter, the layout is created:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，代码应该看起来很熟悉了。我们实例化了在表单中想要显示的各种小部件的对象。然后，创建布局：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'An instance of `QFormLayout` is created. Anytime we want to add a widget to
    the layout, `*personalInformformLayout`, we shall call the `addRow()` method,
    pass a string representing the label and finally the widget we want to align with
    the label:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个`QFormLayout`实例。任何我们想要将小部件添加到布局中，`*personalInformformLayout`，我们都会调用`addRow()`方法，传递一个表示标签的字符串，最后是我们要与标签对齐的小部件：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`"First Name: "` is the label and the widget here is `firstNameLineEdit`.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`"First Name: "` 是标签，而这里的部件是 `firstNameLineEdit`。'
- en: 'The other widgets are added to the layout like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 其他部件以这种方式添加到布局中：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`personalInfoformLayout` is then passed to the `setLayout()` method of the
    `QWidget` instance. This means that the layout for the application window, `window`,
    is `personalInfoformLayout`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将 `personalInfoformLayout` 传递给 `QWidget` 实例的 `setLayout()` 方法。这意味着应用程序窗口
    `window` 的布局是 `personalInfoformLayout`。
- en: Remember that the `QWidget` instance, `window`, will become the main window
    of the application since its `show()` method is called.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`QWidget` 实例 `window` 将成为应用程序的主窗口，因为它的 `show()` 方法被调用。
- en: '`QForm` eliminates the need to specify columns and rows by giving us an easy
    way to add a row to our layout, and each time we do so, we can specify the label
    and the widget we want displayed.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`QForm` 通过提供一种简单的方式来添加行到我们的布局中，消除了指定列和行的需要，每次我们这样做时，我们都可以指定要显示的标签和部件。'
- en: 'You should see this output when you compile and run the project:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编译并运行项目时，你应该看到以下输出：
- en: '![](img/a9a274fc-eae8-472f-ab2d-ef8d3f985723.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a9a274fc-eae8-472f-ab2d-ef8d3f985723.png)'
- en: The preceding screenshot shows how widgets are aligned in those layouts. A form
    is presented in a question-and-answer manner. The labels are usually on the left-hand
    side while the widgets that take the user input are on the right-hand side.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图显示了部件在这些布局中的对齐方式。表单以问答方式呈现。标签通常位于左侧，而接收用户输入的部件位于右侧。
- en: Layouts with direction
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带方向的布局
- en: There are layouts that provide direction of growth when widgets are added to
    them. There are instances where we want to align all widgets within a layout horizontally
    or vertically.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些布局在添加部件时提供了增长方向。有些情况下，我们希望将布局中的所有部件水平或垂直对齐。
- en: The `QHBoxLayout` and `QVBoxLayout` classes provide this functionality.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`QHBoxLayout` 和 `QVBoxLayout` 类提供了这种功能。'
- en: QVBoxLayout
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QVBoxLayout
- en: In a `QVBoxLayout` layout, widgets are aligned vertically and they are packed
    in the layout from top to bottom.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `QVBoxLayout` 布局中，部件是垂直对齐的，并且从上到下打包在布局中。
- en: 'Consider the following diagram:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下图示：
- en: '![](img/46430e28-a761-40e8-a132-f87e584a5ac4.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/46430e28-a761-40e8-a132-f87e584a5ac4.png)'
- en: For `QVBoxLayout`, the arrow gives the direction of growth in which the widgets
    are added to the layout. The first widget, **widget 1**, will occupy the top of
    the layout, while the last call to `addWidget()` will make **widget 5** occupy
    the bottom of the layout.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `QVBoxLayout`，箭头指示部件添加到布局中的增长方向。第一个部件 **widget 1** 将占据布局的顶部，而 `addWidget()`
    的最后一次调用将使 **widget 5** 占据布局的底部。
- en: 'To illustrate how to use the `QVBoxLayout`, consider the following program:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要说明如何使用 `QVBoxLayout`，考虑以下程序：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In previous examples, we indicated the reason why we create an instance of `QWidget`.
    Two labels are created with the strings `"Username"` and `"Password"`. A textbox,
    `QLineEdit` instance is also created to receive both username and password input.
    On the `passwordLineEdit` object, the `setEchoMode()` method is passed the constant
    `QLineEdit::Password` that masks the input of that textbox and replaces it with
    dots to prevent the characters that are typed from being readable.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们说明了创建 `QWidget` 实例的原因。创建了两个带有字符串 `"Username"` 和 `"Password"` 的标签。还创建了一个用于接收用户名和密码输入的文本框，`QLineEdit`
    实例。在 `passwordLineEdit` 对象上，通过传递常量 `QLineEdit::Password` 给 `setEchoMode()` 方法来隐藏该文本框的输入，并用点替换以防止输入的字符可读。
- en: A placeholder text within `passwordLineEdit` is set via the `setPlaceholderText()`
    method. The placeholder text gives further information about the purpose of the
    textbox.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `setPlaceholderText()` 方法设置 `passwordLineEdit` 中的占位文本。占位文本提供了关于文本框用途的更多信息。
- en: Two push buttons are also created, `button1` and `button2`. An instance of `QVBoxLayout`
    is created. To add widgets to the layout, the `addWidget()` method is called and
    passed the specific widget. The very first widget passed to `addWidget` will appear
    on top when displayed. Likewise, the last widget added will show on the bottom,
    which in this case is `button2`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 同样创建了两个按钮，`button1` 和 `button2`。创建了一个 `QVBoxLayout` 的实例。为了向布局中添加小部件，调用 `addWidget()`
    方法并传递特定的部件。传递给 `addWidget` 的第一个部件将在显示时出现在顶部。同样，最后添加的部件将显示在底部，在这个例子中是 `button2`。
- en: The layout for the `window` widget instance is set by passing `layout` to `setLayout()`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 `layout` 传递给 `setLayout()` 方法来设置 `window` 小部件实例的布局。
- en: 'Finally, the `show()` method is called on the window. Compile the project and
    run it to see the output:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在窗口上调用 `show()` 方法。编译项目并运行它以查看输出：
- en: '![](img/e006132f-51fa-43ea-b774-7dc6e1a2eca3.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e006132f-51fa-43ea-b774-7dc6e1a2eca3.png)'
- en: In the preceding screenshot, we can see that the first widget that was added
    to the layout was the label, `label1`, while `button2` (with the text Register)
    was the last widget occupying the bottom.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到首先添加到布局中的小部件是标签 `label1`，而带有文本“注册”的 `button2` 是最后一个占据底部的小部件。
- en: QHBoxLayout
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QHBoxLayout
- en: The `QHBoxLayout` layout class is very similar in use to `QVBoxLayout`. Widgets
    are added to the layout by calling the `addWidget()` method.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`QHBoxLayout` 布局类在用法上与 `QVBoxLayout` 非常相似。通过调用 `addWidget()` 方法将小部件添加到布局中。'
- en: 'Consider the following diagram:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下图表：
- en: '![](img/6e64441d-3ad5-4118-afd3-1e923f9d64af.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6e64441d-3ad5-4118-afd3-1e923f9d64af.png)'
- en: The arrow in the diagram shows the direction in which widgets grow in number
    as they are added to a `QHBoxLayout`. The first widget added to this layout is
    **widget 1**, while **widget 3** is the last widget to be added to the layout.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图表中的箭头显示了小部件随着添加到 `QHBoxLayout` 而增长的方向。首先添加到这个布局中的是 **小部件 1**，而 **小部件 3** 是最后添加到布局中的小部件。
- en: 'A small application to allow users to enter a URL makes use of this layout
    type:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一个允许用户输入 URL 的小应用程序使用了这种布局类型：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A textbox or `QLineEdit` and button are created. A placeholder is set on the
    `QLineEdit` instance, `urlLineEdit`. To enable the placeholder to be seen, we
    stretch `urlLineEdit` by setting `setFixedWidth` to `400`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个文本框或 `QLineEdit` 和按钮。在 `QLineEdit` 实例 `urlLineEdit` 上设置了占位符。为了使占位符可见，我们通过将
    `setFixedWidth` 设置为 `400` 来拉伸 `urlLineEdit`。
- en: An instance of `QHBoxLayout` is created and passed to the `layout` pointer.
    The two widgets, `urlLineEdit` and `exportButton`, are added to the `layout` via
    the `addWidget()` method.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个 `QHBoxLayout` 实例并将其传递给 `layout` 指针。通过 `addWidget()` 方法将两个小部件 `urlLineEdit`
    和 `exportButton` 添加到 `layout` 中。
- en: The layout is set against `window` and the `show()` method of the window is
    called.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 布局被设置在 `window` 上，并调用了窗口的 `show()` 方法。
- en: 'Compile the application and run it. You should see the following output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 编译应用程序并运行它。你应该看到以下输出：
- en: '![](img/6b6a8c51-00cc-4aaf-9957-c096be8df11d.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6b6a8c51-00cc-4aaf-9957-c096be8df11d.png)'
- en: Refer to [Chapter 1](a157893d-287f-42c4-8166-a7d414e09035.xhtml), *Introducing
    Qt 5*, to compile the application. For easy compilation process, remember to create
    a new folder and add the `.cpp` file to it. As usual, the `.pro` file will need
    to be changed to include the widgets module.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[第1章](a157893d-287f-42c4-8166-a7d414e09035.xhtml)，*介绍 Qt 5*，以编译应用程序。为了简化编译过程，请记住创建一个新的文件夹并将
    `.cpp` 文件添加到其中。像往常一样，需要将 `.pro` 文件更改为包含小部件模块。
- en: Because the button was added to the layout after textbox, it appears accordingly,
    standing next to the textbox. If another widget had been added to the layout,
    it would also appear after the button, `exportButton`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因为按钮是在文本框之后添加到布局中的，所以它相应地显示，紧邻文本框。如果另一个小部件被添加到布局中，它也会出现在按钮 `exportButton` 之后。
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have looked at a number of widgets that are useful in creating
    GUI applications. The process of compilation remains the same. We also learned
    how to use layouts to present and arrange multiple widgets.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了在创建 GUI 应用程序时非常有用的许多小部件。编译过程保持不变。我们还学习了如何使用布局来展示和排列多个小部件。
- en: Up to this point, our application does not do anything. The `QPushButton` instances,
    when clicked, do nothing along with the other widgets that are action driven.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的应用程序没有任何功能。当点击 `QPushButton` 实例时，它们以及其他由动作驱动的其他小部件都不会执行任何操作。
- en: In the next chapter, we shall learn how to animate our application so that it
    responds to actions, thus making them useful.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使我们的应用程序能够响应用户操作，从而使它们变得有用。
