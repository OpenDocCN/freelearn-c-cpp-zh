- en: Troubleshooting Tips and Next Steps
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除技巧和下一步操作
- en: This chapter explores some of the most useful tips and tools for analyzing and
    troubleshooting an RTOS-based system. Periodically checking your system during
    development, as well as having a few standard steps to take when troubleshooting,
    can be a huge timesaver when evaluating a problematic system – things don't always
    go as planned! After we've covered some tips, we'll take a look at some of the
    next steps we can take to continue learning and sharpening our embedded programming skills.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了分析并解决基于RTOS的系统的一些最有用的技巧和工具。在开发过程中定期检查您的系统，以及在故障排除时采取一些标准步骤，可以在评估有问题的系统时节省大量时间——事情并不总是按计划进行！在介绍了一些技巧之后，我们将探讨我们可以采取的一些下一步行动，以继续学习和提高我们的嵌入式编程技能。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Useful tips
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有用技巧
- en: Using assertions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用断言
- en: Next steps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一步操作
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: No hardware or software is required for this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不需要硬件或软件。
- en: Useful tips
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用技巧
- en: Beginning development with an RTOS can be quite a shift if you've only used
    a *bare-metal* programming approach, especially if you're also shifting from 8-bit
    MCUs to a 32-bit MCU such as the STM32F7 we've been using in the examples throughout
    this book. Here are some tips that should help keep your project on track and
    help you work through issues when they come up.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只使用过*裸机*编程方法，那么开始使用RTOS可能会相当不同，尤其是如果您也从8位MCU切换到32位MCU，如本书中使用的STM32F7，那么更是如此。以下是一些可以帮助您保持项目进度并在出现问题时解决问题的技巧。
- en: Using tools to analyze threads
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用工具分析线程
- en: Being able to get a clear understanding of what all the threads in a system
    are doing is a huge help – for novices and experts alike. Tooling is especially
    helpful for this. Using a visualization tool such as SEGGER SystemView or Percepio
    Tracealyzer can be invaluable in understanding interactions between various tasks
    and interrupts in a system (see [Chapter 6](699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml),
    *Debugging Tools for Real-Time Systems*, for details).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 能够清楚地了解系统中所有线程正在做什么对新手和专家都有很大帮助。工具在这方面特别有用。使用可视化工具，如SEGGER SystemView或Percepio
    Tracealyzer，在理解系统中各种任务和中断之间的交互时可能非常有价值（有关详细信息，请参阅[第6章](699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml)，*实时系统调试工具*）。
- en: Having an RTOS-aware debugger is also a huge help since it allows us to stack
    the analysis of multiple tasks. This debugger can be part of your IDE or a standalone
    debugger such as SEGGER Ozone (see [Chapters 5](84a945dc-ff6c-4ec8-8b9c-84842db68a85.xhtml),
    *Selecting an IDE*, and [Chapter 6](699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml), *Debugging
    Tools for Real-Time Systems*).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个RTOS感知调试器也非常有帮助，因为它允许我们堆叠多个任务的分析。这个调试器可以是您IDE的一部分，也可以是像SEGGER Ozone这样的独立调试器（请参阅[第5章](84a945dc-ff6c-4ec8-8b9c-84842db68a85.xhtml)，*选择IDE*和[第6章](699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml)，*实时系统调试工具*）。
- en: Keeping an eye on memory usage
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关注内存使用
- en: Memory usage is a very important aspect to consider when using an RTOS. Unlike
    a super-loop with a single stack – which, along with the heap, would consume whatever
    RAM was *left over* – each FreeRTOS task's stack needs to be explicitly sized.
    In [Chapter 15](0f98e454-9804-4589-9854-5c38c9d8d416.xhtml), *FreeRTOS Memory
    Management*, in the *Keeping an eye on stack space* section, we showed you how
    to observe the available stack space, as well as how to implement hooks if an
    overflow was detected.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用RTOS时，内存使用是一个非常重要的考虑因素。与具有单个堆栈的超循环不同——堆栈和堆栈会消耗任何剩余的RAM——每个FreeRTOS任务的堆栈需要显式设置大小。在[第15章](0f98e454-9804-4589-9854-5c38c9d8d416.xhtml)，*FreeRTOS内存管理*，*关注堆栈空间*部分中，我们向您展示了如何观察可用的堆栈空间，以及如果检测到溢出如何实现钩子。
- en: If your application is using dynamic memory allocation, you should strongly
    consider enabling and implementing the failed MALLOC hooks provided by FreeRTOS.
    This was covered in [Chapter 15](0f98e454-9804-4589-9854-5c38c9d8d416.xhtml),
    *FreeRTOS Memory Management*, in the *Keeping an eye on heap space* section as
    well.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序正在使用动态内存分配，您应强烈考虑启用并实施FreeRTOS提供的失败MALLOC钩子。这已在[第15章](0f98e454-9804-4589-9854-5c38c9d8d416.xhtml)，*FreeRTOS内存管理*，*关注堆空间*部分中介绍。
- en: Stack overflow checking
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈溢出检查
- en: If you have a memory protection unit available, it is an excellent idea to make
    use of it since it will detect access violations such as stack overflows with
    better reliability than any of the software-based solutions (see [Chapter 15](0f98e454-9804-4589-9854-5c38c9d8d416.xhtml),
    *FreeRTOS Memory Management*, the *Using a memory protection unit* section).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有可用的内存保护单元，利用它是一个极好的主意，因为它将比任何基于软件的解决方案更可靠地检测到诸如堆栈溢出之类的访问违规（参见[第15章](0f98e454-9804-4589-9854-5c38c9d8d416.xhtml)，*FreeRTOS内存管理*，*使用内存保护单元*部分）。
- en: Another way of keeping an eye on the stack is to set up stack monitoring, which
    was also covered in [Chapter 15](0f98e454-9804-4589-9854-5c38c9d8d416.xhtml), *FreeRTOS
    Memory Management*, in the *Keeping an eye on stack space* section.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种监视堆栈的方法是设置堆栈监控，这在[第15章](0f98e454-9804-4589-9854-5c38c9d8d416.xhtml)，*FreeRTOS内存管理*，*监视堆栈空间*部分也有介绍。
- en: A real-world example of debugging a system that has a stack overflow and checking
    memory is covered in the next section.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍如何通过使用断言来调试具有堆栈溢出并检查内存的系统。
- en: Fixing SystemView dropped data
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复SystemView丢失的数据
- en: 'In the examples we''ve looked at throughout this book, SystemView shows that
    we can stream data visualization by running code on the MCU to store events in
    a local buffer. The contents of the buffer are then transferred data via debug
    hardware to the PC for viewing. Sometimes, during high utilization, you''ll see
    large red blocks in the trace, as shown in the following screenshot:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中我们查看的示例中，SystemView显示我们可以通过在MCU上运行代码来存储事件到本地缓冲区，从而进行数据可视化流。然后，缓冲区的内容通过调试硬件传输到PC进行查看。有时，在高负载期间，你会在跟踪中看到大红色块，如下面的截图所示：
- en: '![](img/da563df0-de19-4425-9970-77792736f005.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/da563df0-de19-4425-9970-77792736f005.png)'
- en: 'These blocks indicate that SystemView has detected dropped packets. The frequency
    of dropped packets can be decreased by doing any of the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些块表明SystemView检测到了丢失的数据包。可以通过以下任何一种方式来减少丢失数据包的频率：
- en: 'Increasing the size of the SystemView buffer on the MCU. `SEGGER_SYSVIEW_Conf.h`
    defines the buffer on line 132\. It is important to note that since this buffer
    resides on the MCU, increasing the size of the buffer will decrease the memory
    available to other pieces of code.:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加MCU上SystemView缓冲区的大小。`SEGGER_SYSVIEW_Conf.h`在132行定义了缓冲区。重要的是要注意，由于此缓冲区位于MCU上，增加缓冲区的大小将减少其他代码可用的内存。
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Increasing the clock speed of the debugger under Target Interface and Speed.
    In some cases, a debugger that supports a faster clock will help (for example,
    a dedicated SEGGER J-Link or J-Trace).
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在目标接口和速度下增加调试器的时钟速度。在某些情况下，支持更快时钟的调试器可能会有所帮助（例如，专门的SEGGER J-Link或J-Trace）。
- en: Decreasing the traffic to the debugger hardware while SystemView is running.
    To do this, you can, for example, close any live trace windows in open debug sessions
    (such as Ozone or STM32CubeIDE).
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在SystemView运行时减少对调试硬件的流量。为此，例如，你可以在打开的调试会话中关闭任何实时跟踪窗口（如Ozone或STM32CubeIDE）。
- en: In the next section, we'll learn how to debug our system by using assertions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何通过使用断言来调试我们的系统。
- en: Using assertions
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用断言
- en: Assertions are excellent tools for catching conditions that simply *shouldn't
    happen*. They provide us with a simple means to check assumptions. See the *Creating
    a task – checking the return value* section of [Chapter 7](2fa909fe-91a6-48c1-8802-8aa767100b8f.xhtml) , *The
    FreeRTOS Scheduler,* for an example of how to add simple assertions to prevent
    code from running when the system is in an unacceptable state.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 断言是捕捉那些“根本不应该发生”的情况的绝佳工具。它们为我们提供了一种简单的方式来检查假设。请参阅[第7章](2fa909fe-91a6-48c1-8802-8aa767100b8f.xhtml)，*FreeRTOS调度器*，*创建任务
    – 检查返回值*部分，了解如何添加简单的断言以防止系统处于不可接受状态时运行代码的示例。
- en: A special FreeRTOS flavor of the assert construct is `configAssert`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: FreeRTOS的断言构造的特殊版本是`configAssert`。
- en: configAssert
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`configAssert`'
- en: '`configAssert` is used throughout FreeRTOS as a way of guarding against an
    improperly configured system. Sometimes, it is triggered when a non-interrupt
    version of the API is called from inside an ISR. Often times, code inside an interrupt
    will attempt to call a FreeRTOS API, but its logical priority is higher than what
    the RTOS will allow.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`configAssert`在FreeRTOS中被用作防止配置不当系统的一种方式。有时，它会在ISR内部调用API的非中断版本时被触发。通常，中断内部的代码会尝试调用FreeRTOS
    API，但其逻辑优先级高于RTOS允许的优先级。'
- en: Rather than allowing an application to run with undefined behavior, FreeRTOS
    will regularly test a set of assertions to ensure all prerequisites are met. On
    their own, these checks are helpful at preventing a system from careening completely
    out of control with no hope of figuring out what the problem is. Instead, the
    system is immediately halted when the invalid condition occurs. FreeRTOS also
    contains thorough documentation on the underlying reasons the assertion has failed (sometimes
    with links to web-based documentation).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 与其让应用程序在未定义的行为下运行，FreeRTOS会定期测试一组断言以确保所有先决条件都已满足。单独来看，这些检查有助于防止系统完全失控，而无法找出问题所在。相反，当出现无效条件时，系统会立即停止。FreeRTOS还包含了关于断言失败的根本原因的详细文档（有时会链接到基于网络的文档）。
- en: Don't ever *cover up* a `configAssert` by disabling it in any way. They are
    often the first notification that a serious configuration problem exists. Disabling
    the assertion will only compound the underlying issue, making it harder to find
    later.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 千万不要通过任何方式**掩盖**`configAssert`。它们通常是存在严重配置问题的第一个通知。禁用断言只会使根本问题更加复杂，使得以后更难找到。
- en: Let's go through an example that shows what the normal symptoms of a system
    halted with `configAssert` might look like, as well as the steps that can be taken
    to diagnose and solve the underlying issue.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来了解系统因`configAssert`而停止时的正常症状可能是什么样，以及可以采取的步骤来诊断和解决根本问题。
- en: Debugging a hung system with configAssert()
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用configAssert()调试挂起系统
- en: When you first bring up the codebase and create some example code to introduce
    SystemView, several problems need to be worked through.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次启动代码库并创建一些示例代码来介绍SystemView时，需要解决几个问题。
- en: 'Here''s our example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的例子：
- en: 'After it was ensured that all of the code was syntactically correct and the
    LEDs were blinking, it''s time to connect SystemView to the running application
    and get some timing diagrams. The first couple of times SystemView is connected,
    a few events are shown, but then the system goes unresponsive:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 确保所有代码在语法上正确，LED闪烁后，是时候将SystemView连接到运行中的应用程序，并获取一些时序图。第一次连接SystemView时，会显示一些事件，但随后系统变得无响应：
- en: The LEDs stopped blinking
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LED停止闪烁
- en: 'No additional events were showing up in SystemView, as shown in the following
    screenshot:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在SystemView中没有显示任何其他事件，如下面的截图所示：
- en: '![](img/77b5a1cb-28e6-42b7-918f-3d9e7d3c2b50.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77b5a1cb-28e6-42b7-918f-3d9e7d3c2b50.png)'
- en: Let's diagnose and solve the underlying issue in a couple of steps.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在几个步骤中诊断并解决根本问题。
- en: Collecting the data
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集数据
- en: Sometimes, it is tempting to take guesses as to what might be happening or make
    assumptions about the system. Rather than doing either of these things, we'll
    simply connect our debugger to the system to see what the problem is.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，猜测可能发生的事情或对系统做出假设是很诱人的。而不会做这两件事，我们只需将调试器连接到系统，看看问题是什么。
- en: 'Since SEGGER Ozone is exceptionally good at connecting to a running system
    without modifying its state, we''re able to connect to the hung application without
    disrupting anything. This allows us to start debugging an application after it''s
    crashed, even if it was previously *not* running through the debugger. This can
    come in very handy during product development since it allows us to run the system
    normally, without constantly starting it from the debugger. Let''s learn how to
    do this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SEGGER Ozone在连接运行中的系统而不修改其状态方面特别出色，我们能够连接到挂起的应用程序而不会破坏任何东西。这允许我们在应用程序崩溃后开始调试，即使它之前**没有**通过调试器运行。这在产品开发期间非常有用，因为它允许我们正常运行系统，而无需不断从调试器启动。让我们学习如何做到这一点：
- en: Set up Ozone with the same code that is running on the target. Note that the
    development board must be connected via USB (see [Chapter 6](699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml),* Debugging
    Tools for Real-Time Systems*, for details).
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用与目标上运行相同的代码设置Ozone。注意，开发板必须通过USB连接（有关详细信息，请参阅[第6章](699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml)，*实时系统调试工具*）。
- en: 'After that, select Attach to Running Program:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择附加到运行程序：
- en: '![](img/41be5a57-4cec-4dca-ac53-f2cbadfdfbf7.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41be5a57-4cec-4dca-ac53-f2cbadfdfbf7.png)'
- en: 'Upon attaching and pausing execution, we''re greeted with the following screen
    and are immediately able to make some observations:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在附加并暂停执行后，我们会看到以下屏幕，并立即能够进行一些观察：
- en: '![](img/ad2fb10e-af88-4011-b4f1-80085668d43b.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ad2fb10e-af88-4011-b4f1-80085668d43b.png)'
- en: 'Notice the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下内容：
- en: The LEDs have stopped blinking because we're spending all of our time in an
    infinite loop because of a failed assertion.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于断言失败，我们花费了所有的时间在一个无限循环中，因此 LED 停止闪烁。
- en: By looking at the Call Stack, we can see that the offending function is `SEGGER_SYSVIEW_RecordSystime`,
    which is apparently making a call to a function called `_cbGetTime`, which in
    turn calls `xTaskGetTickCountFromISR`.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过查看调用栈，我们可以看到有问题的函数是 `SEGGER_SYSVIEW_RecordSystime`，它显然调用了名为 `_cbGetTime` 的函数，而
    `_cbGetTime` 又调用了 `xTaskGetTickCountFromISR`。
- en: Reading through the detailed comment above line 760, it sounds like there may
    be some misconfigured NVIC priority bits.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读第 760 行以上的详细注释，听起来可能有一些配置错误的 NVIC 优先级位。
- en: The maximum acceptable value of `ulMaxPROGROUPValue` (which can be seen by hovering
    over the selected variable) is `1`.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ulMaxPROGROUPValue` 的最大可接受值（可以通过悬停在所选变量上查看）是 `1`。'
- en: Now that we know *which* assertion failed, it's time to figure out the root
    cause of *why* exactly it failed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道哪个断言失败了，现在是时候找出它为什么失败的根本原因了。
- en: Digging deeper – SystemView data breakpoints
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入挖掘 – SystemView 数据断点
- en: 'So far, we''ve determined where our processor is stuck, but we haven''t uncovered
    anything to help us determine what needs to be changed to get the system operational
    again. Here are the steps we need to take to uncover the root cause of the issue:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经确定了处理器卡住的地方，但还没有发现任何帮助我们确定需要更改什么才能使系统再次运行的信息。以下是我们需要采取的步骤来找出问题的根本原因：
- en: 'Let''s take a look at the assertion again. Here, our goal is to troubleshoot
    exactly why it is failing. Run the following command:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次查看断言。在这里，我们的目标是找出它为什么失败的确切原因。运行以下命令：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Using SystemView''s memory viewer, analyze the value of `portAIRCR_REG` in `port.c`:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 SystemView 的内存查看器，分析 `port.c` 中 `portAIRCR_REG` 的值：
- en: '![](img/f63839d2-8f89-41be-9a5c-9ad3882f9c87.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f63839d2-8f89-41be-9a5c-9ad3882f9c87.png)'
- en: 'Since this is a hardcoded memory location, we can Set Data Breakpoint, which
    will pause execution each time the memory location is written. This can be a quick
    way to track down all of the ways a variable is accessed, without attempting to
    search through the code:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这是一个硬编码的内存位置，我们可以设置数据断点，每次写入该内存位置时都会暂停执行。这可以是一种快速跟踪变量所有访问方式的方法，而无需尝试搜索代码：
- en: '![](img/d1dc5491-6065-4e40-968d-9084327b8ebf.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d1dc5491-6065-4e40-968d-9084327b8ebf.png)'
- en: 'Upon restarting the MCU, the write breakpoint is immediately hit. Although
    the program counter is pointing to `HAL_InitTick`, the actual data write to the `0xE000ED0C` address
    was done in the previous function, that is, `HAL_NVIC_SetPriorityGrouping`.  This
    is exactly what we expect since the assert is related to interrupt priority groups:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在重启 MCU 后，写入断点立即被触发。尽管程序计数器指向 `HAL_InitTick`，但实际写入 `0xE000ED0C` 地址的数据是在上一个函数中完成的，即
    `HAL_NVIC_SetPriorityGrouping`。这正是我们所期望的，因为断言与中断优先级组相关：
- en: '![](img/13d927f0-2b5d-4d58-91a0-bb42989983bb.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/13d927f0-2b5d-4d58-91a0-bb42989983bb.png)'
- en: 'Some quick searching through the code for `NVIC_PRIORITYGROUP_4` reveals the
    following comment in `stm32f7xx_hal_cortex.c`:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码中快速搜索 `NVIC_PRIORITYGROUP_4` 可以在 `stm32f7xx_hal_cortex.c` 中找到以下注释：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Priority grouping**: The interrupt controller (NVIC) allows the bits that
    define each interrupt''s priority to be split between bits that define the interrupt''s
    preemption priority bits, as well as the bits that define the interrupt''s sub-priority.
    For simplicity, all bits must be defined to be preemption priority bits. The following
    assertion will fail if this is not the case (if some bits represent a sub-priority).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**优先级分组**：中断控制器（NVIC）允许定义每个中断优先级的位在定义中断抢占优先级的位和定义中断子优先级的位之间分割。为了简单起见，所有位都必须定义为抢占优先级位。如果这不是这样（如果某些位代表子优先级），以下断言将失败。'
- en: Based on this information, there should be `0` bits for the subpriority. So,
    why was the value of the priority bits in `portAIRCR_REG` non-zero?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些信息，子优先级应该有 `0` 个位。那么，为什么 `portAIRCR_REG` 中的优先级位值不为零呢？
- en: 'From the *ARM® Cortex® -M7 Devices Generic User Guide, *we can see that to
    achieve 0 bits of subpriority, the value of the **AIRCR** register masked with
    **0x00000700** must read as 0 (it had a value of **3** when we looked at the value
    in memory):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 *ARM® Cortex® -M7 设备通用用户指南*，我们可以看到，为了达到 0 个子优先级位，**AIRCR** 寄存器与 **0x00000700**
    进行掩码后的值必须为 0（当我们查看内存中的值时，它有 **3** 的值）：
- en: '![](img/46013ad9-c773-49cd-aa75-e6d70d88a8f8.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/46013ad9-c773-49cd-aa75-e6d70d88a8f8.png)'
- en: 'Here is the explanation for `PRIGROUP` in the same manual. Notice that `PRIGROUP`
    must be set to 0b000 for 0 subpriority bits:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是同一手册中关于`PRIGROUP`的解释。注意，`PRIGROUP`必须设置为0b000以有0个子优先级位：
- en: '![](img/6d06da99-492e-4154-9329-f06a638790a1.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d06da99-492e-4154-9329-f06a638790a1.png)'
- en: 'This certainly warrants further investigation... why was the value of `PRIOGROUP` 3
    instead of 0? Let''s take another look at that `configAssert()` line:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实需要进一步调查...为什么`PRIOGROUP`的值是3而不是0？让我们再次查看那个`configAssert()`行：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note the following definition of `ulMaxPRIOGROUPValue` in `port.c`. It is defined
    as *static*, which means it has a permanent home in memory:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下`port.c`中`ulMaxPRIOGROUPValue`的定义。它被定义为*静态的*，这意味着它在内存中有一个永久的位置：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s set up another data breakpoint for `ulMaxPRIGROUPValue` and restart
    the MCU again, but this time, we''ll watch each time it is accessed:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`ulMaxPRIGROUPValue`设置另一个数据断点，并再次重启MCU，但这次，我们将每次访问时都进行监视：
- en: As expected, something was accessed by the `BaseType_t xPortStartScheduler(
    void )` function in `port.c`
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如预期，`BaseType_t xPortStartScheduler(void)`函数在`port.c`中访问了某个内容。
- en: The curious part about the data access breakpoint is that it is hit when the
    program counter is inside `SEGGER_RTT.c`, which doesn't look right since `ulMaxPRIGROUPValue` is
    privately scoped to `xPortStartScheduler` in `port.c`
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于数据访问断点的好奇之处在于，它在程序计数器位于`SEGGER_RTT.c`时被触发，这看起来不太对，因为`ulMaxPRIGROUPValue`在`port.c`的`xPortStartScheduler`中是私有作用域。
- en: 'Looking at the debugger – the problem is staring right at us:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看调试器——问题就在眼前：
- en: The `ulMaxPRIGROUPValue` static variable is being stored in `0x2000 0750`.
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ulMaxPRIGROUPValue`静态变量存储在`0x2000 0750`。'
- en: The data write breakpoint was hit with the stack pointer at `0x200 0740`.
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据写入断点在栈指针为`0x200 0740`时被触发。
- en: 'The stack has been overrun:'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈已被越界：
- en: '![](img/1c02901d-20e3-48fc-bd63-57e41bd18de6.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1c02901d-20e3-48fc-bd63-57e41bd18de6.png)'
- en: We've just uncovered a stack overflow**. **It manifested itself as a write into
    a static variable (which happened to trigger a `configAssert` in an unrelated
    part of the system). This type of wildly unexpected behavior is a common side
    effect of stack overflows.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚发现了一个栈溢出**。**它表现为对静态变量的写入（恰好触发了一个与系统无关部分的`configAssert`）。这种完全出乎意料的行为是栈溢出的常见副作用。
- en: Currently, the minimum values of each stack in `main.c` has been set to 128
    words (1 word = 4 bytes), so increasing this to 256 words (1 KB) gives us plenty
    of headroom.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`main.c`中每个栈的最小值已被设置为128个单词（1个单词=4字节），因此将其增加到256个单词（1 KB）为我们提供了足够的余量。
- en: '*This example is fairly representative of what happens when functionality is
    added to a preexisting task that was working properly previously.* If the new
    functionality requires more functions to be called (with each having local variables),
    those variables will consume stack space. In this example, this problem only showed
    up after adding the SEGGER print functionality to an existing task. Because there
    wasn''t additional stack space available, the task overflowed its stack and corrupted
    the memory that was being used by another task.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个例子相当典型地展示了当向先前运行良好的现有任务添加功能时会发生什么。*如果新功能需要调用更多函数（每个函数都有自己的局部变量），这些变量将消耗栈空间。在这个例子中，这个问题是在向现有任务添加SEGGER打印功能后才出现的。因为没有额外的栈空间可用，任务溢出了栈并破坏了另一个任务使用的内存。'
- en: The problem in this example would have likely been caught if we had the stack
    overflow hooks set up – it would have certainly been caught if the MPU port was
    being used.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们设置了栈溢出钩子，这个问题很可能会被发现——如果使用MPU端口，它肯定会被发现。
- en: Next steps
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下一步
- en: Now that you've been through this book and tinkered with each ready-to-run example
    – wait... you haven't run the examples yet?!  Time to get started on that! They
    have been included because having hands-on experience will help drive these concepts
    home, providing you with both valuable practice and a base development environment
    you can use for your own projects.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经通读了这本书，并对每个现成的示例进行了尝试——等等...你还没有运行示例吗？！现在是时候开始运行它们了！之所以包含这些示例，是因为实际操作经验将有助于加深这些概念的理解，同时为你提供宝贵的实践机会和可用于自己项目的开发环境。
- en: So, assuming you've already run through the examples included, an excellent
    next step to gain an even more in-depth understanding of FreeRTOS is to read *Richard
    Barry's* book, *Mastering the FreeRTOS™ Real-Time Kernel*. This book focuses on
    how to apply the general knowledge that is required to get started with embedded
    systems and build a solid foundation for future development. Mastering FreeRTOS,
    however, is laser-focused on the specific details of FreeRTOS, with examples for
    each of the APIs. Having a hardware environment set up, a basic understanding
    of the fundamentals, and debug/visualization tooling at hand will help you get
    the most out of his book. After you have a system up and running, the code provided
    in *Mastering the FreeRTOS™ Real-Time Kernel* can be easily tested and experimented
    with using real hardware and a visual debugging system.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，假设你已经运行了包含的示例，要更深入地了解FreeRTOS，一个很好的下一步是阅读*理查德·巴里*的书籍，《Mastering the FreeRTOS™
    Real-Time Kernel》。这本书侧重于如何应用开始嵌入式系统开发并建立未来发展的坚实基础所需的一般知识。然而，《Mastering FreeRTOS》专注于FreeRTOS的具体细节，并为每个API提供示例。拥有一个硬件环境、对基础知识的初步理解以及调试/可视化工具将帮助你最大限度地利用他的书籍。在系统运行起来之后，*Mastering
    the FreeRTOS™ Real-Time Kernel*中提供的代码可以很容易地使用真实硬件和可视化调试系统进行测试和实验。
- en: While we're on the subject of building solid foundations, you'll want to consider
    getting acquainted with test-driven development. As you start to create loosely
    coupled code, as we did in [Chapter 12](8e78a49a-1bcd-4cfe-a88f-fb86a821c9c7.xhtml),* Tips
    on Creating Well-Abstracted Architecture*, and [Chapter 13](e728e173-c9b2-4bb8-91c8-ed348ccf9518.xhtml),* Creating
    Loose Coupling with Queues*, testing these subsystems is a natural next step. *James
    Grenning* has many resources available on his website ([https://blog.wingman-sw.com](https://blog.wingman-sw.com)),
    specifically for embedded C/C++. Other TDD resources specific to embedded C include
    *Matt Chernosky's* site ([http://www.electronvector.com/](http://www.electronvector.com/))
    and the unique *Throw the Switch *([http://www.throwtheswitch.org/](http://www.throwtheswitch.org/)).
    A great all-around embedded resource that's been created from decades of hard-earned
    experience is *Jack Gannsle's* site, which you can access at [http://www.ganssle.com/](http://www.ganssle.com/).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论构建坚实基础的话题时，你可能会想要考虑熟悉测试驱动开发。正如我们在第12章[《创建良好抽象架构的技巧》](8e78a49a-1bcd-4cfe-a88f-fb86a821c9c7.xhtml)和第13章[《使用队列创建松耦合》](e728e173-c9b2-4bb8-91c8-ed348ccf9518.xhtml)中所做的那样，开始创建松耦合代码，测试这些子系统是自然的下一步。*詹姆斯·格林宁*在他的网站上提供了许多资源([https://blog.wingman-sw.com](https://blog.wingman-sw.com))，特别是针对嵌入式C/C++的测试驱动开发资源。其他针对嵌入式C的TDD资源包括*马特·切尔诺斯基*的网站([http://www.electronvector.com/](http://www.electronvector.com/))和独特的*Throw
    the Switch*([http://www.throwtheswitch.org/](http://www.throwtheswitch.org/))。一个由数十年的实践经验积累而成的全面嵌入式资源是*杰克·甘斯勒*的网站，你可以通过[http://www.ganssle.com/](http://www.ganssle.com/)访问。
- en: Summary
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this final chapter, we covered a few tips that will help smooth out some
    of the bumps in the road of your RTOS journey, as well as a few suggested next
    steps.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章的最后一章中，我们介绍了一些技巧，这些技巧将帮助你平滑RTOS旅程中的一些颠簸，以及一些建议的下一步行动。
- en: That's it, folks! I hope you've enjoyed this hands-on introduction to developing
    firmware for real-time embedded systems using FreeRTOS, STM32, and SEGGER tools.
    Now, it's time to get out there and start understanding systems, solving problems,
    and analyzing your solution! I'd love to hear about how you've applied what you've
    learned in this book – give me a shout on LinkedIn, Twitter, or GitHub! If you've
    really enjoyed this book and think others would also like it, consider leaving
    a review – they help spread the word!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，各位！我希望你们喜欢这个使用FreeRTOS、STM32和SEGGER工具开发实时嵌入式系统固件的动手介绍。现在，是时候出去开始理解系统、解决问题和分析你的解决方案了！我很乐意听听你是如何应用这本书中学到的知识的——在LinkedIn、Twitter或GitHub上给我留言！如果你真的很喜欢这本书，并认为其他人也会喜欢它，考虑留下评论——它们有助于传播信息！
- en: Questions
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude this book, here is a list of questions for you to test your
    knowledge regarding this chapter''s material. You will find the answers in the
    *Assessments* section of the *Appendix*:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束这本书的时候，这里有一份问题列表，供你测试你对本章材料的了解。你将在附录的*评估*部分找到答案：
- en: When your system crashes after you've added an interrupt or used a new RTOS
    primitive, what steps should you take?
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你在系统中添加中断或使用新的RTOS原语后，系统崩溃了，你应该采取哪些步骤？
- en: Name one common cause of unexpected behavior (caused by firmware) when developing
    with an RTOS.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举一个在开发实时操作系统（RTOS）时，由固件引起的意外行为（问题）的常见原因。
- en: Since your system has no way of outputting data (no exposed serial port or communication
    interface), it will be impossible to debug.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于您的系统没有输出数据的方式（没有暴露的串行端口或通信接口），将无法进行调试。
- en: 'True'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
