- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Project #6 – Tracking and Notifying about Your Heart Rate'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is dedicated to smart healthcare and wearables. It shows how healthcare
    devices can be integrated with the **Arduino IoT Cloud platform** and offers an
    example of an interface between the Arduino IoT Cloud and a third-party service.
    The notification service sends notifications to recipients when the measured heart
    rate exceeds the defined heart rate threshold.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will embark on a practical exploration of smart health and
    wearables by working with a **heart rate sensor** and Seeed Studio’s newest and
    very small development board in the **XIAO series**, based on **ESP32** with a
    lot of features. With the help of a sensor, a development board, and the Arduino
    IoT Cloud, we will build an IoT-enabled wearable healthcare solution. You will
    also learn how to set up webhooks for sending the latest heart rate values to
    Zapier. Finally, you will see how to set up Zaps in Zapier for email/mobile notifications
    on heart rate data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring IoT for smart health solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowing the hardware components – sensors and development boards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the project architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Things, network credentials, cloud variables, and code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a dashboard for web and mobile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the notification service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following hardware components are required to complete this chapter’s exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Seeed Studio XIAO ESP32C3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: USB Type-C cable for the XIAO ESP32C3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pulse sensor (find the complete details and store links in the *Knowing the
    hardware components – sensors and development* *boards* section)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Male headers for the development board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumper cables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For coding, we will use the **Arduino Web Editor**, which includes a large collection
    of development boards and sensor libraries, along with Arduino IoT Cloud for Thing
    and dashboard setup. To develop hardware and sensor designs, we need the **Fritzing**
    desktop software and the **Arduino IDE** desktop software for pulse-sensor calibration
    using the **Serial Plotter**, which is not available in the Arduino Web Editor.
  prefs: []
  type: TYPE_NORMAL
- en: We will also use **Zapier** to send alerts by email when our sensor detects
    a heart rate above our specified **beats-per-minute** (**BPM**) threshold. You
    can use a Free/trial account or buy a Zapier Professional plan according to the
    requirements of your project as Zapier Professional provides more features and
    functions compared to a Free account. The code used in this chapter is available
    from the book’s official GitHub repository at [https://github.com/PacktPublishing/Arduino-IoT-Cloud-for-Developers](https://github.com/PacktPublishing/Arduino-IoT-Cloud-for-Developers).
  prefs: []
  type: TYPE_NORMAL
- en: Exploring IoT for smart health solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Internet of Things** (**IoT**) is playing a significant role in providing
    smart healthcare solutions that can improve patient outcomes and reduce healthcare
    costs. IoT devices can collect real-time data, communicate with other devices,
    and generate insights that can help healthcare providers make better decisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of how IoT can be used in smart health solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Remote patient monitoring**: IoT devices can be used to monitor patients’
    health in real time, even when they are not in the hospital. Wearable devices,
    sensors, and medical-grade IoT devices can collect data on vital signs, BPM rates,
    blood-glucose levels, and medication adherence. Healthcare providers can use this
    data to provide personalized care and prevent complications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Telemedicine**: IoT devices can enable virtual consultations and remote medical
    services. Patients can communicate with their healthcare providers using video
    conferencing, and healthcare providers can remotely monitor patients’ health through
    IoT devices. This can improve access to healthcare services, reduce healthcare
    costs, and improve patient outcomes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Smart medication management**: IoT devices can help patients manage their
    medications more effectively. IoT-enabled pill dispensers can remind patients
    when it’s time to take their medication and can track medication usage. Healthcare
    providers can use this data to provide personalized care and prevent medication
    errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Predictive maintenance**: IoT devices can be used to monitor medical equipment
    and predict when maintenance is required. This can help prevent equipment failures,
    reduce downtime, and improve patient outcomes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Smart hospital management**: IoT devices can be used to manage hospital resources
    more efficiently. For example, IoT-enabled asset tracking systems can help healthcare
    providers locate medical equipment quickly, reducing waiting times for patients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, IoT can enable smart health solutions that improve patient outcomes
    and reduce healthcare costs. Healthcare providers can use IoT data to provide
    personalized care and make more informed decisions. As IoT technology continues
    to evolve, we can expect to see even more innovative healthcare solutions in the
    future.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have discussed IoT and smart healthcare and how IoT is beneficial
    to us in the development of smart healthcare products. Next, we will take a look
    at what types of hardware and sensors are required to carry out the exercise in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the hardware components – sensors and development boards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ESP32 series offers a wide array of development boards that vary in the
    sizes and pins offered. In this chapter, we are using Seeed Studio’s latest development
    board, the **XIAO ESP32C3**, as it’s very compact and smaller in size than other
    boards, cheaper in cost, and provides 5V along with 3.3V. *Figure 12**.1* shows
    a pin diagram of the XIAO ESP32C3 we will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – XIAO ESP32C3 pinout diagram](img/B19752_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – XIAO ESP32C3 pinout diagram
  prefs: []
  type: TYPE_NORMAL
- en: The XIAO ESP32C3 provides multiple pins for digital input/output. In previous
    ESP-series boards such as the ESP8266, we only had one analog pin, but we have
    four on this development board, which removes the biggest hurdle encountered when
    developing solutions using multiple analog pins. To get around this on previous
    ESP-series boards, we had to use **ADS1115**/**ADS1015** for extra analog pins,
    so this development board will save you some bucks with its four analog pins by
    default.
  prefs: []
  type: TYPE_NORMAL
- en: Besides these features, XIAO provides a built-in battery charge module and the
    board is optimized for power consumption, which make this board appropriate for
    developing wearable devices. For connectivity, both Wi-Fi and Bluetooth are available,
    including **Bluetooth Low Energy** (**BLE**) **5 support**, which is more specific
    to IoT use cases. For further details, please visit [https://wiki.seeedstudio.com/XIAO_ESP32C3_Getting_Started/](https://wiki.seeedstudio.com/XIAO_ESP32C3_Getting_Started/).
  prefs: []
  type: TYPE_NORMAL
- en: For our current project, we need one analog pin for the **pulse sensor**, and
    a5V pin for power. One of the good features of our chosen development board is
    that we have a 5V power pin, which is not available in most of the ESP32 series
    development boards.
  prefs: []
  type: TYPE_NORMAL
- en: We use the pulse sensor to measure the BPM but there is a variety of other pulse
    oximeters on the market for BPM and pulse measurement. The following pulse sensor
    (*Figure 12**.2*) is open source, cheaper, and easier to use than other sensors.
    You can also use Chinese-made pulse sensors but you will require controlled conditions
    while using these sensors.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Pulse sensor and its pinout diagram](img/B19752_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Pulse sensor and its pinout diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of official stores where you can buy the original pulse
    sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SparkFun**: [https://www.sparkfun.com/products/11574](https://www.sparkfun.com/products/11574)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adafruit**: [https://www.adafruit.com/product/1093](https://www.adafruit.com/product/1093)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon** **UK**: [https://www.amazon.co.uk/dp/B01CPP4QM0](https://www.amazon.co.uk/dp/B01CPP4QM0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon** **USA**: [https://www.amazon.com/PulseSensor-com-Original-Pulse-Sensor-project/dp/B01CPP4QM0](https://www.amazon.com/PulseSensor-com-Original-Pulse-Sensor-project/dp/B01CPP4QM0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding figure shows the pinout layout of the pulse sensor. *Pin #1*
    is the GND pin, which connects to the onboard GND pin. *Pin #2*, VCC, works with
    both 3.3V and 5V. *Pin #3* connects to any analog pin on the board. I connect
    it to *Pin #A1* on the board. You can solder the male headers to the pulse sensor
    or directly solder the cables without any header pins.'
  prefs: []
  type: TYPE_NORMAL
- en: Measuring a pulse is a very critical and difficult task, but we can benefit
    from [pulsesensor.com](http://pulsesensor.com), started by **World Famous Electronics
    LLC** as a crowd-funding project. On this site, you can find all the official
    details including specifications, how the sensor works, and development board
    code samples.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Chinese-made pulse sensors are good for DIY projects, but even sensors from
    official stores can’t be deployed in real-world use cases without professional
    calibration using a real-time **electrocardiogram** (**ECG**), BPM equipment,
    and a doctor’s verification.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed the pulse sensor and where you can buy it, as
    well as examining its pinout diagram for better understanding. Next, we will examine
    the project architecture, covering how to connect the sensors to the XIAO ESP32C3.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the project architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding sections, we discussed the sensors and development board in
    detail. Now it’s time to get started on the recipe. In hardware development, before
    we start working with sensors and development boards, we need to develop the design
    concepts to get a better understanding of how things will be connected. There
    are many pieces of software available to design and develop design concepts for
    electronics projects, but we are going to use Fritzing.
  prefs: []
  type: TYPE_NORMAL
- en: In the following two subsections, we will cover schematics and project design,
    explaining how to connect the pins to the development board and soldering. Next,
    we will do some calibration of the *pulse sensor fetch-reading threshold*, as
    this is different for different development boards. This is very important to
    do before we send the data to the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Schematics design and assembly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The purpose of design is to get a clear understanding of how the sensors will
    be connected to the development board. A clear design helps engineers to develop
    a prototype on a **breadboard** or **veroboard**. Another major benefit of effective
    design is that Fritzing builds hardware schematics and PCB designs in the background
    according to your design, which can then be adjusted by designers according to
    the system requirements. *Figure 12**.3* shows the project schematic diagram demonstrating
    how to connect the pulse sensor to the XIAO ESP32C3:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – XIAO ESP32C and pulse sensor system design](img/B19752_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – XIAO ESP32C and pulse sensor system design
  prefs: []
  type: TYPE_NORMAL
- en: The design in the preceding figure provides an overview of how to connect the
    sensors to the development board. According to our design, we have 5V and GND
    from the development board to the pulse sensor. The pulse sensor is an analog
    sensor, so we connected its *Signal* pin to the *A1* pin of the development board.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – Final prototype](img/B19752_12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – Final prototype
  prefs: []
  type: TYPE_NORMAL
- en: After soldering the male headers to the pulse sensor and the XIAO ESP32C3, connect
    the pins according to the schematic. There is only one sensor, so no veroboard
    is required. *Figure 12**.4* shows the pulse sensor connected to the XIAO ESP32C3
    without any breadboard or Veroboard, but rather, directly connected with jumper
    wires. Now, it’s time to calibrate the pulse sensor and get an appropriate threshold
    value by putting your fingertip on the sensor.
  prefs: []
  type: TYPE_NORMAL
- en: Sensor calibration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For sensor calibration, we need the Serial Plotter to identify the pulse value
    threshold. Currently, the Arduino Web Editor does not support the Serial Plotter,
    so we are going to use the Arduino IDE. To work with the Arduino IDE, we need
    to install the **Seeed Studio XIAO ESP32C3 series** development board and the
    [pulsesensor.com](http://pulsesensor.com) library.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the ESP32 series development board in the Arduino IDE, firstly,
    add the board’s definition file in the preferences:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to **File** > **Preferences**, and fill the **Additional Boards Manager
    URLs** field with the following URL: [https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_dev_index.json](https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_dev_index.json).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, navigate to `esp32` in the search box, select the latest version of ****esp32****,
    and install it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, select the board by navigating to **Tools** > **Board** > **ESP32 Arduino**
    and selecting **XIAO_ESP32C3**. The list of boards is a little long and you will
    need to scroll to the bottom to find it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s time to install the pulse sensor library. Navigate to `pulsesensor playground`
    into the search bar. Only one library will be returned here – install it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are ready to proceed to the calibration step. Navigate to **File** >
    **Examples** > **PulseSensor Playground** > **Getting Started Project**. Here,
    you will get the template code for calibration, to which we will make the following
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Set the `PulseSensorPurplePin` variable to `A1`. Remember to never use a simple
    `1` as it will give you different values. Next, assign `10` to the `LED` variable.
    After these modifications, upload the code to the board. To monitor the recorded
    values in graph format, navigate to **Tools** > **Serial Plotter**. *Figure 12**.5*
    shows the Serial Plotter presenting all the values in the form of a graph. The
    threshold values are marked by the red box.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – Pulse sensor raw-readings graph using the Serial Plotter](img/B19752_12_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – Pulse sensor raw-readings graph using the Serial Plotter
  prefs: []
  type: TYPE_NORMAL
- en: Put a finger on the front side of the pulse sensor, which is marked with a white
    heart shape. Wait for some time for the readings to stabilize on the Serial Plotter.
    After a few seconds, you should see stable readings as shown in the preceding
    figure. Mark the lowest level as the threshold. In my case, I take **3500** as
    the threshold value to avoid noise.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, download the `PulseSensor_BPM_Alternative` code from the GitHub
    repository under [*Chapter 12*](B19752_12.xhtml#_idTextAnchor251). This is some
    code modified by us that we’ll use to display the BPM. But before uploading the
    code to the board, modify the values as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Assign `A1` to the `PULSE_INPUT` variable, `10` to `PULSE_BLINK`, and set the
    `THRESHOLD` value according to your stabilized reading taken from the Serial Plotter.
    As stated, I am using `3500` from my graph. Upload the code to the board and observe
    the BPM readings in the Serial Monitor. Place a finger on the top of the sensor
    and you will get different BPM readings. *Figure 12**.6* demonstrates what this
    should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6 – BPM values in the Serial Monitor](img/B19752_12_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.6 – BPM values in the Serial Monitor
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure shows random BPM values, and when we put a finger on the
    sensor, it detects **96** and **100** BPM. You can play with the sensor and verify
    the readings with any professional smartwatch. Next, we need to set up a Thing,
    some code, and a dashboard in the Arduino IoT Cloud to prepare our IoT project.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Thing, network credentials, cloud variables, and code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After setting up the hardware, it’s time to set up a Thing in the Arduino IoT
    Cloud. For this project, we need one cloud variable to fetch BPM reading from
    the device. The network settings will be different from those of Arduino IoT development
    boards as we are using an ESP series board. *Figure 12**.7* shows the complete
    Thing details including cloud variables, device info, and network configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7 – Tracking and notifying about your heart rate Thing setup](img/B19752_12_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.7 – Tracking and notifying about your heart rate Thing setup
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up a new `Tracking and notifying about your heart rate`. Then, proceed
    to the following sections of this chapter, which will take us through the following
    steps to create the variables, associate the device, set up the network configuration,
    and finally, apply the code:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we need to set up one cloud variable for **BPM**. The complete details
    regarding cloud variables are available in the following *Cloud* *variables* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, we need to associate the device with the Thing. In our current project,
    we are using the XIAO ESP32C3, so the wizard will be different from that for Arduino
    boards. The complete details are available in the *Device* *association* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to set up the network configuration for the device, but this time,
    we need to provide a security key for ESP-series boards to make the connection
    secure (whereas Arduino-compatible boards are configured by the Arduino IoT Cloud
    automatically during the device setup wizard).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, we will set up the webhook toward the end of the chapter, along with
    the notification service using Zapier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cloud variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following table outlines the properties that we need to use during cloud
    variable creation. For BPM, we could just use the `integer` data type, but thanks
    to the Arduino IoT Cloud extended group of variables, we can choose the specific
    `Heart rate` variable type. Next, make sure you use the same variable declaration
    as in the table; otherwise, you will need to modify the example code according
    to your own naming.
  prefs: []
  type: TYPE_NORMAL
- en: 'For **Permission**, while we do have a **Read/Write** option, I chose **Read
    Only** as we only want to receive data from the device, as opposed to dashboard
    modification, so **Read Only** mode will avoid issues in data consistency. **Update
    Policy** is set to **On change** as the device will send the data whenever there
    is any change detected in the BPM value:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **S#** | **Variable Name** | **Variable Type** | **Declaration** | **Permission**
    | **Update Policy** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | BPM | Heart rate | `bPM` | Read Only | On change |'
  prefs: []
  type: TYPE_TB
- en: Table 12.1 – Cloud variable for our Thing
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have created the cloud variable that receives the heart
    rate value in BPM from the sensor device. In the next section, we will associate
    the device with the Thing.
  prefs: []
  type: TYPE_NORMAL
- en: Device association
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After variable creation, it’s time to add the device and associate it with
    the Thing. Before adding the device, connect the development board to the computer
    and open the **Arduino Create Agent** application. *Figure 12**.8* shows the device
    setup wizard where we have selected **ESP32** and then **XIAO_ESP32C3** from the
    dropdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8 – Device selection wizard](img/B19752_12_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.8 – Device selection wizard
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Select Device** button under the **Associated Devices** section
    on the Thing page. A popup will appear showing all the devices that are already
    available. If you have already added your XIAO ESP32C3, select it. Otherwise,
    click on **SET UP** **NEW DEVICE**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, click on the **Third Party device** option. Select **ESP32** and **XIAO_ESP32C3**
    from the dropdown and click on the **CONTINUE** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in the **Device Name** field and click on the **Next** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the final wizard screen, the **Device ID** and **Secret Key** values will
    be displayed. Copy the **Secret Key** value to a safe place as it will be needed
    later during the network configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, we associated the XIAO ESP32C3 device with the Thing. The device
    association process is somewhat different to adding the Arduino MKR1010 to a Thing.
    Next, let’s complete the network settings.
  prefs: []
  type: TYPE_NORMAL
- en: Network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After associating the device with the Thing, it is time to configure the Wi-Fi
    settings for device communication. Fill in the form shown in *Figure 12**.9* with
    your **Wi-Fi Name** and **Password** values. The last field here is the **Secret
    Key** field. Paste the secret key value in here that we received from the system
    during device creation.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 12.9 – Network configuration for \uFEFFthe Thing](img/B19752_12_09.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 12.9 – Network configuration for the Thing
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12**.9* shows how it should look once you’ve entered all the relevant
    values. In the next subsection, we will cover the coding for the device.'
  prefs: []
  type: TYPE_NORMAL
- en: Coding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code for this chapter is available in the book’s official GitHub repository.
    Download the `Tracking_and_notifying_Your_Heart_Rate_mar31a` code from the repository
    and import it to the Arduino Web Editor.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the code and add it to your Thing by navigating to the **Sketch**
    tab. We will not discuss the code at length as you will get the gist after reading
    the code yourself, but I will explain the main workflow with which we initialize
    all the variables and constants in the setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember to never use the `delay` method as it will create blocking in the
    `ArduinoCloud.update()` method. But before moving on to the code, we need to set
    the `PULSE_INPUT` variable to pin `A1`, `PULSE_BLINK` to digital pin `10` for
    the LED, and set `THRESHOLD` with your calibration value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After configuring the preceding variables with the appropriate values, it’s
    time to explore the loop method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the loop method, the development board calls `pulseSensor.sawNewSample()`
    to fetch new samples if they exist. Other than that, it will not call any activity,
    which is why you will see a delay in readings returned if there is no change found
    by the system in the BPM data. If any change occurred in the sensor readings,
    then BPM readings will verify using the `pulseSensor.sawStartOfBeat()` method.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section where we created the cloud variable, recall the cloud
    variable declaration – our `pulseSensor.getBeatsPerMinute();` method assigns the
    sensor reading to that `thingProperties.h` file. So, when you assign the values
    to these constants, the `ArduinoCloud.update()` method in the loop will automatically
    send the data to the cloud. Finally, upload the code to the device and verify
    the readings returned using the Serial Monitor.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you used different *naming* in the variable declaration, then update the
    code according to your naming scheme. It would be better, however, if you followed
    the steps according to the book first and then change the cloud variable names
    later and modify your code respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Never use the `delay` method, which will create a block for the `ArduinoCloud.update()`
    method, and don’t put code at the end of the loop method, as it will cause a delay
    in the pulse sensor readings.
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino IoT Cloud only updates the value on the dashboard whenever the variable
    value is changed. For example, if the heart beat is `80` and after 5 minutes it’s
    still the same, then the Arduino IoT Cloud will not record the value, so don’t
    get confused if values do not appear to change on the graph. Another benefit of
    this feature is you will not get duplicated data when you export the content.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed the code in depth and guided you through the code
    operation and how to set the threshold values. In the next section, we are going
    to set up the dashboard to visualize the BPM value in different formats for better
    understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a dashboard for web and mobile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After uploading the code to the device, it’s now time to set up the dashboard
    for web and mobile to visualize the data with different widgets. The following
    figure demonstrates how this visualization might look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.10 – Thing dashboard](img/B19752_12_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.10 – Thing dashboard
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we have a BPM reading, and to visualize it, we have
    used two widgets, **Value** and **Advanced Chart**. The **Value** widget on the
    left of the screen shows the real-time **BPM** values, while the **Advanced Chart**
    widget illustrates the real-time readings as well as historical readings for proper
    analysis, just like an ECG machine display. Both widgets are attached to the BPM
    cloud variable.
  prefs: []
  type: TYPE_NORMAL
- en: The **Advanced Chart** widget is a new addition to the widgets on offer, and
    comes with a variety of features including different chart formats such as line,
    spline, spline/line area, and bar charts, with the option to customize the color
    of the plot. Another big feature is the ability to visualize multiple cloud variables
    on the same chart, which is not available in simpler chart widgets. We will use
    that feature in upcoming projects for a proper demonstration.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we briefly discussed some widgets and why these widgets are
    used in our dashboard. Next, we will set up the notification service using Zapier,
    which will send an email/SMS when the pulse is detected as going above or below
    our thresholds.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the notification service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multiple platforms provide **Software-as-a-Service** (**SaaS**) infrastructure
    and operate as a bridge between a variety of applications to make interoperability
    easy. Platforms for this purpose include **Zapier**, **IFTTT**, and **Integromat**,
    and provide an interface to integrate other platforms into the Arduino IoT Cloud
    platform to fulfill the requirements instead of developing the required features
    from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: So firstly, we need to understand why we need the Zapier automation platform.
    In our current project, we want to send notifications by email/SMS when a specific
    threshold is met, but the Arduino IoT Cloud only provides the data visualization,
    webhooks, and API functionalities. We have two options to solve this problem.
    Either we need to develop a custom solution to send notifications by email/SMS
    using Arduino webhooks and APIs, or we can use an automation platform such as
    Zapier or IFTTT, which will save time and reduce costs compared to the first option.
  prefs: []
  type: TYPE_NORMAL
- en: For this exercise, we will use Zapier, which will receive the data via **Arduino
    webhooks**. We will apply Zapier filters in Zaps to manage the threshold, and
    when the threshold is crossed, Zapier will send an email notification about BPM
    levels. A *Zap* is a term used in Zapier to describe an automated workflow that
    allows you to connect apps and services together, and each Zap can consist of
    multiple actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving onto the main steps, first sign up to [zapier.com](http://zapier.com)
    and use the trial version, as the Zapier webhooks we are going to use are only
    available under the *Professional plan*. The following screenshot demonstrates
    the trigger and two actions required to set up our notification functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.11 – Zapier complete notification Zap](img/B19752_12_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.11 – Zapier complete notification Zap
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps to create this, which we will work through for the remainder of this
    section, are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we need to set up the **webhook trigger**, which will provide a URL.
    This URL should be inserted into the **Thing** by clicking on **Set Webhook**
    on the Arduino IoT Cloud Thing page. This trigger will be responsible for receiving
    the data from the Arduino IoT Cloud.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the second step, we apply the filter on the BPM value, which specifies that
    if the BPM is greater than 100 or less than 60, then proceed to the next action;
    otherwise, the BPM is normal and there is no need to send a notification.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we will use the **Email by Zapier** or **Gmail** option to send the
    notification. We add multiple actions to the Zap. To keep things easy and manageable,
    we chose to use a simple email notification. Alternatively, you could also use
    **Twillo** to send SMS notifications to recipients.
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, we have discussed the different triggers and actions step by step
    that are required for notifications to be triggered and sent. The following points
    will guide you through these steps in Zapier:'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot gives a rough idea of how our setup looks in Zapier.
    To create a new Zap in Zapier, click the **Create** button and select **New Zap**,
    which will open a new page where you select the required triggers and actions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `Webhook` in the search bar and select the **Webhooks By Zapier** option,
    which is available under the Professional plan. Click on **Event** and select
    **Catch Hook**, then click **Continue**. In the **Trigger** tab, just leave the
    empty **Pick off a Child Key** textbox as is and proceed to the next step by clicking
    on the **Continue** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Test** tab, you will get the **webhook URL** – copy that and navigate
    to **Thing** in the Arduino IoT Cloud, then click on **Set Webhook**. Insert the
    URL into the window that pops up, then hit the **Save** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Come back to Zapier and click the **Test Trigger** button to verify whether
    data is arriving or not. Before you can verify this, the device must be powered
    on and connected to the internet to send the values. This might not work on your
    first try; if not, try again and you should see the data arriving, which means
    you are receiving the data successfully from the Arduino Thing. *Figure 12**.12*
    shows a trigger test, demonstrating the values received from the Arduino IoT Cloud
    pulse monitoring Thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.12 – Trigger test](img/B19752_12_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.12 – Trigger test
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding screenshot shows Zapier successfully receiving the data from
    the Arduino IoT Cloud Thing. In the red box, we can see **bPM** and **value**.
    The **value** parameter will be used in the next action. Click the **Continue**
    button and a new **Action** popup will appear. Here, we need to configure the
    filter action where we will set the threshold for our BPM notification, as shown
    in *Figure 12**.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.13 – Filter action](img/B19752_12_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.13 – Filter action
  prefs: []
  type: TYPE_NORMAL
- en: Type `Filter` in the search box and select `100` in the next input field. This
    sets the upper threshold value to 100 BPM. Next, click `60` in the next field.
    Lastly, click on **Continue**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our filter is ready; now, our email notification action is required to finish
    the setup. We have two options to send email notifications: either `Email` in
    the search box and click on **Email by Zapier**. Click on **Event** and select
    **Send Outbound Email**. In the next window, set all the parameters for the email
    receiver, subject, and body, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.14 – Email notification settings](img/B19752_12_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.14 – Email notification settings
  prefs: []
  type: TYPE_NORMAL
- en: Only three fields are mandatory here – insert the recipient email in the **To**
    field, write a relevant entry for the **Subject** field, and insert a message
    in the **Body** area. It’s up to you whether you fill the other fields or leave
    them blank. If you observe the preceding screenshot, you may notice I added **Values
    Value** to both the **Subject** and **Body** fields, which will display the values
    that triggered the notification in the email. Click the **Continue** button at
    the bottom of the page and test the action – if you receive the email with the
    BPM values, then publish the Zap and you are good to go.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we set up the notification services for our pulse monitor using
    Zapier. We created a Zap that consists of three steps. Firstly, we set up the
    webhook responsible for receiving the data. The second step deals with the threshold,
    and the third and final step handles sending the email notification.
  prefs: []
  type: TYPE_NORMAL
- en: What next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many more options available to explore, but these are left to you
    to work on, using different health sensors and development boards to do some more
    experiments and learn from them. In the current chapter, we only used one sensor
    that provided only one parameter, but there are many sensors on the market that
    provide a wide variety of functionalities including the monitoring of blood sugar,
    blood oxygen, blood pressure, body temperature, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try the following sensors to enhance your practical knowledge and compare this
    selection with other sensors in terms of features, ranges, and cost:'
  prefs: []
  type: TYPE_NORMAL
- en: LilyPad temperature sensor ([https://www.sparkfun.com/products/8777](https://www.sparkfun.com/products/8777))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High-sensitivity pulse oximeter and heart-rate sensor for wearables ([https://www.seeedstudio.com/MAXREFDES117-HEART-RATE-AND-PULSE-OXIMETRY-MONITOR-p-2762.html?queryID=51de6141574a711bbe455cb4894ce3fb&objectID=411&index
    Name=bazaar_retailer_products](https://www.seeedstudio.com/MAXREFDES117-HEART-RATE-AND-PULSE-OXIMETRY-MONITOR-p-2762.html?queryID=51de6141574a711bbe455cb4894ce3fb&objectID=411&indexName=bazaar_retailer_products))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fall detection module ([https://www.seeedstudio.com/24GHz-mmWave-Radar-Sensor-Fall-Detection-Module-p-5268.html](https://www.seeedstudio.com/24GHz-mmWave-Radar-Sensor-Fall-Detection-Module-p-5268.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open source Arduino blood glucose meter shield
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MIKROE series health sensors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored how to develop a low-cost wearable smart heart-rate
    monitoring system using the XIAO ESP32C3 and a pulse sensor. One important thing
    to note was the necessity of calibrating medical sensors before using them in
    the field. We set up a Thing, which included cloud variable creation, device association,
    network configuration, and coding for our development board. Later, we created
    a dashboard to visualize our sensor readings with different widgets to display
    both current readings and historical data with the help of graphs. Finally, we
    used Zapier to set up an email notification service based on thresholds using
    webhooks and saw how to employ webhooks to integrate third-party services with
    the Arduino IoT Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about scripting in the Arduino IoT Cloud
    with the **Arduino Cloud CLI** (**CCLI**). This is a command-line tool that provides
    access to Arduino IoT Cloud services via terminal commands. We will use the Arduino
    IoT Cloud CLI to automate bulk operations, including bulk device creation, which
    will help us to minimize the time required for operations and maintenance.
  prefs: []
  type: TYPE_NORMAL
