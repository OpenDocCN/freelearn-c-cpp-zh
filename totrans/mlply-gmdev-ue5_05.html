<html><head></head><body>
<div id="_idContainer090">
<h1 class="chapter-number" id="_idParaDest-106"><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-107"><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.2.1">Managing Actors in a Multiplayer Environment</span></h1>
<p><span class="koboSpan" id="kobo.3.1">To properly set up a multiplayer environment in UE5, it’s important that you understand how an Actor’s connection is managed, as well as how its attributes are relevant during a </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">game session.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, you will begin enhancing the player character (which currently is just an empty shell) to gain a comprehensive understanding of the previously mentioned concepts. </span><span class="koboSpan" id="kobo.5.2">To do this, you’ll add more components to the Character class (a camera is something you will absolutely need!) and implement the player </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">input logic.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">Additionally, you will learn why it is important to know who owns an Actor in a multiplayer environment and how it behaves depending on how it is relevant in </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">the level.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">By the end of the chapter, you will have solid knowledge of how to manage an Actor within an Unreal multiplayer game, allowing you to create more robust and efficient </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">multiplayer experiences.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">So, in this chapter, I will present you with the </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">Setting up </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">the character</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Controlling the connection of </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">an Actor</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">Actor relevancy</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.19.1">Introducing authority</span></span></li>
</ul>
<h1 id="_idParaDest-108"><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.20.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.21.1">To follow the topics presented in this chapter, you should have completed the previous chapter and understood </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">its content.</span></span></p>
<p><span class="koboSpan" id="kobo.23.1">Additionally, if you would prefer to begin with the code from the companion repository for this book, you can download the </span><strong class="source-inline"><span class="koboSpan" id="kobo.24.1">.zip</span></strong><span class="koboSpan" id="kobo.25.1"> project files </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">at </span></span><a href="https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5"><span class="No-Break"><span class="koboSpan" id="kobo.27.1">https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.28.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.29.1">You can download the files that are up to date with the end of the last chapter by clicking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.30.1">Unreal Shadows – </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.31.1">Chapter 04</span></strong></span><strong class="source-inline"> </strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.32.1">End</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.33.1"> link.</span></span></p>
<h1 id="_idParaDest-109"><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.34.1">Setting up the character</span></h1>
<p><span class="koboSpan" id="kobo.35.1">Before</span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.36.1"> I start writing about topics such as connections, authority, and roles, I need you to properly set up the player character – at the moment, our poor hero is just represented by an </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">empty class!</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">So, in this section, you will add a camera and some user input and set up the main functionalities that will allow the thief character to move around the level in search of treasures </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">and gold!</span></span></p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.40.1">Adding basic settings to the character</span></h2>
<p><span class="koboSpan" id="kobo.41.1">In the </span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.42.1">next few steps, you’ll add the components </span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.43.1">that will make up the third-person camera behavior and implement their logic. </span><span class="koboSpan" id="kobo.43.2">After that, you’ll set some default values for the components that are already available in the Character class: the Arrow, Capsule, and </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">SkeletalMesh components.</span></span></p>
<h3><span class="koboSpan" id="kobo.45.1">Adding a Camera component to the character</span></h3>
<p><span class="koboSpan" id="kobo.46.1">To </span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.47.1">get started, open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">US_Character.h</span></strong><span class="koboSpan" id="kobo.49.1"> header class. </span><span class="koboSpan" id="kobo.49.2">You </span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.50.1">will be adding a Camera component and a Spring component that will connect the camera to the Capsule component available in the Character class. </span><span class="koboSpan" id="kobo.50.2">To do this, add these two component declarations after the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">GENERATED_BODY()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.52.1"> macro:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.53.1">
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;class USpringArmComponent&gt; CameraBoom;
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;class UCameraComponent&gt; FollowCamera;</span></pre>
<p><span class="koboSpan" id="kobo.54.1">In </span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.55.1">the previous code block, we are declaring a</span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.56.1"> Camera component and a Spring component that will create the camera system. </span><span class="koboSpan" id="kobo.56.2">First, you will notice the </span><strong class="source-inline"><span class="koboSpan" id="kobo.57.1">UPROPERTY()</span></strong><span class="koboSpan" id="kobo.58.1"> declaration on both variables with some property specifiers. </span><span class="koboSpan" id="kobo.58.2">Let me </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">explain them:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.60.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">VisibleAnywhere</span></strong><span class="koboSpan" id="kobo.62.1"> property indicates that this property is visible in all related windows of the Unreal Engine Editor but cannot </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">be edited</span></span></li>
<li><span class="koboSpan" id="kobo.64.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">BlueprintReadOnly</span></strong><span class="koboSpan" id="kobo.66.1"> property indicates that this property can be read by Blueprints but </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">not modified</span></span></li>
<li><span class="koboSpan" id="kobo.68.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">Category</span></strong><span class="koboSpan" id="kobo.70.1"> property specifies the category of the property when displayed in the </span><strong class="bold"><span class="koboSpan" id="kobo.71.1">Blueprint </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.72.1">Details</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.73.1"> panel</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.74.1">You will also notice a </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">meta</span></strong><span class="koboSpan" id="kobo.76.1"> declaration that lets you control how the property interacts with various aspects of Unreal Engine and the Editor: in this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">AllowPrivateAccess</span></strong><span class="koboSpan" id="kobo.78.1"> indicates that a private member should be accessible from a Blueprint. </span><span class="koboSpan" id="kobo.78.2">We need this as these properties’ accessibility is not explicitly declared, and so they default </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">private</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.82.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.83.1">For an exhaustive list of property specifiers, please check the official Epic Games documentation, which can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">here: </span></span><a href="https://docs.unrealengine.com/5.1/en-US/unreal-engine-uproperty-specifiers/"><span class="No-Break"><span class="koboSpan" id="kobo.85.1">https://docs.unrealengine.com/5.1/en-US/unreal-engine-uproperty-specifiers/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.86.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.87.1">Next, look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">class</span></strong><span class="koboSpan" id="kobo.89.1"> keyword before the type – this is a C++ </span><strong class="bold"><span class="koboSpan" id="kobo.90.1">class forward declaration</span></strong><span class="koboSpan" id="kobo.91.1">. </span><span class="koboSpan" id="kobo.91.2">If you are </span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.92.1">unfamiliar with this, it is a way to declare the class name and its members without providing the full class definition. </span><span class="koboSpan" id="kobo.92.2">This can be useful in situations where you want to use a class in a header file but do not want to include the entire class definition, which can make compilation slower and create </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">unnecessary dependencies.</span></span></p>
<p><span class="koboSpan" id="kobo.94.1">Lastly, you will notice the </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">TObjectPtr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.96.1"> template – this is a new addition in UE5 and has been introduced to replace raw pointers (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">USpringComponent*</span></strong><span class="koboSpan" id="kobo.98.1">) in header files with UProperties. </span><span class="koboSpan" id="kobo.98.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">TObjectPtr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.100.1"> template is intended only for member properties declared in the headers of your code. </span><span class="koboSpan" id="kobo.100.2">For functions and short-lived scope within your C++ code in </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">.cpp</span></strong><span class="koboSpan" id="kobo.102.1"> files, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">TObjectPtr&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.104.1"> provides no additional advantages over using </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">raw pointers.</span></span></p>
<p><span class="koboSpan" id="kobo.106.1">As the Camera and Spring components are private, you need to add two getter methods for them. </span><span class="koboSpan" id="kobo.106.2">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">public</span></strong><span class="koboSpan" id="kobo.108.1"> declaration of the header, locate this line </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.110.1">
virtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;</span></pre>
<p><span class="koboSpan" id="kobo.111.1">Then, below this line, add </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.113.1">
FORCEINLINE USpringArmComponent* GetCameraBoom() const { return CameraBoom; }
FORCEINLINE UCameraComponent* GetFollowCamera() const { return FollowCamera; }</span></pre>
<p><span class="koboSpan" id="kobo.114.1">These two</span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.115.1"> methods will let you access the pointer </span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.116.1">components, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">FORCEINLINE</span></strong><span class="koboSpan" id="kobo.118.1"> macro forces the code to be inlined; this is going to give your code some performance benefits as you will avoid a function call when using </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">this method.</span></span></p>
<h3><span class="koboSpan" id="kobo.120.1">Implementing the camera behavior</span></h3>
<p><span class="koboSpan" id="kobo.121.1">Now </span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.122.1">that your properties have been added, it’s time to add some code logic to handle them. </span><span class="koboSpan" id="kobo.122.2">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">.cpp</span></strong><span class="koboSpan" id="kobo.124.1"> file and add the following includes at </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">its top:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.126.1">
#include "Camera/CameraComponent.h"
#include "Components/CapsuleComponent.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "GameFramework/SpringArmComponent.h"</span></pre>
<p><span class="koboSpan" id="kobo.127.1">Then, inside the constructor (i.e., </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">AUS_Character::AUS_Character()</span></strong><span class="koboSpan" id="kobo.129.1">), add </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">this code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.131.1">
CameraBoom = CreateDefaultSubobject&lt;USpringArmComponent&gt;(TEXT("CameraBoom"));
CameraBoom-&gt;SetupAttachment(RootComponent);
CameraBoom-&gt;TargetArmLength = 800.0f;
CameraBoom-&gt;bUsePawnControlRotation = true;</span></pre>
<p><span class="koboSpan" id="kobo.132.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">CreateDefaultSubobject()&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.134.1"> is a function that is used to create a new subobject of a class that will be owned by another object. </span><span class="koboSpan" id="kobo.134.2">A </span><strong class="bold"><span class="koboSpan" id="kobo.135.1">Subobject</span></strong><span class="koboSpan" id="kobo.136.1"> is </span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.137.1">essentially</span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.138.1"> a component or a member variable of an object, and the method is typically called within an object’s constructor to initialize its subobjects (in this case, </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">the components).</span></span></p>
<p><span class="koboSpan" id="kobo.140.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">SetupAttachment()</span></strong><span class="koboSpan" id="kobo.142.1"> method will reparent a component to another one. </span><span class="koboSpan" id="kobo.142.2">In this case, you are attaching the Camera component to </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">RootComponent</span></strong><span class="koboSpan" id="kobo.144.1">, which is actually the </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">Capsule component.</span></span></p>
<p><span class="koboSpan" id="kobo.146.1">Let’s give the camera a similar treatment. </span><span class="koboSpan" id="kobo.146.2">Add this code block just after the previous lines </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.148.1">
FollowCamera = CreateDefaultSubobject&lt;UCameraComponent&gt;(TEXT("FollowCamera"));
FollowCamera-&gt;SetupAttachment(CameraBoom, USpringArmComponent::SocketName);
FollowCamera-&gt;bUsePawnControlRotation = false;</span></pre>
<p><span class="koboSpan" id="kobo.149.1">The only real difference here is that you are reparenting the camera to the Spring component instead of the </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">root one.</span></span></p>
<p><span class="koboSpan" id="kobo.151.1">You have </span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.152.1">just created some sort of “chain of command” where the camera is connected to the Spring component that is connected to the root of the Actor – this will let the camera follow the character with a “springy” behavior whenever the camera hits an obstacle and provide a better feel for </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">the player.</span></span></p>
<h3><span class="koboSpan" id="kobo.154.1">Setting up the default component properties</span></h3>
<p><span class="koboSpan" id="kobo.155.1">As a</span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.156.1"> last step, you’ll be modifying some properties to create a default setup for your Character class. </span><span class="koboSpan" id="kobo.156.2">In the constructor, add these lines </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.158.1">
bUseControllerRotationPitch = false;
bUseControllerRotationYaw = false;
bUseControllerRotationRoll = false;
GetCapsuleComponent()-&gt;InitCapsuleSize(60.f, 96.0f);
GetMesh()-&gt;SetRelativeLocation(FVector(0.f, 0.f, -91.f));
static ConstructorHelpers::FObjectFinder&lt;USkeletalMesh&gt; SkeletalMeshAsset(TEXT("/Game/KayKit/Characters/rogue"));
if (SkeletalMeshAsset.Succeeded())
{
   GetMesh()-&gt;SetSkeletalMesh(SkeletalMeshAsset.Object);
}
GetCharacterMovement()-&gt;bOrientRotationToMovement = true;
GetCharacterMovement()-&gt;RotationRate = FRotator(0.0f, 500.0f, 0.0f);
GetCharacterMovement()-&gt;MaxWalkSpeed = 500.f;
GetCharacterMovement()-&gt;MinAnalogWalkSpeed = 20.f;
GetCharacterMovement()-&gt;BrakingDecelerationWalking = 2000.f;</span></pre>
<p><span class="koboSpan" id="kobo.159.1">Here, you are</span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.160.1"> just changing some of the default values of the character Actor and its components. </span><span class="koboSpan" id="kobo.160.2">The only thing to note is that you are getting the character model and assigning it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">SkeletalMeshComponent</span></strong><span class="koboSpan" id="kobo.162.1"> by means of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">FObjectFinder()</span></strong><span class="koboSpan" id="kobo.164.1"> utility method available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">ConstructorHelpers</span></strong><span class="koboSpan" id="kobo.166.1"> class you’ve </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">used before.</span></span></p>
<h3><span class="koboSpan" id="kobo.168.1">Updating the Character Blueprint</span></h3>
<p><span class="koboSpan" id="kobo.169.1">Now it’s time to compile your</span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.170.1"> project, just to check that you don’t have any syntax errors and that the character has been properly set up. </span><span class="koboSpan" id="kobo.170.2">To do this, save your files, go back to the Unreal Editor, and click the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.171.1">Compile</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.172.1"> button.</span></span></p>
<p><span class="koboSpan" id="kobo.173.1">Once the compilation phase has finished, open the </span><strong class="bold"><span class="koboSpan" id="kobo.174.1">BP_Character</span></strong><span class="koboSpan" id="kobo.175.1"> Blueprint, and you should notice that your changes didn’t show up. </span><span class="koboSpan" id="kobo.175.2">This happens because the Blueprint has not been updated. </span><span class="koboSpan" id="kobo.175.3">To fix this, select </span><strong class="bold"><span class="koboSpan" id="kobo.176.1">File</span></strong><span class="koboSpan" id="kobo.177.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.178.1">Refresh All nodes</span></strong><span class="koboSpan" id="kobo.179.1">. </span><span class="koboSpan" id="kobo.179.2">You should now see the </span><strong class="bold"><span class="koboSpan" id="kobo.180.1">Camera Boom</span></strong><span class="koboSpan" id="kobo.181.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.182.1">Follow Camera</span></strong><span class="koboSpan" id="kobo.183.1"> elements added to the hierarchy in the </span><strong class="bold"><span class="koboSpan" id="kobo.184.1">Components</span></strong><span class="koboSpan" id="kobo.185.1"> panel, as depicted in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.186.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.187.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer075">
<span class="koboSpan" id="kobo.189.1"><img alt="Figure 5.1 – The newly added character components" src="image/Figure_05_01_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.190.1">Figure 5.1 – The newly added character components</span></p>
<p><span class="koboSpan" id="kobo.191.1">You probably still won’t see the updated mesh in the SkeletalMesh component. </span><span class="koboSpan" id="kobo.191.2">To fix this, take the </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.193.1">Select the </span><strong class="bold"><span class="koboSpan" id="kobo.194.1">Mesh</span></strong><span class="koboSpan" id="kobo.195.1"> elements in the </span><strong class="bold"><span class="koboSpan" id="kobo.196.1">Components</span></strong><span class="koboSpan" id="kobo.197.1"> panel and look for the </span><strong class="bold"><span class="koboSpan" id="kobo.198.1">Skeletal Mesh Asset</span></strong><span class="koboSpan" id="kobo.199.1"> field in the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.200.1">Details</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.201.1"> panel.</span></span></li>
<li><span class="koboSpan" id="kobo.202.1">If </span><strong class="bold"><span class="koboSpan" id="kobo.203.1">Skeletal Mesh Asset</span></strong><span class="koboSpan" id="kobo.204.1"> shows a value of </span><strong class="bold"><span class="koboSpan" id="kobo.205.1">None</span></strong><span class="koboSpan" id="kobo.206.1">, click on the </span><strong class="bold"><span class="koboSpan" id="kobo.207.1">Reset Property</span></strong><span class="koboSpan" id="kobo.208.1"> arrow next to it, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.209.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.210.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer076">
<span class="koboSpan" id="kobo.212.1"><img alt="Figure 5.2 – The Reset Property button" src="image/Figure_05_02_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.213.1">Figure 5.2 – The Reset Property button</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.214.1">Double-check the </span><strong class="bold"><span class="koboSpan" id="kobo.215.1">Use Controller Rotation Yaw Y</span></strong><span class="koboSpan" id="kobo.216.1"> property, as it may also need </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">a reset.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.218.1">Now you </span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.219.1">should be able to see the viewport updated with the selected mesh added to it, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.220.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.221.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer077">
<span class="koboSpan" id="kobo.223.1"><img alt="Figure 5.3 – The updated character Blueprint" src="image/Figure_05_03_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.224.1">Figure 5.3 – The updated character Blueprint</span></p>
<p><span class="koboSpan" id="kobo.225.1">With your character set up, it’s time to make it move by adding some </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">user interaction.</span></span></p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.227.1">Adding interaction to the character</span></h2>
<p><span class="koboSpan" id="kobo.228.1">Now we </span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.229.1">will add input settings for the character. </span><span class="koboSpan" id="kobo.229.2">To do this, we will </span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.230.1">be using the new </span><strong class="bold"><span class="koboSpan" id="kobo.231.1">Enhanced Input System</span></strong><span class="koboSpan" id="kobo.232.1"> that</span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.233.1"> has been introduced in UE5. </span><span class="koboSpan" id="kobo.233.2">This new system provides developers with more advanced features than the previous one (known simply as the Input System), such as complex input handling and runtime control remapping. </span><span class="koboSpan" id="kobo.233.3">As the old system is being deprecated, it will probably be removed from Unreal Engine sooner or later, so it is best to stay updated on </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">the changes.</span></span></p>
<p><span class="koboSpan" id="kobo.235.1">The most important thing to know about the Enhanced Input System is how it communicates with your code: this is achieved through </span><strong class="bold"><span class="koboSpan" id="kobo.236.1">Input Actions</span></strong><span class="koboSpan" id="kobo.237.1"> that represent what the character can do during play (i.e., walk, jump, or attack). </span><span class="koboSpan" id="kobo.237.2">A </span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.238.1">group of Input Actions can be collected inside </span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.239.1">an </span><strong class="bold"><span class="koboSpan" id="kobo.240.1">Input Mapping Context</span></strong><span class="koboSpan" id="kobo.241.1"> that represents a set of rules for what will trigger the </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">included actions.</span></span></p>
<p><span class="koboSpan" id="kobo.243.1">At runtime, UE5 will check a list of </span><strong class="bold"><span class="koboSpan" id="kobo.244.1">Input Triggers</span></strong><span class="koboSpan" id="kobo.245.1"> to determine how user input activated an Input Action, validating patterns such</span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.246.1"> as long presses, release events, or double-clicks. </span><span class="koboSpan" id="kobo.246.2">Before triggering inputs, the system can pre-process the raw input through a list </span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.247.1">of </span><strong class="bold"><span class="koboSpan" id="kobo.248.1">Input Modifiers</span></strong><span class="koboSpan" id="kobo.249.1"> that will alter the data, such as setting a custom dead zone for the thumbstick or getting a negative value from the </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">input itself.</span></span></p>
<p><span class="koboSpan" id="kobo.251.1">In this section, you’ll create some basic interaction for your character, which needs to move, sprint, and interact with objects (we’ll leave the attack actions to later chapters). </span><span class="koboSpan" id="kobo.251.2">The sprint and interact actions will be activated by pressing a button, while the move action</span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.252.1"> will be controlled by a keyboard/mouse combo</span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.253.1"> or by the </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">controller thumbsticks.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.255.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.256.1">If you want to explore the full range of possibilities offered by the</span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.257.1"> Enhanced Input System, you can check the official documentation by visiting this web </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">page: </span></span><a href="https://docs.unrealengine.com/5.1/en-US/enhanced-input-in-unreal-engine/"><span class="No-Break"><span class="koboSpan" id="kobo.259.1">https://docs.unrealengine.com/5.1/en-US/enhanced-input-in-unreal-engine/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.260.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.261.1">Creating Input Actions</span></h3>
<p><span class="koboSpan" id="kobo.262.1">To start</span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.263.1"> creating Input Actions, take the </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.265.1">Open your </span><strong class="bold"><span class="koboSpan" id="kobo.266.1">Content Browser</span></strong><span class="koboSpan" id="kobo.267.1"> and add a folder </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">Input</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.271.1">Inside the folder, right-click and select </span><strong class="bold"><span class="koboSpan" id="kobo.272.1">Input</span></strong><span class="koboSpan" id="kobo.273.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.274.1">Input Action</span></strong><span class="koboSpan" id="kobo.275.1"> to create an Input </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">Action asset.</span></span></li>
<li><span class="koboSpan" id="kobo.277.1">Name </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">IA_Interact</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.281.1">Create three other Input Actions and name them </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">IA_Look</span></strong><span class="koboSpan" id="kobo.283.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">IA_Move</span></strong><span class="koboSpan" id="kobo.285.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">IA_Sprint</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.289.1">Let’s begin editing the </span><strong class="bold"><span class="koboSpan" id="kobo.290.1">IA_Interact</span></strong><span class="koboSpan" id="kobo.291.1"> action – we need it to be activated by a single press of a button (or key), and this action should be dispatched the moment the button has been pressed. </span><span class="koboSpan" id="kobo.291.2">To do so, double-click on the asset to open it and do </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">the following:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.293.1">Click on the </span><strong class="bold"><span class="koboSpan" id="kobo.294.1">+</span></strong><span class="koboSpan" id="kobo.295.1"> button next to the </span><strong class="bold"><span class="koboSpan" id="kobo.296.1">Triggers</span></strong><span class="koboSpan" id="kobo.297.1"> field to add </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">a trigger.</span></span></li>
<li><span class="koboSpan" id="kobo.299.1">Click the dropdown that should have been created and select </span><strong class="bold"><span class="koboSpan" id="kobo.300.1">Pressed</span></strong><span class="koboSpan" id="kobo.301.1"> – this option will avoid dispatching multiple events if the player holds </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">the button.</span></span></li>
<li><span class="koboSpan" id="kobo.303.1">Leave the rest as it is – just check that </span><strong class="bold"><span class="koboSpan" id="kobo.304.1">Value Type</span></strong><span class="koboSpan" id="kobo.305.1"> has been set to the default value of </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.306.1">Digital (bool)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.308.1">The final result</span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.309.1"> of the interact action asset is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.310.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.311.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer078">
<span class="koboSpan" id="kobo.313.1"><img alt="Figure 5.4 – The interact action settings" src="image/Figure_05_04_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.314.1">Figure 5.4 – The interact action settings</span></p>
<p><span class="koboSpan" id="kobo.315.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.316.1">IA_Sprint</span></strong><span class="koboSpan" id="kobo.317.1"> action is pretty similar to the interact one but needs to trigger a press event when the character starts sprinting and trigger a release event when the character </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">stops sprinting.</span></span></p>
<p><span class="koboSpan" id="kobo.319.1">Double-click on the </span><strong class="bold"><span class="koboSpan" id="kobo.320.1">IA_Sprint</span></strong><span class="koboSpan" id="kobo.321.1"> asset to open it and change the settings as </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">described here:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.323.1">Add two triggers by clicking the </span><strong class="bold"><span class="koboSpan" id="kobo.324.1">+</span></strong><span class="koboSpan" id="kobo.325.1"> button next to the </span><strong class="bold"><span class="koboSpan" id="kobo.326.1">Triggers</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.327.1">field twice.</span></span></li>
<li><span class="koboSpan" id="kobo.328.1">Click the first dropdown that should have been created and </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">select </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.330.1">Pressed</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.332.1">Click the second dropdown and </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">select </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.334.1">Released</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.336.1">Leave the rest as it is, checking that </span><strong class="bold"><span class="koboSpan" id="kobo.337.1">Value Type</span></strong><span class="koboSpan" id="kobo.338.1"> has been set to the default value of </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.339.1">Digital (bool)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.341.1">The final result of </span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.342.1">the sprint action asset is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.343.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.344.1">.5</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer079">
<span class="koboSpan" id="kobo.346.1"><img alt="Figure 5.5 – The sprint action settings" src="image/Figure_05_05_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.347.1">Figure 5.5 – The sprint action settings</span></p>
<p><span class="koboSpan" id="kobo.348.1">It’s time to set up the </span><strong class="bold"><span class="koboSpan" id="kobo.349.1">IA_Move</span></strong><span class="koboSpan" id="kobo.350.1"> asset, so open it and simply change </span><strong class="bold"><span class="koboSpan" id="kobo.351.1">Value Type</span></strong><span class="koboSpan" id="kobo.352.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.353.1">Axis2D (Vector2D)</span></strong><span class="koboSpan" id="kobo.354.1"> as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.355.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.356.1">.6</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer080">
<span class="koboSpan" id="kobo.358.1"><img alt="Figure 5.6 – The move action settings" src="image/Figure_05_06_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.359.1">Figure 5.6 – The move action settings</span></p>
<p><span class="koboSpan" id="kobo.360.1">As a last step, open </span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.361.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.362.1">AI_Look</span></strong><span class="koboSpan" id="kobo.363.1"> asset and change </span><strong class="bold"><span class="koboSpan" id="kobo.364.1">Value Type</span></strong><span class="koboSpan" id="kobo.365.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.366.1">Axis2D (Vector2D)</span></strong><span class="koboSpan" id="kobo.367.1">, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.368.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.369.1">.7</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer081">
<span class="koboSpan" id="kobo.371.1"><img alt="Figure 5.7 – The look action settings" src="image/Figure_05_07_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.372.1">Figure 5.7 – The look action settings</span></p>
<p><span class="koboSpan" id="kobo.373.1">Now that the basic actions have been defined, it’s time to create the Mapping Context and set </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">its properties.</span></span></p>
<h3><span class="koboSpan" id="kobo.375.1">Setting up the Input Mapping Context</span></h3>
<p><span class="koboSpan" id="kobo.376.1">As explained already, a Mapping Context</span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.377.1"> refers to a set of Input Actions that identifies a specific situation in which the player may find themselves. </span><span class="koboSpan" id="kobo.377.2">The “context” you need to create here is the</span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.378.1"> base actions a character can do (move, look around, and interact), so it’s time to open the </span><strong class="bold"><span class="koboSpan" id="kobo.379.1">Content Browser</span></strong><span class="koboSpan" id="kobo.380.1"> and create </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">this asset:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.382.1">Right-click on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">Input</span></strong><span class="koboSpan" id="kobo.384.1"> folder and select </span><strong class="bold"><span class="koboSpan" id="kobo.385.1">Input</span></strong><span class="koboSpan" id="kobo.386.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.387.1">Input </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.388.1">Mapping Context</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.390.1">Name the newly created asset </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">IMC_Default</span></strong><span class="koboSpan" id="kobo.392.1"> and double-click on it to </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">start editing.</span></span></li>
<li><span class="koboSpan" id="kobo.394.1">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.395.1">+</span></strong><span class="koboSpan" id="kobo.396.1"> button next to the </span><strong class="bold"><span class="koboSpan" id="kobo.397.1">Mappings</span></strong><span class="koboSpan" id="kobo.398.1"> field. </span><span class="koboSpan" id="kobo.398.2">In the drop-down menu, </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">select </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.400.1">IA_Interact</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.402.1">Repeat this step three more times to add </span><strong class="bold"><span class="koboSpan" id="kobo.403.1">IA_Sprint</span></strong><span class="koboSpan" id="kobo.404.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.405.1">IA_Move</span></strong><span class="koboSpan" id="kobo.406.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">and </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.408.1">IA_Look</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.410.1">By the end of these steps, you should have something similar to </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.411.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.412.1">.8</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer082">
<span class="koboSpan" id="kobo.414.1"><img alt="Figure 5.8 – The Input Mapping Context panel" src="image/Figure_05_08_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.415.1">Figure 5.8 – The Input Mapping Context panel</span></p>
<p><span class="koboSpan" id="kobo.416.1">Now that the </span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.417.1">context has been created, it’s time to map the input the player will be using. </span><span class="koboSpan" id="kobo.417.2">As I have stated before, we’ll let them use a controller or a mix of keyboard and mouse interaction. </span><span class="koboSpan" id="kobo.417.3">At the moment, all mappings should be set to </span><strong class="bold"><span class="koboSpan" id="kobo.418.1">None</span></strong><span class="koboSpan" id="kobo.419.1">; this means that no input will pass through </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">this context.</span></span></p>
<p><span class="koboSpan" id="kobo.421.1">Let’s solve this by starting with the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.422.1">IA_Interact</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.423.1"> mapping:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.424.1">Click on the keyboard icon below </span><strong class="bold"><span class="koboSpan" id="kobo.425.1">IA_Interact</span></strong><span class="koboSpan" id="kobo.426.1"> and press the </span><em class="italic"><span class="koboSpan" id="kobo.427.1">I</span></em><span class="koboSpan" id="kobo.428.1"> (for Interact) key on </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">your keyboard.</span></span></li>
<li><span class="koboSpan" id="kobo.430.1">Then click on the </span><strong class="bold"><span class="koboSpan" id="kobo.431.1">+</span></strong><span class="koboSpan" id="kobo.432.1"> button to the right of the </span><strong class="bold"><span class="koboSpan" id="kobo.433.1">IA_Interact</span></strong><span class="koboSpan" id="kobo.434.1"> field to add </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">another mapping.</span></span></li>
<li><span class="koboSpan" id="kobo.436.1">From the drop-down menu, select </span><strong class="bold"><span class="koboSpan" id="kobo.437.1">Gamepad</span></strong><span class="koboSpan" id="kobo.438.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.439.1">Gamepad Face Button Bottom</span></strong><span class="koboSpan" id="kobo.440.1">. </span><span class="koboSpan" id="kobo.440.2">Alternatively, if you have a game controller connected to your PC, you can simply click on the keyboard icon and then press the corresponding button (for instance, the </span><em class="italic"><span class="koboSpan" id="kobo.441.1">A</span></em><span class="koboSpan" id="kobo.442.1"> button for an </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">Xbox controller).</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.444.1">Now we are </span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.445.1">going to set the mapping </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">for </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.447.1">IA_Sprint</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">:</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.449.1">Set </span><strong class="bold"><span class="koboSpan" id="kobo.450.1">Left Shift</span></strong><span class="koboSpan" id="kobo.451.1"> for if the player is using </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">the keyboard.</span></span></li>
<li><span class="koboSpan" id="kobo.453.1">Set </span><strong class="bold"><span class="koboSpan" id="kobo.454.1">Gamepad</span></strong><span class="koboSpan" id="kobo.455.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.456.1">Gamepad Left Thumbstick Button</span></strong><span class="koboSpan" id="kobo.457.1"> for if the player is using the controller (this second option will allow the player to press the thumbstick </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">to sprint).</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.459.1">Next, </span><strong class="bold"><span class="koboSpan" id="kobo.460.1">IA_Move</span></strong><span class="koboSpan" id="kobo.461.1"> will let the player use the left thumbstick controller or the usual WASD keys – this means you will add five interactions: one for the thumbstick and then four for the up, down, left, and right directions. </span><span class="koboSpan" id="kobo.461.2">Let’s add them to the Mapping Context, starting with the </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">thumbstick settings:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.463.1">Add </span><strong class="bold"><span class="koboSpan" id="kobo.464.1">Gamepad</span></strong><span class="koboSpan" id="kobo.465.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.466.1">Gamepad Left Thumbstick 2D-Axis</span></strong><span class="koboSpan" id="kobo.467.1"> to the mappings. </span><span class="koboSpan" id="kobo.467.2">Additionally, add a modifier from the </span><strong class="bold"><span class="koboSpan" id="kobo.468.1">Modifiers</span></strong><span class="koboSpan" id="kobo.469.1"> list with the value </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.470.1">Dead Zone</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.472.1">Moving on to the directions, for the right direction (mapped on your keyboard as </span><em class="italic"><span class="koboSpan" id="kobo.473.1">D</span></em><span class="koboSpan" id="kobo.474.1">), add a </span><strong class="bold"><span class="koboSpan" id="kobo.475.1">Keyboard</span></strong><span class="koboSpan" id="kobo.476.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.477.1">D</span></strong><span class="koboSpan" id="kobo.478.1"> mapping with </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">no modifiers.</span></span></li>
<li><span class="koboSpan" id="kobo.480.1">For the left direction (mapped on your keyboard as </span><em class="italic"><span class="koboSpan" id="kobo.481.1">A</span></em><span class="koboSpan" id="kobo.482.1">), add a </span><strong class="bold"><span class="koboSpan" id="kobo.483.1">Keyboard</span></strong><span class="koboSpan" id="kobo.484.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.485.1">A</span></strong><span class="koboSpan" id="kobo.486.1"> mapping. </span><span class="koboSpan" id="kobo.486.2">Then add a modifier with the value </span><strong class="bold"><span class="koboSpan" id="kobo.487.1">Negate</span></strong><span class="koboSpan" id="kobo.488.1">. </span><span class="koboSpan" id="kobo.488.2">This will grant negative values from this interaction (i.e., movements to the right are positive, while movements to the left </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">are negative).</span></span></li>
<li><span class="koboSpan" id="kobo.490.1">For the forward direction (mapped on your keyboard as </span><em class="italic"><span class="koboSpan" id="kobo.491.1">W</span></em><span class="koboSpan" id="kobo.492.1">), add a </span><strong class="bold"><span class="koboSpan" id="kobo.493.1">Keyboard</span></strong><span class="koboSpan" id="kobo.494.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.495.1">W</span></strong><span class="koboSpan" id="kobo.496.1"> mapping. </span><span class="koboSpan" id="kobo.496.2">Then, add a modifier with the value </span><strong class="bold"><span class="koboSpan" id="kobo.497.1">Swizzle Input Axis Values</span></strong><span class="koboSpan" id="kobo.498.1">, which will convert </span><em class="italic"><span class="koboSpan" id="kobo.499.1">x</span></em><span class="koboSpan" id="kobo.500.1"> values into </span><em class="italic"><span class="koboSpan" id="kobo.501.1">y</span></em><span class="koboSpan" id="kobo.502.1"> (and vice versa), so you’ll get a “forward” value for </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">your character.</span></span></li>
<li><span class="koboSpan" id="kobo.504.1">Lastly, for the backward direction (mapped on your keyboard as </span><em class="italic"><span class="koboSpan" id="kobo.505.1">S</span></em><span class="koboSpan" id="kobo.506.1">), add a </span><strong class="bold"><span class="koboSpan" id="kobo.507.1">Keyboard</span></strong><span class="koboSpan" id="kobo.508.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.509.1">S</span></strong><span class="koboSpan" id="kobo.510.1"> mapping. </span><span class="koboSpan" id="kobo.510.2">Then, add a modifier with the value </span><strong class="bold"><span class="koboSpan" id="kobo.511.1">Swizzle Input Axis Values</span></strong><span class="koboSpan" id="kobo.512.1"> and an additional one with the value </span><strong class="bold"><span class="koboSpan" id="kobo.513.1">Negate</span></strong><span class="koboSpan" id="kobo.514.1">. </span><span class="koboSpan" id="kobo.514.2">This will grant negative values from this interaction in a similar way to the left movement explained for the </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.515.1">A</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.516.1"> key.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.517.1">Finally, the </span><strong class="bold"><span class="koboSpan" id="kobo.518.1">IA_Look</span></strong><span class="koboSpan" id="kobo.519.1"> mapping is going to be controlled by the right thumbstick of the controller or by the movement of the mouse. </span><span class="koboSpan" id="kobo.519.2">To add such settings, take </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.521.1">From the drop-down menu, select </span><strong class="bold"><span class="koboSpan" id="kobo.522.1">Gamepad</span></strong><span class="koboSpan" id="kobo.523.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.524.1">Gamepad Right Thumbstick 2D-Axis</span></strong><span class="koboSpan" id="kobo.525.1"> for the controller. </span><span class="koboSpan" id="kobo.525.2">Additionally, add a modifier from the </span><strong class="bold"><span class="koboSpan" id="kobo.526.1">Modifiers</span></strong><span class="koboSpan" id="kobo.527.1"> list with a value of </span><strong class="bold"><span class="koboSpan" id="kobo.528.1">Dead Zone</span></strong><span class="koboSpan" id="kobo.529.1">, so the thumbstick won’t send data when in the </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">rest position.</span></span></li>
<li><span class="koboSpan" id="kobo.531.1">Select a </span><strong class="bold"><span class="koboSpan" id="kobo.532.1">Mouse</span></strong><span class="koboSpan" id="kobo.533.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.534.1">Mouse XY 2D-Axis</span></strong><span class="koboSpan" id="kobo.535.1"> interaction for the mouse. </span><span class="koboSpan" id="kobo.535.2">Then add a modifier from the </span><strong class="bold"><span class="koboSpan" id="kobo.536.1">Modifiers</span></strong><span class="koboSpan" id="kobo.537.1"> list with the value </span><strong class="bold"><span class="koboSpan" id="kobo.538.1">Negate</span></strong><span class="koboSpan" id="kobo.539.1"> and uncheck the </span><strong class="bold"><span class="koboSpan" id="kobo.540.1">X</span></strong><span class="koboSpan" id="kobo.541.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.542.1">Z</span></strong><span class="koboSpan" id="kobo.543.1"> checkboxes, leaving just the </span><strong class="bold"><span class="koboSpan" id="kobo.544.1">Y</span></strong><span class="koboSpan" id="kobo.545.1"> value selected. </span><span class="koboSpan" id="kobo.545.2">This will grant negative values for the mouse interaction – for instance, moving it forward will let the character move the</span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.546.1"> camera down, and moving it backward will move the </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">camera up.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.548.1">You should now have a Mapping Context similar to the one shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.549.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.550.1">.9</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer083">
<span class="koboSpan" id="kobo.552.1"><img alt="Figure 5.9 – The complete Mapping Context" src="image/Figure_05_09_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.553.1">Figure 5.9 – The complete Mapping Context</span></p>
<p><span class="koboSpan" id="kobo.554.1">Now that the </span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.555.1">Mapping Context has been defined, it’s time to set up the character so that it can receive input from </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">the player.</span></span></p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.557.1">Importing the Enhanced Input Module</span></h2>
<p><span class="koboSpan" id="kobo.558.1">Let’s get back</span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.559.1"> to the IDE, as you are now ready to add some components and code logic to your character. </span><span class="koboSpan" id="kobo.559.2">As we are using the Enhanced Input System, the first thing you will need to do is to add it to the module declaration in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">Build.cs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.561.1"> file.</span></span></p>
<p><span class="koboSpan" id="kobo.562.1">To do so, open </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">UnrealShadows_LOTL.Build.cs</span></strong><span class="koboSpan" id="kobo.564.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">Source</span></strong><span class="koboSpan" id="kobo.566.1"> folder of your C++ project (the name may vary slightly if your project was named in a different way). </span><span class="koboSpan" id="kobo.566.2">Then locate the following line </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.568.1">
PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore" });</span></pre>
<p><span class="koboSpan" id="kobo.569.1">Change it by adding the Enhanced </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">Input module:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.571.1">
PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "EnhancedInput" });</span></pre>
<p><span class="koboSpan" id="kobo.572.1">This will make the </span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.573.1">Enhanced Input module available to your project, and you’ll be ready to start implementing the user interaction, something that you’ll do </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">right now.</span></span></p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.575.1">Adding user interaction to the character</span></h2>
<p><span class="koboSpan" id="kobo.576.1">To add user </span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.577.1">interaction to the character, you will need to </span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.578.1">declare the Enhanced Input assets you created just a few </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">moments ago.</span></span></p>
<p><span class="koboSpan" id="kobo.580.1">In the next steps, you will declare the Mapping Context and action references to your code, along with the corresponding methods. </span><span class="koboSpan" id="kobo.580.2">After that, you’ll implement the code logic needed to handle all actions. </span><span class="koboSpan" id="kobo.580.3">Finally, you’ll declare these actions inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">character Blueprint.</span></span></p>
<h3><span class="koboSpan" id="kobo.582.1">Declaring input properties and functions</span></h3>
<p><span class="koboSpan" id="kobo.583.1">The first thing to do is</span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.584.1"> to add the needed asset references for the Mapping Context and the actions that should be added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">US_Character.h</span></strong><span class="koboSpan" id="kobo.586.1"> header file. </span><span class="koboSpan" id="kobo.586.2">Open the header file, which should already include the following lines of code (if not, add it as a </span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">public declaration):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.588.1">
virtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;</span></pre>
<p><span class="koboSpan" id="kobo.589.1">Next, declare a pointer to the Input Mapping Context and a pointer for each Input Action. </span><span class="koboSpan" id="kobo.589.2">To do this, add the following code in the class implicit </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">private</span></strong><span class="koboSpan" id="kobo.591.1"> section (i.e., just after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">GENERATED_BODY()</span></strong><span class="koboSpan" id="kobo.593.1"> macro), just after the </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">components declarations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.595.1">
UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Input", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;class UInputMappingContext&gt; DefaultMappingContext;
UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Input", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;class UInputAction&gt; MoveAction;
UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Input", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;UInputAction&gt; LookAction;
UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Input", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;UInputAction&gt; SprintAction;
UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Input", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;UInputAction&gt; InteractAction;</span></pre>
<p><span class="koboSpan" id="kobo.596.1">As a last step for the header declarations, add the following methods in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">protected</span></strong><span class="koboSpan" id="kobo.598.1"> section, just after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">BeginPlay()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.600.1">method declaration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.601.1">
void Move(const struct FInputActionValue&amp; Value);
void Look(const FInputActionValue&amp; Value);
void SprintStart(const FInputActionValue&amp; Value);
void SprintEnd(const FInputActionValue&amp; Value);
void Interact(const FInputActionValue&amp; Value);</span></pre>
<p><span class="koboSpan" id="kobo.602.1">As you can see, you</span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.603.1"> added a method for each of the interactions you defined before. </span><span class="koboSpan" id="kobo.603.2">Just remember that in the </span><strong class="bold"><span class="koboSpan" id="kobo.604.1">IA_Sprint</span></strong><span class="koboSpan" id="kobo.605.1"> asset, you declared a </span><strong class="bold"><span class="koboSpan" id="kobo.606.1">Pressed</span></strong><span class="koboSpan" id="kobo.607.1"> and a </span><strong class="bold"><span class="koboSpan" id="kobo.608.1">Released</span></strong><span class="koboSpan" id="kobo.609.1"> trigger, so you will need to handle them with two corresponding methods (i.e., </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">SprintStart()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.611.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">SprintEnd()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">).</span></span></p>
<h3><span class="koboSpan" id="kobo.614.1">Implementing the Mapping Context for the character</span></h3>
<p><span class="koboSpan" id="kobo.615.1">In the next steps, you’ll </span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.616.1">implement the Mapping Context by </span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.617.1">initializing it and binding each input action to the </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">corresponding methods.</span></span></p>
<p><span class="koboSpan" id="kobo.619.1">Open </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">US_Character.ccp</span></strong><span class="koboSpan" id="kobo.621.1"> and add the following block of code, which includes all the classes you’ll be using in the </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">next steps:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.623.1">
#include "Components/InputComponent.h"
#include "GameFramework/Controller.h"
#include "EnhancedInputComponent.h"
#include "EnhancedInputSubsystems.h"</span></pre>
<p><span class="koboSpan" id="kobo.624.1">Then, look for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">BeginPlay()</span></strong><span class="koboSpan" id="kobo.626.1"> method and, after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">Super</span></strong><span class="koboSpan" id="kobo.628.1"> declaration, add this block </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.630.1">
if (APlayerController* PlayerController = Cast&lt;APlayerController&gt;(Controller))
{
   if (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem&lt;UEnhancedInputLocalPlayerSubsystem&gt;(PlayerController-&gt;GetLocalPlayer()))
   {
      Subsystem-&gt;AddMappingContext(DefaultMappingContext, 0);
   }
}</span></pre>
<p><span class="koboSpan" id="kobo.631.1">The first line of code checks that the Controller is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">PlayerController</span></strong><span class="koboSpan" id="kobo.633.1"> by means of a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">Cast&lt;T&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.635.1"> template.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.636.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.637.1">When working in Unreal Engine, it is common to perform casts to specific classes frequently (as you already did in the previous chapters with Blueprints). </span><span class="koboSpan" id="kobo.637.2">You may already be used to casts in pure C++, but you should be aware that Unreal has slightly different behavior, as it is possible to safely cast to types that may not be valid. </span><span class="koboSpan" id="kobo.637.3">If you are used to regular C++ crashes in such cases, you’ll be happy to know that Unreal will simply return a </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">safer </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">nullptr</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.641.1">Then, the code will try to get an Enhanced Input Subsystem from the player and, if successful, will add a Mapping Context to it. </span><span class="koboSpan" id="kobo.641.2">From this point on, all the actions declared inside the context will be “tracked” by the </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">input system.</span></span></p>
<p><span class="koboSpan" id="kobo.643.1">Of course, you</span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.644.1"> will need to bind these actions to a </span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.645.1">corresponding method implementation (i.e., move, sprint, interact, etc.). </span><span class="koboSpan" id="kobo.645.2">To do this, look for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">SetupPlayerInputComponent()</span></strong><span class="koboSpan" id="kobo.647.1"> method and, after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">Super()</span></strong><span class="koboSpan" id="kobo.649.1"> declaration, add this block </span><span class="No-Break"><span class="koboSpan" id="kobo.650.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.651.1">
if (UEnhancedInputComponent* EnhancedInputComponent = Cast&lt;UEnhancedInputComponent&gt;(PlayerInputComponent))
{
   EnhancedInputComponent-&gt;BindAction(MoveAction, ETriggerEvent::Triggered, this, &amp;AUS_Character::Move);
   EnhancedInputComponent-&gt;BindAction(LookAction, ETriggerEvent::Triggered, this, &amp;AUS_Character::Look);
   EnhancedInputComponent-&gt;BindAction(InteractAction, ETriggerEvent::Started, this, &amp;AUS_Character::Interact);
   EnhancedInputComponent-&gt;BindAction(SprintAction, ETriggerEvent::Started, this, &amp;AUS_Character::SprintStart);
   EnhancedInputComponent-&gt;BindAction(SprintAction, ETriggerEvent::Completed, this, &amp;AUS_Character::SprintEnd);
}</span></pre>
<p><span class="koboSpan" id="kobo.652.1">As you can see, we are calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">BindAction()</span></strong><span class="koboSpan" id="kobo.654.1"> method on the input component pointer to bind each action to the </span><span class="No-Break"><span class="koboSpan" id="kobo.655.1">corresponding method.</span></span></p>
<h3><span class="koboSpan" id="kobo.656.1">Implementing the actions</span></h3>
<p><span class="koboSpan" id="kobo.657.1">Now you are ready to implement the </span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.658.1">methods for each action. </span><span class="koboSpan" id="kobo.658.2">Let’s start with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">Move</span></strong><span class="koboSpan" id="kobo.660.1"> method. </span><span class="koboSpan" id="kobo.660.2">Add the following block </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.662.1">
void AUS_Character::Move(const FInputActionValue&amp; Value)
{
   const auto MovementVector = Value.Get&lt;FVector2D&gt;();
   GEngine-&gt;AddOnScreenDebugMessage(0, 5.f, FColor::Yellow, FString::Printf(TEXT("MovementVector: %s"), *MovementVector.ToString()));
   if (Controller != nullptr)
   {
      const auto Rotation = Controller-&gt;GetControlRotation();
      const FRotator YawRotation(0, Rotation.Yaw, 0);
      const auto ForwardDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);
      const auto RightDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);
     AddMovementInput(ForwardDirection, MovementVector.Y);
      AddMovementInput(RightDirection, MovementVector.X);
   }
}</span></pre>
<p><span class="koboSpan" id="kobo.663.1">As you can see, the first thing that this code does is to get the 2D vector from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">Value</span></strong><span class="koboSpan" id="kobo.665.1"> parameter. </span><span class="koboSpan" id="kobo.665.2">This vector contains the</span><em class="italic"><span class="koboSpan" id="kobo.666.1"> x</span></em><span class="koboSpan" id="kobo.667.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.668.1">y</span></em><span class="koboSpan" id="kobo.669.1"> directions for the left thumbstick (or the keyboard) and indicates the direction in which the character should move. </span><span class="koboSpan" id="kobo.669.2">I have added an onscreen message to keep track of </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">this value.</span></span></p>
<p><span class="koboSpan" id="kobo.671.1">Next, if there is a Controller possessing this Actor, we compute the forward and right directions of the Character and move it in the corresponding direction (this is something you should already be familiar with if you’ve ever tried the Unreal Third </span><span class="No-Break"><span class="koboSpan" id="kobo.672.1">Person template).</span></span></p>
<p><span class="koboSpan" id="kobo.673.1">The next </span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.674.1">method you’ll be implementing is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">Look()</span></strong><span class="koboSpan" id="kobo.676.1"> one, so add these lines just after the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">Move()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.678.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.679.1">
void AUS_Character::Look(const FInputActionValue&amp; Value)
{
   const auto LookAxisVector = Value.Get&lt;FVector2D&gt;();
   GEngine-&gt;AddOnScreenDebugMessage(1, 5.f, FColor::Green, FString::Printf(TEXT("LookAxisVector: %s"), *LookAxisVector.ToString()));
   if (Controller != nullptr)
   {
      AddControllerYawInput(LookAxisVector.X);
      AddControllerPitchInput(LookAxisVector.Y);
   }
}</span></pre>
<p><span class="koboSpan" id="kobo.680.1">As you can see, we are getting the 2D vector from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">Value</span></strong><span class="koboSpan" id="kobo.682.1"> parameter that, this time, will come from the right thumbstick or the mouse. </span><span class="koboSpan" id="kobo.682.2">After that, we add a yaw/pitch to the Controller; this will cause the Spring component and, consequently, the Camera component, to rotate around </span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">the character.</span></span></p>
<p><span class="koboSpan" id="kobo.684.1">For the sprint action, the character has two methods available – one for starting the sprint and one for ending it. </span><span class="koboSpan" id="kobo.684.2">Add this code block after the </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">previous function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.686.1">
void AUS_Character::SprintStart(const FInputActionValue&amp; Value)
{
   GEngine-&gt;AddOnScreenDebugMessage(2, 5.f, FColor::Blue, TEXT("SprintStart"));
   GetCharacterMovement()-&gt;MaxWalkSpeed = 3000.f;
}
void AUS_Character::SprintEnd(const FInputActionValue&amp; Value)
{
   GEngine-&gt;AddOnScreenDebugMessage(2, 5.f, FColor::Blue, TEXT("SprintEnd"));
   GetCharacterMovement()-&gt;MaxWalkSpeed = 500.f;
}</span></pre>
<p><span class="koboSpan" id="kobo.687.1">This code simply increases the maximum speed of the character when it </span><span class="No-Break"><span class="koboSpan" id="kobo.688.1">is sprinting.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.689.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.690.1">The walk and sprint values are hardcoded; we will need to get these values from a dataset later on as we progress through </span><span class="No-Break"><span class="koboSpan" id="kobo.691.1">the book.</span></span></p>
<p><span class="koboSpan" id="kobo.692.1">The last</span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.693.1"> method you need to implement is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">Interact()</span></strong><span class="koboSpan" id="kobo.695.1"> one but, at the moment, we don’t have anything to interact with! </span><span class="koboSpan" id="kobo.695.2">So, you’ll just add an onscreen message inside </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">the function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.697.1">
void AUS_Character::Interact(const FInputActionValue&amp; Value)
{
   GEngine-&gt;AddOnScreenDebugMessage(3, 5.f, FColor::Red, TEXT("Interact"));
}</span></pre>
<p><span class="koboSpan" id="kobo.698.1">The last thing </span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.699.1">you need to do to make the character fully functional is to add the input assets to </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">the Blueprint.</span></span></p>
<h3><span class="koboSpan" id="kobo.701.1">Updating the character Blueprint</span></h3>
<p><span class="koboSpan" id="kobo.702.1">To update the</span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.703.1"> Blueprint, take the </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.705.1">Save all the files you have modified and get back to the </span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">Unreal Editor.</span></span></li>
<li><span class="koboSpan" id="kobo.707.1">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.708.1">Compile</span></strong><span class="koboSpan" id="kobo.709.1"> button and wait for the </span><span class="No-Break"><span class="koboSpan" id="kobo.710.1">success message.</span></span></li>
<li><span class="koboSpan" id="kobo.711.1">Open your </span><strong class="bold"><span class="koboSpan" id="kobo.712.1">BP_Character</span></strong><span class="koboSpan" id="kobo.713.1"> Blueprint and select the </span><strong class="bold"><span class="koboSpan" id="kobo.714.1">Class </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.715.1">Defaults</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.716.1"> section.</span></span></li>
<li><span class="koboSpan" id="kobo.717.1">Search for the </span><strong class="bold"><span class="koboSpan" id="kobo.718.1">Input</span></strong><span class="koboSpan" id="kobo.719.1"> category in the </span><strong class="bold"><span class="koboSpan" id="kobo.720.1">Details</span></strong><span class="koboSpan" id="kobo.721.1"> panel. </span><span class="koboSpan" id="kobo.721.2">You should get the </span><strong class="bold"><span class="koboSpan" id="kobo.722.1">Default Mapping Context</span></strong><span class="koboSpan" id="kobo.723.1"> property along with the four actions that have </span><span class="No-Break"><span class="koboSpan" id="kobo.724.1">been created.</span></span></li>
<li><span class="koboSpan" id="kobo.725.1">Click the drop-down button for </span><strong class="bold"><span class="koboSpan" id="kobo.726.1">Default Mapping Context</span></strong><span class="koboSpan" id="kobo.727.1"> and select the corresponding asset (there should be only one </span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">to choose).</span></span></li>
<li><span class="koboSpan" id="kobo.729.1">For each action property, select the corresponding action asset from the </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">drop-down menu.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.731.1">The result of the previous steps is depicted in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.732.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.733.1">.10</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer084">
<span class="koboSpan" id="kobo.735.1"><img alt="Figure 5.10 – The Blueprint input settings" src="image/Figure_05_10_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.736.1">Figure 5.10 – The Blueprint input settings</span></p>
<p><span class="koboSpan" id="kobo.737.1">The character is finally complete! </span><span class="koboSpan" id="kobo.737.2">It’s been hard, but you are now ready to </span><span class="No-Break"><span class="koboSpan" id="kobo.738.1">test it.</span></span></p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.739.1">Testing the character’s movement</span></h2>
<p><span class="koboSpan" id="kobo.740.1">Now </span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.741.1">that the base user interaction has been implemented, it’s time to start testing it on a playable level. </span><span class="koboSpan" id="kobo.741.2">Open the </span><strong class="bold"><span class="koboSpan" id="kobo.742.1">Level_01</span></strong><span class="koboSpan" id="kobo.743.1"> map and do </span><span class="No-Break"><span class="koboSpan" id="kobo.744.1">the following:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.745.1">Look for the </span><strong class="bold"><span class="koboSpan" id="kobo.746.1">SP 1</span></strong><span class="koboSpan" id="kobo.747.1"> (for </span><em class="italic"><span class="koboSpan" id="kobo.748.1">SpawnPoint 1</span></em><span class="koboSpan" id="kobo.749.1">) label in the level and add a </span><strong class="bold"><span class="koboSpan" id="kobo.750.1">Player Start</span></strong><span class="koboSpan" id="kobo.751.1"> Actor </span><span class="No-Break"><span class="koboSpan" id="kobo.752.1">near it.</span></span></li>
<li><span class="koboSpan" id="kobo.753.1">Set </span><strong class="bold"><span class="koboSpan" id="kobo.754.1">Net Mode</span></strong><span class="koboSpan" id="kobo.755.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.756.1">Listen Server</span></strong><span class="koboSpan" id="kobo.757.1"> with </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.758.1">3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.759.1"> players.</span></span></li>
<li><span class="koboSpan" id="kobo.760.1">Hit the </span><strong class="bold"><span class="koboSpan" id="kobo.761.1">Play</span></strong><span class="koboSpan" id="kobo.762.1"> button to test </span><span class="No-Break"><span class="koboSpan" id="kobo.763.1">the game.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.764.1">You should be able to move the characters and make them sprint and </span><span class="No-Break"><span class="koboSpan" id="kobo.765.1">look around.</span></span></p>
<p><span class="koboSpan" id="kobo.766.1">You may be wondering how it is possible that you are already playing a networked game even though you did not add any multiplayer code logic. </span><span class="koboSpan" id="kobo.766.2">The answer is in the Character class, which is already set to be replicated – just open the </span><strong class="bold"><span class="koboSpan" id="kobo.767.1">BP_Character</span></strong><span class="koboSpan" id="kobo.768.1"> Blueprint and look for the </span><strong class="bold"><span class="koboSpan" id="kobo.769.1">Replication</span></strong><span class="koboSpan" id="kobo.770.1"> category. </span><span class="koboSpan" id="kobo.770.2">You will find out that </span><strong class="bold"><span class="koboSpan" id="kobo.771.1">Replicate Movement</span></strong><span class="koboSpan" id="kobo.772.1"> has been set by default and also that the </span><strong class="bold"><span class="koboSpan" id="kobo.773.1">Replicates</span></strong><span class="koboSpan" id="kobo.774.1"> property is set </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">true</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.778.1">You may also have noticed that while the character on the server window moves and sprints smoothly, on the client’s window, movements seem a bit jumpy when you are running. </span><span class="koboSpan" id="kobo.778.2">This is happening because you are trying to execute the sprint action on the client, but the server is the one who is actually in command – as a result, the client will make the character move faster, but the server will bring it back to its move position. </span><span class="koboSpan" id="kobo.778.3">Basically, at the moment, we are trying to “cheat” on the client, but the server, which is authoritative, will forbid you from doing this. </span><span class="koboSpan" id="kobo.778.4">Obviously, this is a bug in our code, but we still have to understand the full meaning of replication and how to execute functions from </span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">the server.</span></span></p>
<p><span class="koboSpan" id="kobo.780.1">To fix this bug, you </span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.781.1">will need to know more about replication. </span><span class="koboSpan" id="kobo.781.2">Just be patient – I will give you more detailed information about this topic in </span><a href="B18203_06.xhtml#_idTextAnchor125"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.782.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.783.1">, </span><em class="italic"><span class="koboSpan" id="kobo.784.1">Replicating Properties </span></em><em class="italic"><span class="koboSpan" id="kobo.785.1">O</span></em><em class="italic"><span class="koboSpan" id="kobo.786.1">ver the Network</span></em><span class="koboSpan" id="kobo.787.1">, and </span><a href="B18203_07.xhtml#_idTextAnchor147"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.788.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.789.1">, </span><em class="italic"><span class="koboSpan" id="kobo.790.1">Using Remote Procedure </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.791.1">Calls (RPCs)</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.793.1">Now that you have created your own hero character from scratch, it’s time to get some knowledge on how an Actor connection is controlled: I will introduce this topic in the </span><span class="No-Break"><span class="koboSpan" id="kobo.794.1">next section.</span></span></p>
<h1 id="_idParaDest-115"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.795.1">Controlling the connection of an Actor</span></h1>
<p><span class="koboSpan" id="kobo.796.1">Now that you </span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.797.1">have created a fully working character, it’s time to understand how a connection is handled inside Unreal Engine (to quickly refresh your understanding of how connections work, you can refer back to </span><a href="B18203_02.xhtml#_idTextAnchor041"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.798.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.799.1">, </span><em class="italic"><span class="koboSpan" id="kobo.800.1">Understanding </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.801.1">Networking Basics</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.802.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.803.1">Each connection has its own </span><strong class="source-inline"><span class="koboSpan" id="kobo.804.1">PlayerController</span></strong><span class="koboSpan" id="kobo.805.1"> that has been created expressly for it; in this case, we say that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.806.1">PlayerController</span></strong><span class="koboSpan" id="kobo.807.1"> is “owned” by </span><span class="No-Break"><span class="koboSpan" id="kobo.808.1">that connection.</span></span></p>
<p><span class="koboSpan" id="kobo.809.1">In Unreal Engine, Actors can have an </span><strong class="bold"><span class="koboSpan" id="kobo.810.1">Owner</span></strong><span class="koboSpan" id="kobo.811.1">: if the outermost Owner of an Actor is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">PlayerController</span></strong><span class="koboSpan" id="kobo.813.1">, then the </span><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">PlayerController</span></strong><span class="koboSpan" id="kobo.815.1"> becomes the Owner of that Actor. </span><span class="koboSpan" id="kobo.815.2">This means that the first Actor is also owned by the</span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.816.1"> same connection that owns </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">PlayerController</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.819.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.820.1">The concept of ownership is used during Actor replication to determine which connections receive updates for each Actor: for instance, an Actor may be flagged so that only the connection that owns that Actor will be sent property updates </span><span class="No-Break"><span class="koboSpan" id="kobo.821.1">for it.</span></span></p>
<p><span class="koboSpan" id="kobo.822.1">As an example, let’s imagine that your thief character (which is basically an Actor) is possessed by a </span><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">PlayerController</span></strong><span class="koboSpan" id="kobo.824.1"> – this </span><strong class="source-inline"><span class="koboSpan" id="kobo.825.1">PlayerController</span></strong><span class="koboSpan" id="kobo.826.1"> will be the Owner of the character. </span><span class="koboSpan" id="kobo.826.2">During gameplay, the thief gets a pickup that grants a magical dagger: once equipped, this weapon will be owned by the Character. </span><span class="koboSpan" id="kobo.826.3">This means that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.827.1">PlayerController</span></strong><span class="koboSpan" id="kobo.828.1"> will also own the dagger. </span><span class="koboSpan" id="kobo.828.2">In the end, both the thief Actor and the dagger will be owned by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.829.1">PlayerController</span></strong><span class="koboSpan" id="kobo.830.1"> connection. </span><span class="koboSpan" id="kobo.830.2">As soon as the thief Actor is no longer possessed by the Player Controller, it will cease to be owned by the connection, and so will </span><span class="No-Break"><span class="koboSpan" id="kobo.831.1">the weapon.</span></span></p>
<p><span class="koboSpan" id="kobo.832.1">If you </span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.833.1">have developed standalone games, you may be used to retrieving the Player Controller or the character by using nodes such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">Get Player Controller</span></strong><span class="koboSpan" id="kobo.835.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">Get Player Character</span></strong><span class="koboSpan" id="kobo.837.1"> (or their corresponding C++ versions, </span><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">UGameplayStatics::GetPlayerController()</span></strong><span class="koboSpan" id="kobo.839.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.840.1">UGameplayStatics::GetPlayerCharacter()</span></strong><span class="koboSpan" id="kobo.841.1">). </span><span class="koboSpan" id="kobo.841.2">Using these functions in a networked environment may be the cause of many issues if you don’t know what you are doing, as you will get different results depending on </span><span class="No-Break"><span class="koboSpan" id="kobo.842.1">the context.</span></span></p>
<p><span class="koboSpan" id="kobo.843.1">As an example, calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">Get Player Controller</span></strong><span class="koboSpan" id="kobo.845.1"> function with </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">Player Index</span></strong><span class="koboSpan" id="kobo.847.1"> equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">0</span></strong><span class="koboSpan" id="kobo.849.1"> will give you the </span><span class="No-Break"><span class="koboSpan" id="kobo.850.1">following results:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.851.1">The listen server’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">PlayerController</span></strong><span class="koboSpan" id="kobo.853.1"> if you are calling it from a </span><span class="No-Break"><span class="koboSpan" id="kobo.854.1">listen server</span></span></li>
<li><span class="koboSpan" id="kobo.855.1">The first client’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.856.1">PlayerController</span></strong><span class="koboSpan" id="kobo.857.1"> if you are calling it from a </span><span class="No-Break"><span class="koboSpan" id="kobo.858.1">dedicated server</span></span></li>
<li><span class="koboSpan" id="kobo.859.1">The client’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.860.1">PlayerController</span></strong><span class="koboSpan" id="kobo.861.1"> if you are calling it from </span><span class="No-Break"><span class="koboSpan" id="kobo.862.1">a client</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.863.1">If things seem confusing, they will become even more so, considering that the index will not be consistent across the server and </span><span class="No-Break"><span class="koboSpan" id="kobo.864.1">different clients.</span></span></p>
<p><span class="koboSpan" id="kobo.865.1">That’s why, when developing multiplayer games in Unreal Engine, you will most probably use some of the following functions (or their </span><span class="No-Break"><span class="koboSpan" id="kobo.866.1">corresponding nodes):</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.867.1">AActor::GetOwner()</span></strong><span class="koboSpan" id="kobo.868.1">, which returns the Owner of an </span><span class="No-Break"><span class="koboSpan" id="kobo.869.1">Actor instance</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">APawn::GetController()</span></strong><span class="koboSpan" id="kobo.871.1">, which returns the Controller for the Pawn or </span><span class="No-Break"><span class="koboSpan" id="kobo.872.1">Character instance</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">AController::GetPawn()</span></strong><span class="koboSpan" id="kobo.874.1">, which returns the Pawn possessed by </span><span class="No-Break"><span class="koboSpan" id="kobo.875.1">the Controller</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">APlayerState::GetPlayerController()</span></strong><span class="koboSpan" id="kobo.877.1">, which will return the Player Controller that created the Player State instance (remote clients will return a </span><span class="No-Break"><span class="koboSpan" id="kobo.878.1">null value)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.879.1">Regarding </span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.880.1">components, you should be aware that they have their own way of determining their owning connection – they will start by following the component’s outer chain until they find the Actor that owns them. </span><span class="koboSpan" id="kobo.880.2">From there, the system will proceed, as explained previously, to determine the owning connection of that Actor. </span><span class="koboSpan" id="kobo.880.3">To get the Owner of the component, you’ll use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">UActorComponent::GetOwner()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.882.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.883.1">In this section, we have just “scratched the surface” of what an Owner is and how to get info about it, but you should be aware that connection ownership is so important that it will be pervasive throughout the rest of the book: in other words, the idea of owning a connection is deemed crucial enough to be addressed throughout the multiplayer project we </span><span class="No-Break"><span class="koboSpan" id="kobo.884.1">are developing.</span></span></p>
<p><span class="koboSpan" id="kobo.885.1">In the next section, I’m going to introduce a topic that is deeply connected with connection </span><span class="No-Break"><span class="koboSpan" id="kobo.886.1">ownership: relevancy.</span></span></p>
<h1 id="_idParaDest-116"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.887.1">Understanding Actor relevancy</span></h1>
<p><span class="koboSpan" id="kobo.888.1">Relevancy</span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.889.1"> is the process of </span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.890.1">determining which objects in a scene should be visible or updated based on their importance to the player. </span><span class="koboSpan" id="kobo.890.2">This is an important concept in Unreal Engine, and by understanding how it works, you can make sure your game runs efficiently. </span><span class="koboSpan" id="kobo.890.3">In this section, we will explore this topic and show an example of how it works depending on </span><span class="No-Break"><span class="koboSpan" id="kobo.891.1">its settings.</span></span></p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.892.1">Understanding relevancy</span></h2>
<p><span class="koboSpan" id="kobo.893.1">In Unreal Engine, the term </span><strong class="bold"><span class="koboSpan" id="kobo.894.1">relevancy</span></strong><span class="koboSpan" id="kobo.895.1"> refers to how the Engine determines which Actors in the game world </span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.896.1">should be replicated to which clients, based on their current locations, and which </span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.897.1">Actors are relevant to the player’s current view </span><span class="No-Break"><span class="koboSpan" id="kobo.898.1">or area.</span></span></p>
<p><span class="koboSpan" id="kobo.899.1">A game level can have a size varying from very small to really huge. </span><span class="koboSpan" id="kobo.899.2">This may pose a problem in updating everything on the network and for every client connected to the server. </span><span class="koboSpan" id="kobo.899.3">As the playing character may not need to know every single thing that’s happening in the level, most of the time, it’s just enough to let it know what </span><span class="No-Break"><span class="koboSpan" id="kobo.900.1">is near.</span></span></p>
<p><span class="koboSpan" id="kobo.901.1">As a consequence, the Engine uses several factors to let the player know if something has changed on an Actor: these factors span from the distance to the Actor itself, its visibility, and whether the Actor is currently active in the game world. </span><span class="koboSpan" id="kobo.901.2">An Actor that is deemed irrelevant will not be replicated to the player’s client, and this will reduce network traffic and improve </span><span class="No-Break"><span class="koboSpan" id="kobo.902.1">game performance.</span></span></p>
<p><span class="koboSpan" id="kobo.903.1">Unreal uses a virtual function named </span><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">AActor::IsNetRelevantFor()</span></strong><span class="koboSpan" id="kobo.905.1"> to test the relevancy of an Actor. </span><span class="koboSpan" id="kobo.905.2">This test evaluates a set of properties that is intended to provide a reliable estimate of the Actors that can actually influence a client. </span><span class="koboSpan" id="kobo.905.3">The tests can be summarized </span><span class="No-Break"><span class="koboSpan" id="kobo.906.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.907.1">First Check</span></strong><span class="koboSpan" id="kobo.908.1">: The Actor is relevant if the </span><span class="No-Break"><span class="koboSpan" id="kobo.909.1">following applies:</span></span><ul><li><span class="koboSpan" id="kobo.910.1">Its </span><strong class="source-inline"><span class="koboSpan" id="kobo.911.1">bAlwaysRelevant</span></strong><span class="koboSpan" id="kobo.912.1"> flag is set </span><span class="No-Break"><span class="koboSpan" id="kobo.913.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">true</span></strong></span></li><li><span class="koboSpan" id="kobo.915.1">Or, it is owned by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.916.1">Pawn</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.917.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.918.1">PlayerController</span></strong></span></li><li><span class="koboSpan" id="kobo.919.1">Or, it is the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.920.1">Pawn</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.921.1"> object</span></span></li><li><span class="koboSpan" id="kobo.922.1">Or, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.923.1">Pawn</span></strong><span class="koboSpan" id="kobo.924.1"> object is the instigator of an action such as noise </span><span class="No-Break"><span class="koboSpan" id="kobo.925.1">or damage</span></span></li></ul></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.926.1">Second Check</span></strong><span class="koboSpan" id="kobo.927.1">: If the Actor’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">bNetUseOwnerRelevancy</span></strong><span class="koboSpan" id="kobo.929.1"> property is </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">true</span></strong><span class="koboSpan" id="kobo.931.1"> and the Actor itself has an Owner, the owner’s relevancy will </span><span class="No-Break"><span class="koboSpan" id="kobo.932.1">be used.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.933.1">Third Check</span></strong><span class="koboSpan" id="kobo.934.1">: If the Actor has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.935.1">bOnlyRelevantToOwner</span></strong><span class="koboSpan" id="kobo.936.1"> property set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.937.1">true</span></strong><span class="koboSpan" id="kobo.938.1"> and does not pass the first check, then it is </span><span class="No-Break"><span class="koboSpan" id="kobo.939.1">not relevant.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.940.1">Fourth Check</span></strong><span class="koboSpan" id="kobo.941.1">: If the Actor is attached to another Actor’s skeleton, then its relevancy is determined by the relevancy of </span><span class="No-Break"><span class="koboSpan" id="kobo.942.1">its parent.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.943.1">Fifth Check</span></strong><span class="koboSpan" id="kobo.944.1">: If the Actor’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.945.1">bHidden</span></strong><span class="koboSpan" id="kobo.946.1"> property is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.947.1">true</span></strong><span class="koboSpan" id="kobo.948.1"> and the root component is not colliding with the checking Actor, then the Actor is </span><span class="No-Break"><span class="koboSpan" id="kobo.949.1">not relevant.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.950.1">Sixth Check</span></strong><span class="koboSpan" id="kobo.951.1">: if </span><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">AGameNetworkManager</span></strong><span class="koboSpan" id="kobo.953.1"> is set to use distance-based relevancy, the Actor is relevant if it is closer than the net </span><span class="No-Break"><span class="koboSpan" id="kobo.954.1">cull distance.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.955.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.956.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.957.1">Pawn</span></strong><span class="koboSpan" id="kobo.958.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.959.1">Character</span></strong><span class="koboSpan" id="kobo.960.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.961.1">PlayerController</span></strong><span class="koboSpan" id="kobo.962.1"> classes have slightly different relevancy checks as they need to consider additional information, such as the </span><span class="No-Break"><span class="koboSpan" id="kobo.963.1">movement component.</span></span></p>
<p><span class="koboSpan" id="kobo.964.1">It should be noted that this system is not perfect, as the distance check may give a false negative when dealing with large Actors. </span><span class="koboSpan" id="kobo.964.2">Additionally, the system does not take into account sound occlusion or other complexities related to ambient sounds. </span><span class="koboSpan" id="kobo.964.3">Nevertheless, the approximation is precise enough to get good results </span><span class="No-Break"><span class="koboSpan" id="kobo.965.1">during gameplay.</span></span></p>
<p><span class="koboSpan" id="kobo.966.1">After </span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.967.1">presenting</span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.968.1"> all this theory, it is time to shift our focus back to the project and begin implementing a tangible example. </span><span class="koboSpan" id="kobo.968.2">In the following subsection, you will see relevancy in action by testing </span><span class="No-Break"><span class="koboSpan" id="kobo.969.1">your character.</span></span></p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.970.1">Testing relevancy</span></h2>
<p><span class="koboSpan" id="kobo.971.1">To test the effect of relevancy during</span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.972.1"> gameplay, you’ll create a simple pickup and play around with </span><span class="No-Break"><span class="koboSpan" id="kobo.973.1">its settings.</span></span></p>
<h3><span class="koboSpan" id="kobo.974.1">Creating the Pickup Actor</span></h3>
<p><span class="koboSpan" id="kobo.975.1">Start by creating a new C++ class </span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.976.1">inheriting from </span><strong class="bold"><span class="koboSpan" id="kobo.977.1">AActor</span></strong><span class="koboSpan" id="kobo.978.1"> and call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.979.1">US_BasePickup</span></strong><span class="koboSpan" id="kobo.980.1">. </span><span class="koboSpan" id="kobo.980.2">Then, open the generated header file and add these two component declarations in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.981.1">private</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.982.1"> section:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.983.1">
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category="Components",  meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;class USphereComponent&gt; SphereCollision;
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category="Components", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;class UStaticMeshComponent&gt; Mesh;</span></pre>
<p><span class="koboSpan" id="kobo.984.1">You should be familiar with the previous code – we are just declaring the Collision component for triggering the pickup and the Mesh component for its </span><span class="No-Break"><span class="koboSpan" id="kobo.985.1">visual aspect.</span></span></p>
<p><span class="koboSpan" id="kobo.986.1">Next, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.987.1">protected</span></strong><span class="koboSpan" id="kobo.988.1"> section, just after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.989.1">BeginPlay()</span></strong><span class="koboSpan" id="kobo.990.1"> declaration, add a declaration that will handle the character overlap with </span><span class="No-Break"><span class="koboSpan" id="kobo.991.1">the Actor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.992.1">
UFUNCTION()
void OnBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult&amp; SweepResult);</span></pre>
<p><span class="koboSpan" id="kobo.993.1">Immediately after that, add the declaration for the </span><span class="No-Break"><span class="koboSpan" id="kobo.994.1">pickup action:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.995.1">
UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Pickup", meta=(DisplayName="Pickup"))
void Pickup(class AUS_Character* OwningCharacter);</span></pre>
<p><span class="koboSpan" id="kobo.996.1">We need this function to be callable inside a Blueprint, so we use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.997.1">BlueprintCallable</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.998.1"> specifier.</span></span></p>
<p><span class="koboSpan" id="kobo.999.1">Then, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1000.1">BlueprintNativeEvent</span></strong><span class="koboSpan" id="kobo.1001.1"> specifier states that the function can be overwritten by a Blueprint, but it also has a default native C++ implementation that will be called if the Blueprint does not </span><span class="No-Break"><span class="koboSpan" id="kobo.1002.1">implement anything.</span></span></p>
<p><span class="koboSpan" id="kobo.1003.1">To natively implement the method, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1004.1">US_BasePickup.cpp</span></strong><span class="koboSpan" id="kobo.1005.1"> file, we will need to implement a C++ function with the same name as the primary function but with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1006.1">_Implementation</span></strong><span class="koboSpan" id="kobo.1007.1"> added to </span><span class="No-Break"><span class="koboSpan" id="kobo.1008.1">the end.</span></span></p>
<p><span class="koboSpan" id="kobo.1009.1">Finally, to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1010.1">public</span></strong><span class="koboSpan" id="kobo.1011.1"> section – and after the corresponding properties, in order to avoid forward declarations – add two getters for the components we </span><span class="No-Break"><span class="koboSpan" id="kobo.1012.1">declared previously:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1013.1">
FORCEINLINE USphereComponent* GetSphereCollision() const { return SphereCollision; }
FORCEINLINE UStaticMeshComponent* GetMesh() const { return Mesh; }</span></pre>
<p><span class="koboSpan" id="kobo.1014.1">Now that the header has been fully declared, open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1015.1">US_BasePickup.cpp</span></strong><span class="koboSpan" id="kobo.1016.1"> file to start adding code logic to your Actor. </span><span class="koboSpan" id="kobo.1016.2">First of all, add the necessary includes at the top of </span><span class="No-Break"><span class="koboSpan" id="kobo.1017.1">the file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1018.1">
#include "US_Character.h"
#include "Components/SphereComponent.h"</span></pre>
<p><span class="koboSpan" id="kobo.1019.1">Then, inside the </span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.1020.1">constructor, add the following block of code, which creates the two components and attaches them to </span><span class="No-Break"><span class="koboSpan" id="kobo.1021.1">the Actor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1022.1">
SphereCollision = CreateDefaultSubobject&lt;USphereComponent&gt;("Collision");
RootComponent = SphereCollision;
SphereCollision-&gt;SetGenerateOverlapEvents(true);
SphereCollision-&gt;SetSphereRadius(200.0f);
Mesh = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;("Mesh");
Mesh-&gt;SetupAttachment(SphereCollision);
Mesh-&gt;SetCollisionEnabled(ECollisionEnabled::NoCollision);</span></pre>
<p><span class="koboSpan" id="kobo.1023.1">Immediately after that, set </span><strong class="source-inline"><span class="koboSpan" id="kobo.1024.1">bReplicates</span></strong><span class="koboSpan" id="kobo.1025.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1026.1">true</span></strong><span class="koboSpan" id="kobo.1027.1"> (as Actors do not replicate </span><span class="No-Break"><span class="koboSpan" id="kobo.1028.1">by default):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1029.1">
bReplicates = true;</span></pre>
<p><span class="koboSpan" id="kobo.1030.1">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1031.1">BeginPlay()</span></strong><span class="koboSpan" id="kobo.1032.1"> function, add a </span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.1033.1">dynamic multi-cast delegate for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1034.1">overlap event:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1035.1">
SphereCollision-&gt;OnComponentBeginOverlap.AddDynamic(this, &amp;AUS_BasePickup::OnBeginOverlap);</span></pre>
<p class="callout-heading"><span class="koboSpan" id="kobo.1036.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1037.1">To give proper attention and focus to replication, I have designated </span><a href="B18203_06.xhtml#_idTextAnchor125"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1038.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.1039.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1040.1">Replicating Properties </span></em><em class="italic"><span class="koboSpan" id="kobo.1041.1">O</span></em><em class="italic"><span class="koboSpan" id="kobo.1042.1">ver the Network</span></em><span class="koboSpan" id="kobo.1043.1">, for an in-depth exploration of </span><span class="No-Break"><span class="koboSpan" id="kobo.1044.1">this topic.</span></span></p>
<p><span class="koboSpan" id="kobo.1045.1">Now add the overlap handler just after the closing bracket of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1046.1">BeginPlay()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1047.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1048.1">
void AUS_BasePickup::OnBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,
                                    UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult&amp; SweepResult)
{
    if (const auto Character = Cast&lt;AUS_Character&gt;(OtherActor))
    {
        Pickup(Character);
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.1049.1">The previous block of code is quite straightforward: after having checked that the overlapping Actor is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1050.1">AUS_Character</span></strong><span class="koboSpan" id="kobo.1051.1"> (i.e., our multiplayer hero), we simply call the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1052.1">Pickup()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1053.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.1054.1">To complete the pickup logic, you will now add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1055.1">Pickup()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1056.1">C++ implementation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1057.1">
void AUS_BasePickup::Pickup_Implementation(AUS_Character * OwningCharacter)
{
   SetOwner(OwningCharacter);
}</span></pre>
<p><span class="koboSpan" id="kobo.1058.1">The code logic of this method can be implemented inside the inheriting Blueprints, but for the sake of demonstration, we are just setting the Owner of this Actor to the overlapping one: this is an important step in making things work in the next </span><span class="No-Break"><span class="koboSpan" id="kobo.1059.1">relevancy tests.</span></span></p>
<p><span class="koboSpan" id="kobo.1060.1">It’s now time to get back to the Unreal Engine Editor and do some “magic” – after all, this is a book about</span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.1061.1"> creating a </span><span class="No-Break"><span class="koboSpan" id="kobo.1062.1">fantasy game!</span></span></p>
<h3><span class="koboSpan" id="kobo.1063.1">Creating a pickup Blueprint class</span></h3>
<p><span class="koboSpan" id="kobo.1064.1">To test the effects of relevancy in </span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.1065.1">action, you’ll create a Blueprint pickup... </span><span class="koboSpan" id="kobo.1065.2">Well, sort of. </span><span class="koboSpan" id="kobo.1065.3">Upon first examination, relevancy can exhibit some peculiar tendencies. </span><span class="koboSpan" id="kobo.1065.4">This is precisely why we’ll be conjuring up a marvelously mystical tome that hovers </span><span class="No-Break"><span class="koboSpan" id="kobo.1066.1">in mid-air!</span></span></p>
<p><span class="koboSpan" id="kobo.1067.1">Open the Unreal Engine Editor and take the </span><span class="No-Break"><span class="koboSpan" id="kobo.1068.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1069.1">Compile your project to add the pickup to the available classes of </span><span class="No-Break"><span class="koboSpan" id="kobo.1070.1">your Blueprints.</span></span></li>
<li><span class="koboSpan" id="kobo.1071.1"> In your </span><strong class="source-inline"><span class="koboSpan" id="kobo.1072.1">Blueprints</span></strong><span class="koboSpan" id="kobo.1073.1"> folder, create a new </span><strong class="bold"><span class="koboSpan" id="kobo.1074.1">Blueprint Class</span></strong><span class="koboSpan" id="kobo.1075.1"> inheriting from </span><strong class="bold"><span class="koboSpan" id="kobo.1076.1">AUS_BasePickup</span></strong><span class="koboSpan" id="kobo.1077.1"> and name </span><span class="No-Break"><span class="koboSpan" id="kobo.1078.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1079.1">BP_SpellBook</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1080.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1081.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.1082.1">Blueprint Details</span></strong><span class="koboSpan" id="kobo.1083.1"> panel, select a mesh for the </span><strong class="bold"><span class="koboSpan" id="kobo.1084.1">Static Mesh</span></strong><span class="koboSpan" id="kobo.1085.1"> property – I opted for the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1086.1">spellBook</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1087.1"> model.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1088.1">To make the book float, we are going to move the mesh up and down by using a </span><strong class="bold"><span class="koboSpan" id="kobo.1089.1">Timeline </span></strong><span class="koboSpan" id="kobo.1090.1">node. </span><span class="koboSpan" id="kobo.1090.2">To do so, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.1091.1">these steps:</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.1092.1">Open the Blueprint Event Graph, right-click on the canvas, and add a </span><strong class="bold"><span class="koboSpan" id="kobo.1093.1">Timeline</span></strong><span class="koboSpan" id="kobo.1094.1"> node – give it a name such </span><span class="No-Break"><span class="koboSpan" id="kobo.1095.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1096.1">Float</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1097.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1098.1">Double-click on the node to open the </span><span class="No-Break"><span class="koboSpan" id="kobo.1099.1">corresponding editor.</span></span></li>
<li><span class="koboSpan" id="kobo.1100.1">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.1101.1">+ Track</span></strong><span class="koboSpan" id="kobo.1102.1"> button </span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.1103.1">to add a new </span><strong class="bold"><span class="koboSpan" id="kobo.1104.1">Float</span></strong><span class="koboSpan" id="kobo.1105.1"> track and name it </span><strong class="source-inline"><span class="koboSpan" id="kobo.1106.1">Alpha</span></strong><span class="koboSpan" id="kobo.1107.1">. </span><span class="koboSpan" id="kobo.1107.2">The button is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1108.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1109.1">.11</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1110.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer085">
<span class="koboSpan" id="kobo.1111.1"><img alt="Figure 5.11 – The Track button" src="image/Figure_05_11_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1112.1">Figure 5.11 – The Track button</span></p>
<ol>
<li value="7"><span class="koboSpan" id="kobo.1113.1">Click on the </span><strong class="bold"><span class="koboSpan" id="kobo.1114.1">Loop</span></strong><span class="koboSpan" id="kobo.1115.1"> button to enable the loop mode. </span><span class="koboSpan" id="kobo.1115.2">The button is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1116.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1117.1">.12</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1118.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer086">
<span class="koboSpan" id="kobo.1119.1"><img alt="Figure 5.12 – The Loop button" src="image/Figure_05_12_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1120.1">Figure 5.12 – The Loop button</span></p>
<ol>
<li value="8"><span class="koboSpan" id="kobo.1121.1">Right-click on the curve panel and select the </span><strong class="bold"><span class="koboSpan" id="kobo.1122.1">Add key to...</span></strong><span class="koboSpan" id="kobo.1123.1"> option. </span><span class="koboSpan" id="kobo.1123.2">Then, set </span><strong class="bold"><span class="koboSpan" id="kobo.1124.1">Time</span></strong><span class="koboSpan" id="kobo.1125.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.1126.1">0</span></strong><span class="koboSpan" id="kobo.1127.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.1128.1">Value</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1129.1">to </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1130.1">0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1131.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1132.1">Create another key, but this time set </span><strong class="bold"><span class="koboSpan" id="kobo.1133.1">Time</span></strong><span class="koboSpan" id="kobo.1134.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.1135.1">2.5</span></strong><span class="koboSpan" id="kobo.1136.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.1137.1">Value</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1138.1">to </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1139.1">0.5</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1140.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1141.1">Create one last key, this time with </span><strong class="bold"><span class="koboSpan" id="kobo.1142.1">Time</span></strong><span class="koboSpan" id="kobo.1143.1"> equal to </span><strong class="bold"><span class="koboSpan" id="kobo.1144.1">5</span></strong><span class="koboSpan" id="kobo.1145.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.1146.1">Value</span></strong><span class="koboSpan" id="kobo.1147.1"> equal </span><span class="No-Break"><span class="koboSpan" id="kobo.1148.1">to </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1149.1">0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1150.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1151.1"> Right-click on each of the keys and set the </span><strong class="bold"><span class="koboSpan" id="kobo.1152.1">Key Interpolation</span></strong><span class="koboSpan" id="kobo.1153.1"> value </span><span class="No-Break"><span class="koboSpan" id="kobo.1154.1">to </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1155.1">Auto</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1156.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1157.1">The final result of the </span><strong class="bold"><span class="koboSpan" id="kobo.1158.1">Timeline</span></strong><span class="koboSpan" id="kobo.1159.1"> node is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1160.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1161.1">.13</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1162.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer087">
<span class="koboSpan" id="kobo.1163.1"><img alt="Figure 5.13 – The Timeline node settings" src="image/Figure_05_13_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1164.1">Figure 5.13 – The Timeline node settings</span></p>
<p><span class="koboSpan" id="kobo.1165.1">You have just created a sinusoidal value that will indefinitely loop between 0 and 1 values; you’ll use this floating value to move the book up and down. </span><span class="koboSpan" id="kobo.1165.2">To implement this floating movement, return to the Event Graph and do </span><span class="No-Break"><span class="koboSpan" id="kobo.1166.1">the following:</span></span></p>
<ol>
<li value="12"><span class="koboSpan" id="kobo.1167.1">Connect the </span><strong class="bold"><span class="koboSpan" id="kobo.1168.1">Event Begin Play</span></strong><span class="koboSpan" id="kobo.1169.1"> node to the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1170.1">Timeline</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1171.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.1172.1">Drag the </span><strong class="bold"><span class="koboSpan" id="kobo.1173.1">Mesh</span></strong><span class="koboSpan" id="kobo.1174.1"> component from the </span><strong class="bold"><span class="koboSpan" id="kobo.1175.1">Components</span></strong><span class="koboSpan" id="kobo.1176.1"> panel onto the Event Graph canvas. </span><span class="koboSpan" id="kobo.1176.2">Click and drag from its outgoing pin to add a </span><strong class="bold"><span class="koboSpan" id="kobo.1177.1">Set Relative </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1178.1">Location</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1179.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.1180.1">Connect</span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.1181.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.1182.1">Set Relative Location</span></strong><span class="koboSpan" id="kobo.1183.1"> incoming execution pin to the </span><strong class="bold"><span class="koboSpan" id="kobo.1184.1">Update</span></strong><span class="koboSpan" id="kobo.1185.1"> execution pin of the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1186.1">Timeline</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1187.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.1188.1">Connect the </span><strong class="bold"><span class="koboSpan" id="kobo.1189.1">Timeline</span></strong><span class="koboSpan" id="kobo.1190.1"> node </span><strong class="bold"><span class="koboSpan" id="kobo.1191.1">Alpha</span></strong><span class="koboSpan" id="kobo.1192.1"> pin to a </span><strong class="bold"><span class="koboSpan" id="kobo.1193.1">Multiply</span></strong><span class="koboSpan" id="kobo.1194.1"> node and set the second parameter of this last node </span><span class="No-Break"><span class="koboSpan" id="kobo.1195.1">to </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1196.1">100</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1197.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1198.1">Right-click on the </span><strong class="bold"><span class="koboSpan" id="kobo.1199.1">New Location</span></strong><span class="koboSpan" id="kobo.1200.1"> pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.1201.1">Set Relative Location</span></strong><span class="koboSpan" id="kobo.1202.1"> node and select </span><strong class="bold"><span class="koboSpan" id="kobo.1203.1">Split Struct Pin</span></strong><span class="koboSpan" id="kobo.1204.1"> to expose the X, Y, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1205.1">Z values.</span></span></li>
<li><span class="koboSpan" id="kobo.1206.1">Connect the </span><strong class="bold"><span class="koboSpan" id="kobo.1207.1">Result</span></strong><span class="koboSpan" id="kobo.1208.1"> pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.1209.1">Multiply</span></strong><span class="koboSpan" id="kobo.1210.1"> node to </span><strong class="bold"><span class="koboSpan" id="kobo.1211.1">New Location Z</span></strong><span class="koboSpan" id="kobo.1212.1"> of the </span><strong class="bold"><span class="koboSpan" id="kobo.1213.1">Set Relative </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1214.1">Location</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1215.1"> node.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1216.1">The complete graph is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1217.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1218.1">.14</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1219.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer088">
<span class="koboSpan" id="kobo.1220.1"><img alt="Figure 5.14 – The floating book graph" src="image/Figure_05_14_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1221.1">Figure 5.14 – The floating book graph</span></p>
<p><span class="koboSpan" id="kobo.1222.1">Please note that this floating animation is purely a visual effect, so we just won’t worry about whether</span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.1223.1"> it is synchronized over </span><span class="No-Break"><span class="koboSpan" id="kobo.1224.1">the network.</span></span></p>
<p><span class="koboSpan" id="kobo.1225.1">Now that the Blueprint item has been created, it’s time to add it to the level and test its pickup functionality – something we are going to do in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1226.1">next subsection.</span></span></p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.1227.1">Testing the relevancy settings</span></h2>
<p><span class="koboSpan" id="kobo.1228.1">It’s now time to test how the </span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.1229.1">spell book behaves in a multiplayer environment when relevancy settings </span><span class="No-Break"><span class="koboSpan" id="kobo.1230.1">are changed.</span></span></p>
<p><span class="koboSpan" id="kobo.1231.1">First of all, drag an instance of the </span><strong class="bold"><span class="koboSpan" id="kobo.1232.1">BP_SpellBook</span></strong><span class="koboSpan" id="kobo.1233.1"> Blueprint into the level, near the PlayerStart Actor, so that the player will be in the line of sight once it has </span><span class="No-Break"><span class="koboSpan" id="kobo.1234.1">been spawned.</span></span></p>
<p><span class="koboSpan" id="kobo.1235.1">Open the </span><strong class="bold"><span class="koboSpan" id="kobo.1236.1">PB_SpeelBook</span></strong><span class="koboSpan" id="kobo.1237.1"> Blueprint and, with the </span><strong class="bold"><span class="koboSpan" id="kobo.1238.1">Class Defaults</span></strong><span class="koboSpan" id="kobo.1239.1"> panel selected, look for the </span><strong class="bold"><span class="koboSpan" id="kobo.1240.1">Replication</span></strong><span class="koboSpan" id="kobo.1241.1"> category. </span><span class="koboSpan" id="kobo.1241.2">The default settings should be similar to the ones shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1242.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1243.1">.15</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1244.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer089">
<span class="koboSpan" id="kobo.1245.1"><img alt="Figure 5.15 – The Replication category" src="image/Figure_05_15_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1246.1">Figure 5.15 – The Replication category</span></p>
<p><span class="koboSpan" id="kobo.1247.1">Try playing the game as a listen server with three players, and every player should see the book as expected. </span><span class="koboSpan" id="kobo.1247.2">Things are going to get a bit trickier in </span><span class="No-Break"><span class="koboSpan" id="kobo.1248.1">a moment...</span></span></p>
<p><span class="koboSpan" id="kobo.1249.1">Stop the application from playing and get back to the </span><strong class="bold"><span class="koboSpan" id="kobo.1250.1">BP_SpellBook</span></strong><span class="koboSpan" id="kobo.1251.1"> Blueprint. </span><span class="koboSpan" id="kobo.1251.2">Look for the </span><strong class="bold"><span class="koboSpan" id="kobo.1252.1">Net Load on Client</span></strong><span class="koboSpan" id="kobo.1253.1"> property and uncheck it. </span><span class="koboSpan" id="kobo.1253.2">As this property will load the Actor during map loading, we need to disable it, so the Actor will be loaded only when it becomes relevant for </span><span class="No-Break"><span class="koboSpan" id="kobo.1254.1">the client.</span></span></p>
<p><span class="koboSpan" id="kobo.1255.1">You are now ready to test</span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.1256.1"> different situations, depending on the properties you change in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1257.1">next steps.</span></span></p>
<h3><span class="koboSpan" id="kobo.1258.1">Setting the net cull distance</span></h3>
<p><span class="koboSpan" id="kobo.1259.1">The first situation you will be testing </span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.1260.1">is about distance culling – at the moment, your </span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.1261.1">object is set to be relevant at a very far distance. </span><span class="koboSpan" id="kobo.1261.2">To check this, run the game again, and you should see no difference since your last gameplay. </span><span class="koboSpan" id="kobo.1261.3">But what happens if you lower </span><strong class="bold"><span class="koboSpan" id="kobo.1262.1">Net Cull Distance Squared</span></strong><span class="koboSpan" id="kobo.1263.1"> to a very low number, for instance, </span><strong class="bold"><span class="koboSpan" id="kobo.1264.1">500</span></strong><span class="koboSpan" id="kobo.1265.1">? </span><span class="koboSpan" id="kobo.1265.2">You will get really “weird” behavior: the server window will show the book, while the two clients </span><span class="No-Break"><span class="koboSpan" id="kobo.1266.1">will not!</span></span></p>
<p><span class="koboSpan" id="kobo.1267.1">With one of the client windows active, try walking near the zone where the book should be, and it will immediately pop up! </span><span class="koboSpan" id="kobo.1267.2">Didn’t I already warn you that this book was nothing short </span><span class="No-Break"><span class="koboSpan" id="kobo.1268.1">of magical?</span></span></p>
<p><span class="koboSpan" id="kobo.1269.1">The property you just changed sets the square of the distance that will be used to make the Actor relevant to the client. </span><span class="koboSpan" id="kobo.1269.2">This means that the spell book will “magically” appear as soon as the character is</span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.1270.1"> within the square root of this distance. </span><span class="koboSpan" id="kobo.1270.2">As the server is </span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.1271.1">authoritative (i.e., knows everything), it will always show </span><span class="No-Break"><span class="koboSpan" id="kobo.1272.1">the Actor.</span></span></p>
<p><span class="koboSpan" id="kobo.1273.1">Let’s now test a way to set the Actor as always relevant and, as such, </span><span class="No-Break"><span class="koboSpan" id="kobo.1274.1">always visible.</span></span></p>
<h3><span class="koboSpan" id="kobo.1275.1">Setting the Actor as always relevant</span></h3>
<p><span class="koboSpan" id="kobo.1276.1">Return to the spell book Blueprint and </span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.1277.1">set the </span><strong class="bold"><span class="koboSpan" id="kobo.1278.1">Always Relevant</span></strong><span class="koboSpan" id="kobo.1279.1"> property</span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.1280.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.1281.1">True</span></strong><span class="koboSpan" id="kobo.1282.1">, leaving the rest as it was in the previous example. </span><span class="koboSpan" id="kobo.1282.2">When you play the game, you will notice that every client will be able to see the book from the start. </span><span class="koboSpan" id="kobo.1282.3">This happens because the book has now been marked as something that should be relevant no matter where the character is in the level; as a consequence, it will be immediately loaded by the client and visible to </span><span class="No-Break"><span class="koboSpan" id="kobo.1283.1">the players.</span></span></p>
<p><span class="koboSpan" id="kobo.1284.1">This is obviously not a desirable situation – getting a continuous update for every Actor in the level is something we don’t want to happen, considering that there could be a multitude of moving elements in our game. </span><span class="koboSpan" id="kobo.1284.2">But you probably already imagined that, </span><span class="No-Break"><span class="koboSpan" id="kobo.1285.1">didn’t you?</span></span></p>
<p><span class="koboSpan" id="kobo.1286.1">Let’s avoid this issue by setting relevancy based on the Owner of </span><span class="No-Break"><span class="koboSpan" id="kobo.1287.1">the Actor.</span></span></p>
<h3><span class="koboSpan" id="kobo.1288.1">Setting the relevancy for the Owner</span></h3>
<p><span class="koboSpan" id="kobo.1289.1">You may remember </span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.1290.1">that the C++ code for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1291.1">Pickup()</span></strong><span class="koboSpan" id="kobo.1292.1"> function assigns the Owner of the pickup to the character overlapping it. </span><span class="koboSpan" id="kobo.1292.2">Instead, in this Blueprint, we’ll see what happens if the Actor is relevant only to </span><span class="No-Break"><span class="koboSpan" id="kobo.1293.1">the Owner:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1294.1">Set the </span><strong class="bold"><span class="koboSpan" id="kobo.1295.1">Only Relevant to Owner</span></strong><span class="koboSpan" id="kobo.1296.1"> property </span><span class="No-Break"><span class="koboSpan" id="kobo.1297.1">to </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1298.1">True</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1299.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1300.1">Set the </span><strong class="bold"><span class="koboSpan" id="kobo.1301.1">Always Relevant</span></strong><span class="koboSpan" id="kobo.1302.1"> property </span><span class="No-Break"><span class="koboSpan" id="kobo.1303.1">to </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1304.1">False</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1305.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1306.1">Set </span><strong class="bold"><span class="koboSpan" id="kobo.1307.1">Net Cull Distance Squared</span></strong><span class="koboSpan" id="kobo.1308.1"> to a really low number, </span><span class="No-Break"><span class="koboSpan" id="kobo.1309.1">say </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1310.1">10</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1311.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1312.1">With the last step, we are setting the spell book so that it won’t be relevant to any client unless it is directly on the object; this will let us test who is the Owner of </span><span class="No-Break"><span class="koboSpan" id="kobo.1313.1">the Actor.</span></span></p>
<p><span class="koboSpan" id="kobo.1314.1">The clients won’t be able to see the book unless they enter its collision zone, which is when the character becomes the Owner of the pickup. </span><span class="koboSpan" id="kobo.1314.2">Once another character enters the pickup zone, it will become the new Owner and the book will become relevant. </span><span class="koboSpan" id="kobo.1314.3">After a few moments, the first client will see the book disappear as the character is no longer the Owner of the pickup, and so it is no longer relevant </span><span class="No-Break"><span class="koboSpan" id="kobo.1315.1">to it!</span></span></p>
<p><span class="koboSpan" id="kobo.1316.1">As a final note, there is one last property you should be aware of: </span><strong class="bold"><span class="koboSpan" id="kobo.1317.1">Net Use Owner Relevancy</span></strong><span class="koboSpan" id="kobo.1318.1"> will</span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.1319.1"> return the relevancy of an Actor depending on its owner relevancy. </span><span class="koboSpan" id="kobo.1319.2">This will come in handy once you assign a weapon to a character or</span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.1320.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.1321.1">an enemy!</span></span></p>
<p><span class="koboSpan" id="kobo.1322.1">In this section, you have now unlocked the mystical secrets of relevancy and witnessed it in action. </span><span class="koboSpan" id="kobo.1322.2">This concept will prove invaluable as you begin optimizing your game, but it’s always best to lay a strong foundation and set the right course from the very beginning. </span><span class="koboSpan" id="kobo.1322.3">The following section will introduce another significant concept, </span><span class="No-Break"><span class="koboSpan" id="kobo.1323.1">namely authority.</span></span></p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.1324.1">Introducing authority</span></h1>
<p><span class="koboSpan" id="kobo.1325.1">As we mentioned in </span><a href="B18203_02.xhtml#_idTextAnchor041"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1326.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.1327.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1328.1">Understanding Networking Basics</span></em><span class="koboSpan" id="kobo.1329.1">, the term </span><strong class="bold"><span class="koboSpan" id="kobo.1330.1">authority</span></strong><span class="koboSpan" id="kobo.1331.1"> refers to </span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.1332.1">which instance of the game has the final say over certain aspects of the game state. </span><span class="koboSpan" id="kobo.1332.2">In an Unreal Engine multiplayer environment, the server is authoritative over the game state: this means that the server makes the final decisions about things such as player movement, damage calculation, and other </span><span class="No-Break"><span class="koboSpan" id="kobo.1333.1">game mechanics.</span></span></p>
<p><span class="koboSpan" id="kobo.1334.1">When a client requests to perform an action that affects the game state, it sends a message to the server requesting permission to perform that action. </span><span class="koboSpan" id="kobo.1334.2">The server then determines whether the action is valid and, if so, updates the game state accordingly. </span><span class="koboSpan" id="kobo.1334.3">Once the server has updated the game state, it sends a message to all clients to inform them of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1335.1">updated state.</span></span></p>
<p><span class="koboSpan" id="kobo.1336.1">In Unreal Engine, Actors can be either locally or remotely controlled, and the concept of authority is important in determining which controls are valid. </span><span class="koboSpan" id="kobo.1336.2">Actors that are locally controlled have authority over their own actions, while those that are remotely controlled receive commands from the server and follow </span><span class="No-Break"><span class="koboSpan" id="kobo.1337.1">those commands.</span></span></p>
<p><span class="koboSpan" id="kobo.1338.1">Overall, the concept of</span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.1339.1"> authority ensures that all players see a consistent game state and that no one player has an </span><span class="No-Break"><span class="koboSpan" id="kobo.1340.1">unfair advantage.</span></span></p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.1341.1">Controlling authority with the Role and Remote Role properties of an Actor</span></h2>
<p><span class="koboSpan" id="kobo.1342.1">In Unreal Engine, there are two </span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.1343.1">properties that return important information about Actor replication: </span><strong class="bold"><span class="koboSpan" id="kobo.1344.1">Role</span></strong><span class="koboSpan" id="kobo.1345.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.1346.1">Remote Role</span></strong><span class="koboSpan" id="kobo.1347.1">. </span><span class="koboSpan" id="kobo.1347.2">These two properties provide information about who has authority over the Actor, whether the Actor is replicated or not, and the method </span><span class="No-Break"><span class="koboSpan" id="kobo.1348.1">of replication.</span></span></p>
<p><span class="koboSpan" id="kobo.1349.1">In Unreal Engine, an Actor can have one of four possible roles</span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.1350.1"> during </span><span class="No-Break"><span class="koboSpan" id="kobo.1351.1">network play:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1352.1">ROLE_Authority</span></strong><span class="koboSpan" id="kobo.1353.1">: The running instance has authoritative control over </span><span class="No-Break"><span class="koboSpan" id="kobo.1354.1">the Actor</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1355.1">ROLE_AutonomousProxy</span></strong><span class="koboSpan" id="kobo.1356.1">: The running instance is an autonomous proxy of </span><span class="No-Break"><span class="koboSpan" id="kobo.1357.1">the Actor</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1358.1">ROLE_SimulatedProxy</span></strong><span class="koboSpan" id="kobo.1359.1">: The running instance is a locally simulated proxy of </span><span class="No-Break"><span class="koboSpan" id="kobo.1360.1">the Actor</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1361.1">ROLE_None</span></strong><span class="koboSpan" id="kobo.1362.1">: In this case, the role</span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.1363.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.1364.1">not relevant</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1365.1">Overall, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1366.1">Role</span></strong><span class="koboSpan" id="kobo.1367.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1368.1">RemoteRole</span></strong><span class="koboSpan" id="kobo.1369.1"> properties are used to control how an Actor behaves during network play in Unreal Engine, and their values can differ depending on the Actor’s ownership and replication settings. </span><span class="koboSpan" id="kobo.1369.2">In particular, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1370.1">Role</span></strong><span class="koboSpan" id="kobo.1371.1"> property specifies the Actor’s role on the local machine, while the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1372.1">RemoteRole</span></strong><span class="koboSpan" id="kobo.1373.1"> property specifies the Actor’s role on the </span><span class="No-Break"><span class="koboSpan" id="kobo.1374.1">remote machine.</span></span></p>
<p><span class="koboSpan" id="kobo.1375.1">As an example, if </span><strong class="source-inline"><span class="koboSpan" id="kobo.1376.1">Role</span></strong><span class="koboSpan" id="kobo.1377.1"> is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1378.1">ROLE_Authority</span></strong><span class="koboSpan" id="kobo.1379.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1380.1">RemoteRole</span></strong><span class="koboSpan" id="kobo.1381.1"> is set to either </span><strong class="source-inline"><span class="koboSpan" id="kobo.1382.1">ROLE_SimulatedProxy</span></strong><span class="koboSpan" id="kobo.1383.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1384.1">ROLE_AutonomousProxy</span></strong><span class="koboSpan" id="kobo.1385.1">, then the current instance of the game is responsible for replicating this Actor to </span><span class="No-Break"><span class="koboSpan" id="kobo.1386.1">remote connections.</span></span></p>
<p><span class="koboSpan" id="kobo.1387.1">It should be noted that only the server replicates Actors to connected clients as clients will never replicate Actors to the server. </span><span class="koboSpan" id="kobo.1387.2">This means that only the server will have </span><strong class="source-inline"><span class="koboSpan" id="kobo.1388.1">Role</span></strong><span class="koboSpan" id="kobo.1389.1"> set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1390.1">ROLE_Authority</span></strong><span class="koboSpan" id="kobo.1391.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1392.1">RemoteRole</span></strong><span class="koboSpan" id="kobo.1393.1"> set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1394.1">ROLE_SimulatedProxy</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1395.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1396.1">ROLE_AutonomousProxy</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1397.1">.</span></span></p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.1398.1">Autonomous and simulated proxy</span></h2>
<p><span class="koboSpan" id="kobo.1399.1">While testing the spell book pickup (well, it was not strictly a “pickup,” but you get the point), you may have noticed that once the Actor’s Owner changed, the book did seem to stay relevant to both the old and the new Owner for a moment. </span><span class="koboSpan" id="kobo.1399.2">To avoid using excessive amounts of CPU resources and bandwidth, the server does not replicate Actors during every update but at a frequency that is determined by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1400.1">AActor::NetUpdateFrequency</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1401.1"> property.</span></span></p>
<p><span class="koboSpan" id="kobo.1402.1">The same thing will happen when updating any Actor during movement, and the client will receive data at predefined intervals; as a consequence, the player may get seemingly erratic updates on an Actor. </span><span class="koboSpan" id="kobo.1402.2">To avoid these kinds of issues, the Engine will try to extrapolate movement based on the latest </span><span class="No-Break"><span class="koboSpan" id="kobo.1403.1">data available.</span></span></p>
<p><span class="koboSpan" id="kobo.1404.1">The default behavior relies on predicting the movement and is governed by a </span><strong class="bold"><span class="koboSpan" id="kobo.1405.1">Simulated Proxy</span></strong><span class="koboSpan" id="kobo.1406.1"> by </span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.1407.1">setting the role to the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1408.1">ROLE_SimulatedProxy</span></strong><span class="koboSpan" id="kobo.1409.1">. </span><span class="koboSpan" id="kobo.1409.2">In this mode, the client continuously updates the location of the Actor based on the latest velocity received from </span><span class="No-Break"><span class="koboSpan" id="kobo.1410.1">the server.</span></span></p>
<p><span class="koboSpan" id="kobo.1411.1">When an Actor is controlled</span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.1412.1"> by a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1413.1">PlayerController</span></strong><span class="koboSpan" id="kobo.1414.1"> object, you may use an </span><strong class="bold"><span class="koboSpan" id="kobo.1415.1">Autonomous Proxy</span></strong><span class="koboSpan" id="kobo.1416.1"> by setting the role to a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1417.1">ROLE_AutonomousProxy</span></strong><span class="koboSpan" id="kobo.1418.1">. </span><span class="koboSpan" id="kobo.1418.2">In this case, the system will receive additional information directly from the human player, making the process of predicting future </span><span class="No-Break"><span class="koboSpan" id="kobo.1419.1">actions smoother.</span></span></p>
<p><span class="koboSpan" id="kobo.1420.1">In this section, you’ve gained some insight into the realms of authority and Actor roles. </span><span class="koboSpan" id="kobo.1420.2">These notions shall undoubtedly come in handy in future chapters, especially as you delve into the complexities of topics such as character weaponry and </span><span class="No-Break"><span class="koboSpan" id="kobo.1421.1">enemy AI.</span></span></p>
<h1 id="_idParaDest-123"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.1422.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1423.1">In this chapter, you made further progress in developing your multiplayer project by updating your character with the required movement and interaction features – this was achieved with the help of the Enhanced Input System provided by </span><span class="No-Break"><span class="koboSpan" id="kobo.1424.1">Unreal Engine.</span></span></p>
<p><span class="koboSpan" id="kobo.1425.1">Next, you gained some clarity on who’s pulling the strings of an Actor in a multiplayer environment by understanding what an </span><span class="No-Break"><span class="koboSpan" id="kobo.1426.1">Owner is.</span></span></p>
<p><span class="koboSpan" id="kobo.1427.1">After that, you started to see the light on the all-important role of relevancy in gaming. </span><span class="koboSpan" id="kobo.1427.2">As you discovered for yourself, it’s crucial to know how properties are set, or things will start to take a big turn for </span><span class="No-Break"><span class="koboSpan" id="kobo.1428.1">the weird.</span></span></p>
<p><span class="koboSpan" id="kobo.1429.1">Lastly, you gained some valuable insights into the different roles that make up an Unreal Engine multiplayer game and why they play a crucial role in replicating an Actor’s behavior across </span><span class="No-Break"><span class="koboSpan" id="kobo.1430.1">multiple clients.</span></span></p>
<p><span class="koboSpan" id="kobo.1431.1">This brings us to a final question: what does “replicating” an object mean exactly? </span><span class="koboSpan" id="kobo.1431.2">Well, I guess it’s time to take a stroll or indulge in a cup of coffee to recharge your batteries. </span><span class="koboSpan" id="kobo.1431.3">You will need to summon all your energy and focus, for I will unveil (almost) all the secrets of replication in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1432.1">next chapter!</span></span></p>
</div>
</body></html>