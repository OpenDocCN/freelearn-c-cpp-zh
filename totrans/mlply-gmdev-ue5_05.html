<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-106"><a id="_idTextAnchor107"/>5</h1>
<h1 id="_idParaDest-107"><a id="_idTextAnchor108"/>Managing Actors in a Multiplayer Environment</h1>
<p>To properly set up a multiplayer environment in UE5, it’s important that you understand how an Actor’s connection is managed, as well as how its attributes are relevant during a game session.</p>
<p>In this chapter, you will begin enhancing the player character (which currently is just an empty shell) to gain a comprehensive understanding of the previously mentioned concepts. To do this, you’ll add more components to the Character class (a camera is something you will absolutely need!) and implement the player input logic.</p>
<p>Additionally, you will learn why it is important to know who owns an Actor in a multiplayer environment and how it behaves depending on how it is relevant in the level.</p>
<p>By the end of the chapter, you will have solid knowledge of how to manage an Actor within an Unreal multiplayer game, allowing you to create more robust and efficient multiplayer experiences.</p>
<p>So, in this chapter, I will present you with the following topics:</p>
<ul>
<li>Setting up the character</li>
<li>Controlling the connection of an Actor</li>
<li>Understanding Actor relevancy</li>
<li>Introducing authority</li>
</ul>
<h1 id="_idParaDest-108"><a id="_idTextAnchor109"/>Technical requirements</h1>
<p>To follow the topics presented in this chapter, you should have completed the previous chapter and understood its content.</p>
<p>Additionally, if you would prefer to begin with the code from the companion repository for this book, you can download the <code>.zip</code> project files at <a href="https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5">https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5</a>.</p>
<p>You can download the files that are up to date with the end of the last chapter by clicking the <code>Unreal Shadows – </code><code>Chapter 04</code><code> </code><code>End</code> link.</p>
<h1 id="_idParaDest-109"><a id="_idTextAnchor110"/>Setting up the character</h1>
<p>Before<a id="_idIndexMarker255"/> I start writing about topics such as connections, authority, and roles, I need you to properly set up the player character – at the moment, our poor hero is just represented by an empty class!</p>
<p>So, in this section, you will add a camera and some user input and set up the main functionalities that will allow the thief character to move around the level in search of treasures and gold!</p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor111"/>Adding basic settings to the character</h2>
<p>In the <a id="_idIndexMarker256"/>next few steps, you’ll add the components <a id="_idIndexMarker257"/>that will make up the third-person camera behavior and implement their logic. After that, you’ll set some default values for the components that are already available in the Character class: the Arrow, Capsule, and SkeletalMesh components.</p>
<h3>Adding a Camera component to the character</h3>
<p>To <a id="_idIndexMarker258"/>get started, open the <code>US_Character.h</code> header class. You <a id="_idIndexMarker259"/>will be adding a Camera component and a Spring component that will connect the camera to the Capsule component available in the Character class. To do this, add these two component declarations after the <code>GENERATED_BODY()</code> macro:</p>
<pre class="source-code">
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;class USpringArmComponent&gt; CameraBoom;
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;class UCameraComponent&gt; FollowCamera;</pre>
<p>In <a id="_idIndexMarker260"/>the previous code block, we are declaring a<a id="_idIndexMarker261"/> Camera component and a Spring component that will create the camera system. First, you will notice the <code>UPROPERTY()</code> declaration on both variables with some property specifiers. Let me explain them:</p>
<ul>
<li>The <code>VisibleAnywhere</code> property indicates that this property is visible in all related windows of the Unreal Engine Editor but cannot be edited</li>
<li>The <code>BlueprintReadOnly</code> property indicates that this property can be read by Blueprints but not modified</li>
<li>The <code>Category</code> property specifies the category of the property when displayed in the <strong class="bold">Blueprint </strong><strong class="bold">Details</strong> panel</li>
</ul>
<p>You will also notice a <code>meta</code> declaration that lets you control how the property interacts with various aspects of Unreal Engine and the Editor: in this case, <code>AllowPrivateAccess</code> indicates that a private member should be accessible from a Blueprint. We need this as these properties’ accessibility is not explicitly declared, and so they default to <code>private</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">For an exhaustive list of property specifiers, please check the official Epic Games documentation, which can be found here: <a href="https://docs.unrealengine.com/5.1/en-US/unreal-engine-uproperty-specifiers/">https://docs.unrealengine.com/5.1/en-US/unreal-engine-uproperty-specifiers/</a>.</p>
<p>Next, look at the <code>class</code> keyword before the type – this is a C++ <strong class="bold">class forward declaration</strong>. If you are <a id="_idIndexMarker262"/>unfamiliar with this, it is a way to declare the class name and its members without providing the full class definition. This can be useful in situations where you want to use a class in a header file but do not want to include the entire class definition, which can make compilation slower and create unnecessary dependencies.</p>
<p>Lastly, you will notice the <code>TObjectPtr&lt;T&gt;</code> template – this is a new addition in UE5 and has been introduced to replace raw pointers (for example, <code>USpringComponent*</code>) in header files with UProperties. The <code>TObjectPtr&lt;T&gt;</code> template is intended only for member properties declared in the headers of your code. For functions and short-lived scope within your C++ code in <code>.cpp</code> files, using <code>TObjectPtr&lt;T&gt;</code> provides no additional advantages over using raw pointers.</p>
<p>As the Camera and Spring components are private, you need to add two getter methods for them. Inside the <code>public</code> declaration of the header, locate this line of code:</p>
<pre class="source-code">
virtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;</pre>
<p>Then, below this line, add the following:</p>
<pre class="source-code">
FORCEINLINE USpringArmComponent* GetCameraBoom() const { return CameraBoom; }
FORCEINLINE UCameraComponent* GetFollowCamera() const { return FollowCamera; }</pre>
<p>These two<a id="_idIndexMarker263"/> methods will let you access the pointer <a id="_idIndexMarker264"/>components, and the <code>FORCEINLINE</code> macro forces the code to be inlined; this is going to give your code some performance benefits as you will avoid a function call when using this method.</p>
<h3>Implementing the camera behavior</h3>
<p>Now <a id="_idIndexMarker265"/>that your properties have been added, it’s time to add some code logic to handle them. Open the <code>.cpp</code> file and add the following includes at its top:</p>
<pre class="source-code">
#include "Camera/CameraComponent.h"
#include "Components/CapsuleComponent.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "GameFramework/SpringArmComponent.h"</pre>
<p>Then, inside the constructor (i.e., <code>AUS_Character::AUS_Character()</code>), add this code:</p>
<pre class="source-code">
CameraBoom = CreateDefaultSubobject&lt;USpringArmComponent&gt;(TEXT("CameraBoom"));
CameraBoom-&gt;SetupAttachment(RootComponent);
CameraBoom-&gt;TargetArmLength = 800.0f;
CameraBoom-&gt;bUsePawnControlRotation = true;</pre>
<p>Here, <code>CreateDefaultSubobject()&lt;T&gt;</code> is a function that is used to create a new subobject of a class that will be owned by another object. A <strong class="bold">Subobject</strong> is <a id="_idIndexMarker266"/>essentially<a id="_idIndexMarker267"/> a component or a member variable of an object, and the method is typically called within an object’s constructor to initialize its subobjects (in this case, the components).</p>
<p>The <code>SetupAttachment()</code> method will reparent a component to another one. In this case, you are attaching the Camera component to <code>RootComponent</code>, which is actually the Capsule component.</p>
<p>Let’s give the camera a similar treatment. Add this code block just after the previous lines of code:</p>
<pre class="source-code">
FollowCamera = CreateDefaultSubobject&lt;UCameraComponent&gt;(TEXT("FollowCamera"));
FollowCamera-&gt;SetupAttachment(CameraBoom, USpringArmComponent::SocketName);
FollowCamera-&gt;bUsePawnControlRotation = false;</pre>
<p>The only real difference here is that you are reparenting the camera to the Spring component instead of the root one.</p>
<p>You have <a id="_idIndexMarker268"/>just created some sort of “chain of command” where the camera is connected to the Spring component that is connected to the root of the Actor – this will let the camera follow the character with a “springy” behavior whenever the camera hits an obstacle and provide a better feel for the player.</p>
<h3>Setting up the default component properties</h3>
<p>As a<a id="_idIndexMarker269"/> last step, you’ll be modifying some properties to create a default setup for your Character class. In the constructor, add these lines of code:</p>
<pre class="source-code">
bUseControllerRotationPitch = false;
bUseControllerRotationYaw = false;
bUseControllerRotationRoll = false;
GetCapsuleComponent()-&gt;InitCapsuleSize(60.f, 96.0f);
GetMesh()-&gt;SetRelativeLocation(FVector(0.f, 0.f, -91.f));
static ConstructorHelpers::FObjectFinder&lt;USkeletalMesh&gt; SkeletalMeshAsset(TEXT("/Game/KayKit/Characters/rogue"));
if (SkeletalMeshAsset.Succeeded())
{
   GetMesh()-&gt;SetSkeletalMesh(SkeletalMeshAsset.Object);
}
GetCharacterMovement()-&gt;bOrientRotationToMovement = true;
GetCharacterMovement()-&gt;RotationRate = FRotator(0.0f, 500.0f, 0.0f);
GetCharacterMovement()-&gt;MaxWalkSpeed = 500.f;
GetCharacterMovement()-&gt;MinAnalogWalkSpeed = 20.f;
GetCharacterMovement()-&gt;BrakingDecelerationWalking = 2000.f;</pre>
<p>Here, you are<a id="_idIndexMarker270"/> just changing some of the default values of the character Actor and its components. The only thing to note is that you are getting the character model and assigning it to <code>SkeletalMeshComponent</code> by means of the <code>FObjectFinder()</code> utility method available in the <code>ConstructorHelpers</code> class you’ve used before.</p>
<h3>Updating the Character Blueprint</h3>
<p>Now it’s time to compile your<a id="_idIndexMarker271"/> project, just to check that you don’t have any syntax errors and that the character has been properly set up. To do this, save your files, go back to the Unreal Editor, and click the <strong class="bold">Compile</strong> button.</p>
<p>Once the compilation phase has finished, open the <strong class="bold">BP_Character</strong> Blueprint, and you should notice that your changes didn’t show up. This happens because the Blueprint has not been updated. To fix this, select <strong class="bold">File</strong> | <strong class="bold">Refresh All nodes</strong>. You should now see the <strong class="bold">Camera Boom</strong> and <strong class="bold">Follow Camera</strong> elements added to the hierarchy in the <strong class="bold">Components</strong> panel, as depicted in <em class="italic">Figure 5</em><em class="italic">.1</em>:</p>
<div><div><img alt="Figure 5.1 – The newly added character components" src="img/Figure_05_01_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – The newly added character components</p>
<p>You probably still won’t see the updated mesh in the SkeletalMesh component. To fix this, take the following steps:</p>
<ol>
<li>Select the <strong class="bold">Mesh</strong> elements in the <strong class="bold">Components</strong> panel and look for the <strong class="bold">Skeletal Mesh Asset</strong> field in the <strong class="bold">Details</strong> panel.</li>
<li>If <strong class="bold">Skeletal Mesh Asset</strong> shows a value of <strong class="bold">None</strong>, click on the <strong class="bold">Reset Property</strong> arrow next to it, as shown in <em class="italic">Figure 5</em><em class="italic">.2</em>:</li>
</ol>
<div><div><img alt="Figure 5.2 – The Reset Property button" src="img/Figure_05_02_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – The Reset Property button</p>
<ol>
<li value="3">Double-check the <strong class="bold">Use Controller Rotation Yaw Y</strong> property, as it may also need a reset.</li>
</ol>
<p>Now you <a id="_idIndexMarker272"/>should be able to see the viewport updated with the selected mesh added to it, as shown in <em class="italic">Figure 5</em><em class="italic">.3</em>:</p>
<div><div><img alt="Figure 5.3 – The updated character Blueprint" src="img/Figure_05_03_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – The updated character Blueprint</p>
<p>With your character set up, it’s time to make it move by adding some user interaction.</p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor112"/>Adding interaction to the character</h2>
<p>Now we <a id="_idIndexMarker273"/>will add input settings for the character. To do this, we will <a id="_idIndexMarker274"/>be using the new <strong class="bold">Enhanced Input System</strong> that<a id="_idIndexMarker275"/> has been introduced in UE5. This new system provides developers with more advanced features than the previous one (known simply as the Input System), such as complex input handling and runtime control remapping. As the old system is being deprecated, it will probably be removed from Unreal Engine sooner or later, so it is best to stay updated on the changes.</p>
<p>The most important thing to know about the Enhanced Input System is how it communicates with your code: this is achieved through <strong class="bold">Input Actions</strong> that represent what the character can do during play (i.e., walk, jump, or attack). A <a id="_idIndexMarker276"/>group of Input Actions can be collected inside <a id="_idIndexMarker277"/>an <strong class="bold">Input Mapping Context</strong> that represents a set of rules for what will trigger the included actions.</p>
<p>At runtime, UE5 will check a list of <strong class="bold">Input Triggers</strong> to determine how user input activated an Input Action, validating patterns such<a id="_idIndexMarker278"/> as long presses, release events, or double-clicks. Before triggering inputs, the system can pre-process the raw input through a list <a id="_idIndexMarker279"/>of <strong class="bold">Input Modifiers</strong> that will alter the data, such as setting a custom dead zone for the thumbstick or getting a negative value from the input itself.</p>
<p>In this section, you’ll create some basic interaction for your character, which needs to move, sprint, and interact with objects (we’ll leave the attack actions to later chapters). The sprint and interact actions will be activated by pressing a button, while the move action<a id="_idIndexMarker280"/> will be controlled by a keyboard/mouse combo<a id="_idIndexMarker281"/> or by the controller thumbsticks.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you want to explore the full range of possibilities offered by the<a id="_idIndexMarker282"/> Enhanced Input System, you can check the official documentation by visiting this web page: <a href="https://docs.unrealengine.com/5.1/en-US/enhanced-input-in-unreal-engine/">https://docs.unrealengine.com/5.1/en-US/enhanced-input-in-unreal-engine/</a>.</p>
<h3>Creating Input Actions</h3>
<p>To start<a id="_idIndexMarker283"/> creating Input Actions, take the following steps:</p>
<ol>
<li>Open your <code>Input</code>.</li>
<li>Inside the folder, right-click and select <strong class="bold">Input</strong> | <strong class="bold">Input Action</strong> to create an Input Action asset.</li>
<li>Name it <code>IA_Interact</code>.</li>
<li>Create three other Input Actions and name them <code>IA_Look</code>, <code>IA_Move</code>, and <code>IA_Sprint</code>.</li>
</ol>
<p>Let’s begin editing the <strong class="bold">IA_Interact</strong> action – we need it to be activated by a single press of a button (or key), and this action should be dispatched the moment the button has been pressed. To do so, double-click on the asset to open it and do the following:</p>
<ol>
<li>Click on the <strong class="bold">+</strong> button next to the <strong class="bold">Triggers</strong> field to add a trigger.</li>
<li>Click the dropdown that should have been created and select <strong class="bold">Pressed</strong> – this option will avoid dispatching multiple events if the player holds the button.</li>
<li>Leave the rest as it is – just check that <strong class="bold">Value Type</strong> has been set to the default value of <strong class="bold">Digital (bool)</strong>.</li>
</ol>
<p>The final result<a id="_idIndexMarker284"/> of the interact action asset is shown in <em class="italic">Figure 5</em><em class="italic">.4</em>:</p>
<div><div><img alt="Figure 5.4 – The interact action settings" src="img/Figure_05_04_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – The interact action settings</p>
<p>The <strong class="bold">IA_Sprint</strong> action is pretty similar to the interact one but needs to trigger a press event when the character starts sprinting and trigger a release event when the character stops sprinting.</p>
<p>Double-click on the <strong class="bold">IA_Sprint</strong> asset to open it and change the settings as described here:</p>
<ol>
<li>Add two triggers by clicking the <strong class="bold">+</strong> button next to the <strong class="bold">Triggers</strong> field twice.</li>
<li>Click the first dropdown that should have been created and select <strong class="bold">Pressed</strong>.</li>
<li>Click the second dropdown and select <strong class="bold">Released</strong>.</li>
<li>Leave the rest as it is, checking that <strong class="bold">Value Type</strong> has been set to the default value of <strong class="bold">Digital (bool)</strong>.</li>
</ol>
<p>The final result of <a id="_idIndexMarker285"/>the sprint action asset is shown in <em class="italic">Figure 5</em><em class="italic">.5</em>:</p>
<div><div><img alt="Figure 5.5 – The sprint action settings" src="img/Figure_05_05_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – The sprint action settings</p>
<p>It’s time to set up the <strong class="bold">IA_Move</strong> asset, so open it and simply change <strong class="bold">Value Type</strong> to <strong class="bold">Axis2D (Vector2D)</strong> as shown in <em class="italic">Figure 5</em><em class="italic">.6</em>:</p>
<div><div><img alt="Figure 5.6 – The move action settings" src="img/Figure_05_06_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – The move action settings</p>
<p>As a last step, open <a id="_idIndexMarker286"/>the <strong class="bold">AI_Look</strong> asset and change <strong class="bold">Value Type</strong> to <strong class="bold">Axis2D (Vector2D)</strong>, as shown in <em class="italic">Figure 5</em><em class="italic">.7</em>:</p>
<div><div><img alt="Figure 5.7 – The look action settings" src="img/Figure_05_07_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – The look action settings</p>
<p>Now that the basic actions have been defined, it’s time to create the Mapping Context and set its properties.</p>
<h3>Setting up the Input Mapping Context</h3>
<p>As explained already, a Mapping Context<a id="_idIndexMarker287"/> refers to a set of Input Actions that identifies a specific situation in which the player may find themselves. The “context” you need to create here is the<a id="_idIndexMarker288"/> base actions a character can do (move, look around, and interact), so it’s time to open the <strong class="bold">Content Browser</strong> and create this asset:</p>
<ol>
<li>Right-click on the <code>Input</code> folder and select <strong class="bold">Input</strong> | <strong class="bold">Input </strong><strong class="bold">Mapping Context</strong>.</li>
<li>Name the newly created asset <code>IMC_Default</code> and double-click on it to start editing.</li>
<li>Click the <strong class="bold">+</strong> button next to the <strong class="bold">Mappings</strong> field. In the drop-down menu, select <strong class="bold">IA_Interact</strong>.</li>
<li>Repeat this step three more times to add <strong class="bold">IA_Sprint</strong>, <strong class="bold">IA_Move</strong>, and <strong class="bold">IA_Look</strong>.</li>
</ol>
<p>By the end of these steps, you should have something similar to <em class="italic">Figure 5</em><em class="italic">.8</em>:</p>
<div><div><img alt="Figure 5.8 – The Input Mapping Context panel" src="img/Figure_05_08_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8 – The Input Mapping Context panel</p>
<p>Now that the <a id="_idIndexMarker289"/>context has been created, it’s time to map the input the player will be using. As I have stated before, we’ll let them use a controller or a mix of keyboard and mouse interaction. At the moment, all mappings should be set to <strong class="bold">None</strong>; this means that no input will pass through this context.</p>
<p>Let’s solve this by starting with the <strong class="bold">IA_Interact</strong> mapping:</p>
<ol>
<li>Click on the keyboard icon below <strong class="bold">IA_Interact</strong> and press the <em class="italic">I</em> (for Interact) key on your keyboard.</li>
<li>Then click on the <strong class="bold">+</strong> button to the right of the <strong class="bold">IA_Interact</strong> field to add another mapping.</li>
<li>From the drop-down menu, select <strong class="bold">Gamepad</strong> | <strong class="bold">Gamepad Face Button Bottom</strong>. Alternatively, if you have a game controller connected to your PC, you can simply click on the keyboard icon and then press the corresponding button (for instance, the <em class="italic">A</em> button for an Xbox controller).</li>
</ol>
<p>Now we are <a id="_idIndexMarker290"/>going to set the mapping for <strong class="bold">IA_Sprint</strong>:</p>
<ol>
<li value="4">Set <strong class="bold">Left Shift</strong> for if the player is using the keyboard.</li>
<li>Set <strong class="bold">Gamepad</strong> | <strong class="bold">Gamepad Left Thumbstick Button</strong> for if the player is using the controller (this second option will allow the player to press the thumbstick to sprint).</li>
</ol>
<p>Next, <strong class="bold">IA_Move</strong> will let the player use the left thumbstick controller or the usual WASD keys – this means you will add five interactions: one for the thumbstick and then four for the up, down, left, and right directions. Let’s add them to the Mapping Context, starting with the thumbstick settings:</p>
<ol>
<li>Add <strong class="bold">Gamepad</strong> | <strong class="bold">Gamepad Left Thumbstick 2D-Axis</strong> to the mappings. Additionally, add a modifier from the <strong class="bold">Modifiers</strong> list with the value <strong class="bold">Dead Zone</strong>.</li>
<li>Moving on to the directions, for the right direction (mapped on your keyboard as <em class="italic">D</em>), add a <strong class="bold">Keyboard</strong> | <strong class="bold">D</strong> mapping with no modifiers.</li>
<li>For the left direction (mapped on your keyboard as <em class="italic">A</em>), add a <strong class="bold">Keyboard</strong> | <strong class="bold">A</strong> mapping. Then add a modifier with the value <strong class="bold">Negate</strong>. This will grant negative values from this interaction (i.e., movements to the right are positive, while movements to the left are negative).</li>
<li>For the forward direction (mapped on your keyboard as <em class="italic">W</em>), add a <strong class="bold">Keyboard</strong> | <strong class="bold">W</strong> mapping. Then, add a modifier with the value <strong class="bold">Swizzle Input Axis Values</strong>, which will convert <em class="italic">x</em> values into <em class="italic">y</em> (and vice versa), so you’ll get a “forward” value for your character.</li>
<li>Lastly, for the backward direction (mapped on your keyboard as <em class="italic">S</em>), add a <strong class="bold">Keyboard</strong> | <strong class="bold">S</strong> mapping. Then, add a modifier with the value <strong class="bold">Swizzle Input Axis Values</strong> and an additional one with the value <strong class="bold">Negate</strong>. This will grant negative values from this interaction in a similar way to the left movement explained for the <em class="italic">A</em> key.</li>
</ol>
<p>Finally, the <strong class="bold">IA_Look</strong> mapping is going to be controlled by the right thumbstick of the controller or by the movement of the mouse. To add such settings, take these steps:</p>
<ol>
<li>From the drop-down menu, select <strong class="bold">Gamepad</strong> | <strong class="bold">Gamepad Right Thumbstick 2D-Axis</strong> for the controller. Additionally, add a modifier from the <strong class="bold">Modifiers</strong> list with a value of <strong class="bold">Dead Zone</strong>, so the thumbstick won’t send data when in the rest position.</li>
<li>Select a <strong class="bold">Mouse</strong> | <strong class="bold">Mouse XY 2D-Axis</strong> interaction for the mouse. Then add a modifier from the <strong class="bold">Modifiers</strong> list with the value <strong class="bold">Negate</strong> and uncheck the <strong class="bold">X</strong> and <strong class="bold">Z</strong> checkboxes, leaving just the <strong class="bold">Y</strong> value selected. This will grant negative values for the mouse interaction – for instance, moving it forward will let the character move the<a id="_idIndexMarker291"/> camera down, and moving it backward will move the camera up.</li>
</ol>
<p>You should now have a Mapping Context similar to the one shown in <em class="italic">Figure 5</em><em class="italic">.9</em>:</p>
<div><div><img alt="Figure 5.9 – The complete Mapping Context" src="img/Figure_05_09_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.9 – The complete Mapping Context</p>
<p>Now that the <a id="_idIndexMarker292"/>Mapping Context has been defined, it’s time to set up the character so that it can receive input from the player.</p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor113"/>Importing the Enhanced Input Module</h2>
<p>Let’s get back<a id="_idIndexMarker293"/> to the IDE, as you are now ready to add some components and code logic to your character. As we are using the Enhanced Input System, the first thing you will need to do is to add it to the module declaration in the <code>Build.cs</code> file.</p>
<p>To do so, open <code>UnrealShadows_LOTL.Build.cs</code> in the <code>Source</code> folder of your C++ project (the name may vary slightly if your project was named in a different way). Then locate the following line of code:</p>
<pre class="source-code">
PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore" });</pre>
<p>Change it by adding the Enhanced Input module:</p>
<pre class="source-code">
PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "EnhancedInput" });</pre>
<p>This will make the <a id="_idIndexMarker294"/>Enhanced Input module available to your project, and you’ll be ready to start implementing the user interaction, something that you’ll do right now.</p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor114"/>Adding user interaction to the character</h2>
<p>To add user <a id="_idIndexMarker295"/>interaction to the character, you will need to <a id="_idIndexMarker296"/>declare the Enhanced Input assets you created just a few moments ago.</p>
<p>In the next steps, you will declare the Mapping Context and action references to your code, along with the corresponding methods. After that, you’ll implement the code logic needed to handle all actions. Finally, you’ll declare these actions inside the character Blueprint.</p>
<h3>Declaring input properties and functions</h3>
<p>The first thing to do is<a id="_idIndexMarker297"/> to add the needed asset references for the Mapping Context and the actions that should be added to the <code>US_Character.h</code> header file. Open the header file, which should already include the following lines of code (if not, add it as a public declaration):</p>
<pre class="source-code">
virtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;</pre>
<p>Next, declare a pointer to the Input Mapping Context and a pointer for each Input Action. To do this, add the following code in the class implicit <code>private</code> section (i.e., just after the <code>GENERATED_BODY()</code> macro), just after the components declarations:</p>
<pre class="source-code">
UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Input", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;class UInputMappingContext&gt; DefaultMappingContext;
UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Input", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;class UInputAction&gt; MoveAction;
UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Input", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;UInputAction&gt; LookAction;
UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Input", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;UInputAction&gt; SprintAction;
UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Input", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;UInputAction&gt; InteractAction;</pre>
<p>As a last step for the header declarations, add the following methods in the <code>protected</code> section, just after the <code>BeginPlay()</code> method declaration:</p>
<pre class="source-code">
void Move(const struct FInputActionValue&amp; Value);
void Look(const FInputActionValue&amp; Value);
void SprintStart(const FInputActionValue&amp; Value);
void SprintEnd(const FInputActionValue&amp; Value);
void Interact(const FInputActionValue&amp; Value);</pre>
<p>As you can see, you<a id="_idIndexMarker298"/> added a method for each of the interactions you defined before. Just remember that in the <code>SprintStart()</code> and <code>SprintEnd()</code>).</p>
<h3>Implementing the Mapping Context for the character</h3>
<p>In the next steps, you’ll <a id="_idIndexMarker299"/>implement the Mapping Context by <a id="_idIndexMarker300"/>initializing it and binding each input action to the corresponding methods.</p>
<p>Open <code>US_Character.ccp</code> and add the following block of code, which includes all the classes you’ll be using in the next steps:</p>
<pre class="source-code">
#include "Components/InputComponent.h"
#include "GameFramework/Controller.h"
#include "EnhancedInputComponent.h"
#include "EnhancedInputSubsystems.h"</pre>
<p>Then, look for the <code>BeginPlay()</code> method and, after the <code>Super</code> declaration, add this block of code:</p>
<pre class="source-code">
if (APlayerController* PlayerController = Cast&lt;APlayerController&gt;(Controller))
{
   if (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem&lt;UEnhancedInputLocalPlayerSubsystem&gt;(PlayerController-&gt;GetLocalPlayer()))
   {
      Subsystem-&gt;AddMappingContext(DefaultMappingContext, 0);
   }
}</pre>
<p>The first line of code checks that the Controller is a <code>PlayerController</code> by means of a <code>Cast&lt;T&gt;</code> template.</p>
<p class="callout-heading">Note</p>
<p class="callout">When working in Unreal Engine, it is common to perform casts to specific classes frequently (as you already did in the previous chapters with Blueprints). You may already be used to casts in pure C++, but you should be aware that Unreal has slightly different behavior, as it is possible to safely cast to types that may not be valid. If you are used to regular C++ crashes in such cases, you’ll be happy to know that Unreal will simply return a safer <code>nullptr</code>.</p>
<p>Then, the code will try to get an Enhanced Input Subsystem from the player and, if successful, will add a Mapping Context to it. From this point on, all the actions declared inside the context will be “tracked” by the input system.</p>
<p>Of course, you<a id="_idIndexMarker301"/> will need to bind these actions to a <a id="_idIndexMarker302"/>corresponding method implementation (i.e., move, sprint, interact, etc.). To do this, look for the <code>SetupPlayerInputComponent()</code> method and, after the <code>Super()</code> declaration, add this block of code:</p>
<pre class="source-code">
if (UEnhancedInputComponent* EnhancedInputComponent = Cast&lt;UEnhancedInputComponent&gt;(PlayerInputComponent))
{
   EnhancedInputComponent-&gt;BindAction(MoveAction, ETriggerEvent::Triggered, this, &amp;AUS_Character::Move);
   EnhancedInputComponent-&gt;BindAction(LookAction, ETriggerEvent::Triggered, this, &amp;AUS_Character::Look);
   EnhancedInputComponent-&gt;BindAction(InteractAction, ETriggerEvent::Started, this, &amp;AUS_Character::Interact);
   EnhancedInputComponent-&gt;BindAction(SprintAction, ETriggerEvent::Started, this, &amp;AUS_Character::SprintStart);
   EnhancedInputComponent-&gt;BindAction(SprintAction, ETriggerEvent::Completed, this, &amp;AUS_Character::SprintEnd);
}</pre>
<p>As you can see, we are calling the <code>BindAction()</code> method on the input component pointer to bind each action to the corresponding method.</p>
<h3>Implementing the actions</h3>
<p>Now you are ready to implement the <a id="_idIndexMarker303"/>methods for each action. Let’s start with the <code>Move</code> method. Add the following block of code:</p>
<pre class="source-code">
void AUS_Character::Move(const FInputActionValue&amp; Value)
{
   const auto MovementVector = Value.Get&lt;FVector2D&gt;();
   GEngine-&gt;AddOnScreenDebugMessage(0, 5.f, FColor::Yellow, FString::Printf(TEXT("MovementVector: %s"), *MovementVector.ToString()));
   if (Controller != nullptr)
   {
      const auto Rotation = Controller-&gt;GetControlRotation();
      const FRotator YawRotation(0, Rotation.Yaw, 0);
      const auto ForwardDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);
      const auto RightDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);
     AddMovementInput(ForwardDirection, MovementVector.Y);
      AddMovementInput(RightDirection, MovementVector.X);
   }
}</pre>
<p>As you can see, the first thing that this code does is to get the 2D vector from the <code>Value</code> parameter. This vector contains the<em class="italic"> x</em> and <em class="italic">y</em> directions for the left thumbstick (or the keyboard) and indicates the direction in which the character should move. I have added an onscreen message to keep track of this value.</p>
<p>Next, if there is a Controller possessing this Actor, we compute the forward and right directions of the Character and move it in the corresponding direction (this is something you should already be familiar with if you’ve ever tried the Unreal Third Person template).</p>
<p>The next <a id="_idIndexMarker304"/>method you’ll be implementing is the <code>Look()</code> one, so add these lines just after the <code>Move()</code> function:</p>
<pre class="source-code">
void AUS_Character::Look(const FInputActionValue&amp; Value)
{
   const auto LookAxisVector = Value.Get&lt;FVector2D&gt;();
   GEngine-&gt;AddOnScreenDebugMessage(1, 5.f, FColor::Green, FString::Printf(TEXT("LookAxisVector: %s"), *LookAxisVector.ToString()));
   if (Controller != nullptr)
   {
      AddControllerYawInput(LookAxisVector.X);
      AddControllerPitchInput(LookAxisVector.Y);
   }
}</pre>
<p>As you can see, we are getting the 2D vector from the <code>Value</code> parameter that, this time, will come from the right thumbstick or the mouse. After that, we add a yaw/pitch to the Controller; this will cause the Spring component and, consequently, the Camera component, to rotate around the character.</p>
<p>For the sprint action, the character has two methods available – one for starting the sprint and one for ending it. Add this code block after the previous function:</p>
<pre class="source-code">
void AUS_Character::SprintStart(const FInputActionValue&amp; Value)
{
   GEngine-&gt;AddOnScreenDebugMessage(2, 5.f, FColor::Blue, TEXT("SprintStart"));
   GetCharacterMovement()-&gt;MaxWalkSpeed = 3000.f;
}
void AUS_Character::SprintEnd(const FInputActionValue&amp; Value)
{
   GEngine-&gt;AddOnScreenDebugMessage(2, 5.f, FColor::Blue, TEXT("SprintEnd"));
   GetCharacterMovement()-&gt;MaxWalkSpeed = 500.f;
}</pre>
<p>This code simply increases the maximum speed of the character when it is sprinting.</p>
<p class="callout-heading">Note</p>
<p class="callout">The walk and sprint values are hardcoded; we will need to get these values from a dataset later on as we progress through the book.</p>
<p>The last<a id="_idIndexMarker305"/> method you need to implement is the <code>Interact()</code> one but, at the moment, we don’t have anything to interact with! So, you’ll just add an onscreen message inside the function:</p>
<pre class="source-code">
void AUS_Character::Interact(const FInputActionValue&amp; Value)
{
   GEngine-&gt;AddOnScreenDebugMessage(3, 5.f, FColor::Red, TEXT("Interact"));
}</pre>
<p>The last thing <a id="_idIndexMarker306"/>you need to do to make the character fully functional is to add the input assets to the Blueprint.</p>
<h3>Updating the character Blueprint</h3>
<p>To update the<a id="_idIndexMarker307"/> Blueprint, take the following steps:</p>
<ol>
<li>Save all the files you have modified and get back to the Unreal Editor.</li>
<li>Click the <strong class="bold">Compile</strong> button and wait for the success message.</li>
<li>Open your <strong class="bold">BP_Character</strong> Blueprint and select the <strong class="bold">Class </strong><strong class="bold">Defaults</strong> section.</li>
<li>Search for the <strong class="bold">Input</strong> category in the <strong class="bold">Details</strong> panel. You should get the <strong class="bold">Default Mapping Context</strong> property along with the four actions that have been created.</li>
<li>Click the drop-down button for <strong class="bold">Default Mapping Context</strong> and select the corresponding asset (there should be only one to choose).</li>
<li>For each action property, select the corresponding action asset from the drop-down menu.</li>
</ol>
<p>The result of the previous steps is depicted in <em class="italic">Figure 5</em><em class="italic">.10</em>:</p>
<div><div><img alt="Figure 5.10 – The Blueprint input settings" src="img/Figure_05_10_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.10 – The Blueprint input settings</p>
<p>The character is finally complete! It’s been hard, but you are now ready to test it.</p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor115"/>Testing the character’s movement</h2>
<p>Now <a id="_idIndexMarker308"/>that the base user interaction has been implemented, it’s time to start testing it on a playable level. Open the <strong class="bold">Level_01</strong> map and do the following:</p>
<ol>
<li>Look for the <strong class="bold">SP 1</strong> (for <em class="italic">SpawnPoint 1</em>) label in the level and add a <strong class="bold">Player Start</strong> Actor near it.</li>
<li>Set <strong class="bold">Net Mode</strong> to <strong class="bold">Listen Server</strong> with <strong class="bold">3</strong> players.</li>
<li>Hit the <strong class="bold">Play</strong> button to test the game.</li>
</ol>
<p>You should be able to move the characters and make them sprint and look around.</p>
<p>You may be wondering how it is possible that you are already playing a networked game even though you did not add any multiplayer code logic. The answer is in the Character class, which is already set to be replicated – just open the <code>true</code>.</p>
<p>You may also have noticed that while the character on the server window moves and sprints smoothly, on the client’s window, movements seem a bit jumpy when you are running. This is happening because you are trying to execute the sprint action on the client, but the server is the one who is actually in command – as a result, the client will make the character move faster, but the server will bring it back to its move position. Basically, at the moment, we are trying to “cheat” on the client, but the server, which is authoritative, will forbid you from doing this. Obviously, this is a bug in our code, but we still have to understand the full meaning of replication and how to execute functions from the server.</p>
<p>To fix this bug, you <a id="_idIndexMarker309"/>will need to know more about replication. Just be patient – I will give you more detailed information about this topic in <a href="B18203_06.xhtml#_idTextAnchor125"><em class="italic">Chapter 6</em></a>, <em class="italic">Replicating Properties </em><em class="italic">O</em><em class="italic">ver the Network</em>, and <a href="B18203_07.xhtml#_idTextAnchor147"><em class="italic">Chapter 7</em></a>, <em class="italic">Using Remote Procedure </em><em class="italic">Calls (RPCs)</em>.</p>
<p>Now that you have created your own hero character from scratch, it’s time to get some knowledge on how an Actor connection is controlled: I will introduce this topic in the next section.</p>
<h1 id="_idParaDest-115"><a id="_idTextAnchor116"/>Controlling the connection of an Actor</h1>
<p>Now that you <a id="_idIndexMarker310"/>have created a fully working character, it’s time to understand how a connection is handled inside Unreal Engine (to quickly refresh your understanding of how connections work, you can refer back to <a href="B18203_02.xhtml#_idTextAnchor041"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding </em><em class="italic">Networking Basics</em>).</p>
<p>Each connection has its own <code>PlayerController</code> that has been created expressly for it; in this case, we say that the <code>PlayerController</code> is “owned” by that connection.</p>
<p>In Unreal Engine, Actors can have an <code>PlayerController</code>, then the <code>PlayerController</code> becomes the Owner of that Actor. This means that the first Actor is also owned by the<a id="_idIndexMarker311"/> same connection that owns the <code>PlayerController</code>.</p>
<p>The concept of ownership is used during Actor replication to determine which connections receive updates for each Actor: for instance, an Actor may be flagged so that only the connection that owns that Actor will be sent property updates for it.</p>
<p>As an example, let’s imagine that your thief character (which is basically an Actor) is possessed by a <code>PlayerController</code> – this <code>PlayerController</code> will be the Owner of the character. During gameplay, the thief gets a pickup that grants a magical dagger: once equipped, this weapon will be owned by the Character. This means that the <code>PlayerController</code> will also own the dagger. In the end, both the thief Actor and the dagger will be owned by the <code>PlayerController</code> connection. As soon as the thief Actor is no longer possessed by the Player Controller, it will cease to be owned by the connection, and so will the weapon.</p>
<p>If you <a id="_idIndexMarker312"/>have developed standalone games, you may be used to retrieving the Player Controller or the character by using nodes such as <code>Get Player Controller</code> or <code>Get Player Character</code> (or their corresponding C++ versions, <code>UGameplayStatics::GetPlayerController()</code> and <code>UGameplayStatics::GetPlayerCharacter()</code>). Using these functions in a networked environment may be the cause of many issues if you don’t know what you are doing, as you will get different results depending on the context.</p>
<p>As an example, calling the <code>Get Player Controller</code> function with <code>Player Index</code> equal to <code>0</code> will give you the following results:</p>
<ul>
<li>The listen server’s <code>PlayerController</code> if you are calling it from a listen server</li>
<li>The first client’s <code>PlayerController</code> if you are calling it from a dedicated server</li>
<li>The client’s <code>PlayerController</code> if you are calling it from a client</li>
</ul>
<p>If things seem confusing, they will become even more so, considering that the index will not be consistent across the server and different clients.</p>
<p>That’s why, when developing multiplayer games in Unreal Engine, you will most probably use some of the following functions (or their corresponding nodes):</p>
<ul>
<li><code>AActor::GetOwner()</code>, which returns the Owner of an Actor instance</li>
<li><code>APawn::GetController()</code>, which returns the Controller for the Pawn or Character instance</li>
<li><code>AController::GetPawn()</code>, which returns the Pawn possessed by the Controller</li>
<li><code>APlayerState::GetPlayerController()</code>, which will return the Player Controller that created the Player State instance (remote clients will return a null value)</li>
</ul>
<p>Regarding <a id="_idIndexMarker313"/>components, you should be aware that they have their own way of determining their owning connection – they will start by following the component’s outer chain until they find the Actor that owns them. From there, the system will proceed, as explained previously, to determine the owning connection of that Actor. To get the Owner of the component, you’ll use the <code>UActorComponent::GetOwner()</code> method.</p>
<p>In this section, we have just “scratched the surface” of what an Owner is and how to get info about it, but you should be aware that connection ownership is so important that it will be pervasive throughout the rest of the book: in other words, the idea of owning a connection is deemed crucial enough to be addressed throughout the multiplayer project we are developing.</p>
<p>In the next section, I’m going to introduce a topic that is deeply connected with connection ownership: relevancy.</p>
<h1 id="_idParaDest-116"><a id="_idTextAnchor117"/>Understanding Actor relevancy</h1>
<p>Relevancy<a id="_idIndexMarker314"/> is the process of <a id="_idIndexMarker315"/>determining which objects in a scene should be visible or updated based on their importance to the player. This is an important concept in Unreal Engine, and by understanding how it works, you can make sure your game runs efficiently. In this section, we will explore this topic and show an example of how it works depending on its settings.</p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor118"/>Understanding relevancy</h2>
<p>In Unreal Engine, the term <strong class="bold">relevancy</strong> refers to how the Engine determines which Actors in the game world <a id="_idIndexMarker316"/>should be replicated to which clients, based on their current locations, and which <a id="_idIndexMarker317"/>Actors are relevant to the player’s current view or area.</p>
<p>A game level can have a size varying from very small to really huge. This may pose a problem in updating everything on the network and for every client connected to the server. As the playing character may not need to know every single thing that’s happening in the level, most of the time, it’s just enough to let it know what is near.</p>
<p>As a consequence, the Engine uses several factors to let the player know if something has changed on an Actor: these factors span from the distance to the Actor itself, its visibility, and whether the Actor is currently active in the game world. An Actor that is deemed irrelevant will not be replicated to the player’s client, and this will reduce network traffic and improve game performance.</p>
<p>Unreal uses a virtual function named <code>AActor::IsNetRelevantFor()</code> to test the relevancy of an Actor. This test evaluates a set of properties that is intended to provide a reliable estimate of the Actors that can actually influence a client. The tests can be summarized as follows:</p>
<ul>
<li><code>bAlwaysRelevant</code> flag is set to <code>true</code></li><li>Or, it is owned by the <code>Pawn</code> or <code>PlayerController</code></li><li>Or, it is the <code>Pawn</code> object</li><li>Or, the <code>Pawn</code> object is the instigator of an action such as noise or damage</li></ul></li>
<li><code>bNetUseOwnerRelevancy</code> property is <code>true</code> and the Actor itself has an Owner, the owner’s relevancy will be used.</li>
<li><code>bOnlyRelevantToOwner</code> property set to <code>true</code> and does not pass the first check, then it is not relevant.</li>
<li><strong class="bold">Fourth Check</strong>: If the Actor is attached to another Actor’s skeleton, then its relevancy is determined by the relevancy of its parent.</li>
<li><code>bHidden</code> property is set to <code>true</code> and the root component is not colliding with the checking Actor, then the Actor is not relevant.</li>
<li><code>AGameNetworkManager</code> is set to use distance-based relevancy, the Actor is relevant if it is closer than the net cull distance.</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">The <code>Pawn</code>/<code>Character</code> and <code>PlayerController</code> classes have slightly different relevancy checks as they need to consider additional information, such as the movement component.</p>
<p>It should be noted that this system is not perfect, as the distance check may give a false negative when dealing with large Actors. Additionally, the system does not take into account sound occlusion or other complexities related to ambient sounds. Nevertheless, the approximation is precise enough to get good results during gameplay.</p>
<p>After <a id="_idIndexMarker318"/>presenting<a id="_idIndexMarker319"/> all this theory, it is time to shift our focus back to the project and begin implementing a tangible example. In the following subsection, you will see relevancy in action by testing your character.</p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor119"/>Testing relevancy</h2>
<p>To test the effect of relevancy during<a id="_idIndexMarker320"/> gameplay, you’ll create a simple pickup and play around with its settings.</p>
<h3>Creating the Pickup Actor</h3>
<p>Start by creating a new C++ class <a id="_idIndexMarker321"/>inheriting from <code>US_BasePickup</code>. Then, open the generated header file and add these two component declarations in the <code>private</code> section:</p>
<pre class="source-code">
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category="Components",  meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;class USphereComponent&gt; SphereCollision;
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category="Components", meta = (AllowPrivateAccess = "true"))
TObjectPtr&lt;class UStaticMeshComponent&gt; Mesh;</pre>
<p>You should be familiar with the previous code – we are just declaring the Collision component for triggering the pickup and the Mesh component for its visual aspect.</p>
<p>Next, in the <code>protected</code> section, just after the <code>BeginPlay()</code> declaration, add a declaration that will handle the character overlap with the Actor:</p>
<pre class="source-code">
UFUNCTION()
void OnBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult&amp; SweepResult);</pre>
<p>Immediately after that, add the declaration for the pickup action:</p>
<pre class="source-code">
UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = "Pickup", meta=(DisplayName="Pickup"))
void Pickup(class AUS_Character* OwningCharacter);</pre>
<p>We need this function to be callable inside a Blueprint, so we use the <code>BlueprintCallable</code> specifier.</p>
<p>Then, the <code>BlueprintNativeEvent</code> specifier states that the function can be overwritten by a Blueprint, but it also has a default native C++ implementation that will be called if the Blueprint does not implement anything.</p>
<p>To natively implement the method, in the <code>US_BasePickup.cpp</code> file, we will need to implement a C++ function with the same name as the primary function but with <code>_Implementation</code> added to the end.</p>
<p>Finally, to the <code>public</code> section – and after the corresponding properties, in order to avoid forward declarations – add two getters for the components we declared previously:</p>
<pre class="source-code">
FORCEINLINE USphereComponent* GetSphereCollision() const { return SphereCollision; }
FORCEINLINE UStaticMeshComponent* GetMesh() const { return Mesh; }</pre>
<p>Now that the header has been fully declared, open the <code>US_BasePickup.cpp</code> file to start adding code logic to your Actor. First of all, add the necessary includes at the top of the file:</p>
<pre class="source-code">
#include "US_Character.h"
#include "Components/SphereComponent.h"</pre>
<p>Then, inside the <a id="_idIndexMarker322"/>constructor, add the following block of code, which creates the two components and attaches them to the Actor:</p>
<pre class="source-code">
SphereCollision = CreateDefaultSubobject&lt;USphereComponent&gt;("Collision");
RootComponent = SphereCollision;
SphereCollision-&gt;SetGenerateOverlapEvents(true);
SphereCollision-&gt;SetSphereRadius(200.0f);
Mesh = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;("Mesh");
Mesh-&gt;SetupAttachment(SphereCollision);
Mesh-&gt;SetCollisionEnabled(ECollisionEnabled::NoCollision);</pre>
<p>Immediately after that, set <code>bReplicates</code> to <code>true</code> (as Actors do not replicate by default):</p>
<pre class="source-code">
bReplicates = true;</pre>
<p>Inside the <code>BeginPlay()</code> function, add a <a id="_idIndexMarker323"/>dynamic multi-cast delegate for the overlap event:</p>
<pre class="source-code">
SphereCollision-&gt;OnComponentBeginOverlap.AddDynamic(this, &amp;AUS_BasePickup::OnBeginOverlap);</pre>
<p class="callout-heading">Note</p>
<p class="callout">To give proper attention and focus to replication, I have designated <a href="B18203_06.xhtml#_idTextAnchor125"><em class="italic">Chapter 6</em></a>, <em class="italic">Replicating Properties </em><em class="italic">O</em><em class="italic">ver the Network</em>, for an in-depth exploration of this topic.</p>
<p>Now add the overlap handler just after the closing bracket of the <code>BeginPlay()</code> function:</p>
<pre class="source-code">
void AUS_BasePickup::OnBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,
                                    UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult&amp; SweepResult)
{
    if (const auto Character = Cast&lt;AUS_Character&gt;(OtherActor))
    {
        Pickup(Character);
    }
}</pre>
<p>The previous block of code is quite straightforward: after having checked that the overlapping Actor is <code>AUS_Character</code> (i.e., our multiplayer hero), we simply call the <code>Pickup()</code> method.</p>
<p>To complete the pickup logic, you will now add the <code>Pickup()</code> C++ implementation:</p>
<pre class="source-code">
void AUS_BasePickup::Pickup_Implementation(AUS_Character * OwningCharacter)
{
   SetOwner(OwningCharacter);
}</pre>
<p>The code logic of this method can be implemented inside the inheriting Blueprints, but for the sake of demonstration, we are just setting the Owner of this Actor to the overlapping one: this is an important step in making things work in the next relevancy tests.</p>
<p>It’s now time to get back to the Unreal Engine Editor and do some “magic” – after all, this is a book about<a id="_idIndexMarker324"/> creating a fantasy game!</p>
<h3>Creating a pickup Blueprint class</h3>
<p>To test the effects of relevancy in <a id="_idIndexMarker325"/>action, you’ll create a Blueprint pickup... Well, sort of. Upon first examination, relevancy can exhibit some peculiar tendencies. This is precisely why we’ll be conjuring up a marvelously mystical tome that hovers in mid-air!</p>
<p>Open the Unreal Engine Editor and take the following steps:</p>
<ol>
<li>Compile your project to add the pickup to the available classes of your Blueprints.</li>
<li> In your <code>Blueprints</code> folder, create a new <code>BP_SpellBook</code>.</li>
<li>In the <strong class="bold">Blueprint Details</strong> panel, select a mesh for the <strong class="bold">Static Mesh</strong> property – I opted for the <strong class="bold">spellBook</strong> model.</li>
</ol>
<p>To make the book float, we are going to move the mesh up and down by using a <strong class="bold">Timeline </strong>node. To do so, follow these steps:</p>
<ol>
<li value="4">Open the Blueprint Event Graph, right-click on the canvas, and add a <code>Float</code>.</li>
<li>Double-click on the node to open the corresponding editor.</li>
<li>Click the <code>Alpha</code>. The button is shown in <em class="italic">Figure 5</em><em class="italic">.11</em>:</li>
</ol>
<div><div><img alt="Figure 5.11 – The Track button" src="img/Figure_05_11_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.11 – The Track button</p>
<ol>
<li value="7">Click on the <strong class="bold">Loop</strong> button to enable the loop mode. The button is shown in <em class="italic">Figure 5</em><em class="italic">.12</em>:</li>
</ol>
<div><div><img alt="Figure 5.12 – The Loop button" src="img/Figure_05_12_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.12 – The Loop button</p>
<ol>
<li value="8">Right-click on the curve panel and select the <strong class="bold">Add key to...</strong> option. Then, set <strong class="bold">Time</strong> to <strong class="bold">0</strong> and <strong class="bold">Value</strong> to <strong class="bold">0</strong>.</li>
<li>Create another key, but this time set <strong class="bold">Time</strong> to <strong class="bold">2.5</strong> and <strong class="bold">Value</strong> to <strong class="bold">0.5</strong>.</li>
<li>Create one last key, this time with <strong class="bold">Time</strong> equal to <strong class="bold">5</strong> and <strong class="bold">Value</strong> equal to <strong class="bold">0</strong>.</li>
<li> Right-click on each of the keys and set the <strong class="bold">Key Interpolation</strong> value to <strong class="bold">Auto</strong>.</li>
</ol>
<p>The final result of the <strong class="bold">Timeline</strong> node is shown in <em class="italic">Figure 5</em><em class="italic">.13</em>:</p>
<div><div><img alt="Figure 5.13 – The Timeline node settings" src="img/Figure_05_13_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.13 – The Timeline node settings</p>
<p>You have just created a sinusoidal value that will indefinitely loop between 0 and 1 values; you’ll use this floating value to move the book up and down. To implement this floating movement, return to the Event Graph and do the following:</p>
<ol>
<li value="12">Connect the <strong class="bold">Event Begin Play</strong> node to the <strong class="bold">Timeline</strong> node.</li>
<li>Drag the <strong class="bold">Mesh</strong> component from the <strong class="bold">Components</strong> panel onto the Event Graph canvas. Click and drag from its outgoing pin to add a <strong class="bold">Set Relative </strong><strong class="bold">Location</strong> node.</li>
<li>Connect<a id="_idIndexMarker327"/> the <strong class="bold">Set Relative Location</strong> incoming execution pin to the <strong class="bold">Update</strong> execution pin of the <strong class="bold">Timeline</strong> node.</li>
<li>Connect the <strong class="bold">Timeline</strong> node <strong class="bold">Alpha</strong> pin to a <strong class="bold">Multiply</strong> node and set the second parameter of this last node to <strong class="bold">100</strong>.</li>
<li>Right-click on the <strong class="bold">New Location</strong> pin of the <strong class="bold">Set Relative Location</strong> node and select <strong class="bold">Split Struct Pin</strong> to expose the X, Y, and Z values.</li>
<li>Connect the <strong class="bold">Result</strong> pin of the <strong class="bold">Multiply</strong> node to <strong class="bold">New Location Z</strong> of the <strong class="bold">Set Relative </strong><strong class="bold">Location</strong> node.</li>
</ol>
<p>The complete graph is shown in <em class="italic">Figure 5</em><em class="italic">.14</em>:</p>
<div><div><img alt="Figure 5.14 – The floating book graph" src="img/Figure_05_14_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.14 – The floating book graph</p>
<p>Please note that this floating animation is purely a visual effect, so we just won’t worry about whether<a id="_idIndexMarker328"/> it is synchronized over the network.</p>
<p>Now that the Blueprint item has been created, it’s time to add it to the level and test its pickup functionality – something we are going to do in the next subsection.</p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor120"/>Testing the relevancy settings</h2>
<p>It’s now time to test how the <a id="_idIndexMarker329"/>spell book behaves in a multiplayer environment when relevancy settings are changed.</p>
<p>First of all, drag an instance of the <strong class="bold">BP_SpellBook</strong> Blueprint into the level, near the PlayerStart Actor, so that the player will be in the line of sight once it has been spawned.</p>
<p>Open the <strong class="bold">PB_SpeelBook</strong> Blueprint and, with the <strong class="bold">Class Defaults</strong> panel selected, look for the <strong class="bold">Replication</strong> category. The default settings should be similar to the ones shown in <em class="italic">Figure 5</em><em class="italic">.15</em>:</p>
<div><div><img alt="Figure 5.15 – The Replication category" src="img/Figure_05_15_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.15 – The Replication category</p>
<p>Try playing the game as a listen server with three players, and every player should see the book as expected. Things are going to get a bit trickier in a moment...</p>
<p>Stop the application from playing and get back to the <strong class="bold">BP_SpellBook</strong> Blueprint. Look for the <strong class="bold">Net Load on Client</strong> property and uncheck it. As this property will load the Actor during map loading, we need to disable it, so the Actor will be loaded only when it becomes relevant for the client.</p>
<p>You are now ready to test<a id="_idIndexMarker330"/> different situations, depending on the properties you change in the next steps.</p>
<h3>Setting the net cull distance</h3>
<p>The first situation you will be testing <a id="_idIndexMarker331"/>is about distance culling – at the moment, your <a id="_idIndexMarker332"/>object is set to be relevant at a very far distance. To check this, run the game again, and you should see no difference since your last gameplay. But what happens if you lower <strong class="bold">Net Cull Distance Squared</strong> to a very low number, for instance, <strong class="bold">500</strong>? You will get really “weird” behavior: the server window will show the book, while the two clients will not!</p>
<p>With one of the client windows active, try walking near the zone where the book should be, and it will immediately pop up! Didn’t I already warn you that this book was nothing short of magical?</p>
<p>The property you just changed sets the square of the distance that will be used to make the Actor relevant to the client. This means that the spell book will “magically” appear as soon as the character is<a id="_idIndexMarker333"/> within the square root of this distance. As the server is <a id="_idIndexMarker334"/>authoritative (i.e., knows everything), it will always show the Actor.</p>
<p>Let’s now test a way to set the Actor as always relevant and, as such, always visible.</p>
<h3>Setting the Actor as always relevant</h3>
<p>Return to the spell book Blueprint and <a id="_idIndexMarker335"/>set the <strong class="bold">Always Relevant</strong> property<a id="_idIndexMarker336"/> to <strong class="bold">True</strong>, leaving the rest as it was in the previous example. When you play the game, you will notice that every client will be able to see the book from the start. This happens because the book has now been marked as something that should be relevant no matter where the character is in the level; as a consequence, it will be immediately loaded by the client and visible to the players.</p>
<p>This is obviously not a desirable situation – getting a continuous update for every Actor in the level is something we don’t want to happen, considering that there could be a multitude of moving elements in our game. But you probably already imagined that, didn’t you?</p>
<p>Let’s avoid this issue by setting relevancy based on the Owner of the Actor.</p>
<h3>Setting the relevancy for the Owner</h3>
<p>You may remember <a id="_idIndexMarker337"/>that the C++ code for the <code>Pickup()</code> function assigns the Owner of the pickup to the character overlapping it. Instead, in this Blueprint, we’ll see what happens if the Actor is relevant only to the Owner:</p>
<ol>
<li>Set the <strong class="bold">Only Relevant to Owner</strong> property to <strong class="bold">True</strong>.</li>
<li>Set the <strong class="bold">Always Relevant</strong> property to <strong class="bold">False</strong>.</li>
<li>Set <strong class="bold">Net Cull Distance Squared</strong> to a really low number, say <strong class="bold">10</strong>.</li>
</ol>
<p>With the last step, we are setting the spell book so that it won’t be relevant to any client unless it is directly on the object; this will let us test who is the Owner of the Actor.</p>
<p>The clients won’t be able to see the book unless they enter its collision zone, which is when the character becomes the Owner of the pickup. Once another character enters the pickup zone, it will become the new Owner and the book will become relevant. After a few moments, the first client will see the book disappear as the character is no longer the Owner of the pickup, and so it is no longer relevant to it!</p>
<p>As a final note, there is one last property you should be aware of: <strong class="bold">Net Use Owner Relevancy</strong> will<a id="_idIndexMarker338"/> return the relevancy of an Actor depending on its owner relevancy. This will come in handy once you assign a weapon to a character or<a id="_idIndexMarker339"/> to an enemy!</p>
<p>In this section, you have now unlocked the mystical secrets of relevancy and witnessed it in action. This concept will prove invaluable as you begin optimizing your game, but it’s always best to lay a strong foundation and set the right course from the very beginning. The following section will introduce another significant concept, namely authority.</p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor121"/>Introducing authority</h1>
<p>As we mentioned in <a href="B18203_02.xhtml#_idTextAnchor041"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding Networking Basics</em>, the term <strong class="bold">authority</strong> refers to <a id="_idIndexMarker340"/>which instance of the game has the final say over certain aspects of the game state. In an Unreal Engine multiplayer environment, the server is authoritative over the game state: this means that the server makes the final decisions about things such as player movement, damage calculation, and other game mechanics.</p>
<p>When a client requests to perform an action that affects the game state, it sends a message to the server requesting permission to perform that action. The server then determines whether the action is valid and, if so, updates the game state accordingly. Once the server has updated the game state, it sends a message to all clients to inform them of the updated state.</p>
<p>In Unreal Engine, Actors can be either locally or remotely controlled, and the concept of authority is important in determining which controls are valid. Actors that are locally controlled have authority over their own actions, while those that are remotely controlled receive commands from the server and follow those commands.</p>
<p>Overall, the concept of<a id="_idIndexMarker341"/> authority ensures that all players see a consistent game state and that no one player has an unfair advantage.</p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor122"/>Controlling authority with the Role and Remote Role properties of an Actor</h2>
<p>In Unreal Engine, there are two <a id="_idIndexMarker342"/>properties that return important information about Actor replication: <strong class="bold">Role</strong> and <strong class="bold">Remote Role</strong>. These two properties provide information about who has authority over the Actor, whether the Actor is replicated or not, and the method of replication.</p>
<p>In Unreal Engine, an Actor can have one of four possible roles<a id="_idIndexMarker343"/> during network play:</p>
<ul>
<li><code>ROLE_Authority</code>: The running instance has authoritative control over the Actor</li>
<li><code>ROLE_AutonomousProxy</code>: The running instance is an autonomous proxy of the Actor</li>
<li><code>ROLE_SimulatedProxy</code>: The running instance is a locally simulated proxy of the Actor</li>
<li><code>ROLE_None</code>: In this case, the role<a id="_idIndexMarker344"/> is not relevant</li>
</ul>
<p>Overall, the <code>Role</code> and <code>RemoteRole</code> properties are used to control how an Actor behaves during network play in Unreal Engine, and their values can differ depending on the Actor’s ownership and replication settings. In particular, the <code>Role</code> property specifies the Actor’s role on the local machine, while the <code>RemoteRole</code> property specifies the Actor’s role on the remote machine.</p>
<p>As an example, if <code>Role</code> is set to <code>ROLE_Authority</code> and <code>RemoteRole</code> is set to either <code>ROLE_SimulatedProxy</code> or <code>ROLE_AutonomousProxy</code>, then the current instance of the game is responsible for replicating this Actor to remote connections.</p>
<p>It should be noted that only the server replicates Actors to connected clients as clients will never replicate Actors to the server. This means that only the server will have <code>Role</code> set to <code>ROLE_Authority</code> and <code>RemoteRole</code> set to <code>ROLE_SimulatedProxy</code> or <code>ROLE_AutonomousProxy</code>.</p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor123"/>Autonomous and simulated proxy</h2>
<p>While testing the spell book pickup (well, it was not strictly a “pickup,” but you get the point), you may have noticed that once the Actor’s Owner changed, the book did seem to stay relevant to both the old and the new Owner for a moment. To avoid using excessive amounts of CPU resources and bandwidth, the server does not replicate Actors during every update but at a frequency that is determined by the <code>AActor::NetUpdateFrequency</code> property.</p>
<p>The same thing will happen when updating any Actor during movement, and the client will receive data at predefined intervals; as a consequence, the player may get seemingly erratic updates on an Actor. To avoid these kinds of issues, the Engine will try to extrapolate movement based on the latest data available.</p>
<p>The default behavior relies on predicting the movement and is governed by a <code>ROLE_SimulatedProxy</code>. In this mode, the client continuously updates the location of the Actor based on the latest velocity received from the server.</p>
<p>When an Actor is controlled<a id="_idIndexMarker346"/> by a <code>PlayerController</code> object, you may use an <code>ROLE_AutonomousProxy</code>. In this case, the system will receive additional information directly from the human player, making the process of predicting future actions smoother.</p>
<p>In this section, you’ve gained some insight into the realms of authority and Actor roles. These notions shall undoubtedly come in handy in future chapters, especially as you delve into the complexities of topics such as character weaponry and enemy AI.</p>
<h1 id="_idParaDest-123"><a id="_idTextAnchor124"/>Summary</h1>
<p>In this chapter, you made further progress in developing your multiplayer project by updating your character with the required movement and interaction features – this was achieved with the help of the Enhanced Input System provided by Unreal Engine.</p>
<p>Next, you gained some clarity on who’s pulling the strings of an Actor in a multiplayer environment by understanding what an Owner is.</p>
<p>After that, you started to see the light on the all-important role of relevancy in gaming. As you discovered for yourself, it’s crucial to know how properties are set, or things will start to take a big turn for the weird.</p>
<p>Lastly, you gained some valuable insights into the different roles that make up an Unreal Engine multiplayer game and why they play a crucial role in replicating an Actor’s behavior across multiple clients.</p>
<p>This brings us to a final question: what does “replicating” an object mean exactly? Well, I guess it’s time to take a stroll or indulge in a cup of coffee to recharge your batteries. You will need to summon all your energy and focus, for I will unveil (almost) all the secrets of replication in the next chapter!</p>
</div>
</body></html>