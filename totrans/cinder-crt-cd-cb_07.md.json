["```cpp\n#include \"cinder/gl/gl.h\"\n```", "```cpp\n    Vec2f mLineBegin,mLineEnd;\n    Rect fmRect;\n    Vec2f mCircleCenter;\n    float mCircleRadius;\n    Vec2f mEllipseCenter;\n    float mElipseWidth, mEllipseHeight;\n    Color mFillColor, mStrokeColor;\n    ```", "```cpp\n    mLineBegin = Vec2f( 10, 10 );\n    mLineEnd = Vec2f( 400, 400 );\n\n    mCircleCenter = Vec2f( 500, 200 );\n    mCircleRadius = 100.0f;\n\n    mEllipseCenter = Vec2f( 200, 300 );\n    mEllipseWidth = 200.0f;\n    ellipseHeight = 100.0f;\n\n    mRect = Rectf( Vec2f( 40, 20 ), Vec2f( 300, 100 ) );\n\n    mFillColor = Color( 1.0f, 1.0f, 1.0f );\n    mStrokeColor = Color( 1.0f, 0.0f, 0.0f );\n    ```", "```cpp\n    gl::clear( Color( 0, 0, 0 ) );\n    gl::color( mFillColor );\n    ```", "```cpp\n    gl::drawSolidRect( mRect );\n    gl::drawSolidCircle( mCircleCenter, mCircleRadius );\n    gl::drawSolidEllipse( mEllipseCenter, mEllipseWidth, ellipseHeight );\n    ```", "```cpp\n    gl::color( mStrokeColor );\n    ```", "```cpp\n    gl::drawLine( mLineBegin, mLineEnd );\n    gl::drawStrokedRect( mRect );\n    gl::drawStrokedCircle( mCircleCenter, mCircleRadius );\n    gl::drawStrokedEllipse( mEllipseCenter, mEllipseWidth, ellipseHeight );\n    ```", "```cpp\nglLineWidth( 5.0f );\n```", "```cpp\n#include \"cinder/gl/gl.h\"\n#include \"cinder/shape2d.h\"\n```", "```cpp\n    Shape2d mShape;\n    Color fillColor, strokeColor;\n    ```", "```cpp\n    mFillColor = Color( 1.0f, 1.0f, 0.0f );\n    mStrokeColor = Color( 0.0f, 0.0f, 0.0f );\n    ```", "```cpp\n    void mouseDown( MouseEvent event );\n    void mouseDrag( MouseEvent event );\n    ```", "```cpp\n    void MyApp::mouseDown( MouseEvent event ){\n      mShape.moveTo( event.getpos() );\n    }\n    ```", "```cpp\n    void MyApp::mouseDrag( MouseEvent event ){\n      mShape.lineTo( event.getPos() );  \n    }\n    ```", "```cpp\n    gl::clear( Color::white() );\n    gl::color( mFillColor );\n    gl::drawSolid( mShape );\n    ```", "```cpp\n    gl::color( mStrokeColor );\n    gl::draw( mShape );\n    ```", "```cpp\n    #include<vector>\n    ```", "```cpp\n    vector <Vec2f> mPath;\n    float mMaxDist;\n    ColorA mColor;\n    bool mDrawPath;\n    ```", "```cpp\n    void MainApp::setup()\n    {\n      mDrawPath = false;\n      mMaxDist = 50.f;\n      mColor = ColorA(0.3f,0.3f,0.3f, 0.05f);\n      setWindowSize(800, 600);\n\n      gl::enableAlphaBlending();\n      gl::clear( Color::white() );\n    }\n    ```", "```cpp\n    void MainApp::mouseDown( MouseEvent event )\n    {\n      mDrawPath = true;\n    }\n\n    void MainApp::mouseUp( MouseEvent event )\n    {\n      mDrawPath = false;\n    }\n    ```", "```cpp\n    void MainApp::draw(){\n      if( mDrawPath ) {\n      drawPoint( getMousePos() );\n        }\n    }\n\n    void MainApp::drawPoint(Vec2f point) {\n      mPath.push_back( point );\n\n      gl::color(mColor);\n      vector<Vec2f>::iterator it;\n      for(it = mPath.begin(); it != mPath.end(); ++it) {\n      if( (*it).distance(point) <mMaxDist ) {\n      gl::drawLine(point, (*it));\n            }\n        }\n    }\n    ```", "```cpp\n    void main()\n    {\n      gl_Position = ftransform();\n      gl_TexCoord[0] = gl_MultiTexCoord0;\n      gl_FrontColor = gl_Color; \n    }\n    ```", "```cpp\n    #version 120\n\n    uniform vec2 size;\n    uniform int num;\n    uniform vec2 positions[100];\n    uniform float radius[100];\n\n    void main(void)\n    {\n\n      // Get coordinates\n      vec 2 texCoord = gl_TexCoord[0].st;\n\n      vec4 color = vec4(1.0,1.0,1.0, 0.0);\n      float a = 0.0;\n\n      int i;  \n      for(i = 0; i<num; i++) {\n        color.a += (radius[i] / sqrt( ((texCoord.x*size.x)-\n        positions[i].x)*((texCoord.x*size.x)-positions[i].x) + \n        ((texCoord.y*size.y)-\n        positions[i].y)*((texCoord.y*size.y)-positions[i].y) ) \n        ); \n        }\n\n      // Set color\n      gl_FragColor = color;\n    }\n    ```", "```cpp\n    #include \"cinder/Utilities.h\"\n    #include \"cinder/gl/GlslProg.h\"\n    ```", "```cpp\n    gl::GlslProg  mMetaballsShader;\n    ```", "```cpp\n    repulsionFactor = -40.f;\n    int numParticle = 10;\n    ```", "```cpp\n    mMetaballsShader = gl::GlslProg( loadAsset(\"passThru_vert.glsl\"), loadAsset(\"mb_frag.glsl\") );\n    ```", "```cpp\n    void MainApp::draw()\n    {\n      gl::enableAlphaBlending();\n      gl::clear( Color::black() );\n\n      int particleNum = mParticleSystem.particles.size();\n\n      mMetaballsShader.bind();\n      mMetaballsShader.uniform( \"size\", Vec2f(getWindowSize()) );\n      mMetaballsShader.uniform( \"num\", particleNum );\n\n      for (int i = 0; i<particleNum; i++) {\n      mMetaballsShader.uniform( \"positions[\" + toString(i) + \n      \"]\", mParticleSystem.particles[i]->position );\n      mMetaballsShader.uniform( \"radius[\" + toString(i) + \n        \"]\", mParticleSystem.particles[i]->radius );\n      }\n\n      gl::color(Color::white());\n      gl::drawSolidRect( getWindowBounds() );\n      mMetaballsShader.unbind();\n    }\n    ```", "```cpp\n    #pragma once\n\n    #include \"cinder/vector.h\"\n    #include \"cinder/text.h\"\n    #include \"cinder/gl/Texture.h\"\n    ```", "```cpp\n    class Letter{\n    public:\n        Letter( ci::Font font, conststd::string& letter );\n\n        void draw();\n        void setPos( const ci::Vec2f& newPos );\n\n        ci::Vec2f pos;\n        float rotation;\n        ci::gl::Texture texture;\n        float width;\n    };\n    ```", "```cpp\n    Letter::Letter( ci::Font font, conststd::string& letter ){\n        ci::TextBoxtextBox;  \n        textBox = ci::TextBox().font( font ).size( ci::Vec2i( ci::TextBox::GROW, ci::TextBox::GROW ) ).text( letter ).premultiplied();\n        texture = textBox.render();\n        width = texture.getWidth() + 10.0f;\n    }\n    ```", "```cpp\n    void Letter::draw(){\n        glPushMatrix();\n        glTranslatef( pos.x, pos.y, 0.0f );\n        glRotatef( ci::toDegrees( rotation ), 0.0f, 0.0f, 1.0f );\n        glTranslatef( 0.0f, -texture.getHeight(), 0.0f );\n        ci::gl::draw( texture );\n        glPopMatrix();\n    }\n    ```", "```cpp\n    void Letter::setPos( const ci::Vec2f&newPos ){\n        ci::Vec2f vel = newPos - pos;\n        rotation = atan2( vel.y, vel.x );\n        pos = newPos;\n    }\n    ```", "```cpp\n    #pragma once\n    #include \"Letter.h\"\n    ```", "```cpp\n    class Word{\n    public:\n        Word( ci::Font font, conststd::string& text );\n\n        ~Word();\n\n        void update( const ci::Path2d& curve, float curveLength, float  progress );\n        void draw();\n\n          std::vector< Letter* > letters;\n          float length;\n    };\n    ```", "```cpp\n    #include \"Word.h\"\n    ```", "```cpp\n    Word::Word( ci::Font font, conststd::string& text ){\n      length = 0.0f;\n      for( int i=0; i<text.size(); i++ ){\n      std::string letterText( 1, text[i] );\n              Letter *letter = new Letter( font, letterText );\n      letters.push_back( letter );\n      length += letter->width;\n        }\n    }\n    ```", "```cpp\n    Word::~Word(){\n      for( std::vector<Letter*>::iterator it = letters.begin(); it != letters.end(); ++it ){\n      delete *it;\n        }\n    }\n    ```", "```cpp\n    void Word::update( const ci::Path2d& curve, float curveLength,   float progress ){\n      float maxProgress = 1.0f - ( length / curveLength );\n      float currentProgress = progress * maxProgress;\n      float progressOffset = 0.0f;\n      for( int i=0; i<letters.size(); i++ ){\n            ci::Vec2f pos = curve.getPosition\n            ( currentProgress + progressOffset );\n            letters[i]->setPos( pos );\n            progressOffset += ( letters[i]->width / curveLength );\n        }\n    }\n    ```", "```cpp\n    void Word::draw(){\n      for( std::vector< Letter* >::iterator it = letters.begin(); it != letters.end(); ++it ){\n            (*it)->draw();\n        }\n    }\n    ```", "```cpp\n    #include \"cinder/Timer.h\"\n    #include \"Word.h\"\n\n    using namespace ci;\n    using namespace ci::app;\n    using namespace std;\n    ```", "```cpp\n    Word * mWord;\n    Path2d mCurve;\n    float mPathLength;\n    Timer mTimer;\n    double mSeconds;\n    ```", "```cpp\n    string text = \"Some Text\";\n    Font font = Font( \"Arial\", 46 );\n    mWord = new Word( font, text );\n    mSeconds = 5.0;\n    ```", "```cpp\n    Vec2f curveBegin( 0.0f, getWindowCenter().y );\n    Vec2f curveCenter = getWindowCenter();\n    Vec2f curveEnd( getWindowWidth(), getWindowCenter().y );\n\n    mCurve.moveTo( curveBegin );\n    mCurve.curveTo( Vec2f( curveBegin.x, curveBegin.y + 200.0f ), Vec2f( curveCenter.x, curveCenter.y + 200.0f ), curveCenter );\n    mCurve.curveTo( Vec2f( curveCenter.x, curveCenter.y - 200.0f ), Vec2f( curveEnd.x, curveEnd.y - 200.0f ), curveEnd );\n    ```", "```cpp\n    mPathLength = 0.0f;\n    for( int i=0; i<mCurve.getNumPoints()-1; i++ ){\n      mPathLength += mCurve.getPoint( i ).distance( mCurve.getPoint( i+1 ) );\n        }\n    ```", "```cpp\n    if( mTimer.isStopped() == false ){\n      float progress;\n      if( mTimer.getSeconds() >mSeconds ){\n        mTimer.stop();\n        progress = 1.0f;\n            } else {\n      progress = (float)( mTimer.getSeconds() / mSeconds );\n            }\n    mWord->update( mCurve, mPathLength, progress );\n        }\n    ```", "```cpp\n    gl::clear( Color( 0, 0, 0 ) ); \n    gl::enableAlphaBlending();\n    mWord->draw(); \n    gl::draw( mCurve );\n    ```", "```cpp\n    void keyUp( KeyEvent event );\n    ```", "```cpp\n    void CurveTextApp::keyUp( KeyEvent event ){\n    mTimer.start();\n    }\n    ```", "```cpp\n    void main()\n    {\n      gl_Position = ftransform();\n      gl_TexCoord[0] = gl_MultiTexCoord0;\n      gl_FrontColor = gl_Color; \n    }\n    ```", "```cpp\n    #version 120\n\n    uniform sampler2D sceneTex; // 0\n\n    uniform float rt_w; // render target width\n    uniform float rt_h; // render target height\n    uniform float vx_offset;\n\n    float offset[3] = float[]( 0.0, 1.3846153846, 3.2307692308 );\n    float weight[3] = float[]( 0.2270270270, 0.3162162162, 0.0702702703 );\n\n    void main() \n    { \n      vec3 tc = vec3(1.0, 0.0, 0.0);\n      if (gl_TexCoord[0].x<(vx_offset-0.01)){\n    vec2 uv = gl_TexCoord[0].xy;\n    tc = texture2D(sceneTex, uv).rgb * weight[0];\n    for (int i=1; i<3; i++) {\n    tc += texture2D(sceneTex, uv + vec2(0.0, offset[i])/rt_h).rgb * weight[i];\n      tc += texture2D(sceneTex, uv - vec2(0.0, offset[i])/rt_h).rgb * weight[i];\n        }\n      }\n    else if (gl_TexCoord[0].x>=(vx_offset+0.01)){\n      tc = texture2D(sceneTex, gl_TexCoord[0].xy).rgb;\n      }\n    gl_FragColor = vec4(tc, 1.0);\n    }\n    ```", "```cpp\n    #version 120\n\n    uniform sampler2D sceneTex; // 0\n\n    uniform float rt_w; // render target width\n    uniform float rt_h; // render target height\n    uniform float vx_offset;\n\n    float offset[3] = float[]( 0.0, 1.3846153846, 3.2307692308 );\n    float weight[3] = float[]( 0.2270270270, 0.3162162162, 0.0702702703 );\n\n    void main() \n    { \n    vec3 tc = vec3(1.0, 0.0, 0.0);\n    if (gl_TexCoord[0].x<(vx_offset-0.01)){\n    vec2 uv = gl_TexCoord[0].xy;\n    tc = texture2D(sceneTex, uv).rgb * weight[0];\n    for (int i=1; i<3; i++) \n        {\n        tc += texture2D(sceneTex, uv + vec2(offset[i])/rt_w, 0.0).rgb * weight[i];\n        tc += texture2D(sceneTex, uv - vec2(offset[i])/rt_w, 0.0).rgb * weight[i];\n        }\n      }\n    else if (gl_TexCoord[0].x>=(vx_offset+0.01))\n      {\n      tc = texture2D(sceneTex, gl_TexCoord[0].xy).rgb;\n      }\n    gl_FragColor = vec4(tc, 1.0);\n    }\n    ```", "```cpp\n    #include \"cinder/Utilities.h\"\n    #include \"cinder/gl/GlslProg.h\"\n    #include \"cinder/gl/Texture.h\"\n    #include \"cinder/ImageIo.h\"\n    #include \"cinder/gl/Fbo.h\"\n    ```", "```cpp\n    gl::GlslProg  mGaussianVShader, mGaussianHShader;\n    gl::Texture mImage, mImageBlur;\n    gl::Fbo    mFboBlur1, mFboBlur2;\n    float           offset, level;\n    params::InterfaceGl mParams;\n    ```", "```cpp\n    void MainApp::setup(){\n      setWindowSize(512, 512);\n\n      level = 0.5f;\n      offset = 0.6f;\n\n      mGaussianVShader = gl::GlslProg( loadAsset(\"passThru_vert.glsl\"), loadAsset(\"gaussian_v_frag.glsl\") );\n      mGaussianHShader = gl::GlslProg( loadAsset(\"passThru_vert.glsl\"), loadAsset(\"gaussian_h_frag.glsl\") );\n      mImage = gl::Texture(loadImage(loadAsset(\"image.png\")));\n\n      mFboBlur1 = gl::Fbo\n      (mImage.getWidth(), mImage.getHeight());\n      mFboBlur2 = gl::Fbo\n      (mImage.getWidth(), mImage.getHeight());\n\n    // Setup the parameters\n      mParams = params::InterfaceGl\n      ( \"Parameters\", Vec2i( 200, 100 ) );\n      mParams.addParam\n      ( \"level\", &level, \"min=0 max=1 step=0.01\" );\n      mParams.addParam\n      ( \"offset\", &offset, \"min=0 max=1 step=0.01\");\n    }\n    ```", "```cpp\n    float rt_w = mImage.getWidth()*3.f-mImage.getWidth()*2.f*level;\n    float rt_h = mImage.getHeight()*3.f-mImage.getHeight()*2.f*level;\n    ```", "```cpp\n    mFboBlur1.bindFramebuffer();\n    gl::setViewport( mFboBlur1.getBounds() );\n    mImage.bind(0);\n    mGaussianVShader.bind();\n    mGaussianVShader.uniform(\"sceneTex\", 0);\n    mGaussianVShader.uniform(\"rt_w\", rt_w);\n    mGaussianVShader.uniform(\"rt_h\", rt_h);\n    mGaussianVShader.uniform(\"vx_offset\", offset);\n    gl::drawSolidRect(mFboBlur1.getBounds());\n    mGaussianVShader.unbind();\n    mFboBlur1.unbindFramebuffer();\n    ```", "```cpp\n    mFboBlur2.bindFramebuffer();\n    mFboBlur1.bindTexture(0);\n    mGaussianHShader.bind();\n    mGaussianHShader.uniform(\"sceneTex\", 0);\n    mGaussianHShader.uniform(\"rt_w\", rt_w);\n    mGaussianHShader.uniform(\"rt_h\", rt_h);\n    mGaussianHShader.uniform(\"vx_offset\", offset);\n    gl::drawSolidRect(mFboBlur2.getBounds());\n    mGaussianHShader.unbind();\n    mFboBlur2.unbindFramebuffer();\n    ```", "```cpp\n    mImageBlur = mFboBlur2.getTexture();\n    ```", "```cpp\n    gl::clear( Color::black() );\n    gl::setMatricesWindow(getWindowSize());\n    gl::setViewport(getWindowBounds());\n    gl::draw(mImageBlur);\n    params::InterfaceGl::draw();\n    ```", "```cpp\n    vector< pair<Particle*, Particle*> > mLinks;\n    float mLinkLength;\n    Particle*   mHandle;\n    bool mIsHandle;\n    ```", "```cpp\n    void MainApp::setup(){\n      mLinkLength = 40.f;\n      mIsHandle   = false;\n\n      float drag = 0.95f;\n\n      Particle *particle = newParticle(getWindowCenter(), 10.f, 10.f, drag );\n      mParticleSystem.addParticle( particle );\n\n      Vec2f r = Vec2f::one()*mLinkLength;\n      for (int i = 1; i<= 3; i++) {\n        r.rotate( M_PI * (i/3.f) );\n        Particle *particle1 = newParticle( particle->position+r, 7.f,7.f, drag );\n        mParticleSystem.addParticle( particle1 );\n        mLinks.push_back(make_pair(mParticleSystem.particles[0], particle1));\n\n        Vec2f r2 = (particle1->position-particle->position);\n        r2.normalize();\n        r2 *= mLinkLength;\n        for (int ii = 1; ii <= 3; ii++) {\n          r2.rotate( M_PI * (ii/3.f) );\n          Particle *particle2 = newParticle( particle1->position+r2, 5.f, 5.f, drag );\n          mParticleSystem.addParticle( particle2 );\n          mLinks.push_back(make_pair(particle1, particle2));\n\n          Vec2f r3 = (particle2->position-particle1->position);\n          r3.normalize();\n          r3 *= mLinkLength;\n          for (int iii = 1; iii <= 3; iii++) {\n    r3.rotate( M_PI * (iii/3.f) );\n    Particle *particle3 = newParticle( particle2->position+r3, 3.f, 3.f, drag );\n    mParticleSystem.addParticle( particle3 );\n    mLinks.push_back(make_pair(particle2, particle3));\n                }\n            }\n        }\n    }\n    ```", "```cpp\n    void MainApp::mouseDown(MouseEvent event){\n      mIsHandle = false;\n\n      float maxDist = 20.f;\n      float minDist = maxDist;\n      for( std::vector<Particle*>::iterator it = mParticleSystem.particles.begin(); it != mParticleSystem.particles.end(); ++it ){\n      float dist = (*it)->position.distance( event.getPos() );\n      if(dist<maxDist&&dist<minDist) {\n      mHandle = (*it);\n      mIsHandle = true;\n      minDist = dist;\n            }\n        }\n    }\n\n    void MainApp::mouseUp(MouseEvent event){\n    mIsHandle = false;\n    }\n    ```", "```cpp\n    void MainApp::update() {\n      for( std::vector<Particle*>::iterator it1 = mParticleSystem.particles.begin(); it1 != mParticleSystem.particles.end(); ++it1 )\n        {\n        for( std::vector<Particle*>::iterator it2 = mParticleSystem.particles.begin(); it2 != mParticleSystem.particles.end(); ++it2 ){\n          Vec2f conVec = (*it2)->position - (*it1)->position;\n          if(conVec.length() <0.1f)continue;\n\n            float distance = conVec.length();\n            conVec.normalize();\n            float force = (mLinkLength*2.0f - distance)* -0.1f;\n            force = math<float>::min(0.f, force);\n\n                (*it1)->forces +=  conVec * force*0.5f;\n                (*it2)->forces += -conVec * force*0.5f;\n            }\n        }\n\n    for( vector<pair<Particle*, Particle*> > ::iterator it = mLinks.begin(); it != mLinks.end(); ++it ){\n      Vec2f conVec = it->second->position - it->first->position;\n      float distance = conVec.length();\n      float diff = (distance-mLinkLength)/distance;\n      it->first->forces += conVec * 0.5f*diff;\n      it->second->forces -= conVec * 0.5f*diff;\n          }\n\n      if(mIsHandle) {\n        mHandle->position = getMousePos();\n        mHandle->forces = Vec2f::zero();\n        }\n\n      mParticleSystem.update();\n    }\n    ```", "```cpp\n    void MainApp::draw()\n    {\n      gl::enableAlphaBlending();\n      gl::clear( Color::white() );\n      gl::setViewport(getWindowBounds());\n      gl::setMatricesWindow( getWindowWidth(), getWindowHeight() );\n\n      gl::color( ColorA(0.f,0.f,0.f, 0.8f) );\n      for( vector<pair<Particle*, Particle*> > ::iterator it = mLinks.begin(); it != mLinks.end(); ++it )\n        {\n        Vec2f conVec = it->second->position - it->first->position;\n        conVec.normalize();\n        gl::drawLine(it->first->position + conVec * ( it->first->radius+2.f ),\n        it->second->position - conVec * ( it->second->radius+2.f ) );\n        }\n\n      gl::color( ci::ColorA(0.f,0.f,0.f, 0.8f) );\n      mParticleSystem.draw();\n    } \n    ```", "```cpp\n    void Particle::draw(){\n      ci::gl::drawSolidCircle( position, radius);\n      ci::gl::drawStrokedCircle( position, radius+2.f);\n    }\n    ```"]