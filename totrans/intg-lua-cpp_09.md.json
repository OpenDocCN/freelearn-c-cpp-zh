["```cpp\nint lua_checkstack (lua_State *L, int n);\n```", "```cpp\nvoid lua_settop (lua_State *L, int index);\n```", "```cpp\n    T *obj = luaModuleDef.createInstance(L);\n    lua_settop(L, 0);\n```", "```cpp\nvoid lua_pushvalue (lua_State *L, int index);\n```", "```cpp\nint lua_pcall(\n    lua_State *L, int nargs, int nresults, int msgh);\n```", "```cpp\ntypedef int (*lua_CFunction) (lua_State *L);\n```", "```cpp\nint luaGetExecutorVersionCode(lua_State *L)\n{\n   lua_pushinteger(L, LuaExecutor::versionCode);\n   return 1;\n}\n```", "```cpp\nvoid registerHostFunctions(lua_State *L)\n{\n    lua_pushcfunction(L, luaGetExecutorVersionCode);\n    lua_setglobal(L, \"host_version\");\n}\n```", "```cpp\nvoid LuaExecutor::registerModule(LuaModule &module)\n{\n    lua_createtable(L, 0, module.luaRegs().size() - 1);\n    int nUpvalues = module.pushLuaUpvalues(L);\n    luaL_setfuncs(L, module.luaRegs().data(), nUpvalues);\n    lua_setglobal(L, module.luaName().c_str());\n}\n```", "```cpp\nvoid luaL_newlib (lua_State *L, const luaL_Reg l[]);\n```", "```cpp\ntypedef struct luaL_Reg {\n    const char *name;\n    lua_CFunction func;\n} luaL_Reg;\n```", "```cpp\n#include \"Destinations.h\"\n#include \"LuaModuleExporter.hpp\"\n#include <lua.hpp>\nnamespace {\n    LuaModuleExporter module =\n        LuaModuleExporter<Destinations>::make(\n            DestinationsLuaModuleDef::def);\n}\nextern \"C\" {\nint luaopen_destinations(lua_State *L)\n{\n    lua_createtable(L, 0, module.luaRegs().size() - 1);\n    int nUpvalues = module.pushLuaUpvalues(L);\n    luaL_setfuncs(L, module.luaRegs().data(), nUpvalues);\n    return 1;\n}\n}\n```", "```cpp\nDESTINATIONS_O = Destinations.o DestinationsModule.o\nDESTINATIONS_SO = destinations.so\ndestinations: ${DESTINATIONS_O}\n    $(CXX) $(CXXFLAGS) $(CPPFLAGS) $(LDFLAGS) -shared \\\n        -o $(DESTINATIONS_SO) ${DESTINATIONS_O} -llua\n```", "```cpp\nChapter09 % ../lua/src/lua\nLua 5.4.6 Copyright (C) 1994-2023 Lua.org, PUC-Rio\n> Destinations = require \"destinations\"\n> dst = Destinations.new(\"Shanghai\", \"Tokyo\")\nDestinations instance created: 0x155a04210\n> dst:wish(\"London\", \"Paris\", \"Amsterdam\")\n> dst:went(\"Paris\")\n> print(\"Visited:\", dst:list_visited())\nVisited: Paris\n> print(\"Unvisited:\", dst:list_unvisited())\nUnvisited: Amsterdam London Shanghai Tokyo\n> os.exit()\nDestinations instance destroyed: 0x155a04210\n```", "```cpp\nvoid lua_pushcclosure(\n    lua_State *L, lua_CFunction fn, int n);\n```", "```cpp\nstruct LuaModuleDef\n{\n    ...\n    const std::function<void(T *)> destroyInstance =\n        [](T *obj) { delete obj; };\n    ...\n};\n```", "```cpp\nstatic int luaDelete(lua_State *L)\n{\n    auto luaModuleDef = getExporter(L)->luaModuleDef;\n    T *obj = *reinterpret_cast<T **>(\n        lua_touserdata(L, 1));\n    luaModuleDef.destroyInstance(obj);\n    return 0;\n}\n```", "```cpp\nstatic LuaModuleExporter<T> *getExporter(lua_State *L)\n{\n    return reinterpret_cast<LuaModuleExporter<T> *>(\n        lua_touserdata(L, lua_upvalueindex(1)));\n}\n```", "```cpp\nclass LuaModule\n{\npublic:\n    virtual int pushLuaUpvalues(lua_State *L)\n    {\n        lua_pushlightuserdata(L, this);\n        return 1;\n    }\n};\n```", "```cpp\nvoid LuaExecutor::registerModule(LuaModule &module)\n{\n    lua_createtable(L, 0, module.luaRegs().size() - 1);\n    int nUpvalues = module.pushLuaUpvalues(L);\n    luaL_setfuncs(L, module.luaRegs().data(), nUpvalues);\n    lua_setglobal(L, module.luaName().c_str());\n}\n```", "```cpp\nstatic int luaNew(lua_State *L)\n{\n    auto exporter = getExporter(L);\n    auto luaModuleDef = exporter->luaModuleDef;\n    ...\n    if (type == LUA_TNIL)\n    {\n        ...\n        lua_pushlightuserdata(L, exporter);\n        lua_pushcclosure(L, luaDelete, 1);\n        lua_setfield(L, -2, \"__gc\");\n    }\n    ...\n}\n```"]