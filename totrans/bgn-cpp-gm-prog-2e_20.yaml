- en: '*Chapter 19*: Game Programming Design Patterns – Starting the Space Invaders
    ++ Game'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 19 章*：游戏编程设计模式 – 开始 Space Invaders ++ 游戏'
- en: Welcome to the final project. As you have come to expect by now, this project
    will take a significant step forward in terms of learning new C++ techniques.
    The next four chapters will look at topics such as **smart pointers**, C++ **assertions,**
    using a gamepad controller, debugging using Visual Studio, **casting** pointers
    of a base class to become pointers of a specific derived class, debugging, and
    a first look at **design patterns**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到最终项目。正如你现在所期待的，这个项目将在学习新的 C++ 技巧方面迈出重要的一步。接下来的四章将探讨诸如 **智能指针**、C++ **断言**、使用游戏手柄控制器、使用
    Visual Studio 进行调试、**类型转换**基类指针到特定派生类指针、调试以及设计模式的第一瞥等主题。
- en: It is my guess that if you are going to make deep, large-scale games in C++,
    then design patterns are going to be a big part of your learning agenda in the
    months and years ahead. In order to introduce this vital topic, I have chosen
    a relatively simple but fun game to serve as an example. In this chapter, we'll
    find out a bit more about the Space Invaders ++ game, and then we can get on to
    the topic of design patterns and why we need them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我猜测，如果你打算用 C++ 制作深度、大规模的游戏，那么设计模式将是你未来几个月和几年学习计划中的重要部分。为了介绍这个至关重要的主题，我选择了一个相对简单但有趣的游戏作为例子。在本章中，我们将更深入地了解
    Space Invaders ++ 游戏，然后我们可以继续讨论设计模式及其必要性。
- en: 'In this hefty chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主题：
- en: Find out about Space Invaders ++ and why we chose it for the final project.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 Space Invaders ++ 以及为什么我们选择它作为最终项目。
- en: Learn what design patterns are and why they matter to game developers.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解什么是设计模式以及为什么它们对游戏开发者很重要。
- en: Study the design patterns in the Space Invaders ++ project that will be used
    over the next four chapters.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究在接下来的四章中将在 Space Invaders ++ 项目中使用的各种设计模式。
- en: We will get started on the Space Invaders ++ project.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将开始 Space Invaders ++ 项目。
- en: Code numerous classes to start fleshing out the game.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写多个类以开始充实游戏。
- en: Let's talk about the game itself.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈游戏本身。
- en: Space Invaders ++
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Space Invaders ++
- en: 'Have a look at the following three screenshots, which visually explain most
    of what we need to know about Space Invaders ++. Just in case you don''t know
    already, Space Invaders is one of the earliest arcade games and was released in
    1978\. If you like a bit of history, you can read the Wikipedia Space Invaders
    game page here: [https://en.wikipedia.org/wiki/Space_Invaders](https://en.wikipedia.org/wiki/Space_Invaders).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下三个截图，它们从视觉上解释了我们关于 Space Invaders ++ 需要知道的大部分内容。如果你还不知道，Space Invaders 是最早的街机游戏之一，于
    1978 年发布。如果你对历史感兴趣，你可以在这里阅读维基百科上的 Space Invaders 游戏页面：[https://en.wikipedia.org/wiki/Space_Invaders](https://en.wikipedia.org/wiki/Space_Invaders)。
- en: 'This first screenshot shows the simple starting screen of our game. For the
    purposes of discussing screens, which we''ll do next, we will call this the **select
    screen**. The player has two choices to select from: quit or play. However, by
    the end of this chapter, you will know how to add and switch between as many screens
    as you like:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这第一张截图显示了游戏简单的起始屏幕。为了讨论屏幕，我们将在下一部分进行讨论，我们将称这个屏幕为 **选择屏幕**。玩家有两个选择：退出或开始游戏。然而，在本章结束时，你将知道如何添加和切换你喜欢的任意多个屏幕：
- en: '![](img/B14278_19_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_19_01.jpg)'
- en: 'As you can see, in the preceding screenshot, there is a new feature we have
    not implemented before: clickable buttons. We will talk more about buttons and
    their counterparts, such as UI panels and screens, shortly.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在前面的截图中有我们之前没有实现的新功能：可点击的按钮。我们将在稍后更多地讨论按钮及其对应物，如 UI 面板和屏幕。
- en: 'The following screenshot shows the game in action. It is quite simple to play.
    For the purposes of discussing screens, which we''ll do next, we will call the
    following screenshot the **play screen**. The invaders move from left to right
    while shooting bullets at the player. When they reach the edge of the screen,
    they drop a little lower, speed up, and head back to the left:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了游戏的实际运行情况。游戏玩法相当简单。为了讨论屏幕，我们将在下一部分进行讨论，我们将称以下截图为 **游戏屏幕**。入侵者从左向右移动，并向玩家射击子弹。当他们到达屏幕边缘时，他们会稍微下降，加速，然后返回左侧：
- en: '![](img/B14278_19_02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_19_02.jpg)'
- en: The player can move left and right as well as up and down, but the vertical
    movement is restricted to the bottom half of the screen.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家可以左右移动，也可以上下移动，但垂直移动仅限于屏幕的下半部分。
- en: Important note
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The original Space Invaders game just allowed horizontal movement.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的 Space Invaders 游戏只允许水平移动。
- en: 'The following screenshot shows the options the player is presented with when
    they have lost three lives. They can choose to play again or quit and go back
    to the select screen:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了玩家在失去三次生命时可以选择的选项。他们可以选择再次玩游戏或退出并返回选择屏幕：
- en: '![](img/B14278_19_03.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_19_03.jpg)'
- en: While Space Invaders ++ does allow us to introduce lots of new C++ topics that
    I have already mentioned in the introduction to the chapter, as well as some more
    game-related topics such as using a gamepad controller, it is true that this isn't
    really a step up in terms of complexity compared to the previous project. So,
    why choose this as the final project?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Space Invaders ++ 允许我们介绍许多我在章节介绍中已经提到的新的C++主题，以及一些与游戏相关的主题，例如使用游戏手柄控制器，但确实，与之前的项目相比，在复杂性方面并没有真正的提升。那么，为什么选择这个作为最终项目呢？
- en: Important note
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In this project, there's lots of code. Most of it we have seen before, either
    in the same context or a different context. It is not possible to explain every
    single line as a new book would be required to do so. I have very carefully chosen
    which code to explain in full, which code to just mention, and which code I am
    guessing you will be able to work out for yourself. I recommend studying all the
    code in this book and in the download bundle as you progress. I will, however,
    go into the structure of the code in full detail as that is the real learning
    objective of this project. Furthermore, all the C++ code is shown in this book,
    so nothing is missing, although only an overview of the `level1.txt` file is shown.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，有很多代码。其中大部分我们在之前已经见过，无论是在相同的环境中还是在不同的环境中。不可能解释每一行代码，因为这需要一本全新的书来做到。我已经非常仔细地选择了要完整解释的代码、只需提及的代码以及我猜测您自己能够解决的代码。我建议您在进步的过程中学习这本书和下载包中的所有代码。然而，我将会详细解释代码的结构，因为这确实是这个项目的真正学习目标。此外，本书中展示了所有的C++代码，所以没有遗漏，尽管只展示了`level1.txt`文件的概述。
- en: Why Space Invaders ++?
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么选择Space Invaders ++？
- en: 'To begin this discussion, please consider my two objectives for this book:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始这次讨论，请考虑我为本书设定的两个目标：
- en: The first objective of this book is to introduce you to C++ programming using
    the learning material of video games. I have already admitted on several occasions
    and several topics that this is just an introduction. C++ and game development
    are too big to fit into this book alone.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本书第一个目标是向您介绍使用视频游戏学习材料进行C++编程。我已经在多个场合和多个主题上承认，这只是一个入门。C++和游戏开发太大，无法仅凭这本书来涵盖。
- en: The second objective of this book is to leave you in a position to continue
    your study while still using games as the learning material.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本书第二个目标是让您在继续学习的同时，仍然可以使用游戏作为学习材料。
- en: The problem is, as we have seen, each time we build a game with more features
    than the last, we end up with a more complicated code structure and the code files
    get longer and longer too. Throughout this book, we have learned new ways to improve
    the structure of our code and at each stage, we have succeeded, but the increasing
    complexity of the games always seems to outweigh the code improvements we learn
    about.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，正如我们所看到的，每次我们构建一个比上一个游戏功能更多的游戏，我们最终都会得到一个更复杂的代码结构，代码文件也越来越长。在整个书中，我们学习了新的方法来改进我们的代码结构，在每一个阶段我们都取得了成功，但游戏的日益复杂性似乎总是超过了我们学到的代码改进。
- en: This project is designed to address this complexity issue and to take back control
    of our source code. Despite this game being less deep than the previous project,
    there will be far more classes to deal with.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目旨在解决这个复杂性问题，并重新控制我们的源代码。尽管这个游戏比之前的项目深度要低，但需要处理的类将远更多。
- en: This obviously implies quite a complicated structure. It will also mean, however,
    that once you get to grips with this structure, you will be able to reuse it for
    much more complicated games without any of the code files going beyond a few hundred
    lines of code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然意味着一个非常复杂的结构。然而，一旦您掌握了这个结构，您将能够为更复杂的游戏重用它，而无需任何代码文件超过几百行代码。
- en: What this project is designed to do is allow you to come up with your own game
    ideas, even complex ones, and get started on them right away, using the design
    patterns we'll discuss in the following section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目旨在让您能够提出自己的游戏想法，即使是复杂的想法，并立即开始使用我们在下一节中将要讨论的设计模式。
- en: Tip
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note, however, that I am definitely not suggesting the code structure (design
    patterns) we will learn about here are the ultimate solution to your game development
    future; in fact, they are far from it. What you will learn are solutions that
    allow you to get started with your dream project without the complexity stopping
    you in your tracks. You will still need to study more about design patterns, C++,
    and game development along the way.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我绝对不是在暗示这里我们将学习到的代码结构（设计模式）是解决你游戏开发未来的终极方案；实际上，它们离这个目标还远着呢。你将学到的是一些解决方案，这些解决方案将帮助你开始你的梦想项目，而不会因为复杂性而停滞不前。你仍然需要在过程中学习更多关于设计模式、C++和游戏开发的知识。
- en: So, what are design patterns?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是设计模式呢？
- en: Design patterns
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式
- en: 'A **design pattern** is a reusable solution to a coding problem. In fact, most
    games (including this one) will use multiple design patterns. The key point about
    design patterns is this: they are already proven to provide a good solution to
    a common problem. We are not going to invent any design patterns – we are just
    going to use some that already exist to solve the problem of our ever-expanding
    code.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**设计模式**是一种可重用的编码问题解决方案。实际上，大多数游戏（包括这个游戏）都会使用多个设计模式。关于设计模式的关键点在于：它们已经被证明能够为常见问题提供良好的解决方案。我们不会发明任何设计模式——我们只是将使用一些已经存在的设计模式来解决我们不断增长的代码中的问题。'
- en: Many design patterns are quite complicated and require further study beyond
    the level of this book if you want to even begin learning them. What follows is
    a simplification of a few key game development-related patterns that will help
    fulfill the second objective of this book. You're urged to continue your study
    to implement them more comprehensively and alongside even more patterns than will
    be discussed here.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 许多设计模式相当复杂，如果你想要开始学习它们，就需要在本书的水平之上进行进一步的学习。以下是对一些关键游戏开发相关模式的简化，这将有助于实现本书的第二个目标。我们鼓励你继续学习，以便更全面地实现它们，并使用比这里讨论的更多的模式。
- en: Let's look at the design patterns that are used in the Space Invaders ++ project.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在Space Invaders ++项目中使用的设计模式。
- en: Screen, InputHandler, UIPanel, and Button
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 屏幕、输入处理器、UI面板和按钮
- en: This project will abstract some concepts further than any of the other projects.
    Space Invaders ++ will introduce the concept of a **screen**. The concept of a
    screen is most easily understood by giving some examples. A game could have a
    menu screen, a settings screen, a high score screen, and a game screen. A **screen**
    is a logical division of the parts of the game. Every screen has some things in
    common with all the other screens, yet each screen also needs its own unique features
    as well. For example, a menu screen might have buttons that enable the player
    to transition to another screen, as well as a neat graphical image or even a dynamic
    scene. The high score screen will, of course, have a list of all the high scores
    and perhaps a button to return to the menu screen. Each screen will have a different
    layout, different buttons to click, and different responses to different keyboard
    presses, but they will all need to be drawn at 60 FPS and interact in the same
    way with the game engine.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目将比其他任何项目都进一步抽象化一些概念。Space Invaders ++将引入**屏幕**的概念。屏幕的概念可以通过一些例子来最容易地理解。一个游戏可以有一个菜单屏幕、设置屏幕、高分屏幕和游戏屏幕。**屏幕**是游戏各部分的逻辑划分。每个屏幕都与所有其他屏幕有一些共同点，但每个屏幕也需要其独特的功能。例如，菜单屏幕可能有一些按钮，允许玩家切换到另一个屏幕，以及一个整洁的图形图像，甚至是一个动态场景。高分屏幕当然会有一份所有高分列表，也许还有一个按钮可以返回到菜单屏幕。每个屏幕将具有不同的布局、不同的按钮可以点击，以及对不同键盘按键的不同响应，但它们都需要以60
    FPS的速度绘制，并以相同的方式与游戏引擎交互。
- en: In the previous projects, we crammed this concept of screens into one place.
    This meant we had sprawling long `if`, `else`, and `else if` blocks of code that
    handled updating, drawing, and responding to user interaction. Our code was getting
    quite challenging to handle already. If we are going to build more complicated
    games, we need to improve on this. The concept of screens means that we can create
    a class that handles all the stuff that happens for every screen, such as updating,
    drawing, and user interaction, and then create a derived class for each type of
    screen, that is, menu, game, high score, and so on, which handles the unique ways
    that a specific screen needs to update, draw, and respond to the user.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的项目中，我们将屏幕的概念压缩到了一个地方。这意味着我们有了处理更新、绘制和响应用户交互的长长的`if`、`else`和`else if`代码块。我们的代码已经变得很难处理了。如果我们打算构建更复杂的游戏，我们需要改进这一点。屏幕的概念意味着我们可以创建一个处理每个屏幕发生的所有事情（如更新、绘制和用户交互）的类，然后为每种类型的屏幕创建一个派生类，即菜单、游戏、高分等，这些类处理特定屏幕需要更新的、绘制的和响应用户的独特方式。
- en: In Space Invaders ++, we will have a `Screen` class. We will then inherit from
    `Screen` to handle two screens, `SelectScreen` and `GameScreen`. Furthermore,
    we will have a `Button` class that knows how to display a button, a `UIPanel`
    class that knows how to draw text, and `Button` instances as well as an `InputHandler`
    class that knows how to detect keyboard and gamepad interaction. We will then
    be able to derive from `UIPanel` and `InputHandler` to let all the different `Screen`
    instances behave exactly as required without coding the basics of a screen, a
    UI panel, an input handler, or a button more than once. The bigger your game gets
    and the more screens it has, the bigger the benefit of doing things this way.
    It also means that the specifics of each screen will not be crammed into long
    `if`, `else`, and `else if` structures as we have been doing so far.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在《太空侵略者++》中，我们将有一个`Screen`类。然后我们将从`Screen`类继承以处理两个屏幕，即`SelectScreen`和`GameScreen`。此外，我们还将有一个知道如何显示按钮的`Button`类，一个知道如何绘制文本的`UIPanel`类，以及`Button`实例以及一个知道如何检测键盘和游戏手柄交互的`InputHandler`类。这样我们就能从`UIPanel`和`InputHandler`继承，让所有不同的`Screen`实例都能按照要求精确地表现，而无需多次编写屏幕、UI面板、输入处理程序或按钮的基础代码。你的游戏越大，屏幕越多，这种方式的益处就越大。这也意味着每个屏幕的具体细节不会像我们之前所做的那样被塞进长长的`if`、`else`和`else
    if`结构中。
- en: 'This is a bit like how we coded the `PlayableCharacter` class and derived `Thomas`
    and `Bob` from it. As we will see, however, we go much further with the abstraction
    this time. Look at the following diagram, which shows a representation of this
    idea and shows just one screen:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点像我们编写`PlayableCharacter`类并从中派生出`Thomas`和`Bob`的方式。然而，正如我们将看到的，这次我们的抽象程度要高得多。看看下面的图表，它展示了这个想法的表示，并且只显示了一个屏幕：
- en: '![](img/B14278_19_04.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14278_19_04.jpg)'
- en: In the preceding diagram, we can see that a screen has one or more `UIPanel`
    instances that it can display selectively and that `UIPanel` instances can have
    zero or more `Button` instances. Each `UIPanel` will have a related `InputHandler`
    because each `UIPanel` will have different combinations and layouts of buttons.
    The buttons are shared via pointers between `UIPanel` and `InputHandler` instances.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，我们可以看到屏幕有一个或多个它可以选择性显示的`UIPanel`实例，并且`UIPanel`实例可以有零个或多个`Button`实例。每个`UIPanel`都将有一个相关的`InputHandler`，因为每个`UIPanel`将具有不同的按钮组合和布局。按钮通过指针在`UIPanel`和`InputHandler`实例之间共享。
- en: If you are wondering which class handles the update stage of the game loop,
    the answer is the `Screen` class. However, once you get your head around how this
    pattern works, it will be simple to add the ability to let `UIPanel` instances
    act in the update phase, too. This could be useful if, say, the panel needed to
    move or maybe show a loading progress bar.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道哪个类处理游戏循环的更新阶段，答案是`Screen`类。然而，一旦你理解了这种模式的工作原理，添加让`UIPanel`实例在更新阶段也能行动的能力将会变得简单。如果，比如说，面板需要移动或者可能显示一个加载进度条，这将是有用的。
- en: A screen will decide which `UIPanel` (and therefore, `InputHandler`) instances
    are currently visible and responding. However, only one screen at a time will
    be visible to the player. We will code a `ScreenManager` class that will be a
    fundamental part of the game engine to handle calling the key functions of the
    appropriate (current) screen. The `ScreenManager` class will also provide a way
    for the `InputHandler` instances to notify us when a change of screen is required,
    for example, when the player clicks the **Play** button on the select screen to
    go to the play screen.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一个屏幕将决定哪些 `UIPanel`（因此，`InputHandler`）实例当前可见并响应。然而，一次只有一个屏幕对玩家可见。我们将编写一个 `ScreenManager`
    类，这将成为游戏引擎的基本部分，用于调用适当（当前）屏幕的关键功能。`ScreenManager` 类还将提供一种方式，让 `InputHandler` 实例在需要屏幕切换时通知我们，例如，当玩家在选择屏幕上点击
    **Play** 按钮以进入游戏屏幕。
- en: '`ScreenManager` will hold an instance of every screen, remember the current
    screen the player is on, and call `update`, `draw`, and `handleInput` on the correct
    screen, as well as switch between screens when required. The following diagram
    will hopefully help you visualize this concept, which we will also be coding soon:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScreenManager` 将保存每个屏幕的实例，记住玩家当前所在的屏幕，并在正确的屏幕上调用 `update`、`draw` 和 `handleInput`，以及在需要时切换屏幕。以下图表可能会帮助你可视化这个概念，我们也将很快进行编码：'
- en: '![](img/B14278_19_05.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_19_05.jpg)'
- en: Note that the diagrams and explanation are a simplification of the solution
    we will be coding, but they give a good overview.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，图表和解释是对我们将要编写的解决方案的简化，但它们提供了一个很好的概述。
- en: Should you want to add a high score screen or another `UIPanel` instance to
    an existing screen, you will know how to do so by the end of [*Chapter 22*](B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445),
    *Using Game Objects and Building a Game*. Of course, it's likely that you will
    want to get started on your very own game. You will be able to divide up your
    next game into as many screens with their dedicated layouts and input handling
    as you need.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在现有屏幕上添加高分屏幕或另一个 `UIPanel` 实例，你将在结束 [*第22章*](B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445)，*使用游戏对象和构建游戏*
    时知道如何这样做。当然，你很可能会想开始你自己的游戏。你将能够将你的下一款游戏划分为你需要的大量屏幕，每个屏幕都有其专门的布局和输入处理。
- en: Entity-Component pattern
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体-组件模式
- en: We will now spend five minutes wallowing in the misery of an apparently unsolvable
    muddle. Then, we will see how the entity-component pattern comes to the rescue.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将花五分钟沉浸在看似无法解决的混乱中。然后，我们将看到实体-组件模式如何拯救我们。
- en: Why lots of diverse object types are hard to manage
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么大量多样的对象类型难以管理
- en: In the previous projects, we coded a class for each object. We had classes such
    as Bat, Ball, Crawler, and Thomas. Then, in the `update` function, we would update
    them, and in the `draw` function, we would draw them. Each object decides how
    updating and drawing takes place.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的项目中，我们为每个对象编写了一个类。我们有像 Bat、Ball、Crawler 和 Thomas 这样的类。然后在 `update` 函数中，我们会更新它们，在
    `draw` 函数中，我们会绘制它们。每个对象决定如何进行更新和绘制。
- en: We could just get started and use this same structure for Space Invaders ++.
    It would work, but we are trying to learn something more manageable so that our
    games can grow in complexity.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以开始使用相同的结构来为 Space Invaders ++ 编码。它会工作，但我们正在尝试学习更易于管理的知识，以便我们的游戏可以增加复杂性。
- en: Another problem with this approach is that we cannot take advantage of inheritance.
    For example, all the invaders, the bullets, and the player draw themselves in
    an identical way, but unless we change how we do things, we will end up with three
    `draw` functions with nearly identical code. If we make a change to how we call
    the `draw` function or the way we handle graphics, we will need to update all
    three classes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个问题是，我们无法利用继承。例如，所有入侵者、子弹和玩家都以相同的方式绘制自己，但除非我们改变做事的方式，否则我们最终会得到三个几乎相同的
    `draw` 函数。如果我们更改调用 `draw` 函数的方式或处理图形的方式，我们需要更新所有三个类。
- en: There must be a better way.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 必须有更好的方法。
- en: Using a generic GameObject for better code structure
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用通用的 GameObject 来优化代码结构
- en: If every object, player, alien, and all the bullets were one generic type, then
    we could pack them away in a `vector` instance and loop through each of their
    `update` functions, followed by each of their `draw` functions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个对象、玩家、外星人和所有子弹都是一种通用类型，那么我们可以将它们打包到一个 `vector` 实例中，并遍历它们的每个 `update` 函数，然后是每个
    `draw` 函数。
- en: We already know one way of doing this – inheritance. At first glance, inheritance
    might seem like a perfect solution. We could create an abstract `GameObject` class
    and then extend it with the `Player`, `Invader`, and `Bullet` classes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道一种做这件事的方法——继承。乍一看，继承可能看起来是一个完美的解决方案。我们可以创建一个抽象的`GameObject`类，然后通过`Player`、`Invader`和`Bullet`类来扩展它。
- en: The `draw` function, which is identical in all three classes, could remain in
    the parent class, and we won't have the problem of all that wasted duplicate code.
    Great!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有三个类中相同的`draw`函数可以保留在父类中，我们也不会有那么多浪费的重复代码问题。太好了！
- en: The problem with this approach is how varied – in some respects – the game objects
    are. Diversity is not a strength; it is just diverse. For example, all the object
    types move differently. The bullets go up or down, the invaders go left and right
    and drop down occasionally, and the player's ship responds to inputs.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的问题在于游戏对象在某种程度上是多么多样化。多样性不是一种优势；它只是多样化。例如，所有对象类型移动方式不同。子弹向上或向下移动，入侵者左右移动并偶尔下降，玩家的飞船对输入做出反应。
- en: 'How would we put this kind of diversity into the `update` so that it could
    control this movement? Maybe we could use something like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将这种多样性融入到`update`中，以便它能控制这种运动？也许我们可以使用类似的东西：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `update` function alone would be bigger than the whole `GameEngine` class!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 单独的`update`函数就会比整个`GameEngine`类还要大！
- en: As you may remember from [*Chapter 15*](B14278_15_Final_AG_ePub.xhtml#_idTextAnchor306),
    *Advanced OOP – Inheritance and Polymorphism*, when we inherit from a class, we
    can also override specific functions. This means we could have a different version
    of the `update` function for each object type. Unfortunately, however, there is
    also a problem with this approach as well.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从[*第15章*](B14278_15_Final_AG_ePub.xhtml#_idTextAnchor306)中可能记得，*高级面向对象编程——继承和多态*，当我们从一个类继承时，我们也可以覆盖特定的函数。这意味着我们可以为每种对象类型拥有不同的`update`函数版本。然而，不幸的是，这种方法也存在问题。
- en: The `GameEngine` engine would have to "know" which type of object it was updating
    or, at the very least, be able to query the `GameObject` instance it was updating
    in order to call the correct version of the `update` function. What is really
    needed is for the `GameObject` to somehow internally choose which version of the
    update `function` is required.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameEngine`引擎必须“知道”它正在更新哪种类型的对象，或者至少能够查询它正在更新的`GameObject`实例，以便调用正确的`update`函数版本。真正需要的是`GameObject`以某种方式内部选择所需的更新`函数`版本。'
- en: Unfortunately, even the part of the solution which did seem to work falls apart
    on closer inspection. I said that the code in the `draw` function was the same
    for all three of the objects, and therefore the `draw` function could be part
    of the parent class and used by all the sub-classes, instead of us having to code
    three separate `draw` functions. Well, what happens when we introduce a new object
    that needs to be drawn differently, such as an animated UFO that flies across
    the top of the screen? In this scenario, the draw solution falls apart too.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，即使是看起来似乎可行的解决方案，在仔细检查时也会分崩离析。我说过，`draw`函数中的代码对所有三个对象都是相同的，因此`draw`函数可以是父类的一部分，并由所有子类使用，而不是我们必须编写三个单独的`draw`函数。那么，当我们引入一个需要以不同方式绘制的新的对象时，比如一个飞越屏幕顶部的动画不明飞行物（UFO）时，会发生什么呢？在这种情况下，绘制解决方案也会崩溃。
- en: Now that we have seen the problems that occur when objects are different from
    each other and yet cry out to be from the same parent class, it is time to look
    at the solution we will use in the Space Invaders ++ project.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了当对象彼此不同但又渴望属于同一个父类时出现的问题，是时候看看我们在Space Invaders ++项目中将要使用的解决方案了。
- en: What we need is a new way of thinking about constructing all our game objects.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是一种新的思考方式来构建我们所有的游戏对象。
- en: Prefer composition over inheritance
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优先考虑组合而非继承
- en: Preferring composition over inheritance refers to the idea of composing objects
    with other objects.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 优先考虑组合而非继承指的是用其他对象组合对象的想法。
- en: Important note
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'This concept was first suggested in the following publication:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念最初是在以下出版物中提出的：
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*《设计模式：可复用面向对象软件元素》*'
- en: by Erich Gamma, Richard Helm, et al.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由Erich Gamma, Richard Helm等人所著。
- en: What if we could code a class (as opposed to a function) that handled how an
    object was drawn? Then for all the classes that draw themselves in the same way,
    we could instantiate one of these special drawing classes within the `GameObject`,
    and any objects that need to be drawn differently could have a different drawing
    object. Then, when a `GameObject` does something differently, we simply compose
    it with a different drawing or updating related class to suit it. All the similarities
    in all our objects can benefit from using the same code, while all the differences
    can benefit from not only being encapsulated but also abstracted (taken out of)
    the base class.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够编写一个处理对象绘制方式的类（而不是函数），那么对于所有以相同方式绘制的类，我们可以在`GameObject`内部实例化这些特殊的绘制类，而任何需要以不同方式绘制的对象都可以拥有不同的绘制对象。然后，当`GameObject`执行不同的操作时，我们只需将其与不同的绘制或更新相关类组合即可。我们所有对象的所有相似之处都可以通过使用相同的代码来受益，而所有差异则不仅可以被封装，还可以被抽象（从基类中提取）。
- en: Note that the heading of this section is composition over inheritance, not composition
    instead of inheritance. Composition doesn't replace inheritance and everything
    you learned in [*Chapter 15*](B14278_15_Final_AG_ePub.xhtml#_idTextAnchor306),
    *Advanced OOP – Inheritance and Polymorphism*, still holds true. However, where
    possible, compose instead of inheriting.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本节的标题是组合优于继承，而不是组合代替继承。组合并不取代继承，你在[*第15章*](B14278_15_Final_AG_ePub.xhtml#_idTextAnchor306)，“高级面向对象编程
    – 继承和多态”中学到的所有内容仍然适用。然而，在可能的情况下，应使用组合而不是继承。
- en: The `GameObject` class is the entity, while the classes it will be composed
    of that do things such as update its position and draw it to the screen are the
    components, which is why it's called the Entity-Component pattern.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameObject`类是实体，而它将组合的执行诸如更新位置和绘制到屏幕上的操作的类是组件，这就是为什么我们称之为实体-组件模式。'
- en: 'Have a look at the following diagram, which represents the Entity-Component
    pattern in the form we will implement it in this project:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下图表，它表示了我们将在本项目中所实现的实体-组件模式：
- en: '![](img/B14278_19_06.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_19_06.jpg)'
- en: In the preceding diagram, we can see that a `GameObject` instance is composed
    of multiple `Component` instances. There will be multiple different classes derived
    from the `Component` class, including `UpdateComponent` and `GraphicsComponent`.
    Furthermore, there can be further specific classes derived from them. For example,
    the `BulletUpdateComponent` and `InvaderUpdateComponent` classes will be derived
    from the `UpdateComponent` class. These classes will handle how a bullet and an
    invader (respectively) update themselves each frame of the game. This is great
    for encapsulation because we don't need the big `switch` blocks to distinguish
    between different objects.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，我们可以看到`GameObject`实例由多个`Component`实例组成。将会有多个从`Component`类派生的不同类，包括`UpdateComponent`和`GraphicsComponent`。此外，还可以从它们进一步派生出更具体的类。例如，`BulletUpdateComponent`和`InvaderUpdateComponent`类将从`UpdateComponent`类派生。这些类将处理子弹和入侵者（分别）在游戏每一帧如何更新自己。这对于封装来说非常好，因为我们不需要大型的`switch`块来区分不同的对象。
- en: When we use composition over inheritance to create a group of classes that represent
    behavior/algorithms, as we will here, this is known as the **Strategy** pattern.
    You could use everything you have learned here and refer to it as the Strategy
    pattern. Entity-Component is a lesser known but more specific implementation,
    and that is why we call it this. The difference is academic, but feel free to
    turn to Google if you want to explore things further. In [*Chapter 23*](B14278_23_Final_AG_ePub.xhtml#_idTextAnchor457),
    *Before You Go…,* I will show you some good resources for this kind of detailed
    research.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用组合优于继承来创建一组表示行为/算法的类，正如我们在这里所做的那样，这被称为**策略模式**。你可以使用在这里学到的所有内容，并将其称为策略模式。实体-组件是一种不太为人所知但更具体的实现，这就是我们这样称呼它的原因。这种区别是学术性的，但如果你想要进一步探索，请随时查阅谷歌。在[*第23章*](B14278_23_Final_AG_ePub.xhtml#_idTextAnchor457)，“在出发前…”，我会向你展示一些这类详细研究的优质资源。
- en: The Entity-Component pattern, along with using composition in preference to
    inheritance, sounds great at first glance but brings with it some problems of
    its own. It would mean that our new `GameObject` class would need to know about
    all the different types of component and every single type of object in the game.
    How would it add all the correct components to itself?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 实体-组件模式，以及相对于继承更倾向于使用组合，乍一看听起来很棒，但它也带来了一些自己的问题。这意味着我们的新 `GameObject` 类将需要了解所有不同类型的组件以及游戏中每一种单独的对象。它将如何为自己添加所有正确的组件？
- en: Let's have a look at the solution.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看解决方案。
- en: Factory pattern
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工厂模式
- en: It is true that if we are to have this universal `GameObject` class that can
    be anything we want it to be, whether that be a bullet, player, invader, or whatever
    else, then we are going to have to code some logic that "knows" about constructing
    these super-flexible `GameObject` instances and composes them with the correct
    components. But adding all this code into the class itself would make it exceptionally
    unwieldy and defeat the entire reason for using the Entity-Component pattern in
    the first place.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，如果我们想要这样一个通用的 `GameObject` 类，它可以成为我们想要的任何东西，无论是子弹、玩家、入侵者还是其他任何东西，那么我们就必须编写一些“知道”如何构建这些超级灵活的
    `GameObject` 实例，并用正确的组件来组合它们的逻辑。但将所有这些代码添加到类中会使它变得异常难以管理，并且违背了最初使用实体-组件模式的原因。
- en: 'We would need a constructor that did something like this hypothetical `GameObject`
    code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个构造器，它能够执行类似于这个假设的 `GameObject` 代码：
- en: '[PRE1]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `GameObject` class would need to know not just which components go with
    which `GameObject` instance, but also which didn't need certain components, such
    as input-related components for controlling the player. For the Space Invaders
    ++ project, we could do this and just about survive the complexity, but just about
    surviving is not the objective; we want to take complete control.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameObject` 类不仅需要知道哪些组件与哪个 `GameObject` 实例相关联，还需要知道哪些组件不需要，例如控制玩家的输入相关组件。对于
    Space Invaders ++ 项目，我们可以这样做并且勉强应对复杂性，但勉强应对并不是目标；我们想要完全控制。'
- en: The `GameObject` class would also need to understand all this logic. Any benefit
    or efficiency gained from using composition over inheritance with the Entity-Component
    pattern would be mainly lost.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameObject` 类还需要理解所有这些逻辑。使用实体-组件模式中组合而非继承所获得的任何好处或效率都将主要丧失。'
- en: Furthermore, what if we decide we want a new type of invader, perhaps a "Cloaker"
    alien that teleports near to the player, takes a shot, and then teleports away
    again? It is fine to code a new `GraphicsComponent` class, perhaps a `CloakingGraphicsComponent`
    that "knows" when it is visible and invisible, along with a new `UpdateComponent`,
    perhaps a `CloakerUpdateComponent` that teleports instead of moving in the conventional
    manner, but what is not fine is we are going to have to add a whole bunch of new
    `if` statements to the `GameObject` class constructor.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们决定我们想要一种新的入侵者类型，比如一个“隐形者”外星人，它靠近玩家，开一枪，然后再次隐形离开？编写一个新的 `GraphicsComponent`
    类，比如一个“隐形GraphicsComponent”类，它“知道”何时可见和不可见，以及一个新的 `UpdateComponent`，比如一个“隐形更新组件”，它通过传送而不是传统方式移动，是可以的，但不好的一点是我们将不得不在
    `GameObject` 类构造器中添加一大堆新的 `if` 语句。
- en: In fact, the situation is even worse than this. What if we decide that regular
    invaders can now cloak? Invaders now need not just a different type of `GraphicsComponent`
    class. We would have to go back into the `GameObject` class to edit all of those
    `if` statements again.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，情况比这还要糟糕。如果我们决定常规入侵者现在可以隐形呢？入侵者现在不仅需要一个不同类型的 `GraphicsComponent` 类。我们还得回到
    `GameObject` 类中去再次编辑所有那些 `if` 语句。
- en: In fact, there are even more scenarios that can be imagined, and they all end
    up with a bigger and bigger `GameObject` class. The `GameObject` class-related
    woes and the perfect partner to the Entity-Component pattern.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，还有更多可以想象的情况，它们最终都会导致 `GameObject` 类越来越大。与实体-组件模式完美匹配的 `GameObject` 类相关的问题。
- en: Important note
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This implementation of the Factory pattern is an easier way to begin to learn
    about the Factory pattern. Why not do a web search for the Factory pattern once
    you have completed this project and see how it can be improved?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这种工厂模式的实现是一个更容易开始学习工厂模式的方法。完成这个项目后，为什么不进行一次网络搜索，看看工厂模式如何得到改进？
- en: The game designer will provide a specification for each and every type of object
    in the game, and the programmer will provide a factory class that builds `GameObject`
    instances from the game designer's specifications. When the game designer comes
    up with new ideas for entities, then all we need to do is ask for a new specification.
    Sometimes, that will involve adding a new production line to the factory that
    uses existing components and, sometimes, it will mean coding new components or
    perhaps updating existing components. The point is that it won't matter how inventive
    the game designer is – the `GameObject` and `GameEngine` classes remain unchanged.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏设计师将为游戏中的每种类型的对象提供规范，程序员将提供一个工厂类，该类根据游戏设计师的规范构建`GameObject`实例。当游戏设计师提出关于实体的新想法时，我们只需要请求一个新的规范。有时，这可能意味着在工厂中添加一个新的生产线，该生产线使用现有的组件，有时则意味着编写新的组件或更新现有组件。关键是，无论游戏设计师多么有创意，`GameObject`和`GameEngine`类都不会改变。
- en: In the Factory code, the current object type is checked and the appropriate
    components (classes) are added to it. The bullet, player, and the invader have
    the same graphics component, but all have different update components.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在工厂代码中，当前的对象类型会被检查，并添加适当的组件（类）到其中。子弹、玩家和入侵者具有相同的图形组件，但所有这些都有不同的更新组件。
- en: When we use composition, it can be less clear which class is responsible for
    the memory. Is it the class that creates it, the class that uses it, or some other
    class? Let's learn some more C++ to help us manage memory a little more simply.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用组合时，可能不太清楚哪个类负责内存。是创建它的类，使用它的类，还是其他某个类？让我们学习更多的C++知识，以便更简单地管理内存。
- en: C++ smart pointers
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++智能指针
- en: '**Smart pointers** are classes that we can use to get the same functionality
    as a regular pointer but with an extra feature – the feature being that they take
    care of their own deletion. In the limited way we have used pointers so far, it
    has not been a problem for us to delete our own memory, but as your code becomes
    more complex, and when you are allocating the new memory in one class but using
    it in another class, it becomes much less clear which class is responsible for
    deleting the memory when we are done with it. And how can a class or function
    know whether a different class or function has finished with some allocated memory?'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**智能指针**是我们可以使用来获得与常规指针相同功能但具有额外功能的类——这个额外功能就是它们会负责自己的删除。在我们迄今为止有限地使用指针的方式中，我们删除自己的内存并没有问题，但随着你的代码变得更加复杂，当你在一个类中分配新内存但在另一个类中使用它时，就变得不太清楚哪个类负责在完成使用后删除内存。一个类或函数如何知道另一个类或函数是否已经完成了对一些已分配内存的使用？'
- en: The solution is smart pointers. There are a few types of smart pointer; we will
    look at the two of the most commonly used ones here. The key to success with smart
    pointers is using the correct type.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是智能指针。有几种类型的智能指针；在这里，我们将查看两种最常用的类型。使用智能指针成功的关键是使用正确的类型。
- en: The first type we will consider is **shared pointers**.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先考虑的是**共享指针**。
- en: Shared pointers
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享指针
- en: The way that a shared pointer can safely delete the memory it points to is by
    keeping a count of the number of different references there are to an area of
    memory. If you pass a pointer to a function, the count is increased by one. If
    you pack a pointer into a vector, the count is increased by one. If the function
    returns, the count is decreased by one. If the vector goes out of scope or has
    the `clear` function called on it, the smart pointer will reduce the reference
    count by one. When the reference count is zero, nothing points to the area of
    memory anymore and the smart pointer class calls `delete`. All the smart pointer
    classes are implemented using regular pointers behind the scenes. We just get
    the benefit of not having to concern ourselves about where or when to call `delete`.
    Let's look at the code for using a shared smart pointer.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 共享指针可以安全地删除它所指向的内存的方式是记录对内存区域的不同引用的数量。如果你将指针传递给一个函数，计数会增加一个。如果你将指针放入一个向量中，计数会增加一个。如果函数返回，计数会减少一个。如果向量超出作用域或对其调用`clear`函数，智能指针会将引用计数减少一个。当引用计数为零时，不再有任何东西指向该内存区域，智能指针类会调用`delete`。所有智能指针类都是在幕后使用常规指针实现的。我们只是得到了不必担心在哪里或何时调用`delete`的好处。让我们看看使用共享智能指针的代码。
- en: 'The following code creates a new shared smart pointer called `myPointer` that
    will point to an instance of `MyClass`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了一个名为`myPointer`的新共享智能指针，它将指向`MyClass`的一个实例：
- en: '[PRE2]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`shared_ptr<MyClass>` is the type while  `myPointer` is its name. The following
    code is how we might initialize `myPointer`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared_ptr<MyClass>`是类型，而`myPointer`是它的名称。以下代码是初始化`myPointer`的方式：'
- en: '[PRE3]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The call to `make_shared` internally calls `new` to allocate the memory. The
    parentheses `()` is the constructor parentheses. If the `MyClass` class constructor
    took an `int` parameter, for example, the preceding code might look like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_shared`的调用在内部调用`new`来分配内存。括号`()`是构造函数括号。例如，如果`MyClass`类的构造函数接受一个`int`参数，前面的代码可能看起来像这样：'
- en: '[PRE4]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `3` in the preceding code is an arbitrary example.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中前面的`3`是一个任意示例。
- en: 'Of course, you can declare and initialize your shared smart pointers in a single
    line of code if required, as shown in the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果需要，你可以在一行代码中声明和初始化你的共享智能指针，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is because `myPointer` is a `shared_ptr` that it has an internal reference
    count that keeps track of how many references point to the area of memory that
    it created. If we make a copy of the pointer, that reference count is increased.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正因为`myPointer`是一个`shared_ptr`，它有一个内部引用计数，用于跟踪指向它创建的内存区域的引用数量。如果我们复制指针，引用计数会增加。
- en: Making a copy of the pointer includes passing the pointer to another function,
    placing it in a `vector`, `map`, or other structure, or simply copying it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 复制指针包括将指针传递给另一个函数，将其放入`vector`、`map`或其他结构中，或者简单地复制它。
- en: 'We can use a smart pointer using the same syntax as a regular pointer. It is
    quite easy to forget sometimes that it isn''t a regular pointer. The following
    code calls the `myFunction` function on `myPointer`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用与常规指针相同的语法使用智能指针。有时很容易忘记它不是一个常规指针。以下代码在`myPointer`上调用`myFunction`函数：
- en: '[PRE6]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: By using a shared smart pointer, there is some performance and memory **overhead**.
    By overhead, I mean that our code runs slower and uses more memory. After all,
    the smart pointer needs a variable to keep track of the reference count, and it
    must check the value of the reference count every time a reference goes out of
    scope. However, this overhead is tiny and only an issue in the most extreme situations
    since  most of the overhead happens while the smart pointers are being created.
    Typically, we will create smart pointers outside of the game loop. Calling a function
    on a smart pointer is as efficient as a regular pointer.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用共享智能指针，会有一些性能和内存**开销**。这里的开销是指我们的代码运行得更慢，并且使用更多的内存。毕竟，智能指针需要一个变量来跟踪引用计数，并且每次引用超出作用域时都必须检查引用计数的值。然而，这种开销非常小，只有在最极端的情况下才是一个问题，因为大部分开销发生在智能指针创建的过程中。通常，我们会在游戏循环之外创建智能指针。在智能指针上调用函数与在常规指针上调用函数一样高效。
- en: Sometimes, we know that we will only ever want one reference to a smart pointer
    and in this situation, **unique** **pointers** are the best option.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们知道我们只想对智能指针有一个引用，在这种情况下，**唯一**指针是最好的选择。
- en: Unique pointers
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 唯一指针
- en: When we know that we only want a single reference to an area of memory, we can
    use a unique smart pointer. Unique pointers lose much of the overhead that I mentioned
    shared pointers have. In addition, if you try and make a copy of a unique pointer,
    the compiler will warn us, and the code will either not compile or it will crash,
    giving us a clear error. This is a very useful feature that can prevent us from
    accidentally copying a pointer that was not meant to be copied. You might be wondering
    if this no copying rule means we can never pass it to a function or even put it
    in a data structure such as a `vector`. To find out, let's look at some code for
    unique smart pointers and explore how they work.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们知道我们只想有一个对内存区域的引用时，我们可以使用唯一智能指针。唯一指针失去了我之前提到的共享指针的大部分开销。此外，如果你尝试复制一个唯一指针，编译器会警告我们，代码可能无法编译，或者会崩溃，给出一个清晰的错误。这是一个非常有用的功能，可以防止我们意外复制一个不应该复制的指针。你可能想知道，如果没有复制规则，我们是否永远不能将其传递给函数，甚至将其放入`vector`等数据结构中。为了找出答案，让我们看看唯一智能指针的代码，并探索它们是如何工作的。
- en: 'The following code creates a unique smart pointer called `myPointer` that points
    to an instance of `MyClass`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了一个名为`myPointer`的唯一智能指针，它指向`MyClass`的一个实例：
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now. let''s suppose we want to add a `unique_ptr` to a `vector`. The first
    thing to note is that `vector` must be of the correct type. The following code
    declares a `vector` that holds unique pointers to `MyClass` instances:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想向`vector`中添加一个`unique_ptr`。首先要注意的是，`vector`必须是正确的类型。以下代码声明了一个包含`MyClass`实例的唯一指针的`vector`：
- en: '[PRE8]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `vector` is called `myVector` and anything you put into it must be of the
    unique pointer type to `MyClass`. But didn''t I say that unique pointers can''t
    be copied? When we know that we will only ever want a single refence to an area
    of memory, we should use `unique_ptr`. This doesn''t mean, however, that the reference
    can''t be moved. Here is an example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector`被命名为`myVector`，你放入其中的任何东西都必须是`MyClass`的唯一指针类型。但我说过唯一指针不能复制吗？当我们知道我们只想有一个内存区域的引用时，我们应该使用`unique_ptr`。但这并不意味着引用不能移动。以下是一个例子：'
- en: '[PRE9]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding code, we can see that the `move` function can be used to put
    a unique smart pointer into a `vector`. Note that when you use the `move` function,
    you are not giving the compiler permission to break the rules and copy a unique
    pointer – you are moving responsibility from the `myPointer` variable to the `myVector`
    instance. If you attempt to use the `myPointer` variable after this point, the
    code will execute and the game will crash, giving you a **Null pointer access
    violation error**. The following code will cause a crash:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到`move`函数可以用来将唯一智能指针放入`vector`中。请注意，当你使用`move`函数时，你并不是在给编译器许可去打破规则并复制一个唯一指针——你是在将责任从`myPointer`变量移动到`myVector`实例。如果你在此之后尝试使用`myPointer`变量，代码将执行，游戏将崩溃，给你一个**空指针访问违规错误**。以下代码将导致崩溃：
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The exact same rules apply when passing a unique pointer to a function; use
    the `move` function to pass responsibility on. We will look at all these scenarios
    again, as well as some more when we get to the project in a few pages time.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当将唯一指针传递给函数时，也适用相同的规则；使用`move`函数传递责任。当我们到达几页后的项目时，我们将再次查看所有这些场景，以及一些其他的场景。
- en: Casting smart pointers
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型转换智能指针
- en: We will often want to pack the smart pointers of derived classes into data structures
    or function parameters of the base class such as all the different derived `Component`
    classes. This is the essence of polymorphism. Smart pointers can achieve this
    using casting. But what happens when we later need to access the functionality
    or data of the derived class?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常希望将派生类的智能指针打包到基类的数据结构或函数参数中，例如所有不同的派生`Component`类。这是多态的本质。智能指针可以通过类型转换来实现这一点。但是，当我们后来需要访问派生类的功能或数据时会发生什么呢？
- en: A good example of where this will regularly be necessary is when we deal with
    components inside our game objects. There will be an abstract `Component` class
    and derived from that there will be `GraphicsComponent`, `UpdateComponent`, and
    more besides.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是，当我们处理游戏对象内部的组件时，这将是经常必要的。将会有一个抽象的`Component`类，从该类派生出的将会有`GraphicsComponent`、`UpdateComponent`等。
- en: As an example, we will want to call the `update` function on all the `UpdateComponent`
    instances each frame of the game loop. But if all the components are stored as
    base class `Component` instances, then it might seem that we can't do this. Casting
    from the base class to a derived class solves this problem.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们希望在游戏循环的每一帧调用所有`UpdateComponent`实例的`update`函数。但如果所有组件都存储为基类`Component`实例，那么这似乎是不可能的。从基类到派生类的类型转换解决了这个问题。
- en: 'The following code casts `myComponent`, which is a base class `Component` instance
    to an `UpdateComponent` class instance, which we can then call the `update` function
    on:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将`myComponent`，一个基类`Component`实例转换为`UpdateComponent`类实例，然后我们可以调用`update`函数：
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Before the equals sign, a new `shared_ptr` to an `UpdateComponent` instance
    is declared. After the equals sign, the `static_pointer_cast` function specifies
    the type to cast to in the angle brackets, `<UpdateComponent>`, and the instance
    to cast from in parentheses, `(MyComponent)`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在等号之前，声明了一个指向`UpdateComponent`实例的新`shared_ptr`。在等号之后，`static_pointer_cast`函数指定了在尖括号中要转换到的类型`<UpdateComponent>`，以及要转换的实例在括号中`(MyComponent)`。
- en: 'We can now use all the functions of the `UpdateComponent` class, which in our
    project includes the `update` function. We would call the `update` function as
    follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`UpdateComponent`类的所有功能，在我们的项目中包括`update`函数。我们可以这样调用`update`函数：
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There are two ways we can cast a class smart pointer to another class smart
    pointer. One is by using `static_pointer_cast`, as we have just seen, and the
    other is to use `dynamic_pointer_cast`. The difference is that `dynamic_pointer_cast`
    can be used if you are uncertain whether the cast will work. When you use `dynamic_pointer_cast`,
    you can then check to see if it worked by testing if the result is a null pointer.
    You use `static_pointer_class` when you are certain the result is the type you
    are casting to. We will use `static_pointer_cast` throughout the Space Invaders
    ++ project.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将一个类的智能指针转换为另一个类的智能指针的两种方式。一种是通过使用 `static_pointer_cast`，正如我们刚才看到的，另一种是使用
    `dynamic_pointer_cast`。区别在于，如果你不确定转换是否可行，可以使用 `dynamic_pointer_cast`。当你使用 `dynamic_pointer_cast`
    时，你可以通过检查结果是否为空指针来查看它是否成功。当你确定结果是你想要转换的类型时，使用 `static_pointer_class`。在整个《太空侵略者
    ++》项目中，我们将使用 `static_pointer_cast`。
- en: We will regularly be casting `Component` instances to different derived types.
    How we will be sure the type we are casting to is the correct type will become
    apparent as we progress with the project.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将经常将 `Component` 实例强制转换为不同的派生类型。当我们随着项目的进展进行转换时，我们将如何确保转换到的类型是正确的类型将变得明显。
- en: C++ assertions
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ 断言
- en: In this project, we will be using C++ **assertions**. As usual, there is more
    to this topic than we will discuss here, but we can still do some useful things
    with just an introduction.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将使用 C++ **断言**。像往常一样，这个话题比我们在这里讨论的要多，但我们仍然可以通过简单的介绍做一些有用的事情。
- en: 'We can use the `#define` preprocessor statement in a class to define a value
    for the entire project. We do so with the following code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在类中使用 `#define` 预处理器语句来为整个项目定义一个值。我们使用以下代码这样做：
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This code would be written at the top of a header file. Now, throughout the
    project, we can write code like the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将写在头文件的最顶部。现在，在整个项目中，我们可以编写如下代码：
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `#ifdef debuggingOnConsole` statement checks whether the `#define` `debuggingOnConsole`
    statement is present. If it is, then any C++ code up to the `#endif` statement
    will be included in the game. We can then choose to comment out the `#define`
    statement to switch our debugging code on or off.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`#ifdef debuggingOnConsole` 语句检查是否存在 `#define` `debuggingOnConsole` 语句。如果存在，则从
    `#ifdef` 语句到 `#endif` 语句之间的任何 C++ 代码都将包含在游戏中。然后我们可以选择取消注释 `#define` 语句来打开或关闭调试代码。'
- en: 'Typically, we will include code such as the following in the `#ifdef` blocks:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们将在 `#ifdef` 块中包含如下代码：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code uses the `cout` statement to print debugging information
    to the console window.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用 `cout` 语句将调试信息打印到控制台窗口。
- en: What these assertions amount to is a way to get feedback from the game during
    development and then with a quick `//` in front of the `#define` statement, strip
    out all the debugging code from the game when we are done.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些断言实际上是一种从开发期间的游戏中获得反馈的方法，然后通过在 `#define` 语句前加上一个快速 `//`，在我们完成时从游戏中移除所有调试代码。
- en: Creating the Space Invaders ++ project
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建《太空侵略者 ++》项目
- en: You can find the runnable code that represents the project at the end of this
    chapter in the `Space Invaders ++` folder. It will take all of chapters 20, 21,
    and 22 to complete and make the project runnable again. The completed code that
    is runnable and represents the project at the end of [*Chapter 22*](B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445),
    *Using Game Objects and Building a Game*, can be found in the `Space Invaders
    ++ 2` folder.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本章末尾的 `Space Invaders ++` 文件夹中找到表示项目的可运行代码。它需要完成第 20、21 和 22 章的内容，才能使项目再次可运行。在
    `Space Invaders ++ 2` 文件夹中可以找到表示项目末尾的、可运行的、完成代码，即 *第 22 章*（[B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445]）*使用游戏对象和构建游戏*。
- en: Create a new project in Visual Studio with the same settings that we used in
    the previous four projects. Call the new project `Space Invaders ++`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中创建一个新的项目，使用与之前四个项目相同的设置。将新项目命名为 `Space Invaders ++`。
- en: Inside the `Space Invaders ++` folder, copy and paste the `fonts`, `graphics`,
    and `sound` folders and their contents from the download bundle. The `fonts`,
    `graphics`, and `sound` folders, as you would expect, contain the font and graphical
    and audio assets we will use in this game.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Space Invaders ++` 文件夹内，从下载包中复制并粘贴 `fonts`、`graphics` 和 `sound` 文件夹及其内容。正如你所期望的，这些文件夹包含我们将用于本游戏的字体、图形和音频资源。
- en: In addition, you will need to download the background file from [https://opengameart.org/content/background-night](https://opengameart.org/content/background-night).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还需要从[https://opengameart.org/content/background-night](https://opengameart.org/content/background-night)下载背景文件。
- en: Important note
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This image is the work of [https://opengameart.org/users/alekei](https://opengameart.org/users/alekei).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这幅图是[https://opengameart.org/users/alekei](https://opengameart.org/users/alekei)的作品。
- en: You can download this from [https://opengameart.org/content/background-night](https://opengameart.org/content/background-night).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://opengameart.org/content/background-night](https://opengameart.org/content/background-night)下载此文件。
- en: You can find the license at [https://creativecommons.org/licenses/by/3.0/](https://creativecommons.org/licenses/by/3.0/).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://creativecommons.org/licenses/by/3.0/](https://creativecommons.org/licenses/by/3.0/)找到许可证。
- en: Rename the file you just downloaded to `background.png` and place it in the
    `graphics` folder of your project.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 将你刚刚下载的文件重命名为`background.png`，并将其放置在项目中的`graphics`文件夹中。
- en: Now, add the `world` folder, including the `level1.txt` file. This file contains
    the layout of all the game objects, and we will discuss it further in [*Chapter
    21*](B14278_21_Final_AG_ePub.xhtml#_idTextAnchor432), *File I/O and the Game Object
    Factory*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加`world`文件夹，包括`level1.txt`文件。此文件包含所有游戏对象的布局，我们将在[*第21章*](B14278_21_Final_AG_ePub.xhtml#_idTextAnchor432)中进一步讨论，*文件I/O和游戏对象工厂*。
- en: Organizing code files with filters
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用过滤器组织代码文件
- en: Next, we will do something new. As there are more class files in this project
    than our previous projects, we will be a bit more organized within Visual Studio.
    We will create a series of **filters**. These are logical organizers we use to
    create a structure for our files. This will allow us to view all our header and
    source files in a more organized way.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将做一些新的事情。由于这个项目中的类文件比我们以前的项目多，我们将在Visual Studio中更加有组织。我们将创建一系列**过滤器**。这些是我们用来创建文件结构的逻辑组织者。这将使我们能够以更有组织的方式查看所有头文件和源文件。
- en: Right-click on the `Engine`. We will add all the core header files to this filter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击`Engine`。我们将把所有核心头文件添加到这个过滤器中。
- en: Right-click on `FileIO`. We will add all the files that read text to and from
    `level1.txt`, as well as some supporting classes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击`FileIO`。我们将添加所有读取`level1.txt`的文件，以及一些支持类。
- en: Make another new filter in `GameObjects`. Everything related to all the game
    objects, including the `GameObject` class and all the `Component` class-related
    header files, will go here.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GameObjects`中创建另一个新的过滤器。所有与所有游戏对象相关的文件，包括`GameObject`类和所有与`Component`类相关的头文件，都将放在这里。
- en: Add yet another filter called `Screens`. Right-click on the `Select`. Now, create
    another filter within `Game`. We will place all the derived versions of `Screen`,
    `InputHandler`, and `UIPanel` in **Game** or **Select** (as appropriate) and all
    the base classes in **Screens**.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 添加另一个名为`Screens`的过滤器。右键单击`Select`。现在，在`Game`中创建另一个过滤器。我们将所有`Screen`、`InputHandler`和`UIPanel`的派生版本放置在**Game**或**Select**（根据需要）中，并将所有基类放置在**Screens**中。
- en: 'Now, repeat all the previous steps of creating filters to create the exact
    same structure in the **Source Files** folder. You should now have a Solution
    Explorer layout that looks as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重复创建过滤器的前几步，以在**源文件**文件夹中创建完全相同的结构。你现在应该有一个如下所示的解决方案资源管理器布局：
- en: '![](img/B14278_19_07.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_19_07.jpg)'
- en: Note that the preceding layout is just for our organizational benefit; it has
    no effect on the code or the finished game. In fact, if you look in the `Space
    Invaders ++` folder using your operating system's file browser, you will see there
    are no additional folders. As we progress with this project and add new classes,
    we will add them within specific filters to make them more organized and less
    cluttered.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的布局只是为了我们的组织利益；它对代码或最终游戏没有影响。实际上，如果你使用操作系统的文件浏览器查看`Space Invaders ++`文件夹，你会看到没有额外的文件夹。随着我们在这个项目中前进并添加新的类，我们将它们添加到特定的过滤器中，以使它们更有组织和更整洁。
- en: Adding a DevelopState file
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加一个DevelopState文件
- en: In order to output debugging data to the console, we will create the `DevelopState`
    class, which does nothing but define `debuggingOnConsole`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将调试数据输出到控制台，我们将创建`DevelopState`类，它除了定义`debuggingOnConsole`之外不做任何事情。
- en: 'Create the `DevelopState.h` file in the `Header Files/Engine` filter and add
    the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Header Files/Engine`过滤器中创建`DevelopState.h`文件，并添加以下代码：
- en: '[PRE16]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can comment out `#define debuggingOnConsole` when the game is working but,
    when we have unexplained crashes, we can uncomment it. If we then add assertions
    at parts throughout our code, we can see if these parts are causing the game to
    crash.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏运行正常时，我们可以取消注释 `#define debuggingOnConsole`，当我们遇到无法解释的崩溃时，我们可以重新注释它。如果我们然后在代码的各个部分添加断言，我们就可以看到这些部分是否导致游戏崩溃。
- en: Coding SpaceInvaders ++.cpp
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 SpaceInvaders ++.cpp
- en: Next, drag and drop the `SpaceInvaders ++.cpp` file that was autogenerated when
    we created the project into the `Source Files/Engine` filter. This isn't required
    – it is just to keep things organized. This file is the entry point to the game
    and is therefore a core file, albeit a very short one.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将我们在创建项目时自动生成的 `SpaceInvaders ++.cpp` 文件拖放到 `Source Files/Engine` 过滤器中。这不是必需的——只是为了保持整洁。此文件是游戏的入口点，因此是一个核心文件，尽管它非常短。
- en: 'Edit `SpaceInvaders ++.cpp` so that it just has the following code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `SpaceInvaders ++.cpp`，使其只包含以下代码：
- en: '[PRE17]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding code creates an instance of `GameEngine` and calls its `run` function.
    There will be errors until we code the `GameEngine` class. We will do that next.
    Note that, throughout this project, there will usually be one, more, or even many
    errors. This is due to the interdependent nature of the classes. I will usually
    mention when there are errors and when they will be dealt with, but perhaps not
    every single one. By the end of this chapter, we will have an error-free, executable
    project, but, after that, it will take until [*Chapter 22*](B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445),
    *Using Game Objects and Building a Game*, until the project is error-free and
    executable again.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码创建了一个 `GameEngine` 实例并调用其 `run` 函数。直到我们编写 `GameEngine` 类之前，都会出现错误。我们将在下一部分完成这项工作。注意，在整个项目中，通常会有一个、更多甚至许多错误。这是由于类之间的相互依赖性。我通常会提到错误以及何时处理它们，但可能不会提到每一个。在本章结束时，我们将有一个没有错误、可执行的项目，但之后，它将需要直到
    [*第22章*](B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445)，*使用游戏对象和构建游戏*，直到项目再次没有错误且可执行。
- en: Coding the GameEngine class
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 GameEngine 类
- en: 'Create a new header file in the `Header Files/Engine` filter called `GameEngine.h`
    and add the following code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Header Files/Engine` 过滤器中创建一个新的头文件，命名为 `GameEngine.h`，并添加以下代码：
- en: '[PRE18]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Study the preceding code to get familiar with it. What's new is that we get
    to see smart pointers in action for the first time. We have a unique pointer of
    the `ScreenManager` Type. This implies that this pointer will not be passed to
    any other classes but, if it is, then ownership will also be passed.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 研究前面的代码以熟悉它。新的是我们第一次看到智能指针的实际应用。我们有一个 `ScreenManager` 类型的唯一指针。这意味着这个指针不会被传递给其他任何类，但如果它被传递，则所有权也会传递。
- en: Other than the smart pointers, there is nothing we haven't seen before. There
    is a `Clock` instance, a `Time` instance, a `RenderWindow` instance, as well as
    variables to keep track of the frame rate and the screen resolution. Furthermore,
    we have functions for handling input, updating, and drawing each frame. This is
    also nothing new. What we do within these functions, however, will be new. We
    also have a `SoundEngine` instance, which will be nearly identical to how we handled
    sound in our other projects. We also have the `run` function, which is public,
    and will kickstart all the private functions.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 除了智能指针之外，我们之前都没有见过。有一个 `Clock` 实例，一个 `Time` 实例，一个 `RenderWindow` 实例，以及用于跟踪帧率和屏幕分辨率的变量。此外，我们还有处理输入、更新和绘制每一帧的函数。这也不是什么新东西。然而，我们在这些函数中所做的工作将是新的。我们还有一个
    `SoundEngine` 实例，它将几乎与我们处理其他项目中的声音的方式相同。我们还有一个公开的 `run` 函数，它将启动所有私有函数。
- en: There are errors because we need to implement the `ScreenManager` and `SoundEngine`
    classes. We will get to them very soon.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 出现错误是因为我们需要实现 `ScreenManager` 和 `SoundEngine` 类。我们很快就会实现它们。
- en: 'Create a new source file in the `Source Files/Engine` filter called `GameEngine.cpp`
    and add the following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Source Files/Engine` 过滤器中创建一个新的源文件，命名为 `GameEngine.cpp`，并添加以下代码：
- en: '[PRE19]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the `GameEngine` constructor, the `RenderWindow` instance is initialized
    and the unique smart pointer to a `ScreenManager` instance is initialized using
    `new`, which passes in the resolution to the `ScreenManager` constructor.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GameEngine` 构造函数中，使用 `new` 初始化 `RenderWindow` 实例，并使用 `new` 初始化指向 `ScreenManager`
    实例的唯一智能指针，将分辨率传递给 `ScreenManager` 构造函数。
- en: Important note
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This is an alternative to calling the `make_unique` function.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种调用 `make_unique` 函数的替代方法。
- en: The `run` function should look very familiar; it restarts the clock and stores
    the time like we have done in every project so far. It then calls the `handleInput`,
    `update`, and `draw` functions.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`run` 函数看起来应该非常熟悉；它重新启动时钟并存储时间，就像我们迄今为止在每一个项目中做的那样。然后调用 `handleInput`、`update`
    和 `draw` 函数。'
- en: In the `handleInput` function, the `handleInput` function of the `ScreenManager`
    instance is called. In the `update` function, the `update` function of the `ScreenManger`
    instance is called. Finally, in the `draw` function, the `RenderWindow` is cleared,
    the `draw` function of the `ScreenManager` instance is called, and the contents
    of the `RenderWindow` instance are displayed.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `handleInput` 函数中，调用的是 `ScreenManager` 实例的 `handleInput` 函数。在 `update` 函数中，调用的是
    `ScreenManger` 实例的 `update` 函数。最后，在 `draw` 函数中，清除 `RenderWindow`，调用 `ScreenManager`
    实例的 `draw` 函数，并显示 `RenderWindow` 实例的内容。
- en: We have successfully passed full responsibility to the `ScreenManager` class
    for handling input, updating, and drawing each frame. As we will see in the *Coding
    the ScreenManager* section, the `ScreenManager` class will further delegate responsibility
    for all these tasks to the appropriate class that's derived from the `Screen`
    class.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地将处理输入、更新和绘制每一帧的完全责任交给了 `ScreenManager` 类。正如我们将在 *编码 ScreenManager* 部分看到的那样，`ScreenManager`
    类将进一步将这些任务的责任委托给从 `Screen` 类派生出的适当类。
- en: Like the related `GameEngine.h` header file, there are errors because we need
    to implement the `ScreenManager` and `SoundEngine` classes.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 与相关的 `GameEngine.h` 头文件一样，存在错误，因为我们需要实现 `ScreenManager` 和 `SoundEngine` 类。
- en: Coding the SoundEngine class
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码 SoundEngine 类
- en: 'Create a new header file in the `Header Files/Engine` filter called `SoundEngine.h`
    and add the following code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Header Files/Engine` 过滤器中创建一个新的头文件，命名为 `SoundEngine.h`，并添加以下代码：
- en: '[PRE20]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a new source file in the `Source Files/Engine` filter called `SoundEngine.cpp`
    and add the following code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Source Files/Engine` 过滤器中创建一个新的源文件，命名为 `SoundEngine.cpp`，并添加以下代码：
- en: '[PRE21]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `SoundEngine` class uses the exact same strategy as the previous `SoundManager`
    class from the previous projects. In fact, `SoundEngine` is slightly simpler than
    `SoundManager` because we are not using spatialization features. For a refresher
    of how the `SoundEngine` class works, refer to [*Chapter 17*](B14278_17_Final_AG_ePub.xhtml#_idTextAnchor340),
    *Sound Spatialization and the HUD*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoundEngine` 类使用与之前项目中 `SoundManager` 类完全相同的策略。事实上，`SoundEngine` 比较简单，因为我们没有使用空间化功能。要了解
    `SoundEngine` 类的工作原理，请参阅 [*第17章*](B14278_17_Final_AG_ePub.xhtml#_idTextAnchor340)，*声音空间化和HUD*。'
- en: Now, we can move on to the `ScreenManager` class.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续编写 `ScreenManager` 类。
- en: Coding the ScreenManager class
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码 ScreenManager 类
- en: 'Create a new header file in the `Header Files/Engine` filter called `ScreenManager.h`
    and add the following code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Header Files/Engine` 过滤器中创建一个新的头文件，命名为 `ScreenManager.h`，并添加以下代码：
- en: '[PRE22]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the previous code, there are some `#include` statements and some functions
    that have been commented out. This is because we will not be coding the `LevelManager`
    class until [*Chapter 21*](B14278_21_Final_AG_ePub.xhtml#_idTextAnchor432), *File
    I/O and the Game Object Factory*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，有一些 `#include` 语句和一些被注释掉的函数。这是因为我们将在 [*第21章*](B14278_21_Final_AG_ePub.xhtml#_idTextAnchor432)，*文件I/O和游戏对象工厂*
    中编写 `LevelManager` 类。
- en: The next thing to notice is that `ScreenManager` inherits from `ScreenManagerRemoteControl`.
    More on this class shortly.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个需要注意的事情是，`ScreenManager` 继承自 `ScreenManagerRemoteControl`。关于这个类，我们稍后会详细介绍。
- en: We have coded a `map` with a key-value pair of `string` and a unique pointer
    to `Screen`. This will allow us to grab the functionality of a specific `Screen`
    instance by using the corresponding `string`. Next, we declare the `string` called
    `m_CurrentScreen` and initialize it to `Select`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了一个 `map`，其键值对为 `string` 和指向 `Screen` 的唯一指针。这将允许我们通过使用相应的 `string` 来获取特定
    `Screen` 实例的功能。接下来，我们声明一个名为 `m_CurrentScreen` 的 `string` 并将其初始化为 `Select`。
- en: Next, we declare an instance of `BitmapStore` called `m_BS`. This will be a
    slightly reworked version of the `TextureHolder` class that we saw in the two
    preceding projects. We will code the `BitmapStore` class next.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明一个名为 `m_BS` 的 `BitmapStore` 实例。这将是我们之前在两个项目中看到的 `TextureHolder` 类的略微修改版本。我们将在下一个项目中编写
    `BitmapStore` 类。
- en: Notice that the constructor for `ScreenManager` takes a `Vector2i` instance,
    which is what we should expect from when we initialized a `ScreenManager` instance
    in the `GameEngine` class.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `ScreenManager` 的构造函数接受一个 `Vector2i` 实例，这是我们初始化 `GameEngine` 类中的 `ScreenManager`
    实例时所期望的。
- en: What follows is the `update`, `draw`, and `handleInput` function prototypes,
    which are called from the `GameEngine` class.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`update`、`draw`和`handleInput`函数原型，这些函数由`GameEngine`类调用。
- en: The next two functions are the most interesting. Note that they are from the
    `ScreenManagerRemoteControl` class, which `ScreenManager` inherits from. These
    are pure virtual functions in `ScreenManagerRemoteControl` and we do things this
    way so that we can share some of the functionality of the `ScreenManager` class
    with other classes. We will code the `ScreenManagerRemoteControl` class in a couple
    of sections time. Remember that, when you inherit from a class that has pure virtual
    functions, you must implement the functions if you want to create an instance.
    Furthermore, the implementations should be contained in the same file as where
    the class is declared. There are four functions, two of which have been commented
    out for now. The two functions of immediate interest are `SwitchScreens` and `loadLevelInPlayMode`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个函数是最有趣的。注意，它们来自`ScreenManagerRemoteControl`类，`ScreenManager`类继承自该类。这些是`ScreenManagerRemoteControl`中的纯虚函数，我们这样做是为了能够与其他类共享`ScreenManager`类的一些功能。我们将在几个部分中编写`ScreenManagerRemoteControl`类。记住，当你从具有纯虚函数的类继承时，如果你想创建一个实例，你必须实现这些函数。此外，实现应该包含在类声明的同一文件中。有四个函数，其中两个目前已被注释掉。两个感兴趣的函数是`SwitchScreens`和`loadLevelInPlayMode`。
- en: The `SwitchScreen` function changes the value of `m_CurrentScreen`, while the
    `loadLevelInPlayMode` function has some temporarily commented out code and a single
    line of active code which calls `SwitchScreens` with the value of `Game`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`SwitchScreen`函数更改`m_CurrentScreen`的值，而`loadLevelInPlayMode`函数有一些暂时注释掉的代码和一行活动代码，该代码调用`SwitchScreens`并传递`Game`的值。'
- en: Let's move on to the `ScreenManager.cpp` file so that we can look at all the
    function definitions.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续查看`ScreenManager.cpp`文件，以便我们可以查看所有函数定义。
- en: 'Create a new source file in the `Source Files/Engine` filter called `ScreenManager.cpp`
    and add the following code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Source Files/Engine`筛选器中创建一个名为`ScreenManager.cpp`的新源文件，并添加以下代码：
- en: '[PRE23]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code, the constructor adds two `Screen` instances to the `map`
    instance – first, a `GameScreen` instance with a key of `"Game"` and then a `SelectScreen`
    instance with a key of `"Select"`. The three functions, `handleInput`, `update`,
    and `draw`, use whatever the current screen is, use the corresponding `Screen`
    instance, and call its `handleInput`, `update`, and `draw` functions.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，构造函数向`map`实例添加了两个`Screen`实例 - 首先，一个键为`"Game"`的`GameScreen`实例，然后是一个键为`"Select"`的`SelectScreen`实例。三个函数`handleInput`、`update`和`draw`使用当前屏幕，使用相应的`Screen`实例，并调用其`handleInput`、`update`和`draw`函数。
- en: When the game is executed for the first time, the versions of these functions
    from `SelectScreen` will be called, but if the `ChangeScreen` or `loadLevelInPlayMode`
    function was called, then then `handleInput`, `update`, and `draw` could be called
    on the `GameScreen` instance from the `map`. You can add as many different types
    of `Screen` instance to the map as you like. I recommend that you complete the
    Space Invaders ++ project before you start doing your own customizations or start
    your own game, however.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏第一次执行时，将调用`SelectScreen`中的这些函数版本，但如果调用了`ChangeScreen`或`loadLevelInPlayMode`函数，则可以在`map`上调用`GameScreen`实例的`handleInput`、`update`和`draw`。你可以将尽可能多的不同类型的`Screen`实例添加到`map`中。然而，我建议你在开始进行自定义或开始自己的游戏之前，先完成Space
    Invaders ++项目。
- en: Coding the BitmapStore class
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写`BitmapStore`类
- en: 'Create a new header file in the `Header Files/Engine` filter called `BitmapStore.h`
    and add the following code:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Header Files/Engine`筛选器中创建一个名为`BitmapStore.h`的新头文件，并添加以下代码：
- en: '[PRE24]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create a new source file in the `Source Files/Engine` filter called `BitmapStore.cpp`
    and add the following code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Source Files/Engine`筛选器中创建一个名为`BitmapStore.cpp`的新源文件，并添加以下代码：
- en: '[PRE25]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding code is almost a copy and paste from the `BitmapStore` class from
    the previous two projects, except for the final `else` block. Inside the final
    `else` block, we use C++ assertions for the first time to output the name of the
    requested texture to the console in the event that the texture isn't found. This
    only happens when `debuggingOnConsole` is defined. Note that this would also crash
    the game.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码几乎是从前两个项目中的`BitmapStore`类复制粘贴过来的，除了最后的`else`块。在最后的`else`块中，我们第一次使用C++断言将请求的纹理名称输出到控制台，如果找不到纹理。这仅在`debuggingOnConsole`被定义时发生。请注意，这也可能导致游戏崩溃。
- en: Coding the ScreenManagerRemoteControl class
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 ScreenManagerRemoteControl 类的代码
- en: 'Create a new header file in the `Header Files/Screens` filter called `ScreenManagerRemoteControl.h`
    and add the following code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Header Files/Screens` 过滤器中创建一个新的头文件，命名为 `ScreenManagerRemoteControl.h`，并添加以下代码：
- en: '[PRE26]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note in the previous code, that there are some `#include` statements and some
    functions that have been commented out. This is because we will not be coding
    the `GameObject` and `GameObjectSharer` classes until the next chapter.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在之前的代码中，有一些 `#include` 语句和一些被注释掉的函数。这是因为我们直到下一章才不会编写 `GameObject` 和 `GameObjectSharer`
    类。
- en: The rest of the code is for the prototypes that match the definitions we saw
    previously in the `ScreenManager.h` file. As you have come to expect, all the
    functions are pure virtual and therefore must be implemented by any class we wish
    to have an instance of.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的代码是为与我们在 `ScreenManager.h` 文件中之前看到的定义相匹配的原型设计的。正如你所期待的，所有函数都是纯虚函数，因此我们必须为任何我们希望有实例的类实现这些函数。
- en: 'Create a new source file in the `Source Files/Screens` filter called `ScreenManagerRemoteControl.cpp`
    and add the following code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Source Files/Screens` 过滤器中创建一个新的源文件，命名为 `ScreenManagerRemoteControl.cpp`，并添加以下代码：
- en: '[PRE27]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This code file is empty because all the code is in the `.h` file. In fact, you
    don't need to create this file, but I always find it a handy reminder in case
    I forget that all the functions for the class are pure virtual and waste time
    looking for the `.cpp` file, which doesn't exist.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码文件是空的，因为所有代码都在 `.h` 文件中。实际上，你不需要创建这个文件，但我总是觉得这是一个方便的提醒，以防我忘记所有类的函数都是纯虚函数，从而浪费时间寻找不存在的
    `.cpp` 文件。
- en: Where are we now?
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们现在在哪里？
- en: At this stage, the only remaining errors in the code are the errors that refer
    to the `SelectScreen` class and the `GameScreen` class. It is going to take quite
    a bit of work to get rid of these errors and have a runnable program. The reason
    for this is that `SelectScreen` and `GameScreen` are derived from `Screen` and,
    in turn, the `Screen` class is also dependent on `InputHandler`, `UIPanel`, and
    `Button`. We will get to them next.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，代码中唯一剩余的错误是关于 `SelectScreen` 类和 `GameScreen` 类的错误。要消除这些错误并得到一个可运行的程序，需要相当多的工作。原因在于
    `SelectScreen` 和 `GameScreen` 都是从 `Screen` 派生的，而 `Screen` 类本身也依赖于 `InputHandler`、`UIPanel`
    和 `Button`。我们将在下一部分处理它们。
- en: Coding the Screen class and its dependents
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 Screen 类及其依赖项的代码
- en: What we will do now is code all the screen-related classes. In addition, each
    of the screens from our game will have their own specific implementation of all
    these classes.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要做的就是编写所有与屏幕相关的类。此外，我们游戏中的每个屏幕都将有这些类的特定实现。
- en: Next, we will code all the base classes; `Screen`, `InputHandler`, `UIPanel`,
    and `Button`. Following that, we will do the full implementation of the `SelectScreen`
    derivations of these classes and a partial implementation of the `GameScreen`
    derivations. At this point, we will be able to run the game and see our screens,
    UI panels, and buttons in action, and also be able to switch between screens.
    In the next chapter, we will work on the game properly and implement `GameObject`
    and `LevelManager`. In [*Chapter 22*](B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445),
    *Using Game Objects and Building a Game,* we will see how we can use them all
    in the `GameScreen` class.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写所有基类；`Screen`、`InputHandler`、`UIPanel` 和 `Button`。随后，我们将实现这些类的 `SelectScreen`
    派生类的完整实现和 `GameScreen` 派生类的部分实现。到这时，我们就能运行游戏并看到我们的屏幕、UI 面板和按钮的实际效果，同时也能在屏幕之间切换。在下一章中，我们将正确处理游戏并实现
    `GameObject` 和 `LevelManager`。在 [*第 22 章*](B14278_22_Final_AG_ePub.xhtml#_idTextAnchor445)，*使用游戏对象和构建游戏*，我们将看到我们如何在
    `GameScreen` 类中使用它们。
- en: Coding the Button class
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 Button 类
- en: 'Create a new header file in the `Header Files/Screens` filter called `Button.h`
    and add the following code:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Header Files/Screens` 过滤器中创建一个新的头文件，命名为 `Button.h`，并添加以下代码：
- en: '[PRE28]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see from the preceding code, a button will be visually represented
    by an SFML `RectangleShape` instance and an SFML `Text` instance. Also note that
    there is a `FloatRect` instance named `m_Collider` that will be used to detect
    mouse clicks on the button. The constructor will receive arguments to configure
    the position, size, color, and text of the button. The button will draw itself
    once each frame of the game loop and has a `draw` function that receives a `RenderWindow`
    reference to enable this.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的代码中看到的，按钮将通过SFML的`RectangleShape`实例和`Text`实例来视觉表示。还要注意，有一个名为`m_Collider`的`FloatRect`实例，它将用于检测按钮上的鼠标点击。构造函数将接收参数来配置按钮的位置、大小、颜色和文本。按钮将在游戏循环的每一帧中绘制自己，并且有一个`draw`函数，它接收一个`RenderWindow`引用来实现这一点。
- en: 'Create a new source file in the `Source Files/Screens` filter called `Button.cpp`
    and add the following code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Source Files/Screens`过滤器中创建一个新的源文件，命名为`Button.cpp`，并添加以下代码：
- en: '[PRE29]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Most of the action takes place in the constructor, and there is nothing we haven't
    seen already on numerous occasions in all the other projects. The button is prepared
    to be drawn using all the values that are passed into the constructor.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分操作都在构造函数中完成，而且我们在所有其他项目中已经多次见过类似的操作。按钮被准备用来绘制，使用构造函数传入的所有值。
- en: The `draw` function uses the `RenderWindow` reference to draw the previously
    configured `Text` instance on top of the previously configured `RectangleShape`
    instance.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw`函数使用`RenderWindow`引用在之前配置的`RectangleShape`实例上绘制之前配置的`Text`实例。'
- en: Coding the UIPanel class
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写UIPanel类
- en: 'Create a new header file in the `Header Files/Screens` filter called `UIPanel.h`
    and add the following code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Header Files/Screens`过滤器中创建一个新的头文件，命名为`UIPanel.h`，并添加以下代码：
- en: '[PRE30]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `private` section of the `UIPanel` class consists of a `RectangleShape`
    that will visually represent the background of the panel, a Boolean to keep track
    of whether the panel is currently visible to the player, and a `vector` of smart
    pointers to hold all the `Button` instances for this panel. Note that the smart
    pointers are of the shared variety so that we can pass them around and let the
    `shared_pointer` class take care of counting the references and deleting the memory
    when necessary.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIPanel`类的`private`部分包括一个将视觉上表示面板背景的`RectangleShape`，一个布尔值来跟踪面板是否当前对玩家可见，以及一个智能指针`vector`来持有此面板的所有`Button`实例。请注意，这些智能指针是共享类型的，这样我们就可以传递它们，并让`shared_pointer`类负责计数引用并在必要时删除内存。'
- en: In the `protected` section, there are member variables for remembering the size
    and spacing of the buttons, as well as a `Text` and a `Font` instance for drawing
    text on the panel. All the panels in this project have just one `Text` instance,
    but specific derived classes are free to add extra members as they need. For example,
    a `HighScoreUIPanel` class might need a `vector` full of `Text` instances to draw
    a list of the highest scores.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在`protected`部分，有用于记住按钮大小和间距的成员变量，以及用于在面板上绘制文本的`Text`和`Font`实例。本项目中的所有面板都只有一个`Text`实例，但具体的派生类可以根据需要添加额外的成员。例如，`HighScoreUIPanel`类可能需要一个充满`Text`实例的`vector`来绘制最高分数列表。
- en: There is also an `addButton` function, and it is this function that will call
    the `Button` class constructor and add the instances to the `vector`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 此外还有一个`addButton`函数，这个函数将调用`Button`类构造函数并将实例添加到`vector`中。
- en: In the `public` section, we can see that every `UIPanel` instance will have
    its own `View` instance. This enables every panel and screen to configure its
    `View` however it likes. All the `View` instances will be drawn to and added to
    `RenderWindow` in layers.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在`public`部分，我们可以看到每个`UIPanel`实例都将有自己的`View`实例。这使得每个面板和屏幕都可以按自己的方式配置其`View`。所有的`View`实例都将被绘制并添加到`RenderWindow`中，形成层。
- en: The `UIPanel` constructor receives all the necessary sizes and colors to configure
    its `RectangleShape`. The `getButtons` function shares the `vector` of `Button`
    instances so that other classes can interact with the buttons. For example, the
    `InputHandler` class will need the buttons to detect mouse clicks on them. This
    is why we used shared smart pointers.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIPanel`构造函数接收所有必要的尺寸和颜色来配置其`RectangleShape`。`getButtons`函数共享`Button`实例的`vector`，以便其他类可以与按钮交互。例如，`InputHandler`类将需要按钮来检测鼠标点击。这就是为什么我们使用了共享智能指针。'
- en: The `draw` function, of course, is called once each frame of the game loop and
    is `virtual`, so it can be optionally overridden and customized by derived classes.
    The `show` and `hide` functions will toggle the value of `m_Hidden` to keep track
    of whether this panel is currently visible to the player.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`draw` 函数在游戏循环的每一帧都会被调用一次，并且是 `virtual` 的，因此它可以被派生类选择性地覆盖和定制。`show` 和 `hide`
    函数将切换 `m_Hidden` 的值，以跟踪这个面板当前是否对玩家可见。
- en: 'Create a new source file in the `Source Files/Screens` filter called `UIPanel.cpp`
    and add the following code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Source Files/Screens` 过滤器中创建一个新的源文件，命名为 `UIPanel.cpp`，并添加以下代码：
- en: '[PRE31]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the constructor, the `RectangleShape` instance is scaled, colored, and positioned.
    The `View` instance is scaled to the size of the panel as well. The `setViewport`
    function of the `View` class is used along with some extra calculations to make
    sure the `View` takes up the correct proportion of the screen relative to the
    resolution and will therefore look approximately the same on screens of varying
    resolutions.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，`RectangleShape` 实例被缩放、着色和定位。`View` 实例也被缩放到面板的大小。`View` 类的 `setViewport`
    函数与一些额外的计算一起使用，以确保 `View` 占据屏幕的正确比例，因此在不同分辨率的屏幕上看起来大致相同。
- en: The `getButtons` function simply returns the `vector` of buttons to the calling
    code. The `addButtons` function uses the `make_shared` function to allocate new
    `Button` instances on the heap and place them into the `vector`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`getButtons` 函数简单地返回按钮的 `vector` 给调用代码。`addButtons` 函数使用 `make_shared` 函数在堆上分配新的
    `Button` 实例，并将它们放入 `vector` 中。'
- en: The `draw` function uses the `setView` function to make the specific `View`
    instance of this panel the one that is drawn upon. Next, there's `RectangleShape`,
    which represents that this panel is drawn. Then, each of the buttons in the `vector`
    are looped through and drawn on top of the `RectangleShape`. All this drawing
    will only happen if `m_Hidden` is false.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw` 函数使用 `setView` 函数来使这个面板的特定 `View` 实例成为被绘制的对象。接下来是 `RectangleShape`，它表示这个面板被绘制。然后，`vector`
    中的每个按钮都会被循环遍历并绘制在 `RectangleShape` 上。所有这些绘制只有在 `m_Hidden` 为假时才会发生。'
- en: The `show` and `hide` functions allow users of the class to toggle `m_Hidden`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`show` 和 `hide` 函数允许类的用户切换 `m_Hidden`。'
- en: Coding the InputHandler class
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 InputHandler 类
- en: 'Create a new header file in the `Header Files/Screens` filter called `InputHandler.h`
    and add the following code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Header Files/Screens` 过滤器中创建一个新的头文件，命名为 `InputHandler.h`，并添加以下代码：
- en: '[PRE32]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There is an error in this file because the `Screen` class doesn't exist yet.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件中有一个错误，因为 `Screen` 类还不存在。
- en: First, study the `private` section of this header file. Each `InputHandler`
    instance will hold a pointer to the screen that holds it. This will be useful
    in a few situations we will come across as the project continues. There is also
    a `vector` of shared smart pointers to `Button` instances. These are the same
    `Button` instances that are in the `UIPanel` we just coded. Each derived `UIPanel`
    will have a matching derived `InputHandler` with which it shares a `vector` of
    buttons.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，研究这个头文件中的 `private` 部分。每个 `InputHandler` 实例都将持有指向包含它的屏幕的指针。在项目继续进行的过程中，我们将遇到一些情况，这将是有用的。还有一个指向
    `Button` 实例的 `vector` 的共享智能指针。这些是我们在刚刚编写的 `UIPanel` 中的相同的 `Button` 实例。每个派生的 `UIPanel`
    都将有一个匹配的派生 `InputHandler`，它与它共享一个按钮的 `vector`。
- en: The `InputHandler` class also holds a pointer to the `View` instance in the
    `UIPanel`. When we code the function definitions in `InputHandler.cpp`, we will
    see how we get this pointer and how it is useful.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputHandler` 类还持有 `UIPanel` 中的 `View` 实例的指针。当我们编写 `InputHandler.cpp` 中的函数定义时，我们将看到如何获取这个指针以及它如何有用。'
- en: There is also a pointer to `ScreenManagerRemoteControl`. Remember from the `ScreenManager`
    class that we have implemented some functions from `ScreenManagerRemoteControl`.
    This is what will give us access to functions such as `SwitchScreen`. This is
    very useful when you consider that `InputHandler` is the class where we will be
    detecting button clicks. Of course, we need to see how we can initialize this
    pointer to make it usable. We will see how in the `InputHandler.cpp` file soon.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个指向 `ScreenManagerRemoteControl` 的指针。记得从 `ScreenManager` 类中，我们已经实现了 `ScreenManagerRemoteControl`
    的一些函数。这将使我们能够访问 `SwitchScreen` 等函数。当考虑到 `InputHandler` 是我们将检测按钮点击的类时，这非常有用。当然，我们需要看看我们如何初始化这个指针，使其可使用。我们将在
    `InputHandler.cpp` 文件中很快看到。
- en: In the `public` section, there is an `initialiseInputHandler` function. This
    is where the `private` members we have just talked about will be prepared for
    use. Look at the parameters; they match the types of the private members exactly.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `public` 部分，有一个 `initialiseInputHandler` 函数。这就是我们刚才提到的私有成员将被准备用于使用的位置。看看参数；它们与私有成员的类型完全匹配。
- en: Next is the `handleInput` function. Remember that this is called once per frame
    by the `GameEngine` class; the `ScreenManager` calls it on the current screen
    and the `Screen` class (coded next), in turn, will call it on all `InputHandler`
    instances that it holds. It receives a `RenderWindow` and an `Event` instance.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `handleInput` 函数。请记住，这个函数由 `GameEngine` 类每帧调用一次；`ScreenManager` 在当前屏幕上调用它，而
    `Screen` 类（稍后编码），依次调用它所持有的所有 `InputHandler` 实例。它接收一个 `RenderWindow` 和一个 `Event`
    实例。
- en: 'Next, there are four `virtual` functions which each derived from the `InputHandler`
    class that it can optionally override if it needs to. They are as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，有四个 `virtual` 函数，每个派生自 `InputHandler` 类，如果需要，它可以选择重写。它们如下所示：
- en: '`handleGamepad`'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handleGamepad`'
- en: '`handleKeyPressed`'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handleKeyPressed`'
- en: '`handleKeyReleased`'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handleKeyReleased`'
- en: '`handleLeftClick`'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handleLeftClick`'
- en: As we will see shortly, in the `InputHandler.cpp` file, the `handleInput` function
    will loop through the data in `Event`, just as we have done so often before. But
    then, instead of handling all the events directly as we have done in the past,
    it will delegate a response to one of the four virtual functions. The derived
    classes will then receive only the events and data they have decided they want
    to handle. Default and empty definitions of the four virtual functions are provided
    in the `InputHandler.cpp` file.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们很快将看到的，在 `InputHandler.cpp` 文件中，`handleInput` 函数将循环遍历 `Event` 中的数据，就像我们之前经常做的那样。但是，然后，它不会像我们过去那样直接处理所有事件，而是将响应委托给四个虚拟函数之一。派生类将只接收它们决定要处理的事件和数据。在
    `InputHandler.cpp` 文件中提供了四个虚拟函数的默认和空定义。
- en: The `getPointerToUIView` function will return the pointer to the panels `View`
    that this `InputHandler` instance holds. We will see shortly that we need `View`
    in order to do mouse click collision detection on the buttons.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`getPointerToUIView` 函数将返回指向这个 `InputHandler` 实例持有的面板 `View` 的指针。我们很快就会看到，我们需要
    `View` 来在按钮上执行鼠标点击碰撞检测。'
- en: '`getPointerToScreenManagerRemoteControl` and `getmParentScreen` return pointers
    to the member variables that are suggested by the names of the functions.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`getPointerToScreenManagerRemoteControl` 和 `getmParentScreen` 返回指向由函数名称建议的成员变量的指针。'
- en: Important note
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that, if you make the private data protected, then the derived `InputHandler`
    classes can access the data without going through the functions we have just discussed.
    When the project is complete, feel free to revisit this section and change this
    if you wish.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你将私有数据设置为 `protected`，那么派生的 `InputHandler` 类可以不通过我们刚才讨论的函数访问数据。当项目完成后，你可以随意回顾这一部分，并根据需要更改它。
- en: Now, we can code all the function definitions.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写所有函数的定义。
- en: 'Create a new source file in the `Source Files/Screens` filter called `InputHandler.cpp`
    and add the following code:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Source Files/Screens` 过滤器中创建一个新的源文件，命名为 `InputHandler.cpp`，并添加以下代码：
- en: '[PRE33]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `initialiseInputHandler` function initializes the private data, as we have
    already discussed, the four `virtual` functions are empty, as expected, and the
    getter functions return pointers to the private members, just like we said they
    would.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`initialiseInputHandler` 函数初始化私有数据，正如我们之前讨论的那样，四个 `virtual` 函数是空的，正如预期的那样，并且获取函数返回指向私有成员的指针，就像我们说的那样。'
- en: The interesting function definition is the `handleInput` function, so let's
    go through it.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是 `handleInput` 函数的定义，让我们来详细看看它。
- en: There is a series of `if` statements, which should look familiar from previous
    projects. Each `if` statement tests for a different type of event, such as a key
    being pressed or a key being released. Instead of handling the event, however,
    the appropriate `virtual` function is called. If the derived `InputHandler` class
    overrides the `virtual` function, it will receive the data and get to handle the
    event. If it doesn't, then the empty default function definition is called, and
    nothing happens.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一系列 `if` 语句，这些语句应该与之前的项目的代码看起来很熟悉。每个 `if` 语句测试不同类型的事件，例如按键按下或按键释放。然而，不是处理事件，而是调用适当的
    `virtual` 函数。如果派生的 `InputHandler` 类重写了 `virtual` 函数，它将接收数据并处理事件。如果没有，则调用空的默认函数定义，什么也不会发生。
- en: When the `MouseButtonReleased` event occurs, each of the `Button` instances
    in the `vector` is tested to see if the click occurred within the button. This
    is achieved using the `contains` function on the collider in each button and passing
    in the position of the mouse click. Note that the button coordinates are relative
    to the panels `View` and not the screen coordinates. For this reason, the `mapPixelToCoords`
    function is used to convert the screen coordinates of the mouse click into the
    corresponding coordinates of the `View`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当`MouseButtonReleased`事件发生时，`vector`中的每个`Button`实例都会被测试，以查看点击是否发生在按钮内。这是通过在每个按钮的碰撞器上使用`contains`函数并传入鼠标点击的位置来实现的。请注意，按钮坐标是相对于面板的`View`而不是屏幕坐标。因此，使用`mapPixelToCoords`函数将鼠标点击的屏幕坐标转换为`View`的对应坐标。
- en: When a collision is detected, the `handleLeftClick virtual` function is called
    and the text from the button is passed in. The derived `InputHandler` classes
    will handle what happens on a button click based on the text of the button.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当检测到碰撞时，会调用`handleLeftClick virtual`函数，并将按钮上的文本传递进去。派生的`InputHandler`类将根据按钮上的文本处理按钮点击发生的情况。
- en: The final line of code in the `handleInput` function calls the final `virtual`
    function called `handleGamepad`. Any derived `InputHandler` classes that implement
    this function will get a chance to respond to the player's actions with the gamepad.
    In this project, only `GameInputHandler` will be concerned with what the gamepad
    is doing. You could adapt the project to allow the player to use the gamepad to
    navigate the menus of the other screen if you want to.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleInput`函数中的最后一行代码调用了最后的`virtual`函数`handleGamepad`。任何实现此函数的派生`InputHandler`类都将有机会通过游戏手柄对玩家的动作做出响应。在这个项目中，只有`GameInputHandler`会关注游戏手柄的行为。如果你想，你可以修改项目以允许玩家使用游戏手柄导航其他屏幕的菜单。'
- en: Coding the Screen class
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写`Screen`类代码
- en: 'Create a new header file in the `Header Files/Screens` filter called `Screen.h`
    and add the following code:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Header Files/Screens`过滤器中创建一个新的头文件，命名为`Screen.h`，并添加以下代码：
- en: '[PRE34]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the `private` section of the preceding code, there is a vector of shared
    smart pointers to `InputHandler` instances. This is where we will store all the
    derived `InputHandler` instances. `SelectScreen` will actually only have one `InputHandler`,
    while `GameScreen` will have two, but you can have as many as you like. Consider,
    for example, a hypothetical settings screen where you might have options for graphics,
    sound, controller, gameplay, and so on. Each of these options could then be clicked
    to reveal a unique `UIPanel` instance with a related `InputHandler`. So, we could
    have avoided using a `vector` for this project, but any significant project would
    almost certainly need a `vector` eventually. The smart pointers are of the shared
    variety, indicating we will be passing the contents via a function at some point.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面代码的`private`部分，有一个指向`InputHandler`实例的共享智能指针向量。这就是我们将存储所有派生`InputHandler`实例的地方。`SelectScreen`实际上只有一个`InputHandler`，而`GameScreen`将有两个，但你喜欢有多少就可以有多少。考虑一下，例如一个假设的设置屏幕，你可能会有图形、声音、控制器、游戏玩法等选项。每个选项都可以点击以显示一个相关的`UIPanel`实例和`InputHandler`。因此，我们本可以避免在这个项目中使用`vector`，但任何重大的项目最终几乎肯定都需要使用`vector`。智能指针是共享类型的，这表明我们将在某个时候通过函数传递内容。
- en: The next member is a `vector` of unique smart pointers to `UIPanel` instances.
    This is where all the derived `UIPanel` instances will go. The unique variety
    of pointer indicates we will not share the pointers; if we do, we will have to
    transfer responsibility.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个成员是一个指向`UIPanel`实例的唯一智能指针向量。这就是所有派生的`UIPanel`实例将去的地方。唯一指针的类型表明我们不会共享指针；如果我们共享，我们将不得不转移责任。
- en: In the protected section is the `addPanel` function, which is where a `Screen`
    will pass in all the details of a new `UIPanel` instance, including its related
    `InputHandler`. Note the parameter to receive a `ScreenManagerRemoteControl` pointer;
    remember that this is required for passing to `InputHandler`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在受保护的区域是`addPanel`函数，这是`Screen`传递所有新`UIPanel`实例的详细信息的地方，包括其相关的`InputHandler`。注意接收`ScreenManagerRemoteControl`指针的参数；记住这是传递给`InputHandler`所必需的。
- en: There is an `initialise` function as well, which we will see the purpose of
    shortly. The final three functions are the `virtual` functions, that is, `update`,
    `draw` and `handleInput`, which the derived `Screen` classes can override as they
    see fit.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一个 `initialise` 函数，我们很快就会看到它的用途。最后的三个函数是 `virtual` 函数，即 `update`、`draw` 和
    `handleInput`，派生的 `Screen` 类可以根据需要覆盖这些函数。
- en: Finally, take note of the `View` instance. Every `Screen` instance will also
    have its own `View` instance to draw to, just like each `UIPanel` does.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，注意一下 `View` 实例。每个 `Screen` 实例也将有自己的 `View` 实例来绘制，就像每个 `UIPanel` 一样。
- en: Let's take a look at the implementation of the functions we have just discussed.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们刚刚讨论过的函数的实现。
- en: 'Create a new source file in the `Source Files/Screens` filter called `Screen.cpp`
    and add the following code:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Source Files/Screens` 过滤器中创建一个新的源文件，命名为 `Screen.cpp`，并添加以下代码：
- en: '[PRE35]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `initialise` function is empty. It is designed to be overridden.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`initialise` 函数是空的。它被设计成可以被覆盖。'
- en: The `addPanel` function, as we already know, stores the `InputHandler` and `UIPanel`
    instances that are passed to it. When an `InputHandler` is passed in, the `initialiseInputHandler`
    function is called and three things are passed in. First is the `vector` of `Button`
    instances, next is the `View` instance from the related `UIPanel` instance, and
    third is the `this` argument. In the current context, `this` is a pointer to the
    `Screen` instance itself. Why not refer to the `InputHandler` class and verify
    that these arguments are correct and what happens to them?
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`addPanel` 函数，正如我们已知的，存储传递给它的 `InputHandler` 和 `UIPanel` 实例。当一个 `InputHandler`
    被传递进来时，`initialiseInputHandler` 函数被调用，并传递了三样东西。首先是 `Button` 实例的 `vector`，接下来是相关
    `UIPanel` 实例的 `View` 实例，第三是 `this` 参数。在当前上下文中，`this` 是指向 `Screen` 实例本身的指针。为什么不参考
    `InputHandler` 类来验证这些参数是否正确以及它们会发生什么？'
- en: 'Next, the panel and the input handler are added to the appropriate `vector`.
    Something interesting happens, however, if you look closely. Take another look
    at the line of code which adds the `UIPanel` instance called `uip` to the `m_Panels`
    vector:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将面板和输入处理器添加到适当的 `vector` 中。然而，如果你仔细观察，会发生一些有趣的事情。再次看看添加名为 `uip` 的 `UIPanel`
    实例到 `m_Panels` 向量的那行代码：
- en: '[PRE36]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The argument that's passed to `push_back` is encased in a call to `move`. This
    transfers responsibility for the unique pointer to the `UIPanel` in the `vector`.
    Any attempt to use `uip` after this point will result in a read access violation
    because `uip` is now a null pointer. The pointer in `m_Panels`, however, is good
    to go. You will probably agree that this is simpler than using a regular pointer
    and working out where to delete it.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `push_back` 的参数被包裹在一个对 `move` 的调用中。这把对 `UIPanel` 在 `vector` 中的唯一指针的责任转移给了
    `UIPanel`。从这一点开始，任何尝试使用 `uip` 的操作都将导致读取访问违规，因为 `uip` 现在是一个空指针。然而，`m_Panels` 中的指针是有效的。你可能认为这比使用常规指针并确定删除位置要简单。
- en: The `handleInput` function loops through every event, passing it in to each
    `InputHandler` in turn.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleInput` 函数遍历每个事件，依次将它们传递给每个 `InputHandler`。'
- en: The `update` function has no functionality in the base class and is empty.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`update` 函数在基类中没有功能，是空的。'
- en: The `draw` function loops through every `UIPanel` instance and calls their `draw`
    functions.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw` 函数遍历每个 `UIPanel` 实例，并调用它们的 `draw` 函数。'
- en: Now, we are ready to code all the derived classes. We will start with the select
    screen (`SelectScreen`) and then move on to the game screen (`GameScreen`). We
    will add one more quick class first, though.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好编写所有派生类了。我们将从选择屏幕（`SelectScreen`）开始，然后继续到游戏屏幕（`GameScreen`）。不过，我们首先会添加一个额外的快速类。
- en: Adding the WorldState.h file
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 WorldState.h 文件
- en: 'Create a new header file in the `Header Files/Engine` filter called `WorldState.h`
    and add the following code:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Header Files/Engine` 过滤器中创建一个新的头文件，命名为 `WorldState.h`，并添加以下代码：
- en: '[PRE37]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: These variables are public and static. As a result, they will be accessible
    throughout the project and are guaranteed to have only a single instance.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量是公共的和静态的。因此，它们将在整个项目中都是可访问的，并且保证只有一个实例。
- en: Coding the derived classes for the select screen
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写选择屏幕的派生类
- en: 'So far, we have coded the fundamental classes that represent the user interface,
    as well as the logical division of our game into screens. Next, we will code specific
    implementations of each of them. Remember that Space Invaders ++ will have two
    screens: select and game. The select screen will be represented by the `SelectScreen`
    class and will have a single `UIPanel` instance, a single `InputHandler` instance,
    and two buttons. The play screen will be represented by the `GameScreen` class
    and it will have two `UIPanel` instances. One is called `GameUIPanel` and will
    display the score, lives, and invader wave number. The other is called `GameOverUIPanel`
    and will display two buttons, giving the player the option to go back to the select
    screen or play again. As the `GameScreen` class is composed of two `UIPanel` instances,
    it will also be composed of two `InputHandler` instances.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经编写了代表用户界面以及将我们的游戏划分为屏幕的基本类。接下来，我们将编写它们的特定实现。记住，Space Invaders ++ 将有两个屏幕：选择屏幕和游戏屏幕。选择屏幕将由`SelectScreen`类表示，并将有一个单独的`UIPanel`实例、一个单独的`InputHandler`实例和两个按钮。游戏屏幕将由`GameScreen`类表示，它将有两个`UIPanel`实例。一个被称为`GameUIPanel`，将显示分数、生命值和入侵者波次。另一个被称为`GameOverUIPanel`，将显示两个按钮，给玩家提供返回选择屏幕或再次游戏的选择。由于`GameScreen`类由两个`UIPanel`实例组成，它也将由两个`InputHandler`实例组成。
- en: Coding the SelectScreen class
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写`SelectScreen`类
- en: 'Create a new header file in the `Header Files/Screens/Select` filter called
    `SelectScreen.h` and add the following code:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Header Files/Screens/Select`过滤器中创建一个新的头文件，命名为`SelectScreen.h`，并添加以下代码：
- en: '[PRE38]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `SelectScreen` class inherits from `Screen`. In the `private` section of
    the preceding code, there is a `ScreenManagerRemoteControl` pointer for switching
    screens, as well as a `Texture` instance and `Sprite` instance for drawing a background.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`SelectScreen`类从`Screen`类继承。在前面的代码的`private`部分中，有一个用于切换屏幕的`ScreenManagerRemoteControl`指针，以及用于绘制背景的`Texture`实例和`Sprite`实例。'
- en: In the `public` section, we can see the constructor and the prototype that overrides
    the `draw` function. The `SelectScreen` class does not need to override the `update`
    function.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在`public`部分，我们可以看到构造函数和覆盖了`draw`函数的原型。`SelectScreen`类不需要覆盖`update`函数。
- en: 'Create a new source file in the `Source Files/Screens/Select` filter called
    `SelectScreen.cpp` and add the following code:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Source Files/Screens/Select`过滤器中创建一个新的源文件，命名为`SelectScreen.cpp`，并添加以下代码：
- en: '[PRE39]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the constructor, the purpose of all the coding so far begins to come together.
    The `make_unique` function is used to create a unique smart pointer to a `SelectUIPanel`
    instance. We will code `SelectUIPanel` in a couple of sections time. Next, the
    `make_shared` function is used to create a shared smart pointer to a `SelectInputHandler`
    instance. We will code the `SelectInputHandler` class next. Now that we have a
    `UIPanel` and an `InputHandler` in the appropriate forms, we can call the `addPanel`
    function and pass them both in. Note that, in the call to `addPanel`, `suip` is
    wrapped in a call to `move`. Any use of `suip` after this point is not possible
    without crashing the program because it is now a null pointer, since ownership
    has been moved to the function argument. Remember that, inside the `Screen` class
    `addPanel` function, ownership is moved again when the unique pointer to `UIPanel`
    is stashed away in the `vector` of `UIPanel` instances.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，到目前为止所有编码的目的开始汇聚。使用`make_unique`函数创建了一个指向`SelectUIPanel`实例的唯一智能指针。我们将在接下来的几个部分中编写`SelectUIPanel`。接下来，使用`make_shared`函数创建了一个指向`SelectInputHandler`实例的共享智能指针。我们将在下一个部分编写`SelectInputHandler`类。现在我们已经有了适当的`UIPanel`和`InputHandler`，我们可以调用`addPanel`函数并将它们都传递进去。注意，在调用`addPanel`时，`suip`被包裹在一个调用`move`的函数中。从这一点开始，任何对`suip`的使用都可能导致程序崩溃，因为它现在是一个空指针，因为所有权已经移动到函数参数。记住，在`Screen`类的`addPanel`函数内部，当将`UIPanel`的唯一指针存储在`UIPanel`实例的`vector`中时，所有权再次转移。
- en: Following this, the `ScreenManagerRemoteControl` pointer is initialized and
    can now be used to switch to another screen when required.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，`ScreenManagerRemoteControl`指针被初始化，现在可以在需要时切换到另一个屏幕。
- en: The final few lines of code in the constructor create and scale a `Sprite` instance
    that uses the `background.png` image, which will fill the entire screen.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数中的最后几行代码创建并缩放了一个使用`background.png`图像的`Sprite`实例，该实例将填充整个屏幕。
- en: In the `draw` function, the call to the `setView` function makes this panel's
    `View` instance the one to draw on, and then the `Sprite` instance is drawn to
    the `RenderWindow` instance.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在`draw`函数中，对`setView`函数的调用使这个面板的`View`实例成为绘制的目标，然后`Sprite`实例被绘制到`RenderWindow`实例上。
- en: Finally, the `draw` function is called on the base `Screen` class, which draws
    all the panels and their related buttons. In this specific case, it draws just
    a single panel, `SelectUIPanel`, which we will code right after we have coded
    `SelectInputHandler`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在基类`Screen`上调用`draw`函数，它绘制所有面板及其相关按钮。在这个特定情况下，它只绘制一个面板，即`SelectUIPanel`，我们将在编写完`SelectInputHandler`之后立即编写它。
- en: Coding the SelectInputHandler class
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写`SelectInputHandler`类
- en: 'Create a new header file in the `Header Files/Screens/Select` filter called
    `SelectInputHandler.h` and add the following code:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Header Files/Screens/Select`过滤器中创建一个新的头文件，命名为`SelectInputHandler.h`，并添加以下代码：
- en: '[PRE40]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `SelectInputHandler` class inherits from `InputHandler` and overrides the
    `handleKeyPressed` and `handleLeftClick` functions. Let's see how these functions
    are implemented.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`SelectInputHandler`类继承自`InputHandler`并重写了`handleKeyPressed`和`handleLeftClick`函数。让我们看看这些函数是如何实现的。'
- en: 'Create a new source file in the `Source Files/Screens/Select` filter called
    `SelectInputHandler.cpp` and add the following code:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Source Files/Screens/Select`过滤器中创建一个新的源文件，命名为`SelectInputHandler.cpp`，并添加以下代码：
- en: '[PRE41]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `handleKeyPressed` function interacts with just one keyboard key. When the
    *Escape* key is pressed, the game quits.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleKeyPressed`函数仅与一个键盘键交互。当按下*Esc*键时，游戏退出。'
- en: In the `handleLeftClick` function, there are two `if` statements. Remember that
    the `handleInputFunction` of the `InputHandler` class passes in the text of the
    button that was clicked, along with a reference to `RenderWindow`. If the `WAVE_NUMBER`
    variable is set to zero, and the `ScreenManagerRemoteControl` pointer calls the
    `loadLevelInPlayMode` function. The `loadLevelInPlayMode` function has its definition
    in `ScreenManagerClass`. Eventually, this function will indeed load a level from
    the passed in file name, but for now, it simply changes screen to the play screen.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在`handleLeftClick`函数中，有两个`if`语句。记住，`InputHandler`类的`handleInputFunction`传递了被点击按钮的文本以及`RenderWindow`的引用。如果`WAVE_NUMBER`变量设置为零，并且`ScreenManagerRemoteControl`指针调用`loadLevelInPlayMode`函数。`loadLevelInPlayMode`函数的定义在`ScreenManagerClass`中。最终，这个函数确实会从传入的文件名中加载一个关卡，但现在，它只是将屏幕切换到游戏屏幕。
- en: If the **Quit** button is clicked, then the game is exited.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果点击了**退出**按钮，则游戏退出。
- en: Important note
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: At this stage, despite including `WorldState.h`, you might have an error using
    `WorldState::WaveNumber`. This is fine; this is happening because of the order
    in which the classes are parsed by Visual Studio. When we add all the game screen-related
    classes that also use `WorldState.h`, which is parsed before this file, the error
    will be gone.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，尽管包含了`WorldState.h`，但在使用`WorldState::WaveNumber`时可能会出现错误。这是正常的；这是由于Visual
    Studio解析类时的顺序造成的。当我们添加所有使用`WorldState.h`的游戏屏幕相关类时，这个文件在解析之前，错误就会消失。
- en: Let's code `SelectUIPanel`. Then, we can move on to the `GameScreen` class.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写`SelectUIPanel`。然后，我们可以继续编写`GameScreen`类。
- en: Coding the SelectUIPanel class
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写`SelectUIPanel`类
- en: 'Create a new header file in the `Header Files/Screens/Select` filter called
    `SelectUIPanel.h` and add the following code:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Header Files/Screens/Select`过滤器中创建一个新的头文件，命名为`SelectUIPanel.h`，并添加以下代码：
- en: '[PRE42]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `SelectUIPanel` class inherits from `UIPanel` and overrides the `draw` function.
    In the preceding header file, you can also see that there is a function called
    `initialiseButtons`, as well as a constructor. Let's code the definitions.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`SelectUIPanel`类继承自`UIPanel`并重写了`draw`函数。在上面的头文件中，你还可以看到一个名为`initialiseButtons`的函数，以及一个构造函数。让我们编写这些定义。'
- en: 'Create a new source file in the Source `Files/Screens/Select` filter called
    `SelectUIPanel.cpp` and add the following code:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在源文件`Files/Screens/Select`过滤器中创建一个新的源文件，命名为`SelectUIPanel.cpp`，并添加以下代码：
- en: '[PRE43]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The constructor receives the screen resolution and immediately uses that data
    to call the superclass constructor. By doing calculations with the values stored
    in `res`, the starting position and size of the panel is calculated. It is important
    that this calculation is done here and not in the `UIPanel` class because every
    `UIPanel` will be a different size and in a different position. Take a look at
    the comments in the preceding code if you are interested in the effect of each
    of the specific calculations. The color is also passed in using alpha, red, green,
    and blue values.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接收屏幕分辨率，并立即使用该数据调用超类构造函数。通过使用存储在`res`中的值进行计算，计算了面板的起始位置和大小。重要的是这个计算在这里进行，而不是在`UIPanel`类中进行，因为每个`UIPanel`的大小和位置都不同。如果你对每个特定计算的效果感兴趣，请查看前面代码中的注释。颜色也通过alpha、红色、绿色和蓝色值传递。
- en: Next, the member variables from the base class that determine button size and
    spacing are initialized. The value of `20` is just an arbitrary value that works,
    but the important part is that all the values are based on the resolution of the
    screen, so they will scale well over different screen resolutions.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，初始化了基类中的成员变量，这些变量决定了按钮的大小和间距。`20`这个值只是一个任意值，它有效，但重要的是所有值都是基于屏幕分辨率的，因此它们将在不同的屏幕分辨率上很好地缩放。
- en: The next few lines of code prepare a `Text` instance, ready to be shown in the
    draw function. Finally, in the constructor, the `initialiseButtons` function is
    called.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行代码准备了一个`Text`实例，以便在绘制函数中显示。最后，在构造函数中调用了`initialiseButtons`函数。
- en: In the `initialiseButtons` function, the `addButton` function is called twice,
    creating a green button with "Play" on it and a red button with "Quit" on it.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在`initialiseButtons`函数中，调用了`addButton`函数两次，创建了一个上面写着“Play”的绿色按钮和一个上面写着“Quit”的红色按钮。
- en: There might be some errors because of the use of the `WorldState.h` file. These
    can be ignored as they will correct themselves as we proceed with the next few
    classes.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用了`WorldState.h`文件，可能会有一些错误。这些错误可以忽略，因为随着我们继续编写接下来的几个类，它们会自行纠正。
- en: Now, we can code all the game screen-related classes.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写所有与游戏界面相关的类。
- en: Coding the derived classes for the game screen
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为游戏界面编写派生类
- en: The structure of all these classes is the same as the select screen-related
    classes. I will be sure to point out where they vary, however. Most of the significant
    differences will be discussed across the next three chapters, however, because
    that is when we will code all the game objects and components and then put them
    to work in the `GameScreen` class.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些类的结构都与选择界面相关的类相同。我一定会指出它们的不同之处。大多数重大差异将在接下来的三章中讨论，因为那时我们将编写所有游戏对象和组件，并将它们用于`GameScreen`类。
- en: The first difference is that the `GameScreen` class has two `UIPanel` instances
    and two `InputHandler` instances.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个区别是`GameScreen`类有两个`UIPanel`实例和两个`InputHandler`实例。
- en: Coding the GameScreen class
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写`GameScreen`类
- en: 'Create a new header file in the `Header Files/Screens/Game` filter called `GameScreen.h`
    and add the following code:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Header Files/Screens/Game`筛选器中创建一个新的头文件，名为`GameScreen.h`，并添加以下代码：
- en: '[PRE44]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note that this is not the finished code – we will add more features to this
    file in the next chapter. This is just enough code so that we can run the game
    and see some basic functionality at the end of this chapter.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这还不是最终的代码——我们将在下一章中向此文件添加更多功能。这只是一些代码，足以让我们运行游戏，并在本章末尾看到一些基本功能。
- en: The code is familiar to the `SelectScreen` class. We also override the `initialise`
    and `update` functions. Furthermore, we have added a Boolean called `m_GameOver`,
    which will keep track of whether the game is currently playing.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与`SelectScreen`类相似。我们还重写了`initialise`和`update`函数。此外，我们添加了一个布尔值`m_GameOver`，它将跟踪游戏是否正在播放。
- en: Let's move on to the function implementations.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到函数实现。
- en: 'Create a new source file in the `Source Files/Screens/Game` filter called `GameScreen.cpp`
    and add the following code:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Source Files/Screens/Game`筛选器中创建一个新的源文件，名为`GameScreen.cpp`，并添加以下代码：
- en: '[PRE45]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Everything that happened in the `SelectScreen` class happens here too, but for
    two `UIPanel` instances and two `InputHandler` instances. The next difference
    is that `GameScreen` does implement the `update` function. This is where all the
    game objects will be updated each frame of the game.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SelectScreen`类中发生的一切在这里也会发生，但有两个`UIPanel`实例和两个`InputHandler`实例。下一个区别是`GameScreen`类实现了`update`函数。这是游戏中的每个游戏对象都会在每个帧更新的地方。
- en: The next difference is that we have added some basic logic for the game into
    the `initialise` and `update` functions.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个不同之处在于，我们在`initialise`和`update`函数中添加了一些基本的游戏逻辑。
- en: Important note
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: I apologize for the inconsistent spelling of the `initialise` and `initialize`
    functions. Changing them at this current stage of production is more likely to
    introduce errors into the book than help you out.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`initialise`和`initialize`函数拼写不一致，我表示歉意。在当前的生产阶段更改它们更有可能将错误引入书中，而不是帮助您。
- en: In the `initialize` function, the code calls the `initialize` function of the
    `GameInputHandler` class that we will code next. The `NUM_INVADERS` variable is
    set to zero, while `m_GameOver` is set to false. Next, the `WAVE_NUMBER` variable
    is tested and, if it equals zero, then the `WorldState` class has its static variables
    initialized, ready for a new game.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在`initialize`函数中，代码调用了我们将要编写的`GameInputHandler`类的`initialize`函数。将`NUM_INVADERS`变量设置为零，同时将`m_GameOver`设置为false。接下来，测试`WAVE_NUMBER`变量，如果它等于零，则`WorldState`类的静态变量被初始化，为新的游戏做好准备。
- en: In the `update` function, the `m_GameOver` variable is used to determine whether
    the game is running and, if it is, two more tests are done. The first tests whether
    all the invaders have been destroyed. At this stage of development, because there
    aren't any invaders, this has the effect of constantly incrementing the wave number.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在`update`函数中，使用`m_GameOver`变量来确定游戏是否正在运行，如果是，则进行两个额外的测试。第一个测试是否所有入侵者都被摧毁了。在当前的开发阶段，因为没有入侵者，这会导致波数不断递增。
- en: The second test checks whether the player has run out of lives and if they have,
    then `m_GameOver` is set to true.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试检查玩家是否用完了生命，如果是，则将`m_GameOver`设置为true。
- en: Coding the GameInputHandler class
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写GameInputHandler类
- en: 'Create a new header file in the `Header Files/Screens/Game` filter called `GameInputHandler.h`
    and add the following code:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Header Files/Screens/Game`筛选器中创建一个新的头文件，命名为`GameInputHandler.h`，并添加以下代码：
- en: '[PRE46]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This class works the same way as `SelectInputHandler` does, but we need to override
    more of the functions. We will add code to the `initialize`, `handleGamepad`,
    `handleKeyPressed`, and `handleKeyReleased` functions here.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的工作方式与`SelectInputHandler`相同，但我们需要覆盖更多的函数。我们将在`initialize`、`handleGamepad`、`handleKeyPressed`和`handleKeyReleased`函数中添加代码。
- en: This is not the finished code – we will add lots more features to this file
    in the next chapter. This is just enough code so that we can run the game and
    see some basic functionality at the end of the chapter.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不是最终的代码——我们将在下一章中向这个文件添加更多功能。这只是一些代码，以便我们可以在章节末尾运行游戏并看到一些基本功能。
- en: 'Create a new source file in the `Source Files/Screens/Game` filter called `GameInputHandler.cpp`
    and add the following code:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Source Files/Screens/Game`筛选器中创建一个新的源文件，命名为`GameInputHandler.cpp`，并添加以下代码：
- en: '[PRE47]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: For now, we only want to add code to the `handleKeyPressed` function, but why
    not add the other empty functions that are shown in the preceding code? When the
    player presses the *Escape* key, the `ScreenMangerRemoteControl` pointer calls
    the `SwitchScreen` function to go back to the select screen.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只想向`handleKeyPressed`函数添加代码，但为什么不添加前面代码中显示的其他空函数呢？当玩家按下*Escape*键时，`ScreenMangerRemoteControl`指针调用`SwitchScreen`函数返回到选择屏幕。
- en: This is not the finished code – we will add lots more features to this file
    in the next chapter. This is just enough code so that we can run the game and
    see some basic functionality at the end of the chapter.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不是最终的代码——我们将在下一章中向这个文件添加更多功能。这只是一些代码，以便我们可以在章节末尾运行游戏并看到一些基本功能。
- en: Coding the GameUIPanel class
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写GameUIPanel类
- en: 'Create a new header file in the `Header Files/Screens/Game` filter called `GameUIPanel.h`
    and add the following code:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Header Files/Screens/Game`筛选器中创建一个新的头文件，命名为`GameUIPanel.h`，并添加以下代码：
- en: '[PRE48]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Like the previous `UIPanel` child class, we'll override the `draw` function
    and also implement the constructor. Let's code these functions now.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的`UIPanel`子类一样，我们将覆盖`draw`函数并实现构造函数。现在让我们编写这些函数。
- en: 'Create a new source file in the `Source Files/Screens/Game` filter called `GameUIPanel.cpp`
    and add the following code:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Source Files/Screens/Game`筛选器中创建一个新的源文件，命名为`GameUIPanel.cpp`，并添加以下代码：
- en: '[PRE49]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The constructor, like the `SelectUIPanel` class, calls the base class constructor
    to configure the position, size, and color of the panel. Also, in the constructor,
    a `Text` instance is prepared for drawing to the screen.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数，就像`SelectUIPanel`类一样，调用基类构造函数来配置面板的位置、大小和颜色。此外，在构造函数中，准备了一个`Text`实例以在屏幕上绘制。
- en: In the `draw` function, a `stringstream` instance is used to concatenate a String
    of text that displays the player's score, lives remaining, and number of waves
    cleared. The `RenderWindow` instance then passes the `Text` instance to its `draw`
    function.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在`draw`函数中，使用`stringstream`实例来连接一个字符串，该字符串显示玩家的得分、剩余生命和清除的波数。然后`RenderWindow`实例将`Text`实例传递给其`draw`函数。
- en: Coding the GameOverInputHandler class
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写GameOverInputHandler类
- en: Remember that the game screen will have two panels and two input handling classes.
    When the player loses their last life, the game over panel will be shown. This
    is what we will code now.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 记住游戏屏幕将有两个面板和两个输入处理类。当玩家失去最后一条生命时，游戏结束面板将显示出来。这是我们接下来要编写的代码。
- en: 'Create a new header file in the `Header Files/Screens/Game` filter called `GameOverInputHandler.h`
    and add the following code:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Header Files/Screens/Game`筛选器中创建一个新的头文件，命名为`GameOverInputHandler.h`，并添加以下代码：
- en: '[PRE50]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: There is nothing different in the preceding code compared to the header files
    of the previous two `InputHandler` derived classes.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 与前两个`InputHandler`派生类的头文件相比，前面的代码没有不同。
- en: 'Create a new source file in the `Source Files/Screens/Game` filter called `GameOverInputHandler.cpp`
    and add the following code:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Source Files/Screens/Game`筛选器中创建一个新的源文件，命名为`GameOverInputHandler.cpp`，并添加以下代码：
- en: '[PRE51]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The preceding code handles two types of event. First, if the *Escape* keyboard
    key is pressed, the game switches to the select screen.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码处理了两种类型的事件。首先，如果按下*Esc*键盘键，游戏将切换到选择屏幕。
- en: In the `handleLeftClick` function, there are two different buttons that are
    handled. If the `loadLevelInPlayMode`, while, if the **Home** button is clicked,
    then the select screen will be shown.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在`handleLeftClick`函数中，处理了两个不同的按钮。如果点击了`loadLevelInPlayMode`，则，如果点击了**主页**按钮，则将显示选择屏幕。
- en: Coding the GameOverUIPanel class
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写GameOverUIPanel类
- en: 'Create a new header file in the `Header Files/Screens/Game` filter called `GameOverUIPanel.h`
    and add the following code:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Header Files/Screens/Game`筛选器中创建一个新的头文件，命名为`GameOverUIPanel.h`，并添加以下代码：
- en: '[PRE52]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: There's nothing new in the preceding header file, so let's look at the function
    implementations
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的头文件中没有新内容，所以让我们看看函数实现。
- en: 'Create a new source file in the `Source Files/Screens/Game` filter called `GameOverUIPanel.cpp`
    and add the following code:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Source Files/Screens/Game`筛选器中创建一个新的源文件，命名为`GameOverUIPanel.cpp`，并添加以下代码：
- en: '[PRE53]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The preceding code configures a panel in the middle of the screen with the text
    **Game Over!** and two buttons that will allow the player to restart the game
    or quit, and go back to the starting screen (home/select).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码在屏幕中间配置了一个面板，上面有**游戏结束**的文本和两个按钮，允许玩家重新开始游戏或退出，并返回到起始屏幕（主页/选择）。
- en: Running the game
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行游戏
- en: 'If you run the game, you will see the select screen, as shown in the following
    screenshot:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行游戏，你将看到选择屏幕，如下面的截图所示：
- en: '![](img/B14278_19_08.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_19_08.jpg)'
- en: 'Press **Play** to transition to the game screen:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 按**播放**键切换到游戏屏幕：
- en: '![](img/B14278_19_09.jpg)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_19_09.jpg)'
- en: Press **Escape** to quit, and go back to the select screen.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 按**Esc**键退出，并返回到选择屏幕。
- en: 'Quit the game and find the following line of code in the `GameScreen` class:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 退出游戏，并在`GameScreen`类中找到以下代码行：
- en: '[PRE54]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Change it to the following:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 更改为以下内容：
- en: '[PRE55]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, run the game again and select the **Play** button. The game over panel
    will be displayed and can be interacted with:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次运行游戏并选择**播放**按钮。游戏结束面板将显示出来，可以与之交互：
- en: '![](img/B14278_19_10.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_19_10.jpg)'
- en: Now, change back `if (true)` in the `GameScreen` class back to `if (WorldState::LIVES
    <= 0)`.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将`GameScreen`类中的`if (true)`改回`if (WorldState::LIVES <= 0)`。
- en: Let's take a break; that was a long chapter.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们休息一下；这是一章很长的内容。
- en: Summary
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You have achieved a lot in this chapter. You have built a solid foundation for
    the Space Invaders ++ game and you have also coded a reusable system that can
    be used for almost any game that is divided up into different "screens".
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章中取得了很大的成就。你已经为Space Invaders ++游戏建立了坚实的基础，并且你还编写了一个可重用的系统，该系统可以用于几乎任何被划分为不同“屏幕”的游戏。
- en: We now have an input handling system in place that can detect keyboard presses
    and mouse clicks and route the responsibility to handle them to a specific panel
    that is part of a specific screen. Furthermore, the abstraction of the concept
    of a screen allows us to set up as many different game loops as we like. The `GameScreen`
    class will be the main class to handle the logic of this game but, once you see
    how over the next few chapters, you could easily code another screen to play a
    completely different game. Of course, the most likely thing you will do is get
    started with your own ideas.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经建立了一个输入处理系统，它可以检测键盘按键和鼠标点击，并将处理这些输入的责任路由到特定屏幕的一部分特定面板。此外，屏幕概念的抽象化使我们能够设置尽可能多的不同游戏循环。`GameScreen`类将是处理这个游戏逻辑的主要类，但在接下来的几章中，你将看到如何轻松地编写另一个屏幕来玩一个完全不同的游戏。当然，你最有可能会从自己的想法开始着手。
- en: In the next chapter, we will code the game objects and components which are
    the basis of our entity-component pattern implementation.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将编写游戏对象和组件，它们是我们实体-组件模式实现的基础。
