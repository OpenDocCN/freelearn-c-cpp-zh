<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer037">
<h1 class="chapter-number" id="_idParaDest-142"><a id="_idTextAnchor366"/>7</h1>
<h1 id="_idParaDest-143"><a id="_idTextAnchor367"/>Utilizing Dynamic Binding through Polymorphism</h1>
<p>This chapter will further extend our knowledge of object-oriented programming in C++. We will begin by introducing a powerful OO concept, <strong class="bold">polymorphism</strong>, and then understand how this idea is implemented in C++ through <em class="italic">direct language support</em>. We will implement polymorphism using virtual functions in hierarchies of related classes, and understand how we can achieve runtime binding of a specific derived class method to a more generic, base class operation. We will understand how the OO concept of polymorphism presented in this chapter will support versatile and robust designs and easily extensible code in C++.</p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>Understanding the OO concept of polymorphism and why it is important to OOP</li>
<li><a id="_idTextAnchor368"/>Defining virtual functions, understanding how virtual functions override base class methods (or halt the overriding process with the <strong class="source-inline">final</strong> specifier), generalizing derived class objects, the need for virtual destructors, as well as understanding function hiding</li>
<li>Understand dynamic (runtime) binding of methods to operations</li>
<li>Detailed understanding of the <strong class="bold">virtual function table</strong> (v-table)</li>
</ul>
<p>By the end of this chapter, you will understand the OO concept of polymorphism, and how to implement this idea in C++ through virtual functions. You will understand how virtual functions enable the runtime binding of methods to operations in C++. You will see how an operation can be specified in a base class and overridden with a preferred implementation in a derived class. You will understand when and why it is important to utilize a virtual destructor.</p>
<p>You will see how instances of derived classes are often stored using base class pointers and why this is significant. We will discover that, regardless of how an instance is stored (as its own type or as that of a base class), the correct version of a virtual function will always be applied through dynamic binding. Specifically, you will see how runtime binding works under the hood as we examine virtual function pointers and virtual function tables in C++. </p>
<p>By understanding the direct language support of polymorphism in C++ using virtual functions, you will be on your way to creating an extensible hierarchy of related classes, featuring dynamic binding of methods to operations. Let us augment our understanding of C++ as an OOP language by detailing these ideals.</p>
<h1 id="_idParaDest-144"><a id="_idTextAnchor369"/>Technical requirements</h1>
<p>Online code for full program examples can be found in the following GitHub URL: <a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter07">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter07</a>. Each full program example can be found in the GitHub under the appropriate chapter heading (subdirectory) in a file that corresponds to the chapter number, followed by a dash, followed by the example number in the chapter at hand. For example, the first full program in this chapter can be found in the subdirectory <strong class="source-inline">Chapter07</strong> in a file named <strong class="source-inline">Chp7-Ex1.cpp</strong> under the aforementioned GitHub directory.</p>
<p>The CiA video for this chapter can be viewed at: <a href="https://bit.ly/3QQUGxg">https://bit.ly/3QQUGxg</a>.</p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor370"/>Understanding the OO concept of polymorphism</h1>
<p>In this section, we <a id="_idIndexMarker549"/>will introduce an essential object-oriented <a id="_idIndexMarker550"/>concept, polymorphism.</p>
<p>From <a href="B19087_05.xhtml#_idTextAnchor222"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Classes in Detail</em>, and <a href="B19087_06.xhtml#_idTextAnchor314"><em class="italic">Chapter 6</em></a>, <em class="italic">Implementing Hierarchies with Single Inheritance</em>, you now understand the key OO ideas of encapsulation, information hiding, generalization, and specialization. You know how to encapsulate a class, how to build inheritance hierarchies using single inheritance, and the various reasons to build hierarchies (such as supporting Is-A relationships or for the lesser-used reason of supporting implementation inheritance). Let’s begin by extending our basic OO terminology by <a id="_idIndexMarker551"/>exploring <strong class="bold">polymorphism</strong>.</p>
<p>When a base class specifies an operation such that a derived class may redefine the operation in its class with a more suitable method, the operation is said to be <strong class="bold">polymorphic</strong>. Let’s revisit our definitions of <strong class="bold">operation</strong> and <strong class="bold">method</strong>, as well as their implications, to understand how these concepts lay the groundwork for polymorphism:</p>
<ul>
<li>In C++, an <strong class="bold">operation</strong> maps to the complete signature of the member function (name plus type and number of arguments – no return type). </li>
<li>Additionally, in C++, a <strong class="bold">method</strong> maps to the definition or body of the operation (that is, the implementation or body of the member function). </li>
<li>Recall that in OO terms, an <strong class="bold">operation</strong> implements a behavior of a class. The implementation of a base class operation may be via several distinct derived class <strong class="bold">methods</strong>.</li>
</ul>
<p><strong class="bold">Polymorphism</strong> gives an object the ability to take on <em class="italic">many forms</em>, yet have its most relevant behaviors applied, even when the object may be represented in a more genericized (base class) state than it is originally defined. This happens in C++ with public inheritance. A derived class object may be more generically pointed to by a base class pointer through upcasting. Yet, if an operation is defined to be polymorphic, the specific method applied when the operation is invoked will be the derived class version, as that is the most appropriate method for the object (irrespective of how it may currently be genericized as a base class object). Here, the derived class object fulfills the Is-A relationship of the base class. For example, a <strong class="source-inline">Student</strong> <em class="italic">Is-A</em> <strong class="source-inline">Person</strong>. Yet, a polymorphic operation will allow <strong class="source-inline">Student</strong> behaviors to be revealed on <strong class="source-inline">Student</strong> objects, even when they have <em class="italic">taken on the form</em> of a <strong class="source-inline">Person</strong>. </p>
<p>As we progress through this chapter, we will see derived class objects taking on the form of their public base classes, that is, taking on <em class="italic">many forms</em> (<strong class="bold">polymorphism</strong>). We will see <a id="_idIndexMarker552"/>how <a id="_idIndexMarker553"/>a polymorphic operation can be specified in a base class and overridden with a preferred implementation in a derived class.</p>
<p>Let’s start by looking at the C++ language feature that allows us to implement polymorphism, namely, virtual functi<a id="_idTextAnchor371"/>ons.</p>
<h1 id="_idParaDest-146"><a id="_idTextAnchor372"/>Implementing polymorphism with virtual functions</h1>
<p>Polymorphism<a id="_idIndexMarker554"/> allows dynamic<a id="_idIndexMarker555"/> binding of a method to an operation. Dynamic, or runtime, binding of a method to an operation is important because derived class instances may be pointed to by base class objects (that is, by pointers of a base class type). In these situations, the pointer type does not provide adequate information regarding the correct method that should be applied to the referenced instance. We need another way – one done at runtime – to determine which method applies to each instance.</p>
<p>Often, it is the case that a pointer to an instance of a derived class type will be generalized as a pointer to the base class type. When an operation is applied to the pointer, the correct method for what the object truly is should be applied, rather than the <a id="_idIndexMarker556"/>method<a id="_idIndexMarker557"/> that <em class="italic">seems</em> appropriate for the generalized pointer type.</p>
<p>Let’s begin with the relevant keywords and logistics necessary to define virtual functions so that we may implement polymorphism.</p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor373"/>Defining virtual functions and overriding base class methods</h2>
<p><strong class="bold">Virtual functions</strong> in C++ directly<a id="_idIndexMarker558"/> support<a id="_idIndexMarker559"/> polymorphism. A <strong class="bold">virtual function</strong> is<a id="_idIndexMarker560"/> as<a id="_idIndexMarker561"/> follows:</p>
<ul>
<li>A member function that correctly allows methods for a given operation to be overridden successively in a hierarchy to provide more suitable definitions</li>
<li>A member function that allows dynamic, rather than the usual static, binding for methods</li>
</ul>
<p>A virtual function is specified using the<a id="_idIndexMarker562"/> keyword <strong class="bold">virtual</strong> with the following nuances:</p>
<ul>
<li>The keyword <strong class="source-inline">virtual</strong> should precede the return type of the function in its prototype.</li>
<li>Functions in the derived class with the same name and signature of a virtual function in any ancestor class redefine the virtual function in those base classes. Here, the keyword <strong class="source-inline">virtual</strong> is optional in the derived class prototype. </li>
<li>Optionally and preferred, the keyword <strong class="source-inline">override</strong> can be added as part of the extended signature in the derived class prototype. This recommended practice will allow the compiler to flag an error if the signature of the intended overridden method does not match the signature as specified in the base class. The <strong class="source-inline">override</strong> keyword can eliminate unintended function hiding.</li>
<li>Functions with the same name, yet a different signature in a derived class, do not redefine a virtual function in their base class; rather, they hide the methods found in their base classes.</li>
<li>Additionally, the keyword <strong class="source-inline">final</strong> can be added as part of the extended signature of a virtual function prototype if the virtual function in question is not intended to be further overridden in a derived class.</li>
</ul>
<p>The derived class need not redefine virtual functions specified in its base class if the inherited methods are suitable. However, should a derived class redefine an operation with a new method, the same signature (as specified by the base class) must be used for the overridden <a id="_idIndexMarker563"/>method. Furthermore, derived <a id="_idIndexMarker564"/>classes <a id="_idIndexMarker565"/>should <a id="_idIndexMarker566"/>only redefine v<a id="_idTextAnchor374"/>irtual functions.</p>
<p>Here is a simple example to illustrate the basic syntax:</p>
<ul>
<li><strong class="source-inline">Print()</strong> is a virtual function defined in the base class <strong class="source-inline">Person</strong>. It will be overridden with a more appropriate implementation in the <strong class="source-inline">Student</strong> class:<p class="source-code">class Person  // base class</p><p class="source-code">{</p><p class="source-code">private:</p><p class="source-code">    string name;</p><p class="source-code">    string title;</p><p class="source-code">public:</p><p class="source-code">    // constructors/destructor (will soon be virtual), </p><p class="source-code">    // public access functions, public interface etc.</p><p class="source-code">    <strong class="bold">virtual</strong> void Pr<a id="_idTextAnchor375"/>int() const</p><p class="source-code">    {</p><p class="source-code">        cout &lt;&lt; title &lt;&lt; " " &lt;&lt; name &lt;&lt; endl;</p><p class="source-code">    }</p><p class="source-code">}; </p></li>
</ul>
<p>Here, the base class <strong class="source-inline">Person</strong>, introduces a virtual function, <strong class="source-inline">Print()</strong>. By labeling this function as <strong class="source-inline">virtual</strong>, the <strong class="source-inline">Person</strong> class is inviting any future descendants to redefine this function with a more suitable implementation or method, should they be so motivated.</p>
<ul>
<li>The virtual function defined in the base class <strong class="source-inline">Person</strong> is, in fact, overridden with a<a id="_idIndexMarker567"/> more <a id="_idIndexMarker568"/>appropriate <a id="_idIndexMarker569"/>implementation <a id="_idIndexMarker570"/>in the <strong class="source-inline">Student</strong> class:<p class="source-code">class Student: public Person  // derived class</p><p class="source-code">{</p><p class="source-code">private:</p><p class="source-code">    float gpa = 0.0;  // in-class initialization</p><p class="source-code">public:</p><p class="source-code">    // constructors, destructor specific to Student,</p><p class="source-code">    // public access functions, public interface, etc.</p><p class="source-code">    void Print() const <strong class="bold">override</strong> </p><p class="source-code">    {</p><p class="source-code">        Person::Print(); // call <a id="_idTextAnchor376"/>base class fn to help</p><p class="source-code">        cout &lt;&lt; " is a student. GPA: " &lt;&lt; gpa &lt;&lt; endl;</p><p class="source-code">    }</p><p class="source-code">}; </p></li>
</ul>
<p>Notice here that the derived class <strong class="source-inline">Student</strong> introduces a new implementation of <strong class="source-inline">Print()</strong> that will override (that is, replace), the definition in <strong class="source-inline">Person</strong>. Note that if the implementation of <strong class="source-inline">Person::Print()</strong> were acceptable to <strong class="source-inline">Student</strong>, <strong class="source-inline">Student</strong> would not be obligated to override this function, even if it is marked as <strong class="source-inline">virtual</strong> in the base class. The mechanics of public inheritance would simply allow the derived class to inherit this method.</p>
<p>But because this function is <strong class="source-inline">virtual</strong> in <strong class="source-inline">Person</strong>, <strong class="source-inline">Student</strong> may opt to redefine this operation with a more suitable method. Here, it does. In the <strong class="source-inline">Student::Print()</strong> implementation, <strong class="source-inline">Student</strong> first calls <strong class="source-inline">Person::Print()</strong> to take advantage of the aforementioned base class function, then prints additional information itself. <strong class="source-inline">Student::Print()</strong> is choosing to call a base class function for help; it is not required to do so if the desired functionality can be implemented fully within its own class scope. </p>
<p>Notice that when <strong class="source-inline">Student::Print()</strong> is defined to override <strong class="source-inline">Person::Print()</strong>, the same signature as specified by the base class is used. This is important. Should a new signature have been used, we would get into a potential function hiding scenario, which we will soon discuss in our <em class="italic">Considering function hiding</em> subsection within this chapter.</p>
<p>Note that though the virtual functions in <strong class="source-inline">Person</strong> and <strong class="source-inline">Student</strong> are written inline, a virtual <a id="_idIndexMarker571"/>function will<a id="_idIndexMarker572"/> almost <a id="_idIndexMarker573"/>never<a id="_idIndexMarker574"/> be expanded as inline code by the compiler since the specific method for the operation must be determined at runtime. A very few cases exist for compiler devirtualization, involving final methods or knowing an instance’s dynamic type; such rare cases would allow a virtual<a id="_idTextAnchor377"/> function to be inlined. </p>
<p>Remember, polymorphic functions are meant to have the ability to override or replace base class versions of a given function. Function overriding differs from function overloading. </p>
<p class="callout-heading">Important distinction</p>
<p class="callout"><strong class="bold">Function overriding</strong> is defined <a id="_idIndexMarker575"/>by introducing the same function name with the same signature in a hierarchy of related classes (via virtual functions), whereas the derived class version is meant to replace the base class version. In contrast, <strong class="bold">function overloading</strong> is defined when two or more functions with the same name, but with different signatures, exist in the same scope of the program (such as in the same class).</p>
<p>Additionally, operations not initially specified as virtual when introduced in a base class definition are not polymorphic and, therefore, should not be overridden in any derived class. This means that if a base class does not use the keyword <strong class="source-inline">virtual</strong> when defining an operation, the base class does not intend for the derived class to redefine this operation with a more suitable derived class method. The base class instead is insisting that the implementation it has provided is suitable for <em class="italic">any</em> of its descendants. Should the derived class attempt to redefine a non-virtual base class operation, a subtle bug will be introduced into the application. The error will be that derived class instances stored using derived class pointers will use the derived class method, yet derived class instances stored using base class pointers will use the base class definition. Instances should always<a id="_idIndexMarker576"/> use their own behavior <a id="_idIndexMarker577"/>irrespective of how they are stored – this is the point of polymorphism. Never redefine a non-virtual function.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Operations not specified in a base class as virtual in C++ are not polymorphic, and should never be overridden by a derived class.</p>
<p>Let’s move forward and discover scenarios when we may want to collect derived class objects by a base class type, and when we may then need to qualify<a id="_idTextAnchor378"/> our destructors as virtual.</p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor379"/>Generalizing derived class objects</h2>
<p>When we view <a id="_idIndexMarker578"/>an <a id="_idIndexMarker579"/>inheritance hierarchy, it is typically one that employs public base classes; that is, it is a hierarchy that utilizes public inheritance to express Is-A relationships. When using inheritance in this manner, we may be motivated to collect groups of related instances together. For example, a hierarchy of <strong class="source-inline">Student</strong> specializations might include <strong class="source-inline">GraduateStudent</strong>, <strong class="source-inline">UnderGraduateStudent</strong>, and <strong class="source-inline">NonDegreeStudent</strong>. Assuming each of these derived classes has a public base class of <strong class="source-inline">Student</strong>, it would be appropriate to say a <strong class="source-inline">GraduateStudent</strong> <em class="italic">Is-A</em> <strong class="source-inline">Student</strong>, and so on. </p>
<p>We may find a reason in our application to group these <em class="italic">somewhat-like</em> instances together into one common set. For example, imagine that we are implementing a billing system for a university. The university may wish for us to collect all students, regardless of their derived class types, into one set to process them uniformly, so as to ca<a id="_idTextAnchor380"/>lculate their semester bills. </p>
<p>The <strong class="source-inline">Student</strong> class may have a polymorphic operation to <strong class="source-inline">CalculateSemesterBill()</strong>, which is implemented as a virtual function in <strong class="source-inline">Student</strong> with a default method. However, selected derived classes, such as <strong class="source-inline">GraduateStudent</strong>, may have preferred implementations that they wish to provide by overriding the operation in their own class with a more appropriate method. A <strong class="source-inline">GraduateStudent</strong>, for example, may have a different method to compute their total bill versus a <strong class="source-inline">NonDegreeStudent</strong>. Hence, each derived class may override the default implementation of <strong class="source-inline">CalculateSemesterBill()</strong> in each of their classes.</p>
<p>Nonetheless, in our bursar application, we can create a set of pointers of type <strong class="source-inline">Student</strong>, though each pointer will inevitably point to instances of the derived class types, such as <strong class="source-inline">GraduateStudent</strong>, <strong class="source-inline">UnderGraduateStudent</strong>, and <strong class="source-inline">NonDegreeStudent</strong>. When instances of derived class types have been generalized in this fashion, it is appropriate to apply functions (often virtual) to the set as defined in the base class level corresponding to the pointer type of the collection. Virtual functions allow these generalized instances to invoke a polymorphic operation to yield their individual derived class methods or implementations of these functions. This is exactly what we <a id="_idIndexMarker580"/>want. But, there are still more details to understand.</p>
<p>This basic premise of generalizing derived class instances will allow us to understand why we may need <a id="_idIndexMarker581"/>virtual destructors within many of our class definitions. Let’s take a look.</p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor381"/>Utilizing virtual destructors</h2>
<p>We now can <a id="_idIndexMarker582"/>conceptualize <a id="_idIndexMarker583"/>situations when grouping derived class instances into a <em class="italic">somewhat-like</em> set stored by their common base class type may be useful. It is actually very powerful to collect sibling type derived class instances by their base class type and employ virtual functions to allow their distinct behaviors to shine through.</p>
<p>But, let’s consider what happens when the memory for a derived class instance stored by a base class pointer goes away. We know its destructor is called, but which one? We actually know that a chain of destructors is called, starting with the destructor of the object type in question. But how do we know the actual derived class object type if the instance has been genericized by being stored using a base class pointer? A <strong class="bold">virtual destructor</strong> solves this issue.</p>
<p>By labeling a destructor as <strong class="source-inline">virtual</strong>, we are allowing it to be overridden as the <em class="italic">starting point</em> in the destruction sequence for a class and any of its descendants. The choice as to which destructor to use as the entry point of destruction will be deferred to runtime using dynamic binding, based on the object’s actual type, not what the pointer type may be that references it. We will soon see how this process is automated by examining C++’s underlying virtual function table.</p>
<p>A virtual destructor, unlike all other virtual functions, actually specifies the starting point for a full sequence of functions to be executed. Recall that as the last line of code in a destructor, the compiler automatically patches in a call to call the immediate base class destructor, and so on, until we reach the initial base class in the hierarchy. The destruction <a id="_idIndexMarker584"/>chain exists to provide a forum to release dynamically allocated data members in all subobjects of a given instance. Contrasting this behavior to other virtual functions, those merely allow the single, correct version of the function to be executed (unless the programmer chooses to call a base class version of the same function as a helper function during the derived method implementation).</p>
<p>You may ask why it is important to start the destruction sequence at the proper level. That is, starting at the level that matches the object’s actual type (versus a generalized pointer type that may point to the object). Recall that each class may have dynamically allocated data members. The destructor will deallocate these data members. Starting with the correct level destructor will ensure that you do not introduce any memory leaks into your application by forgoing appropriate destructors and their corresponding memory deallocations.</p>
<p>Are virtual destructors always necessary? That is a good question! Virtual destructors are always necessary when using a public base class hierarchy, that is, when using public inheritance. Recall that public base classes support Is-A relationships, which easily lead to allowing a derived class instance to be stored using a pointer of its base class type. For example, a <strong class="source-inline">GraduateStudent</strong> <em class="italic">Is-A</em> <strong class="source-inline">Student</strong>, so we can store a <strong class="source-inline">GraduateStudent</strong> as a <strong class="source-inline">Student</strong> in times when we require more generic processing along with its sibling types. We can always upcast in this fashion across a public inheritance boundary. However, when we use implementation inheritance (that is, private or protected base classes), upcasting is not allowed. So, for hierarchies employing private or protected inheritance, virtual destructors are not necessary because upcasting is simply disallowed; hence, it would never be ambiguous as to which destructor should be the entry point for classes in private and protected base class hierarchies. As a second example, we did not include a virtual destructor in our <strong class="source-inline">LinkedList</strong> class in <a href="B19087_06.xhtml#_idTextAnchor314"><em class="italic">Chapter 6</em></a>, <em class="italic">Implementing Hierarchies with Single Inheritance</em>; therefore, <strong class="source-inline">LinkedList</strong> should only be extended as a protected or private base class. We did, however, include a virtual destructor in our <strong class="source-inline">Queue</strong> and <strong class="source-inline">PriorityQueue</strong> classes because <strong class="source-inline">PriorityQueue</strong> uses <strong class="source-inline">Queue</strong> as a public base class. A <strong class="source-inline">PriorityQueue</strong> may be upcast to a <strong class="source-inline">Queue</strong> (but not to a <strong class="source-inline">LinkedList</strong>), necessitating the virtual destructor introduction at the <strong class="source-inline">Queue</strong> and its descendent levels in the hierarchy.</p>
<p>Are the optional keywords <strong class="source-inline">virtual</strong> and <strong class="source-inline">override</strong> recommended when overriding a virtual <a id="_idIndexMarker585"/>destructor? Those<a id="_idIndexMarker586"/> are also good questions. We know that an overridden destructor is only the starting point in the destruction sequence. We also know that, unlike other virtual functions, the derived class destructor will have a unique name from the base class destructor. Even though a derived class destructor automatically overrides a base class destructor that has been declared as <strong class="source-inline">virtual</strong>, the usage of the <em class="italic">optional</em> keyword <strong class="source-inline">override</strong> is recommended in the derived class destructor prototype for documentation. However, the usage of the <em class="italic">optional</em> keyword <strong class="source-inline">virtual</strong> in the derived class destructor is generally no longer used. The reasoning is that the <strong class="source-inline">override</strong> keyword is meant to provide a safety net to catch spelling mistakes between originally defined and overridden functions. With destructors, the function names are not the same, hence<a id="_idIndexMarker587"/> this safety net is not an error-checking advantage, but more <a id="_idIndexMarker588"/>documentative.</p>
<p>Let’s continue by putting all the necessary pieces together so we can see virtual functions of all varieties, including destructors, in action.</p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor382"/>Putting all the pieces together</h2>
<p>So far in this<a id="_idIndexMarker589"/> chapter, we have understood the nuances of virtual functions, including virtual destructors. It is important to see our code in action with all its various components and details. We need to see in one cohesive program the basic syntax to specify virtual functions, including how we may collect derived class instances by base class types, and see how virtual destructors play a role. </p>
<p>Let’s take a look at a more complex, full program example to fully illustrate polymorphism, implemented using virtual functions in C++. This example will be broken into many segments; the full program can be found in the following GitHub location:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter07/Chp7-Ex1.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter07/Chp7-Ex1.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using std::cout;    //preferred to: using namespace std;
using std::endl;
using std::setprecision;
using std::string;
using std::to_string;
constexpr int MAX = 5;
class Person
{
private: 
    string firstName;
    string lastName;
    char middleInitial = '\0';  // in-class initialization
    string title;  // Mr., Ms., Mrs., Miss, Dr., etc.
protected:
    void ModifyTitle(const string &amp;); 
public:
    Person() = default;   // default constructor
    Person(const string &amp;, const string &amp;, char, 
           const string &amp;); 
    // copy constructor =default prototype not needed; we
    // get the default version w/o the =default prototype
    // Person(const Person &amp;) = default;  // copy const.
    <strong class="bold">virtual</strong> ~Person();  // virtual destructor
    const string &amp;GetFirstName() const 
        { return firstName; } 
    const string &amp;GetLastName() const { return lastName; }
    const string &amp;GetTitle() const { return title; } 
    char GetMiddleInitial() const { return middleInitial; }
    <strong class="bold">virtual</strong> void Print() const;
    <strong class="bold">virtual</strong> void IsA() const;  
    <strong class="bold">virtual</strong> void Greeting(const string &amp;) const;
};</pre>
<p>In the aforementioned<a id="_idIndexMarker590"/> class definition, we have augmented our familiar class for <strong class="source-inline">Person</strong>, adding four virtual functions, namely, the destructor (<strong class="source-inline">~Person()</strong>), <strong class="source-inline">Print()</strong>, <strong class="source-inline">IsA()</strong>, and <strong class="source-inline">Greeting(const string &amp;)</strong>. Notice that we have simply placed the keyword <strong class="source-inline">virtual</strong> in front of the return type (if any) of each member function. The remainder of the class definition is as we have e<a id="_idTextAnchor383"/>xplored in depth in the previous chapter.</p>
<p>Now, let’s examine the non-inline member function definitions for <strong class="source-inline">Person</strong>: </p>
<pre class="source-code">
// With in-class initialization, writing the default
// constructor is no longer necessary. 
// Also, remember that strings are member objects and will 
// be default constructed as empty.
// alternate constructor
Person::Person(const string &amp;fn, const string &amp;ln, char mi,
               const string &amp;t): firstName(fn),
               lastName(ln), middleInitial(mi), title(t)
{
    // dynamically allocate memory for any ptr data members 
}
// We are choosing to utilize the default copy constructor. 
// If we wanted to prototype/define it, here's the method:
// Person::Person(const Person &amp;p):
//          firstName(p.firstName), lastName(p.lastName),
//          middleInitial(p.middleInitial), title(p.title)
// { 
    // deep copy any pointer data members here
// }
Person::~Person()
{
    // release memory for any dynamically alloc. data mbrs.
    cout &lt;&lt; "Person destructor &lt;" &lt;&lt; firstName &lt;&lt; " " 
         &lt;&lt; lastName &lt;&lt; "&gt;" &lt;&lt; endl;
}
void Person::ModifyTitle(const string &amp;newTitle)
{   // assignment between strings ensures a deep assignment
    title = newTitle;     
}
void Person::Print() const
{
    cout &lt;&lt; title &lt;&lt; " " &lt;&lt; firstName &lt;&lt; " ";
    cout &lt;&lt; middleInitial &lt;&lt; ". " &lt;&lt; lastName &lt;&lt; endl;
}
void Person::IsA() const
{
    cout &lt;&lt; "Person" &lt;&lt; endl;
}
void Person::Greeting(const string &amp;msg) const
{
    cout &lt;&lt; msg &lt;&lt; endl;
}</pre>
<p>In the previous segment of code, we have specified all of the non-inline member functions of <strong class="source-inline">Person</strong>. Notice that the four virtual functions – the destructor, <strong class="source-inline">Print()</strong>, <strong class="source-inline">IsA()</strong>, and <strong class="source-inline">Greeting()</strong> – do not include the <strong class="source-inline">virtual</strong> keyword in the methods (that is, member function definitions) themselves. </p>
<p>Next, let’s <a id="_idIndexMarker591"/>examine the <strong class="source-inline">Student</strong> class definition and its inline functions:</p>
<pre class="source-code">
class Student: public Person
{
private: 
    float gpa = 0.0;   // in-class initialization
    string currentCourse;
    const string studentId; 
    static int numStudents;  // static data member
public:
    Student();  // default constructor
    Student(const string &amp;, const string &amp;, char, 
            const string &amp;, float, const string &amp;, 
            const string &amp;); 
    Student(const Student &amp;);  // copy constructor
    ~Student() <strong class="bold">override</strong>;  // virtual destructor
    void EarnPhD();  
    // inline function definitions
    float GetGpa() const { return gpa; }
    const string &amp;GetCurrentCourse() const
        { return currentCourse; }
    const string &amp;GetStudentId() const 
        { return studentId; }
    void SetCurrentCourse(const string &amp;); // proto. only
  
    // In the derived class, keyword virtual is optional, 
    // and not currently recommended. Use override instead.
    void Print() const <strong class="bold">final</strong> <strong class="bold">override</strong>;
    void IsA() const <strong class="bold">override</strong>;
    // note: we choose not to redefine 
    // Person::Greeting(const string &amp;) const
    static int GetNumberStudents(); // static mbr. function
};
// definition for static data member 
int Student::numStudents = 0;  // notice initial value of 0
inline void Student::SetCurrentCourse(const string &amp;c)
{
    currentCourse = c;
}
// Definition for static member function (it's also inline)
inline int Student::GetNumberStudents()
{
    return numStudents;
}</pre>
<p>In the previous class definition for <strong class="source-inline">Student</strong>, we again have all of the assorted components we are accustomed to seeing to comprise this class. Additionally, notice that we have overridden and redefined three virtual functions – the destructor, <strong class="source-inline">Print()</strong>, and <strong class="source-inline">IsA()</strong> – using the keyword <strong class="source-inline">override</strong>. These preferred definitions essentially replace or override the default methods specified for these operations in the base class. </p>
<p>Notice, however, that we choose not to redefine <strong class="source-inline">void Person::Greeting(const string &amp;)</strong>, which was introduced as a virtual function in the <strong class="source-inline">Person</strong> class. Simply inheriting this method is fine if we find the inherited definition acceptable for instances of the <strong class="source-inline">Student</strong> class. Furthermore, notice the additional qualification on <strong class="source-inline">Print()</strong> with the <strong class="source-inline">final</strong> qualifier. This keyword indicates that <strong class="source-inline">Print()</strong> may not be overridden in derived classes from <strong class="source-inline">Student</strong>; the method overridden at the <strong class="source-inline">Student</strong> level will be the final implementation.</p>
<p>Recall that the meaning of <strong class="source-inline">override</strong>, when paired with a destructor, is unique, in that it does not imply that the derived class destructor replaces the base class destructor. Instead, it means that the derived class (virtual) destructor is the correct beginning point for the <em class="italic">chain of destruction</em> sequence when initiated by derived class instances (irrespective of how they are stored). The virtual derived class destructor is merely the entry point for<a id="_idIndexMarker592"/> the complete destruction sequence.</p>
<p>Also remember, the derived class of <strong class="source-inline">Student</strong> is not required to override a virtual function that is defined in <strong class="source-inline">Person</strong>. Should the <strong class="source-inline">Student</strong> class find the base class method acceptable, it is automatically inherited. Virtual functions merely allow the derived class to redefine an operation with a more appropriate method when so needed.</p>
<p>Next, let’s examine the non-inline <strong class="source-inline">Student</strong> class member functions:</p>
<pre class="source-code">
Student::Student(): studentId(to_string(numStudents + 100) 
                                        + "Id")
{
   // studentId is const; we need to set at construction. 
   // We're using member init list with a unique id based
   // on numStudents + 100), concatenated with string "Id".
   // Remember, string member currentCourse will be default
   // const. with an empty string (it's a member object)
   numStudents++;     // set static data member
}
// Alternate constructor member function definition
Student::Student(const string &amp;fn, const string &amp;ln, 
                 char mi, const string &amp;t, float avg, 
                 const string &amp;course, const string &amp;id):
                 Person(fn, ln, mi, t), gpa(avg),
                 currentCourse(course), studentId(id)
{
   // dynamically alloc memory for any pointer data members
   numStudents++;
}
// Copy constructor definition
Student::Student(const Student &amp;s) : Person(s),
                gpa(s.gpa), currentCourse(s.currentCourse),
                studentId(s.studentId)
{
   // deep copy any pointer data mbrs of derived class here
   numStudents++;
}
  
// destructor definition
Student::~Student()
{
    // release memory for any dynamically alloc. data mbrs
    cout &lt;&lt; "Student destructor &lt;" &lt;&lt; GetFirstName() &lt;&lt; " "
         &lt;&lt; GetLastName() &lt;&lt; "&gt;" &lt;&lt; endl;
}
void Student::EarnPhD()
{
    ModifyTitle("Dr.");  
}
void Student::Print() const
{   // need to use access functions as these data members 
    // are defined in Person as private
    cout &lt;&lt; GetTitle() &lt;&lt; " " &lt;&lt; GetFirstName() &lt;&lt; " ";
    cout &lt;&lt; GetMiddleInitial() &lt;&lt; ". " &lt;&lt; GetLastName();
    cout &lt;&lt; " with id: " &lt;&lt; studentId &lt;&lt; " GPA: ";
    cout &lt;&lt; setprecision(3) &lt;&lt;  " " &lt;&lt; gpa;
    cout &lt;&lt; " Course: " &lt;&lt; currentCourse &lt;&lt; endl;
}
void Student::IsA() const
{
    cout &lt;&lt; "Student" &lt;&lt; endl;
}</pre>
<p>In the previously listed section of code, we list the non-inline member function definitions for <strong class="source-inline">Student</strong>. Again, notice that the keyword <strong class="source-inline">override</strong> will not appear in any of the virtual <a id="_idIndexMarker593"/>member function definitions themselves, only in their respective prototypes.</p>
<p>Lastly, let’s examine the <strong class="source-inline">main()</strong> function:</p>
<pre class="source-code">
int main()
{
    Person *people[MAX] = { }; // initialize with nullptrs
    people[0] = new Person("Juliet", "Martinez", 'M',
                           "Ms.");
    people[1] = new Student("Hana", "Sato", 'U', "Dr.",
                            3.8, "C++", "178PSU"); 
    people[2] = new Student("Sara", "Kato", 'B', "Dr.",
                            3.9, "C++", "272PSU"); 
    people[3] = new Person("Giselle", "LeBrun", 'R',
                           "Miss");
    people[4] = new Person("Linus", "Van Pelt", 'S',
                           "Mr.");
    // We will soon see a safer and more modern way to loop
    // using a range for loop (starting in Chp. 8). 
    // Meanwhile, let's notice mechanics for accessing 
    // each element.
    for (int i = 0; i &lt; MAX; i++)   
    {
       people[i]-&gt;IsA();
       cout &lt;&lt; "  ";
       people[i]-&gt;Print();
    } 
    for (int i = 0; i &lt; MAX; i++)
       delete people[i];   // engage virtual dest. sequence
    return 0;
}</pre>
<p>Here, in <strong class="source-inline">main()</strong>, we declare an array of pointers to <strong class="source-inline">Person</strong>. Doing so, allows us to collect both <strong class="source-inline">Person</strong> and <strong class="source-inline">Student</strong> instances in this set. Of course, the only operations we may apply to instances stored in this generalized fashion are those found in the base class, <strong class="source-inline">Person</strong>.</p>
<p>Next, we allocate several <strong class="source-inline">Person</strong> and several <strong class="source-inline">Student</strong> instances, storing each instance via an element in the generalized set of pointers. When a <strong class="source-inline">Student</strong> is stored in this fashion, an upcast to the base class type is performed (but the instance is not altered in any fashion). Recall that when we looked at memory layout for derived class instances in <a href="B19087_06.xhtml#_idTextAnchor314"><em class="italic">Chapter 6</em></a>, <em class="italic">Implementing Hierarchies with Single Inheritance</em>, we noticed that a <strong class="source-inline">Student</strong> instance first includes the memory layout of a <strong class="source-inline">Person</strong>, followed by the<a id="_idIndexMarker594"/> additional memory required for <strong class="source-inline">Student</strong> data members. This upcast merely points to the starting point of this collective memory.</p>
<p>Now, we proceed through a loop to apply operations as found in the <strong class="source-inline">Person</strong> class to all instances in this generalized collection. These operations happen to be polymorphic. That is, the virtual functions allow the specific implementation for methods to be called through runtime binding to match the actual object type (irrespective of the fact that the object may be stored in a generalized pointer).</p>
<p>Lastly, we loop through deleting the dynamically allocated instances of <strong class="source-inline">Person</strong> and <strong class="source-inline">Student</strong>, again using the generalized <strong class="source-inline">Person</strong> pointers. Because we know <strong class="source-inline">delete()</strong> will patch in a call to the destructor, we wisely have made the destructors <strong class="source-inline">virtual</strong>, enabling dynamic binding to choose the appropriate starting destructor (in the destruction chain) for each object.</p>
<p>When we look at the output for the aforementioned program, we can see that the specific method for each object is appropriately called for each virtual function, including the destruction sequence. Derived class objects have both the derived, then base class destructor<a id="_idIndexMarker595"/> invoked and executed. Here is the output for the full program example:</p>
<p class="source-code">Person</p>
<p class="source-code">  Ms. Juliet M. Martinez</p>
<p class="source-code">Student</p>
<p class="source-code">  Dr. Hana U. Sato with id: 178PSU GPA:  3.8 Course: C++</p>
<p class="source-code">Student</p>
<p class="source-code">  Dr. Sara B. Kato with id: 272PSU GPA:  3.9 Course: C++</p>
<p class="source-code">Person</p>
<p class="source-code">  Miss Giselle R. LeBrun</p>
<p class="source-code">Person</p>
<p class="source-code">  Mr. Linus S. Van Pelt</p>
<p class="source-code">Person destructor &lt;Juliet Martinez&gt;</p>
<p class="source-code">Student destructor &lt;Hana Sato&gt;</p>
<p class="source-code">Person destructor &lt;Hana Sato&gt;</p>
<p class="source-code">Student destructor &lt;Sara Kato&gt;</p>
<p class="source-code">Person destructor &lt;Sara Kato&gt;</p>
<p class="source-code">Person destructor &lt;Giselle LeBrun&gt;</p>
<p class="source-code">Person destructor &lt;Linus Van Pelt&gt;</p>
<p>Now that we have competency utilizing the concept of polymorphism and the mechanics of<a id="_idIndexMarker596"/> virtual functions, let’s take a look at a less usual situation relating to virtual functions, that of function hiding.</p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor384"/>Considering function hiding</h2>
<p><strong class="bold">Function hiding</strong> is not an <a id="_idIndexMarker597"/>often-used <a id="_idIndexMarker598"/>feature of C++. In fact, it is often employed quite by accident! Let’s review a key point we know about inherited member functions to get started. When an operation is specified by a base class, it is intended to provide a protocol for usage and redefinition (in the case of virtual functions) for all derived class methods. </p>
<p>Sometimes, a derived class will alter the signature of a method that is intended to redefine an operation specified by a base class (let’s think of virtual functions). In this case, the new function, which differs in signature from the operation specified in its ancestor class, will not be considered a virtual redefinition of the inherited operation. In fact, it will <em class="italic">hide</em> inherited methods for the virtual function that have the same name specified in ancestor classes. </p>
<p>When programs are compiled, the signature of each function is compared against the class definition for correct usage. Typically, when a member function is not found in the class that <em class="italic">seemingly</em> matches the instance type, the hierarchy is traversed in an upward fashion until such a match is found or until the hierarchy is exhausted. Let us take a closer look at what the compiler contemplates:</p>
<ul>
<li>When a function is found with the same name as the function being sought out, the signature is examined to see whether it matches the function call exactly, or if type conversion can be applied. When the function is found, but type conversion cannot be applied, the normal traversal sequence is ended.</li>
<li>Functions that hide virtual functions normally halt this upward search sequence, thus hiding a virtual function that otherwise may have been invoked. Recall that at compile time, we are just checking syntax (not deciding which version of a virtual function to call). But if we can’t find a match, an error is flagged.</li>
<li>Function hiding is actually considered helpful and was intended by the language. If the class designer provided a specific function with a given signature and interface, that function should be used for instances of that type. Hidden or unsuspected functions above in the hierarchy should not be used in this specific scenario.</li>
</ul>
<p>Consider the following modification to our previous full program example to, first, illustrate function hiding, and then provide a more flexible solution for managing function hiding:</p>
<ul>
<li>Recall that the <strong class="source-inline">Person</strong> class introduces <strong class="source-inline">virtual void Print()</strong> with no parameters. Imagine that <strong class="source-inline">Student</strong>, instead of overriding <strong class="source-inline">Print()</strong> with the same signature, changes <a id="_idIndexMarker599"/>the <a id="_idIndexMarker600"/>signature to <strong class="source-inline">virtual void Print(const char *)</strong>:<p class="source-code">class Person  // base class</p><p class="source-code">{</p><p class="source-code">    // data members</p><p class="source-code">public:  // member functions, etc. </p><p class="source-code">    <strong class="bold">virtual void Print() const;  </strong></p><p class="source-code">};</p><p class="source-code">class Student: public Person</p><p class="source-code">{</p><p class="source-code">    // data members</p><p class="source-code">public:  // member functions, etc.</p><p class="source-code">    // Newly introduced virtual fn. -- </p><p class="source-code">    // Not a redefinition of Person::Print<a id="_idTextAnchor385"/>()</p><p class="source-code">    <strong class="bold">virtual void Print(const string &amp;) const;</strong></p><p class="source-code">};</p></li>
</ul>
<p>Notice that the signature of <strong class="source-inline">Print()</strong> has changed from base to derived class. The derived class function does not redefine the <strong class="source-inline">virtual void Print();</strong> of its base class. It is a new function that will in fact hide the existence of <strong class="source-inline">Person::Print()</strong>. This is actually what was intended, since you may not recall that the base class offers such an operation, and tracking upward might cause surprising results in your application if you intended <strong class="source-inline">Print(const string &amp;)</strong> to be called but <strong class="source-inline">Print()</strong> is called instead. By adding this new function, the derived class designer is dictating this interface is the appropriate <strong class="source-inline">Print()</strong> for instances of <strong class="source-inline">Student</strong>.</p>
<p>However, nothing is straightforward in C++. For situations where a <strong class="source-inline">Student</strong> is upcast to a <strong class="source-inline">Person</strong>, the <strong class="source-inline">Person::Print()</strong> with no arguments will be called. The <strong class="source-inline">Student::Print(const string &amp;)</strong> is not a virtual redefinition because it does not have the same signature. Hence, the <strong class="source-inline">Person::Print()</strong> will be called for generalized <strong class="source-inline">Student</strong> instances. And yet <strong class="source-inline">Student::Print(const string &amp;)</strong> will be called for <strong class="source-inline">Student</strong> instances stored in <strong class="source-inline">Student</strong> variables. Unfortunately, this is inconsistent with how an instance will behave if it is stored in its own type versus a generalized type. Though function hiding was meant to work in this fashion, it may inevitably <a id="_idIndexMarker601"/>not be <a id="_idIndexMarker602"/>what you would like to happen. Programmers, beware! </p>
<p>Let’s look at some of the cumbersome code that might ensue:</p>
<ul>
<li>Explicit downcasting or use of the scope resolution operator may be required to reveal an otherwise hidden function:<p class="source-code">constexpr int MAX = 2;</p><p class="source-code">int main()</p><p class="source-code">{ </p><p class="source-code">    Person *people[MAX] = { }; // init. with nullptrs</p><p class="source-code">    people[0] = new Person("Jim", "Black", 'M',</p><p class="source-code">                           "Mr.");</p><p class="source-code">    people[1] = new Student("Kim", "Lin", 'Q', "Dr.",</p><p class="source-code">                            3.55, "C++", "334UD"); </p><p class="source-code"> <a id="_idTextAnchor386"/>   people[1]-&gt;Print(); // ok, Person::Print() defined</p><p class="source-code">    // people[1]-&gt;Print("Go Team!"); // error!</p><p class="source-code">    // explicit downcast to derived type assumes you</p><p class="source-code">    // correctly recall what the object is</p><p class="source-code">    (dynamic_cast&lt;Student *&gt; (people[1]))-&gt;</p><p class="source-code">                             Print("I h<a id="_idTextAnchor387"/>ave to study");</p><p class="source-code">    // Student stored in its own type</p><p class="source-code">    Student s1("Jafari", "Kanumba", 'B', "Dr.", 3.9,</p><p class="source-code">               "C++", "845BU"); </p><p class="source-code">    // s1.Print(); // error, base class version hidden</p><p class="source-code"> <a id="_idTextAnchor388"/>   s1.Print("I got an A!"); // works for type Student</p><p class="source-code">    s1.Person::Print(); // works using scope </p><p class="source-code">                      // resolution to base class type</p><p class="source-code">    return 0;</p><p class="source-code">}</p></li>
</ul>
<p>In the <a id="_idIndexMarker603"/>aforementioned <a id="_idIndexMarker604"/>example, we have a generalized set of two <strong class="source-inline">Person</strong> pointers. One entry points to a <strong class="source-inline">Person</strong> and one entry points to a <strong class="source-inline">Student</strong>. Once the <strong class="source-inline">Student</strong> is generalized, the only applicable operations are those found in the <strong class="source-inline">Person</strong> base class. Therefore, a call to <strong class="source-inline">people[1]-&gt;Print();</strong> works and a call to <strong class="source-inline">people[1]-&gt;Print("Go Team!");</strong> does not work. The latter call to <strong class="source-inline">Print(const char *)</strong> is an error at the generalized base class level, even though the object truly is a <strong class="source-inline">Student</strong>.</p>
<p>If, from a generalized pointer, we wish to call specific functions found at the <strong class="source-inline">Student</strong> level in the hierarchy, we will then need to downcast the instance back to its own type (<strong class="source-inline">Student</strong>). We add a downcast with the call: <strong class="source-inline">(dynamic_cast&lt;Student *&gt; (people[1]))-&gt;Print("I have to study");</strong>. Here, we are taking a risk – if <strong class="source-inline">people[1]</strong> was actually a <strong class="source-inline">Person</strong> and not a <strong class="source-inline">Student</strong>, this would generate a runtime error. However, by first checking the result of the dynamic cast to <strong class="source-inline">Student *</strong> prior to invoking <strong class="source-inline">Print()</strong>, we can ensure we have made an appropriate cast. </p>
<p>Next, we instantiate <strong class="source-inline">Student s1;</strong>. Should we try to call <strong class="source-inline">s1.Print()</strong>, we get a compiler error – <strong class="source-inline">Student::Print(const string &amp;)</strong> hides the base class presence of <strong class="source-inline">Person::Print()</strong>. Remember, <strong class="source-inline">s1</strong> is stored in its own type, <strong class="source-inline">Student</strong>, and since <strong class="source-inline">Student::Print(const string &amp;)</strong> is found, the traversal upward to otherwise uncover <strong class="source-inline">Person::Print()</strong> is halted. </p>
<p>Nonetheless, our call to <strong class="source-inline">s1.Print("I got an A!");</strong> is successful because <strong class="source-inline">Print(const string &amp;)</strong> is found at the <strong class="source-inline">Student</strong> class level. Lastly, notice that the call to <strong class="source-inline">s1.Person::Print();</strong> works but requires knowledge of the otherwise hidden function. By using the scope resolution operator (<strong class="source-inline">::</strong>), we can find the base class version of <strong class="source-inline">Print()</strong>. Even though <strong class="source-inline">Print()</strong> is virtual in the base class (implying dynamic binding), using the scope resolution<a id="_idIndexMarker605"/> operation <a id="_idIndexMarker606"/>reverts this call to a statically bound function call.</p>
<p>Let’s propose that we would like to add a new interface to a derived class with a function that would otherwise hide a base class function. Knowing about function hiding, what should we ideally do? We could simply override the virtual function as found in the base class with a new method in the derived class, and then we could overload that function to add the additional interface. Yes, we’re now both overriding and overloading. That is, we are overriding the base class function, and overloading the overridden function in the derived class. </p>
<p>Let’s take a look at what we would now have:</p>
<ul>
<li>Here is the more flexible interface to add the new member function while keeping <a id="_idIndexMarker607"/>the <a id="_idIndexMarker608"/>existing interface that would otherwise be hidden:<p class="source-code">class Person  // base class</p><p class="source-code">{</p><p class="source-code">    // data members</p><p class="source-code">public:  // member functions, etc.</p><p class="source-code">    <strong class="bold">virtual void Print() const;</strong></p><p class="source-code">};</p><p class="source-code">class Student: public Person</p><p class="source-code">{</p><p class="source-code">    // data members</p><p class="source-code">public:  // member functions, etc.</p><p class="source-code">    // Override the base class method so that this</p><p class="source-code">    // interface is not hidden by overloaded fn. below</p><p class="source-code">    <strong class="bold">void Print() const override; </strong></p><p class="source-code">    // add the additional interface </p><p class="source-code">    // (which is overloaded)</p><p class="source-code">    // Note: this additional Print() is virtual</p><p class="source-code">    // from this point forward in the hierarchy</p><p class="source-code">    <strong class="bold">virtual void Print(const string &amp;) const;</strong> </p><p class="source-code">};</p><p class="source-code">int main()</p><p class="source-code">{</p><p class="source-code">    Student s1("Zack", "Doone", 'A', "Dr.", 3.9,</p><p class="source-code">               "C++", "769UMD"); </p><p class="source-code">    s1.Print();  // this version is no longer hidden.</p><p class="source-code">    s1.Print("I got an A!"); // also works</p><p class="source-code">    s1.Person::Print(); // this is no longer necessary</p><p class="source-code">}</p></li>
</ul>
<p>In the preceding code fragment, the <strong class="source-inline">Student</strong> class both overrides <strong class="source-inline">Person::Print()</strong> with <strong class="source-inline">Student::Print()</strong> and overloads <strong class="source-inline">Student::Print()</strong> with <strong class="source-inline">Student::Print(const string &amp;)</strong> to envelop the additional desired interface. Now, for <strong class="source-inline">Student</strong> objects stored in <strong class="source-inline">Student</strong> variables, both interfaces are available – the base class interface is no longer hidden. Of course, <strong class="source-inline">Student</strong> objects referenced by <strong class="source-inline">Person</strong> pointers only have the <strong class="source-inline">Person::Print()</strong> interface, which is to be expected. </p>
<p>Overall, function hiding does not surface often, but when it does, it is often an unwelcome surprise. Now you understand what may happen and why, which helps in making you a better programmer.</p>
<p>Now that we have <a id="_idIndexMarker609"/>looked at all the uses surrounding virtual functions, let’s look under the hood to<a id="_idIndexMarker610"/> see why virtual functions are able to support dynamic binding of a specific method to an operation. To thoroughly understand runtime binding, we will need to look at t<a id="_idTextAnchor389"/>he v-table. Let’s move forward!</p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor390"/>Understanding dynamic binding</h1>
<p>Now that we have <a id="_idIndexMarker611"/>seen how polymorphism is implemented with virtual functions to allow for dynamic binding of an operation to a specific implementation or method, let’s understand why virtual functions allow for runtime binding.</p>
<p>Non-virtual functions are statically bound at compile time. That is, the address of the function in question is determined at compile time, based on the assumed type of the object at hand. For example, if an object is instantiated of type <strong class="source-inline">Student</strong>, a function call would have its prototype verified starting with the <strong class="source-inline">Student</strong> class, and if not found, the hierarchy would be traversed upward to each base class, such as <strong class="source-inline">Person</strong>, to look for the matching prototype. When found, the correct function call would be patched in. This is how static binding works.</p>
<p>However, a virtual function is a type of function in C++ that employs a dynamic binding at runtime. At compile time, any virtual function call is merely replaced with a lookup mechanism to delay binding until runtime. Certainly, each compiler vendor may differ in their implementation of automating virtual functions. However, there is a widely utilized implementation that involves virtual function pointers, a virtual function table, and virtual function table entries for each object type containing virtual functions.</p>
<p>Let’s move forward to investigate how dynamic binding is commonly implemented in C++.</p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor391"/>Comprehending runtime binding of methods to operations</h2>
<p>We know<a id="_idIndexMarker612"/> that virtual functions allow for dynamic binding of an operation (specified in a base class) to a specific implementation or method (often specified in a derived class). How does this work?</p>
<p>When a base class specifies one or more new virtual functions (not just redefinitions of an ancestor’s virtual <a id="_idIndexMarker613"/>functions), a <strong class="bold">virtual function pointer</strong> (<strong class="bold">vptr</strong>) is created below the memory comprising a given instance of that type. This happens at runtime when the memory for an instance is created (on the stack, heap, or static/extern area). When the instance in question is constructed, not only will the appropriate constructor be called to initialize the instance, but this vptr will be initialized to point to the <strong class="bold">virtual function pointer table</strong> (<strong class="bold">v-table</strong>) entry<a id="_idIndexMarker614"/> for that class type.</p>
<p>The v-table entry for a given class type will consist of a set of function pointers. These function pointers are often organized into an array of function pointers. A <strong class="bold">function pointer</strong> is a <a id="_idIndexMarker615"/>pointer to an actual function. By dereferencing this pointer, you will actually invoke the function to which the pointer points. There is an opportunity to pass arguments to the function, however, in order for this call to be generic through a function pointer, the arguments must be uniform for any version of this function that the pointer in question may point to. The premise of a function pointer gives us the ability to point to different versions of a particular function. That is, we could point to different methods for a given operation. This is the basis for which we can automate dynamic binding in C++ for virtual functions.</p>
<p>Let’s consider the particular v-table entry for a specific object type. We know that this table entry will consist of a set of function pointers, such as an array of function pointers. The order in which these function pointers are arranged will be consistent with the order in which the virtual functions are newly introduced by a given class. Functions overriding existing virtual functions that were newly introduced at a higher level in the hierarchy will simply replace table entries with preferred versions of functions to be called, but will <a id="_idIndexMarker616"/>not cause an additional entry to be allocated in the array of function pointers.</p>
<p>So, when the program begins running first in global memory (as a hidden external variable), a v-table will be set up. This table will contain entries for each object type that contains virtual functions. The entry for a given object type will contain a set of function pointers (such as an array of function pointers) that organizes and initializes the dynamically-bound functions for that class. The specific order of the function pointers will correspond to the order in which the virtual functions were introduced (possibly by their ancestor class), and the specific function pointers will be initialized to the preferred versions of these functions for the specific class type in question. That is, the function pointers may point to overridden methods as specified at their own class level.</p>
<p>Then, when an object of a given type is instantiated, the vptr within that object (there will be one per subobject level of newly introduced – not redefined – virtual functions) will be set to point to the corresponding v-table entry for that instance.</p>
<p>It will be useful to see this detail with code and a memory diagram. Let’s look under the<a id="_idTextAnchor392"/> hood to see the code in action!</p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor393"/>Interpreting the v-table in detail</h2>
<p>In order to <a id="_idIndexMarker617"/>detail the memory model and see the <a id="_idIndexMarker618"/>underlying C++ mechanics that will be set up at runtime, let’s consider our detailed, full program example from this section with base class <strong class="source-inline">Person</strong> and derived class <strong class="source-inline">Student</strong>. As a reminder, we will show the key elements of the program:</p>
<ul>
<li>Abbreviated definitions of the <strong class="source-inline">Person</strong> and <strong class="source-inline">Student</strong> classes (we’ll omit the data members and most member function definitions to save space):<p class="source-code">class Person</p><p class="source-code">{</p><p class="source-code">private:   // data members will be as before</p><p class="source-code">protected: // assume all member funcs. are as before,</p><p class="source-code">public:  // but we will show only virtual funcs. here</p><p class="source-code">    <strong class="bold">virtual</strong> ~Person();       // 4 virt fns introduced </p><p class="source-code">    <strong class="bold">virtual</strong> void Print() const;  // in Person class</p><p class="source-code">    <strong class="bold">virtual</strong> void IsA() const;  </p><p class="source-code">    <strong class="bold">virtual</strong> void Greeting(const string &amp;) const;</p><p class="source-code">};</p><p class="source-code">class Student: public Person</p><p class="source-code">{</p><p class="source-code">private:  // data members will be as before</p><p class="source-code">public:   // assume all member funcs. are as before, </p><p class="source-code">    // but we will show only virtual functions here</p><p class="source-code">    ~Student() <strong class="bold">override</strong>;  // 3 virt fns are overridden</p><p class="source-code">    void Print() const <strong class="bold">override</strong>;</p><p class="source-code">    void IsA() const <strong class="bold">override</strong>;</p><p class="source-code">};</p></li>
</ul>
<p>The <strong class="source-inline">Person</strong> and <strong class="source-inline">Student</strong> class definitions are as expected. Assume that the data members and member functions are as shown in the full program example. For brevity, we have just included the virtual functions introduced or redefined at each level. </p>
<ul>
<li>Revisiting key elements of our <strong class="source-inline">main()</strong> function in abbreviated form (reduced to<a id="_idIndexMarker619"/> three <a id="_idIndexMarker620"/>instances):<p class="source-code">constexpr int MAX = 3;</p><p class="source-code">int main()</p><p class="source-code">{</p><p class="source-code">    Person *people[MAX] = { }; // init. with nullptrs</p><p class="source-code">    people[0] = new Person("Joy", "Lin", 'M', "Ms.");</p><p class="source-code">    people[1] = new Student("Renee", "Alexander", 'Z',</p><p class="source-code">                    "Dr.", 3.95,<a id="_idTextAnchor394"/> "C++", "21-MIT"); </p><p class="source-code">    people[2] = new Student("Gabby", "Doone", 'A', </p><p class="source-code">                    "Ms.", 3.95, "C++", "18-GWU"); </p><p class="source-code">    // In Chp. 8, we'll upgrade to a range for loop</p><p class="source-code">    for (int i = 0; i &lt; MAX; i++)</p><p class="source-code">    {                 // at compile time, modified to:</p><p class="source-code">        people[i]-&gt;IsA();  // *(people[i]-&gt;vptr[2])()</p><p class="source-code">        people[i]-&gt;Print();</p><p class="source-code">        people[i]-&gt;Greeting("Hello");</p><p class="source-code">        delete people[i];</p><p class="source-code">    }</p><p class="source-code">    return 0;</p><p class="source-code">}</p></li>
</ul>
<p>Notice in our <strong class="source-inline">main()</strong> function that we instantiate one <strong class="source-inline">Person</strong> instance and two <strong class="source-inline">Student</strong> instances. All are stored in a generic array of pointers of the base class type, <strong class="source-inline">Person</strong>. We then iterate through the set calling virtual functions on each instance, namely <strong class="source-inline">IsA()</strong>, <strong class="source-inline">Print()</strong>, <strong class="source-inline">Greeting()</strong>, and the destructor (which is implicitly called when we delete each instance).</p>
<p>Considering the <a id="_idIndexMarker621"/>memory model for the previous example, we<a id="_idIndexMarker622"/> have the following diagram:</p>
<div>
<div class="IMG---Figure" id="_idContainer036">
<img alt="Figure 7.1 – Memory model for the current example " height="815" src="image/Figure_7.01_B19087.jpg" width="1169"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Memory model for the current example</p>
<p>In the aforementioned memory diagram (which follows the preceding program), notice that we have an array of pointers to the genericized instances of <strong class="source-inline">Person</strong>. The first instance is, in fact, a <strong class="source-inline">Person</strong>, and the second two instances are of type <strong class="source-inline">Student</strong>. But, as a <strong class="source-inline">Student</strong> <em class="italic">Is-A</em> <strong class="source-inline">Person</strong>, it is acceptable to upcast a <strong class="source-inline">Student</strong> to a <strong class="source-inline">Person</strong>. The top part of the memory layout is in fact, a <strong class="source-inline">Person</strong> for each of the <strong class="source-inline">Student</strong> instances. For instances that are in fact of type <strong class="source-inline">Student</strong>, the additional data members for <strong class="source-inline">Student</strong> will follow all the memory required for the <strong class="source-inline">Person</strong> subobject.</p>
<p>Notice that the <strong class="source-inline">vptr</strong> entries immediately follow the data members for the <strong class="source-inline">Person</strong> object (or subobject) for each of the three instances. The location for the <strong class="source-inline">vptr</strong> is the same offset from the top of each object. This is because the virtual functions in question are all introduced at the <strong class="source-inline">Person</strong> level in the hierarchy. Some may be overridden in the <strong class="source-inline">Student</strong> class with more appropriate definitions for <strong class="source-inline">Student</strong>, but the level in which each is introduced is at the <strong class="source-inline">Person</strong> level, hence the <strong class="source-inline">vptr</strong> below the <strong class="source-inline">Person</strong> object (or subobject) will reflect a pointer to the list of operations introduced at the <strong class="source-inline">Person</strong> level.</p>
<p>As an aside, let’s say that <strong class="source-inline">Student</strong> introduced wholly new virtual functions (and not merely redefinitions of existing virtual functions), such as we saw in the previous function hiding scenario. There would then be a second <strong class="source-inline">vptr</strong> entry below the <strong class="source-inline">Student</strong> subobject with those additional (new virtual) operations added.</p>
<p>When each object is instantiated, first the appropriate constructors (proceeding up the hierarchy) will be called for each instance. Additionally, the compiler will patch in a pointer <a id="_idIndexMarker623"/>assignment<a id="_idIndexMarker624"/> for each instance’s <strong class="source-inline">vptr</strong> to be set to the <strong class="source-inline">v-table</strong> entry corresponding to the object’s type. That is, when a <strong class="source-inline">Person</strong> is instantiated, its <strong class="source-inline">vptr</strong> will point to the <strong class="source-inline">v-table</strong> entry for <strong class="source-inline">Person</strong>. When a <strong class="source-inline">Student</strong> is instantiated, its <strong class="source-inline">vptr</strong> will point to the <strong class="source-inline">v-table</strong> entry for <strong class="source-inline">Student</strong>. </p>
<p>Let’s assume that the <strong class="source-inline">v-table</strong> entry for <strong class="source-inline">Person</strong> or <strong class="source-inline">Student</strong> contains an array of function pointers to the appropriate virtual functions for that type. The <strong class="source-inline">v-table</strong> entry for each type actually has more information embedded, such as the size of an instance of that type, and so on. To simplify, we will just look at the portion of the <strong class="source-inline">v-table</strong> entries that automate the dynamic binding for each class type.</p>
<p>Notice that the <strong class="source-inline">v-table</strong> entry for <strong class="source-inline">Person</strong> is an array of four function pointers. Each function pointer will point to the most suitable version of the destructor, <strong class="source-inline">Print()</strong>, <strong class="source-inline">IsA()</strong>, and <strong class="source-inline">Greeting()</strong> for a <strong class="source-inline">Person</strong>. The order in which these function pointers occur corresponds to the order in which these virtual functions were introduced by this class. That is, <strong class="source-inline">vptr[0]</strong> will point to the <strong class="source-inline">Person</strong> destructor, <strong class="source-inline">vptr[1]</strong> will point to <strong class="source-inline">Person::Print()</strong>, and so on.</p>
<p>Now, let’s look at the v-table entry for <strong class="source-inline">Student</strong>. The order in which the virtual functions (as function pointers) are laid into the array is the same order as for the <strong class="source-inline">Person</strong> class. This is because the base class introduced these functions and the ordering in this array of pointers is set by that level. But notice that the actual functions that are pointed to have been overridden for <strong class="source-inline">Student</strong> instances to mostly be methods that were redefined by the derived class, <strong class="source-inline">Student</strong>. That is, the <strong class="source-inline">Student</strong> destructor is specified (as the starting point for destruction), followed by <strong class="source-inline">Student::Print()</strong>, then <strong class="source-inline">Student::IsA()</strong>, and then <strong class="source-inline">Person::Greeting()</strong>. Notice that <strong class="source-inline">vptr[3]</strong> points to <strong class="source-inline">Person::Greeting()</strong>. This is because <strong class="source-inline">Student</strong> did not redefine this function in its class definition; <strong class="source-inline">Student</strong> found the <strong class="source-inline">Person</strong> definition, which is inherited, to be acceptable.</p>
<p>Pairing this memory diagram with the code in our <strong class="source-inline">main()</strong> function, notice that after we instantiate a <strong class="source-inline">Person</strong> and two <strong class="source-inline">Student</strong> instances, storing each in the genericized <strong class="source-inline">Person</strong> array of pointers, we iterate through a loop containing several operations. We uniformly call <strong class="source-inline">people[i]-&gt;Print();</strong>, then <strong class="source-inline">people[i]-&gt;IsA();</strong>, then <strong class="source-inline">people[i]-&gt;Greeting("Hello");</strong>, and then <strong class="source-inline">delete people[i];</strong> (which patches in a destructor call). </p>
<p>Because each of these functions is virtual, the decision as to which function should be called is deferred<a id="_idIndexMarker625"/> to be looked up at runtime. This is <a id="_idIndexMarker626"/>done by accessing each instance’s hidden <strong class="source-inline">vptr</strong> member, indexing into the appropriate <strong class="source-inline">v-table</strong> entry based on the operation at hand, and then dereferencing the function pointer found at that entry to call the appropriate method. The compiler knows, for example, that <strong class="source-inline">vptr[0]</strong> will be the destructor, <strong class="source-inline">vptr[1]</strong> will be the next virtual function introduced in the base class definition, and so on, so that the element position in the v-table that should be activated is easily determined by the name of the polymorphic operation. </p>
<p>Imagine that a call in <strong class="source-inline">main()</strong> to <strong class="source-inline">people[i]-&gt;Print();</strong> was replaced with <strong class="source-inline">*(people[i]-&gt;vptr[1])();</strong>, which is the syntax for dereferencing a function pointer to call the function at hand. Notice that we are first accessing which function using <strong class="source-inline">people[i]-&gt;vptr[1]</strong>, then dereferencing the function pointer using <strong class="source-inline">*</strong>. Notice the parentheses <strong class="source-inline">()</strong>at the end of the statement, which is where any parameters would be passed to the function. Because the code to dereference the function pointer needs to be uniform, the parameters to any such function must also be uniform. That is why any virtual functions overridden in a derived class must use the same signature as specified by the base class. It all makes sense when you look under the hood.</p>
<p>We have now thoroughly examined the OO idea of polymorphism and how it is implemented in C++ using virtual functions. Let’s briefly recap what we’ve covered in this chapter <a id="_idIndexMarker627"/>before moving onward to <a id="_idIndexMarker628"/>our next chapter.</p>
<h1 id="_idParaDest-155"><a id="_idTextAnchor395"/>Summary</h1>
<p>In this chapter, we have moved even further along our journey with object-oriented programming by understanding how virtual functions in C++ provide direct language support for the OO idea of polymorphism. We have seen how virtual functions provide dynamic binding of a specific method to an operation in our inheritance hierarchy.</p>
<p>We have seen how, using virtual functions, an operation specified by a base class can be overridden by a derived class, providing a more suitable implementation. We have seen that the correct method for each object can be selected using runtime binding, regardless of whether the object is stored in its own type or in a generalized type. </p>
<p>We have seen that objects are often generalized using base class pointers and how this can allow the uniform processing of related derived class types. We have seen that, regardless of how an instance is stored (as its own type or as that of a base class using a pointer), the correct version of a virtual function will always be applied through dynamic binding. We have seen that in public inheritance hierarchies where upcasting may be routinely done, having a virtual destructor is essential.</p>
<p>We have also seen how dynamic binding works through examining a typical compiler implementation of embedding a vptr into instances, and how these pointers reference v-table entries (containing sets of member function pointers) relevant to each object type.</p>
<p>We have seen that virtual functions allow us to take advantage of dynamic binding of operations to the most appropriate methods, enabling us to use C++ as an OOP language to implement robust designs featuring polymorphism, which promotes easily extensible code.</p>
<p>By extending our OOP knowledge with the utilization of virtual functions, we can now move forward to include additional object-oriented concepts and details relating to inheritance and polymorphism. Continuing to <a href="B19087_08.xhtml#_idTextAnchor399"><em class="italic">Chapter 8</em></a>, <em class="italic">Mastering Abstract Classes</em>, we will next learn how to employ the OO ideal of abstract classes, along with all the assorted OOP considera<a id="_idTextAnchor396"/>tions surrounding this next object-oriented concept. Let’s continue!</p>
<h1 id="_idParaDest-156"><a id="_idTextAnchor397"/>Questions</h1>
<ol>
<li>Using your <a href="B19087_06.xhtml#_idTextAnchor314"><em class="italic">Chapter 6</em></a>, <em class="italic">Implementing Hierarchies with Single Inheritance</em>, solution, augment your inheritance hiera<a id="_idTextAnchor398"/>rchy to further specialize <strong class="source-inline">Student</strong> with <strong class="source-inline">GraduateStudent</strong> and <strong class="source-inline">NonDegreeStudent</strong>. <ol><li>Add necessary data members to your <strong class="source-inline">GraduateStudent</strong> class. Data members to consider might be <em class="italic">dissertation topic</em> or <em class="italic">graduate advisor</em>. Include appropriate constructors (default, alternate, and copy), a destructor, access member functions, and a suitable public interface. Be sure to place your data members in the private access region. Do the same for <strong class="source-inline">NonDegreeStudent</strong>.</li><li>Add polymorphic operations to <strong class="source-inline">Person</strong>, <strong class="source-inline">Student</strong>, <strong class="source-inline">GraduateStudent</strong>, and <strong class="source-inline">NonDegreeStudent</strong> as necessary. Introduce at the <strong class="source-inline">Person</strong> level virtual functions <strong class="source-inline">IsA()</strong> and <strong class="source-inline">Print()</strong>. Override <strong class="source-inline">IsA()</strong> and <strong class="source-inline">Print()</strong> in your derived classes as necessary. It may be that you override <strong class="source-inline">IsA()</strong> in <strong class="source-inline">Student</strong> and <strong class="source-inline">GraduateStudent</strong>, but choose to override <strong class="source-inline">Print()</strong> only in the <strong class="source-inline">Student()</strong> class. Be sure to include virtual destructors in each of your classes.</li><li>Instantiate <strong class="source-inline">Student</strong>, <strong class="source-inline">GraduateStudent</strong>, <strong class="source-inline">NonDegreeStudent</strong>, and <strong class="source-inline">Person</strong> several times and utilize the appropriate <strong class="source-inline">public</strong> interfaces on each. Be sure to dynamically allocate several instances. </li><li>Create an array of pointers to <strong class="source-inline">Person</strong> and allocate instances of <strong class="source-inline">Person</strong>, <strong class="source-inline">Student</strong>, <strong class="source-inline">GraduateStudent</strong>, and <strong class="source-inline">NonDegreeStudent</strong> to be members of this array. Once generalized, only call polymorphic operations that are found at the <strong class="source-inline">Person</strong> level (and other public methods of <strong class="source-inline">Person</strong>). Be sure to delete any dynamically allocated instances.</li><li>Create an array of pointers to <strong class="source-inline">Student</strong> and allocate only instances of <strong class="source-inline">GraduateStudent</strong> and <strong class="source-inline">NonDegreeStudent</strong> to be members of this array. Now, call operations that are found at the <strong class="source-inline">Student</strong> level to be applied to these generalized instances. Additionally, utilize operations found at the <strong class="source-inline">Person</strong> level – they are inherited and additionally available for generalized <strong class="source-inline">Student</strong> instances. Be sure to delete any dynamically allocated instances pointed to in your array.</li></ol></li>
</ol>
</div>
</div></body></html>