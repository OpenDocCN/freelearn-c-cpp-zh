<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Connecting Qt with Databases</h1>
                </header>
            
            <article>
                
<p>In recent times, most applications integrate with some database for storing information for further processing and future use.</p>
<p>Qt comes with modules and classes that make connecting to databases effortless. The MySql database will be used to illustrate the examples in this chapter, but the same principles will apply to other databases.</p>
<p>By the end of this chapter, you should be able to perform the following:</p>
<ul>
<li>Connect and read from a database</li>
<li>Display and edit database entries via widgets</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">QtSql</h1>
                </header>
            
            <article>
                
<p>The QtSql module comes equipped with classes and drivers for accessing databases. To proceed beyond this point, you should have made the necessary configuration during the installation of Qt on your system to enable database access.</p>
<p>For those on the macOS using Homebrew, remember to issue the command as previously described in <a href="a157893d-287f-42c4-8166-a7d414e09035.xhtml">Chapter 1</a>, <em>Introducing Qt 5</em>.</p>
<p>Linux users have to install the modules and enable the correct flags during compilation to make the QtSql module work, but, for the most part, the instructions in <a href="a157893d-287f-42c4-8166-a7d414e09035.xhtml">Chapter 1</a>, <em>Introducing Qt 5</em>, should suffice.</p>
<p>The QtSql module is comprised of the following layers:</p>
<ul>
<li>UI layer</li>
<li>SQL API layer</li>
<li>Driver layer</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="Images/06e23dc6-4fe5-42d8-bc5c-99a5b04d3d7c.jpg" style="width:36.08em;height:25.50em;" width="3508" height="2480"/></p>
<p> Each level makes use of classes, as illustrated in the preceding diagram.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making the connection</h1>
                </header>
            
            <article>
                
<p>We need to set the grounds for writing our applications, and, in this case, we need to have a running instance of MySql. XAMPP is a good candidate to install to have quick access to a working database.</p>
<div class="packt_infobox"><span>XAMPP is a free and open source, cross-platform web server solution stack package developed by Apache Friends, consisting mainly of the Apache HTTP Server, MariaDB (or MySql) database, and interpreters for scripts written in the PHP and Perl programming languages. Download the latest version from <a href="https://www.apachefriends.org/download.html">https://www.apachefriends.org/download.html</a>.</span></div>
<p>Let's create a database with the following tables by issuing the following statements:</p>
<pre> use contact_db;<br/>   CREATE TABLE IF NOT EXISTS contacts (<br/>   id INT AUTO_INCREMENT,<br/>   last_name VARCHAR(255) NOT NULL,<br/>   first_name VARCHAR(255) NOT NULL,<br/>   phone_number VARCHAR(255) NOT NULL,<br/>   PRIMARY KEY (id)<br/>)  ENGINE=INNODB;</pre>
<p>The name of the database is <kbd>contact_db</kbd>, and it is assumed that you have created it in the MySql instance you installed.</p>
<p>The SQL statements create a table called <kbd>contacts</kbd> with an auto-increment <kbd>id</kbd> field along with,  <kbd>last_name</kbd>, <kbd>first_name</kbd>, and <kbd>phone_number</kbd> fields that store characters.</p>
<p>Now, create a new folder and add a file called <kbd>main.cpp</kbd>. Insert the following lines of code:</p>
<pre>#include &lt;QApplication&gt;<br/>#include &lt;QtSql&gt;<br/>#include &lt;QDebug&gt;<br/>/*<br/> use contact_db;<br/>   CREATE TABLE IF NOT EXISTS contacts (<br/>   id INT AUTO_INCREMENT,<br/>   last_name VARCHAR(255) NOT NULL,<br/>   first_name VARCHAR(255) NOT NULL,<br/>   phone_number VARCHAR(255) NOT NULL,<br/>   PRIMARY KEY (id)<br/>)  ENGINE=INNODB;<br/>*/<br/><strong>int </strong>main(<strong>int </strong>argc, <strong>char </strong>*argv[]) {<br/>   // Setup db connection<br/>   QSqlDatabase db_conn =<br/>           QSqlDatabase::addDatabase("QMYSQL", "contact_db");<br/>   db_conn.setHostName("127.0.0.1");<br/>   db_conn.setDatabaseName("contact_db");<br/>   db_conn.setUserName("root");<br/>   db_conn.setPassword("");<br/>   db_conn.setPort(3306);<br/>   // Error checks<br/>   <strong>if </strong>(!db_conn.open()) {<br/>       qDebug() &lt;&lt; db_conn.lastError();<br/>       <strong>return </strong>1;<br/>   } <strong>else </strong>{<br/>       qDebug() &lt;&lt; "Database connection established !";<br/>   }<br/>}</pre>
<p>To make database connections, we need to include <kbd>QtSql</kbd>. <kbd>QDebug</kbd> provides an output stream where we can write out useful (debugging) information during development to file, device, or standard output.</p>
<p>In the preceding code, the structure of the database table has been commented out, but serves as a reminder in case you have not created it.</p>
<p>To open a connection to a database, a call to <kbd>QSqlDatabase::addDatabase()</kbd> is made. The <kbd>QMYSQL</kbd> parameter is the driver type, and <kbd>contact_db</kbd> is the connection name. A program can have a number of connections to the same database. Furthermore, the <kbd>addDatabase()</kbd> call will return an instance of <kbd>QSqlDatabase</kbd>, which, in essence, is the connection to the database.</p>
<p>This connection, <kbd>db_conn</kbd>, is then initialized with the parameters to make the connection work. The hostname, specific database we want to connect to, username, password, and port number are set on the database connection object, <kbd>db_conn</kbd>:</p>
<pre>db_conn.setHostName("127.0.0.1");<br/>db_conn.setDatabaseName("contact_db");<br/>db_conn.setUserName("root");<br/>db_conn.setPassword("");<br/>db_conn.setPort(3306);</pre>
<p>Depending on a number of situations, you may need to specify more than these parameters to gain access to a database, but, for the most part, this should work. Also, note that the password is an empty string. It is only for illustration purposes. You have to change the password as pertains to your database.</p>
<p>To make the connection, we need to call <kbd>open()</kbd> on the connection object:</p>
<pre>// Error checks<br/><strong>if </strong>(!db_conn.open()) {<br/>   qDebug() &lt;&lt; db_conn.lastError();<br/>   <strong>return </strong>1;<br/>} <strong>else </strong>{<br/>   qDebug() &lt;&lt; "Database connection established !";<br/>}</pre>
<p>A call to <kbd>open()</kbd> will result in a bool being returned to determine whether the connection to the database was successful. <kbd>!db_conn.open()</kbd> tests whether the return value is <kbd>False</kbd>.</p>
<p>Note the way in which we shall compile and run this program.</p>
<p>Issue the following on the command line while you are in the folder where the <kbd>main.cpp</kbd> file is locate:</p>
<pre><strong>% qmake -project</strong></pre>
<p>Open the resulting <kbd>.pro</kbd> file, and add the following lines:</p>
<pre>QT += widgets sql</pre>
<p>We intend to use widgets in the course of this chapter, so it has been listed as the first module to be included. Likewise, we include the SQL module. Proceed with the following commands:</p>
<pre><strong>% qmake</strong><br/><strong>% make</strong><br/><strong>% ./program_executable</strong></pre>
<p>If you get the <kbd>Database connection established!</kbd> response, then it means your program is able to connect to the database smoothly. On the other hand, you may get an error, which will describe the reason why the connection is unable to be established. Go through the following list to ensure you are on the right path when you encounter an error:</p>
<ul>
<li>Ensure the database service is running</li>
<li>Ensure the database you are trying to connect actually exists</li>
<li>Ensure the table given by the schema exists</li>
<li>Ensure the username and password for the database exists</li>
<li>Ensure the Qt was compiled with the MySql module</li>
</ul>
<p>Now, let's update the program so that we can illustrate how to issue the various SQL statements in Qt.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Listing records</h1>
                </header>
            
            <article>
                
<p>In order to execute query statements against the database, we shall make use of the <kbd>QSqlQuery</kbd> class. These statements include data-altering statements, such as <kbd>INSERT</kbd>, <kbd>SELECT</kbd>, and <kbd>UPDATE</kbd>. Data definition statements such as <kbd>CREATE TABLE</kbd> can also be issued.</p>
<p class="mce-root"/>
<p>Consider the following snippet of code to list all entries within the contacts table:</p>
<pre>QSqlQuery statement("SELECT * FROM contacts", db_conn);<br/>QSqlRecord record = statement.record();<br/><strong>while </strong>(statement.next()){<br/>   QString firstName = statement.value(record.indexOf("first_name")).toString();<br/>   QString lastName = statement.value(record.indexOf("last_name")).toString();<br/>   QString phoneNumber = statement.value(record.indexOf("phone_number")).toString();<br/>   qDebug() &lt;&lt; firstName &lt;&lt; " - " &lt;&lt; lastName &lt;&lt; " - " &lt;&lt; phoneNumber;<br/>}</pre>
<p>The query statement and the database connection are passed as parameters to an instance of the <kbd>QSqlQuery</kbd> statement. <kbd>QSqlRecord</kbd> is used to encapsulate a database row or view. We shall use its instance, <kbd>record</kbd>, to get the index of a column in a row. <kbd>statement.record()</kbd> returns field information for the current query.</p>
<p>If there are any rows that match the query in <kbd>statement</kbd>, <kbd>statement.next()</kbd> will allow us to cycle through the returned rows. We can call <kbd>previous()</kbd>, <kbd>first()</kbd>, and <kbd>last()</kbd> to enable us to move back and forth with the returned rows or data.</p>
<p>For each row that is returned and accessed by calling <kbd>statement.next()</kbd>, the <kbd>statement</kbd> object is used to get its corresponding data according to the code, <kbd>statement.value(0).toString()</kbd>. This should return the first column in the row converted to string to be stored in <kbd>firstName</kbd>. Instead of this approach, we can use <kbd>record</kbd>, to obtain the index of the column we are interested in. As such, to extract the first name column, we write <kbd>statement.value(record.indexOf("first_name")).toString()</kbd>.</p>
<p>The <kbd>qDebug()</kbd> call helps to print out the data in <kbd>firstName</kbd>, <kbd>lastName</kbd>, and <kbd>phoneNumber</kbd>, similar to what we would have done using <kbd>cout</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The INSERT operation</h1>
                </header>
            
            <article>
                
<p>To effect a database operation to store data into the database, there are a number of ways to issue out the <kbd>INSERT</kbd> statement.</p>
<p>Consider one form of the <kbd>INSERT</kbd> operation in Qt:</p>
<pre>// Insert new contacts<br/>QSqlQuery insert_statement(db_conn);<br/>insert_statement.prepare("INSERT INTO contacts (last_name, first_name, phone_number)"<br/>                        "VALUES (?, ?, ?)");<br/>insert_statement.addBindValue("Sidle");<br/>insert_statement.addBindValue("Sara");<br/>insert_statement.addBindValue("+14495849555");<br/>insert_statement.exec();</pre>
<p>The <kbd>QSqlQuery</kbd> object, <kbd>insert_statement</kbd>, is instantiated by passing the database connection. Next, the <kbd>INSERT</kbd> statement string is passed to a call to <kbd>prepare()</kbd>. Notice how incomplete our statement is with the use of the three (3) <kbd>?, ?, ?</kbd> (question marks). These question marks will be used as placeholders. To fill these placeholders, the <kbd>addBindValue()</kbd> method is called. The line, <kbd>insert_statement.addBindValue("Sidle")</kbd>, will be used to fill the data in the <kbd>last_name</kbd> column of the <kbd>contacts</kbd> table. The second call to <kbd>addBindValue("Sara")</kbd> will be used to fill the second placeholder.</p>
<p>To execute the statement, the <kbd>insert_statement.exec()</kbd> must be called. The overall effect is that a new record will be inserted into the table.</p>
<p>To change the order in which the data is inserted, we can use the <kbd>insert_statement.bindValue()</kbd> function instead. The <kbd>INSERT</kbd> statement has three (3) positional placeholders, which number from <kbd>0</kbd> up to <kbd>2</kbd>. We can fill the last placeholder first by specifying it as follows:</p>
<pre>insert_statement.prepare("INSERT INTO contacts (last_name, first_name, phone_number)"<br/>                        "VALUES (?, ?, ?)");<br/>insert_statement.bindValue(2, "+144758849555");<br/>insert_statement.bindValue(1, "Brass");<br/>insert_statement.bindValue(0, "Jim");<br/>insert_statement.exec();</pre>
<p>The placeholder for the phone number column is filled first by specifying <kbd>bind(2, "+144758849555")</kbd>, where <kbd>2</kbd> is the index of the <kbd>(phone_number)</kbd> placeholder.</p>
<p>An alternative to using the positions of the placeholders would be to name them. Consider the following <kbd>INSERT</kbd> statement:</p>
<pre>insert_statement.prepare("INSERT INTO contacts (last_name, first_name, phone_number)"<br/>                        "VALUES (:last_name, :first_name, :phone_number)");<br/>insert_statement.bindValue(":last_name", "Brown");<br/>insert_statement.bindValue(":first_name", "Warrick");<br/>insert_statement.bindValue(":phone_number", "+7494588594");<br/>insert_statement.exec();</pre>
<p>Instead of using the index of the position when completing the SQL statement, named placeholders are used to reference the data in the <kbd>VALUES</kbd> part. That way, the name of the placeholders are passed with a corresponding value to every call to <kbd>bindValue()</kbd>.</p>
<p>To persist the data, the <kbd>insert_statement.exec()</kbd> function must be called.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The DELETE operation</h1>
                </header>
            
            <article>
                
<p>The <kbd>DELETE</kbd> operation is another operation that can be performed on a table. To do so, we shall pass a reference to the database connection and pass the <kbd>DELETE</kbd> statement to the <kbd>exec()</kbd> method of <kbd>QSqlQuery</kbd>.</p>
<p>Consider the following snippet:</p>
<pre>// Delete a record<br/>QSqlQuery delete_statement(db_conn);<br/>delete_statement.exec("DELETE FROM contacts WHERE first_name = 'Warrick'");<br/>qDebug() &lt;&lt; "Number of rows affected: " &lt;&lt; delete_statement.numRowsAffected();</pre>
<p><kbd>numRowsAffected()</kbd> is a method that is used to figure out how many records were affected. One benefit of this method is that it helps determine whether our query has changed the database. If it returns <kbd>-1</kbd>, it means that the query's operation produced indeterminate results.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The UPDATE operation</h1>
                </header>
            
            <article>
                
<p>The <kbd>UPDATE</kbd> operation follows the same logic as the <kbd>DELETE</kbd> operation. Consider the following lines of code:</p>
<pre>// Update a record<br/>QSqlQuery update_statement(db_conn);<br/>update_statement.exec("UPDATE contacts SET first_name='Jude' WHERE id=1 ");<br/>qDebug() &lt;&lt; "Number of rows affected: " &lt;&lt; update_statement.numRowsAffected();</pre>
<p>The statement here sets the <kbd>first_name</kbd> of the record with an ID of <kbd>1</kbd> to <kbd>'Jude'</kbd>. <kbd>update_statement.numRowsAffected()</kbd> will return nothing, especially in the case where the first record in the table with <kbd>id=1</kbd> is missing. Do take note of this.</p>
<p>The full program to illustrate the major operations is outlined as follows:</p>
<pre>#include &lt;QApplication&gt;<br/>#include &lt;QtSql&gt;<br/>#include &lt;QDebug&gt;<br/><strong>int </strong>main(<strong>int </strong>argc, <strong>char </strong>*argv[]) {<br/>   // Setup db connection<br/>   QSqlDatabase db_conn =<br/>           QSqlDatabase::addDatabase("QMYSQL", "contact_db");<br/>   db_conn.setHostName("127.0.0.1");<br/>   db_conn.setDatabaseName("contact_db");<br/>   db_conn.setUserName("root");<br/>   db_conn.setPassword("");<br/>   db_conn.setPort(3306);<br/>   // Error checks<br/>   <strong>if </strong>(!db_conn.open()) {<br/>       qDebug() &lt;&lt; db_conn.lastError();<br/>       <strong>return </strong>1;<br/>   } <strong>else </strong>{<br/>       qDebug() &lt;&lt; "Database connection established !";<br/>   }<br/>   // Create table<br/>   QString table_definition = "use contact_db;\n"<br/>                           "    CREATE TABLE IF NOT EXISTS contacts (\n"<br/>                           "    id INT AUTO_INCREMENT,\n"<br/>                           "    last_name VARCHAR(255) NOT NULL,\n"<br/>                           "    first_name VARCHAR(255) NOT NULL,\n"<br/>                           "    phone_number VARCHAR(255) NOT NULL,\n"<br/>                           "    PRIMARY KEY (id)\n"<br/>                           ")  ENGINE=INNODB;";<br/>   QSqlQuery table_creator(table_definition, db_conn);<br/>   // Issue SELECT statement<br/>   QSqlQuery statement("SELECT * FROM contacts", db_conn);<br/>   QSqlRecord record = statement.record();<br/>   <strong>while </strong>(statement.next()){<br/>       QString firstName = <br/>       statement.value(record.indexOf("first_name")).toString();<br/>       QString lastName =<br/>       statement.value(record.indexOf("last_name")).toString();<br/>       QString phoneNumber = <br/>       statement.value(record.indexOf("phone_number")).toString();<br/>       qDebug() &lt;&lt; firstName &lt;&lt; " - " &lt;&lt; lastName &lt;&lt; " - " &lt;&lt; <br/>       phoneNumber;<br/>   }<br/>   // Insert new contacts<br/>   QSqlQuery insert_statement(db_conn);<br/>   insert_statement.prepare("INSERT INTO contacts (last_name, <br/>   first_name, phone_number)"<br/>                            "VALUES (?, ?, ?)");<br/>   insert_statement.addBindValue("Sidle");<br/>   insert_statement.addBindValue("Sara");<br/>   insert_statement.addBindValue("+14495849555");<br/>   insert_statement.exec();<br/>   //QSqlQuery insert_statement(db_conn);<br/>   insert_statement.prepare("INSERT INTO contacts (last_name, <br/>   first_name, phone_number)"<br/>                            "VALUES (?, ?, ?)");<br/>   insert_statement.bindValue(2, "+144758849555");<br/>   insert_statement.bindValue(1, "Brass");<br/>   insert_statement.bindValue(0, "Jim");<br/>   insert_statement.exec();<br/>   insert_statement.prepare("INSERT INTO contacts (last_name, <br/>   first_name, phone_number)"<br/>                            "VALUES (:last_name, :first_name,<br/>                            :phone_number)");<br/>   insert_statement.bindValue(":last_name", "Brown");<br/>   insert_statement.bindValue(":first_name", "Warrick");<br/>   insert_statement.bindValue(":phone_number", "+7494588594");<br/>   insert_statement.exec();<br/>   // Delete a record<br/>   QSqlQuery delete_statement(db_conn);<br/>   delete_statement.exec("DELETE FROM contacts WHERE first_name = <br/>   'Warrick'");<br/>   qDebug() &lt;&lt; "Number of rows affected: " &lt;&lt; <br/>   delete_statement.numRowsAffected();<br/>   // Update a record<br/>   QSqlQuery update_statement(db_conn);<br/>   update_statement.exec("UPDATE contacts SET first_name='Jude' WHERE <br/>   id=1 ");<br/>   qDebug() &lt;&lt; "Number of rows affected: " &lt;&lt; <br/>   update_statement.numRowsAffected();<br/>}</pre>
<p>Of particular importance is how the database table is created. From the preceding code listing, the <kbd>QString</kbd> instance, <kbd>table_definition</kbd>, holds the structure of the table we are about to create. The table is created when <kbd>table_definition</kbd> and the database connection are passed to an instance of <kbd>QSqlQuery</kbd>. That's all it takes to create a table.</p>
<p>Compile and run the program.</p>
<div class="packt_infobox">Remember to edit the <kbd>.pro</kbd> file to include the <kbd>sql</kbd> module.</div>
<p>A typical output of the program run from the command is given as follows:</p>
<pre><strong>./dbBasics.app/Contents/MacOS/dbBasics</strong><br/><strong>Database connection established !</strong><br/><strong>"Jude"  -  "Sidle"  -  "+14495849555"</strong><br/><strong>"Brass"  -  "Jim"  -  "+144758849555"</strong><br/><strong>Number of rows affected:  1</strong><br/><strong>Number of rows affected:  0</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using a data model for database access</h1>
                </header>
            
            <article>
                
<p>There are two classes that can be used in accessing the database. These are the <kbd>QSqlTableModel</kbd> and  <kbd>QSqlQueryModel</kbd> classes. The <kbd>QSqlQueryModel</kbd> class only provides a read-only model to the database. <kbd>QSqlTableModel</kbd> provides both read and write model access to the database.</p>
<p>In application development, you are confronted with the challenge of how to present data and to maintain a relationship between data and presentation (view) such that changes to the data are reflected in the view.</p>
<p>In the early days of the PHP language, data, presentation, and business logic were all jumbled up in one or more scripts. This made debugging and eventual code maintenance a nightmare. This same dilemma does crop up from time to time in language and framework design.</p>
<p>The <strong>Model-View-Controller</strong> (<span><strong>MVC</strong></span>) approach is an attempt to solve this problem. It recognizes that one critical piece of software is data. By recognizing this, it abstracts the data into what is called a model. A model is basically a representation of the data in a software. This data can be a list of strings or integers. It can be the folders and files under a parent folder. The data can also be a list of rows that have been returned from a query against a database.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>This data that has been obtained needs to displayed or presented to the user. The component(s) through which the data is piped is called the view. For example, an HTML page showing a list of student names can be called a view. In Qt, there are a number of widgets that can be used to display data in a model. Some typical views for data presentation are as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/53964bc3-b460-4fb7-b758-6a1b0e60b01d.png" width="953" height="214"/></p>
<p>These view classes are optimized for the displaying of information such that, when they are associated with a model, a change in the model will cause the view to be automatically updated. The view maintains its own state and gets informed when there are changes in the model.</p>
<p>For instance, when a list of names is displayed in a <kbd>QListView</kbd>, a call to <kbd>remove()</kbd> on the model will both remove the item from the model's list and also update the view by reducing the number of items on display.</p>
<p>Instead of writing code to update the view, the view class does so on our behalf. Let's create a sample project that will make use of a model to access data from a database:</p>
<p>Create a new folder and, within it, create a file named <kbd>main.cpp</kbd>. Copy over the following lines of code into <kbd>main.cpp</kbd>:</p>
<pre>#include &lt;QtSql&gt;<br/>#include &lt;QDebug&gt;<br/>/*<br/><strong>int </strong>main(<strong>int </strong>argc, <strong>char </strong>*argv[])<br/>{<br/>   // Setup db connection<br/>   QSqlDatabase db_conn =<br/>           QSqlDatabase::addDatabase("QMYSQL", "contact_db");<br/>   db_conn.setHostName("127.0.0.1");<br/>   db_conn.setDatabaseName("contact_db");<br/>   db_conn.setUserName("root");<br/>   db_conn.setPassword("");<br/>   db_conn.setPort(3306);<br/>   // Error checks<br/>   <strong>if </strong>(!db_conn.open()) {<br/>       qDebug() &lt;&lt; db_conn.lastError(); <strong>return </strong>1;<br/>   }<br/>   // Use Database model<br/>   QSqlTableModel *contactsTableModel = <strong>new </strong>QSqlTableModel(0, db_conn);<br/>   contactsTableModel-&gt;setTable("contacts");<br/>   contactsTableModel-&gt;select();<br/>   <strong>for </strong>(<strong>int </strong>i = 0; i &lt; contactsTableModel-&gt;rowCount(); ++i) {<br/>       QSqlRecord record = contactsTableModel-&gt;record(i);<br/>       QString id = record.value("id").toString();<br/>       QString last_name = record.value("last_name").toString();<br/>       QString first_name = record.value("first_name").toString();<br/>       QString phone_number = record.value("phone_number").toString();<br/>       qDebug() &lt;&lt; id  &lt;&lt; " : " &lt;&lt; first_name &lt;&lt; " : " &lt;&lt; last_name &lt;&lt; " : " &lt;&lt; phone_number;<br/>   }<br/>   // Insert Row<br/>   <strong>int </strong>row = contactsTableModel-&gt;rowCount();<br/>   contactsTableModel-&gt;insertRows(row, 1);<br/>   contactsTableModel-&gt;setData(contactsTableModel-&gt;index(row, 1), "Stokes");<br/>   contactsTableModel-&gt;setData(contactsTableModel-&gt;index(row, 2), "Nick");<br/>   contactsTableModel-&gt;setData(contactsTableModel-&gt;index(row, 3), "+443569948");<br/>   contactsTableModel-&gt;submitAll();<br/>   // Custom filter<br/>   qDebug() &lt;&lt; "\nCustom filter: \n";<br/>   contactsTableModel-&gt;setFilter("id=12 AND last_name like'Stokes'");<br/>   contactsTableModel-&gt;select();<br/>   <strong>for </strong>(<strong>int </strong>i = 0; i &lt; contactsTableModel-&gt;rowCount(); ++i) {<br/>       QSqlRecord record = contactsTableModel-&gt;record(i);<br/>       QString id = record.value("id").toString();<br/>       QString last_name = record.value("last_name").toString();<br/>       QString first_name = record.value("first_name").toString();<br/>       QString phone_number = record.value("phone_number").toString();<br/>       qDebug() &lt;&lt; id  &lt;&lt; " : " &lt;&lt; first_name &lt;&lt; " : " &lt;&lt; last_name &lt;&lt; " : " &lt;&lt; phone_number;<br/>   }<br/>}</pre>
<p>The purpose of this program is to connect to a database, list the rows in a particular table, and issue a <kbd>SELECT</kbd> statement against it.</p>
<p class="mce-root"/>
<p>After establishing a connection to the database, we create an instance of <kbd>QSqlTableModel</kbd> with the line, <kbd>QSqlTableModel *contactsTableModel = new QSqlTableModel(0, db_conn);</kbd>. This instance receives as arguments a pointer to a parent object and a connection to the database connection. This <kbd>QSqlTableModel</kbd> model allows for editing of the rows in a table too.</p>
<p>To select the table within the database we wish to manipulate, a call to the <kbd>setTable()</kbd> method is called on <kbd>contactsTableModel</kbd>. The <kbd>contacts</kbd> string is passed as the name of the table.</p>
<p>To populate the <kbd>contactsTableModel</kbd> model with the information in the table, a call to <kbd>select()</kbd> is issued. A loop is now used to iterate over the data in the model:</p>
<pre><strong>for </strong>(<strong>int </strong>i = 0; i &lt; contactsTableModel-&gt;rowCount(); ++i) {<br/>   QSqlRecord record = contactsTableModel-&gt;record(i);<br/>   QString id = record.value("id").toString();<br/>   QString last_name = record.value("last_name").toString();<br/>   QString first_name = record.value("first_name").toString();<br/>   QString phone_number = record.value("phone_number").toString();<br/>   qDebug() &lt;&lt; id  &lt;&lt; " : " &lt;&lt; first_name &lt;&lt; " : " &lt;&lt; last_name &lt;&lt; " : " &lt;&lt; phone_number;<br/>}</pre>
<p>Each row in the table is obtained by using an index. An index of <kbd>0</kbd> here refers to the first item in the model. This index is not tied to the <strong>primary key</strong> in the table. It is instead a simple way to reference the rows in the table.</p>
<p>The <kbd>rowCount()</kbd> method is useful as it helps in knowing the total row count associated with the latest <kbd>SELECT</kbd> statement.</p>
<p>To obtain each row in the table, the index in the loop, <kbd>i</kbd>, is passed to <kbd>contactsTableModel-&gt;record(i)</kbd>. The <kbd>QSqlRecord</kbd> instance will hold a reference to a row in the table, which was returned by calling <kbd>record(i)</kbd>.</p>
<p>For each row, the value stored at the intersecting column is obtained by passing the name of the column to <kbd>value</kbd>. As such, <kbd>record.value("id")</kbd> will return the value stored in the column <kbd>id</kbd> of the contact table. <kbd>toString()</kbd> returns the output as a string. This same call is issued to obtain the values for <kbd>last_name</kbd>, <kbd>first_name</kbd>, and <kbd>phone_number</kbd> for each row (<kbd>QSqlRecord</kbd> record) in the table.</p>
<p>The <kbd>qDebug()</kbd> statement is then used to output all the values for each row.</p>
<p class="mce-root"/>
<p>Since <kbd>QSqlTableModel</kbd> allows for editing of the table, the following statement inserts a new row with data:</p>
<pre>// Insert Row<br/><strong>int </strong>row = contactsTableModel-&gt;rowCount();<br/>contactsTableModel-&gt;insertRows(row, 1);<br/>contactsTableModel-&gt;setData(contactsTableModel-&gt;index(row, 1), "Stokes");<br/>contactsTableModel-&gt;setData(contactsTableModel-&gt;index(row, 2), "Nick");<br/>contactsTableModel-&gt;setData(contactsTableModel-&gt;index(row, 3), "+443569948");<br/>contactsTableModel-&gt;submitAll();</pre>
<p>The total items in the table are obtained by calling <kbd>rowCount()</kbd>. To insert a single row into the table, a call to <kbd>insertRows(row, 1)</kbd> is made. The single row here is represented by <kbd>1</kbd> at position <kbd>row</kbd>.</p>
<p>At column <kbd>1</kbd>, the <kbd>last_name</kbd> column of the new row gets the value <kbd>"Stokes"</kbd>, after the call to <kbd>setData()</kbd>. <kbd>contactsTableModel-&gt;index(row,1)</kbd> represents the index where <kbd>"Stokes"</kbd> is to be inserted.</p>
<p>To persist the data, a call to <kbd>submitAll()</kbd> is issued. This will write off any changes that are lingering on in memory to the database.</p>
<p>Note at this point that the model has become the interface for accessing the data in the database. We also do not need to know the specific query that the statements map to for the different kinds of database the application talks to. This is a huge advantage.</p>
<p>If this model were associated with a view, the newly inserted row would be populated onto the screen without any code to perform such an operation.</p>
<p>In order to refine the select statement, the <kbd>setFilter()</kbd> method is used:</p>
<pre>// Custom filter<br/>qDebug() &lt;&lt; "\nCustom filter: \n";<br/>contactsTableModel-&gt;setFilter("id=12 AND last_name like 'Stokes'");<br/>contactsTableModel-&gt;select();</pre>
<p>The <kbd>WHERE</kbd> clause part of the SQL statement is what is passed to <kbd>setFilter()</kbd>. The <kbd>WHERE</kbd> clause, in this case, is selecting rows from the table where the <kbd>id</kbd> is equal to <kbd>12</kbd> and the <kbd>last_name</kbd> field is <kbd>'Stokes'</kbd>.</p>
<p>To apply the filter, call the <kbd>select()</kbd> method on <kbd>contactsTableModel</kbd>. The loop is then used to iterate over the results.</p>
<p>Compile and run the project:</p>
<pre><strong>% qmake -project</strong></pre>
<p>Be sure to include the following line in the <kbd>.pro</kbd> file:</p>
<pre>QT += sql widgets</pre>
<p>Compile and run the project:</p>
<pre><strong>% qmake</strong><br/><strong>% make</strong><br/><strong>% ./executable_file</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Displaying the model</h1>
                </header>
            
            <article>
                
<p>In the previous section, we saw how to access the database using the model as an abstraction. Now, we shall try to link it with a model for display. Using the code listing from the previous section, modify <kbd>main.cpp</kbd> to appear as follows:</p>
<pre>#include &lt;QApplication&gt;<br/>#include &lt;QtSql&gt;<br/>#include &lt;QVBoxLayout&gt;<br/>#include &lt;QPushButton&gt;<br/>#include &lt;QDebug&gt;<br/>#include &lt;Qt&gt;<br/>#include &lt;QTableView&gt;<br/>#include &lt;QHeaderView&gt;<br/><strong>int </strong>main(<strong>int </strong>argc, <strong>char </strong>*argv[])<br/>{<br/>   QApplication app(argc, argv);<br/>   // Setup db connection<br/>   QSqlDatabase db_conn =<br/>           QSqlDatabase::addDatabase("QMYSQL", "contact_db");<br/>   db_conn.setHostName("127.0.0.1");<br/>   db_conn.setDatabaseName("contact_db");<br/>   db_conn.setUserName("root");<br/>   db_conn.setPassword("");<br/>   db_conn.setPort(3306);<br/>   // Error checks<br/>   <strong>if </strong>(!db_conn.open()) {<br/>       qDebug() &lt;&lt; db_conn.lastError(); <strong>return </strong>1;<br/>   }</pre>
<p>Because we want to display the model, the widgets classes have been included. The database connections remain the same.</p>
<p>Now, add the following lines of code to <kbd>main.cpp</kbd>:</p>
<pre><strong>enum </strong>{<br/>   ID = 0,<br/>   LastName = 1,<br/>   FirstName = 2,<br/>   PhoneNumber = 3,<br/>};<br/>QSqlTableModel *contactsTableModel = <strong>new </strong>QSqlTableModel(0, db_conn);<br/>contactsTableModel-&gt;setTable("contacts");<br/>contactsTableModel-&gt;select();<br/>contactsTableModel-&gt;setHeaderData(ID, Qt::Horizontal, QObject::tr("ID"));<br/>contactsTableModel-&gt;setHeaderData(LastName, Qt::Horizontal, QObject::tr("Last Name"));<br/>contactsTableModel-&gt;setHeaderData(FirstName, Qt::Horizontal, QObject::tr("First Name"));<br/>contactsTableModel-&gt;setHeaderData(PhoneNumber, Qt::Horizontal, QObject::tr("Phone Number"));<br/>contactsTableModel-&gt;setEditStrategy(<br/>       QSqlTableModel::OnManualSubmit);</pre>
<p>Instead of using magic numbers such as <kbd>0</kbd>, <kbd>1</kbd>, and so on, enumerators provide some context for the constants <kbd>0</kbd>, <kbd>1</kbd>, and so on.</p>
<p>An instance of <kbd>QSqlTableModel</kbd> is created using the connection object, <kbd>db_conn</kbd>. The database table, <kbd>contacts</kbd>, is selected for operations. When a model is being displayed, headers are used to label the columns. To set this, we pass the enumeration values and the name that the column should bear. For instance, calling <kbd>setHeaderData(FirstName, Qt::Horizontal, QObject::tr("First Name"))</kbd> will set the first column, <kbd>FirstName</kbd> (whose real value is 0), to display <kbd>"First Name"</kbd>, horizontally.</p>
<p>We said that the <kbd>Model-View</kbd> concept has an added benefit in that changes made to the view can be made to reflect in the database without writing extra code:</p>
<pre>contactsTableModel-&gt;setEditStrategy(<br/>       QSqlTableModel::OnManualSubmit);</pre>
<p>The preceding lines stipulate that changes to the data displayed in the view should not be propagated to the database. Instead, an independent process should trigger the syncing of the view with the data in the database. In contrast to making the syncing process a manual one, replace the code that has been commented out:</p>
<pre>//contactsTableModel-&gt;setEditStrategy(<br/>//        QSqlTableModel::OnRowChange);</pre>
<p><kbd>setEditStrategy(QSqlTableModel::OnRowChange)</kbd> means that changes made to the data via the view will reflect in the database when the data in the row has changed. We will see more of this when we run the completed program.</p>
<p>Since we have created the model, it is time to add the view. Add the following lines of code to <kbd>main.cpp</kbd>:</p>
<pre>//contactsTableModel-&gt;setEditStrategy(<br/>//        QSqlTableModel::OnRowChange);<br/>// continue from here ...<br/>QTableView *contactsTableView = <strong>new </strong>QTableView();<br/>contactsTableView-&gt;setModel(contactsTableModel);<br/>contactsTableView-&gt;setSelectionMode(QAbstractItemView::SingleSelection);<br/>contactsTableView-&gt;setSelectionBehavior(QAbstractItemView::SelectRows);<br/>QHeaderView *header = contactsTableView-&gt;horizontalHeader();<br/>header-&gt;setStretchLastSection(<strong>true</strong>);</pre>
<p>To show the entries in the database table, the view class, <kbd>QTableView</kbd>, is used here. The <kbd>QTableView</kbd> class is special in that it is a class with an implementation of a model and view all-in-one. That means that internally, this class has an internal model where data can be inserted for display. For our purposes, we shall replace this model.</p>
<p><kbd>QTableView</kbd> presents data in a tabular form with rows and columns. We are choosing to use this view since it resembles how data is organized in a relational database.</p>
<p>After an instance of <kbd>QTableView</kbd> has been instantiated, we set the model to <kbd>contactsTableModel</kbd>, which is the model we created by ourselves by calling the <kbd>setModel()</kbd> method.</p>
<p>The selection of items in the table is restricted to a single item when the <kbd>setSelectionMode()</kbd> method is called. If we want to allow multiple selections in the table, then the <kbd>QAbstractItemView::MultiSelection</kbd> constant should be passed to <kbd>setSelectionMode()</kbd>. The selection, in this case, is made by clicking and dragging the mouse over the items in the table in which you have an interest.</p>
<p>In order to specify what can be selected, the <kbd>QAbstractItemView::SelectRows</kbd> constant is passed to <kbd>setSelectionBehavior()</kbd>. This constant allows for only entire rows to be selected.</p>
<p>When <kbd>QTableView</kbd> is rendered, there is unused space to the right of the widget.</p>
<p>This problem is illustrated in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-353 image-border" src="Images/73e108c7-9b95-4e45-a6c1-666b1d52811e.png" style="width:37.75em;height:19.08em;" width="1173" height="594"/></p>
<p>Consider how the space marked <span class="packt_screen">Empty space</span> presents a gaping hole in the interface.</p>
<p>In order to make the last column stretch to fill the containing widget, we need to obtain an instance of the header object of <kbd>QTableView</kbd> and set the desired property, <kbd>setStretchLastSection()</kbd>, to <kbd>true</kbd>, as in the following code:</p>
<pre>QHeaderView *header = contactsTableView-&gt;horizontalHeader();<br/>header-&gt;setStretchLastSection(<strong>true</strong>);</pre>
<p>At this point, we need to construct a simple window and layout for the application. Add the following lines to <kbd>main.cpp</kbd>:</p>
<pre>QWidget window;<br/>QVBoxLayout *layout = <strong>new </strong>QVBoxLayout();<br/>QPushButton *saveToDbPushButton = <strong>new </strong>QPushButton("Save Changes");<br/>layout-&gt;addWidget(contactsTableView);<br/>layout-&gt;addWidget(saveToDbPushButton);</pre>
<p>A <kbd>QVBoxLayout</kbd> instance will serve as the main layout for the application window. Changes made to the entries in the table will not be persisted to the database. We have intentionally made it thus, in order to use a button to manually write changes to the database. As such, a <kbd>QPushButton</kbd> instance is created. The table and button are added to the layout object.</p>
<p>The last lines of code for <kbd>main.cpp</kbd> are as follows:</p>
<pre>   QObject::connect(saveToDbPushButton, SIGNAL(clicked()), contactsTableModel, SLOT(submitAll()));<br/> window.setLayout(layout);<br/> window.show();<br/> <strong>return </strong>app.exec();<br/>}</pre>
<p>The <kbd>clicked()</kbd> signal of the <kbd>saveToDbPushButton</kbd> object is connected to the <kbd>submitAll()</kbd> slot of the model, <kbd>contactsTableModel</kbd>. After making changes to the entries on the table in the application, clicking the <span class="packt_screen">Push</span> button will write the changes to the database.</p>
<p>The rest of the code reads the same as always.</p>
<p>To compile the application, perform the following commands:</p>
<pre><strong>% qmake -project</strong></pre>
<p>Make sure the <kbd>QT</kbd> variable in the <kbd>.pro</kbd> file has the following line:</p>
<pre>QT += widgets sql</pre>
<p>Continue with the following commands:</p>
<pre><strong>% qmake</strong><br/><strong>% make</strong><br/><strong>% ./name_of_executable</strong></pre>
<p>The output of the application will populate a list in the table, assuming the contacts table is not empty:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-354 image-border" src="Images/8c61b503-f8ac-4fad-a837-1ea0eee6eb38.png" style="width:34.33em;height:16.42em;" width="1027" height="490"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Note how the last column has extended all the way to the edge of the window. From the preceding screenshot, you can see data that has already been persisted in the database. Double-click on any of the cells and edit its content. Click on the <span class="packt_screen">Save Changes</span> button. When you visit the database, you will see that the changes in the application have been reflected in the app.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter illustrated how to connect to databases when developing Qt applications. We learned how to use models to serve as an abstraction for manipulating data in a database. Finally, the information in the database table was displayed with the aid of <kbd>Model-View</kbd> classes. These classes make it easy to extract data for display, while allowing changes made in the view to be propagated to the database.</p>


            </article>

            
        </section>
    </div>



  </body></html>