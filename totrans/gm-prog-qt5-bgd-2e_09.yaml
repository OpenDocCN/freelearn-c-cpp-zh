- en: OpenGL and Vulkan in Qt applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt应用程序中的OpenGL和Vulkan
- en: Hardware acceleration is crucial for implementing modern games with advanced
    graphics effects. Qt Widgets module uses traditional approach optimized for CPU-based
    rendering. Even though you can make any widget use OpenGL, the performance will
    usually not be maximized. However, Qt allows you to use OpenGL or Vulkan directly
    to create high-performance graphics limited only by the graphics card's processing
    power. In this chapter, you will learn about employing your OpenGL and Vulkan
    skills to display fast 3D graphics. If you are not familiar with these technologies,
    this chapter should give you a kickstart for further research in this topic. We
    will also describe multiple Qt helper classes that simplify usage of OpenGL textures,
    shaders, and buffers. By the end of the chapter, you will be able to create 2D
    and 3D graphics for your games using OpenGL and Vulkan classes offered by Qt and
    integrate them with the rest of the user interface.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实现具有高级图形效果的现代游戏来说，硬件加速至关重要。Qt Widgets模块使用针对基于CPU渲染的传统方法进行优化的方法。尽管你可以让任何小部件使用OpenGL，但性能通常不会最大化。然而，Qt允许你直接使用OpenGL或Vulkan来创建高性能的图形，其性能仅受显卡处理能力的限制。在本章中，你将学习如何利用你的OpenGL和Vulkan技能来显示快速3D图形。如果你不熟悉这些技术，本章应该能为你在这个主题上的进一步研究提供一个起点。我们还将描述多个Qt辅助类，这些类简化了OpenGL纹理、着色器和缓冲区的使用。到本章结束时，你将能够使用Qt提供的OpenGL和Vulkan类创建2D和3D图形，并将它们与用户界面的其余部分集成。
- en: 'The main topics covered in this chapter are as listed:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主要主题如下：
- en: OpenGL in Qt applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt应用程序中的OpenGL
- en: Immediate mode
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即模式
- en: Textures
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理
- en: Shaders
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 着色器
- en: OpenGL buffers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL缓冲区
- en: Vulkan in Qt applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt应用程序中的Vulkan
- en: Introduction to OpenGL with Qt
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Qt的OpenGL简介
- en: We are not experts on OpenGL, so in this part of the chapter, we will not teach
    you to do any fancy stuff with OpenGL and Qt but will show you how to enable the
    use of your OpenGL skills in Qt applications. There are a lot of tutorials and
    courses on OpenGL out there, so if you're not that skilled with OpenGL, you can
    still benefit from what is described here by employing the knowledge gained here
    to more easily learn fancy stuff. You can use external materials and a high-level
    API offered by Qt, which will speed up many of the tasks described in the tutorials.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是OpenGL的专家，所以在本章的这一部分，我们不会教你如何使用OpenGL和Qt做任何花哨的事情，而是会向你展示如何在Qt应用程序中启用你的OpenGL技能。关于OpenGL有很多教程和课程，所以如果你对OpenGL不是很熟练，你仍然可以通过应用在这里获得的知识来更容易地学习花哨的东西。你可以使用外部材料和Qt提供的高级API，这将加快教程中描述的许多任务的执行。
- en: OpenGL windows and contexts
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenGL窗口和上下文
- en: There are many ways you can perform OpenGL rendering in Qt. The most straightforward
    way that we will mainly use is to subclass `QOpenGLWindow`. It allows OpenGL to
    render your content directly to a whole window and is suitable if you draw everything
    in your application with OpenGL. You can make it a fullscreen window if you want.
    However, later we will also discuss other approaches that will allow you to integrate
    OpenGL content into a widget-based application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Qt中执行OpenGL渲染的许多方法。我们将主要使用的一种最直接的方法是子类化`QOpenGLWindow`。它允许OpenGL直接将你的内容渲染到整个窗口，如果你使用OpenGL在应用程序中绘制所有内容，它是非常合适的。如果你想让它成为全屏窗口，也可以做到。然而，稍后我们还将讨论其他方法，这些方法将允许你将OpenGL内容集成到基于小部件的应用程序中。
- en: The OpenGL context represents the overall state of the OpenGL pipeline, which
    guides the process of data processing and rendering to a particular device. In
    Qt, it is represented by the `QOpenGLContext` class. A related concept that needs
    explanation is the idea of an OpenGL context being "current" in a thread. The
    way OpenGL calls work is that they do not use any handle to any object containing
    information on where and how to execute the series of low-level OpenGL calls.
    Instead, it is assumed that they are executed in the context of the current machine
    state. The state may dictate whether to render a scene to a screen or to a frame
    buffer object, which mechanisms are enabled, or the properties of the surface
    OpenGL is rendering on. Making a context "current" means that all further OpenGL
    operations issued by a particular thread will be applied to this context. To add
    to that, a context can be "current" only in one thread at the same time; therefore,
    it is important to make the context current before making any OpenGL calls and
    then marking it as available after you are done accessing OpenGL resources.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL 上下文代表 OpenGL 管道整体状态，它指导数据处理和渲染到特定设备的过程。在 Qt 中，它由 `QOpenGLContext` 类表示。需要解释的另一个相关概念是
    OpenGL 上下文在某个线程中“当前”的概念。OpenGL 调用的方式是它们不使用任何包含有关在哪里以及如何执行一系列低级 OpenGL 调用的对象的句柄。相反，它们假定是在当前机器状态的环境中执行的。状态可能决定了是否将场景渲染到屏幕或帧缓冲区对象，启用了哪些机制，或者
    OpenGL 正在渲染的表面的属性。使上下文“当前”意味着所有由特定线程发出的进一步 OpenGL 操作都将应用于此上下文。此外，上下文在同一时间只能在一个线程中“当前”；因此，在调用任何
    OpenGL 调用之前使上下文“当前”并标记它为可用是很重要的。
- en: '`QOpenGLWindow` has a very simple API that hides most of the unnecessary details
    from the developer. Apart from constructors and a destructor, it provides a small
    number of very useful methods. First, there are auxiliary methods for managing
    the OpenGL context: `context()`, which returns the context, and `makeCurrent()`
    as well as `doneCurrent()` for acquiring and releasing the context. The class
    also provides a number of virtual methods we can re-implement to display OpenGL
    graphics.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`QOpenGLWindow` 拥有一个非常简单的 API，它隐藏了大部分对开发者不必要的细节。除了构造函数和析构函数之外，它还提供了一些非常实用的方法。首先，有一些辅助方法用于管理
    OpenGL 上下文：`context()`，它返回上下文，以及 `makeCurrent()` 和 `doneCurrent()` 用于获取和释放上下文。该类还提供了一些虚拟方法，我们可以重新实现它们来显示
    OpenGL 图形。'
- en: 'We will be using the following three virtual methods:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下三种虚拟方法：
- en: '`initializeGL()` is invoked by the framework once, before any painting is actually
    done so that you can prepare any resources or initialize the context in any way
    you require.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initializeGL()` 会在实际进行任何绘制之前由框架调用一次，这样你就可以准备任何资源或以任何你需要的任何方式初始化上下文。'
- en: '`paintGL()` is the equivalent of `paintEvent()` for the widget classes. It
    gets executed whenever the window needs to be repainted. This is the function
    where you should put your OpenGL rendering code.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paintGL()` 对于小部件类来说相当于 `paintEvent()`。每当窗口需要重新绘制时，它都会被执行。这是你应该放置你的 OpenGL
    渲染代码的函数。'
- en: '`resizeGL()` is invoked every time the window is resized. It accepts the width
    and height of the window as parameters. You can make use of that method by re-implementing
    it so that you can prepare yourself for the fact that the next call to `paintGL()` renders
    to a viewport of a different size.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次窗口大小改变时，都会调用 `resizeGL()`。它接受窗口的宽度和高度作为参数。你可以通过重新实现该方法来准备自己，以便下一次调用 `paintGL()`
    时渲染到不同大小的视口。
- en: Before calling any of these virtual functions, `QOpenGLWindow` ensures that
    the OpenGL context is current, so there is no need to manually call `makeCurrent()` in
    them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用这些虚拟函数之前，`QOpenGLWindow` 确保OpenGL上下文是当前的，因此在这些函数中不需要手动调用 `makeCurrent()`。
- en: Accessing OpenGL functions
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问 OpenGL 函数
- en: Interaction with OpenGL is usually done through calling functions provided by
    the OpenGL library. For example, in a regular C++ OpenGL application, you can
    see calls to OpenGL functions such as `glClearColor()`. These functions are resolved
    when your binary is linked against the OpenGL library. However, when you write
    a cross-platform application, resolving all the required OpenGL functions is not
    trivial. Luckily, Qt provides a way to call OpenGL functions without having to
    worry about the platform-specific details.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与 OpenGL 的交互通常是通过调用 OpenGL 库提供的函数来完成的。例如，在一个常规的 C++ OpenGL 应用程序中，您可以看到对 `glClearColor()`
    等OpenGL 函数的调用。这些函数在您的二进制文件与 OpenGL 库链接时被解析。然而，当您编写跨平台应用程序时，解析所有必需的 OpenGL 函数并非易事。幸运的是，Qt
    提供了一种无需担心平台特定细节即可调用 OpenGL 函数的方法。
- en: In a Qt application, you should access OpenGL functions through a family of `QOpenGLFunctions`
    classes. The `QOpenGLFunctions` class itself only provides access to functions
    that are part of OpenGL ES 2.0 API. This subset is expected to work at most desktop
    and embedded platforms supported by Qt (where OpenGL is available at all). However,
    this is a really limited set of functions, and sometimes you may want to use a
    more recent OpenGL version at the cost of supporting less platforms. For each
    known OpenGL version and profile, Qt provides a separate class that contains the
    set of available functions. For example, the `QOpenGLFunctions_3_3_Core` class
    will contain all functions provided by the OpenGL 3.3 core profile.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Qt 应用程序中，您应通过 `QOpenGLFunctions` 类族访问 OpenGL 函数。`QOpenGLFunctions` 类本身仅提供对
    OpenGL ES 2.0 API 中部分函数的访问。这个子集预计将在 Qt 支持的最多桌面和嵌入式平台上工作（在这些平台上 OpenGL 都是可用的）。然而，这是一个非常有限的函数集，有时您可能愿意以支持较少平台为代价使用更新的
    OpenGL 版本。对于每个已知的 OpenGL 版本和配置文件，Qt 提供了一个包含可用函数集的单独类。例如，`QOpenGLFunctions_3_3_Core`
    类将包含 OpenGL 3.3 核心配置文件提供的所有函数。
- en: The approach recommended by Qt is to select the OpenGL functions class corresponding
    to the version you want to use and add this class an the second base class of
    your window or widget. This will make all OpenGL functions from that version available
    within your class. This approach allows you to use code that was using the OpenGL
    library directly without changing it. When you put such code in your class, the
    compiler will, for example, use the `QOpenGLFunctions::glClearColor()` function
    instead of the global `glClearColor()` function provided by the OpenGL library.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 推荐的方法是选择与您想要使用的版本相对应的 OpenGL 函数类，并将其添加到您的窗口或小部件的第二个基类中。这将使该版本的 OpenGL 函数在您的类中可用。这种方法允许您使用直接使用
    OpenGL 库的代码，而无需对其进行更改。当您将此类代码放入您的类中时，编译器将使用 `QOpenGLFunctions::glClearColor()`
    函数而不是 OpenGL 库提供的全局 `glClearColor()` 函数。
- en: However, when using this approach, you must be careful to only use functions
    provided by your base class. You can accidentally use a global function instead
    of a function provided by Qt classes if the Qt class you choose does not contain
    it. For example, if you use `QOpenGLFunctions` as the base class, you can't use
    the `glBegin()` function, as it is not provided by this Qt class. Such erroneous
    code may work on one operating system and then suddenly not compile on another
    because you don't link against the OpenGL library. As long as you only use OpenGL
    functions provided by Qt classes, you don't have to think about linking with the
    OpenGL library or resolving functions in a cross-platform way.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在使用这种方法时，您必须小心，只使用您基类提供的函数。如果您选择的 Qt 类不包含它，您可能会意外地使用全局函数而不是 Qt 类提供的函数。例如，如果您使用
    `QOpenGLFunctions` 作为基类，您就不能使用 `glBegin()` 函数，因为这个函数不是由这个 Qt 类提供的。这样的错误代码可能在某个操作系统上工作，然后突然在另一个操作系统上无法编译，因为您没有链接到
    OpenGL 库。只要您只使用 Qt 类提供的 OpenGL 函数，您就无需考虑与 OpenGL 库的链接或跨平台方式解决函数。
- en: If you want to ensure that you only use Qt OpenGL function wrappers, you can
    use the Qt class as a private field instead of a base class. In that case, you
    have to access every OpenGL function through the private field, for example, `m_openGLFunctions->glClearColor()`.
    This will make your code more verbose, but at least you will be sure that you
    don't accidentally use a global function.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想确保只使用 Qt OpenGL 函数包装器，您可以将 Qt 类用作私有字段而不是基类。在这种情况下，您必须通过私有字段访问每个 OpenGL 函数，例如，`m_openGLFunctions->glClearColor()`。这将使您的代码更加冗长，但至少您可以确信不会意外地使用全局函数。
- en: Before using Qt OpenGL functions, you have to call the `initializeOpenGLFunctions()`
    method of the functions class in the current OpenGL context. This is usually done
    in the `initializeGL()` function of the window. The `QOpenGLFunctions` class is
    expected to always initialize successfully, so its `initializeOpenGLFunctions()` method
    doesn't return anything. In all the other functions' classes, this function returns
    `bool`. If it returns `false`, it means that Qt was not able to resolve all the
    required functions successfully, and your application should exit with an error
    message.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Qt OpenGL 函数之前，您必须调用当前 OpenGL 上下文中函数类的 `initializeOpenGLFunctions()` 方法。这通常在窗口的
    `initializeGL()` 函数中完成。期望 `QOpenGLFunctions` 类始终初始化成功，因此其 `initializeOpenGLFunctions()`
    方法不返回任何内容。在其他所有函数类的所有函数中，此函数返回 `bool`。如果它返回 `false`，则表示 Qt 无法成功解析所有必需的函数，并且您的应用程序应带错误消息退出。
- en: In our examples, we will use the `QOpenGLFunctions_1_1` class that contains
    all OpenGL functions we'll use. When you're creating your own project, think about
    the OpenGL profile you want to target and select the appropriate functions class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将使用包含我们将使用所有 OpenGL 函数的 `QOpenGLFunctions_1_1` 类。当您创建自己的项目时，考虑您想要针对的
    OpenGL 配置文件并选择适当的函数类。
- en: Using OpenGL in immediate mode
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用立即模式的 OpenGL
- en: We will start with the most basic approach that's called **immediate mode**.
    In this mode, no additional setup of OpenGL buffers or shaders is required. You
    can just supply a bunch of geometric primitives and get the result right away.
    Immediate mode is now deprecated because it works much slower and is less flexible
    than more advanced techniques. However, it's so much easier than them that basically
    every OpenGL tutorial starts with describing the immediate mode calls. In this
    section, we'll show how to perform some simple OpenGL drawing with very little
    code. A more modern approach will be covered in the next section of this chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从最基本的方法开始，称为 **立即模式**。在这种模式下，不需要额外的 OpenGL 缓冲区或着色器设置。您只需提供一些几何原语即可立即获得结果。立即模式现在已被弃用，因为它比更高级的技术慢得多，并且灵活性较低。然而，它比它们容易得多，因此基本上每个
    OpenGL 教程都是从描述立即模式调用开始的。在本节中，我们将展示如何用很少的代码执行一些简单的 OpenGL 绘图。更现代的方法将在本章下一节中介绍。
- en: Time for action – Drawing a triangle using Qt and OpenGL
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 使用 Qt 和 OpenGL 绘制三角形
- en: 'For the first exercise, we will create a subclass of `QOpenGLWindow` that renders
    a triangle using simple OpenGL calls. Create a new project, starting with Empty
    qmake Project from the Other Project group as the template. In the project file,
    put the following content:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个练习中，我们将创建一个 `QOpenGLWindow` 的子类，使用简单的 OpenGL 调用来渲染一个三角形。创建一个新的项目，从“其他项目”组中的“空
    qmake 项目”模板开始。在项目文件中，添加以下内容：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that our project does not include Qt Widgets module. Using the `QOpenGLWindow`
    approach allows us to remove this unnecessary dependency and make our application
    more lightweight.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的项目不包括 Qt Widgets 模块。使用 `QOpenGLWindow` 方法允许我们删除这个不必要的依赖，并使我们的应用程序更轻量级。
- en: Note that Qt Core and Qt GUI modules are enabled by default, so you don't have
    to add them to the `QT` variable, but we prefer to explicitly show that we are
    using them in our project.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Qt Core 和 Qt GUI 模块默认启用，因此您不需要将它们添加到 `QT` 变量中，但我们更喜欢明确地显示我们在项目中使用它们。
- en: 'Having the basic project setup ready, let''s define a `SimpleGLWindow` class
    as a subclass of `QOpenGLWindow` and `QOpenGLFunctions_1_1`. Since we don''t want
    to allow external access to OpenGL functions, we use protected inheritance for
    the second base. Next, we override the virtual `initializeGL()` method of `QOpenGLWindow`.
    In this method, we initialize our `QOpenGLFunctions_1_1` base class and use the `glClearColor()`
    function that it provides:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本项目设置就绪后，让我们定义一个 `SimpleGLWindow` 类，作为 `QOpenGLWindow` 和 `QOpenGLFunctions_1_1`
    的子类。由于我们不希望允许外部访问 OpenGL 函数，我们使用保护继承来作为第二个基类。接下来，我们重写 `QOpenGLWindow` 的虚拟 `initializeGL()`
    方法。在这个方法中，我们初始化我们的 `QOpenGLFunctions_1_1` 基类，并使用它提供的 `glClearColor()` 函数：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In `initializeGL()`, we first call `initializeOpenGLFunctions()`, which is a
    method of the `QOpenGLFunctions_1_1` class, one of the base classes of our window
    class. The method takes care of setting up all the functions according to the
    parameters of the current OpenGL context (thus, it is important to first make
    the context current, which luckily is done for us behind the scenes before `initializeGL()`
    is invoked). If this function fails, we use the `qFatal()` macro to print an error
    message to `stderr` and abort the application. Then, we use the `QOpenGLFunctions_1_1::glClearColor()`
    function to set the clear color of the scene to white.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在`initializeGL()`函数中，我们首先调用`initializeOpenGLFunctions()`，这是`QOpenGLFunctions_1_1`类的一个方法，它是我们窗口类的基础类之一。该方法负责根据当前OpenGL上下文的参数设置所有函数（因此，首先使上下文成为当前上下文是很重要的，幸运的是，在调用`initializeGL()`之前，这已经在幕后为我们完成了）。如果此函数失败，我们使用`qFatal()`宏将错误信息打印到`stderr`并终止应用程序。然后，我们使用`QOpenGLFunctions_1_1::glClearColor()`函数将场景的清除颜色设置为白色。
- en: 'The next step is to re-implement `paintGL()` and put the actual drawing code
    there:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是重新实现`paintGL()`函数，并将实际的绘图代码放在那里：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This function first clears the color buffer and sets the OpenGL viewport of
    the context to be the size of the window. Then, we tell OpenGL to start drawing
    using triangles with the `glBegin()` call and passing `GL_TRIANGLES` as the drawing
    mode. Then, we pass three vertices along with their colors to form a triangle.
    Finally, we inform the pipeline, by invoking `glEnd()`, that we are done drawing
    using the current mode.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数首先清除颜色缓冲区，并将上下文的OpenGL视口设置为窗口的大小。然后，我们通过调用`glBegin()`并传递`GL_TRIANGLES`作为绘图模式来告诉OpenGL开始使用三角形进行绘制。然后，我们传递三个顶点及其颜色来形成一个三角形。最后，通过调用`glEnd()`通知管道，我们已完成使用当前模式的绘制。
- en: 'What is left is a trivial `main()` function that sets up the window and starts
    the event loop. Add a new C++ Source File, call it `main.cpp`, and implement `main()`,
    as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的只是一个平凡的`main()`函数，用于设置窗口并启动事件循环。添加一个新的C++源文件，命名为`main.cpp`，并实现`main()`，如下所示：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This function is very similar to what we usually have in the `main()` function,
    but we use `QGuiApplication` instead of `QApplication`, because we only use the
    Qt GUI module. After running the project, you should see the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数与我们通常在`main()`函数中看到的内容非常相似，但我们使用`QGuiApplication`而不是`QApplication`，因为我们只使用Qt
    GUI模块。运行项目后，你应该看到以下内容：
- en: '![](img/70d987b1-b8d0-4f23-ad39-331b02b74d7c.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/70d987b1-b8d0-4f23-ad39-331b02b74d7c.png)'
- en: Multisampling
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多重采样
- en: 'You can see that the triangle has jagged edges. That''s because of the aliasing
    effect. You can counter it by enabling multisampling for the window, which will
    make OpenGL render the contents as if the screen had higher resolution and then
    average the result, which acts as anti-aliasing. To do that, add the following
    code to the constructor of the window:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到三角形有锯齿状的边缘。这是因为走样效应。你可以通过为窗口启用多重采样来对抗它，这将使OpenGL渲染的内容看起来像屏幕有更高的分辨率，然后平均结果，这起到抗走样的作用。为此，将以下代码添加到窗口的构造函数中：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that multisampling is resource-demanding, so setting a high number of samples
    may cause your application to fail if your hardware or driver can't handle it.
    If the application doesn't work after enabling multisampling, try to lower the
    number of samples or just disable it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，多重采样是资源密集型的，所以设置一个很高的样本数可能会导致你的应用程序失败，如果你的硬件或驱动程序无法处理它。如果启用多重采样后应用程序不起作用，请尝试降低样本数或直接禁用它。
- en: Time for action – Scene-based rendering
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 基于场景的渲染
- en: Let's take our rendering code to a higher level. Putting OpenGL code directly
    into the window class requires subclassing the window class and makes the window
    class more and more complex. Let's follow good programming practice and separate
    rendering code from window code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把我们的渲染代码提升到一个更高的层次。直接将OpenGL代码放入窗口类需要子类化窗口类，并使窗口类变得越来越复杂。让我们遵循良好的编程实践，将渲染代码与窗口代码分离。
- en: Create a new class and call it `AbstractGLScene`. It will be the base class
    for
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的类，命名为`AbstractGLScene`。它将是以下类的基类：
- en: 'definitions of OpenGL scenes. We also derive the class (with protected scope)
    from `QOpenGLFunctions_1_1` to make accessing different OpenGL functions easier.
    Make the scene class accept a pointer to `QOpenGLWindow`, either in the constructor
    or through a dedicated setter method. Ensure that the pointer is stored in the
    class for easier access, as we will rely on that pointer for accessing physical
    properties of the window. Add methods for querying the window''s OpenGL context.
    You should end up with code similar to the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL场景的定义。我们还从`QOpenGLFunctions_1_1`派生类（具有保护作用域），以便更容易访问不同的OpenGL函数。确保场景类接受一个指向`QOpenGLWindow`的指针，无论是在构造函数中还是在专门的设置方法中。确保将指针存储在类中，以便更容易访问，因为我们将会依赖这个指针来访问窗口的物理属性。添加查询窗口OpenGL上下文的方法。您最终应该得到类似以下代码的代码：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now the essential part begins. Add two pure virtual methods called `paint()`
    and `initialize()`. Also, remember to add a virtual destructor.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在最重要的部分开始了。添加两个纯虚方法，分别称为`paint()`和`initialize()`。同时，记得添加一个虚析构函数。
- en: Instead of making `initialize()` a pure virtual function, you can implement
    its body in such a way that it will call `initializeOpenGLFunctions()` to fulfill
    the requirements of the `QOpenGFunctions` class. Then, subclasses of `AbstractGLScene`
    can ensure that the functions are initialized properly by calling the base class
    implementation of `initialize()`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必将`initialize()`实现为纯虚函数，您可以以这种方式实现其主体，使其调用`initializeOpenGLFunctions()`以满足`QOpenGFunctions`类的要求。然后，`AbstractGLScene`的子类可以通过调用基类的`initialize()`实现来确保函数被正确初始化。
- en: 'Next, create a subclass of `QOpenGLWindow` and call it `SceneGLWindow`. Add
    an `AbstractGLScene *m_scene` private field and implement a getter and a setter
    for it. Create a constructor using the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个`QOpenGLWindow`的子类，并将其命名为`SceneGLWindow`。添加一个`AbstractGLScene *m_scene`私有字段，并为其实现一个获取器和设置器。使用以下代码创建一个构造函数：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This constructor forwards the parent argument to the base constructor and assigns `NoPartialUpdate`
    as the window's `UpdateBehavior`. This option means that the window will be fully
    painted on each `paintGL()` call and thus no framebuffer is needed. This is the
    default value of the first argument, but since we provide the second argument,
    we are obligated to provide the first argument explicitly.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此构造函数将父参数传递给基构造函数，并将`NoPartialUpdate`作为窗口的`UpdateBehavior`。此选项意味着窗口将在每次`paintGL()`调用时完全重绘，因此不需要帧缓冲区。这是第一个参数的默认值，但因为我们提供了第二个参数，所以我们有义务明确提供第一个参数。
- en: 'Then, re-implement the `initializeGL()` and `paintGL()` methods and make them
    call appropriate equivalents in the scene:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，重新实现`initializeGL()`和`paintGL()`方法，并使它们调用场景中的适当等效方法：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Finally, instantiate `SceneGLWindow` in the `main()` function.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`main()`函数中实例化`SceneGLWindow`。
- en: What just happened?
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We have just set up a class chain that separates the window code from the actual
    OpenGL scene. The window forwards all calls related to scene contents to the scene
    object so that when the window is requested to repaint itself, it delegates the
    task to the scene object. Note that prior to doing that, the window will make
    the OpenGL context current; therefore, all OpenGL calls that the scene makes will
    be related to that context. You can store the code created in this exercise for
    later reuse in further exercises and your own projects.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚设置了一个类链，将窗口代码与实际的OpenGL场景分离。窗口将所有与场景内容相关的调用转发给场景对象，以便当窗口被要求重绘自身时，它将任务委托给场景对象。请注意，在此之前，窗口将使OpenGL上下文成为当前上下文；因此，场景所做的所有OpenGL调用都将与此上下文相关。您可以将在此练习中创建的代码存储起来，以便在后续练习和自己的项目中重复使用。
- en: Time for action – Drawing a textured cube
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 绘制纹理立方体
- en: 'Create a new class named `CubeGLScene` and derive it from `AbstractGLScene`.
    Implement the constructor to forward its argument to the base class constructor.
    Add a method to store a `QImage` object in the scene that will contain texture
    data for the cube. Add a `QOpenGLTexture` pointer member as well, which will contain
    the texture, initialize it to `nullptr` in the constructor, and delete it in the
    destructor. Let''s call the `m_textureImage` image object and the `m_texture` texture. Now
    add a protected `initializeTexture()` method and fill it with the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`CubeGLScene`的新类，并从`AbstractGLScene`派生。实现构造函数以将其参数传递给基类构造函数。添加一个方法来存储场景中的`QImage`对象，该对象将包含立方体的纹理数据。同时添加一个`QOpenGLTexture`指针成员，它将包含纹理，在构造函数中将它初始化为`nullptr`，并在析构函数中删除它。我们将称这个`m_textureImage`图像对象为`m_texture`纹理。现在添加一个受保护的`initializeTexture()`方法，并用以下代码填充它：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The function first mirrors the image vertically. This is because the *y* axis
    in OpenGL points up by default, so a texture would be displayed "upside down". Then,
    we create a `QOpenGLTexture` object, passing it our image. After that, we set
    minification and magnification filters so that the texture looks better when it
    is scaled.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 函数首先垂直翻转图像。这是因为OpenGL中默认的*y*轴向上，所以纹理将显示为“颠倒”。然后，我们创建一个`QOpenGLTexture`对象，并将我们的图像传递给它。之后，我们设置缩小和放大过滤器，以便纹理在缩放时看起来更好。
- en: 'We are now ready to implement the `initialize()` method that will take care
    of setting up the texture and the scene itself:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备实现`initialize()`方法，该方法将负责设置纹理和场景本身：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We make use of a flag called `m_initialized`. This flag is needed to prevent
    the texture from being set up too early (when no OpenGL context is available yet).
    Then, we check whether the texture image is set (using the `QImage::isNull()`
    method); if so, we initialize the texture. Then, we set some additional properties
    of the OpenGL context.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个名为`m_initialized`的标志。这个标志是必要的，以防止纹理设置得太早（当还没有OpenGL上下文时）。然后，我们检查纹理图像是否已设置（使用`QImage::isNull()`方法）；如果是，则初始化纹理。然后，我们设置OpenGL上下文的某些附加属性。
- en: In the setter for `m_textureImage`, add code that checks whether `m_initialized`
    is set to `true` and, if so, calls `initializeTexture()`. This is to make certain
    that the texture is properly set regardless of the order in which the setter and
    `initialize()` are called. Also remember to set `m_initialized` to `false` in
    the constructor.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在`m_textureImage`的设置器中添加代码，检查`m_initialized`是否设置为`true`，如果是，则调用`initializeTexture()`。这是为了确保无论设置器和`initialize()`调用的顺序如何，纹理都得到正确设置。同时，请记住在构造函数中将`m_initialized`设置为`false`。
- en: 'The next step is to prepare the cube data. We will define a special data structure
    for the cube that groups vertex coordinates and texture data in a single object.
    To store coordinates, we will use classes tailored to that purpose—`QVector3D`
    and `QVector2D`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是准备立方体数据。我们将为立方体定义一个特殊的数据结构，该结构将顶点坐标和纹理数据组合在一个对象中。为了存储坐标，我们将使用专门为此目的定制的类——`QVector3D`和`QVector2D`：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`QVector2D`, `QVector3D`, and `QVector4D` are helper classes that represent
    a single point in space and provide some convenient methods. For instance, `QVector2D`
    stores two `float` variables (`x` and `y`), much like the `QPointF` class does.
    These classes are not to be confused with `QVector<T>`, a container template class
    that stores a collection of elements.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`QVector2D`、`QVector3D`和`QVector4D`是表示空间中单个点的辅助类，并提供了一些方便的方法。例如，`QVector2D`存储两个`float`变量（`x`和`y`），就像`QPointF`类一样。这些类不应与`QVector<T>`容器模板类混淆，后者存储元素集合。'
- en: '`QVector<TexturedPoint>` will hold information for the whole cube. The vector
    is initialized with data using the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`QVector<TexturedPoint>`将保存整个立方体的信息。该向量使用以下代码初始化：'
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The code uses C++11 initializer list syntax to set the vector''s data. The
    cube consists of six faces and is centered on the origin of the coordinate system.
    The following diagram presents the same data in graphical form:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用C++11初始化列表语法设置向量的数据。立方体由六个面组成，且以坐标系的原点为中心。以下图表以图形形式展示了相同的数据：
- en: '![](img/3957ca2b-bdee-41e6-99ff-b5c2d0b77fad.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3957ca2b-bdee-41e6-99ff-b5c2d0b77fad.png)'
- en: '`initializeCubeData()` should be called from the scene constructor or from
    the `initialize()` method. What remains is the painting code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`initializeCubeData()`应从场景构造函数或从`initialize()`方法中调用。剩下的就是绘图代码：'
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'First, we set up the viewport and then we rotate the view. Before calling `paintCube()`,
    which will render the cube itself, we enable depth testing and face culling so
    that only visible faces are drawn. The `paintCube()` routine looks as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们设置视口，然后旋转视图。在调用 `paintCube()`（它将渲染立方体本身）之前，我们启用深度测试和面剔除，以便只绘制可见的面。`paintCube()`
    程序如下所示：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: First, the texture is bound and texturing is enabled. Then, we enter the quad
    drawing mode and stream in data from our data structure. Finally, we disable texturing
    again.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，绑定纹理并启用纹理映射。然后，我们进入四边形绘制模式，并从我们的数据结构中流式传输数据。最后，再次禁用纹理映射。
- en: 'For completeness, here''s a `main()` function that executes the scene:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，这里有一个执行场景的 `main()` 函数：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note the use of `QSurfaceFormat` to enable multisample antialiasing for the
    scene. We have also put the texture image into a resource file to avoid problems
    with the relative path to the file.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用 `QSurfaceFormat` 启用场景的多样本抗锯齿。我们还也将纹理图像放入资源文件中，以避免文件相对路径的问题。
- en: Have a go hero – Animating a cube
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试英雄 - 动画一个立方体
- en: 'Try modifying the code to make the cube animated. To do that, have the scene
    inherit `QObject`, add an angle property of the `float` type to it (remember about
    the `Q_OBJECT` macro). Then, modify one of the `glRotatef()` lines to use the
    angle value instead of a constant value. Put the following code in `main()`, right
    before calling `app.exec()`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试修改代码以使立方体动画化。为此，让场景继承 `QObject`，向其中添加一个 `float` 类型的角度属性（记得关于 `Q_OBJECT` 宏）。然后，修改
    `glRotatef()` 中的某一行，使用角度值而不是常数值。在 `main()` 中，在调用 `app.exec()` 之前放入以下代码：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Remember to put a call to `window()->update()` in the setter for the angle property
    so that the scene is redrawn.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在角度属性的设置器中调用 `window()->update()`，以便重新绘制场景。
- en: Modern OpenGL with Qt
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有 Qt 的现代 OpenGL
- en: The OpenGL code shown in the previous section uses a very old technique of streaming
    vertices one by one into a fixed OpenGL pipeline. Nowadays, modern hardware is
    much more feature-rich and not only does it allow faster processing of vertex
    data but also offers the ability to adjust different processing stages, with the
    use of reprogrammable units called **shaders**. In this section, we will take
    a look at what Qt has to offer in the domain of a "modern" approach to using OpenGL.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中显示的 OpenGL 代码使用了一种非常古老的逐个将顶点流式传输到固定 OpenGL 管道的技巧。如今，现代硬件功能更加丰富，不仅允许更快地处理顶点数据，而且还提供了使用可重编程单元（称为着色器）调整不同处理阶段的能力。在本节中，我们将探讨
    Qt 在使用 OpenGL 的“现代”方法领域所能提供的内容。
- en: Shaders
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色器
- en: Qt can make use of shaders through a set of classes based around `QOpenGLShaderProgram`.
    This class allows compiling, linking, and executing of shader programs written
    in GLSL. You can check whether your OpenGL implementation supports shaders by
    inspecting the result of a static `QOpenGLShaderProgram::hasOpenGLShaderPrograms()`
    call that accepts a pointer to an OpenGL context. All modern hardware and all
    decent graphics drivers should have some support for shaders.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 可以通过围绕 `QOpenGLShaderProgram` 类的一系列类来使用着色器。这个类允许编译、链接和执行用 GLSL 编写的着色器程序。您可以通过检查静态
    `QOpenGLShaderProgram::hasOpenGLShaderPrograms()` 调用的结果来检查您的 OpenGL 实现是否支持着色器，该调用接受一个
    OpenGL 上下文的指针。所有现代硬件和所有不错的图形驱动程序都应该有一些对着色器的支持。
- en: 'Qt supports all kinds of shaders, with the most common being vertex and fragment
    shaders. These are both part of the classic OpenGL pipeline. You can see an illustration
    of the pipeline in the following diagram:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 支持所有类型的着色器，其中最常见的是顶点着色器和片段着色器。这些都是经典 OpenGL 管道的一部分。您可以在以下图中看到管道的示意图：
- en: '![](img/f42b8281-ae7a-41a0-b990-31cdd60f284b.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f42b8281-ae7a-41a0-b990-31cdd60f284b.png)'
- en: A single shader is represented by an instance of the `QOpenGLShader` class.
    You need to specify the type of the shader in the constructor of this class. Then,
    you can compile the shader's source code by calling `QOpenGLShader::compileSourceCode()`,
    which has a number of overloads for handling different input formats, or `QOpenGLShader::compileSourceFile()`.
    The `QOpenGLShader` object stores the ID of the compiled shader for future use.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 单个着色器由 `QOpenGLShader` 类的实例表示。您需要在类的构造函数中指定着色器的类型。然后，您可以通过调用 `QOpenGLShader::compileSourceCode()`
    编译着色器的源代码，该函数有多个重载用于处理不同的输入格式，或者调用 `QOpenGLShader::compileSourceFile()`。`QOpenGLShader`
    对象存储了编译后着色器的 ID，以供将来使用。
- en: When you have a set of shaders defined, you can assemble a complete program
    using `QOpenGLShaderProgram::addShader()`. After all shaders are added, you can
    `link()` the program and `bind()` it to the current OpenGL context. The program
    class has a number of methods for setting values of different input parameters—uniforms
    and attributes both in singular and array versions. Qt provides mappings between
    its own types (such as `QSize` or `QColor`) to GLSL counterparts (for example,
    `vec2` and `vec4`) to make the programmer's life even easier.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义了一组着色器后，你可以使用 `QOpenGLShaderProgram::addShader()` 组装一个完整的程序。在所有着色器都添加完毕后，你可以调用
    `link()` 将程序链接，并使用 `bind()` 将其绑定到当前的OpenGL上下文。程序类提供了一系列方法来设置不同输入参数的值——包括单值和数组版本的uniforms和attributes。Qt提供了它自己的类型（如`QSize`或`QColor`）与GLSL对应类型（例如`vec2`和`vec4`）之间的映射，以使程序员的开发工作更加轻松。
- en: 'A typical code flow for using shaders for rendering is as follows (first a
    vertex shader is created and compiled):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用着色器进行渲染的典型代码流程如下（首先创建并编译一个顶点着色器）：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The process is repeated for a fragment shader:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于片段着色器，过程是重复的：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, shaders are linked into a single program in a given OpenGL context:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，着色器在给定的OpenGL上下文中被链接成一个单独的程序：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When shaders are linked together, OpenGL searches for common variables (such
    as uniforms or buffers) in them and maps them together. This allows you, for example,
    to pass a value from the vertex shader to the fragment shader. Behind the scenes,
    the `link()` function uses the `glLinkProgram()` OpenGL call.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当着色器被链接在一起时，OpenGL会在它们中搜索公共变量（如uniforms或buffers）并将它们映射在一起。这使得你可以，例如，从顶点着色器传递一个值到片段着色器。在幕后，`link()`函数使用了`glLinkProgram()`
    OpenGL调用。
- en: 'Whenever the program is used, it should be bound to the current OpenGL context
    and filled with the required data:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 每次使用程序时，都应该将其绑定到当前的OpenGL上下文，并填充所需的数据：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After that, calls activating the render pipeline will use the bound program:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，激活渲染管道的调用将使用绑定的程序：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Time for action – Shaded objects
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 着色物体
- en: Let's convert our last program so that it uses shaders. To make the cube better,
    we will implement a smooth lighting model using the Phong algorithm. At the same
    time, we will learn to use some helper classes that Qt offers for use with OpenGL.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将最后一个程序转换为使用着色器。为了使立方体更好，我们将实现一个使用Phong算法的平滑光照模型。同时，我们将学习如何使用Qt为OpenGL提供的辅助类。
- en: 'The basic goals for this miniproject are as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个迷你项目的目标如下：
- en: Use vertex and fragment shaders for rendering a complex object
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用顶点和片段着色器渲染复杂物体
- en: Handle model, view, and projection matrices
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理模型、视图和投影矩阵
- en: Use attribute arrays for faster drawing
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性数组进行更快的绘制
- en: 'Start by creating a new subclass of `AbstractGLScene`. Let''s give it the following
    interface:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个新的`AbstractGLScene`子类。让我们给它以下接口：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We're not using textures in this project, so `TexturedPoint` was simplified
    to `ScenePoint` with UV texture coordinates removed. Update the `main()` function
    to use the `ShaderGLScene` class.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目我们未使用纹理，因此`TexturedPoint`被简化为`ScenePoint`，并移除了UV纹理坐标。更新`main()`函数以使用`ShaderGLScene`类。
- en: We can start implementing the interface with the `initializeObjectData()` function
    that will be called in the constructor. This function must fill the `m_data` member
    with information about vertices and their normals. The implementation will depend
    on the source of your data.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从`initializeObjectData()`函数开始实现接口，该函数将在构造函数中被调用。这个函数必须用关于顶点和它们法线的信息填充`m_data`成员。实现将取决于你的数据来源。
- en: In the sample code that comes with this book, you can find code that loads data
    from a file in the PLY format generated with the Blender 3D program. To export
    a model from Blender, ensure that it consists of just triangles (for that, select
    the model, go into the Edit mode by pressing *Tab*, open the Faces menu with *Ctrl*
    + *F*, and choose Triangulate Faces). Then, click on File and Export; choose Stanford
    (.ply). You will end up with a text file containing vertex and normal data as
    well as face definitions for the vertices. We add the PLY file to the project's
    resources so that it is always available to our program. Then, we use the `PlyReader` C++
    class that implements the parsing.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书附带示例代码中，你可以找到使用Blender 3D程序生成的PLY格式文件加载数据的代码。要从Blender导出模型，确保它只由三角形组成（为此，选择模型，按*Tab*进入编辑模式，使用*Ctrl*
    + *F*打开面菜单，并选择三角化面）。然后，点击文件并导出；选择斯坦福（.ply）。你将得到一个包含顶点和法线数据以及顶点面定义的文本文件。我们将PLY文件添加到项目的资源中，以便它始终可供我们的程序使用。然后，我们使用实现解析的`PlyReader`C++类。
- en: You can always reuse the cube object from the previous project. Just be aware
    that its normals are not calculated properly for smooth shading; thus, you will
    have to correct them.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以始终重用前一个项目中使用的立方体对象。只需注意，它的法线没有正确计算以进行平滑着色；因此，你必须纠正它们。
- en: 'Before we can set up the shader program, we have to be aware of what the actual
    shaders look like. Shader code will be loaded from external files, so the first
    step is to add a new file to the project. In Creator, right-click on the project
    in the project tree and choose Add New...; from the left pane, choose GLSL, and
    from the list of available templates, choose Vertex Shader (Desktop OpenGL). Call
    the new file `phong.vert` and input the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以设置着色器程序之前，我们必须了解实际的着色器看起来是什么样子。着色器代码将从外部文件加载，因此第一步是向项目中添加一个新文件。在Creator中，在项目树中右键单击项目，然后选择“添加新...”；在左侧面板中，选择GLSL，然后从可用模板列表中选择顶点着色器（桌面OpenGL）。将新文件命名为`phong.vert`并输入以下代码：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The code is very simple. We declare four matrices representing different stages
    of coordinate mapping for the scene. We also define two input attributes—`Vertex`
    and `Normal`—which contain the vertex data. The shader will output two pieces
    of data—a normalized vertex normal and a transformed vertex coordinate as seen
    by the camera. Of course, apart from that, we set `gl_Position` to be the final
    vertex coordinate. In each case, we want to be compliant with the OpenGL/ES specification,
    so we prefix each variable declaration with a precision specifier.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 代码非常简单。我们声明了四个矩阵，代表场景坐标映射的不同阶段。我们还定义了两个输入属性—`Vertex`和`Normal`—它们包含顶点数据。着色器将输出两份数据—一个归一化的顶点法线和从摄像机看到的变换后的顶点坐标。当然，除此之外，我们还将`gl_Position`设置为最终的顶点坐标。在每种情况下，我们都要符合OpenGL/ES规范，因此在每个变量声明前加上一个精度指定符。
- en: 'Next, add another file, call it `phong.frag`, and make it a fragment shader
    (Desktop OpenGL). The content of the file is a typical ambient, diffuse, and specular
    calculation:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加另一个文件，命名为`phong.frag`，并使其成为片段着色器（桌面OpenGL）。文件的内容是典型的环境、漫反射和镜面反射计算：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Apart from using the two varying variables to obtain the interpolated normal
    (`N`) and fragment (`v`) position, the shader declares two structures for keeping
    light and material information. Without going into the details of how the shader
    itself works, it calculates three components—ambient light, diffused light, and
    specular reflection—adds them together, and sets that as the fragment color. Since
    all the per vertex input data is interpolated for each fragment, the final color
    is calculated individually for each pixel.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用两个变化变量来获取插值法线（`N`）和片段位置（`v`）之外，着色器还声明了两个结构来保存光和材料信息。不深入着色器本身的工作细节，它计算三个组件—环境光、漫射光和镜面反射—将它们相加，并将结果设置为片段颜色。由于每个顶点的输入数据都为每个片段进行插值，因此最终颜色是针对每个像素单独计算的。
- en: 'Once we know what the shaders expect, we can set up the shader program object.
    Let''s go through the `initialize()` method. First, we call the base class implementation
    and set the background color of the scene to black, as shown in the following
    code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道着色器期望什么，我们就可以设置着色器程序对象。让我们来回顾一下`initialize()`方法。首先，我们调用基类实现并设置场景的背景颜色为黑色，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add both shader files to the project''s resources. Then, use the following
    code to read shaders from these files and link the shader program:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两个着色器文件添加到项目的资源中。然后，使用以下代码从这些文件中读取着色器并链接着色器程序：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `link()` function returns a Boolean value, but, we skip the error check
    here for simplicity. The next step is to prepare all the input data for the shader,
    as shown:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`link()` 函数返回一个布尔值，但为了简单起见，我们这里跳过了错误检查。下一步是准备所有着色器的输入数据，如下所示：'
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: First, the shader program is bound to the current context so that we can operate
    on it. Then, we enable the setup of two attribute arrays—one for vertex coordinates
    and the other for their normals. In our program, the data is stored in a `QVector<ScenePoint>`,
    where each `ScenePoint` has `coords` and normal `fields`, so there are no separate
    C++ arrays for coordinates and normals. Fortunately, OpenGL is smart enough to
    use our memory layout as is. We just need to map our vector to two attribute arrays.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将着色器程序绑定到当前上下文，这样我们就可以对其操作。然后，我们启用两个属性数组的设置——一个用于顶点坐标，另一个用于它们的法线。在我们的程序中，数据存储在
    `QVector<ScenePoint>` 中，其中每个 `ScenePoint` 有 `coords` 和法线 `fields` 字段，因此没有单独的 C++
    数组用于坐标和法线。幸运的是，OpenGL 足够智能，可以直接使用我们的内存布局。我们只需要将我们的向量映射到两个属性数组。
- en: We inform the program that an attribute called `Vertex` is an array. Each item
    of that array consists of three values of the `GL_FLOAT` type. The first array
    item is located at `&m_data[0].coords`, and data for the next vertex is located
    at `sizeof(ScenePoint)` bytes later than the data for the current point. Then
    we have a similar declaration for the `Normal` attribute, with the only exception
    that the first piece of data is stored at `&m_data[0].normal`. By informing the
    program about layout of the data, we allow it to quickly read all the vertex information
    when needed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通知程序一个名为 `Vertex` 的属性是一个数组。该数组的每个元素由三个 `GL_FLOAT` 类型的值组成。第一个数组元素位于 `&m_data[0].coords`，下一个顶点的数据位于当前点数据之后
    `sizeof(ScenePoint)` 字节的位置。然后我们对 `Normal` 属性有类似的声明，唯一的区别是第一条数据存储在 `&m_data[0].normal`。通过通知程序数据布局，我们允许它在需要时快速读取所有顶点信息。
- en: 'After attribute arrays are set, we pass values for uniform variables to the
    shader program, which concludes the shader program setup. You will note that we
    didn''t set values for uniforms representing the various matrices; we will do
    that separately for each repaint. The `paint()` method takes care of that:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置属性数组之后，我们将均匀变量的值传递给着色器程序，这标志着着色器程序设置的完成。您会注意到我们没有设置表示各种矩阵的均匀变量的值；我们将为每次重绘分别设置这些值。`paint()`
    方法负责这一点：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this method, we make heavy use of the `QMatrix4x4` class that represents
    a 4 × 4 matrix in a so-called row-major order, which is suited to use with OpenGL.
    At the beginning, we reset the projection matrix and use the `perspective()` method
    to give it a perspective transformation based on the current window size. Afterward,
    the view matrix is also reset and the `lookAt()` method is used to prepare the
    transformation for the camera; center value indicates the center of the view that
    the eye is looking at. The `up` vector dictates the vertical orientation of the
    camera (with respect to the eye position).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们大量使用了表示 4×4 矩阵的 `QMatrix4x4` 类，该类以所谓的行主序方式表示矩阵，适合与 OpenGL 一起使用。一开始，我们重置投影矩阵，并使用
    `perspective()` 方法根据当前窗口大小给它一个透视变换。之后，视图矩阵也被重置，并使用 `lookAt()` 方法为摄像机准备变换；中心值表示眼睛所看的视图中心。`up`
    向量指定了摄像机的垂直方向（相对于眼睛位置）。
- en: 'The next couple of lines are similar to what we had in the previous project:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行与上一个项目中的类似：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After that, we do the actual painting of the object:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们进行对象的实际绘制：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We start by setting the model matrix, which dictates where the rendered object
    is positioned relative to the center of the world (in this case, we say that it
    is rotated 45 degrees around the *y* axis). Then we assemble the model-view matrix
    (denoting the position of the object relative to the camera) and pass it to the
    `paintObject()` method:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置模型矩阵，它决定了渲染对象相对于世界中心的位置（在这种情况下，我们说它是绕 *y* 轴旋转了 45 度）。然后我们组装模型视图矩阵（表示对象相对于摄像机的位置）并将其传递给
    `paintObject()` 方法：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This method is very easy, since most of the work was done when setting up the
    shader program. First, the shader program is activated, and then all the required
    matrices are set as uniforms for the shader. Included is the normal matrix calculated
    from the model-view matrix. Finally, a call to `glDrawArrays()` is issued, telling
    it to render with the `GL_TRIANGLES` mode using active arrays, starting from the
    beginning of the array (offset `0`) and reading in the `m_data.size()` entities
    from the array.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法非常简单，因为大部分工作都是在设置着色器程序时完成的。首先，激活着色器程序，然后将所有所需的矩阵设置为着色器的统一变量。其中包括从模型视图矩阵计算出的法线矩阵。最后，发出对`glDrawArrays()`的调用，告诉它使用`GL_TRIANGLES`模式通过活动数组进行渲染，从数组的开始（偏移`0`）读取`m_data.size()`个实体。
- en: 'After you run the project, you should get a result similar to the following
    one, which happens to contain the Blender monkey, Suzanne:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目后，你应该得到一个类似于以下的结果，它恰好包含了Blender猴子，Suzanne：
- en: '![](img/1ce8c466-2324-4654-acd9-73b0b248fc1c.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1ce8c466-2324-4654-acd9-73b0b248fc1c.png)'
- en: GL buffers
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GL缓冲区
- en: 'Using attribute arrays can speed up programming, but for rendering all data
    still needs to be copied to the graphics card on each use. This can be avoided
    with OpenGL buffer objects. Qt provides a neat interface for such objects with
    its `QOpenGLBuffer` class. The currently supported buffer types are vertex buffers
    (where the buffer contains vertex information), index buffers (where the content
    of the buffer is a set of indexes to other buffers that can be used with `glDrawElements()`),
    and also less-commonly-used pixel pack buffers and pixel unpack buffers. The buffer
    is essentially a block of memory that can be uploaded to the graphics card and
    stored there for faster access. There are different usage patterns available that
    dictate how and when the buffer is transferred between the host memory and the
    GPU memory. The most common pattern is a one-time upload of vertex information
    to the GPU that can later be referred to during rendering as many times as needed.
    Changing an existing application that uses an attribute array to use vertex buffers
    is very easy. First, a buffer needs to be instantiated:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属性数组可以加快编程速度，但为了渲染，每次使用时仍然需要将所有数据复制到图形卡上。这可以通过OpenGL缓冲区对象避免。Qt通过其`QOpenGLBuffer`类提供了一个方便的接口。目前支持的缓冲区类型包括顶点缓冲区（其中缓冲区包含顶点信息）、索引缓冲区（其中缓冲区的内容是一组索引，可以与`glDrawElements()`一起使用），以及较少使用的像素打包缓冲区和像素解包缓冲区。缓冲区本质上是一块内存，可以上传到图形卡并存储在那里以实现更快的访问。有不同使用模式可供选择，这些模式决定了缓冲区如何在主机内存和GPU内存之间传输以及何时传输。最常见模式是一次性将顶点信息上传到GPU，之后在渲染过程中可以多次引用。将使用属性数组的现有应用程序更改为使用顶点缓冲区非常简单。首先，需要实例化一个缓冲区：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, its usage pattern needs to be set. In case of a one-time upload, the
    most appropriate type is `StaticDraw`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，需要设置其使用模式。在一次性上传的情况下，最合适的类型是`StaticDraw`：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, the buffer itself has to be created and bound to the current context
    (for example, in the `initializeGL()` function):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，必须创建并绑定缓冲区到当前上下文（例如，在`initializeGL()`函数中）：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The next step is to actually allocate some memory for the buffer and initialize
    it:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是实际为缓冲区分配一些内存并初始化它：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To change data in the buffer, there are two options. First, you can attach
    the buffer to the application''s memory space, using a call to `map()` and then
    fill the data, using a returned pointer:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改缓冲区中的数据，有两种选择。首先，你可以通过调用`map()`将缓冲区附加到应用程序的内存空间，然后使用返回的指针填充数据：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'An alternative approach is to write to the buffer directly, using `write()`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是直接使用`write()`写入缓冲区：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, the buffer can be used in the shader program in a way similar to an
    attribute array:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，缓冲区可以以类似于属性数组的方式在着色器程序中使用：
- en: '[PRE37]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The result is that all the data is uploaded to the GPU once and then used as
    needed by the current shader program or other OpenGL call-supporting buffer objects.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是所有数据一次性上传到GPU，然后根据当前着色器程序或其他OpenGL调用支持的缓冲区对象的需求使用。
- en: Using multiple OpenGL versions
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多个OpenGL版本
- en: 'Earlier in this chapter, we discussed a family of `QOpenGLFunctions` classes
    that provide access to OpenGL functions included in a specific OpenGL profile.
    If your whole application can use one profile, you can just select the appropriate
    Qt class and use it. However, sometimes you don''t want the application to shut
    down completely if the requested profile is not supported on the current system.
    Instead, you can relax your requirements and use an older OpenGL version and provide
    simplified but still working rendering for systems that don''t support the new
    profile. In Qt, you can implement such an approach using `QOpenGLContext::versionFunctions()`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期部分，我们讨论了一组 `QOpenGLFunctions` 类，这些类提供了访问特定 OpenGL 配置中包含的 OpenGL 函数的方法。如果你的整个应用程序可以使用一个配置，你只需选择合适的
    Qt 类并使用它即可。然而，有时你不想在当前系统不支持请求的配置时完全关闭应用程序。相反，你可以放宽要求，使用较旧的 OpenGL 版本，并为不支持新配置的系统提供简化但仍可工作的渲染。在
    Qt 中，你可以使用 `QOpenGLContext::versionFunctions()` 来实现这种方法：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the `initializeGL()` function, we try to request wrapper objects for multiple
    OpenGL versions. If the requested version is not currently available, `versionFunctions()`
    will return `nullptr`. In the `paintGL()` function, we use the best available
    version to perform the actual rendering.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `initializeGL()` 函数中，我们尝试请求多个 OpenGL 版本的包装对象。如果请求的版本当前不可用，`versionFunctions()`
    将返回 `nullptr`。在 `paintGL()` 函数中，我们使用最佳可用版本进行实际渲染。
- en: 'Next, you can use the `QSurfaceFormat` class to specify the OpenGL version
    and profile you want to use:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以使用 `QSurfaceFormat` 类来指定你想要使用的 OpenGL 版本和配置：
- en: '[PRE39]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: By requesting the core profile, you can ensure that old deprecated functionality
    will not be available in our application.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通过请求核心配置，你可以确保旧的和已弃用的功能不会在我们的应用程序中可用。
- en: Offscreen rendering
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 离屏渲染
- en: Sometimes, it is useful to render an OpenGL scene not to the screen but to some
    image that can be later processed externally or used as a texture in some other
    part of rendering. For that, the concept of **Framebuffer Objects** (**FBO**)
    was created. An FBO is a rendering surface that behaves like the regular device
    frame buffer, with the only exception that the resulting pixels do not land on
    the screen. An FBO target can be bound as a texture in an existing scene or dumped
    as an image to regular computer memory. In Qt, such an entity is represented by
    a `QOpenGLFramebufferObject` class.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，将 OpenGL 场景渲染到屏幕上而不是某些图像是有用的，这些图像可以稍后在外部处理或用作渲染其他部分的纹理。为此，创建了 **帧缓冲对象**（**FBO**）的概念。FBO
    是一个渲染表面，其行为类似于常规设备帧缓冲区，唯一的区别是生成的像素不会出现在屏幕上。FBO 目标可以作为纹理绑定到现有场景中，或作为图像输出到常规计算机内存中。在
    Qt 中，这样的实体由 `QOpenGLFramebufferObject` 类表示。
- en: Once you have a current OpenGL context, you can create an instance of `QOpenGLFramebufferObject`,
    using one of the available constructors. A mandatory parameter to pass is the
    size of the canvas (either as a `QSize` object or as a pair of integers describing
    the width and height of the frame). Different constructors accept other parameters,
    such as the type of texture the FBO is to generate or a set of parameters encapsulated
    in `QOpenGLFramebufferObjectFormat`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有一个当前的 OpenGL 上下文，你可以使用其中一个可用的构造函数创建 `QOpenGLFramebufferObject` 的实例。必须传递的强制参数是画布的大小（可以是
    `QSize` 对象，也可以是一对整数，描述帧的宽度和高度）。不同的构造函数接受其他参数，例如 FBO 将生成的纹理类型或封装在 `QOpenGLFramebufferObjectFormat`
    中的参数集。
- en: When the object is created, you can issue a `bind()` call on it, which switches
    the OpenGL pipeline to render to the FBO instead of the default target. A complementary
    method is `release()`, which restores the default rendering target. Afterward,
    the FBO can be queried to return the ID of the OpenGL texture (using the `texture()`
    method) or to convert the texture to `QImage` (by invoking `toImage()`).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象被创建时，你可以在它上面发出一个 `bind()` 调用，这将切换 OpenGL 管道以渲染到 FBO 而不是默认目标。一个互补的方法是 `release()`，它将恢复默认渲染目标。之后，可以查询
    FBO 以返回 OpenGL 纹理的 ID（使用 `texture()` 方法）或将纹理转换为 `QImage`（通过调用 `toImage()`）。
- en: Vulkan in Qt applications
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Qt 应用程序中使用 Vulkan
- en: OpenGL has undergone significant changes as graphics cards hardware has evolved.
    Many old parts of OpenGL API are now deprecated, and even up-to-date API is not
    ideal for utilizing the capabilities of modern hardware. Vulkan was designed as
    an attempt to create an API more suitable for this purpose.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 随着图形卡硬件的发展，OpenGL 已经经历了重大变化。OpenGL API 的许多旧部分现在已被弃用，即使是更新的 API 也不太适合利用现代硬件的能力。Vulkan
    的设计初衷是尝试创建一个更适合此目的的 API。
- en: Vulkan is a new API that can be used instead of OpenGL to perform hardware-accelerated
    rendering and computation. While Vulkan is more verbose and complex than OpenGL,
    it closely represents the actual interaction between CPU and GPU. This allows
    Vulkan users to achieve better control over utilizing GPU resources, which can
    lead to better performance. The first stable version of Vulkan API was released
    in 2016.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan 是一种新的 API，可以用作 OpenGL 的替代品，以执行硬件加速的渲染和计算。虽然 Vulkan 比 OpenGL 更冗长和复杂，但它更接近
    CPU 和 GPU 之间的实际交互。这使得 Vulkan 用户能够更好地控制 GPU 资源的利用，从而可能带来更好的性能。Vulkan API 的第一个稳定版本于
    2016 年发布。
- en: While Vulkan is a cross-platform solution, a Vulkan application still needs
    to contain a bit of platform-specific code, mainly related to window creation
    and event handling. Since Version 5.10, Qt provides a way to use Vulkan along
    with Qt's existing window and event infrastructure. You still retain full access
    to the original Vulkan API for rendering, but, at the same time, you can use the
    already familiar Qt API for everything else.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Vulkan 是一个跨平台解决方案，但 Vulkan 应用程序仍然需要包含一些平台特定的代码，主要与窗口创建和事件处理相关。自 5.10 版本以来，Qt
    提供了一种方法，可以在保留对原始 Vulkan API 渲染的完全访问权限的同时，使用 Qt 的现有窗口和事件基础设施来使用 Vulkan。您仍然可以完全访问原始
    Vulkan API 进行渲染，同时，您还可以使用已经熟悉的 Qt API 来处理其他所有事情。
- en: As with OpenGL, we will not give an in-depth guide of Vulkan here. We will only
    provide simple examples and cover the interaction between Qt and Vulkan. If you
    need more information about Vulkan, you can refer to its official page at [https://www.khronos.org/vulkan/](https://www.khronos.org/vulkan/).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与 OpenGL 类似，这里我们不会深入讲解 Vulkan。我们只会提供一些简单示例，并涵盖 Qt 和 Vulkan 之间的交互。如果您需要更多关于 Vulkan
    的信息，可以参考其官方页面 [https://www.khronos.org/vulkan/](https://www.khronos.org/vulkan/)。
- en: Preparing the developing environment
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备开发环境
- en: Before you can start developing games with Vulkan and Qt, you need to make a
    few preparations. First, you need to install the Vulkan SDK. To do that, head
    to [https://www.lunarg.com/vulkan-sdk/](https://www.lunarg.com/vulkan-sdk/), download
    a file for your operating system, and execute or unpack it. Examine the `index.html`
    file in the `doc` subdirectory in the installation folder to see whether you need
    to perform any additional actions.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开始使用 Vulkan 和 Qt 开发游戏之前，您需要做一些准备工作。首先，您需要安装 Vulkan SDK。为此，请访问 [https://www.lunarg.com/vulkan-sdk/](https://www.lunarg.com/vulkan-sdk/)，下载适用于您操作系统的文件，并执行或解压它。检查安装文件夹中的
    `doc` 子目录下的 `index.html` 文件，以查看是否需要执行任何额外操作。
- en: Next, you need a Qt build with Vulkan support; it must be Qt 5.10 or later.
    If you have installed the most recent version available through the installer,
    it may already be suitable.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要一个支持 Vulkan 的 Qt 构建；它必须是 Qt 5.10 或更高版本。如果您通过安装程序安装了最新版本，它可能已经适合使用。
- en: To check whether your Qt version has Vulkan support, create a new Qt Console
    Application, ensure that you select the kit corresponding to the most recently
    installed Qt version. The Vulkan SDK also requires you to set some environment
    variables, such as `VULKAN_SDK`, `PATH`, `LD_LIBRARY_PATH`, and `VK_LAYER_PATH`
    (exact names and values can depend on the operating system, so refer to the SDK
    documentation). You can edit environment variables for your project by switching
    to Qt Creator's Projects pane and expanding the Build Environment section.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查您的 Qt 版本是否支持 Vulkan，创建一个新的 Qt 控制台应用程序，确保您选择了对应于最新安装的 Qt 版本的工具包。Vulkan SDK
    还要求您设置一些环境变量，例如 `VULKAN_SDK`、`PATH`、`LD_LIBRARY_PATH` 和 `VK_LAYER_PATH`（确切名称和值可能取决于操作系统，因此请参阅
    SDK 文档）。您可以通过切换到 Qt Creator 的“项目”面板并展开“构建环境”部分来编辑项目环境变量。
- en: 'Put the following code in `main.cpp`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码放入 `main.cpp` 文件中：
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Additionally, adjust the project file so that we actually have a Qt GUI application
    instead of a console application:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，调整项目文件，以便我们实际上有一个 Qt GUI 应用程序而不是控制台应用程序：
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If the project builds successfully, your setup is complete.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目构建成功，则您的设置已完成。
- en: If the compiler can't find the `vulkan`/`vulkan.h` header, then the Vulkan SDK
    was not installed properly or its headers are not located in the default include
    path. Check the Vulkan SDK documentation to see whether you have missed something.
    You can also switch to the Projects pane of Qt Creator and edit the build environment
    of the project to make the installed headers visible. Depending on the compiler,
    you may need to set the `INCLUDEPATH` or `CPATH` environment variable.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译器找不到 `vulkan`/`vulkan.h` 头文件，那么 Vulkan SDK 没有正确安装，或者其头文件不在默认的包含路径中。请检查 Vulkan
    SDK 文档，看是否遗漏了某些内容。您还可以切换到 Qt Creator 的“项目”面板，并编辑项目的构建环境，使已安装的头文件可见。根据编译器的不同，您可能需要设置
    `INCLUDEPATH` 或 `CPATH` 环境变量。
- en: If you have a compile error corresponding to the `QVulkanInstance` header, you
    are using a Qt version prior to 5.10\. Ensure that you install a recent version
    and select the correct kit on the Projects pane of Qt Creator.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到了与 `QVulkanInstance` 头文件对应的编译错误，您正在使用 5.10 版本之前的 Qt 版本。请确保安装一个较新版本，并在 Qt
    Creator 的“项目”面板上选择正确的工具包。
- en: 'However, if the `QVulkanInstance` includes directive works, but the `QVulkanInstance`
    class is still not defined, it means that your Qt build lacks Vulkan support. In
    this case, first try to install the most recent version using the official installer,
    if you haven''t done so already:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果 `QVulkanInstance` 包含指令工作，但 `QVulkanInstance` 类仍然未定义，这意味着您的 Qt 构建缺少 Vulkan
    支持。在这种情况下，首先尝试使用官方安装程序安装最新版本，如果您还没有这样做的话：
- en: Close Qt Creator
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 Qt Creator
- en: Launch the **Maintenance Tool** executable from the Qt installation directory
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Qt 安装目录启动 **维护工具** 可执行文件
- en: Select Add or remove components
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“添加或删除组件”
- en: Select the most recent Desktop Qt version
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择最新的桌面 Qt 版本
- en: Confirm the changes
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认更改
- en: After the installation is done, re-open Qt Creator, switch to the Projects pane,
    and select the new kit for the project.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，重新打开 Qt Creator，切换到“项目”面板，并选择项目的新工具包。
- en: Unfortunately, at the time of writing, the Qt builds available through the official
    installer do not have Vulkan support. It's possible (and likely) that it will
    be enabled in the future versions.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在撰写本文时，通过官方安装程序提供的 Qt 构建版本没有 Vulkan 支持。未来版本可能（并且很可能）会启用。
- en: If the `QVulkanInstance` class is still not recognized, you have to build Qt
    from sources. This process varies depending on the operating system and the Qt
    version, so we will not cover the details in the book. Go to the [http://doc.qt.io/qt-5/build-sources.html](http://doc.qt.io/qt-5/build-sources.html)
    page and follow the instructions corresponding to your operating system. If the
    Vulkan SDK is properly installed, the output of the `configure` command should
    contain Vulkan ... yes, indicating that Vulkan support is enabled. After you build
    Qt, open Qt Creator's options dialog and set up a Qt version and a kit, as described
    in [Chapter 2](d129202d-f982-4114-b69a-094d0a136fe9.xhtml), *Installation*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `QVulkanInstance` 类仍然未被识别，您必须从源代码构建 Qt。这个过程取决于操作系统和 Qt 版本，因此我们不会在书中详细说明。请访问
    [http://doc.qt.io/qt-5/build-sources.html](http://doc.qt.io/qt-5/build-sources.html)
    页面，并遵循您操作系统的说明。如果 Vulkan SDK 已正确安装，`configure` 命令的输出应包含 Vulkan ... yes，表示已启用 Vulkan
    支持。在构建 Qt 后，打开 Qt Creator 的选项对话框，并设置 Qt 版本和工具包，如 [第 2 章](d129202d-f982-4114-b69a-094d0a136fe9.xhtml)
    中所述的“安装”部分。
- en: 'Finally, select the new kit for the project on the Projects pane:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在“项目”面板上选择项目的新工具包：
- en: '![](img/9342b3d0-8bf3-4324-b01c-ce58faa85494.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9342b3d0-8bf3-4324-b01c-ce58faa85494.png)'
- en: If you've done everything correctly, the project should now build and execute
    successfully.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经正确完成所有操作，项目现在应该能够成功构建和执行。
- en: Vulkan instance, window, and renderer
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vulkan 实例、窗口和渲染器
- en: Before we start creating our first minimal Vulkan application, let's get familiar
    with the Qt classes we'll need for the task.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建第一个最小 Vulkan 应用程序之前，让我们熟悉我们将需要的 Qt 类。
- en: Unlike OpenGL, Vulkan doesn't have a global state. Interaction with Vulkan starts
    with the instance object represented by the `VkInstance` type. An application
    usually creates a single `VkInstance` object that contains the application-wide
    state. All other Vulkan objects can only be created from the instance object.
    In Qt, the corresponding class is `QVulkanInstance`. This class provides a convenient
    way to configure Vulkan and then initialize it with the given configuration. You
    can also use its `supportedExtensions()` and `supportedLayers()` functions to
    query supported features before using them. After the configuration is done, you
    should call the `create()` function that actually triggers loading Vulkan library
    and creating a `VkInstance` object. If this function returns `true`, the Vulkan
    instance object is ready to be used.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 与OpenGL不同，Vulkan没有全局状态。与Vulkan的交互从由`VkInstance`类型表示的实例对象开始。应用程序通常创建一个包含应用程序范围状态的单个`VkInstance`对象。所有其他Vulkan对象都只能从实例对象创建。在Qt中，相应的类是`QVulkanInstance`。这个类提供了一种方便的方式来配置Vulkan，然后使用给定的配置初始化它。你还可以使用它的`supportedExtensions()`和`supportedLayers()`函数在使用之前查询支持的功能。配置完成后，你应该调用`create()`函数，该函数实际上触发加载Vulkan库并创建一个`VkInstance`对象。如果这个函数返回`true`，则Vulkan实例对象已准备好使用。
- en: The next step is to create a window capable of Vulkan rendering. This is done
    by subclassing the `QVulkanWindow` class. Similar to `QOpenGLWindow`, `QVulkanWindow`
    extends `QWindow` and provides functionality required for utilizing Vulkan capabilities
    as well as some convenience functions. You can also use virtual functions inherited
    from `QWindow` to handle any events dispatched by Qt's event system. However,
    subclasses of `QVulkanWindow` should not perform any actual rendering. This task
    is delegated to the `QVulkanWindowRenderer` class. The `QVulkanWindow::createRenderer()`
    virtual function will be called once after the window is first shown, and you
    should reimplement this function to return your renderer object.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个能够进行Vulkan渲染的窗口。这是通过派生`QVulkanWindow`类来完成的。类似于`QOpenGLWindow`，`QVulkanWindow`扩展了`QWindow`，并提供了利用Vulkan功能以及一些便利函数的功能。你还可以使用从`QWindow`继承的虚函数来处理Qt事件系统分发的任何事件。然而，`QVulkanWindow`的子类不应执行任何实际的渲染。这项任务委托给了`QVulkanWindowRenderer`类。`QVulkanWindow::createRenderer()`虚函数将在窗口首次显示后立即被调用，你应该重写这个函数以返回你的渲染器对象。
- en: 'Now, about the renderer itself: `QVulkanWindowRenderer` is a simple class containing
    nothing more than a set of virtual functions. You can create your own renderer
    by subclassing `QVulkanWindowRenderer` and re-implementing the only pure virtual
    function called `startNextFrame()`. This function will be called when the drawing
    of the next frame is requested. You can perform all required drawing operations
    in this function and end it with a call to `QVulkanWindow::frameReady()` to indicate
    that the drawing is complete. You can also re-implement other virtual functions
    of the renderer. The most useful of them are `initResources()` and `releaseResources()`,
    which allow you to create required resources, store them in private members of
    your renderer class, and then destroy them when necessary.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于渲染器本身：`QVulkanWindowRenderer`是一个简单的类，除了包含一组虚函数之外，没有其他内容。你可以通过派生`QVulkanWindowRenderer`并重写唯一的纯虚函数`startNextFrame()`来创建自己的渲染器。这个函数将在请求绘制下一帧时被调用。你可以在该函数中执行所有必要的绘图操作，并在调用`QVulkanWindow::frameReady()`以指示绘图完成时结束。你还可以重写渲染器的其他虚函数。其中最有用的是`initResources()`和`releaseResources()`，它们允许你创建所需资源，将它们存储在渲染器类的私有成员中，并在必要时销毁它们。
- en: These three classes define the basic structure of your Vulkan application. Let's
    see them in action.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个类定义了你的Vulkan应用程序的基本结构。让我们看看它们是如何工作的。
- en: Time for action – Creating the minimal Vulkan project
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 创建最小化的Vulkan项目
- en: 'We''ve already created a project while testing the developing environment.
    Now let''s add two new classes to the project. One class named `MyWindow` should
    be derived from `QVulkanWindow`, and the other class named `MyRenderer` should
    be derived from `QVulkanWindowRenderer`. Implement the window''s `createRenderer()`
    virtual function:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试开发环境时，我们已经创建了一个项目。现在让我们向项目中添加两个新的类。一个名为`MyWindow`的类应该从`QVulkanWindow`派生，另一个名为`MyRenderer`的类应该从`QVulkanWindowRenderer`派生。实现窗口的`createRenderer()`虚函数：
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Add the `QVulkanWindow *m_window` private field to the renderer class. Implement
    the constructor to initialize this field and override the `startNextFrame()` virtual
    function, as shown:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 将`QVulkanWindow *m_window`私有字段添加到渲染器类中。实现构造函数以初始化此字段，并重写`startNextFrame()`虚函数，如下所示：
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, edit the `main()` function:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，编辑`main()`函数：
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: When you compile and run the project, a blank window with a black background
    should appear.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编译并运行项目时，应该出现一个带有黑色背景的空白窗口。
- en: What just happened?
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We've created a window that will be rendered using Vulkan. The `main()` function
    initializes Vulkan, creates a window, passes the instance object to the window,
    and shows it on the screen. As usual, the final call to `exec()` starts Qt's event
    loop. When the window is shown, Qt will call the `createRenderer()` function on
    the window and a new renderer object will be created in your implementation of
    this function. The renderer is attached to the window and will automatically be
    deleted along with it, so there is no need to delete it manually. Each time the
    window needs to be painted, Qt will call the renderer's `startNextFrame()` function.
    We don't perform any painting yet, so the window remains blank.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已创建一个将使用Vulkan进行渲染的窗口。`main()`函数初始化Vulkan，创建一个窗口，将实例对象传递给窗口，并在屏幕上显示它。像往常一样，对`exec()`的最终调用启动Qt的事件循环。当窗口显示时，Qt将在窗口上调用`createRenderer()`函数，并在你的函数实现中创建一个新的渲染器对象。渲染器附加到窗口，并将自动与其一起删除，因此无需手动删除。每次窗口需要绘制时，Qt都会调用渲染器的`startNextFrame()`函数。我们还没有进行任何绘制，因此窗口保持空白。
- en: It's important that the drawing of every frame ends with a call to `frameReady()`.
    Until this function is called, processing of the frame cannot be completed. However,
    it's not required to call this function directly from the `startNextFrame()` function.
    You can delay this call if you need, for example, to wait for calculations to
    complete in a separate thread.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 每一帧的绘制都以调用`frameReady()`结束是很重要的。在此函数被调用之前，帧的处理不能完成。然而，并不需要直接从`startNextFrame()`函数中调用此函数。如果你需要，可以延迟调用，例如，等待在单独的线程中完成计算。
- en: Similar to how `paintEvent()` works, `startNextFrame()` will not be called continuously
    by default. It will only be called once after showing the window. It will also
    be called each time a part of the window is exposed (for example, as a result
    of moving a window or restoring a minimized window). If you need to render a dynamic
    scene continuously, call `m_window->requestUpdate()` after calling `m_window->frameReady()`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 与`paintEvent()`的工作方式类似，`startNextFrame()`默认情况下不会连续调用。它只会在显示窗口后调用一次。它还会在窗口的任何部分暴露时调用（例如，由于移动窗口或恢复最小化窗口的结果）。如果你需要连续渲染动态场景，请在调用`m_window->frameReady()`后调用`m_window->requestUpdate()`。
- en: Using Vulkan types and functions
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vulkan类型和函数
- en: 'We can let Qt handle loading the Vulkan library and resolving functions for
    us. It works similar to the `QOpenGLFunctions` set of classes. Qt provides two
    functions classes for Vulkan:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以让Qt处理加载Vulkan库和为我们解析函数。它的工作方式类似于`QOpenGLFunctions`类集。Qt为Vulkan提供了两个函数类：
- en: The `QVulkanFunctions` class provides access to the Vulkan functions that are
    not device-specific
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QVulkanFunctions`类提供了访问非设备特定Vulkan函数的接口。'
- en: The `QVulkanDeviceFunctions` class provides functions that work on a specific `VkDevice`
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QVulkanDeviceFunctions`类提供了在特定`VkDevice`上工作的函数。'
- en: 'You can obtain these objects by calling the `functions()` and `deviceFunctions(VkDevice
    device)` methods of the `QVulkanInstance` class, respectively. You will usually
    use the device functions a lot in the renderer, so a common pattern is to add
    the `QVulkanDeviceFunctions *m_devFuncs` private field to your renderer class
    and initialize it in the `initResources()` virtual function:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用`QVulkanInstance`类的`functions()`和`deviceFunctions(VkDevice device)`方法来获取这些对象。你通常会在渲染器中大量使用设备函数，因此一个常见的模式是在你的渲染器类中添加`QVulkanDeviceFunctions
    *m_devFuncs`私有字段，并在`initResources()`虚函数中初始化它：
- en: '[PRE45]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now you can use `m_devFuncs` to access the Vulkan API functions. We won't use
    them directly, so we don't need to figure out how to link against the Vulkan library
    on each platform. Qt does this job for us.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用`m_devFuncs`来访问Vulkan API函数。我们不会直接使用它们，因此不需要为每个平台确定如何链接到Vulkan库。Qt为我们完成这项工作。
- en: As for structures, unions, and typedefs, we can use them directly without worrying
    about the platform details. It's enough to have the Vulkan SDK headers present
    in the system.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对于结构体、联合体和类型定义，我们可以直接使用它们，无需担心平台细节。只要系统中存在Vulkan SDK的头文件就足够了。
- en: Time for action – Drawing with a dynamic background color
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态背景颜色绘制的时间到了
- en: Let's see how we can use the Vulkan API in our Qt project to change the background
    color of the window. We'll cycle through all possible hues of the color while
    retaining constant saturation and lightness. This may sound complicated when you
    think about a color in RGB space, but it's actually very easy if you work with
    the HSL (Hue, Saturation, Lightness) color model. Luckily, `QColor` supports multiple
    color models, including HSL.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在我们的Qt项目中使用Vulkan API来改变窗口的背景颜色。我们将循环遍历所有可能的色调，同时保持饱和度和亮度不变。当你想到在RGB空间中的颜色时，这听起来可能很复杂，但如果你使用HSL（色调、饱和度、亮度）颜色模型工作，实际上非常简单。幸运的是，`QColor`支持多种颜色模型，包括HSL。
- en: 'First, add and initialize the `m_devFuncs` private field, as just shown. Next,
    add the `float m_hue` private field that will hold the current hue of the background
    color. Set its initial value to zero. We can now start writing our `startNextFrame()`
    function that will do all the magic. Let''s go through it piece by piece. First,
    we increment our `m_hue` variable and ensure that we don''t go out of bounds;
    then, we use the `QColor::fromHslF()` function to construct a `QColor` value based
    on given hue, saturation, and lightness (each of them ranges from 0 to 1):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，添加并初始化`m_devFuncs`私有字段，就像刚刚展示的那样。接下来，添加一个`float m_hue`私有字段，它将保存背景颜色的当前色调。将其初始值设置为零。现在我们可以开始编写我们的`startNextFrame()`函数，它将完成所有的魔法。让我们一步一步来看。首先，我们增加我们的`m_hue`变量，并确保我们不会超出范围；然后，我们使用`QColor::fromHslF()`函数根据给定的色调、饱和度和亮度（它们的范围都是0到1）来构建一个`QColor`值：
- en: '[PRE46]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we use this `color` variable to construct a `VkClearValue` array that
    we''ll use for setting the background color:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用这个`color`变量来构建一个`VkClearValue`数组，我们将用它来设置背景颜色：
- en: '[PRE47]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To start a new render pass in Vulkan, we need to initialize a `VkRenderPassBeginInfo`
    structure. It requires a lot of data, but, luckily, `QVulkanWindow` provides most
    of the data for us. We just need to put it into the structure and use the `clearValues`
    array we set up earlier:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Vulkan中开始一个新的渲染过程，我们需要初始化一个`VkRenderPassBeginInfo`结构。它需要很多数据，但幸运的是，`QVulkanWindow`为我们提供了大部分数据。我们只需要将其放入结构中，并使用我们之前设置的`clearValues`数组：
- en: '[PRE48]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, it''s time to perform the rendering:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是时候进行渲染了：
- en: '[PRE49]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `vkCmdBeginRenderPass()` Vulkan API function will begin the render pass,
    which will result in clearing the window with the color we've set. Since we don't
    have anything else to draw, we complete the render pass immediately using the `vkCmdEndRenderPass()`
    function. Then, we indicate that we've already done everything we want for this
    frame by calling the `frameReady()` function. This allows Qt to advance the rendering
    loop. As the final step, we request an update of the window to ensure that the
    new frame will be requested soon and the color animation will go on.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`vkCmdBeginRenderPass()` Vulkan API函数将开始渲染过程，这将导致清除我们设置的颜色的窗口。由于我们没有其他东西要绘制，我们立即使用`vkCmdEndRenderPass()`函数完成渲染过程。然后，我们通过调用`frameReady()`函数来表明我们已经完成了这个帧的所有操作。这允许Qt推进渲染循环。作为最后一步，我们请求更新窗口，以确保新帧将很快被请求，颜色动画将继续。'
- en: 'If you run the project now, you should see a window that constantly changes
    its background color:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行项目，你应该会看到一个不断改变其背景颜色的窗口：
- en: '![](img/e9241a73-f35a-4db6-bc40-79b7c45f456c.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e9241a73-f35a-4db6-bc40-79b7c45f456c.png)'
- en: We would love to show a more advanced example. However, even drawing a simple
    triangle in Vulkan usually requires a few hundred lines of code, because Vulkan
    requires you to explicitly set up a lot of things. While Qt provides a lot of
    helper classes for OpenGL rendering, it does not contain any similar classes that
    would help with Vulkan rendering or computation (as of Qt 5.10), so there is nothing
    specific to Qt in these tasks.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很乐意展示一个更高级的例子。然而，即使在Vulkan中绘制一个简单的三角形通常也需要几百行代码，因为Vulkan要求你明确设置很多东西。虽然Qt为OpenGL渲染提供了许多辅助类，但它并没有包含任何类似的类来帮助进行Vulkan渲染或计算（截至Qt
    5.10），因此在这些任务中并没有针对Qt的具体内容。
- en: If you want to deepen your knowledge of Vulkan, you can study the documentation
    and tutorials present on its official website and the Vulkan SDK website. Qt also
    includes several good examples based on Vulkan, such as Hello Vulkan Triangle, Hello
    Vulkan Texture, and Hello Vulkan Cubes.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想深化你对 Vulkan 的了解，你可以研究其官方网站和 Vulkan SDK 网站上的文档和教程。Qt 还包含一些基于 Vulkan 的良好示例，例如 Hello
    Vulkan Triangle、Hello Vulkan Texture 和 Hello Vulkan Cubes。
- en: Logs and validation
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志和验证
- en: 'Qt automatically receives messages from the Vulkan library and puts them into
    Qt''s own logging system. The critical errors will be passed to `qWarning()`,
    so they will appear in the application output by default. However, Qt also logs
    additional information that can be useful when debugging. This information is
    hidden by default, but you can make it visible by adding the following line to
    the `main()` function just after the construction of `QGuiApplication`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 自动接收来自 Vulkan 库的消息并将它们放入 Qt 的日志系统中。关键错误将通过 `qWarning()` 传递，因此它们默认会出现在应用程序输出中。然而，Qt
    还记录了在调试时可能有用的附加信息。默认情况下，这些信息是隐藏的，但你可以通过在 `main()` 函数中添加以下行来使其可见，就在 `QGuiApplication`
    构造之后：
- en: '[PRE50]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The Vulkan API does not perform any sanity checks by default. If you pass an
    invalid parameter to a Vulkan API function, the application may silently crash,
    or work inconsistently. However, you can enable **validation layers** for your
    Vulkan instance. They do not change the functionality of the API calls, but they
    enable additional checks when possible. It''s a good idea to enable validation
    layers in a debug build. You can do that by calling `setLayers()` on the instance
    object before calling `create()`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan API 默认不执行任何健全性检查。如果你向 Vulkan API 函数传递一个无效的参数，应用程序可能会静默崩溃，或者工作不一致。然而，你可以为你的
    Vulkan 实例启用 **验证层**。它们不会改变 API 调用的功能，但它们在可能的情况下启用额外的检查。在调试构建中启用验证层是一个好主意。你可以在调用
    `create()` 之前通过在实例对象上调用 `setLayers()` 来实现这一点：
- en: '[PRE51]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Keep in mind that an attempt to request a currently unsupported layer or extension
    will be ignored by Qt.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，尝试请求当前不受支持的层或扩展将被 Qt 忽略。
- en: 'Let''s test the validation layers by inserting an invalid parameter to our
    code:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在我们的代码中插入一个无效参数来测试验证层：
- en: '[PRE52]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'When you run the application, Qt should print a warning to the application
    output:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行应用程序时，Qt 应该将警告打印到应用程序输出：
- en: '[PRE53]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If the warning does not appear, it means that the validation layers are not
    available or they failed to load. Check the application output for the presence
    of validation layers (they will be printed after the "Supported Vulkan instance
    layers" line) and any library loading errors. Ensure that you've set up the Vulkan
    SDK and the project's environment variables according to the documentation.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有出现警告，这意味着验证层不可用或加载失败。检查应用程序输出中验证层的存在（它们将在“支持的 Vulkan 实例层”行之后打印出来）以及任何库加载错误。确保你已经根据文档设置了
    Vulkan SDK 和项目的环境变量。
- en: 'However, keep in mind that validation layers have a performance impact on your
    application. You should probably disable them in your final builds. You can also
    disable redirecting Vulkan''s debug output to the Qt logging system, using the
    following code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，验证层会对你的应用程序性能产生影响。你可能在最终构建中禁用它们。你还可以使用以下代码禁用将 Vulkan 的调试输出重定向到 Qt 日志系统：
- en: '[PRE54]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Combining OpenGL or Vulkan with Qt Widgets
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 OpenGL 或 Vulkan 与 Qt Widgets 结合使用
- en: Sometimes you want to combine the powers of accelerated graphics and Qt Widgets.
    While OpenGL and Vulkan are great for rendering high-performance 2D and 3D scenes,
    the Qt Widgets module is far easier to use for creating user interfaces. Qt offers
    a few ways to combine them into a single powerful interface. This can be useful
    if your application depends heavily on widgets (for example, the 3D view is only
    one of the views in your application and is controlled using a bunch of other
    widgets surrounding the main view).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能想结合加速图形和 Qt Widgets 的功能。虽然 OpenGL 和 Vulkan 在渲染高性能 2D 和 3D 场景方面非常出色，但 Qt
    Widgets 模块在创建用户界面方面要容易得多。Qt 提供了几种方法将它们结合成一个单一强大的界面。这在你应用程序严重依赖小部件时非常有用（例如，3D 视图只是你应用程序中的视图之一，并且通过围绕主视图的一堆其他小部件来控制）。
- en: The first way is the `QWidget::createWindowContainer()` function. It takes an
    arbitrary `QWindow` and creates a `QWidget` that keeps the window within its bounds.
    That widget can be put into another widget and can be managed by a layout. While
    the window appears to be embedded into another window, it still remains a native
    window from the operating system's perspective, and any accelerated rendering
    will be performed directly on the window without a heavy performance impact. This
    approach has a few limitations, though. For example, the embedded window will
    always stack on top of other widgets. However, it's suitable in most cases.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是`QWidget::createWindowContainer()`函数。它接受一个任意的`QWindow`并创建一个`QWidget`，该窗口保持在其边界内。这个小部件可以被放入另一个小部件中，并且可以通过布局进行管理。虽然窗口看起来是嵌入到另一个窗口中的，但从操作系统的角度来看，它仍然是一个本地窗口，任何加速渲染都将直接在窗口上执行，而不会对性能产生重大影响。尽管这种方法有一些限制。例如，嵌入的窗口将始终堆叠在其他小部件之上。然而，它在大多数情况下都是合适的。
- en: 'Let''s return to our OpenGL cube project and put it into a layout with an additional
    label:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的OpenGL立方体项目，并给它添加一个额外的标签：
- en: '[PRE55]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Instead of showing the OpenGL window, we created a widget and put the window
    into the layout of that widget:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有显示OpenGL窗口，而是创建了一个小部件，并将窗口放入该小部件的布局中：
- en: '![](img/a629f0d8-28a1-4045-9821-edbff584173f.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a629f0d8-28a1-4045-9821-edbff584173f.png)'
- en: You can apply this approach to any `QWindow`, including Vulkan-based windows
    and Qt Quick windows, which we'll work with in subsequent chapters.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这种方法应用于任何`QWindow`，包括基于Vulkan的窗口和Qt Quick窗口，我们将在随后的章节中处理这些窗口。
- en: There is another way to solve the same task, but it only works with OpenGL.
    You can simply replace `QOpenGLWindow` with `QOpenGLWidget` to turn a window into
    a fully featured widget. The API of `QOpenGLWidget` (including virtual functions)
    is compatible with `QOpenGLWindow`, so it can act as a drop-in replacement. There
    are no limitations for the  stacking order, focus, or opacity of `QOpenGLWidget`.
    You can even mix the OpenGL rendering with `QPainter` operations. However, this
    solution has a performance cost. `QOpenGLWindow` renders directly to the given
    window, while `QOpenGLWidget` first renders to an offscreen buffer that is then
    rendered to the widget, so it will be slower.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 有另一种解决相同任务的方法，但它仅适用于OpenGL。你可以简单地用`QOpenGLWidget`替换`QOpenGLWindow`，将窗口转换成一个功能齐全的小部件。`QOpenGLWidget`的API（包括虚拟函数）与`QOpenGLWindow`兼容，因此它可以作为即插即用的替代品。`QOpenGLWidget`的堆叠顺序、焦点或透明度没有任何限制。你甚至可以将OpenGL渲染与`QPainter`操作混合。然而，这种解决方案会有性能成本。`QOpenGLWindow`直接渲染到指定的窗口，而`QOpenGLWidget`首先渲染到一个离屏缓冲区，然后该缓冲区被渲染到小部件上，所以它会慢一些。
- en: Pop quiz
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 突击测验
- en: Q1\. Which of the following programming languages is accepted by the `QOpenGLShader::compileSourceCode()`
    function?
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 以下哪种编程语言被`QOpenGLShader::compileSourceCode()`函数接受？
- en: C
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C
- en: C++
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C++
- en: GLSL
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GLSL
- en: Q2\. Which virtual function of the `QOpenGLWindow` class should you implement
    to perform OpenGL painting?
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 你应该实现`QOpenGLWindow`类的哪个虚拟函数来执行OpenGL绘图？
- en: '`paintGL()`'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`paintGL()`'
- en: '`paintEvent()`'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`paintEvent()`'
- en: '`makeCurrent()`'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`makeCurrent()`'
- en: Q3\. When should you delete the object of your `QVulkanWindowRenderer` subclass?
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 你应该在何时删除你的`QVulkanWindowRenderer`子类的对象？
- en: In the destructor of the `QVulkanWindow` subclass
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`QVulkanWindow`子类的析构函数中
- en: After deleting the `QVulkanInstance` object
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在删除`QVulkanInstance`对象之后
- en: Never
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从不
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about using OpenGL and Vulkan graphics with Qt.
    With this knowledge, you can create hardware accelerated 2D and 3D graphics. We
    also explored Qt classes that simplify usage of these technologies in Qt applications. If
    you want to sharpen your OpenGL and Vulkan skills, you can study numerous books
    and articles focused on these topics. Qt provides very transparent access to hardware
    accelerated graphics, so adapting any pure OpenGL or Vulkan approaches for Qt
    should be easy. If you prefer to have a higher-level API for accelerated graphics,
    you should turn your attention to Qt Quick and Qt 3D. We will cover it in the
    last part of this book.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用Qt结合OpenGL和Vulkan图形。有了这些知识，你可以创建硬件加速的2D和3D图形。我们还探讨了Qt类，这些类简化了在Qt应用程序中使用这些技术的过程。如果你想要提高你的OpenGL和Vulkan技能，你可以研究许多专注于这些主题的书籍和文章。Qt提供了非常透明的硬件加速图形访问，因此将任何纯OpenGL或Vulkan方法适配到Qt应该很容易。如果你更喜欢使用高级API进行加速图形，你应该关注Qt
    Quick和Qt 3D。我们将在本书的最后一部分介绍它。
- en: In the next chapter, you will learn to implement scripting in your game. This
    will make it more extensible and easier to modify. Scripting can also be used
    to enable modding in your game, allowing players to customize the gameplay how
    they want.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何在你的游戏中实现脚本编写。这将使游戏更加可扩展，并且更容易修改。脚本还可以用来在你的游戏中启用模组，允许玩家按照他们想要的定制游戏玩法。
