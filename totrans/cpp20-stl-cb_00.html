<html><head></head><body>
		<div id="_idContainer005">
			<h1 id="_idParaDest-5"><a id="_idTextAnchor004"/>Preface</h1>
			<h1 id="_idParaDest-6"><a id="_idTextAnchor005"/>About this book</h1>
			<p>The <em class="italic">C++20 STL Cookbook</em> provides recipes to help you get the most out of the C++ STL (Standard Template Library), including new features introduced with C++20. </p>
			<p>C++ is a rich and powerful language. Built upon C, with syntactic extensions for type safety, generic programming, and object-oriented programming, C++ is essentially a low-level language. The STL provides a broad set of higher-level classes, functions, and algorithms to make your programming job easier, more effective, and less prone to error. </p>
			<p>I've often said that C++ is five languages cobbled into one. The formal specification includes 1) the entire <em class="italic">C language</em>, 2) C's cryptic-yet-powerful <em class="italic">macro preprocessor</em>, 3) a feature-rich <em class="italic">class/object</em> model, 4) a <em class="italic">generic programming</em> model called <em class="italic">templates</em>, and finally, built upon C++ classes and templates, 5) the <em class="italic">STL</em>.</p>
			<h2 id="_idParaDest-7"><a id="_idTextAnchor006"/>Prerequisite knowledge</h2>
			<p>This book presumes that you have a basic understanding of C++, including syntax, structure, data types, classes and objects, templates, and the STL.</p>
			<p>The recipes and examples in this book presume that you understand the need to <strong class="source-inline">#include</strong> certain headers to use library functions. The recipes don't usually list all the necessary headers, preferring to focus on the techniques at hand. You're encouraged to download the example code, which has all the necessary <strong class="source-inline">#include</strong> directives and other front matter.</p>
			<p>You may download the example code from GitHub: <a href="https://github.com/PacktPublishing/CPP-20-STL-Cookbook">https://github.com/PacktPublishing/CPP-20-STL-Cookbook</a>.</p>
			<p>These assumptions mean that when you see a piece of code like this:</p>
			<p class="source-code">cout &lt;&lt; "hello, world\n";</p>
			<p>You should already know that you'll need to put this code in a <strong class="source-inline">main()</strong> function, you'll need to <strong class="source-inline">#include</strong> the <strong class="source-inline">&lt;iostream&gt;</strong> header, and <strong class="source-inline">cout</strong> is an object in the <strong class="source-inline">std::</strong> namespace:</p>
			<p class="source-code"><strong class="bold">#include</strong> &lt;iostream&gt;</p>
			<p class="source-code">int <strong class="bold">main()</strong> {</p>
			<p class="source-code">    <strong class="bold">std::cout</strong> &lt;&lt; "hello, world\n";</p>
			<p class="source-code">}</p>
			<h2 id="_idParaDest-8"><a id="_idTextAnchor007"/>The STL's power is derived from templates <em class="italic">(a brief primer)</em></h2>
			<p><em class="italic">Templates</em> are how C++ does <em class="italic">generic programming</em>, code that's independent of type while retaining type safety. C++ templates allow you to use tokens as placeholders for types and classes, like this: </p>
			<p class="source-code">template&lt;typename T&gt;</p>
			<p class="source-code">T add_em_up(T&amp; lhs, T&amp; rhs) {</p>
			<p class="source-code">    return lhs + rhs;</p>
			<p class="source-code">}</p>
			<p>A template may be used for classes and/or functions. In this template function, the <strong class="source-inline">T</strong> represents a <em class="italic">generic type</em>, which allows this code to be used in the context of any compatible class or type:</p>
			<p class="source-code">int a{ 72 };  // see <strong class="bold">braced initialization</strong> below</p>
			<p class="source-code">int b{ 47 };</p>
			<p class="source-code">cout &lt;&lt; <strong class="bold">add_em_up&lt;int&gt;(a, b)</strong> &lt;&lt; "\n";</p>
			<p>This invokes the template function with an <strong class="source-inline">int</strong> type. This same code can be used with any type or class that supports the <strong class="source-inline">+</strong> operator.</p>
			<p>When the compiler sees a <em class="italic">template invocation</em>, like <strong class="source-inline">add_em_up&lt;int&gt;(a, b)</strong>, it creates a <em class="italic">specialization</em>. This is what makes the code type safe. When you invoke <strong class="source-inline">add_em_up()</strong> with an <strong class="source-inline">int</strong> type, the specialization will look something like this: </p>
			<p class="source-code"><strong class="bold">int</strong> add_em_up(<strong class="bold">int</strong>&amp; lhs, <strong class="bold">int</strong>&amp; rhs) {</p>
			<p class="source-code">    return lhs + rhs;</p>
			<p class="source-code">}</p>
			<p>The specialization takes the template and replaces all instances of the <strong class="source-inline">T</strong> placeholder with the type from the invocation, in this case, <strong class="source-inline">int</strong>. The compiler creates a separate specialization of the template each time it's invoked with a different type. </p>
			<p>STL <em class="italic">containers</em>, like <strong class="source-inline">vector</strong>, <strong class="source-inline">stack</strong>, or <strong class="source-inline">map</strong>, along with their <em class="italic">iterators</em> and other supporting functions and algorithms, are built with templates so they can be used generically while maintaining type safety. This is what makes the STL so flexible. Templates are the <em class="italic">T</em> in the STL. </p>
			<h2 id="_idParaDest-9"><a id="_idTextAnchor008"/>This book uses the C++20 standard</h2>
			<p>The C++ language is standardized by the International Organization for Standardization (ISO) on a roughly three-year cycle. The current standard is called C++20 (which was preceded by C++17, C++14, and C++11 before that). C++20 was approved in September 2020. </p>
			<p>C++20 adds many important features to the language and the STL. New features like <em class="italic">format</em>, <em class="italic">modules</em>, <em class="italic">ranges</em>, and more will have significant impact on the way we use the STL.</p>
			<p>There are also convenience changes. For example, if you want to remove every matching element of a <strong class="source-inline">vector</strong>, you may have been using the <em class="italic">erase-remove idiom</em> like this:</p>
			<p class="source-code">auto it = std::remove(vec1.begin(), vec1.end(), value);</p>
			<p class="source-code">vec1.erase(it, vec1.end());</p>
			<p>Starting with C++20 you can use the new <strong class="source-inline">std::erase</strong> function and do all of that in one simple, optimized function call: </p>
			<p class="source-code">std::erase(vec1, value);</p>
			<p>C++20 has many improvements, both subtle and substantial. In this book, we will cover much of it, especially what's relevant to the STL. </p>
			<h2 id="_idParaDest-10"><a id="_idTextAnchor009"/>Braced initialization</h2>
			<p>You may notice that the recipes in this book often use <em class="italic">braced initialization</em> in place of the more familiar <em class="italic">copy initialization</em>. </p>
			<p class="source-code">std::string name{ "Jimi Hendrix" };  // braced initialization</p>
			<p class="source-code">std::string name = "Jimi Hendrix";   // copy initialization</p>
			<p>The <strong class="source-inline">=</strong> operator pulls double-duty as both an assignment and a copy operator. It's common, familiar, and it works, so we've all been using it forever. </p>
			<p>The downside of the <strong class="source-inline">=</strong> operator is that it's also a copy constructor, which often means <em class="italic">implicit narrowing conversion</em>. This is both inefficient and can lead to unintended type conversions, which can be difficult to debug. </p>
			<p>Braced initialization uses the list initialization operator <strong class="source-inline">{}</strong> (introduced in C++11) to avoid those side effects. It's a good habit to get into and you'll see it a lot in this book.</p>
			<p>It's also worth noting that the special case of <strong class="source-inline">T{}</strong> is guaranteed to be zero-initialized. </p>
			<p class="source-code">int x;      // uninitialized            bad  :(</p>
			<p class="source-code">int x = 0;  // zero (copy constructed)  good :)</p>
			<p class="source-code">int x{};    // zero (zero-initialized)  best :D</p>
			<p>The empty brace zero initialization offers a useful shortcut for initializing new variables.</p>
			<h2 id="_idParaDest-11"><a id="_idTextAnchor010"/>Hiding the std:: namespace</h2>
			<p>In most instances, the exercises in this book will hide the <strong class="source-inline">std::</strong> namespace. This is mostly for page space and readability considerations. We all know that most STL identifiers are in the <strong class="source-inline">std::</strong> namespace. I will normally use some form of the <strong class="source-inline">using</strong> declaration to avoid cluttering the examples with repetitive prefixes. For example, when using <strong class="source-inline">cout</strong> you can presume I've included a <strong class="source-inline">using</strong> declaration like this:</p>
			<p class="source-code">using std::cout;    // cout is now sans prefix</p>
			<p class="source-code">cout &lt;&lt; "Hello, Jimi!\n"; </p>
			<p>I usually <em class="italic">will not show</em> the <strong class="source-inline">using</strong> declaration in the recipe listings. This allows us to focus on the purpose of the example.</p>
			<p>It is poor practice to import the entire <strong class="source-inline">std::</strong> namespace in your code. You should <em class="italic">avoid</em> a <strong class="source-inline">using namespace</strong> declaration like this: </p>
			<p class="source-code">using namespace std;    // bad. don't do that. </p>
			<p class="source-code">cout &lt;&lt; "Hello, Jimi!\n"; </p>
			<p>The <strong class="source-inline">std::</strong> namespace includes thousands of identifiers and there's no good reason to clutter your namespace with them. The potential for collisions is not trivial, and can be hard to track down. When you want to use a name without the <strong class="source-inline">std::</strong> prefix, the preferred method is to import a single name at a time, as above. </p>
			<p>To further avoid namespace collisions, I often use a separate namespace for classes that will be re-used. I tend to use <strong class="source-inline">namespace bw</strong> for my personal namespace. You may use something else that works for you.</p>
			<h2 id="_idParaDest-12"><a id="_idTextAnchor011"/>Type aliases with using</h2>
			<p>This book uses the <strong class="source-inline">using</strong> directive for type aliases instead of <strong class="source-inline">typedef</strong>. </p>
			<p>STL classes and types can be verbose at times. A templated iterator class, for example, may look like this:</p>
			<p class="source-code">std::vector&lt;std::pair&lt;int,std::string&gt;&gt;::iterator</p>
			<p>Long type names are not just hard to type, they are prone to error. </p>
			<p>One common technique is to abbreviate long type names with <strong class="source-inline">typedef</strong>:</p>
			<p class="source-code">typedef std::vector&lt;std::pair&lt;int,std::string&gt;&gt;::iterator <strong class="bold">vecit_t</strong></p>
			<p>This declares an alias for our unwieldy iterator type. <strong class="source-inline">typedef</strong> is inherited from C and its syntax reflects that. </p>
			<p>Beginning with C+11, the <strong class="source-inline">using</strong> keyword may be used to create a type alias:</p>
			<p class="source-code">using <strong class="bold">vecit_t</strong> = std::vector&lt;std::pair&lt;int,std::string&gt;&gt;::iterator;</p>
			<p>In most circumstances, a <strong class="source-inline">using</strong> alias is equivalent to <strong class="source-inline">typedef</strong>. The most significant difference is that a <strong class="source-inline">using</strong> alias may be templated: </p>
			<p class="source-code">template&lt;typename T&gt;</p>
			<p class="source-code">using v = std::vector&lt;T&gt;;</p>
			<p class="source-code">v&lt;int&gt; x{};</p>
			<p>For these reasons, and for the sake of clarity, this book prefers the <strong class="source-inline">using</strong> directive for type aliases.</p>
			<h2 id="_idParaDest-13"><a id="_idTextAnchor012"/>Abbreviated function templates</h2>
			<p>Beginning with C++20, an <em class="italic">abbreviated function template</em> may be specified without the template header. For example:</p>
			<p class="source-code">void printc(const <strong class="bold">auto</strong>&amp; c) {</p>
			<p class="source-code">    for (auto i : c) {</p>
			<p class="source-code">        std::cout &lt;&lt; i &lt;&lt; '\n';</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">auto</strong> type in a parameter list works like an anonymous template <strong class="source-inline">typename</strong>. It is equivalent to:</p>
			<p class="source-code">template&lt;<strong class="bold">typename C</strong>&gt;</p>
			<p class="source-code">void printc(const <strong class="bold">C</strong>&amp; c) {</p>
			<p class="source-code">    for (auto i : c) {</p>
			<p class="source-code">        std::cout &lt;&lt; i &lt;&lt; '\n';</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Though new in C++20, abbreviated function templates have been supported by the major compilers for some time already. This book will use abbreviated function templates in many of the examples.</p>
			<h2 id="_idParaDest-14"><a id="_idTextAnchor013"/>The C++20 format() function</h2>
			<p>Until C++20 we've had a choice of using legacy <strong class="source-inline">printf()</strong> or the STL <strong class="source-inline">cout</strong> for formatting text. Both have serious flaws but we've used them because they work. Beginning with C++20, the <strong class="source-inline">format()</strong> function provides text formatting inspired by Python 3's formatter. </p>
			<p>This course uses the new STL <strong class="source-inline">format()</strong> function liberally. Please see <a href="B18267_01_ePub.xhtml#_idTextAnchor027"><em class="italic">Chaper 1</em></a>, <em class="italic">New C++20 Features</em>, for a more comprehensive description. </p>
			<h2 id="_idParaDest-15"><a id="_idTextAnchor014"/>Use the STL to solve real-world problems</h2>
			<p>The recipes in this book use the STL to provide real-world solutions to real-world problems. They have been designed to rely exclusively on the STL and C++ standard libraries, with no external libraries. This should make it easy for you to experiment and learn without the distractions of installing and configuring third-party code. </p>
			<p>Now, let's go have some fun with the STL. <em class="italic">Happy learning!</em> </p>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Who this book is for</h1>
			<p>This book is for <em class="italic">intermediate to advanced</em> C++ programmers who want to get more out of the C++20 Standard Template Library. Basic knowledge of coding and C++ concepts are necessary to get the most out of this book.</p>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>What this book covers</h1>
			<p><a href="B18267_01_ePub.xhtml#_idTextAnchor027"><em class="italic">Chaper 1</em></a>, <em class="italic">New C++20 Features</em>, introduces the new STL features in C++20. It aims to familiarize you with the new language features so you may use them with the STL.</p>
			<p><a href="B18267_02_ePub.xhtml#_idTextAnchor057"><em class="italic">Chapter 2</em></a>, <em class="italic">General STL Features</em>, discusses modern STL features added in recent C++ versions.</p>
			<p><a href="B18267_03_ePub.xhtml#_idTextAnchor076"><em class="italic">Chapter 3</em></a>, <em class="italic">STL Containers</em>, covers the STL's comprehensive library of containers.</p>
			<p><a href="B18267_04_ePub.xhtml#_idTextAnchor122"><em class="italic">Chapter 4</em></a>, <em class="italic">Compatible Iterators</em>, shows how to use and create STL-compatible iterators.</p>
			<p><a href="B18267_05_ePub.xhtml#_idTextAnchor155"><em class="italic">Chapter 5</em></a>, <em class="italic">Lambda Expressions</em>, covers the use of lambdas with STL functions and algorithms.</p>
			<p><a href="B18267_06_ePub.xhtml#_idTextAnchor181"><em class="italic">Chapter 6</em></a>, <em class="italic">STL Algorithms</em>, provides recipes for using and creating STL-compatible algorithms.</p>
			<p><a href="B18267_07_ePub.xhtml#_idTextAnchor212"><em class="italic">Chapter 7</em></a>, <em class="italic">Strings, Stream, and Formatting</em>, describes the STL string and formatter classes.</p>
			<p><a href="B18267_08_ePub.xhtml#_idTextAnchor250"><em class="italic">Chapter 8</em></a>, <em class="italic">Utility Classes</em>, covers STL utilities for date-and-time, smart pointers, optionals, and more.</p>
			<p><a href="B18267_09_ePub.xhtml#_idTextAnchor291"><em class="italic">Chapter 9</em></a>, <em class="italic">Concurrency and Parallelism</em>, describes support for concurrency, including threads, async, atomic types, and more.</p>
			<p><a href="B18267_10_ePub.xhtml#_idTextAnchor324"><em class="italic">Chapter 10</em></a>, <em class="italic">Using the File System</em>, covers the <strong class="source-inline">std::filesystem</strong> classes and how to put them to use with the latest advancements that came out with C++20.</p>
			<p><a href="B18267_11_ePub.xhtml#_idTextAnchor347"><em class="italic">Chapter 11</em></a>, <em class="italic">A Few More Ideas</em>, provides a few more solutions, including a trie class, string split, and more. This provides advanced examples on how to put the STL to use for real-world problems.</p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>The recipes in this book use the GCC compiler</h2>
			<p>Unless otherwise noted, most of the recipes in this book have been developed and tested using the GCC compiler, version 11.2, the latest stable version as of this writing. </p>
			<p>As I write this, C++20 is still new and is not fully implemented on any available compiler. Of the three major compilers, <em class="italic">GCC</em> (GNU), <em class="italic">MSVC</em> (Microsoft), and <em class="italic">Clang</em> (Apple), the MSVC compiler is furthest along in implementing the new standard. Occasionally, we may run into a feature that is implemented on MSVC or another compiler, but not on GCC, in which case I will note which compiler I used. If a feature is not yet implemented on any available compiler, I will explain that I was unable to test it.</p>
			<p class="figure-caption"><img src="image/B18267_Preface_01.png" alt=""/></p>
			<p>I strongly recommend that you install GCC to follow along with the recipes in this book. GCC is freely available under the GNU General Public License (GPL). The easiest way to get the latest version of GCC is to install <em class="italic">Debian Linux</em> (also GPL) and use <strong class="source-inline">apt</strong> with the <strong class="source-inline">testing</strong> repository.</p>
			<p><strong class="bold">If you are using the digital version of this book, we suggest you type the code yourself or download the code from the GitHub repository (link in the next section). This will avoid errors due to copying and pasting formatted code from the e-book.</strong></p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Download the example code files</h2>
			<p>You can download the example code files for this book from GitHub at https://github.com/PacktPublishing/CPP-20-STL-Cookbook. In the event of updates and errata, code will be updated on the GitHub repository.</p>
			<p>We also have other code bundles from our rich catalog of books and videos available at <a href="https://github.com/PacktPublishing/">https://github.com/PacktPublishing/</a>. Check them out!</p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>Conventions used</h1>
			<p>There are a number of text conventions used throughout this book.</p>
			<p><strong class="source-inline">Code in text</strong>: Indicates code words in text, database table names, folder names, file names, file extensions, path names, dummy URLs, user input, and Twitter handles. Here is an example: "The <strong class="source-inline">insert()</strong> method takes an <strong class="source-inline">initializer_list</strong> and calls the private function <strong class="source-inline">_insert()</strong>:"</p>
			<p>A block of code is set as follows:</p>
			<p class="source-code">int main() {</p>
			<p class="source-code">    Frac f{ 5, 3 };</p>
			<p class="source-code">    cout &lt;&lt; format("Frac: {}\n", f);</p>
			<p class="source-code">}</p>
			<p>When we wish to draw your attention to a particular part of a code block, the relevant lines or items are set in bold:</p>
			<p class="source-code">for(uint64_t i{ 2 }; i &lt; n / 2; ++i) {</p>
			<p class="source-code">    if(<strong class="bold">n % i == 0</strong>) return false;</p>
			<p class="source-code">}</p>
			<p>Any command-line input or output is written as follows:</p>
			<p class="source-code">$ ./producer-consumer</p>
			<p class="source-code">Got 0 from the queue</p>
			<p class="source-code">Got 1 from the queue</p>
			<p class="source-code">Got 2 from the queue</p>
			<p class="source-code">finished!</p>
			<p><strong class="bold">Bold</strong>: Indicates a new term, an important word, or words that you see onscreen. For example, words in menus or dialog boxes appear in the text like this. Here is an example: "Select <strong class="bold">System info</strong> from the <strong class="bold">Administration</strong> panel."</p>
			<p class="callout-heading">Tips or important notes</p>
			<p class="callout">Appear like this.</p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>Sections</h1>
			<p>In this book, you will find several headings that appear frequently (<em class="italic">How to do it...</em>, <em class="italic">How it works...</em>, <em class="italic">There's more...</em>, and <em class="italic">See also…</em>).</p>
			<p>To give clear instructions on how to complete a recipe, use these sections as follows:</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>How to do it…</h2>
			<p>This section contains the steps required to follow the recipe.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>How it works…</h2>
			<p>This section usually consists of a detailed explanation of what happened in the previous section.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>There's more…</h2>
			<p>This section consists of additional information about the recipe in order to make you more knowledgeable about the recipe.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>See also…</h2>
			<p>This section provides helpful links to other useful information for the recipe.</p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor025"/>Get in touch</h1>
			<p>Feedback from our readers is always welcome.</p>
			<p><strong class="bold">General feedback</strong>: If you have questions about any aspect of this book, mention the book title in the subject of your message and email us at <a href="http://customercare@packtpub.com">customercare@packtpub.com</a>.</p>
			<p><strong class="bold">Errata</strong>: Although we have taken every care to ensure the accuracy of our content, mistakes do happen. If you have found a mistake in this book, we would be grateful if you would report this to us. Please visit <a href="http://www.packtpub.com/support/errata">www.packtpub.com/support/errata</a>, selecting your book, clicking on the Errata Submission Form link, and entering the details.</p>
			<p><strong class="bold">Piracy</strong>: If you come across any illegal copies of our works in any form on the Internet, we would be grateful if you would provide us with the location address or website name. Please contact us at <a href="http://copyright@packt.com">copyright@packt.com</a> with a link to the material.</p>
			<p><strong class="bold">If you are interested in becoming an author</strong>: If there is a topic that you have expertise in and you are interested in either writing or contributing to a book, please visit <a href="http://authors.packtpub.com">authors.packtpub.com</a>.</p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/>Share Your Thoughts</h1>
			<p>Once you've read <em class="italic">C++20 STL Cookbook</em>, we'd love to hear your thoughts! <a href="https://packt.link/r/1803248718">Please click here to go straight to the Amazon review page</a> for this book and share your feedback.</p>
			<p>Your review is important to us and the tech community and will help us make sure we're delivering excellent quality content.</p>
		</div>
		<div id="_idContainer006" class="Basic-Text-Frame">
			<p class="hidden">     Preface</p>
		</div>
	</body></html>