["```cpp\n    struct owning_A {\n      B b_;\n    };\n\n    struct non_owning_A {\n      B& b_;\n    };\n\n    void test()\n    {\n      B b;\n\n      // a1 takes ownership of [a copy of] b.\n      owning_A a1 { b };\n\n      // a2 merely holds a reference to b;\n      // a2 doesn't own b.\n      non_owning_A a2 { b };\n    }\n```", "```cpp\n    struct owning_A {\n      B *b_;\n\n      explicit owning_A(B *b) : b_(b) {}\n\n      owning_A(owning_A&& other) : b_(other.b_) {\n        other.b_ = nullptr;\n      }\n\n      owning_A& operator= (owning_A&& other) {\n        delete b_;\n        b_ = other.b_;\n        other.b_ = nullptr;\n        return *this;\n      }\n\n      ~owning_A() {\n        delete b_;\n      }\n    };\n\n    struct non_owning_A {\n      B *b_;\n    };\n\n    void test()\n    {\n      B *b = new B;\n\n      // a1 takes ownership of *b.\n      owning_A a1 { b };\n\n      // a2 merely holds a pointer to *b;\n      // a2 doesn't own *b.\n      non_owning_A a2 { b };\n    }\n```", "```cpp\n    std::string c_style[4] = {\n      \"the\", \"quick\", \"brown\", \"fox\"\n    };\n    assert(c_style[2] == \"brown\");\n    assert(std::size(c_style) == 4);\n    assert(std::distance(std::begin(c_style), std::end(c_style)) == 4);\n\n    // Copying via operator= isn't supported.\n    std::string other[4]; \n    std::copy(std::begin(c_style), std::end(c_style), std::begin(other));\n\n    // Swapping IS supported... in linear time, of course.\n    using std::swap;\n    swap(c_style, other);\n\n    // Comparison isn't supported; you have to use a standard algorithm.\n    // Worse, operator== does the \"wrong\" thing: address comparison!\n    assert(c_style != other);\n    assert(std::equal(\n      c_style, c_style + 4,\n      other, other + 4 \n    ));\n    assert(!std::lexicographical_compare(\n      c_style, c_style + 4,\n      other, other + 4\n   ));\n```", "```cpp\n    std::array<std::string, 4> arr = {{\n      \"the\", \"quick\", \"brown\", \"fox\"\n    }};\n    assert(arr[2] == \"brown\");\n\n    // .begin(), .end(), and .size() are all provided.\n    assert(arr.size() == 4);\n    assert(std::distance(arr.begin(), arr.end()) == 4);\n\n    // Copying via operator= is supported... in linear time.\n    std::array<std::string, 4> other;\n    other = arr;\n\n    // Swapping is also supported... in linear time.\n    using std::swap;\n    swap(arr, other);\n\n    // operator== does the natural thing: value comparison!\n    assert(&arr != &other); // The arrays have different addresses... \n    assert(arr == other); // ...but still compare lexicographically equal.\n    assert(arr >= other); // Relational operators are also supported.\n```", "```cpp\n    // You can't return a C-style array from a function.\n    // auto cross_product(const int (&a)[3], const int (&b)[3]) -> int[3];\n\n    // But you can return a std::array.\n    auto cross_product(const std::array<int, 3>& a,\n     const std::array<int, 3>& b) -> std::array<int, 3>\n    {\n      return {{\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0],\n      }};\n    }\n```", "```cpp\n    struct Vec3 {\n      int x, y, z;\n      Vec3(int x, int y, int z) : x(x), y(y), z(z) {}\n    };\n\n    bool operator==(const Vec3& a, const Vec3& b) {\n      return std::tie(a.x, a.y, a.z) ==\n         std::tie(b.x, b.y, b.z);\n    }\n\n    bool operator!=(const Vec3& a, const Vec3& b) {\n      return !(a == b);\n    }\n\n    // Operators < <= > >= don't make sense for Vec3\n\n    Vec3 cross_product(const Vec3& a, const Vec3& b) {\n      return {\n        a.y * b.z - a.z * b.y,\n        a.z * b.x - a.x * b.z,\n        a.x * b.y - a.y * b.x,\n      };\n    }\n```", "```cpp\n    void dont_do_this()\n    {\n      // This variable takes up 4 megabytes of stack space ---\n      // enough to blow your stack and cause a segmentation fault!\n      int arr[1'000'000];\n    }\n\n    void dont_do_this_either()\n    {\n      // Changing it into a C++ std::array doesn't fix the problem.\n      std::array<int, 1'000'000> arr;\n    }\n```", "```cpp\n    template<typename T>\n    inline void destroy_n_elements(T *p, size_t n)\n    {\n      for (size_t i = 0; i < n; ++i) {\n        p[i].~T();\n      }\n    }\n\n    template<typename T>\n    class vector {\n      T *ptr_ = nullptr;\n      size_t size_ = 0;\n      size_t capacity_ = 0;\n\n      public:\n      // ...\n\n      void reserve(size_t c) {\n        if (capacity_ >= c) {\n          // do nothing\n          return;\n        }\n\n        // For now, we'll ignore the problem of\n        // \"What if malloc fails?\"\n        T *new_ptr = (T *)malloc(c * sizeof (T));\n\n        for (size_t i=0; i < size_; ++i) {\n          if constexpr (std::is_nothrow_move_constructible_v<T>) {\n            // If the elements can be moved without risking\n            // an exception, then we'll move the elements.\n            ::new (&new_ptr[i]) T(std::move(ptr_[i]));\n          } else {\n            // If moving the elements might throw an exception,\n            // then moving isn't safe. Make a copy of the elements\n            // until we're sure that we've succeeded; then destroy\n            // the old elements.\n            try {\n              ::new (&new_ptr[i]) T(ptr_[i]);\n            } catch (...) {\n              destroy_n_elements(new_ptr, i);\n              free(new_ptr);\n              throw;\n            }\n          }\n        }\n        // Having successfully moved or copied the elements,\n        // destroy the old array and point ptr_ at the new one.\n        destroy_n_elements(ptr_, size_);\n        free(ptr_);\n        ptr_ = new_ptr;\n        capacity_ = c;\n      }\n\n      ~vector() {\n        destroy_n_elements(ptr_, size_);\n        free(ptr_);\n      }\n    };\n```", "```cpp\n    // If the elements can be moved without risking\n    // an exception, then we'll move the elements.\n    std::conditional_t<\n      std::is_nothrow_move_constructible_v<T>,\n      std::move_iterator<T*>,\n      T*\n      > first(ptr_);\n\n    try {\n      // Move or copy the elements via a standard algorithm.\n      std::uninitialized_copy(first, first + size_, new_ptr);\n    } catch (...) {\n      free(new_ptr);\n      throw;\n    }\n\n    // Having successfully moved or copied the elements,\n    // destroy the old array and point ptr_ at the new one.\n    std::destroy(ptr_, ptr_ + size_);\n    free(ptr_);\n    ptr_ = new_ptr;\n    capacity_ = c;\n```", "```cpp\n    std::vector<int> v = {3, 1, 4};\n\n    auto iter = v.begin();\n    v.reserve(6); // iter is invalidated!\n\n    // This might look like a way to produce the result\n    // {3, 1, 4, 3, 1, 4}; but if the first insertion\n    // triggers reallocation, then the next insertion\n    // will be reading garbage from a dangling iterator!\n    v = std::vector{3, 1, 4};\n    std::copy(\n      v.begin(),\n      v.end(),\n      std::back_inserter(v)\n    );\n```", "```cpp\n    auto end = v.end();\n    for (auto it = v.begin(); it != end; ++it) {\n      if (*it == 4) {\n        v.erase(it); // WRONG!\n      }\n    }\n\n    // Asking the vector for its .end() each time\n    // through the loop does fix the bug...\n    for (auto it = v.begin(); it != v.end(); ) {\n      if (*it == 4) {\n        it = v.erase(it);\n      } else {\n        ++it;\n      }\n    }\n\n    // ...But it's much more efficient to use the\n    // erase-remove idiom.\n    v.erase(\n      std::remove_if(v.begin(), v.end(), [](auto&& elt) {\n        return elt == 4;\n      }),\n      v.end()\n    );\n```", "```cpp\n    std::vector<int> v = {1, 2};\n    std::vector<int> w = {5, 6};\n\n    // Insert a single element.\n    v.insert(v.begin() + 1, 3);\n    assert((v == std::vector{1, 3, 2}));\n\n    // Insert n copies of a single element.\n    v.insert(v.end() - 1, 3, 4);\n    assert((v == std::vector{1, 3, 4, 4, 4, 2}));\n\n    // Insert a whole range of elements.\n    v.insert(v.begin() + 3, w.begin(), w.end());\n    assert((v == std::vector{1, 3, 4, 5, 6, 4, 4, 2}));\n\n    // Insert a braced list of elements.\n    v.insert(v.begin(), {7, 8});\n    assert((v == std::vector{7, 8, 1, 3, 4, 5, 6, 4, 4, 2}));\n```", "```cpp\n    std::vector<bool> vb = {true, false, true, false};\n\n    // vector<bool>::reference has one public member function:\n    vb[3].flip();\n    assert(vb[3] == true);\n\n    // The following line won't compile!\n    // bool& oops = vb[0];\n\n    auto ref = vb[0];\n    assert((!std::is_same_v<decltype(ref), bool>));\n    assert(sizeof vb[0] > sizeof (bool));\n\n    if (sizeof std::as_const(vb)[0] == sizeof (bool)) {\n      puts(\"Your library vendor is libstdc++ or Visual Studio\");\n    } else {\n      puts(\"Your library vendor is libc++\");\n    }\n```", "```cpp\n    struct Bad {\n      int x = 0;\n      Bad() = default;\n      Bad(const Bad&) { puts(\"copy Bad\"); }\n      Bad(Bad&&) { puts(\"move Bad\"); }\n    };\n\n    struct Good {\n      int x = 0;\n      Good() = default;\n      Good(const Good&) { puts(\"copy Good\"); }\n      Good(Good&&) noexcept { puts(\"move Good\"); }\n    };\n\n    class ImplicitlyGood {\n      std::string x;\n      Good y;\n    };\n\n    class ImplicitlyBad {\n      std::string x;\n      Bad y;\n    };\n```", "```cpp\n    template<class T>\n    void test_resizing()\n    {\n      std::vector<T> vec(1);\n      // Force a reallocation on the vector.\n      vec.resize(vec.capacity() + 1);\n    }\n\n    void test()\n    {\n      test_resizing<Good>();\n      test_resizing<Bad>();\n      test_resizing<ImplicitlyGood>();\n      test_resizing<ImplicitlyBad>();\n    }\n```", "```cpp\n    std::vector<int> vec = {1, 2, 3, 4};\n    std::deque<int> deq = {1, 2, 3, 4};\n    int *vec_p = &vec[2];\n    int *deq_p = &deq[2];\n    for (int i=0; i < 1000; ++i) {\n      vec.push_back(i);\n      deq.push_back(i);\n    }\n    assert(vec_p != &vec[2]);\n    assert(deq_p == &deq[2]);\n```", "```cpp\n    std::list<int> a = {3, 6};\n    std::list<int> b = {1, 2, 3, 5, 6};\n\n    a.merge(b);\n    assert(b.empty());\n    assert((a == std::list{1, 2, 3, 3, 5, 6, 6}));\n```", "```cpp\n    std::list<int> lst = {3, 1, 4, 1, 5, 9, 2, 6, 5};\n    auto begin = std::next(lst.begin(), 2);\n    auto end = std::next(lst.end(), -2);\n\n    // Sort just the range [begin, end)\n    std::list<int> sub; \n    sub.splice(sub.begin(), lst, begin, end);\n    sub.sort();\n    lst.splice(end, sub);\n    assert(sub.empty());\n\n    assert((lst == std::list{3, 1, 1, 2, 4, 5, 9, 6, 5}));\n```", "```cpp\n    std::stack<int> stk;\n    stk.push(3); stk.push(1); stk.push(4);\n    assert(stk.top() == 4);\n    stk.pop();\n    assert(stk.top() == 1);\n    stk.pop();\n    assert(stk.top() == 3);\n```", "```cpp\n    std::stack<int> a, b;\n    a.push(3); a.push(1); a.push(4);\n    b.push(2); b.push(7);\n    assert(a != b);\n\n    assert(a.top() < b.top()); // that is, 4 < 7\n    assert(a > b); // because 3 > 2\n```", "```cpp\n    std::priority_queue<int> pq1;\n    std::priority_queue<int, std::vector<int>, std::greater<>> pq2;\n\n    for (int v : {3, 1, 4, 1, 5, 9}) {\n      pq1.push(v);\n      pq2.push(v);\n    }\n\n    assert(pq1.top() == 9); // max-heap by default\n    assert(pq2.top() == 1); // min-heap by choice\n```", "```cpp\n    std::set<int> s;\n    for (int i : {3, 1, 4, 1, 5}) {\n      s.insert(i);\n    }\n\n    // A set's items are stored sorted and deduplicated.\n    assert((s == std::set{1, 3, 4, 5}));\n\n    auto it = s.begin();\n    assert(*it == 1);\n    s.erase(4);\n    s.erase(it); // erase *it, which is 1\n\n    assert((s == std::set{3, 5}));\n```", "```cpp\n    std::set<int> s;\n    auto [it1, b1] = s.insert(1);\n    assert(*it1 == 1 && b1 == true);\n\n    auto [it2, b2] = s.insert(2);\n    assert(*it2 == 2 && b2 == true);\n\n    auto [it3, b3] = s.insert(1); // again\n    assert(*it3 == 1 && b3 == false);\n```", "```cpp\n    std::map<std::string, std::string> m;\n    m[\"hello\"] = \"world\";\n    m[\"quick\"] = \"brown\";\n    m[\"hello\"] = \"dolly\";\n    assert(m.size() == 2);\n```", "```cpp\n    assert(m[\"literally\"] == \"\");\n    assert(m.size() == 3);\n```", "```cpp\n    // Confusingly, \"value_type\" refers to a whole key-value pair.\n    // The types K and V are called \"key_type\" and \"mapped_type\",\n    // respectively.\n    using Pair = decltype(m)::value_type;\n\n    if (m.find(\"hello\") == m.end()) {\n      m.insert(Pair{\"hello\", \"dolly\"});\n\n      // ...or equivalently...\n      m.emplace(\"hello\", \"dolly\");\n    }\n```", "```cpp\n    struct MagicLess {\n      using is_transparent = std::true_type;\n\n      template<class T, class U>\n      bool operator()(T&& t, U&& u) const {\n        return std::forward<T>(t) < std::forward<U>(u);\n      }\n    };\n\n    void test()\n    {\n      std::map<std::string, std::string, MagicLess> m;\n\n      // The STL provides std::less<> as a synonym for MagicLess.\n      std::map<std::string, std::string, std::less<>> m2;\n\n      // Now 'find' no longer constructs a std::string!\n      auto it = m2.find(\"hello\");\n    }\n```", "```cpp\n    auto [begin, end] = m.equal_range(\"hello\");\n    m.erase(begin, end);\n```", "```cpp\n    std::multimap<std::string, std::string> mm;\n    mm.emplace(\"hello\", \"world\");\n    mm.emplace(\"quick\", \"brown\");\n    mm.emplace(\"hello\", \"dolly\");\n    assert(mm.size() == 3);\n\n    // Key-value pairs are stored in sorted order.\n    // Pairs with identical keys are guaranteed to be\n    // stored in the order in which they were inserted.\n    auto it = mm.begin();\n    using Pair = decltype(mm)::value_type;\n    assert(*(it++) == Pair(\"hello\", \"world\"));\n    assert(*(it++) == Pair(\"hello\", \"dolly\"));\n    assert(*(it++) == Pair(\"quick\", \"brown\"));\n```", "```cpp\n    std::multimap<std::string, std::string> mm = {\n      {\"hello\", \"world\"},\n      {\"quick\", \"brown\"},\n      {\"hello\", \"dolly\"},\n    };\n    assert(mm.count(\"hello\") == 2);\n    mm.erase(\"hello\");\n    assert(mm.count(\"hello\") == 0);\n```", "```cpp\n    std::map<std::string, std::string> m = {\n      {\"hello\", \"world\"},\n      {\"quick\", \"brown\"},\n    };\n    std::map<std::string, std::string> otherm = {\n      {\"hello\", \"dolly\"},\n      {\"sad\", \"clown\"},\n    };\n\n    // This should look familiar!\n    m.merge(otherm);\n\n    assert((otherm == decltype(m){\n      {\"hello\", \"dolly\"},\n    }));\n\n    assert((m == decltype(m){\n      {\"hello\", \"world\"},\n      {\"quick\", \"brown\"},\n      {\"sad\", \"clown\"},\n    }));\n```", "```cpp\n    std::map<std::string, std::string> m = {\n      {\"hello\", \"world\"},\n      {\"quick\", \"brown\"},\n    };\n    std::map<std::string, std::string> otherm = {\n      {\"hello\", \"dolly\"},\n      {\"sad\", \"clown\"},\n    };\n\n    using Pair = decltype(m)::value_type;\n\n    // Insertion may succeed...\n    auto nh1 = otherm.extract(\"sad\");\n    assert(nh1.key() == \"sad\" && nh1.mapped() == \"clown\");\n    auto [it2, inserted2, nh2] = m.insert(std::move(nh1));\n    assert(*it2 == Pair(\"sad\", \"clown\") && inserted2 == true && nh2.empty());\n\n    // ...or be blocked by an existing element.\n    auto nh3 = otherm.extract(\"hello\");\n    assert(nh3.key() == \"hello\" && nh3.mapped() == \"dolly\");\n    auto [it4, inserted4, nh4] = m.insert(std::move(nh3));\n    assert(*it4 == Pair(\"hello\", \"world\") && inserted4 == false && !nh4.empty());\n\n    // Overwriting an existing element is a pain.\n    m.insert_or_assign(nh4.key(), nh4.mapped());\n\n    // It is often easiest just to delete the element that's\n    // blocking our desired insertion.\n    m.erase(it4);\n    m.insert(std::move(nh4));\n```", "```cpp\n    std::map<std::string, std::string> m = {\n      {\"hello\", \"world\"},\n      {\"quick\", \"brown\"},\n    };\n    assert(m.begin()->first == \"hello\");\n    assert(std::next(m.begin())->first == \"quick\");\n\n    // Upper-case the {\"quick\", \"brown\"} mapping, with\n    // absolutely no memory allocations anywhere.\n    auto nh = m.extract(\"quick\");\n    std::transform(nh.key().begin(), nh.key().end(), nh.key().begin(), ::toupper);\n    m.insert(std::move(nh));\n\n    assert(m.begin()->first == \"QUICK\");\n    assert(std::next(m.begin())->first == \"hello\");\n```", "```cpp\n    class Widget {\n    public:\n      virtual bool IsEqualTo(Widget const *b) const;\n      virtual int GetHashValue() const;\n    };\n\n    struct myhash {\n      size_t operator()(const Widget *w) const {\n        return w->GetHashValue();\n      }\n    };\n\n    struct myequal {\n      bool operator()(const Widget *a, const Widget *b) const {\n        return a->IsEqualTo(b);\n      }\n    };\n\n    std::unordered_set<Widget *, myhash, myequal> s;\n```"]