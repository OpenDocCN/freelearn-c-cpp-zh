- en: Chapter 4. Working with Shapes and Figures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章。与形状和图形一起工作
- en: 'In this chapter, we develop a program capable of drawing lines, arrows, rectangles,
    and ellipses. The application can be viewed as a more advanced version of the
    circle application. Similar to the circle application, we have a list of figures
    and we catch the user''s mouse actions. However, there are four different kinds
    of figures: lines, arrows, rectangles, and ellipses. They are defined in a class
    hierarchy that is similar to but more advanced than the hierarchy in the Tetris
    game. Moreover, we also introduce cut, copy, paste, cursor control, and registry
    handling:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开发了一个能够绘制线条、箭头、矩形和椭圆的程序。该应用可以被视为圆应用的更高级版本。类似于圆应用，我们有一个图形列表，并捕获用户的鼠标动作。然而，这里有四种不同的图形：线条、箭头、矩形和椭圆。它们定义在一个类似于但比俄罗斯方块游戏中的层次结构更高级的类层次结构中。此外，我们还引入了剪切、复制、粘贴、光标控制和注册处理：
- en: '![Working with Shapes and Figures](img/image_04_001.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![与形状和图形一起工作](img/image_04_001.jpg)'
- en: The user can add new figures, move one or several figures, modify figures by
    grabbing their endpoints, mark and unmark figures by pressing the mouse button
    and the *Ctrl* key, and mark several figures by enclosing them by a rectangle.
    When a figure is marked, it becomes annotated with small black squares. The user
    can modify the shape of a figure by grabbing one of the squares. The user can
    also move a figure by grabbing some other part of the figure.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以添加新的图形，移动一个或多个图形，通过抓取图形的端点修改图形，通过按鼠标按钮和 *Ctrl* 键标记和取消标记图形，并通过矩形包围多个图形来标记多个图形。当一个图形被标记时，它会被小黑方块标注。用户可以通过抓取其中一个方块来修改图形的形状。用户还可以通过抓取图形的其他部分来移动图形。
- en: The MainWindow function
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MainWindow 函数
- en: 'The `MainWindow` function in this application is very similar to that in [Chapter
    3](ch03.html "Chapter 3. Building a Tetris Application"), *Building a Tetris Application*;
    it sets the application name and creates the main document window:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本应用中的 `MainWindow` 函数与 [第 3 章](ch03.html "第 3 章。构建俄罗斯方块应用") 中的相似，*构建俄罗斯方块应用*；它设置应用程序名称并创建主文档窗口：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The DrawDocument class
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DrawDocument 类
- en: 'The `DrawDocument` class extends the `StandardDocument` framework, similar
    to the circle application. It catches the mouse events, overrides the file methods,
    implements cut, copy, and paste, as well as cursor handling:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawDocument` 类扩展了 `StandardDocument` 框架，类似于圆应用。它捕获鼠标事件，重写文件方法，实现剪切、复制和粘贴，以及光标处理：'
- en: '**DrawDocument.h**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**DrawDocument.h**'
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Similar to the circle application, we catch mouse action with the `OnMouseDown`,
    `OnMouseMove`, and `OnMouseUp` methods. However, in this application, we also
    catch double-clicks with the `OnDoubleClick` method. When the user double-clicks
    on a figure, it takes individual actions:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与圆应用类似，我们使用 `OnMouseDown`、`OnMouseMove` 和 `OnMouseUp` 方法捕获鼠标动作。然而，在这个应用中，我们还使用
    `OnDoubleClick` 方法捕获双击。当用户双击一个图形时，它将执行单独的操作：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `OnDraw` method is called when the window''s client area needs to be redrawn.
    It draws the figures, and the rectangle enclosing the figures, if the user is
    in the process of marking figures with a rectangle:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当窗口的客户区域需要重绘时调用 `OnDraw` 方法。它绘制图形，以及如果用户正在用矩形标记图形，则绘制包围图形的矩形：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `ClearDocument` method is called when the user selects the **New** menu
    item, the `ReadDocumentFromStream` method is called when they select the **Open**
    menu item, and the `WriteDocumentToStream` method is called when they select the
    **Save** or **Save As** menu item:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择 **新建** 菜单项时调用 `ClearDocument` 方法，当用户选择 **打开** 菜单项时调用 `ReadDocumentFromStream`
    方法，当用户选择 **保存** 或 **另存为** 菜单项时调用 `WriteDocumentToStream` 方法：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Each figure has an integer identity value that is written by the `WriteDocumentToStream`
    method and read by the `ReadDocumentFromStream` method to decide which figure
    has to be created. Given the identity value, the `CreateFigure` method creates
    the new figure:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 每个图形都有一个整数标识值，该值由 `WriteDocumentToStream` 方法写入并由 `ReadDocumentFromStream` 方法读取，以决定哪个图形需要被创建。给定标识值，`CreateFigure`
    方法创建新的图形：
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this application, we introduce functionality for cut, copy, and paste. The
    `CopyGeneric` method is called when the user selects the **Cut** or **Copy** menu
    item in the **Edit** menu and the `PasteGeneric` method is called when the user
    selects the **Paste** menu item. In the `StandardDocument` framework, there are
    methods for cutting, copying, and pasting ASCII and Unicode text as well. However,
    we do not use them in this application:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们引入了剪切、复制和粘贴的功能。当用户在 **编辑** 菜单中选择 **剪切** 或 **复制** 菜单项时，调用 `CopyGeneric`
    方法；当用户选择 **粘贴** 菜单项时，调用 `PasteGeneric` 方法。在 `StandardDocument` 框架中，还有用于剪切、复制和粘贴
    ASCII 和 Unicode 文本的方法。然而，我们在这个应用程序中没有使用它们：
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `CopyEnable` method returns `true` if information is ready to be copied.
    In that case, the **Cut**, **Copy**, and **Delete** menu items are enabled. In
    this application, we do not override the `PasteEnable` method, since the `StandardDocument`
    framework looks up whether there is a memory buffer in the global clipboard suitable
    to paste. The `OnDelete` method is called when the user selects the **Delete**
    menu item:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`CopyEnable` 方法返回 `true` 如果信息已准备好复制。在这种情况下，**剪切**、**复制**和**删除**菜单项被启用。在这个应用程序中，我们没有重写
    `PasteEnable` 方法，因为 `StandardDocument` 框架会查找全局剪贴板中是否有适合粘贴的内存缓冲区。当用户选择 **删除** 菜单项时，调用
    `OnDelete` 方法：'
- en: '[PRE7]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Similar to the circle application, we have a set of listeners, even though
    the set is larger in this case. Each listener is added to the menus in the constructor.
    Unlike the circle application, we also use enable methods: methods that are called
    before the menu item becomes visible. If the methods return `false`, the menu
    items become disabled and grayed. If the menu item is connected to an accelerator,
    the accelerator also becomes disabled. We place the **Modify**, **Color**, and
    **Fill** items in the **Modify** menu, and the **Line**, **Arrow,** **Rectangle**,
    and **Ellipse** items in the **Add** menu:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与圆形应用程序类似，我们有一组监听器，尽管在这个情况下集合更大。每个监听器都在构造函数中添加到菜单中。与圆形应用程序不同，我们还使用了启用方法：在菜单项变得可见之前被调用的方法。如果方法返回
    `false`，菜单项将变为禁用并变灰。如果菜单项连接到加速器，加速器也将变为禁用。我们将 **修改**、**颜色**和**填充**项放在 **修改** 菜单中，将
    **线**、**箭头**、**矩形**和**椭圆**项放在 **添加** 菜单中：
- en: '[PRE8]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this application, we also introduce cursor control. The `UpdateCursor` method
    sets the cursor to an appropriate appearance depending on whether the user is
    creating, modifying, or moving figures:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们还引入了光标控制。`UpdateCursor` 方法根据用户是在创建、修改还是移动图形来设置光标的外观：
- en: '[PRE9]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'One central point of this application is its mode: the `applicationMode` method
    keeps track of the actions when the user presses the left mouse button. It holds
    the following modes:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序的一个中心点是它的模式：`applicationMode` 方法跟踪用户按下左鼠标按钮时的动作。它保持以下模式：
- en: '`Idle`: The application waits for input from the user. This is always the mode
    as long as the user does not press the left mouse button. However, when the user
    presses the mouse button, until they release it, the `applicationMode` method
    holds one value. The user presses the *Ctrl* key and clicks on an already marked
    figure. The figure becomes unmarked, nothing more happens.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Idle`: 应用程序等待用户的输入。只要用户没有按下左鼠标按钮，这始终是模式。然而，当用户按下鼠标按钮，直到他们释放它，`applicationMode`
    方法保持一个值。用户按下 *Ctrl* 键并点击一个已经标记的图形。图形变为未标记，没有其他操作发生。'
- en: '`ModifySingle`: The user grabs one single figure that is being modified (if
    the user clicks on one of its endpoints) or moved (if the user clicks on any other
    part of the figure).'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ModifySingle`: 用户抓取一个正在修改的单一图形（如果用户点击其端点之一）或移动的图形（如果用户点击图形的任何其他部分）。'
- en: '`ModifyRectangle`: The user has clicked on the client area without hitting
    a figure, resulting in a rectangle being drawn. When the user releases the mouse
    button, every figure completely enclosed by the rectangle is marked.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ModifyRectangle`: 用户在客户端区域点击而没有击中任何图形，导致绘制了一个矩形。当用户释放鼠标按钮时，矩形完全包围的每个图形都会被标记。'
- en: '`MoveMultiple`: The user presses the *Ctr*l key and clicks on an unmarked figure.
    It is not possible to modify more than one figure at the same time.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MoveMultiple`: 用户按下 *Ctrl* 键并点击一个未标记的图形。同时修改多个图形是不可能的。'
- en: 'Note that the `applicationMode` method is relevant only as long as the user
    presses the left mouse button. As soon as they release the mouse button, the `applicationMode`
    method is always `Idle`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`applicationMode` 方法仅在用户按下左鼠标按钮时相关。一旦他们释放鼠标按钮，`applicationMode` 方法始终是 `Idle`：
- en: '[PRE10]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When the `applicationMode` method holds the `Idle` mode, the application waits
    for further input from the user. The `actionMode` field defines the next action,
    which may hold the following values:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当`applicationMode`方法保持`Idle`模式时，应用程序等待用户进一步的输入。`actionMode`字段定义下一个动作，它可以持有以下值：
- en: '`Modify`: When the user presses the mouse button, the `applicationMode` method
    is set to the `ModifySingle` mode if they click on a figure, the `MoveMultiple`
    mode if they click on an unmarked figure while pressing the *Ctrl* key, the `Idle`
    mode if the figure is already marked, or the `ModifyRectangle` mode if they click
    on the client area without hitting a figure.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Modify`：当用户按下鼠标按钮时，如果他们点击一个图形，则`applicationMode`方法设置为`ModifySingle`模式；如果他们在按下*Ctrl*键的同时点击一个未标记的图形，则设置为`MoveMultiple`模式；如果图形已经被标记，则设置为`Idle`模式；如果他们点击客户端区域而没有击中图形，则设置为`ModifyRectangle`模式。'
- en: '`Add`: When the user presses the left mouse button, a new figure is created
    at the location, regardless of whether there already is a figure at the location.
    The value of the `addFigureId` method decides which kind of figure should be added;
    it can hold any of the values `LineId`, `ArrowId`, `RectangleId`, or `EllipseId`.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Add`：当用户按下鼠标左键时，无论该位置是否已有图形，都会在该位置创建一个新的图形。`addFigureId`方法的值决定应该添加哪种类型的图形；它可以持有`LineId`、`ArrowId`、`RectangleId`或`EllipseId`中的任何值。'
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Later in the chapter, we will encounter expressions such as **in Modify mode**
    and **in Add mode**, which refer to the value of the `actionMode` variable: `Modify`
    or `Add`.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将遇到**在修改模式**和**在添加模式**之类的表达式，它们指的是`actionMode`变量的值：`Modify`或`Add`。
- en: 'The `nextColor` and `nextFill` fields hold the figure''s color and fill status
    (in the case of a rectangle or ellipse), respectively, of the next figure to be
    added:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`nextColor`和`nextFill`字段分别存储下一个图形的颜色和填充状态（在矩形或椭圆的情况下）：'
- en: '[PRE12]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Similar to the circle application, when the user adds or modifies a figure,
    we need to store the previous mouse position in the `prevMousePoint` method in
    order to keep track of the distance the mouse has been moved since the last mouse
    action:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与圆的应用类似，当用户添加或修改一个图形时，我们需要在`prevMousePoint`方法中存储之前的鼠标位置，以便跟踪鼠标自上次鼠标操作以来移动的距离：
- en: '[PRE13]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When the `applicationMode` method holds the `ModifySingle` value, the figure
    being modified is always placed at the beginning of the figure pointer list (`figurePtrList[0]`)
    in order for it to appear on top of the figures. When the `applicationMode` method
    holds the `ModifyRectangle` mode, the `insideRectangle` method keeps track of
    the rectangle enclosing the figures:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当`applicationMode`方法保持`ModifySingle`值时，正在修改的图形始终放置在图形指针列表的起始位置（`figurePtrList[0]`），以便它出现在图形之上。当`applicationMode`方法保持`ModifyRectangle`模式时，`insideRectangle`方法跟踪包围图形的矩形：
- en: '[PRE14]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `static DrawFormat` constant is used to identify data to be cut, copied,
    or pasted in the global clipboard. It is arbitrarily set to 1000:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`static DrawFormat`常量用于标识要在全局剪贴板中剪切、复制或粘贴的数据。它被任意设置为1000：'
- en: '[PRE15]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As the user adds and removes figures from the drawing, the figures are dynamically
    created and deleted; their addresses are stored in the `figurePtrList` list. The
    `DynamicList` class is a Small Windows class that is a more advanced version of
    the C++ standard classes `list` and `vector`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 随着用户从绘图添加和删除图形，图形会动态创建和删除；它们的地址存储在`figurePtrList`列表中。`DynamicList`类是一个Small
    Windows类，它是C++标准类`list`和`vector`的更高级版本。
- en: 'The values of the figure list are pointers to the `DrawFigure` class, which
    is the root class of the figure hierarchy used in this application (described
    in [Chapter 5](ch05.html "Chapter 5. The Figure Hierarchy"), *The Figure Hierarchy*).
    Unlike the circle and Tetris applications in the previous chapters, we do not
    store the figure objects directly in the list, but rather their pointers. This
    is necessary, since we use class hierarchy holds with pure virtual methods, which
    makes the `DrawWindow` class abstract and not possible to store directly in the
    list. It is also necessary in order to take advantage of dynamic binding of the
    class hierarchy:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图形列表的值是指向`DrawFigure`类的指针，这是在本应用中使用的图形层次结构的根类（在[第5章](ch05.html "第5章。图形层次结构")中描述，*图形层次结构*）。与前面章节中的圆和俄罗斯方块应用不同，我们不是直接在列表中存储图形对象，而是它们的指针。这是必要的，因为我们使用具有纯虚方法的类层次结构，这使得`DrawWindow`类成为抽象的，不能直接存储在列表中。这也为了利用类层次结构的动态绑定：
- en: '[PRE16]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The application modes
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序模式
- en: 'This section holds a further description of the `applicationMode` field. It
    is closely connected to the mouse input cycle. When the user is not pressing the
    left mouse button, the `applicationMode` method is always in the `Idle` mode.
    When the user presses the left mouse button in modify mode, they can choose to
    press the *Ctrl* key at the same time:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 本节进一步描述了`applicationMode`字段。它与鼠标输入周期紧密相关。当用户没有按下左鼠标按钮时，`applicationMode`方法始终处于`Idle`模式。当用户在修改模式下按下左鼠标按钮时，他们可以选择同时按下**Ctrl**键：
- en: If they do not press the *Ctrl* key, the `applicationMode` method is set to
    the `ModifySingle` mode if they hit a figure. That figure becomes marked and other
    figures become unmarked.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果他们没有按下**Ctrl**键，当点击图形时，`applicationMode`方法会被设置为`ModifySingle`模式。该图形被标记，其他图形变为未标记。
- en: If they do press the *Ctrl* key, the `applicationMode` method is set to the
    `MoveMultiple` mode if they hit a figure that is not marked and to the `Idle`
    mode if it is marked. The figure becomes marked if it is unmarked and unmarked
    if it is marked. The rest of the figures are unaffected.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果他们按下**Ctrl**键，当点击一个未标记的图形时，`applicationMode`方法会被设置为`MoveMultiple`模式；如果点击的是一个已标记的图形，则设置为`Idle`模式。图形在被标记时变为未标记，反之亦然。其他图形不受影响。
- en: If they do not hit a figure, the `applicationMode` method is set to the `ModifyRectangle`
    mode regardless of whether they pressed the *Ctrl* key and the inside rectangle
    (`insideRectangle`) is being initialized. All figures become unmarked. All figures
    that are completely enclosed by the rectangle when the user releases the left
    button are marked.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果他们没有点击图形，无论是否按下**Ctrl**键，`applicationMode`方法都会设置为`ModifyRectangle`模式，并且内部矩形（`insideRectangle`）正在初始化。所有图形都变为未标记。当用户释放左鼠标按钮时，所有完全被矩形包围的图形都会被标记。
- en: 'When the user moves the mouse with the left button pressed in modify mode,
    there are four possible values of the `applicationMode` method to consider:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在修改模式下按下左鼠标按钮并移动鼠标时，需要考虑`applicationMode`方法的四种可能值：
- en: '`Idle`: We do nothing.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Idle`：我们不进行任何操作。'
- en: '`ModifySingle`: We call the `Modify` method on the single figure. This may
    result in the single hit figure being modified or moved, depending on where the
    user hit the figure.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ModifySingle`：我们对单个图形调用`Modify`方法。这可能导致用户点击的图形被修改或移动，具体取决于用户点击图形的位置。'
- en: '`MoveMultiple`: We call the `Move` method on all marked figures. This always
    results in the marked figures being moved, not modified.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MoveMultiple`：我们对所有标记的图形调用`Move`方法。这总是导致标记的图形被移动，而不是被修改。'
- en: '`ModifyRectangle`: We modify the inside rectangle.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ModifyRectangle`：我们修改内部矩形。'
- en: 'Finally, when the user releases the left mouse button, we again look into the
    four modes of the `applicationMode` method:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当用户释放左鼠标按钮时，我们再次查看`applicationMode`方法的四种模式：
- en: '`Idle`, `ModifySingle`, or `MoveMultiple`: We do nothing since everything has
    already been done when the user moved the mouse. The marked figures have been
    moved or modified.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Idle`、`ModifySingle`或`MoveMultiple`：由于用户移动鼠标时已经完成了一切，所以我们不做任何操作。标记的图形已经被移动或修改。'
- en: '`ModifyRectangle`: We mark all figures completely enclosed by the rectangle.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ModifyRectangle`：我们标记所有完全被矩形包围的图形。'
- en: The DynamicList class
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态列表类
- en: 'In this chapter, we use a subset of the methods of the auxiliary `DynamicList`
    class. It holds a set of methods that take callback functions, that is, functions
    that are sent as parameters to methods and called by the methods:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了辅助`DynamicList`类的方法子集。它包含了一组接受回调函数的方法，即作为参数传递给方法并由方法调用的函数：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`IfFuncPtr` and `DoFuncPtr` are pointers to callback functions. The difference
    between them is that the `IfFuncPtr` pointer is intended for methods that only
    inspect the values of the list. Therefore, the `value` parameter is constant.
    The `DoFuncPtr` pointer is intended for methods that modify the values. Consequently,
    the `value` parameter is not constant:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`IfFuncPtr`和`DoFuncPtr`是指向回调函数的指针。它们之间的区别在于，`IfFuncPtr`指针旨在用于仅检查列表值的函数。因此，`value`参数是常量。`DoFuncPtr`指针旨在用于修改值的函数。因此，`value`参数不是常量：'
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `AnyOf` method takes the `ifFuncPtr` pointer and applies it to each value
    of the array. The methods return `true` if at least one of the values satisfies
    the `ifFunctPtr` pointer (if the `ifFuncPtr` pointer returns `true` for the value).
    The `ifVoidPtr` parameter is sent as the second parameter to the `ifFuncPtr` pointer:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnyOf` 方法接受 `ifFuncPtr` 指针并将其应用于数组的每个值。如果至少有一个值满足 `ifFunctPtr` 指针（如果 `ifFuncPtr`
    指针对值返回 `true`），则方法返回 `true`。`ifVoidPtr` 参数作为 `ifFuncPtr` 指针的第二个参数发送：'
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `FirstOf` method also returns `true` if at least one value satisfies the
    `ifFuncPtr` pointer. In that case, the first satisfied value is copied to the
    `value` parameter:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`FirstOf` 方法如果至少有一个值满足 `ifFuncPtr` 指针，也会返回 `true`。在这种情况下，满足条件的第一个值被复制到 `value`
    参数：'
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `Apply` method calls the `doFunctPtr` pointer to every value of the list.
    The `ApplyIf` method calls the `doFuncPtr` pointer to all values that satisfy
    the `ifFuncPtr` pointer:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Apply` 方法调用 `doFunctPtr` 指针到列表中的每个值。`ApplyIf` 方法调用 `doFunctPtr` 指针到所有满足 `ifFuncPtr`
    指针的值：'
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `CopyIf` method copies the values satisfying the `ifFuncPtr` pointer into
    the `copyArray` method. The `RemoveIf` method removes every value satisfying the
    `ifFuncPtr` pointer:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`CopyIf` 方法将满足 `ifFuncPtr` 指针的值复制到 `copyArray` 方法中。`RemoveIf` 方法移除满足 `ifFuncPtr`
    指针的每个值：'
- en: '[PRE22]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `ApplyRemoveIf` method calls the `doFuncPtr` pointer and then removes every
    value satisfying the `ifFuncPtr` pointer, which comes in handy when we want to
    deallocate and remove pointers from the list:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApplyRemoveIf` 方法调用 `doFuncPtr` 指针，然后移除满足 `ifFuncPtr` 指针的每个值，这在我们需要从列表中释放和移除指针时非常有用：'
- en: '[PRE23]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Initialization
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化
- en: 'The constructor of the `DrawDocument` class is similar to the constructor of
    the `CircleDocument` class. We use the `LogicalWithScroll` coordinate system with
    US letter size. The file description `Draw Files` and the suffix `drw` are used
    to filter drawing files in the open and save dialogs. The null pointer indicates
    that the document does not have a parent window, and the `false` parameter indicates
    that the **Print** and **Print Preview** items in the **File** menu are omitted.
    Finally, the initiation lists holding the `DrawFormat` parameter indicates the
    format used to identify data to be copied and pasted. In this case, we use the
    same format for both copying and pasting:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawDocument` 类的构造函数与 `CircleDocument` 类的构造函数类似。我们使用 US 字号大小的 `LogicalWithScroll`
    坐标系。文件描述 `Draw Files` 和后缀 `drw` 用于在打开和保存对话框中过滤绘图文件。空指针表示文档没有父窗口，而 `false` 参数表示在
    **文件** 菜单中省略了 **打印** 和 **打印预览** 项。最后，包含 `DrawFormat` 参数的初始化列表表示用于标识要复制和粘贴的数据的格式。在这种情况下，我们为复制和粘贴使用相同的格式：'
- en: '**DrawDocument.cpp**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**DrawDocument.cpp**'
- en: '[PRE24]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Since we extend the `StandardDocument` framework, the window has a standard
    menu bar with the **File** menu holding **New**, **Open**, **Save**, **Save As**,
    and **Exit** (the **Print** and **Print Preview** items are omitted due to the
    `false` parameter in the constructor call) items, the **Edit** menu holding **Cut**,
    **Copy**, **Paste**, and **Delete**, and the **Help** items, and **About**.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们扩展了 `StandardDocument` 框架，窗口具有标准菜单栏，其中 **文件** 菜单包含 **新建**、**打开**、**保存**、**另存为**
    和 **退出**（由于构造函数调用中的 `false` 参数，省略了 **打印** 和 **打印预览** 项），**编辑** 菜单包含 **剪切**、**复制**、**粘贴**
    和 **删除**，以及 **帮助** 项和 **关于**。
- en: 'We also add two application-specific menus: **Format** and **Add**. The **Format**
    menu holds the menu items **Modify**, **Color**, and **Fill**. Similar to the
    circle application, we mark the menu items with mnemonics and accelerators. However,
    we also use the enable parameters; the `ModifyEnable`, `ColorEnable`, and `FillEnable`
    methods are called before the menu items become visible. If they return `false`,
    the menu item is disabled and grayed:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了两个特定于应用程序的菜单：**格式** 和 **添加**。**格式** 菜单包含 **修改**、**颜色** 和 **填充** 菜单项。类似于圆形应用程序，我们使用助记符和快捷键标记菜单项。然而，我们还将启用参数；在菜单项可见之前调用
    `ModifyEnable`、`ColorEnable` 和 `FillEnable` 方法。如果它们返回 `false`，则菜单项被禁用并变灰：
- en: '[PRE25]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The **Add** menu holds one item for each kind of figure to be added:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**添加** 菜单为要添加的每种图形类型包含一个项：'
- en: '[PRE26]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we read values from the **Windows Registry**, which is a database
    in the Windows system that we can use to store values between the executions of
    our applications. The Small Windows auxiliary classes `Color`, `Font`, `Point`,
    `Size`, and `Rect` have their own registry methods. The Small Windows `Registry`
    class holds static methods for reading and writing text as well as numerical and
    integer values:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们从**Windows注册表**中读取值，这是Windows系统中我们可以用来在应用程序执行之间存储值的数据库。Small Windows辅助类`Color`、`Font`、`Point`、`Size`和`Rect`都有自己的注册方法。Small
    Windows的`Registry`类包含用于读取和写入文本以及数值和整数的静态方法：
- en: '[PRE27]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The destructor writes the values to the registry. In this application, it is
    not necessary to provide any common destructor actions such as deallocating memory
    or closing files:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数将值写入注册表。在这个应用程序中，不需要提供任何常见的析构函数操作，例如释放内存或关闭文件：
- en: '[PRE28]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Mouse input
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 鼠标输入
- en: '`IsFigureMarked`, `IsFigureClicked`, and `UnmarkFigure` are callback functions
    that are called by the `DynamicList` methods `AnyOf`, `FirstOf`, `CopyIf`, `ApplyIf`,
    and `ApplyRemoveIf`. These methods take the pointer to a figure and an optional
    void pointer that holds additional information.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsFigureMarked`、`IsFigureClicked`和`UnmarkFigure`是`DynamicList`方法`AnyOf`、`FirstOf`、`CopyIf`、`ApplyIf`和`ApplyRemoveIf`调用的回调函数。这些方法接受图形的指针和一个可选的void指针，该指针包含附加信息。'
- en: The `IsFigureMarked` function returns `true` if the figure is marked, the `IsFigureClicked`
    function returns `true` if the mouse point given in the `voidPtr` pointer hits
    the figure, and the `IsFigureClicked` function unmarks the figure if it is marked.
    As you can see, the `IsFigureMarked` function is defined as a lambda function,
    while the `IsFigureClicked` function is defined as a regular function.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsFigureMarked`函数如果图形被标记则返回`true`，`IsFigureClicked`函数如果给定的`voidPtr`指针中的鼠标点击图形则返回`true`，如果图形被标记，`IsFigureClicked`函数会取消标记图形。如您所见，`IsFigureMarked`函数被定义为lambda函数，而`IsFigureClicked`函数被定义为常规函数。'
- en: 'There is no rational reason for this, other than that I would like to demonstrate
    both ways to define functions:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这没有合理的理由，除了我想展示定义函数的两种方式：
- en: '[PRE29]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the `OnMouseDown` method, we first check that the user presses the left
    mouse button. If so, we save the mouse position in the `prevMousePoint` field
    so that we can calculate the distance the figure has moved in subsequent calls
    to the `OnMouseMove` method:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OnMouseDown`方法中，我们首先检查用户是否按下鼠标左键。如果是这样，我们将鼠标位置保存到`prevMousePoint`字段中，以便我们可以在后续调用`OnMouseMove`方法时计算图形移动的距离：
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As mentioned earlier, the mouse click will result in different actions depending
    on the value of the `actionMode` method. In case of the `Modify` method, we call
    the `FirstOf` parameter on the figure pointer list to extract the first clicked
    figure. The figures can overlap, and the click may hit more than one figure. In
    that case, we want the topmost figure located at the beginning of the list. The
    `FirstOf` method returns `true` if there is at least one clicked figure, which
    is copied into the `topClickedFigurePtr` reference parameter. The address of the
    `mousePoint` method is given as the second parameter to the `FirstOf` method and
    is, in turn, given to the `IsFigureClicked` function as its second parameter:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，鼠标点击的结果取决于`actionMode`方法值的差异。在`Modify`方法的情况下，我们在图形指针列表上调用`FirstOf`参数以提取第一个点击的图形。图形可以重叠，点击可能击中多个图形。在这种情况下，我们希望列表开头的最上面的图形。如果至少有一个点击的图形，`FirstOf`方法返回`true`，并将其复制到`topClickedFigurePtr`引用参数中。`mousePoint`方法的地址作为`FirstOf`方法的第二个参数给出，并将其作为第二个参数传递给`IsFigureClicked`函数：
- en: '[PRE31]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We have two cases to consider, depending on whether the user presses the *Ctrl*
    key. If they do so, the figure will be marked if it is unmarked and vice versa,
    and other marked figures will remain marked.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要考虑两种情况，这取决于用户是否按下*Ctrl*键。如果这样做，如果图形未被标记，则将其标记，反之亦然，并且其他标记的图形将保持标记。
- en: 'However, in the other case, when the user does not press the *Ctrl* key, the
    figure becomes marked regardless of whether it is already marked, all other marked
    figures become unmarked, and the application is set to the `ModifySingle` mode.
    The figures are removed from the list and inserted at the beginning (front) in
    order to appear on top of the drawing:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在另一种情况下，当用户没有按下*Ctrl*键时，无论图形是否已经标记，图形都会被标记，所有其他标记的图形都会取消标记，并且应用程序设置为`ModifySingle`模式。图形从列表中移除并插入到列表的开始（前端），以便出现在绘图的最上面：
- en: '[PRE32]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If the user presses the *Ctrl* key, we have another two cases. If the clicked
    figure is already marked, we unmark it and set the `applicationMode` method to
    the `Idle` mode. If the clicked figure is not already marked, we mark it and set
    the `applicationMode` method to the `MoveMultiple` mode. In this way, we have
    at least one marked figure to be moved in the `OnMouseMove` method when the user
    moves the mouse. Note that if the user presses the *Ctrl* key, one or several
    figures can be moved but not modified. It would be illogical to modify more than
    one figure at the same time:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户按下 *Ctrl* 键，我们还有另外两种情况。如果点击的图形已经被标记，我们将取消标记它并将 `applicationMode` 方法设置为 `Idle`
    模式。如果点击的图形尚未标记，我们将标记它并将 `applicationMode` 方法设置为 `MoveMultiple` 模式。这样，在用户移动鼠标时，`OnMouseMove`
    方法中至少有一个标记的图形要移动。请注意，如果用户按下 *Ctrl* 键，一个或多个图形可以移动但不能修改。同时修改多个图形是不合逻辑的：
- en: '[PRE33]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If the user hits a point where no figure is located (the `figurePtrList.FirstOf`
    method returns `false`), we unmark all marked figures, initialize the `insideRectangle`
    method, and set the `applicationMode` method to the `ModifyRectangle` mode.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户到达一个没有图形的位置（`figurePtrList.FirstOf` 方法返回 `false`），我们将取消所有标记的图形，初始化 `insideRectangle`
    方法，并将 `applicationMode` 方法设置为 `ModifyRectangle` 模式。
- en: '[PRE34]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'All the aforementioned cases in this method takes place when the `actionMode`
    method is `Modify`. However, it can also be `Add`, in which case a new figure
    will be added to the drawing. We use the `addFigureId` method to decide which
    kind of figure to add when calling the `CreateFigure` method. We set the dirty
    flag, since we have added a figure and the document has been modified. Finally,
    we add the address of the new figure to the beginning of the figure list (so that
    it appears on top) and set the `applicationMode` method to the `ModifySingle`
    mode:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法中提到的所有上述情况都发生在 `actionMode` 方法为 `Modify` 时。然而，它也可以是 `Add`，在这种情况下，将在绘图中新添加一个图形。我们使用
    `addFigureId` 方法在调用 `CreateFigure` 方法时决定添加哪种类型的图形。我们设置脏标志，因为我们已经添加了一个图形，文档已经被修改。最后，我们将新图形的地址添加到图形列表的开头（这样它就会出现在顶部），并将
    `applicationMode` 方法设置为 `ModifySingle` 模式：
- en: '[PRE35]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Depending on the action and modes, the window and cursor may need to be updated:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 根据操作和模式，窗口和光标可能需要更新：
- en: '[PRE36]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `MoveMarkFigure` method is a callback function that is called by the `Apply`
    method on `figurePtrList` in the `OnMouseMove` method. It moves the figure that
    is marked. The address of the moving distance is given in the `voidPtr` parameter:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`MoveMarkFigure` 方法是一个回调函数，它在 `OnMouseMove` 方法中由 `figurePtrList` 的 `Apply`
    方法调用。它移动标记的图形。移动距离的地址在 `voidPtr` 参数中给出：'
- en: '[PRE37]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the `OnMouseMove` method, we start by calculating the distance since the
    previous call to the `OnMouseDown` or `OnMouseMove` method. We also set the `prevMousePoint`
    method to the mouse position:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `OnMouseMove` 方法中，我们首先计算自上次调用 `OnMouseDown` 或 `OnMouseMove` 方法以来的距离。我们还设置
    `prevMousePoint` 方法为鼠标位置：
- en: '[PRE38]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Depending on the `applicationMode` method, we perform different tasks. In case
    of the `Modify` method on a single figure, we call the `MoveOrModify` method on
    that figure. The figure is placed at the beginning of the figure pointer list
    (`figurePtrList[0]`), since we placed it there in the `OnMouseDown` method. The
    idea is that the figure itself, depending on where the user clicked, decides whether
    it is moved or modified. The state of the figure is set when the user clicks on
    it, and depends on whether they click on any of the endpoints of the figure:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 `applicationMode` 方法的不同，我们执行不同的任务。在单个图形的 `Modify` 方法的情况下，我们在该图形上调用 `MoveOrModify`
    方法。由于我们在 `OnMouseDown` 方法中将其放置在那里，该图形位于图形指针列表的开头（`figurePtrList[0]`）。想法是图形本身，根据用户点击的位置，决定它是移动还是修改。图形的状态在用户点击时设置，并取决于他们是否点击了图形的任何端点：
- en: '[PRE39]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In case of multiple movements, we move every marked figure the distance since
    the last mouse message. Note that we do not modify the figures in the multiple
    cases as we do in the single case:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个移动的情况下，我们将每个标记的图形移动到上次鼠标消息的距离。请注意，我们不会像在单个情况下那样在多个情况下修改图形：
- en: '[PRE40]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the rectangle case, we set its bottom-right corner and redraw it:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在矩形的情况下，我们设置其右下角并重新绘制它：
- en: '[PRE41]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `IsFigureInside` and `MarkFigure` methods are callback functions that are
    called by the `DynamicList` methods `CopyIf`, `RemoveIf`, and `Apply` on `figurePtrList`
    in the `OnMouseUp` method. The `IsFigureInside` method returns `true` if the figure
    is located inside the given rectangle, while the `MarkFigure` method simply marks
    the figure:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsFigureInside`和`MarkFigure`方法是回调函数，在`OnMouseUp`方法中由`DynamicList`方法`CopyIf`、`RemoveIf`和`Apply`在`figurePtrList`上调用。如果图形位于给定的矩形内部，`IsFigureInside`方法返回`true`，而`MarkFigure`方法只是标记图形：'
- en: '[PRE42]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the `OnMouseUp` method, we only need to take the `ModifyRectangle` case into
    consideration. We need to decide which figures are totally enclosed by the rectangle.
    In order for them to appear on top of the drawing, we first call the `CopyIf`
    method on the `figurePtrList` list to temporarily copy the figures located completely
    inside the rectangle to the `insideList` list.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OnMouseUp`方法中，我们只需要考虑`ModifyRectangle`情况。我们需要决定哪些图形完全被矩形包围。为了让它们出现在绘图的最上层，我们首先在`figurePtrList`列表上调用`CopyIf`方法，将完全位于矩形内部的图形临时复制到`insideList`列表中。
- en: 'Then we remove the figures from the `figurePtrList` list and insert them from
    the `insideList` list at the beginning of the `figurePtrList` list. This makes
    them appear at the top of the drawing. Finally, we mark the figure inside the
    rectangle by calling `Apply` on the `insideList` list:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们从`figurePtrList`列表中删除图形，并将它们从`insideList`列表中插入到`figurePtrList`列表的开头。这使得它们出现在绘图的最上层。最后，我们通过在`insideList`列表上调用`Apply`来标记矩形内的图形：
- en: '[PRE43]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After the user has released the left mouse button, the application holds the
    `Idle` mode, which it always holds as long as the user does not press the left
    mouse button:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户释放左鼠标按钮后，应用程序保持`Idle`模式，只要用户不按下左鼠标按钮，它就会一直保持这种模式：
- en: '[PRE44]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `OnDoubleClick` method is called when the user double-clicks on the mouse
    button. The difference between a double-click and two consecutive clicks is decided
    by the Windows system, and can be adjusted in the Windows control panel. In case
    of a double-click, the `OnMouseDown` and `OnMouseUp` methods are called before
    the `OnDoubleClick` method. We extract the topmost clicked figure, if any, and
    call the `DoubleClick` method. The result depends on the type of figure: the head
    of an arrow is reversed, a rectangle or ellipse is filled if unfilled and vice
    versa, and a line is not affected at all:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户双击鼠标按钮时，会调用`OnDoubleClick`方法。双击和连续两次点击之间的区别由Windows系统决定，可以在Windows控制面板中调整。在双击的情况下，在`OnDoubleClick`方法之前会调用`OnMouseDown`和`OnMouseUp`方法。如果有的话，我们提取最顶部的点击图形，并调用`DoubleClick`方法。结果取决于图形的类型：箭头的头部会反转，如果矩形或椭圆未被填充，则填充它们，反之亦然，而直线则不受影响：
- en: '[PRE45]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Painting
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制
- en: 'In Small Windows, there are three general painting methods: `OnPaint`, `OnPrint`,
    and `OnDraw`. The Windows system indirectly calls the `OnPaint` and `OnPrint`
    methods for painting a window or printing a paper, respectively. Their default
    behavior is to call the `OnDraw` method. Remember that we do not take any initiatives
    to paint the window, we just wait for the right message. The idea is that in cases
    when we need to distinguish between painting and printing, we override the `OnPaint`
    and `OnPrint` methods, and when we do not need that distinction, we override the
    `OnDraw` method instead.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在小窗口中，有三种常见的绘图方法：`OnPaint`、`OnPrint`和`OnDraw`。Windows系统分别间接调用`OnPaint`和`OnPrint`方法来绘制窗口或打印纸张，它们的默认行为是调用`OnDraw`方法。记住，我们不会主动绘制窗口，我们只是等待正确的消息。这个想法是，在需要区分绘制和打印的情况下，我们重写`OnPaint`和`OnPrint`方法，而在不需要这种区分的情况下，我们重写`OnDraw`方法。
- en: 'In the word processor, which is discussed later in this book, we will look
    into the difference between painting and printing. However, in this application,
    we just override the `OnDraw` method. As mentioned in [Chapter 3](ch03.html "Chapter 3. Building
    a Tetris Application"), *Building a Tetris Application*, the `Graphics` class
    reference is created by the framework and can be considered a toolbox equipped
    with pens and brushes. In this case, we just call the `DrawFigure` method for
    each figure with the `Graphics` reference as a parameter. In case of the `ModifyRectangle`
    mode, we also draw the rectangle:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书稍后讨论的文字处理器中，我们将探讨绘制和打印之间的区别。然而，在这个应用程序中，我们只是重写了`OnDraw`方法。如[第3章](ch03.html
    "第3章。构建俄罗斯方块应用程序")中所述，*构建俄罗斯方块应用程序*，框架创建了`Graphics`类引用，可以被认为是一个配备了笔刷的工具箱。在这种情况下，我们只需使用`Graphics`引用作为参数调用每个图的`DrawFigure`方法。在`ModifyRectangle`模式下，我们也绘制矩形：
- en: '[PRE46]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The File menu
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件菜单
- en: 'Thanks to the framework in the `StandardDocument` class, the file management
    is quite easy. The `ClearDocument` method is called when the user selects the
    **New** menu item, we just delete the figures and clear the figure list:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢`StandardDocument`类中的框架，文件管理变得相当简单。当用户选择**新建**菜单项时，会调用`ClearDocument`方法，我们只需删除图并清空图列表：
- en: '[PRE47]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `WriteDocumentToStream` method is called when the user selects the **Save**
    or **Save As** menu item. It first writes the size of the figure list, and for
    each figure it writes its identity number (which is necessary when reading the
    figure in the `ReadDocumentFromStream` method shown as follows), and then writes
    the figure itself by calling its `WriteFigureToStream` method:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择**保存**或**另存为**菜单项时，会调用`WriteDocumentToStream`方法。它首先写入图列表的大小，然后对于每个图，它写入其标识号（这在读取`ReadDocumentFromStream`方法中显示的图时是必要的），然后通过调用其`WriteFigureToStream`方法来写入图本身：
- en: '[PRE48]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `ReadDocumentFromStream` method is called when the user selects the **Open**
    menu item. It starts by reading the number of figures in the figure list. We need
    to read the identity number for the next figure and call the `CreateFigure` method
    to receive a pointer to the created figure. Then we just call the `ReadFigureFromStream`
    method for the figure and add the figure''s address to the figure pointer list:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择**打开**菜单项时，会调用`ReadDocumentFromStream`方法。它首先读取图列表中的图数量。我们需要读取下一个图的标识号，并调用`CreateFigure`方法以获取创建的图的指针。然后，我们只需调用`ReadFigureFromStream`方法来读取图，并将图的地址添加到图指针列表中：
- en: '[PRE49]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `CreateFigure` method is called by the `ReadFigureFromStream` and `ReadFigureFromClipboard`
    method and creates a figure of the given type:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadFigureFromStream`和`ReadFigureFromClipboard`方法会调用`CreateFigure`方法，并创建给定类型的图：'
- en: '[PRE50]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Cut, copy, and paste
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 剪切、复制和粘贴
- en: 'Similar to the aforementioned file management case, the framework also takes
    care of the details of cut, copy, and paste. First, we do need to decide when
    the cut and copy menu items and accelerators will be enabled. In `Modify` mode,
    it is enough that at least one figure is marked. We use the `DynamicList` method
    `AnyOf` to decide whether at least one figure is marked. In `Add` mode, cut or
    copy is never allowed. We do not need to override the `CutEnable` method, since
    its default behavior in the `StandardDocument` framework is to call the `CopyEnable`
    method:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 与上述文件管理案例类似，框架也负责剪切、复制和粘贴的细节。首先，我们需要决定何时启用剪切和复制菜单项和快捷键。在`Modify`模式下，至少有一个图被标记就足够了。我们使用`DynamicList`方法的`AnyOf`来决定是否至少有一个图被标记。在`Add`模式下，剪切或复制是不允许的。我们不需要重写`CutEnable`方法，因为在`StandardDocument`框架中，它的默认行为是调用`CopyEnable`方法：
- en: '[PRE51]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: There is a `PasteEnable` method in the `StandardDocument` framework. However,
    in this application we do not need to override it, since the framework decides
    when to enable pasting or, more specifically, when there is data on the global
    clipboard with the format code given in the `StandardDocument` constructor, in
    this case the `DrawFormat` field. The global clipboard is a Windows resource intended
    for short-term storing of information that has been copied.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在`StandardDocument`框架中有一个`PasteEnable`方法。然而，在这个应用程序中我们不需要重写它，因为框架决定何时启用粘贴，或者更具体地说，当全局剪贴板上有在`StandardDocument`构造函数中给出的格式代码的数据时，在这种情况下是`DrawFormat`字段。全局剪贴板是一个Windows资源，用于存储已复制信息的短期存储。
- en: 'The `CopyGeneric` method takes a list of characters that are intended to be
    filled with application-specific information. We save the number of marked figures,
    and for each marked figure, we write its identity number and call the `WriteFigureToClipboard`
    method, which writes the figure-specific information to the `infoList` parameter:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`CopyGeneric`方法接受一个字符列表，这些字符打算用应用程序特定的信息填充。我们保存标记图形的数量，并为每个标记的图形，我们写入其身份编号并调用`WriteFigureToClipboard`方法，该方法将图形特定信息写入`infoList`参数：'
- en: '[PRE52]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `PasteGeneric` method pastes the figures in a way similar to the aforementioned
    the `ReadDocumentFromStream` method:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`PasteGeneric`方法以类似于前面提到的`ReadDocumentFromStream`方法的方式粘贴图形：'
- en: '[PRE53]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: There is a `DeleteEnable` method in the `StandardDocument` framework, which
    we do not need to override since its default behavior is to call the `CopyEnable`
    method. The `OnDelete` method goes through the figure list, invalidating and deleting
    the marked figures. We use the `DynamicList` method `ApplyRemoveIf` to remove
    and delete marked figures.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在`StandardDocument`框架中有一个`DeleteEnable`方法，我们不需要重写它，因为其默认行为是调用`CopyEnable`方法。`OnDelete`方法遍历图形列表，使标记的图形无效并删除它们。我们使用`DynamicList`方法的`ApplyRemoveIf`来删除和删除标记的图形。
- en: 'We cannot simply use the `ApplyIf` and `RemoveIf` methods to deallocate and
    remove the figures, since it would result in memory errors (dangling pointers):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能简单地使用`ApplyIf`和`RemoveIf`方法来释放和删除图形，因为这会导致内存错误（悬挂指针）：
- en: '[PRE54]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The Modify menu
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改菜单
- en: 'The **Modify** menu item is quite easy to handle. It is enabled in case the
    application is in the `Idle` mode, which it is in when the user does not press
    the left mouse button. The radio button is also present if the `actionMode` method
    is `Modify`, and the menu item listener just sets the `actionMode` method to `Modify`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**修改**菜单项操作起来非常简单。当应用程序处于`空闲`模式时，它会启用，此时用户没有按下鼠标左键。如果`actionMode`方法设置为`修改`，则也会出现单选按钮，菜单项监听器只需将`actionMode`方法设置为`修改`：'
- en: '[PRE55]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'For the **Color** and **Fill** menu items, there are enable methods that are
    rather easy and listeners that are a little bit more complicated. It is possible
    to change the color in `Modify` mode if at least one figure is marked. In `Add`
    mode, it is always possible to change the color:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**颜色**和**填充**菜单项，有简单的启用方法，监听器则稍微复杂一些。在`修改`模式下，如果至少有一个图形被标记，则可以更改颜色。在`添加`模式下，始终可以更改颜色：
- en: '[PRE56]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `SetFigureColor` method is a callback function that is called by the `ApplyIf`
    method on the `figurePtrList` list in the `OnColor` method:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetFigureColor`方法是一个回调函数，它在`OnColor`方法中由`figurePtrList`列表上的`ApplyIf`方法调用：'
- en: '[PRE57]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `OnColor` method is called when the user selects the **Color** menu item.
    In `Modify` mode, we extract the marked figures and choose the color of the topmost
    of them. We know that at least one figure is marked, otherwise the preceding `ColorEnable`
    method would return `false` and the **Color** menu item would be disabled. If
    the `ColorDialog` call returns `true`, we set the new color of all marked figures
    by calling the `ApplyIf` method on the `figurePtrList` list:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择**颜色**菜单项时，会调用`OnColor`方法。在`修改`模式下，我们提取标记的图形并选择其最上面的颜色。我们知道至少有一个图形被标记，否则前面的`ColorEnable`方法会返回`false`，**颜色**菜单项将被禁用。如果`ColorDialog`调用返回`true`，我们通过在`figurePtrList`列表上调用`ApplyIf`方法来设置所有标记图形的新颜色：
- en: '[PRE58]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If the `actionMode` method is `Add`, we just display a color dialog to set
    the next color:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`actionMode`方法设置为`添加`，我们只需显示一个颜色对话框来设置下一个颜色：
- en: '[PRE59]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `IsFigureMarkedAndFilled` method is a callback function that is called
    by the `AnyOf` method on the `figurePtrList` list in the `FillCheck` method. The
    **Fill** menu item is checked with a radio mark if at least one figure is marked
    and filled:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsFigureMarkedAndFilled`方法是一个回调函数，它在`FillCheck`方法中由`figurePtrList`列表上的`AnyOf`方法调用。如果至少有一个图形被标记并填充，则**填充**菜单项会通过单选标记进行检查：'
- en: '[PRE60]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `IsFigureMarkedAndFillable` method is a callback function that is called
    by the `AnyOf` method on the `figurePtrList` list in the `FillEnable` method.
    The **Fill** menu item is enabled if at least one fillable figure (rectangle or
    ellipse) is marked, or if the user is about to add a rectangle or ellipse:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsFigureMarkedAndFillable`方法是一个回调函数，它在`FillEnable`方法中由`figurePtrList`列表上的`AnyOf`方法调用。如果至少有一个可填充的图形（矩形或椭圆）被标记，或者如果用户即将添加矩形或椭圆，则**填充**菜单项将被启用：'
- en: '[PRE61]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In order to test whether the figure type of the next figure to be added is
    fillable, we create and delete such a figure:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试下一个要添加的图形类型是否可填充，我们创建并删除这样的图形：
- en: '[PRE62]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `InverseFill` method is a callback function that is called by the `AnyOf`
    method on the `figurePtrList` list in the `OnFill` method, which is called when
    the user selects the **Fill** menu item. The `OnFill` method inverts the fill
    status of all marked figures in `Modify` mode. In `Add` mode, it just inverts
    the value of `nextFill`, indicating that the next figure to be added will have
    the inverted fill status:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`InverseFill` 方法是一个回调函数，它在用户选择 **填充** 菜单项时，由 `figurePtrList` 列表中的 `OnFill`
    方法调用，该方法在 `Modify` 模式下反转所有标记图形的填充状态。在 `Add` 模式下，它仅反转 `nextFill` 的值，表示下一个要添加的图形将具有反转的填充状态：'
- en: '[PRE63]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The Add menu
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加菜单
- en: 'The listeners for the items of the `Add` menu are rather straightforward. The
    enable methods are simple, for the menu item to be enabled it is enough if the
    `applicationMode` method is in the `Idle` mode:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`Add` 菜单项的监听器相当直接。启用方法很简单，要使菜单项启用，只需 `applicationMode` 方法处于 `Idle` 模式即可：'
- en: '[PRE64]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The radio methods return `true` in `Add` mode if the figure to be added matches
    the figure of the radio method:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Add` 模式下，单选方法返回 `true` 如果要添加的图形与单选方法的图形匹配：
- en: '[PRE65]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Finally, the methods responding to the menu item and accelerator selections
    sets the `actionMode` to `Add` and the figure to be added:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，响应菜单项和快捷键选择的方法将 `actionMode` 设置为 `Add` 并设置要添加的图形：
- en: '[PRE66]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The cursor
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 光标
- en: 'The `Set` method in the `Cursor` class sets the cursor to an appropriate value.
    If the application mode is `Idle` mode, we wait for the user to press the mouse
    button. In that case, we use the well-known arrow cursor image. If the user is
    in the process of enclosing figures with a rectangle, we use the cross-hair. If
    the user is in the process of moving several figures, we use the cursor with four
    arrows (size all). Finally, if they are in the process of modifying a single figure,
    the figure (whose address is located in the `figurePtrList[0]` list) itself is
    deciding which cursor to use:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cursor` 类中的 `Set` 方法将光标设置为适当的值。如果应用程序模式是 `Idle` 模式，我们等待用户按下鼠标按钮。在这种情况下，我们使用众所周知的箭头光标图像。如果用户正在用矩形包围图形，我们使用十字准线。如果用户正在移动多个图形，我们使用带有四个箭头的光标（大小全部）。最后，如果他们正在修改单个图形，则该图形（其地址位于
    `figurePtrList[0]` 列表中）本身决定使用哪个光标：'
- en: '[PRE67]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you started the development of a drawing program capable of
    drawing lines, arrows, rectangles, and ellipses. In [Chapter 5](ch05.html "Chapter 5. The
    Figure Hierarchy"), *The Figure Hierarchy*, we will look into the figure hierarchy.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始开发一个能够绘制线条、箭头、矩形和椭圆的绘图程序。在[第5章](ch05.html "第5章。图形层次结构")，*图形层次结构*中，我们将探讨图形层次结构。
