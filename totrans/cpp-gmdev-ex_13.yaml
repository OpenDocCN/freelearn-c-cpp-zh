- en: Getting Started with Vulkan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous three chapters, we did our rendering using OpenGL. Although
    OpenGL is good for developing prototypes and getting your rendering going faster,
    it does have its weaknesses. For one, OpenGL is very driver-dependent, which makes
    it slower and less predictable when it comes to performance, which is why we prefer
    Vulkan for rendering.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: About Vulkan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Visual Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vulkan validation layers and extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vulkan instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Vulkan Context class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the window surface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Picking a physical device and creating a logical device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: About Vulkan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With OpenGL, developers have to depend on vendors such as NVIDIA, AMD, and Intel
    to release appropriate drivers so that they can increase the performance of their
    games before they are released. This is only possible if the developer is working
    closely with the vendor. If not, the vendor will only be able to release optimized
    drivers after the release of the game, and it could take a couple of days to release
    the new drivers.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, if you want to port your PC game to a mobile platform and you are
    using OpenGL as your renderer, you will need to port the renderer to OpenGLES,
    which is a subset of OpenGL, where the ES stands for Embedded Systems. Although
    there are a lot of similarities between OpenGL and OpenGLES, there is still additional
    work to be done to get it to work on other platforms. To alleviate these issues,
    Vulkan was introduced. Vulkan gives the developer more control by reducing driver
    impact and providing explicit developer control to make the game perform better.
  prefs: []
  type: TYPE_NORMAL
- en: Vulkan has been developed from the ground up and therefore is not backward compatible
    with OpenGL. When using Vulkan, you have complete access to the GPU.
  prefs: []
  type: TYPE_NORMAL
- en: With complete GPU access, you also have complete responsibility for implementing
    the rendering API. Consequently, the downside of using Vulkan is that you have
    to specify everything when you're developing with it.
  prefs: []
  type: TYPE_NORMAL
- en: All in all, this makes Vulkan a very verbose API where you have to specify everything.
    However, this also makes it easy to create extensions of the API specifications
    for Vulkan when GPUs add newer features.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Vulkan is just a rendering API, so we need to create a window and do math.
    For both, we will use GLFW and GLM, like we did when we created an OpenGL project.
    To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Visual Studio C++ project and call it `VulkanProject`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `GLFW` and `GLM` folders from the OpenGL project and place them inside
    the `VulkanProject` folder, under a folder named `Dependencies`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Download the Vulkan SDK. Go to [https://vulkan.lunarg.com/sdk/home](https://vulkan.lunarg.com/sdk/home)
    and download the Windows version of the SDK, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b4e84ef1-92b7-4289-99da-003f9c0499aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Install the SDK, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e0b1f20e-59ef-462b-9a8f-c16a4e217576.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the `Dependencies` directory, create a new folder called `Vulkan`. Copy
    and paste the `Lib` and include the folder from the Vulkan SDK folder in `C:\
    drive`, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/734566c4-d064-467a-abfd-0afc5c4c1435.png)'
  prefs: []
  type: TYPE_IMG
- en: In the Visual Studio project, create a new blank `source.cpp` file. Open up
    the Vulkan Project properties and add the `include` directory to C/C+ | General
    | Additional Include Directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure that All Configurations and All Platforms are selected in the Configuration
    and Platform drop-down lists, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/405981b3-65ce-41a2-9cf2-d8a11977c6f4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the Library Directories under the Linker | General section, as shown in
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4a23c330-5cbd-4ec9-bb32-379484c85e9b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In Linker | Input, set the libraries that you want to use, as shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3de238cf-8de9-4f3b-a2d6-b4b1d761aff5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With this prep work out of the way, let''s check whether our window creation
    works properly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `source.cpp`, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: First, we include `glfw3.h` and ask `GLFW` to include some Vulkan-related headers.
    Then, in the main function, we initialize `GLFW` by calling `glfwInit()`. Then,
    we call the `glfwWindowHint` functions. The first `glfwWindowHint` function doesn't
    create the OpenGL context since it is created by `Glfw` by default. In the next
    function, we disable resizing for the window we are about to create.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we create the 1,280 x 720 window in a similar way to when we created the
    window in the OpenGL project. We create a `while` loop that checks whether the
    window should be closed. If the window doesn't need to be closed, we will poll
    the system events. Once this is done, we will destroy the window, terminate `glfw`,
    and return `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This should give us a window to work with. Run the application in debug mode
    as an x64 executable to see the window being displayed and saying HELLO VULKAN,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f8b4a3d5-0065-4d80-91a3-990828b2e507.png)'
  prefs: []
  type: TYPE_IMG
- en: Vulkan validation layers and extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we jump into creating the Vulkan application, we have to check for application
    validation layers and extensions. Let''s go over these in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Validation layers**: Since so much control is given to developers, it is
    also possible for the developers to implement the Vulkan applications in an incorrect
    manner. The Vulkan validation layers check for such errors and tell the developer
    that they are doing something wrong and need to fix it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extensions**: Over the course of the development of the Vulkan API, new features
    may be introduced to newer GPUs. To keep Vulkan up to date, we need to extend
    its functionality by adding extensions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One example of this is the introduction of Ray Tracing in the RTX series of
    GPUs. In Vulkan, a new extension was created to support this change in the hardware
    by NVIDIA, that is, `Vk_NV_ray_tracing`. If our game uses this extension, we can
    check whether the hardware supports it.
  prefs: []
  type: TYPE_NORMAL
- en: Similar extensions can be added and checked at the application level as well.
    One such extension is the Debug report extension, which we can generate if something
    goes wrong when we're implementing Vulkan. Our first class will add this functionality
    to the application to check for application validation layers and extensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start creating our first class. Create a new class called `AppValidationLayersAndExtensions`.
    In `AppValidationLayersAndExtensions.h`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We include `vulkan.h`, `iostream`, `vector`, and `glfw`. Then, we create a
    vector called `requiredValidationLayers`; this is where we pass `VK_LAYER_LUNARG
    _standard_validation`. For our application, we will need the standard validation
    layer, which has all the validation layers in it. If we only need specific validation
    layers, then we can specify them individually as well. Next, we create two functions:
    one for checking the support for validation layers and one for getting the required
    extensions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate a report in case an error occurs, we need a debug callback. We
    will add two functions to it: one to set up the debug callback and one to destroy
    it. These functions will call the `debug`, `create`, and `destroy` functions;
    they will call `vkGetInstanceProcAddr` to get the pointers for the `vkCreateDebugReportCallbackEXT`
    and `vkDestroyDebugReportCallbackEXT` pointer functions so that we can call them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be better if it were less confusing to generate a debug report, but
    unfortunately, this is how it must be done. However, we only have to do this once.
    Let''s move on to implementing `AppValidationLayersAndExtentions.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we add the constructor and destructor, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To check the supported validation layers, call the `vkEnumerateInstanceLayerProperties`
    function twice. We call it the first time to get the number of validation layers
    that are available. Once we have the count, we call it again to populate it with
    the names of the layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create an `int` called `layerCount` and pass it in the first time we call
    `vkEnumerateInstanceLayerProperties`. The function takes two parameters: the first
    is the count and the second is initially kept `null`. Once the function is called,
    we will know how many validation layers are available. For the names of the layers,
    we create a new vector called `availableLayers` of the `VkLayerProperties` type
    and initialize it with `layerCount`. Then, the function is called again, and this
    time we pass in `layerCount` and the vector as parameters to store the information.
    After, we make a check between the required layers and the available layers. If
    the validation layer was found, the function will return `true`. If not, it will
    return `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to add the `getRequiredInstanceExtentions` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `getRequiredInstanceExtensions` phrase will get all the extensions that
    are supported by `GLFW`. It takes a Boolean to check whether the validation layers
    are enabled and returns a vector with the names of the supported extensions. In
    this function, we create a `unint32_t` called `glfwExtensionCount` and a `const`
    char for storing the names of the extensions. We call `glfwGetRequiredExtentions`,
    pass in `glfwExtentionCount`, and set it so that it's equal to `glfwExtensions`.
    This will store all the required extensions in `glfwExtensions`.
  prefs: []
  type: TYPE_NORMAL
- en: We create a new extensions vector and store the `glfwExtention` names. If we
    have enabled the validation layer, then we can add an additional extension layer
    called `VK_EXT_debug_report`, which is the extension for generating a debug report.
    This extension vector is returned at the end of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we add the debug report callback function, which will generate a report
    message whenever there is an error, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to create the `setupDebugCallback` function, which will call
    the `createDebugReportCallbackExt` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This function takes a Boolean, which will check that the validation layer is
    enabled. It also takes a Vulkan instance, which we will create after this class.
  prefs: []
  type: TYPE_NORMAL
- en: When creating a Vulkan object, we usually have to populate a struct with the
    required parameters. So, to create `DebugReportCallback`, we have to populate
    the `VkDebugReportCallbackCreateInfoExt` struct first. In the struct, we pass
    in `sType`, which specifies the structure type. We also pass in any flags for
    error and warning reporting. Finally, we pass in the `callback` function itself.
    Then, we call the `createDebugReportCallbackExt` function and pass in the instance,
    the struct, a null pointer for memory allocation, and the `callback` function. 
    Even though we pass in a null pointer for memory allocation, Vulkan will take
    care of memory allocation by itself. This function is available if you have a
    memory allocation function of your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create the `destroy` function so that we can destroy the debug
    report `callback` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Vulkan instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use the `AppValidationLayerAndExtension` class, we have to create a Vulkan
    instance. To do so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create another class called `VulkanInstance`. In `VulkanInstance.h`,
    add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We're including `vulkan.h` and `AppValidationLayersAndExtentions.h` since we
    will need the required validation layers and extensions when we create the Vulkan
    instance. We add the constructor, destructor, and instance of `VkInstance`, as
    well as a function called `ceeateAppAndVkInstance`. This function takes a Boolean
    that checks whether the validation layers are enabled, as well as `AppValidationLayersAndExtensions`.
    That's it for the header.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `.cpp` file, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the `createAppAndVkInstance` function, which will allow us to create
    the Vulkan instance, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding function, we have to populate `VkApplicationInfostruct`, which
    will be required when we create `VkInstance`. Then, we create the `appInfo` struct.
    Here, the first parameter we specify is the `struct` type, which is of the `VK_STRUCTURE_TYPE_APPLICATION_INFO`
    type. The next parameter is the application name itself and is where we specify
    the application version, which is 1.0\. Then, we specify the engine name and version.
    Finally, we specify the Vulkan API version to use.
  prefs: []
  type: TYPE_NORMAL
- en: Once the application `struct` has been populated, we can create the `vkInstanceCreateInfo`
    struct, which will create the Vulkan instance. In the struct instance we created
    – just like all the structs before this – we have to specify the struct with the
    `struct` type, which is `VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have to pass in the application info struct. We have to specify the
    Vulkan extension and validation layers and counts. This information is retrieved
    from the `AppValidationLayersAndExtensions` class. The validation layers are only
    enabled if the class is in debug mode; otherwise, it is not enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can create the Vulkan instance by calling the `vkCreateInstance` function.
    This takes three parameters: the create info instance, an allocator, and the instance
    variable that''s used to store the Vulkan instance. For allocation, we specify
    `nullptr` and let Vulkan take care of memory allocation. If the Vulkan instance
    wasn''t created, a runtime error will be printed to the console to say that the
    function failed to create the Vulkan instance.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to use this `ValidationAndExtensions` class and the Vulkan instance
    class, we will create a new Singleton class called `VulkanContext`. We're doing
    this because we'll need access to some of the Vulkan objects in this class when
    we create our `ObjectRenderer`.
  prefs: []
  type: TYPE_NORMAL
- en: The Vulkan Context class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Vulkan Context class will include all the functionality we need so that
    we can create our Vulkan renderer. In this class, we will create the validation
    layer, create the Vulkan application and instance, select the GPU we want to use,
    create the swapchain, create render targets, create the render pass, and add the
    command buffers so that we can send our draw commands to the GPU.
  prefs: []
  type: TYPE_NORMAL
- en: We will also add two new functions: `drawBegin` and `drawEnd`. In the `drawBegin`
    function, we will add the functionality for the preparation stages of drawing.
    The `drawEnd` function will be called after we have drawn an object and prepared
    it so that it can be presented to the viewport.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `.h` class and `.cpp` file. In the `.h` file, include the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create a Boolean called `isValidationLayersEnabled`. This will
    be set to `true` if the application is running in debug mode and `false` if it''s
    running in release mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create the class itself, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `public` section, we create a static instance and the `getInstance`
    variable and function, which sets and gets the instance of this class. We add
    the destructor and add an `initVulkan` function, which will be used to initialize
    the Vulkan context. In the `private` section, we create an instance of the `AppValidationLayersAndExtentions`
    and `VulkanInstance` classes. In the `VulkanContext.cpp` file, we set the instance
    variable to `null`, and, in the `getInstance` function, we check whether the instance
    was created. If it was not created, we create a new instance, return it, and add
    the destructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add the functionality for the `initVulkan` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: First, we create a new `AppValidationLayersAndExtensions` instance. Then, we
    check whether the validation layers are enabled and check whether the validation
    layers are supported. If `ValidationLayers` is not available, a runtime error
    is sent out, saying that the validation layers are not available.
  prefs: []
  type: TYPE_NORMAL
- en: If the validation layers are supported, a new instance of the `VulkanInstance`
    class is created and the `createAppAndVkInstance` function is called, which creates
    a new `vkInstance`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this is complete, we call the `setupDebugCallBack` function by passing
    in the Boolean and `vkInstance`. In the `source.cpp` file, include the `VulkanContext.h`
    file and call `initVulkan` after the window is created, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Hopefully, you won''t get any errors in the console window when you build and
    run the application. If you do get errors, go through each line of code and make
    sure there are no spelling mistakes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a01dea9-20d8-4215-824d-c92cbb68c200.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating the window surface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need an interface for the window we created for the current platform so that
    we can present the images we will render. We use the `VKSurfaceKHR` property to
    get access to the window surface. To store the surface information that the OS
    supports, we will call the `glfw` function, `glfwCreateWindowSurface`, to create
    the surface that's supported by the OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `VulkanContext.h`, add a new variable of the `VkSurfaceKHR` type called
    `surface`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we need access to the window instance we created in `source.cpp`, change
    the `initVulkan` function so that it accepts a `GLFWwindow`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In `VulkanContext.cpp`, change the `initVulkan` implementation as follows and
    call the `glfwCreateWindowSurface` function, which takes in the Vulkan instance
    and the window. Next, pass in `null` for the allocator and the surface to create
    the surface object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in `source.cpp`, change the `initVulkan` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Picking a physical device and creating a logical device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will create the `Device` class, which will be used to go through the
    different physical devices we have. We will choose one to render our application.
    To check whether your GPU is compatible with Vulkan, check the compatibility list
    on your GPU vendor's site or go to [https://en.wikipedia.org/wiki/Vulkan_(API)](https://en.wikipedia.org/wiki/Vulkan_(API)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, any NVIDIA GPU from the Geforce 600 series and AMD GPU from the
    Radeon HD 2000 series and later should be supported. To access the physical device
    and create a logical device, we will create a new class that will allow us to
    access it whenever we want. Create a new class called `Device`. In `Device.h`,
    add the following includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We will also add a couple of structs for the sake of convenience. The first
    is called `SwapChainSupportDetails`; it has access to `VkSurfaceCapabilitiesKHR`,
    which contains all the required details about the surface. We'll also add the `surfaceFormats` vector
    of the `VkSurfaceFormatKHR` type, which keeps track of all the different image
    formats the surface supports, and the `presentModes` vector of the `VkPresentModeKHR` type,
    which stores the presentation modes that the GPU supports.
  prefs: []
  type: TYPE_NORMAL
- en: Rendered images will be sent to the window surface and displayed. This is how
    we are able to see the final rendered image using a renderer, such as OpenGL or
    Vulkan. Now, we can show these images to the window one at a time, which is fine
    if we want to look at a still image forever. However, when we run a game that
    is updated every 16 milliseconds (60 times in a second), there may be cases where
    the image has not been fully rendered, but it would be time to display it. At
    this point, we will see half-rendered images, which leads to screen tearing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid this, we use double buffering. This allows us to render the image
    so that it has two different images, known as the front buffer and the back buffer,
    and ping-pong between them. Then, we present the buffer that has finished rendering
    and display it to the viewport while the next frame is still being rendered, as
    shown in the following diagram. There are different ways to present the image
    as well. We will look at these different presentation modes when we create the
    swapchain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee9c08d1-1be2-4404-8aca-76b1e698d73a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to create a struct to track the surface properties, format, and presentation
    modes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: A GPU also has what is called `QueueFamilies`. Commands are sent to the GPU
    and then executed using queues. There are separate queues for different kinds
    of work. Render commands are sent to render queues, compute commands are sent
    to compute queues, and there are also presentation queues for presenting images.
    We also need to know which queues the GPU supports and how many of the queues
    are present.
  prefs: []
  type: TYPE_NORMAL
- en: The renderer, compute, and presentation queues can be combined and are known
    as queue families. These queues can be combined in different ways to form a number
    of queue families. This means that there can be a combination of render and presentation
    queues that forms one queue family, while another family may just contain compute
    queues. Therefore, we have to check whether we have at least one queue family
    with graphics and presentation queues. This is because we need a graphics queue
    to pass our rendering commands into and a presentation queue to present the image
    after we render it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add one more struct to check for both, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will create the `Device` class itself. After creating the class, we
    add the constructor and destructor, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to add some variables so that we can store the physical device,
    the `SwapChainSupportDetails`, and the `QueueFamilyIndices`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To create double buffering, we have to check that the device supports it. This
    is done using the `VK_KHR_SWAPCHAIN_EXTENSION_NAME` extension, which checks for
    a swapchain. First, we create a vector of the `char*` const and pass in the extension
    name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add the `pickPhysicalDevice` function, which will be selected depending
    on whether the device is suitable. While checking for suitability, we will check
    whether the selected device supports the swapchain extension, get the swapchain
    support details, and get the queue family indices, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also add a getter function to get the queue families of the current
    device, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the physical device we want to use, we will create an instance
    of the logical device. The logical device is an interface for the physical device
    itself. We will use the logical device to create buffers and so on. We will also
    store the current device graphics and present a queue so that we can send the
    graphics and presentation commands. Finally, we will add a `destroy` function,
    which is used to destroy the physical and logical devices we created, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all for the `Device.h` file. Let''s move on to `Device.cpp`. First,
    we include `Device.h` and add the constructor and the destructor, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the real work begins. We need to create the `pickPhysicalDevice` function,
    which takes a Vulkan instance and the `VkSurface`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are creating an `int32` to store the count of the number of physical
    devices. We get the number of available GPUs using `vkEnumeratePhysicalDevices`
    and pass the Vulkan instance, the count, and `null` for the third parameter. This
    will retrieve the number of available devices. If `deviceCount` is zero, this
    means that there are no GPUs available. Then, we print the available number of
    devices to the console.
  prefs: []
  type: TYPE_NORMAL
- en: To get the physical devices themselves, we create a vector called `devices`,
    which will store the `VkPhysicalDevice` data type; this will store the devices
    for us. We will call the `vkEnumeratePhysicalDevices` function again, but this
    time – apart from passing in the Vulkan instance and the device count – we will
    also store the device information in the vector that we passed in as the third
    parameter. Then, we will print out the number of devices with the `DEVICE PROPERTIES` heading.
  prefs: []
  type: TYPE_NORMAL
- en: To get the properties of the available devices, we will go through the number
    of devices and get their properties using `vkGetPhysicalDeviceProperties` before
    storing them in the variable of the `VkPhysicalDeviceProperties` type.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to print out the name of the device and call `DeviceSuitable` on
    the device. If the device is suitable, we will store it as a `physicalDevice`
    and break out of the loop. Note that we set the first available device as the
    device we will be using.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there is no suitable device, we throw a runtime error to say that a suitable
    device wasn''t found. Let''s take a look at the `DeviceSuitable` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this function, we get the queue family indices by calling `findQueueFamilies`.
    Then, we check whether `VK_KHR_SWAPCHAIN_EXTENSION_NAMEextension` is supported.
    After this, we check for swapchain support on the device. If the surface formats
    and presentation modes are not empty, `swapChainAdequateboolean` is set to `true`.
    Finally, we get the physical device features by calling `vkGetPhysicalDeviceFeatures`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we return `true` if the queue families are present, the swapchain extension
    is supported, the swapchain is adequate, and the device supports anisotropic filtering.
    Anisotropic filtering is a mode that makes the pixels in the distance clearer.
  prefs: []
  type: TYPE_NORMAL
- en: Anisotropic filtering is a mode that, when enabled, helps sharpen textures that
    are viewed from extreme angles.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the image on the right has anisotropic filtering
    enabled and the image on the left has it disabled. In the image on the right,
    the white dashed line is still relatively visible further down the road. However,
    in the image on the left, the dashed line becomes blurry and pixelated. Therefore,
    anisotropic filtering is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b63e98b4-c702-4646-82ba-fd69536d5b56.png)'
  prefs: []
  type: TYPE_IMG
- en: (Taken from [https://i.imgur.com/jzCq5sT.jpg](https://i.imgur.com/jzCq5sT.jpg))
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the three functions we called in the previous function. First,
    let''s check out the `findQueueFamilies` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: To get the queue family properties, we call the `vkGetPhysicalDeviceQueueFamilyProperties`
    function; then, in the physical device, we pass an `int`, which we use to store
    the number of queue families, and the `null` pointer. This will give us the number
    of queue families that are available.
  prefs: []
  type: TYPE_NORMAL
- en: Next, for the properties themselves, we create a vector of the `VkQueueFamilyProperties` type,
    called `queueFamilies`, to store the necessary information. Then, we call `vkGetPhysicalDeviceFamilyProperties`
    and pass in the physical device, the count, and `queueFamilies` itself to populate
    it with the required data. We create an `int`, `i`, and initialize it to `0`.
    This will store the index of the graphics and presentation indices.
  prefs: []
  type: TYPE_NORMAL
- en: In the `for` loop, we check whether each of the queue families supports a graphics
    queue by looking for `VK_QUEUE_GRAPHICS_BIT`. If they do, we set the graphics
    family index.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we check for presentation support by passing in the index. This will check
    whether the same family supports presentation as well. If it supports presentation,
    we set `presentFamily` to that index.
  prefs: []
  type: TYPE_NORMAL
- en: If the queue family supports graphics and presentation, the graphics and presentation
    index will be the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the number of queue families by device and the
    number of queues in each queue family:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1fb0547-fff6-4569-aaa7-9d19500f67cc.png)'
  prefs: []
  type: TYPE_IMG
- en: There are three queue families on my GPU. The first queue family at the 0^(th)
    index has 16 queues, the second queue family at the 1^(st) index has one queue,
    and the third queue family at the 2^(nd) index has eight queues.
  prefs: []
  type: TYPE_NORMAL
- en: The `queueFlags` specify the queues in the queue family. The queues that are
    supported could be for graphics, compute, transfer, or sparse binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, we check that both the graphics and presentation indices were found,
    and then we break out of the loop. Finally, we return `queueFamilyIndices`. I
    am running the project on an Intel Iris Plus Graphics 650\. This integrated intel
    GPU has one queue family that supports graphics and the presentation queue. Different
    GPUs have different queue families and each family may support more than one queue
    type. Next, let''s look at the device extension that is supported. We can check
    this by using the `checkDeviceExtensionSupported` function, which takes in a physical
    device, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We get the number of extensions that are supported by the device by calling
    `vkEnumerateDeviceExtensionProperties` and passing in the physical device, the
    null pointer, an `int` to store the count in it, and `null`. The actual properties
    are stored inside the `availableExtensions` vector, which stores the `VkExtensionProperties` data
    type. By calling `vkEnumerateDeviceExtensionProperties` again, we get the device's
    extension properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'We populate the `requiredExtensions` vector with the extension we require.
    Then, we check the available extension vector with the required extensions. If
    the required extension is found, we remove it from the vector. This means that
    the device supports the extension and returns the value from the function, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7f60c53-6246-4e52-a334-8763320c8bcd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The device I am running has 73 available extensions, as shown in the following
    code. You can set a breakpoint and take a look at the device extension properties
    to view the supported extension of the device. The third function we will look
    at is the `querySwapChainSupport` function, which populates the surface capabilities,
    surface formats, and presentation modes that are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: To get the surface capabilities, we call `vkGetPhysicalDeviceSurfaceCapabilitiesKHR`
    and pass in the device, that is, `surface`, to get the surface capabilities. To
    get the surface format and presentation modes, we call `vkGetPhysicalDeviceSurfaceFormatKHR`
    and `vkGetPhysicalDeviceSurfacePresentModeKHR` twice.
  prefs: []
  type: TYPE_NORMAL
- en: The first time we call the `vkGetPhysicalDeviceSurfacePresentModeKHR` function,
    we get the number of formats and modes that are present; we call it a second time
    to get the formats and the modes that have been populated and stored in the vectors
    of the struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the capabilities of my device surface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5c9f1c3-30f8-4dea-8b8f-cc6facc73daf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, the minimum image count is two, meaning that we can add double buffering.
    These are the surface formats and the color space that my device supports:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8887e334-8668-4c48-9e42-8831c766f2b0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here are the presentation modes that are supported by my device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76276022-dd84-42d6-a807-7110aa899c6e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, it seems that my device only supports the immediate mode. We will see the
    use of this in the ahead chapters. After getting the physical device properties,
    we set the getter function for the `queueFamiliyIndices`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can create the logical device by using the `createLogicalDevice` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the logical device, we have to populate the `VkDeviceCreateInfo`
    struct, which requires the `queueCreateInfo` struct. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a vector so that we can store `VkDeviceQueueCreateInfo` and any necessary
    information for the graphics and presentation queues.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another vector of the `int` type so that we can store the indices of
    the graphics and presentation queues.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For each queue family, populate `VkDeviceQueueCreateInfo`. Create a local struct
    and pass in the struct type, the queue family index, the queue count, and priority
    (which is `1`), and then push it into the `queueCreateInfos` vector, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the device, specify the device features that we will be using. For
    the device features, we will create a variable of the `VkPhysicalDeviceFeatures`
    type and set `samplerAnisotropy` to `true`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Create the `VkDeviceCreateInfo` struct, which we need in order to create the
    logical device. Set the type to `VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO` and then
    set `queueCreateInfos`, the count, and the device features that are to be enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the device extension count and names. If the validation layer is enabled,
    we set the validation layer''s count and names. Create the `logicalDevice` by
    calling `vkCreateDevice` and passing in the physical device, the create device
    information, and `null` for the allocator. Then, create the logical device, as
    shown in the following code. If this fails, then we throw a runtime error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the device graphics and presentation queue, as shown in the following code.
    We are now done with the `Device` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This wraps up the `Device` class. Include the `Device.h` file in `VulkanContext.h`
    and add a new device object of the `Device` type to the `VulkanContext` class''s
    private section, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `VulkanContext.cpp` file in the `VulkanInit` function, add the following
    code after creating the surface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a new instance of the `device` class and we choose a device from
    the available physical devices. You will then be able to create the logical device.
    Run the application to see which device the application will run on. On my desktop,
    the following device count and name were found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ba1c7ca6-5f59-48e6-81fb-e3ab6cc5abf2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On my laptop, the application found one device with the following device name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2c89d883-db8b-4d79-97d1-43caacc381a8.png)'
  prefs: []
  type: TYPE_IMG
- en: Set breakpoints inside `findQueueFamilies`, `checkDeviceExtensionSupport`, and
    `querySwapChainSupport` to check for the number of queue family device extensions
    and for swapchain support for your GPUs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are about a quarter of the way through the process of seeing something being
    rendered to the viewport. In this chapter, we set the validation layers and the
    extension that we will need in order to set up Vulkan rendering. We created a
    Vulkan application and instance and then created a device class so that we can
    select the physical device. We also created the logical device so that we can
    interact with the GPU.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will create the swapchain itself so that we can swap
    between buffers, and we will create the render and the depth texture to draw the
    scene. We will create a render pass to set how the render textures are to be used
    and then create the draw command buffers, which will execute our draw commands.
  prefs: []
  type: TYPE_NORMAL
