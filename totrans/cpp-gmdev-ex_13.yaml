- en: Getting Started with Vulkan
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous three chapters, we did our rendering using OpenGL. Although
    OpenGL is good for developing prototypes and getting your rendering going faster,
    it does have its weaknesses. For one, OpenGL is very driver-dependent, which makes
    it slower and less predictable when it comes to performance, which is why we prefer
    Vulkan for rendering.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: About Vulkan
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Visual Studio
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vulkan validation layers and extensions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vulkan instances
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Vulkan Context class
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the window surface
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Picking a physical device and creating a logical device
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: About Vulkan
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With OpenGL, developers have to depend on vendors such as NVIDIA, AMD, and Intel
    to release appropriate drivers so that they can increase the performance of their
    games before they are released. This is only possible if the developer is working
    closely with the vendor. If not, the vendor will only be able to release optimized
    drivers after the release of the game, and it could take a couple of days to release
    the new drivers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, if you want to port your PC game to a mobile platform and you are
    using OpenGL as your renderer, you will need to port the renderer to OpenGLES,
    which is a subset of OpenGL, where the ES stands for Embedded Systems. Although
    there are a lot of similarities between OpenGL and OpenGLES, there is still additional
    work to be done to get it to work on other platforms. To alleviate these issues,
    Vulkan was introduced. Vulkan gives the developer more control by reducing driver
    impact and providing explicit developer control to make the game perform better.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Vulkan has been developed from the ground up and therefore is not backward compatible
    with OpenGL. When using Vulkan, you have complete access to the GPU.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: With complete GPU access, you also have complete responsibility for implementing
    the rendering API. Consequently, the downside of using Vulkan is that you have
    to specify everything when you're developing with it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: All in all, this makes Vulkan a very verbose API where you have to specify everything.
    However, this also makes it easy to create extensions of the API specifications
    for Vulkan when GPUs add newer features.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Visual Studio
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Vulkan is just a rendering API, so we need to create a window and do math.
    For both, we will use GLFW and GLM, like we did when we created an OpenGL project.
    To do this, follow these steps:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Visual Studio C++ project and call it `VulkanProject`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `GLFW` and `GLM` folders from the OpenGL project and place them inside
    the `VulkanProject` folder, under a folder named `Dependencies`.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Download the Vulkan SDK. Go to [https://vulkan.lunarg.com/sdk/home](https://vulkan.lunarg.com/sdk/home)
    and download the Windows version of the SDK, as shown in the following screenshot:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b4e84ef1-92b7-4289-99da-003f9c0499aa.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
- en: 'Install the SDK, as shown in the following screenshot:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e0b1f20e-59ef-462b-9a8f-c16a4e217576.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: 'In the `Dependencies` directory, create a new folder called `Vulkan`. Copy
    and paste the `Lib` and include the folder from the Vulkan SDK folder in `C:\
    drive`, as shown in the following screenshot:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/734566c4-d064-467a-abfd-0afc5c4c1435.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: In the Visual Studio project, create a new blank `source.cpp` file. Open up
    the Vulkan Project properties and add the `include` directory to C/C+ | General
    | Additional Include Directory.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure that All Configurations and All Platforms are selected in the Configuration
    and Platform drop-down lists, as shown in the following screenshot:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/405981b3-65ce-41a2-9cf2-d8a11977c6f4.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: 'Add the Library Directories under the Linker | General section, as shown in
    the following screenshot:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4a23c330-5cbd-4ec9-bb32-379484c85e9b.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: 'In Linker | Input, set the libraries that you want to use, as shown in the
    following screenshot:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3de238cf-8de9-4f3b-a2d6-b4b1d761aff5.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: 'With this prep work out of the way, let''s check whether our window creation
    works properly:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'In `source.cpp`, add the following code:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: First, we include `glfw3.h` and ask `GLFW` to include some Vulkan-related headers.
    Then, in the main function, we initialize `GLFW` by calling `glfwInit()`. Then,
    we call the `glfwWindowHint` functions. The first `glfwWindowHint` function doesn't
    create the OpenGL context since it is created by `Glfw` by default. In the next
    function, we disable resizing for the window we are about to create.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Then, we create the 1,280 x 720 window in a similar way to when we created the
    window in the OpenGL project. We create a `while` loop that checks whether the
    window should be closed. If the window doesn't need to be closed, we will poll
    the system events. Once this is done, we will destroy the window, terminate `glfw`,
    and return `0`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'This should give us a window to work with. Run the application in debug mode
    as an x64 executable to see the window being displayed and saying HELLO VULKAN,
    as shown in the following screenshot:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f8b4a3d5-0065-4d80-91a3-990828b2e507.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: Vulkan validation layers and extensions
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we jump into creating the Vulkan application, we have to check for application
    validation layers and extensions. Let''s go over these in more detail:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '**Validation layers**: Since so much control is given to developers, it is
    also possible for the developers to implement the Vulkan applications in an incorrect
    manner. The Vulkan validation layers check for such errors and tell the developer
    that they are doing something wrong and need to fix it.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extensions**: Over the course of the development of the Vulkan API, new features
    may be introduced to newer GPUs. To keep Vulkan up to date, we need to extend
    its functionality by adding extensions.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One example of this is the introduction of Ray Tracing in the RTX series of
    GPUs. In Vulkan, a new extension was created to support this change in the hardware
    by NVIDIA, that is, `Vk_NV_ray_tracing`. If our game uses this extension, we can
    check whether the hardware supports it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这类的一个例子是在RTX系列GPU中引入光线追踪。在Vulkan中，创建了一个新的扩展来支持NVIDIA在硬件上的这一变化，即`Vk_NV_ray_tracing`。如果我们的游戏使用这个扩展，我们可以检查硬件是否支持它。
- en: Similar extensions can be added and checked at the application level as well.
    One such extension is the Debug report extension, which we can generate if something
    goes wrong when we're implementing Vulkan. Our first class will add this functionality
    to the application to check for application validation layers and extensions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的扩展也可以在应用程序级别添加和检查。其中一个这样的扩展是调试报告扩展，当我们在实现Vulkan时出现问题时，我们可以生成这个扩展。我们的第一个类将向应用程序添加此功能，以检查应用程序验证层和扩展。
- en: 'Let''s start creating our first class. Create a new class called `AppValidationLayersAndExtensions`.
    In `AppValidationLayersAndExtensions.h`, add the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建我们的第一个类。创建一个名为`AppValidationLayersAndExtensions`的新类。在`AppValidationLayersAndExtensions.h`中，添加以下代码：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We include `vulkan.h`, `iostream`, `vector`, and `glfw`. Then, we create a
    vector called `requiredValidationLayers`; this is where we pass `VK_LAYER_LUNARG
    _standard_validation`. For our application, we will need the standard validation
    layer, which has all the validation layers in it. If we only need specific validation
    layers, then we can specify them individually as well. Next, we create two functions:
    one for checking the support for validation layers and one for getting the required
    extensions.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含`vulkan.h`、`iostream`、`vector`和`glfw`。然后，我们创建一个名为`requiredValidationLayers`的向量；这是我们将`VK_LAYER_LUNARG_standard_validation`传递的地方。对于我们的应用程序，我们需要标准验证层，其中包含所有验证层。如果我们只需要特定的验证层，我们也可以单独指定它们。接下来，我们创建两个函数：一个用于检查验证层的支持，另一个用于获取所需的扩展。
- en: 'To generate a report in case an error occurs, we need a debug callback. We
    will add two functions to it: one to set up the debug callback and one to destroy
    it. These functions will call the `debug`, `create`, and `destroy` functions;
    they will call `vkGetInstanceProcAddr` to get the pointers for the `vkCreateDebugReportCallbackEXT`
    and `vkDestroyDebugReportCallbackEXT` pointer functions so that we can call them.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在发生错误时生成报告，我们需要一个调试回调。我们将向其中添加两个函数：一个用于设置调试回调，另一个用于销毁它。这些函数将调用`debug`、`create`和`destroy`函数；它们将调用`vkGetInstanceProcAddr`以获取`vkCreateDebugReportCallbackEXT`和`vkDestroyDebugReportCallbackEXT`指针函数的指针，以便我们可以调用它们。
- en: 'It would be better if it were less confusing to generate a debug report, but
    unfortunately, this is how it must be done. However, we only have to do this once.
    Let''s move on to implementing `AppValidationLayersAndExtentions.cpp`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果生成调试报告不那么令人困惑会更好，但不幸的是，这就是必须这样做的方式。然而，我们只需要做一次。让我们继续实施`AppValidationLayersAndExtentions.cpp`：
- en: 'First, we add the constructor and destructor, as follows:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们添加构造函数和析构函数，如下所示：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To check the supported validation layers, call the `vkEnumerateInstanceLayerProperties`
    function twice. We call it the first time to get the number of validation layers
    that are available. Once we have the count, we call it again to populate it with
    the names of the layers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查支持的验证层，调用`vkEnumerateInstanceLayerProperties`函数两次。我们第一次调用它以获取可用的验证层数量。一旦我们有了计数，我们再次调用它以填充层的名称。
- en: 'We create an `int` called `layerCount` and pass it in the first time we call
    `vkEnumerateInstanceLayerProperties`. The function takes two parameters: the first
    is the count and the second is initially kept `null`. Once the function is called,
    we will know how many validation layers are available. For the names of the layers,
    we create a new vector called `availableLayers` of the `VkLayerProperties` type
    and initialize it with `layerCount`. Then, the function is called again, and this
    time we pass in `layerCount` and the vector as parameters to store the information.
    After, we make a check between the required layers and the available layers. If
    the validation layer was found, the function will return `true`. If not, it will
    return `false`.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to add the `getRequiredInstanceExtentions` function, as follows:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `getRequiredInstanceExtensions` phrase will get all the extensions that
    are supported by `GLFW`. It takes a Boolean to check whether the validation layers
    are enabled and returns a vector with the names of the supported extensions. In
    this function, we create a `unint32_t` called `glfwExtensionCount` and a `const`
    char for storing the names of the extensions. We call `glfwGetRequiredExtentions`,
    pass in `glfwExtentionCount`, and set it so that it's equal to `glfwExtensions`.
    This will store all the required extensions in `glfwExtensions`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: We create a new extensions vector and store the `glfwExtention` names. If we
    have enabled the validation layer, then we can add an additional extension layer
    called `VK_EXT_debug_report`, which is the extension for generating a debug report.
    This extension vector is returned at the end of the function.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we add the debug report callback function, which will generate a report
    message whenever there is an error, as follows:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we need to create the `setupDebugCallback` function, which will call
    the `createDebugReportCallbackExt` function, as follows:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This function takes a Boolean, which will check that the validation layer is
    enabled. It also takes a Vulkan instance, which we will create after this class.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: When creating a Vulkan object, we usually have to populate a struct with the
    required parameters. So, to create `DebugReportCallback`, we have to populate
    the `VkDebugReportCallbackCreateInfoExt` struct first. In the struct, we pass
    in `sType`, which specifies the structure type. We also pass in any flags for
    error and warning reporting. Finally, we pass in the `callback` function itself.
    Then, we call the `createDebugReportCallbackExt` function and pass in the instance,
    the struct, a null pointer for memory allocation, and the `callback` function. 
    Even though we pass in a null pointer for memory allocation, Vulkan will take
    care of memory allocation by itself. This function is available if you have a
    memory allocation function of your own.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create the `destroy` function so that we can destroy the debug
    report `callback` function, as follows:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Vulkan instances
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use the `AppValidationLayerAndExtension` class, we have to create a Vulkan
    instance. To do so, follow these steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `AppValidationLayerAndExtension` 类，我们必须创建一个 Vulkan 实例。为此，请按照以下步骤操作：
- en: 'We will create another class called `VulkanInstance`. In `VulkanInstance.h`,
    add the following code:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建另一个名为 `VulkanInstance` 的类。在 `VulkanInstance.h` 中，添加以下代码：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We're including `vulkan.h` and `AppValidationLayersAndExtentions.h` since we
    will need the required validation layers and extensions when we create the Vulkan
    instance. We add the constructor, destructor, and instance of `VkInstance`, as
    well as a function called `ceeateAppAndVkInstance`. This function takes a Boolean
    that checks whether the validation layers are enabled, as well as `AppValidationLayersAndExtensions`.
    That's it for the header.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含 `vulkan.h` 和 `AppValidationLayersAndExtentions.h`，因为我们创建 Vulkan 实例时将需要所需的验证层和扩展。我们添加了构造函数、析构函数以及
    `VkInstance` 的实例，以及一个名为 `ceeateAppAndVkInstance` 的函数。这个函数接受一个布尔值，用于检查验证层是否启用，以及
    `AppValidationLayersAndExtensions`。这就是头文件的内容。
- en: 'In the `.cpp` file, add the following code:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `.cpp` 文件中，添加以下代码：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then add the `createAppAndVkInstance` function, which will allow us to create
    the Vulkan instance, as follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加 `createAppAndVkInstance` 函数，这将允许我们创建 Vulkan 实例，如下所示：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding function, we have to populate `VkApplicationInfostruct`, which
    will be required when we create `VkInstance`. Then, we create the `appInfo` struct.
    Here, the first parameter we specify is the `struct` type, which is of the `VK_STRUCTURE_TYPE_APPLICATION_INFO`
    type. The next parameter is the application name itself and is where we specify
    the application version, which is 1.0\. Then, we specify the engine name and version.
    Finally, we specify the Vulkan API version to use.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，我们必须填充 `VkApplicationInfostruct`，这在创建 `VkInstance` 时是必需的。然后，我们创建 `appInfo`
    结构体。在这里，我们指定的第一个参数是 `struct` 类型，它是 `VK_STRUCTURE_TYPE_APPLICATION_INFO` 类型。下一个参数是应用程序名称本身，我们在这里指定应用程序版本，版本号为
    1.0。然后，我们指定引擎名称和版本。最后，我们指定要使用的 Vulkan API 版本。
- en: Once the application `struct` has been populated, we can create the `vkInstanceCreateInfo`
    struct, which will create the Vulkan instance. In the struct instance we created
    – just like all the structs before this – we have to specify the struct with the
    `struct` type, which is `VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序 `struct` 已被填充，我们可以创建 `vkInstanceCreateInfo` 结构体，这将创建 Vulkan 实例。在我们创建的结构体实例中——就像之前的所有结构体一样——我们必须指定具有
    `struct` 类型的结构体，它是 `VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO`。
- en: Then, we have to pass in the application info struct. We have to specify the
    Vulkan extension and validation layers and counts. This information is retrieved
    from the `AppValidationLayersAndExtensions` class. The validation layers are only
    enabled if the class is in debug mode; otherwise, it is not enabled.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须传递应用程序信息结构体。我们必须指定 Vulkan 扩展和验证层以及计数。这些信息是从 `AppValidationLayersAndExtensions`
    类中检索的。验证层仅在类处于调试模式时启用；否则，它不会被启用。
- en: 'Now, we can create the Vulkan instance by calling the `vkCreateInstance` function.
    This takes three parameters: the create info instance, an allocator, and the instance
    variable that''s used to store the Vulkan instance. For allocation, we specify
    `nullptr` and let Vulkan take care of memory allocation. If the Vulkan instance
    wasn''t created, a runtime error will be printed to the console to say that the
    function failed to create the Vulkan instance.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过调用 `vkCreateInstance` 函数来创建 Vulkan 实例。这个函数有三个参数：创建信息实例、分配器和用于存储 Vulkan
    实例的实例变量。对于分配，我们指定 `nullptr` 并让 Vulkan 处理内存分配。如果 Vulkan 实例没有创建，将在控制台打印运行时错误，表示函数未能创建
    Vulkan 实例。
- en: In order to use this `ValidationAndExtensions` class and the Vulkan instance
    class, we will create a new Singleton class called `VulkanContext`. We're doing
    this because we'll need access to some of the Vulkan objects in this class when
    we create our `ObjectRenderer`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用这个 `ValidationAndExtensions` 类和 Vulkan 实例类，我们将创建一个新的 Singleton 类，名为 `VulkanContext`。我们这样做是因为在创建我们的
    `ObjectRenderer` 时，我们需要访问这个类中的一些 Vulkan 对象。
- en: The Vulkan Context class
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vulkan 上下文类
- en: The Vulkan Context class will include all the functionality we need so that
    we can create our Vulkan renderer. In this class, we will create the validation
    layer, create the Vulkan application and instance, select the GPU we want to use,
    create the swapchain, create render targets, create the render pass, and add the
    command buffers so that we can send our draw commands to the GPU.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: We will also add two new functions: `drawBegin` and `drawEnd`. In the `drawBegin`
    function, we will add the functionality for the preparation stages of drawing.
    The `drawEnd` function will be called after we have drawn an object and prepared
    it so that it can be presented to the viewport.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `.h` class and `.cpp` file. In the `.h` file, include the following
    code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we will create a Boolean called `isValidationLayersEnabled`. This will
    be set to `true` if the application is running in debug mode and `false` if it''s
    running in release mode:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we create the class itself, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the `public` section, we create a static instance and the `getInstance`
    variable and function, which sets and gets the instance of this class. We add
    the destructor and add an `initVulkan` function, which will be used to initialize
    the Vulkan context. In the `private` section, we create an instance of the `AppValidationLayersAndExtentions`
    and `VulkanInstance` classes. In the `VulkanContext.cpp` file, we set the instance
    variable to `null`, and, in the `getInstance` function, we check whether the instance
    was created. If it was not created, we create a new instance, return it, and add
    the destructor:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we add the functionality for the `initVulkan` function, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, we create a new `AppValidationLayersAndExtensions` instance. Then, we
    check whether the validation layers are enabled and check whether the validation
    layers are supported. If `ValidationLayers` is not available, a runtime error
    is sent out, saying that the validation layers are not available.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: If the validation layers are supported, a new instance of the `VulkanInstance`
    class is created and the `createAppAndVkInstance` function is called, which creates
    a new `vkInstance`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this is complete, we call the `setupDebugCallBack` function by passing
    in the Boolean and `vkInstance`. In the `source.cpp` file, include the `VulkanContext.h`
    file and call `initVulkan` after the window is created, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Hopefully, you won''t get any errors in the console window when you build and
    run the application. If you do get errors, go through each line of code and make
    sure there are no spelling mistakes:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a01dea9-20d8-4215-824d-c92cbb68c200.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: Creating the window surface
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need an interface for the window we created for the current platform so that
    we can present the images we will render. We use the `VKSurfaceKHR` property to
    get access to the window surface. To store the surface information that the OS
    supports, we will call the `glfw` function, `glfwCreateWindowSurface`, to create
    the surface that's supported by the OS.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'In `VulkanContext.h`, add a new variable of the `VkSurfaceKHR` type called
    `surface`, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Since we need access to the window instance we created in `source.cpp`, change
    the `initVulkan` function so that it accepts a `GLFWwindow`, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In `VulkanContext.cpp`, change the `initVulkan` implementation as follows and
    call the `glfwCreateWindowSurface` function, which takes in the Vulkan instance
    and the window. Next, pass in `null` for the allocator and the surface to create
    the surface object:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, in `source.cpp`, change the `initVulkan` function, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Picking a physical device and creating a logical device
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will create the `Device` class, which will be used to go through the
    different physical devices we have. We will choose one to render our application.
    To check whether your GPU is compatible with Vulkan, check the compatibility list
    on your GPU vendor's site or go to [https://en.wikipedia.org/wiki/Vulkan_(API)](https://en.wikipedia.org/wiki/Vulkan_(API)).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, any NVIDIA GPU from the Geforce 600 series and AMD GPU from the
    Radeon HD 2000 series and later should be supported. To access the physical device
    and create a logical device, we will create a new class that will allow us to
    access it whenever we want. Create a new class called `Device`. In `Device.h`,
    add the following includes:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We will also add a couple of structs for the sake of convenience. The first
    is called `SwapChainSupportDetails`; it has access to `VkSurfaceCapabilitiesKHR`,
    which contains all the required details about the surface. We'll also add the `surfaceFormats` vector
    of the `VkSurfaceFormatKHR` type, which keeps track of all the different image
    formats the surface supports, and the `presentModes` vector of the `VkPresentModeKHR` type,
    which stores the presentation modes that the GPU supports.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Rendered images will be sent to the window surface and displayed. This is how
    we are able to see the final rendered image using a renderer, such as OpenGL or
    Vulkan. Now, we can show these images to the window one at a time, which is fine
    if we want to look at a still image forever. However, when we run a game that
    is updated every 16 milliseconds (60 times in a second), there may be cases where
    the image has not been fully rendered, but it would be time to display it. At
    this point, we will see half-rendered images, which leads to screen tearing.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid this, we use double buffering. This allows us to render the image
    so that it has two different images, known as the front buffer and the back buffer,
    and ping-pong between them. Then, we present the buffer that has finished rendering
    and display it to the viewport while the next frame is still being rendered, as
    shown in the following diagram. There are different ways to present the image
    as well. We will look at these different presentation modes when we create the
    swapchain:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，我们使用双缓冲。这允许我们渲染图像，使其具有两个不同的图像，称为前缓冲区和后缓冲区，并在它们之间进行ping-pong。然后，我们展示已经完成渲染的缓冲区，并在下一个帧仍在渲染时将其显示到视口中，如下面的图所示。还有不同的方式来展示图像。当我们创建swapchain时，我们将查看这些不同的呈现模式：
- en: '![](img/ee9c08d1-1be2-4404-8aca-76b1e698d73a.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ee9c08d1-1be2-4404-8aca-76b1e698d73a.png)'
- en: 'We need to create a struct to track the surface properties, format, and presentation
    modes, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个结构体来跟踪表面属性、格式和呈现模式，如下所示：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A GPU also has what is called `QueueFamilies`. Commands are sent to the GPU
    and then executed using queues. There are separate queues for different kinds
    of work. Render commands are sent to render queues, compute commands are sent
    to compute queues, and there are also presentation queues for presenting images.
    We also need to know which queues the GPU supports and how many of the queues
    are present.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: GPU也有被称为`QueueFamilies`的东西。命令被发送到GPU，然后使用队列执行。有针对不同类型工作的单独队列。渲染命令被发送到渲染队列，计算命令被发送到计算队列，还有用于展示图像的呈现队列。我们还需要知道GPU支持哪些队列以及有多少队列存在。
- en: The renderer, compute, and presentation queues can be combined and are known
    as queue families. These queues can be combined in different ways to form a number
    of queue families. This means that there can be a combination of render and presentation
    queues that forms one queue family, while another family may just contain compute
    queues. Therefore, we have to check whether we have at least one queue family
    with graphics and presentation queues. This is because we need a graphics queue
    to pass our rendering commands into and a presentation queue to present the image
    after we render it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染器、计算和呈现队列可以组合，并被称为队列家族。这些队列可以以不同的方式组合，形成多个队列家族。这意味着可以组合渲染和呈现队列形成一个队列家族，而另一个家族可能只包含计算队列。因此，我们必须检查我们是否至少有一个包含图形和呈现队列的队列家族。这是因为我们需要一个图形队列来传递我们的渲染命令，以及一个呈现队列在渲染后展示图像。
- en: 'We will add one more struct to check for both, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个结构体来检查这两个方面，如下所示：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we will create the `Device` class itself. After creating the class, we
    add the constructor and destructor, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建`Device`类本身。在创建类之后，我们添加构造函数和析构函数，如下所示：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we need to add some variables so that we can store the physical device,
    the `SwapChainSupportDetails`, and the `QueueFamilyIndices`, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要添加一些变量，以便我们可以存储物理设备、`SwapChainSupportDetails`和`QueueFamilyIndices`，如下所示：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To create double buffering, we have to check that the device supports it. This
    is done using the `VK_KHR_SWAPCHAIN_EXTENSION_NAME` extension, which checks for
    a swapchain. First, we create a vector of the `char*` const and pass in the extension
    name, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建双缓冲，我们必须检查设备是否支持它。这是通过使用`VK_KHR_SWAPCHAIN_EXTENSION_NAME`扩展来完成的，该扩展检查swapchain。首先，我们创建一个`char*`常量向量，并传入扩展名称，如下所示：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, we add the `pickPhysicalDevice` function, which will be selected depending
    on whether the device is suitable. While checking for suitability, we will check
    whether the selected device supports the swapchain extension, get the swapchain
    support details, and get the queue family indices, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加了`pickPhysicalDevice`函数，该函数将根据设备是否合适来选择。在检查合适性的过程中，我们将检查所选设备是否支持swapchain扩展，获取swapchain支持详情，以及获取队列家族索引，如下所示：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We will also add a getter function to get the queue families of the current
    device, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加一个获取器函数来获取当前设备的队列家族，如下所示：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once we have the physical device we want to use, we will create an instance
    of the logical device. The logical device is an interface for the physical device
    itself. We will use the logical device to create buffers and so on. We will also
    store the current device graphics and present a queue so that we can send the
    graphics and presentation commands. Finally, we will add a `destroy` function,
    which is used to destroy the physical and logical devices we created, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'That''s all for the `Device.h` file. Let''s move on to `Device.cpp`. First,
    we include `Device.h` and add the constructor and the destructor, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, the real work begins. We need to create the `pickPhysicalDevice` function,
    which takes a Vulkan instance and the `VkSurface`, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we are creating an `int32` to store the count of the number of physical
    devices. We get the number of available GPUs using `vkEnumeratePhysicalDevices`
    and pass the Vulkan instance, the count, and `null` for the third parameter. This
    will retrieve the number of available devices. If `deviceCount` is zero, this
    means that there are no GPUs available. Then, we print the available number of
    devices to the console.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: To get the physical devices themselves, we create a vector called `devices`,
    which will store the `VkPhysicalDevice` data type; this will store the devices
    for us. We will call the `vkEnumeratePhysicalDevices` function again, but this
    time – apart from passing in the Vulkan instance and the device count – we will
    also store the device information in the vector that we passed in as the third
    parameter. Then, we will print out the number of devices with the `DEVICE PROPERTIES` heading.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: To get the properties of the available devices, we will go through the number
    of devices and get their properties using `vkGetPhysicalDeviceProperties` before
    storing them in the variable of the `VkPhysicalDeviceProperties` type.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to print out the name of the device and call `DeviceSuitable` on
    the device. If the device is suitable, we will store it as a `physicalDevice`
    and break out of the loop. Note that we set the first available device as the
    device we will be using.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'If there is no suitable device, we throw a runtime error to say that a suitable
    device wasn''t found. Let''s take a look at the `DeviceSuitable` function:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this function, we get the queue family indices by calling `findQueueFamilies`.
    Then, we check whether `VK_KHR_SWAPCHAIN_EXTENSION_NAMEextension` is supported.
    After this, we check for swapchain support on the device. If the surface formats
    and presentation modes are not empty, `swapChainAdequateboolean` is set to `true`.
    Finally, we get the physical device features by calling `vkGetPhysicalDeviceFeatures`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we return `true` if the queue families are present, the swapchain extension
    is supported, the swapchain is adequate, and the device supports anisotropic filtering.
    Anisotropic filtering is a mode that makes the pixels in the distance clearer.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Anisotropic filtering is a mode that, when enabled, helps sharpen textures that
    are viewed from extreme angles.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 各向异性过滤是一种模式，当启用时，有助于从极端角度查看的纹理变得更加清晰。
- en: 'In the following example, the image on the right has anisotropic filtering
    enabled and the image on the left has it disabled. In the image on the right,
    the white dashed line is still relatively visible further down the road. However,
    in the image on the left, the dashed line becomes blurry and pixelated. Therefore,
    anisotropic filtering is required:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，右侧的图像启用了各向异性过滤，而左侧的图像未启用。在右侧的图像中，白色虚线在道路下方仍然相对可见。然而，在左侧的图像中，虚线变得模糊且像素化。因此，需要各向异性过滤：
- en: '![](img/b63e98b4-c702-4646-82ba-fd69536d5b56.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b63e98b4-c702-4646-82ba-fd69536d5b56.png)'
- en: (Taken from [https://i.imgur.com/jzCq5sT.jpg](https://i.imgur.com/jzCq5sT.jpg))
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: （摘自[https://i.imgur.com/jzCq5sT.jpg](https://i.imgur.com/jzCq5sT.jpg))
- en: 'Let''s look at the three functions we called in the previous function. First,
    let''s check out the `findQueueFamilies` function:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在上一函数中调用的三个函数。首先，让我们看看`findQueueFamilies`函数：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: To get the queue family properties, we call the `vkGetPhysicalDeviceQueueFamilyProperties`
    function; then, in the physical device, we pass an `int`, which we use to store
    the number of queue families, and the `null` pointer. This will give us the number
    of queue families that are available.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取队列家族属性，我们调用`vkGetPhysicalDeviceQueueFamilyProperties`函数；然后，在物理设备中，我们传递一个`int`，我们用它来存储队列家族的数量，以及`null`指针。这将给我们提供可用的队列家族数量。
- en: Next, for the properties themselves, we create a vector of the `VkQueueFamilyProperties` type,
    called `queueFamilies`, to store the necessary information. Then, we call `vkGetPhysicalDeviceFamilyProperties`
    and pass in the physical device, the count, and `queueFamilies` itself to populate
    it with the required data. We create an `int`, `i`, and initialize it to `0`.
    This will store the index of the graphics and presentation indices.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对于属性本身，我们创建了一个`VkQueueFamilyProperties`类型的向量，称为`queueFamilies`，用于存储必要的信息。然后，我们调用`vkGetPhysicalDeviceFamilyProperties`并传递物理设备、计数和`queueFamilies`本身，以填充所需的数据。我们创建一个`int`，`i`，并将其初始化为`0`。这将存储图形和演示索引的索引。
- en: In the `for` loop, we check whether each of the queue families supports a graphics
    queue by looking for `VK_QUEUE_GRAPHICS_BIT`. If they do, we set the graphics
    family index.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环中，我们检查每个队列家族是否支持图形队列，通过查找`VK_QUEUE_GRAPHICS_BIT`。如果支持，我们设置图形家族索引。
- en: Then, we check for presentation support by passing in the index. This will check
    whether the same family supports presentation as well. If it supports presentation,
    we set `presentFamily` to that index.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过传递索引来检查演示支持。这将检查是否相同的家族也支持演示。如果它支持演示，我们将`presentFamily`设置为该索引。
- en: If the queue family supports graphics and presentation, the graphics and presentation
    index will be the same.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果队列家族支持图形和演示，图形和演示索引将是相同的。
- en: 'The following screenshot shows the number of queue families by device and the
    number of queues in each queue family:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了按设备划分的队列家族数量以及每个队列家族中的队列数量：
- en: '![](img/b1fb0547-fff6-4569-aaa7-9d19500f67cc.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b1fb0547-fff6-4569-aaa7-9d19500f67cc.png)'
- en: There are three queue families on my GPU. The first queue family at the 0^(th)
    index has 16 queues, the second queue family at the 1^(st) index has one queue,
    and the third queue family at the 2^(nd) index has eight queues.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我的GPU上有三个队列家族。第一个队列家族在0^(th)索引处有16个队列，第二个队列家族在1^(st)索引处有一个队列，第三个队列家族在2^(nd)索引处有八个队列。
- en: The `queueFlags` specify the queues in the queue family. The queues that are
    supported could be for graphics, compute, transfer, or sparse binding.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`queueFlags`指定队列家族中的队列。支持的队列可以是图形、计算、传输或稀疏绑定。'
- en: 'After this, we check that both the graphics and presentation indices were found,
    and then we break out of the loop. Finally, we return `queueFamilyIndices`. I
    am running the project on an Intel Iris Plus Graphics 650\. This integrated intel
    GPU has one queue family that supports graphics and the presentation queue. Different
    GPUs have different queue families and each family may support more than one queue
    type. Next, let''s look at the device extension that is supported. We can check
    this by using the `checkDeviceExtensionSupported` function, which takes in a physical
    device, as shown in the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We get the number of extensions that are supported by the device by calling
    `vkEnumerateDeviceExtensionProperties` and passing in the physical device, the
    null pointer, an `int` to store the count in it, and `null`. The actual properties
    are stored inside the `availableExtensions` vector, which stores the `VkExtensionProperties` data
    type. By calling `vkEnumerateDeviceExtensionProperties` again, we get the device's
    extension properties.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'We populate the `requiredExtensions` vector with the extension we require.
    Then, we check the available extension vector with the required extensions. If
    the required extension is found, we remove it from the vector. This means that
    the device supports the extension and returns the value from the function, as
    shown in the following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7f60c53-6246-4e52-a334-8763320c8bcd.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: 'The device I am running has 73 available extensions, as shown in the following
    code. You can set a breakpoint and take a look at the device extension properties
    to view the supported extension of the device. The third function we will look
    at is the `querySwapChainSupport` function, which populates the surface capabilities,
    surface formats, and presentation modes that are available:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: To get the surface capabilities, we call `vkGetPhysicalDeviceSurfaceCapabilitiesKHR`
    and pass in the device, that is, `surface`, to get the surface capabilities. To
    get the surface format and presentation modes, we call `vkGetPhysicalDeviceSurfaceFormatKHR`
    and `vkGetPhysicalDeviceSurfacePresentModeKHR` twice.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The first time we call the `vkGetPhysicalDeviceSurfacePresentModeKHR` function,
    we get the number of formats and modes that are present; we call it a second time
    to get the formats and the modes that have been populated and stored in the vectors
    of the struct.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the capabilities of my device surface:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5c9f1c3-30f8-4dea-8b8f-cc6facc73daf.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: 'So, the minimum image count is two, meaning that we can add double buffering.
    These are the surface formats and the color space that my device supports:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8887e334-8668-4c48-9e42-8831c766f2b0.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: 'Here are the presentation modes that are supported by my device:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76276022-dd84-42d6-a807-7110aa899c6e.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: 'So, it seems that my device only supports the immediate mode. We will see the
    use of this in the ahead chapters. After getting the physical device properties,
    we set the getter function for the `queueFamiliyIndices`, as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, we can create the logical device by using the `createLogicalDevice` function.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the logical device, we have to populate the `VkDeviceCreateInfo`
    struct, which requires the `queueCreateInfo` struct. Let''s get started:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Create a vector so that we can store `VkDeviceQueueCreateInfo` and any necessary
    information for the graphics and presentation queues.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another vector of the `int` type so that we can store the indices of
    the graphics and presentation queues.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For each queue family, populate `VkDeviceQueueCreateInfo`. Create a local struct
    and pass in the struct type, the queue family index, the queue count, and priority
    (which is `1`), and then push it into the `queueCreateInfos` vector, as shown
    in the following code:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To create the device, specify the device features that we will be using. For
    the device features, we will create a variable of the `VkPhysicalDeviceFeatures`
    type and set `samplerAnisotropy` to `true`, as follows:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Create the `VkDeviceCreateInfo` struct, which we need in order to create the
    logical device. Set the type to `VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO` and then
    set `queueCreateInfos`, the count, and the device features that are to be enabled.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the device extension count and names. If the validation layer is enabled,
    we set the validation layer''s count and names. Create the `logicalDevice` by
    calling `vkCreateDevice` and passing in the physical device, the create device
    information, and `null` for the allocator. Then, create the logical device, as
    shown in the following code. If this fails, then we throw a runtime error:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Get the device graphics and presentation queue, as shown in the following code.
    We are now done with the `Device` class:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This wraps up the `Device` class. Include the `Device.h` file in `VulkanContext.h`
    and add a new device object of the `Device` type to the `VulkanContext` class''s
    private section, as follows:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the `VulkanContext.cpp` file in the `VulkanInit` function, add the following
    code after creating the surface:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This will create a new instance of the `device` class and we choose a device from
    the available physical devices. You will then be able to create the logical device.
    Run the application to see which device the application will run on. On my desktop,
    the following device count and name were found:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ba1c7ca6-5f59-48e6-81fb-e3ab6cc5abf2.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
- en: 'On my laptop, the application found one device with the following device name:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2c89d883-db8b-4d79-97d1-43caacc381a8.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
- en: Set breakpoints inside `findQueueFamilies`, `checkDeviceExtensionSupport`, and
    `querySwapChainSupport` to check for the number of queue family device extensions
    and for swapchain support for your GPUs.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are about a quarter of the way through the process of seeing something being
    rendered to the viewport. In this chapter, we set the validation layers and the
    extension that we will need in order to set up Vulkan rendering. We created a
    Vulkan application and instance and then created a device class so that we can
    select the physical device. We also created the logical device so that we can
    interact with the GPU.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了大约四分之一的渲染到视口的过程。在这一章中，我们设置了验证层和我们需要设置的扩展，以便设置Vulkan渲染。我们创建了一个Vulkan应用程序和实例，然后创建了一个设备类，以便我们可以选择物理设备。我们还创建了一个逻辑设备，以便我们可以与GPU交互。
- en: In the next chapter, we will create the swapchain itself so that we can swap
    between buffers, and we will create the render and the depth texture to draw the
    scene. We will create a render pass to set how the render textures are to be used
    and then create the draw command buffers, which will execute our draw commands.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将创建swapchain本身，以便我们可以在缓冲区之间进行交换，并且我们将创建渲染和深度纹理来绘制场景。我们将创建一个渲染通道来设置渲染纹理的使用方式，然后创建绘制命令缓冲区，这些缓冲区将执行我们的绘制命令。
