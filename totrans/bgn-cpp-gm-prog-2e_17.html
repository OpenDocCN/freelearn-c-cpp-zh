<html><head></head><body>
		<div><h1 id="_idParaDest-317"><a id="_idTextAnchor327"/><em class="italic">Chapter 16</em>: Building Playable Levels and Collision Detection</h1>
			<p>This chapter will probably be one of the most satisfying chapters of this project. The reason for this is that, by the end of it, we will have a playable game. Although there will still be features to implement (sound, particle effects, the HUD, and shader effects), Bob and Thomas will be able to run, jump, and explore the world. Furthermore, you will be able to create your very own level designs of any size or complexity by simply making platforms and obstacles in a text file.</p>
			<p>We will achieve all this by covering the following topics: </p>
			<ul>
				<li>Exploring how to design levels in a text file</li>
				<li>Building a <code>LevelManager</code> class that will load levels from a text file, convert them into data that our game can use, and keep track of the level details such as spawn position, current level, and allowed time limit</li>
				<li>Updating the game engine to use <code>LevelManager</code></li>
				<li>Coding a polymorphic function to handle collision detection for both Bob and Thomas</li>
			</ul>
			<h1 id="_idParaDest-318"><a id="_idTextAnchor328"/>Designing some levels</h1>
			<p>Remember the sprite-sheet that we introduced in <a href="B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292"><em class="italic">Chapter 14</em></a>, <em class="italic">Abstraction and Code Management – Making Better Use of OOP</em>? Here it is again, annotated with numbers that represent each tile that we will build all our levels from:</p>
			<div><div><img src="img/B14278_16_01.jpg" alt=""/>
				</div>
			</div>
			<p>The image has been placed on a grey background so that we can see the different details of the sprite-sheet better. The chequered background represents the level of transparency. So, all the tiles except for number 1 will reveal at least a little of the background behind them. Let's go over them now:</p>
			<ul>
				<li>Tile 0 is completely transparent and will be used to fill in the gaps where there aren't any other tiles. </li>
				<li>Tile 1 is for the platforms that Thomas and Bob will walk on. </li>
				<li>Tile 2 is for fire tiles and 3 is for water tiles. </li>
				<li>In terms of tile 4, you might need to look quite closely to see it. It has a white square outline. This is the goal of the level and is where Thomas and Bob must get to together. </li>
			</ul>
			<p>Keep this image in mind as we discuss designing the levels.</p>
			<p>We will enter combinations of these tile numbers into text files to design the layouts. An example will help:</p>
			<pre>0000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000
1111111111000111111222222221111133111111111411
0000000000000000001222222221000133100000001110
0000000000000000001222222221000133100000000000
0000000000000000001222222221000133100000000000
0000000000000000001111111111000111100000000000</pre>
			<p>The previous code translates into the following level layout:</p>
			<div><div><img src="img/B14278_16_02.jpg" alt=""/>
				</div>
			</div>
			<p>Note that, to get the previous screenshot, I had to zoom out of the <code>View</code> and that the image has been cropped. The actual start of the level would look as follows:</p>
			<div><div><img src="img/B14278_16_03.jpg" alt=""/>
				</div>
			</div>
			<p>These screenshots demonstrate two things. First, you can see how you can quickly construct level designs using a simple and free text editor such as Windows Notepad or Notepad ++. Just make sure you use a monospace font so that all the numbers are the same size. This makes designing the levels much easier.</p>
			<p>Secondly, these screenshots demonstrate the gameplay aspects of the design. From left to right in the level, Thomas and Bob need to jump over a small hole or they will fall to their death (respawn). Then, they have a large expanse of fire to traverse. It is impossible for Bob to jump that many tiles. The players will need to work together to find the solution. The only way that Bob will clear the fire tiles is by standing on Thomas's head and jumping from there, as shown in the following screenshot:</p>
			<div><div><img src="img/B14278_16_04.jpg" alt=""/>
				</div>
			</div>
			<p>It is then quite simple to get to the goal and move on to the next level.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">I strongly encourage you to complete this chapter and then spend some time designing your own levels.</p>
			<p>I have included a few level designs to get us started. They are in the <code>levels</code> folder that we added to the project back in <a href="B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292"><em class="italic">Chapter 14</em></a>, <em class="italic">Abstraction and Code Management – Making Better Use of OOP</em>.</p>
			<p>There are some zoomed-out views of the game there, along with a screenshot of the code of the level design. The screenshot of the code is probably more useful than reproducing the textual content. If the code has to be checked, just open the files in the <code>levels</code> folder. </p>
			<p>This is what the code looks like:</p>
			<div><div><img src="img/B14278_16_05.jpg" alt=""/>
				</div>
			</div>
			<p>This is the level layout that the previous code will produce:</p>
			<div><div><img src="img/B14278_16_05b.jpg" alt=""/>
				</div>
			</div>
			<p>This level is the "leap of faith" level I referred to in <a href="B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292"><em class="italic">Chapter 14</em></a>, <em class="italic">Abstraction and Code Management – Making Better Use of OOP</em>:</p>
			<div><div><img src="img/B14278_16_06.jpg" alt=""/>
				</div>
			</div>
			<p>The code for the in-game platforms has been highlighted, as they are not very clear in the zoomed-out screenshot that follows:</p>
			<div><div><img src="img/B14278_16_06b.jpg" alt=""/>
				</div>
			</div>
			<p>The provided designs are simple. The game engine will be able to handle very large designs, but we have the freedom to use our imagination and build some long and challenging levels.</p>
			<p>Of course, these designs won't do anything until we learn how to load them and convert the text into a playable level. Additionally, it won't be possible to stand on any platforms until we have implemented the collision detection. </p>
			<p>First, let's handle loading the level designs.</p>
			<h1 id="_idParaDest-319"><a id="_idTextAnchor329"/>Building the LevelManager class</h1>
			<p>It will take several phases of coding to make our level designs work. </p>
			<p>The first thing we will do is code the <code>LevelManager</code> header file. This will allow us to look at and discuss the member variables and functions that will be in the <code>LevelManager</code> class.</p>
			<p>Next, we will code the <code>LevelManager.cpp</code> file, which will have all the function definitions in it. Since this is a long file, we will break it up into several sections to code and discuss them.</p>
			<p>Once the <code>LevelManager</code> class is complete, we will add an instance of it to the game engine (<code>Engine</code> class). We will also add a new function to the <code>Engine</code> class, <code>loadLevel</code>, which we can call from the <code>update</code> function whenever a new level is required. The <code>loadLevel</code> function will not only use the <code>LevelManager</code> instance to load the appropriate level – it will also take care of aspects such as spawning the player characters and preparing the clock.</p>
			<p>Now, let's get an overview of <code>LevelManager</code> by coding the <code>LevelManager.h</code> file.</p>
			<h2 id="_idParaDest-320"><a id="_idTextAnchor330"/>Coding LevelManager.h</h2>
			<p>Right-click <code>LevelManager.h</code>. Finally, click the <code>LevelManager</code> class.</p>
			<p>Add the following include directives and private variables and then we will discuss them:</p>
			<pre>#pragma once
#include &lt;SFML/Graphics.hpp&gt;
using namespace sf;
using namespace std;
class LevelManager
{
private:
    Vector2i m_LevelSize;
    Vector2f m_StartPosition;
    float m_TimeModifier = 1;
    float m_BaseTimeLimit = 0;
    int m_CurrentLevel = 0;
    const int NUM_LEVELS = 4;
// public declarations go here</pre>
			<p>The preceding code declares a <code>Vector2i</code>, <code>m_LevelSize</code> to hold two integer values that will hold the horizontal and vertical number of tiles that the current map contains. The <code>Vector2f</code>, <code>m_StartPosition</code> contains the coordinates in the world where Bob and Thomas should be spawned. Note that this is not a tile position relatable to <code>m_LevelSize</code> units but a horizontal and vertical pixel position in the level.</p>
			<p>The <code>m_TimeModifier</code> member variable is a float type variable that will be used to multiply the time that's available in the current level. The reason we want to do this is so that we can change (decrease) this value so that we can shorten the time that's available each time the player attempts the same level. As an example, if the player gets 60 seconds for the first time they attempt level 1, then 60 multiplied by 1 is, of course, 60. When the player completes all the levels and comes back to level 1 for the second time, <code>m_TimeModifier</code> will have been reduced by 10 percent. Then, when the time available is multiplied by 0.9, the amount of time that's available to the player will be 54 seconds. This is 10 percent less. The game will get steadily harder.</p>
			<p>The <code>m_BaseTimeLimit</code> float variable holds the original, unmodified time limit we have just discussed.</p>
			<p>We can probably guess that <code>m_CurrentLevel</code> will hold the current level number that is being played.</p>
			<p>The <code>int</code>, <code>NUM_LEVELS</code> constant will be used to flag when it is appropriate to go back to level 1 again and reduce the value of <code>m_TimeModifier</code>. </p>
			<p>Now, add the following public variables and function declarations after the previous code we added:</p>
			<pre>public:
    const int TILE_SIZE = 50;
    const int VERTS_IN_QUAD = 4;
    float getTimeLimit();
    Vector2f getStartPosition();
    int** nextLevel(VertexArray&amp; rVaLevel);
    Vector2i getLevelSize();
    int getCurrentLevel();
};</pre>
			<p>In the previous code, there are two constant <code>int</code> members. <code>TILE_SIZE</code> is a useful constant to remind us that each tile in the sprite-sheet is fifty pixels wide and fifty pixels high. <code>VERTS_IN_QUAD</code> is a useful constant to make our manipulation of a <code>VertexArray</code> less error-prone. There are, in fact, four vertices in a quad. Now, we can't forget this.</p>
			<p>The <code>getTimeLimit</code>, <code>getStartPosition</code>, <code>getLevelSize</code>, and <code>getCurrentLevel</code> functions are simple getter functions which return the current value of the private member variables we declared in the previous block of code.</p>
			<p>The function that deserves to be talked about more is <code>nextLevel</code>. This function receives a <code>VertexArray</code> reference, just like we used in the Zombie Arena game. The function can then work on the <code>VertexArray</code> reference and all the changes will be present in the <code>VertexArray</code> reference from the calling code. </p>
			<p>The <code>nextLevel</code> function returns a pointer to a pointer, which means we can return an address of the first element of a two-dimensional array of <code>int</code> values. We will be building a two-dimensional array of <code>int</code> values that will represent the layout of each level. Of course, these int values will be read from the level design text files. </p>
			<h2 id="_idParaDest-321"><a id="_idTextAnchor331"/>Coding the LevelManager.cpp file</h2>
			<p>Right-click <code>LevelManager.cpp</code>. Finally, click the <code>.cpp</code> file for the <code>LevelManager</code> class. </p>
			<p>As this is quite a long class, we will break it up to discuss it in six chunks. The first five will cover the <code>nextLevel</code> function, while the sixth will cover the rest of the functions.</p>
			<p>Add the following include directives and the first (of five) part of the <code>nextLevel</code> function:</p>
			<pre>#include &lt;SFML/Graphics.hpp&gt;
#include &lt;SFML/Audio.hpp&gt;
#include "TextureHolder.h"
#include &lt;sstream&gt;
#include &lt;fstream&gt;
#include "LevelManager.h"
using namespace sf;
using namespace std;
int** LevelManager::nextLevel(VertexArray&amp; rVaLevel)
{
    m_LevelSize.x = 0;
    m_LevelSize.y = 0;
    // Get the next level
    m_CurrentLevel++;
    if (m_CurrentLevel &gt; NUM_LEVELS)
    {
        m_CurrentLevel = 1;
        m_TimeModifier -= .1f;
    }
    // Load the appropriate level from a text file
    string levelToLoad;
    switch (m_CurrentLevel)
    {
    case 1:
        levelToLoad = "levels/level1.txt";
        m_StartPosition.x = 100;
        m_StartPosition.y = 100;
        m_BaseTimeLimit = 30.0f;
        break;
    case 2:
        levelToLoad = "levels/level2.txt";
        m_StartPosition.x = 100;
        m_StartPosition.y = 3600;
        m_BaseTimeLimit = 100.0f;
        break;
    case 3:
        levelToLoad = "levels/level3.txt";
        m_StartPosition.x = 1250;
        m_StartPosition.y = 0;
        m_BaseTimeLimit = 30.0f;
        break;
    case 4:
        levelToLoad = "levels/level4.txt";
        m_StartPosition.x = 50;
        m_StartPosition.y = 200;
        m_BaseTimeLimit = 50.0f;
        break;
    }// End switch</pre>
			<p>After the include directives, the code initializes the <code>m_LevelSize.x</code> and <code>m_LevelSize.y</code> variables to zero.</p>
			<p>Next, <code>m_CurrentLevel</code> is incremented. The <code>if</code> statement that follows checks whether <code>m_CurrentLevel</code> is greater than <code>NUM_LEVELS</code>. If it is, then <code>m_CurrentLevel</code> is set back to <code>1</code> and <code>m_TimeModifier</code> is reduced by <code>0.1</code> in order to shorten the allowed time for all levels.</p>
			<p>The code then switches based on the value held by <code>m_CurrentLevel</code>. Each <code>case</code> statement initializes the name of the text file that holds the level design, the starting position for Thomas and Bob, as well as <code>m_BaseTimeLimit</code>, which is the unmodified time limit for the level in question.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you design your own levels, add a <code>case</code> statement and the appropriate values for it here. Also, edit the <code>NUM_LEVELS</code> constant in the <code>LevelManager.h</code> file.</p>
			<p>Now, add the second part of the <code>nextLevel</code> function, as follows. Add this code immediately after the previous code. Study the code as we add it so we can discuss it:</p>
			<pre>    ifstream inputFile(levelToLoad);
    string s;
    // Count the number of rows in the file
    while (getline(inputFile, s))
    {
        ++m_LevelSize.y;
    }
    // Store the length of the rows
    m_LevelSize.x = s.length();</pre>
			<p>In the preceding (second part) code, we declare an <code>ifstream</code> object called <code>inputFile</code> which opens a stream to the file name contained in <code>levelToLoad</code>.</p>
			<p>The code loops through each line of the file using <code>getLine</code>, but doesn't record any of its content. All it does is count the number of lines by incrementing <code>m_LevelSize.y</code>. After the <code>for</code> loop, the width of the level is saved in <code>m_LevelSize.x</code> using the <code>s.length</code> function. This implies that the length of all the lines must be the same or we would run into trouble.</p>
			<p>At this point, we know and have saved the length and width of the current level in <code>m_LevelSize</code>.</p>
			<p>Now, add the third part of the <code>nextLevel</code> function, as shown in the following code. Add the code immediately underneath the previous code. Study the code as we add it so we can discuss it:</p>
			<pre>    // Go back to the start of the file
    inputFile.clear();
    inputFile.seekg(0, ios::beg);
    // Prepare the 2D array to hold the int values from the file
    int** arrayLevel = new int*[m_LevelSize.y];
    for (int i = 0; i &lt; m_LevelSize.y; ++i)
    {
        // Add a new array into each array element
        arrayLevel[i] = new int[m_LevelSize.x];
    }</pre>
			<p>First, we clear <code>inputFile</code> using its <code>clear</code> function. The <code>seekg</code> function, which is called with the <code>0, ios::beg</code> parameters, moves the file cursor's position (where characters will be read from next) to the beginning of the file.</p>
			<p>Next, we declare a pointer to a pointer called <code>arrayLevel</code>. Note that this is done on the free store/heap using the <code>new</code> keyword. Once we have initialized this two-dimensional array, we will be able to return its address to the calling code and it will persist until we either delete it or the game is closed.</p>
			<p>The <code>for</code> loop loops from 0 to <code>m_LevelSize.y -1</code>. In each pass of the loop, it adds a new array of <code>int</code> values, on the heap, to match the value of <code>m_LevelSize.x</code>. We now have a perfectly configured (for the current level) two-dimensional array. The only problem is that there is nothing in it yet.</p>
			<p>Now, add the fourth part of the <code>nextLevel</code> function, as shown in the following code. Add this code immediately after the previous code. Study the code as we add it so we can discuss it:</p>
			<pre>    // Loop through the file and store all 
   // the values in the 2d array
    string row;
    int y = 0;
    while (inputFile &gt;&gt; row)
    {
        for (int x = 0; x &lt; row.length(); x++) {
            const char val = row[x];
            arrayLevel[y][x] = atoi(&amp;val);
        }
        y++;
    }
    // Close the file
    inputFile.close();</pre>
			<p>First, the code initializes a <code>string</code> called <code>row</code> that will hold only one row of the level design at a time. We also declare and initialize an <code>int</code> called <code>y</code> that will help us count the rows.</p>
			<p>The <code>while</code> loop executes repeatedly until <code>inputFile</code> gets past the last row. Inside the <code>while</code> loop, there is a <code>for</code> loop which goes through each character of the current row and stores it in the two-dimensional array, <code>arrayLevel</code>. Notice that we access the right element of the two-dimensional array with <code>arrayLevel[y][x]=</code>. The <code>atoi</code> function converts the <code>char val</code> into an <code>int</code>. This is required because we have a two-dimensional array for <code>int</code>, and not for <code>char</code>.</p>
			<p>Now, let's add the fifth part of the <code>nextLevel</code> function, as shown here. Add this code immediately after the previous code. Study the code as we add it, so we can discuss it:</p>
			<pre>    // What type of primitive are we using?
    rVaLevel.setPrimitiveType(Quads);
    // Set the size of the vertex array
    rVaLevel.resize(m_LevelSize.x * 
      m_LevelSize.y * VERTS_IN_QUAD);
    // Start at the beginning of the vertex array
    int currentVertex = 0;
    for (int x = 0; x &lt; m_LevelSize.x; x++)
    {
        for (int y = 0; y &lt; m_LevelSize.y; y++)
        {
            // Position each vertex in the current quad
            rVaLevel[currentVertex + 0].position = 
                Vector2f(x * TILE_SIZE, 
                y * TILE_SIZE);
            rVaLevel[currentVertex + 1].position = 
                Vector2f((x * TILE_SIZE) + TILE_SIZE, 
                y * TILE_SIZE);
            rVaLevel[currentVertex + 2].position = 
                Vector2f((x * TILE_SIZE) + TILE_SIZE, 
                (y * TILE_SIZE) + TILE_SIZE);
            rVaLevel[currentVertex + 3].position = 
                Vector2f((x * TILE_SIZE), 
                (y * TILE_SIZE) + TILE_SIZE);
            // Which tile from the sprite sheet should we use
            int verticalOffset = arrayLevel[y][x] * TILE_SIZE;
            rVaLevel[currentVertex + 0].texCoords = 
                Vector2f(0, 0 + verticalOffset);
            rVaLevel[currentVertex + 1].texCoords = 
                Vector2f(TILE_SIZE, 0 + verticalOffset);
            rVaLevel[currentVertex + 2].texCoords = 
                Vector2f(TILE_SIZE, TILE_SIZE + verticalOffset);
            rVaLevel[currentVertex + 3].texCoords = 
                Vector2f(0, TILE_SIZE + verticalOffset);
            // Position ready for the next four vertices
            currentVertex = currentVertex + VERTS_IN_QUAD;
        }
    }
    return arrayLevel;
} // End of nextLevel function</pre>
			<p>Although this is the longest section of code from the five sections (we divided <code>nextLevel</code> in two), it is also the most straightforward. This is because we have seen very similar code in the Zombie Arena project.</p>
			<p>The process for the precedingcode is that the nested <code>for</code> loops loop from zero through to the width and height of the level. For each position in the array, four vertices are put into the <code>VertexArray</code> and four texture coordinates are assigned from the sprite-sheet. The positions of the vertices and texture coordinates are calculated using the <code>currentVertex</code> variable, <code>TILE SIZE</code>, and the <code>VERTS_IN_QUAD</code> constants. At the end of each loop of the inner <code>for</code> loop, <code>currentVertex</code> is increased by <code>VERTS_IN_QUAD</code>, moving nicely on to the next tile.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The important thing to remember about <code>VertexArray</code> is that it was passed in to <code>nextLevel</code> by reference. Therefore, <code>VertexArray</code> will be available in the calling code. We will call <code>nextLevel</code> from the code in the <code>Engine</code> class.</p>
			<p>Once this function has been called, the <code>Engine</code> class will have a <code>VertexArray</code> to represent the level graphically and a two-dimensional array of <code>int</code> values as a numerical representation of all the platforms and obstacles in the level.</p>
			<p>The rest of the <code>LevelManager</code> functions are all simple getter functions but do take the time to familiarize yourself with which private value is returned by which function. Add the remaining functions from the <code>LevelManager</code> class, as follows:</p>
			<pre>Vector2i LevelManager::getLevelSize()
{
    return m_LevelSize;
}
int LevelManager::getCurrentLevel()
{
    return m_CurrentLevel;
}
float LevelManager::getTimeLimit()
{
    return m_BaseTimeLimit * m_TimeModifier;
}
Vector2f LevelManager::getStartPosition()
{
    return m_StartPosition;
}</pre>
			<p>Now that the <code>LevelManager</code> class is complete, we can move on to using it. We will code another function in the <code>Engine</code> class to do so.</p>
			<h1 id="_idParaDest-322"><a id="_idTextAnchor332"/>Coding the loadLevel function</h1>
			<p>To be clear, this function is part of the <code>Engine</code> class, although it will delegate much of its work to other functions, including those of the <code>LevelManager</code> class that we just built.</p>
			<p>First, let's add the declaration for the new function, along with some other new pieces of code, to the <code>Engine.h</code> file. Open the <code>Engine.h</code> file and add the highlighted lines of code shown in the abbreviated snapshot of the <code>Engine.h</code> file, as follows:</p>
			<pre>#pragma once
#include &lt;SFML/Graphics.hpp&gt;
#include "TextureHolder.h"
#include "Thomas.h"
#include "Bob.h"
<strong class="bold">#include "LevelManager.h"</strong>
using namespace sf;
class Engine
{
private:
    // The texture holder
    TextureHolder th;
    // Thomas and his friend, Bob
    Thomas m_Thomas;
    Bob m_Bob;
<strong class="bold">    // A class to manage all the levels</strong>
<strong class="bold">    LevelManager m_LM;</strong>
    const int TILE_SIZE = 50;
    const int VERTS_IN_QUAD = 4;
    // The force pushing the characters down
    const int GRAVITY = 300;
    // A regular RenderWindow
    RenderWindow m_Window;
    // The main Views
    View m_MainView;
    View m_LeftView;
    View m_RightView;
    // Three views for the background
    View m_BGMainView;
    View m_BGLeftView;
    View m_BGRightView;
    View m_HudView;
    // Declare a sprite and a Texture for the background
    Sprite m_BackgroundSprite;
    Texture m_BackgroundTexture;
    // Is the game currently playing?
    bool m_Playing = false;
    // Is character 1 or 2 the current focus?
    bool m_Character1 = true;
    // Start in full screen mode
    bool m_SplitScreen = false;
    // How much time is left in the current level
    float m_TimeRemaining = 10;
    Time m_GameTimeTotal;
    // Is it time for a new/first level?
    bool m_NewLevelRequired = true;
<strong class="bold">    // The vertex array for the level tiles</strong>
<strong class="bold">    VertexArray m_VALevel;</strong>
<strong class="bold">    // The 2d array with the map for the level</strong>
<strong class="bold">    // A pointer to a pointer</strong>
<strong class="bold">    int** m_ArrayLevel = NULL;</strong>
<strong class="bold">    // Texture for the level tiles</strong>
<strong class="bold">    Texture m_TextureTiles;</strong>
    
    // Private functions for internal use only
    void input();
    void update(float dtAsSeconds);
    void draw();    
<strong class="bold">    // Load a new level</strong>
<strong class="bold">    void loadLevel();</strong>
    
public:
    // The Engine constructor
    Engine();
    ...
    ...        
    ...</pre>
			<p>This is what we can see in the previous code:</p>
			<ul>
				<li>We included the <code>LevelManager.h</code> file.</li>
				<li>We added an instance of <code>LevelManager</code> called <code>m_LM</code>.</li>
				<li>We added a <code>VertexArray</code> called <code>m_VALevel</code>.</li>
				<li>We added a pointer to a pointer to int that will hold the two-dimensional array that is returned from <code>nextLevel</code>.</li>
				<li>We added a new <code>Texture</code> object for the sprite-sheet.</li>
				<li>We added the declaration for the <code>loadLevel</code> function that we will write now.</li>
			</ul>
			<p>Right-click <code>LoadLevel.cpp</code>. Finally, click the <code>loadLevel</code> function.</p>
			<p>Add the code for the <code>loadLevel</code> function to the <code>LoadLevel.cpp</code> file. Then, we can discuss it:</p>
			<pre>#include "Engine.h"
void Engine::loadLevel()
{
    m_Playing = false;
    // Delete the previously allocated memory
    for (int i = 0; i &lt; m_LM.getLevelSize().y; ++i)
    {
        delete[] m_ArrayLevel[i];
    }
    delete[] m_ArrayLevel;
    // Load the next 2d array with the map for the level
    // And repopulate the vertex array as well
    m_ArrayLevel = m_LM.nextLevel(m_VALevel);
    // How long is this new time limit
    m_TimeRemaining = m_LM.getTimeLimit();
    // Spawn Thomas and Bob
    m_Thomas.spawn(m_LM.getStartPosition(), GRAVITY);
    m_Bob.spawn(m_LM.getStartPosition(), GRAVITY);
    // Make sure this code isn't run again
    m_NewLevelRequired = false;
}</pre>
			<p>First, we set <code>m_Playing</code> to false to stop parts of the <code>update</code> function from executing. Next, we loop through all the horizontal arrays within <code>m_ArrayLevel</code> and delete them. After the <code>for</code> loop, we delete <code>m_ArrayLevel</code> itself.</p>
			<p><code>m_ArrayLevel = m_LM.nextLevel(m_VALevel)</code> calls <code>nextLevel</code> and prepares the <code>VertexArray</code>  <code>m_VALevel</code>, as well as the two-dimensional array known as <code>m_ArrayLevel</code>. The level is set up and ready to go.</p>
			<p><code>m_TimeRemaining</code> is initialized by calling <code>getTimeLimit</code> and Thomas and Bob are spawned using the <code>spawn</code> function, along with the value returned from <code>getStartPosition</code>.</p>
			<p>Finally, <code>m_NewLevelRequired</code> is set to <code>false</code>. As we will see in a few pages time, <code>m_NewLevelRequired</code> being set to <code>true</code> causes <code>loadLevel</code> to be called. We only want to run this function once.</p>
			<h1 id="_idParaDest-323"><a id="_idTextAnchor333"/>Updating the engine</h1>
			<p>Open the <code>Engine.cpp</code> file and add the following highlighted code to load the sprite-sheet texture at the end of the Engine constructor:</p>
			<pre>Engine::Engine()
{
    // Get the screen resolution and create an SFML window and View
    Vector2f resolution;
    resolution.x = VideoMode::getDesktopMode().width;
    resolution.y = VideoMode::getDesktopMode().height;
    m_Window.create(VideoMode(resolution.x, resolution.y),
        "Thomas was late",
        Style::Fullscreen);
    // Initialize the full screen view
    m_MainView.setSize(resolution);
    m_HudView.reset(
        FloatRect(0, 0, resolution.x, resolution.y));
    // Initialize the split-screen Views
    m_LeftView.setViewport(
        FloatRect(0.001f, 0.001f, 0.498f, 0.998f));
    m_RightView.setViewport(
        FloatRect(0.5f, 0.001f, 0.499f, 0.998f));
    m_BGLeftView.setViewport(
        FloatRect(0.001f, 0.001f, 0.498f, 0.998f));
    m_BGRightView.setViewport(
        FloatRect(0.5f, 0.001f, 0.499f, 0.998f));
    // Can this graphics card use shaders?
    if (!sf::Shader::isAvailable())
    {
        // Time to get a new PC
        m_Window.close();
    }
    m_BackgroundTexture = TextureHolder::GetTexture(
        "graphics/background.png");
    // Associate the sprite with the texture
    m_BackgroundSprite.setTexture(m_BackgroundTexture);
<strong class="bold">    // Load the texture for the background vertex array</strong>
<strong class="bold">    m_TextureTiles = TextureHolder::GetTexture(</strong>
<strong class="bold">        "graphics/tiles_sheet.png");</strong>
}</pre>
			<p>All we do in the previous code is load the sprite-sheet into <code>m_TextureTiles</code>.</p>
			<p>Open the <code>Update.cpp</code> file and make the following highlighted changes and additions:</p>
			<pre>void Engine::update(float dtAsSeconds)
{
    if (m_NewLevelRequired)
    {
        // These calls to spawn will be moved to a new
        // loadLevel function soon
        // Spawn Thomas and Bob
<strong class="bold">        //m_Thomas.spawn(Vector2f(0,0), GRAVITY);</strong>
<strong class="bold">        //m_Bob.spawn(Vector2f(100, 0), GRAVITY);</strong>
        // Make sure spawn is called only once
<strong class="bold">        //m_TimeRemaining = 10;</strong>
<strong class="bold">        //m_NewLevelRequired = false;</strong>
<strong class="bold">        // Load a level</strong>
<strong class="bold">        loadLevel();</strong>
        
    }</pre>
			<p>Actually, we should delete, rather than comment out, the lines we are no longer using. I have just shown it in this way so that the changes are clear. All there should be in the previous <code>if</code> statement is the call to <code>loadLevel</code>.</p>
			<p>Finally, before we can see the results of the work we've done so far in this chapter, open the <code>Draw.cpp</code> file and make the following highlighted additions to draw the vertex array that represents a level:</p>
			<pre>void Engine::draw()
{
    // Rub out the last frame
    m_Window.clear(Color::White);
    if (!m_SplitScreen)
    {
        // Switch to background view
        m_Window.setView(m_BGMainView);
        // Draw the background
        m_Window.draw(m_BackgroundSprite);
        // Switch to m_MainView
        m_Window.setView(m_MainView);        
<strong class="bold">        // Draw the Level</strong>
<strong class="bold">        m_Window.draw(m_VALevel, &amp;m_TextureTiles);</strong>
        // Draw thomas
        m_Window.draw(m_Thomas.getSprite());
        // Draw bob
        m_Window.draw(m_Bob.getSprite());
    }
    else
    {
        // Split-screen view is active
        // First draw Thomas' side of the screen
        // Switch to background view
        m_Window.setView(m_BGLeftView);
        // Draw the background
        m_Window.draw(m_BackgroundSprite);
        // Switch to m_LeftView
        m_Window.setView(m_LeftView);
<strong class="bold">        // Draw the Level</strong>
<strong class="bold">        m_Window.draw(m_VALevel, &amp;m_TextureTiles);</strong>
            
        // Draw bob
        m_Window.draw(m_Bob.getSprite());
        // Draw thomas
        m_Window.draw(m_Thomas.getSprite());
        
        // Now draw Bob's side of the screen
        // Switch to background view
        m_Window.setView(m_BGRightView);
        // Draw the background
        m_Window.draw(m_BackgroundSprite);
        // Switch to m_RightView
        m_Window.setView(m_RightView);
<strong class="bold">        // Draw the Level</strong>
<strong class="bold">        m_Window.draw(m_VALevel, &amp;m_TextureTiles);</strong>
        // Draw thomas
        m_Window.draw(m_Thomas.getSprite());
        // Draw bob
        m_Window.draw(m_Bob.getSprite());
                
    }
    // Draw the HUD
    // Switch to m_HudView
    m_Window.setView(m_HudView);
    
    
    // Show everything we have just drawn
    m_Window.display();
}</pre>
			<p>Note that we need to draw the <code>VertexArray</code> for all the screen options (full, left, and right).</p>
			<p>Now, you can run the game. Unfortunately, however, Thomas and Bob fall straight through all our lovingly designed platforms. Due to this, we can't try and progress through the levels and beat the clock.</p>
			<h1 id="_idParaDest-324"><a id="_idTextAnchor334"/>Collision detection</h1>
			<p>We will handle collision detection using rectangle intersection and the SFML <code>intersects</code> function. What will be different in this project is that we will abstract the collision detection code into its own function. Thomas and Bob, as we have already seen, have multiple rectangles (<code>m_Head</code>, <code>m_Feet</code>, <code>m_Left</code>, and <code>m_Right</code>) that we need to check for collisions.</p>
			<h2 id="_idParaDest-325"><a id="_idTextAnchor335"/>Coding the detectCollisions function</h2>
			<p>To be clear, this function is part of the <code>Engine</code> class. Open the <code>Engine.h</code> file and add a declaration for a function called <code>detectCollisions</code>. This is highlighted in the following code snippet:</p>
			<pre>    // Private functions for internal use only
    void input();
    void update(float dtAsSeconds);
    void draw();
    // Load a new level
    void loadLevel();
<strong class="bold">    bool detectCollisions(PlayableCharacter&amp; character);</strong>
    
public:
    // The Engine constructor
    Engine();</pre>
			<p>Notice from the signature that the <code>detectCollision</code> function takes a polymorphic argument as a <code>PlayerCharacter</code> object. As we know, <code>PlayerCharacter</code> is abstract and can never be instantiated. We do, however, inherit from it with the <code>Thomas</code> and <code>Bob</code> classes. We will be able to pass either <code>m_Thomas</code> or <code>m_Bob</code> to <code>detectCollisions</code>.</p>
			<p>Right-click <code>DetectCollisions.cpp</code>. Finally, click the <code>detectCollisions </code>function.</p>
			<p>Add the following code to <code>DetectCollisions.cpp</code>. Note that this is just the first part of this function:</p>
			<pre>#include "Engine.h"
bool Engine::detectCollisions(PlayableCharacter&amp; character)
{
    bool reachedGoal = false;
    // Make a rect for all his parts
    FloatRect detectionZone = character.getPosition();
    // Make a FloatRect to test each block
    FloatRect block;
    block.width = TILE_SIZE;
    block.height = TILE_SIZE;
    // Build a zone around thomas to detect collisions
    int startX = (int)(detectionZone.left / TILE_SIZE) - 1;
    int startY = (int)(detectionZone.top / TILE_SIZE) - 1;
    int endX = (int)(detectionZone.left / TILE_SIZE) + 2;
    // Thomas is quite tall so check a few tiles vertically
    int endY = (int)(detectionZone.top / TILE_SIZE) + 3;
    // Make sure we don't test positions lower than zero
    // Or higher than the end of the array
    if (startX &lt; 0)startX = 0;
    if (startY &lt; 0)startY = 0;
    if (endX &gt;= m_LM.getLevelSize().x)
        endX = m_LM.getLevelSize().x;
    if (endY &gt;= m_LM.getLevelSize().y)
        endY = m_LM.getLevelSize().y;</pre>
			<p>The first thing that we do is declare a Boolean called <code>reachedGoal</code>. This is the value that the <code>detectCollisions</code> function returns to the calling code. It is initialized to <code>false</code>.</p>
			<p>Next, we declare a <code>FloatRect</code> object called <code>detectionZone</code> and initialize it with the same rectangle that represents the entire rectangle of the character sprite. Note that we will not actually do intersection tests with this rectangle. After, we declare another <code>FloatRect</code> called <code>block</code>. We initialize <code>block</code> as a 50 by 50 game unit rectangle. We will see <code>block</code> in use shortly.</p>
			<p>Next, we will look at how we will use <code>detectionZone</code>. We initialize four <code>int</code> variables, <code>startX</code>, <code>startY</code>, <code>endX</code>, and <code>endY</code>, by expanding the area around <code>detectionZone</code> by a few blocks. In the four <code>if</code> statements that follow, we check that it is not possible to try and do collision detection on a tile that does not exist. We will achieve this by making sure we never check positions less than zero or greater than the value returned by <code>getLevelSize().x</code> or <code>.y</code>. </p>
			<p>What all this previous code has done is create an area that is used to do collision detection. There is no point doing collision detection on a block that is hundreds or thousands of pixels away from the character. In addition, if we try and do collision detection where an array position doesn't exist (less than zero or greater than <code>getLevelSize()...</code>), the game will crash. </p>
			<p>Next, add the following code, which handles the player falling out of the level:</p>
			<pre>    // Has the character fallen out of the map?
    FloatRect level(0, 0, 
        m_LM.getLevelSize().x * TILE_SIZE, 
        m_LM.getLevelSize().y * TILE_SIZE);
    
    if (!character.getPosition().intersects(level))
    {
        // respawn the character
        character.spawn(m_LM.getStartPosition(), GRAVITY);
    }</pre>
			<p>For a character to stop falling, it must collide with a platform. Therefore, if the player moves out of the map (where there are no platforms), they will continuously fall. The previous code checks whether the character <em class="italic">does not</em> intersect with the <code>FloatRect</code>, <code>level</code>. If it does not, then it has fallen out of the level and the <code>spawn</code> function sends it back to the start.</p>
			<p>Add the following, quite long. code block and then we will go through what it does:</p>
			<pre>    // Loop through all the local blocks
    for (int x = startX; x &lt; endX; x++)
    {
        for (int y = startY; y &lt; endY; y++)
        {
            // Initialize the starting position of the current block
            block.left = x * TILE_SIZE;
            block.top = y * TILE_SIZE;
            // Has character been burnt or drowned?
            // Use head as this allows him to sink a bit
            if (m_ArrayLevel[y][x] == 2 || m_ArrayLevel[y][x] == 3)
            {
                if (character.getHead().intersects(block))
                {
                    character.spawn(m_LM.getStartPosition(), GRAVITY);
                    // Which sound should be played?
                    if (m_ArrayLevel[y][x] == 2)// Fire, ouch!
                    {
                        // Play a sound
                    }
                    else // Water
                    {
                        // Play a sound
                    }
                }
            }
            
            // Is character colliding with a regular block
            if (m_ArrayLevel[y][x] == 1)
            {
                if (character.getRight().intersects(block))
                {
                    character.stopRight(block.left);
                }
                else if (character.getLeft().intersects(block))
                {
                    character.stopLeft(block.left);
                }
                if (character.getFeet().intersects(block))
                {
                    character.stopFalling(block.top);
                }
                else if (character.getHead().intersects(block))
                {
                    character.stopJump();
                }
            }
            
            // More collision detection here once we have 
            // learned about particle effects
            // Has the character reached the goal?
            if (m_ArrayLevel[y][x] == 4)
            {
                // Character has reached the goal
                reachedGoal = true;
            }
        }
    }</pre>
			<p>The previous code does three things using the same techniques. It loops through all the values contained between <code>startX</code>, <code>endX</code>, and <code>startY</code>, <code>endY</code>. For each pass, it checks and does the following:</p>
			<ul>
				<li>Has the character been burned or drowned? <code>if (m_ArrayLevel[y][x] == 2 || m_ArrayLevel[y][x] == 3)</code> determines whether the current position being checked is a fire or a water tile. If the character's head intersects with one of these tiles, the player is respawned. We also code an empty <code>if</code>/<code>else</code> block in preparation to add sound in the next chapter.</li>
				<li>Has the character touched a regular tile? <code>code if (m_ArrayLevel[y][x] == 1)</code> determines whether the current position being checked holds a regular tile. If it intersects with any of the rectangles that represent the various body parts of the character, then the related function is called (<code>stopRight</code>, <code>stopLeft</code>, <code>stopFalling</code>, or <code>stopJump</code>). The value that is passed to each of these functions and how the function uses that value to reposition the character is quite nuanced. While it is not necessary to closely examine these values to understand the code, we might like to look at the values that are passed in and then refer to the appropriate function of the <code>PlayableCharacter</code> class in the previous chapter. This will help you appreciate exactly what is going on.</li>
				<li>Has the character touched the goal tile? This is determined with <code>if (m_ArrayLevel[y][x] == 4)</code>. All we need to do is set <code>reachedGoal</code> to <code>true</code>. The <code>update</code> function of the <code>Engine</code> class will keep track of whether both characters (Thomas and Bob) have reached the goal simultaneously. We will write this code in the <code>update</code> function in just a minute.</li>
			</ul>
			<p>Add the following line of code to the <code>detectCollisions</code> function:</p>
			<pre>    // All done, return, whether or 
   // not a new level might be required
    return reachedGoal;
}</pre>
			<p>The previous line of code returns the <code>reachedGoal</code> Boolean value so that the calling code can keep track and respond appropriately if both characters simultaneously reach the goal.</p>
			<p>All we need to do now is call the <code>detectCollision</code> function once per character, per frame. Add the following highlighted code in the <code>Update.cpp</code> file within the <code>if(m_Playing)</code> block of code:</p>
			<pre>if (m_Playing)
{
    // Update Thomas
    m_Thomas.update(dtAsSeconds);
    // Update Bob
    m_Bob.update(dtAsSeconds);
<strong class="bold">    // Detect collisions and see if characters </strong>
<strong class="bold">    // have reached the goal tile</strong>
<strong class="bold">    // The second part of the if condition is only executed</strong>
<strong class="bold">    // when thomas is touching the home tile</strong>
<strong class="bold">    if (detectCollisions(m_Thomas) &amp;&amp; detectCollisions(m_Bob))</strong>
<strong class="bold">    {</strong>
<strong class="bold">        // New level required</strong>
<strong class="bold">        m_NewLevelRequired = true;</strong>
<strong class="bold">        // Play the reach goal sound    </strong>
<strong class="bold">    }</strong>
<strong class="bold">    else</strong>
<strong class="bold">    {</strong>
<strong class="bold">        // Run bobs collision detection</strong>
<strong class="bold">        detectCollisions(m_Bob);</strong>
<strong class="bold">    }</strong>
    // Count down the time the player has left
    m_TimeRemaining -= dtAsSeconds;
    // Have Thomas and Bob run out of time?
    if (m_TimeRemaining &lt;= 0)
    {
        m_NewLevelRequired = true;
    }
}// End if playing</pre>
			<p>The previous code calls the <code>detectCollision</code> function and checks if both Bob and Thomas have simultaneously reached the goal. If they have, then the next level is prepared by setting <code>m_NewLevelRequired</code> to <code>true</code>.</p>
			<p>You can run the game and walk on the platforms. You can reach the goal and start a new level. Also, for the first time, the jump button (<em class="italic">W </em>or <em class="italic">Up</em> arrow) will work. </p>
			<p>If you reach the goal, then the next level will load. If you reach the goal of the last level, then the first level will load with a 10% reduced time limit. Of course, there is no visual feedback for the time or the current level because we haven't built a HUD yet. We will do so in the next chapter.</p>
			<p>Many of the levels, however, require Thomas and Bob to work as a team. More specifically, Thomas and Bob need to be able to climb on each other's heads.</p>
			<h2 id="_idParaDest-326"><a id="_idTextAnchor336"/>More collision detection</h2>
			<p>Add the following code just after you added the previous code in the <code>Update.cpp</code> file, within the <code>if (m_Playing)</code> section:</p>
			<pre>if (m_Playing)
{
    // Update Thomas
    m_Thomas.update(dtAsSeconds);
    // Update Bob
    m_Bob.update(dtAsSeconds);
    // Detect collisions and see if characters 
    // have reached the goal tile
    // The second part of the if condition is only executed
    // when thomas is touching the home tile
    if (detectCollisions(m_Thomas) &amp;&amp; detectCollisions(m_Bob))
    {
        // New level required
        m_NewLevelRequired = true;
        // Play the reach goal sound
    }
    else
    {
        // Run bobs collision detection
        detectCollisions(m_Bob);
    }
<strong class="bold">    // Let bob and thomas jump on each others heads</strong>
<strong class="bold">    if (m_Bob.getFeet().intersects(m_Thomas.getHead()))</strong>
<strong class="bold">    {</strong>
<strong class="bold">        m_Bob.stopFalling(m_Thomas.getHead().top);</strong>
<strong class="bold">    }</strong>
<strong class="bold">    else if (m_Thomas.getFeet().intersects(m_Bob.getHead()))</strong>
<strong class="bold">    {</strong>
<strong class="bold">        m_Thomas.stopFalling(m_Bob.getHead().top);</strong>
<strong class="bold">    }</strong>
    // Count down the time the player has left
    m_TimeRemaining -= dtAsSeconds;
    // Have Thomas and Bob run out of time?
    if (m_TimeRemaining &lt;= 0)
    {
        m_NewLevelRequired = true;
    }
}// End if playing</pre>
			<p>You can run the game again and stand on the heads of Thomas and Bob to get to the hard-to-reach places that were previously not possible to get to:</p>
			<div><div><img src="img/B14278_16_09.jpg" alt=""/>
				</div>
			</div>
			<h1 id="_idParaDest-327"><a id="_idTextAnchor337"/>Summary</h1>
			<p><a id="_idTextAnchor338"/>There was quite a lot of code in this chapter. We learned how to read from a file and convert strings of text into <code>char</code> values and then into int <code>values</code>. Once we had a two-dimensional array of <code>int</code> values, we were able to populate a <code>VertexArray</code> instance to show the level on the screen. We then used the same two-dimensional array of <code>int</code> values to implement collision detection. We used rectangle intersection, just like we did in the Zombie Arena project, although this time, for more precision, we gave each character four collision zones – one each to represent their head, feet, left, and right-hand sides.</p>
			<p>Now that the game is totally playable, we need to represent the state of the game (score and time) on the screen. In the next chapter, we will implement the HUD, along with some much more advanced sound effects than we have used so far.</p>
		</div>
	</body></html>