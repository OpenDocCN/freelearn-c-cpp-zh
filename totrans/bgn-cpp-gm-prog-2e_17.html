<html><head></head><body>
		<div id="_idContainer109">
			<h1 id="_idParaDest-317"><a id="_idTextAnchor327"/><em class="italic">Chapter 16</em>: Building Playable Levels and Collision Detection</h1>
			<p>This chapter will probably be one of the most satisfying chapters of this project. The reason for this is that, by the end of it, we will have a playable game. Although there will still be features to implement (sound, particle effects, the HUD, and shader effects), Bob and Thomas will be able to run, jump, and explore the world. Furthermore, you will be able to create your very own level designs of any size or complexity by simply making platforms and obstacles in a text file.</p>
			<p>We will achieve all this by covering the following topics: </p>
			<ul>
				<li>Exploring how to design levels in a text file</li>
				<li>Building a <strong class="source-inline">LevelManager</strong> class that will load levels from a text file, convert them into data that our game can use, and keep track of the level details such as spawn position, current level, and allowed time limit</li>
				<li>Updating the game engine to use <strong class="source-inline">LevelManager</strong></li>
				<li>Coding a polymorphic function to handle collision detection for both Bob and Thomas</li>
			</ul>
			<h1 id="_idParaDest-318"><a id="_idTextAnchor328"/>Designing some levels</h1>
			<p>Remember the sprite-sheet that we introduced in <a href="B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292"><em class="italic">Chapter 14</em></a>, <em class="italic">Abstraction and Code Management – Making Better Use of OOP</em>? Here it is again, annotated with numbers that represent each tile that we will build all our levels from:</p>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="image/B14278_16_01.jpg" alt=""/>
				</div>
			</div>
			<p>The image has been placed on a grey background so that we can see the different details of the sprite-sheet better. The chequered background represents the level of transparency. So, all the tiles except for number 1 will reveal at least a little of the background behind them. Let's go over them now:</p>
			<ul>
				<li>Tile 0 is completely transparent and will be used to fill in the gaps where there aren't any other tiles. </li>
				<li>Tile 1 is for the platforms that Thomas and Bob will walk on. </li>
				<li>Tile 2 is for fire tiles and 3 is for water tiles. </li>
				<li>In terms of tile 4, you might need to look quite closely to see it. It has a white square outline. This is the goal of the level and is where Thomas and Bob must get to together. </li>
			</ul>
			<p>Keep this image in mind as we discuss designing the levels.</p>
			<p>We will enter combinations of these tile numbers into text files to design the layouts. An example will help:</p>
			<p class="source-code">0000000000000000000000000000000000000000000000</p>
			<p class="source-code">0000000000000000000000000000000000000000000000</p>
			<p class="source-code">0000000000000000000000000000000000000000000000</p>
			<p class="source-code">0000000000000000000000000000000000000000000000</p>
			<p class="source-code">0000000000000000000000000000000000000000000000</p>
			<p class="source-code">0000000000000000000000000000000000000000000000</p>
			<p class="source-code">1111111111000111111222222221111133111111111411</p>
			<p class="source-code">0000000000000000001222222221000133100000001110</p>
			<p class="source-code">0000000000000000001222222221000133100000000000</p>
			<p class="source-code">0000000000000000001222222221000133100000000000</p>
			<p class="source-code">0000000000000000001111111111000111100000000000</p>
			<p>The previous code translates into the following level layout:</p>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="image/B14278_16_02.jpg" alt=""/>
				</div>
			</div>
			<p>Note that, to get the previous screenshot, I had to zoom out of the <strong class="source-inline">View</strong> and that the image has been cropped. The actual start of the level would look as follows:</p>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/B14278_16_03.jpg" alt=""/>
				</div>
			</div>
			<p>These screenshots demonstrate two things. First, you can see how you can quickly construct level designs using a simple and free text editor such as Windows Notepad or Notepad ++. Just make sure you use a monospace font so that all the numbers are the same size. This makes designing the levels much easier.</p>
			<p>Secondly, these screenshots demonstrate the gameplay aspects of the design. From left to right in the level, Thomas and Bob need to jump over a small hole or they will fall to their death (respawn). Then, they have a large expanse of fire to traverse. It is impossible for Bob to jump that many tiles. The players will need to work together to find the solution. The only way that Bob will clear the fire tiles is by standing on Thomas's head and jumping from there, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="image/B14278_16_04.jpg" alt=""/>
				</div>
			</div>
			<p>It is then quite simple to get to the goal and move on to the next level.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">I strongly encourage you to complete this chapter and then spend some time designing your own levels.</p>
			<p>I have included a few level designs to get us started. They are in the <strong class="source-inline">levels</strong> folder that we added to the project back in <a href="B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292"><em class="italic">Chapter 14</em></a>, <em class="italic">Abstraction and Code Management – Making Better Use of OOP</em>.</p>
			<p>There are some zoomed-out views of the game there, along with a screenshot of the code of the level design. The screenshot of the code is probably more useful than reproducing the textual content. If the code has to be checked, just open the files in the <strong class="source-inline">levels</strong> folder. </p>
			<p>This is what the code looks like:</p>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="image/B14278_16_05.jpg" alt=""/>
				</div>
			</div>
			<p>This is the level layout that the previous code will produce:</p>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<img src="image/B14278_16_05b.jpg" alt=""/>
				</div>
			</div>
			<p>This level is the "leap of faith" level I referred to in <a href="B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292"><em class="italic">Chapter 14</em></a>, <em class="italic">Abstraction and Code Management – Making Better Use of OOP</em>:</p>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<img src="image/B14278_16_06.jpg" alt=""/>
				</div>
			</div>
			<p>The code for the in-game platforms has been highlighted, as they are not very clear in the zoomed-out screenshot that follows:</p>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<img src="image/B14278_16_06b.jpg" alt=""/>
				</div>
			</div>
			<p>The provided designs are simple. The game engine will be able to handle very large designs, but we have the freedom to use our imagination and build some long and challenging levels.</p>
			<p>Of course, these designs won't do anything until we learn how to load them and convert the text into a playable level. Additionally, it won't be possible to stand on any platforms until we have implemented the collision detection. </p>
			<p>First, let's handle loading the level designs.</p>
			<h1 id="_idParaDest-319"><a id="_idTextAnchor329"/>Building the LevelManager class</h1>
			<p>It will take several phases of coding to make our level designs work. </p>
			<p>The first thing we will do is code the <strong class="source-inline">LevelManager</strong> header file. This will allow us to look at and discuss the member variables and functions that will be in the <strong class="source-inline">LevelManager</strong> class.</p>
			<p>Next, we will code the <strong class="source-inline">LevelManager.cpp</strong> file, which will have all the function definitions in it. Since this is a long file, we will break it up into several sections to code and discuss them.</p>
			<p>Once the <strong class="source-inline">LevelManager</strong> class is complete, we will add an instance of it to the game engine (<strong class="source-inline">Engine</strong> class). We will also add a new function to the <strong class="source-inline">Engine</strong> class, <strong class="source-inline">loadLevel</strong>, which we can call from the <strong class="source-inline">update</strong> function whenever a new level is required. The <strong class="source-inline">loadLevel</strong> function will not only use the <strong class="source-inline">LevelManager</strong> instance to load the appropriate level – it will also take care of aspects such as spawning the player characters and preparing the clock.</p>
			<p>Now, let's get an overview of <strong class="source-inline">LevelManager</strong> by coding the <strong class="source-inline">LevelManager.h</strong> file.</p>
			<h2 id="_idParaDest-320"><a id="_idTextAnchor330"/>Coding LevelManager.h</h2>
			<p>Right-click <strong class="bold">Header Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">Header File (.h)</strong> and then, in the <strong class="bold">Name</strong> field, type <strong class="source-inline">LevelManager.h</strong>. Finally, click the <strong class="bold">Add</strong> button. We are now ready to code the header file for the <strong class="source-inline">LevelManager</strong> class.</p>
			<p>Add the following include directives and private variables and then we will discuss them:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">using namespace std;</p>
			<p class="source-code">class LevelManager</p>
			<p class="source-code">{</p>
			<p class="source-code">private:</p>
			<p class="source-code">    Vector2i m_LevelSize;</p>
			<p class="source-code">    Vector2f m_StartPosition;</p>
			<p class="source-code">    float m_TimeModifier = 1;</p>
			<p class="source-code">    float m_BaseTimeLimit = 0;</p>
			<p class="source-code">    int m_CurrentLevel = 0;</p>
			<p class="source-code">    const int NUM_LEVELS = 4;</p>
			<p class="source-code">// public declarations go here</p>
			<p>The preceding code declares a <strong class="source-inline">Vector2i</strong>, <strong class="source-inline">m_LevelSize</strong> to hold two integer values that will hold the horizontal and vertical number of tiles that the current map contains. The <strong class="source-inline">Vector2f</strong>, <strong class="source-inline">m_StartPosition</strong> contains the coordinates in the world where Bob and Thomas should be spawned. Note that this is not a tile position relatable to <strong class="source-inline">m_LevelSize</strong> units but a horizontal and vertical pixel position in the level.</p>
			<p>The <strong class="source-inline">m_TimeModifier</strong> member variable is a float type variable that will be used to multiply the time that's available in the current level. The reason we want to do this is so that we can change (decrease) this value so that we can shorten the time that's available each time the player attempts the same level. As an example, if the player gets 60 seconds for the first time they attempt level 1, then 60 multiplied by 1 is, of course, 60. When the player completes all the levels and comes back to level 1 for the second time, <strong class="source-inline">m_TimeModifier</strong> will have been reduced by 10 percent. Then, when the time available is multiplied by 0.9, the amount of time that's available to the player will be 54 seconds. This is 10 percent less. The game will get steadily harder.</p>
			<p>The <strong class="source-inline">m_BaseTimeLimit</strong> float variable holds the original, unmodified time limit we have just discussed.</p>
			<p>We can probably guess that <strong class="source-inline">m_CurrentLevel</strong> will hold the current level number that is being played.</p>
			<p>The <strong class="source-inline">int</strong>, <strong class="source-inline">NUM_LEVELS</strong> constant will be used to flag when it is appropriate to go back to level 1 again and reduce the value of <strong class="source-inline">m_TimeModifier</strong>. </p>
			<p>Now, add the following public variables and function declarations after the previous code we added:</p>
			<p class="source-code">public:</p>
			<p class="source-code">    const int TILE_SIZE = 50;</p>
			<p class="source-code">    const int VERTS_IN_QUAD = 4;</p>
			<p class="source-code">    float getTimeLimit();</p>
			<p class="source-code">    Vector2f getStartPosition();</p>
			<p class="source-code">    int** nextLevel(VertexArray&amp; rVaLevel);</p>
			<p class="source-code">    Vector2i getLevelSize();</p>
			<p class="source-code">    int getCurrentLevel();</p>
			<p class="source-code">};</p>
			<p>In the previous code, there are two constant <strong class="source-inline">int</strong> members. <strong class="source-inline">TILE_SIZE</strong> is a useful constant to remind us that each tile in the sprite-sheet is fifty pixels wide and fifty pixels high. <strong class="source-inline">VERTS_IN_QUAD</strong> is a useful constant to make our manipulation of a <strong class="source-inline">VertexArray</strong> less error-prone. There are, in fact, four vertices in a quad. Now, we can't forget this.</p>
			<p>The <strong class="source-inline">getTimeLimit</strong>, <strong class="source-inline">getStartPosition</strong>, <strong class="source-inline">getLevelSize</strong>, and <strong class="source-inline">getCurrentLevel</strong> functions are simple getter functions which return the current value of the private member variables we declared in the previous block of code.</p>
			<p>The function that deserves to be talked about more is <strong class="source-inline">nextLevel</strong>. This function receives a <strong class="source-inline">VertexArray</strong> reference, just like we used in the Zombie Arena game. The function can then work on the <strong class="source-inline">VertexArray</strong> reference and all the changes will be present in the <strong class="source-inline">VertexArray</strong> reference from the calling code. </p>
			<p>The <strong class="source-inline">nextLevel</strong> function returns a pointer to a pointer, which means we can return an address of the first element of a two-dimensional array of <strong class="source-inline">int</strong> values. We will be building a two-dimensional array of <strong class="source-inline">int</strong> values that will represent the layout of each level. Of course, these int values will be read from the level design text files. </p>
			<h2 id="_idParaDest-321"><a id="_idTextAnchor331"/>Coding the LevelManager.cpp file</h2>
			<p>Right-click <strong class="bold">Source Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">C++ File (.cpp)</strong> and then, in the <strong class="bold">Name</strong> field, type <strong class="source-inline">LevelManager.cpp</strong>. Finally, click the <strong class="bold">Add</strong> button. We are now ready to code the <strong class="source-inline">.cpp</strong> file for the <strong class="source-inline">LevelManager</strong> class. </p>
			<p>As this is quite a long class, we will break it up to discuss it in six chunks. The first five will cover the <strong class="source-inline">nextLevel</strong> function, while the sixth will cover the rest of the functions.</p>
			<p>Add the following include directives and the first (of five) part of the <strong class="source-inline">nextLevel</strong> function:</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">#include &lt;SFML/Audio.hpp&gt;</p>
			<p class="source-code">#include "TextureHolder.h"</p>
			<p class="source-code">#include &lt;sstream&gt;</p>
			<p class="source-code">#include &lt;fstream&gt;</p>
			<p class="source-code">#include "LevelManager.h"</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">using namespace std;</p>
			<p class="source-code">int** LevelManager::nextLevel(VertexArray&amp; rVaLevel)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_LevelSize.x = 0;</p>
			<p class="source-code">    m_LevelSize.y = 0;</p>
			<p class="source-code">    // Get the next level</p>
			<p class="source-code">    m_CurrentLevel++;</p>
			<p class="source-code">    if (m_CurrentLevel &gt; NUM_LEVELS)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_CurrentLevel = 1;</p>
			<p class="source-code">        m_TimeModifier -= .1f;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    // Load the appropriate level from a text file</p>
			<p class="source-code">    string levelToLoad;</p>
			<p class="source-code">    switch (m_CurrentLevel)</p>
			<p class="source-code">    {</p>
			<p class="source-code">    case 1:</p>
			<p class="source-code">        levelToLoad = "levels/level1.txt";</p>
			<p class="source-code">        m_StartPosition.x = 100;</p>
			<p class="source-code">        m_StartPosition.y = 100;</p>
			<p class="source-code">        m_BaseTimeLimit = 30.0f;</p>
			<p class="source-code">        break;</p>
			<p class="source-code">    case 2:</p>
			<p class="source-code">        levelToLoad = "levels/level2.txt";</p>
			<p class="source-code">        m_StartPosition.x = 100;</p>
			<p class="source-code">        m_StartPosition.y = 3600;</p>
			<p class="source-code">        m_BaseTimeLimit = 100.0f;</p>
			<p class="source-code">        break;</p>
			<p class="source-code">    case 3:</p>
			<p class="source-code">        levelToLoad = "levels/level3.txt";</p>
			<p class="source-code">        m_StartPosition.x = 1250;</p>
			<p class="source-code">        m_StartPosition.y = 0;</p>
			<p class="source-code">        m_BaseTimeLimit = 30.0f;</p>
			<p class="source-code">        break;</p>
			<p class="source-code">    case 4:</p>
			<p class="source-code">        levelToLoad = "levels/level4.txt";</p>
			<p class="source-code">        m_StartPosition.x = 50;</p>
			<p class="source-code">        m_StartPosition.y = 200;</p>
			<p class="source-code">        m_BaseTimeLimit = 50.0f;</p>
			<p class="source-code">        break;</p>
			<p class="source-code">    }// End switch</p>
			<p>After the include directives, the code initializes the <strong class="source-inline">m_LevelSize.x</strong> and <strong class="source-inline">m_LevelSize.y</strong> variables to zero.</p>
			<p>Next, <strong class="source-inline">m_CurrentLevel</strong> is incremented. The <strong class="source-inline">if</strong> statement that follows checks whether <strong class="source-inline">m_CurrentLevel</strong> is greater than <strong class="source-inline">NUM_LEVELS</strong>. If it is, then <strong class="source-inline">m_CurrentLevel</strong> is set back to <strong class="source-inline">1</strong> and <strong class="source-inline">m_TimeModifier</strong> is reduced by <strong class="source-inline">0.1</strong> in order to shorten the allowed time for all levels.</p>
			<p>The code then switches based on the value held by <strong class="source-inline">m_CurrentLevel</strong>. Each <strong class="source-inline">case</strong> statement initializes the name of the text file that holds the level design, the starting position for Thomas and Bob, as well as <strong class="source-inline">m_BaseTimeLimit</strong>, which is the unmodified time limit for the level in question.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you design your own levels, add a <strong class="source-inline">case</strong> statement and the appropriate values for it here. Also, edit the <strong class="source-inline">NUM_LEVELS</strong> constant in the <strong class="source-inline">LevelManager.h</strong> file.</p>
			<p>Now, add the second part of the <strong class="source-inline">nextLevel</strong> function, as follows. Add this code immediately after the previous code. Study the code as we add it so we can discuss it:</p>
			<p class="source-code">    ifstream inputFile(levelToLoad);</p>
			<p class="source-code">    string s;</p>
			<p class="source-code">    // Count the number of rows in the file</p>
			<p class="source-code">    while (getline(inputFile, s))</p>
			<p class="source-code">    {</p>
			<p class="source-code">        ++m_LevelSize.y;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    // Store the length of the rows</p>
			<p class="source-code">    m_LevelSize.x = s.length();</p>
			<p>In the preceding (second part) code, we declare an <strong class="source-inline">ifstream</strong> object called <strong class="source-inline">inputFile</strong> which opens a stream to the file name contained in <strong class="source-inline">levelToLoad</strong>.</p>
			<p>The code loops through each line of the file using <strong class="source-inline">getLine</strong>, but doesn't record any of its content. All it does is count the number of lines by incrementing <strong class="source-inline">m_LevelSize.y</strong>. After the <strong class="source-inline">for</strong> loop, the width of the level is saved in <strong class="source-inline">m_LevelSize.x</strong> using the <strong class="source-inline">s.length</strong> function. This implies that the length of all the lines must be the same or we would run into trouble.</p>
			<p>At this point, we know and have saved the length and width of the current level in <strong class="source-inline">m_LevelSize</strong>.</p>
			<p>Now, add the third part of the <strong class="source-inline">nextLevel</strong> function, as shown in the following code. Add the code immediately underneath the previous code. Study the code as we add it so we can discuss it:</p>
			<p class="source-code">    // Go back to the start of the file</p>
			<p class="source-code">    inputFile.clear();</p>
			<p class="source-code">    inputFile.seekg(0, ios::beg);</p>
			<p class="source-code">    // Prepare the 2D array to hold the int values from the file</p>
			<p class="source-code">    int** arrayLevel = new int*[m_LevelSize.y];</p>
			<p class="source-code">    for (int i = 0; i &lt; m_LevelSize.y; ++i)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Add a new array into each array element</p>
			<p class="source-code">        arrayLevel[i] = new int[m_LevelSize.x];</p>
			<p class="source-code">    }</p>
			<p>First, we clear <strong class="source-inline">inputFile</strong> using its <strong class="source-inline">clear</strong> function. The <strong class="source-inline">seekg</strong> function, which is called with the <strong class="source-inline">0, ios::beg</strong> parameters, moves the file cursor's position (where characters will be read from next) to the beginning of the file.</p>
			<p>Next, we declare a pointer to a pointer called <strong class="source-inline">arrayLevel</strong>. Note that this is done on the free store/heap using the <strong class="source-inline">new</strong> keyword. Once we have initialized this two-dimensional array, we will be able to return its address to the calling code and it will persist until we either delete it or the game is closed.</p>
			<p>The <strong class="source-inline">for</strong> loop loops from 0 to <strong class="source-inline">m_LevelSize.y -1</strong>. In each pass of the loop, it adds a new array of <strong class="source-inline">int</strong> values, on the heap, to match the value of <strong class="source-inline">m_LevelSize.x</strong>. We now have a perfectly configured (for the current level) two-dimensional array. The only problem is that there is nothing in it yet.</p>
			<p>Now, add the fourth part of the <strong class="source-inline">nextLevel</strong> function, as shown in the following code. Add this code immediately after the previous code. Study the code as we add it so we can discuss it:</p>
			<p class="source-code">    // Loop through the file and store all </p>
			<p class="source-code">   // the values in the 2d array</p>
			<p class="source-code">    string row;</p>
			<p class="source-code">    int y = 0;</p>
			<p class="source-code">    while (inputFile &gt;&gt; row)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        for (int x = 0; x &lt; row.length(); x++) {</p>
			<p class="source-code">            const char val = row[x];</p>
			<p class="source-code">            arrayLevel[y][x] = atoi(&amp;val);</p>
			<p class="source-code">        }</p>
			<p class="source-code">        y++;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    // Close the file</p>
			<p class="source-code">    inputFile.close();</p>
			<p>First, the code initializes a <strong class="source-inline">string</strong> called <strong class="source-inline">row</strong> that will hold only one row of the level design at a time. We also declare and initialize an <strong class="source-inline">int</strong> called <strong class="source-inline">y</strong> that will help us count the rows.</p>
			<p>The <strong class="source-inline">while</strong> loop executes repeatedly until <strong class="source-inline">inputFile</strong> gets past the last row. Inside the <strong class="source-inline">while</strong> loop, there is a <strong class="source-inline">for</strong> loop which goes through each character of the current row and stores it in the two-dimensional array, <strong class="source-inline">arrayLevel</strong>. Notice that we access the right element of the two-dimensional array with <strong class="source-inline">arrayLevel[y][x]=</strong>. The <strong class="source-inline">atoi</strong> function converts the <strong class="source-inline">char val</strong> into an <strong class="source-inline">int</strong>. This is required because we have a two-dimensional array for <strong class="source-inline">int</strong>, and not for <strong class="source-inline">char</strong>.</p>
			<p>Now, let's add the fifth part of the <strong class="source-inline">nextLevel</strong> function, as shown here. Add this code immediately after the previous code. Study the code as we add it, so we can discuss it:</p>
			<p class="source-code">    // What type of primitive are we using?</p>
			<p class="source-code">    rVaLevel.setPrimitiveType(Quads);</p>
			<p class="source-code">    // Set the size of the vertex array</p>
			<p class="source-code">    rVaLevel.resize(m_LevelSize.x * </p>
			<p class="source-code">      m_LevelSize.y * VERTS_IN_QUAD);</p>
			<p class="source-code">    // Start at the beginning of the vertex array</p>
			<p class="source-code">    int currentVertex = 0;</p>
			<p class="source-code">    for (int x = 0; x &lt; m_LevelSize.x; x++)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        for (int y = 0; y &lt; m_LevelSize.y; y++)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            // Position each vertex in the current quad</p>
			<p class="source-code">            rVaLevel[currentVertex + 0].position = </p>
			<p class="source-code">                Vector2f(x * TILE_SIZE, </p>
			<p class="source-code">                y * TILE_SIZE);</p>
			<p class="source-code">            rVaLevel[currentVertex + 1].position = </p>
			<p class="source-code">                Vector2f((x * TILE_SIZE) + TILE_SIZE, </p>
			<p class="source-code">                y * TILE_SIZE);</p>
			<p class="source-code">            rVaLevel[currentVertex + 2].position = </p>
			<p class="source-code">                Vector2f((x * TILE_SIZE) + TILE_SIZE, </p>
			<p class="source-code">                (y * TILE_SIZE) + TILE_SIZE);</p>
			<p class="source-code">            rVaLevel[currentVertex + 3].position = </p>
			<p class="source-code">                Vector2f((x * TILE_SIZE), </p>
			<p class="source-code">                (y * TILE_SIZE) + TILE_SIZE);</p>
			<p class="source-code">            // Which tile from the sprite sheet should we use</p>
			<p class="source-code">            int verticalOffset = arrayLevel[y][x] * TILE_SIZE;</p>
			<p class="source-code">            rVaLevel[currentVertex + 0].texCoords = </p>
			<p class="source-code">                Vector2f(0, 0 + verticalOffset);</p>
			<p class="source-code">            rVaLevel[currentVertex + 1].texCoords = </p>
			<p class="source-code">                Vector2f(TILE_SIZE, 0 + verticalOffset);</p>
			<p class="source-code">            rVaLevel[currentVertex + 2].texCoords = </p>
			<p class="source-code">                Vector2f(TILE_SIZE, TILE_SIZE + verticalOffset);</p>
			<p class="source-code">            rVaLevel[currentVertex + 3].texCoords = </p>
			<p class="source-code">                Vector2f(0, TILE_SIZE + verticalOffset);</p>
			<p class="source-code">            // Position ready for the next four vertices</p>
			<p class="source-code">            currentVertex = currentVertex + VERTS_IN_QUAD;</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return arrayLevel;</p>
			<p class="source-code">} // End of nextLevel function</p>
			<p>Although this is the longest section of code from the five sections (we divided <strong class="source-inline">nextLevel</strong> in two), it is also the most straightforward. This is because we have seen very similar code in the Zombie Arena project.</p>
			<p>The process for the precedingcode is that the nested <strong class="source-inline">for</strong> loops loop from zero through to the width and height of the level. For each position in the array, four vertices are put into the <strong class="source-inline">VertexArray</strong> and four texture coordinates are assigned from the sprite-sheet. The positions of the vertices and texture coordinates are calculated using the <strong class="source-inline">currentVertex</strong> variable, <strong class="source-inline">TILE SIZE</strong>, and the <strong class="source-inline">VERTS_IN_QUAD</strong> constants. At the end of each loop of the inner <strong class="source-inline">for</strong> loop, <strong class="source-inline">currentVertex</strong> is increased by <strong class="source-inline">VERTS_IN_QUAD</strong>, moving nicely on to the next tile.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The important thing to remember about <strong class="source-inline">VertexArray</strong> is that it was passed in to <strong class="source-inline">nextLevel</strong> by reference. Therefore, <strong class="source-inline">VertexArray</strong> will be available in the calling code. We will call <strong class="source-inline">nextLevel</strong> from the code in the <strong class="source-inline">Engine</strong> class.</p>
			<p>Once this function has been called, the <strong class="source-inline">Engine</strong> class will have a <strong class="source-inline">VertexArray</strong> to represent the level graphically and a two-dimensional array of <strong class="source-inline">int</strong> values as a numerical representation of all the platforms and obstacles in the level.</p>
			<p>The rest of the <strong class="source-inline">LevelManager</strong> functions are all simple getter functions but do take the time to familiarize yourself with which private value is returned by which function. Add the remaining functions from the <strong class="source-inline">LevelManager</strong> class, as follows:</p>
			<p class="source-code">Vector2i LevelManager::getLevelSize()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_LevelSize;</p>
			<p class="source-code">}</p>
			<p class="source-code">int LevelManager::getCurrentLevel()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_CurrentLevel;</p>
			<p class="source-code">}</p>
			<p class="source-code">float LevelManager::getTimeLimit()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_BaseTimeLimit * m_TimeModifier;</p>
			<p class="source-code">}</p>
			<p class="source-code">Vector2f LevelManager::getStartPosition()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_StartPosition;</p>
			<p class="source-code">}</p>
			<p>Now that the <strong class="source-inline">LevelManager</strong> class is complete, we can move on to using it. We will code another function in the <strong class="source-inline">Engine</strong> class to do so.</p>
			<h1 id="_idParaDest-322"><a id="_idTextAnchor332"/>Coding the loadLevel function</h1>
			<p>To be clear, this function is part of the <strong class="source-inline">Engine</strong> class, although it will delegate much of its work to other functions, including those of the <strong class="source-inline">LevelManager</strong> class that we just built.</p>
			<p>First, let's add the declaration for the new function, along with some other new pieces of code, to the <strong class="source-inline">Engine.h</strong> file. Open the <strong class="source-inline">Engine.h</strong> file and add the highlighted lines of code shown in the abbreviated snapshot of the <strong class="source-inline">Engine.h</strong> file, as follows:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">#include "TextureHolder.h"</p>
			<p class="source-code">#include "Thomas.h"</p>
			<p class="source-code">#include "Bob.h"</p>
			<p class="source-code"><strong class="bold">#include "LevelManager.h"</strong></p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">class Engine</p>
			<p class="source-code">{</p>
			<p class="source-code">private:</p>
			<p class="source-code">    // The texture holder</p>
			<p class="source-code">    TextureHolder th;</p>
			<p class="source-code">    // Thomas and his friend, Bob</p>
			<p class="source-code">    Thomas m_Thomas;</p>
			<p class="source-code">    Bob m_Bob;</p>
			<p class="source-code"><strong class="bold">    // A class to manage all the levels</strong></p>
			<p class="source-code"><strong class="bold">    LevelManager m_LM;</strong></p>
			<p class="source-code">    const int TILE_SIZE = 50;</p>
			<p class="source-code">    const int VERTS_IN_QUAD = 4;</p>
			<p class="source-code">    // The force pushing the characters down</p>
			<p class="source-code">    const int GRAVITY = 300;</p>
			<p class="source-code">    // A regular RenderWindow</p>
			<p class="source-code">    RenderWindow m_Window;</p>
			<p class="source-code">    // The main Views</p>
			<p class="source-code">    View m_MainView;</p>
			<p class="source-code">    View m_LeftView;</p>
			<p class="source-code">    View m_RightView;</p>
			<p class="source-code">    // Three views for the background</p>
			<p class="source-code">    View m_BGMainView;</p>
			<p class="source-code">    View m_BGLeftView;</p>
			<p class="source-code">    View m_BGRightView;</p>
			<p class="source-code">    View m_HudView;</p>
			<p class="source-code">    // Declare a sprite and a Texture for the background</p>
			<p class="source-code">    Sprite m_BackgroundSprite;</p>
			<p class="source-code">    Texture m_BackgroundTexture;</p>
			<p class="source-code">    // Is the game currently playing?</p>
			<p class="source-code">    bool m_Playing = false;</p>
			<p class="source-code">    // Is character 1 or 2 the current focus?</p>
			<p class="source-code">    bool m_Character1 = true;</p>
			<p class="source-code">    // Start in full screen mode</p>
			<p class="source-code">    bool m_SplitScreen = false;</p>
			<p class="source-code">    // How much time is left in the current level</p>
			<p class="source-code">    float m_TimeRemaining = 10;</p>
			<p class="source-code">    Time m_GameTimeTotal;</p>
			<p class="source-code">    // Is it time for a new/first level?</p>
			<p class="source-code">    bool m_NewLevelRequired = true;</p>
			<p class="source-code"><strong class="bold">    // The vertex array for the level tiles</strong></p>
			<p class="source-code"><strong class="bold">    VertexArray m_VALevel;</strong></p>
			<p class="source-code"><strong class="bold">    // The 2d array with the map for the level</strong></p>
			<p class="source-code"><strong class="bold">    // A pointer to a pointer</strong></p>
			<p class="source-code"><strong class="bold">    int** m_ArrayLevel = NULL;</strong></p>
			<p class="source-code"><strong class="bold">    // Texture for the level tiles</strong></p>
			<p class="source-code"><strong class="bold">    Texture m_TextureTiles;</strong></p>
			<p class="source-code">    </p>
			<p class="source-code">    // Private functions for internal use only</p>
			<p class="source-code">    void input();</p>
			<p class="source-code">    void update(float dtAsSeconds);</p>
			<p class="source-code">    void draw();    </p>
			<p class="source-code"><strong class="bold">    // Load a new level</strong></p>
			<p class="source-code"><strong class="bold">    void loadLevel();</strong></p>
			<p class="source-code">    </p>
			<p class="source-code">public:</p>
			<p class="source-code">    // The Engine constructor</p>
			<p class="source-code">    Engine();</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    ...        </p>
			<p class="source-code">    ...</p>
			<p>This is what we can see in the previous code:</p>
			<ul>
				<li>We included the <strong class="source-inline">LevelManager.h</strong> file.</li>
				<li>We added an instance of <strong class="source-inline">LevelManager</strong> called <strong class="source-inline">m_LM</strong>.</li>
				<li>We added a <strong class="source-inline">VertexArray</strong> called <strong class="source-inline">m_VALevel</strong>.</li>
				<li>We added a pointer to a pointer to int that will hold the two-dimensional array that is returned from <strong class="source-inline">nextLevel</strong>.</li>
				<li>We added a new <strong class="source-inline">Texture</strong> object for the sprite-sheet.</li>
				<li>We added the declaration for the <strong class="source-inline">loadLevel</strong> function that we will write now.</li>
			</ul>
			<p>Right-click <strong class="bold">Source Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">C++ File (.cpp)</strong> and then, in the <strong class="bold">Name</strong> field, type <strong class="source-inline">LoadLevel.cpp</strong>. Finally, click the <strong class="bold">Add</strong> button. We are now ready to code the <strong class="source-inline">loadLevel</strong> function.</p>
			<p>Add the code for the <strong class="source-inline">loadLevel</strong> function to the <strong class="source-inline">LoadLevel.cpp</strong> file. Then, we can discuss it:</p>
			<p class="source-code">#include "Engine.h"</p>
			<p class="source-code">void Engine::loadLevel()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Playing = false;</p>
			<p class="source-code">    // Delete the previously allocated memory</p>
			<p class="source-code">    for (int i = 0; i &lt; m_LM.getLevelSize().y; ++i)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        delete[] m_ArrayLevel[i];</p>
			<p class="source-code">    }</p>
			<p class="source-code">    delete[] m_ArrayLevel;</p>
			<p class="source-code">    // Load the next 2d array with the map for the level</p>
			<p class="source-code">    // And repopulate the vertex array as well</p>
			<p class="source-code">    m_ArrayLevel = m_LM.nextLevel(m_VALevel);</p>
			<p class="source-code">    // How long is this new time limit</p>
			<p class="source-code">    m_TimeRemaining = m_LM.getTimeLimit();</p>
			<p class="source-code">    // Spawn Thomas and Bob</p>
			<p class="source-code">    m_Thomas.spawn(m_LM.getStartPosition(), GRAVITY);</p>
			<p class="source-code">    m_Bob.spawn(m_LM.getStartPosition(), GRAVITY);</p>
			<p class="source-code">    // Make sure this code isn't run again</p>
			<p class="source-code">    m_NewLevelRequired = false;</p>
			<p class="source-code">}</p>
			<p>First, we set <strong class="source-inline">m_Playing</strong> to false to stop parts of the <strong class="source-inline">update</strong> function from executing. Next, we loop through all the horizontal arrays within <strong class="source-inline">m_ArrayLevel</strong> and delete them. After the <strong class="source-inline">for</strong> loop, we delete <strong class="source-inline">m_ArrayLevel</strong> itself.</p>
			<p><strong class="source-inline">m_ArrayLevel = m_LM.nextLevel(m_VALevel)</strong> calls <strong class="source-inline">nextLevel</strong> and prepares the <strong class="source-inline">VertexArray</strong>  <strong class="source-inline">m_VALevel</strong>, as well as the two-dimensional array known as <strong class="source-inline">m_ArrayLevel</strong>. The level is set up and ready to go.</p>
			<p><strong class="source-inline">m_TimeRemaining</strong> is initialized by calling <strong class="source-inline">getTimeLimit</strong> and Thomas and Bob are spawned using the <strong class="source-inline">spawn</strong> function, along with the value returned from <strong class="source-inline">getStartPosition</strong>.</p>
			<p>Finally, <strong class="source-inline">m_NewLevelRequired</strong> is set to <strong class="source-inline">false</strong>. As we will see in a few pages time, <strong class="source-inline">m_NewLevelRequired</strong> being set to <strong class="source-inline">true</strong> causes <strong class="source-inline">loadLevel</strong> to be called. We only want to run this function once.</p>
			<h1 id="_idParaDest-323"><a id="_idTextAnchor333"/>Updating the engine</h1>
			<p>Open the <strong class="source-inline">Engine.cpp</strong> file and add the following highlighted code to load the sprite-sheet texture at the end of the Engine constructor:</p>
			<p class="source-code">Engine::Engine()</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Get the screen resolution and create an SFML window and View</p>
			<p class="source-code">    Vector2f resolution;</p>
			<p class="source-code">    resolution.x = VideoMode::getDesktopMode().width;</p>
			<p class="source-code">    resolution.y = VideoMode::getDesktopMode().height;</p>
			<p class="source-code">    m_Window.create(VideoMode(resolution.x, resolution.y),</p>
			<p class="source-code">        "Thomas was late",</p>
			<p class="source-code">        Style::Fullscreen);</p>
			<p class="source-code">    // Initialize the full screen view</p>
			<p class="source-code">    m_MainView.setSize(resolution);</p>
			<p class="source-code">    m_HudView.reset(</p>
			<p class="source-code">        FloatRect(0, 0, resolution.x, resolution.y));</p>
			<p class="source-code">    // Initialize the split-screen Views</p>
			<p class="source-code">    m_LeftView.setViewport(</p>
			<p class="source-code">        FloatRect(0.001f, 0.001f, 0.498f, 0.998f));</p>
			<p class="source-code">    m_RightView.setViewport(</p>
			<p class="source-code">        FloatRect(0.5f, 0.001f, 0.499f, 0.998f));</p>
			<p class="source-code">    m_BGLeftView.setViewport(</p>
			<p class="source-code">        FloatRect(0.001f, 0.001f, 0.498f, 0.998f));</p>
			<p class="source-code">    m_BGRightView.setViewport(</p>
			<p class="source-code">        FloatRect(0.5f, 0.001f, 0.499f, 0.998f));</p>
			<p class="source-code">    // Can this graphics card use shaders?</p>
			<p class="source-code">    if (!sf::Shader::isAvailable())</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Time to get a new PC</p>
			<p class="source-code">        m_Window.close();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    m_BackgroundTexture = TextureHolder::GetTexture(</p>
			<p class="source-code">        "graphics/background.png");</p>
			<p class="source-code">    // Associate the sprite with the texture</p>
			<p class="source-code">    m_BackgroundSprite.setTexture(m_BackgroundTexture);</p>
			<p class="source-code"><strong class="bold">    // Load the texture for the background vertex array</strong></p>
			<p class="source-code"><strong class="bold">    m_TextureTiles = TextureHolder::GetTexture(</strong></p>
			<p class="source-code"><strong class="bold">        "graphics/tiles_sheet.png");</strong></p>
			<p class="source-code">}</p>
			<p>All we do in the previous code is load the sprite-sheet into <strong class="source-inline">m_TextureTiles</strong>.</p>
			<p>Open the <strong class="source-inline">Update.cpp</strong> file and make the following highlighted changes and additions:</p>
			<p class="source-code">void Engine::update(float dtAsSeconds)</p>
			<p class="source-code">{</p>
			<p class="source-code">    if (m_NewLevelRequired)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // These calls to spawn will be moved to a new</p>
			<p class="source-code">        // loadLevel function soon</p>
			<p class="source-code">        // Spawn Thomas and Bob</p>
			<p class="source-code"><strong class="bold">        //m_Thomas.spawn(Vector2f(0,0), GRAVITY);</strong></p>
			<p class="source-code"><strong class="bold">        //m_Bob.spawn(Vector2f(100, 0), GRAVITY);</strong></p>
			<p class="source-code">        // Make sure spawn is called only once</p>
			<p class="source-code"><strong class="bold">        //m_TimeRemaining = 10;</strong></p>
			<p class="source-code"><strong class="bold">        //m_NewLevelRequired = false;</strong></p>
			<p class="source-code"><strong class="bold">        // Load a level</strong></p>
			<p class="source-code"><strong class="bold">        loadLevel();</strong></p>
			<p class="source-code">        </p>
			<p class="source-code">    }</p>
			<p>Actually, we should delete, rather than comment out, the lines we are no longer using. I have just shown it in this way so that the changes are clear. All there should be in the previous <strong class="source-inline">if</strong> statement is the call to <strong class="source-inline">loadLevel</strong>.</p>
			<p>Finally, before we can see the results of the work we've done so far in this chapter, open the <strong class="source-inline">Draw.cpp</strong> file and make the following highlighted additions to draw the vertex array that represents a level:</p>
			<p class="source-code">void Engine::draw()</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Rub out the last frame</p>
			<p class="source-code">    m_Window.clear(Color::White);</p>
			<p class="source-code">    if (!m_SplitScreen)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Switch to background view</p>
			<p class="source-code">        m_Window.setView(m_BGMainView);</p>
			<p class="source-code">        // Draw the background</p>
			<p class="source-code">        m_Window.draw(m_BackgroundSprite);</p>
			<p class="source-code">        // Switch to m_MainView</p>
			<p class="source-code">        m_Window.setView(m_MainView);        </p>
			<p class="source-code"><strong class="bold">        // Draw the Level</strong></p>
			<p class="source-code"><strong class="bold">        m_Window.draw(m_VALevel, &amp;m_TextureTiles);</strong></p>
			<p class="source-code">        // Draw thomas</p>
			<p class="source-code">        m_Window.draw(m_Thomas.getSprite());</p>
			<p class="source-code">        // Draw bob</p>
			<p class="source-code">        m_Window.draw(m_Bob.getSprite());</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Split-screen view is active</p>
			<p class="source-code">        // First draw Thomas' side of the screen</p>
			<p class="source-code">        // Switch to background view</p>
			<p class="source-code">        m_Window.setView(m_BGLeftView);</p>
			<p class="source-code">        // Draw the background</p>
			<p class="source-code">        m_Window.draw(m_BackgroundSprite);</p>
			<p class="source-code">        // Switch to m_LeftView</p>
			<p class="source-code">        m_Window.setView(m_LeftView);</p>
			<p class="source-code"><strong class="bold">        // Draw the Level</strong></p>
			<p class="source-code"><strong class="bold">        m_Window.draw(m_VALevel, &amp;m_TextureTiles);</strong></p>
			<p class="source-code">            </p>
			<p class="source-code">        // Draw bob</p>
			<p class="source-code">        m_Window.draw(m_Bob.getSprite());</p>
			<p class="source-code">        // Draw thomas</p>
			<p class="source-code">        m_Window.draw(m_Thomas.getSprite());</p>
			<p class="source-code">        </p>
			<p class="source-code">        // Now draw Bob's side of the screen</p>
			<p class="source-code">        // Switch to background view</p>
			<p class="source-code">        m_Window.setView(m_BGRightView);</p>
			<p class="source-code">        // Draw the background</p>
			<p class="source-code">        m_Window.draw(m_BackgroundSprite);</p>
			<p class="source-code">        // Switch to m_RightView</p>
			<p class="source-code">        m_Window.setView(m_RightView);</p>
			<p class="source-code"><strong class="bold">        // Draw the Level</strong></p>
			<p class="source-code"><strong class="bold">        m_Window.draw(m_VALevel, &amp;m_TextureTiles);</strong></p>
			<p class="source-code">        // Draw thomas</p>
			<p class="source-code">        m_Window.draw(m_Thomas.getSprite());</p>
			<p class="source-code">        // Draw bob</p>
			<p class="source-code">        m_Window.draw(m_Bob.getSprite());</p>
			<p class="source-code">                </p>
			<p class="source-code">    }</p>
			<p class="source-code">    // Draw the HUD</p>
			<p class="source-code">    // Switch to m_HudView</p>
			<p class="source-code">    m_Window.setView(m_HudView);</p>
			<p class="source-code">    </p>
			<p class="source-code">    </p>
			<p class="source-code">    // Show everything we have just drawn</p>
			<p class="source-code">    m_Window.display();</p>
			<p class="source-code">}</p>
			<p>Note that we need to draw the <strong class="source-inline">VertexArray</strong> for all the screen options (full, left, and right).</p>
			<p>Now, you can run the game. Unfortunately, however, Thomas and Bob fall straight through all our lovingly designed platforms. Due to this, we can't try and progress through the levels and beat the clock.</p>
			<h1 id="_idParaDest-324"><a id="_idTextAnchor334"/>Collision detection</h1>
			<p>We will handle collision detection using rectangle intersection and the SFML <strong class="source-inline">intersects</strong> function. What will be different in this project is that we will abstract the collision detection code into its own function. Thomas and Bob, as we have already seen, have multiple rectangles (<strong class="source-inline">m_Head</strong>, <strong class="source-inline">m_Feet</strong>, <strong class="source-inline">m_Left</strong>, and <strong class="source-inline">m_Right</strong>) that we need to check for collisions.</p>
			<h2 id="_idParaDest-325"><a id="_idTextAnchor335"/>Coding the detectCollisions function</h2>
			<p>To be clear, this function is part of the <strong class="source-inline">Engine</strong> class. Open the <strong class="source-inline">Engine.h</strong> file and add a declaration for a function called <strong class="source-inline">detectCollisions</strong>. This is highlighted in the following code snippet:</p>
			<p class="source-code">    // Private functions for internal use only</p>
			<p class="source-code">    void input();</p>
			<p class="source-code">    void update(float dtAsSeconds);</p>
			<p class="source-code">    void draw();</p>
			<p class="source-code">    // Load a new level</p>
			<p class="source-code">    void loadLevel();</p>
			<p class="source-code"><strong class="bold">    bool detectCollisions(PlayableCharacter&amp; character);</strong></p>
			<p class="source-code">    </p>
			<p class="source-code">public:</p>
			<p class="source-code">    // The Engine constructor</p>
			<p class="source-code">    Engine();</p>
			<p>Notice from the signature that the <strong class="source-inline">detectCollision</strong> function takes a polymorphic argument as a <strong class="source-inline">PlayerCharacter</strong> object. As we know, <strong class="source-inline">PlayerCharacter</strong> is abstract and can never be instantiated. We do, however, inherit from it with the <strong class="source-inline">Thomas</strong> and <strong class="source-inline">Bob</strong> classes. We will be able to pass either <strong class="source-inline">m_Thomas</strong> or <strong class="source-inline">m_Bob</strong> to <strong class="source-inline">detectCollisions</strong>.</p>
			<p>Right-click <strong class="bold">Source Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">C++ File (.cpp)</strong> and then, in the <strong class="bold">Name</strong> field, type <strong class="source-inline">DetectCollisions.cpp</strong>. Finally, click the <strong class="bold">Add</strong> button. We are now ready to code the <strong class="source-inline">detectCollisions </strong>function.</p>
			<p>Add the following code to <strong class="source-inline">DetectCollisions.cpp</strong>. Note that this is just the first part of this function:</p>
			<p class="source-code">#include "Engine.h"</p>
			<p class="source-code">bool Engine::detectCollisions(PlayableCharacter&amp; character)</p>
			<p class="source-code">{</p>
			<p class="source-code">    bool reachedGoal = false;</p>
			<p class="source-code">    // Make a rect for all his parts</p>
			<p class="source-code">    FloatRect detectionZone = character.getPosition();</p>
			<p class="source-code">    // Make a FloatRect to test each block</p>
			<p class="source-code">    FloatRect block;</p>
			<p class="source-code">    block.width = TILE_SIZE;</p>
			<p class="source-code">    block.height = TILE_SIZE;</p>
			<p class="source-code">    // Build a zone around thomas to detect collisions</p>
			<p class="source-code">    int startX = (int)(detectionZone.left / TILE_SIZE) - 1;</p>
			<p class="source-code">    int startY = (int)(detectionZone.top / TILE_SIZE) - 1;</p>
			<p class="source-code">    int endX = (int)(detectionZone.left / TILE_SIZE) + 2;</p>
			<p class="source-code">    // Thomas is quite tall so check a few tiles vertically</p>
			<p class="source-code">    int endY = (int)(detectionZone.top / TILE_SIZE) + 3;</p>
			<p class="source-code">    // Make sure we don't test positions lower than zero</p>
			<p class="source-code">    // Or higher than the end of the array</p>
			<p class="source-code">    if (startX &lt; 0)startX = 0;</p>
			<p class="source-code">    if (startY &lt; 0)startY = 0;</p>
			<p class="source-code">    if (endX &gt;= m_LM.getLevelSize().x)</p>
			<p class="source-code">        endX = m_LM.getLevelSize().x;</p>
			<p class="source-code">    if (endY &gt;= m_LM.getLevelSize().y)</p>
			<p class="source-code">        endY = m_LM.getLevelSize().y;</p>
			<p>The first thing that we do is declare a Boolean called <strong class="source-inline">reachedGoal</strong>. This is the value that the <strong class="source-inline">detectCollisions</strong> function returns to the calling code. It is initialized to <strong class="source-inline">false</strong>.</p>
			<p>Next, we declare a <strong class="source-inline">FloatRect</strong> object called <strong class="source-inline">detectionZone</strong> and initialize it with the same rectangle that represents the entire rectangle of the character sprite. Note that we will not actually do intersection tests with this rectangle. After, we declare another <strong class="source-inline">FloatRect</strong> called <strong class="source-inline">block</strong>. We initialize <strong class="source-inline">block</strong> as a 50 by 50 game unit rectangle. We will see <strong class="source-inline">block</strong> in use shortly.</p>
			<p>Next, we will look at how we will use <strong class="source-inline">detectionZone</strong>. We initialize four <strong class="source-inline">int</strong> variables, <strong class="source-inline">startX</strong>, <strong class="source-inline">startY</strong>, <strong class="source-inline">endX</strong>, and <strong class="source-inline">endY</strong>, by expanding the area around <strong class="source-inline">detectionZone</strong> by a few blocks. In the four <strong class="source-inline">if</strong> statements that follow, we check that it is not possible to try and do collision detection on a tile that does not exist. We will achieve this by making sure we never check positions less than zero or greater than the value returned by <strong class="source-inline">getLevelSize().x</strong> or <strong class="source-inline">.y</strong>. </p>
			<p>What all this previous code has done is create an area that is used to do collision detection. There is no point doing collision detection on a block that is hundreds or thousands of pixels away from the character. In addition, if we try and do collision detection where an array position doesn't exist (less than zero or greater than <strong class="source-inline">getLevelSize()...</strong>), the game will crash. </p>
			<p>Next, add the following code, which handles the player falling out of the level:</p>
			<p class="source-code">    // Has the character fallen out of the map?</p>
			<p class="source-code">    FloatRect level(0, 0, </p>
			<p class="source-code">        m_LM.getLevelSize().x * TILE_SIZE, </p>
			<p class="source-code">        m_LM.getLevelSize().y * TILE_SIZE);</p>
			<p class="source-code">    </p>
			<p class="source-code">    if (!character.getPosition().intersects(level))</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // respawn the character</p>
			<p class="source-code">        character.spawn(m_LM.getStartPosition(), GRAVITY);</p>
			<p class="source-code">    }</p>
			<p>For a character to stop falling, it must collide with a platform. Therefore, if the player moves out of the map (where there are no platforms), they will continuously fall. The previous code checks whether the character <em class="italic">does not</em> intersect with the <strong class="source-inline">FloatRect</strong>, <strong class="source-inline">level</strong>. If it does not, then it has fallen out of the level and the <strong class="source-inline">spawn</strong> function sends it back to the start.</p>
			<p>Add the following, quite long. code block and then we will go through what it does:</p>
			<p class="source-code">    // Loop through all the local blocks</p>
			<p class="source-code">    for (int x = startX; x &lt; endX; x++)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        for (int y = startY; y &lt; endY; y++)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            // Initialize the starting position of the current block</p>
			<p class="source-code">            block.left = x * TILE_SIZE;</p>
			<p class="source-code">            block.top = y * TILE_SIZE;</p>
			<p class="source-code">            // Has character been burnt or drowned?</p>
			<p class="source-code">            // Use head as this allows him to sink a bit</p>
			<p class="source-code">            if (m_ArrayLevel[y][x] == 2 || m_ArrayLevel[y][x] == 3)</p>
			<p class="source-code">            {</p>
			<p class="source-code">                if (character.getHead().intersects(block))</p>
			<p class="source-code">                {</p>
			<p class="source-code">                    character.spawn(m_LM.getStartPosition(), GRAVITY);</p>
			<p class="source-code">                    // Which sound should be played?</p>
			<p class="source-code">                    if (m_ArrayLevel[y][x] == 2)// Fire, ouch!</p>
			<p class="source-code">                    {</p>
			<p class="source-code">                        // Play a sound</p>
			<p class="source-code">                    }</p>
			<p class="source-code">                    else // Water</p>
			<p class="source-code">                    {</p>
			<p class="source-code">                        // Play a sound</p>
			<p class="source-code">                    }</p>
			<p class="source-code">                }</p>
			<p class="source-code">            }</p>
			<p class="source-code">            </p>
			<p class="source-code">            // Is character colliding with a regular block</p>
			<p class="source-code">            if (m_ArrayLevel[y][x] == 1)</p>
			<p class="source-code">            {</p>
			<p class="source-code">                if (character.getRight().intersects(block))</p>
			<p class="source-code">                {</p>
			<p class="source-code">                    character.stopRight(block.left);</p>
			<p class="source-code">                }</p>
			<p class="source-code">                else if (character.getLeft().intersects(block))</p>
			<p class="source-code">                {</p>
			<p class="source-code">                    character.stopLeft(block.left);</p>
			<p class="source-code">                }</p>
			<p class="source-code">                if (character.getFeet().intersects(block))</p>
			<p class="source-code">                {</p>
			<p class="source-code">                    character.stopFalling(block.top);</p>
			<p class="source-code">                }</p>
			<p class="source-code">                else if (character.getHead().intersects(block))</p>
			<p class="source-code">                {</p>
			<p class="source-code">                    character.stopJump();</p>
			<p class="source-code">                }</p>
			<p class="source-code">            }</p>
			<p class="source-code">            </p>
			<p class="source-code">            // More collision detection here once we have </p>
			<p class="source-code">            // learned about particle effects</p>
			<p class="source-code">            // Has the character reached the goal?</p>
			<p class="source-code">            if (m_ArrayLevel[y][x] == 4)</p>
			<p class="source-code">            {</p>
			<p class="source-code">                // Character has reached the goal</p>
			<p class="source-code">                reachedGoal = true;</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p>The previous code does three things using the same techniques. It loops through all the values contained between <strong class="source-inline">startX</strong>, <strong class="source-inline">endX</strong>, and <strong class="source-inline">startY</strong>, <strong class="source-inline">endY</strong>. For each pass, it checks and does the following:</p>
			<ul>
				<li>Has the character been burned or drowned? <strong class="source-inline">if (m_ArrayLevel[y][x] == 2 || m_ArrayLevel[y][x] == 3)</strong> determines whether the current position being checked is a fire or a water tile. If the character's head intersects with one of these tiles, the player is respawned. We also code an empty <strong class="source-inline">if</strong>/<strong class="source-inline">else</strong> block in preparation to add sound in the next chapter.</li>
				<li>Has the character touched a regular tile? <strong class="source-inline">code if (m_ArrayLevel[y][x] == 1)</strong> determines whether the current position being checked holds a regular tile. If it intersects with any of the rectangles that represent the various body parts of the character, then the related function is called (<strong class="source-inline">stopRight</strong>, <strong class="source-inline">stopLeft</strong>, <strong class="source-inline">stopFalling</strong>, or <strong class="source-inline">stopJump</strong>). The value that is passed to each of these functions and how the function uses that value to reposition the character is quite nuanced. While it is not necessary to closely examine these values to understand the code, we might like to look at the values that are passed in and then refer to the appropriate function of the <strong class="source-inline">PlayableCharacter</strong> class in the previous chapter. This will help you appreciate exactly what is going on.</li>
				<li>Has the character touched the goal tile? This is determined with <strong class="source-inline">if (m_ArrayLevel[y][x] == 4)</strong>. All we need to do is set <strong class="source-inline">reachedGoal</strong> to <strong class="source-inline">true</strong>. The <strong class="source-inline">update</strong> function of the <strong class="source-inline">Engine</strong> class will keep track of whether both characters (Thomas and Bob) have reached the goal simultaneously. We will write this code in the <strong class="source-inline">update</strong> function in just a minute.</li>
			</ul>
			<p>Add the following line of code to the <strong class="source-inline">detectCollisions</strong> function:</p>
			<p class="source-code">    // All done, return, whether or </p>
			<p class="source-code">   // not a new level might be required</p>
			<p class="source-code">    return reachedGoal;</p>
			<p class="source-code">}</p>
			<p>The previous line of code returns the <strong class="source-inline">reachedGoal</strong> Boolean value so that the calling code can keep track and respond appropriately if both characters simultaneously reach the goal.</p>
			<p>All we need to do now is call the <strong class="source-inline">detectCollision</strong> function once per character, per frame. Add the following highlighted code in the <strong class="source-inline">Update.cpp</strong> file within the <strong class="source-inline">if(m_Playing)</strong> block of code:</p>
			<p class="source-code">if (m_Playing)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Update Thomas</p>
			<p class="source-code">    m_Thomas.update(dtAsSeconds);</p>
			<p class="source-code">    // Update Bob</p>
			<p class="source-code">    m_Bob.update(dtAsSeconds);</p>
			<p class="source-code"><strong class="bold">    // Detect collisions and see if characters </strong></p>
			<p class="source-code"><strong class="bold">    // have reached the goal tile</strong></p>
			<p class="source-code"><strong class="bold">    // The second part of the if condition is only executed</strong></p>
			<p class="source-code"><strong class="bold">    // when thomas is touching the home tile</strong></p>
			<p class="source-code"><strong class="bold">    if (detectCollisions(m_Thomas) &amp;&amp; detectCollisions(m_Bob))</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        // New level required</strong></p>
			<p class="source-code"><strong class="bold">        m_NewLevelRequired = true;</strong></p>
			<p class="source-code"><strong class="bold">        // Play the reach goal sound    </strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code"><strong class="bold">    else</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        // Run bobs collision detection</strong></p>
			<p class="source-code"><strong class="bold">        detectCollisions(m_Bob);</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">    // Count down the time the player has left</p>
			<p class="source-code">    m_TimeRemaining -= dtAsSeconds;</p>
			<p class="source-code">    // Have Thomas and Bob run out of time?</p>
			<p class="source-code">    if (m_TimeRemaining &lt;= 0)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_NewLevelRequired = true;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}// End if playing</p>
			<p>The previous code calls the <strong class="source-inline">detectCollision</strong> function and checks if both Bob and Thomas have simultaneously reached the goal. If they have, then the next level is prepared by setting <strong class="source-inline">m_NewLevelRequired</strong> to <strong class="source-inline">true</strong>.</p>
			<p>You can run the game and walk on the platforms. You can reach the goal and start a new level. Also, for the first time, the jump button (<em class="italic">W </em>or <em class="italic">Up</em> arrow) will work. </p>
			<p>If you reach the goal, then the next level will load. If you reach the goal of the last level, then the first level will load with a 10% reduced time limit. Of course, there is no visual feedback for the time or the current level because we haven't built a HUD yet. We will do so in the next chapter.</p>
			<p>Many of the levels, however, require Thomas and Bob to work as a team. More specifically, Thomas and Bob need to be able to climb on each other's heads.</p>
			<h2 id="_idParaDest-326"><a id="_idTextAnchor336"/>More collision detection</h2>
			<p>Add the following code just after you added the previous code in the <strong class="source-inline">Update.cpp</strong> file, within the <strong class="source-inline">if (m_Playing)</strong> section:</p>
			<p class="source-code">if (m_Playing)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Update Thomas</p>
			<p class="source-code">    m_Thomas.update(dtAsSeconds);</p>
			<p class="source-code">    // Update Bob</p>
			<p class="source-code">    m_Bob.update(dtAsSeconds);</p>
			<p class="source-code">    // Detect collisions and see if characters </p>
			<p class="source-code">    // have reached the goal tile</p>
			<p class="source-code">    // The second part of the if condition is only executed</p>
			<p class="source-code">    // when thomas is touching the home tile</p>
			<p class="source-code">    if (detectCollisions(m_Thomas) &amp;&amp; detectCollisions(m_Bob))</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // New level required</p>
			<p class="source-code">        m_NewLevelRequired = true;</p>
			<p class="source-code">        // Play the reach goal sound</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Run bobs collision detection</p>
			<p class="source-code">        detectCollisions(m_Bob);</p>
			<p class="source-code">    }</p>
			<p class="source-code"><strong class="bold">    // Let bob and thomas jump on each others heads</strong></p>
			<p class="source-code"><strong class="bold">    if (m_Bob.getFeet().intersects(m_Thomas.getHead()))</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        m_Bob.stopFalling(m_Thomas.getHead().top);</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code"><strong class="bold">    else if (m_Thomas.getFeet().intersects(m_Bob.getHead()))</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        m_Thomas.stopFalling(m_Bob.getHead().top);</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">    // Count down the time the player has left</p>
			<p class="source-code">    m_TimeRemaining -= dtAsSeconds;</p>
			<p class="source-code">    // Have Thomas and Bob run out of time?</p>
			<p class="source-code">    if (m_TimeRemaining &lt;= 0)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_NewLevelRequired = true;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}// End if playing</p>
			<p>You can run the game again and stand on the heads of Thomas and Bob to get to the hard-to-reach places that were previously not possible to get to:</p>
			<div>
				<div id="_idContainer108" class="IMG---Figure">
					<img src="image/B14278_16_09.jpg" alt=""/>
				</div>
			</div>
			<h1 id="_idParaDest-327"><a id="_idTextAnchor337"/>Summary</h1>
			<p><a id="_idTextAnchor338"/>There was quite a lot of code in this chapter. We learned how to read from a file and convert strings of text into <strong class="source-inline">char</strong> values and then into int <strong class="source-inline">values</strong>. Once we had a two-dimensional array of <strong class="source-inline">int</strong> values, we were able to populate a <strong class="source-inline">VertexArray</strong> instance to show the level on the screen. We then used the same two-dimensional array of <strong class="source-inline">int</strong> values to implement collision detection. We used rectangle intersection, just like we did in the Zombie Arena project, although this time, for more precision, we gave each character four collision zones – one each to represent their head, feet, left, and right-hand sides.</p>
			<p>Now that the game is totally playable, we need to represent the state of the game (score and time) on the screen. In the next chapter, we will implement the HUD, along with some much more advanced sound effects than we have used so far.</p>
		</div>
	</body></html>