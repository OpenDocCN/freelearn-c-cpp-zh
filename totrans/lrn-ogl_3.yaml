- en: Transformations, Projections, and Camera
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变换、投影和相机
- en: In the previous chapter, we discussed about how to create shapes in OpenGL using
    our libraries. We learned to add colors to our shapes and we'll also discussed
    how to add texture to the shapes. This chapter will be the continuation of the
    previous chapter and we'll discuss how to apply transformations such as rotation
    or translate to our shapes. We'll also discuss the projection and the coordinate
    system and try to implement that in our game world. You'll also get to learn about
    the camera class and we'll use that to view and navigate through our multiple
    objects we'll create in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们讨论了如何使用我们的库在 OpenGL 中创建形状。我们学习了如何给形状添加颜色，并讨论了如何给形状添加纹理。本章将是前一章的延续，我们将讨论如何将旋转或平移等变换应用到我们的形状上。我们还将讨论投影和坐标系统，并尝试在我们的游戏世界中实现它们。您还将了解相机类，我们将使用它来观察和导航我们在本章中创建的多个对象。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Applying transformations such as rotations and translate to our shapes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将旋转和平移等变换应用到我们的形状上
- en: Implementation of projection and the coordinate system in the game world
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏世界中投影和坐标系统的实现
- en: Adding multiple objects to our game world
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多个对象添加到我们的游戏世界中
- en: Creating and using camera class for a better view of objects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用相机类以更好地观察对象
- en: So let's begin...
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧...
- en: You can refer to all the code files for this chapter in the `Chapter03` folder
    on GitHub. The GitHub link can be found in the preface of the book.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 的 `Chapter03` 文件夹中找到本章的所有代码文件。GitHub 链接可以在书的序言中找到。
- en: Transformations using GLM
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GLM 进行变换
- en: We'll be looking at making transformations to our shape and the texture applied
    to it. To do the transformations, we'll be using the OpenGL Mathematics library
    that is GLM. For transformations, we need to use vectors and matrices, and GLM
    handles a lot of that in the backend for us. All we have to do is call the correct
    method (for example, translate or rotate), and it'll do the appropriate matrices
    and vector transformations for us.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何对我们的形状及其应用的纹理进行变换。为了进行变换，我们将使用 OpenGL 数学库 GLM。对于变换，我们需要使用向量和矩阵，GLM 在后台为我们处理了很多。我们只需要调用正确的方法（例如，平移或旋转），它就会为我们执行适当的矩阵和向量变换。
- en: It is recommended that you go to [learnopengl.com](https://learnopengl.com/)
    and [open.gl](https://www.opengl.org/). These sites have got some great resources
    that showcase all the different vectors and matrices and how to use them, and
    it goes into more depth about the mathematics behind it. So, if you're interested,
    you should definitely visit these sites.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您访问 [learnopengl.com](https://learnopengl.com/) 和 [open.gl](https://www.opengl.org/)。这些网站提供了一些非常棒的资源，展示了所有不同的向量和矩阵以及如何使用它们，并且深入探讨了背后的数学原理。所以，如果您感兴趣，您绝对应该访问这些网站。
- en: Setting up a project to use GLM on Windows / Mac
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Windows / Mac 上设置使用 GLM 的项目
- en: So, to begin with, we need to download and install the GLM library onto our
    system. It's very similar to installing the other frameworks that we learned to
    install in the previous chapters, whether it's GLFW, SDL, or SFML. But if you
    wish to review this, please refer to the *Setting up a project to use SOIL on
    Windows or Mac* section in [Chapter 2](674fc755-f955-4a25-b241-bd882af16879.xhtml),
    *Drawing Shapes and Applying Textures*. The setup process for GLM will be very
    much similar to what was discussed in the mentioned section. For the further sections
    we'll assume that you've install the GLM library in your system and set the project
    up too.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在我们的系统上下载并安装 GLM 库。这与其他我们在前几章中学到的安装框架非常相似，无论是 GLFW、SDL 还是 SFML。但如果你希望复习这部分内容，请参考[第
    2 章](674fc755-f955-4a25-b241-bd882af16879.xhtml)中“在 Windows 或 Mac 上设置项目以使用 SOIL”部分，*绘制形状和应用纹理*。GLM
    的设置过程将与该部分讨论的内容非常相似。对于后续章节，我们将假设你已经安装了 GLM 库并设置了项目。
- en: Now that the GLM library is installed and our project is setup, let's move on
    to make some modifications to our code so that we can transform our shapes and
    textures applied to it. In further sections, we'll make some modifications to
    our code from the previous chapter to transform our shapes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在GLM库已经安装，我们的项目也已设置好，接下来让我们对代码进行一些修改，以便我们可以变换应用到形状上的形状和纹理。在后续章节中，我们将对前一章的代码进行修改，以变换我们的形状。
- en: So, to begin with, we will first need to update our shader files.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，我们需要更新我们的着色器文件。
- en: Updating shader files
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新着色器文件
- en: 'Let''s follow the below mentioned steps to update the shader files:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们遵循以下步骤来更新着色器文件：
- en: 'We''ll go to our vertex shader that is `core.vs` file and perform the following
    highlighted modifications to the code:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将转到我们的顶点着色器，即`core.vs`文件，并对代码进行以下高亮显示的修改：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For the fragment shader, we don't need to do anything as we'll be requiring
    that code as it is.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于片段着色器，我们不需要做任何事情，因为我们将会以原样要求这段代码。
- en: Now we can go to `main.cpp` and carry out the modification to our main code
    to apply transformations to our objects.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以转到`main.cpp`并修改我们的主代码，以将变换应用于我们的对象。
- en: Applying transformations to the objects
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将变换应用于对象
- en: 'Take a look at the following steps to understand the modifications that we
    need to carry out to incorporate transformations in our main code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下步骤，以了解我们需要在我们的主代码中实现哪些修改以包含变换：
- en: 'To make changes to our main code, we''ll begin by including the `GLM` header
    file in our code, so add the following highlighted include terms in your code:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要修改我们的主代码，我们首先需要在代码中包含`GLM`头文件，所以请在您的代码中添加以下高亮显示的包含项：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The next thing that we are going to do is create the transformation matrix
    that we want to apply. To do this, go to the while loop, and somewhere in the
    loop between defining the shader and activating the texture we''ll need to add
    the code described as follows:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接下来要做的事情是创建我们想要应用的变换矩阵。为此，进入while循环，并在定义着色器和激活纹理之间的循环中，我们需要添加以下描述的代码：
- en: First of all, we're going to just create the transformation matrix. So, we'll
    begin by typing `glm::mat4` and we'll call it `transform`.
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将只创建变换矩阵。因此，我们将开始输入`glm::mat4`，并将其命名为`transform`。
- en: Then we'll add the type of transformation. For the translate transformation
    we'll define it as `transform = glm::translate();`. For the `translate ()` function,
    the first parameter that we will need to specify is the 4x4 matrix that we're
    going to use. Next, we'll specify the vector, which is `glm::vec3()`. This takes
    three parameters—the x, y, and z coordinates—and for those we'll pass the values
    `0.5f` , `-0.5f` and `0.0f`. Remember, the values should range between -1 and
    1, for now.
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将添加变换的类型。对于平移变换，我们将定义为`transform = glm::translate();`。对于`translate()`函数，我们需要指定的第一个参数是我们将要使用的4x4矩阵。接下来，我们将指定向量，它是`glm::vec3()`。这需要三个参数——x、y和z坐标——对于这些，我们将传递值`0.5f`、`-0.5f`和`0.0f`。记住，这些值应该在-1和1之间，目前是这样的。
- en: 'Next, we''ll define the rotate transformation, `transform = glm::rotate()`,
    and for the `rotate()` function we''ll pass parameters: for the `matrix`, we''re
    going to specify `transform` again. For the `angle`, we need to state how much
    we want it to rotate by, because we don''t want it just to rotate once. We want
    it to constantly rotate. Therefore, we''ll add `glfwGetTime()` and cast it to
    `GLfloat`. The `glfwGetTime()` function will be the amount of time that has passed
    since GLFW was initialized and use that to rotate our object.'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将定义旋转变换，`transform = glm::rotate()`，对于`rotate()`函数，我们将传递参数：对于`matrix`，我们将再次指定`transform`。对于`angle`，我们需要说明我们希望它旋转多少，因为我们不希望它只旋转一次。我们希望它持续旋转。因此，我们将添加`glfwGetTime()`并将其转换为`GLfloat`。`glfwGetTime()`函数将是从GLFW初始化以来经过的时间量，我们将使用它来旋转我们的对象。
- en: 'For more information on **time methods**, you can visit the following links:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 关于**时间方法**的更多信息，您可以访问以下链接：
- en: for GLFW time input, visit [https://www.glfw.org/docs/3.0/group__time.html](https://www.glfw.org/docs/3.0/group__time.html);
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于GLFW时间输入，请访问[https://www.glfw.org/docs/3.0/group__time.html](https://www.glfw.org/docs/3.0/group__time.html)；
- en: for SDL time input, you can use the `SDL_GetTicks` method and read the information
    at [https://wiki.libsdl.org/SDL_GetTicks](https://wiki.libsdl.org/SDL_GetTicks);
    and, for SFML, you can use the `getElapsedTime` method and for more info on that
    you can visit [https://www.sfml-dev.org/tutorials/2.5/system-time.php](https://www.sfml-dev.org/tutorials/2.5/system-time.php)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SDL时间输入，您可以使用`SDL_GetTicks`方法，并在[https://wiki.libsdl.org/SDL_GetTicks](https://wiki.libsdl.org/SDL_GetTicks)上读取信息；对于SFML，您可以使用`getElapsedTime`方法，并且有关更多信息，您可以访问[https://www.sfml-dev.org/tutorials/2.5/system-time.php](https://www.sfml-dev.org/tutorials/2.5/system-time.php)。
- en: We will need to time the method so that the texture rotates at a certain speed.
    So, we will multiply the method `glfwGetTime( )` by `-5.0f`. This will make the
    object rotate in one way. If you add a positive number, it rotates the other way.
    Try experimenting with the value. By increasing the value you will make it rotate
    faster, and by reducing the value you will make it go slower.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要调整方法的时间，以便纹理以一定的速度旋转。所以，我们将方法 `glfwGetTime( )` 乘以 `-5.0f`。这将使物体以一个方向旋转。如果你添加一个正数，它将以另一个方向旋转。尝试调整这个值。通过增加值，你会使它旋转得更快，而通过减少值，你会使它旋转得更慢。
- en: The third parameter that we need to pass is `glm::vec3()`, and for the vector
    you have to specify what axes you want the shapes to rotate around. So, either
    use `1.0f` or `0.0f`. Adding `0.0f` means you don't want it to rotate around that
    particular axis. So, we'll define it as `0.0f, 0.0f, 1.0f`. This means that our
    texture will rotate around the z axis. The reason we've chosen z is because, at
    the moment, we're not doing anything in 3D. So, by rotating round the z axis,
    it'll just look like it's a 2D transformation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要传递的第三个参数是 `glm::vec3()`，对于这个向量，你必须指定形状要围绕哪个轴旋转。所以，你可以使用 `1.0f` 或 `0.0f`。添加
    `0.0f` 表示你不想围绕该特定轴旋转。因此，我们将它定义为 `0.0f, 0.0f, 1.0f`。这意味着我们的纹理将围绕 z 轴旋转。我们选择 z 的原因是因为，目前我们并没有在
    3D 中做任何事情。所以，通过围绕 z 轴旋转，它看起来就像是一个 2D 变换。
- en: 'Take a look at the following code to get a clear understanding of the preceding
    description:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下代码以获得对先前描述的清晰理解：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that we''ve created our transformation matrix, we can actually get on to
    applying it. Therefore, we need to get the matrix uniform location and set the
    matrix up for our shader to use. So we need to create a `GLint` variable `transformLocation`
    and to that we''ll assign the value of `glGetUniformLocation()`, and to this function
    need to pass `ourShader.Program` and our transformation matrix `"transform"`.
    Next, we need to define uniform matrix in our code, so add the `glUniformMatrix4fv()`
    function to our code, and this takes a few parameters. First of all is the `transformLocation`,
    then `1`, and then `GL_FALSE` and `glm::value_ptr()`, and to this function we
    need to specify the transformation matrix that we''re using:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了变换矩阵，我们可以开始应用它。因此，我们需要获取矩阵的统一位置，并设置矩阵以便我们的着色器可以使用。所以我们需要创建一个 `GLint`
    变量 `transformLocation`，并将其分配给 `glGetUniformLocation()` 的值，并将此函数传递给 `ourShader.Program`
    和我们的变换矩阵 `"transform"`。接下来，我们需要在我们的代码中定义统一矩阵，所以将 `glUniformMatrix4fv()` 函数添加到我们的代码中，这个函数需要一些参数。首先，是
    `transformLocation`，然后是 `1`，然后是 `GL_FALSE` 和 `glm::value_ptr()`，并在此函数中指定我们使用的变换矩阵：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you want to know more about what these parameters are doing, it is recommended
    that you check out [learnopengl.com](http://learnopengl.com) and [open.gl](http://open.gl),
    because these sites explain a lot of this in more depth.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于这些参数的作用，建议你查看 [learnopengl.com](http://learnopengl.com) 和 [open.gl](http://open.gl)，因为这些网站对这些内容进行了更深入的讲解。
- en: 'And now we''re all set and ready to run. If we run this, we should get our
    image rotating in the top-right corner, as shown in the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置完毕，准备运行。如果我们运行这个程序，我们的图像应该会在右上角旋转，如下面的截图所示：
- en: '![](img/465fb17b-3d25-4d0d-bc0b-4dc0d544e3a1.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/465fb17b-3d25-4d0d-bc0b-4dc0d544e3a1.png)'
- en: The illustration used in this chapter is for explanatory purposes only. We do
    not recommend you to misuse these in any way. For more information please consult
    the terms and conditions of the publisher mentioned in the Disclaimer section
    of this book.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的插图仅用于说明目的。我们不推荐你以任何方式误用这些内容。如需更多信息，请参阅本书免责声明部分中提到的出版商的条款和条件。
- en: 'It is recommended that you try experimenting with the following line of code
    to vary the location and speed of rotation:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 建议你尝试使用以下代码行来改变旋转的位置和速度：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Projections and coordinate systems
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 投影和坐标系
- en: 'In this section, we''re going to look at the projections and the coordinate
    systems. So let''s first understand what the coordinate systems are? There are
    two types of coordinate system: a left-handed and a right-handed coordinate system.
    The best way to visualize them is to put up both of your hands, as shown in the
    following image:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨投影和坐标系。所以，让我们首先了解坐标系是什么？有两种类型的坐标系：左手坐标系和右手坐标系。可视化它们最好的方法是举起你的双手，如下面的图片所示：
- en: '![](img/a4e1f039-aea0-4962-929b-cea2fbd1bd56.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a4e1f039-aea0-4962-929b-cea2fbd1bd56.png)'
- en: As per the image, the index fingers of both your hands should point up. Your
    middle fingers should point towards you and your thumbs should point to the left
    and right directions, respectively. Once you've done that, the direction that
    your fingers and your thumbs are pointing is the positive direction for that axis.
    So, the way the index finger is pointing (upward) is the positive y axis. The
    direction in which the middle finger is pointing is the positive z axis and the
    thumbs are pointing in the direction of the positive x axis. OpenGL uses the right-handed
    coordinate system, while the DirectX uses the left-handed coordinate system.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，你双手的食指应该指向上方。你的中指应该指向你，你的拇指应该分别指向左右方向。一旦你这样做，你的手指和拇指所指的方向就是该轴的正方向。所以，食指所指的方向（向上）是正y轴。中指所指的方向是正z轴，而拇指指向正x轴的方向。OpenGL使用右手坐标系，而DirectX使用左手坐标系。
- en: 'For more information on the coordinate system, you can check out the following
    links:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 关于坐标系统的更多信息，你可以查看以下链接：
- en: '[https://learnopengl.com/](https://learnopengl.com/) and [https://open.gl./](https://open.gl./)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://learnopengl.com/](https://learnopengl.com/) 和 [https://open.gl./](https://open.gl./)'
- en: Now that we've discussed the coordinate system, let's understand the different
    types of projection we've got in OpenGL. We have the perspective projection and
    orthographic projection. Perspective projection takes depth into consideration,
    which, generally speaking, every game in production would, whereas, orthographic
    projection doesn't take depth into consideration. So, in orthographic projection,
    an object or part of an object that is further away from you still looks the same
    size. If you have two identical objects and one is further away, it will still
    look the same size. However, in perspective projection, just like in real life,
    the object, that is further away would look smaller. You might be wondering, where
    orthographic projection would ever be useful? One example is in architecture,
    when you're creating a laid-out design and you want to have objects behind other
    objects, but, because you're giving measurements, you don't want them to vary
    in size.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了坐标系，让我们了解OpenGL中不同的投影类型。我们有透视投影和正交投影。透视投影考虑深度，一般来说，每个正在制作的游戏都会考虑这一点，而正交投影则不考虑深度。所以，在正交投影中，离你更远的物体或物体的部分看起来仍然是同样的大小。如果你有两个相同的物体，其中一个离你更远，它看起来仍然是同样的大小。然而，在透视投影中，就像在现实生活中一样，离你更远的物体会看起来更小。你可能想知道，正交投影在什么情况下会有用？一个例子是建筑，当你创建一个布局设计，你想要有物体在其它物体后面，但是，因为你提供了测量数据，你不想它们的大小发生变化。
- en: Modifications to the code
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码修改
- en: In this section, we will make some modifications to our texture code to integrate
    projection and coordinate system in our game world.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将对我们的纹理代码进行一些修改，以整合投影和坐标系到我们的游戏世界中。
- en: We'll begin our modifications by updating the shader files.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从更新着色器文件开始我们的修改。
- en: Making modifications to the shader files
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改着色器文件
- en: 'Check out the next steps to understand what modifications we need to do to
    our shader files:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 查看下一步骤以了解我们需要对着色器文件进行哪些修改：
- en: 'The first thing that we want to do is go to our vertex shader and carry out
    the following highlighted changes to the code:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要做的第一件事是进入我们的顶点着色器，并对代码进行以下突出显示的更改：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, we have removed all the color values because we are just
    using textures now. Second, we deleted the uniform matrix transform as well because
    we're going to use a few different ways of transforming. Third, we created a uniform
    4x4 matrix, which is going to be the model matrix. Fourth, we created a uniform
    4x4 matrix, which is the view matrix, and another uniform 4x4 matrix, which is
    the projection matrix. These three different types of matrices do very important
    stuff. The model matrix converts local-object coordinates to camera coordinates.
    The projection matrix converts the camera coordinates to normalized coordinates,
    so the coordinates are between 0 and 1, and the view matrix converts the normalized
    coordinates to window coordinates. Finally, we assigned the value of multiplication
    for the matrix to the `gl_position` to implement it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们移除了所有的颜色值，因为我们现在只使用纹理。其次，我们也删除了统一矩阵变换，因为我们将要使用几种不同的变换方式。第三，我们创建了一个4x4的统一矩阵，它将成为模型矩阵。第四，我们创建了一个4x4的统一矩阵，它是视图矩阵，还有一个4x4的统一矩阵，它是投影矩阵。这三种不同类型的矩阵执行非常重要的任务。模型矩阵将局部对象坐标转换为相机坐标。投影矩阵将相机坐标转换为归一化坐标，因此坐标在0到1之间，视图矩阵将归一化坐标转换为窗口坐标。最后，我们将矩阵乘积的值赋给`gl_position`以实现它。
- en: Next, we'll move on to the core-fragment shader, and in here we'll get rid of
    `vec3 ourColor`; and the rest will remain as it is. The reason for deleting the
    color parameter is the same as described in the previous step.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将转向核心片段着色器，在这里我们将移除`vec3 ourColor`；其余的将保持不变。删除颜色参数的原因与上一步描述的相同。
- en: Modifications to the main code
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对主代码的修改
- en: 'Now that we have updated our shader files, we''ll go ahead and make some modifications
    to our main code to implement the projection and the coordinate system. Follow
    the below mentioned steps:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经更新了我们的着色器文件，我们将继续对主代码进行一些修改以实现投影和坐标系。请按照以下步骤操作：
- en: First of all, we'll get rid of the EBO, as we're not using the element buffer
    object anymore; we'll get rid of any other instances of element buffer object,
    and we'll remove the `glDeleteBuffers( 1, &EBO )`, too. Then, we'll delete the
    color attribute.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将移除EBO，因为我们不再使用元素缓冲对象；我们将移除任何其他元素缓冲对象的实例，并且也将移除`glDeleteBuffers( 1, &EBO
    )`。然后，我们将删除颜色属性。
- en: Now that we have cleaned our project, we are going to enable depth in our code;
    the reason we need to enable it is because if we've got 3D objects or objects
    that are further away from us or nearer to us, we need to plan for depth. So,
    let's go to our code and below `glViewport` we'll add the `glEnable()` function;
    to do this, we'll pass `GL_DEPTH_TEST`. Then, we'll go to the while loop, and
    in the `glClear()` function we'll need to specify depth to clear the depth buffer,
    so add `| GL_DEPTH_BUFFER_BIT` to it.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经清理了我们的项目，我们将在代码中启用深度；我们需要启用它的原因是，如果我们有3D对象或者离我们更远或更近的对象，我们需要考虑深度。所以，让我们进入我们的代码，在`glViewport`下面添加`glEnable()`函数；为此，我们将传递`GL_DEPTH_TEST`。然后，我们将进入while循环，在`glClear()`函数中我们需要指定深度以清除深度缓冲区，所以向其中添加`|
    GL_DEPTH_BUFFER_BIT`。
- en: 'Now that we''ve implemented depth in our application, we''re going update the
    indices and the vertices present in our code. We are implementing a 3D cube in
    this section to help illustrate perspective and orthographic projection. Therefore,
    we''ll have to make modifications to our vertices and get rid of our indices.
    To add the updated vertices to your code, please refer to the `main.cpp` present
    inside the `Projections and Coordinate Systems` folder. You''ll observe that there
    are vertices for two types of projections: orthographic projection and the perspective
    projection. We''ll be switching between the two of them to understand the difference
    between the two projections. In the updated vertices, we have defined six sets
    of vertices and texture coordinates, each one for a face of the cube. For your
    reference, check out a set of vertices for one side of the cube that is mentioned
    in the following and let''s try to understand what it defines:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经在我们的应用程序中实现了深度，我们将更新代码中的索引和顶点。在本节中，我们将实现一个3D立方体来帮助说明透视投影和正交投影。因此，我们需要修改我们的顶点并删除我们的索引。要将更新的顶点添加到你的代码中，请参考`Projections
    and Coordinate Systems`文件夹中的`main.cpp`。你会观察到有两种类型的投影的顶点：正交投影和透视投影。我们将在这两者之间切换，以了解两种投影之间的区别。在更新的顶点中，我们定义了六组顶点和纹理坐标，每组对应立方体的一个面。为了参考，请查看以下提到的立方体一侧的顶点集，并尝试理解它定义的内容：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, the first three values in a row are the x, y and z positions,
    and the next two are the normalized texture coordinates. We covered pretty much
    all of this in the previous section. It is recommended that you take a look at
    each one of these sets and try to figure out which face of the cube they correlate
    to.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，每行前三个值是x、y和z位置，接下来的两个是归一化纹理坐标。我们已经在上一节中详细介绍了这些内容。建议你查看每一组值，并尝试找出它们与立方体的哪个面相关联。
- en: 'Next, once we''ve updated the vertices, we need to make some modifications
    to our attributes, so take look at the updated attributes, as follows, and make
    similar changes to our code:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，一旦我们更新了顶点，我们需要对我们的属性做一些修改，所以请查看以下更新的属性，并按照我们的代码进行类似修改：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we have updated the factor by which we multiply size
    of vertices to `5` because there are five different pieces of information on each
    row in our updated vertices.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们已将乘以顶点大小的因子更新为`5`，因为我们的更新顶点中每行有五个不同的信息。
- en: In terms of our texture loading, we won't touch any of that code whatsoever,
    as that is defining our texture perfectly.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在纹理加载方面，我们不会触及任何代码，因为那已经完美定义了我们的纹理。
- en: 'So, after we''ve unbinded the texture and cleaned it up, and before the `while`
    loop starts, we are going to define the projection matrix `glm::mat4 projection;`,
    The first one we''re going to discuss is perspective projection, because that''s
    the one that you''ll probably be using most of the time. Therefore, we''ll add
    `projection = glm::perspective()`; the `perspective()` takes a few values:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，在我们解绑纹理并清理完毕之后，在`while`循环开始之前，我们将定义投影矩阵`glm::mat4 projection;`。我们首先要讨论的是透视投影，因为那通常是你会用得最多的。因此，我们将添加`projection
    = glm::perspective();`，`perspective()`函数需要几个值：
- en: The first value is the field of view, and, for that, we're going to use 45 degrees.
    This is a very common value for video games.
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个值是视野，我们将使用45度。这在视频游戏中是一个非常常见的值。
- en: The second value is the aspect ratio, and, for that, we'll add `screenWidth
    / screenHeight`. This keeps it dynamic. We're going to cast each to `GLfloat`.
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个值是宽高比，我们将添加`screenWidth / screenHeight`。这使其保持动态。我们将每个值转换为`GLfloat`。
- en: For the third value (the near clipping plane), we'll just add `0.1f`.
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第三个值（近裁剪面），我们只需添加`0.1f`。
- en: For the fourth value (the far clipping plane), we'll use `1000.0f`.
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第四个值（远裁剪面），我们将使用`1000.0f`。
- en: 'Take a look at the following highlighted code to understand the previous description:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下突出显示的代码，以了解前面的描述：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: View Frustum
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视锥体
- en: 'Let''s try to understand the preceding description of code with the help of
    a simple View Frustum image, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们借助以下简单的视锥体图像来理解前面的代码描述：
- en: '![](img/1fb8ca0b-0f34-4afa-bccb-b183108d6da2.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1fb8ca0b-0f34-4afa-bccb-b183108d6da2.png)'
- en: The center of projection is where the virtual camera is placed. **zNear** is
    the near clipping plane, which we have defined as `0.1f` in our code. The `1000.0f`
    value refers to the far clipping plane, which is **zFar**. These two values mean
    that anything nearer than the near clipping plane won't be drawn for you on the
    screen, anything further than the far clipping plane won't be drawn for you, and
    anything outside of the view frustum box won't be drawn for you either. The aspect
    ratio is the **width** divided by the **height**, and the field of view is basically
    how tall it is.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 投影中心是虚拟摄像机放置的位置。**zNear**是近裁剪面，我们在代码中将其定义为`0.1f`。`1000.0f`值指的是远裁剪面，即**zFar**。这两个值意味着任何比近裁剪面近的物体都不会在屏幕上为你绘制，任何比远裁剪面远的物体也不会为你绘制，而且任何在视图视锥体之外的物体也不会为你绘制。纵横比是**宽度**除以**高度**，视场基本上是它的高度。
- en: Modifications to while loop
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对while循环的修改
- en: 'Now that we''ve created the projection matrix, we can actually start creating
    the model and the view matrices, and you need to do that within our while loop.
    Let''s take a look at the following steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了投影矩阵，我们实际上可以开始创建模型和视图矩阵了，你需要在while循环中完成这个操作。让我们看看以下步骤：
- en: So, to begin with, we're going to get rid of the code that defines our transformation
    matrix, as we're no longer using that. We'll move the `glActiveTexture()` code
    before we activate our shader.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，首先，我们将移除定义变换矩阵的代码，因为我们不再使用它。我们将把`glActiveTexture()`代码移动到激活着色器之前。
- en: 'After that, we''re going to create the model and view matrices, for which we''ll
    add the following code to our while loop after we have activated our shader. We''ll
    begin with adding the `glm:: mat4 model` and `glm::mat4 view` matrix. The model
    will be `model = glm::rotate ()`, and we''ll just put an initial sort of rotation
    in `rotate ()`. For the `rotate ()`, we''re going to pass following parameters:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将创建模型和视图矩阵，为此，在激活着色器后，我们将在while循环中添加以下代码。我们将从添加`glm::mat4 model`和`glm::mat4
    view`矩阵开始。模型将是`model = glm::rotate()`，我们将在`rotate()`中添加一个初始的旋转。对于`rotate()`，我们将传递以下参数：
- en: First we'll pass `model`, which refers to the model matrix
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们将传递`model`，它指的是模型矩阵
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Second for the angle of rotation, we're just going to pass the `glfwGetTime()`,
    which will get the time between starting GLFW and now. This is obviously only
    going to constantly increase, hence we can use this as a nice way of providing
    rotation. We'll cast this function to `GLfloat`, then we'll multiply it by `1.0f`.
    This is a great way of increasing and decreasing the speed, as all you have do
    is vary the value.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，对于旋转角度，我们只需传递`glfwGetTime()`，这将获取从开始GLFW到现在的时间。这显然只会不断增加，因此我们可以用这种方式提供旋转。我们将此函数转换为`GLfloat`，然后将其乘以`1.0f`。这是一个增加和减少速度的好方法，因为你只需要改变值。
- en: For more information about angle of rotation, please refer to the information
    box that was provided earlier with links for SFML, SDL, and GLFW, for you to check
    out.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 关于旋转角度的更多信息，请参阅之前提供的带有SFML、SDL和GLFW链接的信息框。
- en: The next parameter that we're going to provide is the vector 3 matrix `glm::vec3()`,
    and for `vec3()` we're going to use `0.5f` in the x axis, `1.0f` in the y axis
    and we're not going to have any rotation in the z axis. This is going to add a
    nice effect to our cube.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们将提供的是向量3矩阵`glm::vec3()`，对于`vec3()`，我们将在x轴上使用`0.5f`，在y轴上使用`1.0f`，而在z轴上则没有旋转。这将给我们的立方体添加一个很好的效果。
- en: Next, we are going to type `view = glm::translate()`. In here, we're going to
    move the view slightly. So, in the `translate ()`, we'll first pass our view matrix;
    then we specify what sort of movement we want, so will type `glm::vec3()` ; and
    to `vec3()` we're going to pass `0.0f`, `0.0f`, `-3.0f` for the axes. So we're
    going to be moving the camera, which is essentially so we can actually see what
    is going on. Otherwise, we'd principally be within our cube only.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将输入`view = glm::translate()`。在这里，我们将稍微移动视图。因此，在`translate()`中，我们首先传递我们的视图矩阵；然后我们指定我们想要的移动类型，所以我们将输入`glm::vec3()`；然后我们将`vec3()`传递给`0.0f`、`0.0f`、`-3.0f`轴。因此，我们将移动摄像机，这实际上是为了我们可以真正看到正在发生的事情。否则，我们基本上会处于立方体内部。
- en: 'Take a look at the following code to understand the preceding description:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下代码以了解前面的描述：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that we've got that sorted, you might be wondering why we are adding a rotation
    and a translation matrix. This is just for this particular section to get a better
    view of the projections. You may not want to add a rotation or a translation matrix
    to further sections.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经整理好了，你可能想知道为什么我们要添加旋转和变换矩阵。这只是为了这个特定的部分，以便更好地查看投影。你可能不希望在后续部分添加旋转或变换矩阵。
- en: 'Next, to get the uniform location, we''ll add following highlighted lines of
    code:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为了获取统一的位置，我们将添加以下突出显示的代码行：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Next, we need to draw our object, so we're going to add `glBindVertexArray()`,
    and to that we'll pass the the vertex array object `VAO`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要绘制我们的对象，所以我们将添加 `glBindVertexArray()`，并将传递顶点数组对象 `VAO`。
- en: 'We''ll then add `glDrawArrays ()` to that, firstly, we''ll pass:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将添加 `glDrawArrays ()`，首先，我们将传递：
- en: Firstly `GL_TRIANGLES`.
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先 `GL_TRIANGLES`。
- en: Secondly, the first vertex will start at `0`
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，第一个顶点将从 `0` 开始
- en: For the count we'll pass `36`, because there are two triangles per face and
    each triangle has three coordinates. The two triangles result in six coordinates,
    so 6 x 6 = 36\.
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于计数，我们将传递 `36`，因为每个面有两个三角形，每个三角形有三个坐标。两个三角形产生六个坐标，所以 6 x 6 = 36。
- en: Next, we'll unbind it, so we're going to add `glBindVertexArray()` to which
    we'll pass `0`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将解绑它，所以我们将添加 `glBindVertexArray()` 并传递 `0`。
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we are all sorted, let''s recheck the code once and then run it. If you
    don''t come across any errors, you will get a similar rotating cube on your screen
    to the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经整理好了，让我们再次检查代码，然后运行它。如果你没有遇到任何错误，你将在屏幕上看到一个类似的旋转立方体，如下所示：
- en: '![](img/a2070aef-a86f-4d35-9055-beaede154c82.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2070aef-a86f-4d35-9055-beaede154c82.png)'
- en: Orthgraphic projection
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正交投影
- en: Now let's just see how orthgraphic projection looks, and understand the difference
    between orthographic and perspective projections. So, we're going to comment the
    perspective-projection coordinates and add the orthagraphic-projection coordinates
    from the `main.cpp` present inside the `Projections and Coordinate Systems` folder.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看正交投影的形状，并理解正交投影和透视投影之间的区别。所以，我们将注释掉透视投影坐标，并从“投影和坐标系”文件夹中的 `main.cpp`
    添加正交投影坐标。
- en: 'Then we''ll go to our `glm::mat4 projection;` and comment out the perspective
    projection, and add the following highlighted line of code for the orthographic
    projection:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将转到 `glm::mat4 projection;` 并注释掉透视投影，并添加以下突出显示的代码行用于正交投影：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You may be wondering where the field of view and the ratio are. We don''t need
    those because the cube is more like the box shown in the following image:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道视场和比例在哪里。我们不需要那些，因为立方体更像是以下图像中显示的盒子：
- en: '![](img/586e2d48-4151-4342-85b5-2e6fc2342905.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/586e2d48-4151-4342-85b5-2e6fc2342905.png)'
- en: 'Now we''ve only other two things that needs to be changed, those are the model
    and the view matrices, simply because this will help to demonstrate what we''re
    trying to show. So, comment out the perspective-projection model and view definitions,
    and add the following lines of code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只剩下两件事需要更改，那就是模型和视图矩阵，因为这将有助于展示我们试图展示的内容。所以，注释掉透视投影模型和视图定义，并添加以下代码行：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let''s run this code and see what our cube looks like:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行这段代码，看看我们的立方体是什么样子：
- en: '![](img/d27bd157-402e-4567-94e0-344ab418e48f.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d27bd157-402e-4567-94e0-344ab418e48f.png)'
- en: 'So we''ve got our cube, but this looks a bit weird. It just looks like a big,
    long rectangle. But what''s actually happening is that the image facing us is
    the front face of the cube and the top rectangular image is the top face of the
    cube. We''ve rotated the cube, but without perspective, and it''s hard to tell
    which face is which. But let''s try an experiment and watch what happens when
    we comment out the orthagraphic `view` and uncomment the perspective `view`. Let''s
    bring in the perspective projection again, uncomment the perspective array, and
    comment out the orthagraphic array. Now if we run the code with the perspective
    projection, you''ll see a key difference between orthographic and perspective
    projections; take a look at the following image:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们得到了我们的立方体，但看起来有点奇怪。它看起来就像一个又长又大的矩形。但实际上，面对我们的图像是立方体的前面，顶部矩形图像是立方体的顶部。我们已经旋转了立方体，但没有透视，很难判断哪个面是哪个。但让我们做一个实验，看看当我们注释掉正交的
    `view` 并取消注释透视的 `view` 时会发生什么。让我们再次引入透视投影，取消注释透视数组，并注释掉正交数组。现在如果我们用透视投影运行代码，你将看到正交投影和透视投影之间的一个关键区别；看看以下图像：
- en: '![](img/446d1a27-20fc-4c92-9ff8-f3a4ce252efb.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/446d1a27-20fc-4c92-9ff8-f3a4ce252efb.png)'
- en: Looking at the preceding image now, it blatantly looks more like a cube. Obviously,
    we can't see the sides, the bottom, or the back face, but, based on what we're
    seeing here, it looks much more like a cube compared to how it looked before.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看前面的图像，它明显更像是一个立方体。显然，我们看不到侧面、底部或背面，但根据我们在这里看到的情况，它看起来比之前更像一个立方体。
- en: Adding a Camera class to the project
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将`Camera`类添加到项目中
- en: In the previous section, we learned how to add objects to our screen and how
    to apply texture, transformation and projection to the objects. As we progress
    ahead in the book, we will add various objects to our screen, but as we add more
    objects to it and if we wish to view those from different angles, we don't want
    to have specific code to be able to do that or to move freely around the objects.
    Therefore, in this chapter, we'll be looking at implementing a `Camera` class,
    which will help us to move around our world freely, using the keyboard, and view
    those objects from different angles. Implementing this class will help us to improvise
    a walking style of movement and take a look at the virtual world around the player
    with the help of the mouse. As we learned in the previous chapter, what we've
    got currently is the single cube we've created. As we are seeking to implement
    multiple objects in this chapter, we'll basically get rid of the vertices that
    describe our single cube, and use a simple array of vertices and a loop to draw
    multiple cubes. Instead of just moving around one cube, we'll see multiple cubes,
    which will be fantastic.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何将对象添加到屏幕上，以及如何将纹理、变换和投影应用到对象上。随着我们在本书中继续前进，我们将向屏幕添加各种对象，但当我们向其中添加更多对象，并且希望从不同的角度观察它们时，我们不希望有特定的代码来实现这一点或自由地在对象周围移动。因此，在本章中，我们将探讨实现一个`Camera`类，这将帮助我们自由地在我们的世界中移动，使用键盘，并从不同的角度观察这些对象。实现这个类将帮助我们改进移动风格，并借助鼠标查看玩家周围的虚拟世界。正如我们在上一章所学，我们目前拥有的只是一个我们创建的单个立方体。由于我们本章的目标是实现多个对象，我们将基本上删除描述单个立方体的顶点，并使用一个简单的顶点数组和循环来绘制多个立方体。我们不仅会看到单个立方体的移动，还会看到多个立方体，这将非常棒。
- en: 'Here are the things we''re going to cover in this section:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖以下内容：
- en: Learning how to draw multiple cubes
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何绘制多个立方体
- en: Creating the `Camera` class and implementing it in our current application
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`Camera`类并在我们的当前应用程序中实现它
- en: There are just a few prerequisites before we get started. We'll use the source
    code from the previous chapter, which was on projections and coordinate systems.
    If you don't have the source code, you can download it from the GitHub link provided
    in the preface of this book. Also, in this chapter, we'll be using GLFW as the
    framework. This means we will be using some GLFW coding here, but this is actually
    only for the input of what we're doing. Feel free to check out the input guides
    for other libraries too, try to swap the code with other libraries, and try experimenting.
    The `Camera` class that we are going to define in this chapter won't be affected
    by your experimentation, as it isn't going to have any framework-specific code.
    Only the main code will be affected, as it's going to be used to detect the input.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，只有几个先决条件。我们将使用上一章的源代码，该章是关于投影和坐标系。如果您没有源代码，您可以从本书前言中提供的GitHub链接下载。此外，在本章中，我们将使用GLFW作为框架。这意味着我们将在这里使用一些GLFW编码，但这实际上只是为了输入我们所做的操作。您可以自由地查看其他库的输入指南，尝试用其他库交换代码，并尝试实验。我们将在本章中定义的`Camera`类不会受到您实验的影响，因为它不会包含任何框架特定的代码。只有主代码会受到影響，因为它将被用来检测输入。
- en: Let's get started.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Creating a Camera.h header file
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Camera.h头文件
- en: 'We''ll begin by creating a header file for our `Camera` class, so we''ll create
    an empty header file in our project and add it to our target. We''ll name it `Camera.h`.
    We''ll only have a header because the methods that we''re going to implement are
    very simple methods. But you can extract it into a separate CPP file if you want
    to. It is recommended that you try experimenting that way as well, because it
    will be a great way to learn. Let''s begin coding our camera header. Follow these
    steps:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先为我们的`Camera`类创建一个头文件，因此我们将在项目中创建一个空的头文件并将其添加到我们的目标中。我们将将其命名为`Camera.h`。我们只会有一个头文件，因为我们将要实现的方法非常简单。但如果你想的话，也可以将其提取到一个单独的CPP文件中。建议你也尝试这种方式进行实验，因为这将是一个很好的学习方法。让我们开始编写我们的摄像机头文件。按照以下步骤进行：
- en: First, let's get rid of the default code that is already present in the file.
    Then, add `#pragma` when the code is a simpler version. This doesn't work on all
    compilers, but most compilers will support this.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们删除文件中已经存在的默认代码。然后，当代码是一个更简单的版本时，添加`#pragma`。这并不是所有编译器都支持，但大多数编译器都会支持这一点。
- en: Then, we'll add the `#include` vector. We'll be using the `vector` class for
    stuff such as positioning. Let's then add `#define GLEW_STATIC`, because we're
    going to be using GLEW in here, which we've already linked to our project. Next,
    we'll add `#include GL/glew.h`. We're also going to include some OpenGL Mathematics
    libraries, so let’s add `glm/glm.hpp` and `#include glm/gtc/matrix_transform.hpp`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将添加`#include`向量。我们将使用`vector`类来处理诸如定位之类的操作。接下来，让我们添加`#define GLEW_STATIC`，因为我们将在其中使用GLEW，它已经链接到我们的项目中。然后，我们将添加`#include
    GL/glew.h`。我们还将包含一些OpenGL数学库，所以让我们添加`glm/glm.hpp`和`#include glm/gtc/matrix_transform.hpp`。
- en: Next, we're going to create an enumeration to define several possible options
    for camera movement. Let’s add `enum Camera_Movements`. This will contain `FORWARD`,
    `BACKWARD`, `LEFT` and `RIGHT`, which we need to use to find out which way the
    user wants to move the camera -- essentially, to identify which way a user wants
    to walk.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个枚举来定义摄像机移动的几个可能选项。让我们添加`enum Camera_Movements`。这将包含`FORWARD`、`BACKWARD`、`LEFT`和`RIGHT`，我们需要使用这些来找出用户想要将摄像机移动到哪个方向——本质上，是为了确定用户想要向哪个方向行走。
- en: Now, we're going to create some constant camera values for the yaw, pitch, and
    speed of the camera movement, and sensitivity and zoom. We're not going to have
    methods for these, apart from for the zoom, but you can have methods for all the
    other ones. You can create getters and setters; it is recommended that you do
    this as an extra task. It's a great way of learning and you'll be able to use
    them later on.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将为摄像机的偏航、俯仰和移动速度创建一些常量值，以及灵敏度和缩放。除了缩放之外，我们不会为这些值提供方法，但你可以为其他所有值创建方法。你可以创建获取器和设置器；建议你将此作为一个额外任务来完成。这是一个很好的学习方法，你以后也能使用它们。
- en: 'So, we''re going to add `const`. Obviously, at the moment, because we''re using
    a constant, you won''t be able to modify it, but if you do want to modify it,
    that''s not a problem. But these are the default values, so you wouldn''t be manipulating
    this particular variable specifically. You''d be manipulating the variables within
    the Camera class, which we''re going to create in a short while. So, add `const
    GLfloat YAW = -90.0f;`. Then add `const GLfloat PITCH = 0.0f` and `const GLfloat
    SPEED = 6.0f`. This is the value of speed that we’ve discovered works well with
    the camera and screen; you can manipulate it to make it slower and faster, as
    you desire. A higher value is faster and a lower value is slower. Next, add `const
    GLfloat SENSITIVITY = 0.25f`. This defines the sensitivity of our mouse movement.
    Again, the higher the value, the faster the mouse movement, and the lower the
    value, the slower the mouse movement. Now we''re going to include `const GLfloat
    ZOOM`. The zoom value is the field of view, so a value of 45 degrees is very common.
    A higher value would basically mean a taller screen. It''s essentially what the
    old games used, so you can try that. Check out the following code to understand
    the preceding description:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们将添加`const`。显然，目前因为我们使用了一个常量，所以你不能修改它，但如果你想要修改，那不是问题。但这些是默认值，所以你不会特别操作这个变量。你会操作Camera类中的变量，我们将在不久的将来创建它。所以，添加`const
    GLfloat YAW = -90.0f;`。然后添加`const GLfloat PITCH = 0.0f`和`const GLfloat SPEED =
    6.0f`。这是与相机和屏幕配合得很好的速度值；你可以根据需要调整它，使其变慢或变快。值越高，速度越快，值越低，速度越慢。接下来，添加`const GLfloat
    SENSITIVITY = 0.25f`。这定义了鼠标移动的灵敏度。同样，值越高，鼠标移动越快，值越低，鼠标移动越慢。现在我们将包括`const GLfloat
    ZOOM`。缩放值是视野，所以45度的值非常常见。值越高，屏幕就越高。这基本上是老游戏所用的，你可以尝试一下。查看以下代码以了解前面的描述：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we''re going to create a Camera class and then type `public`. We''re
    going to create a constructor with vectors first, and then a constructor with
    scalar values. Let’s begin by adding `Camera ()`, which will take the parameters
    shown in the following code:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个Camera类，然后输入`public`。我们将首先创建一个带有向量的构造函数，然后是一个带有标量值的构造函数。让我们从添加`Camera()`开始，它将接受以下代码中显示的参数：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we''re going to quickly implement our camera constructor, so add the
    following lines for the constructor:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将快速实现我们的相机构造函数，所以为构造函数添加以下行：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now that we''re done with this particular constructor, we''re going to add
    the constructor with scalar values to our code. Add the following lines to your
    code:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经完成了这个特定的构造函数，我们将添加带有标量值的构造函数到我们的代码中。向你的代码中添加以下行：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now we''re going to implement a getter for getting the view matrix, because
    this''ll return the view matrix that is calculated using Euler angles and the
    `lookAt` matrix. We''re going to add `glm::mat4`, and we’re going to call it `GetViewMatrix(
    )`. We''ll use this in our `main.cpp`, and we’ll add the following highlighted
    line of code to that class:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将实现一个获取视图矩阵的getter，因为这个将会返回使用欧拉角和`lookAt`矩阵计算出的视图矩阵。我们将添加`glm::mat4`，并将其命名为`GetViewMatrix()`。我们将在`main.cpp`中使用它，并添加以下高亮显示的代码行到这个类中：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is basically just stating where we want to look; we want to be looking
    in front, obviously; and we want to use the up vector so we've made it relative.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是声明我们想要看的地方；显然，我们想要向前看；并且我们想要使用向上向量，所以我们使其相对。
- en: 'Now we''re going to just process some keyboard input; using this keyboard input,
    we''ll detect if we''re going forward, backward, left, or right, and we''ll move
    in that direction. So let’s add the following line of code:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将处理一些键盘输入；使用这个键盘输入，我们将检测我们是在前进、后退、左转还是右转，然后我们将朝那个方向移动。所以让我们添加以下代码行：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This `Camera_Movement` is the `enum` that we created in the preceding steps.
    `GLfloat deltaTime` is the time between frames, so we can create frame-independent
    movement, because the last thing you want is to have 60 frames per second and
    suddenly dip to 30 frames, which is half the speed. You want it to be the same
    speed, obviously. It won't look as smooth, but you'll still get a consistent movement,
    and that is what is important.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Camera_Movement`是我们之前步骤中创建的`enum`。`GLfloat deltaTime`是帧之间的时间，因此我们可以创建与帧无关的运动，因为你最不希望看到的是每秒60帧，突然降到30帧，这只有一半的速度。你显然希望它保持相同的速度。它可能看起来不那么平滑，但你仍然会得到一致的运动，这才是最重要的。
- en: 'Next, in the code file, we''re going to add the following lines of code:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在代码文件中，我们将添加以下代码行：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding lines of code, we added `GLfloat velocity` and assigned it
    the value of `movementSpeed * deltaTime`. So, let's say the `movementSpeed` is
    `5`, for example, and the `deltaTime` is `0.1`, so the `GLfloat velocity` would
    be `0.5`. Hence, if it's a higher delta time, it'll have a higher movement speed.
    If it's a lower delta time, it'll have a lower movement speed. This just keeps
    it all frame-rate independent. Next, we added `if` statements to check the direction
    in which the user is moving. If the user is moving in any particular direction,
    then the `position += this front * velocity`, where `velocity` is equal to the
    value that we've already calculated.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码行中，我们添加了`GLfloat velocity`并将其赋值为`movementSpeed * deltaTime`。假设`movementSpeed`是`5`，例如，而`deltaTime`是`0.1`，那么`GLfloat
    velocity`将是`0.5`。因此，如果delta time更高，移动速度也会更高。如果delta time更低，移动速度也会更低。这仅仅保持了所有帧率独立。接下来，我们添加了`if`语句来检查用户移动的方向。如果用户向任何特定方向移动，那么`position
    += this front * velocity`，其中`velocity`等于我们之前计算出的值。
- en: You might be wondering why we aren't using a switch statement or why we aren't
    using an `if else/if else` series. First, let's say you clicked the forward key
    and the left key, then you want to be able to move essentially in a northwest
    direction. Ignoring which way we're looking—so let's assume we're just looking
    north - you want to be able to move northwest. You don't want to have to press
    one key, then let go, then press another key. Likewise, if you're moving forward
    and you click backwards, you'll stop. You don't want to be having to release keys;
    this is the reason we're using separate `if` statements.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们不使用开关语句，或者为什么不使用`if else/if else`系列。首先，假设你同时按下了前进键和左键，那么你希望能够向西北方向移动。忽略我们朝向的方向——让我们假设我们正朝北看——你希望能够向西北方向移动。你不想需要先按下一个键，然后松开，再按另一个键。同样地，如果你正在前进，然后点击后退，你会停止。你不想需要释放按键；这就是我们使用单独的`if`语句的原因。
- en: 'The next thing we''ll do is process the mouse movement. This will process the
    input received from our mouse system, whether that''s GLFW, SDL, or SFML, and
    it will use an offset value so it can adjust the x and y direction. So, we''re
    going to add `void ProcessMouseMovement()` and pass `GLfloat xOffset` to it. This
    is essentially the difference between the mouse movements, because, otherwise,
    how do we know where we''re moving to? We essentially need to think about the
    speed. Then add `GLfloat yOffset, GLboolean constrainPitch` to constrain the pitch
    and set that equal to true. Now we''re going to calculate the offset, and we''ll
    adjust that using our `mouseSensitivity`. We''ll add the following lines of code:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将处理鼠标移动。这将处理从我们的鼠标系统接收到的输入，无论是GLFW、SDL还是SFML，并且它将使用偏移值来调整x和y方向。因此，我们将添加`void
    ProcessMouseMovement()`函数，并将`GLfloat xOffset`传递给它。这实际上是鼠标移动之间的差异，因为否则我们怎么知道我们要移动到哪里呢？我们实际上需要考虑速度。然后添加`GLfloat
    yOffset, GLboolean constrainPitch`来约束俯仰角，并将其设置为true。现在我们将计算偏移量，并使用我们的`mouseSensitivity`来调整它。我们将添加以下代码行：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we''re going to check if the pitch is constrained by using the if statement.
    We want to prevent the user from being able to go out of bounds, so that the screen
    doesn''t get flipped if we move our mouse, or effectively the way we look, to
    the left and to the right; if we move to the left for too long, we''ll loop back
    round. The same is true for the right direction (that is, anti-clockwise and clockwise.
    When you look up and down, you generally only want to be able to look up by about
    90 degrees, which is roughly what your head can do, and then just look down by
    roughly 90 degrees to your feet, which is again approximately what your head can
    do. You don''t want to be able to just keep looping back round, because you''ll
    start getting all sorts of different problems, such as gimbal lock. But, in general,
    that''s not the sort of movement that you have in games, because games are based
    on real life and the constraints of the human body. So we''re going to check the
    pitch. If `pitch > 89.0f`, then we''ll assign the pitch as `89.0f`. If `pitch
    < -89.0f`, we''ll assign the pitch as `-89.0f`. Finally, we’ll update the camera
    vectors by adding `this->updateCameraVectors( );`. This will update the front,
    right, and up vectors using the Euler angles that we''ve defined here. Take a
    look at the following code to understand the preceding description:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用if语句检查俯仰角是否受到限制。我们希望防止用户超出范围，这样当我们的鼠标移动时，屏幕就不会翻转，或者实际上是我们看左和看右的方式；如果我们向左移动时间过长，我们会回到起点。同样的情况也适用于右方向（即逆时针和顺时针。当你向上或向下看时，你通常只能向上看大约90度，这大约是头部能做的，然后向下看大约90度到你的脚，这又是头部能做的。你不希望能够不断地循环回到起点，因为这会导致各种各样的问题，比如陀螺仪锁定。但是，一般来说，这种运动在游戏中是不存在的，因为游戏是基于现实生活和人体限制的。所以我们将检查俯仰角。如果`pitch
    > 89.0f`，我们将俯仰角设置为`89.0f`。如果`pitch < -89.0f`，我们将俯仰角设置为`-89.0f`。最后，我们将通过添加`this->updateCameraVectors();`来更新相机向量。这将使用我们在这里定义的欧拉角更新前、右和上向量。请查看以下代码以了解前面的描述：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now that we've processed the mouse movement, we're going to process the mouse
    scroll, so we’ll add `void ProcessMouseScroll()`, and we'll pass `GLfloat yOffset`
    to that.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经处理了鼠标移动，接下来我们将处理鼠标滚轮操作，因此我们将添加`void ProcessMouseScroll()`函数，并将`GLfloat
    yOffset`传递给它。
- en: You can use `xOffset` if you want to be able to detect the horizontal scroll.
    A lot of mice don't have horizontal scroll, but quite a few new mice, especially
    gaming mice and productivity mice, do. But, generally speaking, you probably only
    want to detect movement in the y axis--that is, vertical scroll. But you can easily
    extend this method, and this class in general, to suit your requirements.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你想要能够检测水平滚动，可以使用`xOffset`。许多鼠标没有水平滚动功能，但相当多的新型鼠标，尤其是游戏鼠标和生产力鼠标，都有。但是，一般来说，你可能只想检测y轴上的移动——也就是说，垂直滚动。但是你可以轻松扩展这个方法和这个类，以满足你的需求。
- en: 'Add the following `if` statements to your code:'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在你的代码中添加以下`if`语句：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we''re going to create a getter for getting the zoom, because the zoom
    variable will be private. Actually, all the variables are private in this class.
    We''re only really creating the zoom getter simply because it''s the only one
    we''re using outside of this class for now. But if you need to use something such
    as the up vector, the yaw, the pitch, or any of the other variables that we''re
    creating, feel free to create appropriate getters and setters. Therefore, we’ll
    next add following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个获取缩放的getter，因为缩放变量将是私有的。实际上，这个类中的所有变量都是私有的。我们真正创建缩放getter的原因仅仅是因为它是我们现在在类外使用的唯一一个。但是，如果你需要使用诸如上向量、偏航、俯仰或其他我们创建的任何变量，请随意创建适当的getter和setter。因此，我们接下来将添加以下代码：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now we''re going to do define the camera attributes, so we’ll add following
    lines of code to our camera class:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将定义相机属性，因此我们将向我们的相机类添加以下代码行：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Feel free to visit [learnopengl.com](http://learnopengl.com) and [open.gl](http://open.gl),
    and check out those websites for more in-depth written information and some nice
    diagrams regarding all the different variables and the methods that we have discussed
    in this chapter.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎访问[learnopengl.com](http://learnopengl.com)和[open.gl](http://open.gl)，并查看这些网站以获取更深入的书面信息和一些关于我们本章讨论的所有不同变量和方法的优秀图表。
- en: 'Then we’ll add some Euler angles to our class:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将向我们的类中添加一些欧拉角：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'All of these parameters that we''ve been using are finally getting created.
    Next, we’ll add some camera options to our code:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们一直在使用的所有这些参数最终都被创建出来了。接下来，我们将在我们的代码中添加一些摄像机选项：
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The last thing we need to add into this class is `void updateCameraVectors`,
    and, when we''re updating the camera vectors, we need to calculate the new front
    vector, so we''ll add `glm::vec3 front`, which is temporary storage for it. Then
    we''ll add `front.x`, and we’ll assign a value of `cos ( glm::radians( this->yaw
    ))` multiplied by `cos( glm::radians( this->pitch ) )` to it. Again, the mathematical
    calculations here are obviously quite complex and quite in depth, so we would
    recommend you check out the aforementioned links. Take a look at the following
    code to understand what other elements will be added to `updateCameraVectors`:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要添加到这个类中的最后一件事是 `void updateCameraVectors`，当我们更新摄像机向量时，我们需要计算新的前向量，因此我们将添加
    `glm::vec3 front`，这是它的临时存储。然后我们将添加 `front.x`，并将 `cos ( glm::radians( this->yaw
    ))` 乘以 `cos( glm::radians( this->pitch ) )` 的值分配给它。再次强调，这里的数学计算显然非常复杂且深入，所以我们建议您查看上述链接。查看以下代码以了解将添加到
    `updateCameraVectors` 的其他元素：
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With this last line of code, we have finally completed the `Camera` class. Please
    check out the `camera.h` file for the entire code. This file is present inside
    the `camera` folder in the `Getting started` folder.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一行代码，我们最终完成了 `Camera` 类。请查看 `camera.h` 文件以获取完整的代码。此文件位于 `Getting started`
    文件夹中的 `camera` 文件夹内。
- en: Making modifications to main.cpp
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对 main.cpp 进行修改
- en: Now that we have created our `Camera` class, let’s go back to our `main.cpp`
    and make some modifications to it, such as implementing multiple cubes on our
    screens, adding a camera class, and moving through the multiple objects.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的 `Camera` 类，让我们回到 `main.cpp` 并对其进行一些修改，例如在我们的屏幕上实现多个立方体，添加一个摄像机类，并在多个对象之间移动。
- en: In our `main.cpp`, we'll start implementing the input stuff that we've been
    doing. So, we're going to use the GLFW for our input system, but, again, feel
    free to check out the previous links for more information on the GLFW, SFML, and
    SDL input systems.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `main.cpp` 中，我们将开始实现我们一直在做的输入部分。因此，我们将使用 GLFW 作为我们的输入系统，但，再次提醒，您可以自由查看之前的链接以获取有关
    GLFW、SFML 和 SDL 输入系统的更多信息。
- en: We’ll begin with including our `Camera` class in our code. Add `#include Camera.h`
    at the start of the code,
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从在我们的代码中包含 `Camera` 类开始。在代码的开始处添加 `#include Camera.h`，
- en: 'Then, in the section where we define our screen dimensions, we’ll make the
    following modifications:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在定义我们的屏幕尺寸的部分，我们将进行以下修改：
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, let's just replace every `screenWidth` and `screenHeight` we’ve used with
    `SCREEN_WIDTH`, and `SCREEN_HEIGHT`.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将所有使用的 `screenWidth` 和 `screenHeight` 替换为 `SCREEN_WIDTH` 和 `SCREEN_HEIGHT`。
- en: As we’ll be using perspective projection, we need to get rid of all the orthographic
    projection code as we're not using that anymore.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将使用透视投影，我们需要删除所有正交投影代码，因为我们不再使用它了。
- en: 'Now, before we start with our `int main`, we’re going to create some function
    prototypes. Add the following lines of code to your `main.cpp` file:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们开始 `int main` 之前，我们将创建一些函数原型。将以下代码行添加到您的 `main.cpp` 文件中：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding code, we first added `void KeyCallback( )`; this is where
    the framework-specific code starts. To that function we passed `GLFWwindow *window`,
    and then we needed to check what key was pressed, so we added `int key`, `scancode`,
    `action` and `mode`. We then added the rest of the functions. In the `MouseCallback(
    )`, we passed `double xPos` and `double yPos`. These are the x and y positions
    of our mouse in our window. We''re actually going to hide the mouse cursor to
    provide a more immersive experience. Then, we added one final method prototype
    to the preceding code: `void DoMovement`. This method will be called in every
    single frame, and this''ll move our camera. Even if we haven''t made any movement,
    it''ll still be called, but it won''t obviously move our camera.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先添加了 `void KeyCallback( )`; 这是从这里开始框架特定代码的地方。我们将 `GLFWwindow *window`
    传递给这个函数，然后我们需要检查哪个键被按下，因此添加了 `int key`、`scancode`、`action` 和 `mode`。然后我们添加了其余的函数。在
    `MouseCallback( )` 中，我们传递了 `double xPos` 和 `double yPos`。这些是我们鼠标在窗口中的 x 和 y 位置。我们实际上将隐藏鼠标光标以提供更沉浸式的体验。然后，我们在前面的代码中添加了一个最终的方法原型：`void
    DoMovement`。这个方法将在每一帧中被调用，并将移动我们的摄像机。即使我们没有进行任何移动，它仍然会被调用，但不会明显移动我们的摄像机。
- en: 'Now, we just need to initially set some values up for our camera, so we''re
    going to add `Camera`, create a `camera ( )` object, and we’ll pass `glm::vec3
    ( )` to it. To the `vec3( )`, we’ll pass `0.0f`, `0.0f`, `3.0f`. These are just
    the initial values. Next, we’ll add `GLfloat lastX`, which is the last position
    of the camera, initially. We''ll make it equal to the center of the screen, so
    this is going to be our mouse movement. We''ll add `WIDTH / 2.0` and `GLfloat
    lastY = WIDTH / 2.0f;`. Take a look at the following to understand this description:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只需要为我们的相机初始化一些值，所以我们将添加`Camera`，创建一个`camera()`对象，并将`glm::vec3()`传递给它。对于`vec3()`，我们将传递`0.0f`、`0.0f`、`3.0f`。这些只是初始值。接下来，我们将添加`GLfloat
    lastX`，这是相机的最后位置，初始时。我们将使其等于屏幕中心，这将是我们鼠标移动的位置。我们将添加`WIDTH / 2.0`和`GLfloat lastY
    = WIDTH / 2.0f;`。查看以下内容以了解此描述：
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Below this will be a `bool` of keys, which will be an array of 1,024 different
    types of key. We’re going to add `bool firstMouse = true`, as we’re handling one
    type of mouse:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之下将是一个`bool`类型的键数组，它将包含1,024种不同类型的键。我们将添加`bool firstMouse = true`，因为我们正在处理一种鼠标类型：
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we will add `deltatime` and `lastframe`, which will be used in the code
    to determine the time between frames:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加`deltatime`和`lastframe`，它们将在代码中用于确定帧之间的时间：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, in our int main, after our `glfwMakeContextCurrent( window );` we are
    going to add `glfwSetKeyCallback( );` and to that we’ll provide `window`; we''ll
    provide the method that we''re using, which is `KeyCallback`; and then we''ll
    duplicate this line of code three times and make following highlighted modifications
    to it:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们的`int main`中，在`glfwMakeContextCurrent(window);`之后，我们将添加`glfwSetKeyCallback();`，并将`window`作为参数传递给它。我们将提供我们使用的方法，即`KeyCallback`；然后我们将重复此行代码三次，并对其进行以下突出显示的修改：
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, we are calling the function prototypes that we have defined previously.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在调用之前定义的函数原型。
- en: Next, we want to fix our mouse to the center of our screen, within the window
    itself, so we’ll add `glfwSetInputMode( )` and we’ll pass `window`to it. As the
    mode that we're changing is the cursor, we'll pass `GLFW_CURSOR` with a value
    of `GLFW_CURSOR_ DISABLED` to it, as we don't want the cursor to be totally disabled.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们想要将鼠标固定在屏幕中心，在窗口内部，所以我们将添加`glfwSetInputMode();`并将`window`传递给它。由于我们正在更改的模式是光标，我们将传递`GLFW_CURSOR`与值`GLFW_CURSOR_DISABLED`，因为我们不希望光标完全禁用。
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As we are going to render multiple cubes in this code, we'll create an array
    of vectors, which will contain the cubes' positions. These are just arbitrary
    positions, so you can change them later to experiment with those. Go to the `main.cpp`
    file in the `Camera` folder, and copy and paste the array of vectors `glm::vec3
    cubePositions[]` to your code.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将在代码中渲染多个立方体，我们将创建一个向量数组，该数组将包含立方体的位置。这些位置只是任意位置，所以你可以稍后更改它们以进行实验。前往“Camera”文件夹中的`main.cpp`文件，并将向量数组`glm::vec3
    cubePositions[]`复制并粘贴到你的代码中。
- en: 'Next, we''re going to move the projection code inside the while loop, because
    we''re going to change the field of view using the mouse scroll, so we want to
    be able to update the projection every single frame if we''re actually changing
    the field-of-view value. So, after we’ve activated our shader code and binded
    texture using texture units, add the projection code and make the following changes
    to it:'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们将移动投影代码到while循环内部，因为我们将通过鼠标滚轮更改视场，所以如果我们实际上正在更改视场值，我们希望能够在每一帧更新投影。因此，在激活我们的着色器代码并使用纹理单元绑定纹理之后，添加投影代码并对其进行以下更改：
- en: '[PRE37]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After the start of the while loop, we''ll set the frame time, so we’ll add
    `GLfloat currentFrame = glfwGetTime()`. Then we’ll add `deltaTime = currentFrame
    - lastFrame`. This is our way of detecting the time between the frames. If, let''s
    say, our current frame is at time 100 and our last frame was at time 80, the time
    between the last frame and the current frame would be 20--though it''d normally
    be a second or millisecond. Then we’ll add `lastFrame = the currentFrame`, as
    the last frame will be the current frame when we restart this while loop on the
    next iteration, because we''ll have a different frame at that particular moment.
    Refer to the following code to understand the description:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在while循环开始后，我们将设置帧时间，所以我们将添加`GLfloat currentFrame = glfwGetTime()`。然后我们将添加`deltaTime
    = currentFrame - lastFrame`。这是我们检测帧间时间的方式。比如说，如果我们的当前帧在时间100，而我们的上一帧在时间80，那么上一帧和当前帧之间的时间将是20——尽管它通常是一秒或毫秒。然后我们将添加`lastFrame
    = the currentFrame`，因为当我们在下一次迭代中重新启动这个while循环时，最后一帧将是当前帧，因为我们将在那个特定时刻有一个不同的帧。请参考以下代码来理解描述：
- en: '[PRE38]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: After we've handled all the events, we're actually going to handle the movement,
    so add `DoMovement()`.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理完所有事件后，我们将实际处理移动，所以添加`DoMovement()`。
- en: 'Now we’ll go to the section in the code where we have defined the `view` and
    model matrix, and make the following modifications:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将进入代码中定义`view`和模型矩阵的部分，并进行以下修改：
- en: '[PRE39]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the preceding code, you must have noticed that we got rid of model-matrix
    code, which is because we're going to put that inside a for loop that will iterate
    over our cube-position array, draw the objects in different locations, and use
    the model to generate sort of a random rotation.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你可能已经注意到我们移除了模型矩阵代码，这是因为我们将把它放在一个for循环中，该循环将遍历我们的立方体位置数组，在不同的位置绘制对象，并使用模型生成一种随机的旋转。
- en: 'Between binding the vertex array to the vertex-array object, and unbinding
    it, we''re essentially going to add a for loop in which we''re going to pass a
    parameter as `GLuint i = 0; i < 10; i++`. It is recommended that you to try to
    make it dynamic, so you can add more cube positions and you can draw more cubes.
    That''d be another great task for you. We’ll add the following highlighted statements
    to the for loop. First of all, we''re going to calculate the model matrix for
    each object, and then pass it to our shader before we start drawing:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将顶点数组绑定到顶点数组对象和解除绑定之间，我们实际上将添加一个for循环，我们将传递一个参数作为`GLuint i = 0; i < 10; i++`。建议你尝试使其动态化，这样你就可以添加更多的立方体位置，并绘制更多的立方体。那将是你另一个很好的任务。我们将在for循环中添加以下突出显示的语句。首先，我们将为每个对象计算模型矩阵，然后在我们开始绘制之前将其传递给我们的着色器：
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We used a value of `20.0` in the preceding code as it's just a calculated value.
    Try varying this value and see what happens. You might find a better value than
    that. We have cut and pasted the `glUniformMatrix4fv();` from the while loop.
    Now we are done with our while loop.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面代码中使用了一个值为`20.0`，因为这只是一个计算值。尝试改变这个值并看看会发生什么。你可能会找到一个更好的值。我们已经从while循环中复制并粘贴了`glUniformMatrix4fv();`。现在我们已经完成了我们的while循环。
- en: 'Now we can start to implement those function prototypes, which is the last
    thing to do before we can run the code and observe our output. After the end of
    while loop, we''ll add `void DoMovement()`, which is going to handle our movement
    and call the appropriate keyboard method in our Camera class. So, this is not
    going to take in any parameters, but we will add some if statements. We want to
    use the *W, A, S, D* and arrow keys, so we’re going to pass the condition as `keys[GLFW_KEY_W]
    || keys[GLFW_KEY_UP]`. In the if statement, we’ll add `camera.ProcessKeyboard(
    FORWARD, deltaTime );` because we''re moving forward, and we''ll add `deltaTime`,
    which we''ve already calculated in our while loop. This is the code for moving
    forward. Similarly, we’ll add statements for all other directions; take a look
    at the following highlighted code:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以开始实现那些函数原型，这是在我们能够运行代码并观察输出之前要做的最后一件事。在while循环结束后，我们将添加`void DoMovement()`，这将处理我们的移动并调用Camera类中的适当键盘方法。所以，这个函数不会接受任何参数，但我们将添加一些if语句。我们想要使用*W,
    A, S, D*和箭头键，所以我们将条件作为`keys[GLFW_KEY_W] || keys[GLFW_KEY_UP]`传递。在if语句中，我们将添加`camera.ProcessKeyboard(FORWARD,
    deltaTime);`因为我们正在向前移动，并且我们将添加`deltaTime`，这是我们已经在while循环中计算过的。这是向前移动的代码。同样，我们还将为所有其他方向添加语句；请查看以下突出显示的代码：
- en: '[PRE41]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, we''re going to do a callback, so we''ll add the following code:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将进行一个回调，所以我们将添加以下代码：
- en: '[PRE42]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now we can add the `MouseCallback`:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以添加`MouseCallback`：
- en: '[PRE43]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then we are going to add `void ScrollCallback()`, to which we will pass the
    following parameters: `GLFWwindow *window, double xOffset, double yOffset`'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将添加 `void ScrollCallback()`，并将以下参数传递给它：`GLFWwindow *window, double xOffset,
    double yOffset`
- en: 'Inside that method we are going to add the following code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个方法中，我们将添加以下代码：
- en: '[PRE44]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now we''re ready to see if this works, so run it. Once it has been compiled
    error free, you’ll get to see the following output :'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好查看这个是否工作，所以运行它。一旦编译无误，你将看到以下输出：
- en: '![](img/8d57175b-37ee-4583-a692-932065bfdf0c.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d57175b-37ee-4583-a692-932065bfdf0c.png)'
- en: We've created our multiple cubes, and we can look around and move. We can use
    the *W*, *A*, *S*, and *D* keys and arrow keys to move around. So we can move
    not just forward and backward, but forward and right, forward and left, back and
    right, and back and left. What's great about this camera system is the forward
    is relative to the way we're looking. So, if we look at a particular cube, then
    press forward, it moves towards our cube. If we try to go through the cube, we'll
    go through and we’ll get to see the inverse of the textures. The reason we can
    go through it is simply because there's no collision detection.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了多个立方体，并且可以四处查看和移动。我们可以使用 *W*、*A*、*S* 和 *D* 键以及箭头键来移动。因此，我们不仅可以向前和向后移动，还可以向前和向右、向前和向左、向后和向右、向后和向左移动。这个相机系统的优点是向前移动是相对于我们观察的方向的。所以，如果我们看一个特定的立方体，然后按向前键，它就会移动到我们的立方体方向。如果我们试图穿过立方体，我们会穿过它，并且可以看到纹理的逆面。我们可以穿过它的原因很简单，那就是没有碰撞检测。
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to apply transformations such as rotation to
    our shape, and learned to draw a cube and apply texture to it. Then, we explored
    the concepts of projections, Perspective and Orthographic, and implemented those
    in our game world.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何应用变换，如旋转到我们的形状上，并学会了如何绘制一个立方体并将其纹理化。然后，我们探讨了投影的概念，包括透视和正交投影，并在我们的游戏世界中实现了这些概念。
- en: In the next chapter, we'll talk about lighting, its effects and sources of light
    that we have in OpenGL
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论光照、其效果以及我们在OpenGL中拥有的光源。
