- en: Transformations, Projections, and Camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed about how to create shapes in OpenGL using
    our libraries. We learned to add colors to our shapes and we'll also discussed
    how to add texture to the shapes. This chapter will be the continuation of the
    previous chapter and we'll discuss how to apply transformations such as rotation
    or translate to our shapes. We'll also discuss the projection and the coordinate
    system and try to implement that in our game world. You'll also get to learn about
    the camera class and we'll use that to view and navigate through our multiple
    objects we'll create in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Applying transformations such as rotations and translate to our shapes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation of projection and the coordinate system in the game world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding multiple objects to our game world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using camera class for a better view of objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So let's begin...
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to all the code files for this chapter in the `Chapter03` folder
    on GitHub. The GitHub link can be found in the preface of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Transformations using GLM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll be looking at making transformations to our shape and the texture applied
    to it. To do the transformations, we'll be using the OpenGL Mathematics library
    that is GLM. For transformations, we need to use vectors and matrices, and GLM
    handles a lot of that in the backend for us. All we have to do is call the correct
    method (for example, translate or rotate), and it'll do the appropriate matrices
    and vector transformations for us.
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended that you go to [learnopengl.com](https://learnopengl.com/)
    and [open.gl](https://www.opengl.org/). These sites have got some great resources
    that showcase all the different vectors and matrices and how to use them, and
    it goes into more depth about the mathematics behind it. So, if you're interested,
    you should definitely visit these sites.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a project to use GLM on Windows / Mac
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, to begin with, we need to download and install the GLM library onto our
    system. It's very similar to installing the other frameworks that we learned to
    install in the previous chapters, whether it's GLFW, SDL, or SFML. But if you
    wish to review this, please refer to the *Setting up a project to use SOIL on
    Windows or Mac* section in [Chapter 2](674fc755-f955-4a25-b241-bd882af16879.xhtml),
    *Drawing Shapes and Applying Textures*. The setup process for GLM will be very
    much similar to what was discussed in the mentioned section. For the further sections
    we'll assume that you've install the GLM library in your system and set the project
    up too.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the GLM library is installed and our project is setup, let's move on
    to make some modifications to our code so that we can transform our shapes and
    textures applied to it. In further sections, we'll make some modifications to
    our code from the previous chapter to transform our shapes.
  prefs: []
  type: TYPE_NORMAL
- en: So, to begin with, we will first need to update our shader files.
  prefs: []
  type: TYPE_NORMAL
- en: Updating shader files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s follow the below mentioned steps to update the shader files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll go to our vertex shader that is `core.vs` file and perform the following
    highlighted modifications to the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For the fragment shader, we don't need to do anything as we'll be requiring
    that code as it is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we can go to `main.cpp` and carry out the modification to our main code
    to apply transformations to our objects.
  prefs: []
  type: TYPE_NORMAL
- en: Applying transformations to the objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take a look at the following steps to understand the modifications that we
    need to carry out to incorporate transformations in our main code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make changes to our main code, we''ll begin by including the `GLM` header
    file in our code, so add the following highlighted include terms in your code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing that we are going to do is create the transformation matrix
    that we want to apply. To do this, go to the while loop, and somewhere in the
    loop between defining the shader and activating the texture we''ll need to add
    the code described as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First of all, we're going to just create the transformation matrix. So, we'll
    begin by typing `glm::mat4` and we'll call it `transform`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we'll add the type of transformation. For the translate transformation
    we'll define it as `transform = glm::translate();`. For the `translate ()` function,
    the first parameter that we will need to specify is the 4x4 matrix that we're
    going to use. Next, we'll specify the vector, which is `glm::vec3()`. This takes
    three parameters—the x, y, and z coordinates—and for those we'll pass the values
    `0.5f` , `-0.5f` and `0.0f`. Remember, the values should range between -1 and
    1, for now.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we''ll define the rotate transformation, `transform = glm::rotate()`,
    and for the `rotate()` function we''ll pass parameters: for the `matrix`, we''re
    going to specify `transform` again. For the `angle`, we need to state how much
    we want it to rotate by, because we don''t want it just to rotate once. We want
    it to constantly rotate. Therefore, we''ll add `glfwGetTime()` and cast it to
    `GLfloat`. The `glfwGetTime()` function will be the amount of time that has passed
    since GLFW was initialized and use that to rotate our object.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For more information on **time methods**, you can visit the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: for GLFW time input, visit [https://www.glfw.org/docs/3.0/group__time.html](https://www.glfw.org/docs/3.0/group__time.html);
  prefs: []
  type: TYPE_NORMAL
- en: for SDL time input, you can use the `SDL_GetTicks` method and read the information
    at [https://wiki.libsdl.org/SDL_GetTicks](https://wiki.libsdl.org/SDL_GetTicks);
    and, for SFML, you can use the `getElapsedTime` method and for more info on that
    you can visit [https://www.sfml-dev.org/tutorials/2.5/system-time.php](https://www.sfml-dev.org/tutorials/2.5/system-time.php)
  prefs: []
  type: TYPE_NORMAL
- en: We will need to time the method so that the texture rotates at a certain speed.
    So, we will multiply the method `glfwGetTime( )` by `-5.0f`. This will make the
    object rotate in one way. If you add a positive number, it rotates the other way.
    Try experimenting with the value. By increasing the value you will make it rotate
    faster, and by reducing the value you will make it go slower.
  prefs: []
  type: TYPE_NORMAL
- en: The third parameter that we need to pass is `glm::vec3()`, and for the vector
    you have to specify what axes you want the shapes to rotate around. So, either
    use `1.0f` or `0.0f`. Adding `0.0f` means you don't want it to rotate around that
    particular axis. So, we'll define it as `0.0f, 0.0f, 1.0f`. This means that our
    texture will rotate around the z axis. The reason we've chosen z is because, at
    the moment, we're not doing anything in 3D. So, by rotating round the z axis,
    it'll just look like it's a 2D transformation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code to get a clear understanding of the preceding
    description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve created our transformation matrix, we can actually get on to
    applying it. Therefore, we need to get the matrix uniform location and set the
    matrix up for our shader to use. So we need to create a `GLint` variable `transformLocation`
    and to that we''ll assign the value of `glGetUniformLocation()`, and to this function
    need to pass `ourShader.Program` and our transformation matrix `"transform"`.
    Next, we need to define uniform matrix in our code, so add the `glUniformMatrix4fv()`
    function to our code, and this takes a few parameters. First of all is the `transformLocation`,
    then `1`, and then `GL_FALSE` and `glm::value_ptr()`, and to this function we
    need to specify the transformation matrix that we''re using:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you want to know more about what these parameters are doing, it is recommended
    that you check out [learnopengl.com](http://learnopengl.com) and [open.gl](http://open.gl),
    because these sites explain a lot of this in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now we''re all set and ready to run. If we run this, we should get our
    image rotating in the top-right corner, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/465fb17b-3d25-4d0d-bc0b-4dc0d544e3a1.png)'
  prefs: []
  type: TYPE_IMG
- en: The illustration used in this chapter is for explanatory purposes only. We do
    not recommend you to misuse these in any way. For more information please consult
    the terms and conditions of the publisher mentioned in the Disclaimer section
    of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is recommended that you try experimenting with the following line of code
    to vary the location and speed of rotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Projections and coordinate systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''re going to look at the projections and the coordinate
    systems. So let''s first understand what the coordinate systems are? There are
    two types of coordinate system: a left-handed and a right-handed coordinate system.
    The best way to visualize them is to put up both of your hands, as shown in the
    following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4e1f039-aea0-4962-929b-cea2fbd1bd56.png)'
  prefs: []
  type: TYPE_IMG
- en: As per the image, the index fingers of both your hands should point up. Your
    middle fingers should point towards you and your thumbs should point to the left
    and right directions, respectively. Once you've done that, the direction that
    your fingers and your thumbs are pointing is the positive direction for that axis.
    So, the way the index finger is pointing (upward) is the positive y axis. The
    direction in which the middle finger is pointing is the positive z axis and the
    thumbs are pointing in the direction of the positive x axis. OpenGL uses the right-handed
    coordinate system, while the DirectX uses the left-handed coordinate system.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on the coordinate system, you can check out the following
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learnopengl.com/](https://learnopengl.com/) and [https://open.gl./](https://open.gl./)'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've discussed the coordinate system, let's understand the different
    types of projection we've got in OpenGL. We have the perspective projection and
    orthographic projection. Perspective projection takes depth into consideration,
    which, generally speaking, every game in production would, whereas, orthographic
    projection doesn't take depth into consideration. So, in orthographic projection,
    an object or part of an object that is further away from you still looks the same
    size. If you have two identical objects and one is further away, it will still
    look the same size. However, in perspective projection, just like in real life,
    the object, that is further away would look smaller. You might be wondering, where
    orthographic projection would ever be useful? One example is in architecture,
    when you're creating a laid-out design and you want to have objects behind other
    objects, but, because you're giving measurements, you don't want them to vary
    in size.
  prefs: []
  type: TYPE_NORMAL
- en: Modifications to the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will make some modifications to our texture code to integrate
    projection and coordinate system in our game world.
  prefs: []
  type: TYPE_NORMAL
- en: We'll begin our modifications by updating the shader files.
  prefs: []
  type: TYPE_NORMAL
- en: Making modifications to the shader files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check out the next steps to understand what modifications we need to do to
    our shader files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that we want to do is go to our vertex shader and carry out
    the following highlighted changes to the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have removed all the color values because we are just
    using textures now. Second, we deleted the uniform matrix transform as well because
    we're going to use a few different ways of transforming. Third, we created a uniform
    4x4 matrix, which is going to be the model matrix. Fourth, we created a uniform
    4x4 matrix, which is the view matrix, and another uniform 4x4 matrix, which is
    the projection matrix. These three different types of matrices do very important
    stuff. The model matrix converts local-object coordinates to camera coordinates.
    The projection matrix converts the camera coordinates to normalized coordinates,
    so the coordinates are between 0 and 1, and the view matrix converts the normalized
    coordinates to window coordinates. Finally, we assigned the value of multiplication
    for the matrix to the `gl_position` to implement it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll move on to the core-fragment shader, and in here we'll get rid of
    `vec3 ourColor`; and the rest will remain as it is. The reason for deleting the
    color parameter is the same as described in the previous step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modifications to the main code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have updated our shader files, we''ll go ahead and make some modifications
    to our main code to implement the projection and the coordinate system. Follow
    the below mentioned steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we'll get rid of the EBO, as we're not using the element buffer
    object anymore; we'll get rid of any other instances of element buffer object,
    and we'll remove the `glDeleteBuffers( 1, &EBO )`, too. Then, we'll delete the
    color attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have cleaned our project, we are going to enable depth in our code;
    the reason we need to enable it is because if we've got 3D objects or objects
    that are further away from us or nearer to us, we need to plan for depth. So,
    let's go to our code and below `glViewport` we'll add the `glEnable()` function;
    to do this, we'll pass `GL_DEPTH_TEST`. Then, we'll go to the while loop, and
    in the `glClear()` function we'll need to specify depth to clear the depth buffer,
    so add `| GL_DEPTH_BUFFER_BIT` to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we''ve implemented depth in our application, we''re going update the
    indices and the vertices present in our code. We are implementing a 3D cube in
    this section to help illustrate perspective and orthographic projection. Therefore,
    we''ll have to make modifications to our vertices and get rid of our indices.
    To add the updated vertices to your code, please refer to the `main.cpp` present
    inside the `Projections and Coordinate Systems` folder. You''ll observe that there
    are vertices for two types of projections: orthographic projection and the perspective
    projection. We''ll be switching between the two of them to understand the difference
    between the two projections. In the updated vertices, we have defined six sets
    of vertices and texture coordinates, each one for a face of the cube. For your
    reference, check out a set of vertices for one side of the cube that is mentioned
    in the following and let''s try to understand what it defines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the first three values in a row are the x, y and z positions,
    and the next two are the normalized texture coordinates. We covered pretty much
    all of this in the previous section. It is recommended that you take a look at
    each one of these sets and try to figure out which face of the cube they correlate
    to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, once we''ve updated the vertices, we need to make some modifications
    to our attributes, so take look at the updated attributes, as follows, and make
    similar changes to our code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have updated the factor by which we multiply size
    of vertices to `5` because there are five different pieces of information on each
    row in our updated vertices.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of our texture loading, we won't touch any of that code whatsoever,
    as that is defining our texture perfectly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, after we''ve unbinded the texture and cleaned it up, and before the `while`
    loop starts, we are going to define the projection matrix `glm::mat4 projection;`,
    The first one we''re going to discuss is perspective projection, because that''s
    the one that you''ll probably be using most of the time. Therefore, we''ll add
    `projection = glm::perspective()`; the `perspective()` takes a few values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first value is the field of view, and, for that, we're going to use 45 degrees.
    This is a very common value for video games.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The second value is the aspect ratio, and, for that, we'll add `screenWidth
    / screenHeight`. This keeps it dynamic. We're going to cast each to `GLfloat`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For the third value (the near clipping plane), we'll just add `0.1f`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For the fourth value (the far clipping plane), we'll use `1000.0f`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the following highlighted code to understand the previous description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: View Frustum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try to understand the preceding description of code with the help of
    a simple View Frustum image, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1fb8ca0b-0f34-4afa-bccb-b183108d6da2.png)'
  prefs: []
  type: TYPE_IMG
- en: The center of projection is where the virtual camera is placed. **zNear** is
    the near clipping plane, which we have defined as `0.1f` in our code. The `1000.0f`
    value refers to the far clipping plane, which is **zFar**. These two values mean
    that anything nearer than the near clipping plane won't be drawn for you on the
    screen, anything further than the far clipping plane won't be drawn for you, and
    anything outside of the view frustum box won't be drawn for you either. The aspect
    ratio is the **width** divided by the **height**, and the field of view is basically
    how tall it is.
  prefs: []
  type: TYPE_NORMAL
- en: Modifications to while loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve created the projection matrix, we can actually start creating
    the model and the view matrices, and you need to do that within our while loop.
    Let''s take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: So, to begin with, we're going to get rid of the code that defines our transformation
    matrix, as we're no longer using that. We'll move the `glActiveTexture()` code
    before we activate our shader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After that, we''re going to create the model and view matrices, for which we''ll
    add the following code to our while loop after we have activated our shader. We''ll
    begin with adding the `glm:: mat4 model` and `glm::mat4 view` matrix. The model
    will be `model = glm::rotate ()`, and we''ll just put an initial sort of rotation
    in `rotate ()`. For the `rotate ()`, we''re going to pass following parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First we'll pass `model`, which refers to the model matrix
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Second for the angle of rotation, we're just going to pass the `glfwGetTime()`,
    which will get the time between starting GLFW and now. This is obviously only
    going to constantly increase, hence we can use this as a nice way of providing
    rotation. We'll cast this function to `GLfloat`, then we'll multiply it by `1.0f`.
    This is a great way of increasing and decreasing the speed, as all you have do
    is vary the value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information about angle of rotation, please refer to the information
    box that was provided earlier with links for SFML, SDL, and GLFW, for you to check
    out.
  prefs: []
  type: TYPE_NORMAL
- en: The next parameter that we're going to provide is the vector 3 matrix `glm::vec3()`,
    and for `vec3()` we're going to use `0.5f` in the x axis, `1.0f` in the y axis
    and we're not going to have any rotation in the z axis. This is going to add a
    nice effect to our cube.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we are going to type `view = glm::translate()`. In here, we're going to
    move the view slightly. So, in the `translate ()`, we'll first pass our view matrix;
    then we specify what sort of movement we want, so will type `glm::vec3()` ; and
    to `vec3()` we're going to pass `0.0f`, `0.0f`, `-3.0f` for the axes. So we're
    going to be moving the camera, which is essentially so we can actually see what
    is going on. Otherwise, we'd principally be within our cube only.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Take a look at the following code to understand the preceding description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've got that sorted, you might be wondering why we are adding a rotation
    and a translation matrix. This is just for this particular section to get a better
    view of the projections. You may not want to add a rotation or a translation matrix
    to further sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, to get the uniform location, we''ll add following highlighted lines of
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need to draw our object, so we're going to add `glBindVertexArray()`,
    and to that we'll pass the the vertex array object `VAO`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll then add `glDrawArrays ()` to that, firstly, we''ll pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Firstly `GL_TRIANGLES`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondly, the first vertex will start at `0`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For the count we'll pass `36`, because there are two triangles per face and
    each triangle has three coordinates. The two triangles result in six coordinates,
    so 6 x 6 = 36\.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we'll unbind it, so we're going to add `glBindVertexArray()` to which
    we'll pass `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are all sorted, let''s recheck the code once and then run it. If you
    don''t come across any errors, you will get a similar rotating cube on your screen
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2070aef-a86f-4d35-9055-beaede154c82.png)'
  prefs: []
  type: TYPE_IMG
- en: Orthgraphic projection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's just see how orthgraphic projection looks, and understand the difference
    between orthographic and perspective projections. So, we're going to comment the
    perspective-projection coordinates and add the orthagraphic-projection coordinates
    from the `main.cpp` present inside the `Projections and Coordinate Systems` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we''ll go to our `glm::mat4 projection;` and comment out the perspective
    projection, and add the following highlighted line of code for the orthographic
    projection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You may be wondering where the field of view and the ratio are. We don''t need
    those because the cube is more like the box shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/586e2d48-4151-4342-85b5-2e6fc2342905.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we''ve only other two things that needs to be changed, those are the model
    and the view matrices, simply because this will help to demonstrate what we''re
    trying to show. So, comment out the perspective-projection model and view definitions,
    and add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run this code and see what our cube looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d27bd157-402e-4567-94e0-344ab418e48f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So we''ve got our cube, but this looks a bit weird. It just looks like a big,
    long rectangle. But what''s actually happening is that the image facing us is
    the front face of the cube and the top rectangular image is the top face of the
    cube. We''ve rotated the cube, but without perspective, and it''s hard to tell
    which face is which. But let''s try an experiment and watch what happens when
    we comment out the orthagraphic `view` and uncomment the perspective `view`. Let''s
    bring in the perspective projection again, uncomment the perspective array, and
    comment out the orthagraphic array. Now if we run the code with the perspective
    projection, you''ll see a key difference between orthographic and perspective
    projections; take a look at the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/446d1a27-20fc-4c92-9ff8-f3a4ce252efb.png)'
  prefs: []
  type: TYPE_IMG
- en: Looking at the preceding image now, it blatantly looks more like a cube. Obviously,
    we can't see the sides, the bottom, or the back face, but, based on what we're
    seeing here, it looks much more like a cube compared to how it looked before.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Camera class to the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned how to add objects to our screen and how
    to apply texture, transformation and projection to the objects. As we progress
    ahead in the book, we will add various objects to our screen, but as we add more
    objects to it and if we wish to view those from different angles, we don't want
    to have specific code to be able to do that or to move freely around the objects.
    Therefore, in this chapter, we'll be looking at implementing a `Camera` class,
    which will help us to move around our world freely, using the keyboard, and view
    those objects from different angles. Implementing this class will help us to improvise
    a walking style of movement and take a look at the virtual world around the player
    with the help of the mouse. As we learned in the previous chapter, what we've
    got currently is the single cube we've created. As we are seeking to implement
    multiple objects in this chapter, we'll basically get rid of the vertices that
    describe our single cube, and use a simple array of vertices and a loop to draw
    multiple cubes. Instead of just moving around one cube, we'll see multiple cubes,
    which will be fantastic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the things we''re going to cover in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning how to draw multiple cubes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the `Camera` class and implementing it in our current application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are just a few prerequisites before we get started. We'll use the source
    code from the previous chapter, which was on projections and coordinate systems.
    If you don't have the source code, you can download it from the GitHub link provided
    in the preface of this book. Also, in this chapter, we'll be using GLFW as the
    framework. This means we will be using some GLFW coding here, but this is actually
    only for the input of what we're doing. Feel free to check out the input guides
    for other libraries too, try to swap the code with other libraries, and try experimenting.
    The `Camera` class that we are going to define in this chapter won't be affected
    by your experimentation, as it isn't going to have any framework-specific code.
    Only the main code will be affected, as it's going to be used to detect the input.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Camera.h header file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll begin by creating a header file for our `Camera` class, so we''ll create
    an empty header file in our project and add it to our target. We''ll name it `Camera.h`.
    We''ll only have a header because the methods that we''re going to implement are
    very simple methods. But you can extract it into a separate CPP file if you want
    to. It is recommended that you try experimenting that way as well, because it
    will be a great way to learn. Let''s begin coding our camera header. Follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, let's get rid of the default code that is already present in the file.
    Then, add `#pragma` when the code is a simpler version. This doesn't work on all
    compilers, but most compilers will support this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we'll add the `#include` vector. We'll be using the `vector` class for
    stuff such as positioning. Let's then add `#define GLEW_STATIC`, because we're
    going to be using GLEW in here, which we've already linked to our project. Next,
    we'll add `#include GL/glew.h`. We're also going to include some OpenGL Mathematics
    libraries, so let’s add `glm/glm.hpp` and `#include glm/gtc/matrix_transform.hpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we're going to create an enumeration to define several possible options
    for camera movement. Let’s add `enum Camera_Movements`. This will contain `FORWARD`,
    `BACKWARD`, `LEFT` and `RIGHT`, which we need to use to find out which way the
    user wants to move the camera -- essentially, to identify which way a user wants
    to walk.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we're going to create some constant camera values for the yaw, pitch, and
    speed of the camera movement, and sensitivity and zoom. We're not going to have
    methods for these, apart from for the zoom, but you can have methods for all the
    other ones. You can create getters and setters; it is recommended that you do
    this as an extra task. It's a great way of learning and you'll be able to use
    them later on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, we''re going to add `const`. Obviously, at the moment, because we''re using
    a constant, you won''t be able to modify it, but if you do want to modify it,
    that''s not a problem. But these are the default values, so you wouldn''t be manipulating
    this particular variable specifically. You''d be manipulating the variables within
    the Camera class, which we''re going to create in a short while. So, add `const
    GLfloat YAW = -90.0f;`. Then add `const GLfloat PITCH = 0.0f` and `const GLfloat
    SPEED = 6.0f`. This is the value of speed that we’ve discovered works well with
    the camera and screen; you can manipulate it to make it slower and faster, as
    you desire. A higher value is faster and a lower value is slower. Next, add `const
    GLfloat SENSITIVITY = 0.25f`. This defines the sensitivity of our mouse movement.
    Again, the higher the value, the faster the mouse movement, and the lower the
    value, the slower the mouse movement. Now we''re going to include `const GLfloat
    ZOOM`. The zoom value is the field of view, so a value of 45 degrees is very common.
    A higher value would basically mean a taller screen. It''s essentially what the
    old games used, so you can try that. Check out the following code to understand
    the preceding description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''re going to create a Camera class and then type `public`. We''re
    going to create a constructor with vectors first, and then a constructor with
    scalar values. Let’s begin by adding `Camera ()`, which will take the parameters
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''re going to quickly implement our camera constructor, so add the
    following lines for the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''re done with this particular constructor, we''re going to add
    the constructor with scalar values to our code. Add the following lines to your
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''re going to implement a getter for getting the view matrix, because
    this''ll return the view matrix that is calculated using Euler angles and the
    `lookAt` matrix. We''re going to add `glm::mat4`, and we’re going to call it `GetViewMatrix(
    )`. We''ll use this in our `main.cpp`, and we’ll add the following highlighted
    line of code to that class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is basically just stating where we want to look; we want to be looking
    in front, obviously; and we want to use the up vector so we've made it relative.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''re going to just process some keyboard input; using this keyboard input,
    we''ll detect if we''re going forward, backward, left, or right, and we''ll move
    in that direction. So let’s add the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This `Camera_Movement` is the `enum` that we created in the preceding steps.
    `GLfloat deltaTime` is the time between frames, so we can create frame-independent
    movement, because the last thing you want is to have 60 frames per second and
    suddenly dip to 30 frames, which is half the speed. You want it to be the same
    speed, obviously. It won't look as smooth, but you'll still get a consistent movement,
    and that is what is important.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in the code file, we''re going to add the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding lines of code, we added `GLfloat velocity` and assigned it
    the value of `movementSpeed * deltaTime`. So, let's say the `movementSpeed` is
    `5`, for example, and the `deltaTime` is `0.1`, so the `GLfloat velocity` would
    be `0.5`. Hence, if it's a higher delta time, it'll have a higher movement speed.
    If it's a lower delta time, it'll have a lower movement speed. This just keeps
    it all frame-rate independent. Next, we added `if` statements to check the direction
    in which the user is moving. If the user is moving in any particular direction,
    then the `position += this front * velocity`, where `velocity` is equal to the
    value that we've already calculated.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering why we aren't using a switch statement or why we aren't
    using an `if else/if else` series. First, let's say you clicked the forward key
    and the left key, then you want to be able to move essentially in a northwest
    direction. Ignoring which way we're looking—so let's assume we're just looking
    north - you want to be able to move northwest. You don't want to have to press
    one key, then let go, then press another key. Likewise, if you're moving forward
    and you click backwards, you'll stop. You don't want to be having to release keys;
    this is the reason we're using separate `if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we''ll do is process the mouse movement. This will process the
    input received from our mouse system, whether that''s GLFW, SDL, or SFML, and
    it will use an offset value so it can adjust the x and y direction. So, we''re
    going to add `void ProcessMouseMovement()` and pass `GLfloat xOffset` to it. This
    is essentially the difference between the mouse movements, because, otherwise,
    how do we know where we''re moving to? We essentially need to think about the
    speed. Then add `GLfloat yOffset, GLboolean constrainPitch` to constrain the pitch
    and set that equal to true. Now we''re going to calculate the offset, and we''ll
    adjust that using our `mouseSensitivity`. We''ll add the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''re going to check if the pitch is constrained by using the if statement.
    We want to prevent the user from being able to go out of bounds, so that the screen
    doesn''t get flipped if we move our mouse, or effectively the way we look, to
    the left and to the right; if we move to the left for too long, we''ll loop back
    round. The same is true for the right direction (that is, anti-clockwise and clockwise.
    When you look up and down, you generally only want to be able to look up by about
    90 degrees, which is roughly what your head can do, and then just look down by
    roughly 90 degrees to your feet, which is again approximately what your head can
    do. You don''t want to be able to just keep looping back round, because you''ll
    start getting all sorts of different problems, such as gimbal lock. But, in general,
    that''s not the sort of movement that you have in games, because games are based
    on real life and the constraints of the human body. So we''re going to check the
    pitch. If `pitch > 89.0f`, then we''ll assign the pitch as `89.0f`. If `pitch
    < -89.0f`, we''ll assign the pitch as `-89.0f`. Finally, we’ll update the camera
    vectors by adding `this->updateCameraVectors( );`. This will update the front,
    right, and up vectors using the Euler angles that we''ve defined here. Take a
    look at the following code to understand the preceding description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've processed the mouse movement, we're going to process the mouse
    scroll, so we’ll add `void ProcessMouseScroll()`, and we'll pass `GLfloat yOffset`
    to that.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use `xOffset` if you want to be able to detect the horizontal scroll.
    A lot of mice don't have horizontal scroll, but quite a few new mice, especially
    gaming mice and productivity mice, do. But, generally speaking, you probably only
    want to detect movement in the y axis--that is, vertical scroll. But you can easily
    extend this method, and this class in general, to suit your requirements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following `if` statements to your code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''re going to create a getter for getting the zoom, because the zoom
    variable will be private. Actually, all the variables are private in this class.
    We''re only really creating the zoom getter simply because it''s the only one
    we''re using outside of this class for now. But if you need to use something such
    as the up vector, the yaw, the pitch, or any of the other variables that we''re
    creating, feel free to create appropriate getters and setters. Therefore, we’ll
    next add following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''re going to do define the camera attributes, so we’ll add following
    lines of code to our camera class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Feel free to visit [learnopengl.com](http://learnopengl.com) and [open.gl](http://open.gl),
    and check out those websites for more in-depth written information and some nice
    diagrams regarding all the different variables and the methods that we have discussed
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we’ll add some Euler angles to our class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'All of these parameters that we''ve been using are finally getting created.
    Next, we’ll add some camera options to our code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to add into this class is `void updateCameraVectors`,
    and, when we''re updating the camera vectors, we need to calculate the new front
    vector, so we''ll add `glm::vec3 front`, which is temporary storage for it. Then
    we''ll add `front.x`, and we’ll assign a value of `cos ( glm::radians( this->yaw
    ))` multiplied by `cos( glm::radians( this->pitch ) )` to it. Again, the mathematical
    calculations here are obviously quite complex and quite in depth, so we would
    recommend you check out the aforementioned links. Take a look at the following
    code to understand what other elements will be added to `updateCameraVectors`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: With this last line of code, we have finally completed the `Camera` class. Please
    check out the `camera.h` file for the entire code. This file is present inside
    the `camera` folder in the `Getting started` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Making modifications to main.cpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have created our `Camera` class, let’s go back to our `main.cpp`
    and make some modifications to it, such as implementing multiple cubes on our
    screens, adding a camera class, and moving through the multiple objects.
  prefs: []
  type: TYPE_NORMAL
- en: In our `main.cpp`, we'll start implementing the input stuff that we've been
    doing. So, we're going to use the GLFW for our input system, but, again, feel
    free to check out the previous links for more information on the GLFW, SFML, and
    SDL input systems.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin with including our `Camera` class in our code. Add `#include Camera.h`
    at the start of the code,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, in the section where we define our screen dimensions, we’ll make the
    following modifications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's just replace every `screenWidth` and `screenHeight` we’ve used with
    `SCREEN_WIDTH`, and `SCREEN_HEIGHT`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we’ll be using perspective projection, we need to get rid of all the orthographic
    projection code as we're not using that anymore.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, before we start with our `int main`, we’re going to create some function
    prototypes. Add the following lines of code to your `main.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we first added `void KeyCallback( )`; this is where
    the framework-specific code starts. To that function we passed `GLFWwindow *window`,
    and then we needed to check what key was pressed, so we added `int key`, `scancode`,
    `action` and `mode`. We then added the rest of the functions. In the `MouseCallback(
    )`, we passed `double xPos` and `double yPos`. These are the x and y positions
    of our mouse in our window. We''re actually going to hide the mouse cursor to
    provide a more immersive experience. Then, we added one final method prototype
    to the preceding code: `void DoMovement`. This method will be called in every
    single frame, and this''ll move our camera. Even if we haven''t made any movement,
    it''ll still be called, but it won''t obviously move our camera.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we just need to initially set some values up for our camera, so we''re
    going to add `Camera`, create a `camera ( )` object, and we’ll pass `glm::vec3
    ( )` to it. To the `vec3( )`, we’ll pass `0.0f`, `0.0f`, `3.0f`. These are just
    the initial values. Next, we’ll add `GLfloat lastX`, which is the last position
    of the camera, initially. We''ll make it equal to the center of the screen, so
    this is going to be our mouse movement. We''ll add `WIDTH / 2.0` and `GLfloat
    lastY = WIDTH / 2.0f;`. Take a look at the following to understand this description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Below this will be a `bool` of keys, which will be an array of 1,024 different
    types of key. We’re going to add `bool firstMouse = true`, as we’re handling one
    type of mouse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will add `deltatime` and `lastframe`, which will be used in the code
    to determine the time between frames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in our int main, after our `glfwMakeContextCurrent( window );` we are
    going to add `glfwSetKeyCallback( );` and to that we’ll provide `window`; we''ll
    provide the method that we''re using, which is `KeyCallback`; and then we''ll
    duplicate this line of code three times and make following highlighted modifications
    to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are calling the function prototypes that we have defined previously.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we want to fix our mouse to the center of our screen, within the window
    itself, so we’ll add `glfwSetInputMode( )` and we’ll pass `window`to it. As the
    mode that we're changing is the cursor, we'll pass `GLFW_CURSOR` with a value
    of `GLFW_CURSOR_ DISABLED` to it, as we don't want the cursor to be totally disabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As we are going to render multiple cubes in this code, we'll create an array
    of vectors, which will contain the cubes' positions. These are just arbitrary
    positions, so you can change them later to experiment with those. Go to the `main.cpp`
    file in the `Camera` folder, and copy and paste the array of vectors `glm::vec3
    cubePositions[]` to your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we''re going to move the projection code inside the while loop, because
    we''re going to change the field of view using the mouse scroll, so we want to
    be able to update the projection every single frame if we''re actually changing
    the field-of-view value. So, after we’ve activated our shader code and binded
    texture using texture units, add the projection code and make the following changes
    to it:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'After the start of the while loop, we''ll set the frame time, so we’ll add
    `GLfloat currentFrame = glfwGetTime()`. Then we’ll add `deltaTime = currentFrame
    - lastFrame`. This is our way of detecting the time between the frames. If, let''s
    say, our current frame is at time 100 and our last frame was at time 80, the time
    between the last frame and the current frame would be 20--though it''d normally
    be a second or millisecond. Then we’ll add `lastFrame = the currentFrame`, as
    the last frame will be the current frame when we restart this while loop on the
    next iteration, because we''ll have a different frame at that particular moment.
    Refer to the following code to understand the description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: After we've handled all the events, we're actually going to handle the movement,
    so add `DoMovement()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we’ll go to the section in the code where we have defined the `view` and
    model matrix, and make the following modifications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you must have noticed that we got rid of model-matrix
    code, which is because we're going to put that inside a for loop that will iterate
    over our cube-position array, draw the objects in different locations, and use
    the model to generate sort of a random rotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Between binding the vertex array to the vertex-array object, and unbinding
    it, we''re essentially going to add a for loop in which we''re going to pass a
    parameter as `GLuint i = 0; i < 10; i++`. It is recommended that you to try to
    make it dynamic, so you can add more cube positions and you can draw more cubes.
    That''d be another great task for you. We’ll add the following highlighted statements
    to the for loop. First of all, we''re going to calculate the model matrix for
    each object, and then pass it to our shader before we start drawing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We used a value of `20.0` in the preceding code as it's just a calculated value.
    Try varying this value and see what happens. You might find a better value than
    that. We have cut and pasted the `glUniformMatrix4fv();` from the while loop.
    Now we are done with our while loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can start to implement those function prototypes, which is the last
    thing to do before we can run the code and observe our output. After the end of
    while loop, we''ll add `void DoMovement()`, which is going to handle our movement
    and call the appropriate keyboard method in our Camera class. So, this is not
    going to take in any parameters, but we will add some if statements. We want to
    use the *W, A, S, D* and arrow keys, so we’re going to pass the condition as `keys[GLFW_KEY_W]
    || keys[GLFW_KEY_UP]`. In the if statement, we’ll add `camera.ProcessKeyboard(
    FORWARD, deltaTime );` because we''re moving forward, and we''ll add `deltaTime`,
    which we''ve already calculated in our while loop. This is the code for moving
    forward. Similarly, we’ll add statements for all other directions; take a look
    at the following highlighted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''re going to do a callback, so we''ll add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can add the `MouseCallback`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we are going to add `void ScrollCallback()`, to which we will pass the
    following parameters: `GLFWwindow *window, double xOffset, double yOffset`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside that method we are going to add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''re ready to see if this works, so run it. Once it has been compiled
    error free, you’ll get to see the following output :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d57175b-37ee-4583-a692-932065bfdf0c.png)'
  prefs: []
  type: TYPE_IMG
- en: We've created our multiple cubes, and we can look around and move. We can use
    the *W*, *A*, *S*, and *D* keys and arrow keys to move around. So we can move
    not just forward and backward, but forward and right, forward and left, back and
    right, and back and left. What's great about this camera system is the forward
    is relative to the way we're looking. So, if we look at a particular cube, then
    press forward, it moves towards our cube. If we try to go through the cube, we'll
    go through and we’ll get to see the inverse of the textures. The reason we can
    go through it is simply because there's no collision detection.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to apply transformations such as rotation to
    our shape, and learned to draw a cube and apply texture to it. Then, we explored
    the concepts of projections, Perspective and Orthographic, and implemented those
    in our game world.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll talk about lighting, its effects and sources of light
    that we have in OpenGL
  prefs: []
  type: TYPE_NORMAL
