- en: '19'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exception Safety
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will guide you through the complexities of exception safety. It
    demystifies the levels of exception safety, distinguishing between basic and strong
    guarantees, underscoring their significance, and offering proven strategies to
    achieve them. Mastering these advanced topics allows you to create more resilient,
    efficient, and adaptable C++ applications and data structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic exception safety
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strong exception safety
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The effect of `noexcept` on STL containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code in this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  prefs: []
  type: TYPE_NORMAL
- en: Basic exception safety
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Basic exception safety**, colloquially termed the *guarantee*, pledges that
    your program won’t leak resources when an exception occurs and its invariants
    are preserved. Simply put, the software won’t devolve into chaos. When unforeseen
    exceptions occur, the operation might fail, but your application continues functioning,
    and no data gets mangled.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Two real-world examples of unforeseen exceptions that can be effectively managed
    without causing resource leaks or data corruption include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**File operation failure during data processing**: Consider an application
    that processes large data files. During this process, the application might encounter
    an unexpected exception, such as a failure to read a portion of the file due to
    disk I/O errors. In this case, basic exception safety ensures the application
    does not leak resources (such as file handles or memory allocated for data processing).
    It maintains the integrity of any data structures involved. The application might
    not complete the intended file processing. Still, it will handle the exception
    gracefully, freeing up any resources and leaving the application in a stable state
    to continue functioning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network communication interruption in a client-server application**: In a
    client-server application, an unforeseen exception might occur if the network
    connection is suddenly lost during a critical data exchange. Basic exception safety
    in this scenario ensures that the application does not end up with partial or
    corrupted data states. The system might fail to complete the current operation
    (such as updating a record or retrieving data), but it will effectively manage
    resources such as network sockets and memory buffers. The application will catch
    the exception, clean up resources, and ensure its core functionality remains intact
    and ready for subsequent operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pivotal role of program invariants in the STL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine you’re crafting a sophisticated application, and at its heart lies the
    C++ `std::vector`, `std::map`, or any other, operates under specific invariants.
    A `std::vector` container, for instance, guarantees contiguous memory. If any
    operation disrupts these invariants, the results can range from performance penalties
    to insidious bugs.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure basic exception safety with the STL, you need to ascertain that operations
    on these containers either succeed or, if they throw an exception, leave the container
    in its original state without violating its invariants. For instance, if a `push_back`
    operation on `std::vector` throws an exception, the vector should remain untouched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how we could use basic exception safety when pushing
    data into `std::vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, if an exception occurs (i.e., due to `bad_alloc` if the system
    runs out of memory), the `catch` block handles it. Importantly, if `push_back`
    throws an exception, it guarantees that the state of the vector (`vec`) remains
    unchanged, thus preserving the container’s invariants.
  prefs: []
  type: TYPE_NORMAL
- en: Resource integrity – the guardian of robust software
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An exception thrown during a memory allocation or other resource-intensive tasks
    can spell disaster if not managed correctly. The STL, however, offers tools that,
    when used aptly, ensure that resources remain intact, even when exceptions loom.
  prefs: []
  type: TYPE_NORMAL
- en: STL containers such as `std::vector` and `std::string` handle their memory.
    If an exception arises during an operation, the container ensures no memory leaks
    occur. Moreover, the idiom **Resource Acquisition Is Initialization** (**RAII**),
    a hallmark of C++ design, assures that resources are acquired upon object creation
    and released when they go out of scope. The RAII principle is a sentinel against
    resource leaks, particularly during exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: RAII, is a programming idiom used in C++ to manage resource allocation and deallocation.
    In RAII, resources (such as memory, file handles, and network connections) are
    acquired and released by objects. When an object is created (initialized), it
    acquires a resource, and when the object is destroyed (its lifetime ends), it
    releases the resource. This ensures automatic and exception-safe resource management,
    preventing resource leaks and ensuring clean resource release even in the face
    of exceptions. RAII is a fundamental concept in C++ for effective resource management.
  prefs: []
  type: TYPE_NORMAL
- en: Harnessing the STL for basic exception safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the STL at your disposal and knowledge of its intricacies, achieving basic
    exception safety becomes less daunting. Consider the following best practices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Leveraging the copy-and-swap idiom**: When modifying STL containers, a common
    technique to ensure exception safety is to create a copy of the container, perform
    the operations on the copy, and then swap the contents with the original. If an
    exception arises, the original remains unaffected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::shared_ptr` and `std::unique_ptr` not only manage memory but also guarantee
    no leaks during exceptions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Guarded operations**: Before any irreversible operation on an STL container,
    always ensure that any operation that can throw an exception has already been
    executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Staying informed with STL documentation**: Familiarize yourself with the
    exception guarantees of STL functions and methods. Awareness of what exceptions
    a particular STL function might throw aids in crafting resilient software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embracing basic exception safety with the STL sets the stage for more resilient,
    reliable, and robust software. With this foundational understanding, you’re equipped
    to tackle the intricacies of STL, ensuring that even when the unexpected occurs,
    your software stands unyielding. But this is just the beginning, as the next level,
    strong exception safety, beckons, offering even more robust guarantees and strategies
    to wield the STL with finesse.
  prefs: []
  type: TYPE_NORMAL
- en: Strong exception safety
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you immerse yourself further into the intricate world of C++ and the STL,
    you’ll encounter the term *strong exception safety*. This is not just fancy jargon
    but also the gold standard in the STL’s exception handling. It guarantees developers
    an assurance like no other – operations will either complete successfully or revert
    to their previous state without any side effects. It’s like having a safety net
    that ensures, come what may, your application’s integrity remains unscathed.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating STL containers with strong guarantees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember those dynamic days spent with `std::vector`, `std::map`, and other
    STL containers? Now, think of adding elements, resizing, or even modifying them.
    When these operations succeed, it is business as usual. But if they falter and
    throw an exception, strong exception safety guarantees that the container remains
    as it was, untouched and unaltered.
  prefs: []
  type: TYPE_NORMAL
- en: Achieving this with STL containers, fortunately, doesn’t demand Herculean efforts.
    Many STL container operations naturally provide strong exception safety. But when
    they don’t, techniques such as the *copy-and-swap* idiom rescue them. By operating
    on a copy and swapping the contents with the original only when sure of success,
    you can guarantee no changes to the original container if an exception is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Crafting custom STL containers with strong guarantees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When venturing into the territory of creating custom STL containers, the responsibility
    to ensure strong exception safety rests squarely on your shoulders. Key strategies
    to achieve this include the following practices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Localized commit points**: By delaying any changes that affect the container’s
    state until the very last moment and ensuring that these changes are exception-free
    once started, you solidify a strong guarantee.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RAII to the forefront**: Harnessing the might of RAII, especially with resource
    management, is pivotal. This ensures that resources are appropriately managed
    and cleaned up if there are exceptions, leaving the container unchanged.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Immutable operations**: Whenever possible, design operations that don’t modify
    the container until they’re sure of success.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To illustrate the concept of creating custom STL containers with strong guarantees,
    let’s consider the example of a custom container that manages a dynamic array.
    The code will demonstrate localized commit points, the RAII idiom, and immutable
    operations to provide strong exception safety.
  prefs: []
  type: TYPE_NORMAL
- en: First, we are going to create the `CustomArray` class. The `CustomArray` class
    is a template class designed to manage dynamic arrays of a specified data type,
    `T`. It provides essential functionalities for creating, copying, moving, and
    managing dynamic arrays with a strong exception guarantee. The class uses RAII
    principles and leverages `std::unique_ptr` for resource management, ensuring efficient
    and safe memory handling. It supports both copy and move semantics, making it
    suitable for use in various scenarios, such as dynamic array manipulation and
    container reallocation. Let’s walk through this in sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will break this example up into several sections to discuss here. For the
    full code example, please refer to the GitHub repository. First, we will look
    at the constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We provided three constructors for our class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`explicit CustomArray(size_t size)`: This is the primary constructor of the
    `CustomArray` class. It allows you to create an instance of the class by specifying
    the desired size for the dynamic array. It initializes the `size` member variable
    with the provided size and allocates memory for the dynamic array, using `std::make_unique`.
    It also initializes the elements of the array with default values (assuming that
    type `T` can be safely default-constructed), using `std::fill`. This constructor
    is marked as `explicit`, meaning it cannot be used for implicit type conversions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CustomArray(const CustomArray &other)`: This is the copy constructor of the
    `CustomArray` class. It allows you to create a new `CustomArray` object that is
    a copy of an existing `CustomArray` object, `other`. It initializes the `size`
    member with the size of `other`, allocates memory for the dynamic array, and then
    uses the `safeCopy` function to perform a deep copy of the data from `other` to
    the new object. This constructor is used when you want to create a new copy of
    an existing object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CustomArray(CustomArray &&other)noexcept`: This is the move constructor of
    the `CustomArray` class. It enables you to efficiently transfer ownership of the
    data from one `CustomArray` object (typically `rvalue`) to another. It transfers
    the ownership of the dynamically allocated array from `other` to the current object
    using `std::move`, updates the `size` member, and sets `size` of `other` to zero
    to indicate that it no longer owns the data. This constructor is marked `noexcept`
    to ensure a strong guarantee during container reallocation, meaning it won’t throw
    exceptions. It’s used when you want to move the contents of one object into another,
    typically for optimization purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, let’s look at the assignment operator overloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we provided two overloads of the assignment operator. These two member
    functions are assignment operators for the `CustomArray` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CustomArray &operator=(const CustomArray &other)`: This is the copy assignment
    operator. It allows you to assign the contents of one `CustomArray` object to
    another of the same type. It performs a deep copy of the data from `other` to
    the current object, ensuring that both objects have independent copies of the
    data. It also updates the `size` member and transfers ownership of the new data
    using `std::move`. The operator returns a reference to the current object, allowing
    for chaining assignments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CustomArray &operator=(CustomArray &&other) noexcept`: This is the move assignment
    operator. It allows you to efficiently transfer ownership of the data from one
    `CustomArray` object (typically `rvalue`) to another. It moves `std::unique_ptr`
    containing the data from `other` to the current object, updates the `size` member,
    and sets `size` of `other` to zero to indicate that it no longer owns the data.
    This operator is marked `noexcept` to ensure a strong guarantee during container
    reallocation, meaning it won’t throw exceptions. Like the copy assignment operator,
    it returns a reference to the current object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To summarize this example, the `CustomArray` class demonstrates the following
    principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '`data`) is only changed at commit points, such as at the end of the copy assignment
    operator, after the success of all operations that could potentially throw an
    exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unique_ptr` manages the dynamic array, ensuring that memory is automatically
    deallocated when the `CustomArray` object goes out of scope or an exception occurs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Immutable operations**: Operations that could throw exceptions, such as memory
    allocation and copying, are performed on temporary objects. The container’s state
    is modified only when these operations are guaranteed to have succeeded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This example follows C++ and STL best practices and uses modern C++ features,
    ensuring a custom container that respects strong exception safety guarantees.
  prefs: []
  type: TYPE_NORMAL
- en: Infusing exception safety into custom STL algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Algorithms dance in harmony with data. In the STL, ensuring that custom algorithms
    provide strong exception safety guarantees can be the difference between an efficient
    application and one riddled with unpredictable behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure this, you should keep the following in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Operate on copies**: Wherever feasible, operate on a copy of the data, ensuring
    the original remains unmodified if exceptions are thrown.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Atomic operations**: Design algorithms where operations, once started, are
    completed successfully or can be rolled back without side effects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception safety is the path to robust applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Strong exception safety is more than just a tenet – it is a commitment to the
    reliability and robustness of your application. When wielding the STL, its containers,
    and its algorithms or venturing into creating your own, this guarantee stands
    as a bulwark against unforeseen exceptions and unpredictable behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: By ensuring that operations either see through to their successful completion
    or restore the original state, strong exception safety not only elevates the reliability
    of applications but also imbues developers with confidence that their software
    can weather the storms of exceptions, leaving the integrity of their data and
    resources intact.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we wrap up our exploration of exception safety in the STL. As we
    explored basic and strong guarantees, the hope is that you’re now equipped with
    the knowledge and tools to craft resilient and dependable C++ applications. And
    remember that in the dynamic world of software development, it is not just about
    preventing exceptions but also ensuring we’re prepared when they arise. Next,
    we will examine the use of `noexcept` on STL operations.
  prefs: []
  type: TYPE_NORMAL
- en: The effect of noexcept on STL operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++ STL gives a rich assortment of data structures and algorithms that greatly
    simplify programming in C++. Exception safety is a critical aspect of robust C++
    programming, and the `noexcept` specifier plays a pivotal role in achieving it.
    This section elucidates the impact of noexcept on STL operations and how its correct
    application can enhance the reliability and performance of STL-based code.
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to noexcept
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Introduced in C++11, `noexcept` is a specifier that can be added to function
    declarations to indicate that the function is not expected to throw exceptions.
    When a function is declared with `noexcept`, it enables specific optimizations
    and guarantees that make exception handling more predictable. For instance, when
    an exception is thrown from a `noexcept` function, the program calls `std::terminate`,
    as the function violated its contract of not throwing exceptions. Hence, `noexcept`
    is a commitment that a function promises to uphold.
  prefs: []
  type: TYPE_NORMAL
- en: Application to STL data types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using `noexcept` with STL data types primarily affects the move operations –
    move constructors and move assignment operators. These operations are fundamental
    to the performance of STL containers, since they allow the transfer of resources
    from one object to another without costly deep copies. When these operations are
    `noexcept`, STL containers can safely perform optimizations, such as reallocating
    buffers more efficiently during resizing operations.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a scenario with `std::vector`, an STL container that dynamically resizes
    itself as elements are added. Suppose the vector holds objects of a type whose
    move constructor is `noexcept`. In that case, the vector can reallocate its internal
    array by moving the objects to the new array without the overhead of handling
    potential exceptions. If the move constructor is not `noexcept`, the vector must
    use the copy constructor instead, which is less efficient and might throw exceptions,
    leading to a potential partial state and loss of strong exception safety.
  prefs: []
  type: TYPE_NORMAL
- en: Application to STL algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The impact of `noexcept` extends beyond data types to algorithms. STL algorithms
    can offer stronger guarantees and perform better when working with functions that
    are `noexcept`. For example, `std::sort` can execute more efficiently if its comparison
    function does not throw exceptions. The algorithm can optimize its implementation,
    knowing that it does not need to account for the complications that arise from
    exception handling.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take the `std::for_each` algorithm, which applies a function to a range
    of elements. If the used function is marked as `noexcept`, `std::for_each` can
    operate with the understanding that exceptions will not interrupt the iteration.
    This can lead to better inlining and reduced overhead, as the compiler does not
    need to generate additional code to handle exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the lambda function passed to `std::for_each` is declared `noexcept`.
    This informs the compiler and the algorithm that the function is guaranteed not
    to throw any exceptions, allowing potential performance optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: The `noexcept` specifier is a powerful tool for C++ developers, providing performance
    optimizations and semantic guarantees about exception safety. When applied judiciously
    to STL operations, `noexcept` enables STL containers and algorithms to operate
    more efficiently and reliably. Understanding and using `noexcept` appropriately
    is essential for intermediate-level C++ developers looking to write high-quality,
    exception-safe code with STL.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked to understand the crucial concept of exception safety
    with the STL. We explored the different levels of exception safety, namely basic
    and strong guarantees, and outlined strategies to ensure that your programs are
    resilient to exceptions. We learned how to maintain program invariants and resource
    integrity through detailed discussions, mainly focusing on RAII principles and
    guarded operations to prevent resource leaks and maintain container states during
    exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding exception safety is indispensable for writing robust C++ applications.
    It ensures that, even in the face of errors, your software’s integrity remains
    intact, preventing resource leaks and preserving the validity of data structures.
    This knowledge is the backbone of reliable and maintainable code, as it allows
    us to uphold strong guarantees that our applications will behave predictably under
    exceptional conditions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, titled *Thread Safety and Concurrency with the STL*, we
    will build upon the foundation of exception safety to tackle the intricacies of
    concurrent programming in C++.
  prefs: []
  type: TYPE_NORMAL
