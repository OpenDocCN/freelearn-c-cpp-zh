- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: A Perfectly Decoupled System
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完美解耦的系统
- en: In the previous chapter, we learned about interfaces and event delegates and
    how they can be used as tools to remove the need for unnecessary object references
    within our program structures. This was the concept of decoupling.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了接口和事件委托以及它们如何作为工具来消除程序结构中不必要的对象引用的需求。这就是解耦的概念。
- en: In this chapter, we will take the concept of decoupling and extrapolate it throughout
    our system design. We will look at a structure that should provide a robust framework
    for any system and the standard method for planning it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨解耦的概念，并将其扩展到我们的系统设计中。我们将研究一种应该为任何系统提供强大框架的结构和规划它的标准方法。
- en: 'In this chapter, we’ll cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Using UML to plan a sample hierarchy
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 UML 规划示例层次结构
- en: Decoupling the reference train
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解耦参考列车
- en: By the end of this chapter, you will be able to architect complex game communication
    hierarchies in a fully decoupled and modular way. This will allow you to build
    more maintainable and expandable systems that enable development team cohesion.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够以完全解耦和模块化的方式构建复杂的游戏通信层次结构。这将使你能够构建更易于维护和扩展的系统，从而促进开发团队的协作。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter will be focused on implementing the tools from [*Chapter 6*](B18297_06.xhtml#_idTextAnchor076)
    in the same project, linked on GitHub.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将专注于在同一项目中实现 [*第 6 章*](B18297_06.xhtml#_idTextAnchor076) 中的工具，该工具在 GitHub
    上有链接。
- en: If you want to jump straight in at this point, you can download the *chapter7*
    branch from GitHub at [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter07](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter07)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想直接进入这一部分，你可以从 GitHub 下载 *chapter7* 分支，网址为 [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter07](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter07)。
- en: Otherwise, the planning section only really requires a pen and paper or a free
    drawing tool. Once the purpose and vocabulary of UML diagrams have been grasped,
    there are helpful online tools for speeding up their generation. The easiest to
    use is Mermaid ([https://mermaid.live](https://mermaid.live)), which provides
    a text editing interface for diagram editing. It presents as a paid service if
    you wish to save multiple diagrams, but seeing as every element of your diagram
    or chart is serialized as text in the URL, shown in the address bar of your browser,
    a simple copy and paste of the URL into a notes app will save the diagram. Other
    tools include Photoshop and Paint or dedicated drawing tools such as drawio.com
    ([https://www.drawio.com/](https://www.drawio.com/)) and whimsical.com ([https://whimsical.com/](https://whimsical.com/)).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，规划部分只需一支笔和一张纸或一个免费的绘图工具。一旦掌握了 UML 图表的目的和词汇，就有助于加快生成图表的在线工具。最易使用的是 Mermaid
    ([https://mermaid.live](https://mermaid.live))，它提供了一个文本编辑界面用于图表编辑。如果你希望保存多个图表，它将作为一个付费服务提供。但鉴于你的图表或图表的每个元素都作为文本序列化在
    URL 中，显示在浏览器的地址栏中，只需简单地将 URL 复制粘贴到笔记应用中即可保存图表。其他工具包括 Photoshop 和 Paint 或专门的绘图工具，如
    drawio.com ([https://www.drawio.com/](https://www.drawio.com/)) 和 whimsical.com
    ([https://whimsical.com/](https://whimsical.com/))。
- en: Using UML to plan a sample hierarchy
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 UML 规划示例层次结构
- en: '**Unified Modeling Language** (**UML**) is a tool that programmers use to visually
    communicate the structure of large systems during the design phase and when creating
    technical documentation. Classes are represented as boxes, with relationships
    shown through different types of arrows linking the boxes.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**统一建模语言** (**UML**) 是程序员在设计阶段和创建技术文档时用于视觉传达大型系统结构的工具。类以框的形式表示，通过不同类型的箭头连接框来显示关系。'
- en: What are the types of class relations?
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类关系有哪些类型？
- en: Let us take a look at different types of class relations and how they are presented
    using UML class diagrams.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看不同类型的类关系以及它们如何通过 UML 类图来表示。
- en: Inheritance
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继承
- en: Standard arrows, as seen in *Figure 7**.1*, show inheritance with the parent
    being indicated by the end with the arrow head.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 标准箭头，如图 7**.1** 所示，用箭头尾端表示父类，显示继承关系。
- en: '![Figure 7.1 – An example of a UML class diagram showing inheritance syntax](img/Figure_07.01_B18297.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – 显示继承语法的 UML 类图示例](img/Figure_07.01_B18297.jpg)'
- en: Figure 7.1 – An example of a UML class diagram showing inheritance syntax
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 一个显示继承语法的 UML 类图示例
- en: In *Figure 7**.1*, the **Character** and **Vehicle** classes inherit from the
    **Pawn** class.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 7.1 中，**Character** 和 **Vehicle** 类从 **Pawn** 类继承。
- en: Composition
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组合
- en: '**Composition** is a type of class relation where the composed classes give
    the parent class the functionality. This tool is seen a lot with multi-functional
    classes being broken down into their separate functions then composed together
    into a wrapper. You can show composition with a solid diamond at the end of a
    line.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**组合** 是一种类关系类型，组合类给父类提供功能。这个工具在多功能类被分解成它们各自的功能然后组合成一个包装器时经常被看到。你可以通过在一条线的末端放置一个实心菱形来表示组合。'
- en: '![Figure 7.2 – An example UML class diagram showing composition syntax](img/Figure_07.02_B18297.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 一个示例 UML 类图，展示组合语法](img/Figure_07.02_B18297.jpg)'
- en: Figure 7.2 – An example UML class diagram showing composition syntax
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 一个示例 UML 类图，展示组合语法
- en: In *Figure 7**.2*, **GameGrid** composes a reference to **Pathfinder** and **FogManager**.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 7.2 中，**GameGrid** 组合了对 **Pathfinder** 和 **FogManager** 的引用。
- en: Aggregation
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 聚合
- en: '**Aggregation** is a concept crucial to designing decoupled systems as it quite
    literally represents the coupling that is present. At some point in the communication
    chain, for objects to communicate, at least a one-way connection must be established.
    Aggregation is when that connection is between two non-dependent classes. Similar
    to composition, aggregation is also shown by a line with a diamond at the head
    but the diamond for aggregation is just an outline.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**聚合** 是设计解耦系统的一个关键概念，因为它确实代表了存在的耦合。在通信链中的某个时刻，为了对象能够通信，至少需要建立一个单向连接。聚合就是这种连接在两个非依赖类之间时的情况。与组合类似，聚合也通过一个头部带有菱形的线来表示，但聚合的菱形只是一个轮廓。'
- en: '![Figure 7.3 – An example UML class diagram showing aggregation syntax](img/Figure_07.03_B18297.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – 一个示例 UML 类图，展示聚合语法](img/Figure_07.03_B18297.jpg)'
- en: Figure 7.3 – An example UML class diagram showing aggregation syntax
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 一个示例 UML 类图，展示聚合语法
- en: '*Figure 7**.3* shows **Pawn** and **Widget** aggregated into **PlayerController**.
    Both can exist and function without this connection so it is an aggregation.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3* 展示了 **Pawn** 和 **Widget** 聚合到 **PlayerController** 中。两者都可以在没有这种连接的情况下存在和运行，因此这是一个聚合。
- en: What is a sequence diagram?
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是序列图？
- en: In addition to the UML class diagrams we’ve explored so far, UML has more forms
    it can take. A **sequence diagram**, shown in *Figure 7**.4*, shows the execution
    of functions between objects over time. This is a crucial way to show how signals
    get around your class structures. Using a sequence diagram after something goes
    wrong can help identify what a call stack should look like at different lines
    of execution to pinpoint errors.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们之前探索的 UML 类图之外，UML 还有更多形式。图 7.4* 中所示的 **序列图** 显示了对象之间随时间执行函数。这是展示信号如何在类结构中传递的关键方式。在出现问题后使用序列图可以帮助确定在不同执行行上调用栈应该是什么样子，以定位错误。
- en: '![Figure 7.4 – An example UML sequence diagram](img/Figure_07.04_B18297.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – 一个示例 UML 序列图](img/Figure_07.04_B18297.jpg)'
- en: Figure 7.4 – An example UML sequence diagram
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 一个示例 UML 序列图
- en: In *Figure 7**.4*, we are communicating an initialization chain from **GameMode**
    through **PlayerController** to **Character**. The sequence diagram helps us see
    that when the **Character Init** function is executing, our call stack should
    be three deep and what order each class is in the chain. These diagrams are necessary
    for clarifying key communications but, as with all UML, it can have the opposite
    effect if it tries to encompass too much at once.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 7.4 中，我们正在传达从 **GameMode** 通过 **PlayerController** 到 **Character** 的初始化链。序列图帮助我们看到当
    **Character Init** 函数正在执行时，我们的调用栈应该是三层的，以及每个类在链中的顺序。这些图对于阐明关键通信是必要的，但就像所有的 UML
    一样，如果试图一次性包含太多内容，可能会产生相反的效果。
- en: With these tools in our belt, we can better describe the structures coming up
    in this chapter to other developers. The benefit of using UML over coding segments
    is in its standardization and agnosticism, meaning the programmer we show this
    to doesn’t need to speak the same language to understand what we mean.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些工具，我们可以更好地向其他开发者描述本章中出现的结构。使用 UML 而不是代码段的好处在于其标准化和通用性，这意味着向我们展示这个的程序员不需要说同样的语言就能理解我们的意思。
- en: Decoupling references is a key skill for all developers in all object-oriented
    languages to understand. With universal methods of communication such as UML,
    we can establish a precedent and enforce it across all levels of development.
    Let's now use loads of sequence diagrams and aggregation to fix some messy, heavily
    coupled code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 解耦引用是所有面向对象语言开发人员都需要理解的关键技能。通过像UML这样的通用通信方法，我们可以建立先例并在所有开发级别强制执行。现在让我们使用大量的序列图和聚合来修复一些混乱、高度耦合的代码。
- en: Decoupling the reference train
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解耦参考列车
- en: Now let’s take knowledge of these three connection types and see how we can
    associate every class in the example UML class diagram that follows, using a few
    rules. Once everything is associated, we’ll implement decoupling in an example
    and look at the benefits this brings.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解这三种连接类型，并看看我们如何可以使用一些规则将以下示例UML类图中的每个类关联起来。一旦一切都被关联起来，我们将在一个示例中实现解耦，并看看这带来的好处。
- en: Modularity and decoupling
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块化和解耦
- en: We’ll start with a bunch of scattered classes, which are organized in a way
    that will function but is messy to work with, as shown in *Figure 7**.5*. To make
    everything function here clearly, the developer has added references, as and when
    needed, to any class.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一些散乱的类开始，这些类以某种方式组织起来可以工作，但使用起来很混乱，如*图7.5*所示。为了使这里的一切都能清楚地工作，开发者已经根据需要为任何类添加了引用。
- en: '![Figure 7.5 – Example UML showing a messy system](img/Figure_07.05_B18297.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5 – 示例UML展示一个混乱的系统](img/Figure_07.05_B18297.jpg)'
- en: Figure 7.5 – Example UML showing a messy system
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 示例UML展示一个混乱的系统
- en: 'Let’s analyze how the **Character** to **Projectile** interaction occurs by
    looking at the sequence diagram in *Figure 7**.6*. When the character *fires*,
    it spawns a projectile but then doesn’t hold onto the reference. Instead, the
    projectile grabs a reference to the character and when it hits an AI unit, this
    reference is used to feed back whether it killed anything through a function call.
    Why is this bad? It’s not necessarily going to impact the final built game, but
    it does make the code involved in this interaction single-use. If an enemy unit
    wants to fire, due to it being a different setup, we are left with two bad options:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看*图7.6*中的序列图来分析**角色**到**投射物**的交互是如何发生的。当角色*发射*时，它会生成一个投射物，但随后并不保持对参考的持有。相反，投射物获取对角色的引用，当它击中一个AI单位时，这个引用被用来通过函数调用反馈是否击中了任何东西。这为什么是坏事？这并不一定会影响最终构建的游戏，但它确实使得涉及此交互的代码成为单次使用。如果一个敌方单位想要发射，由于它是一个不同的设置，我们只剩下两个糟糕的选择：
- en: Bastardization through inheritance and overloading functions, thereby breaking
    several of our SOLID principles
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过继承和函数重载来破坏我们的SOLID原则
- en: Repeat ourselves in a new actor, which, as we know, should ring alarm bells
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个新的演员中重复自己，正如我们所知，这应该会响起警钟
- en: '![Figure 7.6 – Example UML sequence diagram showing the complexity of a messy
    interaction](img/Figure_07.06_B18297.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6 – 示例UML序列图展示混乱交互的复杂性](img/Figure_07.06_B18297.jpg)'
- en: Figure 7.6 – Example UML sequence diagram showing the complexity of a messy
    interaction
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – 示例UML序列图展示混乱交互的复杂性
- en: 'The solution to this problem is modularity and decoupling. We need to establish
    a hierarchy where each class is connected to a single tree, where connections
    represent ownership. The first step is to analyze class responsibilities. The
    **Character** class currently takes care of too many areas. It deals with player
    representation in the world but also weapon logic. Due to this logic possibly
    being duplicated in the AI enemy class, it makes sense to spin it out into its
    own class that can be shared. Linking this into an aggregation chain with the
    **GameMode** at the top, flowing down through the **Character** and **Weapon**
    to the **Projectile**, gives us the tree we were aiming for from the start, as
    shown in *Figure 7**.7*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是模块化和解耦。我们需要建立一个层次结构，其中每个类都连接到一个单一的树，其中连接表示所有权。第一步是分析类的职责。当前的**角色**类负责太多领域。它处理世界中的玩家表示，但也处理武器逻辑。由于这种逻辑可能在AI敌方类中重复，因此将其拆分出来成为一个可以共享的类是有意义的。将这个类链接到一个聚合链中，从顶部的**游戏模式**开始，通过**角色**和**武器**流向**投射物**，我们就得到了一开始就想要的树，如图*图7.7*所示：
- en: '![Figure 7.7 – A UML class diagram showing classes in a tree structure](img/Figure_07.07_B18297.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7 – 一个显示树结构的UML类图](img/Figure_07.07_B18297.jpg)'
- en: Figure 7.7 – A UML class diagram showing classes in a tree structure
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 – 一个显示树结构的UML类图
- en: In general terms, the tree we established in *Figure 7**.7* is conceptual. There
    could be pointers to owned classes in parents for practicality, but it mostly
    exists in the design document. In Unreal, everything below the PlayerController
    can be spawned at runtime, which helps to make the structure more concrete. All
    spawned objects can be cached as `TObjectPtr<T>` variables, with `T` being the
    exact type we need. To link the tree up above the `PostLogin` and `Logout` functions
    of `AGameModeBase`, PlayerControllers can be cached in a `TArray<TObjectPtr<APlayerController>>`
    for later use. If you want to make a distinction between AIController and PlayerController
    in the structure, then you will need to store them separately. PlayerControllers
    can be cached via the `PostLogin` function with a cast to the respective base
    type as needed, but AIControllers must be cached when the AI-controlled pawn is
    spawned and accessed via the instigator reference.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从一般意义上讲，我们在*图7.7*中建立的树是概念性的。为了实用性，父母类中可能会有指向所拥有类的指针，但它主要存在于设计文档中。在虚幻引擎中，PlayerController之下的所有内容都可以在运行时生成，这有助于使结构更加具体。所有生成的对象都可以作为`TObjectPtr<T>`变量缓存，其中`T`是我们需要的确切类型。为了将树与`AGameModeBase`的`PostLogin`和`Logout`函数链接起来，可以将PlayerControllers缓存到`TArray<TObjectPtr<APlayerController>>`中以便后续使用。如果你想在结构中区分AIController和PlayerController，那么你需要将它们分别存储。PlayerControllers可以通过`PostLogin`函数进行缓存，并根据需要将其转换为相应的基类型，但AIControllers必须在AI控制的单位生成和通过施动者引用访问时进行缓存。
- en: Important note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Be aware that `PostLogin` only fires for PlayerControllers, yet `Logout` deals
    with all controller types, including AI. This makes defensive coding important
    in `Logout`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`PostLogin`只为PlayerControllers触发，而`Logout`处理所有控制器类型，包括AI。这使得在`Logout`中进行防御性编码变得重要。
- en: '![Figure 7.8 – Repeat of Figure 7.7 but with more detail showing how classes
    are connected](img/Figure_07.08_B18297.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图7.8 – 图7.7的重复，但提供了更多细节，展示了类之间的连接](img/Figure_07.08_B18297.jpg)'
- en: Figure 7.8 – Repeat of Figure 7.7 but with more detail showing how classes are
    connected
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 – 图7.7的重复，但提供了更多细节，展示了类之间的连接
- en: '*Figure 7**.8* shows how the different methods described in this section could
    be used to connect the classes in memory.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.8*展示了本节中描述的不同方法如何用于在内存中连接类。'
- en: Establishing infrastructure
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建立基础设施
- en: 'The next step is to start establishing infrastructure, such as public functions,
    event delegates, and interfaces, to provide entry and exit points for signals.
    Each fulfills a very specific purpose:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是开始建立基础设施，例如公共函数、事件委托和接口，为信号提供入口和出口点。每个都履行一个非常具体的目的：
- en: '**Public functions** are used for communication when there is a cached variable
    reference of the correct type. Following the aggregation lines that represent
    this connection, as shown in *Figure 7**.8*, all function calls will happen to
    head down the tree through the chain of ownership.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共函数**用于在存在正确类型的缓存变量引用时进行通信。遵循表示此连接的聚合线，如图*图7.8*所示，所有函数调用都将通过所有权链向下传递到树的顶端。'
- en: '**Event delegates** allow anonymous communication when the listener has a cached
    variable reference for the event’s class. This ends up being the exact opposite
    of the public function calls, allowing communication to back up the reference
    chain toward the top of the tree.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件委托**允许在监听者有事件类的缓存变量引用时进行匿名通信。这最终与公共函数调用相反，允许通信沿着参考链向上传递。'
- en: '`AActor*` reference that can be gained at runtime, usually via some kind of
    collision event, the interface can be used to invoke some kind of function without
    needing to know the exact type of the receiver.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在运行时获得的`AActor*`引用，通常通过某种类型的碰撞事件，该接口可用于调用某种函数，而无需知道接收者的确切类型。
- en: 'This boils down to a simple communication rule: *functions down, events up,
    and interfaces sideways*. The result is a decoupled system in which each class
    only has reference to the one layer below it and yet signals can be sent all over
    with ease.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这归结为一个简单的通信规则：*函数向下，事件向上，接口横向*。结果是解耦系统，其中每个类只对其下一层有引用，但信号可以轻松地发送到各个地方。
- en: Implementing decoupled design in an example
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在示例中实现解耦设计
- en: 'The best way to embed decoupled design into your process is to practice it.
    As a start, we will focus on how using the player character in our example project
    can receive points shown on the UI for eliminating enemy units. We will start
    with the UML class diagram shown in *Figure 7**.9*:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将解耦设计嵌入到您的过程中的最佳方式是练习它。作为一个开始，我们将关注如何在我们的示例项目中使用玩家角色接收UI上显示的消除敌人单位所获得的分数。我们将从*图7.9*中显示的UML类图开始：
- en: '![Figure 7.9 – Planned UML class diagram for the linked project](img/Figure_07.09_B18297.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图7.9 – 链接项目的计划UML类图](img/Figure_07.09_B18297.jpg)'
- en: Figure 7.9 – Planned UML class diagram for the linked project
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 – 链接项目的计划UML类图
- en: 'Next, we will overlay the signal path onto the UML, as shown in *Figure 7**.10*:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将像*图7.10*中所示的那样，将信号路径叠加到UML上：
- en: '![Figure 7.10 – Signal path overlayed on UML class diagram](img/Figure_07.10_B18297.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图7.10 – UML类图上叠加的信号路径](img/Figure_07.10_B18297.jpg)'
- en: Figure 7.10 – Signal path overlayed on UML class diagram
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 – UML类图上叠加的信号路径
- en: 'Overlaying the signal path onto the UML will allow us to plan the infrastructure
    effectively, producing a UML sequence diagram, as shown in *Figure 7**.11*:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将信号路径叠加到UML上，将使我们能够有效地规划基础设施，生成如图*图7.11*所示的UML序列图：
- en: '![Figure 7.11 – UML sequence diagram showing the signal path for killing an
    enemy](img/Figure_07.11_B18297.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图7.11 – 显示杀死敌人信号路径的UML序列图](img/Figure_07.11_B18297.jpg)'
- en: Figure 7.11 – UML sequence diagram showing the signal path for killing an enemy
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 – 显示杀死敌人信号路径的UML序列图
- en: To put this decoupled plan into practice, head to the folder labeled [*Chapter
    7*](B18297_07.xhtml#_idTextAnchor090) in the example project. Open the level in
    this folder and take the following steps. Whenever a class is mentioned, please
    use the [*Chapter 7*](B18297_07.xhtml#_idTextAnchor090) version denoted by `_CH7`
    in the class and filenames. All of the following code is for you to add and embellish
    as you see fit. All the needed classes have been created already. This exercise
    only requires you to add the new code to the areas specified by the protection-level
    tags. Any new variables will need to be linked up in the inspectors of the Blueprint
    children in the editor, but this is made clear at the end of this section.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这个解耦计划付诸实践，请前往示例项目中标记为[*第7章*](B18297_07.xhtml#_idTextAnchor090)的文件夹。打开该文件夹中的层级，并按照以下步骤操作。每当提到一个类时，请使用类和文件名中标记为`_CH7`的[*第7章*](B18297_07.xhtml#_idTextAnchor090)版本。所有以下代码都是供您根据需要添加和修饰的。所有需要的类都已经创建好了。这个练习仅要求您将新代码添加到由保护级标签指定的区域。任何新的变量都需要在编辑器中蓝图子项的检查器中链接起来，但这一点在本节末尾已经讲得很清楚。
- en: Stepping through the implementation, let’s start at the top in the game mode.
    `GameMode_CH7` will have links to `PlayerController_CH7` and any AI spawned in
    the level. This may work better with an AI manager for larger games, but we have
    no need to over-complicate the process. These references are cast to the correct
    types and cached. After casting, `listener` functions can be attached to the event
    delegates on the controllers, establishing the first link, but we haven’t made
    any controllers yet so we will return here once the initialization chain is complete.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现步骤中，让我们从游戏模式的最顶部开始。`GameMode_CH7`将链接到`PlayerController_CH7`以及在该层级中生成的任何AI。对于大型游戏，这可能需要一个AI管理器来工作得更好，但我们没有使过程过于复杂的必要。这些引用被转换为正确的类型并缓存起来。转换后，可以将`listener`函数附加到控制器上的事件委托，从而建立第一个链接，但我们还没有创建任何控制器，所以一旦初始化链完成，我们就会返回这里。
- en: The GameMode header is a simple set of holder variables and the start of the
    initialization chain in a `BeginPlay` override.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameMode`头文件是一个简单的变量持有集和`BeginPlay`重写中的初始化链的开始。'
- en: Let's get started with the header file.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从头文件开始。
- en: GameMode_CH7.h excerpt
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: GameMode_CH7.h摘录
- en: '[PRE0]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The GameMode body deals with PlayerController initialization and reference registry
    in the `PostLogin` and `Logout` functions as that is what Unreal will automatically
    call when PlayerControllers enter and exit the game. This can be confusing as
    it is networking terminology but Unreal still uses it for single-player games.
    On the other hand, AIControllers are gathered and initialized on `BeginPlay` as
    they are assumed to be in the level already.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameMode`的主体处理`PlayerController`的初始化和引用注册，在`PostLogin`和`Logout`函数中，因为这是当`PlayerControllers`进入和退出游戏时Unreal会自动调用的。这可能有些令人困惑，因为这是网络术语，但Unreal仍然在单玩家游戏中使用它。另一方面，AIControllers在`BeginPlay`中被收集和初始化，因为它们被认为已经在层级中了。'
- en: So, now, we can set these up in the body file.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在主体文件中设置这些。
- en: GameMode_CH7.cpp excerpt
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: GameMode_CH7.cpp 简节
- en: '[PRE1]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, the controllers need to gain reference to and initialize the characters
    they are controlling. This is a simpler process than before as the controllers
    all spawn in their characters via an initialization chain. This means there is
    no need for casting; the characters are already the correct type. This also applies
    to the `ScoreWidget` class we will use to display the player’s score, which has
    been provided as part of the `Chapter` `Resources` folder.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，控制器需要获取它们所控制的角色的引用并初始化它们。这个过程比之前简单，因为所有控制器都是通过初始化链创建它们的角色。这意味着不需要进行类型转换；角色已经是正确的类型。这也适用于我们将用于显示玩家得分的
    `ScoreWidget` 类，它已经被作为 `Chapter` `Resources` 文件夹的一部分提供。
- en: The PlayerController header has a custom public function for initialization,
    a class reference to the type of pawn it would like to spawn, and an object reference
    to the actual pawn it has spawned.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: PlayerController 头文件包含一个用于初始化的自定义公共函数，一个指向它想要创建的 pawn 类型的类引用，以及一个指向它实际已创建的 pawn
    的对象引用。
- en: 'Write out the PlayerController header file as shown in the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下代码写出 PlayerController 头文件：
- en: PlayerController_CH7.h excerpt
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: PlayerController_CH7.h 简节
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the PlayerController body, we use the functions provided to us by Unreal
    within the GameMode class to spawn a new pawn of the type specified in the header
    at one of the player start points. The PlayerController then possesses it and
    calls the initialization function on that pawn.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PlayerController 主体中，我们使用 Unreal 在 GameMode 类中提供的函数在玩家起始点之一创建一个指定类型的新的 pawn。然后
    PlayerController 拥有它并调用该 pawn 的初始化函数。
- en: Let's set that up.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置一下。
- en: PlayerController_CH7.cpp excerpt
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: PlayerController_CH7.cpp 简节
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Down the other branch from the GameMode, our AIController header is similar
    to the PlayerController minus the reference to the class it would like to spawn,
    as with a standard Unreal AI setup the pawn is already in the world.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从 GameMode 的另一分支下来，我们的 AIController 头文件与 PlayerController 类似，只是没有指向它想要创建的类的引用，因为在标准的
    Unreal AI 设置中，pawn 已经在世界上。
- en: 'So, the header file for the AIController needs to be set out like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，AIController 的头文件需要设置如下：
- en: AIController_CH7.h excerpt
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: AIController_CH7.h 简节
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This point of the AIController being a generally simpler implementation extends
    to the initialization function. As there is no need to spawn any new pawns, we
    can simply get a reference to the currently possessed one and call its initialization
    function, passing the communication on.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: AIController 作为一个通常更简单的实现，这一点也扩展到了初始化函数。因为没有必要创建任何新的 pawn，我们可以简单地获取当前拥有的 pawn
    的引用，并调用它的初始化函数，传递通信。
- en: 'Write the Initialization function as shown:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下代码写出初始化函数：
- en: AIController_CH7.cpp excerpt
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: AIController_CH7.cpp 简节
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The last initialization is the `AIUnit` class. In the header, we have a variable
    to hold a `HealthComponent`, like the one we made at the end of [*Chapter 6*](B18297_06.xhtml#_idTextAnchor076),
    and a `listener` function to bind to the component’s event for death.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的初始化是 `AIUnit` 类。在头文件中，我们有一个变量来保存一个 `HealthComponent`，就像我们在 [*第 6 章*](B18297_06.xhtml#_idTextAnchor076)
    结尾处创建的那样，还有一个 `listener` 函数来绑定到组件的死亡事件。
- en: So, let's setup the AIUnit header.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们设置 AIUnit 的头文件。
- en: AIUnit _CH7.h excerpt
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: AIUnit _CH7.h 简节
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The body makes a new instance of a `HealthComponent` in the constructor and
    binds the `listener` function in the initialization.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 主体在构造函数中创建一个新的 `HealthComponent` 实例，并在初始化中绑定 `listener` 函数。
- en: We should now add the `HealthComponent` and initialization functions to the
    AIUnit body file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该将 `HealthComponent` 和初始化函数添加到 AIUnit 主体文件中。
- en: AIUnit _CH7.cpp excerpt
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: AIUnit _CH7.cpp 简节
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that all classes are initialized, we can step back up through the chain,
    adding the event delegates and their `listener` functions, starting with how the
    `AIUnit` responds to the health component death event. This needs to be done on
    both branches of the tree for the player and AI side, but we will only show the
    AI side as that is where the points come from. The listener should broadcast the
    `AIUnit` death event for now, including however many points this `AIUnit` was
    worth. This link is where animations and sound effects could be played to provide
    feedback to the player.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有类都已初始化，我们可以沿着链条向上移动，添加事件代理及其 `listener` 函数，从 `AIUnit` 如何响应健康组件的死亡事件开始。这需要在玩家和
    AI 侧的树形结构的两个分支上完成，但我们只展示 AI 侧，因为分数来自那里。目前，监听器应该广播 `AIUnit` 的死亡事件，包括这个 `AIUnit`
    值得多少分数。这个链接是播放动画和音效以向玩家提供反馈的地方。
- en: Extension task
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展任务
- en: The other damage event in the `HealthComponent` is being ignored for the purpose
    of explaining the process. As an extension task after finishing the chapter, try
    to hook this up so that when an AI character receives damage, it feeds through
    the chain to the controller and updates the health bar from there.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`HealthComponent` 中的另一个伤害事件在此处被忽略，以解释过程。作为本章完成后的扩展任务，尝试将其连接起来，以便当 AI 角色受到伤害时，它可以通过链条传递到控制器，并从那里更新生命条。'
- en: Adding the following code through the `AIUnit` header, we declare a new delegate
    type called `FAIUnitDeathSignature` with two parameters. This type is then used
    in the class header to make the `OnUnitDeath` public delegate. We also add an
    integer here so that we can balance the value of destroying the unit to the player.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `AIUnit` 头文件添加以下代码，我们声明了一个新的委托类型 `FAIUnitDeathSignature`，它有两个参数。然后，在类头文件中使用此类型来创建
    `OnUnitDeath` 公共委托。我们还添加了一个整数，这样我们就可以平衡摧毁单位对玩家的价值。
- en: So, lets add those to the header file.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们将这些添加到头文件中。
- en: AIUnit _CH7.h excerpt
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: AIUnit _CH7.h 摘录
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `AIUnit` body is much simpler though, as we are just using it to be a link
    in a chain, so once the `HealthComponent` death listener function fires, it can
    broadcast the new `OnUnitDeath` delegate and destroy the pawn.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`AIUnit` 实体结构要简单得多，因为我们只是用它作为链条中的一个链接，所以一旦 `HealthComponent` 的死亡监听器函数被触发，它就可以广播新的
    `OnUnitDeath` 代理并销毁 pawn。'
- en: Add the following code to the body file.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到主体文件中。
- en: AIUnit _CH7.cpp excerpt
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: AIUnit _CH7.cpp 摘录
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Following up the chain, the AIController can start listening to the AIUnit’s
    pass-through death event. This level is another pass-through for now, but could
    be where the controller recycles itself and finds another `AIUnit` to spawn depending
    on the gameplay loop.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着链条继续，AIController 可以开始监听 AIUnit 的透传死亡事件。这个级别现在是一个透传，但可能是控制器自我回收并找到另一个 `AIUnit`
    来生成的地方，这取决于游戏循环。
- en: The AIController header gets a similar set of items to the `AIUnit` with a new
    delegate type definition that takes two parameters. We don’t reuse the definition
    in the unit so that when we come to expand the game, these two classes aren’t
    tied to each other and can be swapped out as necessary. There is also a `private`
    function that matches the signature for the `AIUnit` `OnUnitDeath` delegate so
    it can be added as a listener.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: AIController 头文件得到了与 `AIUnit` 相似的一组项目，包括一个新的委托类型定义，它接受两个参数。我们不重用这个定义，以便在扩展游戏时，这两个类不会相互绑定，可以根据需要替换。还有一个与
    `AIUnit` `OnUnitDeath` 代理签名匹配的 `private` 函数，以便它可以作为监听器添加。
- en: Go ahead and add the following code to the header file.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请将以下代码添加到头文件中。
- en: AIController_CH7.h excerpt
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: AIController_CH7.h 摘录
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The AIController body binds the `listener` function to the `AIUnit OnUnitDeath`
    delegate right after the `Init` function is called. This way, we know that all
    variables inside the `AIUnit` have been set up correctly before we start listening
    for gameplay signals. The listener function itself is then just a passthrough
    broadcasting the `OnControllerDeath` delegate.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: AIController 主体在调用 `Init` 函数后立即将 `listener` 函数绑定到 `AIUnit OnUnitDeath` 代理。这样，我们知道在开始监听游戏信号之前，`AIUnit`
    内部的所有变量都已正确设置。监听器函数本身只是一个透传，广播 `OnControllerDeath` 代理。
- en: Let's add that to the code in the body file.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其添加到主体文件的代码中。
- en: AIController_CH7.cpp excerpt
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: AIController_CH7.cpp 摘录
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The GameMode can now link a listener function to all the AIControllers. This
    function just calls a `public` function on the PlayerController to increment its
    points for now, but it can be used as a jumping-off point to check against win
    conditions, and in a multiplayer scenario, make sure all players have an updated
    scoreboard via the `GameState`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: GameMode 现在可以将监听函数链接到所有 AIController。这个函数目前只是调用 PlayerController 的一个 `public`
    函数来增加其分数，但它可以用作检查胜利条件的起点，在多人游戏中，通过 `GameState` 确保所有玩家都有一个更新的分数板。
- en: This following excerpt shows where to add the listener function declaration
    in the GameMode header.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的简节显示了在 GameMode 头文件中添加监听函数声明的地方。
- en: GameMode_CH7.h excerpt
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: GameMode_CH7.h 简节
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the GameMode body, we then bind the listener function to each AIController
    right after we call the `Init` function on each one. This time, the listener function
    doesn’t simply broadcast another event, as this is where the communication reverses
    and starts going down another branch of the communication hierarchy that we designed
    earlier in the chapter. Instead, we call a function on the PlayerController telling
    it to add points. This is not strictly the best way of doing this, but it does
    show the structure cleanly. Ideally, you would check which controller needed the
    points based on the `causer` argument passed through the delegate chain.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GameMode 主体中，我们在对每个 AIController 调用 `Init` 函数之后立即将监听函数绑定到每个 AIController。这次，监听函数并不简单地广播另一个事件，因为这是通信反转并开始沿着我们在本章早期设计的通信层次结构中的另一个分支的地方。相反，我们调用
    PlayerController 上的一个函数，告诉它增加分数。这并不是严格上最好的做法，但它确实清晰地展示了结构。理想情况下，你会根据通过委托链传递的 `causer`
    参数检查哪个控制器需要分数。
- en: 'So, add the following code to the body file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将以下代码添加到主体文件中：
- en: GameMode_CH7.cpp excerpt
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: GameMode_CH7.cpp 简节
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The Player controller then needs to implement this `public` function so that
    when the game mode tells it to add points, it updates the UI as well. The UI references
    are included in the class for you already – that’s why they are missing from the
    header in the following code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Player 控制器需要实现这个 `public` 函数，以便当游戏模式告诉它增加分数时，它也会更新 UI。UI 引用已经包含在类中为你准备好了——这就是为什么在以下代码的头部中它们缺失的原因。
- en: The PlayerController header just needs the public accessor `AddPoints` function
    and a variable to store the current number of points. This is arbitrary but they
    must be stored somewhere, and this seems like as good a place as any to store
    them.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: PlayerController 头文件只需要 `AddPoints` 公共访问器函数和一个存储当前分数的变量。这是任意的，但它们必须存储在某处，而且这似乎是存储它们的好地方。
- en: 'So, let''s add these:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们添加以下内容：
- en: PlayerController_CH7.h excerpt
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: PlayerController_CH7.h 简节
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`AddPoints` does what it says on the tin, but also serves as a signal passthrough
    for the UI where we tell it to update the value shown onscreen with the new points
    value.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddPoints` 做如其名，但也作为 UI 的信号透传，我们告诉它用新的分数值更新屏幕上显示的值。'
- en: 'Add the following excerpt to the body file:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下简节添加到主体文件中：
- en: PlayerController_CH7.cpp excerpt
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: PlayerController_CH7.cpp 简节
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With that all done, you should be able to play the game as before from this
    new level, but when you destroy enemy AI units, the number at the top left of
    the viewport increases each time. This is the core of a game loop built in a decoupled
    way. Of course, our AI needs to fight back and there needs to be some balancing
    to make this into a good gameplay experience, but functionally it is all there.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些后，你应该能够从这个新关卡以之前的方式玩游戏，但是当你摧毁敌人 AI 单位时，视口左上角的数字会每次增加。这是以解耦方式构建的游戏循环的核心。当然，我们的
    AI 需要反击，并且需要一些平衡来使这个游戏体验变得更好，但从功能上讲，一切都在那里。
- en: Benefits of decoupling
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解耦的好处
- en: The benefit of setting things up in a decoupled way should now be evident. If
    we need to swap out game modes for a different objective-based mode, then we can
    do that as no class needs a direct reference to the game mode. As long as all
    the same functions are called and the events are listened to, everything will
    function. You can also check the size of the dependencies for each class using
    the method shown in [*Chapter 1*](B18297_01.xhtml#_idTextAnchor016) to see how
    small each class is in memory now that it has a reference to only one layer below
    itself and maybe an interface or two.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以解耦方式设置事物的优势现在应该很明显。如果我们需要为不同的基于目标的游戏模式进行交换，那么我们可以这样做，因为没有类需要直接引用游戏模式。只要调用所有相同的函数并监听事件，一切都会正常工作。你还可以使用[*第1章*](B18297_01.xhtml#_idTextAnchor016)中所示的方法来检查每个类的依赖关系大小，以查看现在每个类在内存中有多小，因为它只引用了自己下面的一层，可能还有一两个接口。
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With this chapter completed, you should be equipped to design communication
    hierarchies for games with a focus on anonymous modular design in UML for implementation
    within Unreal. We have covered the basics of UML and why it is useful as a planning
    and communication tool. Using this UML, we then set about taking a simple communication
    and anonymizing it using the event delegate tool from [*Chapter 6*](B18297_06.xhtml#_idTextAnchor076)
    to decouple the reference chain as much as we could. This anonymous modular should
    work for most communications you design from here on, with exceptions being extremely
    rare.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你应该能够设计以匿名模块化设计为重点的游戏通信层次结构，并在虚幻引擎中实现。我们已经介绍了UML的基本知识以及为什么它作为规划和沟通工具是有用的。使用这个UML，我们接下来着手将一个简单的通信匿名化，使用来自[*第6章*](B18297_06.xhtml#_idTextAnchor076)的事件委托工具，尽可能解耦引用链。这个匿名模块化应该适用于你从现在开始设计的绝大多数通信，例外情况极为罕见。
- en: In the next chapter, we are going to look at patterns you can set up as a library
    to move around with you between projects. We will look at why you should not overuse
    the singleton pattern, as most people do, and why you should make use of the command
    and state patterns in almost every project.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨你可以设置为库的模式，在项目之间移动。我们将探讨为什么你不应该过度使用单例模式，因为大多数人都是这样做的，以及为什么你应该几乎在每一个项目中都利用命令和状态模式。
- en: 'Part 3: Building on Top of Unreal'
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分：在虚幻引擎之上构建
- en: In this part, we will take the leap from looking at patterns that have already
    been scaffolded to making some of our own.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们将从查看已经搭建好的模式跃迁到创建我们自己的模式。
- en: Each chapter deals with a different category of pattern, starting with behavioral
    patterns that allow classes to serve their use more cleanly, through structural
    patterns that assist you when building systems for a large team to work on, to
    optimization patterns that aim to speed up your code. By the end of this section,
    you should have a host of patterns built in a modular way, ready to be transferred
    between projects.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 每一章都处理不同类别的模式，从允许类以更干净的方式服务的**行为模式**开始，通过**结构模式**帮助你在为大型团队构建系统时，到旨在加快你代码的**优化模式**。到本节结束时，你应该有一系列以模块化方式构建的模式，可以方便地在项目之间转移。
- en: 'This part has the following chapters:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 8*](B18297_08.xhtml#_idTextAnchor113)*, Building Design Patterns
    – Singleton, Command, and State*'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B18297_08.xhtml#_idTextAnchor113)*，构建设计模式 – 单例、命令和状态*'
- en: '[*Chapter 9*](B18297_09.xhtml#_idTextAnchor130)*, Structuring Code with Behavioral
    Patterns – Template, Subclass Sandbox, and Type Object*'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B18297_09.xhtml#_idTextAnchor130)*，使用行为模式结构化代码 – 模板、子类沙盒和类型对象*'
- en: '[*Chapter 10*](B18297_10.xhtml#_idTextAnchor148)*, Optimisation through Patterns*'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B18297_10.xhtml#_idTextAnchor148)*，通过模式进行优化*'
