- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Perfectly Decoupled System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about interfaces and event delegates and
    how they can be used as tools to remove the need for unnecessary object references
    within our program structures. This was the concept of decoupling.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will take the concept of decoupling and extrapolate it throughout
    our system design. We will look at a structure that should provide a robust framework
    for any system and the standard method for planning it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using UML to plan a sample hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decoupling the reference train
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to architect complex game communication
    hierarchies in a fully decoupled and modular way. This will allow you to build
    more maintainable and expandable systems that enable development team cohesion.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will be focused on implementing the tools from [*Chapter 6*](B18297_06.xhtml#_idTextAnchor076)
    in the same project, linked on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to jump straight in at this point, you can download the *chapter7*
    branch from GitHub at [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter07](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter07)
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, the planning section only really requires a pen and paper or a free
    drawing tool. Once the purpose and vocabulary of UML diagrams have been grasped,
    there are helpful online tools for speeding up their generation. The easiest to
    use is Mermaid ([https://mermaid.live](https://mermaid.live)), which provides
    a text editing interface for diagram editing. It presents as a paid service if
    you wish to save multiple diagrams, but seeing as every element of your diagram
    or chart is serialized as text in the URL, shown in the address bar of your browser,
    a simple copy and paste of the URL into a notes app will save the diagram. Other
    tools include Photoshop and Paint or dedicated drawing tools such as drawio.com
    ([https://www.drawio.com/](https://www.drawio.com/)) and whimsical.com ([https://whimsical.com/](https://whimsical.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: Using UML to plan a sample hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Unified Modeling Language** (**UML**) is a tool that programmers use to visually
    communicate the structure of large systems during the design phase and when creating
    technical documentation. Classes are represented as boxes, with relationships
    shown through different types of arrows linking the boxes.'
  prefs: []
  type: TYPE_NORMAL
- en: What are the types of class relations?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us take a look at different types of class relations and how they are presented
    using UML class diagrams.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Standard arrows, as seen in *Figure 7**.1*, show inheritance with the parent
    being indicated by the end with the arrow head.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – An example of a UML class diagram showing inheritance syntax](img/Figure_07.01_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – An example of a UML class diagram showing inheritance syntax
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 7**.1*, the **Character** and **Vehicle** classes inherit from the
    **Pawn** class.
  prefs: []
  type: TYPE_NORMAL
- en: Composition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Composition** is a type of class relation where the composed classes give
    the parent class the functionality. This tool is seen a lot with multi-functional
    classes being broken down into their separate functions then composed together
    into a wrapper. You can show composition with a solid diamond at the end of a
    line.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – An example UML class diagram showing composition syntax](img/Figure_07.02_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – An example UML class diagram showing composition syntax
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 7**.2*, **GameGrid** composes a reference to **Pathfinder** and **FogManager**.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Aggregation** is a concept crucial to designing decoupled systems as it quite
    literally represents the coupling that is present. At some point in the communication
    chain, for objects to communicate, at least a one-way connection must be established.
    Aggregation is when that connection is between two non-dependent classes. Similar
    to composition, aggregation is also shown by a line with a diamond at the head
    but the diamond for aggregation is just an outline.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – An example UML class diagram showing aggregation syntax](img/Figure_07.03_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – An example UML class diagram showing aggregation syntax
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7**.3* shows **Pawn** and **Widget** aggregated into **PlayerController**.
    Both can exist and function without this connection so it is an aggregation.'
  prefs: []
  type: TYPE_NORMAL
- en: What is a sequence diagram?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the UML class diagrams we’ve explored so far, UML has more forms
    it can take. A **sequence diagram**, shown in *Figure 7**.4*, shows the execution
    of functions between objects over time. This is a crucial way to show how signals
    get around your class structures. Using a sequence diagram after something goes
    wrong can help identify what a call stack should look like at different lines
    of execution to pinpoint errors.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – An example UML sequence diagram](img/Figure_07.04_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – An example UML sequence diagram
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 7**.4*, we are communicating an initialization chain from **GameMode**
    through **PlayerController** to **Character**. The sequence diagram helps us see
    that when the **Character Init** function is executing, our call stack should
    be three deep and what order each class is in the chain. These diagrams are necessary
    for clarifying key communications but, as with all UML, it can have the opposite
    effect if it tries to encompass too much at once.
  prefs: []
  type: TYPE_NORMAL
- en: With these tools in our belt, we can better describe the structures coming up
    in this chapter to other developers. The benefit of using UML over coding segments
    is in its standardization and agnosticism, meaning the programmer we show this
    to doesn’t need to speak the same language to understand what we mean.
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling references is a key skill for all developers in all object-oriented
    languages to understand. With universal methods of communication such as UML,
    we can establish a precedent and enforce it across all levels of development.
    Let's now use loads of sequence diagrams and aggregation to fix some messy, heavily
    coupled code.
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling the reference train
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let’s take knowledge of these three connection types and see how we can
    associate every class in the example UML class diagram that follows, using a few
    rules. Once everything is associated, we’ll implement decoupling in an example
    and look at the benefits this brings.
  prefs: []
  type: TYPE_NORMAL
- en: Modularity and decoupling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll start with a bunch of scattered classes, which are organized in a way
    that will function but is messy to work with, as shown in *Figure 7**.5*. To make
    everything function here clearly, the developer has added references, as and when
    needed, to any class.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Example UML showing a messy system](img/Figure_07.05_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Example UML showing a messy system
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s analyze how the **Character** to **Projectile** interaction occurs by
    looking at the sequence diagram in *Figure 7**.6*. When the character *fires*,
    it spawns a projectile but then doesn’t hold onto the reference. Instead, the
    projectile grabs a reference to the character and when it hits an AI unit, this
    reference is used to feed back whether it killed anything through a function call.
    Why is this bad? It’s not necessarily going to impact the final built game, but
    it does make the code involved in this interaction single-use. If an enemy unit
    wants to fire, due to it being a different setup, we are left with two bad options:'
  prefs: []
  type: TYPE_NORMAL
- en: Bastardization through inheritance and overloading functions, thereby breaking
    several of our SOLID principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeat ourselves in a new actor, which, as we know, should ring alarm bells
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Example UML sequence diagram showing the complexity of a messy
    interaction](img/Figure_07.06_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – Example UML sequence diagram showing the complexity of a messy
    interaction
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this problem is modularity and decoupling. We need to establish
    a hierarchy where each class is connected to a single tree, where connections
    represent ownership. The first step is to analyze class responsibilities. The
    **Character** class currently takes care of too many areas. It deals with player
    representation in the world but also weapon logic. Due to this logic possibly
    being duplicated in the AI enemy class, it makes sense to spin it out into its
    own class that can be shared. Linking this into an aggregation chain with the
    **GameMode** at the top, flowing down through the **Character** and **Weapon**
    to the **Projectile**, gives us the tree we were aiming for from the start, as
    shown in *Figure 7**.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – A UML class diagram showing classes in a tree structure](img/Figure_07.07_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – A UML class diagram showing classes in a tree structure
  prefs: []
  type: TYPE_NORMAL
- en: In general terms, the tree we established in *Figure 7**.7* is conceptual. There
    could be pointers to owned classes in parents for practicality, but it mostly
    exists in the design document. In Unreal, everything below the PlayerController
    can be spawned at runtime, which helps to make the structure more concrete. All
    spawned objects can be cached as `TObjectPtr<T>` variables, with `T` being the
    exact type we need. To link the tree up above the `PostLogin` and `Logout` functions
    of `AGameModeBase`, PlayerControllers can be cached in a `TArray<TObjectPtr<APlayerController>>`
    for later use. If you want to make a distinction between AIController and PlayerController
    in the structure, then you will need to store them separately. PlayerControllers
    can be cached via the `PostLogin` function with a cast to the respective base
    type as needed, but AIControllers must be cached when the AI-controlled pawn is
    spawned and accessed via the instigator reference.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that `PostLogin` only fires for PlayerControllers, yet `Logout` deals
    with all controller types, including AI. This makes defensive coding important
    in `Logout`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Repeat of Figure 7.7 but with more detail showing how classes
    are connected](img/Figure_07.08_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – Repeat of Figure 7.7 but with more detail showing how classes are
    connected
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7**.8* shows how the different methods described in this section could
    be used to connect the classes in memory.'
  prefs: []
  type: TYPE_NORMAL
- en: Establishing infrastructure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step is to start establishing infrastructure, such as public functions,
    event delegates, and interfaces, to provide entry and exit points for signals.
    Each fulfills a very specific purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Public functions** are used for communication when there is a cached variable
    reference of the correct type. Following the aggregation lines that represent
    this connection, as shown in *Figure 7**.8*, all function calls will happen to
    head down the tree through the chain of ownership.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event delegates** allow anonymous communication when the listener has a cached
    variable reference for the event’s class. This ends up being the exact opposite
    of the public function calls, allowing communication to back up the reference
    chain toward the top of the tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AActor*` reference that can be gained at runtime, usually via some kind of
    collision event, the interface can be used to invoke some kind of function without
    needing to know the exact type of the receiver.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This boils down to a simple communication rule: *functions down, events up,
    and interfaces sideways*. The result is a decoupled system in which each class
    only has reference to the one layer below it and yet signals can be sent all over
    with ease.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing decoupled design in an example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The best way to embed decoupled design into your process is to practice it.
    As a start, we will focus on how using the player character in our example project
    can receive points shown on the UI for eliminating enemy units. We will start
    with the UML class diagram shown in *Figure 7**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Planned UML class diagram for the linked project](img/Figure_07.09_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – Planned UML class diagram for the linked project
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will overlay the signal path onto the UML, as shown in *Figure 7**.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Signal path overlayed on UML class diagram](img/Figure_07.10_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – Signal path overlayed on UML class diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'Overlaying the signal path onto the UML will allow us to plan the infrastructure
    effectively, producing a UML sequence diagram, as shown in *Figure 7**.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – UML sequence diagram showing the signal path for killing an
    enemy](img/Figure_07.11_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – UML sequence diagram showing the signal path for killing an enemy
  prefs: []
  type: TYPE_NORMAL
- en: To put this decoupled plan into practice, head to the folder labeled [*Chapter
    7*](B18297_07.xhtml#_idTextAnchor090) in the example project. Open the level in
    this folder and take the following steps. Whenever a class is mentioned, please
    use the [*Chapter 7*](B18297_07.xhtml#_idTextAnchor090) version denoted by `_CH7`
    in the class and filenames. All of the following code is for you to add and embellish
    as you see fit. All the needed classes have been created already. This exercise
    only requires you to add the new code to the areas specified by the protection-level
    tags. Any new variables will need to be linked up in the inspectors of the Blueprint
    children in the editor, but this is made clear at the end of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Stepping through the implementation, let’s start at the top in the game mode.
    `GameMode_CH7` will have links to `PlayerController_CH7` and any AI spawned in
    the level. This may work better with an AI manager for larger games, but we have
    no need to over-complicate the process. These references are cast to the correct
    types and cached. After casting, `listener` functions can be attached to the event
    delegates on the controllers, establishing the first link, but we haven’t made
    any controllers yet so we will return here once the initialization chain is complete.
  prefs: []
  type: TYPE_NORMAL
- en: The GameMode header is a simple set of holder variables and the start of the
    initialization chain in a `BeginPlay` override.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started with the header file.
  prefs: []
  type: TYPE_NORMAL
- en: GameMode_CH7.h excerpt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The GameMode body deals with PlayerController initialization and reference registry
    in the `PostLogin` and `Logout` functions as that is what Unreal will automatically
    call when PlayerControllers enter and exit the game. This can be confusing as
    it is networking terminology but Unreal still uses it for single-player games.
    On the other hand, AIControllers are gathered and initialized on `BeginPlay` as
    they are assumed to be in the level already.
  prefs: []
  type: TYPE_NORMAL
- en: So, now, we can set these up in the body file.
  prefs: []
  type: TYPE_NORMAL
- en: GameMode_CH7.cpp excerpt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Next, the controllers need to gain reference to and initialize the characters
    they are controlling. This is a simpler process than before as the controllers
    all spawn in their characters via an initialization chain. This means there is
    no need for casting; the characters are already the correct type. This also applies
    to the `ScoreWidget` class we will use to display the player’s score, which has
    been provided as part of the `Chapter` `Resources` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The PlayerController header has a custom public function for initialization,
    a class reference to the type of pawn it would like to spawn, and an object reference
    to the actual pawn it has spawned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write out the PlayerController header file as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: PlayerController_CH7.h excerpt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the PlayerController body, we use the functions provided to us by Unreal
    within the GameMode class to spawn a new pawn of the type specified in the header
    at one of the player start points. The PlayerController then possesses it and
    calls the initialization function on that pawn.
  prefs: []
  type: TYPE_NORMAL
- en: Let's set that up.
  prefs: []
  type: TYPE_NORMAL
- en: PlayerController_CH7.cpp excerpt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Down the other branch from the GameMode, our AIController header is similar
    to the PlayerController minus the reference to the class it would like to spawn,
    as with a standard Unreal AI setup the pawn is already in the world.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the header file for the AIController needs to be set out like this:'
  prefs: []
  type: TYPE_NORMAL
- en: AIController_CH7.h excerpt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This point of the AIController being a generally simpler implementation extends
    to the initialization function. As there is no need to spawn any new pawns, we
    can simply get a reference to the currently possessed one and call its initialization
    function, passing the communication on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the Initialization function as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: AIController_CH7.cpp excerpt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The last initialization is the `AIUnit` class. In the header, we have a variable
    to hold a `HealthComponent`, like the one we made at the end of [*Chapter 6*](B18297_06.xhtml#_idTextAnchor076),
    and a `listener` function to bind to the component’s event for death.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's setup the AIUnit header.
  prefs: []
  type: TYPE_NORMAL
- en: AIUnit _CH7.h excerpt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The body makes a new instance of a `HealthComponent` in the constructor and
    binds the `listener` function in the initialization.
  prefs: []
  type: TYPE_NORMAL
- en: We should now add the `HealthComponent` and initialization functions to the
    AIUnit body file.
  prefs: []
  type: TYPE_NORMAL
- en: AIUnit _CH7.cpp excerpt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now that all classes are initialized, we can step back up through the chain,
    adding the event delegates and their `listener` functions, starting with how the
    `AIUnit` responds to the health component death event. This needs to be done on
    both branches of the tree for the player and AI side, but we will only show the
    AI side as that is where the points come from. The listener should broadcast the
    `AIUnit` death event for now, including however many points this `AIUnit` was
    worth. This link is where animations and sound effects could be played to provide
    feedback to the player.
  prefs: []
  type: TYPE_NORMAL
- en: Extension task
  prefs: []
  type: TYPE_NORMAL
- en: The other damage event in the `HealthComponent` is being ignored for the purpose
    of explaining the process. As an extension task after finishing the chapter, try
    to hook this up so that when an AI character receives damage, it feeds through
    the chain to the controller and updates the health bar from there.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the following code through the `AIUnit` header, we declare a new delegate
    type called `FAIUnitDeathSignature` with two parameters. This type is then used
    in the class header to make the `OnUnitDeath` public delegate. We also add an
    integer here so that we can balance the value of destroying the unit to the player.
  prefs: []
  type: TYPE_NORMAL
- en: So, lets add those to the header file.
  prefs: []
  type: TYPE_NORMAL
- en: AIUnit _CH7.h excerpt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `AIUnit` body is much simpler though, as we are just using it to be a link
    in a chain, so once the `HealthComponent` death listener function fires, it can
    broadcast the new `OnUnitDeath` delegate and destroy the pawn.
  prefs: []
  type: TYPE_NORMAL
- en: Add the following code to the body file.
  prefs: []
  type: TYPE_NORMAL
- en: AIUnit _CH7.cpp excerpt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Following up the chain, the AIController can start listening to the AIUnit’s
    pass-through death event. This level is another pass-through for now, but could
    be where the controller recycles itself and finds another `AIUnit` to spawn depending
    on the gameplay loop.
  prefs: []
  type: TYPE_NORMAL
- en: The AIController header gets a similar set of items to the `AIUnit` with a new
    delegate type definition that takes two parameters. We don’t reuse the definition
    in the unit so that when we come to expand the game, these two classes aren’t
    tied to each other and can be swapped out as necessary. There is also a `private`
    function that matches the signature for the `AIUnit` `OnUnitDeath` delegate so
    it can be added as a listener.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and add the following code to the header file.
  prefs: []
  type: TYPE_NORMAL
- en: AIController_CH7.h excerpt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The AIController body binds the `listener` function to the `AIUnit OnUnitDeath`
    delegate right after the `Init` function is called. This way, we know that all
    variables inside the `AIUnit` have been set up correctly before we start listening
    for gameplay signals. The listener function itself is then just a passthrough
    broadcasting the `OnControllerDeath` delegate.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add that to the code in the body file.
  prefs: []
  type: TYPE_NORMAL
- en: AIController_CH7.cpp excerpt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The GameMode can now link a listener function to all the AIControllers. This
    function just calls a `public` function on the PlayerController to increment its
    points for now, but it can be used as a jumping-off point to check against win
    conditions, and in a multiplayer scenario, make sure all players have an updated
    scoreboard via the `GameState`.
  prefs: []
  type: TYPE_NORMAL
- en: This following excerpt shows where to add the listener function declaration
    in the GameMode header.
  prefs: []
  type: TYPE_NORMAL
- en: GameMode_CH7.h excerpt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the GameMode body, we then bind the listener function to each AIController
    right after we call the `Init` function on each one. This time, the listener function
    doesn’t simply broadcast another event, as this is where the communication reverses
    and starts going down another branch of the communication hierarchy that we designed
    earlier in the chapter. Instead, we call a function on the PlayerController telling
    it to add points. This is not strictly the best way of doing this, but it does
    show the structure cleanly. Ideally, you would check which controller needed the
    points based on the `causer` argument passed through the delegate chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, add the following code to the body file:'
  prefs: []
  type: TYPE_NORMAL
- en: GameMode_CH7.cpp excerpt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The Player controller then needs to implement this `public` function so that
    when the game mode tells it to add points, it updates the UI as well. The UI references
    are included in the class for you already – that’s why they are missing from the
    header in the following code.
  prefs: []
  type: TYPE_NORMAL
- en: The PlayerController header just needs the public accessor `AddPoints` function
    and a variable to store the current number of points. This is arbitrary but they
    must be stored somewhere, and this seems like as good a place as any to store
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s add these:'
  prefs: []
  type: TYPE_NORMAL
- en: PlayerController_CH7.h excerpt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`AddPoints` does what it says on the tin, but also serves as a signal passthrough
    for the UI where we tell it to update the value shown onscreen with the new points
    value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following excerpt to the body file:'
  prefs: []
  type: TYPE_NORMAL
- en: PlayerController_CH7.cpp excerpt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: With that all done, you should be able to play the game as before from this
    new level, but when you destroy enemy AI units, the number at the top left of
    the viewport increases each time. This is the core of a game loop built in a decoupled
    way. Of course, our AI needs to fight back and there needs to be some balancing
    to make this into a good gameplay experience, but functionally it is all there.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of decoupling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The benefit of setting things up in a decoupled way should now be evident. If
    we need to swap out game modes for a different objective-based mode, then we can
    do that as no class needs a direct reference to the game mode. As long as all
    the same functions are called and the events are listened to, everything will
    function. You can also check the size of the dependencies for each class using
    the method shown in [*Chapter 1*](B18297_01.xhtml#_idTextAnchor016) to see how
    small each class is in memory now that it has a reference to only one layer below
    itself and maybe an interface or two.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this chapter completed, you should be equipped to design communication
    hierarchies for games with a focus on anonymous modular design in UML for implementation
    within Unreal. We have covered the basics of UML and why it is useful as a planning
    and communication tool. Using this UML, we then set about taking a simple communication
    and anonymizing it using the event delegate tool from [*Chapter 6*](B18297_06.xhtml#_idTextAnchor076)
    to decouple the reference chain as much as we could. This anonymous modular should
    work for most communications you design from here on, with exceptions being extremely
    rare.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to look at patterns you can set up as a library
    to move around with you between projects. We will look at why you should not overuse
    the singleton pattern, as most people do, and why you should make use of the command
    and state patterns in almost every project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Building on Top of Unreal'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we will take the leap from looking at patterns that have already
    been scaffolded to making some of our own.
  prefs: []
  type: TYPE_NORMAL
- en: Each chapter deals with a different category of pattern, starting with behavioral
    patterns that allow classes to serve their use more cleanly, through structural
    patterns that assist you when building systems for a large team to work on, to
    optimization patterns that aim to speed up your code. By the end of this section,
    you should have a host of patterns built in a modular way, ready to be transferred
    between projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B18297_08.xhtml#_idTextAnchor113)*, Building Design Patterns
    – Singleton, Command, and State*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B18297_09.xhtml#_idTextAnchor130)*, Structuring Code with Behavioral
    Patterns – Template, Subclass Sandbox, and Type Object*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B18297_10.xhtml#_idTextAnchor148)*, Optimisation through Patterns*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
