- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jungle Jump – Running and Jumping in a 2D Platformer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you’ll build a *platformer* game in the tradition of classics
    such as *Super Mario Bros*. Platform games are a very popular genre, and understanding
    how they work can help you make a variety of different game styles. If you’ve
    never attempted making one before, the player movement in platformers can be surprisingly
    complex to implement, and you’ll see how Godot’s `CharacterBody2D` node has features
    to help you in that process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this project, you will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `CharacterBody2D` node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `Camera2D` node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining animations and user input to produce complex character behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing levels using `TileMap`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an infinitely scrolling background using `ParallaxLayer`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transitioning between scenes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing your project and planning for expansion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a screenshot of the completed game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: Completed game screenshot](img/B19289_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Completed game screenshot'
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with the previous projects, you’ll start by downloading the art assets for
    the game, which can be found here: [https://github.com/PacktPublishing/Godot-Engine-Game-Development-Projects-Second-Edition/tree/main/Downloads](https://github.com/PacktPublishing/Godot-Engine-Game-Development-Projects-Second-Edition/tree/main/Downloads)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also find the complete code for this chapter on GitHub at: [https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter04%20-%20Jungle%20Jump](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter04%20-%20Jungle%20Jump)'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a new project, start by opening **Project Settings** so that you can
    configure the defaults that you’ll need.
  prefs: []
  type: TYPE_NORMAL
- en: 'The art assets for this game use a **pixel art** style, which means they look
    best when the images are not smoothed, which is Godot’s default setting for **texture
    filtering**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2: Texture filtering](img/B19289_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: Texture filtering'
  prefs: []
  type: TYPE_NORMAL
- en: While it’s possible to set this on each `Sprite2D`, it’s more convenient to
    specify the default setting. Click the **Advanced** toggle in the top right and
    find the **Rendering/Textures** section on the left. In the settings list, scroll
    to the bottom and find the **Canvas Textures/Default Texture Filter** setting.
    Change it from **Linear** to **Nearest**.
  prefs: []
  type: TYPE_NORMAL
- en: Then, under **Display/Window**, change **Stretch/Mode** to **canvas items**
    and **Aspect** to **expand**. These settings will allow the user to resize the
    game window while preserving the image’s quality. Once the project is complete,
    you’ll be able to see the effects of this setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you can set up the collision layers. Because this game will have several
    different types of collision objects that need to interact in different ways,
    you’ll use Godot’s **collision layer** system to help organize them. The layers
    will be more convenient to use if they’re assigned names, so go to the **Layer
    Names | 2D Physics** section and name the first four layers like this (by typing
    directly in the box next to the layer number):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3: Setting physics layer names](img/B19289_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: Setting physics layer names'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add the following actions for the player controls to the **Input**
    **Map** area:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Action name** | **Key(s)** |'
  prefs: []
  type: TYPE_TB
- en: '| `right` | *D*, → |'
  prefs: []
  type: TYPE_TB
- en: '| `left` | *A*, ← |'
  prefs: []
  type: TYPE_TB
- en: '| `jump` | Space |'
  prefs: []
  type: TYPE_TB
- en: '| `up` | *S*, ↑ |'
  prefs: []
  type: TYPE_TB
- en: '| `down` | *W*, ↓ |'
  prefs: []
  type: TYPE_TB
- en: Make sure you use the exact names for the input actions since you’ll be referencing
    them in code later.
  prefs: []
  type: TYPE_NORMAL
- en: That’s all you need to set in **Project Settings**. But before you start making
    the player scene, you need to learn about a different type of physics node.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing kinematic bodies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A platformer requires gravity, collisions, jumping, and other physics behavior,
    so you might think that `RigidBody2D` would be the perfect choice to implement
    the character’s movement. In practice, you’ll find that the more realistic physics
    of the rigid body are not desirable for a platform character. To the player, realism
    is less important than responsive control and an action feel. So, as the developer,
    you want to have precise control over the character’s movements and collision
    response. For this reason, a **kinematic** style of physics is usually the better
    choice for a platform character.
  prefs: []
  type: TYPE_NORMAL
- en: The `CharacterBody2D` node is designed for implementing physics bodies that
    are to be controlled directly via code. These nodes detect collisions with other
    bodies when they move but are not affected by global physics properties such as
    gravity or friction. This doesn’t mean that they can’t be affected by gravity
    and other forces – just that you must calculate those forces and their effects
    in code; the physics engine will not move a `CharacterBody2D` node automatically.
  prefs: []
  type: TYPE_NORMAL
- en: When moving a `CharacterBody2D` node as with `RigidBody2D`, you should not set
    its `position` property directly. Instead, you must use the `move_and_collide()`
    or `move_and_slide()` methods provided by the body. These methods move the body
    along a given vector and instantly stop it if a collision is detected with another
    body. It’s then up to you to decide on any **collision response**.
  prefs: []
  type: TYPE_NORMAL
- en: Collision response
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After a collision, you may want the body to bounce, slide along a wall, or
    alter the properties of the object it hit. The way you handle collision response
    depends on which method you use to move the body:'
  prefs: []
  type: TYPE_NORMAL
- en: move_and_collide()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using this method, the function returns a `KinematicCollision2D` object
    upon collision. This object contains information about the collision and the colliding
    body. You can use this information to determine the response. Note that the function
    returns `null` when movement is completed successfully with no collision.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you want the body to bounce off the colliding object, you could
    use the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: move_and_slide()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sliding is a very common option for collision response. Imagine a player moving
    along a wall in a top-down game, or running along the ground in a platformer.
    While it’s possible to code the response yourself after using `move_and_collide()`,
    `move_and_slide()` provides a convenient way to implement sliding movement. When
    using this method, the body will automatically slide along the surface of a colliding
    object. In addition, sliding collisions will allow you to detect the orientation
    of the surface using methods such as `is_on_floor()`.
  prefs: []
  type: TYPE_NORMAL
- en: Since this project will require you to allow the player character to run along
    the ground and up/down slopes, `move_and_slide()` is going to play a large role
    in your player’s movement.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an understanding of what kinematic bodies are, you’ll use
    one to make the character for this game.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the player scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Godot node that implements kinematic movement and collision is called `CharacterBody`
    `2D`.
  prefs: []
  type: TYPE_NORMAL
- en: Open a new scene and add a `CharacterBody2D` node named `Player` as the root
    and save the scene. Don’t forget to click the `Player` scene, you should also
    create a new folder to contain it. This will help keep your project folder organized
    as you add more scenes and scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the properties of `CharacterBody2D` in the Inspector. Notice the default
    values of **Motion Mode** and **Up Direction**. “Grounded” mode means the body
    will consider one collision direction as the “floor,” the opposite wall as the
    “ceiling,” and any others as “walls” – which one is determined by **Up Direction**.
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve done in previous projects, you’ll include all the nodes the player
    character needs to function in the Player scene. For this game, that means handling
    collisions with various game objects, including platforms, enemies, and collectibles;
    displaying animations for actions, such as running or jumping; and attaching a
    camera to follow the player around the level.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting the various animations can quickly become unmanageable, so you’ll
    need to use a **finite-state machine** (**FSM**) to manage and track the player’s
    state. See [*Chapter* *3*](B19289_03.xhtml#_idTextAnchor066) to review how a simplified
    FSM can be built. You’ll follow a similar pattern for this project.
  prefs: []
  type: TYPE_NORMAL
- en: Collision layers and masks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A body’s `Player` needs to be assigned to the “player” layer (which you named
    in **Project Settings**). Similarly, **Collision/Mask** sets which layers the
    body can “see” or interact with. If an object is on a layer that is not in the
    player’s **Mask**, then the player won’t interact with it at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the player’s **Layer** to **player** and **Mask** to **environment**, **enemies**,
    and **items**. Click the three dots to the right to open a list of checkboxes
    showing the names you’ve assigned to the layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: Setting collision layers](img/B19289_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Setting collision layers'
  prefs: []
  type: TYPE_NORMAL
- en: This will ensure that the player is on the “player” layer so that other objects
    can be configured to detect the player or not. Setting the **Mask** value to all
    three layers means the player will be able to interact with objects on any of
    those layers.
  prefs: []
  type: TYPE_NORMAL
- en: About AnimationPlayer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier in this book, you used `AnimatedSprite2D` to display the frame-based
    animations of your characters. This is a great tool, but it’s only useful for
    animating the visual texture of a node. What if you want to also animate any of
    a node’s other properties?
  prefs: []
  type: TYPE_NORMAL
- en: This is where `AnimationPlayer` comes in. This node is a very powerful tool
    for creating animations that can affect multiple nodes at once; you can modify
    any of their properties.
  prefs: []
  type: TYPE_NORMAL
- en: Animations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To set up the character’s animations, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `Sprite2D` node to `Player`. Drag the `res://assets/player_sheet.png`
    file from the **FileSystem** dock and drop it into the **Texture** property. The
    player animation will be saved in the form of a sprite sheet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19289_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: Sprite sheet'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll use `AnimationPlayer` to handle the animations, so, in the `Sprite2D`,
    set `19`. Then, set `7` to see the player standing. Finally, move `Sprite2D` upward
    until its feet are standing on the ground by setting `(0, -16)`. This will make
    it easier to code the player’s interactions later because you will know that the
    player’s `position` property represents the location of its feet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `AnimationPlayer` node to the scene. You’ll use this node to change the
    `Sprite2D` to the appropriate values for each animation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before you start, review the different parts of the **Animation** panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.6: The Animation panel](img/B19289_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: The Animation panel'
  prefs: []
  type: TYPE_NORMAL
- en: Click the `idle`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its `0.4` seconds. Click the **Loop** icon to make the animation loop, and
    set the track’s **Update Mode** to **Continuous**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the `Sprite2D` to `7`, which is the first frame of the idle animation,
    and click the **keyframe** icon next to the property to add an animation track
    with a new keyframe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7: Adding a keyframe](img/B19289_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: Adding a keyframe'
  prefs: []
  type: TYPE_NORMAL
- en: Slide the play scrubber to `0.3` (you can adjust the zoom slider in the bottom
    right to make it easier to find). Add a keyframe for frame `10`, which is the
    last frame of **idle**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the `7` and ended on frame `10`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, repeat this process for the other animations. See the following table
    for a list of their settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Length** | **Frames** | **Looping** |'
  prefs: []
  type: TYPE_TB
- en: '| `idle` | `0.4` | `7` → `10` | On |'
  prefs: []
  type: TYPE_TB
- en: '| `run` | `0.5` | `13` →`18` | On |'
  prefs: []
  type: TYPE_TB
- en: '| `hurt` | `0.2` | `5` → `6` | On |'
  prefs: []
  type: TYPE_TB
- en: '| `jump_up` | `0.1` | `11` | Off |'
  prefs: []
  type: TYPE_TB
- en: '| `jump_down` | `0.1` | `12` | Off |'
  prefs: []
  type: TYPE_TB
- en: There are also animations in the sprite sheet for crouching and climbing, but
    you can add those later, once the basic movement is completed.
  prefs: []
  type: TYPE_NORMAL
- en: Collision shape
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with other bodies, `CharacterBody2D` needs a shape assigned to define its
    collision bounds. Add a `CollisionShape2D` node and create a new `RectangleShape2D`
    inside it. When sizing the shape, you want it to reach the bottom of the image
    (the player’s feet) but be a little bit narrower than the player’s image. In general,
    making the shape a bit smaller than the image will result in a better feel when
    playing, avoiding the experience of hitting something that looks like it wouldn’t
    result in a collision.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll also need to offset the shape a small amount to make it fit. Setting
    the `CollisionShape2D` node’s `(0, -10)` works well. When you’re done, it should
    look approximately like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8: Player collision shape](img/B19289_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: Player collision shape'
  prefs: []
  type: TYPE_NORMAL
- en: Multiple shapes
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, depending on the complexity of your character and its interactions
    with other objects, you may want to add multiple shapes to the same object. You
    might have one shape at the player’s feet to detect ground collisions, another
    on its body to detect damage, and yet another covering the player’s front to detect
    contact with walls.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing the player scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add a `Camera2D` node to the `Player` scene. This node will keep the game window
    centered on the player as it moves around the level. You can also use it to zoom
    in on the player since pixel art is relatively small compared to the game window’s
    size. Remember, since you set the filtering option in **Project Settings**, the
    player’s texture will remain pixelated and blocky when zoomed in.
  prefs: []
  type: TYPE_NORMAL
- en: To enable the camera, set the `(2.5, 2.5)`. Values smaller than 1 zoom the camera
    out, while larger values zoom it in.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll see a pinkish-purple rectangle surrounding the player. That’s the camera’s
    **screen rectangle** and it shows what the camera will see. You can adjust the
    **Zoom** property to increase or decrease its size to see more or less of the
    world around the player.
  prefs: []
  type: TYPE_NORMAL
- en: Player states
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The player character has a wide variety of behaviors, such as jumping, running,
    and crouching. Coding such behaviors can become very complex and hard to manage.
    One solution is to use Boolean variables (`is_jumping` or `is_running`, for example),
    but this leads to possibly confusing states (what if `is_crouching` and `is_jumping`
    are both `true`?) and quickly leads to `_spaghetti_ code`.
  prefs: []
  type: TYPE_NORMAL
- en: A better solution to this problem is to use a state machine to handle the player’s
    current state and control the transition to other states. This concept was introduced
    in [*Chapter 3*](B19289_03.xhtml#_idTextAnchor066), and you’ll expand on it in
    this project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a diagram of the player’s states and the transitions between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9: Player state diagram](img/B19289_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.9: Player state diagram'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, state diagrams can become quite complex, even with a relatively
    small number of states.
  prefs: []
  type: TYPE_NORMAL
- en: Other states
  prefs: []
  type: TYPE_NORMAL
- en: Note that while the sprite sheet contains animations for them, the `CROUCH`
    and `CLIMB` states are not included here. This is to keep the number of states
    manageable at the beginning of the project. Later, you’ll have the opportunity
    to add them.
  prefs: []
  type: TYPE_NORMAL
- en: Player script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Attach a new script to the `Player` node. Note that the dialog shows a **Template**
    property with Godot’s default **Basic Movement** for this node type. Uncheck the
    **Template** box – you won’t need that example code for this project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to start setting up the player’s state machine. As in
    the *Space Rocks* game, you can use an `enum` type to define the allowed states
    for the system. When you want to change the player’s state, you can call `change_state()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For now, the script only changes which animation is playing, but you’ll add
    more state functionality later.
  prefs: []
  type: TYPE_NORMAL
- en: Player movement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The player needs three controls: left, right, and jump. Comparing the current
    state to which keys are pressed will trigger a state change if the transition
    is allowed by the state diagram’s rules. Add the `get_input()` function to process
    the inputs and determine the result. Each `if` condition represents one of the
    transitions in the state diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that the jump check is using `is_action_just_pressed()` rather than `is_action_pressed()`.
    While the latter returns `true` so long as the key is held down, the former is
    only `true` in the frame after the key was pressed. This means that the player
    must press the jump key each time they want to jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'Call this function from `_physics_process()`, add the pull of gravity to the
    player’s `velocity`, and call the `move_and_slide()` method to move:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember, since the `(0, -1)`, any collision below the player’s feet will be
    considered the “floor,” and `is_on_floor()` will be set to `true` by `move_and_slide()`.
    You can use this fact to detect when the jump ends by adding this right after
    `move_and_slide()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The jump will look better if the animation switches from `jump_up` to `jump_down`
    when falling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Later, once the level is complete, the player will be passed a spawn location.
    To handle this, add this function to the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With that, you have finished adding movement, and the correct animation should
    play for each situation. This would be a good point to stop and test the player
    to make sure everything is working. You can’t just run the scene, though, because
    the player will just start falling without any surface to stand on.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the movement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a new scene and add a `Node` object called `Main` (later, this will
    become your main scene). Add an instance of `Player`, then add a `StaticBody2D`
    node with a rectangular collision shape. Stretch the collision shape horizontally
    so that it’s wide enough to walk back and forth on, and place it below the character:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10: Test scene with a platform](img/B19289_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.10: Test scene with a platform'
  prefs: []
  type: TYPE_NORMAL
- en: Since it doesn’t have a `Sprite2D` node, the static body will be invisible if
    you run the game. In the menu, choose **Debug** > **Visible Collision Shapes**.
    This is a useful debug setting that will draw the collision shapes while the game
    is running. You can turn it on whenever you need to test or troubleshoot collisions.
  prefs: []
  type: TYPE_NORMAL
- en: Press `idle` animation when it hits the static body.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on, make sure that all the movements and animations are working
    correctly. Run and jump in all directions and check that the correct animations
    are playing whenever the state changes. If you find any problems, review the previous
    sections and make sure you didn’t miss a step.
  prefs: []
  type: TYPE_NORMAL
- en: Player health
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Eventually, the player is going to encounter danger, so you should add a damage
    system. The player will start with three hearts and lose one each time they are
    damaged.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following to the top of the script (just after the `extends` line):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You’ll emit the `life_changed` signal whenever the value of `life` changes,
    notifying the display to update. `dead` will be emitted when `life` reaches `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Add `life = 3` to the `reset()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two possible ways for the player to be hurt: running into a spike
    object in the environment or being hit by an enemy. In either event, the following
    function can be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is being nice to the player: if they’re already hurt, they can’t
    get hurt again (at least for a brief time until the `hurt` animation has stopped
    playing). Without this, it’s easy to get stuck in a loop of getting hurt, resulting
    in a quick death.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few things to do when the state changes to `HURT` in the `change_state()`
    function you created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When they’re hurt, not only do they lose one `life`, but they are also bounced
    up and away from the damaging object. After a short time, the state changes back
    to `IDLE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, the input should be disabled during the `HURT` state. Add this to the
    beginning of `get_input()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, the player is ready to take damage once the rest of the game has been set
    up. Next, you will create the objects that the player will collect in the game.
  prefs: []
  type: TYPE_NORMAL
- en: Collectible items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you start making the level, you need to create some items that the player
    can collect, since those will be part of the level as well. The `assets/sprites`
    folder contains sprite sheets for two types of collectibles: cherries and gems.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than make a separate scene for each type of item, you can use a single
    scene and swap out the `texture` property in the script. Both objects have the
    same behavior: animating in place and disappearing when collected by the player.
    You can also add a `tween` effect for the collection (see [*Chapter 2*](B19289_02.xhtml#_idTextAnchor030)).'
  prefs: []
  type: TYPE_NORMAL
- en: Scene setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start the new scene with `Area2D` and name it `Item`. Save the scene in a new
    `items` folder.
  prefs: []
  type: TYPE_NORMAL
- en: An area is a good choice for these objects because you want to detect when the
    player contacts them, but you don’t need a collision response from them. In the
    Inspector, set `collectibles` (layer 4) and `player` (layer 2). This will ensure
    that only the `Player` node will be able to collect them, while the enemies will
    pass right through.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add three child nodes: `Sprite2D`, `CollisionShape2D`, and `AnimationPlayer`.
    Drag `res://assets/sprites/cherry.png` into the `Sprite2D` node’s `5`. Then, add
    a circle shape to `CollisionShape2D` and size it appropriately:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11: Item with collision](img/B19289_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.11: Item with collision'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a collision size
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, you should size your collision shapes so that they benefit
    the player. This means that enemy hitboxes should be a little smaller than the
    image, while the hitboxes of beneficial items should be slightly oversized. This
    reduces player frustration and results in a better gameplay experience.
  prefs: []
  type: TYPE_NORMAL
- en: Add a new animation to `AnimationPlayer` (you only need one, so you can name
    it anything you like). Set `1.6` seconds, `0.2` seconds, and **Looping** to **on**.
    Click the **Autoplay on Load** button so that the animation will start automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the `Sprite2D` node’s `0` and click the key button to create the track.
    This sprite sheet only contains half the animation, so the animation needs to
    play the frames in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: '*0 -> 1 -> 2 -> 3 -> 4 -> 3 -> 2 -> 1*'
  prefs: []
  type: TYPE_NORMAL
- en: Drag the scrubber to time `0.8` and key `4`. Then, key `1` at time `1.4`. Set
    `res://assets/sprites/coin.png` image into **Texture** and it will work just the
    same since it has the same number of frames. This will make it easy to spawn both
    cherries and gems in your game.
  prefs: []
  type: TYPE_NORMAL
- en: Collectible script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Item` script needs to do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the start conditions (which `texture` and `position`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detect when the player overlaps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the first part, add the following code to your new item script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You’ll emit the `picked_up` signal when the player collects the item. In the
    `textures` dictionary, you will find a list of the item types and their corresponding
    image files. Note that you can quickly paste those paths into the script by dragging
    the file from **FileSystem** and dropping it into the script editor.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `init()` function sets `texture` and `position`. Your level script
    will use this to spawn all the items that you’ve placed in your level map.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, connect the `body_entered` signal of `Item` and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This signal will allow the game’s main script to react to the item being picked
    up. It can add to the score, increase the player’s health, or any other effect
    you want the item to apply.
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that these collectible items are set up very much like
    the coins from *Coin Dash* were. Areas are very useful for any type of item where
    you need to know when it’s been touched. In the next section, you’ll start laying
    out the level scene so that you can place these collectibles.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For most of you, this section will take up the largest chunk of your time. Once
    you start designing a level, you’ll find it’s a lot of fun to lay out all the
    pieces and create challenging jumps, secret paths, and dangerous encounters.
  prefs: []
  type: TYPE_NORMAL
- en: First, you’ll create a generic `Level` scene containing all the nodes and code
    that is common to all levels. You can then create any number of `Level` scenes
    that inherit from this master level.
  prefs: []
  type: TYPE_NORMAL
- en: Using TileMaps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new scene and add a `Node2D` node named `LevelBase`. Save the scene
    in a new folder called `levels`. This is where you’ll save all the levels you
    create, and they will all inherit functionality from this `level_base.tscn` scene.
    They’ll all have the same node hierarchy – only the layout will be different.
  prefs: []
  type: TYPE_NORMAL
- en: A tilemap is a common tool for designing game environments using a grid of tiles.
    They allow you to draw a level layout by painting the tiles onto the grid rather
    than placing many individual nodes one at a time. They are also more efficient
    because they batch all the individual tile textures and collision shapes into
    a single game object.
  prefs: []
  type: TYPE_NORMAL
- en: Add a `TileMap` node; a new **TileMap** panel will appear at the bottom of the
    editor window. Note that it says **The edited TileMap has no** **TileSet resource**.
  prefs: []
  type: TYPE_NORMAL
- en: About TileSets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To draw a map using `TileMap`, it must have `TileSet` assigned. This `TileSet`
    contains all the individual tile textures, along with any collision shapes they
    may have.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on how many tiles you may have, it can be time-consuming to create
    `TileSet`, especially for the first time. For that reason, some pre-generated
    tilesets have been included in the `assets` folder. Feel free to use those instead,
    but do read through the following section. It contains useful information to help
    you understand how `TileSet` works. If you’d rather use the provided tilesets,
    skip to the *Using the provided* *TileSets* section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a TileSet
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In Godot, `TileSet` is a type of `Resource`. Examples of other resources include
    `Texture`, `Animation`, and `RectangleShape2D`. They are not nodes; instead, they
    are containers that hold a certain type of data and are usually saved as `.``tres`
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the steps for creating a `TileSet` container:'
  prefs: []
  type: TYPE_NORMAL
- en: Click `TileMap`. You’ll see that you now have a **TileSet** panel available,
    which you can select at the bottom of the editor window. You can click the two
    upward arrows, ![](img/B19289_04_12.png), to make the panel fill the editor screen.
    Click it again to shrink the panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `TileSet` panel is where you can place the textures that you want to slice
    up into tiles. Drag `res://assets/environment/tileset.png` into this box. A popup
    will appear, asking if you’d like to automatically create tiles. Select `16x16`
    pixel tiles in the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.12: Adding a TileSet](img/B19289_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.12: Adding a TileSet'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try selecting the **TileMap** panel at the bottom and then select the grass
    block image in the top left of the tiles. Then, click in the editor window to
    draw some tiles by left-clicking in the editor window. You can right-click on
    a tile to clear it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.13: Drawing with TileMaps](img/B19289_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.13: Drawing with TileMaps'
  prefs: []
  type: TYPE_NORMAL
- en: If all you wanted to do was draw a background, you’d be done. However, you also
    need to add collisions to these tiles so that the player can stand on them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **TileSet** panel again and, in the Inspector, find the **PhysicsLayers**
    property and click **Add Element**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.14: Adding a physics layer to TileSet](img/B19289_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.14: Adding a physics layer to TileSet'
  prefs: []
  type: TYPE_NORMAL
- en: Since these tiles will be in the `environment` layer, you don’t need to change
    the layer/mask settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click `Physics` `Layer 0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.15: Adding collisions to tiles](img/B19289_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.15: Adding collisions to tiles'
  prefs: []
  type: TYPE_NORMAL
- en: Start clicking on the tiles to add the default square collision shape to them.
    If you want to edit a tile’s collision shape, you can do so – click the tile again
    to apply the changes. If you get stuck with a shape you don’t like, click the
    three dots and choose **Reset to default** **tile shape**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also drag the `props.png` image into the texture list for some decorative
    items to spice up your level.
  prefs: []
  type: TYPE_NORMAL
- en: Using the provided TileSets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Pre-configured tilesets have been included in the `assets` download for this
    project. There are three to be added to three different `TileMap` nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`World` – `tiles_world.tres`: Ground and platform tiles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Items` – `tiles_items.tres`: Markers for spawning collectibles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Danger` – `tiles_spikes.tres`: Items that cause damage on collision'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the `Items` and `Danger` tilemaps and add the associated tileset to the
    **Tile** **Set** property.
  prefs: []
  type: TYPE_NORMAL
- en: Add an instance of the `Player` scene and a `Marker2D` node named `SpawnPoint`.
    You can use this node to mark where in your level you want the player to start.
  prefs: []
  type: TYPE_NORMAL
- en: 'Attach a script to the `Level` node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Later, you’ll be scanning the `Items` map to spawn collectibles in the designated
    locations. This map layer shouldn’t be seen, so you could set it as hidden in
    the scene. However, this is easy to forget, so `_ready()` ensures that it’s not
    visible during gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the first level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, you’re ready to start drawing the level! Click `level_base.tscn`. Name
    the root node `Level01` and save it (in the `levels` folder). Notice that the
    child nodes are colored yellow, indicating that they are `level_base.tscn`. If
    you make changes to that original scene, those changes will also appear in this
    scene.
  prefs: []
  type: TYPE_NORMAL
- en: Start with the `World` map and be creative. Do you like lots of jumps, or twisty
    tunnels to explore? Long runs or careful upward climbs?
  prefs: []
  type: TYPE_NORMAL
- en: Before going too far with your level design, make sure you experiment with jump
    distance. You can change the player’s `jump_speed`, `run_speed`, and `gravity`
    properties to alter how high and how far they can jump. Set up some different
    gap sizes and run the scene to try them out. Don’t forget to drag the `SpawnPoint`
    node to the place you want the player to start.
  prefs: []
  type: TYPE_NORMAL
- en: How you set the player’s movement properties will have a big impact on how your
    level should be laid out. Make sure you’re happy with your settings before spending
    too much time on the full design.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the `World` map set up, use the `Items` map to mark the locations
    where you’d like to spawn the cherries and gems. The tiles that mark the spawn
    locations are drawn with a magenta background to make them stand out. Remember,
    they’ll be replaced at runtime and the tiles themselves won’t be seen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have your level laid out, you can limit the horizontal scrolling of
    the player camera to match the size of the map (plus a small buffer on each end).
    Add this code to `level_base.gd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The script also needs to scan the `Items` map and look for the item markers.
    Collecting items will add to the player’s score, so you can add a variable to
    track that as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `spawn_items()` function uses `get_used_cells()` to get a list of which
    cells in `TileMap` are not empty. These cells are in `_map coordinates_`, not
    pixel coordinates, so later, when you spawn the item, you can use `map_to_local()`
    to convert the values.
  prefs: []
  type: TYPE_NORMAL
- en: The marker tiles have a `gem` or `cherry`. That’s then used to tell the new
    instance which type of item it should be.
  prefs: []
  type: TYPE_NORMAL
- en: The `score` variable is there to keep track of how many items the player has
    collected. You could have this trigger completion of the level, give a bonus,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Add `spawn_items()` to `_ready()` and try running the level. You should see
    gems and cherries appear wherever you’ve added them. Also, check that they disappear
    when you collect them.
  prefs: []
  type: TYPE_NORMAL
- en: Adding dangerous objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Danger` map layer is designed to hold the spike objects that will harm
    the player when touched. Any tile on this `TileMap` will cause damage to the player!
    Try placing a few of them where you can easily test running into them.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Danger` tilemap to a group called `danger` so that you can easily identify
    it when colliding. This will also allow you to make other harmful objects upon
    adding them to the same group.
  prefs: []
  type: TYPE_NORMAL
- en: About slide collisions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a `CharacterBody2D` node is moved with `move_and_slide()`, it may collide
    with more than one object in the same frame’s movement. For example, when running
    into a corner, the body may hit the wall and the floor at the same time. You can
    use the `get_slide_collision_count()` function to find out how many collisions
    occurred; then, you can get information about each collision using `get_slide_collision()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of `Player`, you want to detect when a collision occurs against
    the `Danger` tilemap. You can do this just after using `move_and_slide()` in `player.gd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that before checking for a collision with the `danger` group, you can first
    check if the player is already in the `HURT` state. If they are, you can skip
    checking to see if they are colliding with a dangerous object.
  prefs: []
  type: TYPE_NORMAL
- en: The `for` loop iterates through the number of collisions given by `get_slide_collision_count()`
    to check each one for an object in the danger group.
  prefs: []
  type: TYPE_NORMAL
- en: Play your scene and try running into one of the spikes. You should see the player
    change to the `HURT` state (playing the animation) for a brief time before returning
    to `IDLE`. After three hits, the player will enter the `DEAD` state, which currently
    only hides the player.
  prefs: []
  type: TYPE_NORMAL
- en: Scrolling background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two background images in the `res://assets/environment/` folder:
    `back.png` and `middle.png`, for the far and near background, respectively. By
    placing these images behind the tilemap and scrolling them at different speeds
    relative to the camera, you can create an attractive illusion of depth in the
    background:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `ParallaxBackground` node to the `LevelBase` scene (so that it will be
    present on all inherited levels). This node works with the camera to create a
    scrolling effect. Drag this node to the top of the scene tree so that it will
    be drawn behind the rest of the nodes. Next, add a `ParallaxLayer` node as its
    child. `ParallaxBackground` can have any number of `ParallaxLayer` children, allowing
    you to make multiple independently scrolling layers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `Sprite2D` node as a child of `ParallaxLayer` and drag the `back.png`
    image into its `Sprite2D` node’s `(``1.5, 1.5)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On `ParallaxLayer`, set `(0.2, 1)` (you’ll need to click the `x` and `y` values
    to be set separately). This setting controls how fast the background scrolls concerning
    the camera movement. By setting it to a number less than `1`, the image will only
    move a small amount as the player moves left and right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You need to be sure the image repeats if your level is wider than the size of
    the image, so set `(576, 0)`. This is exactly the width of the image (`384` times
    `1.5`), so the image will be repeated when it has moved by that number of pixels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that this background image is designed for levels that are wide rather
    than tall. If you jump too high, you’ll see the top of the image. You can fix
    this by setting the top limit of the camera. If you haven’t moved the background’s
    position, its top-left corner will still be at (`0, 0)`, so you can set the `0`.
    If you have moved `ParallaxLayer` or its `Sprite2D` node, you can find the correct
    value to use by looking at the `y` value of the node’s **Position**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try playing the level and running left and right. You should see the background
    moving by a small amount compared to how far you run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add another `ParallaxLayer` (also as a child of `ParallaxBackground`) and give
    it a `Sprite2D` child. This time, use the `middle.png` image. This image is much
    narrower than the sky image, so you’ll need to adjust some settings to make it
    repeat properly. This is because `ParallaxBackground` needs to have images that
    are at least as big as the viewport area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the `Sprite2D` node’s `Mirror`. Then, expand the `(880, 368)`. `880` is
    the width of the image (`176`) multiplied by `5`, so you will now see five repetitions
    of the image, each one a mirror of the last.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Move the `Sprite2D` node so that the image overlaps the bottom half of the
    ocean/sky image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.16: Parallax background setup](img/B19289_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.16: Parallax background setup'
  prefs: []
  type: TYPE_NORMAL
- en: Set the second `ParallaxLayer` node’s `(0.6, 1)` and `880, 0)`. Using a higher
    scale factor means that this layer will scroll a little bit faster than the cloud
    layer behind it. Play the scene to test the effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your `Level` scene’s node tree should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17: Level scene nodes](img/B19289_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.17: Level scene nodes'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your level scene now has all the pieces you need to create your level design.
    Do you want your player to have to make very precise jumps (a parkour level),
    run through a series of winding passages trying to find all the items (a maze
    level), or some combination of the two? This is your chance to try out some creative
    ideas, but make sure you leave some room for the next object you’ll make: enemies.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding enemies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many different behaviors you could add for an enemy. For this game,
    the enemy will walk along a platform in a straight line and change direction when
    hitting an obstacle.
  prefs: []
  type: TYPE_NORMAL
- en: Scene setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As before, you’ll need to create a new scene to represent the enemy:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with a `CharacterBody2D` node named `Enemy` and give it three children:
    `Sprite2D`, `CollisionShape2D`, and `AnimationPlayer`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the scene in a folder called `enemies`. If you decide to add more enemy
    types to the game, you can save them all here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the body’s collision **Layer** to **enemies** and its **Mask** to **environment**,
    **player**, and **enemies**. As with the player, this determines which types of
    objects the enemy will collide with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s also useful to group enemies together, so click the `enemies`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `res://assets/sprites/opossum.png` to `6`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a rectangular collision shape that covers most (but not all) of the image,
    making sure that the bottom of the collision shape is aligned with the bottom
    of the opossum’s feet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.18: Enemy collision shape](img/B19289_04_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.18: Enemy collision shape'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new animation to `AnimationPlayer` called `walk`. Set `0.6` seconds and
    turn **Looping** and **Autoplay on** **Load** on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `walk` animation needs to have two tracks: one that sets the `Sprite2D`
    node and one that changes its `0` at time zero, and `5` at time `0.5`. Don’t forget
    to change **Update Mode** to **Continuous**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When finished, your animation should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.19: Enemy animations](img/B19289_04_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.19: Enemy animations'
  prefs: []
  type: TYPE_NORMAL
- en: Scripting the enemy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By now, moving a `CharacterBody2D` node be familiar to you. Look at this script
    and try to understand what it’s doing before reading the explanation provided
    after:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this script, the `facing` variable keeps track of the movement in the `x`
    direction, either `1` or `-1`. As with the player, after moving, you must check
    the slide collisions. If the colliding object is the player, you must call its
    `hurt()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you must check whether the colliding body’s `x` component that isn’t `0`.
    This means it points to the left or right, which means it is a wall or other obstacle.
    The direction of the normal is then used to set the new facing. Giving the body
    a small upward velocity will give the enemy a small bounce effect when turning
    around, which will look more appealing.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, if for some reason the enemy falls off a platform, you don’t want the
    game to have to track it falling forever, so you must delete any enemy whose `y`
    coordinate becomes too large.
  prefs: []
  type: TYPE_NORMAL
- en: Add an instance of `Enemy` to your level scene. Make sure it has some obstacles
    on either side and play the scene. Check that the enemy walks back and forth between
    the obstacles. Try putting the player in its path and verify that the player’s
    `hurt()` function is called.
  prefs: []
  type: TYPE_NORMAL
- en: You may notice that if you jump on top of the enemy, nothing happens. We will
    handle that part next.
  prefs: []
  type: TYPE_NORMAL
- en: Damaging the enemy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s not fair if the player can’t hit back, so in the tradition of Mario, jumping
    on top of the enemy will defeat it.
  prefs: []
  type: TYPE_NORMAL
- en: Start by adding a new animation to the enemy’s `AnimationPlayer` node called
    `death`. Set `0.3` and `0.05`. Don’t turn on looping for this animation.
  prefs: []
  type: TYPE_NORMAL
- en: The `death` animation will also set both `res://assets/sprites/enemy_death.png`
    image into the sprite’s `0` and `5` values of **Frame** at the start and end of
    the animation. Remember to set **Update Mode** to **Continuous**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `enemy.gd` so that you have a way to trigger the
    death animation on the enemy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When the player hits the enemy under the right conditions, it will call `take_damage()`,
    which plays the `death` animation, disables collision, and halts movement.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the death animation finishes playing, it’s OK to remove the enemy, so
    connect the `animation_finished` signal of `AnimationPlayer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.20: AnimationPlayer’s signals](img/B19289_04_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.20: AnimationPlayer’s signals'
  prefs: []
  type: TYPE_NORMAL
- en: 'This signal is called every time any animation finishes, so you need to check
    if it’s the correct one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To complete this process, go to the `player.gd` script and add the following
    code to the section of `_physics_process()` where you check the collisions. This
    code will check if the player hit an enemy from above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This code compares the `y` position of the player’s feet to the enemy’s `y`
    position to see if the player is above the enemy. If they are, the enemy should
    be hurt; otherwise, the player should be.
  prefs: []
  type: TYPE_NORMAL
- en: Run the level again and try jumping on the enemy to check that everything is
    working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Player script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’ve made several additions to the player’s script. Here’s what the full
    script should look like now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If you’re having any trouble with the player code, try to think about what part
    could be the problem. Is it the movement? The hit detection when running into
    an enemy? If you can narrow down the problem, it’ll help you determine which part
    of the script you should be focusing on.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you’re satisfied with how the player is behaving before moving on
    to the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Game UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in the previous projects you’ve worked on, you’ll need a HUD to display information
    during gameplay. Collecting items will increase the player’s score, so that number
    should be displayed, as well as the player’s remaining life value, which will
    be shown as a series of hearts.
  prefs: []
  type: TYPE_NORMAL
- en: Scene setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new scene with a `MarginContainer` root node named `HUD` and save it
    in a new `ui` folder. Set `50` and the top/bottom margins to `20`.
  prefs: []
  type: TYPE_NORMAL
- en: Add an `HBoxContainer` node to keep things aligned and give it two children,
    `Label` and `HBoxContainer`, named `Score` and `LifeCounter`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: On the `Score` label, set the `100` and in the Inspector, under `res://assets/Kenney
    Thick.ttf` into the `48`. Under `16` and `100` displayed in white with a black
    outline.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `LifeCounter`, add a `TextureRect` child and name it `L1`. Drag `res://assets/heart.png`
    into its `L1` and duplicate (*Ctrl* + *D*) it four times so that you have a row
    of five hearts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.21: HUD node setup](img/B19289_04_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.21: HUD node setup'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re finished, your HUD should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.22: HUD preview](img/B19289_04_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.22: HUD preview'
  prefs: []
  type: TYPE_NORMAL
- en: The next step will be to add a script so that the HUD can update during the
    game.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting the HUD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This script needs two functions that can be called to update the two values
    being displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in `update_life()`, you calculate how many hearts to display by setting
    `visible` to `false` if the number of that heart is less than the life amount.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching the HUD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open `level_base.tscn` (the base level scene, not your `Level01` scene) and
    add `CanvasLayer`. Add an instance of `HUD` as a child of this `Canvaslayer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the level’s `Player` instance and connect its `life_changed` signal
    to the HUD’s `update_life()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.23: Connecting a signal](img/B19289_04_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.23: Connecting a signal'
  prefs: []
  type: TYPE_NORMAL
- en: Do the same with the `score_changed` signal of the `Level` node, connecting
    it to the HUD’s `update_score()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that if you don’t want to use the scene tree to connect the signals, or
    if you find the signal connection window confusing or difficult to use, you can
    accomplish the same thing in your script by adding these lines to the `_ready()`
    function of `level.gd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Play the game and verify that you can see the HUD and that it updates correctly.
    Make sure you collect some items and let the enemy hit you. Is your score increasing?
    When you’re hit, do you lose one heart? Once you’ve checked this, you can continue
    to the next section and make the title screen.
  prefs: []
  type: TYPE_NORMAL
- en: Title screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The title screen is the first thing the player will see, and the game will return
    to this screen when the player dies and the game ends.
  prefs: []
  type: TYPE_NORMAL
- en: Scene setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start with a `Control` node and set `TextureRect` node using the `back.png`
    image. Set **Layout** to **Full Rect** and **Stretch Mode** to **Keep** **Aspect
    Covered**.
  prefs: []
  type: TYPE_NORMAL
- en: Add another `TextureRect`, this time using `middle.png` and setting **Stretch
    Mode** to **Tile**. Drag the width of the rectangle until it’s wider than the
    screen and arrange it so that it covers the bottom half.
  prefs: []
  type: TYPE_NORMAL
- en: Add two `Label` nodes named `Title` and `Message` and set their `Jungle Jump`
    and `Press Space to Play`, respectively. Add the font to each one as you’ve done
    before, setting the title to size `72` and the message to size `48`. Set the title’s
    layout to **Centered** and the message’s layout to **Center Bottom**.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re finished, the scene should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.24: Title screen](img/B19289_04_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.24: Title screen'
  prefs: []
  type: TYPE_NORMAL
- en: To make the title screen more interesting, add an `AnimationPlayer` node to
    it. Create a new animation named `intro` and set it to autoplay. In this animation,
    you can animate the elements of the screen to make them move, appear, fade in,
    or any other effect you like.
  prefs: []
  type: TYPE_NORMAL
- en: For example, keyframe the current `Title` at time `0.5`. Then, at time `0`,
    drag `Title` off the top of the screen and add another keyframe. Now, the title
    will drop onto the screen when you play the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'Feel free to add tracks that animate the other nodes’ properties. For example,
    here is an animation that drops the title down, fades in the two textures, and
    then makes the message appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.25: Title screen animations](img/B19289_04_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.25: Title screen animations'
  prefs: []
  type: TYPE_NORMAL
- en: This title screen has been kept simple, but you should feel free to add to it
    if you’d like. You could show an example of some platforms, add an animation of
    the character running across the screen, or some other game art. But what happens
    when the player hits “start”? For this, you need to load the first level in the
    main scene.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the main scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve made some level scenes, but eventually, you’re going to want to make
    more than one. How does the game know which one to load? Your `Main` scene is
    going to take care of that.
  prefs: []
  type: TYPE_NORMAL
- en: Delete any extra nodes you added to `main.tscn` when you were testing the player’s
    movement. This scene will now be responsible for loading the current level. Before
    it can do that, however, you need a way to keep track of the current level. You
    can’t keep track of that variable in the level scene because that will be replaced
    with a newly loaded level when it ends. To keep track of data that needs to be
    carried from scene to scene, you can use an **autoload**.
  prefs: []
  type: TYPE_NORMAL
- en: About autoloads
  prefs: []
  type: TYPE_NORMAL
- en: In Godot, you can configure a script or scene as an autoload. This means that
    the engine will automatically load it at all times. Even if you change the current
    scene in `SceneTree`, the autoloaded node will remain. You can also refer to that
    autoloaded scene by name from any other node in your game.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `game_state.gd` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You should set `num_levels` to the number of levels you’ve created in the `levels`
    folder. Make sure you name them consistently as `level_01.tscn`, `level_02.tscn`,
    and so on so that they can be found easily.
  prefs: []
  type: TYPE_NORMAL
- en: To add this script as an autoload, open `game_state.gd` and then click the **Add**
    button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add this script to your `Main` scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, whenever the `Main` scene is loaded, it will include the level scene that
    corresponds to the current level.
  prefs: []
  type: TYPE_NORMAL
- en: 'The title screen needs to transition to the game scene, so attach this script
    to the `Title` node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can call the `restart()` function when the player dies by adding
    it to `level.gd`. In the `Level` scene, connect the `Player` instance’s `died`
    signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now be able to play through the game fully. Make sure `title.tscn`
    is set as the game’s main scene (that is, the one that runs first). If you’ve
    previously set a different scene to be the “main” scene, you can change this in
    **Projects Settings** under **Application/Run**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.26: Choosing a main scene](img/B19289_04_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.26: Choosing a main scene'
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning between levels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your levels now need a way to transition from one to the next. In the `res://assets/environment/props.png`
    sprite sheet, there is an image of a door that you can use for your level’s exit.
    Finding and walking into the door will take the player to the next level.
  prefs: []
  type: TYPE_NORMAL
- en: Door scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make a new scene with an `Area2D` node named `Door` and save it in the `items`
    folder. Add a `Sprite2D` node and use the `props.png` image as `-8`. This will
    ensure that when the door is placed at the tile location, it will be positioned
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Add a `CollisionShape2D` node and give it a rectangular shape that covers the
    door. Put the door on the `items` layer and set its mask so that it only scans
    the `player` layer.
  prefs: []
  type: TYPE_NORMAL
- en: This scene doesn’t need a script because you’re just going to use its `body_entered`
    signal in the level script.
  prefs: []
  type: TYPE_NORMAL
- en: To place the door in the level, you can use the door object from the `tiles_items`
    tileset, which you are using in your `Items` tilemap to place the cherries and
    gems. Place a door in your level and open `level.gd`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `level.gd`, define the door scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, update `spawn_items()` so that it also instantiates doors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the function that will be called when the player touches the door:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Play the game and try walking into the door. If you’ve set `num_levels` in `game_state.gd`
    to a number greater than 1, the game will attempt to load `level_02.tscn` when
    you touch the door.
  prefs: []
  type: TYPE_NORMAL
- en: Screen settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall that at the beginning of this chapter, you set `canvas_items` and `expand`,
    respectively. Run the game, and then try resizing the game window. Notice that
    if you make the window wider, you can see more of the game world to the player’s
    left/right. This is what the `expand` value is doing.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to prevent this, you can set it to `keep` instead, which will always
    show the same amount of the game world as shown by the camera. However, it also
    means that if you make your window a different shape than the game, you’ll get
    black bars to fill in the extra space.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, setting `ignore` will not display the black bars, but the game
    content will be stretched to fill the space, distorting the image.
  prefs: []
  type: TYPE_NORMAL
- en: Take some time to experiment with the various settings and decide which one
    you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing touches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you’ve completed the main structure of the game, and hopefully designed
    a few levels for the player to enjoy, you can consider making some additions to
    improve the gameplay. In this section, you’ll find a few more suggested features
    – add them as-is or adjust them to your liking.
  prefs: []
  type: TYPE_NORMAL
- en: Sound effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with the previous projects, you can add audio effects and music to improve
    the experience. In `res://assets/audio/`, you’ll find audio files you can use
    for different game events, such as player jump, enemy hit, and item pickup. There
    are also two music files: `Intro Theme` for the title screen and `Grasslands Theme`
    for the level scene.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding these to the game will be left to you, but here are a few tips:'
  prefs: []
  type: TYPE_NORMAL
- en: You may find it helpful to adjust the volume of individual sounds. This can
    be set with the **Volume dB** property. Setting a negative value will reduce the
    sound’s volume.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can attach the music to the master `level.tscn` scene; that music will be
    used for all levels. You could also attach separate music to individual levels
    if you want to set a certain mood.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your first thought might be to put `AudioStreamPlayer` on the `Item` scene to
    play the pickup sound. However, since the pickup is deleted when the player touches
    it, that won’t work well. Instead, put the audio player in the `Level` scene,
    since that’s where the result of the pickup is handled (increasing the score).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Double jumping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Double jumps are a popular platforming feature. The player gets a second, usually
    smaller, upwards boost if they press the jump key a second time while in the air.
    To implement this feature, you need to add a few things to the player script.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you will need variables to track the number of jumps and determine how
    big the second boost will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When entering the `JUMP` state, reset the number of jumps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In `get_input()`, allow the jump if it meets the conditions that have been.
    Put this before the `if` statement where you check if the player is on the floor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In `_physics_process()`, when you land on the ground, reset the jump count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Play your game and try out the double jumps. Note that this code makes the second
    jump 2/3rds the size of the upward speed of the initial jump. You can adjust this
    according to your preferences.
  prefs: []
  type: TYPE_NORMAL
- en: Dust particles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Spawning dust particles at the character’s feet is a low-effort effect that
    can add a lot of character to your player’s movements. In this section, you’ll
    add a small puff of dust to the player’s feet that is emitted whenever they land
    on the ground. This adds a sense of weight and impact to the player’s jumps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `CPUParticles2D` node to the `Player` scene and name it `Dust`. Set the
    following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Amount | `20` |'
  prefs: []
  type: TYPE_TB
- en: '| Lifetime | `0.45` |'
  prefs: []
  type: TYPE_TB
- en: '| One Shot | `On` |'
  prefs: []
  type: TYPE_TB
- en: '| Speed Scale | `2` |'
  prefs: []
  type: TYPE_TB
- en: '| Explosiveness | `0.7` |'
  prefs: []
  type: TYPE_TB
- en: '| Emission Shape | `Rectangle` |'
  prefs: []
  type: TYPE_TB
- en: '| Rect Extents | `1, 6` |'
  prefs: []
  type: TYPE_TB
- en: '| Initial Velocity Max | `10` |'
  prefs: []
  type: TYPE_TB
- en: '| Scale Amount Max | `3` |'
  prefs: []
  type: TYPE_TB
- en: '| Position | `-``2, 0` |'
  prefs: []
  type: TYPE_TB
- en: '| Rotation | `-``90` |'
  prefs: []
  type: TYPE_TB
- en: The default particle color is white, but the dust effect will look better in
    a tan shade. It should also fade away so that it appears to dissipate. This can
    be accomplished with `Gradient`. In the **Color/Color Ramp** area, select **New
    Gradient**.
  prefs: []
  type: TYPE_NORMAL
- en: '`Gradient` has two colors: a start color on the left and an end color on the
    right. These can be selected using the small rectangles at either end of the gradient.
    Clicking on the large square on the right allows you to set the color for the
    selected rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.27: Color Ramp](img/B19289_04_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.27: Color Ramp'
  prefs: []
  type: TYPE_NORMAL
- en: Set the start color to a tan shade, and set the end to the same color, but with
    the alpha value set to `0`. You should see a continuously puffing smoke effect.
    In the Inspector, set **One Shot** to on. Now, the particles will only emit once,
    each time you check the **Emitting** box.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to alter the properties that have been provided here. Experimenting
    with particle effects can be great fun, and often, you’ll stumble upon a very
    nice effect just by tinkering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’re happy with its appearance, add the following to the player’s `_physics_process()`
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Run the game and observe the puff of dust every time your character lands on
    the ground.
  prefs: []
  type: TYPE_NORMAL
- en: Ladders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The player sprite sheet includes frames for a climbing animation, and the tileset
    contains ladder images. Currently, the ladder tiles do nothing – in `TileSet`,
    they do not have any collision shape assigned. That’s OK because you don’t want
    the player to collide with the ladders – you want them to be able to move up and
    down on them.
  prefs: []
  type: TYPE_NORMAL
- en: Player code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Start by selecting the player’s `AnimationPlayer` node and adding a new animation
    called `climb`. Its `0.4` and it should be set to `Sprite2D` are *0 -> 1 -> 0
    ->* *2*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to `player.gd` and add a new state, `CLIMB`, to the `state` enum. In addition,
    add two new variable declarations at the top of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You’ll use `is_on_ladder` to keep track of whether the player is on a ladder
    or not. Using this, you can decide whether the up and down actions should have
    any effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `change_state()`, add a condition for the new state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In `get_input()`, you need to check for the input actions and then determine
    if they change the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, you have three new conditions to check. First, if the player is not in
    the `CLIMB` state but is on a ladder, then pressing up should make the player
    start climbing. Second, if the player is currently climbing, then the up and down
    inputs should make them move up and down the ladder, but stop the animation from
    playing if no action is pressed. Finally, if the player leaves the ladder while
    climbing, they leave the `CLIMB` state.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also need to make sure that gravity doesn’t pull the player downward while
    they’re on a ladder. Add a condition to the gravity code in `_physics_process()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now, the player is ready to climb, which means you can add some ladders to your
    level.
  prefs: []
  type: TYPE_NORMAL
- en: Level setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add an `Area2D` node named `Ladders` to the `Level` scene, but don’t add a
    collision shape to it yet. Connect its `body_entered` and `body_exited` signals
    and set its collision `items` and `player`. This ensures that only the player
    can interact with the ladder. These signals are how you’ll let the player know
    they are or aren’t on a ladder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the level needs to look for any ladder tiles and add collision shapes
    to the `Ladders` area whenever it finds one. Add the following function to `level.gd`
    and call it in `_ready()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note that the collision shapes you’re adding are only `8` pixels wide. If you
    make the shape the full width of the ladder tile, then the player will still look
    as though they’re climbing even when they’re hanging off the side, which looks
    a bit odd.
  prefs: []
  type: TYPE_NORMAL
- en: Try it out – go to one of your level scenes and place some ladder tiles anywhere
    you’d like on your `World` tile map. Play the scene and try climbing the ladders.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you’re at the top of a ladder and step on it, you’ll fall to the
    bottom rather than climb down (although pressing up as you fall will cause you
    to grab the ladder). If you prefer to automatically transition to the climbing
    state, you can add an additional falling check in `_physics_process()`.
  prefs: []
  type: TYPE_NORMAL
- en: Moving platforms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Moving platforms are a fun addition to your level design toolkit. In this section,
    you’ll make a moving platform that you can place anywhere on your level and set
    its movement and speed.
  prefs: []
  type: TYPE_NORMAL
- en: Start with a new scene using a `Node2D` node and name it `MovingPlatform`. Save
    the scene and add `TileMap` as a child. Since your platform art is all in sprite
    sheets and they’ve already been sliced into tiles and had collisions added, this
    will make your platform easy to draw. Add `tiles_world.tres` as **Tile Set**.
    You’ll also need to check the **Collision Animatable** box, which will make sure
    the collisions work properly even while moving.
  prefs: []
  type: TYPE_NORMAL
- en: 'Draw a few tiles into `TileMap`, but make sure to start at the origin, `(0,
    0)`, so that things will line up cleanly. These tiles work well for a floating
    platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.28: Floating platform](img/B19289_04_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.28: Floating platform'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a script to the root node and start with these variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: These will allow you to set the movement amount and speed. `offset` is relative
    to the starting point, and since it’s a `Vector2` node, you can have platforms
    that move horizontally, vertically, or diagonally. `duration` is measured in seconds
    and represents how long the *complete* cycle will take.
  prefs: []
  type: TYPE_NORMAL
- en: 'The platform will always be moving, so you can start the animation in `_ready()`.
    It will use a `tween` method to animate the position in two steps: from the start
    position to the offset position and vice versa:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are a few notes about tween usage:'
  prefs: []
  type: TYPE_NORMAL
- en: You need to set the process mode so that the movement will be synced to physics
    and the player will be able to collide properly with the platform (that is, stand
    on it).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set_loops()` tells `tween` to repeat once finished.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set_parallel(false)` tells `tween` to perform the two property tweens sequentially
    rather than at the same time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also experiment with other tween curves. Adding `tween.set_trans(Tween.TRANS_SINE)`,
    for example, will make the platform slow down at the ends of the movement for
    a more natural look. Try experimenting with the other transition types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, you can add instances of `MovingPlatform` to the level scene. To make
    sure things line up properly, make sure you turn on grid snapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.29: Enabling grid snapping](img/B19289_04_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.29: Enabling grid snapping'
  prefs: []
  type: TYPE_NORMAL
- en: The default value is `(8, 8)`, but you can change it by clicking the three dots
    next to the icon and choosing **Configure Snap**.
  prefs: []
  type: TYPE_NORMAL
- en: When you run the game now, you will have a lot more to interact with. The ladders
    and moving platforms give you a lot more possibilities for your level designs.
    But you don’t have to stop there! Considering everything you’ve done in this chapter,
    there are many other features that you could still add. The player animation includes
    a “crouching” animation – what if the enemies could throw things at the player
    that could be ducked under? Many platformer games include additional movement
    mechanics such as sliding down slopes, wall jumps, changing gravity, and many
    more. Choose one and see if you can add it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use the `CharacterBody2D` node to create
    arcade-style physics for player movement. This is a powerful node that can be
    used for a wide variety of game objects – not just platform characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'You learned about the `TileMap` node for level design – a powerful tool with
    even more features than you used in this project. An entire chapter could be written
    on all of the different things you can do with it. For more information, see the
    *Using TileMaps* page on the Godot documentation website: https://docs.godotengine.org/en/latest/tutorials/2d/using_tilemaps.html.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Camera2D` and `ParallaxBackground` are also key tools for any game where you
    want to move around in a world that’s bigger than the size of the screen. The
    camera node in particular will be a node that you’ll use in most 2D projects.'
  prefs: []
  type: TYPE_NORMAL
- en: You also made extensive use of what you learned in earlier projects to tie everything
    together. Hopefully, at this point, you have a good grasp of the scene system
    and how a Godot project is structured.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, before moving on, take a few moments to play your game and look
    through its various scenes and scripts to review how you built it. Review any
    sections of this chapter that you found particularly tricky. And most importantly,
    before moving on, try to make some changes to the project.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll make the jump to 3D!
  prefs: []
  type: TYPE_NORMAL
