["```cpp\n#include \"gpio_exti.h\"\n#define GPIOCEN            (1U<<2)\n#define SYSCFGEN        (1U<<14)\nvoid pc13_exti_init(void)\n{\n    /*Disable global interrupts*/\n    __disable_irq();\n    /*Enable clock access for GPIOC*/\n    RCC->AHB1ENR |=GPIOCEN;\n    /*Set PC13 as input*/\n    GPIOC->MODER &=~(1U<<26);\n    GPIOC->MODER &=~(1U<<27);\n    /*Enable clock access to SYSCFG*/\n    RCC->APB2ENR |=SYSCFGEN;\n    /*Select PORTC for EXTI13*/\n    SYSCFG->EXTICR[3] |=(1U<<5);\n    /*Unmask EXTI13*/\n    EXTI->IMR |=(1U<<13);\n    /*Select falling edge trigger*/\n    EXTI->FTSR |=(1U<<13);\n    /*Enable EXTI13 line in NVIC*/\n    NVIC_EnableIRQ(EXTI15_10_IRQn);\n    /*Enable global interrupts*/\n    __enable_irq();\n}\n```", "```cpp\n__disable_irq();\n```", "```cpp\nRCC->AHB1ENR |= GPIOCEN;\n```", "```cpp\nGPIOC->MODER &= ~(1U<<26);\nGPIOC->MODER &= ~(1U<<27);\n```", "```cpp\nRCC->APB2ENR |= SYSCFGEN;\n```", "```cpp\nSYSCFG->EXTICR[3] |= (1U<<5);\n```", "```cpp\nEXTI->IMR |= (1U<<13);\n```", "```cpp\nEXTI->FTSR |= (1U<<13);\n```", "```cpp\nNVIC_EnableIRQ(EXTI15_10_IRQn);\n```", "```cpp\n__enable_irq();\n```", "```cpp\n#ifndef  GPIO_EXTI_H__\n#define GPIO_EXTI_H__\n#include <stdint.h>\n#include \"stm32f4xx.h\"\n#define   LINE13        (1U<<13)\nvoid pc13_exti_init(void);\nmain.c file:\n\n```", "```cpp\n\n\t\t\tLet’s break down the code:\n\n\t\t\t\t*   The main function initializes the system components and then enters an infinite loop.\n\t\t\t\t*   The `exti_callback` function is called when the external interrupt occurs.\n\t\t\t\t*   `EXTI15_10_IRQHandler` handles interrupts for EXTI lines 10 to 15, including line 13 (`PC13`)\n\n```", "```cpp\n\n\t\t\tThe preceding line checks whether the pending bit for EXTI line 13 is set, indicating an interrupt has occurred.\n\n```", "```cpp\n\n\t\t\tThe preceding line clears the pending bit by writing a `1` to it, acknowledging the interrupt, and allowing it to be processed again.\n\n```", "```cpp\n\n\t\t\tThis calls the `exti_callback` function to handle the interrupt, which, in our case, prints a message and toggles the LED.\n\t\t\tTo test on the microcontroller, simply build the project and run it. To generate the EXTI interrupt, press the blue push button.\n\t\t\tOpen RealTerm and configure the appropriate port and baud rate to view the printed message that confirms the EXTI interrupts occur when the blue push button is pressed.\n\t\t\tSummary\n\t\t\tIn this chapter, we learned about the important role of interrupts in embedded systems development. Interrupts are essential for creating responsive and efficient firmware, allowing microcontrollers to handle real-time events effectively. By mastering the concepts of interrupts, you can develop systems that react promptly to external stimuli, enhancing the robustness and versatility of your embedded applications.\n\t\t\tWe started by exploring the fundamental role of interrupts in firmware, comparing them with exceptions to highlight their unique purposes and handling mechanisms. We then examined the specifics of the ISR, the IVT, and the NVIC, which together form the backbone of interrupt handling in Arm Cortex-M microcontrollers.\n\t\t\tNext, we focused on the STM32 EXTI controller, a vital peripheral for managing external interrupts in STM32 microcontrollers. We discussed the key features and registers of the EXTI, and how to configure and utilize it for various applications.\n\t\t\tFinally, we applied this knowledge by developing an EXTI driver, providing practical experience in implementing interrupt-driven firmware.\n\t\t\tIn the next chapter, we will learn about the **Realtime Clock** (**RTC**) peripheral.\n\n```"]