["```cpp\n// Example 01\ntemplate <typename T>\nT increment(T x) { return x + 1; }\n```", "```cpp\nincrement(5);    // T is int, returns 6\nincrement(4.2);    // T is double, return 5.2 char c[10];\nincrement(c);    // T is char*, returns &c[1]\n```", "```cpp\ntemplate <typename T> T sum(T from, T to, T step) {\n  T res = from;\n  while ((from += step) < to) { res += from; }\n  return res;\n}\n```", "```cpp\ntemplate <typename T> void f(T t);\n```", "```cpp\n// Example 01a\nvoid f(auto t);\n```", "```cpp\nvoid f(std::vector<auto>& v);\n```", "```cpp\ntemplate <typename T> void f(std::vector<T>& v);\n```", "```cpp\ntemplate <typename T> T f(T t);\n```", "```cpp\nauto f(auto t) -> decltype(t);\n```", "```cpp\n// Example 02\ntemplate <typename T> class ArrayOf2 {\n  public:\n  T& operator[](size_t i) { return a_[i]; }\n  const T& operator[](size_t i) const { return a_[i]; }\n  T sum() const { return a_[0] + a_[1]; }\n  private:\n  T a_[2];\n};\n```", "```cpp\nArrayOf2<int> i; i[0] = 1; i[1] = 5;\nstd::cout << i.sum();                       // 6\nArrayOf2<double> x; x[0] = -3.5; x[1] = 4;\nstd::cout << x.sum();                       // 0.5\nArrayOf2<char*> c; char s[] = \"Hello\";\nc[0] = s; c[1] = s + 2;\n```", "```cpp\n// Example 03\ntemplate <typename T> constexpr T pi =\nT(3.14159265358979323846264338327950288419716939937510582097494459230781L);\npi<float>;      // 3.141592\npi<double>;     // 3.141592653589793\n```", "```cpp\n// Example 04\ntemplate <typename T, size_t N> class Array {\n  public:\n  T& operator[](size_t i) {\n    if (i >= N) throw std::out_of_range(\"Bad index\");\n     return data_[i];\n  }\n  private:\n  T data_[N];\n};\nArray<int, 5> a;      // OK\ncin >> a[0];\nArray<int, a[0]> b;   // Error\n```", "```cpp\nconstexpr size_t length(const char* s) {\n  size_t res = 0;\n  while (*(s++)) ++res;\n  return res;\n}\nstd::cout << length(\"abc\") << std::endl;\nchar s[] = \"runtime\";\nstd::cout << length(s) << std::endl;\n```", "```cpp\nstatic_assert(length(\"abc\") == 3, \"\"); // OK\nchar s[] = \"runtime\";\nstatic_assert(length(s) == 7, \"\"); // Fails\n```", "```cpp\n// Example 05c\ntemplate <auto V>\nstatic constexpr auto force_consteval = V;\n```", "```cpp\nstd::cout << force_consteval<length(\"abc\")> << std::endl;\nchar s[] = \"runtime\";\nstd::cout << force_consteval<length(s)> << std::endl;\n```", "```cpp\n// Example 05d\ntemplate <typename T, T V>\nstatic constexpr auto force_consteval_helper = V;\n#define force_consteval(V)\nforce_consteval_helper<decltype(V), (V)>\nstd::cout << force_consteval(length(\"abc\")) << std::endl;\n```", "```cpp\n// Example 06a\ntemplate <typename T,\n         template <typename> typename Container>\nclass Builder {\n  Container<T> data_;\n  public:\n  void add(const T& t) { data_.push_back(t); }\n  void print() const {\n    for (const auto& x : data_) std::cout << x << \" \";\n    std::cout << std::endl;\n  }\n};\n```", "```cpp\ntemplate <typename T> class my_vector { … };\nBuilder<int, my_vector> b;\nb.add(1);\nb.add(2);\nb.print();\n```", "```cpp\n// Example 06b\ntemplate <template <typename> class Out_container,\n          template <typename> class In_container,\n          typename T> Out_container<T>\nresequence(const In_container<T>& in_container) {\n  Out_container<T> out_container;\n  for (auto x : in_container) {\n    out_container.push_back(x);\n  }\n  return out_container;\n}\n```", "```cpp\nmy_vector<int> v { 1, 2, 3, 4, 5 };\ntemplate <typename T> class my_deque { … };\nauto d = resequence<my_deque>(v);// my_deque with 1 … 5\n```", "```cpp\ntemplate <template <typename> class Container, typename T>\nvoid print(const Container<T>& container) {\n  for (auto x : container) { std::cout << x << \" \"; }\n  std::cout << std::endl;\n}\nstd::vector<int> v { 1, 2, 3, 4, 5 };\nprint(v);\n```", "```cpp\ntemplate <typename T> T half(T x) { return x/2; }\nint i = half<int>(5);\n```", "```cpp\ndouble x = half<double>(5);\n```", "```cpp\nauto x = half(8);    // int\nauto y = half(1.5);    // double\n```", "```cpp\nlong x = ...;\nunsigned int y = ...;\nauto x = half(y + z);\n```", "```cpp\ntemplate <typename U> auto f(U);\nhalf(f(5));\n```", "```cpp\ntemplate <typename U, typename V> U half(V x) {\n  return x/2;\n}\nauto y = half<double>(8);\n```", "```cpp\ntemplate <typename T> T Max(T x, T y) {\n  return (x > y) ? x : y;\n}\nauto x = Max(7L, 11); // Error\n```", "```cpp\ntemplate <typename T> T decrement(T* p) {\n  return --(*p);\n}\nint i = 7;\ndecrement(&i);    // i == 6\n```", "```cpp\ntemplate <typename T> T first(const std::vector<T>& v) {\n  return v[0];\n}\nstd::vector<int> v{11, 25, 67};\nfirst(v);    // T is int, returns 11\n```", "```cpp\ntemplate <typename U, typename V>\nstd::pair<V, U> swap12(const std::pair<U, V>& x) {\n  return std::pair<V, U>(x.second, x.first);\n}\nswap12(std::make_pair(7, 4.2)); // pair of 4.2, 7\n```", "```cpp\ntemplate <typename U, typename V>\nauto swap12(const std::pair<U, V>& x) {\n  return std::make_pair(x.second, x.first);\n}\n```", "```cpp\ntemplate <typename T> auto swap12(const T& x) {\n  return std::make_pair(x.second, x.first);\n}\n```", "```cpp\ntemplate <typename N, typename D> class Ratio {\n  public:\n  Ratio() : num_(), denom_() {}\n  Ratio(const N& num, const D& denom) :\n    num_(num), denom_(denom) {}\n  explicit operator double() const {\n    return double(num_)/double(denom_);\n  }\n  private:\n  N num_;\n  D denom_;\n};\nRatio<int, double> r;\n```", "```cpp\nRatio<int, double> r(5, 0.1);\n```", "```cpp\nRatio r(5, 0.1);\n```", "```cpp\ntemplate <typename N, typename D>\nRatio<N, D> make_ratio(const N& num, const D& denom) {\n  return { num, denom };\n}\nauto r(make_ratio(5, 0.1));\n```", "```cpp\ntemplate class Ratio<long, long>;\ntemplate Ratio<long, long> make_ratio(const long&,\n                                      const long&);\n```", "```cpp\n// In the header:\nclass A {\n  static int n;\n};\n// In a C file:\nint A::n = 0;\nstd::cout << A::n;\n```", "```cpp\n// In the header:\ntemplate <typename T> class A {\n  static T n;\n};\ntemplate <typename T> T A<T>::n {};\n```", "```cpp\n// In the header:\ntemplate <typename T> class A {\n  static inline T n {};\n};\n```", "```cpp\n// In the header:\nclass A {\n  static inline int n = 0;\n};\n```", "```cpp\ntemplate <> class Ratio<double, double> {\n  public:\n  Ratio() : value_() {}\n  template <typename N, typename D>\n    Ratio(const N& num, const D& denom) :\n      value_(double(num)/double(denom)) {}\n  explicit operator double() const { return value_; }\n  private:\n  double value_;\n};\n```", "```cpp\ntemplate <> Ratio<float, float>::operator double() const {\n  return num_/denom_;\n}\n```", "```cpp\ntemplate <typename T> T do_something(T x) {\n  return ++x;\n}\ntemplate <> double do_something<double>(double x) {\n  return x/2;\n}\ndo_something(3);        // 4\ndo_something(3.0);    // 1.5\n```", "```cpp\ntemplate <> long do_something<int>(int x) { return x*x; }\n```", "```cpp\ntemplate <typename N, typename D> class Ratio {\n  .....\n};\ntemplate <typename D> class Ratio<double, D> {\n  public:\n  Ratio() : value_() {}\n  Ratio(const double& num, const D& denom) :\n    value_(num/double(denom)) {}\n  explicit operator double() const { return value_; }\n  private:\n  double value_;\n};\n```", "```cpp\ntemplate <typename N> class Ratio<N, double> {\n  public:\n  Ratio() : value_() {}\n  Ratio(const N& num, const double& denom) :\n    value_(double(num)/denom) {}\n  explicit operator double() const { return value_; }\n  private:\n  double value_;\n};\n```", "```cpp\ntemplate <> class Ratio<double, double> {\n  public:\n  Ratio() : value_() {}\n  template <typename N, typename D>\n    Ratio(const N& num, const D& denom) :\n      value_(double(num)/double(denom)) {}\n  explicit operator double() const { return value_; }\n  private:\n  double value_;\n};\n```", "```cpp\ntemplate <typename N, typename D> class Ratio<N*, D*> {\n  public:\n  Ratio(N* num, D* denom) : num_(num), denom_(denom) {}\n  explicit operator double() const {\n    return double(*num_)/double(*denom_);\n  }\n  private:\n  N* const num_;\n  D* const denom_;\n};\nint i = 5; double x = 10;\nauto r(make_ratio(&i, &x));        // Ratio<int*, double*>\ndouble(r);                    // 0.5\nx = 2.5;\ndouble(r);                    // 2\n```", "```cpp\ntemplate <typename T> class Value; // Declaration \ntemplate <typename T> class Value<T*> {\n  public:\n  explicit Value(T* p) : v_(*p) {} private:\n  T v_;\n};\ntemplate <typename T> class Value<T&> {\n  public:\n  explicit Value(T& p) : v_(p) {}\n  private:\n  T v_;\n};\nint i = 5; int* p = &i; int& r = i;\nValue<int*> v1(p); // T* specialization\nValue<int&> v2(r); // T& specialization\n```", "```cpp\n// Example 07\nvoid whatami(int x) {\n  std::cout << x << \" is int\" << std::endl;\n}\nvoid whatami(long x) {\n  std::cout << x << \" is long\" << std::endl;\n}\nwhatami(5);    // 5 is int\nwhatami(5.0);    // Compilation error\n```", "```cpp\nvoid whatami(int x); // Same as above\nvoid whatami(long x); // Same as above\ntemplate <typename T> void whatami(T* x) {\n  std::cout << x << \" is a pointer\" << std::endl;\n}\nint i = 5;\nwhatami(i);    // 5 is int\nwhatami(&i);    // 0x???? is a pointer\n```", "```cpp\nvoid whatami(int x); // Same as above\nvoid whatami(long x); // Same as above\ntemplate <typename T> void whatami(T* x); // Same as above\ntemplate <typename T> void whatami(T&& x) {\n  std::cout << \"Something weird\" << std::endl;\n}\nclass C {    };\nC c;\nwhatami(c);    // Something weird\nwhatami(&c);    // 0x???? is a pointer\n```", "```cpp\nvoid whatami(int x) {\n  std::cout << x << \" is int\" << std::endl;\n}\nvoid whatami(double x) {\n  std::cout << x << \" is double\" << std::endl;\n}\ntemplate <typename T> void whatami(T&& x) {\n  std::cout << \"Something weird\" << std::endl;\n}\nint i = 5;\nfloat x = 4.2;\nwhatami(i);    // i is int\nwhatami(x);    // Something weird\nwhatami(1.2);    // 1.2 is double\n```", "```cpp\ntemplate <typename T> void whatami(T&& x) {\n  std::cout << \"Something weird\" << std::endl;\n}\ntemplate <typename T> void whatami(T x) {\n  std::cout << \"Something copyable\" << std::endl;\n}\nclass C {};\nC c;\nwhatami(c);\n```", "```cpp\nvoid whatami(...) {\n  std::cout << \"It's something or somethings\" << std::endl;\n}\n```", "```cpp\ntemplate <typename ... T> auto sum(const T& ... x);\n```", "```cpp\n// Example 08a\ntemplate <typename ... T> auto sum(const T& ... x) {\n  return (x + ...);\n}\nsum(5, 7, 3);        // 15, int\nsum(5, 7L, 3);        // 15, long\nsum(5, 7L, 2.9);        // 14.9, double\n```", "```cpp\nstatic_assert(std::is_same_v<\n  decltype(sum(5, 7L, 2.9)), double>);\n```", "```cpp\n// Example 08b\ntemplate <typename T1> auto sum(const T1& x1) {\n  return x1;\n}\ntemplate <typename T1, typename ... T>\nauto sum(const T1& x1, const T& ... x) {\n  return x1 + sum(x ...);\n}\n```", "```cpp\n// Example 09\ntemplate <typename ... T> struct Group;\n```", "```cpp\ntemplate <typename ... T> struct Group;\ntemplate <typename T1> struct Group<T1> {\n  T1 t1_;\n  Group() = default;\n  explicit Group(const T1& t1) : t1_(t1) {}\n  explicit Group(T1&& t1) : t1_(std::move(t1)) {}\n  explicit operator const T1&() const { return t1_; }\n  explicit operator T1&() { return t1_; }\n};\n```", "```cpp\ntemplate <typename T1, typename ... T>\nstruct Group<T1, T ...> : Group<T ...> {\n  T1 t1_;\n  Group() = default;\n  explicit Group(const T1& t1, T&& ... t) :\n    Group<T ...>(std::forward<T>(t) ...), t1_(t1) {}\n  explicit Group(T1&& t1, T&& ... t) :\n    Group<T...>(std::forward<T>(t)...),\n                t1_(std::move(t1)) {}\n  explicit operator const T1&() const { return t1_; }\n  explicit operator T1&() { return t1_; }\n};\n```", "```cpp\nGroup<int, long> g(3, 5);\nint(g);    // 3\nlong(g);    // 5\n```", "```cpp\ntemplate <typename ... T> Group(T&&... t) -> Group<T...>;\nGroup g(3, 2.2, std::string(\"xyz\"));\nint(g);            // 3\ndouble(g);            // 2.2\nstd::string(g);        // \"xyz\"\n```", "```cpp\ntemplate <typename ... T> auto makeGroup(T&& ... t) {\n  return Group<T ...>(std::forward<T>(t) ...);\n}\nauto g = makeGroup(3, 2.2, std::string(\"xyz\"));\n```", "```cpp\n// Example 10\ntemplate <auto... Values> struct value_list {};\n```", "```cpp\ntemplate <size_t N, auto... Values>\nstruct nth_value_helper;\ntemplate <size_t n, auto v1, auto... Values>\nstruct nth_value_helper<n, v1, Values...> {\n  static constexpr auto value =\n    nth_value_helper<n - 1, Values...>::value;\n};\ntemplate <auto v1, auto... Values>\nstruct nth_value_helper<0, v1, Values...> {\n  static constexpr auto value = v1;\n};\ntemplate <size_t N, auto... Values>\nconstexpr auto nth_value(value_list<Values...>) {\n  return nth_value_helper<N, Values...>::value;\n}\n```", "```cpp\ntemplate <template <typename...> class Container,\n         typename... T>\nvoid print(const Container<T...>& container);\nstd::vector<int> v{ … };\nprint(v);\n```", "```cpp\nvoid f(int i); struct G {\n  void operator()(int i);\n};\nf(5);            // Function\nG g; g(5);        // Functor\n```", "```cpp\nbool compare(int i, int j) { return i < j; }\nvoid do_work() {\n  std::vector<int> v;\n  .....\n  std::sort(v.begin(), v.end(), compare);\n}\n```", "```cpp\nvoid do_work() {\n  std::vector<int> v;\n  .....\n  struct compare {\n    bool operator()(int i, int j) const { return i < j; }\n  };\n  std::sort(v.begin(), v.end(), compare());\n}\n```", "```cpp\nvoid do_work() {\n  std::vector<int> v;\n  .....\n  auto compare = [](int i, int j) { return i < j; };\n  std::sort(v.begin(), v.end(), compare);\n}\n```", "```cpp\n  std::sort(v.begin(), v.end(),\n            [](int i, int j) { return i < j; });\n```", "```cpp\n// Example 11\nvoid do_work() {\n  std::vector<double> v;\n  .....\n  struct compare_with_tolerance {\n    const double tolerance;\n    explicit compare_with_tolerance(double tol) :\n      tolerance(tol) {}\n    bool operator()(double x, double y) const {\n      return x < y && std::abs(x - y) > tolerance;\n    }\n  };\n  double tolerance = 0.01;\n  std::sort(v.begin(), v.end(),\n            compare_with_tolerance(tolerance));\n}\n```", "```cpp\nvoid do_work() {\n  std::vector<double> v;\n  .....\n  double tolerance = 0.01;\n  auto compare_with_tolerance = [=](auto x, auto y) {\n    return x < y && std::abs(x - y) > tolerance;\n  };\n  std::sort(v.begin(), v.end(), compare_with_tolerance);\n}\n```", "```cpp\nauto compare_with_tolerance = [&](auto x, auto y) {\n  return x < y && std::abs(x - y) > tolerance;\n};\n```", "```cpp\ndouble tolerance = 0.01;\nsize_t count = 0; // line 2\nauto compare_with_tolerance = [=](auto x, auto y) mutable {\n  std::cout << \"called \" << ++count << \" times\\n\";\n  return x < y && std::abs(x - y) > tolerance;\n};\nstd::vector<double> v;\n… store values in v …\n// Counts calls but does not change the value on line 2\nstd::sort(v.begin(), v.end(), compare_with_tolerance);\n```", "```cpp\ndouble tolerance = 0.01;\nsize_t count = 0;\nauto compare_with_tolerance = [&](auto x, auto y) mutable {\n  ++count; // Changes count above\n  return x < y && std::abs(x - y) > tolerance;\n};\nstd::vector<double> v;\n… store values in v …\nstd::sort(v.begin(), v.end(), compare_with_tolerance);\nstd::cout << \"lambda called \" << count << \" times\\n\";\n```", "```cpp\n// Example 12a\ntemplate <typename ... F> struct overload_set;\ntemplate <typename F1>\nstruct overload_set<F1> : public F1 {\n  overload_set(F1&& f1) : F1(std::move(f1)) {}\n  overload_set(const F1& f1) : F1(f1) {}\n  using F1::operator();\n};\ntemplate <typename F1, typename ... F>\nstruct overload_set<F1, F ...> :\n    public F1, public overload_set<F ...> {\n  overload_set(F1&& f1, F&& ... f) :\n    F1(std::move(f1)),\n    overload_set<F ...>(std::forward<F>(f) ...) {}\n  overload_set(const F1& f1, F&& ... f) :\n    F1(f1), overload_set<F ...>(std::forward<F>(f) ...) {}\n  using F1::operator();\n  using overload_set<F ...>::operator();\n};\ntemplate <typename ... F> auto overload(F&& ... f) {\n  return overload_set<F ...>(std::forward<F>(f) ...);\n}\n```", "```cpp\nint i = 5;\ndouble d = 7.3;\nauto l = overload(\n  [](int* i) { std::cout << \"i=\" << *i << std::endl; },\n  [](double* d) { std::cout << \"d=\" << *d << std::endl; }\n);\nl(&i);    // i=5\nl(&d);    // d=5.3\n```", "```cpp\n// Example 12b\ntemplate <typename ... F>\nstruct overload_set : public F ... {\n  overload_set(F&& ... f) : F(std::forward<F>(f)) ... {}\n  using F::operator() ...;    // C++17\n};\ntemplate <typename ... F> auto overload(F&& ... f) {\n  return overload_set<F ...>(std::forward<F>(f) ...);\n}\n```", "```cpp\n// Example 12c\ntemplate <typename ... F>\nstruct overload : public F ... {\n  using F::operator() ...;\n};\ntemplate <typename ... F> // Deduction guide\noverload(F&& ... ) -> overload<F ...>;\n```", "```cpp\nint i = 5;\ndouble d = 7.3;\nauto l = overload{\n  [](int* i) { std::cout << \"i=\" << *i << std::endl; },\n  [](double* d) { std::cout << \"d=\" << *d << std::endl; },\n};\nl(&i);    // i=5\nl(&d);    // d=5.3\n```", "```cpp\n// Example 13a\ntemplate <typename T> T copy(T&& t)\n  requires (sizeof(T) > 1)\n{\n  return std::forward<T>(t);\n}\n```", "```cpp\ntemplate <typename T1, typename T2>\nstd::common_type_t<T1, T2> min2(T1&& t1, T2&& t2)\n{\n  if (t1 < t2) return std::forward<T1>(t1);\n  return std::forward<T2>(t2);\n}\n```", "```cpp\nstatic_assert(sizeof(t1 < t2) > 0);\n```", "```cpp\n// Example 13b\ntemplate <typename T1, typename T2>\nstd::common_type_t<T1, T2> min2(T1&& t1, T2&& t2)\n  requires (sizeof(t1 < t2) > 0)\n{\n  if (t1 < t2) return std::forward<T1>(t1);\n  return std::forward<T2>(t2);\n}\n```", "```cpp\ntemplate <typename T1, typename T2>\nstd::common_type_t<T1, T2> min2(T1&& t1, T2&& t2)\n  requires (sizeof(t1 < t2));\n```", "```cpp\n// Example 13b\ntemplate <typename T1, typename T2>\nstd::common_type_t<T1, T2> min2(T1&& t1, T2&& t2)\n  requires (requires { t1 < t2; });\n```", "```cpp\n// Example 13c\ntemplate <typename T1, typename T2> concept Comparable =\n  requires(T1 t1, T2 t2) { t1 < t2; };\n```", "```cpp\ntemplate <typename T1, typename T2>\nstd::common_type_t<T1, T2> min2(T1&& t1, T2&& t2)\n  requires Comparable<T1, T2>;\n```", "```cpp\n// Example 14a,b\ntemplate <typename T> concept HasXOR =\n  requires(T a, T b) { a ^ b; };\n```", "```cpp\ntemplate <HasXOR T> void MySwap(T& x, T& y) {\n     x = x ^ y;\n     y = x ^ y;\n     x = x ^ y;\n}\n```", "```cpp\ntemplate <typename T> concept Assignable =\n  requires(T a, T b) {\n    T(std::move(b));\n    b = std::move(a);\n  };\n```", "```cpp\ntemplate <Assignable T> void MySwap(T& x, T& y)\n  requires (!HasXOR<T>)\n{\n  T tmp(std::move(x));\n  x = std::move(y);\n  y = std::move(tmp);\n}\n```", "```cpp\n// Example 15\ntemplate <typename T> class ArrayOf2 {\n  public:\n  T& operator[](size_t i) { return a_[i]; }\n  const T& operator[](size_t i) const { return a_[i]; }\n  T sum() const requires (requires (T a, T b) { a + b; }) {\n    return a_[0] + a_[1];\n  }\n  private:\n  T a_[2];\n};\n```"]