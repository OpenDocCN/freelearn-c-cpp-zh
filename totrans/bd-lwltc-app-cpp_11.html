<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-280"><a id="_idTextAnchor293"/>11</h1>
<h1 id="_idParaDest-281"><a id="_idTextAnchor294"/>Adding Instrumentation and Measuring Performance</h1>
<p>In this chapter, we will add a system to measure the performance of the C++ components we have built so far in this book. We will measure the latencies in the trading exchange system we built in <em class="italic">Part 2</em> and the latencies in the client’s trading system built in the previous section. Finally, we will measure and analyze the performance of the end-to-end system by running the different algorithms we built in the previous section. In this chapter, we will cover the following topics:</p>
<ul>
<li>Adding an instrumentation system to measure system performance</li>
<li>Measuring latencies in the exchange</li>
<li>Measuring latencies in the trading engine</li>
<li>Running the entire ecosystem with the new instrumentation system</li>
</ul>
<h1 id="_idParaDest-282"><a id="_idTextAnchor295"/>Technical requirements</h1>
<p>All the code for this book can be found in the book’s GitHub repository at <a href="https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP">https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP</a>. The source for this chapter is in the <code>Chapter11</code> directory in the repository.</p>
<p>This chapter relies on a lot of the previous chapters since we will be measuring the performance of all the different components and subcomponents in the electronic trading ecosystem. So, we expect you to be familiar with the code base we have built so far, specifically, the <em class="italic">Building the C++ Matching Engine</em>, <em class="italic">Communicating with Market Participants</em>, <em class="italic">Processing Market Data and Sending Orders to the Exchange in C++</em>, <em class="italic">Building the C++ Trading Algorithm Building Blocks</em>, and finally, <em class="italic">Building the C++ Market Making and Liquidity Taking </em><em class="italic">Algorithms</em> chapters.</p>
<p>The specifications of the environment in which the source code for this book was developed are shown next. We present the details of this environment since all the C++ code presented in this book is not necessarily portable and might require some minor changes to work in your environment:</p>
<ul>
<li>OS – <code>Linux 5.19.0-41-generic #42~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Apr 18 17:40:00 UTC 2 x86_64 x86_64 </code><code>x86_64 GNU/Linux</code></li>
<li>GCC – <code>g++ (Ubuntu </code><code>11.3.0-1ubuntu1~22.04.1) 11.3.0</code></li>
<li>CMake – <code>cmake </code><code>version 3.23.2</code></li>
<li>Ninja – <code>1.10.2</code></li>
</ul>
<h1 id="_idParaDest-283"><a id="_idTextAnchor296"/>Adding an instrumentation system to measure system performance</h1>
<p>The first task we need to tackle<a id="_idIndexMarker1442"/> is to add a few utility methods<a id="_idIndexMarker1443"/> that will serve as the base of our performance measurement system. These are meant to be used to measure the latencies of internal components and subcomponents for processes running on the same server. These are also meant to be used to measure latencies between the different components, which are unlikely to be on the same server in practice, such as the trading exchange and the trading clients, which are on different servers. Note, however, that in this book, we run the trading exchange and the trading clients on the same server for simplicity. Now, let us start by adding these utilities in the next section.</p>
<h2 id="_idParaDest-284"><a id="_idTextAnchor297"/>Adding utilities for performance measurement using RDTSC</h2>
<p>The first performance measurement utility we <a id="_idIndexMarker1444"/>add does not directly<a id="_idIndexMarker1445"/> measure the time itself but, instead, measures how many CPU clock cycles elapse between two spots in our code base. This is achieved<a id="_idIndexMarker1446"/> by reading the value of the <code>rdtsc</code>, to fetch and return this value, which returns this in the form of two 32-bit values that we will convert into a single 64-bit value. We can use these <code>rdtsc</code> values as is to measure/compare performance if we do not really care about converting them into time units. The other option is to convert this <code>rdtsc</code> value into time units, which is achieved <a id="_idIndexMarker1447"/>by dividing this value<a id="_idIndexMarker1448"/> by the system’s clock frequency, which is specified as the number of CPU clock cycles per second. For instance, on my system, the CPU clock frequency comes out to be around 2.6 GHz, as shown here:</p>
<pre class="source-code">
sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter11$ cat /proc/cpuinfo | grep MHz
cpu MHz         : 2645.048
cpu MHz         : 2645.035
cpu MHz         : 2645.033
cpu MHz         : 2645.050</pre>
<p>What this means is that if we measure the <code>rdtsc</code> value before and after the execution of a code block and the difference between the two values is 26 clock cycles, on my system, that translates to approximately 26 / 2.6 = a 10-nanosecond execution time. We will talk about this more in the last subsection of this section, <em class="italic">Understanding some issues with measurement systems in practice</em>. So, without any more delay, let us look at the code for this measurement implementation. All the code for this section can be found in the <code>Chapter11/common/perf_utils.h</code> source file.</p>
<p>First, we implement an <code>rdtsc()</code> C++ method, which internally calls the <code>rdtsc</code> assembly instruction and provides it with two variables, <code>lo</code> and <code>hi</code>, to read the lower and higher 32-bits that make up the final <code>rdtsc</code> value. The <code>__asm__</code> instruction tells the compiler that what follows it is an assembly instruction. The <code>__volatile__</code> instruction exists to prevent the compiler from optimizing the instructions so that it is executed as is to make sure we read the TSC register every time this is called. We save the output into the <code>lo</code> and <code>hi</code> variables and, finally, using a bit shift operation, create a 64-bit value from them and return it:</p>
<pre class="source-code">
#pragma once
namespace Common {
  inline auto rdtsc() noexcept {
    unsigned int lo, hi;
    __asm__ __volatile__ ("rdtsc" : "=a" (lo), "=d" (hi));
    return ((uint64_t) hi &lt;&lt; 32) | lo;
  }
}</pre>
<p>Next, we will define a simple preprocessor macro, <code>START_MEASURE</code>, which accepts an argument called <code>TAG</code>, and all it does<a id="_idIndexMarker1449"/> is create a variable with that name<a id="_idIndexMarker1450"/> and saves the value of the <code>rdtsc()</code> method we just built in it. In other words, this macro simply creates a variable with the name provided and saves the <code>rdtsc()</code> value in it:</p>
<pre class="source-code">
#define START_MEASURE(TAG) const auto TAG = Common::rdtsc()</pre>
<p>We define another complimentary macro called <code>END_MEASURE</code>, which accepts an argument called <code>TAG</code> as well as an argument called <code>LOGGER</code>, which it expects to be of our <code>Common::Logger</code> type. It takes another measurement using the <code>rdtsc()</code> method we built previously and uses the <code>LOGGER</code> object to log the difference between the two. The only reason this code block is enclosed in a <code>do {} while(false)</code> loop (without a terminating semi-colon) is to make sure that the compiler catches missing semi-colons when this method is invoked. In other words, <code>END_MEASURE(example, logger_);</code> is a valid use but <code>END_MEASURE(example, logger_)</code> (missing semi-colon) causes a compilation error to maintain symmetry with <code>START_MEASURE</code>. This is not strictly necessary, just a preference on our part:</p>
<pre class="source-code">
#define END_MEASURE(TAG, LOGGER) \
      do { \
        const auto end = Common::rdtsc(); \
        LOGGER.log("% RDTSC "#TAG" %\n",
          Common::getCurrentTimeStr(&amp;time_str_), (end -
            TAG)); \
      } while(false)</pre>
<p>Finally, we will define a similar macro called <code>TTT_MEASURE</code> that takes similar arguments (i.e., <code>TAG</code> and <code>LOGGER</code>), This macro simply logs the current time in nanoseconds, which it obtains by calling our <code>Common::getCurrentNanos()</code> method that we saw before:</p>
<pre class="source-code">
#define TTT_MEASURE(TAG, LOGGER) \
      do { \
        const auto TAG = Common::getCurrentNanos(); \
        LOGGER.log("% TTT "#TAG" %\n", Common::
          getCurrentTimeStr(&amp;time_str_), TAG); \
      } while(false)</pre>
<p>We will use these macros<a id="_idIndexMarker1451"/> throughout this chapter, but before<a id="_idIndexMarker1452"/> we do that, we need to make some minor changes to the time utilities we built before and have seen many uses of already.</p>
<h2 id="_idParaDest-285"><a id="_idTextAnchor298"/>Updating our previous time utilities</h2>
<p>In this section, we will make a minor change<a id="_idIndexMarker1453"/> to the time utility <code>Common::getCurrentTimeStr()</code> method to make the output more informative and granular. The goal here is to change our previous output, which looked like this:</p>
<pre class="source-code">
onMarketUpdate() Sat Jun  3 09:46:34 2023 MEMarketUpdate</pre>
<p>We want to change it to this format, which drops the date and year from the output and changes the time output from just having seconds to having seconds and nanoseconds to add granularity:</p>
<pre class="source-code">
onMarketUpdate() 09:46:34.645778416 MEMarketUpdate</pre>
<p>This will help us inspect, order, and analyze events that happen in the same second even more closely. These changes can be found in the <code>Chapter11/common/time_utils.h</code> source file.</p>
<p>Note that the other change is the inclusion of the <code>perf_utils.h</code> header file containing the measurement methods we built in the previous section:</p>
<pre class="source-code">
#include "perf_utils.h"</pre>
<p>We saw this before in the <em class="italic">Building the C++ Building Blocks for Low-Latency Applications</em> chapter in the <em class="italic">Designing utility methods for time</em> section. We call <code>std::chrono::system_clock::now()</code> to extract the current <code>time_point</code> value and save it in the <code>clock</code> variable. We also extract and save the <code>time_t</code> object from it into the <code>time</code> variable using the <code>std::chrono::system_clock::to_time_t()</code> method, as shown:</p>
<pre class="source-code">
namespace Common {
  inline auto&amp; getCurrentTimeStr(std::string* time_str) {
    const auto clock = std::chrono::system_clock::now();
    const auto time = std::chrono::
      system_clock::to_time_t(clock);</pre>
<p>We use a combination of <code>sprintf()</code>, <code>ctime()</code>, and the previously seen <code>std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(clock.time_since_epoch()).count()</code> method to extract and format the current time in the <code>HH:MM:SS.nnnnnnnnn</code> format. Finally, we assign it to the <code>time_str</code> object of the <code>std::string</code> type, which is passed<a id="_idIndexMarker1454"/> to this method, as well as return it:</p>
<pre class="source-code">
    char nanos_str[24];
    sprintf(nanos_str, "%.8s.%09ld", ctime(&amp;time) + 11,
      std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;
       (clock.time_since_epoch()).count() % NANOS_TO_SECS);
    time_str-&gt;assign(nanos_str);
    return *time_str;
  }
}</pre>
<p>Before we move on to using these new methods, we will discuss a few more points regarding measuring performance in practice.</p>
<h2 id="_idParaDest-286"><a id="_idTextAnchor299"/>Understanding some issues with measurement systems in practice</h2>
<p>In this section, we will discuss a few important considerations when it comes to measuring performance in practice. This is important to understand because performance measurement is not always as easy as it seems and it requires you to understand some nuances.</p>
<h3>Adding overhead due to instrumentation</h3>
<p>The first key point <a id="_idIndexMarker1455"/>we want to make about measuring performance in practice is that it is important to consider that the measurement system itself is not zero-latency. What this means is that adding instrumentation into the path of the critical code base adds some extra latency. It is important to make sure that the instrumentation system/routine itself is extremely low-latency relative to the latency of the system it’s measuring. A hypothetical example is that if we are measuring something that takes a few microseconds, we need to make sure that the measurement routines take a few nanoseconds to not add too much overhead. One of the reasons we have the option of using <code>rdtsc()</code> to measure performance is that it is significantly faster than calling something such as <code>std::chrono::system_clock::now()</code> or <code>clock_gettime()</code>. That gives us the option of using <code>rdtsc()</code> if we are measuring a code block that has extremely low latency to add minimal overhead.</p>
<h3>Understanding the limitations and reliability of RDTSC</h3>
<p>The second key point is regarding <code>rdtsc()</code>, which is not always very portable and can have reliability concerns<a id="_idIndexMarker1456"/> depending on the platform. Another <a id="_idIndexMarker1457"/>consideration with <code>rdtsc()</code> when converting it into time units is that CPU clock frequency can vary from core to core on a system, and using a static CPU clock frequency for the conversion is not always accurate.</p>
<h3>Setting up the correct measurement environment</h3>
<p>The third point regarding measuring<a id="_idIndexMarker1458"/> performance on trading servers is that a lot of tuning needs to be done to facilitate accurate measurements. This involves techniques such as disabling interrupts, making sure unnecessary processes are not running, making sure the NUMA setup is correct, tweaking CPU power settings, setting up CPU isolation, pinning threads to specific cores, and so on. Discussing all these considerations when it comes to electronic trading is beyond the scope of this book, nor is it the focus of this book. We just wanted<a id="_idIndexMarker1459"/> to mention that there are additional considerations when it comes to performance measurement. We refer <a id="_idIndexMarker1460"/>interested readers to the book <em class="italic">Developing High-Frequency Trading Systems: Learn how to implement high-frequency trading from scratch with C++ or Java basics</em>, which discusses <strong class="bold">High-Frequency electronic Trading</strong> (<strong class="bold">HFT</strong>) specific considerations.</p>
<p>Now we can move on to using the performance measurement system we built in this section in our electronic trading ecosystem, starting with the exchange in the next section.</p>
<h1 id="_idParaDest-287"><a id="_idTextAnchor300"/>Measuring latencies at the exchange</h1>
<p>First, we will add instrumentation<a id="_idIndexMarker1461"/> to the components on the electronic trading exchange side – the market data publisher, the matching engine, and the order server. Our approach to measuring performance will comprise two forms; let us understand those first before we look at the code.</p>
<h3>Understanding how to measure internally</h3>
<p>The first approach is to measure<a id="_idIndexMarker1462"/> the latency of internal components – for example, how long does a call to the <code>Exchange::MatchingEngine::processClientRequest()</code> method take or how long does a call to the <code>Exchange::MEOrderBook::add()</code> method take? For these cases, we will use a pair of <code>START_MEASURE()</code> and <code>END_MEASURE()</code> macros, which, in turn, use the <code>rdtsc()</code> method to measure the performance of each such call. There is nothing here that prevents us from using the <code>TTT_MEASURE()</code> macro in place of <code>rdtsc()</code> or as a supplement. But we will use <code>rdtsc()</code> for these, for the sake of providing examples of how to use the two different instrumentation systems. Additionally, we use the rationale that a call to a function such as the one we mentioned previously should be very quick and it might be better to use the lower overhead <code>rdtsc()</code> methods for that. The complete list of internal measurements we will take is listed next, but interested readers should use similar techniques to add even more points of measurement as they see fit. We will see the code for how to measure these familiar methods shortly, but for now, the methods<a id="_idIndexMarker1463"/> we will measure on the exchange side are the following:</p>
<ul>
<li><code>Common::McastSocket::send()</code></li>
<li><code>Exchange::MEOrderBook::add()</code></li>
<li><code>Exchange::MEOrderBook::cancel()</code></li>
<li><code>Exchange::MatchingEngine::processClientRequest()</code></li>
<li><code>Exchange::MEOrderBook::removeOrder()</code></li>
<li><code>Exchange::MEOrderBook::match()</code></li>
<li><code>Exchange::MEOrderBook::match()</code></li>
<li><code>Exchange::MEOrderBook::checkForMatch()</code></li>
<li><code>Exchange::MEOrderBook::addOrder()</code></li>
<li><code>Exchange::MEOrderBook::removeOrder()</code></li>
<li><code>Common::TCPSocket::send()</code></li>
<li><code>Exchange::FIFOSequencer::addClientRequest()</code></li>
<li><code>Exchange::FIFOSequencer::sequenceAndPublish()</code></li>
</ul>
<p>Next, let us take a few steps back and understand which high-level spots/hops we will timestamp in the electronic trading exchange.</p>
<h3>Understanding key hops at the exchange</h3>
<p>In addition to measuring the functioning<a id="_idIndexMarker1464"/> of internal components, exchanges can record performance data, especially timestamps, to track how events (client requests) propagate through the different components and subcomponents. We mean tracking and, often, publishing metrics such as when an order reached the order server, when it reached the matching engine, when the response to that request left the order server, when market updates corresponding to that request left the market data publisher, and so on. By recording these metrics, exchanges can understand and investigate their performance under different market/load conditions, track per-participant performance, and so on. By publishing these metrics to the market participants, the participants can understand and investigate their own performance and consider ways to improve them.</p>
<p>In our electronic trading exchange, we will take timestamps of the following events:</p>
<ul>
<li><code>T1_OrderServer_TCP_read</code> – the time when a client request is first read at the TCP socket in <code>OrderServer</code></li>
<li><code>T2_OrderServer_LFQueue_write</code> – the time when a client request is written to <code>LFQueue</code> that connects to <code>MatchingEngine</code></li>
<li><code>T3_MatchingEngine_LFQueue_read</code> – the time when <code>MatchingEngine</code> reads a client request from <code>LFQueue</code></li>
<li><code>T4_MatchingEngine_LFQueue_write</code> – the time when the market update is written to the <code>LFQueue</code> connected to <code>MarketDataPublisher</code></li>
<li><code>T4t_MatchingEngine_LFQueue_write</code> – the time when the client response is written to the <code>LFQueue</code> connected to <code>OrderServer</code></li>
<li><code>T5_MarketDataPublisher_LFQueue_read</code> – the time when the market update is read from <code>LFQueue</code></li>
<li><code>T5t_OrderServer_LFQueue_read</code> – the time when the client response is read from <code>LFQueue</code></li>
<li><code>T6_MarketDataPublisher_UDP_write</code> – the time when the market update is written to the UDP socket in <code>MarketDataPublisher</code></li>
<li><code>T6t_OrderServer_TCP_write</code> – the time when the client response is written to the TCP socket in <code>OrderServer</code></li>
</ul>
<p>The exact locations of these timestamps<a id="_idIndexMarker1465"/> are shown in the following figure:</p>
<div><div><img alt="Figure 11.1 – The topology of the electronic trading exchange with the key hops to timestamp" src="img/B19434_11_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – The topology of the electronic trading exchange with the key hops to timestamp</p>
<p>Now, starting in the next section, we<a id="_idIndexMarker1466"/> can start looking at the code changes we need to add to these two forms of measurement.</p>
<h2 id="_idParaDest-288"><a id="_idTextAnchor301"/>Measuring the latencies inside the market data publisher</h2>
<p>First, we will add performance measurement<a id="_idIndexMarker1467"/> and timestamping code<a id="_idIndexMarker1468"/> to the market data publisher. For the sake of brevity, we will only show the code blocks where we make these changes instead of including the source code for the entire source file or full code blocks in the case of large code blocks. All the changes, as well as the full, updated source code for the market data publisher-related changes, are in the <code>Chapter11/exchange/market_data/market_data_publisher.cpp</code> source file.</p>
<p>First, in the <code>MarketDataPublisher::run()</code> method, we will add a timestamp using the <code>TTT_MEASURE</code> macro and the <code>T5_MarketDataPublisher_LFQueue_read</code> tag right after reading from <code>outgoing_md_updates_</code> <code>LFQueue</code>, as shown here:</p>
<pre class="source-code">
  auto MarketDataPublisher::run() noexcept -&gt; void {
    ...
    while (run_) {
      for (auto market_update = outgoing_md_updates_-&gt;
        getNextToRead();
           outgoing_md_updates_-&gt;size() &amp;&amp; market_update;
             market_update = outgoing_md_updates_-&gt;
               getNextToRead()) {
        TTT_MEASURE(T5_MarketDataPublisher_LFQueue_read,
          logger_);</pre>
<p>Next, we will measure the time taken to call <code>MCastSocket::send()</code> on <code>incremental_socket_</code> using the <code>START_MEASURE</code> and <code>END_MEASURE</code> macros and the <code>Exchange_McastSocket_send</code> tag:</p>
<pre class="source-code">
        START_MEASURE(Exchange_McastSocket_send);
        incremental_socket_.send(&amp;next_inc_seq_num_,
          sizeof(next_inc_seq_num_));
        incremental_socket_.send(market_update,
          sizeof(MEMarketUpdate));
        END_MEASURE(Exchange_McastSocket_send, logger_);</pre>
<p>Finally, we will take another timestamp using the <code>TTT_MEASURE</code> macro and the <code>T6_MarketDataPublisher_UDP_write</code> tag right after<a id="_idIndexMarker1469"/> the socket write<a id="_idIndexMarker1470"/> is finished:</p>
<pre class="source-code">
        outgoing_md_updates_-&gt;updateReadIndex();
        TTT_MEASURE(T6_MarketDataPublisher_UDP_write,
          logger_);
        ...</pre>
<p>Next, let us look at the changes in the <code>OrderServer</code> component for performance measurement and timestamping.</p>
<h2 id="_idParaDest-289"><a id="_idTextAnchor302"/>Measuring the latencies inside the order server</h2>
<p>All the changes for performance measurement<a id="_idIndexMarker1471"/> and timestamping, as well as the full<a id="_idIndexMarker1472"/> source code for <code>OrderServer</code>, are in the <code>Chapter11/exchange/order_server/order_server.h</code> source file. As before, we will only show minimal code blocks where the changes are made for the sake of brevity and to avoid repetition.</p>
<p>First, we will make changes to the <code>OrderServer::run()</code> method, right after reading an entry from <code>outgoing_responses_</code> <code>LFQueue</code>. We use the <code>TTT_MEASURE</code> macro with the <code>T5t_OrderServer_LFQueue_read</code> tag, as shown here:</p>
<pre class="source-code">
    auto run() noexcept {
      ...
      while (run_) {
      ...
        for (auto client_response = outgoing_responses_-&gt;
          getNextToRead(); outgoing_responses_-&gt;size() &amp;&amp;
            client_response; client_response =
              outgoing_responses_-&gt;getNextToRead()) {
          TTT_MEASURE(T5t_OrderServer_LFQueue_read,
            logger_);</pre>
<p>Next, we will measure<a id="_idIndexMarker1473"/> the call to the <code>TCPSocket::send()</code> method using the <code>START_MEASURE</code> and <code>END_MEASURE</code> macros and the <code>Exchange_TCPSocket_send</code> tag. Note that<a id="_idIndexMarker1474"/> we measure the call to send out the full client response message, which, in our implementation, results in two calls to the <code>TCPSocket::send()</code> methods:</p>
<pre class="source-code">
          START_MEASURE(Exchange_TCPSocket_send);
          cid_tcp_socket_[client_response-&gt;client_id_]-&gt;
            send(&amp;next_outgoing_seq_num,
              sizeof(next_outgoing_seq_num));
          cid_tcp_socket_[client_response-&gt;client_id_]-&gt;
             send(client_response,
               sizeof(MEClientResponse));
          END_MEASURE(Exchange_TCPSocket_send, logger_);</pre>
<p>Finally, after the TCP socket send operations finish, we take another timestamp using the <code>TTT_MEASURE</code> method and the <code>T6t_OrderServer_TCP_write</code> tag:</p>
<pre class="source-code">
          outgoing_responses_-&gt;updateReadIndex();
          TTT_MEASURE(T6t_OrderServer_TCP_write, logger_);
          ...</pre>
<p>The next set of changes is in the <code>OrderServer::recvCallback()</code> method. Right as soon as we enter the method, we take a timestamp with the <code>TTT_MEASURE</code> macro with the <code>T1_OrderServer_TCP_read</code> tag:</p>
<pre class="source-code">
    auto recvCallback(TCPSocket *socket, Nanos rx_time)
      noexcept {
      TTT_MEASURE(T1_OrderServer_TCP_read, logger_);
      ...</pre>
<p>Finally, at the end of this method, we measure the call to <code>FIFOSequencer::addClientRequest()</code>, using the <code>START_MEASURE</code> and <code>END_MEASURE</code> macros with the <code>Exchange_FIFOSequencer_addClientRequest</code> tag:</p>
<pre class="source-code">
START_MEASURE(Exchange_FIFOSequencer_addClientRequest);
          fifo_sequencer_.addClientRequest(rx_time,
            request-&gt;me_client_request_);
              END_MEASURE(Exchange_FIFOSequencer_
                addClientRequest, logger_);
          ...</pre>
<p>Finally, for <code>OrderServer</code>, we need to update the <code>OrderServer::recvFinishedCallback()</code> method. We measure<a id="_idIndexMarker1475"/> the call to the <code>FIFOSequencer::sequenceAndPublish()</code> method using<a id="_idIndexMarker1476"/> the <code>START_MEASURE</code> and <code>END_MEASURE</code> macros with the <code>Exchange_FIFOSequencer_sequenceAndPublish</code> tag:</p>
<pre class="source-code">
    auto recvFinishedCallback() noexcept {
    START_MEASURE(Exchange_FIFOSequencer_sequenceAndPublis)
    ;
      fifo_sequencer_.sequenceAndPublish();
      END_MEASURE(Exchange_FIFOSequencer_
        sequenceAndPublish, logger_);
    }</pre>
<p>In the next subsection, we will add instrumentation to the <code>FIFOSequencer</code> subcomponent.</p>
<h3>Measuring the latencies inside FIFOSequencer</h3>
<p>All the instrumentation<a id="_idIndexMarker1477"/> changes, as well as the full, updated source for the <code>FIFOSequencer</code> subcomponent, can be found in the <code>Chapter11/exchange/order_server/fifo_sequencer.h</code> source file. The only changes we will make are in the <code>FIFOSequencer::sequenceAndPublish()</code> method. Here, all we do is add a timestamp after we write a client request to <code>incoming_requests_</code> <code>LFQueue</code>, which we do by using the <code>TTT_MEASURE</code> macro and using the <code>T2_OrderServer_LFQueue_write</code> tag value, as shown here:</p>
<pre class="source-code">
    auto sequenceAndPublish() {
      for (size_t i = 0; i &lt; pending_size_; ++i) {
        ...
        auto next_write = incoming_requests_-&gt;
          getNextToWriteTo();
        *next_write = std::move(client_request.request_);
        incoming_requests_-&gt;updateWriteIndex();
        TTT_MEASURE(T2_OrderServer_LFQueue_write,
          (*logger_));
        ...</pre>
<p>Next, we move on to the task of adding instrumentation and timestamps to the core matching engine component as well as its subcomponents.</p>
<h2 id="_idParaDest-290"><a id="_idTextAnchor303"/>Measuring the latencies inside the matching engine and order book</h2>
<p>First, we will update<a id="_idIndexMarker1478"/> <code>MatchingEngine</code>; all the changes<a id="_idIndexMarker1479"/> and the full, updated<a id="_idIndexMarker1480"/> source for <code>MatchingEngine</code> can be found<a id="_idIndexMarker1481"/> in the <code>Chapter11/exchange/matcher/matching_engine.h</code> source file.</p>
<p>In the <code>MatchingEngine::processClientRequest()</code> method, we will measure the time it takes for the <code>MEOrderBook::add()</code> and <code>MEOrderBook::cancel()</code> methods. First, we show the changes for the <code>MEOrderBook::add()</code> method using the <code>START_MEASURE</code> and <code>END_MEASURE</code> macros and the <code>Exchange_MEOrderBook_add</code> tag:</p>
<pre class="source-code">
    auto processClientRequest(const MEClientRequest
      *client_request) noexcept {
      ...
      switch (client_request-&gt;type_) {
        case ClientRequestType::NEW: {
          START_MEASURE(Exchange_MEOrderBook_add);
          order_book-&gt;add(client_request-&gt;client_id_,
           client_request-&gt;order_id_, client_request-&gt;
             ticker_id_,
                           client_request-&gt;side_,
                             client_request-&gt;price_,
                               client_request-&gt;qty_);
          END_MEASURE(Exchange_MEOrderBook_add, logger_);
          ...</pre>
<p>Then, we have the changes for <code>MEOrderBook::cancel()</code> using the <code>START_MEASURE</code> and <code>END_MEASURE</code> macros and the <code>Exchange_MEOrderBook_cancel</code> tag, as shown here:</p>
<pre class="source-code">
        case ClientRequestType::CANCEL: {
          START_MEASURE(Exchange_MEOrderBook_cancel);
          order_book-&gt;cancel(client_request-&gt;client_id_,
            client_request-&gt;order_id_, client_request-&gt;
              ticker_id_);
          END_MEASURE(Exchange_MEOrderBook_cancel,
            logger_);
          ...</pre>
<p>The next method we need<a id="_idIndexMarker1482"/> to update is <code>MatchingEngine::sendClientResponse()</code>. We will use the <code>TTT_MEASURE</code> macro <a id="_idIndexMarker1483"/>with the <code>T4t_MatchingEngine_LFQueue_write</code> tag right after we write<a id="_idIndexMarker1484"/> the client response<a id="_idIndexMarker1485"/> to <code>outgoing_ogw_responses_</code> <code>LFQueue</code>, as shown here:</p>
<pre class="source-code">
    auto sendClientResponse(const MEClientResponse
      *client_response) noexcept {
      ...
      auto next_write = outgoing_ogw_responses_-&gt;
        getNextToWriteTo();
      *next_write = std::move(*client_response);
      outgoing_ogw_responses_-&gt;updateWriteIndex();
      TTT_MEASURE(T4t_MatchingEngine_LFQueue_write,
        logger_);
    }</pre>
<p>We also need to update the <code>MatchingEngine::sendMarketUpdate()</code> method by adding a timestamp after writing the market update to <code>outgoing_md_updates_</code> <code>LFQueue</code> using the <code>TTT_MEASURE</code> macro and the <code>T4_MatchingEngine_LFQueue_write</code> tag:</p>
<pre class="source-code">
    auto sendMarketUpdate(const MEMarketUpdate
      *market_update) noexcept {
      ...
      auto next_write = outgoing_md_updates_-&gt;
        getNextToWriteTo();
      *next_write = *market_update;
      outgoing_md_updates_-&gt;updateWriteIndex();
      TTT_MEASURE(T4_MatchingEngine_LFQueue_write,
        logger_);
    }</pre>
<p>The final method we need to update in <code>MatchingEngine</code> is the <code>run()</code> method itself. We take a timestamp right after reading from <code>incoming_requests_</code> <code>LFQueue</code>, using the <code>TTT_MEASURE</code> macro and the <code>T3_MatchingEngine_LFQueue_read</code> tag, as shown here:</p>
<pre class="source-code">
    auto run() noexcept {
      while (run_) {
        const auto me_client_request = incoming_requests_-&gt;
          getNextToRead();
        if (LIKELY(me_client_request)) {
          TTT_MEASURE(T3_MatchingEngine_LFQueue_read,
            logger_);</pre>
<p>And we measure the call to the <code>MatchingEngine::processClientRequest()</code> method with the <code>START_MEASURE</code> and <code>END_MEASURE</code> macros with the <code>Exchange_MatchingEngine_processClientRequest</code> tag:</p>
<pre class="source-code">
START_MEASURE(Exchange_MatchingEngine_processClientRequest);          processClientRequest(me_client_request);
END_MEASURE(Exchange_MatchingEngine_processClientRequest,
  logger_);
          ...</pre>
<p>The final component<a id="_idIndexMarker1486"/> on the exchange<a id="_idIndexMarker1487"/> side that we need to update<a id="_idIndexMarker1488"/> is the <code>MEOrderBook</code> subcomponent<a id="_idIndexMarker1489"/> in <code>MatchingEngine</code>.</p>
<h3>Measuring the latencies inside MEOrderBook</h3>
<p>We will discuss<a id="_idIndexMarker1490"/> the instrumentation changes to the <code>MEOrderBook</code> component in this subsection, which can be found in the <code>Chapter11/exchange/matcher/me_order_book.cpp</code> source file.</p>
<p>The first method we will update is <code>MEOrderBook::match()</code>. We want to measure the call to <code>MEOrderBook::removeOrder()</code> with the <code>START_MEASURE</code> and <code>END_MEASURE</code> macros and the <code>Exchange_MEOrderBook_removeOrder</code> tag, as shown here:</p>
<pre class="source-code">
  auto MEOrderBook::match(TickerId ticker_id, ClientId
    client_id, Side side, OrderId client_order_id, OrderId
      new_market_order_id, MEOrder* itr, Qty* leaves_qty)
        noexcept {
    ...
    if (!order-&gt;qty_) {
      ...
      START_MEASURE(Exchange_MEOrderBook_removeOrder);
      removeOrder(order);
      END_MEASURE(Exchange_MEOrderBook_removeOrder,
        (*logger_));
      ...</pre>
<p>We also need<a id="_idIndexMarker1491"/> to update the <code>MEOrderBook::checkForMatch()</code> method to measure the calls to <code>MEOrderBook::match()</code>. We use the <code>START_MEASURE</code> and <code>END_MEASURE</code> macros with the <code>Exchange_MEOrderBook_match</code> tag for the two branches of execution, as shown here:</p>
<pre class="source-code">
  auto MEOrderBook::checkForMatch(ClientId client_id,
    OrderId client_order_id, TickerId ticker_id, Side side,
      Price price, Qty qty, Qty new_market_order_id)
        noexcept {
    ...
    if (side == Side::BUY) {
      while (leaves_qty &amp;&amp; asks_by_price_) {
        ...
        START_MEASURE(Exchange_MEOrderBook_match);
        match(ticker_id, client_id, side, client_order_id,
          new_market_order_id, ask_itr, &amp;leaves_qty);
        END_MEASURE(Exchange_MEOrderBook_match,
          (*logger_));
      }
    }
    if (side == Side::SELL) {
      while (leaves_qty &amp;&amp; bids_by_price_) {
        ...
        START_MEASURE(Exchange_MEOrderBook_match);
        match(ticker_id, client_id, side, client_order_id,
          new_market_order_id, bid_itr, &amp;leaves_qty);
        END_MEASURE(Exchange_MEOrderBook_match,
          (*logger_));
      }
    }
    ...</pre>
<p>We will add additional instrumentation<a id="_idIndexMarker1492"/> within the <code>MEOrderBook::add()</code> method to measure a few different calls. The first one is the call to <code>MEOrderBook::checkForMatch()</code>, for which we will use the <code>Exchange_MEOrderBook_checkForMatch</code> tag:</p>
<pre class="source-code">
  auto MEOrderBook::add(ClientId client_id, OrderId
    client_order_id, TickerId ticker_id, Side side, Price
      price, Qty qty) noexcept -&gt; void {
    ...
    START_MEASURE(Exchange_MEOrderBook_checkForMatch);
    const auto leaves_qty = checkForMatch(client_id,
      client_order_id, ticker_id, side, price, qty,
        new_market_order_id);
    END_MEASURE(Exchange_MEOrderBook_checkForMatch,
      (*logger_));
    …</pre>
<p>The next one is the call to <code>MEOrderBook::addOrder()</code>, for which we will use the <code>Exchange_MEOrderBook_addOrder</code> tag:</p>
<pre class="source-code">
      START_MEASURE(Exchange_MEOrderBook_addOrder);
      addOrder(order);
      END_MEASURE(Exchange_MEOrderBook_addOrder,
       (*logger_));
      ...</pre>
<p>The last <code>MEOrderBook</code> method we need to add<a id="_idIndexMarker1493"/> more granular instrumentation to is the <code>cancel()</code> method. In this method, we want to measure the call to the <code>MEOrderBook::removeOrder()</code> method, as shown next, with the <code>START_MEASURE</code> and <code>END_MEASURE</code> macros and the <code>Exchange_MEOrderBook_removeOrder</code> tag:</p>
<pre class="source-code">
  auto MEOrderBook::cancel(ClientId client_id, OrderId
    order_id, TickerId ticker_id) noexcept -&gt; void {
      ...
      START_MEASURE(Exchange_MEOrderBook_removeOrder);
      removeOrder(exchange_order);
      END_MEASURE(Exchange_MEOrderBook_removeOrder,
        (*logger_));
      ...</pre>
<p>This concludes all the measurements we wanted to add on the side of the electronic exchange, and in the next section, we will add similar instrumentation on the other side: that is, the trading client system.</p>
<h1 id="_idParaDest-291"><a id="_idTextAnchor304"/>Measuring latencies in the trading engine</h1>
<p>In this section, we will focus on adding<a id="_idIndexMarker1494"/> performance measurement and timestamps to the trading client’s system – the market data consumer, the order gateway, and the trade engine and its subcomponents. Here too, we will measure the performance of internal components as well as add timestamps to help with a higher-level analysis of incoming and outgoing events latencies.</p>
<h3>Understanding how to measure internally</h3>
<p>The motivation and approach<a id="_idIndexMarker1495"/> toward measuring the performance of internal components for the trading clients’ systems are identical to those on the exchange side. The complete list of internal measurements we will take is listed next, but interested readers should use similar techniques to add even more points of measurement as they see fit. We will see the code for how to measure these familiar methods shortly, but for now, the methods we will measure on the client’s side are the following:</p>
<ul>
<li><code>Trading::MarketDataConsumer::recvCallback()</code></li>
<li><code>Common::TCPSocket::send()</code></li>
<li><code>Trading::OrderGateway::recvCallback()</code></li>
<li><code>Trading::OrderManager::moveOrders()</code></li>
<li><code>Trading::OrderManager::onOrderUpdate()</code></li>
<li><code>Trading::OrderManager::moveOrders()</code></li>
<li><code>Trading::OrderManager::onOrderUpdate()</code></li>
<li><code>Trading::MarketOrderBook::addOrder()</code></li>
<li><code>Trading::MarketOrderBook::removeOrder()</code></li>
<li><code>Trading::MarketOrderBook::updateBBO()</code></li>
<li><code>Trading::OrderManager::cancelOrder()</code></li>
<li><code>Trading::RiskManager::checkPreTradeRisk()</code></li>
<li><code>Trading::OrderManager::newOrder()</code></li>
<li><code>Trading::OrderManager::moveOrder()</code></li>
<li><code>Trading::OrderManager::moveOrder()</code></li>
<li><code>Trading::PositionKeeper::updateBBO()</code></li>
<li><code>Trading::FeatureEngine::onOrderBookUpdate()</code></li>
<li><code>Trading::TradeEngine::algoOnOrderBookUpdate()</code></li>
<li><code>Trading::FeatureEngine::onTradeUpdate()</code></li>
<li><code>Trading::TradeEngine::algoOnTradeUpdate()</code></li>
<li><code>Trading::PositionKeeper::addFill()</code></li>
<li><code>Trading::TradeEngine::algoOnOrderUpdate()</code></li>
</ul>
<p>As we did with the electronic trading<a id="_idIndexMarker1496"/> exchange, we will understand the key hops that we will timestamp in the trading client’s system.</p>
<h3>Understanding key hops in the trading client’s system</h3>
<p>Market participants also have<a id="_idIndexMarker1497"/> similar reasons for timestamping the flow of events<a id="_idIndexMarker1498"/> through each of the components and subcomponents. By recording and analyzing the timings of these events, participants can seek to improve their systems as well as analyze how to increase profitability.</p>
<p>In our electronic trading client’s system, we will take timestamps of the following events:</p>
<ul>
<li><code>T7_MarketDataConsumer_UDP_read</code> – the time when a market data update is read from the UDP socket in <code>MarketDataConsumer</code></li>
<li><code>T7t_OrderGateway_TCP_read</code> – the time when a client response is read from the TCP socket in <code>OrderGateway</code></li>
<li><code>T8_MarketDataConsumer_LFQueue_write</code> – the time when a market data update is written to the <code>LFQueue</code> connected to <code>TradeEngine</code></li>
<li><code>T8t_OrderGateway_LFQueue_write</code> – the time when a client response is written to the <code>LFQueue</code> connected to <code>TradeEngine</code></li>
<li><code>T9_TradeEngine_LFQueue_read</code> – the time when a market data update is read from the <code>LFQueue</code> from <code>MarketDataConsumer</code></li>
<li><code>T9t_TradeEngine_LFQueue_read</code> – the time when a client response is read from the <code>LFQueue</code> from <code>OrderGateway</code></li>
<li><code>T10_TradeEngine_LFQueue_write</code> – the time when a client request is written to the <code>LFQueue</code> connected to <code>OrderGateway</code></li>
<li><code>T11_OrderGateway_LFQueue_read</code> – the time when <code>OrderGateway</code> reads a client request from the <code>LFQueue</code> from <code>TradeEngine</code></li>
<li><code>T12_OrderGateway_TCP_write</code> – the time when <code>OrderGateway</code> writes a client request to the TCP socket</li>
</ul>
<p>The exact locations<a id="_idIndexMarker1499"/> of these timestamps<a id="_idIndexMarker1500"/> are shown in the following figure:</p>
<div><div><img alt="Figure 11.2 – The topology of the electronic trading client’s system with the key hops to timestamp" src="img/B19434_11_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – The topology of the electronic trading client’s system with the key hops to timestamp</p>
<p>Now, starting in the next section, we can start looking at the code changes we need to add to these two forms of measurement.</p>
<h2 id="_idParaDest-292"><a id="_idTextAnchor305"/>Measuring the latencies inside the market data consumer</h2>
<p>We will start with the <code>MarketDataConsumer</code> component and, as we discussed<a id="_idIndexMarker1501"/> before, we will only show the changes to the code<a id="_idIndexMarker1502"/> here and omit repeating the full source code. The changes, as well as the full source code, are in the <code>Chapter11/trading/market_data/market_data_consumer.cpp</code> source file.</p>
<p>The first timestamp we take is as soon as we enter <code>MarketDataConsumer::recvCallback()</code>, where we use the <code>TTT_MEASURE</code> macro with the <code>T7_MarketDataConsumer_UDP_read</code> tag:</p>
<pre class="source-code">
  auto MarketDataConsumer::recvCallback(McastSocket
    *socket) noexcept -&gt; void {
    TTT_MEASURE(T7_MarketDataConsumer_UDP_read, logger_);</pre>
<p>We will also enclose the entire method using the <code>START_MEASURE</code> and <code>END_MEASURE</code> macros with the <code>Trading_MarketDataConsumer_recvCallback</code> tag to measure the latency of the entire method:</p>
<pre class="source-code">
    START_MEASURE(Trading_MarketDataConsumer_recvCallback);
    ...
    END_MEASURE(Trading_MarketDataConsumer_recvCallback,
      logger_);
  }</pre>
<p>We will add a timestamp<a id="_idIndexMarker1503"/> right after writing the decoded <a id="_idIndexMarker1504"/>market update to <code>incoming_md_updates_</code> <code>LFQueue</code>, using the <code>TTT_MEASURE</code> macro and the <code>T8_MarketDataConsumer_LFQueue_write</code> tag:</p>
<pre class="source-code">
          auto next_write = incoming_md_updates_-&gt;
            getNextToWriteTo();
          *next_write = std::move(request-&gt;
            me_market_update_);
          incoming_md_updates_-&gt;updateWriteIndex();
          TTT_MEASURE(T8_MarketDataConsumer_LFQueue_write,
            logger_);</pre>
<p>In the next section, we move on to adding performance measurement to the <code>OrderGateway</code> component.</p>
<h2 id="_idParaDest-293"><a id="_idTextAnchor306"/>Measuring the latencies inside the order gateway</h2>
<p>We will update the <code>OrderGateway</code> component in this<a id="_idIndexMarker1505"/> subsection; all the changes<a id="_idIndexMarker1506"/> and the updated full source code are available in the <code>Chapter11/trading/order_gw/order_gateway.cpp</code> source file.</p>
<p>The first method we will update is the <code>OrderGateway::run()</code> method, and the first timestamp we take is when we read a client request from <code>outgoing_requests_</code> <code>LFQueue</code>. We accomplish this by using the <code>TTT_MEASURE</code> macro and the <code>T11_OrderGateway_LFQueue_read</code> tag:</p>
<pre class="source-code">
  auto OrderGateway::run() noexcept -&gt; void {
      ...
      for(auto client_request = outgoing_requests_-&gt;
       getNextToRead(); client_request; client_request =
         outgoing_requests_-&gt;getNextToRead()) {
        TTT_MEASURE(T11_OrderGateway_LFQueue_read,
          logger_);</pre>
<p>The next thing we will measure is the time it takes to execute the <code>Common::TCPSocket::send()</code> method, which we accomplish, as shown next, using the <code>Trading_TCPSocket_send</code> tag:</p>
<pre class="source-code">
        START_MEASURE(Trading_TCPSocket_send);
        tcp_socket_.send(&amp;next_outgoing_seq_num_,
          sizeof(next_outgoing_seq_num_));
        tcp_socket_.send(client_request,
          sizeof(Exchange::MEClientRequest));
        END_MEASURE(Trading_TCPSocket_send, logger_);</pre>
<p>Finally, we also timestamp right after <code>TCPSocket::send()</code> finishes using the <code>TTT_MEASURE</code> macro and the <code>T12_OrderGateway_TCP_write</code> tag:</p>
<pre class="source-code">
        outgoing_requests_-&gt;updateReadIndex();
        TTT_MEASURE(T12_OrderGateway_TCP_write, logger_);</pre>
<p>The next method<a id="_idIndexMarker1507"/> we will update in the <code>OrderGateway</code> component<a id="_idIndexMarker1508"/> is the <code>recvCallback()</code> method. As soon as we enter the <code>recvCallback()</code> method, we take a timestamp using the <code>TTT_MEASURE</code> macro and the <code>T7t_OrderGateway_TCP_read</code> tag:</p>
<pre class="source-code">
  auto OrderGateway::recvCallback(TCPSocket *socket, Nanos
    rx_time) noexcept -&gt; void {
    TTT_MEASURE(T7t_OrderGateway_TCP_read, logger_);</pre>
<p>As with <code>MarketDataConsumer::recvCallback()</code>, we will enclose the entire <code>OrderGateway::recvCallback()</code> method using the <code>START_MEASURE</code> and <code>END_MEASURE</code> macros and the <code>Trading_OrderGateway_recvCallback</code> tag:</p>
<pre class="source-code">
    START_MEASURE(Trading_OrderGateway_recvCallback);
    ...
    END_MEASURE(Trading_OrderGateway_recvCallback,
      logger_);
  }</pre>
<p>We also take a timestamp right after writing the client response to <code>incoming_responses_</code> <code>LFQueue</code> using the <code>TTT_MEASURE</code> macro and the <code>T8t_OrderGateway_LFQueue_write</code> tag:</p>
<pre class="source-code">
        auto next_write = incoming_responses_-&gt;
          getNextToWriteTo();
        *next_write = std::move(response-&gt;
          me_client_response_);
        incoming_responses_-&gt;updateWriteIndex();
        TTT_MEASURE(T8t_OrderGateway_LFQueue_write,
          logger_);</pre>
<p>In the next and final subsection of this section, we will add the instrumentation code to the trade engine and all the subcomponents in the trade engine.</p>
<h2 id="_idParaDest-294"><a id="_idTextAnchor307"/>Measuring the latencies inside the trading engine</h2>
<p>First, we will start by updating the <code>TradeEngine</code> class itself, and the changes<a id="_idIndexMarker1509"/> and the full updated source code for this can be found in the <code>Chapter11/trading/strategy/trade_engine.cpp</code> source file.</p>
<p>The <code>TradeEngine::sendClientRequest()</code> method is first on our list, and here, we take a timestamp after writing the client request to <code>outgoing_ogw_requests_</code> <code>LFQueue</code> with the <code>T10_TradeEngine_LFQueue_write</code> tag:</p>
<pre class="source-code">
  auto TradeEngine::sendClientRequest(const
    Exchange::MEClientRequest *client_request) noexcept -&gt; void {
    auto next_write = outgoing_ogw_requests_-&gt;
     getNextToWriteTo();
    *next_write = std::move(*client_request);
    outgoing_ogw_requests_-&gt;updateWriteIndex();
    TTT_MEASURE(T10_TradeEngine_LFQueue_write, logger_);</pre>
<p>The next method on our list is the <code>TradeEngine::run()</code> method, where the first task is to take a timestamp right after reading a client response from <code>incoming_ogw_responses_</code> <code>LFQueue</code>, with the <code>TTT_MEASURE</code> macro and the <code>T9t_TradeEngine_LFQueue_read</code> tag:</p>
<pre class="source-code">
  auto TradeEngine::run() noexcept -&gt; void {
    while (run_) {
      for (auto client_response = incoming_ogw_responses_-&gt;
        getNextToRead(); client_response; client_response =
          incoming_ogw_responses_-&gt;getNextToRead()) {
        TTT_MEASURE(T9t_TradeEngine_LFQueue_read, logger_);</pre>
<p>We will also take a timestamp measurement right after reading a market update from <code>incoming_md_updates_</code> <code>LFQueue</code> with the <code>T9_TradeEngine_LFQueue_read</code> tag:</p>
<pre class="source-code">
      for (auto market_update = incoming_md_updates_-&gt;
        getNextToRead(); market_update; market_update =
          incoming_md_updates_-&gt;getNextToRead()) {
        TTT_MEASURE(T9_TradeEngine_LFQueue_read, logger_);</pre>
<p>The next method<a id="_idIndexMarker1510"/> we need to update is the <code>TradeEngine::onOrderBookUpdate()</code> method, where the first thing we will do is measure the call to <code>PositionKeeper::updateBBO()</code>, using the <code>START_MEASURE</code> and <code>END_MEASURE</code> macros and the <code>Trading_PositionKeeper_updateBBO</code> tag:</p>
<pre class="source-code">
  auto TradeEngine::onOrderBookUpdate(TickerId ticker_id,
    Price price, Side side, MarketOrderBook *book) noexcept
    -&gt; void {
    ...
    START_MEASURE(Trading_PositionKeeper_updateBBO);
    position_keeper_.updateBBO(ticker_id, bbo);
    END_MEASURE(Trading_PositionKeeper_updateBBO, logger_);</pre>
<p>We also need to measure the call to the <code>FeatureEngine::onOrderBookUpdate()</code> method, for which we use the <code>Trading_FeatureEngine_onOrderBookUpdate</code> tag:</p>
<pre class="source-code">
    START_MEASURE(Trading_FeatureEngine_onOrderBookUpdate);
    feature_engine_.onOrderBookUpdate(ticker_id, price,
      side, book);
    END_MEASURE(Trading_FeatureEngine_onOrderBookUpdate,
      logger_);</pre>
<p>We also need to measure the call to <code>TradeEngine::algoOnOrderBookUpdate_</code> <code>std::function</code>, which calls <code>onOrderBookUpdate()</code> in either the <code>MarketMaker</code> or <code>LiquidityTaker</code> algorithm instance. We use the <code>START_MEASURE</code> and <code>END_MEASURE</code> macros and use the <code>Trading_TradeEngine_algoOnOrderBookUpdate_</code> tag:</p>
<pre class="source-code">
 START_MEASURE(Trading_TradeEngine_algoOnOrderBookUpdate_);
    algoOnOrderBookUpdate_(ticker_id, price, side, book);
    END_MEASURE(Trading_TradeEngine_algoOnOrderBookUpdate_,
      logger_);</pre>
<p>The next method is the <code>TradeEngine::onTradeUpdate()</code> method. Here, the first call we measure<a id="_idIndexMarker1511"/> is the call to <code>FeatureEngine::onTradeUpdate()</code>, to which we assign the <code>Trading_FeatureEngine_onTradeUpdate</code> tag:</p>
<pre class="source-code">
  auto TradeEngine::onTradeUpdate(const
    Exchange::MEMarketUpdate *market_update,
      MarketOrderBook *book) noexcept -&gt; void {
    ...
    START_MEASURE(Trading_FeatureEngine_onTradeUpdate);
    feature_engine_.onTradeUpdate(market_update, book);
    END_MEASURE(Trading_FeatureEngine_onTradeUpdate,
      logger_);</pre>
<p>The other call we will measure<a id="_idIndexMarker1512"/> is the call using the <code>TradeEngine::algoOnTradeUpdate_</code> standard function, which will forward it to the <code>MarketMaker</code> or <code>LiquidityTaker</code> instance. We use the <code>START_MEASURE</code> and <code>END_MEASURE</code> macros using the tag of <code>Trading_TradeEngine_algoOnTradeUpdate_</code>:</p>
<pre class="source-code">
    START_MEASURE(Trading_TradeEngine_algoOnTradeUpdate_);
    algoOnTradeUpdate_(market_update, book);
    END_MEASURE(Trading_TradeEngine_algoOnTradeUpdate_,
      logger_);</pre>
<p>The final method we have left to add instrumentation to is <code>TradeEngine::onOrderUpdate()</code>. Here, the first function call that we measure will be the call to <code>PositionKeeper::addFill()</code> using the <code>Trading_PositionKeeper_addFill</code> tag:</p>
<pre class="source-code">
  auto TradeEngine::onOrderUpdate(const
    Exchange::MEClientResponse *client_response) noexcept -
     &gt; void {
    if (UNLIKELY(client_response-&gt;type_ ==
      Exchange::ClientResponseType::FILLED)) {
      START_MEASURE(Trading_PositionKeeper_addFill);
      position_keeper_.addFill(client_response);
      END_MEASURE(Trading_PositionKeeper_addFill, logger_);
    }</pre>
<p>Finally, we add the <code>START_MEASURE</code> and <code>END_MEASURE</code> macros with the <code>Trading_TradeEngine_algoOnOrderUpdate_  </code>tag around the invocation of the <code>algoOnOrderUpdate_</code> <code>std::function</code> object:</p>
<pre class="source-code">
    START_MEASURE(Trading_TradeEngine_algoOnOrderUpdate_);
    algoOnOrderUpdate_(client_response);
    END_MEASURE(Trading_TradeEngine_algoOnOrderUpdate_,
      logger_);</pre>
<p>We will add some internal<a id="_idIndexMarker1513"/> measurement code to each of the subcomponents that work with each other inside <code>TradeEngine</code>, starting with the <code>OrderManager</code> component next.</p>
<h3>Measuring the latencies inside OrderManager</h3>
<p>The changes to add performance<a id="_idIndexMarker1514"/> measurement in <code>OrderManager</code> are the focus<a id="_idIndexMarker1515"/> of this subsection, and all the code can be found in the <code>Chapter11/trading/strategy/order_manager.h</code> source file.</p>
<p>First, we will add measurements to the <code>OrderManager::moveOrder()</code> method. The first thing we will measure is the call to the <code>OrderManager::cancelOrder()</code> method using the <code>Trading_OrderManager_cancelOrder</code> tag:</p>
<pre class="source-code">
    auto moveOrder(OMOrder *order, TickerId ticker_id,
      Price price, Side side, Qty qty) noexcept {
      switch (order-&gt;order_state_) {
        case OMOrderState::LIVE: {
          if(order-&gt;price_ != price) {
           START_MEASURE(Trading_OrderManager_cancelOrder);
            cancelOrder(order);
            END_MEASURE(Trading_OrderManager_cancelOrder,
              (*logger_));</pre>
<p>We will also measure<a id="_idIndexMarker1516"/> the call to the <code>RiskManager</code> component, specifically<a id="_idIndexMarker1517"/> the <code>checkPreTradeRisk()</code> call. We will use the <code>START_MEASURE</code> and <code>END_MEASURE</code> macros with the <code>Trading_RiskManager_checkPreTradeRisk</code> tag around the risk check, as shown next:</p>
<pre class="source-code">
        case OMOrderState::DEAD: {
          if(LIKELY(price != Price_INVALID)) {
            START_MEASURE(Trading_RiskManager_checkPreTrade
Risk);
            const auto risk_result =
              risk_manager_.checkPreTradeRisk(ticker_id,
                side, qty);
            END_MEASURE(Trading_RiskManager_checkPreTradeRi
sk,
  (*logger_));</pre>
<p>Another thing to measure is the call to <code>OrderManager::newOrder()</code> if the risk check succeeds, and we will assign the measurement the <code>Trading_OrderManager_newOrder</code> tag, as shown here:</p>
<pre class="source-code">
            if(LIKELY(risk_result ==
              RiskCheckResult::ALLOWED)) {
              START_MEASURE(Trading_OrderManager_newOrder);
              newOrder(order, ticker_id, price, side, qty);
              END_MEASURE(Trading_OrderManager_newOrder,
                (*logger_));</pre>
<p>The other method in <code>OrderManager</code> to which we will add<a id="_idIndexMarker1518"/> measurements is the <code>moveOrders()</code> method, and there we<a id="_idIndexMarker1519"/> will enclose the calls to <code>OrderManager::moveOrder()</code> with <code>START_MEASURE</code> and <code>END_MEASURE</code> and the <code>Trading_OrderManager_moveOrder</code> tag:</p>
<pre class="source-code">
    auto moveOrders(TickerId ticker_id, Price bid_price,
      Price ask_price, Qty clip) noexcept {
        ...
        START_MEASURE(Trading_OrderManager_moveOrder);
        moveOrder(bid_order, ticker_id, bid_price,
          Side::BUY, clip);
        END_MEASURE(Trading_OrderManager_moveOrder,
          (*logger_));
        ...
        START_MEASURE(Trading_OrderManager_moveOrder);
        moveOrder(ask_order, ticker_id, ask_price,
          Side::SELL, clip);
        END_MEASURE(Trading_OrderManager_moveOrder,
          (*logger_));</pre>
<p>The next subcomponent in the <code>TradeEngine</code> class that we need to update is <code>MarketOrderBook</code>.</p>
<h3>Measuring the latencies inside MarketOrderBook</h3>
<p>The changes and full<a id="_idIndexMarker1520"/> source for <code>MarketOrderBook</code> can be found<a id="_idIndexMarker1521"/> in the <code>Chapter11/trading/strategy/market_order_book.cpp</code> source file.</p>
<p>First, in the <code>MarketOrderBook::onMarketUpdate()</code> method and the case for the <code>MarketUpdateType::ADD</code> message, we will measure the call to <code>MarketOrderBook::addOrder()</code>. This is achieved as usual by using the <code>START_MEASURE</code> and <code>END_MEASURE</code> macros with the <code>Trading_MarketOrderBook_addOrder</code> tag:</p>
<pre class="source-code">
  auto MarketOrderBook::onMarketUpdate(const
    Exchange::MEMarketUpdate *market_update) noexcept -&gt;
void {
    ...
    switch (market_update-&gt;type_) {
      case Exchange::MarketUpdateType::ADD: {
        auto order = order_pool_.allocate(market_update-&gt;
          order_id_, market_update-&gt;side_, market_update-&gt;
            price_,
                                          market_update-&gt;
                                            qty_,
                                     market_update-
                                       &gt;priority_, nullptr,
                                         nullptr);
        START_MEASURE(Trading_MarketOrderBook_addOrder);
        addOrder(order);
        END_MEASURE(Trading_MarketOrderBook_addOrder,
          (*logger_));</pre>
<p>To measure the call to <code>MarketOrderBook::removeOrder()</code> in the <code>MarketUpdateType::CANCEL</code> case, we will use the <code>Trading_MarketOrderBook_removeOrder</code> tag in the <code>START _MEASURE</code> and <code>END_MEASURE</code> macros:</p>
<pre class="source-code">
      case Exchange::MarketUpdateType::CANCEL: {
        auto order = oid_to_order_.at(market_update-
          &gt;order_id_);
        START_MEASURE(Trading_MarketOrderBook_removeOrder);
        removeOrder(order);
        END_MEASURE(Trading_MarketOrderBook_removeOrder,
          (*logger_));</pre>
<p>Finally, we will add a measurement <a id="_idIndexMarker1522"/>around the call<a id="_idIndexMarker1523"/> to <code>MarketOrderBook::updateBBO()</code> and assign it the <code>Trading_MarketOrderBook_updateBBO</code> tag:</p>
<pre class="source-code">
    START_MEASURE(Trading_MarketOrderBook_updateBBO);
    updateBBO(bid_updated, ask_updated);
    END_MEASURE(Trading_MarketOrderBook_updateBBO,
      (*logger_));</pre>
<p>The next component to measure is one of the trading algorithms – the <code>LiquidityTaker</code> algorithm.</p>
<h3>Measuring the latencies inside the LiquidityTaker algorithm</h3>
<p>The changes we discuss<a id="_idIndexMarker1524"/> here, as well as the full <a id="_idIndexMarker1525"/>source code, are in the <code>Chapter11/trading/strategy/liquidity_taker.h</code> source file.</p>
<p>Our first measurement is in the <code>onTradeUpdate()</code> method for the <code>LiquidityTaker</code> class. When the signal initiates a trade, we measure the call to <code>OrderManager::moveOrders()</code> and assign it the <code>OrderManager_moveOrders</code> tag, as shown here:</p>
<pre class="source-code">
    auto onTradeUpdate(const Exchange::MEMarketUpdate
      *market_update, MarketOrderBook *book) noexcept -&gt;
void {
        ...
        if (agg_qty_ratio &gt;= threshold) {
          START_MEASURE(OrderManager_moveOrders);
          if (market_update-&gt;side_ == Side::BUY)
            order_manager_-&gt;moveOrders(market_update-&gt;
              ticker_id_, bbo-&gt;ask_price_, Price_INVALID,
                clip);
          else
            order_manager_-&gt;moveOrders(market_update-&gt;
              ticker_id_, Price_INVALID, bbo-&gt;bid_price_,
                clip);
          END_MEASURE(OrderManager_moveOrders, (*logger_));
        }</pre>
<p>The other call we want<a id="_idIndexMarker1526"/> to measure is in the <code>onOrderUpdate()</code> method and measures<a id="_idIndexMarker1527"/> the call to <code>OrderManager::onOrderUpdate()</code> using the <code>START_MEASURE</code> and <code>END_MEASURE</code> macros and the <code>Trading_OrderManager_onOrderUpdate</code> tag:</p>
<pre class="source-code">
    auto onOrderUpdate(const Exchange::MEClientResponse
      *client_response) noexcept -&gt; void {
      START_MEASURE(Trading_OrderManager_onOrderUpdate);
      order_manager_-&gt;onOrderUpdate(client_response);
      END_MEASURE(Trading_OrderManager_onOrderUpdate,
        (*logger_));</pre>
<p>Finally, we are down to our last component for this chapter, updating the <code>MarketMaker</code> algorithm.</p>
<h3>Measuring the latencies inside the MarketMaker algorithm</h3>
<p>The changes<a id="_idIndexMarker1528"/> and the full source<a id="_idIndexMarker1529"/> code for <code>MarketMaker</code> are in the <code>Chapter11/trading/strategy/market_maker.h</code> source file.</p>
<p>The <code>MarketMaker::onOrderBookUpdate()</code> method contains the call to <code>OrderManager::moveOrders()</code>, which is what we measure in the next code block with the <code>Trading_OrderManager_moveOrders</code> tag:</p>
<pre class="source-code">
    auto onOrderBookUpdate(TickerId ticker_id, Price price,
      Side side, const MarketOrderBook *book) noexcept -&gt;
void {
        ...
        START_MEASURE(Trading_OrderManager_moveOrders);
        order_manager_-&gt;moveOrders(ticker_id, bid_price,
          ask_price, clip);
        END_MEASURE(Trading_OrderManager_moveOrders,
          (*logger_));</pre>
<p>The other method, <code>MarketMaker::onOrderUpdate()</code>, contains the call to <code>OrderManager::onOrderUpdate()</code>, which we also measure and to which we will assign the <code>Trading_OrderManager_onOrderUpdate</code> tag:</p>
<pre class="source-code">
    auto onOrderUpdate(const Exchange::MEClientResponse
      *client_response) noexcept -&gt; void {
      ...
      START_MEASURE(Trading_OrderManager_onOrderUpdate);
      order_manager_-&gt;onOrderUpdate(client_response);
      END_MEASURE(Trading_OrderManager_onOrderUpdate,
        (*logger_));</pre>
<p>This concludes all the performance<a id="_idIndexMarker1530"/> measurement and timestamping-related<a id="_idIndexMarker1531"/> changes across our entire electronic trading ecosystem. We will very quickly look at how to run the ecosystem with all the changes we made so far and what differences we find in the log files.</p>
<h1 id="_idParaDest-295"><a id="_idTextAnchor308"/>Running the entire ecosystem with the new instrumentation system</h1>
<p>Running the updated electronic trading ecosystem remains<a id="_idIndexMarker1532"/> the same as before <a id="_idIndexMarker1533"/>and is launched by running the following script:</p>
<pre class="source-code">
sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter11$ bash scripts/run_exchange_and_clients.sh</pre>
<p>Once the new ecosystem is done running, you can notice performance measurement log entries such as the following for the RDTSC measurements:</p>
<pre class="source-code">
sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter11$ grep Exchange_MEOrderBook_match *.log
exchange_matching_engine.log:02:42:59.980424597 RDTSC Exchange_MEOrderBook_match 205247
exchange_matching_engine.log:02:43:00.022326352 RDTSC Exchange_MEOrderBook_match 216239</pre>
<p>There are also entries such as the following for the RDTSC measurements:</p>
<pre class="source-code">
sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter11$ grep Trading_MarketOrderBook_addOrder *.log
trading_engine_1.log:02:44:18.894251975 RDTSC Trading_MarketOrderBook_addOrder 204
trading_engine_1.log:02:44:18.904221378 RDTSC Trading_MarketOrderBook_addOrder 971</pre>
<p>There are entries such as the following for the TTT measurements:</p>
<pre class="source-code">
sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter11$ grep T6_MarketDataPublisher_UDP_write *.log
exchange_market_data_publisher.log:02:40:13.596201293 TTT T6_MarketDataPublisher_UDP_write 1685864413596201240
exchange_market_data_publisher.log:02:40:13.624236967 TTT T6_MarketDataPublisher_UDP_write 1685864413624236907</pre>
<p>And there are also entries<a id="_idIndexMarker1534"/> such as the following <a id="_idIndexMarker1535"/>for the TTT measurements:</p>
<pre class="source-code">
sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter11$ grep T8t_OrderGateway_LFQueue_write *.log
trading_order_gateway_1.log:02:40:14.524401434 TTT T8t_OrderGateway_LFQueue_write 1685864414524401386
trading_order_gateway_1.log:02:40:14.524425862 TTT T8t_OrderGateway_LFQueue_write 1685864414524425811</pre>
<p>We will revisit this performance data in the next chapter, but we have now finished this chapter.</p>
<h1 id="_idParaDest-296"><a id="_idTextAnchor309"/>Summary</h1>
<p>This chapter was dedicated completely to measuring the performance of our electronic trading ecosystem. First, we built a system to measure and compare the latency incurred due to the execution of any arbitrary code block. We also built a system to generate nanosecond-level timestamps when notable events occur. We also discussed the motivation behind the design of these systems as well as various important points to keep in mind when using these performance measurement techniques.</p>
<p>The next section was dedicated to understanding the design and motivation of performance measurements within the various components and subcomponents on the electronic exchange’s end. We then built and updated all the source code in the exchange to add the performance measurement and timestamping code.</p>
<p>After we finished the discussion and implementation of performance measurement within the electronic exchange, we performed similar measurements in the trading system. Finally, we concluded the chapter by running this updated ecosystem and observing the new log entries from the performance measurement system.</p>
<p>In the next and concluding chapter, we will analyze this performance data in detail, discuss our findings, and discuss how to optimize the performance.</p>
</div>
</body></html>