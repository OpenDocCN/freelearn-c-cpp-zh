<html><head></head><body>
<div id="_idContainer072">
<h1 class="chapter-number" id="_idParaDest-280"><a id="_idTextAnchor293"/><span class="koboSpan" id="kobo.1.1">11</span></h1>
<h1 id="_idParaDest-281"><a id="_idTextAnchor294"/><span class="koboSpan" id="kobo.2.1">Adding Instrumentation and Measuring Performance</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we will add a system to measure the performance of the C++ components we have built so far in this book. </span><span class="koboSpan" id="kobo.3.2">We will measure the latencies in the trading exchange system we built in </span><em class="italic"><span class="koboSpan" id="kobo.4.1">Part 2</span></em><span class="koboSpan" id="kobo.5.1"> and the latencies in the client’s trading system built in the previous section. </span><span class="koboSpan" id="kobo.5.2">Finally, we will measure and analyze the performance of the end-to-end system by running the different algorithms we built in the previous section. </span><span class="koboSpan" id="kobo.5.3">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Adding an instrumentation system to measure </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">system performance</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Measuring latencies in </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">the exchange</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Measuring latencies in the </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">trading engine</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Running the entire ecosystem with the new </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">instrumentation system</span></span></li>
</ul>
<h1 id="_idParaDest-282"><a id="_idTextAnchor295"/><span class="koboSpan" id="kobo.15.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.16.1">All the code for this book can be found in the book’s GitHub repository at </span><a href="https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP"><span class="koboSpan" id="kobo.17.1">https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP</span></a><span class="koboSpan" id="kobo.18.1">. </span><span class="koboSpan" id="kobo.18.2">The source for this chapter is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.19.1">Chapter11</span></strong><span class="koboSpan" id="kobo.20.1"> directory in </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">the repository.</span></span></p>
<p><span class="koboSpan" id="kobo.22.1">This chapter relies on a lot of the previous chapters since we will be measuring the performance of all the different components and subcomponents in the electronic trading ecosystem. </span><span class="koboSpan" id="kobo.22.2">So, we expect you to be familiar with the code base we have built so far, specifically, the </span><em class="italic"><span class="koboSpan" id="kobo.23.1">Building the C++ Matching Engine</span></em><span class="koboSpan" id="kobo.24.1">, </span><em class="italic"><span class="koboSpan" id="kobo.25.1">Communicating with Market Participants</span></em><span class="koboSpan" id="kobo.26.1">, </span><em class="italic"><span class="koboSpan" id="kobo.27.1">Processing Market Data and Sending Orders to the Exchange in C++</span></em><span class="koboSpan" id="kobo.28.1">, </span><em class="italic"><span class="koboSpan" id="kobo.29.1">Building the C++ Trading Algorithm Building Blocks</span></em><span class="koboSpan" id="kobo.30.1">, and finally, </span><em class="italic"><span class="koboSpan" id="kobo.31.1">Building the C++ Market Making and Liquidity Taking </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.32.1">Algorithms</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.33.1"> chapters.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">The specifications of the environment in which the source code for this book was developed are shown next. </span><span class="koboSpan" id="kobo.34.2">We present the details of this environment since all the C++ code presented in this book is not necessarily portable and might require some minor changes to work in </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">your environment:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.36.1">OS – </span><strong class="source-inline"><span class="koboSpan" id="kobo.37.1">Linux 5.19.0-41-generic #42~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Apr 18 17:40:00 UTC 2 x86_64 x86_64 </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">x86_64 GNU/Linux</span></strong></span></li>
<li><span class="koboSpan" id="kobo.39.1">GCC – </span><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">g++ (Ubuntu </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">11.3.0-1ubuntu1~22.04.1) 11.3.0</span></strong></span></li>
<li><span class="koboSpan" id="kobo.42.1">CMake – </span><strong class="source-inline"><span class="koboSpan" id="kobo.43.1">cmake </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">version 3.23.2</span></strong></span></li>
<li><span class="koboSpan" id="kobo.45.1">Ninja – </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">1.10.2</span></strong></span></li>
</ul>
<h1 id="_idParaDest-283"><a id="_idTextAnchor296"/><span class="koboSpan" id="kobo.47.1">Adding an instrumentation system to measure system performance</span></h1>
<p><span class="koboSpan" id="kobo.48.1">The first task we need to tackle</span><a id="_idIndexMarker1442"/><span class="koboSpan" id="kobo.49.1"> is to add a few utility methods</span><a id="_idIndexMarker1443"/><span class="koboSpan" id="kobo.50.1"> that will serve as the base of our performance measurement system. </span><span class="koboSpan" id="kobo.50.2">These are meant to be used to measure the latencies of internal components and subcomponents for processes running on the same server. </span><span class="koboSpan" id="kobo.50.3">These are also meant to be used to measure latencies between the different components, which are unlikely to be on the same server in practice, such as the trading exchange and the trading clients, which are on different servers. </span><span class="koboSpan" id="kobo.50.4">Note, however, that in this book, we run the trading exchange and the trading clients on the same server for simplicity. </span><span class="koboSpan" id="kobo.50.5">Now, let us start by adding these utilities in the </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">next section.</span></span></p>
<h2 id="_idParaDest-284"><a id="_idTextAnchor297"/><span class="koboSpan" id="kobo.52.1">Adding utilities for performance measurement using RDTSC</span></h2>
<p><span class="koboSpan" id="kobo.53.1">The first performance measurement utility we </span><a id="_idIndexMarker1444"/><span class="koboSpan" id="kobo.54.1">add does not directly</span><a id="_idIndexMarker1445"/><span class="koboSpan" id="kobo.55.1"> measure the time itself but, instead, measures how many CPU clock cycles elapse between two spots in our code base. </span><span class="koboSpan" id="kobo.55.2">This is achieved</span><a id="_idIndexMarker1446"/><span class="koboSpan" id="kobo.56.1"> by reading the value of the </span><strong class="bold"><span class="koboSpan" id="kobo.57.1">Time Stamp Counter</span></strong><span class="koboSpan" id="kobo.58.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.59.1">TSC</span></strong><span class="koboSpan" id="kobo.60.1">), a 64-bit register containing the number of CPU cycles. </span><span class="koboSpan" id="kobo.60.2">We will execute an assembly instruction, </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">rdtsc</span></strong><span class="koboSpan" id="kobo.62.1">, to fetch and return this value, which returns this in the form of two 32-bit values that we will convert into a single 64-bit value. </span><span class="koboSpan" id="kobo.62.2">We can use these </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">rdtsc</span></strong><span class="koboSpan" id="kobo.64.1"> values as is to measure/compare performance if we do not really care about converting them into time units. </span><span class="koboSpan" id="kobo.64.2">The other option is to convert this </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">rdtsc</span></strong><span class="koboSpan" id="kobo.66.1"> value into time units, which is achieved </span><a id="_idIndexMarker1447"/><span class="koboSpan" id="kobo.67.1">by dividing this value</span><a id="_idIndexMarker1448"/><span class="koboSpan" id="kobo.68.1"> by the system’s clock frequency, which is specified as the number of CPU clock cycles per second. </span><span class="koboSpan" id="kobo.68.2">For instance, on my system, the CPU clock frequency comes out to be around 2.6 GHz, as </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.70.1">
sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter11$ cat /proc/cpuinfo | grep MHz
cpu MHz         : 2645.048
cpu MHz         : 2645.035
cpu MHz         : 2645.033
cpu MHz         : 2645.050</span></pre>
<p><span class="koboSpan" id="kobo.71.1">What this means is that if we measure the </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">rdtsc</span></strong><span class="koboSpan" id="kobo.73.1"> value before and after the execution of a code block and the difference between the two values is 26 clock cycles, on my system, that translates to approximately 26 / 2.6 = a 10-nanosecond execution time. </span><span class="koboSpan" id="kobo.73.2">We will talk about this more in the last subsection of this section, </span><em class="italic"><span class="koboSpan" id="kobo.74.1">Understanding some issues with measurement systems in practice</span></em><span class="koboSpan" id="kobo.75.1">. </span><span class="koboSpan" id="kobo.75.2">So, without any more delay, let us look at the code for this measurement implementation. </span><span class="koboSpan" id="kobo.75.3">All the code for this section can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">Chapter11/common/perf_utils.h</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.77.1">source file.</span></span></p>
<p><span class="koboSpan" id="kobo.78.1">First, we implement an </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">rdtsc()</span></strong><span class="koboSpan" id="kobo.80.1"> C++ method, which internally calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">rdtsc</span></strong><span class="koboSpan" id="kobo.82.1"> assembly instruction and provides it with two variables, </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">lo</span></strong><span class="koboSpan" id="kobo.84.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">hi</span></strong><span class="koboSpan" id="kobo.86.1">, to read the lower and higher 32-bits that make up the final </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">rdtsc</span></strong><span class="koboSpan" id="kobo.88.1"> value. </span><span class="koboSpan" id="kobo.88.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">__asm__</span></strong><span class="koboSpan" id="kobo.90.1"> instruction tells the compiler that what follows it is an assembly instruction. </span><span class="koboSpan" id="kobo.90.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">__volatile__</span></strong><span class="koboSpan" id="kobo.92.1"> instruction exists to prevent the compiler from optimizing the instructions so that it is executed as is to make sure we read the TSC register every time this is called. </span><span class="koboSpan" id="kobo.92.2">We save the output into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">lo</span></strong><span class="koboSpan" id="kobo.94.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">hi</span></strong><span class="koboSpan" id="kobo.96.1"> variables and, finally, using a bit shift operation, create a 64-bit value from them and </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">return it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.98.1">
#pragma once
namespace Common {
  inline auto rdtsc() noexcept {
    unsigned int lo, hi;
    __asm__ __volatile__ ("rdtsc" : "=a" (lo), "=d" (hi));
    return ((uint64_t) hi &lt;&lt; 32) | lo;
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.99.1">Next, we will define a simple preprocessor macro, </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">START_MEASURE</span></strong><span class="koboSpan" id="kobo.101.1">, which accepts an argument called </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">TAG</span></strong><span class="koboSpan" id="kobo.103.1">, and all it does</span><a id="_idIndexMarker1449"/><span class="koboSpan" id="kobo.104.1"> is create a variable with that name</span><a id="_idIndexMarker1450"/><span class="koboSpan" id="kobo.105.1"> and saves the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">rdtsc()</span></strong><span class="koboSpan" id="kobo.107.1"> method we just built in it. </span><span class="koboSpan" id="kobo.107.2">In other words, this macro simply creates a variable with the name provided and saves the </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">rdtsc()</span></strong><span class="koboSpan" id="kobo.109.1"> value </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">in it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.111.1">
#define START_MEASURE(TAG) const auto TAG = Common::rdtsc()</span></pre>
<p><span class="koboSpan" id="kobo.112.1">We define another complimentary macro called </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">END_MEASURE</span></strong><span class="koboSpan" id="kobo.114.1">, which accepts an argument called </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">TAG</span></strong><span class="koboSpan" id="kobo.116.1"> as well as an argument called </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">LOGGER</span></strong><span class="koboSpan" id="kobo.118.1">, which it expects to be of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">Common::Logger</span></strong><span class="koboSpan" id="kobo.120.1"> type. </span><span class="koboSpan" id="kobo.120.2">It takes another measurement using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">rdtsc()</span></strong><span class="koboSpan" id="kobo.122.1"> method we built previously and uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">LOGGER</span></strong><span class="koboSpan" id="kobo.124.1"> object to log the difference between the two. </span><span class="koboSpan" id="kobo.124.2">The only reason this code block is enclosed in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">do {} while(false)</span></strong><span class="koboSpan" id="kobo.126.1"> loop (without a terminating semi-colon) is to make sure that the compiler catches missing semi-colons when this method is invoked. </span><span class="koboSpan" id="kobo.126.2">In other words, </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">END_MEASURE(example, logger_);</span></strong><span class="koboSpan" id="kobo.128.1"> is a valid use but </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">END_MEASURE(example, logger_)</span></strong><span class="koboSpan" id="kobo.130.1"> (missing semi-colon) causes a compilation error to maintain symmetry with </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">START_MEASURE</span></strong><span class="koboSpan" id="kobo.132.1">. </span><span class="koboSpan" id="kobo.132.2">This is not strictly necessary, just a preference on </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">our part:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.134.1">
#define END_MEASURE(TAG, LOGGER) \
      do { \
        const auto end = Common::rdtsc(); \
        LOGGER.log("% RDTSC "#TAG" %\n",
          Common::getCurrentTimeStr(&amp;time_str_), (end -
            TAG)); \
      } while(false)</span></pre>
<p><span class="koboSpan" id="kobo.135.1">Finally, we will define a similar macro called </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">TTT_MEASURE</span></strong><span class="koboSpan" id="kobo.137.1"> that takes similar arguments (i.e., </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">TAG</span></strong><span class="koboSpan" id="kobo.139.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">LOGGER</span></strong><span class="koboSpan" id="kobo.141.1">), This macro simply logs the current time in nanoseconds, which it obtains by calling our </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">Common::getCurrentNanos()</span></strong><span class="koboSpan" id="kobo.143.1"> method that we </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">saw before:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.145.1">
#define TTT_MEASURE(TAG, LOGGER) \
      do { \
        const auto TAG = Common::getCurrentNanos(); \
        LOGGER.log("% TTT "#TAG" %\n", Common::
          getCurrentTimeStr(&amp;time_str_), TAG); \
      } while(false)</span></pre>
<p><span class="koboSpan" id="kobo.146.1">We will use these macros</span><a id="_idIndexMarker1451"/><span class="koboSpan" id="kobo.147.1"> throughout this chapter, but before</span><a id="_idIndexMarker1452"/><span class="koboSpan" id="kobo.148.1"> we do that, we need to make some minor changes to the time utilities we built before and have seen many uses </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">of already.</span></span></p>
<h2 id="_idParaDest-285"><a id="_idTextAnchor298"/><span class="koboSpan" id="kobo.150.1">Updating our previous time utilities</span></h2>
<p><span class="koboSpan" id="kobo.151.1">In this section, we will make a minor change</span><a id="_idIndexMarker1453"/><span class="koboSpan" id="kobo.152.1"> to the time utility </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">Common::getCurrentTimeStr()</span></strong><span class="koboSpan" id="kobo.154.1"> method to make the output more informative and granular. </span><span class="koboSpan" id="kobo.154.2">The goal here is to change our previous output, which looked </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.156.1">
onMarketUpdate() Sat Jun  3 09:46:34 2023 MEMarketUpdate</span></pre>
<p><span class="koboSpan" id="kobo.157.1">We want to change it to this format, which drops the date and year from the output and changes the time output from just having seconds to having seconds and nanoseconds to </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">add granularity:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.159.1">
onMarketUpdate() 09:46:34.645778416 MEMarketUpdate</span></pre>
<p><span class="koboSpan" id="kobo.160.1">This will help us inspect, order, and analyze events that happen in the same second even more closely. </span><span class="koboSpan" id="kobo.160.2">These changes can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">Chapter11/common/time_utils.h</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.162.1">source file.</span></span></p>
<p><span class="koboSpan" id="kobo.163.1">Note that the other change is the inclusion of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">perf_utils.h</span></strong><span class="koboSpan" id="kobo.165.1"> header file containing the measurement methods we built in the </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">previous section:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.167.1">
#include "perf_utils.h"</span></pre>
<p><span class="koboSpan" id="kobo.168.1">We saw this before in the </span><em class="italic"><span class="koboSpan" id="kobo.169.1">Building the C++ Building Blocks for Low-Latency Applications</span></em><span class="koboSpan" id="kobo.170.1"> chapter in the </span><em class="italic"><span class="koboSpan" id="kobo.171.1">Designing utility methods for time</span></em><span class="koboSpan" id="kobo.172.1"> section. </span><span class="koboSpan" id="kobo.172.2">We call </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">std::chrono::system_clock::now()</span></strong><span class="koboSpan" id="kobo.174.1"> to extract the current </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">time_point</span></strong><span class="koboSpan" id="kobo.176.1"> value and save it in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">clock</span></strong><span class="koboSpan" id="kobo.178.1"> variable. </span><span class="koboSpan" id="kobo.178.2">We also extract and save the </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">time_t</span></strong><span class="koboSpan" id="kobo.180.1"> object from it into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">time</span></strong><span class="koboSpan" id="kobo.182.1"> variable using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">std::chrono::system_clock::to_time_t()</span></strong><span class="koboSpan" id="kobo.184.1"> method, </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">as shown:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.186.1">
namespace Common {
  inline auto&amp; getCurrentTimeStr(std::string* time_str) {
    const auto clock = std::chrono::system_clock::now();
    const auto time = std::chrono::
      system_clock::to_time_t(clock);</span></pre>
<p><span class="koboSpan" id="kobo.187.1">We use a combination of </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">sprintf()</span></strong><span class="koboSpan" id="kobo.189.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">ctime()</span></strong><span class="koboSpan" id="kobo.191.1">, and the previously seen </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(clock.time_since_epoch()).count()</span></strong><span class="koboSpan" id="kobo.193.1"> method to extract and format the current time in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">HH:MM:SS.nnnnnnnnn</span></strong><span class="koboSpan" id="kobo.195.1"> format. </span><span class="koboSpan" id="kobo.195.2">Finally, we assign it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">time_str</span></strong><span class="koboSpan" id="kobo.197.1"> object of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">std::string</span></strong><span class="koboSpan" id="kobo.199.1"> type, which is passed</span><a id="_idIndexMarker1454"/><span class="koboSpan" id="kobo.200.1"> to this method, as well as </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">return it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.202.1">
    char nanos_str[24];
    sprintf(nanos_str, "%.8s.%09ld", ctime(&amp;time) + 11,
      std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;
       (clock.time_since_epoch()).count() % NANOS_TO_SECS);
    time_str-&gt;assign(nanos_str);
    return *time_str;
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.203.1">Before we move on to using these new methods, we will discuss a few more points regarding measuring performance </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">in practice.</span></span></p>
<h2 id="_idParaDest-286"><a id="_idTextAnchor299"/><span class="koboSpan" id="kobo.205.1">Understanding some issues with measurement systems in practice</span></h2>
<p><span class="koboSpan" id="kobo.206.1">In this section, we will discuss a few important considerations when it comes to measuring performance in practice. </span><span class="koboSpan" id="kobo.206.2">This is important to understand because performance measurement is not always as easy as it seems and it requires you to understand </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">some nuances.</span></span></p>
<h3><span class="koboSpan" id="kobo.208.1">Adding overhead due to instrumentation</span></h3>
<p><span class="koboSpan" id="kobo.209.1">The first key point </span><a id="_idIndexMarker1455"/><span class="koboSpan" id="kobo.210.1">we want to make about measuring performance in practice is that it is important to consider that the measurement system itself is not zero-latency. </span><span class="koboSpan" id="kobo.210.2">What this means is that adding instrumentation into the path of the critical code base adds some extra latency. </span><span class="koboSpan" id="kobo.210.3">It is important to make sure that the instrumentation system/routine itself is extremely low-latency relative to the latency of the system it’s measuring. </span><span class="koboSpan" id="kobo.210.4">A hypothetical example is that if we are measuring something that takes a few microseconds, we need to make sure that the measurement routines take a few nanoseconds to not add too much overhead. </span><span class="koboSpan" id="kobo.210.5">One of the reasons we have the option of using </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">rdtsc()</span></strong><span class="koboSpan" id="kobo.212.1"> to measure performance is that it is significantly faster than calling something such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">std::chrono::system_clock::now()</span></strong><span class="koboSpan" id="kobo.214.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">clock_gettime()</span></strong><span class="koboSpan" id="kobo.216.1">. </span><span class="koboSpan" id="kobo.216.2">That gives us the option of using </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">rdtsc()</span></strong><span class="koboSpan" id="kobo.218.1"> if we are measuring a code block that has extremely low latency to add </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">minimal overhead.</span></span></p>
<h3><span class="koboSpan" id="kobo.220.1">Understanding the limitations and reliability of RDTSC</span></h3>
<p><span class="koboSpan" id="kobo.221.1">The second key point is regarding </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">rdtsc()</span></strong><span class="koboSpan" id="kobo.223.1">, which is not always very portable and can have reliability concerns</span><a id="_idIndexMarker1456"/><span class="koboSpan" id="kobo.224.1"> depending on the platform. </span><span class="koboSpan" id="kobo.224.2">Another </span><a id="_idIndexMarker1457"/><span class="koboSpan" id="kobo.225.1">consideration with </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">rdtsc()</span></strong><span class="koboSpan" id="kobo.227.1"> when converting it into time units is that CPU clock frequency can vary from core to core on a system, and using a static CPU clock frequency for the conversion is not </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">always accurate.</span></span></p>
<h3><span class="koboSpan" id="kobo.229.1">Setting up the correct measurement environment</span></h3>
<p><span class="koboSpan" id="kobo.230.1">The third point regarding measuring</span><a id="_idIndexMarker1458"/><span class="koboSpan" id="kobo.231.1"> performance on trading servers is that a lot of tuning needs to be done to facilitate accurate measurements. </span><span class="koboSpan" id="kobo.231.2">This involves techniques such as disabling interrupts, making sure unnecessary processes are not running, making sure the NUMA setup is correct, tweaking CPU power settings, setting up CPU isolation, pinning threads to specific cores, and so on. </span><span class="koboSpan" id="kobo.231.3">Discussing all these considerations when it comes to electronic trading is beyond the scope of this book, nor is it the focus of this book. </span><span class="koboSpan" id="kobo.231.4">We just wanted</span><a id="_idIndexMarker1459"/><span class="koboSpan" id="kobo.232.1"> to mention that there are additional considerations when it comes to performance measurement. </span><span class="koboSpan" id="kobo.232.2">We refer </span><a id="_idIndexMarker1460"/><span class="koboSpan" id="kobo.233.1">interested readers to the book </span><em class="italic"><span class="koboSpan" id="kobo.234.1">Developing High-Frequency Trading Systems: Learn how to implement high-frequency trading from scratch with C++ or Java basics</span></em><span class="koboSpan" id="kobo.235.1">, which discusses </span><strong class="bold"><span class="koboSpan" id="kobo.236.1">High-Frequency electronic Trading</span></strong><span class="koboSpan" id="kobo.237.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.238.1">HFT</span></strong><span class="koboSpan" id="kobo.239.1">) </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">specific considerations.</span></span></p>
<p><span class="koboSpan" id="kobo.241.1">Now we can move on to using the performance measurement system we built in this section in our electronic trading ecosystem, starting with the exchange in the </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">next section.</span></span></p>
<h1 id="_idParaDest-287"><a id="_idTextAnchor300"/><span class="koboSpan" id="kobo.243.1">Measuring latencies at the exchange</span></h1>
<p><span class="koboSpan" id="kobo.244.1">First, we will add instrumentation</span><a id="_idIndexMarker1461"/><span class="koboSpan" id="kobo.245.1"> to the components on the electronic trading exchange side – the market data publisher, the matching engine, and the order server. </span><span class="koboSpan" id="kobo.245.2">Our approach to measuring performance will comprise two forms; let us understand those first before we look at </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">the code.</span></span></p>
<h3><span class="koboSpan" id="kobo.247.1">Understanding how to measure internally</span></h3>
<p><span class="koboSpan" id="kobo.248.1">The first approach is to measure</span><a id="_idIndexMarker1462"/><span class="koboSpan" id="kobo.249.1"> the latency of internal components – for example, how long does a call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">Exchange::MatchingEngine::processClientRequest()</span></strong><span class="koboSpan" id="kobo.251.1"> method take or how long does a call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">Exchange::MEOrderBook::add()</span></strong><span class="koboSpan" id="kobo.253.1"> method take? </span><span class="koboSpan" id="kobo.253.2">For these cases, we will use a pair of </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">START_MEASURE()</span></strong><span class="koboSpan" id="kobo.255.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">END_MEASURE()</span></strong><span class="koboSpan" id="kobo.257.1"> macros, which, in turn, use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">rdtsc()</span></strong><span class="koboSpan" id="kobo.259.1"> method to measure the performance of each such call. </span><span class="koboSpan" id="kobo.259.2">There is nothing here that prevents us from using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">TTT_MEASURE()</span></strong><span class="koboSpan" id="kobo.261.1"> macro in place of </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">rdtsc()</span></strong><span class="koboSpan" id="kobo.263.1"> or as a supplement. </span><span class="koboSpan" id="kobo.263.2">But we will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">rdtsc()</span></strong><span class="koboSpan" id="kobo.265.1"> for these, for the sake of providing examples of how to use the two different instrumentation systems. </span><span class="koboSpan" id="kobo.265.2">Additionally, we use the rationale that a call to a function such as the one we mentioned previously should be very quick and it might be better to use the lower overhead </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">rdtsc()</span></strong><span class="koboSpan" id="kobo.267.1"> methods for that. </span><span class="koboSpan" id="kobo.267.2">The complete list of internal measurements we will take is listed next, but interested readers should use similar techniques to add even more points of measurement as they see fit. </span><span class="koboSpan" id="kobo.267.3">We will see the code for how to measure these familiar methods shortly, but for now, the methods</span><a id="_idIndexMarker1463"/><span class="koboSpan" id="kobo.268.1"> we will measure on the exchange side are </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">the following:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">Common::McastSocket::send()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">Exchange::MEOrderBook::add()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">Exchange::MEOrderBook::cancel()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">Exchange::MatchingEngine::processClientRequest()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">Exchange::MEOrderBook::removeOrder()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">Exchange::MEOrderBook::match()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">Exchange::MEOrderBook::match()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">Exchange::MEOrderBook::checkForMatch()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">Exchange::MEOrderBook::addOrder()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">Exchange::MEOrderBook::removeOrder()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">Common::TCPSocket::send()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">Exchange::FIFOSequencer::addClientRequest()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">Exchange::FIFOSequencer::sequenceAndPublish()</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.283.1">Next, let us take a few steps back and understand which high-level spots/hops we will timestamp in the electronic </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">trading exchange.</span></span></p>
<h3><span class="koboSpan" id="kobo.285.1">Understanding key hops at the exchange</span></h3>
<p><span class="koboSpan" id="kobo.286.1">In addition to measuring the functioning</span><a id="_idIndexMarker1464"/><span class="koboSpan" id="kobo.287.1"> of internal components, exchanges can record performance data, especially timestamps, to track how events (client requests) propagate through the different components and subcomponents. </span><span class="koboSpan" id="kobo.287.2">We mean tracking and, often, publishing metrics such as when an order reached the order server, when it reached the matching engine, when the response to that request left the order server, when market updates corresponding to that request left the market data publisher, and so on. </span><span class="koboSpan" id="kobo.287.3">By recording these metrics, exchanges can understand and investigate their performance under different market/load conditions, track per-participant performance, and so on. </span><span class="koboSpan" id="kobo.287.4">By publishing these metrics to the market participants, the participants can understand and investigate their own performance and consider ways to </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">improve them.</span></span></p>
<p><span class="koboSpan" id="kobo.289.1">In our electronic trading exchange, we will take timestamps of the </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">following events:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">T1_OrderServer_TCP_read</span></strong><span class="koboSpan" id="kobo.292.1"> – the time when a client request is first read at the TCP socket </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">OrderServer</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">T2_OrderServer_LFQueue_write</span></strong><span class="koboSpan" id="kobo.296.1"> – the time when a client request is written to </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">LFQueue</span></strong><span class="koboSpan" id="kobo.298.1"> that connects </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">MatchingEngine</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">T3_MatchingEngine_LFQueue_read</span></strong><span class="koboSpan" id="kobo.302.1"> – the time when </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">MatchingEngine</span></strong><span class="koboSpan" id="kobo.304.1"> reads a client request </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">LFQueue</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">T4_MatchingEngine_LFQueue_write</span></strong><span class="koboSpan" id="kobo.308.1"> – the time when the market update is written to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">LFQueue</span></strong><span class="koboSpan" id="kobo.310.1"> connected </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">MarketDataPublisher</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">T4t_MatchingEngine_LFQueue_write</span></strong><span class="koboSpan" id="kobo.314.1"> – the time when the client response is written to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">LFQueue</span></strong><span class="koboSpan" id="kobo.316.1"> connected </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">OrderServer</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">T5_MarketDataPublisher_LFQueue_read</span></strong><span class="koboSpan" id="kobo.320.1"> – the time when the market update is read </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">LFQueue</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">T5t_OrderServer_LFQueue_read</span></strong><span class="koboSpan" id="kobo.324.1"> – the time when the client response is read </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">LFQueue</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">T6_MarketDataPublisher_UDP_write</span></strong><span class="koboSpan" id="kobo.328.1"> – the time when the market update is written to the UDP socket </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">MarketDataPublisher</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">T6t_OrderServer_TCP_write</span></strong><span class="koboSpan" id="kobo.332.1"> – the time when the client response is written to the TCP socket </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">OrderServer</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.335.1">The exact locations of these timestamps</span><a id="_idIndexMarker1465"/><span class="koboSpan" id="kobo.336.1"> are shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer070">
<span class="koboSpan" id="kobo.338.1"><img alt="Figure 11.1 – The topology of the electronic trading exchange with the key hops to timestamp" src="image/B19434_11_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.339.1">Figure 11.1 – The topology of the electronic trading exchange with the key hops to timestamp</span></p>
<p><span class="koboSpan" id="kobo.340.1">Now, starting in the next section, we</span><a id="_idIndexMarker1466"/><span class="koboSpan" id="kobo.341.1"> can start looking at the code changes we need to add to these two forms </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">of measurement.</span></span></p>
<h2 id="_idParaDest-288"><a id="_idTextAnchor301"/><span class="koboSpan" id="kobo.343.1">Measuring the latencies inside the market data publisher</span></h2>
<p><span class="koboSpan" id="kobo.344.1">First, we will add performance measurement</span><a id="_idIndexMarker1467"/><span class="koboSpan" id="kobo.345.1"> and timestamping code</span><a id="_idIndexMarker1468"/><span class="koboSpan" id="kobo.346.1"> to the market data publisher. </span><span class="koboSpan" id="kobo.346.2">For the sake of brevity, we will only show the code blocks where we make these changes instead of including the source code for the entire source file or full code blocks in the case of large code blocks. </span><span class="koboSpan" id="kobo.346.3">All the changes, as well as the full, updated source code for the market data publisher-related changes, are in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">Chapter11/exchange/market_data/market_data_publisher.cpp</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.348.1">source file.</span></span></p>
<p><span class="koboSpan" id="kobo.349.1">First, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">MarketDataPublisher::run()</span></strong><span class="koboSpan" id="kobo.351.1"> method, we will add a timestamp using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">TTT_MEASURE</span></strong><span class="koboSpan" id="kobo.353.1"> macro and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">T5_MarketDataPublisher_LFQueue_read</span></strong><span class="koboSpan" id="kobo.355.1"> tag right after reading from </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">outgoing_md_updates_</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.357.1">LFQueue</span></strong><span class="koboSpan" id="kobo.358.1">, as </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.360.1">
  auto MarketDataPublisher::run() noexcept -&gt; void {
    ...
</span><span class="koboSpan" id="kobo.360.2">    while (run_) {
      for (auto market_update = outgoing_md_updates_-&gt;
        getNextToRead();
           outgoing_md_updates_-&gt;size() &amp;&amp; market_update;
             market_update = outgoing_md_updates_-&gt;
               getNextToRead()) {
        TTT_MEASURE(T5_MarketDataPublisher_LFQueue_read,
          logger_);</span></pre>
<p><span class="koboSpan" id="kobo.361.1">Next, we will measure the time taken to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">MCastSocket::send()</span></strong><span class="koboSpan" id="kobo.363.1"> on </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">incremental_socket_</span></strong><span class="koboSpan" id="kobo.365.1"> using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">START_MEASURE</span></strong><span class="koboSpan" id="kobo.367.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">END_MEASURE</span></strong><span class="koboSpan" id="kobo.369.1"> macros and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">Exchange_McastSocket_send</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.371.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.372.1">
        START_MEASURE(Exchange_McastSocket_send);
        incremental_socket_.send(&amp;next_inc_seq_num_,
          sizeof(next_inc_seq_num_));
        incremental_socket_.send(market_update,
          sizeof(MEMarketUpdate));
        END_MEASURE(Exchange_McastSocket_send, logger_);</span></pre>
<p><span class="koboSpan" id="kobo.373.1">Finally, we will take another timestamp using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">TTT_MEASURE</span></strong><span class="koboSpan" id="kobo.375.1"> macro and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">T6_MarketDataPublisher_UDP_write</span></strong><span class="koboSpan" id="kobo.377.1"> tag right after</span><a id="_idIndexMarker1469"/><span class="koboSpan" id="kobo.378.1"> the socket write</span><a id="_idIndexMarker1470"/> <span class="No-Break"><span class="koboSpan" id="kobo.379.1">is finished:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.380.1">
        outgoing_md_updates_-&gt;updateReadIndex();
        TTT_MEASURE(T6_MarketDataPublisher_UDP_write,
          logger_);
        ...</span></pre>
<p><span class="koboSpan" id="kobo.381.1">Next, let us look at the changes in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">OrderServer</span></strong><span class="koboSpan" id="kobo.383.1"> component for performance measurement </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">and timestamping.</span></span></p>
<h2 id="_idParaDest-289"><a id="_idTextAnchor302"/><span class="koboSpan" id="kobo.385.1">Measuring the latencies inside the order server</span></h2>
<p><span class="koboSpan" id="kobo.386.1">All the changes for performance measurement</span><a id="_idIndexMarker1471"/><span class="koboSpan" id="kobo.387.1"> and timestamping, as well as the full</span><a id="_idIndexMarker1472"/><span class="koboSpan" id="kobo.388.1"> source code for </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">OrderServer</span></strong><span class="koboSpan" id="kobo.390.1">, are in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">Chapter11/exchange/order_server/order_server.h</span></strong><span class="koboSpan" id="kobo.392.1"> source file. </span><span class="koboSpan" id="kobo.392.2">As before, we will only show minimal code blocks where the changes are made for the sake of brevity and to </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">avoid repetition.</span></span></p>
<p><span class="koboSpan" id="kobo.394.1">First, we will make changes to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">OrderServer::run()</span></strong><span class="koboSpan" id="kobo.396.1"> method, right after reading an entry from </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">outgoing_responses_</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.398.1">LFQueue</span></strong><span class="koboSpan" id="kobo.399.1">. </span><span class="koboSpan" id="kobo.399.2">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">TTT_MEASURE</span></strong><span class="koboSpan" id="kobo.401.1"> macro with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">T5t_OrderServer_LFQueue_read</span></strong><span class="koboSpan" id="kobo.403.1"> tag, as </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.405.1">
    auto run() noexcept {
      ...
</span><span class="koboSpan" id="kobo.405.2">      while (run_) {
      ...
</span><span class="koboSpan" id="kobo.405.3">        for (auto client_response = outgoing_responses_-&gt;
          getNextToRead(); outgoing_responses_-&gt;size() &amp;&amp;
            client_response; client_response =
              outgoing_responses_-&gt;getNextToRead()) {
          TTT_MEASURE(T5t_OrderServer_LFQueue_read,
            logger_);</span></pre>
<p><span class="koboSpan" id="kobo.406.1">Next, we will measure</span><a id="_idIndexMarker1473"/><span class="koboSpan" id="kobo.407.1"> the call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">TCPSocket::send()</span></strong><span class="koboSpan" id="kobo.409.1"> method using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">START_MEASURE</span></strong><span class="koboSpan" id="kobo.411.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">END_MEASURE</span></strong><span class="koboSpan" id="kobo.413.1"> macros and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">Exchange_TCPSocket_send</span></strong><span class="koboSpan" id="kobo.415.1"> tag. </span><span class="koboSpan" id="kobo.415.2">Note that</span><a id="_idIndexMarker1474"/><span class="koboSpan" id="kobo.416.1"> we measure the call to send out the full client response message, which, in our implementation, results in two calls to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">TCPSocket::send()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.418.1"> methods:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.419.1">
          START_MEASURE(Exchange_TCPSocket_send);
          cid_tcp_socket_[client_response-&gt;client_id_]-&gt;
            send(&amp;next_outgoing_seq_num,
              sizeof(next_outgoing_seq_num));
          cid_tcp_socket_[client_response-&gt;client_id_]-&gt;
             send(client_response,
               sizeof(MEClientResponse));
          END_MEASURE(Exchange_TCPSocket_send, logger_);</span></pre>
<p><span class="koboSpan" id="kobo.420.1">Finally, after the TCP socket send operations finish, we take another timestamp using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">TTT_MEASURE</span></strong><span class="koboSpan" id="kobo.422.1"> method and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">T6t_OrderServer_TCP_write</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.424.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.425.1">
          outgoing_responses_-&gt;updateReadIndex();
          TTT_MEASURE(T6t_OrderServer_TCP_write, logger_);
          ...</span></pre>
<p><span class="koboSpan" id="kobo.426.1">The next set of changes is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">OrderServer::recvCallback()</span></strong><span class="koboSpan" id="kobo.428.1"> method. </span><span class="koboSpan" id="kobo.428.2">Right as soon as we enter the method, we take a timestamp with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">TTT_MEASURE</span></strong><span class="koboSpan" id="kobo.430.1"> macro with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">T1_OrderServer_TCP_read</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.432.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.433.1">
    auto recvCallback(TCPSocket *socket, Nanos rx_time)
      noexcept {
      TTT_MEASURE(T1_OrderServer_TCP_read, logger_);
      ...</span></pre>
<p><span class="koboSpan" id="kobo.434.1">Finally, at the end of this method, we measure the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">FIFOSequencer::addClientRequest()</span></strong><span class="koboSpan" id="kobo.436.1">, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">START_MEASURE</span></strong><span class="koboSpan" id="kobo.438.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">END_MEASURE</span></strong><span class="koboSpan" id="kobo.440.1"> macros with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">Exchange_FIFOSequencer_addClientRequest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.442.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.443.1">
START_MEASURE(Exchange_FIFOSequencer_addClientRequest);
          fifo_sequencer_.addClientRequest(rx_time,
            request-&gt;me_client_request_);
              END_MEASURE(Exchange_FIFOSequencer_
                addClientRequest, logger_);
          ...</span></pre>
<p><span class="koboSpan" id="kobo.444.1">Finally, for </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">OrderServer</span></strong><span class="koboSpan" id="kobo.446.1">, we need to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">OrderServer::recvFinishedCallback()</span></strong><span class="koboSpan" id="kobo.448.1"> method. </span><span class="koboSpan" id="kobo.448.2">We measure</span><a id="_idIndexMarker1475"/><span class="koboSpan" id="kobo.449.1"> the call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">FIFOSequencer::sequenceAndPublish()</span></strong><span class="koboSpan" id="kobo.451.1"> method using</span><a id="_idIndexMarker1476"/><span class="koboSpan" id="kobo.452.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">START_MEASURE</span></strong><span class="koboSpan" id="kobo.454.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">END_MEASURE</span></strong><span class="koboSpan" id="kobo.456.1"> macros with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">Exchange_FIFOSequencer_sequenceAndPublish</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.458.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.459.1">
    auto recvFinishedCallback() noexcept {
    START_MEASURE(Exchange_FIFOSequencer_sequenceAndPublis)
    ;
      fifo_sequencer_.sequenceAndPublish();
      END_MEASURE(Exchange_FIFOSequencer_
        sequenceAndPublish, logger_);
    }</span></pre>
<p><span class="koboSpan" id="kobo.460.1">In the next subsection, we will add instrumentation to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">FIFOSequencer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.462.1"> subcomponent.</span></span></p>
<h3><span class="koboSpan" id="kobo.463.1">Measuring the latencies inside FIFOSequencer</span></h3>
<p><span class="koboSpan" id="kobo.464.1">All the instrumentation</span><a id="_idIndexMarker1477"/><span class="koboSpan" id="kobo.465.1"> changes, as well as the full, updated source for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">FIFOSequencer</span></strong><span class="koboSpan" id="kobo.467.1"> subcomponent, can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">Chapter11/exchange/order_server/fifo_sequencer.h</span></strong><span class="koboSpan" id="kobo.469.1"> source file. </span><span class="koboSpan" id="kobo.469.2">The only changes we will make are in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">FIFOSequencer::sequenceAndPublish()</span></strong><span class="koboSpan" id="kobo.471.1"> method. </span><span class="koboSpan" id="kobo.471.2">Here, all we do is add a timestamp after we write a client request to </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">incoming_requests_</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.473.1">LFQueue</span></strong><span class="koboSpan" id="kobo.474.1">, which we do by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">TTT_MEASURE</span></strong><span class="koboSpan" id="kobo.476.1"> macro and using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">T2_OrderServer_LFQueue_write</span></strong><span class="koboSpan" id="kobo.478.1"> tag value, as </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.480.1">
    auto sequenceAndPublish() {
      for (size_t i = 0; i &lt; pending_size_; ++i) {
        ...
</span><span class="koboSpan" id="kobo.480.2">        auto next_write = incoming_requests_-&gt;
          getNextToWriteTo();
        *next_write = std::move(client_request.request_);
        incoming_requests_-&gt;updateWriteIndex();
        TTT_MEASURE(T2_OrderServer_LFQueue_write,
          (*logger_));
        ...</span></pre>
<p><span class="koboSpan" id="kobo.481.1">Next, we move on to the task of adding instrumentation and timestamps to the core matching engine component as well as </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">its subcomponents.</span></span></p>
<h2 id="_idParaDest-290"><a id="_idTextAnchor303"/><span class="koboSpan" id="kobo.483.1">Measuring the latencies inside the matching engine and order book</span></h2>
<p><span class="koboSpan" id="kobo.484.1">First, we will update</span><a id="_idIndexMarker1478"/> <strong class="source-inline"><span class="koboSpan" id="kobo.485.1">MatchingEngine</span></strong><span class="koboSpan" id="kobo.486.1">; all the changes</span><a id="_idIndexMarker1479"/><span class="koboSpan" id="kobo.487.1"> and the full, updated</span><a id="_idIndexMarker1480"/><span class="koboSpan" id="kobo.488.1"> source for </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">MatchingEngine</span></strong><span class="koboSpan" id="kobo.490.1"> can be found</span><a id="_idIndexMarker1481"/><span class="koboSpan" id="kobo.491.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">Chapter11/exchange/matcher/matching_engine.h</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.493.1">source file.</span></span></p>
<p><span class="koboSpan" id="kobo.494.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">MatchingEngine::processClientRequest()</span></strong><span class="koboSpan" id="kobo.496.1"> method, we will measure the time it takes for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">MEOrderBook::add()</span></strong><span class="koboSpan" id="kobo.498.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">MEOrderBook::cancel()</span></strong><span class="koboSpan" id="kobo.500.1"> methods. </span><span class="koboSpan" id="kobo.500.2">First, we show the changes for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">MEOrderBook::add()</span></strong><span class="koboSpan" id="kobo.502.1"> method using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">START_MEASURE</span></strong><span class="koboSpan" id="kobo.504.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">END_MEASURE</span></strong><span class="koboSpan" id="kobo.506.1"> macros and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">Exchange_MEOrderBook_add</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.508.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.509.1">
    auto processClientRequest(const MEClientRequest
      *client_request) noexcept {
      ...
</span><span class="koboSpan" id="kobo.509.2">      switch (client_request-&gt;type_) {
        case ClientRequestType::NEW: {
          START_MEASURE(Exchange_MEOrderBook_add);
          order_book-&gt;add(client_request-&gt;client_id_,
           client_request-&gt;order_id_, client_request-&gt;
             ticker_id_,
                           client_request-&gt;side_,
                             client_request-&gt;price_,
                               client_request-&gt;qty_);
          END_MEASURE(Exchange_MEOrderBook_add, logger_);
          ...</span></pre>
<p><span class="koboSpan" id="kobo.510.1">Then, we have the changes for </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">MEOrderBook::cancel()</span></strong><span class="koboSpan" id="kobo.512.1"> using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">START_MEASURE</span></strong><span class="koboSpan" id="kobo.514.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">END_MEASURE</span></strong><span class="koboSpan" id="kobo.516.1"> macros and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">Exchange_MEOrderBook_cancel</span></strong><span class="koboSpan" id="kobo.518.1"> tag, as </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.520.1">
        case ClientRequestType::CANCEL: {
          START_MEASURE(Exchange_MEOrderBook_cancel);
          order_book-&gt;cancel(client_request-&gt;client_id_,
            client_request-&gt;order_id_, client_request-&gt;
              ticker_id_);
          END_MEASURE(Exchange_MEOrderBook_cancel,
            logger_);
          ...</span></pre>
<p><span class="koboSpan" id="kobo.521.1">The next method we need</span><a id="_idIndexMarker1482"/><span class="koboSpan" id="kobo.522.1"> to update is </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">MatchingEngine::sendClientResponse()</span></strong><span class="koboSpan" id="kobo.524.1">. </span><span class="koboSpan" id="kobo.524.2">We will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">TTT_MEASURE</span></strong><span class="koboSpan" id="kobo.526.1"> macro </span><a id="_idIndexMarker1483"/><span class="koboSpan" id="kobo.527.1">with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">T4t_MatchingEngine_LFQueue_write</span></strong><span class="koboSpan" id="kobo.529.1"> tag right after we write</span><a id="_idIndexMarker1484"/><span class="koboSpan" id="kobo.530.1"> the client response</span><a id="_idIndexMarker1485"/><span class="koboSpan" id="kobo.531.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">outgoing_ogw_responses_</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.533.1">LFQueue</span></strong><span class="koboSpan" id="kobo.534.1">, as </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.536.1">
    auto sendClientResponse(const MEClientResponse
      *client_response) noexcept {
      ...
</span><span class="koboSpan" id="kobo.536.2">      auto next_write = outgoing_ogw_responses_-&gt;
        getNextToWriteTo();
      *next_write = std::move(*client_response);
      outgoing_ogw_responses_-&gt;updateWriteIndex();
      TTT_MEASURE(T4t_MatchingEngine_LFQueue_write,
        logger_);
    }</span></pre>
<p><span class="koboSpan" id="kobo.537.1">We also need to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">MatchingEngine::sendMarketUpdate()</span></strong><span class="koboSpan" id="kobo.539.1"> method by adding a timestamp after writing the market update to </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">outgoing_md_updates_</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.541.1">LFQueue</span></strong><span class="koboSpan" id="kobo.542.1"> using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">TTT_MEASURE</span></strong><span class="koboSpan" id="kobo.544.1"> macro and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">T4_MatchingEngine_LFQueue_write</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.546.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.547.1">
    auto sendMarketUpdate(const MEMarketUpdate
      *market_update) noexcept {
      ...
</span><span class="koboSpan" id="kobo.547.2">      auto next_write = outgoing_md_updates_-&gt;
        getNextToWriteTo();
      *next_write = *market_update;
      outgoing_md_updates_-&gt;updateWriteIndex();
      TTT_MEASURE(T4_MatchingEngine_LFQueue_write,
        logger_);
    }</span></pre>
<p><span class="koboSpan" id="kobo.548.1">The final method we need to update in </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">MatchingEngine</span></strong><span class="koboSpan" id="kobo.550.1"> is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">run()</span></strong><span class="koboSpan" id="kobo.552.1"> method itself. </span><span class="koboSpan" id="kobo.552.2">We take a timestamp right after reading from </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">incoming_requests_</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.554.1">LFQueue</span></strong><span class="koboSpan" id="kobo.555.1">, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">TTT_MEASURE</span></strong><span class="koboSpan" id="kobo.557.1"> macro and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">T3_MatchingEngine_LFQueue_read</span></strong><span class="koboSpan" id="kobo.559.1"> tag, as </span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.561.1">
    auto run() noexcept {
      while (run_) {
        const auto me_client_request = incoming_requests_-&gt;
          getNextToRead();
        if (LIKELY(me_client_request)) {
          TTT_MEASURE(T3_MatchingEngine_LFQueue_read,
            logger_);</span></pre>
<p><span class="koboSpan" id="kobo.562.1">And we measure the call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">MatchingEngine::processClientRequest()</span></strong><span class="koboSpan" id="kobo.564.1"> method with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">START_MEASURE</span></strong><span class="koboSpan" id="kobo.566.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">END_MEASURE</span></strong><span class="koboSpan" id="kobo.568.1"> macros with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">Exchange_MatchingEngine_processClientRequest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.570.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.571.1">
START_MEASURE(Exchange_MatchingEngine_processClientRequest);          processClientRequest(me_client_request);
END_MEASURE(Exchange_MatchingEngine_processClientRequest,
  logger_);
          ...</span></pre>
<p><span class="koboSpan" id="kobo.572.1">The final component</span><a id="_idIndexMarker1486"/><span class="koboSpan" id="kobo.573.1"> on the exchange</span><a id="_idIndexMarker1487"/><span class="koboSpan" id="kobo.574.1"> side that we need to update</span><a id="_idIndexMarker1488"/><span class="koboSpan" id="kobo.575.1"> is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">MEOrderBook</span></strong><span class="koboSpan" id="kobo.577.1"> subcomponent</span><a id="_idIndexMarker1489"/> <span class="No-Break"><span class="koboSpan" id="kobo.578.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">MatchingEngine</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.581.1">Measuring the latencies inside MEOrderBook</span></h3>
<p><span class="koboSpan" id="kobo.582.1">We will discuss</span><a id="_idIndexMarker1490"/><span class="koboSpan" id="kobo.583.1"> the instrumentation changes to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">MEOrderBook</span></strong><span class="koboSpan" id="kobo.585.1"> component in this subsection, which can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">Chapter11/exchange/matcher/me_order_book.cpp</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.587.1">source file.</span></span></p>
<p><span class="koboSpan" id="kobo.588.1">The first method we will update is </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">MEOrderBook::match()</span></strong><span class="koboSpan" id="kobo.590.1">. </span><span class="koboSpan" id="kobo.590.2">We want to measure the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">MEOrderBook::removeOrder()</span></strong><span class="koboSpan" id="kobo.592.1"> with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">START_MEASURE</span></strong><span class="koboSpan" id="kobo.594.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">END_MEASURE</span></strong><span class="koboSpan" id="kobo.596.1"> macros and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">Exchange_MEOrderBook_removeOrder</span></strong><span class="koboSpan" id="kobo.598.1"> tag, as </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.600.1">
  auto MEOrderBook::match(TickerId ticker_id, ClientId
    client_id, Side side, OrderId client_order_id, OrderId
      new_market_order_id, MEOrder* itr, Qty* leaves_qty)
        noexcept {
    ...
</span><span class="koboSpan" id="kobo.600.2">    if (!order-&gt;qty_) {
      ...
</span><span class="koboSpan" id="kobo.600.3">      START_MEASURE(Exchange_MEOrderBook_removeOrder);
      removeOrder(order);
      END_MEASURE(Exchange_MEOrderBook_removeOrder,
        (*logger_));
      ...</span></pre>
<p><span class="koboSpan" id="kobo.601.1">We also need</span><a id="_idIndexMarker1491"/><span class="koboSpan" id="kobo.602.1"> to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">MEOrderBook::checkForMatch()</span></strong><span class="koboSpan" id="kobo.604.1"> method to measure the calls to </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">MEOrderBook::match()</span></strong><span class="koboSpan" id="kobo.606.1">. </span><span class="koboSpan" id="kobo.606.2">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">START_MEASURE</span></strong><span class="koboSpan" id="kobo.608.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">END_MEASURE</span></strong><span class="koboSpan" id="kobo.610.1"> macros with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">Exchange_MEOrderBook_match</span></strong><span class="koboSpan" id="kobo.612.1"> tag for the two branches of execution, as </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.614.1">
  auto MEOrderBook::checkForMatch(ClientId client_id,
    OrderId client_order_id, TickerId ticker_id, Side side,
      Price price, Qty qty, Qty new_market_order_id)
        noexcept {
    ...
</span><span class="koboSpan" id="kobo.614.2">    if (side == Side::BUY) {
      while (leaves_qty &amp;&amp; asks_by_price_) {
        ...
</span><span class="koboSpan" id="kobo.614.3">        START_MEASURE(Exchange_MEOrderBook_match);
        match(ticker_id, client_id, side, client_order_id,
          new_market_order_id, ask_itr, &amp;leaves_qty);
        END_MEASURE(Exchange_MEOrderBook_match,
          (*logger_));
      }
    }
    if (side == Side::SELL) {
      while (leaves_qty &amp;&amp; bids_by_price_) {
        ...
</span><span class="koboSpan" id="kobo.614.4">        START_MEASURE(Exchange_MEOrderBook_match);
        match(ticker_id, client_id, side, client_order_id,
          new_market_order_id, bid_itr, &amp;leaves_qty);
        END_MEASURE(Exchange_MEOrderBook_match,
          (*logger_));
      }
    }
    ...</span></pre>
<p><span class="koboSpan" id="kobo.615.1">We will add additional instrumentation</span><a id="_idIndexMarker1492"/><span class="koboSpan" id="kobo.616.1"> within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">MEOrderBook::add()</span></strong><span class="koboSpan" id="kobo.618.1"> method to measure a few different calls. </span><span class="koboSpan" id="kobo.618.2">The first one is the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">MEOrderBook::checkForMatch()</span></strong><span class="koboSpan" id="kobo.620.1">, for which we will use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">Exchange_MEOrderBook_checkForMatch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.622.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.623.1">
  auto MEOrderBook::add(ClientId client_id, OrderId
    client_order_id, TickerId ticker_id, Side side, Price
      price, Qty qty) noexcept -&gt; void {
    ...
</span><span class="koboSpan" id="kobo.623.2">    START_MEASURE(Exchange_MEOrderBook_checkForMatch);
    const auto leaves_qty = checkForMatch(client_id,
      client_order_id, ticker_id, side, price, qty,
        new_market_order_id);
    END_MEASURE(Exchange_MEOrderBook_checkForMatch,
      (*logger_));
    …</span></pre>
<p><span class="koboSpan" id="kobo.624.1">The next one is the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">MEOrderBook::addOrder()</span></strong><span class="koboSpan" id="kobo.626.1">, for which we will use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">Exchange_MEOrderBook_addOrder</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.628.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.629.1">
      START_MEASURE(Exchange_MEOrderBook_addOrder);
      addOrder(order);
      END_MEASURE(Exchange_MEOrderBook_addOrder,
       (*logger_));
      ...</span></pre>
<p><span class="koboSpan" id="kobo.630.1">The last </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">MEOrderBook</span></strong><span class="koboSpan" id="kobo.632.1"> method we need to add</span><a id="_idIndexMarker1493"/><span class="koboSpan" id="kobo.633.1"> more granular instrumentation to is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">cancel()</span></strong><span class="koboSpan" id="kobo.635.1"> method. </span><span class="koboSpan" id="kobo.635.2">In this method, we want to measure the call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">MEOrderBook::removeOrder()</span></strong><span class="koboSpan" id="kobo.637.1"> method, as shown next, with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">START_MEASURE</span></strong><span class="koboSpan" id="kobo.639.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">END_MEASURE</span></strong><span class="koboSpan" id="kobo.641.1"> macros and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">Exchange_MEOrderBook_removeOrder</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.643.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.644.1">
  auto MEOrderBook::cancel(ClientId client_id, OrderId
    order_id, TickerId ticker_id) noexcept -&gt; void {
      ...
</span><span class="koboSpan" id="kobo.644.2">      START_MEASURE(Exchange_MEOrderBook_removeOrder);
      removeOrder(exchange_order);
      END_MEASURE(Exchange_MEOrderBook_removeOrder,
        (*logger_));
      ...</span></pre>
<p><span class="koboSpan" id="kobo.645.1">This concludes all the measurements we wanted to add on the side of the electronic exchange, and in the next section, we will add similar instrumentation on the other side: that is, the trading </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">client system.</span></span></p>
<h1 id="_idParaDest-291"><a id="_idTextAnchor304"/><span class="koboSpan" id="kobo.647.1">Measuring latencies in the trading engine</span></h1>
<p><span class="koboSpan" id="kobo.648.1">In this section, we will focus on adding</span><a id="_idIndexMarker1494"/><span class="koboSpan" id="kobo.649.1"> performance measurement and timestamps to the trading client’s system – the market data consumer, the order gateway, and the trade engine and its subcomponents. </span><span class="koboSpan" id="kobo.649.2">Here too, we will measure the performance of internal components as well as add timestamps to help with a higher-level analysis of incoming and outgoing </span><span class="No-Break"><span class="koboSpan" id="kobo.650.1">events latencies.</span></span></p>
<h3><span class="koboSpan" id="kobo.651.1">Understanding how to measure internally</span></h3>
<p><span class="koboSpan" id="kobo.652.1">The motivation and approach</span><a id="_idIndexMarker1495"/><span class="koboSpan" id="kobo.653.1"> toward measuring the performance of internal components for the trading clients’ systems are identical to those on the exchange side. </span><span class="koboSpan" id="kobo.653.2">The complete list of internal measurements we will take is listed next, but interested readers should use similar techniques to add even more points of measurement as they see fit. </span><span class="koboSpan" id="kobo.653.3">We will see the code for how to measure these familiar methods shortly, but for now, the methods we will measure on the client’s side are </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">the following:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">Trading::MarketDataConsumer::recvCallback()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">Common::TCPSocket::send()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">Trading::OrderGateway::recvCallback()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">Trading::OrderManager::moveOrders()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">Trading::OrderManager::onOrderUpdate()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">Trading::OrderManager::moveOrders()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">Trading::OrderManager::onOrderUpdate()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">Trading::MarketOrderBook::addOrder()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">Trading::MarketOrderBook::removeOrder()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">Trading::MarketOrderBook::updateBBO()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">Trading::OrderManager::cancelOrder()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">Trading::RiskManager::checkPreTradeRisk()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">Trading::OrderManager::newOrder()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">Trading::OrderManager::moveOrder()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">Trading::OrderManager::moveOrder()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">Trading::PositionKeeper::updateBBO()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">Trading::FeatureEngine::onOrderBookUpdate()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">Trading::TradeEngine::algoOnOrderBookUpdate()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">Trading::FeatureEngine::onTradeUpdate()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">Trading::TradeEngine::algoOnTradeUpdate()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">Trading::PositionKeeper::addFill()</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">Trading::TradeEngine::algoOnOrderUpdate()</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.677.1">As we did with the electronic trading</span><a id="_idIndexMarker1496"/><span class="koboSpan" id="kobo.678.1"> exchange, we will understand the key hops that we will timestamp in the trading </span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">client’s system.</span></span></p>
<h3><span class="koboSpan" id="kobo.680.1">Understanding key hops in the trading client’s system</span></h3>
<p><span class="koboSpan" id="kobo.681.1">Market participants also have</span><a id="_idIndexMarker1497"/><span class="koboSpan" id="kobo.682.1"> similar reasons for timestamping the flow of events</span><a id="_idIndexMarker1498"/><span class="koboSpan" id="kobo.683.1"> through each of the components and subcomponents. </span><span class="koboSpan" id="kobo.683.2">By recording and analyzing the timings of these events, participants can seek to improve their systems as well as analyze how to </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">increase profitability.</span></span></p>
<p><span class="koboSpan" id="kobo.685.1">In our electronic trading client’s system, we will take timestamps of the </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">following events:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">T7_MarketDataConsumer_UDP_read</span></strong><span class="koboSpan" id="kobo.688.1"> – the time when a market data update is read from the UDP socket </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">MarketDataConsumer</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">T7t_OrderGateway_TCP_read</span></strong><span class="koboSpan" id="kobo.692.1"> – the time when a client response is read from the TCP socket </span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">OrderGateway</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">T8_MarketDataConsumer_LFQueue_write</span></strong><span class="koboSpan" id="kobo.696.1"> – the time when a market data update is written to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">LFQueue</span></strong><span class="koboSpan" id="kobo.698.1"> connected </span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">TradeEngine</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">T8t_OrderGateway_LFQueue_write</span></strong><span class="koboSpan" id="kobo.702.1"> – the time when a client response is written to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">LFQueue</span></strong><span class="koboSpan" id="kobo.704.1"> connected </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">TradeEngine</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">T9_TradeEngine_LFQueue_read</span></strong><span class="koboSpan" id="kobo.708.1"> – the time when a market data update is read from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">LFQueue</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.710.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">MarketDataConsumer</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">T9t_TradeEngine_LFQueue_read</span></strong><span class="koboSpan" id="kobo.713.1"> – the time when a client response is read from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">LFQueue</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.715.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">OrderGateway</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">T10_TradeEngine_LFQueue_write</span></strong><span class="koboSpan" id="kobo.718.1"> – the time when a client request is written to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">LFQueue</span></strong><span class="koboSpan" id="kobo.720.1"> connected </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">OrderGateway</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">T11_OrderGateway_LFQueue_read</span></strong><span class="koboSpan" id="kobo.724.1"> – the time when </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">OrderGateway</span></strong><span class="koboSpan" id="kobo.726.1"> reads a client request from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">LFQueue</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.728.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">TradeEngine</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">T12_OrderGateway_TCP_write</span></strong><span class="koboSpan" id="kobo.731.1"> – the time when </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">OrderGateway</span></strong><span class="koboSpan" id="kobo.733.1"> writes a client request to the </span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">TCP socket</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.735.1">The exact locations</span><a id="_idIndexMarker1499"/><span class="koboSpan" id="kobo.736.1"> of these timestamps</span><a id="_idIndexMarker1500"/><span class="koboSpan" id="kobo.737.1"> are shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.738.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer071">
<span class="koboSpan" id="kobo.739.1"><img alt="Figure 11.2 – The topology of the electronic trading client’s system with the key hops to timestamp" src="image/B19434_11_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.740.1">Figure 11.2 – The topology of the electronic trading client’s system with the key hops to timestamp</span></p>
<p><span class="koboSpan" id="kobo.741.1">Now, starting in the next section, we can start looking at the code changes we need to add to these two forms </span><span class="No-Break"><span class="koboSpan" id="kobo.742.1">of measurement.</span></span></p>
<h2 id="_idParaDest-292"><a id="_idTextAnchor305"/><span class="koboSpan" id="kobo.743.1">Measuring the latencies inside the market data consumer</span></h2>
<p><span class="koboSpan" id="kobo.744.1">We will start with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">MarketDataConsumer</span></strong><span class="koboSpan" id="kobo.746.1"> component and, as we discussed</span><a id="_idIndexMarker1501"/><span class="koboSpan" id="kobo.747.1"> before, we will only show the changes to the code</span><a id="_idIndexMarker1502"/><span class="koboSpan" id="kobo.748.1"> here and omit repeating the full source code. </span><span class="koboSpan" id="kobo.748.2">The changes, as well as the full source code, are in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">Chapter11/trading/market_data/market_data_consumer.cpp</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.750.1">source file.</span></span></p>
<p><span class="koboSpan" id="kobo.751.1">The first timestamp we take is as soon as we enter </span><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">MarketDataConsumer::recvCallback()</span></strong><span class="koboSpan" id="kobo.753.1">, where we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">TTT_MEASURE</span></strong><span class="koboSpan" id="kobo.755.1"> macro with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">T7_MarketDataConsumer_UDP_read</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.757.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.758.1">
  auto MarketDataConsumer::recvCallback(McastSocket
    *socket) noexcept -&gt; void {
    TTT_MEASURE(T7_MarketDataConsumer_UDP_read, logger_);</span></pre>
<p><span class="koboSpan" id="kobo.759.1">We will also enclose the entire method using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">START_MEASURE</span></strong><span class="koboSpan" id="kobo.761.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">END_MEASURE</span></strong><span class="koboSpan" id="kobo.763.1"> macros with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">Trading_MarketDataConsumer_recvCallback</span></strong><span class="koboSpan" id="kobo.765.1"> tag to measure the latency of the </span><span class="No-Break"><span class="koboSpan" id="kobo.766.1">entire method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.767.1">
    START_MEASURE(Trading_MarketDataConsumer_recvCallback);
    ...
</span><span class="koboSpan" id="kobo.767.2">    END_MEASURE(Trading_MarketDataConsumer_recvCallback,
      logger_);
  }</span></pre>
<p><span class="koboSpan" id="kobo.768.1">We will add a timestamp</span><a id="_idIndexMarker1503"/><span class="koboSpan" id="kobo.769.1"> right after writing the decoded </span><a id="_idIndexMarker1504"/><span class="koboSpan" id="kobo.770.1">market update to </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">incoming_md_updates_</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.772.1">LFQueue</span></strong><span class="koboSpan" id="kobo.773.1">, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">TTT_MEASURE</span></strong><span class="koboSpan" id="kobo.775.1"> macro and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">T8_MarketDataConsumer_LFQueue_write</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.777.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.778.1">
          auto next_write = incoming_md_updates_-&gt;
            getNextToWriteTo();
          *next_write = std::move(request-&gt;
            me_market_update_);
          incoming_md_updates_-&gt;updateWriteIndex();
          TTT_MEASURE(T8_MarketDataConsumer_LFQueue_write,
            logger_);</span></pre>
<p><span class="koboSpan" id="kobo.779.1">In the next section, we move on to adding performance measurement to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">OrderGateway</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.781.1"> component.</span></span></p>
<h2 id="_idParaDest-293"><a id="_idTextAnchor306"/><span class="koboSpan" id="kobo.782.1">Measuring the latencies inside the order gateway</span></h2>
<p><span class="koboSpan" id="kobo.783.1">We will update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">OrderGateway</span></strong><span class="koboSpan" id="kobo.785.1"> component in this</span><a id="_idIndexMarker1505"/><span class="koboSpan" id="kobo.786.1"> subsection; all the changes</span><a id="_idIndexMarker1506"/><span class="koboSpan" id="kobo.787.1"> and the updated full source code are available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.788.1">Chapter11/trading/order_gw/order_gateway.cpp</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.789.1">source file.</span></span></p>
<p><span class="koboSpan" id="kobo.790.1">The first method we will update is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">OrderGateway::run()</span></strong><span class="koboSpan" id="kobo.792.1"> method, and the first timestamp we take is when we read a client request from </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">outgoing_requests_</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.794.1">LFQueue</span></strong><span class="koboSpan" id="kobo.795.1">. </span><span class="koboSpan" id="kobo.795.2">We accomplish this by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.796.1">TTT_MEASURE</span></strong><span class="koboSpan" id="kobo.797.1"> macro and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.798.1">T11_OrderGateway_LFQueue_read</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.799.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.800.1">
  auto OrderGateway::run() noexcept -&gt; void {
      ...
</span><span class="koboSpan" id="kobo.800.2">      for(auto client_request = outgoing_requests_-&gt;
       getNextToRead(); client_request; client_request =
         outgoing_requests_-&gt;getNextToRead()) {
        TTT_MEASURE(T11_OrderGateway_LFQueue_read,
          logger_);</span></pre>
<p><span class="koboSpan" id="kobo.801.1">The next thing we will measure is the time it takes to execute the </span><strong class="source-inline"><span class="koboSpan" id="kobo.802.1">Common::TCPSocket::send()</span></strong><span class="koboSpan" id="kobo.803.1"> method, which we accomplish, as shown next, using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.804.1">Trading_TCPSocket_send</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.805.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.806.1">
        START_MEASURE(Trading_TCPSocket_send);
        tcp_socket_.send(&amp;next_outgoing_seq_num_,
          sizeof(next_outgoing_seq_num_));
        tcp_socket_.send(client_request,
          sizeof(Exchange::MEClientRequest));
        END_MEASURE(Trading_TCPSocket_send, logger_);</span></pre>
<p><span class="koboSpan" id="kobo.807.1">Finally, we also timestamp right after </span><strong class="source-inline"><span class="koboSpan" id="kobo.808.1">TCPSocket::send()</span></strong><span class="koboSpan" id="kobo.809.1"> finishes using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">TTT_MEASURE</span></strong><span class="koboSpan" id="kobo.811.1"> macro and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">T12_OrderGateway_TCP_write</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.813.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.814.1">
        outgoing_requests_-&gt;updateReadIndex();
        TTT_MEASURE(T12_OrderGateway_TCP_write, logger_);</span></pre>
<p><span class="koboSpan" id="kobo.815.1">The next method</span><a id="_idIndexMarker1507"/><span class="koboSpan" id="kobo.816.1"> we will update in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">OrderGateway</span></strong><span class="koboSpan" id="kobo.818.1"> component</span><a id="_idIndexMarker1508"/><span class="koboSpan" id="kobo.819.1"> is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">recvCallback()</span></strong><span class="koboSpan" id="kobo.821.1"> method. </span><span class="koboSpan" id="kobo.821.2">As soon as we enter the </span><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">recvCallback()</span></strong><span class="koboSpan" id="kobo.823.1"> method, we take a timestamp using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">TTT_MEASURE</span></strong><span class="koboSpan" id="kobo.825.1"> macro and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">T7t_OrderGateway_TCP_read</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.827.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.828.1">
  auto OrderGateway::recvCallback(TCPSocket *socket, Nanos
    rx_time) noexcept -&gt; void {
    TTT_MEASURE(T7t_OrderGateway_TCP_read, logger_);</span></pre>
<p><span class="koboSpan" id="kobo.829.1">As with </span><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">MarketDataConsumer::recvCallback()</span></strong><span class="koboSpan" id="kobo.831.1">, we will enclose the entire </span><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">OrderGateway::recvCallback()</span></strong><span class="koboSpan" id="kobo.833.1"> method using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">START_MEASURE</span></strong><span class="koboSpan" id="kobo.835.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">END_MEASURE</span></strong><span class="koboSpan" id="kobo.837.1"> macros and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">Trading_OrderGateway_recvCallback</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.839.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.840.1">
    START_MEASURE(Trading_OrderGateway_recvCallback);
    ...
</span><span class="koboSpan" id="kobo.840.2">    END_MEASURE(Trading_OrderGateway_recvCallback,
      logger_);
  }</span></pre>
<p><span class="koboSpan" id="kobo.841.1">We also take a timestamp right after writing the client response to </span><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">incoming_responses_</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.843.1">LFQueue</span></strong><span class="koboSpan" id="kobo.844.1"> using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.845.1">TTT_MEASURE</span></strong><span class="koboSpan" id="kobo.846.1"> macro and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">T8t_OrderGateway_LFQueue_write</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.848.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.849.1">
        auto next_write = incoming_responses_-&gt;
          getNextToWriteTo();
        *next_write = std::move(response-&gt;
          me_client_response_);
        incoming_responses_-&gt;updateWriteIndex();
        TTT_MEASURE(T8t_OrderGateway_LFQueue_write,
          logger_);</span></pre>
<p><span class="koboSpan" id="kobo.850.1">In the next and final subsection of this section, we will add the instrumentation code to the trade engine and all the subcomponents in the </span><span class="No-Break"><span class="koboSpan" id="kobo.851.1">trade engine.</span></span></p>
<h2 id="_idParaDest-294"><a id="_idTextAnchor307"/><span class="koboSpan" id="kobo.852.1">Measuring the latencies inside the trading engine</span></h2>
<p><span class="koboSpan" id="kobo.853.1">First, we will start by updating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.854.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.855.1"> class itself, and the changes</span><a id="_idIndexMarker1509"/><span class="koboSpan" id="kobo.856.1"> and the full updated source code for this can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">Chapter11/trading/strategy/trade_engine.cpp</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.858.1">source file.</span></span></p>
<p><span class="koboSpan" id="kobo.859.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.860.1">TradeEngine::sendClientRequest()</span></strong><span class="koboSpan" id="kobo.861.1"> method is first on our list, and here, we take a timestamp after writing the client request to </span><strong class="source-inline"><span class="koboSpan" id="kobo.862.1">outgoing_ogw_requests_</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.863.1">LFQueue</span></strong><span class="koboSpan" id="kobo.864.1"> with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">T10_TradeEngine_LFQueue_write</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.866.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.867.1">
  auto TradeEngine::sendClientRequest(const
    Exchange::MEClientRequest *client_request) noexcept -&gt; void {
    auto next_write = outgoing_ogw_requests_-&gt;
     getNextToWriteTo();
    *next_write = std::move(*client_request);
    outgoing_ogw_requests_-&gt;updateWriteIndex();
    TTT_MEASURE(T10_TradeEngine_LFQueue_write, logger_);</span></pre>
<p><span class="koboSpan" id="kobo.868.1">The next method on our list is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.869.1">TradeEngine::run()</span></strong><span class="koboSpan" id="kobo.870.1"> method, where the first task is to take a timestamp right after reading a client response from </span><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">incoming_ogw_responses_</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.872.1">LFQueue</span></strong><span class="koboSpan" id="kobo.873.1">, with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">TTT_MEASURE</span></strong><span class="koboSpan" id="kobo.875.1"> macro and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">T9t_TradeEngine_LFQueue_read</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.877.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.878.1">
  auto TradeEngine::run() noexcept -&gt; void {
    while (run_) {
      for (auto client_response = incoming_ogw_responses_-&gt;
        getNextToRead(); client_response; client_response =
          incoming_ogw_responses_-&gt;getNextToRead()) {
        TTT_MEASURE(T9t_TradeEngine_LFQueue_read, logger_);</span></pre>
<p><span class="koboSpan" id="kobo.879.1">We will also take a timestamp measurement right after reading a market update from </span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">incoming_md_updates_</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.881.1">LFQueue</span></strong><span class="koboSpan" id="kobo.882.1"> with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">T9_TradeEngine_LFQueue_read</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.884.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.885.1">
      for (auto market_update = incoming_md_updates_-&gt;
        getNextToRead(); market_update; market_update =
          incoming_md_updates_-&gt;getNextToRead()) {
        TTT_MEASURE(T9_TradeEngine_LFQueue_read, logger_);</span></pre>
<p><span class="koboSpan" id="kobo.886.1">The next method</span><a id="_idIndexMarker1510"/><span class="koboSpan" id="kobo.887.1"> we need to update is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.888.1">TradeEngine::onOrderBookUpdate()</span></strong><span class="koboSpan" id="kobo.889.1"> method, where the first thing we will do is measure the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.890.1">PositionKeeper::updateBBO()</span></strong><span class="koboSpan" id="kobo.891.1">, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.892.1">START_MEASURE</span></strong><span class="koboSpan" id="kobo.893.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.894.1">END_MEASURE</span></strong><span class="koboSpan" id="kobo.895.1"> macros and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">Trading_PositionKeeper_updateBBO</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.897.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.898.1">
  auto TradeEngine::onOrderBookUpdate(TickerId ticker_id,
    Price price, Side side, MarketOrderBook *book) noexcept
    -&gt; void {
    ...
</span><span class="koboSpan" id="kobo.898.2">    START_MEASURE(Trading_PositionKeeper_updateBBO);
    position_keeper_.updateBBO(ticker_id, bbo);
    END_MEASURE(Trading_PositionKeeper_updateBBO, logger_);</span></pre>
<p><span class="koboSpan" id="kobo.899.1">We also need to measure the call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.900.1">FeatureEngine::onOrderBookUpdate()</span></strong><span class="koboSpan" id="kobo.901.1"> method, for which we use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">Trading_FeatureEngine_onOrderBookUpdate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.903.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.904.1">
    START_MEASURE(Trading_FeatureEngine_onOrderBookUpdate);
    feature_engine_.onOrderBookUpdate(ticker_id, price,
      side, book);
    END_MEASURE(Trading_FeatureEngine_onOrderBookUpdate,
      logger_);</span></pre>
<p><span class="koboSpan" id="kobo.905.1">We also need to measure the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.906.1">TradeEngine::algoOnOrderBookUpdate_</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.907.1">std::function</span></strong><span class="koboSpan" id="kobo.908.1">, which calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.909.1">onOrderBookUpdate()</span></strong><span class="koboSpan" id="kobo.910.1"> in either the </span><strong class="source-inline"><span class="koboSpan" id="kobo.911.1">MarketMaker</span></strong><span class="koboSpan" id="kobo.912.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.913.1">LiquidityTaker</span></strong><span class="koboSpan" id="kobo.914.1"> algorithm instance. </span><span class="koboSpan" id="kobo.914.2">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.915.1">START_MEASURE</span></strong><span class="koboSpan" id="kobo.916.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.917.1">END_MEASURE</span></strong><span class="koboSpan" id="kobo.918.1"> macros and use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.919.1">Trading_TradeEngine_algoOnOrderBookUpdate_</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.920.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.921.1">
 START_MEASURE(Trading_TradeEngine_algoOnOrderBookUpdate_);
    algoOnOrderBookUpdate_(ticker_id, price, side, book);
    END_MEASURE(Trading_TradeEngine_algoOnOrderBookUpdate_,
      logger_);</span></pre>
<p><span class="koboSpan" id="kobo.922.1">The next method is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.923.1">TradeEngine::onTradeUpdate()</span></strong><span class="koboSpan" id="kobo.924.1"> method. </span><span class="koboSpan" id="kobo.924.2">Here, the first call we measure</span><a id="_idIndexMarker1511"/><span class="koboSpan" id="kobo.925.1"> is the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.926.1">FeatureEngine::onTradeUpdate()</span></strong><span class="koboSpan" id="kobo.927.1">, to which we assign the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">Trading_FeatureEngine_onTradeUpdate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.929.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.930.1">
  auto TradeEngine::onTradeUpdate(const
    Exchange::MEMarketUpdate *market_update,
      MarketOrderBook *book) noexcept -&gt; void {
    ...
</span><span class="koboSpan" id="kobo.930.2">    START_MEASURE(Trading_FeatureEngine_onTradeUpdate);
    feature_engine_.onTradeUpdate(market_update, book);
    END_MEASURE(Trading_FeatureEngine_onTradeUpdate,
      logger_);</span></pre>
<p><span class="koboSpan" id="kobo.931.1">The other call we will measure</span><a id="_idIndexMarker1512"/><span class="koboSpan" id="kobo.932.1"> is the call using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.933.1">TradeEngine::algoOnTradeUpdate_</span></strong><span class="koboSpan" id="kobo.934.1"> standard function, which will forward it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.935.1">MarketMaker</span></strong><span class="koboSpan" id="kobo.936.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.937.1">LiquidityTaker</span></strong><span class="koboSpan" id="kobo.938.1"> instance. </span><span class="koboSpan" id="kobo.938.2">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.939.1">START_MEASURE</span></strong><span class="koboSpan" id="kobo.940.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.941.1">END_MEASURE</span></strong><span class="koboSpan" id="kobo.942.1"> macros using the tag </span><span class="No-Break"><span class="koboSpan" id="kobo.943.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">Trading_TradeEngine_algoOnTradeUpdate_</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.945.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.946.1">
    START_MEASURE(Trading_TradeEngine_algoOnTradeUpdate_);
    algoOnTradeUpdate_(market_update, book);
    END_MEASURE(Trading_TradeEngine_algoOnTradeUpdate_,
      logger_);</span></pre>
<p><span class="koboSpan" id="kobo.947.1">The final method we have left to add instrumentation to is </span><strong class="source-inline"><span class="koboSpan" id="kobo.948.1">TradeEngine::onOrderUpdate()</span></strong><span class="koboSpan" id="kobo.949.1">. </span><span class="koboSpan" id="kobo.949.2">Here, the first function call that we measure will be the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.950.1">PositionKeeper::addFill()</span></strong><span class="koboSpan" id="kobo.951.1"> using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">Trading_PositionKeeper_addFill</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.953.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.954.1">
  auto TradeEngine::onOrderUpdate(const
    Exchange::MEClientResponse *client_response) noexcept -
     &gt; void {
    if (UNLIKELY(client_response-&gt;type_ ==
      Exchange::ClientResponseType::FILLED)) {
      START_MEASURE(Trading_PositionKeeper_addFill);
      position_keeper_.addFill(client_response);
      END_MEASURE(Trading_PositionKeeper_addFill, logger_);
    }</span></pre>
<p><span class="koboSpan" id="kobo.955.1">Finally, we add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.956.1">START_MEASURE</span></strong><span class="koboSpan" id="kobo.957.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.958.1">END_MEASURE</span></strong><span class="koboSpan" id="kobo.959.1"> macros with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.960.1">Trading_TradeEngine_algoOnOrderUpdate_  </span></strong><span class="koboSpan" id="kobo.961.1">tag around the invocation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.962.1">algoOnOrderUpdate_</span></strong> <span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.963.1">std::function</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.964.1"> object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.965.1">
    START_MEASURE(Trading_TradeEngine_algoOnOrderUpdate_);
    algoOnOrderUpdate_(client_response);
    END_MEASURE(Trading_TradeEngine_algoOnOrderUpdate_,
      logger_);</span></pre>
<p><span class="koboSpan" id="kobo.966.1">We will add some internal</span><a id="_idIndexMarker1513"/><span class="koboSpan" id="kobo.967.1"> measurement code to each of the subcomponents that work with each other inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.968.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.969.1">, starting with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.970.1">OrderManager</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.971.1">component next.</span></span></p>
<h3><span class="koboSpan" id="kobo.972.1">Measuring the latencies inside OrderManager</span></h3>
<p><span class="koboSpan" id="kobo.973.1">The changes to add performance</span><a id="_idIndexMarker1514"/><span class="koboSpan" id="kobo.974.1"> measurement in </span><strong class="source-inline"><span class="koboSpan" id="kobo.975.1">OrderManager</span></strong><span class="koboSpan" id="kobo.976.1"> are the focus</span><a id="_idIndexMarker1515"/><span class="koboSpan" id="kobo.977.1"> of this subsection, and all the code can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.978.1">Chapter11/trading/strategy/order_manager.h</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.979.1">source file.</span></span></p>
<p><span class="koboSpan" id="kobo.980.1">First, we will add measurements to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.981.1">OrderManager::moveOrder()</span></strong><span class="koboSpan" id="kobo.982.1"> method. </span><span class="koboSpan" id="kobo.982.2">The first thing we will measure is the call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.983.1">OrderManager::cancelOrder()</span></strong><span class="koboSpan" id="kobo.984.1"> method using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.985.1">Trading_OrderManager_cancelOrder</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.986.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.987.1">
    auto moveOrder(OMOrder *order, TickerId ticker_id,
      Price price, Side side, Qty qty) noexcept {
      switch (order-&gt;order_state_) {
        case OMOrderState::LIVE: {
          if(order-&gt;price_ != price) {
           START_MEASURE(Trading_OrderManager_cancelOrder);
            cancelOrder(order);
            END_MEASURE(Trading_OrderManager_cancelOrder,
              (*logger_));</span></pre>
<p><span class="koboSpan" id="kobo.988.1">We will also measure</span><a id="_idIndexMarker1516"/><span class="koboSpan" id="kobo.989.1"> the call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.990.1">RiskManager</span></strong><span class="koboSpan" id="kobo.991.1"> component, specifically</span><a id="_idIndexMarker1517"/><span class="koboSpan" id="kobo.992.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.993.1">checkPreTradeRisk()</span></strong><span class="koboSpan" id="kobo.994.1"> call. </span><span class="koboSpan" id="kobo.994.2">We will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.995.1">START_MEASURE</span></strong><span class="koboSpan" id="kobo.996.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.997.1">END_MEASURE</span></strong><span class="koboSpan" id="kobo.998.1"> macros with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.999.1">Trading_RiskManager_checkPreTradeRisk</span></strong><span class="koboSpan" id="kobo.1000.1"> tag around the risk check, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1001.1">shown next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1002.1">
        case OMOrderState::DEAD: {
          if(LIKELY(price != Price_INVALID)) {
            START_MEASURE(Trading_RiskManager_checkPreTrade
Risk);
            const auto risk_result =
              risk_manager_.checkPreTradeRisk(ticker_id,
                side, qty);
            END_MEASURE(Trading_RiskManager_checkPreTradeRi
sk,
  (*logger_));</span></pre>
<p><span class="koboSpan" id="kobo.1003.1">Another thing to measure is the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1004.1">OrderManager::newOrder()</span></strong><span class="koboSpan" id="kobo.1005.1"> if the risk check succeeds, and we will assign the measurement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1006.1">Trading_OrderManager_newOrder</span></strong><span class="koboSpan" id="kobo.1007.1"> tag, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1008.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1009.1">
            if(LIKELY(risk_result ==
              RiskCheckResult::ALLOWED)) {
              START_MEASURE(Trading_OrderManager_newOrder);
              newOrder(order, ticker_id, price, side, qty);
              END_MEASURE(Trading_OrderManager_newOrder,
                (*logger_));</span></pre>
<p><span class="koboSpan" id="kobo.1010.1">The other method in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1011.1">OrderManager</span></strong><span class="koboSpan" id="kobo.1012.1"> to which we will add</span><a id="_idIndexMarker1518"/><span class="koboSpan" id="kobo.1013.1"> measurements is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1014.1">moveOrders()</span></strong><span class="koboSpan" id="kobo.1015.1"> method, and there we</span><a id="_idIndexMarker1519"/><span class="koboSpan" id="kobo.1016.1"> will enclose the calls to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1017.1">OrderManager::moveOrder()</span></strong><span class="koboSpan" id="kobo.1018.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1019.1">START_MEASURE</span></strong><span class="koboSpan" id="kobo.1020.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1021.1">END_MEASURE</span></strong><span class="koboSpan" id="kobo.1022.1"> and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1023.1">Trading_OrderManager_moveOrder</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1024.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1025.1">
    auto moveOrders(TickerId ticker_id, Price bid_price,
      Price ask_price, Qty clip) noexcept {
        ...
</span><span class="koboSpan" id="kobo.1025.2">        START_MEASURE(Trading_OrderManager_moveOrder);
        moveOrder(bid_order, ticker_id, bid_price,
          Side::BUY, clip);
        END_MEASURE(Trading_OrderManager_moveOrder,
          (*logger_));
        ...
</span><span class="koboSpan" id="kobo.1025.3">        START_MEASURE(Trading_OrderManager_moveOrder);
        moveOrder(ask_order, ticker_id, ask_price,
          Side::SELL, clip);
        END_MEASURE(Trading_OrderManager_moveOrder,
          (*logger_));</span></pre>
<p><span class="koboSpan" id="kobo.1026.1">The next subcomponent in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1027.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.1028.1"> class that we need to update </span><span class="No-Break"><span class="koboSpan" id="kobo.1029.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1030.1">MarketOrderBook</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1031.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.1032.1">Measuring the latencies inside MarketOrderBook</span></h3>
<p><span class="koboSpan" id="kobo.1033.1">The changes and full</span><a id="_idIndexMarker1520"/><span class="koboSpan" id="kobo.1034.1"> source for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1035.1">MarketOrderBook</span></strong><span class="koboSpan" id="kobo.1036.1"> can be found</span><a id="_idIndexMarker1521"/><span class="koboSpan" id="kobo.1037.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1038.1">Chapter11/trading/strategy/market_order_book.cpp</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1039.1">source file.</span></span></p>
<p><span class="koboSpan" id="kobo.1040.1">First, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1041.1">MarketOrderBook::onMarketUpdate()</span></strong><span class="koboSpan" id="kobo.1042.1"> method and the case for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1043.1">MarketUpdateType::ADD</span></strong><span class="koboSpan" id="kobo.1044.1"> message, we will measure the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1045.1">MarketOrderBook::addOrder()</span></strong><span class="koboSpan" id="kobo.1046.1">. </span><span class="koboSpan" id="kobo.1046.2">This is achieved as usual by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1047.1">START_MEASURE</span></strong><span class="koboSpan" id="kobo.1048.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1049.1">END_MEASURE</span></strong><span class="koboSpan" id="kobo.1050.1"> macros with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1051.1">Trading_MarketOrderBook_addOrder</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1052.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1053.1">
  auto MarketOrderBook::onMarketUpdate(const
    Exchange::MEMarketUpdate *market_update) noexcept -&gt;
void {
    ...
</span><span class="koboSpan" id="kobo.1053.2">    switch (market_update-&gt;type_) {
      case Exchange::MarketUpdateType::ADD: {
        auto order = order_pool_.allocate(market_update-&gt;
          order_id_, market_update-&gt;side_, market_update-&gt;
            price_,
                                          market_update-&gt;
                                            qty_,
                                     market_update-
                                       &gt;priority_, nullptr,
                                         nullptr);
        START_MEASURE(Trading_MarketOrderBook_addOrder);
        addOrder(order);
        END_MEASURE(Trading_MarketOrderBook_addOrder,
          (*logger_));</span></pre>
<p><span class="koboSpan" id="kobo.1054.1">To measure the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1055.1">MarketOrderBook::removeOrder()</span></strong><span class="koboSpan" id="kobo.1056.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1057.1">MarketUpdateType::CANCEL</span></strong><span class="koboSpan" id="kobo.1058.1"> case, we will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1059.1">Trading_MarketOrderBook_removeOrder</span></strong><span class="koboSpan" id="kobo.1060.1"> tag in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1061.1">START _MEASURE</span></strong><span class="koboSpan" id="kobo.1062.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1063.1">END_MEASURE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1064.1"> macros:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1065.1">
      case Exchange::MarketUpdateType::CANCEL: {
        auto order = oid_to_order_.at(market_update-
          &gt;order_id_);
        START_MEASURE(Trading_MarketOrderBook_removeOrder);
        removeOrder(order);
        END_MEASURE(Trading_MarketOrderBook_removeOrder,
          (*logger_));</span></pre>
<p><span class="koboSpan" id="kobo.1066.1">Finally, we will add a measurement </span><a id="_idIndexMarker1522"/><span class="koboSpan" id="kobo.1067.1">around the call</span><a id="_idIndexMarker1523"/><span class="koboSpan" id="kobo.1068.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1069.1">MarketOrderBook::updateBBO()</span></strong><span class="koboSpan" id="kobo.1070.1"> and assign it the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1071.1">Trading_MarketOrderBook_updateBBO</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1072.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1073.1">
    START_MEASURE(Trading_MarketOrderBook_updateBBO);
    updateBBO(bid_updated, ask_updated);
    END_MEASURE(Trading_MarketOrderBook_updateBBO,
      (*logger_));</span></pre>
<p><span class="koboSpan" id="kobo.1074.1">The next component to measure is one of the trading algorithms – the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1075.1">LiquidityTaker</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1076.1"> algorithm.</span></span></p>
<h3><span class="koboSpan" id="kobo.1077.1">Measuring the latencies inside the LiquidityTaker algorithm</span></h3>
<p><span class="koboSpan" id="kobo.1078.1">The changes we discuss</span><a id="_idIndexMarker1524"/><span class="koboSpan" id="kobo.1079.1"> here, as well as the full </span><a id="_idIndexMarker1525"/><span class="koboSpan" id="kobo.1080.1">source code, are in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1081.1">Chapter11/trading/strategy/liquidity_taker.h</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1082.1">source file.</span></span></p>
<p><span class="koboSpan" id="kobo.1083.1">Our first measurement is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1084.1">onTradeUpdate()</span></strong><span class="koboSpan" id="kobo.1085.1"> method for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1086.1">LiquidityTaker</span></strong><span class="koboSpan" id="kobo.1087.1"> class. </span><span class="koboSpan" id="kobo.1087.2">When the signal initiates a trade, we measure the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1088.1">OrderManager::moveOrders()</span></strong><span class="koboSpan" id="kobo.1089.1"> and assign it the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1090.1">OrderManager_moveOrders</span></strong><span class="koboSpan" id="kobo.1091.1"> tag, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1092.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1093.1">
    auto onTradeUpdate(const Exchange::MEMarketUpdate
      *market_update, MarketOrderBook *book) noexcept -&gt;
void {
        ...
</span><span class="koboSpan" id="kobo.1093.2">        if (agg_qty_ratio &gt;= threshold) {
          START_MEASURE(OrderManager_moveOrders);
          if (market_update-&gt;side_ == Side::BUY)
            order_manager_-&gt;moveOrders(market_update-&gt;
              ticker_id_, bbo-&gt;ask_price_, Price_INVALID,
                clip);
          else
            order_manager_-&gt;moveOrders(market_update-&gt;
              ticker_id_, Price_INVALID, bbo-&gt;bid_price_,
                clip);
          END_MEASURE(OrderManager_moveOrders, (*logger_));
        }</span></pre>
<p><span class="koboSpan" id="kobo.1094.1">The other call we want</span><a id="_idIndexMarker1526"/><span class="koboSpan" id="kobo.1095.1"> to measure is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1096.1">onOrderUpdate()</span></strong><span class="koboSpan" id="kobo.1097.1"> method and measures</span><a id="_idIndexMarker1527"/><span class="koboSpan" id="kobo.1098.1"> the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1099.1">OrderManager::onOrderUpdate()</span></strong><span class="koboSpan" id="kobo.1100.1"> using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1101.1">START_MEASURE</span></strong><span class="koboSpan" id="kobo.1102.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1103.1">END_MEASURE</span></strong><span class="koboSpan" id="kobo.1104.1"> macros and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1105.1">Trading_OrderManager_onOrderUpdate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1106.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1107.1">
    auto onOrderUpdate(const Exchange::MEClientResponse
      *client_response) noexcept -&gt; void {
      START_MEASURE(Trading_OrderManager_onOrderUpdate);
      order_manager_-&gt;onOrderUpdate(client_response);
      END_MEASURE(Trading_OrderManager_onOrderUpdate,
        (*logger_));</span></pre>
<p><span class="koboSpan" id="kobo.1108.1">Finally, we are down to our last component for this chapter, updating the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1109.1">MarketMaker</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1110.1"> algorithm.</span></span></p>
<h3><span class="koboSpan" id="kobo.1111.1">Measuring the latencies inside the MarketMaker algorithm</span></h3>
<p><span class="koboSpan" id="kobo.1112.1">The changes</span><a id="_idIndexMarker1528"/><span class="koboSpan" id="kobo.1113.1"> and the full source</span><a id="_idIndexMarker1529"/><span class="koboSpan" id="kobo.1114.1"> code for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1115.1">MarketMaker</span></strong><span class="koboSpan" id="kobo.1116.1"> are in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1117.1">Chapter11/trading/strategy/market_maker.h</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1118.1">source file.</span></span></p>
<p><span class="koboSpan" id="kobo.1119.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1120.1">MarketMaker::onOrderBookUpdate()</span></strong><span class="koboSpan" id="kobo.1121.1"> method contains the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1122.1">OrderManager::moveOrders()</span></strong><span class="koboSpan" id="kobo.1123.1">, which is what we measure in the next code block with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1124.1">Trading_OrderManager_moveOrders</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1125.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1126.1">
    auto onOrderBookUpdate(TickerId ticker_id, Price price,
      Side side, const MarketOrderBook *book) noexcept -&gt;
void {
        ...
</span><span class="koboSpan" id="kobo.1126.2">        START_MEASURE(Trading_OrderManager_moveOrders);
        order_manager_-&gt;moveOrders(ticker_id, bid_price,
          ask_price, clip);
        END_MEASURE(Trading_OrderManager_moveOrders,
          (*logger_));</span></pre>
<p><span class="koboSpan" id="kobo.1127.1">The other method, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1128.1">MarketMaker::onOrderUpdate()</span></strong><span class="koboSpan" id="kobo.1129.1">, contains the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1130.1">OrderManager::onOrderUpdate()</span></strong><span class="koboSpan" id="kobo.1131.1">, which we also measure and to which we will assign the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1132.1">Trading_OrderManager_onOrderUpdate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1133.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1134.1">
    auto onOrderUpdate(const Exchange::MEClientResponse
      *client_response) noexcept -&gt; void {
      ...
</span><span class="koboSpan" id="kobo.1134.2">      START_MEASURE(Trading_OrderManager_onOrderUpdate);
      order_manager_-&gt;onOrderUpdate(client_response);
      END_MEASURE(Trading_OrderManager_onOrderUpdate,
        (*logger_));</span></pre>
<p><span class="koboSpan" id="kobo.1135.1">This concludes all the performance</span><a id="_idIndexMarker1530"/><span class="koboSpan" id="kobo.1136.1"> measurement and timestamping-related</span><a id="_idIndexMarker1531"/><span class="koboSpan" id="kobo.1137.1"> changes across our entire electronic trading ecosystem. </span><span class="koboSpan" id="kobo.1137.2">We will very quickly look at how to run the ecosystem with all the changes we made so far and what differences we find in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1138.1">log files.</span></span></p>
<h1 id="_idParaDest-295"><a id="_idTextAnchor308"/><span class="koboSpan" id="kobo.1139.1">Running the entire ecosystem with the new instrumentation system</span></h1>
<p><span class="koboSpan" id="kobo.1140.1">Running the updated electronic trading ecosystem remains</span><a id="_idIndexMarker1532"/><span class="koboSpan" id="kobo.1141.1"> the same as before </span><a id="_idIndexMarker1533"/><span class="koboSpan" id="kobo.1142.1">and is launched by running the </span><span class="No-Break"><span class="koboSpan" id="kobo.1143.1">following script:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1144.1">
sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter11$ bash scripts/run_exchange_and_clients.sh</span></pre>
<p><span class="koboSpan" id="kobo.1145.1">Once the new ecosystem is done running, you can notice performance measurement log entries such as the following for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1146.1">RDTSC measurements:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1147.1">
sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter11$ grep Exchange_MEOrderBook_match *.log
exchange_matching_engine.log:02:42:59.980424597 RDTSC Exchange_MEOrderBook_match 205247
exchange_matching_engine.log:02:43:00.022326352 RDTSC Exchange_MEOrderBook_match 216239</span></pre>
<p><span class="koboSpan" id="kobo.1148.1">There are also entries such as the following for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1149.1">RDTSC measurements:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1150.1">
sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter11$ grep Trading_MarketOrderBook_addOrder *.log
trading_engine_1.log:02:44:18.894251975 RDTSC Trading_MarketOrderBook_addOrder 204
trading_engine_1.log:02:44:18.904221378 RDTSC Trading_MarketOrderBook_addOrder 971</span></pre>
<p><span class="koboSpan" id="kobo.1151.1">There are entries such as the following for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1152.1">TTT measurements:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1153.1">
sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter11$ grep T6_MarketDataPublisher_UDP_write *.log
exchange_market_data_publisher.log:02:40:13.596201293 TTT T6_MarketDataPublisher_UDP_write 1685864413596201240
exchange_market_data_publisher.log:02:40:13.624236967 TTT T6_MarketDataPublisher_UDP_write 1685864413624236907</span></pre>
<p><span class="koboSpan" id="kobo.1154.1">And there are also entries</span><a id="_idIndexMarker1534"/><span class="koboSpan" id="kobo.1155.1"> such as the following </span><a id="_idIndexMarker1535"/><span class="koboSpan" id="kobo.1156.1">for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1157.1">TTT measurements:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1158.1">
sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter11$ grep T8t_OrderGateway_LFQueue_write *.log
trading_order_gateway_1.log:02:40:14.524401434 TTT T8t_OrderGateway_LFQueue_write 1685864414524401386
trading_order_gateway_1.log:02:40:14.524425862 TTT T8t_OrderGateway_LFQueue_write 1685864414524425811</span></pre>
<p><span class="koboSpan" id="kobo.1159.1">We will revisit this performance data in the next chapter, but we have now finished </span><span class="No-Break"><span class="koboSpan" id="kobo.1160.1">this chapter.</span></span></p>
<h1 id="_idParaDest-296"><a id="_idTextAnchor309"/><span class="koboSpan" id="kobo.1161.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1162.1">This chapter was dedicated completely to measuring the performance of our electronic trading ecosystem. </span><span class="koboSpan" id="kobo.1162.2">First, we built a system to measure and compare the latency incurred due to the execution of any arbitrary code block. </span><span class="koboSpan" id="kobo.1162.3">We also built a system to generate nanosecond-level timestamps when notable events occur. </span><span class="koboSpan" id="kobo.1162.4">We also discussed the motivation behind the design of these systems as well as various important points to keep in mind when using these performance </span><span class="No-Break"><span class="koboSpan" id="kobo.1163.1">measurement techniques.</span></span></p>
<p><span class="koboSpan" id="kobo.1164.1">The next section was dedicated to understanding the design and motivation of performance measurements within the various components and subcomponents on the electronic exchange’s end. </span><span class="koboSpan" id="kobo.1164.2">We then built and updated all the source code in the exchange to add the performance measurement and </span><span class="No-Break"><span class="koboSpan" id="kobo.1165.1">timestamping code.</span></span></p>
<p><span class="koboSpan" id="kobo.1166.1">After we finished the discussion and implementation of performance measurement within the electronic exchange, we performed similar measurements in the trading system. </span><span class="koboSpan" id="kobo.1166.2">Finally, we concluded the chapter by running this updated ecosystem and observing the new log entries from the performance </span><span class="No-Break"><span class="koboSpan" id="kobo.1167.1">measurement system.</span></span></p>
<p><span class="koboSpan" id="kobo.1168.1">In the next and concluding chapter, we will analyze this performance data in detail, discuss our findings, and discuss how to optimize </span><span class="No-Break"><span class="koboSpan" id="kobo.1169.1">the performance.</span></span></p>
</div>
</body></html>