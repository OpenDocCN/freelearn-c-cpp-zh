["```cpp\nUPROPERTY(Replicated, EditAnywhere)\nuint32 JumpCount;\n\nvoid Jump() override;\n```", "```cpp\n#include \"UnrealNetwork.h\" // DOREPLIFETIME\n```", "```cpp\nvoid AChapter_12Character::SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent)\n{\n  // Set up gameplay key bindings\n  check(PlayerInputComponent);\n PlayerInputComponent->BindAction(\"Jump\", IE_Pressed, this, &AChapter_12Character::Jump);\n  PlayerInputComponent->BindAction(\"Jump\", IE_Released, this, &ACharacter::StopJumping);\n\n  ...\n```", "```cpp\nvoid AChapter_12Character::Jump()\n{\n    Super::Jump();\n\n    JumpCount++;\n\n    if (Role == ROLE_Authority)\n    {\n        // Only print function once\n        GEngine->AddOnScreenDebugMessage(-1, 5.0f,\n            FColor::Green,\n            FString::Printf(TEXT(\"%s called Jump %d times!\"),\n            *GetName(), JumpCount)\n        );\n    }\n\n}\n\nvoid AChapter_12Character::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>&\n    OutLifetimeProps) const\n{\n    Super::GetLifetimeReplicatedProps(OutLifetimeProps);\n\n    // Replicate to every client\n    //DOREPLIFETIME(AChapter_12Character, JumpCount);\n}\n```", "```cpp\nvoid AChapter_12Character::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>&\n    OutLifetimeProps) const\n{\n    Super::GetLifetimeReplicatedProps(OutLifetimeProps);\n\n    // Replicate to every client\n    //DOREPLIFETIME(AChapter_12Character, JumpCount);\n\n // Value is already updated locally, so we can skip replicating \n    // the value for the owner\n DOREPLIFETIME_CONDITION(AChapter_12Character, JumpCount, COND_SkipOwner);\n}\n```", "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"CollectibleObject.generated.h\"\n\nUCLASS()\nclass CHAPTER_12_API ACollectibleObject : public AActor\n{\n    GENERATED_BODY()\n\npublic: \n    // Sets default values for this actor's properties\n    ACollectibleObject();\n\n // Event called when something starts to overlaps the\n // sphere collider\n // Note: UFUNCTION required for replication callbacks\n UFUNCTION() \n void OnBeginOverlap(class UPrimitiveComponent*\n HitComp, \n class AActor* OtherActor,\n class UPrimitiveComponent*\n OtherComp,\n int32 OtherBodyIndex, bool\n bFromSweep,\n const FHitResult& SweepResult);\n\n // Our server function to update the score.\n UFUNCTION(Reliable, Server, WithValidation)\n void UpdateScore(int32 Amount);\n\n void UpdateScore_Implementation(int32 Amount);\n bool UpdateScore_Validate(int32 Amount);\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic: \n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n};\n```", "```cpp\n#include \"ConstructorHelpers.h\"\n#include \"Components/SphereComponent.h\"\n\n// ...\n\n// Sets default values\nACollectibleObject::ACollectibleObject()\n{\n   // Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n  PrimaryActorTick.bCanEverTick = true;\n\n    // Must be true for an Actor to replicate anything\n bReplicates = true;\n\n // Create a sphere collider for players to hit\n USphereComponent * SphereCollider = CreateDefaultSubobject<USphereComponent>(TEXT(\"SphereComponent\"));\n\n // Sets the root of our object to be the sphere collider\n RootComponent = SphereCollider;\n\n // Sets the size of our collider to have a radius of\n // 64 units\n SphereCollider->InitSphereRadius(64.0f);\n\n // Makes it so that OnBeginOverlap will be called\n // whenever something hits this.\n SphereCollider->OnComponentBeginOverlap.AddDynamic(this, &ACollectibleObject::OnBeginOverlap);\n\n // Create a visual to make it easier to see\n UStaticMeshComponent * SphereVisual = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"Static Mesh\"));\n\n // Attach the static mesh to the root\n SphereVisual->SetupAttachment(RootComponent);\n\n // Get a reference to a sphere mesh\n auto MeshAsset = ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT(\"StaticMesh'/Engine/BasicShapes/Sphere.Sphere'\"));\n\n // Assign the mesh if valid\n if (MeshAsset.Object != nullptr)\n {\n SphereVisual->SetStaticMesh(MeshAsset.Object);\n }\n\n // Resize to be smaller than the larger sphere collider\n SphereVisual->SetWorldScale3D(FVector(0.5f));\n\n}\n```", "```cpp\n// Event called when something starts to overlaps the\n// sphere collider\nvoid ACollectibleObject::OnBeginOverlap(\n    class UPrimitiveComponent* HitComp,\n    class AActor* OtherActor,\n    class UPrimitiveComponent* OtherComp,\n    int32 OtherBodyIndex,\n    bool bFromSweep,\n    const FHitResult& SweepResult)\n{\n    // If I am the server\n    if (Role == ROLE_Authority)\n    {\n        // Then a coin will be gained!\n        UpdateScore(1);\n        Destroy();\n    }\n}\n```", "```cpp\n// Do something here that modifies game state.\nvoid ACollectibleObject::UpdateScore_Implementation(int32\n    Amount)\n{\n    if (GEngine)\n    {\n        GEngine->AddOnScreenDebugMessage(-1, 5.0f,\n            FColor::Green,\n            \"Collected!\");\n    }\n}\n\n// Optionally validate the request and return false if the\n// function should not be run.\nbool ACollectibleObject::UpdateScore_Validate(int32 Amount)\n{\n    return true;\n}\n```", "```cpp\nusing UnrealBuildTool;\n\npublic class Chapter_12 : ModuleRules\n{\n  public Chapter_12(ReadOnlyTargetRules Target) : base(Target)\n  {\n    PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;\n\n    PublicDependencyModuleNames.AddRange(new string[] { \"Core\", \"CoreUObject\", \"Engine\", \"InputCore\", \"HeadMountedDisplay\" });\n\n        PrivateDependencyModuleNames.AddRange(new string[] { \"Slate\", \"SlateCore\" });\n    }\n}\n```", "```cpp\n#include \"Chapter_12GameMode.h\"\n#include \"Chapter_12Character.h\"\n#include \"NetworkHUD.h\"\n#include \"UObject/ConstructorHelpers.h\"\n\nAChapter_12GameMode::AChapter_12GameMode()\n{\n  // set default pawn class to our Blueprinted character\n  static ConstructorHelpers::FClassFinder<APawn> PlayerPawnBPClass(TEXT(\"/Game/ThirdPersonCPP/Blueprints/ThirdPersonCharacter\"));\n  if (PlayerPawnBPClass.Class != NULL)\n  {\n    DefaultPawnClass = PlayerPawnBPClass.Class;\n  }\n\n HUDClass = ANetworkHUD::StaticClass();\n}\n```", "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/HUD.h\"\n#include \"NetworkHUD.generated.h\"\n\n/**\n * \n */\nUCLASS()\nclass CHAPTER_12_API ANetworkHUD : public AHUD\n{\n    GENERATED_BODY()\n\npublic:\n    virtual void DrawHUD() override;\n};\n```", "```cpp\n#include \"NetworkHUD.h\"\n#include \"Engine/Canvas.h\"\n#include \"Chapter_12Character.h\"\n\nvoid ANetworkHUD::DrawHUD()\n{\n Super::DrawHUD();\n\n AChapter_12Character* PlayerCharacter = Cast<AChapter_12Character>(GetOwningPawn());\n\n if(PlayerCharacter)\n {\n Canvas->DrawText(GEngine->GetMediumFont(), FString::Printf(TEXT(\"Called Jump %d times!\"), PlayerCharacter->JumpCount), 10, 10);\n }\n}\n```", "```cpp\nvoid AChapter_12Character::Jump()\n{\n    Super::Jump();\n\n    JumpCount++;\n\n //if (Role == ROLE_Authority)\n //{\n // // Only print function once\n // GEngine->AddOnScreenDebugMessage(-1, 5.0f,\n // FColor::Green,\n // FString::Printf(TEXT(\"%s called Jump %d times!\"), *GetName(), JumpCount));\n //}\n}\n```"]