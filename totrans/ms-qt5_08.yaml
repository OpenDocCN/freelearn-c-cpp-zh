- en: Chapter 8.  Animations - Its Alive, Alive!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how to create a custom Qt Designer plugin.
    This chapter will push things further and teach you how to create a distributable
    Software Development Kit (SDK) to third-party developers, how the plugin system
    works with Qt, and how to make your application more attractive using fancy animations.
  prefs: []
  type: TYPE_NORMAL
- en: The example project will be a reimplementation of the project from [Chapter
    7](part0071.xhtml#aid-23MNU1 "Chapter 7.  Third-Party Libraries Without a Headache"), *Third-Party
    Libraries Without a Headache*. You will build the same image processing application,
    but with the ability to import the filters from plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will teach you how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an SDK using the Qt Plugin system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement custom plugins using the SDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Factorize build tasks using `.pri`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically load plugins in your final application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the Qt Animation framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use simple, sequential, and parallel animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply custom effects using `QPropertyAnimation` and `QGraphics` effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing an SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before diving into the code, we have to take a moment to reflect on how we
    are going to structure it. This chapter has two goals:'
  prefs: []
  type: TYPE_NORMAL
- en: Cover the Qt Plugin system in more depth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Study and integrate the Qt Animation Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first part of the chapter will focus on the plugin system. What we aim to
    do is provide a way to build plugins that can be integrated in our application
    to third-party developers. These plugins should be dynamically loaded. The application
    will be a direct offspring of the example project from [Chapter 7](part0071.xhtml#aid-23MNU1
    "Chapter 7.  Third-Party Libraries Without a Headache"), *Third-Party Libraries
    Without a Headache*. The features will be exactly the same, except it will be
    using this new plugin system and will have fancy animations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure of the project will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing an SDK](img/image00416.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The parent project is `ch08-image-animation`, which is composed of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`filter-plugin-original`: A library project, which is the implementation of
    the original filter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter-plugin-grayscale`: A library project, which is the implementation of
    the grayscale filter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter-plugin-blur`: A library project, which is the implementation of the
    blur filter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image-animation`: A Qt Widgets application, which will load the plugins needed
    to display them and make it possible to apply each one to a loaded picture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will develop each one of these plugins, but keep in mind that they might
    have been created by a third-party developer. To achieve this openness, an SDK
    will be available for each plugin. This SDK relies on the Qt Plugin system.
  prefs: []
  type: TYPE_NORMAL
- en: It is crucial to think about what should be handled by the plugin. Our application
    is an image processing piece of software. We chose to limit the responsibility
    of the plugin to the picture processing part, but this is definitely a design
    choice.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach could have been to let the plugin developer provide its own
    UI to configure the plugin (for example, to vary the intensity of the blur). In
    this chapter, we have kept it simple by focusing only on the plugin development
    itself. It is really up to you and how you want to design your application. By
    opening up the range of what the plugin can do, you also increase the burden for
    the plugin developer. There is always a trade-off; giving more choice tends to
    increase the complexity. It is a well-known fact that we developers are a bunch
    of lazy people. At least, we want to be lazy while the computer is working for
    us.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by building the SDK that will be deployed in each plugin. Execute
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Subdirs project** named `ch08-image-animation` (do not add a sub-project
    at the end of the wizard).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your filesystem explorer, open the `ch08-image-animation` directory and create
    an `sdk` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside `sdk`, create an empty `Filter.h` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our SDK will consist of a single file, `Filter.h`, the interface (or header)
    that should be implemented with each plugin. Each plugin is responsible for returning
    the modified picture according to its desired features. Because this SDK is not
    linked to any particular project, we will simply display it in Qt Creator under
    the special folder **Other files**. To do so, update `ch08-image-animation.pro`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After `ch08-image-animation.pro` has been parsed by Qt Creator, you should
    see the following in the **Projects** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing an SDK](img/image00417.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `Filter.h` file is available at the parent project level. As a result,
    it will be easier to factorize the SDK plumbing code between our various plugins.
    Let''s implement `Filter.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down this interface: a `Filter` subclass must provide a name by
    implementing `name()` and returning a processed image when implementing `process()`.
    As you can see, `Filter.h` is indeed very close to the version seen in [Chapter
    7](part0071.xhtml#aid-23MNU1 "Chapter 7.  Third-Party Libraries Without a Headache"), *Third-Party
    Libraries Without a Headache*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the really new stuff comes right after the class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `Filter_iid` is a unique identifier to let Qt know the interface name. This
    will be enforced on the implementer side, which will also have to state this identifier.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a real-world use case, you should add a version number to this unique identifier.
    This will let you properly handle the versioning of your SDK and the attached
    plugins.
  prefs: []
  type: TYPE_NORMAL
- en: The `Q_DECLARE_INTERFACE` macro associates the class to the given identifier.
    It will give Qt the ability to check that the loaded plugin can be safely casted
    to the `Filter` type.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In production code, it is safer to declare your interfaces inside a namespace.
    You never know the code environment in which your SDK will be deployed. This,
    way, you avoid potential name collision. If you do declare in a namespace, make
    sure that the `Q_DECLARE_INTERFACE` macro is outside the namespace scope.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The SDK was painless to create. We can now proceed to create our first plugin.
    We already know that all our plugins will include the SDK we just completed. Fortunately,
    this can be easily factorized in a `.pri` file (PRoject Include). A `.pri` file
    behaves exactly like a `.pro` file; the only difference is that it is intended
    to be included inside `.pro` files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ch08-image-animation` directory, create a file named `plugins-common.pri`
    that contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This file will be included in each `.pro` plugin. It aims to tell the compiler
    where it can find the headers of the SDK and where to look to resolve dependencies
    between headers and sources. This will enhance the modification detection and
    properly compile the sources when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this file in the project, we have to add it to the `OTHER_FILES` macro
    in `ch08-image-animation.pro`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The most straightforward plugin to build is `filter-plugin-original` as it
    does not perform any specific processing on the image. Let''s create this plugin
    with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **Subproject** in `ch08-image-animation`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Library** | **C++ Library** | **Choose...**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose a **Shared Library**, name it `filter-plugin-original`, and then click
    on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **QtCore** and go to **QtWidgets** | **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the created class `FilterOriginal` and click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add it as a **subproject** to `ch08-image-animation` then click on **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Qt Creator creates a lot of boilerplate code for us, but in this case, we do
    not need it. Update `filter-plugin-original.pro` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We start by specifying that the `TARGET` should be properly named according
    to the OS convention with `$$qtLibraryTarget()`. The `CONFIG` property adds the `plugin`
    directive, which tells the generated `Makefile` to include the necessary instructions
    to compile a dll/so/dylib (pick your OS).
  prefs: []
  type: TYPE_NORMAL
- en: We removed the unnecessary `DEFINES` and `FilterOriginal_global.h`. Nothing
    specific to the plugin should be exposed to the caller, and therefore, there is
    no need to handle the symbol export.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now proceed to `FilterOriginal.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `FilterOriginal` class must first inherit `QObject`; when the plugin will
    be loaded, it will first be a `QObject` class before being casted to the real
    type, `Filter`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Q_PLUGIN_METADATA` macro is stated to export the proper implemented interface
    identifier to Qt. It annotates the class to let the Qt metasystem know about it.
    We meet the unique identifier we defined in `Filter.h` again.
  prefs: []
  type: TYPE_NORMAL
- en: The `Q_INTERFACES` macro tells the Qt metaobject system which interface the
    class implements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `FilterOriginal.cpp` barely deserves to be printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, its implementation is a no-op. The only thing we added to the
    version from [Chapter 7](part0071.xhtml#aid-23MNU1 "Chapter 7.  Third-Party Libraries
    Without a Headache"), *Third-Party Libraries Without a Headache*, is the `name()`
    function, which returns `Original`.
  prefs: []
  type: TYPE_NORMAL
- en: We will now implement the grayscale filter. As we did in [Chapter 7](part0071.xhtml#aid-23MNU1
    "Chapter 7.  Third-Party Libraries Without a Headache"), *Third-Party Libraries
    Without a Headache*, we will rely on the OpenCV library to process the picture.
    The same can be said for the following plugin, the blur.
  prefs: []
  type: TYPE_NORMAL
- en: Since these two projects have their own `.pro` file, you can already foresee
    that the OpenCV linking will be the same. This is a perfect use-case for a `.pri`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `ch08-image-animation` directory, create a new file called `plugins-common-opencv.pri`.
    Do not forget to add it to `OTHER_FILES` in `ch08-image-animation.pro`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the content of `plugins-common-opencv.pri`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The content of `plugins-common-opencv.pri` is a direct copy of what we made
    in [Chapter 7](part0071.xhtml#aid-23MNU1 "Chapter 7.  Third-Party Libraries Without
    a Headache"), *Third-Party Libraries Without a Headache*.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the plumbing is now ready; we can now go ahead with the `filter-plugin-grayscale`
    project. As with `filter-plugin-original`, we will build it the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **C++ Library Subproject** of `ch08-image-animation` with the **Shared
    Library** type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a class named `FilterGrayscale`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Required Modules**, select **QtCore** and **QWidgets**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the updated version of `filter-plugin-grayscale.pro`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The content is very much like `filter-plugin-original.pro`. We only added `plugins-common-opencv.pri`
    to let our plugin link with OpenCV.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for `FilterGrayscale`, the header is exactly like `FilterOriginal.h`. Here
    are the relevant pieces on `FilterGrayscale.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The inclusion of `plugins-common-opencv.pri` lets us properly include the `cv.h`
    header.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last plugin we will implement is the blur plugin. Once again, create a
    **C++ Library ** **Subproject** and create the `FilterBlur` class. The project
    structure and the content of the `.pro` file are the same. Here is `FilterBlur.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The amount of blur is hard-coded at `17`. In a production application, it could
    have been compelling to make this amount variable from the application.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to push the project further, try to include a layout in the SDK
    that contains a way to configure the plugin properties.
  prefs: []
  type: TYPE_NORMAL
- en: Loading your plugins dynamically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now deal with the application loading these plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **Subproject** inside `ch08-image-animation`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the type **Qt Widgets Application**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it `image-animation` and accept the default **Class Information settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have a few last things to do in the `.pro` files. First, `image-animation`
    will try to load the plugins from somewhere in its output directory. Because each
    filter plugin project is independent, its output directory is separated from `image-animation`.
    Thus, each time you modify a plugin, you will have to copy yourself the compiled
    shared library inside the proper `image-animation` directory. This works to make
    it available to the `image-animation` application, but we are lazy developers,
    right?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can automate this by updating `plugins-common-pri` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In a nutshell, the output library is deployed in the output `image-animation/plugins`
    directory. Windows has a different output project structure; that is why we have
    to have a platform-specific section.
  prefs: []
  type: TYPE_NORMAL
- en: Even better, the `plugins` directory is automatically created with the instruction `createPluginsDir.commands
    = $$QMAKE_MKDIR_CMD $$createPluginsDir.path`. Instead of using a system command
    (`mkdir`), we have to use the special `$$QMAKE_MKDIR_CMD` command. Qt will then
    replace it with the correct shell command (depending on your OS) to create the
    directory only if it does not already exist. Do not forget to add the `make install`
    build step to execute this task!
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing to do in the `.pro` files concerns `image-animation`. The application
    will manipulate `Filter` instances. As a consequence, it needs to access the SDK.
    Add the following to `image-animation.pro`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Fasten your seatbelt. We will now load our freshly baked plugins. In `image-animation`,
    create a new class named `FilterLoader`. Here is the `FilterLoader.h` content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This class is responsible for loading the plugins. Once again, we rely on C++11
    smart pointers with `unique_ptr` to explicate the ownership of the `Filter` instances.
    The `FilterLoader` class will be the owner with `mFilters` and provides a getter
    to the `vector` with `filters()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that `filter()` returns a `const&` to the `vector`. This semantic brings
    two benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: The reference makes sure that the `vector` is not copied. Without it, the compiler
    would have barked something like "`FilterLoader` is not the owner anymore of `mFilters`
    content!" at us. Of course, because it deals with C++ templates, the compiler
    error would have looked rather like an astounding insult to the English language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `const` keyword makes sure that the `vector` type cannot be modified by
    callers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we can create the `FilterLoader.cpp`: file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The meat of the class lies in `loadFilter()`. We start by moving in the `plugins`
    directory with `pluginsDir`, located in the output directory of `image-animation`.
    A special case is handled for the Mac platform: `QApplication::applicationDirPath()`
    returns a path inside the bundle of the generated application. The only way to
    get out is to climb our way up three times with the `cdUp()` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each `fileName` in this directory, we try to load a `QPluginLoader` loader.
    A `QPluginLoader` provides access to a Qt plugin. It is the cross-platform way
    to load a shared library. Moreover, the `QPluginLoader` loader has the following
    benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: It checks that the plugin is linked with the same version of Qt as the host
    application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It simplifies the loading of the plugin by providing direct access to the plugin
    via `instance()` rather than relying on C functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then proceed to try to load the plugin using `pluginLoader.instance()`. This
    will try to load the root component of the plugin. In our case, the root component
    is either `FilerOriginal`, `FilterGrayscale`, or  `FilterBlur`. This function
    always returns a `QObject*`; if the plugin could not be loaded, it returns `0`.
    This is the reason why we inherited the `QObject` class in our custom plugins.
  prefs: []
  type: TYPE_NORMAL
- en: The call to `instance()` implicitly tries to load the plugin. Once this has
    been done, the `QPluginLoader` does not handle the memory of the `plugin`. From
    here, we cast the plugin to `Filter*` using `qobject_cast()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `qobject_cast()` function behaves similarly to the standard C++ `dynamic_cast()`;
    the difference is that it does not require **RTTI** (**runtime type information**).
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, the `Filter*` casted `plugin` is wrapped inside a `unique_ptr`
    and added to `mFilters` vector.
  prefs: []
  type: TYPE_NORMAL
- en: Using the plugins inside the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the plugins are properly loaded, they have to be reachable from the
    UI of the application. To do so, we are going to take some inspiration (shameless
    stealing) from the `FilterWidget` class of [Chapter 7](part0071.xhtml#aid-23MNU1
    "Chapter 7.  Third-Party Libraries Without a Headache"), *Third-Party Libraries
    Without a Headache*.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Qt Designer **Form Class** using the **Widget** template named `FilterWidget`.
    The `FilterWidget.ui` file is exactly the same as the one completed in [Chapter
    7](part0071.xhtml#aid-23MNU1 "Chapter 7.  Third-Party Libraries Without a Headache"), *Third-Party
    Libraries Without a Headache*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `FilterWidget.h` file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Overall, we trimmed everything concerning the Qt Designer plugin and simply
    passed the `mFilter` value by reference to the constructor. The `FilterWidget`
    class is not the owner of the `Filter` anymore; it is rather the client that calls
    it. Remember that the owner of `Filter` (aka the plugin) is `FilterLoader`.
  prefs: []
  type: TYPE_NORMAL
- en: The other modification is the new `setThumbnail()` function. It should be called
    in place of the old `updateThumbnail()`. The new `updateThumbnail()` now only
    performs the thumbnail processing and does not touch the source thumbnail. This
    division is done to prepare the work for the coming animation section. The thumbnail
    update will be done only once the animation has been finished.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please refer to the source code of the chapter to see `FilterWidget.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: All the low layers have been completed. The next step is to fill `MainWindow`.
    Once again, it follows the same pattern we covered in [Chapter 7](part0071.xhtml#aid-23MNU1
    "Chapter 7.  Third-Party Libraries Without a Headache"), *Third-Party Libraries
    Without a Headache*. The sole difference with `MainWindow.ui` is that `filtersLayout`
    is empty. Obviously, the plugin is loaded dynamically, so we have nothing to put
    inside it at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s cover `MainWindow.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The only notable thing is the addition of `mFilterLoader` as a member variable.
    In `MainWindow.cpp`, we will focus on the changes only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `initFilters()` function does not load the filters from the `ui` content.
    Rather, it starts by calling the `mFilterLoader.loadFilters()` function to dynamically
    load the plugins from the `plugins` directory.
  prefs: []
  type: TYPE_NORMAL
- en: After that, an `auto&` filter is assigned with `mFilterLoader.filters()`. Note
    that it is much more readable to use `auto` keyword. The real type is `std::vector<std::unique_ptr<Filter>>&`,
    which looks more like a cryptic incantation than a simple object type.
  prefs: []
  type: TYPE_NORMAL
- en: For each of these filters, we create a `FilterWidget*` and pass it the reference
    of the `filter`. Here, `filter` is effectively a `unique_ptr`. The people behind
    C++11 wisely modified the dereferencing operator, making it transparent to the
    new `FilterWidget(*filter)`. The combination of the `auto` keyword and the overload
    of the `->` operator, or the dereference operator, makes the use of new C++ features
    much more enjoyable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the for loop. For each `filter` we do the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `FilterWidget` template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `FilterWidget` template to the `filtersLayout` children.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the `FilterWidget::pictureProcessed` signal to the `MainWindow::displayPicture` slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the new `FilterWidget` template to the `QVector``mFilters`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the end, the first `FilterWidget` is selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only other modification to `MainWindow.cpp` is the implementation of `loadPicture()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `updateThumbnail()` function has been split into two functions, and here
    is where it is used.
  prefs: []
  type: TYPE_NORMAL
- en: The application can now be tested. You should be able to execute it and see
    the dynamic plugins loaded and displaying the processed default Lenna picture.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering the Animation Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your application works like a charm. It is now time to look at how we can make
    it jump and move, or, in a word, live. The Qt Animation Framework can be used
    to create and start animations of Qt properties. The property value will be smoothly
    interpolated by an internal global timer handle by Qt. You can animate anything
    as long as it is a Qt property. You can even create a property for your own object
    using `Q_PROPERTY`. If you forgot about `Q_PROPERTY`, please refer to [Chapter
    7](part0071.xhtml#aid-23MNU1 "Chapter 7.  Third-Party Libraries Without a Headache"), *Third-Party
    Libraries Without a Headache*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Three main classes are provided to build animations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QPropertyAnimation`: This class animates one Qt property animation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QParallelAnimationGroup`: This class animates multiple animations in parallel
    (all the animations start together)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QSequentialAnimationGroup`: This class animates multiple animations in sequence
    (the animations run one by one in a defined order)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All those classes inherit `QAbstractAnimation`. Here is a diagram from the
    official Qt documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Discovering the Animation Framework](img/image00418.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Please notice that `QAbstractAnimation`, `QVariantAnimation`, and `QAnimationGroup`
    are abstract classes. Here is a simple example of a Qt animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet moves a `QLabel` label from the 0 x 0 position to 300
    x 200 in four seconds. The first thing to do is to define the target object and
    its property. In our case, the target object is `label` and we want to animate
    the property called `geometry`. Then, we set the animation duration in milliseconds: `4000`
    milliseconds for four seconds. Finally, we can decide the start and end values
    of the `geometry` property, which is a `QRect`, defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `label` object starts with the 0 x 0 position and ends with 300 x 200\.
    In this example, the size is fixed (150 x 50), but you can also animate the width
    and the height if you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we call the `start()` function to begin the animation. In four seconds,
    the animation smoothly moves the label from the 0 x 0 position to 300 x 200\.
    By default, the animation uses a linear interpolation to provide intermediate
    values, so, after two seconds, the `label` will be at the 150 x 100 position.
    The linear interpolation of the value looks like the following schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Discovering the Animation Framework](img/image00419.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In our case, the `label` object will move with a constant speed from the start
    to the end position. An easing function is a mathematical function that describes
    the evolution of a value over time. The easing curve is the visual representation
    of the mathematical function. The default linear interpolation is a good start,
    but Qt provides plenty of easing curves to control the speed behavior of your
    animation. Here is the updated example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can set the target object and the property name directly using the `QPropertyAnimation`
    constructor. As a result, we removed the `setTargetObject()` and `setPropertyName()`
    functions. After that, we use `setEasingCurve()` to specify a curve for this animation.
    The `InCirc` looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Discovering the Animation Framework](img/image00420.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: With this easing curve, the label starts to move really slowly but accelerates
    progressively during the animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way is to define the intermediate key steps yourself, using the `setKeyValueAt()`
    function. Let''s update our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now setting key frames using `setKeyValueAt()`. The first argument is
    the time step in the range 0 to 1\. In our case, step 1 means four seconds. The
    key frames at step 0 and step 1 provide the same positions as the start/end positions
    of the first example. As you can see, we also add a key frame at step 0.25 (that''s
    one second for us) with the position 225 x 112.5\. The next schema illustrates
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Discovering the Animation Framework](img/image00421.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can clearly distinguish the three key frames created with `setKeyValueAt()`.
    In our example, our `label` will quickly reach the 225 x 112.5 position in one
    second. Then the label will slowly move to the 300 x 200 position during the remaining
    three seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have more than one `QPropertyAnimation` object, you can use groups to
    create more complex sequences. Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we are using a `QSequentialAnimationGroup` to run animations
    one by one. The first thing to do is to add animations to `animationGroup`. Then,
    when we call `start()` on our animation group, `animation1` is `launched`. When `animation1`
    is finished, `animationGroup` runs `animation2`. A `QSequentialAnimationGroup`
    is finished when the last animation of the list ends. The next schema depicts
    this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Discovering the Animation Framework](img/image00422.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The second animation group, `QParallelAnimationGroup`, is initialized and started
    in the same way as `QSequentialAnimationGroup`. But the behavior is different:
    it starts all the animations in parallel, waiting for the longest animation to
    end. Here is an illustration of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Discovering the Animation Framework](img/image00423.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Keep in mind that an animation group is itself an animation (it inherits `QAbstractAnimation`).
    As a consequence, you can add animation groups to other animation groups to create
    a very complex animation sequence!
  prefs: []
  type: TYPE_NORMAL
- en: Making your thumbnails jump
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s apply what we learned about the Qt Animation Framework to our project.
    Each time the user clicks on a filter thumbnail, we want to poke it. All modifications
    will be done on the `FilterWidget` class. Let''s start with `FilterWidget.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The first function, `initAnimations()`, initializes the animations used by `FilterWidget`.
    The second function, `startSelectionAnimation()`, performs tasks required to start
    this animation correctly. As you can see, we are also declaring a `QPropertyAnimation`
    class, as covered in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now update `FilterWidget.cpp`. Let''s update the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We initialize our `QPropertyAnimation` called `mSelectionAnimation`. The constructor
    also calls `initAnimations()`. Here is its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You should be familiar with these animation initialization steps now. The target
    object is the `thumbnailLabel` displaying the filter plugin preview. The property
    name to animate is `geometry`, because we want to update the position of this `QLabel`.
    Finally, we set the animation duration to 200 ms. Like jokes, keep it short and
    sweet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the existing mouse event handler like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Each time the user clicks on the thumbnail, the selection animation moving
    the thumbnail will be called. We can now add this most important function like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to do is to retrieve the current geometry of `thumbnailLabel`
    called `currentGeometry`. Then, we create a `targetGeometry` object with the same `x`, `width`,
    and `height` values. We only reduce the `y` position by 50, so the target position
    is always above the current position.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we define our key frames:'
  prefs: []
  type: TYPE_NORMAL
- en: '**At step 0**, the value is the current position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**At step 0.3** (60 ms, because the total duration is 200 ms), the value is
    the target position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**At step 1** (the end of the animation), we bring it to back the original
    position. The thumbnail will quickly reach the target position, then slowly fall
    down to its original position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These key frames must be initialized before each animation starts. Because the
    layout is dynamic, the position (and so the geometry) could have been updated
    when the user resizes the main window.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that we are preventing the animation from starting again if the
    current state is not stopped. Without this precaution, the thumbnail could move
    to the top again and again if the user clicks like a mad man on the widget.
  prefs: []
  type: TYPE_NORMAL
- en: You can now test your application and click on a filter effect. The filter thumbnail
    will jump to respond to your click!
  prefs: []
  type: TYPE_NORMAL
- en: Fading the picture in
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the user opens a picture, we want to fade in the image by playing with
    its opacity. The classes `QLabel` or `QWidget` do not provide an opacity property.
    However, we can add a visual effect to any `QWidget` using a `QGraphicsEffect`.
    For this animation, we will use `QGraphicsOpacityEffect` to provide an `opacity`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a schema to describe the role of each one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fading the picture in](img/image00424.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In our case, the `QWidget` class is our `QLabel` and the `QGraphicsEffect` class
    is `QGraphicsOpacityEffect`. Qt provides the Graphics Effect system to alter the
    rendering of a `QWidget` class. The abstract class `QGraphicsEffect` has a pure
    virtual method `draw()` that is implemented by each graphics effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now update the `MainWindow.h` according to the next snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `initAnimations()` private function is in charge of all the animation initializations.
    The  `mLoadPictureAnimation` member variable performs the fade-in animation on
    the loaded picture. Finally, we declare `mPictureOpacityEffect`, the mandatory `QGraphicsOpacityEffect`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s switch to the implementation part with the `MainWindow.cpp` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: No surprises here. We use the initializer list to construct our two new member
    variables. The `MainWindow` constructor also calls `initAnimations()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how this animation is initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to do is to link our `QGraphicsOpacityEffect` with our `QLabel`.
    This can be easily done by calling the `setGraphicsEffect()` function on `pictureLabel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can set our animation up. In this case, `mLoadPictureAnimation` targets `mPictureOpacityEffect`
    and will affect its property named `opacity`. The animation duration is `500`
    milliseconds. Next, we set the opacity value when the animation starts and ends:'
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning, the picture is completely transparent (`opacity` value is `0`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end, the picture is fully visible (`opacity` value is `1`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For this animation, we use the easing curve `InCubic`. This curve looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fading the picture in](img/image00425.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Feel free to try other curves to find the one that looks the best for you.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can get the list of all easing curves with a visual preview here:[http://doc.qt.io/qt-5/qeasingcurve.html](http://doc.qt.io/qt-5/qeasingcurve.html)
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to start the animation at the right place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You can now start your application and load a picture. You should see your picture
    fade in over 500 milliseconds!
  prefs: []
  type: TYPE_NORMAL
- en: Flashing the thumbnail in a sequence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this last animation, we want to display a blue flash on each filter preview
    when the thumbnail is updated. We do not want to flash all previews at the same
    time, but in a sequence, one by one. This feature will be achieved in two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a color animation in `FilterWidget` to display a blue flash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a sequential animation group in `MainWindow` containing all `FilterWidget`
    color animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start to add the color animation. Update `FilterWidget.h` as shown in
    the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This time we do not want to affect the opacity, but rather colorize the thumbnail
    in blue. Thus, we use another Qt standard effect: `QGraphicsColorizeEffect`. We
    also declare a new `QPropertyAnimation` named `mColorAnimation` and its corresponding
    getter, `colorAnimation()`. We declare `mColorAnimation` as a pointer because
    the ownership will be taken by the animation group of `MainWindow`. This topic
    will be covered soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update the constructor in `FilterWidget.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We just have to construct our two new member variables, `mColorAnimation` and `mColorEffect`.
    Let''s look at the amazing complexity of the getter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'It was a lie: we always try to write comprehensive code!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the preliminaries are done, we can initialize the color animation
    by updating the  `initAnimations()` function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The first part sets the color filter up. Here, we chose a kind of turquoise
    color for the flash effect. The colorize effect is handled by its `strength` property.
    By default, the value is `1.0`, so, we set it to `0.0` to keep it from affecting
    our default thumbnail of Lenna. Finally, we link the `thumbnailLabel` with this `mColorEffect`
    calling `setGraphicsEffect()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part is the color animation preparation. This animation targets
    the color effect and its property, named `strength`. This is a short flash; `200`
    milliseconds is enough:'
  prefs: []
  type: TYPE_NORMAL
- en: We want to start with a full strength effect, so we put the start value at `1.0`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During the animation, the colorize effect will decrease until it reaches `0.0`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default linear interpolation is fine here, so we do not use any easing curve.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we are. The color effect/animation is initialized and we provided a `colorAnimation()`
    getter. We can now begin the second part of this feature, Updating `MainWindow.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare a `QSequentialAnimationGroup` class to trigger, one by one, all `FilterWidget`
    color animations displaying the blue flash. Let''s update the constructor in `MainWindow.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'A new member variable means a new construction in the initializer list: that
    is the rule!'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now update `initAnimations()` to prepare our animation group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Do you remember that an animation group is only an animation container? As a
    consequence, we iterate on every `FilterWidget` to get its color animation and
    fill our `mFiltersGroupAnimation` calling `addAnimation()`. Thanks to C++11's
    range-based for loop, it is really readable. Keep in mind that when you add an
    animation to an animation group, the group takes ownership of this animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our animation group is ready. We can now start it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Start your application and open a picture. You can see that all filter thumbnails
    will flash one by one from left to right. This is what we intended, but it''s
    still not perfect because all the thumbnails are already updated before the flashes.
    We have this behavior because the `loadPicture()` function actually sets and updates
    all thumbnails, and then finally starts the sequential animation group. Here is
    a schema illustrating the current behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Flashing the thumbnail in a sequence](img/image00426.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The schema only describes the behavior for two thumbnails, but the principle
    is the same with three thumbnails. Here is the targeted behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Flashing the thumbnail in a sequence](img/image00427.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We must only update the thumbnail when the flash animation is over. Fortunately,
    `QPropertyAnimation` emits the `finished` signal when the animation is over, so
    we only have to make a few changes. Update `loadPicture()` function from `MainWindow.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we kept the set and only removed the update thumbnail when
    a new picture is opened by the user. At this stage, all `FilterWidget` instances
    have the correct thumbnail, but they don''t display it. Let''s fix this by updating `FilterWidget.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We connect a `lambda` function to the finished signal of the color animation.
    This `lambda` simply updates the thumbnail. You can now start your application
    again and load a picture. You should see that we not only animate the sequential
    blue flash, but also the thumbnail update.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you defined a `Filter` interface in your own SDK. Your filters
    are now plugins. You know how to create and load a new plugin, so your application
    is now modular and can be easily extended. We have also enhanced the application
    with the Qt Animation Framework. You know how to animate the position, the color,
    and the opacity of any `QWidget`, using `QGraphicsEffect` if necessary. We created
    a sequential animation that starts three animations one by one with `QSequentialAnimationGroup`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will talk about a big subject: threading. The Qt framework
    can help you build a robust and reliable multithreading application. To illustrate
    the chapter, we will create a Mandelbrot fractal generator using threadpools.'
  prefs: []
  type: TYPE_NORMAL
