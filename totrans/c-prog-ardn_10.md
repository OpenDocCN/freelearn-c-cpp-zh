# 第10章。一些高级技术

在本章中，我们将学习可以一起使用或独立使用的技术。在这里开发的每个技术都是你未来或当前项目的新工具。我们将使用EEPROM为Arduino板提供一个可读可写的内存系统。

我们还将测试Arduino板之间的通信，使用GPS模块，使我们的板子实现自主化，以及更多。

# 使用EEPROM进行数据存储

到目前为止，我们学习和使用Arduino板作为完全依赖电力的设备。确实，它们需要电流来执行我们固件中编译的任务。

正如我们所注意到的，当我们关闭它们时，每个活着的变量和数据都会丢失。幸运的是，固件不会。

## Arduino板上的三个原生内存池

基于ATmega168芯片组的Arduino板拥有三个不同的内存池：

+   闪存内存

+   SRAM

+   EEPROM

闪存也被称为程序空间。这是我们的固件存储的地方。

**SRAM**代表**静态随机存取存储器**，是运行中的固件存储、读取和操作变量的地方。

**EEPROM**代表**电擦除可编程只读存储器**。这是程序员可以存储长期数据的地方。这是我们的固件所在的地方，如果板子关闭，EEPROM中的任何内容都不会被擦除。

ATmega168具有：

+   16000字节的闪存（其中2000字节用于引导加载程序）

+   1024字节的SRAM

+   512字节的EEPROM

在这里，我们不会讨论在编程时必须注意内存的事实；我们将在本书的最后一章[第13章](ch13.html "第13章. 提高你的C编程和创建库")中这样做，*提高你的C编程和创建库*。

这里有趣的部分是EEPROM空间。它允许我们在Arduino上存储数据，而我们直到现在甚至都不知道这一点。让我们测试EEPROM原生库。

### 使用EEPROM核心库进行读写

基本上，这个示例不需要任何接线。我们将使用512字节的内部EEPROM。以下是一些读取EEPROM所有字节并将其打印到计算机串行监视器的代码：

[PRE0]

这段代码属于公共领域，并作为EEPROM库的示例提供。你可以在Arduino IDE的**文件**菜单下的**示例**文件夹中找到它，在**示例** | **EEPROM**文件夹中。

首先，我们包含库本身。然后我们定义一个用于存储当前读取地址的变量。我们将其初始化为0，即内存寄存器的开始。我们还定义了一个字节类型的变量。

在`setup()`函数中，我们初始化串行通信。在`loop()`中，我们读取当前地址的字节并将其存储在变量`value`中。然后我们将结果打印到串行端口。注意第二个`Serial.print()`语句中的`\t`值。这代表制表符（就像电脑键盘上的*Tab*键）。这将在打印的当前地址和值本身之间写入制表符，以便使内容更易读。

我们前进到下一个地址。我们检查地址是否等于512，如果是，我们将地址计数器重置为0，依此类推。

我们添加了一个小的延迟。我们可以使用`EEPROM.write(addr, val);`以相同的方式写入字节，其中`addr`是你想写入值`val`的地址。

小心，这些都是字节（8比特=256个可能值）。在内部EEPROM上读写操作相当简单，所以让我们看看通过I2C连接的外部EEPROM会怎样。

## 外部EEPROM布线

电子市场上有很多廉价的EEPROM组件。我们将使用经典的24LC256，这是一个实现I2C读写操作并提供256千比特（32千字节）内存空间的EEPROM。

你可以在Sparkfun找到它：[https://www.sparkfun.com/products/525](https://www.sparkfun.com/products/525)。以下是使用I2C布线其更大的兄弟24LC1025（1024k字节）的方法：

![外部EEPROM布线](img/7584_10_001.jpg)

通过I2C通信连接到Arduino的24LC256 EEPROM

对应的图如下所示：

![外部EEPROM布线](img/7584_10_002.jpg)

通过I2C通信连接到Arduino的24LC256 EEPROM

让我们描述一下EEPROM。

**A0**、**A1**和**A2**是芯片地址输入。**+V**和**0V**是**5V**和地。WP是写保护引脚。如果它连接到地，我们可以写入EEPROM。如果它连接到5V，则不能。

SCL和SDA是参与I2C通信的两个引脚，并连接到**SDA** / **SCL**。**SDA**代表**串行** **数据** **线**，**SCL**代表**串行** **时钟** **线**。注意SDA/SCL引脚。以下取决于你的板：

+   Arduino UNO R3之前的I2C引脚是A4（SDA）和A5（SCL）

+   Mega2560，20号引脚（SDA）和21号引脚（SCL）

+   Leonardo，2号引脚（SDA）和3号引脚（SCL）

+   Due引脚，20号引脚（SDA）和21号引脚（SCL），还有一个SDA1和SCL1

## 读写EEPROM

我们可以用于I2C目的的底层库是`Wire`。你可以在Arduino核心库中直接找到它。这个库负责处理原始比特，但我们需要更仔细地查看它。

`Wire`库为我们处理了很多事情。让我们检查文件夹`Chapter10/readWriteI2C`中的代码：

[PRE1]

我们首先包含`Wire`库。然后我们定义2个函数：

+   `eepromWrite()`

+   `eepromRead()`

这些函数使用`Wire`库将字节写入和读取到外部EEPROM。

`Setup()` 函数实例化了 `Wire` 和 `Serial` 通信。然后使用 `for` 循环，我们将数据写入特定的地址。这些数据基本上是一个字符 'a' 加上一个数字。这种结构从 'a' 写到 'a' + 9，即 'j'。这是一个展示我们如何快速存储东西的例子，但当然我们可以写入更有意义的数据。

然后，我们向串行监视器打印一条消息，以告知用户 Arduino 已完成对 EEPROM 的写入。

在 `loop()` 函数中，我们读取 EEPROM。它与 EEPROM 库非常相似。

显然，我们还没有讨论地址。以下是一个 I2C 消息格式：

![读取和写入 EEPROM](img/7584_10_003.jpg)

一个 I2C 消息

`Wire` 库负责**起始位**和**确认位**。控制码是固定的，你可以通过将**芯片选择位**（A0、A1 和 A2 引脚）连接到地或 +V 来更改。这意味着有 8 种地址的可能性，从 0 到 7。

1010000 1010001… 直到 1010111。1010000 二进制表示十六进制的 0x50，而 1010111 表示 0x57。

在我们的情况下，我们将 **A0**、**A1** 和 **A2** 连接到地，然后 EEPROM 在 I2C 总线上的地址是 0x50。我们可以在 I2C 总线上使用多个地址，但只有当我们需要更多的存储容量时。实际上，我们可能需要在固件中为不同的设备分配地址。

我们现在可以想象在 EEPROM 空间中存储很多东西，从播放 PCM 音频的样本到，最终，巨大的查找表或任何需要比 Arduino 本身更多内存的东西。

# 使用 GPS 模块

**GPS** 代表 **全球定位系统**。该系统基于卫星星座。

基本上，一个至少接收来自 4 颗嵌入特殊原子钟的卫星的接收器，通过计算这些信号之间的传播时间以及与自身的传播时间，可以精确地计算出其三维位置。这听起来很神奇；其实只是三角学的应用。

我们不会深入探讨这个过程的细节；相反，我们关注来自 GPS 模块的数据解析。你可以在维基百科上获取更多信息：[http://en.wikipedia.org/wiki/Global_Positioning_System](http://en.wikipedia.org/wiki/Global_Positioning_System)。

## 连接 Parallax GPS 接收器模块

Parallax GPS 接收器基于 PMB-248 规范，以其小巧的尺寸和低廉的成本，为 Arduino 添加位置检测提供了非常简单的方法。

![连接 Parallax GPS 接收器模块](img/7584_10_004.jpg)

Parallax GPS 接收器：小巧尺寸和精确

它提供标准的原始 NMEA01823 字符串，甚至可以通过串行命令接口提供特定用户请求的数据。它可以跟踪 12 颗卫星，甚至 WAAS（仅在 USA 和 Hawaii 可用的系统，用于帮助 GPS 信号计算）。

NMEA0183 是一种结合了硬件和逻辑规范，用于海洋电子设备（如声纳、风速计等）之间的通信，包括 GPS。关于此协议的详细描述可以在这里找到：[http://aprs.gids.nl/nmea/](http://aprs.gids.nl/nmea/)。

该模块提供当前时间、日期、纬度、经度、海拔、速度以及航向/航向，以及其他数据。

我们可以向 GPS 模块写入数据以请求特定的字符串。然而，如果我们将 **/RAW** 引脚拉低，模块会自动传输一些字符串。这些字符串是：

+   $GPGGA: 全球定位系统定位数据

+   $GPGSV: 视野中的 GPS 卫星

+   $GPGSA: GPS DOP 和活动卫星

+   $GPRMC: 推荐的最小特定 GPS/Transit 数据

这些数据必须由 Arduino 捕获并最终使用。让我们先检查一下接线：

![接线 Parallax GPS 接收器模块](img/7584_10_005.jpg)

通过将 /RAW 引脚拉低，自动模式下连接到 Arduino 的 Parallax GPS 接收器

接线相当简单。

是的，Parallax GPS 接收器只消耗一个数据引脚：数字引脚 0。让我们在这里停顿两秒钟。我们不是讨论过在 Arduino 上我们不能同时使用 USB 端口进行串行监控，以及引脚 0 和 1 用于其他串行功能吗？

使用 Rx/Tx 2 根线进行串行通信，串行软件实现可以是全双工的。

在我们的例子中，GPS 设备将数据发送到 Arduino 的 Rx 引脚。这个引脚（数字引脚 0）连接到 USB Rx 引脚。同时，Arduino 使用连接到数字引脚 1 的 USB Tx 引脚将数据发送到计算机。

在我们的情况下这里有问题吗？没有。我们只需要注意干扰。我们绝对不能通过 USB 从计算机发送数据到 Arduino，因为它已经从 GPS 设备接收了串行引脚 0 的数据。这是我们唯一需要注意的事情。

`Serial.write()` 函数将写入数字引脚 1，而 USB Tx 数字引脚 1 没有连接到任何东西。因此，没有问题，数据将被发送到 USB。`Serial.read()` 函数从数字引脚 0 和 USB 读取，我们没有从计算机发送任何数据到 USB，所以它可以无任何问题地读取数字引脚 0。

我们将 /RAW 引脚拉低。在这种模式下，设备会自动将数据推送到 Arduino；我的意思是，不需要请求它。

## 解析 GPS 位置数据

在构建任何能够使用 GPS 数据的固件之前，我们必须更多地了解设备能够传输的内容。

我们可以在以下位置查看 GPS 设备的数据表：[http://www.rcc.ryerson.ca/media/2008HCLParallaxGPSReceiverModuledatasheet.pdf](http://www.rcc.ryerson.ca/media/2008HCLParallaxGPSReceiverModuledatasheet.pdf)。

这里是可传输数据的一个示例：

`$GPRMC,220516,A,5133.82,N,00042.24,W,173.8,231.8,130694,004.2,W*70`

`$GPRMC` 定义了发送的信息序列的类型。逗号是一个分隔符，用于分隔每个数据字段。

下面是每个字段的含义：

1.  定位的 UTC 时间

1.  数据状态（`A` 表示有效位置，`V` 表示警告）

1.  定位的纬度

1.  北或南纬度

1.  定位的经度

1.  东或西经度

1.  地面速度（以节为单位）

1.  航迹向度（以度为单位）

1.  定位的 UTC 日期

1.  磁差（以度为单位）

1.  东或西磁差

1.  校验和

一旦我们知道发送了什么数据，我们就可以在我们的固件中编写一个解析器。以下是一个可能的固件示例。您可以在文件夹 `Chapter10/locateMe` 中找到它：

[PRE2]

让我们解释一下代码。首先，我定义了几个变量：

+   `rxPin` 是 GPS 设备连接的数字输入

+   `byteGPS` 是通过串行通信从 GPS 读取的最新字节

+   `line` 是一个缓冲区数组

+   `commandGPR` 是与我们要解析的消息相关的字符串

+   `counter` 是索引数组的索引

+   `correctness` 存储消息的有效性

+   `lineCounter` 是跟踪数据缓冲区位置的计数器

+   `index` 存储GPS数据字符串中每个分隔符的位置（","）

在 `setup()` 函数中，我们首先将数字引脚0定义为输入，然后以串行接口所需的4800波特率开始串行通信（请记住始终检查您的数据表）。然后，我们通过填充空格字符来清除我们的 `line` 数组缓冲区。

在 `loop()` 函数中，我们首先从串行输入读取字节，数字引脚为0。如果端口不为空，我们进入由 `else` 块定义的 `if` 条件测试的第二部分。如果它是空的，我们只需等待100毫秒然后再次尝试读取。

首先，解析开始于将读取的数据放入行缓冲区中数组的特定索引：`lineCounter`。然后，我们增加后者以便存储接收到的数据。

我们然后将读取的数据作为原始行打印到USB端口。就在这个时候，串行监视器可以接收并显示我们之前引用的示例中的原始数据行。

然后，我们测试数据本身，将其与 13 进行比较。如果它等于 13，这意味着数据通信已完成，我们可以开始解析。

我们重置 `counter` 和 `correctness` 变量，并检查缓冲区中的前6个字符是否等于 `$GPRMC`。对于每个匹配项，我们增加 `correctness` 变量。

这是一个经典的模式。实际上，如果所有测试都为真，那么最终 `correctness` 等于 `6`。然后我们只需检查 `correctness` 是否等于 `6`，以查看是否所有测试都为真，以及前6个字符是否等于 `$GPRMC`。

如果是这样，我们可以确信我们有一个正确的 NMEA 原始序列类型 `$GPRMC`，然后我们可以开始实际解析数据的负载部分。

首先，我们通过存储字符串中每个逗号分隔符的位置来分割我们的原始字符串。然后，我们用最后一个部分分隔符，即"*"字符，做同样的事情。在这个时候，我们能够区分哪个字符属于字符串的哪个部分，我的意思是，哪个部分属于原始消息。

这是一个在原始消息的每个值之间的循环，我们使用switch/case结构测试每个值，以便显示介绍GPS数据消息每个值的正确句子。

最后，最棘手的部分是最后的`for()`循环。我们并不像通常那样开始。实际上，我们在循环中使用数组`index`在特定位置`i`来开始`j`索引。

这里是一个显示原始消息周围索引的小型电路图：

![解析GPS位置数据](img/7584_10_006.jpg)

根据每个分隔符逐步解析消息的每一部分

我们根据每个分隔符的位置逐步增加，并显示每个值。这是使用GPS模块解析和使用位置数据的一种方法。这些数据可以根据你的目的以多种方式使用。我喜欢数据可视化，我为学生制作了小项目，使用GPS模块每隔30秒在街上抓取位置并写入EEPROM。然后，我使用这些数据制作了一些图表。我最喜欢的一个是以下这个：

![解析GPS位置数据](img/7584_10_007.jpg)

使用由GPS Arduino模块提供的数据集设计的Processing数据可视化

每一行都是一个时间戳。行的长度代表我在Arduino GPS模块两次测量之间花费的时间。行越长，我在这个旅行步骤上花费的时间就越长。

你的问题可能是：你在街上行走时是如何给你的Arduino + GPS模块供电的？

现在，让我们看看如何使用电池使Arduino实现自主性。

# Arduino、电池和自主性

Arduino板可以通过两种方式供电：

+   来自电脑的USB线

+   外部电源

从本节开始，我们就已经使用USB为Arduino供电。这是一种相当好的开始方式（甚至可以做出一个很棒的项目）。这很简单，适用于许多用途。

当我们需要更多的自主性和移动性时，我们也可以使用外部电源为Arduino设备供电。

在任何情况下，我们都要记住，我们的Arduino及其连接的电路都需要供电。通常，Arduino的功耗不超过50mA。添加一些LED，你会发现功耗增加。

让我们检查一些实际应用的案例。

## 经典的USB供电案例

我们为什么和什么时候会使用USB电源？

显然，如果我们需要我们的电脑连接到Arduino进行数据通信，我们可以自然地通过USB为Arduino供电。

这就是使用USB电源的主要原因。

也有一些情况，我们无法拥有很多电源插座。有时，在安装设计项目中存在许多限制，我们没有很多电源插座。这也是使用USB供电的一个例子。

基本上，在使用USB端口供电之前，首先要考虑的是我们电路的全球功耗。

的确，正如我们已经学到的，USB端口可以提供的最大电流大约是500mA。确保不要超过这个值。超过这个功耗限制，事情变得完全不可预测，有些电脑甚至可能重新启动，而有些电脑可能禁用所有USB端口。我们必须记住这一点。

## 外部电源供电

有两种不同的方式为基于Arduino的系统供电。我们可以将两种主要的电源供应方式表述为：

+   电池

+   电源适配器

### 使用电池供电

如果我们记得正确的话，Arduino Uno和Mega等实例可以在6 V到20 V的外部电源下运行。为了稳定使用，建议的范围是7 V到12 V。9 V是一个理想的电压。

为了将板设置为外部电源供电，你必须注意电源跳线。我们必须将其放在外部电源侧，称为EXT。这种设置适用于Arduino Diecimilla和较老的Arduino板：

![使用电池供电](img/7584_10_008.jpg)

将电源跳线放在EXT侧，意味着设置为外部电源

让我们用9 V电池检查基本接线：

![使用电池供电](img/7584_10_009.jpg)

一个连接到Arduino板UNO R3的9V电池

这种简单的接线提供了一种为Arduino板供电的方法。如果你将其他电路连接到Arduino上，通过Arduino的电池将为它们供电。

我们还可以使用其他类型的电池。纽扣电池是一种在外部供电时节省空间的好方法：

![使用电池供电](img/7584_10_010.jpg)

一个经典的纽扣电池

有许多类型的纽扣电池座，可以在我们的电路中使用这种电池。通常，纽扣电池提供3.6 V，110 mAh。如果这不能为Arduino Uno供电，它可以轻松地为工作在3.3 V电压下的Arduino Pro Mini供电：

![使用电池供电](img/7584_10_011.jpg)

Arduino Pro Mono

Arduino Pro Mini板非常有趣，因为它可以嵌入许多需要离散和有时隐藏在墙内的电路中，用于数字艺术安装，或者当它们作为移动工具使用时，可以放入可以放入口袋的小塑料盒中。

我们还可以使用聚合物锂离子电池。我曾在几个自主设备项目中使用过它们。

然而，我们可能会有一些需要更多电力的项目。

## Arduino电源适配器

对于需要更多电力的项目，我们必须使用外部电源。Arduino的设置与使用电池时相同。现成的Arduino适配器必须满足一些要求：

+   直流适配器（这里没有交流适配器！）

+   输出电压为9V至12V直流电

+   至少能输出250mA的最低电流，但目标是500mA或更佳，最好是1A

+   必须有一个中心正极2.1mm电源插头

在插入Arduino之前，你必须在适配器上寻找以下图案。

首先，连接器的中心必须是正极部分；查看以下图解。你应该能看到在Arduino兼容适配器上：

![Arduino电源适配器](img/7584_10_012.jpg)

表示中心正极插头的符号

然后，电压和电流特性。这必须显示类似以下内容：输出：12 VDC 1 A。这是一个例子；12 VDC和5 A也是可以的。别忘了电流只由电路中的内容驱动。输出更高电流的电源适配器不会损害你的电路，因为电路只会吸取它需要的。

市面上有很多适配器可供使用，并且可以与我们的Arduino板一起使用。

## 如何计算电流消耗

为了计算电路中的电流，你必须使用本书第一章中描述的欧姆定律。

当你检查一个组件的数据表，比如LED，你可以看到通过它的电流。

让我们用这份数据表检查RGB共阴极LED：[https://www.sparkfun.com/datasheets/Components/YSL-R596CR3G4B5C-C10.pdf](https://www.sparkfun.com/datasheets/Components/YSL-R596CR3G4B5C-C10.pdf)

我们可以看到正向电流为20 mA，峰值正向电流为30 mA。如果我们有五个这样的LED以最大亮度开启（即红色、蓝色和绿色点亮），我们就有：5 x (20 + 20 + 20) = 300 mA的正常使用电流，甚至峰值也会消耗5 x (30 + 30 + 30) = 450 mA。

在这种情况下，所有LED都同时完全开启。

你必须已经理解了我们已经在电源循环中使用的策略，即依次快速开启每个LED。这提供了一种减少功耗的方法，同时也允许一些项目使用大量LED而不需要外部电源适配器。

我不会在这里描述每种情况的计算，但你必须参考电学规则来精确计算消耗。

根据经验，没有比你的电压表和安培表更好的工具了，前者测量两点之间的电压，后者测量电路中某些点的电流。

我建议你做一些计算以确保：

+   不要超过Arduino每引脚的容量

+   不要超过USB 450mA的限制，以防你使用USB电源

然后，之后，同时使用电压表和安培表进行布线和测量。

最后，大多数Arduino板的一个经典参考可以在本页找到：[http://playground.arduino.cc/Main/ArduinoPinCurrentLimitations](http://playground.arduino.cc/Main/ArduinoPinCurrentLimitations)。

我们可以找到Arduino每个部分的电流消耗限制。

# 在gLCD上绘图

绘图总是很有趣。与LED矩阵相比，绘制和处理LCD显示也很有趣，因为我们有可以轻松开关的高密度点设备。

LCD存在许多类型。两种主要类型是字符和图形类型。

我们在这里讨论的是图形类型，特别是基于在许多常规gLCD设备中使用的KS0108图形控制器。

我们将使用一个在Google上可用的优秀库。它包含Michael Margolis和Bill Perry的代码，命名为`glcd-arduino`。此库根据GNU Lesser GPL许可。

让我们在这里下载它：[http://code.google.com/p/glcd-arduino/downloads/list](http://code.google.com/p/glcd-arduino/downloads/list)。下载最新版本。

解压它，将其放在所有库所在的目录中，然后重新启动或启动你的Arduino IDE。

你现在应该看到很多与gLCD库相关的示例。

我们不会检查这个库提供的所有优秀功能和功能，但您可以在Arduino网站上查看这个页面：[http://playground.arduino.cc/Code/GLCDks0108](http://playground.arduino.cc/Code/GLCDks0108)。

## 连接设备

我们将检查基于KS0108的gLCD类型面板B的连接：

![连接设备](img/7584_10_013.jpg)

将许多线连接到Arduino和电位器以调整LCD对比度

对应的电气图如下：

![连接设备](img/7584_10_014.jpg)

基于KS0108的gLCD类型面板B连接到Arduino Uno R3

这有很多线。当然，我们可以乘以东西。我们还可以使用Arduino MEGA并继续使用其他数字引脚用于其他目的，但这不是重点。让我们检查这个强大库的一些功能。

## 演示库

查看名为`GLCDdemo`的示例。它展示了库中几乎所有的功能。

库中提供了非常好的PDF文档。它解释了每个可用的方法。您可以在`library`文件夹中的`doc`子文件夹中找到它：

![演示库](img/7584_10_015.jpg)

gLCD-Arduino文档显示屏幕坐标系系统

首先，我们必须包含`glcd.h`以使用库。然后，我们必须包含一些其他头文件，在这个例子中，字体和位图，以便使用字体排版方法和位图对象。

## 一些有用的方法家族

我建议将学习方法分为三个部分：

+   全局GLCD方法

+   绘图方法

+   文本方法

### 全局GLCD方法

第一项是`init()`函数。这个函数初始化库，必须在调用任何其他gLCD方法之前调用。

`SetDisplayMode()` 函数很有用，因为它设置LCD的使用为正常（在白色背景上用黑色书写）或反转。白色只是意味着不是黑色。真正的颜色当然取决于背光颜色。

`ClearScreen()` 函数擦除屏幕，在正常模式下填充白色背景，或在反转模式下填充黑色。

`ReadData()` 和 `WriteData()` 函数是真正原始的方法，它们获取和设置特定坐标处的字节数据。

### 绘图方法

这些是一组专门用于在屏幕上绘制的函数。

常量集合如下：

+   `GLCD.Width` 是显示宽度（以像素为单位）

+   `GLCD.Height` 是显示高度（以像素为单位）

+   `GLCD.Right` 是最右侧的最后一行像素（等于 GLCD.Width – 1）

+   `GLCD.Bottom` 是底部最后一行像素（等于 GLCD.Height – 1）

+   `GLCD.CenterX` 和 `GLCD.CenterY` 是像素中心的坐标

基本上，你可以通过移动图形光标和绘制原始形状来绘图：

| 函数 | 描述 |
| --- | --- |
| `GotoXY()` | 将光标移动到特定坐标 |
| `DrawVLine()` | 在同一像素列中从一点绘制到另一点，但位于初始点的上方或下方 |
| `DrawHLine()` | 与 `DrawVLine()` 工作方式相同，但在同一像素行上 |
| `DrawLine()` | 在两个坐标之间绘制线条 |

还可以绘制一些更复杂的形状：

| 函数 | 描述 |
| --- | --- |
| `DrawRect()` | 当提供宽度和高度时，从一点绘制矩形。 |
| `FillRect()` | 与 `DrawRect()` 工作方式相同，但通过用黑色（或白色）像素填充矩形形状。 |
| `DrawRoundRect()` | 绘制具有圆角的矩形。 |
| `DrawCircle()` 和 `FillCircle()` | 从坐标和半径绘制圆，以及用黑色（或白色）像素填充的圆。 |
| `DrawBitmap()` | 在屏幕上的特定位置绘制整个位图。它使用指向该位图的内存中的指针。 |

使用这组函数，你可以基本上绘制任何你想要的东西。

### 文本方法

这些是一组专门用于屏幕排版的函数：

| 函数 | 描述 |
| --- | --- |
| `SelectFont()` | 首先，这选择在后续函数调用中使用的字体。 |
| `SetFontColor()` | 选择颜色。 |
| `SetTextMode()` | 选择滚动方向。 |
| `CursorTo()` | 将光标移动到特定的列和行。列的计算使用最宽字符的宽度。 |
| `CursorToXY()` | 将光标移动到特定的像素坐标。 |

有一个重要的特性需要了解，那就是Arduino的打印函数可以与gLCD库一起使用；例如，`GLCD.print()` 可以正常工作。官方网站上还有其他一些函数可供使用。

最后，我建议您测试名为 `life` 的示例。这是基于约翰·康威的生命游戏。这是一个很好的例子，展示了您可以做什么，并实现一些不错且有用的逻辑。

在 gLCD 上绘图很棒，但我们也可以使用一个小型处理 VGA 的模块。

# 使用 Gameduino 扩展板通过 VGA 输出

Gameduino 是一个 Arduino 扩展板。这是我们在这本书中首次使用的一个。基本上，扩展板是一个可以插入到另一个 PCB（印刷电路板）上的 PCB，这里指的是我们的 Arduino。

Arduino 扩展板是预制的电路，包括组件，有时还包括处理器。它们通过处理一些特定任务来为我们的 Arduino 板添加功能。

在这里，Gameduino 将为我们的 Arduino 添加无法自行完成的 VGA 绘图功能。

Gameduino 添加了一个 VGA 端口、一个用于声音的迷你插孔，并且还包含了一个 FPGA Xilling Spartan3A。FPGA Xilling Spartan3A 可以比 Arduino 本身更快地处理图形数据。Arduino 可以通过 SPI 接口控制这个图形硬件驱动程序。

让我们看看它是如何工作的：

![使用 Gameduino 扩展板通过 VGA 输出](img/7584_10_016.jpg)

Gameduino 控制器 Arduino 扩展板

Arduino 扩展板可以直接插入 Arduino 板。请查看以下截图：

![使用 Gameduino 扩展板通过 VGA 输出](img/7584_10_017.jpg)

Gameduino 插入 Arduino 板

这里是 Gameduino 的一些特点：

+   视频输出为 400 x 300 像素，512 种颜色

+   所有颜色都以内置 15 位精度处理

+   兼容任何标准 VGA 显示器（800 x 600 @ 72 Hz）

+   背景图形（512 x 512 像素字符，256 个字符）

+   前景图形（16 x 16 像素精灵能力，透明度，旋转/翻转，精灵碰撞检测）

+   音频输出为立体声；12 位频率合成器

+   64 个独立的 10 到 8000 Hz 语音

+   样本回放通道

基本概念是将它插入 Arduino，并使用我们的 Arduino 固件来控制它，库负责处理 Arduino 和 Gameduino 之间的所有 SPI 通信。

我们不能在这里描述所有示例，但我希望您能找到正确的方向。首先，官方网站：[http://excamera.com/sphinx/gameduino/](http://excamera.com/sphinx/gameduino/)。

您可以在以下位置找到库：[http://excamera.com/files/gameduino/synth/sketches/Gameduino.zip](http://excamera.com/files/gameduino/synth/sketches/Gameduino.zip)。

您还可以在此处查看和使用快速参考海报：[http://excamera.com/files/gameduino/synth/doc/gen/poster.pdf](http://excamera.com/files/gameduino/synth/doc/gen/poster.pdf)。

为了您的信息，我目前正在设计一个基于这个扩展板的数字艺术装置。我打算在我的个人网站上[http://julienbayle.net](http://julienbayle.net)描述它，并且还会提供整个电路图。

# 摘要

在本章的第一个、高级章节中，我们了解了一些关于如何处理新具体概念的方法，例如在非易失性存储器（内部和外部EEPROM）上存储数据，使用GPS模块接收器，在图形LCD上绘图，以及使用一个名为Gameduino的Arduino Shield来添加新功能和增强我们的Arduino。这使得它能够显示VGA信号，并且还能产生音频。我们还学习了Arduino作为一个非常便携和移动设备的用途，从电源供应的角度来看是自给自足的。

在下一章中，我们将讨论网络概念。创建和使用网络是当今常见的通信方式。在下一章中，我们将描述使用Arduino项目进行有线和无线网络的使用。
