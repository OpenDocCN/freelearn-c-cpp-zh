<html><head></head><body>
		<div id="_idContainer023">
			<h1 id="_idParaDest-93"><em class="italic"><a id="_idTextAnchor093"/>Chapter 7</em>: Handling AST</h1>
			<p>In the previous chapter, we learned how Clang's preprocessor handles preprocessing directives in C-family languages. We also learned how to write different kinds of preprocessor plugins, such as pragma handlers, to extend Clang's functionalities. Those skills are especially useful when it comes to implementing field-specific logic or even custom language features.</p>
			<p>In this chapter, we're going to talk about a <strong class="bold">semantic-aware</strong> representation of the original source code file once it has been parsed, known as an <strong class="bold">Abstract Syntax Tree (AST)</strong>. An AST is a <a id="_idIndexMarker268"/>format that carries rich semantic information, including types, expression trees, and symbols, to name a few. It is not only used as a blueprint to generate LLVM IR for later compilation stages but is also the recommended format for performing static analysis. On top of that, Clang also provides a nice framework for developers to intercept and manipulate AST in the middle of the frontend pipeline via a simple plugin interface. </p>
			<p>In this chapter, we are going to cover how to process AST in Clang, the important APIs for in-memory AST representation, and how to write AST plugins to implement custom logic with little effort. We will cover the following topics:</p>
			<ul>
				<li>Learning about AST in Clang</li>
				<li>Writing AST plugins</li>
			</ul>
			<p>By the end of this chapter, you will know how to work with AST in Clang in order to analyze programs at the source code level. In addition, you will know how to inject custom AST processing logic into Clang in an easy way via AST plugins.</p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor094"/>Technical requirements</h1>
			<p>This chapter expects that you have a build of the <strong class="source-inline">clang</strong> executable. If you don't, please build it using the following command:</p>
			<p class="source-code">$ ninja clang</p>
			<p>In addition, you can use the following command-line flag to print out the textual representation of AST:</p>
			<p class="source-code">$ clang <strong class="bold">-Xclang -ast-dump</strong> foo.c</p>
			<p>For example, let's say <strong class="source-inline">foo.c</strong> contains the following content:</p>
			<p class="source-code">int foo(int c) { return c + 1; }</p>
			<p>By using the <strong class="source-inline">-Xclang -ast-dump</strong> command-line flag, we can print out AST for <strong class="source-inline">foo.c</strong>:</p>
			<p class="source-code">TranslationUnitDecl 0x560f3929f5a8 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt;</p>
			<p class="source-code">|…</p>
			<p class="source-code">`-FunctionDecl 0x560f392e1350 &lt;foo.c:2:1, col:30&gt; col:5 foo 'int (int)'</p>
			<p class="source-code">  |-<strong class="bold">ParmVarDecl 0x560f392e1280 &lt;col:9, col:13&gt; col:13 used c 'int'</strong></p>
			<p class="source-code">  `-CompoundStmt 0x560f392e14c8 &lt;col:16, col:30&gt;</p>
			<p class="source-code">    `-ReturnStmt 0x560f392e14b8 &lt;col:17, col:28&gt;</p>
			<p class="source-code">      `-BinaryOperator 0x560f392e1498 &lt;col:24, col:28&gt; 'int' '+'</p>
			<p class="source-code">        |-ImplicitCastExpr 0x560f392e1480 &lt;col:24&gt; 'int' &lt;LValueToRValue&gt;</p>
			<p class="source-code">        | `-DeclRefExpr 0x560f392e1440 &lt;col:24&gt; 'int' lvalue ParmVar 0x560f392e1280 'c' 'int'</p>
			<p class="source-code">        `-IntegerLiteral 0x560f392e1460 &lt;col:28&gt; 'int' 1</p>
			<p>This flag is useful for finding out what C++ class is used to represent a certain part of the code. For example, the formal function parameter/argument is represented by the <strong class="source-inline">ParmVarDecl</strong> class, which is highlighted in the previous code.</p>
			<p>The code samples for this chapter can be found here: <a href="https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter07">https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter07</a>.</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor095"/>Learning about AST in Clang</h1>
			<p>In this section, we are <a id="_idIndexMarker269"/>going to learn about Clang's AST in-memory representation and its essential API usage. The first part of this section will provide you with a high-level overview of Clang AST's hierarchy; the second part will focus on a more specific topic regarding type representation in Clang AST; and the final part will show you the basic usage of AST matcher, which is extremely useful when you're writing an AST plugin.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor096"/>In-memory structure of Clang AST</h2>
			<p>The in-memory <a id="_idIndexMarker270"/>representation of AST in Clang is organized <a id="_idIndexMarker271"/>in a hierarchy structure that resembles the syntax structure of C-family language programs. Starting from the top-most level, there are two classes worth mentioning: </p>
			<ul>
				<li><strong class="source-inline">TranslationUnitDecl</strong>: This class represents an input source file, also called a translation unit (most of <a id="_idIndexMarker272"/>the time). It contains all the top-level declarations – global variables, classes, and functions, to name a few – as its children, where each of those top-level declarations has its own subtree that recursively defines the rest of the AST.</li>
				<li><strong class="source-inline">ASTContext</strong>: As its name suggests, this class keeps track of all the AST nodes and other metadata from the input source files. If there are multiple input source files, each of them gets its own <strong class="source-inline">TranslationUnitDecl</strong>, but they all share the same <strong class="source-inline">ASTContext</strong>.</li>
			</ul>
			<p>In addition to the structure, the body of the AST – the AST nodes – can be further classified into three primary categories: <strong class="bold">declaration</strong>, <strong class="bold">statement</strong>, and <strong class="bold">expression</strong>. The nodes in these categories are represented by subclasses derived from the <strong class="source-inline">Decl</strong>, <strong class="source-inline">Expr</strong>, and <strong class="source-inline">Stmt</strong> classes, respectively. In the following sections, we are going to introduce each of these in-memory AST representations.</p>
			<h3>Declarations</h3>
			<p>Language constructs <a id="_idIndexMarker273"/>such as variable declarations (global and local), functions, and struct/class declarations are represented by subclasses of <strong class="source-inline">Decl</strong>. Though we are not going to go into each of these subclasses here, the following diagram shows common declaration constructions in C/C++ and their corresponding AST classes:</p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/Figure_7.1_B14590.jpg" alt="Figure 7.1 – Common declarations in C/C++ and their AST classes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – Common declarations in C/C++ and their AST classes</p>
			<p>Between more concrete subclasses, such as <strong class="source-inline">FunctionDecl</strong> and <strong class="source-inline">Decl</strong>, there are several <a id="_idIndexMarker274"/>important <em class="italic">abstract</em> classes that represent certain language concepts:</p>
			<ul>
				<li><strong class="source-inline">NamedDecl</strong>: For every declaration that has a name.</li>
				<li><strong class="source-inline">ValueDecl</strong>: For declarations whose declared instances can be a value, and thus are associated with type information.</li>
				<li><strong class="source-inline">DeclaratorDecl</strong>: For every declaration that uses declarator (basically a statement in the form of <strong class="source-inline">&lt;type and qualifier&gt; &lt;identifier name&gt;</strong>). They provide extra information about parts other than the identifier. For example, they provide access to an in-memory object with namespace resolution, which acts as a qualifier in the declarator.</li>
			</ul>
			<p>To learn more about AST classes for other kinds of declarations, you can always navigate through the subclasses of <strong class="source-inline">Decl</strong> on LLVM's official API reference website.</p>
			<h3>Statements</h3>
			<p>Most directives in a program that represent the concept of <em class="italic">actions</em> can be classified as statements and are <a id="_idIndexMarker275"/>represented by subclasses of <strong class="source-inline">Stmt</strong>, including <em class="italic">expressions</em>, which we are going to cover shortly. In addition to imperative statements such as function calls or return sites, <strong class="source-inline">Stmt</strong> also covers structural concepts such as <strong class="source-inline">for</strong> loops and <strong class="source-inline">if</strong> statements. Here is a diagram showing a common language construct represented by <strong class="source-inline">Stmt</strong> (except expression) in C/C++ and its corresponding AST classes:</p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/Figure_7.2_B14590.jpg" alt="Figure 7.2 – Common statements (excluding expressions) in C/C++ and their AST classes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – Common statements (excluding expressions) in C/C++ and their AST classes</p>
			<p>There are two things worth mentioning about the previous diagram:</p>
			<ul>
				<li><strong class="source-inline">CompoundStmt</strong>, which is a container for multiple statements, represents not only the function body but basically any code block enclosed by curly braces <strong class="source-inline">('{', '}')</strong>. Therefore, though not shown in the preceding diagram due to a lack of space, <strong class="source-inline">IfStmt</strong>, <strong class="source-inline">ForStmt</strong>, <strong class="source-inline">WhileStmt</strong>, and <strong class="source-inline">SwitchStmt</strong> all have a <strong class="source-inline">CompoundStmt</strong> child node representing their bodies.</li>
				<li>Declarations in a <strong class="source-inline">CompoundStmt</strong> will be wrapped by a <strong class="source-inline">DeclStmt</strong> node, in which the real <strong class="source-inline">Decl</strong> instance is its child node. This creates a simpler AST design.</li>
			</ul>
			<p>Statements are one of the most prevailing directives in a typical C/C++ program. It is worth noting, however, that <a id="_idIndexMarker276"/>many statements are organized in a hierarchy (for example, <strong class="source-inline">ForStmt</strong> and its loop body), so it might take you extra steps to go down this hierarchy before you find the desired <strong class="source-inline">Stmt</strong> node.</p>
			<h3>Expressions</h3>
			<p>Expressions in Clang AST are a special kind of statement. Different from other statements, expressions <a id="_idIndexMarker277"/>always generate <em class="italic">values</em>. For example, a simple arithmetic expression, <em class="italic">3 + 4</em>, is expected to generate an integer value. All expressions in Clang AST are represented by subclasses of <strong class="source-inline">Expr</strong>. Here is a diagram showing a common language construct represented by <strong class="source-inline">Expr</strong> in C/C++ and its corresponding AST classes:</p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/Figure_7.3_B14590.jpg" alt="Figure 7.3 – Common expressions in C/C++ and their AST classes &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3 – Common expressions in C/C++ and their AST classes </p>
			<p>One important <strong class="source-inline">Expr</strong> class is <strong class="source-inline">DeclRefExpr</strong>. It represents the concept of symbol reference. You can use one of its APIs, <strong class="source-inline">DeclRefExpr::getDecl()</strong>, to retrieve the referenced symbol's <strong class="source-inline">Decl</strong> object. Handy symbol information like this only appears after AST has been generated, so this is one of the reasons people always recommend implementing static analysis logic on AST rather on more primitive forms (inside the parser, for example).</p>
			<p>Another interesting <strong class="source-inline">Expr</strong> class – not highlighted in the preceding diagram due to a lack of space – is <strong class="source-inline">ParenExpr</strong>, which <a id="_idIndexMarker278"/>represents the parentheses that wrap around an expression. For example, in the preceding diagram, <strong class="bold">(x + 1)</strong> is a <strong class="source-inline">ParenExpr</strong> with a <strong class="source-inline">BinaryOperator</strong> representing <strong class="bold">x + 1</strong> as its child.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor097"/>Types in Clang AST</h2>
			<p>The type system is one of the most crucial components in modern compilers, especially for statically typed <a id="_idIndexMarker279"/>languages such as C/C++. Type checking ensures that the input source code is well-formed (to some extent) and catches as many errors as possible at compile time. While we don't need to do type checking by ourselves in Clang, it is done by the <strong class="source-inline">Sema</strong> subsystem, which we introduced in <a href="B14590_05_Final_JC_ePub.xhtml#_idTextAnchor067"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Clang's Architecture</em>. You will probably need to leverage this information when you're processing the AST. Let's learn how types are modeled in Clang AST.</p>
			<h3>Core classes</h3>
			<p>The core of <a id="_idIndexMarker280"/>Clang AST's type system is the <strong class="source-inline">clang::Type</strong> class. Each type in the input code – including primitive types such as <strong class="source-inline">int</strong> and user-defined types such as struct/class – is represented by a <strong class="bold">singleton type</strong> (more specifically, a <em class="italic">subclass</em> of <strong class="source-inline">Type</strong>) object.</p>
			<p class="callout-heading">Terminology</p>
			<p class="callout">In the rest of this chapter, we will call types in the <a id="_idIndexMarker281"/>input source code <strong class="bold">source code types</strong>.</p>
			<p>A <strong class="bold">singleton</strong> is a design <a id="_idIndexMarker282"/>pattern that forces a resource or an abstract concept to be represented by only one in-memory object. In our case, source code types are the resources, so you will find only one <strong class="source-inline">Type</strong> object for each of those types. One of the biggest advantages of this design is that you have an easier way to compare two <strong class="source-inline">Type</strong> objects. Let's say you have two <strong class="source-inline">Type</strong> pointers. By doing a simple pointer comparison (which is extremely fast) on them, you can tell if they're representing the same source code type.</p>
			<p class="callout-heading">Counter Example of a Singleton Design</p>
			<p class="callout">If <strong class="source-inline">Type</strong> in Clang AST is not using a singleton design, to compare if two <strong class="source-inline">Type</strong> pointers are representing the same source code types, you need to inspect the content of the objects they are pointing to, which is not efficient.</p>
			<p>As we <a id="_idIndexMarker283"/>mentioned earlier, each source code type is actually represented by a subclass of <strong class="source-inline">Type</strong>. Here are some common <strong class="source-inline">Type</strong> subclasses:</p>
			<ul>
				<li><strong class="source-inline">BuiltinType</strong>: For primitive types such as <strong class="source-inline">int</strong>, <strong class="source-inline">char</strong>, and <strong class="source-inline">float</strong>.</li>
				<li><strong class="source-inline">PointerType</strong>: For all the pointer types. It has a function called <strong class="source-inline">PointerType::getPointee()</strong> for retrieving the source code type being pointed to by it.</li>
				<li><strong class="source-inline">ArrayType</strong>: For all the array types. Note that it has other subclasses for more specific arrays that have either a constant or variable length.</li>
				<li><strong class="source-inline">RecordType</strong>: For struct/class/union types. It has a function called <strong class="source-inline">RecordType::getDecl()</strong> for retrieving the underlying <strong class="source-inline">RecordDecl</strong>.</li>
				<li><strong class="source-inline">FunctionType</strong>: For representing a function's signature; that is, a function's argument types and return type (and other properties, such as its calling convention).</li>
			</ul>
			<p>Let us now move on to the qualified types. </p>
			<h3>Qualified types</h3>
			<p>One of the most confusing <a id="_idIndexMarker284"/>things for people new to Clang's code base is that many places use the <strong class="source-inline">QualType</strong> class rather than subclasses of <strong class="source-inline">Type</strong> to represent source code types. <strong class="source-inline">QualType</strong> stands for <strong class="bold">qualified type</strong>. It acts as a <a id="_idIndexMarker285"/>wrapper around <strong class="source-inline">Type</strong> to represent concepts such as <strong class="source-inline">const &lt;type&gt;</strong>, <strong class="source-inline">volatile &lt;type&gt;</strong>, and <strong class="source-inline">restrict &lt;type&gt;*</strong>.</p>
			<p>To create a <strong class="source-inline">QualType</strong> from a <strong class="source-inline">Type</strong> pointer, you can use the following code:</p>
			<p class="source-code">// If `T` is representing 'int'…</p>
			<p class="source-code">QualType toConstVolatileTy(Type *T) {</p>
			<p class="source-code">  return <strong class="bold">QualType(T, Qualifier::Const | Qualifier::Volatile)</strong>;</p>
			<p class="source-code">} // Then the returned QualType represents `volatile const int`</p>
			<p>In this section, we learned <a id="_idIndexMarker286"/>about the type system in Clang AST. Let's now move on to ASTMatcher, a syntax to match patterns. </p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor098"/>ASTMatcher</h2>
			<p>When we are dealing with a program's AST – for example, we're checking if there is any suboptimal syntax – searching <a id="_idIndexMarker287"/>for specific AST nodes <em class="italic">pattern</em> is usually the first step, and one of the most common things people do. Using the knowledge we learned in the previous section, we know that this kind of pattern matching can be done by iterating through AST nodes via their in-memory classes APIs. For example, given a <strong class="source-inline">FunctionDecl</strong> – the AST class of a function – you can use the following code to find out if there is a <strong class="source-inline">while</strong> loop in its body and if the exit condition of that loop is always a literal Boolean value; that is, <strong class="source-inline">true</strong>:</p>
			<p class="source-code">// `FD` has the type of `const FunctionDecl&amp;`</p>
			<p class="source-code">const auto* Body = dyn_cast&lt;CompoundStmt&gt;(FD.getBody());</p>
			<p class="source-code">for(const auto* S : Body-&gt;body()) {</p>
			<p class="source-code">  if(const auto* L = dyn_cast&lt;WhileStmt&gt;(S)) {</p>
			<p class="source-code">    if(const auto* Cond = dyn_cast&lt;CXXBoolLiteralExpr&gt;      (L-&gt;getCond()))</p>
			<p class="source-code">      if(Cond-&gt;getValue()) {</p>
			<p class="source-code">        // The exit condition is `true`!!</p>
			<p class="source-code">      }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>As you can see, it created more than three (indention) layers of <strong class="source-inline">if</strong> statements to complete such a simple check. Not to mention in real-world cases, we need to insert even more sanity checks among these lines! While Clang's AST design is not hard to understand, we need a more <em class="italic">concise</em> syntax to complete pattern matching jobs. Fortunately, Clang has <a id="_idIndexMarker288"/>already provided one – the <strong class="bold">ASTMatcher</strong>.</p>
			<p>ASTMatcher is the utility that helps you write AST pattern matching logic via a clean, concise, and <a id="_idIndexMarker289"/>efficient <strong class="bold">Domain-Specific Language</strong> (<strong class="bold">DSL</strong>). Using ASTMatcher, doing the same matching shown in the previous snippet only takes few lines of code:</p>
			<p class="source-code">functionDecl(compountStmt(hasAnySubstatement(</p>
			<p class="source-code">  whileStmt(</p>
			<p class="source-code">    hasCondition(cxxBoolLiteral(equals(true)))))));</p>
			<p>Most of the directives in the preceding snippet are pretty straightforward: function calls such as <strong class="source-inline">compoundStmt(…)</strong> and <strong class="source-inline">whileStmt(…)</strong> check if the current node matches a specific node type. Here, the arguments in these function calls either represent pattern matchers on their subtree or check additional properties of the current node. There are also other directives for expressing qualifying concepts (for example, <em class="italic">for all substatements in this loop body, a return value exists</em>), such as <strong class="source-inline">hasAnySubstatement(…)</strong>, and directives for expressing data type and constant values such as the combination of <strong class="source-inline">cxxBoolLiteral(equals(true))</strong>.</p>
			<p>In short, using ASTMatcher can make your pattern matching logic more <em class="italic">expressive</em>. In this section, we showed you the basic usage of this elegant DSL.</p>
			<h3>Traversing AST</h3>
			<p>Before we dive into the <a id="_idIndexMarker290"/>core syntax, let's learn how ASTMatcher traverses AST and how it passes the result back to users after the matching process is completed.</p>
			<p><strong class="source-inline">MatchFinder</strong> is a commonly used driver for the pattern matching process. Its basic usage is pretty simple:</p>
			<p class="source-code">using namespace ast_matchers;</p>
			<p class="source-code">…</p>
			<p class="source-code">MatchFinder Finder;</p>
			<p class="source-code">// Add AST matching patterns to `MatchFinder`</p>
			<p class="source-code">Finder.<strong class="bold">addMatch</strong>(<strong class="bold">traverse</strong>(<strong class="bold">TK_AsIs</strong>, pattern1), Callback1);</p>
			<p class="source-code">Finder.addMatch(traverse(TK_AsIs, <strong class="bold">pattern2</strong>), <strong class="bold">Callback2</strong>);</p>
			<p class="source-code">…</p>
			<p class="source-code">// Match a given AST. `Tree` has the type of `ASTContext&amp;`</p>
			<p class="source-code">// If there is a match in either of the above patterns,</p>
			<p class="source-code">// functions in Callback1 or Callback2 will be invoked // accordingly</p>
			<p class="source-code">Finder.<strong class="bold">matchAST</strong>(Tree);</p>
			<p class="source-code">// …Or match a specific AST node. `FD` has the type of // `FunctionDecl&amp;`</p>
			<p class="source-code">Finder.match(FD, Tree);</p>
			<p><strong class="source-inline">pattern1</strong> and <strong class="source-inline">pattern2</strong> are pattern objects <a id="_idIndexMarker291"/>that are constructed by DSL, as shown previously. What's more interesting is the <strong class="source-inline">traverse</strong> function and the <strong class="source-inline">TK_AsIs</strong> argument. The <strong class="source-inline">traverse</strong> function is a part of the pattern matching DSL, but instead of expressing patterns, it describes the action of traversing AST nodes. On top of that, the <strong class="source-inline">TK_AsIs</strong> argument represents the <em class="italic">traversing mode</em>. </p>
			<p>When we showed you the command-line flag for dumping AST in textual format (<strong class="source-inline">-Xclang -ast-dump</strong>) earlier in this chapter, you may have found that many <em class="italic">hidden AST nodes</em> were inserted into the tree to assist with the program's semantics rather than representing the real code that was written by the programmers. For example, <strong class="source-inline">ImplicitCastExpr</strong> is inserted in lots of places to ensure the program's type correctness. Dealing with these nodes might be a painful experience when you're composing pattern matching logic. Thus, the <strong class="source-inline">traverse</strong> function provides an alternative, <em class="italic">simplified</em>, way to traverse the tree. Let's say we have the following input source code:</p>
			<p class="source-code">struct B {</p>
			<p class="source-code">  B(int);</p>
			<p class="source-code">};</p>
			<p class="source-code">B foo() { return 87; }</p>
			<p>When you pass <strong class="source-inline">TK_AsIs</strong> as the first argument to <strong class="source-inline">traverse</strong>, it observes the tree, similar <a id="_idIndexMarker292"/>to how <strong class="source-inline">-ast-dump</strong> does:</p>
			<p class="source-code">FunctionDecl</p>
			<p class="source-code">`-CompoundStmt</p>
			<p class="source-code">  `-ReturnStmt</p>
			<p class="source-code">    `-ExprWithCleanups</p>
			<p class="source-code">      `-CXXConstructExpr</p>
			<p class="source-code">        `-MaterializeTemporaryExpr</p>
			<p class="source-code">          `-ImplicitCastExpr</p>
			<p class="source-code">            `-ImplicitCastExpr</p>
			<p class="source-code">              `-CXXConstructExpr</p>
			<p class="source-code">                `-IntegerLiteral 'int' 87<a id="_idTextAnchor099"/></p>
			<p>However, by using <strong class="source-inline">TK_IgnoreUnlessSpelledInSource</strong> as the first argument, the tree that's observed is equal to the following one:</p>
			<p class="source-code">FunctionDecl</p>
			<p class="source-code">`-CompoundStmt</p>
			<p class="source-code">  `-ReturnStmt</p>
			<p class="source-code">    `-IntegerLiteral 'int' 87</p>
			<p>As its name suggests, <strong class="source-inline">TK_IgnoreUnlessSpelledInSource</strong> only visit nodes that are really shown in the source code. This greatly simplifies the process of writing a matching pattern since we don't need to worry about the nitty-gritty details of AST anymore.</p>
			<p>On the other hand, <strong class="source-inline">Callback1</strong> and <strong class="source-inline">Callback2</strong> in the first snippet are <strong class="source-inline">MatchFinder::MatchCallback</strong> objects that describe the actions to perform when there is a match. Here is <a id="_idIndexMarker293"/>the skeleton of a <strong class="source-inline">MatchCallback</strong> implementation:</p>
			<p class="source-code">struct MyMatchCallback : public MatchFinder::MatchCallback {</p>
			<p class="source-code">  void run(const MatchFinder::MatchResult &amp;Result) override {</p>
			<p class="source-code">    // Reach here if there is a match on the corresponding     // pattern</p>
			<p class="source-code">    // Handling "bound" result from `Result`, if there is any</p>
			<p class="source-code">  }</p>
			<p class="source-code">};</p>
			<p>In the next section, we will show you how to bind a specific part of the pattern with a tag and retrieve it in <strong class="source-inline">MatchCallback</strong>.</p>
			<p>Last but not least, though we used <strong class="source-inline">MatchFinder::match</strong> and <strong class="source-inline">MatchFinder::matchAST</strong> in the first snippet to kick off the matching process, there are other ways to do this. For example, you can use <strong class="source-inline">MatchFinder::newASTConsumer</strong> to create an <strong class="source-inline">ASTConsumer</strong> instance that will run the described pattern matching activity. Alternatively, you can use <strong class="source-inline">ast_matchers::match(…)</strong> (not a member function under <strong class="source-inline">MatchFinder</strong> but a standalone function) to perform matching on a provided pattern and <strong class="source-inline">ASTContext</strong> in a single run, before returning the matched node.</p>
			<h3>ASTMatcher DSL</h3>
			<p>ASTMatcher provides an easy-to-use and concise C++ DSL to help with matching AST. As we saw earlier, the <em class="italic">structure</em> of the desired pattern is expressed by nested function calls, where each of <a id="_idIndexMarker294"/>these functions represents the <em class="italic">type</em> of AST node to match.</p>
			<p>Using this DSL to express simple patterns cannot be easier. However, when you're trying to compose patterns with multiple conditions/predicates, things get a little bit more complicated. For example, although we know a for loop (for example, <strong class="source-inline">for(I = 0; I &lt; 10; ++I){…}</strong>) can be matched by the <strong class="source-inline">forStmt(…)</strong> directive, how do we add a condition to its initialize statement (<strong class="source-inline">I = 0</strong> ) and exit the condition (<strong class="source-inline">I &lt; 10</strong>) or its loop body? Not only does the official API reference site (the doxygen website we usually use) lacks clear documentation on this part, most of these DSL functions are also pretty flexible in how they accept a wide range of arguments as their subpatterns. For example, following the question on matching a <strong class="source-inline">for</strong> loop, you can use the following code to check only the loop's body:</p>
			<p class="source-code">forStmt(hasBody(…));</p>
			<p>Alternatively, you can check its loop body and its exit condition, like so:</p>
			<p class="source-code">forStmt(hasBody(…),</p>
			<p class="source-code">        hasCondition(…));</p>
			<p>A generalized version of this question would be, given an arbitrary DSL directive, how do we know the <em class="italic">available</em> directives that can be combined with it?</p>
			<p>To answer this question, we will leverage a documentation website LLVM specifically created for ASTMatcher: <a href="https://clang.llvm.org/docs/LibASTMatchersReference.html">https://clang.llvm.org/docs/LibASTMatchersReference.html</a>. This website consists of a huge three-column table showing the returned type and argument types for each of the DSL directives:</p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/Figure_7.4_B14590.jpg" alt="Figure 7.4 – Part of the ASTMatcher DSL reference&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4 – Part of the ASTMatcher DSL reference</p>
			<p>Though this table is just a simplified version of normal API references, it already shows you how to search for candidate directives. For example, now that you know <strong class="source-inline">forStmt(…)</strong> takes zero or multiple <strong class="source-inline">Matcher&lt;ForStmt&gt;</strong>, we can search this table for directives that return either <strong class="source-inline">Matcher&lt;ForStmt&gt;</strong> or <strong class="source-inline">Matcher&lt;(parent class of ForStmt)&gt;</strong>, such as <strong class="source-inline">Matcher&lt;Stmt&gt;</strong>. In this case, we can quickly spot <strong class="source-inline">hasCondition</strong>, <strong class="source-inline">hasBody</strong>, <strong class="source-inline">hasIncrement</strong>, or <strong class="source-inline">hasLoopInit</strong> as candidates (of course, many other directives that return <strong class="source-inline">Matcher&lt;Stmt&gt;</strong> can also be used).</p>
			<p>When you're performing <a id="_idIndexMarker295"/>pattern matching, there are many cases where you not only want to know if a pattern matches or not but also get the matched AST nodes. In the context of ASTMatcher, its DSL directives only check the <em class="italic">type</em> of the AST nodes. If you want to retrieve (part of the) concrete AST nodes that are being matched, you can use the <strong class="source-inline">bind(…)</strong> API. Here is an example:</p>
			<p class="source-code">forStmt(</p>
			<p class="source-code">  hasCondition(</p>
			<p class="source-code">    <strong class="bold">expr().bind("exit_condition")</strong>));</p>
			<p>Here, we used <strong class="source-inline">expr()</strong> as a wildcard pattern to match any <strong class="source-inline">Expr</strong> node. This directive also calls <strong class="source-inline">bind(…)</strong> to associate the matched <strong class="source-inline">Expr</strong> AST node with the name <strong class="source-inline">exit_condition</strong>.</p>
			<p>Then, in <strong class="source-inline">MatchCallback</strong>, which we introduced earlier, we can retrieve the bound node by using the following code:</p>
			<p class="source-code">…</p>
			<p class="source-code">void run(const MatchFinder::MatchResult &amp;Result) override {</p>
			<p class="source-code">  cons auto&amp; Nodes = Result.Nodes;</p>
			<p class="source-code">  const Expr* CondExpr = Nodes.<strong class="bold">getNodeAs&lt;Expr&gt;    ("exit_condition")</strong>;</p>
			<p class="source-code">  // Use `CondExpr`…</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">getNodeAs&lt;…&gt;(…)</strong> function <a id="_idIndexMarker296"/>tries to fetch the bound AST node under the given name and cast it to the type suggested by the template argument.</p>
			<p>Note that you're allowed to bind different AST nodes under the same name, in which case only the last bounded one will be shown in <strong class="source-inline">MatchCallback::run</strong>.</p>
			<h3>Putting everything together</h3>
			<p>Now that you've learned about both the pattern matching DSL syntax and how to traverse AST using ASTMatcher, let's put these two things together.</p>
			<p>Let's say we want to know the number of <a id="_idIndexMarker297"/>iterations – also known as the <em class="italic">trip count</em> – that a simple <strong class="source-inline">for</strong> loop (the loop index starts from zero and is incremented by one at each iteration and bounded by a literal integer) has in a function:</p>
			<ol>
				<li>First, we must write the following code for matching and traversing:<p class="source-code">auto PatExitCondition = binaryOperator(</p><p class="source-code">                           hasOperatorName("&lt;"),</p><p class="source-code">                           hasRHS(integerLiteral()</p><p class="source-code">                           .bind("trip_count")));</p><p class="source-code">auto Pattern = functionDecl(</p><p class="source-code">                 compountStmt(hasAnySubstatement(</p><p class="source-code">              forStmt(hasCondition(PatExitCondition)))));</p><p class="source-code">MatchFinder Finder;</p><p class="source-code">auto* Callback = new MyMatchCallback();</p><p class="source-code">Finder.addMatcher(traverse(TK_IgnoreUnlessSpelledInSource,</p><p class="source-code">                           Pattern), Callback);</p><p>The preceding snippet also shows how <em class="italic">modular</em> DSL patterns are. You can create individual pattern fragments and compose them depending on your needs, as long as they're compatible.</p><p>Finally, here is what <strong class="source-inline">MyMatchCallback::run</strong> looks like:</p><p class="source-code">void run(const MatchFinder::MatchResult &amp;Result) override {</p><p class="source-code">  const auto&amp; Nodes = Result.Nodes;</p><p class="source-code">  const auto* TripCount = </p><p class="source-code">        Nodes.getNodeAs&lt;IntegerLiteral&gt;("trip_count");</p><p class="source-code">  if (TripCount)</p><p class="source-code">    TripCount-&gt;dump(); // print to llvm::errs()</p><p class="source-code">}</p></li>
				<li>After this, you can use <strong class="source-inline">Finder</strong> to match the desired pattern (either by calling <strong class="source-inline">MatchFinder::match</strong> or <strong class="source-inline">MatchFinder::matchAST</strong>, or by creating an <strong class="source-inline">ASTConsumer</strong> using <strong class="source-inline">MatchFinder::newASTConsumer</strong>) on an AST. The matched trip count will be printed to <strong class="source-inline">stderr</strong>. For instance, if the input source code is <strong class="source-inline">for(int i = 0; i &lt; 10; ++i) {…}</strong>, the output will simply be <strong class="source-inline">10</strong>.</li>
			</ol>
			<p>In this section, we learned how Clang structures its AST, how Clang AST is represented in memory, and how to use ASTMatcher to help developers with AST pattern matching. With this knowledge, in the next section, we will show you how to create an AST plugin, which is one of the easiest ways to inject custom logic into Clang's compilation pipeline.</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor100"/>Writing AST plugins</h1>
			<p>In the previous section, we learned how AST is represented in Clang and learned what its in-memory <a id="_idIndexMarker298"/>classes look like. We also learned about some useful skills we can use to perform pattern matching on Clang AST. In this section, we will learn how to write plugins that allow you to insert custom AST processing logic into Clang's compilation pipeline.</p>
			<p>This section will be divided into three parts:</p>
			<ul>
				<li><strong class="bold">Project overview</strong>: The goal and overview of the demo project we are going to create in this section.</li>
				<li><strong class="bold">Printing diagnostic messages</strong>: Before we dive into the core of developing a plugin, we are going to learn how to use Clang's <strong class="source-inline">DiagnosticsEngine</strong>, a powerful subsystem that helps you print out well-formatted and meaningful diagnostic messages. This will make our demo project more applicable to real-world scenarios.</li>
				<li><strong class="bold">Creating the AST plugin</strong>: This section will show you how to create an AST plugin from scratch, fill in all the implementation details, and how to run it with Clang.</li>
			</ul>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor101"/>Project overview</h2>
			<p>In this section, we will create a <a id="_idIndexMarker299"/>plugin that prompts the user with warning messages whenever there are <strong class="source-inline">if</strong>-<strong class="source-inline">else</strong> statements in the input code that can be converted into <strong class="bold">ternary operators</strong>.</p>
			<p class="callout-heading">Quick Refresher – Ternary Operator</p>
			<p class="callout">The <a id="_idIndexMarker300"/>ternary operator, <strong class="source-inline">x? val_1 : val_2</strong>, is evaluated to <strong class="source-inline">val_1</strong> when the <strong class="source-inline">x</strong> condition is true. Otherwise, it is evaluated to <strong class="source-inline">val_2</strong>.</p>
			<p>For example, let's look at the following C/C++ snippet:</p>
			<p class="source-code">int foo(int c) {</p>
			<p class="source-code">  if (c &gt; 10) {</p>
			<p class="source-code">    return c + 100;</p>
			<p class="source-code">  } else {</p>
			<p class="source-code">    return 94;</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">void bar(int x) {</p>
			<p class="source-code">  int a;</p>
			<p class="source-code">  if (x &gt; 10) {</p>
			<p class="source-code">    a = 87;</p>
			<p class="source-code">  } else {</p>
			<p class="source-code">    a = x – 100;</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">if</strong>-<strong class="source-inline">else</strong> statements in <a id="_idIndexMarker301"/>both functions can be converted into ternary operators, like this:</p>
			<p class="source-code">int foo(int c) {</p>
			<p class="source-code">  return <strong class="bold">c &gt; 10? c + 100 : 94</strong>;</p>
			<p class="source-code">}</p>
			<p class="source-code">void bar(int x) {</p>
			<p class="source-code">  int a;</p>
			<p class="source-code">  a = <strong class="bold">x &gt; 10? 87 : x – 100</strong>;</p>
			<p class="source-code">}</p>
			<p>In this project, we will only focus on finding two kinds of potential ternary operator opportunities:</p>
			<ul>
				<li>Both the <strong class="source-inline">then</strong> block (true branch) and the <strong class="source-inline">else</strong> block (false branch) contain a single <strong class="source-inline">return</strong> statement. In this case, we can coalesce their return values and the branch condition into one ternary operator (as the new returned value).</li>
				<li>Both the <strong class="source-inline">then</strong> block and the <strong class="source-inline">else</strong> block only contain a single assignment statement. Both statements use a single <strong class="source-inline">DeclRefExpr</strong> – that is, a symbol reference – as the LHS, and both <strong class="source-inline">DeclRefExpr</strong> objects point to the same <strong class="source-inline">Decl</strong> (symbol). In other <a id="_idIndexMarker302"/>words, we are covering the case of the <strong class="source-inline">bar</strong> function shown in the preceding snippet. Note that we are not covering cases where the LHS is more complicated; for example, where an array subscription, <strong class="source-inline">a[i]</strong>, is used as the LHS.</li>
			</ul>
			<p>After identifying these patterns, we must prompt warning messages to the user and provide extra information to help the user fix this issue:</p>
			<p class="source-code">$ clang …(flags to run the plugin) ./test.c</p>
			<p class="source-code">./test.c:2:3: <strong class="bold">warning</strong>: this if statement can be converted to ternary operator:</p>
			<p class="source-code">  if (c &gt; 10) {</p>
			<p class="source-code">  ^</p>
			<p class="source-code">./test.c:3:12: <strong class="bold">note</strong>: with true expression being this:</p>
			<p class="source-code">    return c + 100;</p>
			<p class="source-code">           ^</p>
			<p class="source-code">./test.c:5:12: <strong class="bold">note</strong>: with false expression being this:</p>
			<p class="source-code">    return 94;</p>
			<p class="source-code">           ^</p>
			<p class="source-code">./test.c:11:3: <strong class="bold">warning</strong>: this if statement can be converted to ternary operator:</p>
			<p class="source-code">  if (x &gt; 10) {</p>
			<p class="source-code">  ^</p>
			<p class="source-code">./test.c:12:9: <strong class="bold">note</strong>: with true expression being this:</p>
			<p class="source-code">    a = 87;</p>
			<p class="source-code">        ^</p>
			<p class="source-code">./test.c:14:9: <strong class="bold">note</strong>: with false expression being this:</p>
			<p class="source-code">    a = x - 100;</p>
			<p class="source-code">        ^</p>
			<p class="source-code">2 warnings generated.</p>
			<p>Each warning message – which tells you which <strong class="source-inline">if</strong>-<strong class="source-inline">else</strong> statement can be converted into a ternary operator – is <a id="_idIndexMarker303"/>followed by two notes pointing out the potential expressions to construct for the operator.</p>
			<p>Compared to handcrafting compiler messages, as we did in the <em class="italic">Developing custom preprocessor plugins and callbacks</em> section of <a href="B14590_06_Final_JC_ePub.xhtml#_idTextAnchor078"><em class="italic">Chapter 6</em></a>, <em class="italic">Extending the Preprocessor</em>, here, we are using Clang's diagnostics infrastructure to print messages that carry richer information, such as the snapshot of code that the message is referring to. We will show you how to use that <a id="_idTextAnchor102"/>diagnostic infrastructure next.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor103"/>Printing diagnostic messages</h2>
			<p>In <a href="B14590_06_Final_JC_ePub.xhtml#_idTextAnchor078"><em class="italic">Chapter 6</em></a>, <em class="italic">Extending the Preprocessor</em>, we asked <a id="_idIndexMarker304"/>if you could improve the <a id="_idIndexMarker305"/>warning message format in the example project shown in the <em class="italic">Developing custom preprocessor plugins and callbacks</em> section, so that it's closer to the compiler messages you saw from Clang. One of the solutions to that question is using Clang's diagnostic framework. We are going to look at this in this section.</p>
			<p>Clang's diagnostic framework <a id="_idIndexMarker306"/>consists of three primary parts: </p>
			<ul>
				<li><strong class="bold">Diagnostic IDs</strong></li>
				<li><strong class="bold">Diagnostic engine</strong></li>
				<li><strong class="bold">Diagnostic consumers (clients)</strong></li>
			</ul>
			<p>Their relationships can be seen in the following diagram:</p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/Figure_7.5_B14590.jpg" alt="Figure 7.5 – High-level organization of Clang's diagnostic framework&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – High-level organization of Clang's diagnostic framework</p>
			<h3>Diagnostic messages</h3>
			<p>Starting from the left-hand side of the <a id="_idIndexMarker307"/>preceding diagram, most of the time, a diagnostic message – for example, <em class="italic">use of undeclared identifier "x"</em> – is <a id="_idIndexMarker308"/>associated with a message <strong class="bold">template</strong> that has its own diagnostic ID. Using the undeclared identifier message, for example, its message template looks like this:</p>
			<p class="source-code">"use of undeclared identifier <strong class="bold">%0</strong>"</p>
			<p><strong class="source-inline">%0</strong> is a <strong class="bold">placeholder</strong> that will be filled in by supplemental data later. In this case, it is the concrete identifier name (<strong class="source-inline">x</strong>, in the preceding example message). The number following <strong class="source-inline">%</strong> also suggests which supplemental data it will use. We will cover this format in detail shortly.</p>
			<p>Templates are registered with the diagnostic engine via TableGen syntax. For example, the message we are discussing here is put inside <strong class="source-inline">clang/include/clang/Basic/DiagnosticSemaKinds.td</strong>:</p>
			<p class="source-code">def <strong class="bold">err_undeclared_var_use</strong> : <strong class="bold">Error</strong>&lt;"use of undeclared identifier %0"&gt;;</p>
			<p>We highlighted two parts in the preceding snippet. First, the name of this message template, <strong class="source-inline">err_undeclared_var_use</strong>, will be used later as the unique diagnostic ID. Second, the <strong class="source-inline">Error</strong> TableGen class suggested that this is an error message, or more formally speaking, its <em class="italic">diagnostic level</em> error.</p>
			<p>In summary, a <a id="_idIndexMarker309"/>diagnostic message consists of a <a id="_idIndexMarker310"/>unique diagnostic ID – which is associated with a message template and its diagnostic level – and the supplemental data to put in the placeholders of the template, if there are any.</p>
			<h3>Diagnostic consumers</h3>
			<p>After the diagnostic <a id="_idIndexMarker311"/>message is sent to the diagnostic engine – represented by the <strong class="source-inline">DiagnosticsEngine</strong> class – the engine formats the messages into textual contents <a id="_idIndexMarker312"/>and send them to one of the <strong class="bold">diagnostic consumers</strong> (also called <strong class="bold">clients</strong> in the <a id="_idIndexMarker313"/>code base; we will use the term <strong class="bold">consumer</strong> in rest of this section).</p>
			<p>A diagnostic consumer – an implementation of the <strong class="source-inline">DiagnosticConsumer</strong> class – post-processes the textual messages sent from <strong class="source-inline">DiagnosticsEngine</strong> and exports them via different mediums. For example, the default <strong class="source-inline">TextDiagnosticPrinter</strong> prints messages to the command-line interface; <strong class="source-inline">LogDiagnosticPrinter</strong>, on the other hand, decorates the incoming messages with simple XML tags before printing them into log files. In theory, you can even create a custom <strong class="source-inline">DiagnosticConsumer</strong> that sends diagnostic messages to a remote host!</p>
			<h3>Reporting diagnostic messages</h3>
			<p>Now that you <a id="_idIndexMarker314"/>have learned how Clang's diagnostic framework works, let's learn how to send (report) a diagnostic message to <strong class="source-inline">DiagnosticEngine</strong>:</p>
			<ol>
				<li value="1">First, we need to retrieve a reference to <strong class="source-inline">DiagnosticEngine</strong>. The engine itself is sitting at the core of Clang's compilation pipeline, so you can fetch it from various primary components, such as <strong class="source-inline">ASTContext</strong> and <strong class="source-inline">SourceManager</strong>. The following is an example:<p class="source-code">// `Ctx` has the type of `ASTContext&amp;`</p><p class="source-code">DiagnosticsEngine&amp; Diag = Ctx.<strong class="bold">getDiagnostics</strong>();</p></li>
				<li>Next, we need to use the <strong class="source-inline">DiagnosticsEngine::Report</strong> function. This function always takes a diagnostic ID as one of its arguments. For example, to report <strong class="source-inline">err_undeclared_var_use</strong>, which we introduced earlier, use the following code:<p class="source-code">Diag.Report(<strong class="bold">diag::err_undeclared_var_use</strong>);</p><p>However, we know that <strong class="source-inline">err_undeclared_var_use</strong> takes one placeholder argument – namely, the identifier name – which is supplied through concatenating the <strong class="source-inline">Report</strong> function call with <strong class="source-inline">&lt;&lt;</strong> operators:</p><p class="source-code">Diag.Report(diag::err_undeclared_var_use) <strong class="bold">&lt;&lt; ident_name_str</strong>;</p></li>
				<li>Recall that <strong class="source-inline">err_undeclared_var_use</strong> only has one placeholder, <strong class="source-inline">%0</strong>, so it picks up the first values in the following <strong class="source-inline">&lt;&lt;</strong> stream. Let's say we have a diagnostic message, <strong class="source-inline">err_invalid_placement</strong>, with the following template:<p class="source-code">"you cannot put <strong class="bold">%1</strong> into <strong class="bold">%0</strong>"</p></li>
				<li>You can report this using the following code:<p class="source-code">Diag.Report(diag::err_invalid_placement)</p><p class="source-code">             &lt;&lt; "<strong class="source-inline">boiling oil</strong>" &lt;&lt; "<strong class="source-inline">water</strong>";</p></li>
				<li>In addition to simple placeholders, another useful feature is the <strong class="source-inline">%select</strong> directive. For example, we have a diagnostic message, <strong class="source-inline">warn_exceed_limit</strong>, with a template like this:<p class="source-code">"you exceed the daily <strong class="bold">%select{wifi|cellular network}0</strong> limit"</p><p>The <strong class="source-inline">%select</strong> directive consists of curly braces in which different message options are separated by <strong class="source-inline">|</strong>. Outside the curly braces, a number – <strong class="source-inline">0</strong>, in the preceding code – indicates which supplement data is used to select the option within the braces. The following is an example of this:</p><p class="source-code">Diag.Report(diag::warn_exceed_limit) &lt;&lt; <strong class="bold">1</strong>;</p><p>The preceding snippet will <a id="_idIndexMarker315"/>output <strong class="bold">You exceed the daily cellular network limit</strong>. Let's say you use <strong class="source-inline">0</strong> as the parameter after the stream operator (<strong class="source-inline">&lt;&lt;</strong>):</p><p class="source-code">Diag.Report(diag::warn_exceed_limit) &lt;&lt; <strong class="bold">0</strong>;</p><p>This will result in a message stating <strong class="bold">you exceed the daily wifi limit</strong>.</p></li>
				<li>Now, let's say you use another version of the <strong class="source-inline">Report</strong> function, which takes an additional <strong class="source-inline">SourceLocation</strong> argument:<p class="source-code">// `SLoc` has the type of `SourceLocation`</p><p class="source-code">Diag.Report(<strong class="bold">SLoc</strong>, diag::err_undeclared_var_use)</p><p class="source-code">                  &lt;&lt; ident_name_str;</p><p>The output message will contain part of the source code being pointed to by <strong class="source-inline">SLoc</strong>:</p><p class="source-code">test.cc:2:10: error: use of undeclared identifier 'x'</p><p class="source-code">  <strong class="bold">return x + 1;</strong></p><p class="source-code"><strong class="bold">         ^</strong></p></li>
				<li>Last but not least, though most of the diagnostic messages are registered with <strong class="source-inline">DiagnosticsEngine</strong> via TableGen code put <em class="italic">inside</em> Clang's source tree, this doesn't mean that developers cannot create their new diagnostic messages without modifying Clang's source tree. Let's introduce <strong class="source-inline">DiagnosticsEngine::getCustomDiagID(…)</strong>, the API that creates a new diagnostic ID from a message template and diagnostic level provided by developers:<p class="source-code">auto MyDiagID = Diag.<strong class="bold">getCustomDiagID</strong>(DiagnosticsEngine::<strong class="bold">Note</strong>,</p><p class="source-code"><strong class="bold">"Today's weather is %0"</strong>);</p><p>The preceding <a id="_idIndexMarker316"/>snippet creates a new diagnostic ID, <strong class="source-inline">MyDiagID</strong>, that has a message template of <strong class="bold">Today's weather is %0</strong> at its note diagnostic level. You can use this diagnostic ID just like any other ID:</p><p class="source-code">Diag.Report(<strong class="bold">MyDiagID</strong>) &lt;&lt; "cloudy";</p></li>
			</ol>
			<p>In this section, you learned how to leverage Clang's diagnostic framework to print out messages just like normal compiler messages.</p>
			<p>Next, we are going to combine all the skills we've learned about in this chapter to create a custom AST plugin.</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor104"/>Creating the AST plugin</h2>
			<p>In the previous sections <a id="_idIndexMarker317"/>of this chapter, we explored Clang's AST and learned how to use it in in-memory APIs. In this section, we will learn how to write a plugin that helps you insert your custom AST processing logic into Clang's compilation pipeline in an easy way.</p>
			<p>In <a href="B14590_05_Final_JC_ePub.xhtml#_idTextAnchor067"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Clang's Architecture</em>, we learned about the advantages of using Clang (AST) plugins: they can be developed even you are using a prebuilt <strong class="source-inline">clang</strong> executable, they are easy to write, and they have good integration with the existing toolchain and build systems, to name a few. In <a href="B14590_06_Final_JC_ePub.xhtml#_idTextAnchor078"><em class="italic">Chapter 6</em></a>, <em class="italic">Extending the Preprocessor</em>, we developed a plugin for custom pragma handling in the preprocessor. In this chapter, we will also be writing a plugin, but this one will be designed for custom AST processing. The code skeletons for these two plugins are also quite different.</p>
			<p>We introduced the sample project we will be using in this section in the <em class="italic">Project overview</em> section. This plugin will prompt users with warning messages if some <strong class="source-inline">if</strong>-<strong class="source-inline">else</strong> statements in the input code can be converted into ternary operators. In addition, it also shows extra hints about candidate expressions for building the ternary operator.</p>
			<p>Here are the detailed steps for building the plugin:</p>
			<ol>
				<li value="1">Similar to the pragma plugin we saw in <a href="B14590_06_Final_JC_ePub.xhtml#_idTextAnchor078"><em class="italic">Chapter 6</em></a>, <em class="italic">Extending the Preprocessor</em>, creating a plugin in Clang is basically like implementing a class. In the case of the AST plugin, this will be the <strong class="source-inline">PluginASTAction</strong> class.<p><strong class="source-inline">PluginASTAction</strong> is a subclass of <strong class="source-inline">ASTFrontendAction</strong> – a <strong class="source-inline">FrontendAction</strong> specialized for handling AST (if you're not familiar with <strong class="source-inline">FrontendAction</strong>, feel free to read <a href="B14590_05_Final_JC_ePub.xhtml#_idTextAnchor067"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Clang's Architecture</em>, again). Thus, we <a id="_idIndexMarker318"/>need to implement the <strong class="source-inline">CreateASTConsumer</strong> member function:</p><p class="source-code">struct TernaryConverterAction : public <strong class="bold">PluginASTAction</strong> {</p><p class="source-code">  std::unique_ptr&lt;ASTConsumer&gt;</p><p class="source-code">    <strong class="bold">CreateASTConsumer</strong>(CompilerInstance &amp;CI,</p><p class="source-code">                      StringRef InFile) override;</p><p class="source-code">};</p><p>We will fill in this function later.</p></li>
				<li>In addition to <strong class="source-inline">CreateASTConsumer</strong>, there are two other member functions we can override to change some of the functionalities: <strong class="source-inline">getActionType</strong> and <strong class="source-inline">ParseArgs</strong>. The former tells Clang <em class="italic">how</em> this plugin should be executed by returning one of the enum values shown here:<p>a.<strong class="source-inline"> Cmdline</strong>: The plugin will be executed after the main action if users provide the <strong class="source-inline">-plugin &lt;plugin name&gt;</strong> (frontend) command-line flag.</p><p>b.<strong class="source-inline"> ReplaceAction</strong>: This replaces the original action Clang was going to perform. For example, if Clang was supposed to compile input code into an object file (the <strong class="source-inline">-c</strong> flag), it will execute the plugin's action instead once the plugin has been loaded.</p><p>c.<strong class="source-inline"> AddBefore/AfterMainAction</strong>: The original Clang action will still be executed, and the plugin action will be prepended/appended to it.</p><p>Here, we will use the <strong class="source-inline">Cmdline</strong> action type:</p><p class="source-code">struct TernaryConverterAction : public PluginASTAction {</p><p class="source-code">  …</p><p class="source-code">  ActionType getActionType() override { return <strong class="bold">Cmdline</strong>; }</p><p class="source-code">};</p><p>The <strong class="source-inline">ParseArgs</strong> member function, on the other hand, handles (frontend) command-line options <a id="_idIndexMarker319"/>specific to this plugin. In other words, you can create custom command-line flags for your plugin. In our case, we are going to create two flags: <strong class="source-inline">-no-detect-return</strong> and <strong class="source-inline">-no-detect-assignment</strong>. This allows us to decide whether we wish to detect potential ternary conversions regarding <strong class="source-inline">return</strong> statements or assignment statements, respectively:</p><p class="source-code">struct TernaryConverterAction : public PluginASTAction {</p><p class="source-code">  …</p><p class="source-code">  bool <strong class="bold">NoAssignment</strong> = false,</p><p class="source-code">       <strong class="bold">NoReturn</strong> = false;</p><p class="source-code">  bool ParseArgs(const CompilerInstance &amp;CI,</p><p class="source-code">         const std::vector&lt;std::string&gt; &amp;Args) override {</p><p class="source-code">    for (const auto &amp;Arg : Args) {</p><p class="source-code">      if (Arg == <strong class="bold">"-no-detect-assignment"</strong>) NoAssignment =         true;</p><p class="source-code">      if (Arg == <strong class="bold">"-no-detect-return"</strong>) NoReturn = true;</p><p class="source-code">    }</p><p class="source-code">    <strong class="bold">return true</strong>;    </p><p class="source-code">  }</p><p class="source-code">};</p><p>As shown in the preceding snippet, we created two boolean flags, <strong class="source-inline">NoReturn</strong> and <strong class="source-inline">NoAssignment</strong>, to carry our command-line options' values. An important thing to know is the return value for <strong class="source-inline">ParseArgs</strong>. Instead of returning <em class="italic">if it parsed any custom flag</em>, <strong class="source-inline">ParseArgs</strong> is actually returning <em class="italic">if the plugin should continue its execution</em>. Therefore, you should always return true in most cases.</p></li>
				<li>Now, we are going to talk <a id="_idIndexMarker320"/>about the content of <strong class="source-inline">CreateASTConsumer</strong>. This function will return an <strong class="source-inline">ASTConsumer</strong> object, which is the main body that we will put our custom logic in. Nevertheless, we are not going to directly implement an <strong class="source-inline">ASTConsumer</strong>. Instead, we are going to us the <strong class="source-inline">ASTConsumer</strong> object that was generated by <em class="italic">ASTMatcher</em>, which we introduced earlier in this chapter.<p>Recall that two things are required to build a <strong class="source-inline">MatchFinder</strong> instance – the primary pattern matching driver in ASTMatcher (patterns written in ASTMatcher's own DSL) and a <strong class="source-inline">MatchCallback</strong> implementation. Let's separate our patterns and matcher callbacks into two categories: patterns for detecting potential ternary operator opportunities based on <strong class="source-inline">return</strong> statements and those for detecting <em class="italic">assignment-statement-based opportunities</em>.</p><p>Here is the skeleton for <strong class="source-inline">CreateASTConsumer</strong>:</p><p class="source-code">using namespace ast_matchers;</p><p class="source-code">struct TernaryConverterAction : public PluginASTAction {</p><p class="source-code">  …</p><p class="source-code">private:</p><p class="source-code">  std::unique_ptr&lt;MatchFinder&gt; <strong class="bold">ASTFinder</strong>;</p><p class="source-code">  std::unique_ptr&lt;MatchFinder::MatchCallback&gt;     <strong class="bold">ReturnMatchCB</strong>, <strong class="bold">AssignMatchCB</strong>;</p><p class="source-code">};</p><p class="source-code">std::unique_ptr&lt;ASTConsumer&gt;</p><p class="source-code">TernaryConverterAction::CreateASTConsumer (CompilerInstance &amp;CI, StringRef InFile) {</p><p class="source-code">  ASTFinder = std::make_unique&lt;MatchFinder&gt;();</p><p class="source-code">  // Return matcher</p><p class="source-code">  if (!NoReturn) {</p><p class="source-code">    ReturnMatchCB = /*<strong class="bold">TODO: Build MatcherCallback       instance</strong>*/</p><p class="source-code">    ASTFinder-&gt;addMatcher(traverse      (TK_IgnoreUnlessSpelledInSource, </p><p class="source-code">      /*<strong class="bold">TODO: Patterns in DSL</strong>*/), ReturnMatchCB.get());</p><p class="source-code">  }</p><p class="source-code">  // Assignment matcher</p><p class="source-code">  if (!NoAssignment) {</p><p class="source-code">    AssignMatchCB = /*<strong class="bold">TODO: Build MatcherCallback       instance</strong>*/</p><p class="source-code">    ASTFinder-&gt;addMatcher(traverse      (TK_IgnoreUnlessSpelledInSource,</p><p class="source-code">       /*<strong class="bold">TODO: Patterns in DSL</strong>*/), AssignMatchCB.get());</p><p class="source-code">  }</p><p class="source-code">  return std::move(<strong class="bold">ASTFinder-&gt;newASTConsumer</strong>());</p><p class="source-code">}</p><p>The preceding code <a id="_idIndexMarker321"/>created three additional <strong class="source-inline">unique_ptr</strong> type member variables: one for holding <strong class="source-inline">MatchFinder</strong> and two <strong class="source-inline">MatchCallback</strong> ones for return-based and assignment-based patterns.</p><p class="callout-heading">Why Use unique_ptr?</p><p class="callout">The rationale behind using <strong class="source-inline">unique_ptr</strong> to store those three objects – or storing those objects <em class="italic">persistently</em> – is because the <strong class="source-inline">ASTConsumer</strong> instance we created at the end of <strong class="source-inline">CreateASTConsumer</strong> (<strong class="source-inline">ASTFinder-&gt;newASTConsumer()</strong>) keeps references to those three objects. Thus, we need a way to keep them alive during the lifetime of the frontend.</p><p>In addition to that, we registered the pattern for traversal with MatchFinder by using <strong class="source-inline">MatchFinder::addMatcher</strong>, the <strong class="source-inline">traverse</strong> function, and <strong class="source-inline">MatchCallback</strong> instances. If you're not familiar with these APIs, feel free to check out the <em class="italic">ASTMatcher</em> section.</p><p>Now, we only need to compose the matching patterns and implement some callbacks to print out warning messages if there is a match – as the <strong class="source-inline">TODO</strong> comments suggested in the preceding snippet.</p></li>
				<li>Let's deal with the patterns first. The patterns we are looking for – both return-based and assignment-based patterns – have <strong class="source-inline">if</strong>-<strong class="source-inline">else</strong> statements (<strong class="source-inline">IfStmt</strong>) enclosed by a function (<strong class="source-inline">FunctionDecl</strong> for the entire function and <strong class="source-inline">CompoundStmt</strong> for the <a id="_idIndexMarker322"/>function body) in their outermost layout. Inside both, in the true branch and false branch of <strong class="source-inline">IfStmt</strong>, only one statement can exist. This structure can be illustrated like so:<p class="source-code">FunctionDecl </p><p class="source-code">  |_CompoundStmt</p><p class="source-code">    |_(Other AST nodes we don't care)</p><p class="source-code">    |_IfStmt</p><p class="source-code">      |_(true branch: contain only one return/assign         statement)</p><p class="source-code">      |_(false branch: contain only one return/assign         statement)</p><p>To convert this concept into ASTMatcher's DSL, here is the DSL code that's shared between the return-based and assignment-based patterns:</p><p class="source-code">functionDecl(</p><p class="source-code">  compoundStmt(hasAnySubstatement</p><p class="source-code">    IfStmt(</p><p class="source-code">      hasThen(/*<strong class="bold">TODO: Sub-pattern</strong>*/)</p><p class="source-code">      hasElse(/*<strong class="bold">TODO: Sub-pattern</strong>*/)</p><p class="source-code">    )</p><p class="source-code">  )</p><p class="source-code">);</p><p>One important thing to remember is that when you're dealing with <strong class="source-inline">CompoundStmt</strong>, you should always use quantifier directives such as <strong class="source-inline">hasAnySubstatement</strong> to match its body statements.</p><p>We are going to use the previous <strong class="source-inline">TODO</strong> comments to customize for either return-based or assignment-based situations. Let's use subpattern variables to replace those <strong class="source-inline">TODO</strong> <a id="_idTextAnchor105"/>comments and put <a id="_idIndexMarker323"/>the preceding code into another function:</p><p class="source-code">StatementMatcher</p><p class="source-code">buildIfStmtMatcher(StatementMatcher <strong class="bold">truePattern</strong>,</p><p class="source-code">                   StatementMatcher <strong class="bold">falsePattern</strong>) {</p><p class="source-code">  return functionDecl(</p><p class="source-code">    compoundStmt(hasAnySubstatement</p><p class="source-code">      IfStmt(</p><p class="source-code">        hasThen(<strong class="bold">truePattern</strong>)</p><p class="source-code">        hasElse(<strong class="bold">falsePattern</strong>))));</p><p class="source-code">}</p></li>
				<li>For return-based patterns, the subpatterns for both the <strong class="source-inline">if</strong>-<strong class="source-inline">else</strong> branches mentioned in the previous step are identical and simple. We're also using a separate function to create this pattern:<p class="source-code">StatementMatcher buildReturnMatcher() {</p><p class="source-code">  return compoundStmt(<strong class="bold">statementCountIs(1)</strong>,</p><p class="source-code">                      hasAnySubstatement(</p><p class="source-code">                        returnStmt(</p><p class="source-code">                          <strong class="bold">hasReturnValue</strong>(<strong class="bold">expr</strong>()))));</p><p class="source-code">}</p><p>As shown in the preceding snippet, we are using the <strong class="source-inline">statementCountIs</strong> directive to match the code blocks with only one statement. Also, we specified that we don't want an empty return via <strong class="source-inline">hasReturnValue(…)</strong>. The argument for <strong class="source-inline">hasReturnValue</strong> is necessary since the latter takes at least one argument, but since we don't care what type of node it is, we are using <strong class="source-inline">expr()</strong> as some sort of wildcard pattern.</p><p>For assignment-based patterns, things get a little bit complicated: we don't just want to match a single assignment statement (modeled by the <strong class="source-inline">BinaryOperator</strong> class) in both branches – the LHS of those assignments need to be <strong class="source-inline">DeclRefExpr</strong> expressions that point to the same <strong class="source-inline">Decl</strong> instance. Unfortunately, we are not able to <a id="_idIndexMarker324"/>express all these predicates using ASTMatch's DSL. What we can do, however, is push off some of those checks into <strong class="source-inline">MatchCallback</strong> later, and only use DSL directives to check the <em class="italic">shape</em> of our desired patterns:</p><p class="source-code">StatementMatcher buildAssignmentMatcher() {</p><p class="source-code">  return compoundStmt(statementCountIs(1),</p><p class="source-code">                      hasAnySubstatement(</p><p class="source-code">                        binaryOperator(</p><p class="source-code">                          <strong class="bold">hasOperatorName("=")</strong>,</p><p class="source-code">                          hasLHS(<strong class="bold">declRefExpr</strong>())</p><p class="source-code">                        )));</p><p class="source-code">}</p></li>
				<li>Now that we've completed the skeleton for our patterns, it's time to implement <strong class="source-inline">MatchCallback</strong>. There are two things we are going to do in <strong class="source-inline">MatchCallback::run</strong>. First, for our assignment-based pattern, we need to check if the LHS' <strong class="source-inline">DeclRefExpr</strong> of those matched assignment candidates is pointing to the same <strong class="source-inline">Decl</strong>. Second, we want to print out messages that help users rewrite <strong class="source-inline">if</strong>-<strong class="source-inline">else</strong> branches as ternary operators. In other words, we need location information from some of the matched AST nodes.<p>Let's solve the first task using the <em class="italic">AST node binding technique</em>. The plan is to bind the candidate assignment's LHS <strong class="source-inline">DeclRefExpr</strong> nodes so that we can retrieve them from <strong class="source-inline">MatchCallback::run</strong> later and perform further checks on their <strong class="source-inline">Decl</strong> nodes. Let's change <strong class="source-inline">buildAssignmentMatch</strong> into this:</p><p class="source-code">StatementMatcher buildAssignmentMatcher() {</p><p class="source-code">  return compoundStmt(statementCountIs(1),</p><p class="source-code">                      hasAnySubstatement(</p><p class="source-code">                        binaryOperator(</p><p class="source-code">                          hasOperatorName("="),</p><p class="source-code">                          hasLHS(<strong class="bold">declRefExpr().                          bind("dest")</strong>))));</p><p class="source-code">}</p><p>Though the preceding code seems straightforward, there is one problem in this binding scheme: in both branches, <strong class="source-inline">DeclRefExpr</strong> is bound to the same name, meaning that the AST node that occurred later will overwrite the previously bound node. So, eventually, we <a id="_idIndexMarker325"/>won't get <strong class="source-inline">DeclRefExpr</strong> nodes from both branches as we previously planned.</p><p>Therefore, let's use a different tags for <strong class="source-inline">DeclRefExpr</strong> that match from both branches: <strong class="source-inline">dest.true</strong> for the true branch and <strong class="source-inline">dest.false</strong> for the false branch. Let's tweak the preceding code to reflect this strategy:</p><p class="source-code">StatementMatcher buildAssignmentMatcher(StringRef <strong class="bold">Suffix</strong>) {</p><p class="source-code">  auto DestTag = <strong class="bold">("dest" + Suffix).str()</strong>;</p><p class="source-code">  return compoundStmt(statementCountIs(1),</p><p class="source-code">                      hasAnySubstatement(</p><p class="source-code">                        binaryOperator(</p><p class="source-code">                          hasOperatorName("="),</p><p class="source-code">                          hasLHS(<strong class="bold">declRefExpr().                           bind(DestTag)</strong>))));</p><p class="source-code">}</p><p>Later, when we call <strong class="source-inline">buildAssignmentMatcher</strong>, we will pass different suffixes for the different branches – either <strong class="source-inline">.true</strong> or <strong class="source-inline">.false</strong>.</p><p>Finally, we must retrieve the bound nodes in <strong class="source-inline">MatchCallback::run</strong>. Here, we are creating different <strong class="source-inline">MatchCallback</strong> subclasses for return-based and assignment-based scenarios – <strong class="source-inline">MatchReturnCallback</strong> and <strong class="source-inline">MatchAssignmentCallback</strong>, respectively. Here <a id="_idIndexMarker326"/>is a part of the code in <strong class="source-inline">MatchAssignmentCallback::run</strong>:</p><p class="source-code">void</p><p class="source-code">MatchAssignmentCallback::run(const MatchResult &amp;Result) override {</p><p class="source-code">  const auto&amp; Nodes = Result.Nodes;</p><p class="source-code">  // Check if destination of both assignments are the   // same</p><p class="source-code">  const auto *DestTrue =</p><p class="source-code">             Nodes.<strong class="bold">getNodeAs&lt;DeclRefExpr&gt;</strong>("dest.true"),</p><p class="source-code">             *DestFalse = </p><p class="source-code">             Nodes.<strong class="bold">getNodeAs&lt;DeclRefExpr&gt;</strong>("dest.false");</p><p class="source-code">  if (DestTrue-&gt;<strong class="bold">getDecl</strong>() == DestFalse-&gt;<strong class="bold">getDecl</strong>()) {</p><p class="source-code">    // Can be converted into ternary operator!</p><p class="source-code">  }</p><p class="source-code">}</p><p>We are going to solve the second task – printing useful information to users – in the next step.</p></li>
				<li>To print useful information – including <em class="italic">which</em> part of the code can be converted into a ternary operator, and <em class="italic">how</em> can you build that ternary operator – we need to retrieve some AST nodes from the matched patterns before getting their source location information. For this, we will use some node binding tricks, as we did in the <a id="_idIndexMarker327"/>previous step. This time, we will modify all the pattern building functions; that is, <strong class="source-inline">buildIfStmtMatcher</strong>, <strong class="source-inline">buildReturnMatcher</strong>, and <strong class="source-inline">buildAssignmentMatcher</strong>:<p class="source-code">StatementMatcher</p><p class="source-code">buildIfStmtMatcher(StatementMatcher truePattern,</p><p class="source-code">                   StatementMatcher falsePattern) {</p><p class="source-code">  return functionDecl(</p><p class="source-code">    compoundStmt(hasAnySubstatement</p><p class="source-code">      IfStmt(</p><p class="source-code">        hasThen(truePattern)</p><p class="source-code">        hasElse(falsePattern)).<strong class="bold">bind("if_stmt")</strong></p><p class="source-code">    ));</p><p class="source-code">}</p><p>Here, we bound the matched <strong class="source-inline">IfStmt</strong> since we want to tell our users where the potential places that can be converted into ternary operators are:</p><p class="source-code">StatementMatcher buildReturnMatcher(StringRef <strong class="bold">Suffix</strong>) {</p><p class="source-code">  auto Tag = <strong class="bold">("return" + Suffix)</strong>.str();</p><p class="source-code">  return compoundStmt(statementCountIs(1),</p><p class="source-code">                      hasAnySubstatement(</p><p class="source-code">                        returnStmt(hasReturnValue(</p><p class="source-code">                          <strong class="bold">expr().bind(Tag)</strong></p><p class="source-code">                        ))));</p><p class="source-code">}</p><p class="source-code">StatementMatcher buildAssignmentMatcher(StringRef Suffix) {</p><p class="source-code">  auto DestTag = ("dest" + Suffix).str();</p><p class="source-code">  auto ValTag = <strong class="bold">("val" + Suffix)</strong>.str();</p><p class="source-code">  return compoundStmt(statementCountIs(1),</p><p class="source-code">                      hasAnySubstatement(</p><p class="source-code">                        binaryOperator(</p><p class="source-code">                          hasOperatorName("="),</p><p class="source-code">                          hasLHS(declRefExpr().                          bind(DestTag)),</p><p class="source-code">                          <strong class="bold">hasRHS</strong>(expr().<strong class="bold">bind(ValTag)</strong>)</p><p class="source-code">                        )));</p><p class="source-code">}</p><p>We used the same node binding tricks here that we did in the preceding snippet. After this, we can retrieve <a id="_idIndexMarker328"/>those bound nodes from <strong class="source-inline">MatchCallback::run</strong> and print out the message using the <strong class="source-inline">SourceLocation</strong> information that's attached to those nodes.</p><p>We are going to use Clang's diagnostic framework to print out those messages here (feel free to read the <em class="italic">Printing diagnostic messages</em> section again if you're not familiar with it). And since the prospective message formats are not existing ones in Clang's code base, we are going to create our own diagnostic ID via <strong class="source-inline">DiagnosticsEngine::getCustomDiagID(…)</strong>. Here is what we will do in <strong class="source-inline">MatchAssignmentCallback::run</strong> (we will only demo <strong class="source-inline">MatchAssignmentCallback</strong> here since <strong class="source-inline">MatchReturnCallback</strong> is similar):</p><p class="source-code">void</p><p class="source-code">MatchAssignmentCallback::run(const MatchResult &amp;Result) override {</p><p class="source-code">  …</p><p class="source-code">  auto&amp; Diag = Result.<strong class="bold">Context</strong>-&gt;<strong class="bold">getDiagnostics</strong>();</p><p class="source-code">  auto <strong class="bold">DiagWarnMain</strong> = Diag.<strong class="bold">getCustomDiagID</strong>(</p><p class="source-code">    DiagnosticsEngine::Warning,</p><p class="source-code">    "this if statement can be converted to ternary      operator:");</p><p class="source-code">  auto <strong class="bold">DiagNoteTrueExpr</strong> = Diag.<strong class="bold">getCustomDiagID</strong>(</p><p class="source-code">    DiagnosticsEngine::Note,</p><p class="source-code">    "with true expression being this:");</p><p class="source-code">  auto <strong class="bold">DiagNoteFalseExpr</strong> = Diag.<strong class="bold">getCustomDiagID</strong>(</p><p class="source-code">    DiagnosticsEngine::Note,</p><p class="source-code">    "with false expression being this:");</p><p class="source-code">  …</p><p class="source-code">}</p><p>Combining this with bound node retrievals, here is how we are going to print the messages:</p><p class="source-code">void</p><p class="source-code">MatchAssignmentCallback::run(const MatchResult &amp;Result) override {</p><p class="source-code">  …</p><p class="source-code">  if (DestTrue &amp;&amp; DestFalse) {</p><p class="source-code">      if (DestTrue-&gt;getDecl() == DestFalse-&gt;getDecl()) {</p><p class="source-code">        // Can be converted to ternary!</p><p class="source-code">        const auto* If = Nodes.getNodeAs&lt;IfStmt&gt;        ("if_stmt");</p><p class="source-code">        Diag.Report(If-&gt;getBeginLoc(), <strong class="bold">DiagWarnMain</strong>);</p><p class="source-code">        const auto* TrueValExpr = </p><p class="source-code">                    Nodes.getNodeAs&lt;Expr&gt;("<strong class="bold">val.true</strong>");</p><p class="source-code">        const auto* FalseValExpr = </p><p class="source-code">                    Nodes.getNodeAs&lt;Expr&gt;("<strong class="bold">val.false</strong>");</p><p class="source-code">        Diag.Report(TrueValExpr-&gt;getBeginLoc(), </p><p class="source-code">                    <strong class="bold">DiagNoteTrueExpr</strong>);</p><p class="source-code">        Diag.Report(FalseValExpr-&gt;getBeginLoc(), </p><p class="source-code">                    <strong class="bold">DiagNoteFalseExpr</strong>);</p><p class="source-code">      }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Finally, go <a id="_idIndexMarker329"/>back to <strong class="source-inline">CreateASTConsumer</strong>. Here is how everything is pieced together:<p class="source-code">std::unique_ptr&lt;ASTConsumer&gt;</p><p class="source-code">TernaryConverterAction::CreateASTConsumer(CompilerInstance &amp;CI, StringRef InFile) {</p><p class="source-code">  …</p><p class="source-code">  // Return matcher</p><p class="source-code">  if (!NoReturn) {</p><p class="source-code">  ReturnMatchCB = std::make_unique&lt;<strong class="bold">MatchReturnCallback</strong>&gt;();</p><p class="source-code">    ASTFinder-&gt;addMatcher(</p><p class="source-code">      traverse(TK_IgnoreUnlessSpelledInSource,                          </p><p class="source-code">               buildIfStmtMatcher(</p><p class="source-code">                 <strong class="bold">buildReturnMatcher(".true")</strong>,                                                 </p><p class="source-code">                 <strong class="bold">buildReturnMatcher(".false")</strong>)),</p><p class="source-code">      ReturnMatchCB.get()</p><p class="source-code">    );</p><p class="source-code">  }</p><p class="source-code">  // Assignment matcher</p><p class="source-code">  if (!NoAssignment) {</p><p class="source-code">    AssignMatchCB = std::make_     unique&lt;<strong class="bold">MatchAssignmentCallback</strong>&gt;();</p><p class="source-code">    ASTFinder-&gt;addMatcher(</p><p class="source-code">      traverse(TK_IgnoreUnlessSpelledInSource,</p><p class="source-code">               buildIfStmtMatcher(</p><p class="source-code">                 <strong class="bold">buildAssignmentMatcher(".true")</strong>,</p><p class="source-code">                 <strong class="bold">buildAssignmentMatcher(".false")</strong>)),</p><p class="source-code">      AssignMatchCB.get()</p><p class="source-code">    );</p><p class="source-code">  }</p><p class="source-code">  return std::move(ASTFinder-&gt;newASTConsumer());</p><p class="source-code">}</p><p>And that wraps up all the things we need to do!</p></li>
				<li>Last bu<a id="_idTextAnchor106"/>t not least, this is the command for running our plugin:<p class="source-code"><strong class="bold">$ clang -fsyntax-only -fplugin=/path/to/TernaryConverter.so -Xclang -plugin -Xclang ternary-converter \</strong></p><p class="source-code"><strong class="bold">    test.c</strong></p><p>You will get an output <a id="_idIndexMarker330"/>similar to the one you saw in the <em class="italic">Project overview</em> section.</p><p>To use plugin-specific flags, such as <strong class="source-inline">-no-detect-return</strong> and <strong class="source-inline">-no-detect-assignment</strong> in this project, please add the command-line options highlighted here:</p><p class="source-code"><strong class="bold">$ clang -fsyntax-only -fplugin=/path/to/TernaryConverter.so -Xclang -plugin -Xclang ternary-converter \</strong></p><p class="source-code"><strong class="bold">   -Xclang -plugin-arg-ternary-converter \</strong></p><p class="source-code"><strong class="bold">   -Xclang -no-detect-return \</strong></p><p class="source-code"><strong class="bold">    test.c</strong></p><p>To be more specific, the first highlighted argument is in <strong class="source-inline">-plugin-arg-&lt;plugin name&gt;</strong> format.</p></li>
			</ol>
			<p>In this section, you learned how to write an AST plugin that sends messages to users whenever there is an <strong class="source-inline">if</strong>-<strong class="source-inline">else</strong> statement that can be converted into a ternary operator. You did this by leveraging all the techniques that were covered in this chapter; that is, Clang AST's in-memory representation, ASTMatcher, and the diagnostic framework, to name a few.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor107"/>Summary</h1>
			<p>When it comes to program analysis, AST is usually the recommended medium to use, thanks to its rich amount of semantic information and high-level structures. In this chapter, we learned about the powerful in-memory AST representation that's used in Clang, including its C++ classes and APIs. This gives you a clear picture of the source code you are analyzing. </p>
			<p>Furthermore, we learned and practiced a concise way to do pattern matching on AST – a crucial procedure for program analysis – via Clang's ASTMatcher. Familiarizing yourself with this technique can greatly improve your efficiency when it comes to filtering out interesting areas from the input source code. Last but not least, we learned how to write an AST plugin that makes it easier for you to integrate custom logic into the default Clang compilation pipeline.</p>
			<p>In the next chapter, we will look at the <strong class="bold">drivers</strong> and <strong class="bold">toolchains</strong> in Clang. We will show you how they work and how to customize them.</p>
		</div>
	</body></html>