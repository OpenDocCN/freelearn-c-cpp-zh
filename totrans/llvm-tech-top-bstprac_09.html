<html><head></head><body>
		<div><h1 id="_idParaDest-93"><em class="italic"><a id="_idTextAnchor093"/>Chapter 7</em>: Handling AST</h1>
			<p>In the previous chapter, we learned how Clang's preprocessor handles preprocessing directives in C-family languages. We also learned how to write different kinds of preprocessor plugins, such as pragma handlers, to extend Clang's functionalities. Those skills are especially useful when it comes to implementing field-specific logic or even custom language features.</p>
			<p>In this chapter, we're going to talk about a <strong class="bold">semantic-aware</strong> representation of the original source code file once it has been parsed, known as an <strong class="bold">Abstract Syntax Tree (AST)</strong>. An AST is a <a id="_idIndexMarker268"/>format that carries rich semantic information, including types, expression trees, and symbols, to name a few. It is not only used as a blueprint to generate LLVM IR for later compilation stages but is also the recommended format for performing static analysis. On top of that, Clang also provides a nice framework for developers to intercept and manipulate AST in the middle of the frontend pipeline via a simple plugin interface. </p>
			<p>In this chapter, we are going to cover how to process AST in Clang, the important APIs for in-memory AST representation, and how to write AST plugins to implement custom logic with little effort. We will cover the following topics:</p>
			<ul>
				<li>Learning about AST in Clang</li>
				<li>Writing AST plugins</li>
			</ul>
			<p>By the end of this chapter, you will know how to work with AST in Clang in order to analyze programs at the source code level. In addition, you will know how to inject custom AST processing logic into Clang in an easy way via AST plugins.</p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor094"/>Technical requirements</h1>
			<p>This chapter expects that you have a build of the <code>clang</code> executable. If you don't, please build it using the following command:</p>
			<pre>$ ninja clang</pre>
			<p>In addition, you can use the following command-line flag to print out the textual representation of AST:</p>
			<pre>$ clang <strong class="bold">-Xclang -ast-dump</strong> foo.c</pre>
			<p>For example, let's say <code>foo.c</code> contains the following content:</p>
			<pre>int foo(int c) { return c + 1; }</pre>
			<p>By using the <code>-Xclang -ast-dump</code> command-line flag, we can print out AST for <code>foo.c</code>:</p>
			<pre>TranslationUnitDecl 0x560f3929f5a8 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt;
|…
`-FunctionDecl 0x560f392e1350 &lt;foo.c:2:1, col:30&gt; col:5 foo 'int (int)'
  |-<strong class="bold">ParmVarDecl 0x560f392e1280 &lt;col:9, col:13&gt; col:13 used c 'int'</strong>
  `-CompoundStmt 0x560f392e14c8 &lt;col:16, col:30&gt;
    `-ReturnStmt 0x560f392e14b8 &lt;col:17, col:28&gt;
      `-BinaryOperator 0x560f392e1498 &lt;col:24, col:28&gt; 'int' '+'
        |-ImplicitCastExpr 0x560f392e1480 &lt;col:24&gt; 'int' &lt;LValueToRValue&gt;
        | `-DeclRefExpr 0x560f392e1440 &lt;col:24&gt; 'int' lvalue ParmVar 0x560f392e1280 'c' 'int'
        `-IntegerLiteral 0x560f392e1460 &lt;col:28&gt; 'int' 1</pre>
			<p>This flag is useful for finding out what C++ class is used to represent a certain part of the code. For example, the formal function parameter/argument is represented by the <code>ParmVarDecl</code> class, which is highlighted in the previous code.</p>
			<p>The code samples for this chapter can be found here: <a href="https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter07">https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter07</a>.</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor095"/>Learning about AST in Clang</h1>
			<p>In this section, we are <a id="_idIndexMarker269"/>going to learn about Clang's AST in-memory representation and its essential API usage. The first part of this section will provide you with a high-level overview of Clang AST's hierarchy; the second part will focus on a more specific topic regarding type representation in Clang AST; and the final part will show you the basic usage of AST matcher, which is extremely useful when you're writing an AST plugin.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor096"/>In-memory structure of Clang AST</h2>
			<p>The in-memory <a id="_idIndexMarker270"/>representation of AST in Clang is organized <a id="_idIndexMarker271"/>in a hierarchy structure that resembles the syntax structure of C-family language programs. Starting from the top-most level, there are two classes worth mentioning: </p>
			<ul>
				<li><code>TranslationUnitDecl</code>: This class represents an input source file, also called a translation unit (most of <a id="_idIndexMarker272"/>the time). It contains all the top-level declarations – global variables, classes, and functions, to name a few – as its children, where each of those top-level declarations has its own subtree that recursively defines the rest of the AST.</li>
				<li><code>ASTContext</code>: As its name suggests, this class keeps track of all the AST nodes and other metadata from the input source files. If there are multiple input source files, each of them gets its own <code>TranslationUnitDecl</code>, but they all share the same <code>ASTContext</code>.</li>
			</ul>
			<p>In addition to the structure, the body of the AST – the AST nodes – can be further classified into three primary categories: <code>Decl</code>, <code>Expr</code>, and <code>Stmt</code> classes, respectively. In the following sections, we are going to introduce each of these in-memory AST representations.</p>
			<h3>Declarations</h3>
			<p>Language constructs <a id="_idIndexMarker273"/>such as variable declarations (global and local), functions, and struct/class declarations are represented by subclasses of <code>Decl</code>. Though we are not going to go into each of these subclasses here, the following diagram shows common declaration constructions in C/C++ and their corresponding AST classes:</p>
			<div><div><img src="img/Figure_7.1_B14590.jpg" alt="Figure 7.1 – Common declarations in C/C++ and their AST classes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – Common declarations in C/C++ and their AST classes</p>
			<p>Between more concrete subclasses, such as <code>FunctionDecl</code> and <code>Decl</code>, there are several <a id="_idIndexMarker274"/>important <em class="italic">abstract</em> classes that represent certain language concepts:</p>
			<ul>
				<li><code>NamedDecl</code>: For every declaration that has a name.</li>
				<li><code>ValueDecl</code>: For declarations whose declared instances can be a value, and thus are associated with type information.</li>
				<li><code>DeclaratorDecl</code>: For every declaration that uses declarator (basically a statement in the form of <code>&lt;type and qualifier&gt; &lt;identifier name&gt;</code>). They provide extra information about parts other than the identifier. For example, they provide access to an in-memory object with namespace resolution, which acts as a qualifier in the declarator.</li>
			</ul>
			<p>To learn more about AST classes for other kinds of declarations, you can always navigate through the subclasses of <code>Decl</code> on LLVM's official API reference website.</p>
			<h3>Statements</h3>
			<p>Most directives in a program that represent the concept of <em class="italic">actions</em> can be classified as statements and are <a id="_idIndexMarker275"/>represented by subclasses of <code>Stmt</code>, including <em class="italic">expressions</em>, which we are going to cover shortly. In addition to imperative statements such as function calls or return sites, <code>Stmt</code> also covers structural concepts such as <code>for</code> loops and <code>if</code> statements. Here is a diagram showing a common language construct represented by <code>Stmt</code> (except expression) in C/C++ and its corresponding AST classes:</p>
			<div><div><img src="img/Figure_7.2_B14590.jpg" alt="Figure 7.2 – Common statements (excluding expressions) in C/C++ and their AST classes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – Common statements (excluding expressions) in C/C++ and their AST classes</p>
			<p>There are two things worth mentioning about the previous diagram:</p>
			<ul>
				<li><code>CompoundStmt</code>, which is a container for multiple statements, represents not only the function body but basically any code block enclosed by curly braces <code>('{', '}')</code>. Therefore, though not shown in the preceding diagram due to a lack of space, <code>IfStmt</code>, <code>ForStmt</code>, <code>WhileStmt</code>, and <code>SwitchStmt</code> all have a <code>CompoundStmt</code> child node representing their bodies.</li>
				<li>Declarations in a <code>CompoundStmt</code> will be wrapped by a <code>DeclStmt</code> node, in which the real <code>Decl</code> instance is its child node. This creates a simpler AST design.</li>
			</ul>
			<p>Statements are one of the most prevailing directives in a typical C/C++ program. It is worth noting, however, that <a id="_idIndexMarker276"/>many statements are organized in a hierarchy (for example, <code>ForStmt</code> and its loop body), so it might take you extra steps to go down this hierarchy before you find the desired <code>Stmt</code> node.</p>
			<h3>Expressions</h3>
			<p>Expressions in Clang AST are a special kind of statement. Different from other statements, expressions <a id="_idIndexMarker277"/>always generate <em class="italic">values</em>. For example, a simple arithmetic expression, <em class="italic">3 + 4</em>, is expected to generate an integer value. All expressions in Clang AST are represented by subclasses of <code>Expr</code>. Here is a diagram showing a common language construct represented by <code>Expr</code> in C/C++ and its corresponding AST classes:</p>
			<div><div><img src="img/Figure_7.3_B14590.jpg" alt="Figure 7.3 – Common expressions in C/C++ and their AST classes &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3 – Common expressions in C/C++ and their AST classes </p>
			<p>One important <code>Expr</code> class is <code>DeclRefExpr</code>. It represents the concept of symbol reference. You can use one of its APIs, <code>DeclRefExpr::getDecl()</code>, to retrieve the referenced symbol's <code>Decl</code> object. Handy symbol information like this only appears after AST has been generated, so this is one of the reasons people always recommend implementing static analysis logic on AST rather on more primitive forms (inside the parser, for example).</p>
			<p>Another interesting <code>Expr</code> class – not highlighted in the preceding diagram due to a lack of space – is <code>ParenExpr</code>, which <a id="_idIndexMarker278"/>represents the parentheses that wrap around an expression. For example, in the preceding diagram, <code>ParenExpr</code> with a <code>BinaryOperator</code> representing <strong class="bold">x + 1</strong> as its child.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor097"/>Types in Clang AST</h2>
			<p>The type system is one of the most crucial components in modern compilers, especially for statically typed <a id="_idIndexMarker279"/>languages such as C/C++. Type checking ensures that the input source code is well-formed (to some extent) and catches as many errors as possible at compile time. While we don't need to do type checking by ourselves in Clang, it is done by the <code>Sema</code> subsystem, which we introduced in <a href="B14590_05_Final_JC_ePub.xhtml#_idTextAnchor067"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Clang's Architecture</em>. You will probably need to leverage this information when you're processing the AST. Let's learn how types are modeled in Clang AST.</p>
			<h3>Core classes</h3>
			<p>The core of <a id="_idIndexMarker280"/>Clang AST's type system is the <code>clang::Type</code> class. Each type in the input code – including primitive types such as <code>int</code> and user-defined types such as struct/class – is represented by a <code>Type</code>) object.</p>
			<p class="callout-heading">Terminology</p>
			<p class="callout">In the rest of this chapter, we will call types in the <a id="_idIndexMarker281"/>input source code <strong class="bold">source code types</strong>.</p>
			<p>A <code>Type</code> object for each of those types. One of the biggest advantages of this design is that you have an easier way to compare two <code>Type</code> objects. Let's say you have two <code>Type</code> pointers. By doing a simple pointer comparison (which is extremely fast) on them, you can tell if they're representing the same source code type.</p>
			<p class="callout-heading">Counter Example of a Singleton Design</p>
			<p class="callout">If <code>Type</code> in Clang AST is not using a singleton design, to compare if two <code>Type</code> pointers are representing the same source code types, you need to inspect the content of the objects they are pointing to, which is not efficient.</p>
			<p>As we <a id="_idIndexMarker283"/>mentioned earlier, each source code type is actually represented by a subclass of <code>Type</code>. Here are some common <code>Type</code> subclasses:</p>
			<ul>
				<li><code>BuiltinType</code>: For primitive types such as <code>int</code>, <code>char</code>, and <code>float</code>.</li>
				<li><code>PointerType</code>: For all the pointer types. It has a function called <code>PointerType::getPointee()</code> for retrieving the source code type being pointed to by it.</li>
				<li><code>ArrayType</code>: For all the array types. Note that it has other subclasses for more specific arrays that have either a constant or variable length.</li>
				<li><code>RecordType</code>: For struct/class/union types. It has a function called <code>RecordType::getDecl()</code> for retrieving the underlying <code>RecordDecl</code>.</li>
				<li><code>FunctionType</code>: For representing a function's signature; that is, a function's argument types and return type (and other properties, such as its calling convention).</li>
			</ul>
			<p>Let us now move on to the qualified types. </p>
			<h3>Qualified types</h3>
			<p>One of the most confusing <a id="_idIndexMarker284"/>things for people new to Clang's code base is that many places use the <code>QualType</code> class rather than subclasses of <code>Type</code> to represent source code types. <code>QualType</code> stands for <code>Type</code> to represent concepts such as <code>const &lt;type&gt;</code>, <code>volatile &lt;type&gt;</code>, and <code>restrict &lt;type&gt;*</code>.</p>
			<p>To create a <code>QualType</code> from a <code>Type</code> pointer, you can use the following code:</p>
			<pre>// If `T` is representing 'int'…
QualType toConstVolatileTy(Type *T) {
  return <strong class="bold">QualType(T, Qualifier::Const | Qualifier::Volatile)</strong>;
} // Then the returned QualType represents `volatile const int`</pre>
			<p>In this section, we learned <a id="_idIndexMarker286"/>about the type system in Clang AST. Let's now move on to ASTMatcher, a syntax to match patterns. </p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor098"/>ASTMatcher</h2>
			<p>When we are dealing with a program's AST – for example, we're checking if there is any suboptimal syntax – searching <a id="_idIndexMarker287"/>for specific AST nodes <em class="italic">pattern</em> is usually the first step, and one of the most common things people do. Using the knowledge we learned in the previous section, we know that this kind of pattern matching can be done by iterating through AST nodes via their in-memory classes APIs. For example, given a <code>FunctionDecl</code> – the AST class of a function – you can use the following code to find out if there is a <code>while</code> loop in its body and if the exit condition of that loop is always a literal Boolean value; that is, <code>true</code>:</p>
			<pre>// `FD` has the type of `const FunctionDecl&amp;`
const auto* Body = dyn_cast&lt;CompoundStmt&gt;(FD.getBody());
for(const auto* S : Body-&gt;body()) {
  if(const auto* L = dyn_cast&lt;WhileStmt&gt;(S)) {
    if(const auto* Cond = dyn_cast&lt;CXXBoolLiteralExpr&gt;      (L-&gt;getCond()))
      if(Cond-&gt;getValue()) {
        // The exit condition is `true`!!
      }
  }
}</pre>
			<p>As you can see, it created more than three (indention) layers of <code>if</code> statements to complete such a simple check. Not to mention in real-world cases, we need to insert even more sanity checks among these lines! While Clang's AST design is not hard to understand, we need a more <em class="italic">concise</em> syntax to complete pattern matching jobs. Fortunately, Clang has <a id="_idIndexMarker288"/>already provided one – the <strong class="bold">ASTMatcher</strong>.</p>
			<p>ASTMatcher is the utility that helps you write AST pattern matching logic via a clean, concise, and <a id="_idIndexMarker289"/>efficient <strong class="bold">Domain-Specific Language</strong> (<strong class="bold">DSL</strong>). Using ASTMatcher, doing the same matching shown in the previous snippet only takes few lines of code:</p>
			<pre>functionDecl(compountStmt(hasAnySubstatement(
  whileStmt(
    hasCondition(cxxBoolLiteral(equals(true)))))));</pre>
			<p>Most of the directives in the preceding snippet are pretty straightforward: function calls such as <code>compoundStmt(…)</code> and <code>whileStmt(…)</code> check if the current node matches a specific node type. Here, the arguments in these function calls either represent pattern matchers on their subtree or check additional properties of the current node. There are also other directives for expressing qualifying concepts (for example, <em class="italic">for all substatements in this loop body, a return value exists</em>), such as <code>hasAnySubstatement(…)</code>, and directives for expressing data type and constant values such as the combination of <code>cxxBoolLiteral(equals(true))</code>.</p>
			<p>In short, using ASTMatcher can make your pattern matching logic more <em class="italic">expressive</em>. In this section, we showed you the basic usage of this elegant DSL.</p>
			<h3>Traversing AST</h3>
			<p>Before we dive into the <a id="_idIndexMarker290"/>core syntax, let's learn how ASTMatcher traverses AST and how it passes the result back to users after the matching process is completed.</p>
			<p><code>MatchFinder</code> is a commonly used driver for the pattern matching process. Its basic usage is pretty simple:</p>
			<pre>using namespace ast_matchers;
…
MatchFinder Finder;
// Add AST matching patterns to `MatchFinder`
Finder.<strong class="bold">addMatch</strong>(<strong class="bold">traverse</strong>(<strong class="bold">TK_AsIs</strong>, pattern1), Callback1);
Finder.addMatch(traverse(TK_AsIs, <strong class="bold">pattern2</strong>), <strong class="bold">Callback2</strong>);
…
// Match a given AST. `Tree` has the type of `ASTContext&amp;`
// If there is a match in either of the above patterns,
// functions in Callback1 or Callback2 will be invoked // accordingly
Finder.<strong class="bold">matchAST</strong>(Tree);
// …Or match a specific AST node. `FD` has the type of // `FunctionDecl&amp;`
Finder.match(FD, Tree);</pre>
			<p><code>pattern1</code> and <code>pattern2</code> are pattern objects <a id="_idIndexMarker291"/>that are constructed by DSL, as shown previously. What's more interesting is the <code>traverse</code> function and the <code>TK_AsIs</code> argument. The <code>traverse</code> function is a part of the pattern matching DSL, but instead of expressing patterns, it describes the action of traversing AST nodes. On top of that, the <code>TK_AsIs</code> argument represents the <em class="italic">traversing mode</em>. </p>
			<p>When we showed you the command-line flag for dumping AST in textual format (<code>-Xclang -ast-dump</code>) earlier in this chapter, you may have found that many <em class="italic">hidden AST nodes</em> were inserted into the tree to assist with the program's semantics rather than representing the real code that was written by the programmers. For example, <code>ImplicitCastExpr</code> is inserted in lots of places to ensure the program's type correctness. Dealing with these nodes might be a painful experience when you're composing pattern matching logic. Thus, the <code>traverse</code> function provides an alternative, <em class="italic">simplified</em>, way to traverse the tree. Let's say we have the following input source code:</p>
			<pre>struct B {
  B(int);
};
B foo() { return 87; }</pre>
			<p>When you pass <code>TK_AsIs</code> as the first argument to <code>traverse</code>, it observes the tree, similar <a id="_idIndexMarker292"/>to how <code>-ast-dump</code> does:</p>
			<pre>FunctionDecl
`-CompoundStmt
  `-ReturnStmt
    `-ExprWithCleanups
      `-CXXConstructExpr
        `-MaterializeTemporaryExpr
          `-ImplicitCastExpr
            `-ImplicitCastExpr
              `-CXXConstructExpr
                `-IntegerLiteral 'int' 87<a id="_idTextAnchor099"/></pre>
			<p>However, by using <code>TK_IgnoreUnlessSpelledInSource</code> as the first argument, the tree that's observed is equal to the following one:</p>
			<pre>FunctionDecl
`-CompoundStmt
  `-ReturnStmt
    `-IntegerLiteral 'int' 87</pre>
			<p>As its name suggests, <code>TK_IgnoreUnlessSpelledInSource</code> only visit nodes that are really shown in the source code. This greatly simplifies the process of writing a matching pattern since we don't need to worry about the nitty-gritty details of AST anymore.</p>
			<p>On the other hand, <code>Callback1</code> and <code>Callback2</code> in the first snippet are <code>MatchFinder::MatchCallback</code> objects that describe the actions to perform when there is a match. Here is <a id="_idIndexMarker293"/>the skeleton of a <code>MatchCallback</code> implementation:</p>
			<pre>struct MyMatchCallback : public MatchFinder::MatchCallback {
  void run(const MatchFinder::MatchResult &amp;Result) override {
    // Reach here if there is a match on the corresponding     // pattern
    // Handling "bound" result from `Result`, if there is any
  }
};</pre>
			<p>In the next section, we will show you how to bind a specific part of the pattern with a tag and retrieve it in <code>MatchCallback</code>.</p>
			<p>Last but not least, though we used <code>MatchFinder::match</code> and <code>MatchFinder::matchAST</code> in the first snippet to kick off the matching process, there are other ways to do this. For example, you can use <code>MatchFinder::newASTConsumer</code> to create an <code>ASTConsumer</code> instance that will run the described pattern matching activity. Alternatively, you can use <code>ast_matchers::match(…)</code> (not a member function under <code>MatchFinder</code> but a standalone function) to perform matching on a provided pattern and <code>ASTContext</code> in a single run, before returning the matched node.</p>
			<h3>ASTMatcher DSL</h3>
			<p>ASTMatcher provides an easy-to-use and concise C++ DSL to help with matching AST. As we saw earlier, the <em class="italic">structure</em> of the desired pattern is expressed by nested function calls, where each of <a id="_idIndexMarker294"/>these functions represents the <em class="italic">type</em> of AST node to match.</p>
			<p>Using this DSL to express simple patterns cannot be easier. However, when you're trying to compose patterns with multiple conditions/predicates, things get a little bit more complicated. For example, although we know a for loop (for example, <code>for(I = 0; I &lt; 10; ++I){…}</code>) can be matched by the <code>forStmt(…)</code> directive, how do we add a condition to its initialize statement (<code>I = 0</code> ) and exit the condition (<code>I &lt; 10</code>) or its loop body? Not only does the official API reference site (the doxygen website we usually use) lacks clear documentation on this part, most of these DSL functions are also pretty flexible in how they accept a wide range of arguments as their subpatterns. For example, following the question on matching a <code>for</code> loop, you can use the following code to check only the loop's body:</p>
			<pre>forStmt(hasBody(…));</pre>
			<p>Alternatively, you can check its loop body and its exit condition, like so:</p>
			<pre>forStmt(hasBody(…),
        hasCondition(…));</pre>
			<p>A generalized version of this question would be, given an arbitrary DSL directive, how do we know the <em class="italic">available</em> directives that can be combined with it?</p>
			<p>To answer this question, we will leverage a documentation website LLVM specifically created for ASTMatcher: <a href="https://clang.llvm.org/docs/LibASTMatchersReference.html">https://clang.llvm.org/docs/LibASTMatchersReference.html</a>. This website consists of a huge three-column table showing the returned type and argument types for each of the DSL directives:</p>
			<div><div><img src="img/Figure_7.4_B14590.jpg" alt="Figure 7.4 – Part of the ASTMatcher DSL reference&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4 – Part of the ASTMatcher DSL reference</p>
			<p>Though this table is just a simplified version of normal API references, it already shows you how to search for candidate directives. For example, now that you know <code>forStmt(…)</code> takes zero or multiple <code>Matcher&lt;ForStmt&gt;</code>, we can search this table for directives that return either <code>Matcher&lt;ForStmt&gt;</code> or <code>Matcher&lt;(parent class of ForStmt)&gt;</code>, such as <code>Matcher&lt;Stmt&gt;</code>. In this case, we can quickly spot <code>hasCondition</code>, <code>hasBody</code>, <code>hasIncrement</code>, or <code>hasLoopInit</code> as candidates (of course, many other directives that return <code>Matcher&lt;Stmt&gt;</code> can also be used).</p>
			<p>When you're performing <a id="_idIndexMarker295"/>pattern matching, there are many cases where you not only want to know if a pattern matches or not but also get the matched AST nodes. In the context of ASTMatcher, its DSL directives only check the <em class="italic">type</em> of the AST nodes. If you want to retrieve (part of the) concrete AST nodes that are being matched, you can use the <code>bind(…)</code> API. Here is an example:</p>
			<pre>forStmt(
  hasCondition(
    <strong class="bold">expr().bind("exit_condition")</strong>));</pre>
			<p>Here, we used <code>expr()</code> as a wildcard pattern to match any <code>Expr</code> node. This directive also calls <code>bind(…)</code> to associate the matched <code>Expr</code> AST node with the name <code>exit_condition</code>.</p>
			<p>Then, in <code>MatchCallback</code>, which we introduced earlier, we can retrieve the bound node by using the following code:</p>
			<pre>…
void run(const MatchFinder::MatchResult &amp;Result) override {
  cons auto&amp; Nodes = Result.Nodes;
  const Expr* CondExpr = Nodes.<strong class="bold">getNodeAs&lt;Expr&gt;    ("exit_condition")</strong>;
  // Use `CondExpr`…
}</pre>
			<p>The <code>getNodeAs&lt;…&gt;(…)</code> function <a id="_idIndexMarker296"/>tries to fetch the bound AST node under the given name and cast it to the type suggested by the template argument.</p>
			<p>Note that you're allowed to bind different AST nodes under the same name, in which case only the last bounded one will be shown in <code>MatchCallback::run</code>.</p>
			<h3>Putting everything together</h3>
			<p>Now that you've learned about both the pattern matching DSL syntax and how to traverse AST using ASTMatcher, let's put these two things together.</p>
			<p>Let's say we want to know the number of <a id="_idIndexMarker297"/>iterations – also known as the <em class="italic">trip count</em> – that a simple <code>for</code> loop (the loop index starts from zero and is incremented by one at each iteration and bounded by a literal integer) has in a function:</p>
			<ol>
				<li>First, we must write the following code for matching and traversing:<pre>auto PatExitCondition = binaryOperator(
                           hasOperatorName("&lt;"),
                           hasRHS(integerLiteral()
                           .bind("trip_count")));
auto Pattern = functionDecl(
                 compountStmt(hasAnySubstatement(
              forStmt(hasCondition(PatExitCondition)))));
MatchFinder Finder;
auto* Callback = new MyMatchCallback();
Finder.addMatcher(traverse(TK_IgnoreUnlessSpelledInSource,
                           Pattern), Callback);</pre><p>The preceding snippet also shows how <em class="italic">modular</em> DSL patterns are. You can create individual pattern fragments and compose them depending on your needs, as long as they're compatible.</p><p>Finally, here is what <code>MyMatchCallback::run</code> looks like:</p><pre>void run(const MatchFinder::MatchResult &amp;Result) override {
  const auto&amp; Nodes = Result.Nodes;
  const auto* TripCount = 
        Nodes.getNodeAs&lt;IntegerLiteral&gt;("trip_count");
  if (TripCount)
    TripCount-&gt;dump(); // print to llvm::errs()
}</pre></li>
				<li>After this, you can use <code>Finder</code> to match the desired pattern (either by calling <code>MatchFinder::match</code> or <code>MatchFinder::matchAST</code>, or by creating an <code>ASTConsumer</code> using <code>MatchFinder::newASTConsumer</code>) on an AST. The matched trip count will be printed to <code>stderr</code>. For instance, if the input source code is <code>for(int i = 0; i &lt; 10; ++i) {…}</code>, the output will simply be <code>10</code>.</li>
			</ol>
			<p>In this section, we learned how Clang structures its AST, how Clang AST is represented in memory, and how to use ASTMatcher to help developers with AST pattern matching. With this knowledge, in the next section, we will show you how to create an AST plugin, which is one of the easiest ways to inject custom logic into Clang's compilation pipeline.</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor100"/>Writing AST plugins</h1>
			<p>In the previous section, we learned how AST is represented in Clang and learned what its in-memory <a id="_idIndexMarker298"/>classes look like. We also learned about some useful skills we can use to perform pattern matching on Clang AST. In this section, we will learn how to write plugins that allow you to insert custom AST processing logic into Clang's compilation pipeline.</p>
			<p>This section will be divided into three parts:</p>
			<ul>
				<li><strong class="bold">Project overview</strong>: The goal and overview of the demo project we are going to create in this section.</li>
				<li><code>DiagnosticsEngine</code>, a powerful subsystem that helps you print out well-formatted and meaningful diagnostic messages. This will make our demo project more applicable to real-world scenarios.</li>
				<li><strong class="bold">Creating the AST plugin</strong>: This section will show you how to create an AST plugin from scratch, fill in all the implementation details, and how to run it with Clang.</li>
			</ul>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor101"/>Project overview</h2>
			<p>In this section, we will create a <a id="_idIndexMarker299"/>plugin that prompts the user with warning messages whenever there are <code>if</code>-<code>else</code> statements in the input code that can be converted into <strong class="bold">ternary operators</strong>.</p>
			<p class="callout-heading">Quick Refresher – Ternary Operator</p>
			<p class="callout">The <a id="_idIndexMarker300"/>ternary operator, <code>x? val_1 : val_2</code>, is evaluated to <code>val_1</code> when the <code>x</code> condition is true. Otherwise, it is evaluated to <code>val_2</code>.</p>
			<p>For example, let's look at the following C/C++ snippet:</p>
			<pre>int foo(int c) {
  if (c &gt; 10) {
    return c + 100;
  } else {
    return 94;
  }
}
void bar(int x) {
  int a;
  if (x &gt; 10) {
    a = 87;
  } else {
    a = x – 100;
  }
}</pre>
			<p>The <code>if</code>-<code>else</code> statements in <a id="_idIndexMarker301"/>both functions can be converted into ternary operators, like this:</p>
			<pre>int foo(int c) {
  return <strong class="bold">c &gt; 10? c + 100 : 94</strong>;
}
void bar(int x) {
  int a;
  a = <strong class="bold">x &gt; 10? 87 : x – 100</strong>;
}</pre>
			<p>In this project, we will only focus on finding two kinds of potential ternary operator opportunities:</p>
			<ul>
				<li>Both the <code>then</code> block (true branch) and the <code>else</code> block (false branch) contain a single <code>return</code> statement. In this case, we can coalesce their return values and the branch condition into one ternary operator (as the new returned value).</li>
				<li>Both the <code>then</code> block and the <code>else</code> block only contain a single assignment statement. Both statements use a single <code>DeclRefExpr</code> – that is, a symbol reference – as the LHS, and both <code>DeclRefExpr</code> objects point to the same <code>Decl</code> (symbol). In other <a id="_idIndexMarker302"/>words, we are covering the case of the <code>bar</code> function shown in the preceding snippet. Note that we are not covering cases where the LHS is more complicated; for example, where an array subscription, <code>a[i]</code>, is used as the LHS.</li>
			</ul>
			<p>After identifying these patterns, we must prompt warning messages to the user and provide extra information to help the user fix this issue:</p>
			<pre>$ clang …(flags to run the plugin) ./test.c
./test.c:2:3: <strong class="bold">warning</strong>: this if statement can be converted to ternary operator:
  if (c &gt; 10) {
  ^
./test.c:3:12: <strong class="bold">note</strong>: with true expression being this:
    return c + 100;
           ^
./test.c:5:12: <strong class="bold">note</strong>: with false expression being this:
    return 94;
           ^
./test.c:11:3: <strong class="bold">warning</strong>: this if statement can be converted to ternary operator:
  if (x &gt; 10) {
  ^
./test.c:12:9: <strong class="bold">note</strong>: with true expression being this:
    a = 87;
        ^
./test.c:14:9: <strong class="bold">note</strong>: with false expression being this:
    a = x - 100;
        ^
2 warnings generated.</pre>
			<p>Each warning message – which tells you which <code>if</code>-<code>else</code> statement can be converted into a ternary operator – is <a id="_idIndexMarker303"/>followed by two notes pointing out the potential expressions to construct for the operator.</p>
			<p>Compared to handcrafting compiler messages, as we did in the <em class="italic">Developing custom preprocessor plugins and callbacks</em> section of <a href="B14590_06_Final_JC_ePub.xhtml#_idTextAnchor078"><em class="italic">Chapter 6</em></a>, <em class="italic">Extending the Preprocessor</em>, here, we are using Clang's diagnostics infrastructure to print messages that carry richer information, such as the snapshot of code that the message is referring to. We will show you how to use that <a id="_idTextAnchor102"/>diagnostic infrastructure next.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor103"/>Printing diagnostic messages</h2>
			<p>In <a href="B14590_06_Final_JC_ePub.xhtml#_idTextAnchor078"><em class="italic">Chapter 6</em></a>, <em class="italic">Extending the Preprocessor</em>, we asked <a id="_idIndexMarker304"/>if you could improve the <a id="_idIndexMarker305"/>warning message format in the example project shown in the <em class="italic">Developing custom preprocessor plugins and callbacks</em> section, so that it's closer to the compiler messages you saw from Clang. One of the solutions to that question is using Clang's diagnostic framework. We are going to look at this in this section.</p>
			<p>Clang's diagnostic framework <a id="_idIndexMarker306"/>consists of three primary parts: </p>
			<ul>
				<li><strong class="bold">Diagnostic IDs</strong></li>
				<li><strong class="bold">Diagnostic engine</strong></li>
				<li><strong class="bold">Diagnostic consumers (clients)</strong></li>
			</ul>
			<p>Their relationships can be seen in the following diagram:</p>
			<div><div><img src="img/Figure_7.5_B14590.jpg" alt="Figure 7.5 – High-level organization of Clang's diagnostic framework&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – High-level organization of Clang's diagnostic framework</p>
			<h3>Diagnostic messages</h3>
			<p>Starting from the left-hand side of the <a id="_idIndexMarker307"/>preceding diagram, most of the time, a diagnostic message – for example, <em class="italic">use of undeclared identifier "x"</em> – is <a id="_idIndexMarker308"/>associated with a message <strong class="bold">template</strong> that has its own diagnostic ID. Using the undeclared identifier message, for example, its message template looks like this:</p>
			<pre>"use of undeclared identifier <strong class="bold">%0</strong>"</pre>
			<p><code>%0</code> is a <code>x</code>, in the preceding example message). The number following <code>%</code> also suggests which supplemental data it will use. We will cover this format in detail shortly.</p>
			<p>Templates are registered with the diagnostic engine via TableGen syntax. For example, the message we are discussing here is put inside <code>clang/include/clang/Basic/DiagnosticSemaKinds.td</code>:</p>
			<pre>def <strong class="bold">err_undeclared_var_use</strong> : <strong class="bold">Error</strong>&lt;"use of undeclared identifier %0"&gt;;</pre>
			<p>We highlighted two parts in the preceding snippet. First, the name of this message template, <code>err_undeclared_var_use</code>, will be used later as the unique diagnostic ID. Second, the <code>Error</code> TableGen class suggested that this is an error message, or more formally speaking, its <em class="italic">diagnostic level</em> error.</p>
			<p>In summary, a <a id="_idIndexMarker309"/>diagnostic message consists of a <a id="_idIndexMarker310"/>unique diagnostic ID – which is associated with a message template and its diagnostic level – and the supplemental data to put in the placeholders of the template, if there are any.</p>
			<h3>Diagnostic consumers</h3>
			<p>After the diagnostic <a id="_idIndexMarker311"/>message is sent to the diagnostic engine – represented by the <code>DiagnosticsEngine</code> class – the engine formats the messages into textual contents <a id="_idIndexMarker312"/>and send them to one of the <strong class="bold">diagnostic consumers</strong> (also called <strong class="bold">clients</strong> in the <a id="_idIndexMarker313"/>code base; we will use the term <strong class="bold">consumer</strong> in rest of this section).</p>
			<p>A diagnostic consumer – an implementation of the <code>DiagnosticConsumer</code> class – post-processes the textual messages sent from <code>DiagnosticsEngine</code> and exports them via different mediums. For example, the default <code>TextDiagnosticPrinter</code> prints messages to the command-line interface; <code>LogDiagnosticPrinter</code>, on the other hand, decorates the incoming messages with simple XML tags before printing them into log files. In theory, you can even create a custom <code>DiagnosticConsumer</code> that sends diagnostic messages to a remote host!</p>
			<h3>Reporting diagnostic messages</h3>
			<p>Now that you <a id="_idIndexMarker314"/>have learned how Clang's diagnostic framework works, let's learn how to send (report) a diagnostic message to <code>DiagnosticEngine</code>:</p>
			<ol>
				<li value="1">First, we need to retrieve a reference to <code>DiagnosticEngine</code>. The engine itself is sitting at the core of Clang's compilation pipeline, so you can fetch it from various primary components, such as <code>ASTContext</code> and <code>SourceManager</code>. The following is an example:<pre>// `Ctx` has the type of `ASTContext&amp;`
DiagnosticsEngine&amp; Diag = Ctx.<strong class="bold">getDiagnostics</strong>();</pre></li>
				<li>Next, we need to use the <code>DiagnosticsEngine::Report</code> function. This function always takes a diagnostic ID as one of its arguments. For example, to report <code>err_undeclared_var_use</code>, which we introduced earlier, use the following code:<pre>Diag.Report(<code>err_undeclared_var_use</code> takes one placeholder argument – namely, the identifier name – which is supplied through concatenating the <code>Report</code> function call with <code>&lt;&lt;</code> operators:</p><pre>Diag.Report(diag::err_undeclared_var_use) <strong class="bold">&lt;&lt; ident_name_str</strong>;</pre></li>
				<li>Recall that <code>err_undeclared_var_use</code> only has one placeholder, <code>%0</code>, so it picks up the first values in the following <code>&lt;&lt;</code> stream. Let's say we have a diagnostic message, <code>err_invalid_placement</code>, with the following template:<pre>"you cannot put <strong class="bold">%1</strong> into <strong class="bold">%0</strong>"</pre></li>
				<li>You can report this using the following code:<pre>Diag.Report(diag::err_invalid_placement)
             &lt;&lt; "<code>boiling oil</code>" &lt;&lt; "<code>water</code>";</pre></li>
				<li>In addition to simple placeholders, another useful feature is the <code>%select</code> directive. For example, we have a diagnostic message, <code>warn_exceed_limit</code>, with a template like this:<pre>"you exceed the daily <code>%select</code> directive consists of curly braces in which different message options are separated by <code>|</code>. Outside the curly braces, a number – <code>0</code>, in the preceding code – indicates which supplement data is used to select the option within the braces. The following is an example of this:</p><pre>Diag.Report(diag::warn_exceed_limit) &lt;&lt; <code>0</code> as the parameter after the stream operator (<code>&lt;&lt;</code>):</p><pre>Diag.Report(diag::warn_exceed_limit) &lt;&lt; <strong class="bold">0</strong>;</pre><p>This will result in a message stating <strong class="bold">you exceed the daily wifi limit</strong>.</p></li>
				<li>Now, let's say you use another version of the <code>Report</code> function, which takes an additional <code>SourceLocation</code> argument:<pre>// `SLoc` has the type of `SourceLocation`
Diag.Report(<code>SLoc</code>:</p><pre>test.cc:2:10: error: use of undeclared identifier 'x'
  <strong class="bold">return x + 1;</strong>
<strong class="bold">         ^</strong></pre></li>
				<li>Last but not least, though most of the diagnostic messages are registered with <code>DiagnosticsEngine</code> via TableGen code put <em class="italic">inside</em> Clang's source tree, this doesn't mean that developers cannot create their new diagnostic messages without modifying Clang's source tree. Let's introduce <code>DiagnosticsEngine::getCustomDiagID(…)</code>, the API that creates a new diagnostic ID from a message template and diagnostic level provided by developers:<pre>auto MyDiagID = Diag.<code>MyDiagID</code>, that has a message template of <strong class="bold">Today's weather is %0</strong> at its note diagnostic level. You can use this diagnostic ID just like any other ID:</p><pre>Diag.Report(<strong class="bold">MyDiagID</strong>) &lt;&lt; "cloudy";</pre></li>
			</ol>
			<p>In this section, you learned how to leverage Clang's diagnostic framework to print out messages just like normal compiler messages.</p>
			<p>Next, we are going to combine all the skills we've learned about in this chapter to create a custom AST plugin.</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor104"/>Creating the AST plugin</h2>
			<p>In the previous sections <a id="_idIndexMarker317"/>of this chapter, we explored Clang's AST and learned how to use it in in-memory APIs. In this section, we will learn how to write a plugin that helps you insert your custom AST processing logic into Clang's compilation pipeline in an easy way.</p>
			<p>In <a href="B14590_05_Final_JC_ePub.xhtml#_idTextAnchor067"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Clang's Architecture</em>, we learned about the advantages of using Clang (AST) plugins: they can be developed even you are using a prebuilt <code>clang</code> executable, they are easy to write, and they have good integration with the existing toolchain and build systems, to name a few. In <a href="B14590_06_Final_JC_ePub.xhtml#_idTextAnchor078"><em class="italic">Chapter 6</em></a>, <em class="italic">Extending the Preprocessor</em>, we developed a plugin for custom pragma handling in the preprocessor. In this chapter, we will also be writing a plugin, but this one will be designed for custom AST processing. The code skeletons for these two plugins are also quite different.</p>
			<p>We introduced the sample project we will be using in this section in the <em class="italic">Project overview</em> section. This plugin will prompt users with warning messages if some <code>if</code>-<code>else</code> statements in the input code can be converted into ternary operators. In addition, it also shows extra hints about candidate expressions for building the ternary operator.</p>
			<p>Here are the detailed steps for building the plugin:</p>
			<ol>
				<li value="1">Similar to the pragma plugin we saw in <a href="B14590_06_Final_JC_ePub.xhtml#_idTextAnchor078"><em class="italic">Chapter 6</em></a>, <em class="italic">Extending the Preprocessor</em>, creating a plugin in Clang is basically like implementing a class. In the case of the AST plugin, this will be the <code>PluginASTAction</code> class.<p><code>PluginASTAction</code> is a subclass of <code>ASTFrontendAction</code> – a <code>FrontendAction</code> specialized for handling AST (if you're not familiar with <code>FrontendAction</code>, feel free to read <a href="B14590_05_Final_JC_ePub.xhtml#_idTextAnchor067"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Clang's Architecture</em>, again). Thus, we <a id="_idIndexMarker318"/>need to implement the <code>CreateASTConsumer</code> member function:</p><pre>struct TernaryConverterAction : public <strong class="bold">PluginASTAction</strong> {
  std::unique_ptr&lt;ASTConsumer&gt;
    <strong class="bold">CreateASTConsumer</strong>(CompilerInstance &amp;CI,
                      StringRef InFile) override;
};</pre><p>We will fill in this function later.</p></li>
				<li>In addition to <code>CreateASTConsumer</code>, there are two other member functions we can override to change some of the functionalities: <code>getActionType</code> and <code>ParseArgs</code>. The former tells Clang <em class="italic">how</em> this plugin should be executed by returning one of the enum values shown here:<p>a.<code> Cmdline</code>: The plugin will be executed after the main action if users provide the <code>-plugin &lt;plugin name&gt;</code> (frontend) command-line flag.</p><p>b.<code> ReplaceAction</code>: This replaces the original action Clang was going to perform. For example, if Clang was supposed to compile input code into an object file (the <code>-c</code> flag), it will execute the plugin's action instead once the plugin has been loaded.</p><p>c.<code> AddBefore/AfterMainAction</code>: The original Clang action will still be executed, and the plugin action will be prepended/appended to it.</p><p>Here, we will use the <code>Cmdline</code> action type:</p><pre>struct TernaryConverterAction : public PluginASTAction {
  …
  ActionType getActionType() override { return <code>ParseArgs</code> member function, on the other hand, handles (frontend) command-line options <a id="_idIndexMarker319"/>specific to this plugin. In other words, you can create custom command-line flags for your plugin. In our case, we are going to create two flags: <code>-no-detect-return</code> and <code>-no-detect-assignment</code>. This allows us to decide whether we wish to detect potential ternary conversions regarding <code>return</code> statements or assignment statements, respectively:</p><pre>struct TernaryConverterAction : public PluginASTAction {
  …
  bool <code>NoReturn</code> and <code>NoAssignment</code>, to carry our command-line options' values. An important thing to know is the return value for <code>ParseArgs</code>. Instead of returning <em class="italic">if it parsed any custom flag</em>, <code>ParseArgs</code> is actually returning <em class="italic">if the plugin should continue its execution</em>. Therefore, you should always return true in most cases.</p></li>
				<li>Now, we are going to talk <a id="_idIndexMarker320"/>about the content of <code>CreateASTConsumer</code>. This function will return an <code>ASTConsumer</code> object, which is the main body that we will put our custom logic in. Nevertheless, we are not going to directly implement an <code>ASTConsumer</code>. Instead, we are going to us the <code>ASTConsumer</code> object that was generated by <em class="italic">ASTMatcher</em>, which we introduced earlier in this chapter.<p>Recall that two things are required to build a <code>MatchFinder</code> instance – the primary pattern matching driver in ASTMatcher (patterns written in ASTMatcher's own DSL) and a <code>MatchCallback</code> implementation. Let's separate our patterns and matcher callbacks into two categories: patterns for detecting potential ternary operator opportunities based on <code>return</code> statements and those for detecting <em class="italic">assignment-statement-based opportunities</em>.</p><p>Here is the skeleton for <code>CreateASTConsumer</code>:</p><pre>using namespace ast_matchers;
struct TernaryConverterAction : public PluginASTAction {
  …
private:
  std::unique_ptr&lt;MatchFinder&gt; <code>unique_ptr</code> type member variables: one for holding <code>MatchFinder</code> and two <code>MatchCallback</code> ones for return-based and assignment-based patterns.</p><p class="callout-heading">Why Use unique_ptr?</p><p class="callout">The rationale behind using <code>unique_ptr</code> to store those three objects – or storing those objects <em class="italic">persistently</em> – is because the <code>ASTConsumer</code> instance we created at the end of <code>CreateASTConsumer</code> (<code>ASTFinder-&gt;newASTConsumer()</code>) keeps references to those three objects. Thus, we need a way to keep them alive during the lifetime of the frontend.</p><p>In addition to that, we registered the pattern for traversal with MatchFinder by using <code>MatchFinder::addMatcher</code>, the <code>traverse</code> function, and <code>MatchCallback</code> instances. If you're not familiar with these APIs, feel free to check out the <em class="italic">ASTMatcher</em> section.</p><p>Now, we only need to compose the matching patterns and implement some callbacks to print out warning messages if there is a match – as the <code>TODO</code> comments suggested in the preceding snippet.</p></li>
				<li>Let's deal with the patterns first. The patterns we are looking for – both return-based and assignment-based patterns – have <code>if</code>-<code>else</code> statements (<code>IfStmt</code>) enclosed by a function (<code>FunctionDecl</code> for the entire function and <code>CompoundStmt</code> for the <a id="_idIndexMarker322"/>function body) in their outermost layout. Inside both, in the true branch and false branch of <code>IfStmt</code>, only one statement can exist. This structure can be illustrated like so:<pre>FunctionDecl 
  |_CompoundStmt
    |_(Other AST nodes we don't care)
    |_IfStmt
      |_(true branch: contain only one return/assign         statement)
      |_(false branch: contain only one return/assign         statement)</pre><p>To convert this concept into ASTMatcher's DSL, here is the DSL code that's shared between the return-based and assignment-based patterns:</p><pre>functionDecl(
  compoundStmt(hasAnySubstatement
    IfStmt(
      hasThen(/*<code>CompoundStmt</code>, you should always use quantifier directives such as <code>hasAnySubstatement</code> to match its body statements.</p><p>We are going to use the previous <code>TODO</code> comments to customize for either return-based or assignment-based situations. Let's use subpattern variables to replace those <code>TODO</code> <a id="_idTextAnchor105"/>comments and put <a id="_idIndexMarker323"/>the preceding code into another function:</p><pre>StatementMatcher
buildIfStmtMatcher(StatementMatcher <strong class="bold">truePattern</strong>,
                   StatementMatcher <strong class="bold">falsePattern</strong>) {
  return functionDecl(
    compoundStmt(hasAnySubstatement
      IfStmt(
        hasThen(<strong class="bold">truePattern</strong>)
        hasElse(<strong class="bold">falsePattern</strong>))));
}</pre></li>
				<li>For return-based patterns, the subpatterns for both the <code>if</code>-<code>else</code> branches mentioned in the previous step are identical and simple. We're also using a separate function to create this pattern:<pre>StatementMatcher buildReturnMatcher() {
  return compoundStmt(<code>statementCountIs</code> directive to match the code blocks with only one statement. Also, we specified that we don't want an empty return via <code>hasReturnValue(…)</code>. The argument for <code>hasReturnValue</code> is necessary since the latter takes at least one argument, but since we don't care what type of node it is, we are using <code>expr()</code> as some sort of wildcard pattern.</p><p>For assignment-based patterns, things get a little bit complicated: we don't just want to match a single assignment statement (modeled by the <code>BinaryOperator</code> class) in both branches – the LHS of those assignments need to be <code>DeclRefExpr</code> expressions that point to the same <code>Decl</code> instance. Unfortunately, we are not able to <a id="_idIndexMarker324"/>express all these predicates using ASTMatch's DSL. What we can do, however, is push off some of those checks into <code>MatchCallback</code> later, and only use DSL directives to check the <em class="italic">shape</em> of our desired patterns:</p><pre>StatementMatcher buildAssignmentMatcher() {
  return compoundStmt(statementCountIs(1),
                      hasAnySubstatement(
                        binaryOperator(
                          <strong class="bold">hasOperatorName("=")</strong>,
                          hasLHS(<strong class="bold">declRefExpr</strong>())
                        )));
}</pre></li>
				<li>Now that we've completed the skeleton for our patterns, it's time to implement <code>MatchCallback</code>. There are two things we are going to do in <code>MatchCallback::run</code>. First, for our assignment-based pattern, we need to check if the LHS' <code>DeclRefExpr</code> of those matched assignment candidates is pointing to the same <code>Decl</code>. Second, we want to print out messages that help users rewrite <code>if</code>-<code>else</code> branches as ternary operators. In other words, we need location information from some of the matched AST nodes.<p>Let's solve the first task using the <em class="italic">AST node binding technique</em>. The plan is to bind the candidate assignment's LHS <code>DeclRefExpr</code> nodes so that we can retrieve them from <code>MatchCallback::run</code> later and perform further checks on their <code>Decl</code> nodes. Let's change <code>buildAssignmentMatch</code> into this:</p><pre>StatementMatcher buildAssignmentMatcher() {
  return compoundStmt(statementCountIs(1),
                      hasAnySubstatement(
                        binaryOperator(
                          hasOperatorName("="),
                          hasLHS(<code>DeclRefExpr</code> is bound to the same name, meaning that the AST node that occurred later will overwrite the previously bound node. So, eventually, we <a id="_idIndexMarker325"/>won't get <code>DeclRefExpr</code> nodes from both branches as we previously planned.</p><p>Therefore, let's use a different tags for <code>DeclRefExpr</code> that match from both branches: <code>dest.true</code> for the true branch and <code>dest.false</code> for the false branch. Let's tweak the preceding code to reflect this strategy:</p><pre>StatementMatcher buildAssignmentMatcher(StringRef <code>buildAssignmentMatcher</code>, we will pass different suffixes for the different branches – either <code>.true</code> or <code>.false</code>.</p><p>Finally, we must retrieve the bound nodes in <code>MatchCallback::run</code>. Here, we are creating different <code>MatchCallback</code> subclasses for return-based and assignment-based scenarios – <code>MatchReturnCallback</code> and <code>MatchAssignmentCallback</code>, respectively. Here <a id="_idIndexMarker326"/>is a part of the code in <code>MatchAssignmentCallback::run</code>:</p><pre>void
MatchAssignmentCallback::run(const MatchResult &amp;Result) override {
  const auto&amp; Nodes = Result.Nodes;
  // Check if destination of both assignments are the   // same
  const auto *DestTrue =
             Nodes.<strong class="bold">getNodeAs&lt;DeclRefExpr&gt;</strong>("dest.true"),
             *DestFalse = 
             Nodes.<strong class="bold">getNodeAs&lt;DeclRefExpr&gt;</strong>("dest.false");
  if (DestTrue-&gt;<strong class="bold">getDecl</strong>() == DestFalse-&gt;<strong class="bold">getDecl</strong>()) {
    // Can be converted into ternary operator!
  }
}</pre><p>We are going to solve the second task – printing useful information to users – in the next step.</p></li>
				<li>To print useful information – including <em class="italic">which</em> part of the code can be converted into a ternary operator, and <em class="italic">how</em> can you build that ternary operator – we need to retrieve some AST nodes from the matched patterns before getting their source location information. For this, we will use some node binding tricks, as we did in the <a id="_idIndexMarker327"/>previous step. This time, we will modify all the pattern building functions; that is, <code>buildIfStmtMatcher</code>, <code>buildReturnMatcher</code>, and <code>buildAssignmentMatcher</code>:<pre>StatementMatcher
buildIfStmtMatcher(StatementMatcher truePattern,
                   StatementMatcher falsePattern) {
  return functionDecl(
    compoundStmt(hasAnySubstatement
      IfStmt(
        hasThen(truePattern)
        hasElse(falsePattern)).<code>IfStmt</code> since we want to tell our users where the potential places that can be converted into ternary operators are:</p><pre>StatementMatcher buildReturnMatcher(StringRef <code>MatchCallback::run</code> and print out the message using the <code>SourceLocation</code> information that's attached to those nodes.</p><p>We are going to use Clang's diagnostic framework to print out those messages here (feel free to read the <em class="italic">Printing diagnostic messages</em> section again if you're not familiar with it). And since the prospective message formats are not existing ones in Clang's code base, we are going to create our own diagnostic ID via <code>DiagnosticsEngine::getCustomDiagID(…)</code>. Here is what we will do in <code>MatchAssignmentCallback::run</code> (we will only demo <code>MatchAssignmentCallback</code> here since <code>MatchReturnCallback</code> is similar):</p><pre>void
MatchAssignmentCallback::run(const MatchResult &amp;Result) override {
  …
  auto&amp; Diag = Result.<strong class="bold">Context</strong>-&gt;<strong class="bold">getDiagnostics</strong>();
  auto <strong class="bold">DiagWarnMain</strong> = Diag.<strong class="bold">getCustomDiagID</strong>(
    DiagnosticsEngine::Warning,
    "this if statement can be converted to ternary      operator:");
  auto <strong class="bold">DiagNoteTrueExpr</strong> = Diag.<strong class="bold">getCustomDiagID</strong>(
    DiagnosticsEngine::Note,
    "with true expression being this:");
  auto <strong class="bold">DiagNoteFalseExpr</strong> = Diag.<strong class="bold">getCustomDiagID</strong>(
    DiagnosticsEngine::Note,
    "with false expression being this:");
  …
}</pre><p>Combining this with bound node retrievals, here is how we are going to print the messages:</p><pre>void
MatchAssignmentCallback::run(const MatchResult &amp;Result) override {
  …
  if (DestTrue &amp;&amp; DestFalse) {
      if (DestTrue-&gt;getDecl() == DestFalse-&gt;getDecl()) {
        // Can be converted to ternary!
        const auto* If = Nodes.getNodeAs&lt;IfStmt&gt;        ("if_stmt");
        Diag.Report(If-&gt;getBeginLoc(), <strong class="bold">DiagWarnMain</strong>);
        const auto* TrueValExpr = 
                    Nodes.getNodeAs&lt;Expr&gt;("<strong class="bold">val.true</strong>");
        const auto* FalseValExpr = 
                    Nodes.getNodeAs&lt;Expr&gt;("<strong class="bold">val.false</strong>");
        Diag.Report(TrueValExpr-&gt;getBeginLoc(), 
                    <strong class="bold">DiagNoteTrueExpr</strong>);
        Diag.Report(FalseValExpr-&gt;getBeginLoc(), 
                    <strong class="bold">DiagNoteFalseExpr</strong>);
      }
    }
}</pre></li>
				<li>Finally, go <a id="_idIndexMarker329"/>back to <code>CreateASTConsumer</code>. Here is how everything is pieced together:<pre>std::unique_ptr&lt;ASTConsumer&gt;
TernaryConverterAction::CreateASTConsumer(CompilerInstance &amp;CI, StringRef InFile) {
  …
  // Return matcher
  if (!NoReturn) {
  ReturnMatchCB = std::make_unique&lt;<strong class="bold">MatchReturnCallback</strong>&gt;();
    ASTFinder-&gt;addMatcher(
      traverse(TK_IgnoreUnlessSpelledInSource,                          
               buildIfStmtMatcher(
                 <strong class="bold">buildReturnMatcher(".true")</strong>,                                                 
                 <strong class="bold">buildReturnMatcher(".false")</strong>)),
      ReturnMatchCB.get()
    );
  }
  // Assignment matcher
  if (!NoAssignment) {
    AssignMatchCB = std::make_     unique&lt;<strong class="bold">MatchAssignmentCallback</strong>&gt;();
    ASTFinder-&gt;addMatcher(
      traverse(TK_IgnoreUnlessSpelledInSource,
               buildIfStmtMatcher(
                 <strong class="bold">buildAssignmentMatcher(".true")</strong>,
                 <strong class="bold">buildAssignmentMatcher(".false")</strong>)),
      AssignMatchCB.get()
    );
  }
  return std::move(ASTFinder-&gt;newASTConsumer());
}</pre><p>And that wraps up all the things we need to do!</p></li>
				<li>Last bu<a id="_idTextAnchor106"/>t not least, this is the command for running our plugin:<pre><code>-no-detect-return</code> and <code>-no-detect-assignment</code> in this project, please add the command-line options highlighted here:</p><pre><code>-plugin-arg-&lt;plugin name&gt;</code> format.</p></li>
			</ol>
			<p>In this section, you learned how to write an AST plugin that sends messages to users whenever there is an <code>if</code>-<code>else</code> statement that can be converted into a ternary operator. You did this by leveraging all the techniques that were covered in this chapter; that is, Clang AST's in-memory representation, ASTMatcher, and the diagnostic framework, to name a few.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor107"/>Summary</h1>
			<p>When it comes to program analysis, AST is usually the recommended medium to use, thanks to its rich amount of semantic information and high-level structures. In this chapter, we learned about the powerful in-memory AST representation that's used in Clang, including its C++ classes and APIs. This gives you a clear picture of the source code you are analyzing. </p>
			<p>Furthermore, we learned and practiced a concise way to do pattern matching on AST – a crucial procedure for program analysis – via Clang's ASTMatcher. Familiarizing yourself with this technique can greatly improve your efficiency when it comes to filtering out interesting areas from the input source code. Last but not least, we learned how to write an AST plugin that makes it easier for you to integrate custom logic into the default Clang compilation pipeline.</p>
			<p>In the next chapter, we will look at the <strong class="bold">drivers</strong> and <strong class="bold">toolchains</strong> in Clang. We will show you how they work and how to customize them.</p>
		</div>
	</body></html>