# 第4章。使用函数、数学和计时提高编程能力

作为一位数字艺术家，我需要特殊的条件才能工作。我们都需要自己的环境和氛围来提高生产力。即使我们每个人都有自己的方式，也有很多共同之处。

在这一章中，我想给你一些元素，这将使你更容易编写易于阅读、重用，尽可能美观的源代码。就像阴阳一样，对我来说，我的艺术和编程方面始终有一种禅意。这里我可以提供一些编程智慧之珠，以给你的创造性带来平静。

我们将要学习一些我们之前已经稍微使用过的一些内容：函数。它们同时有助于提高可读性和效率。在这个过程中，我们将涉及到许多项目中常用的数学和三角学。我们还将讨论一些计算优化的方法，并以Arduino固件中的与计时相关的事件或动作结束这一章。

在真正深入Arduino纯项目之前，这将是一个非常有趣的章节！

# 介绍函数

函数是一段通过名称定义的代码，可以在C程序中的许多不同点重用/执行。函数的名称在C程序中必须是**唯一的**。它也是`全局`的，这意味着，正如你之前已经读到的关于变量的内容，它可以在包含函数声明/定义的作用域内的C程序中的任何地方使用（参见[第3章](ch03.html "第3章。C基础 - 使你更强壮")中的作用域概念部分，*C基础 - 使你更强壮*）。

函数可能需要传递给它一些特殊元素；这些被称为**参数**。函数也可以产生并返回**结果**。

## 函数的结构

函数是一块代码，它有一个标题和一个主体。在标准C中，函数的声明和定义是分开进行的。函数的声明特别被称为函数原型的声明，并且必须在**头文件**中完成（参见[第2章](ch02.html "第2章。C语言初探")，*C语言初探*）。

### 使用Arduino IDE创建函数原型

Arduino IDE使我们的生活变得更简单；它为我们创建函数原型。但在特殊情况下，如果你需要声明函数原型，你可以在代码文件的开头进行声明。这提供了一种很好的源代码集中化的方式。

让我们用一个简单的例子来说明，我们想要创建一个函数，该函数将两个整数相加并产生/返回结果。有两个参数是整数类型的变量。在这种情况下，这两个`int`（整数）值的加法结果是另一个`int`值。这不必是，但在这个例子中是这样的。在这种情况下，原型将是：

[PRE0]

### 函数的标题和名称

了解原型看起来像什么很有趣，因为它与我们所说的头相似。函数的头是其第一个语句定义。让我们通过编写我们的函数 `mySum` 的全局结构来进一步了解：

[PRE1]

函数头具有以下全局形式：

[PRE2]

`returnType` 是一个变量类型。到现在为止，我猜你更好地理解了 `void` 类型。在我们的函数不返回任何内容的情况下，我们必须通过选择 `returnType` 等于 `void` 来指定它。

`functionName` 必须选择易于记忆，并且应尽可能具有自描述性。想象一下支持其他人编写的代码。寻找 `myNiceAndCoolMathFunction` 需要研究。另一方面，`mySum` 是自解释的。你更愿意支持哪个代码示例？

Arduino 核心库（甚至 C 语言）遵循一个称为驼峰式命名的命名约定。两个单词之间的区别，因为我们*不能*在函数名中使用空白/空格字符，是通过将单词的首字母大写来实现的。这不是必需的，但如果你想在以后节省时间，则推荐这样做。它更容易阅读，并且使函数具有自解释性。

`mysum` 的可读性不如 `mySum`，对吧？参数是一系列变量声明。在我们的 `mySum` 示例中，我们创建了两个函数参数。但我们也可以有一个没有参数的函数。想象一下，你需要调用一个函数来执行一个始终相同的动作，不依赖于变量。你会这样写：

[PRE3]

### 注意

在函数内部声明的变量只对其包含它们的函数是已知的。这就是所谓的“作用域”。在函数内部声明的此类变量在其他任何地方都无法访问，但它们可以被“传递”。可以传递的变量被称为**参数**。

### 函数的体和语句

如你可能直觉理解的那样，函数体是所有事情发生的地方；它是所有函数指令步骤构建的地方。

将函数体想象成一个真实、纯净且全新的代码块。你可以声明和定义变量，添加条件，并玩转循环。将函数体（指令）想象成雕塑家的粘土被塑形和塑造，最终以期望的效果呈现出来；可能是一块或几块，可能是相同的副本，等等。这是对现有事物的操作，但请记住：垃圾输入，垃圾输出！

你也可以，就像我们刚才介绍的，返回一个变量的值。让我们创建我们的 `mySum` 示例的函数体：

[PRE4]

`int result;` 声明了一个变量，并将其命名为 `result`。它的作用域与参数的作用域相同。`result = m + n;` 包含两个运算符，你已经知道 `+` 的优先级高于 `=`，这很好，因为数学运算首先进行，然后将结果存储在 `result` 变量中。这就是魔法发生的地方；取两个运算符，将它们中的一个变成函数。记住，在多个数学运算的组合中，不要忘记优先级顺序；这是至关重要的，以免得到意外的结果。

最后，`return result;` 是使函数调用返回值的语句。让我们通过一个实际的Arduino代码示例来更好地理解这一点：

[PRE5]

正如你所看到的，`mySum` 函数在示例中已经被定义并调用。最重要的语句是 `currentResult = mySum(i,i+1);`。当然，`i` 和 `i+1` 的技巧很有趣，但在这里要认识到的是在 `loop()` 函数开始处声明的变量 `currentResult` 的使用。

在编程中，重要的是要认识到右边的所有内容（内容）都进入左边（新容器）。根据优先级规则，函数调用相对于 `=` 赋值运算符的优先级为2对16。这意味着调用首先进行，函数返回 `+` 操作的结果，正如我们设计的那样。从这个角度来看，你刚刚学到了一些非常重要的东西：*函数返回值的调用语句是一个值*。

你可以查看 *附录B，C和C++中的运算符优先级* 以获取完整的优先级列表。与变量内的所有值一样，我们可以将其存储到另一个变量中，这里是在整数变量 `result` 中。

## 使用函数的好处

编程是关于为一般和特定目的编写代码片段。使用函数是分割你的代码的最佳方式之一。

### 更容易的编码和调试

函数真的可以帮助我们更好地组织。在设计程序时，我们经常使用伪代码，这也是我们注意到有很多常见语句的步骤。这些常见语句通常可以放在函数中。

函数/调用模式也更容易调试。函数所在的部分只有一段代码。如果有问题，我们只需调试一次函数本身，然后所有的调用都会被修复，而不是修改整个代码部分。

![更易编码和调试](img/7584_04_001.jpg)

函数使你的代码更容易调试

### 更好的模块化有助于重用性

你的一些代码将是高级和通用的。例如，在某个时候，你可能需要一系列可以切割数组并按照基本规则重新组合所有值的语句。这个系列可以是函数的主体。另一种方式是编写一个将华氏单位转换为摄氏单位的函数可能对你感兴趣。这两个例子都是通用函数。

相反，你也可以有一个特定功能的唯一目的是将美元转换为法国法郎。你可能不会经常调用它，但如果偶尔需要，它总是准备好处理这个任务。

在这两种情况下，函数都可以使用，当然也可以重用。背后的想法是节省时间。这也意味着你可以抓取一些已经存在的函数并重用它们。当然，这必须遵循一些原则，例如：

+   代码许可

+   尊重可以作为库一部分的函数的API

+   与你的目的相匹配

**代码许可**问题是一个重要点。我们习惯于抓取、测试和复制粘贴东西，但你找到的代码并不总是属于公共领域。你必须注意通常包含在代码发布存档中的许可文件，以及在代码的第一行，其中注释可以帮助你理解尊重其再使用的条件。

**应用程序编程接口**（**API**）意味着在使用与该API相关的材料之前，你必须遵守一些文档。我理解纯粹主义者可能会认为这是一种轻微的滥用，但这是一种相当实用主义的定义。

基本上，一个API定义了可以在其他程序内部重用的例程、数据结构和其他代码实体的规范。API规范可以是库的文档。在这种情况下，它将精确地定义你可以做什么，不可以做什么。

良好的匹配原则可能看起来很明显，但有时出于方便，我们会找到一个现有的库并选择使用它而不是编写自己的解决方案。不幸的是，有时最终我们只是增加了比最初打算更多的复杂性。自己来做可能满足简单的需求，并且肯定会避免更全面解决方案的复杂性和特殊性。还有避免潜在的性能损失；当你真正需要的是走到街角的超市时，你不会买一辆豪华轿车。

### 更好的可读性

这是其他益处的结果，但我希望让你明白这一点比注释你的代码更为重要。更好的可读性意味着节省时间来专注于其他事情。这也意味着更容易进行代码升级和改进步骤。

# C标准数学函数和Arduino

正如我们已经看到的，几乎所有的由编译器**avr-g++**支持的C和C++标准实体都应该与Arduino兼容。这也适用于C数学函数。

这组函数是（著名的）C标准库的一部分。这个组中的许多函数在C++中被继承。C和C++在复数的使用上存在一些差异。C++不从这个库中提供复数处理，而是通过其自己的C++标准库，使用类模板 `std::complex` 来提供。

几乎所有这些函数都是为了与浮点数一起工作并对其进行操作而设计的。在标准C中，这个库被称为 `math.h`（一个文件名），我们在C程序的头部提到它，这样我们就可以使用它的函数。

## Arduino核心中的三角函数

我们经常需要进行一些三角计算，从确定物体移动的距离，到角速度，以及许多其他现实世界的属性。有时，你需要在Arduino本身内部做这些计算，因为你会将其用作一个没有附近任何计算机的自主智能单元。

Arduino核心提供了经典的三角函数，可以通过编写它们的原型来总结。这些函数中的大部分以弧度返回结果。让我们先简要回顾一下我们的三角学！

### 一些先决条件

我保证，我会快速且简洁。但以下这些文本将节省你寻找你那本旧且破旧的学校课本的时间。当我从特定领域学习知识时，我特别喜欢把所有需要的东西都放在手边。

#### 弧度和度数之间的区别

**弧度**是许多三角函数使用的单位。然后，我们必须清楚弧度和度数，尤其是如何将一个转换为另一个。以下是官方的弧度定义：**Alpha**是两个距离之间的比率，并以弧度单位表示。

![弧度和度数之间的区别](img/7584_04_002.jpg)

弧度定义

**度**是一个完整旋转的1/360（完整圆）。考虑到这两个定义以及一个完整旋转等于2π的事实，我们可以将一个转换为另一个：

### 注意

angleradian = angledegree x π/180

angledegree = angleradian x 180/π

#### 余弦、正弦和正切

让我们看看三角形的例子：

![余弦、正弦和正切](img/7584_04_003.jpg)

考虑到以弧度为角度A，我们可以定义余弦、正弦和正切如下：

+   cos(A) = b/h

+   sin(A) = a/h

+   tan(A) = sin(A)/cos(A) = a/b

余弦和正弦在弧度角度的值为-1到1之间演变，而正切有一些特殊点，在这些点上它没有定义，然后周期性地从-∞演变到+∞。我们可以如下在同一张图上表示它们：

![余弦、正弦和正切](img/7584_04_004.jpg)

图形余弦、正弦和正切表示

当然，这些函数会振荡，无限地复制相同的演变。记住它们不仅可以用于纯计算，还可以通过用更平滑的振荡代替线性值演变来避免时间上的过度线性演变。我们稍后会看到这一点。

当我们有一个角度时，我们知道如何计算余弦/正弦/正切，但当我们已经有了余弦/正弦/正切时，如何计算角度呢？

#### 反余弦、反正弦和反正切

反余弦、反正弦和反正切被称为反三角函数。这些函数用于计算角度，当你已经有了之前提到的距离比时。

它们被称为反函数，因为这是之前看到的三角函数的逆/倒数过程。基本上，这些函数为你提供一个角度，但考虑到周期性，它们提供了很多角度。如果 k 是整数，我们可以写成：

+   sin (A) = x ó A = arcsin(x) + 2kπ 或 y = π – arcsin(x) + 2kπ

+   cos (A) = x ó A = arccos(x) + 2kπ 或 y = 2π – arccos (x) + 2kπ

+   tan (A) = x ó A = arctan(x) + kπ

这些是正确的数学关系。实际上，在通常情况下，我们可以忽略完整的旋转情况，并忘记余弦和正弦函数的 2kπ 以及正切函数的 kπ。

### 三角函数

`Math.h` 包含三角函数的原型，Arduino 核心也是如此：

+   `double cos (double x);` 返回 `x` 弧度的余弦值

+   `double sin (double x);` 返回 `x` 弧度的正弦值

+   `double tan (double x);` 返回 `x` 弧度的正切值

+   `double acos (double x);` 返回 A，对应于 cos (A) = `x` 的角度

+   `double asin (double x);` 返回 A，对应于 sin (A) = `x` 的角度

+   `double atan (double x);` 返回 A，对应于 tan (A) = `x` 的角度

+   `double atan2 (double y, double x);` 返回 arctan (`y`/`x`)

## 指数函数和一些其他函数

进行计算，即使是基本的计算，也涉及其他类型的数学函数，例如幂、绝对值等。Arduino 核心随后实现了这些函数。以下是一些数学函数的示例：

+   `double pow (double x, double y);` 返回 `x` 的 `y` 次幂

+   `double exp (double x);` 返回 `x` 的指数值

+   `double log (double x);` 返回 `x` 的自然对数，其中 `x` > 0

+   `double log10 (double x);` 返回 `x` 以 10 为底的对数，其中 `x` > 0

+   `double square (double x);` 返回 `x` 的平方

+   `double sqrt (double x);` 返回 `x` 的平方根，其中 `x` >= 0

+   `double fabs (double x);` 返回 `x` 的绝对值

当然，数学规则，特别是考虑到值的范围，必须得到尊重。这就是为什么我在列表中添加了一些关于 `x` 的条件。

所有这些函数都非常有用，即使是解决小问题。有一天，我在一个研讨会上教某人，不得不解释如何使用传感器测量温度。这位学生相当有动力，但她不了解这些函数，因为她只是玩输入和输出，没有进行任何转换（因为她基本上不需要那样做）。然后我们学习了这些函数，她甚至优化了自己的固件，这让我为她感到非常自豪！

现在，让我们探讨一些优化方法。

# 接近计算优化

这一部分是一个方法。这意味着它不包含所有高级编程优化的技巧，但包含纯计算的优化。

通常，我们设计一个想法，编写一个程序，然后优化它。对于大型程序来说，这很正常。对于较小的程序，我们可以在编码时进行优化。

### 注意

通常，我们的固件很小，所以我建议你考虑以下新规则：编写每个语句时都要考虑到优化。

我现在可以添加一些其他内容：不要用太多的神秘优化方案破坏你代码的可读性；我在写那的时候想到了*指针*。我会添加几行关于它们的介绍，以便让你至少熟悉这个概念。

## 位移运算的幂

如果我考虑一个数组来存储东西，我几乎总是选择2的幂作为大小。为什么？因为编译器，而不是通过使用CPU密集型的乘法操作来进行数组索引，可以使用更高效的位移操作。

### 位操作是什么？

你们中的一些人可能已经理解了我的工作方式；我使用了很多借口来教你们新东西。位运算符是针对位的具体运算符。有些情况下需要这种计算。我可以引用两个我们将在本书下一部分学习的情况：

+   使用移位寄存器进行复用

+   执行涉及乘法和除法运算符的2的幂的算术运算

有四个运算符和两个位移运算符。在我们深入之前，让我们更多地了解二进制数制。

### 二进制数制

我们习惯于使用十进制系统进行计数，也称为十进制数制或基-10数制。在这个系统中，我们可以这样计数：

0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12...

二进制数制是计算机和数字电子设备底层使用的系统。它也被称为基-2系统。在这个系统中，我们这样计数：

0, 1, 10, 11, 100, 101, 110, 111...

#### 将二进制数轻松转换为十进制数

将二进制转换为十进制的一个小技巧，从索引0开始，先计算0和1的位置。

让我们以110101为例。它可以表示如下：

| 位置 | 0 | 1 | 2 | 3 | 4 | 5 |
| --- | --- | --- | --- | --- | --- | --- |
| |   | 1 | 0 | 1 | 0 | 1 | 1 |

然后，我可以写出这个乘积之和，它等于我的110101数字的十进制版本：

1 x 20 + 0 x 21 + 1 x 22 + 0 x 23 + 1 x 24 + 1 x 25 = 1 + 4 + 16 + 32 = 53

每一位 *决定* 我们是否需要考虑2的幂，考虑到其位置。

### 与（AND）、或（OR）、异或（XOR）和非（NOT）运算符

让我们来看看这四个运算符。

#### 与（AND）

按位与运算符用单个与号（`&`）表示。这个运算符根据以下规则独立地对每个位位置进行操作：

+   0 `&` 0 == 0

+   0 `&` 1 == 0

+   1 `&` 0 == 0

+   1 `&` 1 == 1

让我们用一个实际的整数例子来说明，整数是一个16位的值：

[PRE6]

为了容易找到结果，我们必须遵循前面的规则，逐位比较每个位置的每个位。

#### OR

按位或运算符用单个竖线表示：`|`。在 OSX 上，可以通过按 *Alt* + *Shift* + *l*（字母 L）来实现，在其他 PC 键盘上则是 *Shift* + *\*。这个运算符根据以下规则独立地对每个位位置进行操作：

+   0 `|` 0 == 0

+   0 `|` 1 == 1

+   1 `|` 0 == 1

+   1 `|` 1 == 1

#### XOR

按位异或运算符用单个撇号符号表示：`^`。这个运算符根据以下规则独立地对每个位位置进行操作：

+   0 `^` 0 == 0

+   0 `^` 1 == 1

+   1 `^` 0 == 1

+   1 `^` 1 == 0

这是 XOR 的排他版本，因此得名 XOR。

#### NOT

按位异或运算符用波浪线符号表示：`~`。它是一个一元运算符，也就是说，如果你正确地记住这个术语，它只能应用于一个数字。我在我的研讨会上称它为*位变换器*。它将每个位变换为其相反数：

+   `~`0 == 1

+   `~`1 == 0

让我们用一个实际的整数例子来说明，正如你所知，整数是 16 位值：

[PRE7]

如你所知，C 语言中的 `int` 类型是一个有符号类型（[第 3 章](ch03.html "第 3 章。C 基础 – 使你更强壮"），*C 基础 – 使你更强壮*），能够编码从 -32,768 到 32,767 的数字——包括负数。

### 按位移位操作

来自 C++ 的左移和右移运算符分别用 `<<` 和 `>>` 表示。这很容易记住，双 << 表示向左移动，另一个 >> 表示向右移动。基本上，它的工作原理是这样的：

[PRE8]

很容易看出它是如何工作的。你将所有位从特定数量的位置向左或向右移动。有些人可能已经注意到，这与乘以或除以 2 是相同的。`<< 1` 表示乘以 2，`>> 1` 表示除以 2。`<< 3` 表示乘以 8（2^3），`>> 5` 表示除以 32（2^5），以此类推。

### 这一切都是关于性能

按位操作是处理器直接支持的原始操作。特别是对于嵌入式系统，它们仍然不如普通计算机强大，使用按位操作可以显著提高性能。我可以写出两条新的规则：

+   使用 2 的幂作为数组大小，在 CPU 执行索引计算时，会内部/隐式地驱动使用位移动运算符。正如我们刚刚学到的，乘以或除以 2 可以非常高效和快速地通过位移动来完成。

+   所有乘以或除以 2 的幂次的乘除运算都应该用位移动来替换。

这是在晦涩代码和高效代码之间最完美的折衷。我过去经常这样做。当然，我们将会学习使用它的实际案例。我们仍然处于这本书最理论的部分，但这里的一切很快就会变得清晰。

## switch 语句标签优化技术

在编写 `switch`…`case` 条件结构时，也可以对其进行优化。

### 优化案例范围

第一条规则是将考虑的switch的所有案例尽可能放在最窄的范围内。

在这种情况下，编译器生成我们所说的“案例标签跳转表”，而不是生成巨大的`if`-`else`-`if`级联。基于跳转表的`switch`…`case`语句的性能与`switch`语句中案例条目的数量无关。

### 注意

因此，将所有switch的案例放在尽可能窄的范围内。

### 根据频率优化案例

第二条规则是，当你知道频率时，将所有案例按最常发生到最不常发生的顺序排序。

如前所述，在`switch`语句包含相隔较远的案例的情况下，因为你不能以其他方式处理，编译器会替换`switch`语句并生成`if`-`else`-`if`级联。这意味着总是减少潜在的比较次数会更好；这也意味着如果最可能的案例被放在开始处，你就有更大的机会做到这一点。

### 注意

因此，将所有案例按最常发生到最不常发生的顺序排序。

## 范围越小，板子越好

就像我们在讨论变量作用域时已经提到的那样，始终为任何变量使用可能的最小作用域。让我们用名为`myFunction`的函数来检查这个例子：

[PRE9]

`temporaryVariable`只在一种情况下需要，即`valueToTest`等于`1`。如果我在`if`语句之外声明`temporaryVariable`，无论`valueToTest`的值如何，`temporaryVariable`都会被创建。

在我引用的例子中，我们节省了内存和处理时间；在所有`valueToTest`不等于`1`的情况下，变量`temporaryVariable`甚至没有被创建。

### 注意

为所有变量使用可能的最小作用域。

## 返回的道

函数通常是根据特定的想法设计的，它们是能够通过包含的语句执行特定操作的代码模块，并且也能够返回一个结果。这个概念提供了一个很好的方法，在我们不在函数内部时忘记函数内部执行的所有特定操作。我们知道函数被设计成当我们给它提供参数时提供结果。

再次强调，这是一种关注程序核心的好方法。

### 直接返回的概念

正如你可能已经理解的，声明一个变量会在内存中创建一个位置。当然，这个位置不能被其他东西使用。创建变量的过程会消耗处理器时间。让我们更详细地看看之前的例子：

[PRE10]

我能做些什么来尝试避免使用`temporaryVariable`？我可以进行如下直接的返回：

[PRE11]

在更长的版本中：

+   我们在`valueToTest == 1`的案例中，因此`valueToTest`等于`1`

+   我直接在`return`语句中放入计算

在那种情况下，不再需要创建临时变量。有些情况下，写很多临时变量可能更易于阅读。但现在，你已经意识到在可读性和效率之间找到折衷是值得的。

### 注意

使用直接返回而不是很多临时变量。

### 如果不需要返回值，请使用void

我经常阅读包含没有返回值的函数返回类型的代码。编译器可能会警告你这一点。但如果没有警告，你必须注意这个问题。调用一个提供返回类型的函数时，总是会传递返回值，即使函数体内实际上没有返回任何内容。这会产生CPU开销。

### 注意

如果你的函数不返回任何内容，请使用`void`作为返回类型。

## 查找表的秘密

**查找表**是编程宇宙中最强大的技巧之一。它们是包含预先计算值的数组，因此通过简单的数组索引操作替换了复杂的运行时计算。例如，想象一下你想通过读取来自一组距离传感器的距离来跟踪某个东西的位置。你将需要进行*三角*和可能*幂*的计算。由于这些计算可能会消耗处理器的时间，使用数组内容读取而不是这些计算会更聪明、更经济。这是查找表使用的通常说明。

这些查找表可以预先计算并存储在静态程序的存储内存中，或者计算在程序的初始化阶段（在这种情况下，我们称它们为*预取查找表*）。

有些函数在CPU工作方面特别昂贵。三角函数就是这样一种函数，在嵌入式系统中，由于存储空间和内存有限，它们可能会产生不良后果。它们通常在代码中被预取。让我们看看我们如何做到这一点。

### 表初始化

我们必须预先计算余弦**查找表**（**LUT**）。我们需要创建一个小的精度系统。在调用cos(x)时，我们可以拥有我们想要的任何x值。但如果我们想在具有设计上有限大小的数组中预取值，我们必须计算有限数量的值。然后，我们不能为所有浮点值计算余弦(x)的结果，而只能为计算出的那些值。

我认为精度是0.5度的角度。这意味着，例如，在我们系统中，45度的余弦值将等于45度4分钟的余弦值。这是合理的。

让我们考虑Arduino代码。你可以在`Chapter04`/`CosLUT`/文件夹中找到这段代码：

[PRE12]

`cosLUT`被声明为一个特殊大小的`float`类型数组。360 * 1/(精度，以度为单位)就是我们数组中需要的元素数量。在这里，精度是0.5度，当然，声明可以简化如下：

[PRE13]

我们还声明并定义了一个 `DEG2RAD` 常量，它有助于将度转换为弧度。我们声明了 `cosinePrecision` 和 `cosinePeriod` 以执行这些计算一次。

然后，我们定义了一个 `initCosineLUT()` 函数，它在 `setup()` 函数内部执行预计算。在其主体中，我们可以看到一个从 `i=0` 到数组大小的循环。这个循环预先计算了从 0 到 2π 的所有 x 值的余弦(x)值。我明确地将 x 写成 `i * DEG2RAD * precision`，以便保持精度可见。

在板初始化时，它计算所有查找表值一次，并通过简单的数组索引操作提供这些值以供进一步计算。

### 用数组索引操作替换纯计算

现在，让我们检索我们的余弦值。我们可以通过访问另一个函数来轻松检索我们的值，如下所示：

[PRE14]

`angle * 1 / cosinePrecision` 给出了考虑给定精度的 LUT 的角度。我们应用一个考虑 `cosinePeriod` 值的模运算，将更高角度的值包装到 LUT 的限制内，我们得到了索引。我们直接返回与我们的索引对应的数组值。

我们也可以使用这种技术进行平方根预取。这是我使用另一种语言在编写我的第一个名为 **digital collisions** 的 iOS 应用程序时使用的方法（[http://julienbayle.net/blog/2012/04/07/digital-collisions-1-1-new-features](http://julienbayle.net/blog/2012/04/07/digital-collisions-1-1-new-features)）。如果你没有测试过，这是一个基于物理碰撞算法的生成音乐和视觉应用程序。我需要进行大量的距离和旋转计算。相信我，这种技术将第一个缓慢的原型变成了一个快速的应用程序。

## 泰勒级数展开技巧

有一种节省CPU工作量的好方法，这需要一些数学知识。我的意思是，稍微高级一点的数学。以下内容非常简化。但确实，我们需要关注事情中的C部分，而不是完全关注数学。

泰勒级数展开是一种通过使用多项式表达式来近似特定点（及其周围）的几乎每个数学表达式的方法。

### 注意

多项式表达式类似于以下表达式：

P(x) = a + bx + cx^2 + dx^3

P(x)是一个三次多项式函数。a, b, c和d是浮点数。

泰勒级数的理念是，我们可以通过使用表示该表达式的理论无限和的第一个项来近似一个表达式。让我们举一些例子。

例如，考虑 x 从 -π 到 π 的变化；我们可以将正弦函数写成以下形式：

sin(x) ≈ x - x^3/6 + x^5/120 - x^7/5040

符号 ≈ 表示“约等于”。在合理范围内，我们可以用 x - x^3/6 + x^5/120 - x^7/5040 替换 sin(x)。这没有魔法，只是数学定理。我们也可以将 x 从 -2 到 3 的变化写成以下形式：

ex ≈ 1 + x + x^2/2 + x^3/6 + x^4/24

我可以在这里添加一些其他示例，但你将在 *附录 D，一些有用的泰勒级数用于计算优化* 中找到这些。这些技术是一些节省 CPU 时间的强大技巧。

## Arduino 核心甚至提供了指针

指针是 C 编程初学者的更复杂的技术，但我希望你能理解这个概念。它们不是数据，而是指向数据起始点的指针。至少有两种方法可以将数据传递给一个函数或其他东西：

+   复制并传递它

+   向它传递一个指针

在第一种情况下，如果数据量太大，我们的内存堆栈就会爆炸，因为整个数据都会复制在堆栈中。我们除了指针传递外别无选择。

在这种情况下，我们有数据存储在内存中的位置的引用。我们可以按照我们想要的任何方式操作，但只能通过使用指针。指针是处理任何类型数据，尤其是数组的智能方式。

# 时间测量

时间总是测量和处理的有意思的东西，尤其是在嵌入式软件中，这显然是我们在这里的主要目的。Arduino 核心包括几个我将要讨论的时间函数。

还有一个命名得非常巧妙的库，名为 **SimpleTimer Library**，由 *Marcello Romani* 设计，作为一个 GNU LGPL 2.1 + 库。这是一个基于 `millis()` 核心函数的好库，这意味着最大分辨率是 1 毫秒。这对你未来 99% 的项目来说将绰绰有余。*Marcello* 甚至为这本书制作了一个基于 `micros()` 的特殊版本库。

Arduino 核心库现在也包括一个能够达到 8 微秒分辨率的本地函数，这意味着你可以测量 1/8,000,000 秒的时间差；非常精确，不是吗？

我还会在书的最后一章描述一个更高分辨率的库 **FlexiTimer2**。它将提供一个高分辨率、可定制的计时器。

## Arduino 板子有自己的手表吗？

Arduino 板芯片提供其 *运行时间*。*运行时间* 是自板子启动以来的时间。这意味着你无法在不保持板子开启和供电的情况下，以原生方式存储绝对时间和日期。此外，它将要求你设置一次绝对时间，然后保持 Arduino 板供电。可以自主地为板子供电。我会在本书的后面部分讨论这一点。

### `millis()` 函数

核心函数 `millis()` 返回自板子上次启动以来的毫秒数。为了你的信息，1 毫秒等于 1/1000 秒。

Arduino核心文档还提供，这个数值在大约50天后会回到零（这被称为计时器溢出）。现在你可以笑了，但想象一下你的最新安装艺术性地在纽约市的MoMA中阐释时间概念，50天后会完全混乱。你肯定会对这个信息感兴趣，不是吗？`millis()`的返回格式是`unsigned long`。

这里是一个你将在接下来的几分钟内上传到板上的示例。你还可以在`Chapter04`/`measuringUptime`/文件夹中找到这段代码：

[PRE15]

你能优化这个（仅出于教学目的，因为这个程序非常小）吗？是的，我们确实可以避免使用`measuredTime`变量。它看起来会更像这样：

[PRE16]

它的简单性也很美，不是吗？我相信你会同意的。所以将这段代码上传到你的板上，启动串行监视器，看看它。

### `micros()`函数

如果你需要更高的精度，可以使用`micros()`函数。它提供与之前所述的8微秒精度相同的工作时间，但大约有70分钟的溢出（远小于50天，对吧？）。我们获得了精度，但失去了溢出时间范围。你还可以在`Chapter04`/`measuringUptimeMicros`/文件夹中找到以下代码：

[PRE17]

上传并检查串行监视器。

## 延迟概念和程序流程

就像那位连自己说话都是散文的布尔乔亚绅士一样，你已经使用了`delay()`核心函数，却并未意识到。在`loop()`函数中，可以通过直接使用`delay()`和`delayMicroseconds()`函数来延迟Arduino程序。

这两个函数都会使程序暂停。唯一的区别是，你必须为`delay()`提供一个毫秒数，为`delayMicroseconds()`提供一个微秒数。

### 程序在延迟期间做什么？

什么也不做。它等待。这个子子节并不是玩笑。我希望你能专注于这个特定的点，因为稍后它将非常重要。

### 注意

当你在程序中调用`delay`或`delayMicroseconds`时，它会停止执行一段时间。

这里有一个小图解，说明了当我们打开Arduino时会发生什么：

![程序在延迟期间做什么？](img/7584_04_012.jpg)

Arduino固件的一个生命周期

现在是一个固件执行的图解，这是我们将在下一行中工作的部分：

![程序在延迟期间做什么？](img/7584_04_005.jpg)

固件生命周期中的主要部分循环

接受这样一个事实：当`setup()`停止时，`loop()`函数开始循环，`loop()`中的所有内容都是连续的。现在看看当出现延迟时的情况：

![程序在延迟期间做什么？](img/7584_04_006.jpg)

当调用`delay()`时，固件的主要部分循环，并中断

当调用 `delay()` 时，整个程序会中断。中断的长度取决于传递给 `delay()` 的参数。

我们可以注意到，所有事情都是按顺序和按时完成的。如果一条语句执行需要很长时间，Arduino 的芯片会先执行它，然后继续下一个任务。

在那种非常常见和普遍的情况下，如果某个特定任务（语句、函数调用或任何其他）需要很长时间，整个程序可能会挂起并产生中断；考虑用户体验。

想象一下这样一个具体案例，你需要在同一时间读取传感器，切换一些开关，并将信息写入显示屏。如果你按顺序这样做，并且你有大量的传感器，这是相当常见的，那么在 `loop()` 中执行这个任务会在其他任务之后，你可能会在信息显示上出现一些延迟和减速。

![程序在延迟期间做什么？](img/7584_04_007.jpg)

一个忙于许多输入和输出的 Arduino 板

我通常至少向我的学生传授两个处理这种单一任务属性（可能会感觉像是一种限制）的概念：

+   线程

+   中断处理程序（以及随后的中断服务例程概念）

我显然还教授另一个：*轮询*。**轮询是一种特殊的中断情况，我们将从这里开始。**

### 投票概念 – 一种特殊的中断情况

你知道轮询这个词。我可以将其总结为“询问，等待答案，并将其保存在某处”。

如果我想创建一个读取输入并当这些输入的值满足特定条件时执行某些操作的代码，我会编写以下伪代码：

[PRE18]

这里可能有什么令人烦恼的地方？我循环地轮询新信息，并必须等待它。

在这个步骤中，没有做更多的事情，但想象一下输入值在很长时间内保持不变。我会在循环中周期性地请求这个值，将其他任务约束为等待。

这听起来像是一种浪费时间的行为。通常，轮询是完全足够的。它必须在这里写，而不是其他原始程序员可能会告诉你的内容。

我们是创造者，我们需要让事物相互沟通和运作，我们可以并且喜欢测试，不是吗？那么，你在这里就学到了一些重要的东西。

### 注意

在测试基本解决方案之前，不要设计复杂的程序解决方案。

有一天，我要求一些人设计基本代码。当然，像往常一样，他们连接到了互联网，我只是同意了，因为我们几乎所有人今天都在这样做，对吧？有些人比其他人先完成。

为什么呢？很多后来完成的人试图使用消息系统和外部库构建一个漂亮的多线程解决方案。他们的意图是好的，但在我们拥有的时间里，他们没有完成，只有一块漂亮的 Arduino 板，一些有线组件，以及一些在桌子上无法工作的代码。

你想知道其他人桌面上的内容吗？一个基于投票的例行程序，它完美地驱动着他们的电路！考虑到电路，这种基于投票的固件浪费的时间完全不重要。

### 注意

考虑到核心优化，但首先测试你的基本代码。

### 中断处理程序的概念

轮询很好，但有点耗时，正如我们刚才发现的。最好的方法是有能力以更智能的方式控制处理器何时需要处理输入或输出。

想象一下我们之前绘制的具有许多输入和输出的例子。也许，这是一个必须根据用户操作做出反应的系统。通常，我们可以认为用户输入的速度比系统的响应能力慢得多。

这意味着我们可以创建一个系统，当特定事件发生时，如用户输入，就会中断显示。这个概念被称为*基于事件的中断系统*。

**中断**是一个信号。当特定事件发生时，会向处理器发送一个中断消息。有时它被发送到处理器外部（硬件中断），有时是内部（软件中断）。

这就是磁盘控制器或任何外部外围设备如何通知主单元处理器在正确的时间提供这个或那个信息。

中断处理程序是一种通过执行某些操作来处理中断的例程。例如，当鼠标移动时，计算机操作系统（通常称为OS）必须在另一个位置重新绘制光标。让处理器本身每毫秒都测试鼠标是否移动，这将是疯狂的，因为CPU将运行在100%的利用率。似乎有一个专门的硬件部分来做这件事更明智。当鼠标移动发生时，它会向处理器发送一个中断，然后处理器会重新绘制鼠标。

在我们安装了大量的输入和输出的情况下，我们可以考虑使用中断来处理用户输入。我们不得不实现所谓的**中断服务例程**（**ISR**），这是一个仅在物理世界事件发生时调用的例程，即当传感器值改变或类似情况发生时。

Arduino现在提供了一种将中断附加到函数的好方法，现在设计ISR（即使我们稍后会学习如何做）变得容易。例如，我们现在可以使用ISR来响应模拟热传感器的值变化。在这种情况下，我们不会永久性地轮询模拟输入，而是让我们的低级Arduino部分来做。只有当值根据我们如何附加中断而变化（上升或下降）时，这才会作为触发器，并执行一个特殊函数（例如，LCD显示屏更新为新值）。

轮询、ISR，现在，我们将引入线程。请稍等！

### 线程是什么？

线程是处理器执行一系列任务（通常循环，但不一定）的运行程序流程。

只有一个处理器时，通常是通过*时分复用*来完成的，这意味着处理器根据时间在不同的线程之间切换，即上下文切换。

![什么是线程？](img/7584_04_008.jpg)

时分复用提供了多任务处理

更先进的处理器提供了*多线程*功能。它们表现得好像它们不仅仅是单个处理器，每个部分同时处理一个任务。

![什么是线程？](img/7584_04_009.jpg)

真正的多线程提供了同时发生的任务

由于我们现在没有处理计算机处理器，所以不深入探讨计算机处理器，我可以告诉你，线程是在编程中用来使任务同时运行的不错的技术。

不幸的是，Arduino核心不提供多线程，其他任何微控制器也不提供。因为Arduino是一个开源硬件项目，一些黑客已经设计了一种Arduino板的变体，并创建了一些Freeduino变体，提供*并发*，一个开源编程语言，以及一个特别为多线程设计的环境。这超出了我们的话题，但至少，如果你对此感兴趣，你现在有一些线索。

如果需要，让我们转向第二个解决方案，以超越一次只处理一个任务的限制。

### 一个现实生活中的轮询库示例

如本节第一行所述，Marcello的库是一个非常不错的库。它提供了一种基于轮询的方式来启动定时动作。

这些动作通常是函数调用。表现像这样的函数有时被称为回调函数。这些函数通常作为另一个代码片段的参数被调用。

假设我想让Arduino板上的宝贵LED每120毫秒闪烁一次。我可以使用延迟，但这将完全停止程序。不够聪明。

我可以在板上黑客一个硬件定时器，但这将是过度杀鸡用牛刀。一个更实用的解决方案是我会使用Marcello的`SimpleTimer`库中的回调函数。轮询提供了一种简单且经济的方式（从计算的角度来看）来处理非定时器依赖的应用程序，同时避免了使用中断，这会引发更复杂的问题，如硬件定时器过度消耗（劫持），这会导致其他复杂因素。

然而，如果你想要每5毫秒调用一个函数，而这个函数需要9毫秒才能完成，它将每9毫秒被调用一次。在我们的例子中，需要120毫秒来产生一个既美观又对眼睛友好的可见闪烁，我们非常安全。

仅供参考，你不需要在板子和你的电脑之间连接任何超过USB电缆的东西。Arduino板上焊接的LED连接到了数字引脚13。让我们使用它。

但首先，让我们下载`SimpleTimer`库，以便你第一次使用外部库。

#### 安装外部库

从[http://playground.arduino.cc/Code/SimpleTimer](http://playground.arduino.cc/Code/SimpleTimer)下载它，并在你的电脑上的某个位置解压。你通常会看到一个包含至少两个文件的文件夹：

+   头文件（`.h`扩展名）

+   源代码文件（`.cpp`扩展名）

现在，你可以亲自看看它们是什么。在这些文件中，你有源代码。打开你的草图簿文件夹（见[第1章](ch01.html "第1章. 让我们连接东西"), *让我们连接东西*），如果存在，将库文件夹移动到`libraries`文件夹中，否则创建这个特殊的文件夹：

![安装外部库](img/7584_04_010.jpg)

Marcello Romani编写的SimpleTimer的头文件和源代码

下次你启动Arduino IDE时，如果你去**草图** | **导入库**，你会在底部看到一个新库。

![安装外部库](img/7584_04_011.jpg)

为了包含一个库，你可以点击菜单中的它，它将在你的代码中写入`#include <libname.h>`。你也可以自己输入这个。

#### 让我们来测试一下代码

上传此代码并重新启动Arduino；我将解释它是如何工作的。你也可以在`Chapter04`/`simpleTimerBlinker`/文件夹中找到此代码：

[PRE19]

在我们的案例中，这个库很容易使用。当然，你首先必须包含它。然后，你必须通过声明来创建`SimpleTimer`的实例，这是一个对象构造。

然后，我使用一个`currentLEDState`布尔值来显式存储LED的当前状态。最后，我声明/定义`ledPin`为所需的引脚号（在这种情况下，13）以使LED闪烁。`setup()`基本上是一些初始化。这里最重要的是`timer.setInterval()`函数。

也许，这是你的第一次方法调用。对象timer包含一些我们可以使用的方法。其中之一是`setInterval`，它接受两个变量：

+   一个时间间隔

+   回调函数

我们在这里传递一个函数名（一段代码）给另一段代码。这是典型回调系统的结构。

`loop()`是通过在每次运行时调用计时器对象的`run()`方法来设计的。这是使用它的必要条件。至少，回调函数`blink()`在最后使用了一个小技巧。

比较很明显。我测试LED的当前状态，如果它已经开启，我就将其关闭，否则将其开启。然后，我反转状态，这就是技巧。我正在使用`!`（非）一元运算符在这个布尔变量上以翻转其值，并将反转后的值赋给布尔变量本身。我本可以这样写：

[PRE20]

实际上，无论是哪种方式，都没有性能提升。这只是一个个人决定；使用你喜欢的任何一种。

我个人认为翻转是一个必须每次都做的通用动作，与状态无关。这就是为什么我建议你将其放在测试结构之外的原因。

# 摘要

这完成了本书的第一部分。我希望你已经能够吸收并享受这些（庞大）的第一步。如果还没有，你可能想要花些时间去回顾一下你可能不太清楚的地方；更好地理解你所做的事情总是值得的。

我们对C和C++编程了解得更多一些，至少足够让我们安全地通过接下来的两部分。我们现在可以理解Arduino的基本任务，我们可以上传我们的固件，并且可以用基本的接线来测试它们。

现在，我们将进一步深入到一个更加实用、理论较少的领域。准备好去探索新的物理世界，在那里你可以让事物发声，相互交流，你的电脑将能够对你的感受和反应做出回应，有时甚至不需要电线！再次提醒，你可能想要花一点时间去回顾一下你可能仍然有些模糊的地方；知识就是力量。

未来已经到来！
