["```cpp\n   // naïve version with elems of type T*\n   Vector(size_type n, const_reference init)\n      : elems{ new value_type[n] }, nelems{ n }, cap{ n } {\n      try {\n         std::fill(begin(), end(), init);\n      } catch (...) {\n         delete [] elems;\n         throw;\n      }\n   }\n// ...\n```", "```cpp\n   // sophisticated version with elems of type T*\n   Vector(size_type n, const_reference init)\n      : elems{ static_cast<pointer>(\n           std::malloc(n * sizeof(value_type))\n        ) }, nelems{ n }, cap{ n } {\n      try {\n         std::uninitialized_fill(begin(), end(), init);\n      } catch (...) {\n         std::free(elems);\n         throw;\n      }\n   }\n// ...\n```", "```cpp\n// naïve implementation, explicit memory management\n// declaration of the data members...\npointer elems{};\nsize_type nelems{}, cap{};\n```", "```cpp\n// naïve implementation, implicit memory management\n// declaration of the data members...\nstd::unique_ptr<value_type[]> elems;\nsize_type nelems{}, cap{};\n```", "```cpp\n// naïve implementation, explicit memory management\niterator begin() {\n   return elems; // raw pointer to the memory block\n}\nconst_iterator begin() const {\n   return elems; // raw pointer to the memory block\n}\n```", "```cpp\n// naïve implementation, implicit memory management\niterator begin() {\n   return elems.get(); // raw pointer to the beginning\n                       // of the underlying memory block\n}\nconst_iterator begin() const {\n   return elems.get(); // likewise\n}\n```", "```cpp\n// naïve implementation, explicit memory management\n   Vector(size_type n, const_reference init)\n      : elems{ new value_type[n] }, nelems{ n }, cap{ n } {\n      try {\n         std:: fill(begin(), end(), init);\n      } catch (...) {\n         delete [] elems;\n         throw;\n      }\n   }\n// ...\n```", "```cpp\n// naïve implementation, implicit memory management\n   Vector(size_type n, const_reference init)\n      : elems{ new value_type[n] }, nelems{ n }, cap{ n } {\n      std:: fill(begin(), end(), init);\n   }\n// ...\n```", "```cpp\n// naïve implementation, explicit memory management\n   Vector(Vector &&other)\n      : elems{ std::exchange(other.elems, nullptr) },\n        nelems{ std::exchange(other.nelems, 0) },\n        cap{ std::exchange(other.cap, 0) } {\n   }\n   Vector& operator=(Vector &&other) {\n      Vector{ other }.swap(*this);\n      return *this;\n   }\n   ~Vector() {\n      delete [] elems;\n   }\n// ...\n```", "```cpp\n// naïve implementation, implicit memory management\n   Vector(Vector&&) = default;\n   Vector& operator=(Vector&&) = default;\n   ~Vector() = default;\n// ...\n```", "```cpp\n// naïve implementation, explicit memory management\n   void resize(size_type new_cap) {\n      if(new_cap <= capacity()) return;\n      auto p = new T[new_cap];\n      if constexpr(std::is_nothrow_move_assignable_v<T>) {\n         std::move(begin(), end(), p);\n      } else try {\n         std::copy(begin(), end(), p);\n      } catch (...) {\n         delete[] p;\n         throw;\n      }\n      delete[] elems;\n      elems = p;\n      cap = new_cap;\n   }\n```", "```cpp\n// naïve implementation, implicit memory management\n   void resize(size_type new_cap) {\n      if(new_cap <= capacity()) return;\n      auto p = std::make_unique<value_type[]>(new_cap);\n      if constexpr(std::is_nothrow_move_assignable_v<T>) {\n         std::move(begin(), end(), p.get());\n      } else {\n         std::copy(begin(), end(), p.get());\n      }\n      elems.reset(p.release());\n      cap = new_cap;\n   }\n```", "```cpp\n// ...\ntemplate <class T>\nclass Vector {\npublic:\n   using value_type = T;\n   using size_type = std::size_t;\n   using pointer = T*;\n   using const_pointer = const T*;\n   using reference = T&;\n   using const_reference = const T&;\n   // ...\n```", "```cpp\n   // ...\nprivate:\n   struct deleter {\n      Vector& source;\n      void operator()(value_type* p) {\n         std::destroy(std::begin(source),\n                      std::end(source));\n         std::free(static_cast<void*>(p));\n      }\n   };\n   std::unique_ptr<value_type[], deleter> elems;\n   size_type nelems{},\n             cap{};\n   // ...\n```", "```cpp\n   // ...\n   using iterator = pointer;\n   using const_iterator = const_pointer;\n   iterator begin() { return elems.get(); }\n   const_iterator begin() const { return elems.get(); }\n   // ...\n```", "```cpp\n   // ...\n   constexpr Vector()\n      : elems{ nullptr, deleter { *this } } {\n   }\n   Vector(size_type n, const_reference init)\n      : elems{ static_cast<pointer>(\n           std::malloc(n * sizeof(value_type))\n        ), deleter{ *this }\n      } {\n      std::uninitialized_fill(begin(), begin() + n, init);\n      nelems = cap = n;\n   }\n   Vector(Vector&& other) noexcept\n      : elems{ std::exchange(\n           other.elems.release()), deleter{ *this }\n        },\n        nelems{ std::exchange(other.nelems, 0) },\n        cap{ std::exchange(other.cap, 0) } {\n   }\n   // ...\n```", "```cpp\n   // ...\n   ~Vector() = default;\n   void swap(Vector& other) noexcept {\n      using std::swap;\n      swap(elems, other.elems);\n      swap(nelems, other.nelems);\n      swap(cap, other.cap);\n   }\n   Vector& operator=(const Vector& other) {\n      Vector{ other }.swap(*this);\n      return *this;\n   }\n   Vector& operator=(Vector&& other) {\n      Vector{ std::move(other) }.swap(*this);\n      return *this;\n   }\n   reference operator[](size_type n) { return elems[n]; }\n   const_reference operator[](size_type n) const {\n      return elems[n];\n   }\n```", "```cpp\n   // ...\n   void reserve(size_type new_cap) {\n      if (new_cap <= capacity()) return;\n      std::unique_ptr<value_type[]> p{\n         static_cast<pointer>(\n            std::malloc(new_cap * sizeof(T))\n         )\n      };\n      if constexpr (std::is_nothrow_move_assignable_v<T>) {\n         std::uninitialized_move(begin(), end(), p.get());\n      } else {\n         std::uninitialized_copy(begin(), end(), p.get());\n      }\n      std::destroy(begin(), end());\n      elems.reset(p.release());\n      cap = new_cap;\n   }\n```", "```cpp\n   // ...\n   void resize(size_type new_cap) {\n      if (new_cap <= capacity()) return;\n      std::unique_ptr<value_type[]> p =\n         static_cast<pointer>(\n            std::malloc(new_cap * sizeof(T))\n         );\n      if constexpr (std::is_nothrow_move_assignable_v<T>) {\n         std::uninitialized_move(begin(), end(), p.get());\n      } else {\n         std::uninitialized_copy(begin(), end(), p.get());\n      }\n      std::uninitialized_fill(\n         p.get() + size(), p.get() + new_cap, value_type{}\n      );\n      std::destroy(begin(), end());\n      elems.reset(p.release());\n      nelems = cap = new_cap;\n   }\n   // ...\n```", "```cpp\ntemplate <class T>\nclass ForwardList {\npublic:\n   // ...\nprivate:\n   struct Node {\n      value_type value;\n      std::unique_ptr<Node> next; // <--\n      Node(const_reference value) : value{ value } {\n      }\n      Node(value_type&& value) : value{ std::move(value) }{\n      }\n   };\n   Node* head{};\n   size_type nelems{};\n   // ...\n```", "```cpp\n   // ...\n   ~ForwardList() {\n      delete head; // <-- lots of work starts here!\n   }\n   // ...\n```", "```cpp\n   // ...\n   template <class U> class Iterator {\n   public:\n      // ...\n   private:\n      Node* cur{};\n   public:\n      // ...\n      Iterator& operator++() {\n         cur = cur->next.get(); // <--\n         return *this;\n      }\n   // ...\n```", "```cpp\n   // ...\n   template <std::forward_iterator It>\n   ForwardList(It b, It e) {\n      try {\n         if (b == e) return;\n         head = new Node{ *b };\n         auto q = head;\n         ++nelems;\n         for (++b; b != e; ++b) {\n            q->next = std::make_unique<Node>(*b); // <--\n            q = q->next.get(); // <--\n            ++nelems;\n         }\n      } catch (...) {\n         delete head; // <--\n         throw;\n      }\n   }\n   // ...\n```", "```cpp\n   // ...\n   void push_front(const_reference val) {\n      auto p = new Node{ val };\n      p->next = std::unique_ptr<Node>{ head }; // <--\n      head = p;\n      ++nelems;\n   }\n   void push_front(T&& val) {\n      auto p = new Node{ std::move(val) };\n      p->next = std::unique_ptr<Node>{ head }; // <--\n      head = p;\n      ++nelems;\n   }\n   // ...\n```", "```cpp\n   // ...\n   iterator\n      insert_after(iterator pos, const_reference value) {\n      auto p = std::make_unique<Node>(value); // <-- A\n      p->next.reset(pos.cur->next.get()); // <-- B\n      pos.cur->next.release(); // <-- C\n      pos.cur->next.reset(p.get()); // <-- D\n      p.release(); // <-- E\n      ++nelems;\n      return { pos.cur->next.get() }; // <-- F\n   }\n   // ...\n```", "```cpp\ntemplate <class T>\nclass ForwardList {\n   // ...\n   struct Node {\n      value_type value;\n      Node* next = nullptr;\n      Node(const_reference value) : value{ value } {\n      }\n      Node(value_type&& value) : value{ std::move(value) }{\n      }\n   };\n   struct deleter { // <--\n      void operator()(Node* p) const {\n         while (p) {\n            Node* q = p->next;\n            delete p;\n            p = q;\n         }\n      }\n   };\n   std::unique_ptr<Node, deleter> head;\nForwardList<T> type that, when an object of that type is destroyed, implicitly ensures that the nodes in the list are destructed. The entire list remains built from raw pointers, such that nodes are not responsible for memory management, which is probably an upgrade from the previous attempt.\nWith this implementation, we would get a defaulted `ForwardList<T>` destructor, which is a good thing. There would be a tiny complexity increase in `clear()` where we need to distinguish the `head` smart pointer from the underlying pointer:\n\n```", "```cpp\n\n The iterator interface needs to be adapted somewhat since `head` is not a `Node*` anymore, but iterators trade in non-owning resources:\n\n```", "```cpp\n\n The `ForwardList<T>` constructor that takes a pair of iterators and towards which most other constructors converge requires slight modifications:\n\n```", "```cpp\n\n The exception handling side of this member function is indeed simplified, being made implicit from the fact that, should any constructor of a `T` object throw an exception, the previously created nodes will be destroyed.\nAs in the previous version, our `push_front()` member functions will require some adjustment as they interact with the `head` data member:\n\n```", "```cpp\n\n On the upside, no member function that does not interact with the `head` data member requires any modification.\nIs this “implicitness” worth it? It probably depends on the way in which you approach writing code. We did gain something of value in implicit exception safety. There is value in separating concerns, and this implementation does free the container from the task of managing memory (for the most part). It is up to you, dear reader, to determine whether the reduced complexity “here” outweighs the added complexity “there.”\nSummary\nIn this chapter, we reexamined containers written in [*Chapter 12*](B21071_12.xhtml#_idTextAnchor172), seeking to use implicit memory management tools in such a way as to make our implementations simpler and safer. We did reach an improvement in `Vector<T>` but the results obtained with our node-based `ForwardList<T>` container were… not absent, but arguably less conclusive depending on your perspective.\nIn the next chapter, we will introduce the idea of allocators, objects that inform containers as to how memory should be obtained or liberated, and examine how they impact the ways in which we write code.\n\n```"]