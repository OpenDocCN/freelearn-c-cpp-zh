["```cpp\n#define LIKELY(x) __builtin_expect(!!(x), 1)\n#define UNLIKELY(x) __builtin_expect(!!(x), 0)\n```", "```cpp\ninline auto ASSERT(bool cond, const std::string& msg)\n  noexcept {\n  if(UNLIKELY(!cond)) {\n    std::cerr << msg << std::endl;\n    exit(EXIT_FAILURE);\n  }\n}\ninline auto FATAL(const std::string& msg) noexcept {\n  std::cerr << msg << std::endl;\n  exit(EXIT_FAILURE);\n}\n```", "```cpp\n#include <cstring>\n#include <iostream>\n```", "```cpp\n#pragma once\n#include <iostream>\n#include <atomic>\n#include <thread>\n#include <unistd.h>\n#include <sys/syscall.h>\ntemplate<typename T, typename... A>\ninline auto createAndStartThread(int core_id, const\n  std::string &name, T &&func, A &&... args) noexcept {\n  std::atomic<bool> running(false), failed(false);\n  auto thread_body = [&] {\n    if (core_id >= 0 && !setThreadCore(core_id)) {\n      std::cerr << \"Failed to set core affinity for \" <<\n        name << \" \" << pthread_self() << \" to \" << core_id\n          << std::endl;\n      failed = true;\n      return;\n    }\n    std::cout << \"Set core affinity for \" << name << \" \" <<\n      pthread_self() << \" to \" << core_id << std::endl;\n    running = true;\n    std::forward<T>(func)((std::forward<A>(args))...);\n  };\n  auto t = new std::thread(thread_body);\n  while (!running && !failed) {\n    using namespace std::literals::chrono_literals;\n    std::this_thread::sleep_for(1s);\n  }\n  if (failed) {\n    t->join();\n    delete t;\n    t = nullptr;\n  }\n  return t;\n}\n```", "```cpp\ninline auto setThreadCore(int core_id) noexcept {\n  cpu_set_t cpuset;\n  CPU_ZERO(&cpuset);\n  CPU_SET(core_id, &cpuset);\n  return (pthread_setaffinity_np(pthread_self(), sizeof\n    (cpu_set_t), &cpuset) == 0);\n}\n```", "```cpp\n#include \"thread_utils.h\"\nauto dummyFunction(int a, int b, bool sleep) {\n  std::cout << \"dummyFunction(\" << a << \",\" << b << \")\" <<\n    std::endl;\n  std::cout << \"dummyFunction output=\" << a + b <<\n    std::endl;\n  if(sleep) {\n    std::cout << \"dummyFunction sleeping...\" << std::endl;\n    using namespace std::literals::chrono_literals;\n    std::this_thread::sleep_for(5s);\n  }\n  std::cout << \"dummyFunction done.\" << std::endl;\n}\nint main(int, char **) {\n  using namespace Common;\n  auto t1 = createAndStartThread(-1, \"dummyFunction1\",\n    dummyFunction, 12, 21, false);\n  auto t2 = createAndStartThread(1, \"dummyFunction2\",\n    dummyFunction, 15, 51, true);\n  std::cout << \"main waiting for threads to be done.\" <<\n    std::endl;\n  t1->join();\n  t2->join();\n  std::cout << \"main exiting.\" << std::endl;\n  return 0;\n}\n```", "```cpp\n(base) sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter4$ ./cmake-build-release/thread_example\nSet core affinity for dummyFunction1 140124979386112 to -1\ndummyFunction(12,21)\ndummyFunction output=33\ndummyFunction done.\nSet core affinity for dummyFunction2 140124970993408 to 1\ndummyFunction(15,51)\ndummyFunction output=66\ndummyFunction sleeping...\nmain waiting for threads to be done.\ndummyFunction done.\nmain exiting.\n```", "```cpp\n#pragma once\n#include <cstdint>\n#include <vector>\n#include <string>\n#include \"macros.h\"\nnamespace Common {\n  template<typename T>\n  class MemPool final {\nprivate:\n  struct ObjectBlock {\n    T object_;\n    bool is_free_ = true;\n  };\n  std::vector<ObjectBlock> store_;\n  size_t next_free_index_ = 0;\n};\n```", "```cpp\npublic:\n  explicit MemPool(std::size_t num_elems) :\n      store_(num_elems, {T(), true}) /* pre-allocation of\n        vector storage. */ {\n    ASSERT(reinterpret_cast<const ObjectBlock *>\n      (&(store_[0].object_)) == &(store_[0]), \"T object\n        should be first member of ObjectBlock.\");\n  }\n```", "```cpp\n  MemPool() = delete;\n  MemPool(const MemPool&) = delete;\n  MemPool(const MemPool&&) = delete;\n  MemPool& operator=(const MemPool&) = delete;\n  MemPool& operator=(const MemPool&&) = delete;\n```", "```cpp\n    template<typename... Args>\n    T *allocate(Args... args) noexcept {\n      auto obj_block = &(store_[next_free_index_]);\n      ASSERT(obj_block->is_free_, \"Expected free\n        ObjectBlock at index:\" + std::to_string\n          (next_free_index_));\n      T *ret = &(obj_block->object_);\n      ret = new(ret) T(args...); // placement new.\n      obj_block->is_free_ = false;\n      updateNextFreeIndex();\n      return ret;\n    }\n```", "```cpp\n  private:\n    auto updateNextFreeIndex() noexcept {\n      const auto initial_free_index = next_free_index_;\n      while (!store_[next_free_index_].is_free_) {\n        ++next_free_index_;\n        if (UNLIKELY(next_free_index_ == store_.size())) {\n          // hardware branch predictor should almost always\n              predict this to be false any ways.\n          next_free_index_ = 0;\n        }\n        if (UNLIKELY(initial_free_index ==\n          next_free_index_)) {\n          ASSERT(initial_free_index != next_free_index_,\n            \"Memory Pool out of space.\");\n        }\n      }\n    }\n```", "```cpp\n    auto deallocate(const T *elem) noexcept {\n      const auto elem_index = (reinterpret_cast<const\n        ObjectBlock *>(elem) - &store_[0]);\n      ASSERT(elem_index >= 0 && static_cast<size_t>\n        (elem_index) < store_.size(), \"Element being\n          deallocated does not belong to this Memory\n            pool.\");\n      ASSERT(!store_[elem_index].is_free_, \"Expected in-use\n        ObjectBlock at index:\" + std::to_string\n          (elem_index));\n      store_[elem_index].is_free_ = true;\n    }\n```", "```cpp\n#include \"mem_pool.h\"\nstruct MyStruct {\n  int d_[3];\n};\nint main(int, char **) {\n  using namespace Common;\n  MemPool<double> prim_pool(50);\n  MemPool<MyStruct> struct_pool(50);\n  for(auto i = 0; i < 50; ++i) {\n    auto p_ret = prim_pool.allocate(i);\n    auto s_ret = struct_pool.allocate(MyStruct{i, i+1,\n      i+2});\n    std::cout << \"prim elem:\" << *p_ret << \" allocated at:\"\n      << p_ret << std::endl;\n    std::cout << \"struct elem:\" << s_ret->d_[0] << \",\" <<\n      s_ret->d_[1] << \",\" << s_ret->d_[2] << \" allocated\n        at:\" << s_ret << std::endl;\n    if(i % 5 == 0) {\n      std::cout << \"deallocating prim elem:\" << *p_ret << \"\n        from:\" << p_ret << std::endl;\n      std::cout << \"deallocating struct elem:\" << s_ret\n        ->d_[0] << \",\" << s_ret->d_[1] << \",\" << s_ret->\n           d_[2] << \" from:\" << s_ret << std::endl;\n      prim_pool.deallocate(p_ret);\n      struct_pool.deallocate(s_ret);\n    }\n  }\n  return 0;\n}\n```", "```cpp\n(base) sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter4$ ./cmake-build-release/mem_pool_example\nprim elem:0 allocated at:0x5641b4d1beb0\nstruct elem:0,1,2 allocated at:0x5641b4d1c220\ndeallocating prim elem:0 from:0x5641b4d1beb0\ndeallocating struct elem:0,1,2 from:0x5641b4d1c220\nprim elem:1 allocated at:0x5641b4d1bec0\nstruct elem:1,2,3 allocated at:0x5641b4d1c230\nprim elem:2 allocated at:0x5641b4d1bed0\n...\n```", "```cpp\n#pragma once\n#include <iostream>\n#include <vector>\n#include <atomic>\nnamespace Common {\n  template<typename T>\n  class LFQueue final {\n  private:\n    std::vector<T> store_;\n    std::atomic<size_t> next_write_index_ = {0};\n    std::atomic<size_t> next_read_index_ = {0};\n    std::atomic<size_t> num_elements_ = {0};\n  };\n}\n```", "```cpp\ntemplate<typename T>\nclass LFQueue final {\npublic:\n  LFQueue(std::size_t num_elems) :\n      store_(num_elems, T()) /* pre-allocation of vector\n        storage. */ {\n  }\n```", "```cpp\n  LFQueue() = delete;\n  LFQueue(const LFQueue&) = delete;\n  LFQueue(const LFQueue&&) = delete;\n  LFQueue& operator=(const LFQueue&) = delete;\n  LFQueue& operator=(const LFQueue&&) = delete;\n```", "```cpp\n  auto getNextToWriteTo() noexcept {\n    return &store_[next_write_index_];\n  }\n  auto updateWriteIndex() noexcept {\n      next_write_index_ = (next_write_index_ + 1) %\n        store_.size();\n      num_elements_++;\n  }\n```", "```cpp\n  auto getNextToRead() const noexcept -> const T * {\n    return (next_read_index_ == next_write_index_) ?\n      nullptr : &store_[next_read_index_];\n  }\n  auto updateReadIndex() noexcept {\n      next_read_index_ = (next_read_index_ + 1) %\n        store_.size();\n      ASSERT(num_elements_ != 0, \"Read an invalid element\n        in:\" + std::to_string(pthread_self()));\n      num_elements_--;\n  }\n```", "```cpp\n    auto size() const noexcept {\n      return num_elements_.load();\n    }\n```", "```cpp\n#include \"thread_utils.h\"\n#include \"lf_queue.h\"\nstruct MyStruct {\n  int d_[3];\n};\nusing namespace Common;\nauto consumeFunction(LFQueue<MyStruct>* lfq) {\n  using namespace std::literals::chrono_literals;\n  std::this_thread::sleep_for(5s);\n  while(lfq->size()) {\n    const auto d = lfq->getNextToRead();\n    lfq->updateReadIndex();\n    std::cout << \"consumeFunction read elem:\" << d->d_[0]\n      << \",\" << d->d_[1] << \",\" << d->d_[2] << \" lfq-size:\"\n        <<lfq->size() << std::endl;\n    std::this_thread::sleep_for(1s);\n  }\n  std::cout << \"consumeFunction exiting.\" << std::endl;\n}\nint main(int, char **) {\n  LFQueue<MyStruct> lfq(20);\n  auto ct = createAndStartThread(-1, \"\", consumeFunction,\n    &lfq);\n  for(auto i = 0; i < 50; ++i) {\n    const MyStruct d{i, i * 10, i * 100};\n    *(lfq.getNextToWriteTo()) = d;\n    lfq.updateWriteIndex();\n    std::cout << \"main constructed elem:\" << d.d_[0] << \",\"\n      << d.d_[1] << \",\" << d.d_[2] << \" lfq-size:\" <<\n        lfq.size() << std::endl;\n    using namespace std::literals::chrono_literals;\n    std::this_thread::sleep_for(1s);\n  }\n  ct->join();\n  std::cout << \"main exiting.\" << std::endl;\n  return 0;\n}\n```", "```cpp\n(base) sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter4$ ./cmake-build-release/lf_queue_example\nSet core affinity for  139710770276096 to -1\nmain constructed elem:0,0,0 lfq-size:1\nmain constructed elem:1,10,100 lfq-size:2\nmain constructed elem:2,20,200 lfq-size:3\nmain constructed elem:3,30,300 lfq-size:4\nconsumeFunction read elem:0,0,0 lfq-size:3\nmain constructed elem:4,40,400 lfq-size:4\nconsumeFunction read elem:1,10,100 lfq-size:3\nmain constructed elem:5,50,500 lfq-size:4\nconsumeFunction read elem:2,20,200 lfq-size:3\nmain constructed elem:6,60,600 lfq-size:4\nconsumeFunction read elem:3,30,300 lfq-size:3\nmain constructed elem:7,70,700 lfq-size:4\nconsumeFunction read elem:4,40,400 lfq-size:3\n...\n```", "```cpp\n#pragma once\n#include <chrono>\n#include <ctime>\nnamespace Common {\n  typedef int64_t Nanos;\n  constexpr Nanos NANOS_TO_MICROS = 1000;\n  constexpr Nanos MICROS_TO_MILLIS = 1000;\n  constexpr Nanos MILLIS_TO_SECS = 1000;\n  constexpr Nanos NANOS_TO_MILLIS = NANO_TO_MICROS *\n    MICROS_TO_MILLIS;\n  constexpr Nanos NANOS_TO_SECS = NANOS_TO_MILLIS *\n    MILLIS_TO_SECS;\n  inline auto getCurrentNanos() noexcept {\n    return std::chrono::duration_cast\n      <std::chrono::nanoseconds>(std::chrono::\n        system_clock::now().time_since_epoch()).count();\n  }\n  inline auto& getCurrentTimeStr(std::string* time_str) {\n    const auto time = std::chrono::system_clock::\n      to_time_t(std::chrono::system_clock::now());\n    time_str->assign(ctime(&time));\n    if(!time_str->empty())\n      time_str->at(time_str->length()-1) = '\\0';\n    return *time_str;\n  }\n}\n```", "```cpp\n#pragma once\n#include <string>\n#include <fstream>\n#include <cstdio>\n#include \"types.h\"\n#include \"macros.h\"\n#include \"lf_queue.h\"\n#include \"thread_utils.h\"\n#include \"time_utils.h\"\nnamespace Common {\nconstexpr size_t LOG_QUEUE_SIZE = 8 * 1024 * 1024;\nenum class LogType : int8_t {\n  CHAR = 0,\n  INTEGER = 1, LONG_INTEGER = 2, LONG_LONG_INTEGER = 3,\n  UNSIGNED_INTEGER = 4, UNSIGNED_LONG_INTEGER = 5,\n  UNSIGNED_LONG_LONG_INTEGER = 6,\n  FLOAT = 7, DOUBLE = 8\n};\n}\n```", "```cpp\nstruct LogElement {\n  LogType type_ = LogType::CHAR;\n  union {\n    char c;\n    int i; long l; long long ll;\n    unsigned u; unsigned long ul; unsigned long long ull;\n    float f; double d;\n  } u_;\n};\n```", "```cpp\nclass Logger final {\nprivate:\n  const std::string file_name_;\n  std::ofstream file_;\n  LFQueue<LogElement> queue_;\n  std::atomic<bool> running_ = {true};\n  std::thread *logger_thread_ = nullptr;\n};\n```", "```cpp\n  explicit Logger(const std::string &file_name)\n      : file_name_(file_name), queue_(LOG_QUEUE_SIZE) {\n    file_.open(file_name);\n    ASSERT(file_.is_open(), \"Could not open log file:\" +\n      file_name);\n    logger_thread_ = createAndStartThread(-1,\n      \"Common/Logger\", [this]() { flushQueue(); });\n    ASSERT(logger_thread_ != nullptr, \"Failed to start\n      Logger thread.\");\n  }\n```", "```cpp\n  auto flushQueue() noexcept {\n    while (running_) {\n      for (auto next = queue_.getNextToRead();\n        queue_.size() && next; next = queue_\n          .getNextToRead()) {\n        switch (next->type_) {\n          case LogType::CHAR: file_ << next->u_.c; break;\n          case LogType::INTEGER: file_ << next->u_.i; break;\n          case LogType::LONG_INTEGER: file_ << next->u_.l; break;\n          case LogType::LONG_LONG_INTEGER: file_ << next->\n             u_.ll; break;\n          case LogType::UNSIGNED_INTEGER: file_ << next->\n             u_.u; break;\n          case LogType::UNSIGNED_LONG_INTEGER: file_ <<\n             next->u_.ul; break;\n          case LogType::UNSIGNED_LONG_LONG_INTEGER: file_\n              << next->u_.ull; break;\n          case LogType::FLOAT: file_ << next->u_.f; break;\n          case LogType::DOUBLE: file_ << next->u_.d; break;\n        }\n        queue_.updateReadIndex();\n        next = queue_.getNextToRead();\n      }\n      using namespace std::literals::chrono_literals;\n      std::this_thread::sleep_for(1ms);\n    }\n  }\n```", "```cpp\n  ~Logger() {\n    std::cerr << \"Flushing and closing Logger for \" <<\n      file_name_ << std::endl;\n    while (queue_.size()) {\n      using namespace std::literals::chrono_literals;\n      std::this_thread::sleep_for(1s);\n    }\n    running_ = false;\n    logger_thread_->join();\n    file_.close();\n  }\n```", "```cpp\n  Logger() = delete;\n  Logger(const Logger &) = delete;\n  Logger(const Logger &&) = delete;\n  Logger &operator=(const Logger &) = delete;\n  Logger &operator=(const Logger &&) = delete;\n```", "```cpp\n  auto pushValue(const LogElement &log_element) noexcept {\n    *(queue_.getNextToWriteTo()) = log_element;\n    queue_.updateWriteIndex();\n  }\n```", "```cpp\n  auto pushValue(const char value) noexcept {\n    pushValue(LogElement{LogType::CHAR, {.c = value}});\n  }\n```", "```cpp\n  auto pushValue(const char *value) noexcept {\n    while (*value) {\n      pushValue(*value);\n      ++value;\n    }\n  }\n```", "```cpp\n  auto pushValue(const std::string &value) noexcept {\n    pushValue(value.c_str());\n  }\n```", "```cpp\n  auto pushValue(const int value) noexcept {\n    pushValue(LogElement{LogType::INTEGER, {.i = value}});\n  }\n  auto pushValue(const long value) noexcept {\n    pushValue(LogElement{LogType::LONG_INTEGER, {.l =\n      value}});\n  }\n  auto pushValue(const long long value) noexcept {\n    pushValue(LogElement{LogType::LONG_LONG_INTEGER, {.ll =\n      value}});\n  }\n  auto pushValue(const unsigned value) noexcept {\n    pushValue(LogElement{LogType::UNSIGNED_INTEGER, {.u =\n      value}});\n  }\n  auto pushValue(const unsigned long value) noexcept {\n    pushValue(LogElement{LogType::UNSIGNED_LONG_INTEGER,\n      {.ul = value}});\n  }\n  auto pushValue(const unsigned long long value) noexcept {\n    pushValue(LogElement{LogType::UNSIGNED_LONG_LONG_INTEGER,\n  {.ull = value}});\n  }\n  auto pushValue(const float value) noexcept {\n    pushValue(LogElement{LogType::FLOAT, {.f = value}});\n  }\n  auto pushValue(const double value) noexcept {\n    pushValue(LogElement{LogType::DOUBLE, {.d = value}});\n  }\n```", "```cpp\n  template<typename T, typename... A>\n  auto log(const char *s, const T &value, A... args)\n  noexcept {\n    while (*s) {\n      if (*s == '%') {\n        if (UNLIKELY(*(s + 1) == '%')) {\n          ++s;\n        } else {\n          pushValue(value);\n          log(s + 1, args...);\n          return;\n        }\n      }\n      pushValue(*s++);\n    }\n    FATAL(\"extra arguments provided to log()\");\n  }\n```", "```cpp\nint int_val = 10;\nstd::string str_val = \"hello\";\ndouble dbl_val = 10.10;\nlog(\"Integer:% String:% Double:%\",\n  int_val, str_val, dbl_val);\n```", "```cpp\n  auto log(const char *s) noexcept {\n    while (*s) {\n      if (*s == '%') {\n        if (UNLIKELY(*(s + 1) == '%')) {\n          ++s;\n        } else {\n          FATAL(\"missing arguments to log()\");\n        }\n      }\n      pushValue(*s++);\n    }\n  }\n```", "```cpp\n#include \"logging.h\"\nint main(int, char **) {\n  using namespace Common;\n  char c = 'd';\n  int i = 3;\n  unsigned long ul = 65;\n  float f = 3.4;\n  double d = 34.56;\n  const char* s = \"test C-string\";\n  std::string ss = \"test string\";\n  Logger logger(\"logging_example.log\");\n  logger.log(\"Logging a char:% an int:% and an\n    unsigned:%\\n\", c, i, ul);\n  logger.log(\"Logging a float:% and a double:%\\n\", f, d);\n  logger.log(\"Logging a C-string:'%'\\n\", s);\n  logger.log(\"Logging a string:'%'\\n\", ss);\n  return 0;\n}\n```", "```cpp\n(base) sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter4$ cat logging_example.log\nLogging a char:d an int:3 and an unsigned:65\nLogging a float:3.4 and a double:34.56\nLogging a C-string:'test C-string'\nLogging a string:'test string'\n```", "```cpp\n#pragma once\n#include <iostream>\n#include <string>\n#include <unordered_set>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <arpa/inet.h>\n#include <ifaddrs.h>\n#include <sys/socket.h>\n#include <fcntl.h>\n#include \"macros.h\"\n#include \"logging.h\"\nnamespace Common {\n  constexpr int MaxTCPServerBacklog = 1024;\n  auto getIfaceIP(const std::string &iface) -> std::string;\n  auto setNonBlocking(int fd) -> bool;\n  auto setNoDelay(int fd) -> bool;\n  auto setSOTimestamp(int fd) -> bool;\n  auto wouldBlock() -> bool;\n  auto setMcastTTL(int fd, int ttl) -> bool;\n  auto setTTL(int fd, int ttl) -> bool;\n  auto join(int fd, const std::string &ip, const\n    std::string &iface, int port) -> bool;\n  auto createSocket(Logger &logger, const std::string\n    &t_ip, const std::string &iface, int port, bool is_udp,\n       bool is_blocking, bool is_listening, int ttl, bool\n         needs_so_timestamp) -> int;\n}\n```", "```cpp\n#include \"socket_utils.h\"\nnamespace Common {\n  auto getIfaceIP(const std::string &iface) -> std::string {\n    char buf[NI_MAXHOST] = {'\\0'};\n    ifaddrs *ifaddr = nullptr;\n    if (getifaddrs(&ifaddr) != -1) {\n      for (ifaddrs *ifa = ifaddr; ifa; ifa = ifa->ifa_next) {\n        if (ifa->ifa_addr && ifa->ifa_addr->sa_family ==\n          AF_INET && iface == ifa->ifa_name) {\n          getnameinfo(ifa->ifa_addr, sizeof(sockaddr_in),\n            buf, sizeof(buf), NULL, 0, NI_NUMERICHOST);\n          break;\n        }\n      }\n      freeifaddrs(ifaddr);\n    }\n    return buf;\n  }\n}\n```", "```cpp\nlo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536\n        inet 127.0.0.1  netmask 255.0.0.0\nwlp4s0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n        inet 192.168.10.104  netmask 255.255.255.0  broadcast 192.168.10.255\n```", "```cpp\nauto setNonBlocking(int fd) -> bool {\n  const auto flags = fcntl(fd, F_GETFL, 0);\n  if (flags == -1)\n    return false;\n  if (flags & O_NONBLOCK)\n    return true;\n  return (fcntl(fd, F_SETFL, flags | O_NONBLOCK) != -1);\n}\n```", "```cpp\nauto setNoDelay(int fd) -> bool {\n  int one = 1;\n  return (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY,\n    reinterpret_cast<void *>(&one), sizeof(one)) != -1);\n}\n```", "```cpp\nauto wouldBlock() -> bool {\n  return (errno == EWOULDBLOCK || errno == EINPROGRESS);\n}\n```", "```cpp\nauto setTTL(int fd, int ttl) -> bool {\n  return (setsockopt(fd, IPPROTO_IP, IP_TTL,\n    reinterpret_cast<void *>(&ttl), sizeof(ttl)) != -1);\n}\nauto setMcastTTL(int fd, int mcast_ttl) noexcept -> bool {\n  return (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_TTL,\n    reinterpret_cast<void *>(&mcast_ttl), sizeof\n      (mcast_ttl)) != -1);\n}\n```", "```cpp\n  auto setSOTimestamp(int fd) -> bool {\n    int one = 1;\n    return (setsockopt(fd, SOL_SOCKET, SO_TIMESTAMP,\n      reinterpret_cast<void *>(&one), sizeof(one)) != -1);\n  }\n```", "```cpp\n  auto createSocket(Logger &logger, const std::string\n    &t_ip, const std::string &iface, int port,\n                    bool is_udp, bool is_blocking, bool\n                      is_listening, int ttl, bool\n                        needs_so_timestamp) -> int {\n    std::string time_str;\n    const auto ip = t_ip.empty() ? getIfaceIP(iface) :\n      t_ip;\n    logger.log(\"%:% %() % ip:% iface:% port:% is_udp:%\n      is_blocking:% is_listening:% ttl:% SO_time:%\\n\",\n        __FILE__, __LINE__, __FUNCTION__,\n               Common::getCurrentTimeStr(&time_str), ip,\n                 iface, port, is_udp, is_blocking,\n                   is_listening, ttl, needs_so_timestamp);\n    addrinfo hints{};\n    hints.ai_family = AF_INET;\n    hints.ai_socktype = is_udp ? SOCK_DGRAM : SOCK_STREAM;\n    hints.ai_protocol = is_udp ? IPPROTO_UDP : IPPROTO_TCP;\n    hints.ai_flags = is_listening ? AI_PASSIVE : 0;\n    if (std::isdigit(ip.c_str()[0]))\n      hints.ai_flags |= AI_NUMERICHOST;\n    hints.ai_flags |= AI_NUMERICSERV;\n    addrinfo *result = nullptr;\n    const auto rc = getaddrinfo(ip.c_str(), std::\n      to_string(port).c_str(), &hints, &result);\n    if (rc) {\n      logger.log(\"getaddrinfo() failed. error:% errno:%\\n\",\n        gai_strerror(rc), strerror(errno));\n      return -1;\n    }\n```", "```cpp\n  int fd = -1;\n  int one = 1;\n  for (addrinfo *rp = result; rp; rp = rp->ai_next) {\n    fd = socket(rp->ai_family, rp->ai_socktype, rp\n      ->ai_protocol);\n    if (fd == -1) {\n      logger.log(\"socket() failed. errno:%\\n\",\n         strerror(errno));\n      return -1;\n    }\n```", "```cpp\n    if (!is_blocking) {\n      if (!setNonBlocking(fd)) {\n        logger.log(\"setNonBlocking() failed. errno:%\\n\",\n          strerror(errno));\n        return -1;\n      }\n      if (!is_udp && !setNoDelay(fd)) {\n        logger.log(\"setNoDelay() failed. errno:%\\n\",\n          strerror(errno));\n        return -1;\n      }\n    }\n```", "```cpp\n    if (!is_listening && connect(fd, rp->ai_addr, rp\n      ->ai_addrlen) == 1 && !wouldBlock()) {\n      logger.log(\"connect() failed. errno:%\\n\",\n        strerror(errno));\n      return -1;\n    }\n```", "```cpp\nconstexpr int MaxTCPServerBacklog = 1024;\n```", "```cpp\n    if (is_listening && setsockopt(fd, SOL_SOCKET,\n      SO_REUSEADDR, reinterpret_cast<const char *>(&one),\n        sizeof(one)) == -1) {\n      logger.log(\"setsockopt() SO_REUSEADDR failed.\n        errno:%\\n\", strerror(errno));\n      return -1;\n    }\n    if (is_listening && bind(fd, rp->ai_addr, rp->\n      ai_addrlen) == -1) {\n      logger.log(\"bind() failed. errno:%\\n\",\n        strerror(errno));\n      return -1;\n    }\n    if (!is_udp && is_listening && listen(fd,\n      MaxTCPServerBacklog) == -1) {\n      logger.log(\"listen() failed. errno:%\\n\",\n        strerror(errno));\n      return -1;\n    }\n```", "```cpp\n    if (is_udp && ttl) {\n      const bool is_multicast = atoi(ip.c_str()) & 0xe0;\n      if (is_multicast && !setMcastTTL(fd, ttl)) {\n        logger.log(\"setMcastTTL() failed. errno:%\\n\",\n          strerror(errno));\n        return -1;\n      }\n      if (!is_multicast && !setTTL(fd, ttl)) {\n        logger.log(\"setTTL() failed. errno:%\\n\",\n          strerror(errno));\n        return -1;\n      }\n    }\n      if (needs_so_timestamp && !setSOTimestamp(fd)) {\n        logger.log(\"setSOTimestamp() failed. errno:%\\n\",\n          strerror(errno));\n        return -1;\n      }\n  }\n  if (result)\n    freeaddrinfo(result);\n  return fd;\n}\n```", "```cpp\n#pragma once\n#include <functional>\n#include \"socket_utils.h\"\n#include \"logging.h\"\nnamespace Common {\n  constexpr size_t TCPBufferSize = 64 * 1024 * 1024;\n  struct TCPSocket {\n    int fd_ = -1;\n    char *send_buffer_ = nullptr;\n    size_t next_send_valid_index_ = 0;\n    char *rcv_buffer_ = nullptr;\n    size_t next_rcv_valid_index_ = 0;\n    bool send_disconnected_ = false;\n    bool recv_disconnected_ = false;\n    struct sockaddr_in inInAddr;\n    std::function<void(TCPSocket *s, Nanos rx_time)>\n      recv_callback_;\n    std::string time_str_;\n    Logger &logger_;\n  };\n}\n```", "```cpp\n    auto defaultRecvCallback(TCPSocket *socket, Nanos\n      rx_time) noexcept {\n      logger_.log(\"%:% %() %\n        TCPSocket::defaultRecvCallback() socket:% len:%\n          rx:%\\n\", __FILE__, __LINE__, __FUNCTION__,\n                  Common::getCurrentTimeStr(&time_str_),\n                    socket->fd_, socket->\n                      next_rcv_valid_index_, rx_time);\n    }\n```", "```cpp\nconstexpr size_t TCPBufferSize = 64 * 1024 * 1024;\n    explicit TCPSocket(Logger &logger)\n        : logger_(logger) {\n      send_buffer_ = new char[TCPBufferSize];\n      rcv_buffer_ = new char[TCPBufferSize];\n      recv_callback_ = [this](auto socket, auto rx_time) {\n        defaultRecvCallback(socket, rx_time); };\n    }\n```", "```cpp\n  auto TCPSocket::destroy() noexcept -> void {\n    close(fd_);\n    fd_ = -1;\n  }\n  ~TCPSocket() {\n    destroy();\n    delete[] send_buffer_; send_buffer_ = nullptr;\n    delete[] rcv_buffer_; rcv_buffer_ = nullptr;\n  }\n```", "```cpp\n  // Deleted default, copy & move constructors and\n    assignment-operators.\n  TCPSocket() = delete;\n  TCPSocket(const TCPSocket &) = delete;\n  TCPSocket(const TCPSocket &&) = delete;\n  TCPSocket &operator=(const TCPSocket &) = delete;\n  TCPSocket &operator=(const TCPSocket &&) = delete;\n```", "```cpp\n  auto TCPSocket::connect(const std::string &ip, const\n    std::string &iface, int port, bool is_listening) ->\n      int {\n    destroy();\n    fd_ = createSocket(logger_, ip, iface, port, false,\n      false, is_listening, 0, true);\n    inInAddr.sin_addr.s_addr = INADDR_ANY;\n    inInAddr.sin_port = htons(port);\n    inInAddr.sin_family = AF_INET;\n    return fd_;\n  }\n```", "```cpp\n  auto TCPSocket::send(const void *data, size_t len)\n    noexcept -> void {\n    if (len > 0) {\n      memcpy(send_buffer_ + next_send_valid_index_, data,\n        len);\n      next_send_valid_index_ += len;\n    }\n  }\n```", "```cpp\n  auto TCPSocket::sendAndRecv() noexcept -> bool {\n    char ctrl[CMSG_SPACE(sizeof(struct timeval))];\n    struct cmsghdr *cmsg = (struct cmsghdr *) &ctrl;\n    struct iovec iov;\n    iov.iov_base = rcv_buffer_ + next_rcv_valid_index_;\n    iov.iov_len = TCPBufferSize - next_rcv_valid_index_;\n    msghdr msg;\n    msg.msg_control = ctrl;\n    msg.msg_controllen = sizeof(ctrl);\n    msg.msg_name = &inInAddr;\n    msg.msg_namelen = sizeof(inInAddr);\n    msg.msg_iov = &iov;\n    msg.msg_iovlen = 1;\n    const auto n_rcv = recvmsg(fd_, &msg, MSG_DONTWAIT);\n    if (n_rcv > 0) {\n      next_rcv_valid_index_ += n_rcv;\n      Nanos kernel_time = 0;\n      struct timeval time_kernel;\n      if (cmsg->cmsg_level == SOL_SOCKET &&\n          cmsg->cmsg_type == SCM_TIMESTAMP &&\n          cmsg->cmsg_len == CMSG_LEN(sizeof(time_kernel))) {\n        memcpy(&time_kernel, CMSG_DATA(cmsg),\n          sizeof(time_kernel));\n        kernel_time = time_kernel.tv_sec * NANOS_TO_SECS +\n          time_kernel.tv_usec * NANOS_TO_MICROS;\n      }\n      const auto user_time = getCurrentNanos();\n      logger_.log(\"%:% %() % read socket:% len:% utime:%\n        ktime:% diff:%\\n\", __FILE__, __LINE__,\n          __FUNCTION__,\n                  Common::getCurrentTimeStr(&time_str_),\n                    fd_, next_rcv_valid_index_, user_time,\n                      kernel_time, (user_time -\n                        kernel_time));\n      recv_callback_(this, kernel_time);\n    }\n    ssize_t n_send = std::min(TCPBufferSize,\n      next_send_valid_index_);\n    while (n_send > 0) {\n      auto n_send_this_msg = std::min(static_cast<ssize_t>\n        (next_send_valid_index_), n_send);\n      const int flags = MSG_DONTWAIT | MSG_NOSIGNAL |\n         (n_send_this_msg < n_send ? MSG_MORE : 0);\n      auto n = ::send(fd_, send_buffer_, n_send_this_msg,\n        flags);\n      if (UNLIKELY(n < 0)) {\n        if (!wouldBlock())\n          send_disconnected_ = true;\n        break;\n      }\n      logger_.log(\"%:% %() % send socket:% len:%\\n\",\n        __FILE__, __LINE__, __FUNCTION__,\n          Common::getCurrentTimeStr(&time_str_), fd_, n);\n      n_send -= n;\n      ASSERT(n == n_send_this_msg, \"Don't support partial\n        send lengths yet.\");\n    }\n    next_send_valid_index_ = 0;\n    return (n_rcv > 0);\n  }\n```", "```cpp\n#pragma once\n#include \"tcp_socket.h\"\nnamespace Common {\n  struct TCPServer {\n  public:\n    int efd_ = -1;\n    TCPSocket listener_socket_;\n    epoll_event events_[1024];\n    std::vector<TCPSocket *> sockets_, receive_sockets_,\n      send_sockets_, disconnected_sockets_;\n    std::function<void(TCPSocket *s, Nanos rx_time)>\n      recv_callback_;\n    std::function<void()> recv_finished_callback_;\n    std::string time_str_;\n    Logger &logger_;\n  };\n}\n```", "```cpp\n    explicit TCPServer(Logger &logger)\n        : listener_socket_(logger), logger_(logger) {\n      recv_callback_ = [this](auto socket, auto rx_time) {\n        defaultRecvCallback(socket, rx_time); };\n      recv_finished_callback_ = [this]() {\n        defaultRecvFinishedCallback(); };\n    }\n```", "```cpp\n    auto defaultRecvCallback(TCPSocket *socket, Nanos\n      rx_time) noexcept {\n      logger_.log(\"%:% %() %\n        TCPServer::defaultRecvCallback() socket:% len:%\n          rx:%\\n\", __FILE__, __LINE__, __FUNCTION__,\n            Common::getCurrentTimeStr(&time_str_), socket->\n              fd_, socket->next_rcv_valid_index_, rx_time);\n    }\n    auto defaultRecvFinishedCallback() noexcept {\n      logger_.log(\"%:% %() % TCPServer::\n       defaultRecvFinishedCallback()\\n\", __FILE__,\n       __LINE__, __FUNCTION__,\n        Common::getCurrentTimeStr(&time_str_));\n    }\n```", "```cpp\n  auto TCPServer::destroy() {\n    close(efd_);\n    efd_ = -1;\n    listener_socket_.destroy();\n  }\n```", "```cpp\n    TCPServer() = delete;\n    TCPServer(const TCPServer &) = delete;\n    TCPServer(const TCPServer &&) = delete;\n    TCPServer &operator=(const TCPServer &) = delete;\n    TCPServer &operator=(const TCPServer &&) = delete;\n```", "```cpp\n  auto TCPServer::listen(const std::string &iface, int\n    port) -> void {\n    destroy();\n    efd_ = epoll_create(1);\n    ASSERT(efd_ >= 0, \"epoll_create() failed error:\" +\n      std::string(std::strerror(errno)));\n    ASSERT(listener_socket_.connect(\"\", iface, port, true)\n      >= 0,\n           \"Listener socket failed to connect. iface:\" +\n             iface + \" port:\" + std::to_string(port) + \"\n               error:\" + std::string\n                 (std::strerror(errno)));\n    ASSERT(epoll_add(&listener_socket_), \"epoll_ctl()\n      failed. error:\" + std::string(std::strerror(errno)));\n  }\n```", "```cpp\n  auto TCPServer::epoll_add(TCPSocket *socket) {\n    epoll_event ev{};\n    ev.events = EPOLLET | EPOLLIN;\n    ev.data.ptr = reinterpret_cast<void *>(socket);\n    return (epoll_ctl(efd_, EPOLL_CTL_ADD, socket->fd_,\n      &ev) != -1);\n  }\n```", "```cpp\n  auto TCPServer::epoll_del(TCPSocket *socket) {\n    return (epoll_ctl(efd_, EPOLL_CTL_DEL, socket->fd_,\n      nullptr) != -1);\n  }\n```", "```cpp\n  auto TCPServer::del(TCPSocket *socket) {\n    epoll_del(socket);\n    sockets_.erase(std::remove(sockets_.begin(),\n      sockets_.end(), socket), sockets_.end());\n    receive_sockets_.erase(std::remove\n      (receive_sockets_.begin(), receive_sockets_.end(),\n        socket), receive_sockets_.end());\n    send_sockets_.erase(std::remove(send_sockets_.begin(),\n      send_sockets_.end(), socket), send_sockets_.end());\n  }\n```", "```cpp\n  auto TCPServer::poll() noexcept -> void {\n    const int max_events = 1 + sockets_.size();\n    for (auto socket: disconnected_sockets_) {\n      del(socket);\n    }\n    const int n = epoll_wait(efd_, events_, max_events, 0);\n```", "```cpp\n    bool have_new_connection = false;\n    for (int i = 0; i < n; ++i) {\n      epoll_event &event = events_[i];\n      auto socket = reinterpret_cast<TCPSocket\n        *>(event.data.ptr);\n```", "```cpp\n      if (event.events & EPOLLIN) {\n        if (socket == &listener_socket_) {\n          logger_.log(\"%:% %() % EPOLLIN\n            listener_socket:%\\n\", __FILE__, __LINE__,\n              __FUNCTION__,\n               Common::getCurrentTimeStr(&time_str_),\n                 socket->fd_);\n          have_new_connection = true;\n          continue;\n        }\n        logger_.log(\"%:% %() % EPOLLIN socket:%\\n\",\n          __FILE__, __LINE__, __FUNCTION__,\n            Common::getCurrentTimeStr(&time_str_), socket-\n              >fd_);\n        if(std::find(receive_sockets_.begin(),\n          receive_sockets_.end(), socket) ==\n            receive_sockets_.end())\n          receive_sockets_.push_back(socket);\n      }\n```", "```cpp\n      if (event.events & EPOLLOUT) {\n        logger_.log(\"%:% %() % EPOLLOUT socket:%\\n\",\n          __FILE__, __LINE__, __FUNCTION__,\n            Common::getCurrentTimeStr(&time_str_), socket-\n             >fd_);\n        if(std::find(send_sockets_.begin(),\n          send_sockets_.end(), socket) ==\n            send_sockets_.end())\n          send_sockets_.push_back(socket);\n      }\n```", "```cpp\n      if (event.events & (EPOLLERR | EPOLLHUP)) {\n        logger_.log(\"%:% %() % EPOLLERR socket:%\\n\",\n          __FILE__, __LINE__, __FUNCTION__,\n            Common::getCurrentTimeStr(&time_str_), socket-\n              >fd_);\n        if(std::find(disconnected_sockets_.begin(),\n          disconnected_sockets_.end(), socket) ==\n            disconnected_sockets_.end())\n          disconnected_sockets_.push_back(socket);\n      }\n    }\n```", "```cpp\n    while (have_new_connection) {\n      logger_.log(\"%:% %() % have_new_connection\\n\",\n        __FILE__, __LINE__, __FUNCTION__,\n         Common::getCurrentTimeStr(&time_str_));\n      sockaddr_storage addr;\n      socklen_t addr_len = sizeof(addr);\n      int fd = accept(listener_socket_.fd_,\n        reinterpret_cast<sockaddr *>(&addr), &addr_len);\n      if (fd == -1)\n        break;\n      ASSERT(setNonBlocking(fd) && setNoDelay(fd), \"Failed\n        to set non-blocking or no-delay on socket:\" + std::\n          to_string(fd));\n      logger_.log(\"%:% %() % accepted socket:%\\n\",\n        __FILE__, __LINE__, __FUNCTION__,\n          Common::getCurrentTimeStr(&time_str_), fd);\n```", "```cpp\n      TCPSocket *socket = new TCPSocket(logger_);\n      socket->fd_ = fd;\n      socket->recv_callback_ = recv_callback_;\n      ASSERT(epoll_add(socket), \"Unable to add socket.\n        error:\" + std::string(std::strerror(errno)));\n      if(std::find(sockets_.begin(), sockets_.end(),\n        socket) == sockets_.end())\n        sockets_.push_back(socket);\n      if(std::find(receive_sockets_.begin(),\n        receive_sockets_.end(), socket) ==\n          receive_sockets_.end())\n        receive_sockets_.push_back(socket);\n    }\n  }\n```", "```cpp\n  auto TCPServer::sendAndRecv() noexcept -> void {\n    auto recv = false;\n    for (auto socket: receive_sockets_) {\n      if(socket->sendAndRecv())\n        recv = true;\n    }\n    if(recv)\n      recv_finished_callback_();\n    for (auto socket: send_sockets_) {\n      socket->sendAndRecv();\n    }\n  }\n```", "```cpp\n#include \"time_utils.h\"\n#include \"logging.h\"\n#include \"tcp_server.h\"\nint main(int, char **) {\n  using namespace Common;\n  std::string time_str_;\n  Logger logger_(\"socket_example.log\");\n  auto tcpServerRecvCallback = [&](TCPSocket *socket, Nanos\n    rx_time)\n  noexcept{\n      logger_.log(\"TCPServer::defaultRecvCallback()\n        socket:% len:% rx:%\\n\",\n                  socket->fd_, socket->\n                    next_rcv_valid_index_, rx_time);\n      const std::string reply = \"TCPServer received msg:\" +\n        std::string(socket->rcv_buffer_, socket->\n          next_rcv_valid_index_);\n      socket->next_rcv_valid_index_ = 0;\n      socket->send(reply.data(), reply.length());\n  };\n  auto tcpServerRecvFinishedCallback = [&]()\n  noexcept{\n      logger_.log(\"TCPServer::defaultRecvFinishedCallback()\\n\");\n  };\n  auto tcpClientRecvCallback = [&](TCPSocket *socket, Nanos\n    rx_time)\n  noexcept{\n      const std::string recv_msg = std::string(socket->\n        rcv_buffer_, socket->next_rcv_valid_index_);\n      socket->next_rcv_valid_index_ = 0;\n      logger_.log(\"TCPSocket::defaultRecvCallback()\n        socket:% len:% rx:% msg:%\\n\",\n      socket->fd_, socket->next_rcv_valid_index_, rx_time,\n        recv_msg);\n  };\n```", "```cpp\n  const std::string iface = \"lo\";\n  const std::string ip = \"127.0.0.1\";\n  const int port = 12345;\n  logger_.log(\"Creating TCPServer on iface:% port:%\\n\",\n    iface, port);\n  TCPServer server(logger_);\n  server.recv_callback_ = tcpServerRecvCallback;\n  server.recv_finished_callback_ =\n    tcpServerRecvFinishedCallback;\n  server.listen(iface, port);\n  std::vector < TCPSocket * > clients(5);\n  for (size_t i = 0; i < clients.size(); ++i) {\n    clients[i] = new TCPSocket(logger_);\n    clients[i]->recv_callback_ = tcpClientRecvCallback;\n    logger_.log(\"Connecting TCPClient-[%] on ip:% iface:%\n      port:%\\n\", i, ip, iface, port);\n    clients[i]->connect(ip, iface, port, false);\n    server.poll();\n  }\n```", "```cpp\n  using namespace std::literals::chrono_literals;\n  for (auto itr = 0; itr < 5; ++itr) {\n    for (size_t i = 0; i < clients.size(); ++i) {\n      const std::string client_msg = \"CLIENT-[\" +\n        std::to_string(i) + \"] : Sending \" +\n          std::to_string(itr * 100 + i);\n      logger_.log(\"Sending TCPClient-[%] %\\n\", i,\n        client_msg);\n      clients[i]->send(client_msg.data(),\n        client_msg.length());\n      clients[i]->sendAndRecv();\n      std::this_thread::sleep_for(500ms);\n      server.poll();\n      server.sendAndRecv();\n    }\n  }\n  for (auto itr = 0; itr < 5; ++itr) {\n    for (auto &client: clients)\n      client->sendAndRecv();\n    server.poll();\n    server.sendAndRecv();\n    std::this_thread::sleep_for(500ms);\n  }\n  return 0;\n}\n```", "```cpp\n(base) sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter4$ ./cmake-build-release/socket_example ; cat socket_example.log\nCreating TCPServer on iface:lo port:12345\n/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter4/socket_utils.cpp:68 createSocket() Sat Mar 25 11:32:55 2023 ip:127.0.0.1 iface:lo port:12345 is_udp:0 is_blocking:0 is_listening:1 ttl:0 SO_time:1\nConnecting TCPClient-[0] on ip:127.0.0.1 iface:lo port:12345\n/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter4/tcp_server.cpp:74 poll() Sat Mar 25 11:32:55 2023 EPOLLIN listener_socket:5\n/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter4/tcp_server.cpp:97 poll() Sat Mar 25 11:32:55 2023 have_new_connection\n…\nSending TCPClient-[0] CLIENT-[0] : Sending 0\n/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter4/tcp_socket.cpp:67 sendAndRecv() Sat Mar 25 11:32:55 2023 send socket:6 len:22\n/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter4/tcp_server.cpp:78 poll() Sat Mar 25 11:32:55 2023 EPOLLIN socket:7\n/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter4/tcp_socket.cpp:51 sendAndRecv() Sat Mar 25 11:32:55 2023 read socket:7 len:22 utime:1679761975918407366 ktime:0 diff:1679761975918407366\nTCPServer::defaultRecvCallback() socket:7 len:22 rx:0\n…\nTCPSocket::defaultRecvCallback() socket:12 len:0 rx:1679761987425505000 msg:TCPServer received msg:CLIENT-[3] : Sending 403\n/home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter4/tcp_socket.cpp:51 sendAndRecv() Sat Mar 25 11:33:07 2023 read socket:14 len:47 utime:1679761987925931213 ktime:1679761987925816000 diff:115213\nTCPSocket::defaultRecvCallback() socket:14 len:0 rx:1679761987925816000 msg:TCPServer received msg:CLIENT-[4] : Sending 404\n```"]