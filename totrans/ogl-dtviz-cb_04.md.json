["```cpp\nglfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\nglfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 2);\nglfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\nglfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n```", "```cpp\n    #include <glm/glm.hpp>\n    ```", "```cpp\n    #include <SOIL.h>\n    ```", "```cpp\n    #include <opencv2/core/core.hpp>\n    #include <opencv2/highgui/highgui.hpp>\n    ```", "```cpp\ncmake_minimum_required (VERSION 2.8)\nset(CMAKE_CONFIGURATION_TYPES Debug Release)\nset(PROGRAM_PATH \"C:/Program Files \\(x86\\)\")\nset(OpenCV_DIR ${PROGRAM_PATH}/opencv/build)\nproject (code_simple)\n#modify these path based on your configuration\n#OpenCV\nfind_package(OpenCV REQUIRED )\nINCLUDE_DIRECTORIES(${OpenCV_INCLUDE_DIRS})\nINCLUDE_DIRECTORIES(${PROGRAM_PATH}/glm)\nINCLUDE_DIRECTORIES(${PROGRAM_PATH}/glew-1.10.0/include)\nLINK_DIRECTORIES(${PROGRAM_PATH}/glew-1.10.0/lib/Release)\nINCLUDE_DIRECTORIES(${PROGRAM_PATH}/glfw-3.0.4/include)\nLINK_DIRECTORIES(${PROGRAM_PATH}/glfw-3.0.4/lib)\nINCLUDE_DIRECTORIES(${PROGRAM_PATH}/Simple\\ OpenGL\\ Image\\ Library/src)\nLINK_DIRECTORIES(${PROGRAM_PATH}/Simple\\ OpenGL\\ Image\\ Library/lib)\nadd_subdirectory (../common common)\nadd_executable (main main.cpp)\ntarget_link_libraries (main LINK_PUBLIC shader controls texture glew32s glfw3 opengl32 ${OpenCV_LIBS} SOIL)\n```", "```cpp\nsudo apt-get install libglm-dev libglew1.6-dev libsoil-dev libopencv\n\n```", "```cpp\nsudo port install opencv glm glew\n\n```", "```cpp\n    tar xzvf glew-1.10.0.tgz\n\n    ```", "```cpp\n    cd glew-1.10.0\n    make && sudo make install \n\n    ```", "```cpp\n    unzip glm-0.9.5.4.zip\n\n    ```", "```cpp\n    sudo cp -r glm/glm/ /usr/include/glm\n\n    ```", "```cpp\n    unzip soil.zip\n\n    ```", "```cpp\n    CXXFLAGS =-arch x86_64 –arch i386 -O2 -s -Wall\n\n    ```", "```cpp\n    cd Simple\\ OpenGL\\ Image\\ Library/projects/makefile\n    mkdir obj\n    make && sudo make install\n\n    ```", "```cpp\n    unzip opencv-2.4.9.zip\n\n    ```", "```cpp\n    cd opencv-2.4.9/\n    mkdir build\n    cd build\n    cmake ../\n    make && sudo make install\n\n    ```", "```cpp\n    sudo sh -c 'echo \"/usr/local/lib\" > /etc/ld.so.conf.d/opencv.conf'\n    sudo ldconfig –v \n\n    ```", "```cpp\n    CFILES = ../common/shader.cpp ../common/texture.cpp ../common/controls.cpp main.cpp \n    CFLAGS = -O3 -c -Wall\n    INCLUDES = -I/usr/include -I/usr/include/SOIL -I../common  `pkg-config --cflags glfw3` `pkg-config --cflags opencv`\n    LIBS = -lm -L/usr/local/lib -lGLEW -lSOIL  `pkg-config --static --libs glfw3` `pkg-config --libs opencv`\n    CC = g++\n    OBJECTS=$(CFILES:.cpp=.o)\n    EXECUTABLE=main\n    all: $(CFILES) $(EXECUTABLE) \n    $(EXECUTABLE): $(OBJECTS) \n     $(CC) $(INCLUDES) $(OBJECTS) -o $@ $(LIBS)\n    .cpp.o:\n     $(CC) $(CFLAGS) $(INCLUDES) $< -o $@\n\n    clean:\n     rm -v -f *~ ../common/*.o *.o *.obj $(EXECUTABLE)\n\n    ```", "```cpp\n#version 150 \nin vec3 position;\nin vec3 color_in;\nout vec3 color;\nvoid main() {\n  color = color_in;\n  gl_Position = vec4(position, 1.0);\n}\n```", "```cpp\n#version 150 \nin vec3 color;\nout vec4 color_out;\nvoid main() {\n  color_out = vec4(Color, 1.0);\n}\n```", "```cpp\n#ifndef SHADER_HPP\n#define SHADER_HPP\nGLuint LoadShaders(const char * vertex_file_path,const char * fragment_file_path);\n#endif\n```", "```cpp\n    #include <iostream>\n    #include <fstream>\n    #include <algorithm>\n    #include <vector>\n    #include \"shader.hpp\"\n    ```", "```cpp\n    std::string readSourceFile(const char *path){\n      std::string code;\n      std::ifstream file_stream(path, std::ios::in);\n      if(file_stream.is_open()){\n        std::string line = \"\";\n        while(getline(file_stream, line))\n        code += \"\\n\" + line;\n        file_stream.close();\n        return code;\n      }else{\n        printf(\"Failed to open \\\"%s\\\".\\n\", path);\n        return \"\";\n      }\n    }\n    ```", "```cpp\n    void CompileShader(std::string program_code, GLuint shader_id){\n      GLint result = GL_FALSE;\n      int infolog_length;\n      char const * program_code_pointer = program_code.c_str();\n      glShaderSource(shader_id, 1, &program_code_pointer , NULL);\n      glCompileShader(shader_id);\n      //check the shader for successful compile\n      glGetShaderiv(shader_id, GL_COMPILE_STATUS, &result);\n      glGetShaderiv(shader_id, GL_INFO_LOG_LENGTH, &infolog_length);\n      if ( infolog_length > 0 ){\n        std::vector<char> error_msg(infolog_length+1);\n        glGetShaderInfoLog(shader_id, infolog_length, NULL, &error_msg[0]);\n        printf(\"%s\\n\", &error_msg[0]);\n      }\n    }\n    ```", "```cpp\n    GLuint LoadShaders(const char * vertex_file_path,const char * fragment_file_path){\n      GLuint vertex_shader_id = glCreateShader(GL_VERTEX_SHADER);\n      GLuint fragment_shader_id = glCreateShader(GL_FRAGMENT_SHADER);\n      std::string vertex_shader_code = readSourceFile(vertex_file_path);\n      if(vertex_shader_code == \"\"){\n        return 0; \n      }\n      std::string fragment_shader_code = readSourceFile(fragment_file_path);\n      if(fragment_shader_code == \"\"){\n        return 0; \n      }\n    ```", "```cpp\n      printf(\"Compiling Vertex shader : %s\\n\", vertex_file_path);\n      CompileShader(vertex_shader_code, vertex_shader_id);\n      printf(\"Compiling Fragment shader : %s\\n\",fragment_file_path);\n      CompileShader(fragment_shader_code, fragment_shader_id);\n    ```", "```cpp\n      GLint result = GL_FALSE;\n      int infolog_length;\n      printf(\"Linking program\\n\");\n      GLuint program_id = glCreateProgram();\n      glAttachShader(program_id, vertex_shader_id);\n      glAttachShader(program_id, fragment_shader_id);\n      glLinkProgram(program_id);\n      //check the program and ensure that the program is linked properly\n      glGetProgramiv(program_id, GL_LINK_STATUS, &result);\n      glGetProgramiv(program_id, GL_INFO_LOG_LENGTH, &infolog_length);\n      if ( infolog_length > 0 ){\n        std::vector<char> program_error_msg(infolog_length+1);\n        glGetProgramInfoLog(program_id, infolog_length, NULL, &program_error_msg[0]);\n        printf(\"%s\\n\", &program_error_msg[0]);\n      }else{\n        printf(\"Linked Successfully\\n\");\n      }\n\n      //flag for delete, and will free all memories\n      //when the attached program is deleted\n      glDeleteShader(vertex_shader_id);\n      glDeleteShader(fragment_shader_id);\n      return program_id;\n    }\n    ```", "```cpp\n    #include <stdio.h>\n    #include <stdlib.h>\n    //GLFW and GLEW libraries\n    #include <GL/glew.h>\n    #include <GLFW/glfw3.h>\n    #include \"common/shader.hpp\"\n    ```", "```cpp\n    //Global variables\n    GLFWwindow* window;\n    ```", "```cpp\n    int main(int argc, char **argv)\n    {\n      //Initialize GLFW\n      if(!glfwInit()){\n        fprintf( stderr, \"Failed to initialize GLFW\\n\" );\n        exit(EXIT_FAILURE);\n      }\n    ```", "```cpp\n      //enable anti-aliasing 4x with GLFW\n      glfwWindowHint(GLFW_SAMPLES, 4);\n      /* specify the client API version that the created context must be compatible with. */\n      glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n      glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 2);\n      //make the GLFW forward compatible\n      glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n      //use the OpenGL Core \n      glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n    ```", "```cpp\n      window = glfwCreateWindow(640, 480, \"Chapter 4 - GLSL\", NULL, NULL);\n      if(!window){\n        fprintf( stderr, \"Failed to open GLFW window. If you have an Intel GPU, they are not 3.3 compatible. Try the 2.1 version of the tutorials.\\n\" );\n        glfwTerminate();\n        exit(EXIT_FAILURE);\n      }\n      glfwMakeContextCurrent(window);\n      glfwSwapInterval(1);\n    ```", "```cpp\n      glewExperimental = true; \n      if (glewInit() != GLEW_OK) {\n        fprintf(stderr, \"Final to Initialize GLEW\\n\");\n        glfwTerminate();\n        exit(EXIT_FAILURE);\n      }\n    ```", "```cpp\n      GLuint program = LoadShaders(\"simple.vert\", \"simple.frag\");\n      glBindFragDataLocation(program, 0, \"color_out\");\n      glUseProgram(program);\n    ```", "```cpp\n      GLuint vertex_buffer;\n      GLuint color_buffer;\n      glGenBuffers(1, &vertex_buffer);\n      glGenBuffers(1, &color_buffer);\n      const GLfloat vertices[] = {\n        -1.0f, -1.0f, 0.0f,\n        1.0f, -1.0f, 0.0f,\n        1.0f, 1.0f, 0.0f,\n        -1.0f, -1.0f, 0.0f,\n        1.0f, 1.0f, 0.0f,\n        -1.0f, 1.0f, 0.0f\n      };\n      const GLfloat colors[]={\n        0.0f, 0.0f, 1.0f,\n        0.0f, 1.0f, 0.0f,\n        1.0f, 0.0f, 0.0f,\n        0.0f, 0.0f, 1.0f,\n        1.0f, 0.0f, 0.0f,\n        0.0f, 1.0f, 0.0f\n      };\n\n      glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);\n      glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n      glBindBuffer(GL_ARRAY_BUFFER, color_buffer);\n      glBufferData(GL_ARRAY_BUFFER, sizeof(colors), colors, GL_STATIC_DRAW);\n    ```", "```cpp\n      GLint position_attrib = glGetAttribLocation(program, \"position\");\n      glEnableVertexAttribArray(position_attrib);\n      glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);\n      glVertexAttribPointer(position_attrib, 3, GL_FLOAT, GL_FALSE, 0, (void*)0);\n\n      GLint color_attrib = glGetAttribLocation(program, \"color_in\");\n      glEnableVertexAttribArray(color_attrib);\n      glBindBuffer(GL_ARRAY_BUFFER, color_buffer);\n      glVertexAttribPointer(color_attrib, 3, GL_FLOAT, GL_FALSE, 0, (void*)0);\n    ```", "```cpp\n      while(!glfwWindowShouldClose(window)){\n        // Clear the screen to black\n        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n        glClear(GL_COLOR_BUFFER_BIT);\n        // Draw a rectangle from the 2 triangles using 6 vertices\n        glDrawArrays(GL_TRIANGLES, 0, 6);\n        glfwSwapBuffers(window);\n        glfwPollEvents();\n      }\n    ```", "```cpp\n      //clean up the memories\n      glDisableVertexAttribArray(position_attrib);\n      glDisableVertexAttribArray(color_attrib);\n      glDeleteBuffers(1, &vertex_buffer);\n      glDeleteBuffers(1, &color_buffer);\n      glDeleteVertexArrays(1, &vertex_array);\n      glDeleteProgram(program);\n      // Close OpenGL window and terminate GLFW\n      glfwDestroyWindow(window);\n      glfwTerminate();\n      exit(EXIT_SUCCESS);\n    }\n    ```", "```cpp\n#ifndef _COMMON_h\n#define _COMMON_h\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <string>\n#include <GL/glew.h>\n#include <GLFW/glfw3.h>\nusing namespace std; \n#endif\n```", "```cpp\n#version 150 \nin vec2 UV;\nout vec4 color;\nuniform sampler2D textureSampler;\nvoid main(){\n  color = texture(textureSampler, UV).rgba;\n}\n```", "```cpp\n#version 150\nin vec3 vertexPosition_modelspace;\nin vec2 vertexUV;\nout vec2 UV;\nuniform mat4 MVP;\nvoid main(){\n  //position of the vertex in clip space\n  gl_Position = MVP * vec4(vertexPosition_modelspace,1);\n  UV = vertexUV;\n}\n```", "```cpp\n    #include \"texture.hpp\"\n    #include <SOIL.h>\n    ```", "```cpp\n    GLuint initializeTexture(const unsigned char *image_data, int width, int height, GLenum format){\n      GLuint textureID=0;\n      //create and bind one texture element\n      glGenTextures(1, &textureID);\n      glBindTexture(GL_TEXTURE_2D, textureID);\n      glPixelStorei(GL_UNPACK_ALIGNMENT,1);\n      /* Specify target texture. The parameters describe the format and type of the image data */\n      glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, format, GL_UNSIGNED_BYTE, image_data);\n      /* Set the wrap parameter for texture coordinate s & t to GL_CLAMP, which clamps the coordinates within [0, 1] */\n      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n      /* Set the magnification method to linear and return weighted average of four texture elements closest to the center of the pixel */\n      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n      /* Choose the mipmap that most closely matches the size of the pixel being textured and use the GL_NEAREST criterion (the texture element nearest to the center of the pixel) to produce a texture value. */\n      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);\n      glGenerateMipmap(GL_TEXTURE_2D);\n      return textureID;\n    }\n    ```", "```cpp\n    void updateTexture(const unsigned char *image_data, int width, int height, GLenum format){\n      // Update Texture\n      glTexSubImage2D (GL_TEXTURE_2D, 0, 0, 0, width, height, format, GL_UNSIGNED_BYTE, image_data);\n      /* Sets the wrap parameter for texture coordinate s & t to GL_CLAMP, which clamps the coordinates within [0, 1]. */\n      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n      /* Set the magnification method to linear and return weighted average of four texture elements closest to the center of the pixel */\n      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n      /* Choose the mipmap that most closely matches the size of the pixel being textured and use the GL_NEAREST criterion (the texture element nearest to the center of the pixel) to produce a texture value. */\n      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);\n      glGenerateMipmap(GL_TEXTURE_2D);\n    }\n    ```", "```cpp\n    GLuint loadImageToTexture(const char * imagepath){\n      int width, height, channels;\n      GLuint textureID=0;\n      //Load the images and convert them to RGBA format\n      unsigned char* image = SOIL_load_image(imagepath, &width, &height, &channels, SOIL_LOAD_RGBA);\n      if(!image){\n        printf(\"Failed to load image %s\\n\", imagepath);\n        return textureID;\n      }\n      printf(\"Loaded Image: %d x %d - %d channels\\n\", width, height, channels);\n      textureID=initializeTexture(image, width, height, GL_RGBA);\n      SOIL_free_image_data(image);\n      return textureID;\n    }\n    ```", "```cpp\n    #define GLM_FORCE_RADIANS\n    #include <glm/glm.hpp>\n    #include <glm/gtc/matrix_transform.hpp>\n    #include \"controls.hpp\"\n    ```", "```cpp\n    //initial position of the camera\n    glm::vec3 g_position = glm::vec3( 0, 0, 2 );\n    const float speed = 3.0f; // 3 units / second\n    float g_initial_fov = glm::pi<float>()*0.4f;\n    //the view matrix and projection matrix\n    glm::mat4 g_view_matrix;\n    glm::mat4 g_projection_matrix;\n    ```", "```cpp\n    glm::mat4 getViewMatrix(){\n      return g_view_matrix;\n    }\n    glm::mat4 getProjectionMatrix(){\n      return g_projection_matrix;\n    }\n    ```", "```cpp\n    void computeViewProjectionMatrices(GLFWwindow* window){\n      static double last_time = glfwGetTime();\n      // Compute time difference between current and last frame\n      double current_time = glfwGetTime();\n      float delta_time = float(current_time - last_time);\n      int width, height;\n      glfwGetWindowSize(window, &width, &height);\n      //direction vector for movement\n      glm::vec3 direction(0, 0, -1);\n      //up vector\n      glm::vec3 up = glm::vec3(0,-1,0);\n      if (glfwGetKey(window, GLFW_KEY_UP) == GLFW_PRESS){\n        g_position += direction * delta_time * speed;\n      }\n      else if (glfwGetKey(window, GLFW_KEY_DOWN) == GLFW_PRESS){\n        g_position -= direction * delta_time * speed;\n      }\n      else if (glfwGetKey(window, GLFW_KEY_RIGHT) == GLFW_PRESS){\n        g_initial_fov -= 0.1 * delta_time * speed;\n      }\n      else if (glfwGetKey(window, GLFW_KEY_LEFT) == GLFW_PRESS){\n        g_initial_fov += 0.1 * delta_time * speed;\n      }\n      /* update projection matrix: Field of View, aspect ratio, display range : 0.1 unit <-> 100 units */\n      g_projection_matrix = glm::perspective(g_initial_fov, (float)width/(float)height, 0.1f, 100.0f);\n\n      // update the view matrix\n      g_view_matrix = glm::lookAt(\n        g_position,      // camera position\n        g_position+direction, // viewing direction\n        up         // up direction\n      );\n      last_time = current_time;\n    }\n    ```", "```cpp\n    #define GLM_FORCE_RADIANS\n    #include <stdio.h>\n    #include <stdlib.h>\n    #include <GL/glew.h>\n    #include <GLFW/glfw3.h>\n    #include <glm/glm.hpp>\n    #include <glm/gtc/matrix_transform.hpp>\n    using namespace glm;\n    #include <common/shader.hpp>\n    #include <common/texture.hpp>\n    #include <common/controls.hpp>\n    #include <common/common.h>\n    ```", "```cpp\n    GLFWwindow* g_window;\n    const int WINDOWS_WIDTH = 1280;\n    const int WINDOWS_HEIGHT = 720;\n    float aspect_ratio = 3.0f/2.0f;\n    float z_offset = 2.0f;\n    float rotateY = 0.0f;\n    float rotateX = 0.0f;\n    //Our vertices\n    static const GLfloat g_vertex_buffer_data[] = {\n      -aspect_ratio,-1.0f,z_offset,\n      aspect_ratio,-1.0f,z_offset,\n      aspect_ratio,1.0f,z_offset,\n      -aspect_ratio,-1.0f,z_offset,\n      aspect_ratio,1.0f,z_offset,\n      -aspect_ratio,1.0f,z_offset\n    };\n    //UV map for the vertices\n    static const GLfloat g_uv_buffer_data[] = {\n      1.0f, 0.0f,\n      0.0f, 0.0f,\n      0.0f, 1.0f,\n      1.0f, 0.0f,\n      0.0f, 1.0f,\n      1.0f, 1.0f\n    };\n    ```", "```cpp\n    static void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods)\n    {\n      if (action != GLFW_PRESS && action != GLFW_REPEAT)\n      return;\n      switch (key)\n      {\n        case GLFW_KEY_ESCAPE:\n          glfwSetWindowShouldClose(window, GL_TRUE);\n          break;\n        case GLFW_KEY_SPACE:\n          rotateX=0;\n          rotateY=0;\n          break;\n        case GLFW_KEY_Z:\n          rotateX+=0.01;\n          break;\n        case GLFW_KEY_X:\n          rotateX-=0.01;\n          break;\n        case GLFW_KEY_A:\n          rotateY+=0.01;\n          break;\n        case GLFW_KEY_S:\n          rotateY-=0.01;\n          break;\n        default:\n          break;\n      }\n    }\n    ```", "```cpp\n    int main(int argc, char **argv)\n    {\n      //Initialize the GLFW\n      if(!glfwInit()){\n        fprintf( stderr, \"Failed to initialize GLFW\\n\" );\n        exit(EXIT_FAILURE);\n      }\n\n      //enable anti-alising 4x with GLFW\n      glfwWindowHint(GLFW_SAMPLES, 4);\n      //specify the client API version \n      glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n      glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 2);\n      //make the GLFW forward compatible\n      glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n      //enable the OpenGL core profile for GLFW \n      glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n    ```", "```cpp\n      //create a GLFW windows object\n      window = glfwCreateWindow(WINDOWS_WIDTH, WINDOWS_HEIGHT, \"Chapter 4 - Texture Mapping\", NULL, NULL);\n      if(!window){\n        fprintf( stderr, \"Failed to open GLFW window. If you have an Intel GPU, they are not 3.3 compatible. Try the 2.1 version of the tutorials.\\n\" );\n        glfwTerminate();\n        exit(EXIT_FAILURE);\n      }\n      /* make the context of the specified window current for the calling thread */\n      glfwMakeContextCurrent(window);\n      glfwSwapInterval(1);\n      glewExperimental = true; // Needed for core profile\n      if (glewInit() != GLEW_OK) {\n        fprintf(stderr, \"Final to Initialize GLEW\\n\");\n        glfwTerminate();\n        exit(EXIT_FAILURE);\n      }\n      //keyboard input callback\n      glfwSetInputMode(window,GLFW_STICKY_KEYS,GL_TRUE);\n      glfwSetKeyCallback(window, key_callback);\n    ```", "```cpp\n      glClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n      glEnable(GL_BLEND);\n      glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);\n    ```", "```cpp\n      GLuint program_id = LoadShaders( \"transform.vert\", \"texture.frag\" );\n    ```", "```cpp\n      char *filepath;\n      //load the texture from image with SOIL\n      if(argc<2){\n        filepath = (char*)malloc(sizeof(char)*512);\n        sprintf(filepath, \"texture.png\");\n      }\n      else{\n        filepath = argv[1];\n      }\n\n      int width;\n      int height;\n      GLuint texture_id = loadImageToTexture(filepath, &width, &height);\n\n      aspect_ratio = (float)width/(float)height;\n      if(!texture_id){\n        //if we get 0 with no texture\n        glfwTerminate();\n        exit(EXIT_FAILURE); \n      }\n    ```", "```cpp\n      //get the location for our \"MVP\" uniform variable\n      GLuint matrix_id = glGetUniformLocation(program_id, \"MVP\");\n      //get a handler for our \"myTextureSampler\" uniform\n      GLuint texture_sampler_id = glGetUniformLocation(program_id, \"textureSampler\");\n      //attribute ID for the variables\n      GLint attribute_vertex, attribute_uv;\n      attribute_vertex = glGetAttribLocation(program_id, \"vertexPosition_modelspace\");\n      attribute_uv = glGetAttribLocation(program_id, \"vertexUV\");\n    ```", "```cpp\n      GLuint vertex_array_id;\n      glGenVertexArrays(1, &vertex_array_id);\n      glBindVertexArray(vertex_array_id);\n    ```", "```cpp\n      //initialize the vertex buffer memory.\n      GLuint vertex_buffer;\n      glGenBuffers(1, &vertex_buffer);\n      glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);\n      glBufferData(GL_ARRAY_BUFFER, sizeof(g_vertex_buffer_data), g_vertex_buffer_data, GL_STATIC_DRAW);\n      //initialize the UV buffer memory\n      GLuint uv_buffer;\n      glGenBuffers(1, &uv_buffer);\n      glBindBuffer(GL_ARRAY_BUFFER, uv_buffer);\n      glBufferData(GL_ARRAY_BUFFER, sizeof(g_uv_buffer_data), g_uv_buffer_data, GL_STATIC_DRAW);\n    ```", "```cpp\n      glUseProgram(program_id);\n      //binds our texture in Texture Unit 0\n      glActiveTexture(GL_TEXTURE0);\n      glBindTexture(GL_TEXTURE_2D, texture_id);\n      glUniform1i(texture_sampler_id, 0);\n      //1st attribute buffer: vertices for position\n      glEnableVertexAttribArray(attribute_vertex);\n      glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);\n      glVertexAttribPointer(attribute_vertex, 3, GL_FLOAT, GL_FALSE, 0, (void*)0);\n      //2nd attribute buffer: UVs mapping\n      glEnableVertexAttribArray(attribute_uv);\n      glBindBuffer(GL_ARRAY_BUFFER, uv_buffer);\n      glVertexAttribPointer(attribute_uv, 2, GL_FLOAT, GL_FALSE, 0, (void*)0);\n    ```", "```cpp\n      //time-stamping for performance measurement\n      double previous_time = glfwGetTime(); \n      do{\n        //clear the screen\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n        glClearColor(1.0f, 1.0f, 1.0f, 0.0f);\n    ```", "```cpp\n        //compute the MVP matrix from keyboard and mouse input\n        computeMatricesFromInputs(g_window);\n        //obtain the View and Model Matrix for rendering\n        glm::mat4 projection_matrix = getProjectionMatrix();\n        glm::mat4 view_matrix = getViewMatrix();\n        glm::mat4 model_matrix = glm::mat4(1.0);\n        model_matrix = glm::rotate(model_matrix, glm::pi<float>() * rotateY, glm::vec3(0.0f, 1.0f, 0.0f));\n        model_matrix = glm::rotate(model_matrix, glm::pi<float>() * rotateX, glm::vec3(1.0f, 0.0f, 0.0f));\n        glm::mat4 mvp = projection_matrix * view_matrix * model_matrix;\n        //send our transformation to the currently bound shader \n        //in the \"MVP\" uniform variable\n        glUniformMatrix4fv(matrix_id, 1, GL_FALSE, &mvp[0][0]);\n    ```", "```cpp\n        glDrawArrays(GL_TRIANGLES, 0, 6); //draw a square\n        //swap buffers\n        glfwSwapBuffers(window);\n        glfwPollEvents();\n    ```", "```cpp\n      } // Check if the ESC key was pressed or the window was closed\n      while(!glfwWindowShouldClose(window) && glfwGetKey(window, GLFW_KEY_ESCAPE )!=GLFW_PRESS);\n      glDisableVertexAttribArray(attribute_vertex);\n      glDisableVertexAttribArray(attribute_uv);\n      // Clean up VBO and shader\n      glDeleteBuffers(1, &vertex_buffer);\n      glDeleteBuffers(1, &uv_buffer);\n      glDeleteProgram(program_id);\n      glDeleteTextures(1, &texture_id);\n      glDeleteVertexArrays(1, &vertex_array_id);\n      // Close OpenGL window and terminate GLFW\n      glfwDestroyWindow(g_window);\n      glfwTerminate();\n      exit(EXIT_SUCCESS);\n    }\n    ```", "```cpp\n#include <opencv2/opencv.hpp>\nusing namespace cv;\n```", "```cpp\n    char *filepath;\n    if(argc<2){\n      filepath = (char*)malloc(sizeof(char)*512);\n      sprintf(filepath, \"video.mov\");\n    }\n    else{\n      filepath = argv[1];\n    }\n    //Handling Video input with OpenCV\n    VideoCapture cap(filepath); // open the default camera\n    Mat frame;\n    if (!cap.isOpened()){ // check if we succeeded\n      printf(\"Cannot open files\\n\");\n      glfwTerminate();\n      exit(EXIT_FAILURE);\n      }else{\n        cap >> frame; // get a new frame from camera\n        printf(\"Got Video, %d x %d\\n\",frame.size().width, frame.size().height);\n      }\n      cap >> frame; // get a new frame from camera\n      GLuint texture_id = initializeTexture(frame.data, frame.size().width, frame.size().height, GL_BGR);\n      aspect_ratio = (float)frame.size().width/ (float)frame.size().height;\n    ```", "```cpp\n      /* get the video feed, reset to beginning if it reaches the end of the video */\n      if(!cap.grab()){\n        printf(\"End of Video, Resetting\\n\");\n        cap.release();\n        cap.open(filepath); // open the default camera\n      }\n      cap >> frame; // get a new frame from camera\n      //update the texture with the new frame\n      updateTexture(frame.data, frame.size().width, frame.size().height, GL_BGR);\n    ```", "```cpp\n      void main(){\n        //compute the results of Sobel filter\n        float graylevel = sobel_filter();\n        color = heatMap(graylevel, 0.1, 3.0);\n      }\n    ```", "```cpp\n      float sobel_filter()\n      {\n        float dx = 1.0 / float(1280);\n        float dy = 1.0 / float(720);\n\n        float s00 = pixel_operator(-dx, dy);\n        float s10 = pixel_operator(-dx, 0);\n        float s20 = pixel_operator(-dx,-dy);\n        float s01 = pixel_operator(0.0,dy);\n        float s21 = pixel_operator(0.0, -dy);\n        float s02 = pixel_operator(dx, dy);\n        float s12 = pixel_operator(dx, 0.0);\n        float s22 = pixel_operator(dx, -dy);\n        float sx = s00 + 2 * s10 + s20 - (s02 + 2 * s12 + s22);\n        float sy = s00 + 2 * s01 + s02 - (s20 + 2 * s21 + s22);\n        float dist = sx * sx + sy * sy;\n        return dist;\n      }\n    ```", "```cpp\n      float rgb2gray(vec3 color ) {\n        return 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n      }\n    ```", "```cpp\n      float pixel_operator(float dx, float dy){\n        return rgb2gray(texture( textureSampler, UV + vec2(dx,dy)).rgb);\n      }\n    ```", "```cpp\n      vec4 heatMap(float v, float vmin, float vmax){\n        float dv;\n        float r, g, b;\n        if (v < vmin)\n          v = vmin;\n        if (v > vmax)\n          v = vmax;\n        dv = vmax - vmin;\n        if(v == 0){\n          return vec4(0.0, 0.0, 0.0, 1.0);\n      }\n      if (v < (vmin + 0.25f * dv)) {\n        r = 0.0f;\n        g = 4.0f * (v - vmin) / dv;\n      } else if (v < (vmin + 0.5f * dv)) {\n        r = 0.0f;\n        b = 1.0f + 4.0f * (vmin + 0.25f * dv - v) / dv;\n      } else if (v < (vmin + 0.75f * dv)) {\n        r = 4.0f * (v - vmin - 0.5f * dv) / dv;\n        b = 0.0f;\n      } else {\n        g = 1.0f + 4.0f * (vmin + 0.75f * dv - v) / dv;\n        b = 0.0f;\n      }\n      return vec4(r, g, b, 1.0);\n    }\n    ```", "```cpp\nvoid main(){\n  //compute the results of Sobel filter\n  float graylevel = sobel_filter();\n  color = vec4(graylevel, graylevel, graylevel, 1.0);\n}\n```", "```cpp\nvoid main(){\n  //compute the results of Sobel filter\n  float graylevel = sobel_filter();\n  //process the right side of the image\n    if(UV.x > 0.5)\n      color = heatMap(graylevel, 0.0, 3.0) + texture(textureSampler, UV);\n      else\n      color = vec4(graylevel, graylevel, graylevel, 1.0) + texture (textureSampler, UV);\n}\n```"]