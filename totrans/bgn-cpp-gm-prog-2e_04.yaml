- en: '*Chapter 3*: C++ Strings and SFML Time – Player Input and HUD'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第三章*：C++ 字符串和 SFML 时间 – 玩家输入和 HUD'
- en: In this chapter, we will continue with the Timber!! game. We will spend around
    half of this chapter learning how to manipulate text and display it on the screen,
    and the other half looking at timing and how a visual time-bar can inform the
    player about the remaining time and create a sense of urgency in the game.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续开发Timber!!游戏。我们将用大约一半的时间学习如何操作文本并在屏幕上显示它，另一半时间将探讨计时以及如何通过视觉时间条让玩家了解剩余时间，并在游戏中创造紧迫感。
- en: 'We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Pausing and restarting the game
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停和重新启动游戏
- en: C++ Strings
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ 字符串
- en: SFML text and SFML font classes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SFML 文本和 SFML 字体类
- en: Adding a HUD to Timber!!!
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Timber!!!添加一个HUD
- en: Adding a time-bar to Timber!!!
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Timber!!!添加时间条
- en: Pausing and restarting the game
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暂停和重新启动游戏
- en: As we work on this game over the next three chapters, the code will obviously
    get longer and longer. So, now seems like a good time to think ahead and add a
    little bit more structure to our code. We will add this structure so that we can
    pause and restart the game.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的三章中，我们将会对这款游戏进行开发，代码显然会越来越长。因此，现在似乎是提前思考并给我们的代码添加更多结构的好时机。我们将添加这种结构，以便我们可以暂停和重新启动游戏。
- en: We will add code so that, when the game is run for the first time, it will be
    in a paused state. The player will then be able to press the *Enter* key to start
    the game. Then, the game will run until either the player gets squished or runs
    out of time. At this point, the game will pause and wait for the player to press
    *Enter* so that they can restart the game.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加代码，使得当游戏第一次运行时，它将处于暂停状态。玩家随后可以按下*Enter*键来开始游戏。然后，游戏将继续运行，直到玩家被压扁或用完时间。此时，游戏将暂停并等待玩家按下*Enter*键，以便他们可以重新启动游戏。
- en: Let's step through setting this up a bit at a time.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地设置这个变量。
- en: 'First, declare a new `bool` variable called `paused` outside the main game
    loop and initialize it to `true`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在主游戏循环外部声明一个新的`bool`变量，命名为`paused`，并将其初始化为`true`：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, whenever the game is run, we have a `paused` variable that will be `true`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次游戏运行时，我们都有一个`paused`变量，它的初始值是`true`。
- en: 'Next, we will add another `if` statement where the expression will check whether
    the *Enter* key is currently being pressed. If it is being pressed, it sets `paused`
    to `false`. Add the following highlighted code just after our other keyboard-handling
    code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加另一个`if`语句，其中表达式将检查*Enter*键是否当前被按下。如果是被按下，它将`paused`设置为`false`。在其他的键盘处理代码之后添加以下突出显示的代码：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, we have a `bool` called `paused` that starts off `true` but changes to
    `false` when the player presses the *Enter* key. At this point, we must make our
    game loop respond appropriately, based on whatever the current value of `paused`
    might be.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个名为`paused`的`bool`变量，它一开始是`true`，但当玩家按下*Enter*键时，它将变为`false`。在这个时候，我们必须让我们的游戏循环根据`paused`的当前值做出适当的响应。
- en: This is how we will proceed. We will wrap the entire update part of the code,
    including the code we wrote in the last chapter for moving the bee and clouds,
    in an `if` statement.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这样进行。我们将整个更新部分的代码，包括我们在上一章中编写的移动蜜蜂和云的代码，包裹在一个`if`语句中。
- en: In the following code, note that the `if` block will only execute when `paused`
    is not equal to `true`. Put another way, the game won't move/update when it is
    paused.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，请注意，只有当`paused`不等于`true`时，`if`块才会执行。换句话说，当游戏处于暂停状态时，游戏不会移动/更新。
- en: This is exactly what we want. Look carefully at the place where we added the
    new `if` statement and its corresponding opening and closing curly braces `{...}`.
    If they are put in the wrong place, things will not work as expected.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们想要的。仔细看看我们添加新`if`语句及其对应的开闭花括号`{...}`的位置。如果它们放在错误的位置，事情将不会按预期工作。
- en: 'Add the following highlighted code to wrap the updated part of the code, paying
    close attention to the context that follows. I have added `...` on a few lines
    to represent hidden code. Obviously, ... is not real code and should not be added
    to the game. You can identify where to place the new code (highlighted) at the
    start and the end by the unhighlighted code surrounding it:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下突出显示的代码添加到更新部分的代码中，注意上下文。我在几行代码中添加了`...`来表示隐藏的代码。显然，...不是真正的代码，不应该添加到游戏中。你可以通过周围的未突出显示代码来确定放置新代码（突出显示）的开始和结束位置：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that, when you place the closing curly brace of the new `if` block, Visual
    Studio neatly adjusts all the indenting to keep the code tidy.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你放置新的 `if` 块的闭合花括号时，Visual Studio 会整洁地调整所有缩进来保持代码整洁。
- en: Now, you can run the game and everything will be static until you press the
    *Enter* key. It is now possible to go about adding features to our game. We just
    need to remember that, when the player dies or runs out of time, we need to set
    `paused` to `true`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行游戏，直到你按下 *Enter* 键，一切都将保持静态。现在，你可以开始添加游戏功能。我们只需要记住，当玩家死亡或用完时间时，我们需要将
    `paused` 设置为 `true`。
- en: In the previous chapter, we took our first look at C++ Strings. We need to learn
    a bit more about them so that we can implement the player's HUD.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们第一次了解了 C++ 字符串。我们需要了解它们更多，以便我们可以实现玩家的 HUD。
- en: C++ Strings
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ 字符串
- en: In the previous chapter, we briefly mentioned Strings and we learned that a
    String can hold alphanumeric data – anything from a single character to a whole
    book. We didn't look at declaring, initializing, or manipulating Strings, so let's
    do that now.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要介绍了字符串，并了解到字符串可以存储字母数字数据——从单个字符到整本书。我们没有查看声明、初始化或操作字符串，所以现在让我们来做这件事。
- en: Declaring Strings
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明字符串
- en: 'Declaring a String variable is simple. It is the same process that we used
    for other variables in the previous chapter: we state the type, followed by the
    name:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 声明字符串变量很简单。这与我们在上一章中用于其他变量的过程相同：我们声明类型，然后是名称：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once we have declared a String, we can assign a value to it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们声明了一个字符串，我们就可以给它赋值。
- en: Assigning a value to a String
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为字符串赋值
- en: 'To assign a value to a String, just like regular variables, we simply put the
    name, followed by the assignment operator, and then the value:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要为字符串赋值，就像常规变量一样，我们只需写出名称，然后是赋值运算符，最后是值：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note that the values need to be enclosed in quotation marks. Just like regular
    variables, we can also declare and assign values in a single line:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，值需要用引号括起来。就像常规变量一样，我们也可以在一行中声明和赋值：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the next section, we will see how we can change the values of our String
    variables.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何更改我们的字符串变量的值。
- en: Manipulating Strings
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串操作
- en: 'We can use the `#include <sstream>` directive to give us some extra manipulation
    options for our Strings. The `sstream` class allows us to "add" some Strings together.
    When we add Strings together, this is known as **concatenation**:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `#include <sstream>` 指令为我们提供一些额外的字符串操作选项。`sstream` 类允许我们将一些字符串“相加”。当我们把字符串相加时，这被称为**连接**：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In addition to this, by using `sstream` objects a String variable can even
    be concatenated with a variable of a different type. The following code starts
    to reveal how Strings might be useful to us:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过使用 `sstream` 对象，字符串变量甚至可以与不同类型的变量连接。以下代码开始揭示字符串可能对我们有多有用：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, `ss` is used to join the content of `scoreText` with
    the value from `score`. Note that although score holds an `int` value, the final
    value held by `ss` is still a String that holds an equivalent value; in this case,
    "1".
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`ss` 用于将 `scoreText` 的内容与 `score` 的值连接起来。请注意，尽管 `score` 保持一个 `int` 值，但
    `ss` 最终持有的值仍然是一个包含等效值的字符串；在这种情况下，"1"。
- en: Tip
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `<<` operator is one of the bitwise operators. C++, however, allows you
    to write your own classes and override what a specific operator does within the
    context of your class. The `sstream` class has done this to make the `<<` operator
    work the way it does. The complexity is hidden in the class. We can use its functionality
    without worrying about how it works. If you are feeling adventurous, you can read
    about operator overloading at [http://www.tutorialspoint.com/cplusplus/cpp_overloading.htm](http://www.tutorialspoint.com/cplusplus/cpp_overloading.htm).
    You don't need any more information in order to continue with the project.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`<<` 运算符是位运算符之一。然而，C++ 允许你编写自己的类并覆盖在类上下文中特定运算符的行为。`sstream` 类就是这样做的，以便 `<<`
    运算符按这种方式工作。复杂性被隐藏在类中。我们可以使用其功能而不必担心它是如何工作的。如果你感到好奇，你可以阅读有关运算符重载的信息，请参阅 [http://www.tutorialspoint.com/cplusplus/cpp_overloading.htm](http://www.tutorialspoint.com/cplusplus/cpp_overloading.htm)。为了继续项目，你不需要更多的信息。'
- en: Now that we know the basics of C++ Strings and how we can use `sstream`, we
    will look at how we can use some SFML classes to display them on the screen.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 C++ 字符串的基础以及如何使用 `sstream`，我们将看看如何使用一些 SFML 类在屏幕上显示它们。
- en: SFML's Text and Font classes
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SFML 的文本和字体类
- en: Let's talk about the `Text` and `Font` classes using some hypothetical code
    before we go ahead and add the code to our game.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续添加游戏代码之前，让我们通过一些假设的代码来讨论`Text`和`Font`类。
- en: The first step in being able to draw text on the screen is to have a font. In
    [*Chapter 1*](B14278_01_Final_AG_ePub.xhtml#_idTextAnchor017), *C++, SFML, Visual
    Studio, and Starting the First Game*, we added a font file to the project folder.
    Now, we can load the font into an SFML `Font` object, so that it's ready to use.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上绘制文本的第一步是拥有一个字体。在[*第一章*](B14278_01_Final_AG_ePub.xhtml#_idTextAnchor017)，*C++、SFML、Visual
    Studio和开始第一个游戏*中，我们将字体文件添加到了项目文件夹中。现在，我们可以将字体加载到SFML `Font`对象中，使其准备好使用。
- en: 'The code to do so looks like the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此目的的代码如下：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, we first declare the `Font` object and then load an actual
    font file. Note that `myfont.ttf` is a hypothetical font and that we could use
    any font in the project folder.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先声明了`Font`对象，然后加载了一个实际的字体文件。请注意，`myfont.ttf`是一个假设的字体，我们可以在项目文件夹中使用任何字体。
- en: 'Once we have loaded a font, we need an SFML `Text` object:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们加载了一个字体，我们需要一个SFML `Text`对象：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we can configure our `Text` object. This includes the size, the color,
    the position on-screen, the String that holds the message, and of course the act
    of associating it with our `font` object:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以配置我们的`Text`对象。这包括大小、颜色、屏幕上的位置、包含消息的字符串，以及当然，将其与我们的`font`对象关联的操作：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that we can create and manipulate String values as well as assign, declare,
    and initialize SFML `Text` objects, we can move on to the next section, where
    we will add a HUD to Timber!!!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够创建和操作字符串值，以及分配、声明和初始化SFML `Text`对象，我们可以继续到下一部分，在那里我们将为Timber添加HUD！！！
- en: Implementing the HUD
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现HUD
- en: Now, we know enough about Strings, SFML `Text`, and SFML `Font` to go about
    implementing the HUD. **HUD** stands for **Heads Up Display**. It can be as simple
    as the score and text messages on the screen or it can include more complex elements
    such as a time-bar, mini-map, or compass that represents the direction that the
    player character is facing.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们对字符串、SFML `Text`和SFML `Font`有了足够的了解，可以着手实现HUD。**HUD**代表**抬头显示**。它可以像屏幕上的分数和文本消息那样简单，也可以包括更复杂元素，如时间条、小地图或指南针，代表玩家角色面对的方向。
- en: To get started with the HUD, we need to add another `#include` directive to
    the top of the code file to add access to the `sstream` class. As we already know,
    the `sstream` class adds some really useful functionality for combining Strings
    and other variable types into a String.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用HUD，我们需要在代码文件顶部添加另一个`#include`指令以添加对`sstream`类的访问。正如我们已知的，`sstream`类为将字符串和其他变量类型组合成字符串添加了一些非常实用的功能。
- en: 'Add the following line of highlighted code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下高亮代码行：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we will set up our SFML `Text` objects: one to hold a message that we
    will vary to suit the state of the game and one that will hold the score and will
    need to be regularly updated.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将设置我们的SFML `Text`对象：一个用于存储我们将根据游戏状态变化的消息，另一个将存储分数并需要定期更新。
- en: The code declares the `Text` and `Font` objects, loads the font, assigns the
    font to the `Text` objects, and then adds the String messages, color, and size.
    This should look familiar from our discussion in the previous section. In addition,
    we added a new `int` variable called `score` that we can manipulate so that it
    holds the player's score.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 代码声明了`Text`和`Font`对象，加载了字体，将字体分配给`Text`对象，然后添加了字符串消息、颜色和大小。这应该与我们在上一节中的讨论相似。此外，我们添加了一个名为`score`的新`int`变量，我们可以操作它，使其包含玩家的分数。
- en: Tip
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember that, if you chose a different font from `KOMIKAP_.ttf`, back in [*Chapter
    1*](B14278_01_Final_AG_ePub.xhtml#_idTextAnchor017)*, C++, SFML, Visual Studio,
    and Starting the First Game*, you will need to change that part of the code to
    match the `.ttf` file that you have in the `Visual Studio Stuff/Projects/Timber/fonts`
    folder.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果你在[*第一章*](B14278_01_Final_AG_ePub.xhtml#_idTextAnchor017)*C++、SFML、Visual
    Studio和开始第一个游戏*中选择了不同的字体`KOMIKAP_.ttf`，你需要将代码中相应部分更改为与`Visual Studio Stuff/Projects/Timber/fonts`文件夹中的`.ttf`文件匹配。
- en: 'By adding the following highlighted code, we will be ready to move on to updating
    the HUD:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加以下高亮代码，我们将准备好继续更新HUD：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding code we have achieved the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们实现了以下内容：
- en: Declared a variable to hold the score
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个变量来保存分数
- en: Declared some SFML `Text` and `Font` objects
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明了一些SFML `Text`和`Font`对象
- en: Initialized the `Font` object by loading a font from a file
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过从文件中加载字体初始化`Font`对象
- en: Initialized the `Text` objects using the font and some Strings
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字体和一些字符串初始化`Text`对象
- en: Set the size and color of the `Text` objects using the `setCharacterSize` and
    `setFillColor` functions
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`setCharacterSize`和`setFillColor`函数设置`Text`对象的大小和颜色
- en: 'The following snippet of code might look a little convoluted, even complex.
    It is, however, straightforward when you break it down a bit. Examine and add
    the new highlighted code. We will go through it after this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段可能看起来有些复杂，甚至有些复杂。然而，当你稍微分解它时，它却是直截了当的。检查并添加新的突出显示的代码。我们将在之后讨论它：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We have two objects of the `Text` type that we will display on the screen. We
    want to position `scoreText` to the top left with a little bit of padding. This
    is not a challenge; we simply use `scoreText.setPosition(20, 20)`, which positions
    it at the top left with 20 pixels of horizontal and vertical padding.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个`Text`类型的对象，我们将在屏幕上显示。我们希望将`scoreText`定位在左上角，并留有一定的填充。这并不构成挑战；我们只需使用`scoreText.setPosition(20,
    20)`，这样它就会定位在左上角，水平方向和垂直方向各有20像素的填充。
- en: Positioning `messageText`, however, is not so easy. We want to position it in
    the exact midpoint of the screen. Initially, this might not seem like a problem,
    but then we have to remember that the origin of everything we draw is at the top
    left-hand corner. So, if we simply divide the screen width and height by two and
    use the results in `mesageText.setPosition...`, then the top left of the text
    will be in the center of the screen and it will spread out untidily to the right.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，定位`messageText`并不那么简单。我们希望将其定位在屏幕的精确中点。最初，这可能看起来不是问题，但我们必须记住，我们绘制的一切的原点都在左上角。因此，如果我们简单地将屏幕宽度和高度除以二，并在`mesageText.setPosition...`中使用结果，那么文本的左上角就会在屏幕中心，并且它将杂乱无章地向右扩展。
- en: 'The following is the code under discussion again for convenience:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为了方便再次讨论的代码：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: What the code does is set the *center* of `messageText` to the center of the
    screen. The rather complex-looking bit of code that we are reviewing repositions
    the origin of `messageText` to the center of itself.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 代码所做的就是将`messageText`的*中心*设置为屏幕的中心。我们正在审查的看起来相当复杂的代码片段重新定位了`messageText`的原点到其自身中心。
- en: In the preceding code, we first declare a new object of the `FloatRect` type
    called `textRect`. A `FloatRect` object, as its name suggests, holds a rectangle
    with floating-point coordinates.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先声明了一个名为`textRect`的新对象，其类型为`FloatRect`。正如其名称所暗示的，`FloatRect`对象包含一个具有浮点坐标的矩形。
- en: The code then uses the `mesageText.getLocalBounds` function to initialize `textRect`
    with the coordinates of the rectangle that wraps `messageText`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码使用`mesageText.getLocalBounds`函数用包围`messageText`的矩形的坐标初始化`textRect`。
- en: 'The next line of code, which is spread over four lines as it is quite long,
    uses the `messageText.setOrigin` function to change the origin (the point that
    is used to draw at) to the center of `textRect`. Of course, `textRect` holds a
    rectangle that matches the coordinates that wrap `messageText`. Then, this following
    line of code executes:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码，由于它相当长，被分散在四行中，使用了`messageText.setOrigin`函数来改变原点（用于绘制的点）到`textRect`的中心。当然，`textRect`包含一个与`messageText`坐标相匹配的矩形。然后，执行以下代码行：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, `messageText` will be neatly positioned in the exact center of the screen.
    We will use this code each time we change the text of `messageText` because changing
    the message changes the size of `messageText`, so its origin will need recalculating.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`messageText`将被整齐地定位在屏幕的精确中心。我们将使用此代码每次更改`messageText`的文本，因为更改消息会改变`messageText`的大小，因此需要重新计算其原点。
- en: 'Next, we declare an object of the `stringstream` type called `ss`. Note that
    we use the full name, including the namespace, that is, `std::stringstream`. We
    could avoid this syntax by adding `using namespace std` to the top of our code
    file. We aren''t going to here, though, because we use it infrequently. Take a
    look at the following code and add it to the game; then, we can go through it
    in more detail. Since we only want this code to execute when the game is not paused,
    be sure to add it with the other code, inside the `if(!paused)` block, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明了一个名为`ss`的`stringstream`类型对象。请注意，我们使用了包括命名空间在内的完整名称，即`std::stringstream`。我们可以通过在代码文件顶部添加`using
    namespace std`来避免这种语法。不过，在这里我们不会这样做，因为我们很少使用它。请查看以下代码并将其添加到游戏中；然后，我们可以更详细地讨论它。由于我们只想在游戏未暂停时执行此代码，请确保将其与其他代码一起添加到`if(!paused)`块中，如下所示：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We use `ss` and the special functionality provided by the `<<` operator, which
    concatenates variables into a `stringstream`. Here, `ss << "Score = " << score`
    has the effect of creating a String with `"Score = "`. Whatever the value of `score`
    is, is concatenated together. For example, when the game first starts, `score`
    is equal to zero, so `ss` will hold the `"Score = 0"` value. If `score` ever changes,
    `ss` will adapt each frame.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ss`和`<<`运算符提供的特殊功能，该运算符将变量连接到一个`stringstream`中。在这里，`ss << "Score = " <<
    score`的效果是创建一个包含`"Score = "`的字符串。无论`score`的值是多少，都会被连接在一起。例如，当游戏第一次开始时，`score`等于零，所以`ss`将保持`"Score
    = 0"`的值。如果`score`发生变化，`ss`将适应每一帧。
- en: 'The following line of code simply sets the String contained in `ss` to `scoreText`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行代码只是将`ss`中包含的字符串设置为`scoreText`：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It is now ready to be drawn to the screen.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它已经准备好被绘制到屏幕上了。
- en: This following code draws both `Text` objects (`scoreText` and `messageText`),
    but the code that draws `messageText` is wrapped in an `if` statement. This `if`
    statement causes `messageText` to only be drawn when the game is paused.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码绘制了两个`Text`对象（`scoreText`和`messageText`），但绘制`messageText`的代码被包裹在一个`if`语句中。这个`if`语句导致`messageText`只有在游戏暂停时才会被绘制。
- en: 'Add the following highlighted code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下高亮代码：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can now run the game and see our HUD being drawn on the screen. You will
    see the **Score = 0** and **PRESS ENTER TO START** messages. The latter will disappear
    when you press *Enter*:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行游戏，并看到我们的HUD被绘制到屏幕上。你会看到**得分 = 0**和**按回车键开始**的消息。当你按下*Enter*键时，后者将消失：
- en: '![](img/B14278_03_01.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14278_03_01.jpg)'
- en: If you want to see the score updating, add a temporary line of code, `score
    ++;`, anywhere in the `while(window.isOpen)` loop. If you add this temporary line,
    you will see the score go up fast, very fast!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要看到分数更新，请在`while(window.isOpen)`循环中的任何地方添加一个临时行代码，`score ++;`。如果你添加了这个临时行代码，你会看到分数快速上升，非常快！
- en: If you added the temporary code, that is, `score ++;`, be sure to delete it
    before continuing.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你添加了临时代码，即`score ++;`，在继续之前务必将其删除。
- en: Adding a time-bar
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加时间条
- en: Since time is a crucial mechanism in the game, it is necessary to keep the player
    aware of it. They need to know if their allotted six seconds are about to run
    out. It will give them a sense of urgency as the end of the game draws near and
    a sense of accomplishment if they perform well enough to maintain or increase
    their remaining time.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于时间在游戏中是一个关键机制，因此有必要让玩家意识到这一点。他们需要知道他们分配的六秒是否即将用完。当游戏接近结束时，这会给他们一种紧迫感；如果他们表现良好，能够保持或增加剩余时间，这会给他们一种成就感。
- en: Drawing the number of seconds remaining on the screen is not easy to read (when
    concentrating on the branches), nor is it a particularly interesting way to achieve
    the objective.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上绘制剩余秒数不易阅读（当专注于分支时），也不是实现目标的一种特别有趣的方式。
- en: What we need is a time-bar. Our time-bar will be a simple red rectangle that's
    prominently displayed on the screen. It will start off nice and wide, but rapidly
    shrink as time runs out. When the player's remaining time reaches zero, the time-bar
    will be gone completely.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是一个时间条。我们的时间条将是一个简单且突出显示在屏幕上的红色矩形。它一开始会很宽，但随着时间的流逝会迅速缩小。当玩家的剩余时间达到零时，时间条将完全消失。
- en: At the same time as adding the time-bar, we will add the necessary code to keep
    track of the player's remaining time, and respond when it runs out. Let's go through
    this step by step.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 同时添加时间条时，我们还将添加必要的代码来跟踪玩家的剩余时间，并在时间用尽时做出响应。让我们一步一步地完成这个过程。
- en: 'Find the `Clock clock;` declaration from earlier and add the highlighted code
    just after it, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 找到之前声明的`Clock clock;`，在其后添加高亮代码，如下所示：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First, we declare an object of the `RectangleShape` type and call it `timeBar`.
    `RectagleShape` is an SFML class that is perfect for drawing simple rectangles.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明一个`RectangleShape`类型的对象，并将其命名为`timeBar`。`RectangleShape`是SFML类，非常适合绘制简单的矩形。
- en: Next, we will add a few `float` variables, `timeBarStartWidth` and `timeBarHeight`.
    We initialize them to `400` and `80`, respectively. These variables will help
    us keep track of the size we need to draw `timeBar` at each frame.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加几个`float`类型的变量，`timeBarStartWidth`和`timeBarHeight`。我们将它们分别初始化为`400`和`80`。这些变量将帮助我们跟踪在每一帧绘制`timeBar`所需的大小。
- en: Next, we set the size of `timeBar` using the `timeBar.setSize` function. We
    don't just pass in our two new `float` variables. First, we create a new object
    of the `Vector2f` type. What is different here, however, is that we don't give
    the new object a name. Instead, we simply initialize it with our two float variables
    and pass it straight in to the `setSize` function.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`timeBar.setSize`函数设置`timeBar`的大小。我们不仅仅传递两个新的`float`变量。首先，我们创建一个新的`Vector2f`类型的对象。然而，这里的不同之处在于我们没有给这个新对象命名。相反，我们直接用两个浮点变量初始化它，并将其直接传递给`setSize`函数。
- en: Tip
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: '`Vector2f` is a class that holds two `float` variables. It also has some other
    functionality that will be introduced throughout this book.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vector2f`是一个包含两个`float`变量的类。它还有一些其他功能，将在本书的其余部分介绍。'
- en: After that, we color `timeBar` red by using the `setFillColor` function.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们通过使用`setFillColor`函数将`timeBar`涂成红色。
- en: 'The last thing we do to `timeBar` in the previous code is set its position.
    The vertical coordinate is completely straightforward but the way we set the horizontal
    coordinate is slightly convoluted. Here is the calculation again:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中我们对`timeBar`做的最后一件事是设置其位置。垂直坐标非常直接，但设置水平坐标的方式稍微复杂一些。这里再次进行计算：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First, the code divides 1920 by 2\. Then, it divides `timeBarStartWidth` by
    2\. Finally, it subtracts the latter from the former.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码将1920除以2。然后，它将`timeBarStartWidth`除以2。最后，它从前者减去后者。
- en: The result makes `timeBar` sit neatly and centrally, in a horizontal fashion,
    on the screen.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 结果使`timeBar`整齐地、水平地位于屏幕中央。
- en: The final three lines of code that we are talking about declare a new `Time`
    object called `gameTimeTotal`, a new `float` called `timeRemaining` that is initialized
    to `6`, and a curious-sounding `float` named `timeBarWidthPerSecond`, which we
    will discuss next.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在讨论的最后三行代码声明了一个名为`gameTimeTotal`的新`Time`对象，一个初始化为`6`的新`float`变量`timeRemaining`，以及一个听起来很奇怪的名为`timeBarWidthPerSecond`的`float`变量，我们将在下一节讨论。
- en: The `timeBarWidthPerSecond` variable is initialized with `timeBarStartWidth`
    divided by `timeRemaining`. The result is exactly the amount of pixels that `timeBar`
    needs to shrink by each second of the game. This will be useful when we resize
    `timeBar` in each frame.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeBarWidthPerSecond`变量通过将`timeBarStartWidth`除以`timeRemaining`初始化。结果是`timeBar`每秒需要缩小的像素数。当我们在每一帧调整`timeBar`大小时，这将很有用。'
- en: Obviously, we need to reset the time remaining each time the player starts a
    new game. The logical place to do this is when the *Enter* key is pressed. We
    can also set `score` back to zero at the same time. Let's do that now by adding
    the following highlighted code
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，每次玩家开始新游戏时，我们都需要重置剩余时间。进行此操作的逻辑位置是在按下*Enter*键时。我们还可以同时将`score`设置回零。现在让我们添加以下突出显示的代码：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we must reduce each frame by the amount of time remaining and resize `timeBar`
    accordingly. Add the following highlighted code to the update section, as shown
    here:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须通过剩余时间减少每一帧，并相应地调整`timeBar`的大小。将以下突出显示的代码添加到更新部分，如下所示：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'First, we subtracted the amount of time the player has left by however long
    the previous frame took to execute with the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过以下代码减去玩家剩余的时间与上一帧执行所需的时间量：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we adjusted the size of `timeBar` with the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用以下代码调整了`timeBar`的大小：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The x value of `Vector2F` is initialized with `timebarWidthPerSecond` when multiplied
    by `timeRemaining`. This produces exactly the right width, relative to how long
    the player has left. The height remains the same and `timeBarHeight` is used without
    any manipulation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vector2F`的x值在乘以`timeRemaining`时初始化为`timebarWidthPerSecond`，这会产生与玩家剩余时间成正比的正确宽度。高度保持不变，`timeBarHeight`未经过任何操作就被使用。'
- en: 'And of course, we must detect when the time has run out. For now, we will simply
    detect that time has run out, pause the game, and change the text of `messageText`.
    Later, we will do more work here. Add the following highlighted code right after
    the previous code we added. We will look at it in more detail later:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们必须检测时间是否已耗尽。目前，我们将简单地检测时间是否已耗尽，暂停游戏，并更改`messageText`的文本。稍后，我们将在这里做更多的工作。将以下突出显示的代码添加到之前添加的代码之后。我们稍后会详细讨论它：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s step through the previous code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析之前的代码：
- en: First, we test whether time has run out with `if(timeRemaining<= 0.0f).`
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用`if(timeRemaining<= 0.0f)`测试时间是否已耗尽。
- en: Then, we set `paused` to `true`, so this will be the last time the update part
    of our code is executed (until the player presses *Enter* again).
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将 `paused` 设置为 `true`，因此这将是我们代码更新部分的最后一次执行（直到玩家再次按下 *Enter* 键）。
- en: Then, we change the message of `messageText`, calculate its new center to be
    set as its origin, and position it in the center of the screen.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们更改 `messageText` 的信息，计算其新的中心并将其设置为原点，并将其定位在屏幕中央。
- en: 'Finally, for this part of the code, we need to draw `timeBar`. There is nothing
    new in this code that we haven''t seen many times before. Just note that we draw
    `timeBar` after the tree so that it is not partially obscured. Add the following
    highlighted code to draw the time-bar:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于这段代码，我们需要绘制 `timeBar`。这段代码中没有我们之前没有多次见过的内容。只需注意，我们在绘制树之后绘制 `timeBar`，这样它就不会被部分遮挡。添加以下高亮代码以绘制时间条：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, you can run the game, press *Enter* to start it, and watch the time-bar
    smoothly disappear down to nothing:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行游戏，按下 *Enter* 键开始它，并观察时间条平滑地消失到无：
- en: '![](img/Image85176.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image85176.jpg)'
- en: 'The game then pauses and the **OUT OF TIME!!** message will appear in the center
    of the screen:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏随后暂停，屏幕中央将出现 **OUT OF TIME!!** 信息：
- en: '![](img/B14278_03_04.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_03_04.jpg)'
- en: You can, of course, press *Enter* to start the game again and watch it run from
    the beginning.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以按下 *Enter* 键重新开始游戏，并从开始观看它运行。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about Strings, SFML `Text`, and SFML `Font`. Between
    them, they allowed us to draw text to the screen, which provided the player with
    a HUD. We also used `sstream`, which allows us to concatenate Strings and other
    variables to display the score.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了字符串、SFML `Text` 和 SFML `Font`。它们共同使我们能够在屏幕上绘制文本，为玩家提供了抬头显示（HUD）。我们还使用了
    `sstream`，它允许我们将字符串和其他变量连接起来以显示分数。
- en: We also explored the SFML `RectangleShape` class, which does exactly what its
    name suggests. We used an object of the `RectangleShape` type and some carefully
    planned variables to draw a time-bar that visually displays to the player how
    much time they have left. Once we implement chopping and moving branches that
    can squash the player, the time-bar will provide visual feedback that will create
    tension and urgency.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了 SFML 的 `RectangleShape` 类，它确实如其名称所暗示的那样。我们使用 `RectangleShape` 类型的对象和一些精心策划的变量来绘制一个时间条，它以视觉方式向玩家显示他们剩余的时间。一旦我们实现了可以挤压玩家的砍伐和移动树枝，时间条将提供视觉反馈，从而创造紧张和紧迫感。
- en: In the next chapter, we are going to learn about a whole range of new C++ features,
    including loops, arrays, switching, enumerations, and functions. This will allow
    us to move tree branches, keep track of their locations, and squash the player.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习一系列新的 C++ 功能，包括循环、数组、切换、枚举和函数。这将使我们能够移动树枝，跟踪它们的位置，并挤压玩家。
- en: FAQ
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题解答
- en: Q) I can foresee that positioning sprites by their top-left corner could sometimes
    be inconvenient. Is there an alternative?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Q) 我可以预见，有时通过精灵的左上角定位可能会不方便。有没有替代方案？
- en: A) Fortunately, you can choose what point of a sprite is used as the positioning/origin
    pixel, just like we did with `messageText`, using the `setOrigin` function.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: A) 幸运的是，你可以选择使用精灵的哪个点作为定位/原点像素，就像我们使用 `messageText` 时做的那样，通过使用 `setOrigin` 函数。
- en: Q) The code is getting rather long and I am struggling to keep track of where
    everything is. How can we fix this?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Q) 代码变得越来越长，我很难跟踪所有内容的位置。我们该如何解决这个问题？
- en: A) Yes, I agree. In the next chapter, we will look at the first of a few ways
    we can organize our code and make it more readable. We will look at this when
    we learn about writing C++ functions. In addition, we will learn about a new way
    we can handle multiple objects/variables of the same type (like the clouds) when
    we learn about C++ arrays.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: A) 是的，我同意。在下一章中，我们将探讨几种组织代码和使其更易读的方法之一。我们将在我们学习编写 C++ 函数时探讨这一点。此外，当我们学习 C++
    数组时，我们还将了解一种处理相同类型多个对象/变量的新方法（如云）。
