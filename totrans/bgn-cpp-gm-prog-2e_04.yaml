- en: '*Chapter 3*: C++ Strings and SFML Time – Player Input and HUD'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will continue with the Timber!! game. We will spend around
    half of this chapter learning how to manipulate text and display it on the screen,
    and the other half looking at timing and how a visual time-bar can inform the
    player about the remaining time and create a sense of urgency in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Pausing and restarting the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++ Strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SFML text and SFML font classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a HUD to Timber!!!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a time-bar to Timber!!!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pausing and restarting the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we work on this game over the next three chapters, the code will obviously
    get longer and longer. So, now seems like a good time to think ahead and add a
    little bit more structure to our code. We will add this structure so that we can
    pause and restart the game.
  prefs: []
  type: TYPE_NORMAL
- en: We will add code so that, when the game is run for the first time, it will be
    in a paused state. The player will then be able to press the *Enter* key to start
    the game. Then, the game will run until either the player gets squished or runs
    out of time. At this point, the game will pause and wait for the player to press
    *Enter* so that they can restart the game.
  prefs: []
  type: TYPE_NORMAL
- en: Let's step through setting this up a bit at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, declare a new `bool` variable called `paused` outside the main game
    loop and initialize it to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, whenever the game is run, we have a `paused` variable that will be `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will add another `if` statement where the expression will check whether
    the *Enter* key is currently being pressed. If it is being pressed, it sets `paused`
    to `false`. Add the following highlighted code just after our other keyboard-handling
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have a `bool` called `paused` that starts off `true` but changes to
    `false` when the player presses the *Enter* key. At this point, we must make our
    game loop respond appropriately, based on whatever the current value of `paused`
    might be.
  prefs: []
  type: TYPE_NORMAL
- en: This is how we will proceed. We will wrap the entire update part of the code,
    including the code we wrote in the last chapter for moving the bee and clouds,
    in an `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: In the following code, note that the `if` block will only execute when `paused`
    is not equal to `true`. Put another way, the game won't move/update when it is
    paused.
  prefs: []
  type: TYPE_NORMAL
- en: This is exactly what we want. Look carefully at the place where we added the
    new `if` statement and its corresponding opening and closing curly braces `{...}`.
    If they are put in the wrong place, things will not work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following highlighted code to wrap the updated part of the code, paying
    close attention to the context that follows. I have added `...` on a few lines
    to represent hidden code. Obviously, ... is not real code and should not be added
    to the game. You can identify where to place the new code (highlighted) at the
    start and the end by the unhighlighted code surrounding it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that, when you place the closing curly brace of the new `if` block, Visual
    Studio neatly adjusts all the indenting to keep the code tidy.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can run the game and everything will be static until you press the
    *Enter* key. It is now possible to go about adding features to our game. We just
    need to remember that, when the player dies or runs out of time, we need to set
    `paused` to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we took our first look at C++ Strings. We need to learn
    a bit more about them so that we can implement the player's HUD.
  prefs: []
  type: TYPE_NORMAL
- en: C++ Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we briefly mentioned Strings and we learned that a
    String can hold alphanumeric data – anything from a single character to a whole
    book. We didn't look at declaring, initializing, or manipulating Strings, so let's
    do that now.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Declaring a String variable is simple. It is the same process that we used
    for other variables in the previous chapter: we state the type, followed by the
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Once we have declared a String, we can assign a value to it.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning a value to a String
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To assign a value to a String, just like regular variables, we simply put the
    name, followed by the assignment operator, and then the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the values need to be enclosed in quotation marks. Just like regular
    variables, we can also declare and assign values in a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will see how we can change the values of our String
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use the `#include <sstream>` directive to give us some extra manipulation
    options for our Strings. The `sstream` class allows us to "add" some Strings together.
    When we add Strings together, this is known as **concatenation**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to this, by using `sstream` objects a String variable can even
    be concatenated with a variable of a different type. The following code starts
    to reveal how Strings might be useful to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `ss` is used to join the content of `scoreText` with
    the value from `score`. Note that although score holds an `int` value, the final
    value held by `ss` is still a String that holds an equivalent value; in this case,
    "1".
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The `<<` operator is one of the bitwise operators. C++, however, allows you
    to write your own classes and override what a specific operator does within the
    context of your class. The `sstream` class has done this to make the `<<` operator
    work the way it does. The complexity is hidden in the class. We can use its functionality
    without worrying about how it works. If you are feeling adventurous, you can read
    about operator overloading at [http://www.tutorialspoint.com/cplusplus/cpp_overloading.htm](http://www.tutorialspoint.com/cplusplus/cpp_overloading.htm).
    You don't need any more information in order to continue with the project.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the basics of C++ Strings and how we can use `sstream`, we
    will look at how we can use some SFML classes to display them on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: SFML's Text and Font classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's talk about the `Text` and `Font` classes using some hypothetical code
    before we go ahead and add the code to our game.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in being able to draw text on the screen is to have a font. In
    [*Chapter 1*](B14278_01_Final_AG_ePub.xhtml#_idTextAnchor017), *C++, SFML, Visual
    Studio, and Starting the First Game*, we added a font file to the project folder.
    Now, we can load the font into an SFML `Font` object, so that it's ready to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to do so looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we first declare the `Font` object and then load an actual
    font file. Note that `myfont.ttf` is a hypothetical font and that we could use
    any font in the project folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have loaded a font, we need an SFML `Text` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can configure our `Text` object. This includes the size, the color,
    the position on-screen, the String that holds the message, and of course the act
    of associating it with our `font` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now that we can create and manipulate String values as well as assign, declare,
    and initialize SFML `Text` objects, we can move on to the next section, where
    we will add a HUD to Timber!!!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the HUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we know enough about Strings, SFML `Text`, and SFML `Font` to go about
    implementing the HUD. **HUD** stands for **Heads Up Display**. It can be as simple
    as the score and text messages on the screen or it can include more complex elements
    such as a time-bar, mini-map, or compass that represents the direction that the
    player character is facing.
  prefs: []
  type: TYPE_NORMAL
- en: To get started with the HUD, we need to add another `#include` directive to
    the top of the code file to add access to the `sstream` class. As we already know,
    the `sstream` class adds some really useful functionality for combining Strings
    and other variable types into a String.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will set up our SFML `Text` objects: one to hold a message that we
    will vary to suit the state of the game and one that will hold the score and will
    need to be regularly updated.'
  prefs: []
  type: TYPE_NORMAL
- en: The code declares the `Text` and `Font` objects, loads the font, assigns the
    font to the `Text` objects, and then adds the String messages, color, and size.
    This should look familiar from our discussion in the previous section. In addition,
    we added a new `int` variable called `score` that we can manipulate so that it
    holds the player's score.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Remember that, if you chose a different font from `KOMIKAP_.ttf`, back in [*Chapter
    1*](B14278_01_Final_AG_ePub.xhtml#_idTextAnchor017)*, C++, SFML, Visual Studio,
    and Starting the First Game*, you will need to change that part of the code to
    match the `.ttf` file that you have in the `Visual Studio Stuff/Projects/Timber/fonts`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'By adding the following highlighted code, we will be ready to move on to updating
    the HUD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code we have achieved the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Declared a variable to hold the score
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declared some SFML `Text` and `Font` objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialized the `Font` object by loading a font from a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialized the `Text` objects using the font and some Strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the size and color of the `Text` objects using the `setCharacterSize` and
    `setFillColor` functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following snippet of code might look a little convoluted, even complex.
    It is, however, straightforward when you break it down a bit. Examine and add
    the new highlighted code. We will go through it after this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We have two objects of the `Text` type that we will display on the screen. We
    want to position `scoreText` to the top left with a little bit of padding. This
    is not a challenge; we simply use `scoreText.setPosition(20, 20)`, which positions
    it at the top left with 20 pixels of horizontal and vertical padding.
  prefs: []
  type: TYPE_NORMAL
- en: Positioning `messageText`, however, is not so easy. We want to position it in
    the exact midpoint of the screen. Initially, this might not seem like a problem,
    but then we have to remember that the origin of everything we draw is at the top
    left-hand corner. So, if we simply divide the screen width and height by two and
    use the results in `mesageText.setPosition...`, then the top left of the text
    will be in the center of the screen and it will spread out untidily to the right.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code under discussion again for convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: What the code does is set the *center* of `messageText` to the center of the
    screen. The rather complex-looking bit of code that we are reviewing repositions
    the origin of `messageText` to the center of itself.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we first declare a new object of the `FloatRect` type
    called `textRect`. A `FloatRect` object, as its name suggests, holds a rectangle
    with floating-point coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: The code then uses the `mesageText.getLocalBounds` function to initialize `textRect`
    with the coordinates of the rectangle that wraps `messageText`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next line of code, which is spread over four lines as it is quite long,
    uses the `messageText.setOrigin` function to change the origin (the point that
    is used to draw at) to the center of `textRect`. Of course, `textRect` holds a
    rectangle that matches the coordinates that wrap `messageText`. Then, this following
    line of code executes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, `messageText` will be neatly positioned in the exact center of the screen.
    We will use this code each time we change the text of `messageText` because changing
    the message changes the size of `messageText`, so its origin will need recalculating.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we declare an object of the `stringstream` type called `ss`. Note that
    we use the full name, including the namespace, that is, `std::stringstream`. We
    could avoid this syntax by adding `using namespace std` to the top of our code
    file. We aren''t going to here, though, because we use it infrequently. Take a
    look at the following code and add it to the game; then, we can go through it
    in more detail. Since we only want this code to execute when the game is not paused,
    be sure to add it with the other code, inside the `if(!paused)` block, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We use `ss` and the special functionality provided by the `<<` operator, which
    concatenates variables into a `stringstream`. Here, `ss << "Score = " << score`
    has the effect of creating a String with `"Score = "`. Whatever the value of `score`
    is, is concatenated together. For example, when the game first starts, `score`
    is equal to zero, so `ss` will hold the `"Score = 0"` value. If `score` ever changes,
    `ss` will adapt each frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line of code simply sets the String contained in `ss` to `scoreText`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It is now ready to be drawn to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: This following code draws both `Text` objects (`scoreText` and `messageText`),
    but the code that draws `messageText` is wrapped in an `if` statement. This `if`
    statement causes `messageText` to only be drawn when the game is paused.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now run the game and see our HUD being drawn on the screen. You will
    see the **Score = 0** and **PRESS ENTER TO START** messages. The latter will disappear
    when you press *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14278_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to see the score updating, add a temporary line of code, `score
    ++;`, anywhere in the `while(window.isOpen)` loop. If you add this temporary line,
    you will see the score go up fast, very fast!
  prefs: []
  type: TYPE_NORMAL
- en: If you added the temporary code, that is, `score ++;`, be sure to delete it
    before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a time-bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since time is a crucial mechanism in the game, it is necessary to keep the player
    aware of it. They need to know if their allotted six seconds are about to run
    out. It will give them a sense of urgency as the end of the game draws near and
    a sense of accomplishment if they perform well enough to maintain or increase
    their remaining time.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the number of seconds remaining on the screen is not easy to read (when
    concentrating on the branches), nor is it a particularly interesting way to achieve
    the objective.
  prefs: []
  type: TYPE_NORMAL
- en: What we need is a time-bar. Our time-bar will be a simple red rectangle that's
    prominently displayed on the screen. It will start off nice and wide, but rapidly
    shrink as time runs out. When the player's remaining time reaches zero, the time-bar
    will be gone completely.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time as adding the time-bar, we will add the necessary code to keep
    track of the player's remaining time, and respond when it runs out. Let's go through
    this step by step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the `Clock clock;` declaration from earlier and add the highlighted code
    just after it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: First, we declare an object of the `RectangleShape` type and call it `timeBar`.
    `RectagleShape` is an SFML class that is perfect for drawing simple rectangles.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will add a few `float` variables, `timeBarStartWidth` and `timeBarHeight`.
    We initialize them to `400` and `80`, respectively. These variables will help
    us keep track of the size we need to draw `timeBar` at each frame.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set the size of `timeBar` using the `timeBar.setSize` function. We
    don't just pass in our two new `float` variables. First, we create a new object
    of the `Vector2f` type. What is different here, however, is that we don't give
    the new object a name. Instead, we simply initialize it with our two float variables
    and pass it straight in to the `setSize` function.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: '`Vector2f` is a class that holds two `float` variables. It also has some other
    functionality that will be introduced throughout this book.'
  prefs: []
  type: TYPE_NORMAL
- en: After that, we color `timeBar` red by using the `setFillColor` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we do to `timeBar` in the previous code is set its position.
    The vertical coordinate is completely straightforward but the way we set the horizontal
    coordinate is slightly convoluted. Here is the calculation again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: First, the code divides 1920 by 2\. Then, it divides `timeBarStartWidth` by
    2\. Finally, it subtracts the latter from the former.
  prefs: []
  type: TYPE_NORMAL
- en: The result makes `timeBar` sit neatly and centrally, in a horizontal fashion,
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The final three lines of code that we are talking about declare a new `Time`
    object called `gameTimeTotal`, a new `float` called `timeRemaining` that is initialized
    to `6`, and a curious-sounding `float` named `timeBarWidthPerSecond`, which we
    will discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: The `timeBarWidthPerSecond` variable is initialized with `timeBarStartWidth`
    divided by `timeRemaining`. The result is exactly the amount of pixels that `timeBar`
    needs to shrink by each second of the game. This will be useful when we resize
    `timeBar` in each frame.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, we need to reset the time remaining each time the player starts a
    new game. The logical place to do this is when the *Enter* key is pressed. We
    can also set `score` back to zero at the same time. Let's do that now by adding
    the following highlighted code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we must reduce each frame by the amount of time remaining and resize `timeBar`
    accordingly. Add the following highlighted code to the update section, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we subtracted the amount of time the player has left by however long
    the previous frame took to execute with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we adjusted the size of `timeBar` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The x value of `Vector2F` is initialized with `timebarWidthPerSecond` when multiplied
    by `timeRemaining`. This produces exactly the right width, relative to how long
    the player has left. The height remains the same and `timeBarHeight` is used without
    any manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'And of course, we must detect when the time has run out. For now, we will simply
    detect that time has run out, pause the game, and change the text of `messageText`.
    Later, we will do more work here. Add the following highlighted code right after
    the previous code we added. We will look at it in more detail later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s step through the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we test whether time has run out with `if(timeRemaining<= 0.0f).`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we set `paused` to `true`, so this will be the last time the update part
    of our code is executed (until the player presses *Enter* again).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we change the message of `messageText`, calculate its new center to be
    set as its origin, and position it in the center of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, for this part of the code, we need to draw `timeBar`. There is nothing
    new in this code that we haven''t seen many times before. Just note that we draw
    `timeBar` after the tree so that it is not partially obscured. Add the following
    highlighted code to draw the time-bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can run the game, press *Enter* to start it, and watch the time-bar
    smoothly disappear down to nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image85176.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The game then pauses and the **OUT OF TIME!!** message will appear in the center
    of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14278_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can, of course, press *Enter* to start the game again and watch it run from
    the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about Strings, SFML `Text`, and SFML `Font`. Between
    them, they allowed us to draw text to the screen, which provided the player with
    a HUD. We also used `sstream`, which allows us to concatenate Strings and other
    variables to display the score.
  prefs: []
  type: TYPE_NORMAL
- en: We also explored the SFML `RectangleShape` class, which does exactly what its
    name suggests. We used an object of the `RectangleShape` type and some carefully
    planned variables to draw a time-bar that visually displays to the player how
    much time they have left. Once we implement chopping and moving branches that
    can squash the player, the time-bar will provide visual feedback that will create
    tension and urgency.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn about a whole range of new C++ features,
    including loops, arrays, switching, enumerations, and functions. This will allow
    us to move tree branches, keep track of their locations, and squash the player.
  prefs: []
  type: TYPE_NORMAL
- en: FAQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q) I can foresee that positioning sprites by their top-left corner could sometimes
    be inconvenient. Is there an alternative?
  prefs: []
  type: TYPE_NORMAL
- en: A) Fortunately, you can choose what point of a sprite is used as the positioning/origin
    pixel, just like we did with `messageText`, using the `setOrigin` function.
  prefs: []
  type: TYPE_NORMAL
- en: Q) The code is getting rather long and I am struggling to keep track of where
    everything is. How can we fix this?
  prefs: []
  type: TYPE_NORMAL
- en: A) Yes, I agree. In the next chapter, we will look at the first of a few ways
    we can organize our code and make it more readable. We will look at this when
    we learn about writing C++ functions. In addition, we will learn about a new way
    we can handle multiple objects/variables of the same type (like the clouds) when
    we learn about C++ arrays.
  prefs: []
  type: TYPE_NORMAL
