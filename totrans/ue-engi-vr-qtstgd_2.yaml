- en: Locomotion, Design, and Starting Our Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our knowledge of the current state of VR technology and game development,
    we may now begin working on our first title. As we mentioned in [Chapter 1](926e8e71-f556-43b2-b4f8-47dc017c7a38.xhtml), *Introducing
    VR Technology in Unreal Engine 4*, *Server 17* puts the player in the role of
    an intrepid hacker in search of the truth in a corrupt dystopian future. Everyone
    has secrets, and some will pay big sums of money for the secrets of others. In
    design terms, this means we're going to create a puzzle game in which the player
    solves puzzles and uses different tools to crack open different puzzle boxes that
    represent computer servers on a network. Through the building of this simple game,
    we'll address all of the steps of VR game design with the goal of arming you with
    the tools and know-how to begin work on your own title. The first step in the
    process is design and, for that, I always turn to the Human-Centered Design process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The Human-Centered Design process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing our locomotion method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up new game files in Unreal Engine 4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Human-Centered Design process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Human-Centered Design** (**HCD**) process is a flexible set of design
    principles that allows for the design of pretty much anything, from shoes, to
    cars, to software. Central to HCD is the principle that the designer is thinking
    of the end user at every step of the way. Would this decision make the product
    better for my user? Would making the color customizable delight my user and make
    them more likely to use my product? By asking these questions and thinking about
    your user, you're able to create a design that's more likely to be a success with
    its target audience.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HCD process has the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4b8cc87-48ca-43dc-9a12-063009a6456e.png)'
  prefs: []
  type: TYPE_IMG
- en: The HCD process
  prefs: []
  type: TYPE_NORMAL
- en: '**Discovery**: In this, we research the problem we''re presented with and the
    target demographic interested in our solution. We search to see whether this is
    something that someone has attempted to solve before and if so what they tried.
    We reach out to our potential users to find people who will talk to us so we can
    discover what they need from a solution.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Empathy**: Here, we speak with as many potential users as possible to gather
    what they''re looking for in a solution. We want to dig deep. Why is this something
    they want or need? Are there any connections back to a memory or an emotion? For
    example, nostalgia is a powerful longing for experiences related to a person''s
    youth. It''s also one of the strongest emotions that game developers like to touch
    on.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Ideate**: Once we know what our user wants, it''s time to brainstorm! When
    we ideate, we want to come up with as many ideas as possible. No idea is too out
    there or crazy (as long as it benefits our user).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Prototype**: Once we settle on an idea, we want to build a quick and easy
    version to allow our user to try it. No fancy programming or incredible art here—we
    want to create a playable version of our game, quickly and cheaply.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Test**: Put the prototype in front of the user and record the results! It''s
    often at this point that a product may fail. This might be caused by a problem
    with the design or something that the user didn''t understand or like. Record
    the data and learn from it!'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Refine**: With the user test data in hand, we go back to the ideate phase
    and try again. You''ll likely go through this cycle several times before your
    game is complete, but if you''re checking in with your user regularly and getting
    feedback from other designers and friends, you''ll surely come up with the next
    killer app.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For *Server 17*, our ideal user is someone who has never experienced VR before.
    They''re interested in a simple, yet very immersive experience that leverages
    the unique abilities of VR. They may be fans of cyberpunk movies such as *Tron*
    and *Tron: Legacy* and the *Shadowrun* series of games. Nostalgia may also come
    into play when they think about their first experience with a new piece of gaming
    hardware. It''s possible you have many friends who fit this profile that you can
    use as a reference while designing the game and we can also make use of online
    communities to gather further opinions. Once we''ve completed the **Discovery**
    and **Empathy** steps with a bit of research and some interviews with our user,
    we''re now ready to make a few design decisions regarding locomotion, or the process
    of our player moving through our game world.'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing our locomotion method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of our goals as VR designers is to leverage the unique advantages of this
    new technology to create novel experiences that players want to play again and
    again. The technology is fantastic for making the player feel as if they're interacting
    in a living and breathing fantasy world they would otherwise not be able to inhabit.
    Using the hand controllers, our players can touch our world and interact with
    it in a very visceral sense. However, locomotion systems still haven't caught
    up to that level of immersion yet.
  prefs: []
  type: TYPE_NORMAL
- en: Player locomotion in VR is still in its infancy, and, as such, there's no one
    method that has been found to work well. Many methods have been tried. There are
    vehicle simulation games, where the player remains seated in a cockpit. There
    are action/adventure games where players run through a landscape using artificial
    methods such as a thumbstick or teleportation. Others attempt to maintain immersion
    by having the player stand within a small area with everything they need readily
    accessible, allowing the player to move around naturally but at the expense of
    an expansive environment. Each method of locomotion is a trade-off between giving
    the player an immersive, natural sensation and avoiding unpleasant feelings, such
    as VR sickness.
  prefs: []
  type: TYPE_NORMAL
- en: During my time as a college professor, I had the opportunity to help my students
    to design a kayaking simulator for the local museum. The students devised a locomotion
    system that allowed the player to remain seated and use a paddle with an attached
    sensor to navigate their virtual craft down the river rapids. Though the system
    worked well in testing with their peers (it felt natural and worked well for me),
    we found that it had a profoundly negative affect on several of our users at the
    museum. One of our testers even had to leave work after testing our game. After
    asking the tester some questions, it was discovered that, although the paddle
    movement of our controller felt right, the realistic physics of the boat in the
    water made it impossible for them to play. Further questioning of the test group
    showed the students that this one tester wasn't the only player who had issues.
    In the end, they had to take some artistic license with the movement of the water
    to create a more enjoyable experience and learned that our user's experience and
    enjoyment was more important than realism.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this lack of a best practice may be concerning to some, the designer
    in us all should see this as an exciting opportunity to innovate and create new
    systems that provide our players with the best gameplay possible. The variety
    of systems can be broken down into four major categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Natural
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Artificial
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cockpit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physical (creative)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Natural locomotion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Not to be confused with the app of the same name, natural locomotion refers
    to a method of moving within VR that minimizes VR sickness by taking natural player
    movements, such as swinging arms and jumping, into the game world. We can see
    natural locomotion at work in the game *Tribe XR* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8db7f30c-fc76-412a-9dd0-8ec572963672.png)'
  prefs: []
  type: TYPE_IMG
- en: Tribe XR is an up and coming DJ app that can teach you how to mix music with
    in-game lessons
  prefs: []
  type: TYPE_NORMAL
- en: This covers a variety of methods, but all seem to provide the player with a
    direct translation of their movement into player movement in the game. Though
    this method has been shown to limit player discomfort, it isn't without its drawbacks.
    This approach limits the player to the space covered by their system's sensors
    and requires designers to design with this in mind. This can mean designing the
    level specifically around the average playspace size and making sure that everything
    the player needs is well within reach. This method has been used in such games
    as *Job Simulator*, *Tribe VR*, and *Waltz of the Wizard*.
  prefs: []
  type: TYPE_NORMAL
- en: Artificial locomotion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Artificial locomotion is essentially the opposite of natural locomotion. This
    technique relies on more traditional game controls such as thumbsticks, touch
    pads, and other input methods to move the player around our game levels.
  prefs: []
  type: TYPE_NORMAL
- en: Despite being the best locomotion when porting traditional titles to VR (think
    *Skyrim VR* and *Fallout 4 VR*), artificial locomotion has the greatest chance
    of causing VR sickness due to vexation, or the disconnect between what our eyes
    are seeing and what the rest of the senses are experiencing. There are several
    techniques we can use to minimize this vexation. One way is to dynamically decrease
    the player's field of view while they're moving. This creates a very subtle effect
    that hides some of the player's peripheral vision when they're moving or turning.
    Another is to have the player accelerate at a consistent rate during movement.
    Consistent acceleration puts less pressure on the vestibular system—the portion
    of our brain that senses acceleration. The same principle can be applied to rotation.
    Consistent slow turning or snap turning can feel better to a player. The final
    technique I would like to mention is teleportation. Teleportation is a great way
    to allow a player to navigate large environments without VR sickness. However,
    this method doesn't feel very natural depending on the game's story and setting.
  prefs: []
  type: TYPE_NORMAL
- en: Cockpit locomotion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to natural locomotion, cockpit locomotion allows for very natural movement
    for games such as space sims, vehicle racing, and other games that have the player
    sitting in a vehicle.
  prefs: []
  type: TYPE_NORMAL
- en: 'By tricking the body into thinking that movement is similar to riding in a
    car, we can bypass many of the causes of VR sickness. The downside to this method
    is that it isn''t applicable to most situations. Games that use this method successfully
    include *Elite: Dangerous*, *Star Trek Bridge Crew*, and *Archangel: Hellfire*.'
  prefs: []
  type: TYPE_NORMAL
- en: Physical locomotion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Physical locomotion systems refer to unique movement control schemes that tend
    to be designed for the specific game experiences they're applied to. Because of
    this, they tend to be some of the most innovative ideas that we see in the VR
    space today.
  prefs: []
  type: TYPE_NORMAL
- en: This type of locomotion covers purpose built movement methods such as the kayak
    paddle system built by my students, as well as hand-over-hand climbing, running
    in place while swinging the controllers, swimming motions, and flying by moving
    the player's arms. Because the player is making specific arm or body movements,
    they tend to feel a very high rate of immersion while experiencing very little
    VR sickness. These systems aren't without disadvantages. Some players may find
    the movement silly or gimmicky. They're also not usually usable outside their
    specific game. Games that have successfully implemented this type of locomotion
    include *The Climb*, *Eagle Flight*, and the spell casting mechanic found in *Waltz
    of the Wizard*.
  prefs: []
  type: TYPE_NORMAL
- en: Taking into account what we know about our user (new to VR, looking for immersive
    and visceral experiences, and fans of cyberpunk), what type or types of locomotion
    would be best here? For the new user, natural locomotion seems as though it would
    work the best, since it tends to be intuitive and works well for maintaining immersion.
    So that we aren't limiting our level design to just the player's defined play
    space, we can also choose to integrate teleportation into our control scheme.
    Despite its drawback of not being immersive, I feel that the cyberspace setting
    of our game would actually support the player teleporting around the level.
  prefs: []
  type: TYPE_NORMAL
- en: With these design decisions made, it's time to launch **Unreal Engine 4** (**UE4**)
    and set up our project files!
  prefs: []
  type: TYPE_NORMAL
- en: Setting up new game files in UE4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UE4 is a versatile collection of tools that helps you to create the game of
    your dreams. To get you started down that path, Epic Games provides a collection
    of starter projects to jump-start your games by setting up some of the most important
    features for you. This often includes player character, sample weapons, and other
    necessary files. In this book, we'll begin creating files within the Virtual Reality
    Starter project so that we can make use of some of the basic art assets that this
    project provides. Beyond that, I'll show you how to create the blueprints we'll
    need from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Every game or software project needs to stay organized and we use **naming conventions**
    to do just that. A naming convention is a naming scheme and folder structure that
    ensures that every filename is standardized so that anyone in a particular game
    team can read a filename and understand exactly what they're looking at. You may
    have noticed it while browsing through some of the project files inside UE4\.
    Epic Games provides its naming convention on the Unreal Wiki at [https://wiki.unrealengine.com/Assets_Naming_Convention](https://wiki.unrealengine.com/Assets_Naming_Convention),
    and we'll be using it throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any new game in Unreal needs certain blueprints created to customize the project
    to fit our needs. These files include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GameMode`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GameState`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PlayerPawn`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But how do all of these files interact, and why do we need them? When UE4 launches
    a game, the engine creates two files to help it understand what the rules of the
    game are before it loads and levels or players. These are `GameMode` and `GameState`.
    `GameMode` contains the rules that make our game unique, such as the total number
    of players and how those players connect to the game, as well as default settings,
    such as the default player pawn, player controller, and game state. By creating
    our own game mode, we're taking the first step toward customizing our project.
    The `GameState` file that's loaded after the game starts is designed to track
    everything that's important to our game, such as scores, missions completed, and
    other elements that are relevant to the game as a whole. This isn't for things
    that are player-specific, as there is a different player state. I've often used
    this as a place to store data needed to build levels in a procedural generation
    game, for example. Lastly, we'll need a custom `PlayerPawn`. `PlayerPawn` is the
    player's physical representation in the game and is possessed by our player during
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: Project setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can start creating our custom project files, we need to let Unreal
    create our project base and begin to lay out our folder structure. This will keep
    our files organized as we build *Server 17*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by opening Unreal Engine 4.20.2 and starting a new project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d8d56d8-75be-4ce2-83f2-37f5d156b8a8.png)'
  prefs: []
  type: TYPE_IMG
- en: The screen you're greeted with when you first open UE4
  prefs: []
  type: TYPE_NORMAL
- en: 'Welcome to the new project window. From here, we''ll create our project based
    on the UR template:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose the new project tab from the top of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Blueprint section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the Virtual Reality template near the bottom of the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the middle project setting to Scalable 3D or 2D.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure the project folder is in a space you can find easily. Change the name
    to `VRQuickStart`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Smack that Create Project button, and let''s continue! Now take a look at the
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d149918f-85d6-4a77-9a0f-be10565488ec.png)'
  prefs: []
  type: TYPE_IMG
- en: Much of the interaction with the game engine takes place in the Content Browser
  prefs: []
  type: TYPE_NORMAL
- en: 'With our new project open, look around the interface and locate your Content
    Browser:'
  prefs: []
  type: TYPE_NORMAL
- en: It's time to get organized. One of the first steps is to create our own project
    folder similar to the `VirtualReality` and `VirtualRealityBP` folders Epic Games
    uses. Right-click on the `Content` folder inside the Content Browser and select
    New Folder from the top of the list. Name the new folder `Server17`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on our new folder to enter it. Right-click in the Content Browser and
    select New Folder. Name it `Blueprints`. This will be the home of our new blueprints.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we continue with development, we'll add several more folders to our file
    structure to help to contain and organize our files. Remember to stick to our
    naming convention as we go, as this will be a huge help later when you're adding
    team members or coming back to your project after a leave of absence.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our custom Game Mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our project base and our file structure established, let''s create our
    first custom file: our `GameMode` file. Click on our new `Blueprints` folder,
    and right-click to bring up the menu. From the Create Basic Asset section, choose
    Blueprint Class. This will bring up the Pick Parent Class menu, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d76237df-1cf6-4837-ac62-a006b5c06e30.png)'
  prefs: []
  type: TYPE_IMG
- en: From the Pick Parent Class menu, we can create a new file that extends the functionality
    of a parent file
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to extend the basic `GameMode` class and tell our project to use
    our new file:'
  prefs: []
  type: TYPE_NORMAL
- en: From the Pick Parent Class menu, we can extend any basic class that the engine
    has to offer. Click the Game Mode Base button, and name the new file `S17GameMode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Simply creating `GameMode` isn't enough for the engine to recognize it within
    our project. To ensure that it's used, click on the Settings button of the viewport
    and select Project settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alternately, we could have opened up the World Settings and navigated down to
    the Game Mode section of the menu, and then clicked the *+* button next to the
    GameMode Override. Much like doing math or most creative pursuits, there's more
    than one way to create something inside Unreal. What I'm sharing are the methods
    and processes that I've learned in my career. If you find a different way or a
    better way to do any of the things that I talk about in this book, feel free to
    share them with me and the UE4 development community!
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the Project settings menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cdc6b332-f61b-43a9-af0f-da44990607f5.png)'
  prefs: []
  type: TYPE_IMG
- en: Project settings
  prefs: []
  type: TYPE_NORMAL
- en: Under the Project section of the menu, select Maps & Modes. This section of
    the menu allows you to specify the default map that opens when the editor opens,
    as well as define the default `GameMode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Default Modes section of the menu, use the Default GameMode drop-down
    menu and select S17GameMode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the S17GameMode set as our default, we can now begin to create the rest
    of our custom project files. We'll come back to the Projects setting screen and
    change the defaults further once we have the rest of our pieces in place.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a GameState
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Where `GameMode` is great for setting our game specific rules and storing our
    mode defaults, `GameState` is there to store our important level-wide elements.
    Similar to when we created our `GameMode` class, we''ll need to extend a `GameState`
    class as the base for our custom state. Let''s go back to the Pick Parent Class
    menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a43ddc81-0aa8-4f9f-a082-03ba06919da4.png)'
  prefs: []
  type: TYPE_IMG
- en: Extending GameStateBase to create our custom GameState class
  prefs: []
  type: TYPE_NORMAL
- en: 'Yet, unlike our `GameMode`, we''re going to extend the `GameStateBase` class,
    or the class from which all `GameState` files extend:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the Content Browser and select the Blueprint Class from the Create
    Basic Asset section of the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Pick Parent Class menu, we're going to skip the top portion of the
    menu that lists many of the common extended classes and select the All Classes
    collapsed menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will show us all of the classes that we can extend within the engine. Use
    the search box to find the GameStateBase and select it. Then, press the Select
    button at the bottom of the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name our new game state `S17GameState`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A discussion of the interaction between `GameMode`, `GameState`, and individual
    `PlayerStates` in the context of single and multiplayer games.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom PlayerPawn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have two different files to help with managing the information
    and variables that will be present in our level, it''s time to build our `PlayerPawn`,
    or the physical representation of our player. `PlayerPawn` takes in information
    from the headset and hand controllers and translates that into movement and action
    within the game. Depending on how we choose to represent our player, there are
    several different directions we can go in:'
  prefs: []
  type: TYPE_NORMAL
- en: '**First-person format**: The player has no avatar. The hands and head float
    in the air.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**First person with arms**: Using inverse kinematics, we''re able to give the
    player arms that move with the location of the hand controllers. However, the
    head still floats.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**First person with full body**: Similar to the first person with arms setup,
    this allows the player to be represented by a full body, with inverse kinematics
    used for both the hands and the head.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Third person**: A full third-person character with the player looking down
    on it from a camera set above and behind the player model. This option has been
    known to limit VR sickness but at the cost of immersion. This player setup has
    been successfully used in some games when used in conjunction with a first-person
    option—for example: the first-person view is used when the player is shooting
    and performing actions, but the third-person view is used when the player is moving.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For *Server 17*, the player takes on the role of a cyberpunk hacker trying to
    break into a server to find encrypted file data to steal. Set in the future, and
    the player and the server interact inside a virtual environment created by the
    player's hacking hardware. For this reason, we can represent the player using
    the basic first-person format without sacrificing the experience. This method
    will also help with keeping our game optimized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though we could use the Motion Controller Pawn that''s supplied with the template
    we''re using, let''s go ahead and create one from scratch. Start by creating a
    new `Pawn` class for us to use:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the Content Browser within our `Blueprints` folder and select
    Blueprint Class from the New Basic Asset section of the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We want to create a new Pawn for our player to possess or to receive controller
    input data. Select Pawn from the menu and name it `S17PlayerPawn`. Double-click
    the new Pawn to open the interface, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bb41e610-aa1f-4a51-b49a-5a431e9b6da9.png)'
  prefs: []
  type: TYPE_IMG
- en: The open Pawn class with components showing
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll add a scene component to our player to act as a root object for
    our camera. In the top-left of the Blueprint interface, in the Components panel
    of the menu, click on the Add Component button and search for a Scene Component.
    Create it and name it `HMDRoot`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's time to add our player camera as a child of our new Scene object. With
    `HMDRoot` selected, go back to the Add Component button and find a Camera object.
    Create it and name it `HMDCam`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we need to create a way to track our player's motion controllers so that
    the hands of our player character move and act appropriately. With `HMDRoot` selected,
    create a Motion Controller component with the Add Component menu and name it `MotionController_L`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Repeat the preceding steps to create another Motion Controller component and
    name it `MotionController_R`. The Details panel will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3748807f-78bd-4a75-8ea4-a2d8a2f9085a.png)'
  prefs: []
  type: TYPE_IMG
- en: MotionController_R settings
  prefs: []
  type: TYPE_NORMAL
- en: With our `MotionController_R` component selected, look over at the Details panel
    and find the Motion Controller section of the menu. Change the Motion Source option
    to Right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Programming our custom PlayerPawn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s move on to a bit of programming to ensure that our PlayerPawn is used
    and set up correctly for our player''s hardware. Unreal needs to know where to
    set the Tracking Origin, or where to set the default height of the player, which
    can vary depending on your equipment. For the HTC Vive, the default is to target
    standing VR experiences by using a tracking origin set to the floor. The Oculus
    Rift, on the other hand, is set to target sitting VR experiences by default and
    uses an eye-level tracking origin. It might be easy to simply just set things
    up for the Vive, knowing that this is the platform we''re targeting, but I want
    to create something that might be reusable outside just this project. We''ll add
    the following to our PlayerPawn''s Event Graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e19ad995-eea0-4a5e-9be2-13f0fff1dbfa.png)'
  prefs: []
  type: TYPE_IMG
- en: PlayerPawn Event Graph
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we''ll detect what hardware the player might be using and set the
    Tracking Origin based on our player''s equipment:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the Event Graph tab in the center of our `S17PlayerPawn` and drag an
    execute line out of the Event BeginPlay node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drop it and select the Switch on Name node. Switch on Name is a flow-control
    node, which means that it restricts and directs the flow of execution through
    the blueprint. This node will direct the blueprint to set the tracking origin
    based on the HMD hardware found.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag off the Selection input on the Switch on Name node. Use the search box
    to find Get HMD Device Name. This node represents a function designed to fetch
    the name of the player's HMD hardware.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the Switch on Name node, click the Add Pin button two times. In the Details
    panel, name the pins OculusHMD and SteamVR. Also in the Details panel, turn off
    the option has Default Pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now let's set the criteria for each of our hardware options. Drag off the OculusHMD
    pin and search for the Set Tracking Origin node. Select it, and use the drop-down
    box on the node to select Eye Level tracking.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag off the SteamVR pin, and create another Set Tracking origin node. This
    time, we'll set it to Floor Level tracking.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now click the Save button, so you don't lose your work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With our tracking origin in place, we can now go back into our project settings
    and tell `S17GameMode` to use our `S17PlayerPawn` as our Default Player Pawn.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the beginning of this chapter, we learned one of the best ways to design
    with a particular type of user in mind: the HCD process. When using HCD, we always
    want to keep our player in mind as we make each design decision, ensuring that
    the game we create meets every one of our player''s expectations and is a delight
    to play. This is our goal for *Server 17*. With a few of our design decisions
    in place, we then created our project and began to customize our files by creating
    our custom `GameMode`, `GameState`, and `PlayerPawn` files.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll further flesh out the design for *Server 17* and
    look at the different types of gameplay that are popular in today's current VR
    market. Specifically, we'll focus on gameplay that takes advantage of the unique
    input methods and immersive qualities that VR has to offer and how we can apply
    those to our own game. In the end, we'll decide how our game will work and begin
    building those systems. Soon, we'll have a working prototype that we can show
    off to our players!
  prefs: []
  type: TYPE_NORMAL
