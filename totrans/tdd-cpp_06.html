<html><head></head><body>
		<div><h1 id="_idParaDest-57" class="chapter-number" lang="en-GB"><a id="_idTextAnchor059"/>6</h1>
			<h1 id="_idParaDest-58" lang="en-GB"><a id="_idTextAnchor060"/>Explore Improvements Early</h1>
			<p lang="en-GB">We’ve come a long way with the testing library and have been using TDD the entire time to get us here. Sometimes, it’s important to explore new ideas before a project gets too far. After creating anything, we’ll have insights that we didn’t have at the beginning. And after working with a design for a while, we’ll develop a feel for what we like and what we might want to change. I encourage you to take this time to reflect on a design before proceeding.</p>
			<p lang="en-GB">We have something that is working and a bit of experience using it, so is there anything that we can improve?</p>
			<p lang="en-GB">This approach is like a higher-level process of TDD, as explained in <a href="B18567_03.xhtml#_idTextAnchor031"><em class="italic" lang="">Chapter 3</em></a>, <em class="italic" lang="">The TDD Process</em>. First, we work out how we’d like to use something, then get it built, then do the minimal amount of work to get it working and the tests passing, and then enhance the design. We’ve got many things working now, but we haven’t gone so far yet where it would be too hard to change. We’re going to look at ways that the overall design could be enhanced.</p>
			<p lang="en-GB">At this point, it’s also a good idea to look around at other similar solutions and compare them. Get ideas. And try some new things to see whether they might be better. I’ve done this and would like to explore two topics in this chapter:</p>
			<ul>
				<li lang="en-GB">Can we use a new feature of C++ 20 to get line numbers instead of using <code>__LINE__</code>?</li>
				<li lang="en-GB">What would the tests look like if we used lambdas?</li>
			</ul>
			<p lang="en-GB">By the end of this chapter, you’ll understand the importance of and the process involved in exploring improvements early on in the design of your projects. Even if you don’t always decide to accept new ideas and make changes, your project will be better because you have taken the time to consider alternatives.</p>
			<h1 id="_idParaDest-59" lang="en-GB"><a id="_idTextAnchor061"/>Technical requirements</h1>
			<p lang="en-GB">The code in this chapter uses standard C++, and we will try out a feature introduced in C++ 20. The code is based on and continues from the previous chapters.</p>
			<p lang="en-GB">You can find all of the code for this chapter at the following GitHub repository:</p>
			<p lang="en-GB"><a href="https://github.com/PacktPublishing/Test-Driven-Development-with-CPP">https://github.com/PacktPublishing/Test-Driven-Development-with-CPP</a></p>
			<h1 id="_idParaDest-60" lang="en-GB"><a id="_idTextAnchor062"/>Getting line numbers without macros</h1>
			<p lang="en-GB">C++ 20 includes a new class that<a id="_idIndexMarker164"/> will help us get line numbers. In fact, it has a lot more information than just the line number. It includes the name of the file, the function name, and even the column number. However, we only need the line<a id="_idIndexMarker165"/> number. Note that at the time of writing this book, the implementation of this new class for my compiler has a bug. The end result is that I have had to put the code back to the way it was before the changes described in this section.</p>
			<p lang="en-GB">The new class is called <code>source_location</code>, and once it finally works correctly, we can change all of the existing <code>confirm</code> functions so that they accept <code>std::source_location</code> instead of the int for the line number. One example of an existing <code>confirm</code> function looks like this:</p>
			<pre class="source-code" lang="en-GB">
inline void confirm (
    bool expected,
    bool actual,
    int line)
{
    if (actual != expected)
    {
        throw BoolConfirmException(expected, line);
    }
}</pre>
			<p lang="en-GB">We can eventually update the confirm functions to use <code>std::source_location</code> by changing all of the <code>confirm</code> functions, including the template override, to be similar to the following:</p>
			<pre class="source-code" lang="en-GB">
inline void confirm (
    bool expected, 
    bool actual,
    const std::source_location location = 
        std::source_location::current())
{
    if (actual != expected)
    {
        throw BoolConfirmException(expected, location.line());
    }
}</pre>
			<p lang="en-GB">We’re not going to be making these changes right now because of the bug. The code does work as long as there is only a single source file in the project that tries to use <code>source_location</code>. The moment more than one source file tries to use <code>source_location</code>, there is a linker warning and the line method returns bad data. The bug should eventually get fixed, and I’m leaving this section in the book because it is a better approach. Depending on<a id="_idIndexMarker166"/> what compiler you are using, you might be able to start using <code>source_location</code> now.</p>
			<p lang="en-GB">Not only does the last parameter type and name change, but the usage needs to change when the line number is passed to the exception when it’s thrown. Notice how the new parameter includes a default value that gets set to the current location. The default parameter value means we no<a id="_idIndexMarker167"/> longer need to pass anything for the line number. The new location will get a default value that includes the current line number.</p>
			<p lang="en-GB">We need to include the header file for <code>source_location</code> at the top of <code>Test.h</code>, as follows:</p>
			<pre class="source-code" lang="en-GB">
#include &lt;ostream&gt;
#include &lt;source_location&gt;
#include &lt;string_view&gt;
#include &lt;vector&gt;</pre>
			<p lang="en-GB">The macros that call <code>confirm</code> need to be updated to no longer worry about the line number:</p>
			<pre class="source-code" lang="en-GB">
#define CONFIRM_FALSE( actual ) \
    MereTDD::confirm(false, actual)
#define CONFIRM_TRUE( actual ) \
    MereTDD::confirm(true, actual)
#define CONFIRM( expected, actual ) \
    MereTDD::confirm(expected, actual)</pre>
			<p lang="en-GB">Once <code>source_location</code> works properly, then we won’t really need these macros anymore. The first two are still useful because they eliminate the need to specify the expected bool value. Additionally, all three are slightly useful because they wrap up the specification of the <code>MereTDD</code> namespace. Even though we won’t technically need to keep using the macros, I like to keep using them because I think that the all-caps names help the confirmations stand out in the tests better.</p>
			<p lang="en-GB">This improvement would have<a id="_idIndexMarker168"/> been minor and limited to just the <code>confirm</code> functions and macros. So, should we still move to C++ 20 even though we can’t yet use <code>source_location</code>? I think so. If nothing else, this bug shows that changes are always being made to the standard libraries, and using the latest compiler and standard library is normally the <a id="_idIndexMarker169"/>best choice. Plus, there will be features we will use later in the book that are only found in C++20. For example, we’ll be using the <code>std::map</code> class and a useful method that was added in C++20 to determine whether the map contains an element already. We’ll be using <em class="italic" lang="">concepts</em> in <a href="B18567_12.xhtml#_idTextAnchor123"><em class="italic" lang="">Chapter 12</em></a>, <em class="italic" lang="">Creating Better Test Confirmations</em>, which are only found in C++20.</p>
			<p lang="en-GB">The next improvement will be a bit more involved.</p>
			<h1 id="_idParaDest-61" lang="en-GB"><a id="_idTextAnchor063"/>Exploring lambdas for tests</h1>
			<p lang="en-GB">It’s getting more and more<a id="_idIndexMarker170"/> common for developers to avoid macros in their code. And I agree that there is almost no need for macros anymore. With <code>std::source_location</code> from the previous section, one of the last reasons to use macros has been eliminated.</p>
			<p lang="en-GB">Some companies might <a id="_idIndexMarker171"/>even have rules against using macros anywhere in their code. I think that’s a bit too much especially given the trouble with <code>std::source_location</code>. Macros still have the ability to wrap up code so that it can be inserted instead of the macro itself.</p>
			<p lang="en-GB">As the previous section shows, the <code>CONFIRM_TRUE</code>, <code>CONFIRM_FALSE</code>, and <code>CONFIRM</code> macros may no longer be absolutely necessary. I still like them. But if you don’t want to use them, then you don’t have to – at least once <code>std::source_location</code> works reliably in a large project.</p>
			<p lang="en-GB">The <code>TEST</code> and <code>TEST_EX</code> macros are still needed because they wrap up the declaration of the derived test classes, give them unique names, and set up the code so that the test body can follow. The result looks like we’re declaring a simple function. This is the effect we want. A test should be simple to write. What we have now is about as simple as it gets. But the design uses macros. Is there anything we can do to remove the need for the <code>TEST</code> and <code>TEST_EX</code> macros?</p>
			<p lang="en-GB">Whatever changes we make, we should keep the simplicity of declaring a test in <code>Creation.cpp</code> so that it looks similar to the following:</p>
			<pre class="source-code" lang="en-GB">
TEST("Test can be created")
{
}</pre>
			<p lang="en-GB">What we really need is <a id="_idIndexMarker172"/>something that introduces a test, gives it a name, lets the test register itself, and then lets us write the body of the test function. The <code>TEST</code> macro<a id="_idIndexMarker173"/> provides this ability by hiding the declaration of a global instance of a class derived from the <code>TestBase</code> class. This declaration is left unfinished by the macro, so we can provide the body of the test function inside the curly braces. The other <code>TEST_EX</code> macro does something similar with the addition of catching the exception provided to the macro.</p>
			<p lang="en-GB">There is another way to write a function body in C++ without giving the function body a name. And that is to declare a <em class="italic" lang="">lambda</em>. What would a test look like if we stopped using the <code>TEST</code> macro and implemented the test function with a lambda instead? For now, let’s just focus on tests that do not expect an exception to be thrown. The following is what an empty test might look like:</p>
			<pre class="source-code" lang="en-GB">
Test test123("Test can be created") = [] ()
{
};</pre>
			<p lang="en-GB">With this example, I’m trying to stick to the syntax needed by C++. This assumes we have a class called <code>Test</code> that we want to create an instance of. In this design, tests would reuse the <code>Test</code> class instead of defining a new class. The <code>Test</code> class would override the <code>operator =</code> method to accept a lambda. We need to give the instance a name so that the example uses <code>test123</code>. Why <code>test123</code>? Well, any object instance created still needs a unique name, so I’m using a number to provide something unique. We would need to continue using a macro to generate a unique number based on the line number if we decided to use this design. So, while this design avoids a new derived class for each test, it creates a new lambda for each test instead.</p>
			<p lang="en-GB">There’s a bigger problem with this idea. The code doesn’t compile. It might be possible to get the code to compile within a function. But as a declaration of a global <code>Test</code> instance, we can’t call an assignment operator. The best I can come up with would be to put the lambda inside the constructor as a new argument, as follows:</p>
			<pre class="source-code" lang="en-GB">
Test test123("Test can be created", [] ()
{
});</pre>
			<p lang="en-GB">While it works for this test, it causes problems in the expected failure tests when we try to call the <code>setExpectedFailureReason</code> method because <code>setExpectedFailureReason</code> is not in scope within the lambda body. Also, we’re getting further away from the simple way we have now of declaring a test. The extra lambda syntax and the closing <a id="_idIndexMarker174"/>parenthesis and semicolon at the end make this harder to get right.</p>
			<p lang="en-GB">I’ve seen at least one<a id="_idIndexMarker175"/> other test library that does use lambdas and appears to avoid the need to declare a unique name and, thereby, avoid the need for a macro with something like this:</p>
			<pre class="source-code" lang="en-GB">
int main ()
{
    Test("Test can be created") = [] ()
    {
    };
    return 0;
};</pre>
			<p lang="en-GB">But what this actually does is call a <em class="italic" lang="">function</em> named <code>Test</code> and pass the string literal as an argument. Then, the function returns a temporary object that overrides <code>operator =</code>, which is called to accept the lambda. The only place functions can be called is within other functions or class methods. That means a solution like this needs to declare tests from within a function, and the tests cannot be declared globally as instances like we are doing.</p>
			<p lang="en-GB">Usually, this means you declare all your tests from within the <code>main</code> function. Or you declare your tests as simple functions and call those functions from within <code>main</code>. Either way, you end up modifying <code>main</code> to call every test function. If you forget to modify <code>main</code>, then your test won’t get run. We’re going to keep <code>main</code> simple and uncluttered. The only thing <code>main</code> will do in our solution is run the tests that have been registered.</p>
			<p lang="en-GB">Even though lambdas won’t work for us because of the added complexity and because of the inability to call test methods such as <code>setExpectedFailureReason</code>, we can improve the current design a bit. The <code>TEST</code> and, especially, <code>TEST_EX</code> macros are doing work that we can remove from the macros.</p>
			<p lang="en-GB">Let’s start by modifying <a id="_idIndexMarker176"/>the <code>TestBase</code> class in <code>Test.h</code> so that it registers itself instead of doing the registration with derived classes in the macros. Also, we need to move the <code>getTests</code> function right before the <code>TestBase</code> class. And we need to forward declare<a id="_idIndexMarker177"/> the <code>TestBase</code> class since <code>getTests</code> uses a pointer to <code>TestBase</code>, like this:</p>
			<pre class="source-code" lang="en-GB">
class TestBase;
inline std::vector&lt;TestBase *&gt; &amp; getTests ()
{
    static std::vector&lt;TestBase *&gt; tests;
    return tests;
}
class TestBase
{
public:
    TestBase (std::string_view name)
    : mName(name), mPassed(true), mConfirmLocation(-1)
    {
        getTests().push_back(this);
    }</pre>
			<p lang="en-GB">We’ll keep the rest of <code>TestBase</code> unchanged because it handles properties such as the name and whether the test passed or not. We still have derived classes, but the goal of this simplification is to remove any work that the <code>TEST</code> and <code>TEST_EX</code> macros need to perform.</p>
			<p lang="en-GB">Most of the work that the <code>TEST</code> macro needs to do is to declare a derived class with a <code>run</code> method that will be filled in. The need to register the test is now handled by <code>TestBase</code>. The <code>TEST_EX</code> macro can be simplified further by creating another class called <code>TestExBase</code>, which will deal with the expected exception. Declare this new class right after <code>TestBase</code>. It looks like this:</p>
			<pre class="source-code" lang="en-GB">
template &lt;typename ExceptionT&gt;
class TestExBase : public TestBase
{
public:
    TestExBase (std::string_view name,
        std::string_view exceptionName)
    : TestBase(name), mExceptionName(exceptionName)
    { }
    void runEx () override
    {
        try
        {
            run();
        }
        catch (ExceptionT const &amp;)
        {
            return;
        }
        throw MissingException(mExceptionName);
    }
private:
    std::string mExceptionName;
};</pre>
			<p lang="en-GB">The <code>TestExBase</code> class <a id="_idIndexMarker178"/>derives from <code>TestBase</code> and is a template class designed to catch the expected exception. This code is currently written into <code>TEST_EX</code>, and we <a id="_idIndexMarker179"/>will change <code>TEST_EX</code> to use this new base class instead.</p>
			<p lang="en-GB">We’re ready to simplify the <code>TEST</code> and <code>TEST_EX</code> macros. The new <code>TEST</code> macro looks like this:</p>
			<pre class="source-code" lang="en-GB">
#define TEST( testName ) \
namespace { \
class MERETDD_CLASS : public MereTDD::TestBase \
{ \
public: \
    MERETDD_CLASS (std::string_view name) \
    : TestBase(name) \
    { } \
    void run () override; \
}; \
} /* end of unnamed namespace */ \
MERETDD_CLASS MERETDD_INSTANCE(testName); \
void MERETDD_CLASS::run ()</pre>
			<p lang="en-GB">It’s slightly simpler than before. The constructor no longer needs to have code in the body because the registration is done in the<a id="_idIndexMarker180"/> base class.</p>
			<p lang="en-GB">The bigger <a id="_idIndexMarker181"/>simplification is in the <code>TEST_EX</code> macro, which looks like this:</p>
			<pre class="source-code" lang="en-GB">
#define TEST_EX( testName, exceptionType ) \
namespace { \
class MERETDD_CLASS : public MereTDD::TestExBase&lt;exceptionType&gt; \
{ \
public: \
    MERETDD_CLASS (std::string_view name, \
        std::string_view exceptionName) \
    : TestExBase(name, exceptionName) \
    { } \
    void run () override; \
}; \
} /* end of unnamed namespace */ \
MERETDD_CLASS MERETDD_INSTANCE(testName, #exceptionType); \
void MERETDD_CLASS::run ()</pre>
			<p lang="en-GB">It’s a lot simpler than before because all the exception handling is done in its direct base class. Notice how the macro still needs to use the <code>#</code> operator for <code>exceptionType</code> when constructing the instance. Additionally, notice how it uses <code>exceptionType</code> without the <code>#</code> operator when specifying the template type to derive from.</p>
			<h1 id="_idParaDest-62" lang="en-GB"><a id="_idTextAnchor064"/>Summary</h1>
			<p lang="en-GB">This chapter explored ways in which to improve the test library by making use of a new feature in C++ 20 to get line numbers from the standard library instead of from the preprocessor. Even though the new code doesn’t work right now, it will eventually make the <code>CONFIRM_TRUE</code>, <code>CONFIRM_FALSE</code>, and <code>CONFIRM</code> macros optional. You will no longer have to use the macros. But I still like to use them because they help wrap up code that is easy to get wrong. And the macros are easier to spot in the tests because they use all capital letters.</p>
			<p lang="en-GB">We also explored a trend to avoid macros when declaring tests and what it would look like if we used lambdas instead. The approach almost worked with a more complicated test declaration. The extra complexity doesn’t matter though because the design did not work for all the tests.</p>
			<p lang="en-GB">It is still valuable for you to read about the proposed changes. You can learn about how other test libraries might work and understand why this book explains a solution that embraces macros.</p>
			<p lang="en-GB">This chapter has also shown you how to follow the TDD process at a higher level. The step in the process to enhance a test can be applied to an overall design. We were able to improve and simplify the <code>TEST</code> and <code>TEST_EX</code> macros, which makes all of the tests better.</p>
			<p lang="en-GB">The next chapter will explore what will be needed to add code that will run before and after the tests to help get things ready for the tests and clean things up after the tests finish.</p>
		</div>
	</body></html>