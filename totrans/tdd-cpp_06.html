<html><head></head><body>
		<div id="_idContainer013">
			<h1 id="_idParaDest-57" class="chapter-number" lang="en-GB"><a id="_idTextAnchor059"/>6</h1>
			<h1 id="_idParaDest-58" lang="en-GB"><a id="_idTextAnchor060"/>Explore Improvements Early</h1>
			<p lang="en-GB">We’ve come a long way with the testing library and have been using TDD the entire time to get us here. Sometimes, it’s important to explore new ideas before a project gets too far. After creating anything, we’ll have insights that we didn’t have at the beginning. And after working with a design for a while, we’ll develop a feel for what we like and what we might want to change. I encourage you to take this time to reflect on a design <span class="No-Break" lang="">before proceeding.</span></p>
			<p lang="en-GB">We have something that is working and a bit of experience using it, so is there anything that we <span class="No-Break" lang="">can improve?</span></p>
			<p lang="en-GB">This approach is like a higher-level process of TDD, as explained in <a href="B18567_03.xhtml#_idTextAnchor031"><span class="No-Break" lang=""><em class="italic" lang="">Chapter 3</em></span></a>, <em class="italic" lang="">The TDD Process</em>. First, we work out how we’d like to use something, then get it built, then do the minimal amount of work to get it working and the tests passing, and then enhance the design. We’ve got many things working now, but we haven’t gone so far yet where it would be too hard to change. We’re going to look at ways that the overall design could <span class="No-Break" lang="">be enhanced.</span></p>
			<p lang="en-GB">At this point, it’s also a good idea to look around at other similar solutions and compare them. Get ideas. And try some new things to see whether they might be better. I’ve done this and would like to explore two topics in <span class="No-Break" lang="">this chapter:</span></p>
			<ul>
				<li lang="en-GB">Can we use a new feature of C++ 20 to get line numbers instead of <span class="No-Break" lang="">using </span><span class="No-Break" lang=""><strong class="source-inline" lang="">__LINE__</strong></span><span class="No-Break" lang="">?</span></li>
				<li lang="en-GB">What would the tests look like if we <span class="No-Break" lang="">used lambdas?</span></li>
			</ul>
			<p lang="en-GB">By the end of this chapter, you’ll understand the importance of and the process involved in exploring improvements early on in the design of your projects. Even if you don’t always decide to accept new ideas and make changes, your project will be better because you have taken the time to <span class="No-Break" lang="">consider alternatives.</span></p>
			<h1 id="_idParaDest-59" lang="en-GB"><a id="_idTextAnchor061"/>Technical requirements</h1>
			<p lang="en-GB">The code in this chapter uses standard C++, and we will try out a feature introduced in C++ 20. The code is based on and continues from the <span class="No-Break" lang="">previous chapters.</span></p>
			<p lang="en-GB">You can find all of the code for this chapter at the following <span class="No-Break" lang="">GitHub repository:</span></p>
			<p lang="en-GB"><a href="https://github.com/PacktPublishing/Test-Driven-Development-with-CPP"><span class="No-Break" lang="">https://github.com/PacktPublishing/Test-Driven-Development-with-CPP</span></a></p>
			<h1 id="_idParaDest-60" lang="en-GB"><a id="_idTextAnchor062"/>Getting line numbers without macros</h1>
			<p lang="en-GB">C++ 20 includes a new class that<a id="_idIndexMarker164"/> will help us get line numbers. In fact, it has a lot more information than just the line number. It includes the name of the file, the function name, and even the column number. However, we only need the line<a id="_idIndexMarker165"/> number. Note that at the time of writing this book, the implementation of this new class for my compiler has a bug. The end result is that I have had to put the code back to the way it was before the changes described in <span class="No-Break" lang="">this section.</span></p>
			<p lang="en-GB">The new class is called <strong class="source-inline" lang="">source_location</strong>, and once it finally works correctly, we can change all of the existing <strong class="source-inline" lang="">confirm</strong> functions so that they accept <strong class="source-inline" lang="">std::source_location</strong> instead of the int for the line number. One example of an existing <strong class="source-inline" lang="">confirm</strong> function looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
inline void confirm (
    bool expected,
    bool actual,
    int line)
{
    if (actual != expected)
    {
        throw BoolConfirmException(expected, line);
    }
}</pre>
			<p lang="en-GB">We can eventually update the confirm functions to use <strong class="source-inline" lang="">std::source_location</strong> by changing all of the <strong class="source-inline" lang="">confirm</strong> functions, including the template override, to be similar to <span class="No-Break" lang="">the following:</span></p>
			<pre class="source-code" lang="en-GB">
inline void confirm (
    bool expected, 
    bool actual,
    const std::source_location location = 
        std::source_location::current())
{
    if (actual != expected)
    {
        throw BoolConfirmException(expected, location.line());
    }
}</pre>
			<p lang="en-GB">We’re not going to be making these changes right now because of the bug. The code does work as long as there is only a single source file in the project that tries to use <strong class="source-inline" lang="">source_location</strong>. The moment more than one source file tries to use <strong class="source-inline" lang="">source_location</strong>, there is a linker warning and the line method returns bad data. The bug should eventually get fixed, and I’m leaving this section in the book because it is a better approach. Depending on<a id="_idIndexMarker166"/> what compiler you are using, you might be able to start using <span class="No-Break" lang=""><strong class="source-inline" lang="">source_location</strong></span><span class="No-Break" lang=""> now.</span></p>
			<p lang="en-GB">Not only does the last parameter type and name change, but the usage needs to change when the line number is passed to the exception when it’s thrown. Notice how the new parameter includes a default value that gets set to the current location. The default parameter value means we no<a id="_idIndexMarker167"/> longer need to pass anything for the line number. The new location will get a default value that includes the current <span class="No-Break" lang="">line number.</span></p>
			<p lang="en-GB">We need to include the header file for <strong class="source-inline" lang="">source_location</strong> at the top of <strong class="source-inline" lang="">Test.h</strong>, <span class="No-Break" lang="">as follows:</span></p>
			<pre class="source-code" lang="en-GB">
#include &lt;ostream&gt;
#include &lt;source_location&gt;
#include &lt;string_view&gt;
#include &lt;vector&gt;</pre>
			<p lang="en-GB">The macros that call <strong class="source-inline" lang="">confirm</strong> need to be updated to no longer worry about the <span class="No-Break" lang="">line number:</span></p>
			<pre class="source-code" lang="en-GB">
#define CONFIRM_FALSE( actual ) \
    MereTDD::confirm(false, actual)
#define CONFIRM_TRUE( actual ) \
    MereTDD::confirm(true, actual)
#define CONFIRM( expected, actual ) \
    MereTDD::confirm(expected, actual)</pre>
			<p lang="en-GB">Once <strong class="source-inline" lang="">source_location</strong> works properly, then we won’t really need these macros anymore. The first two are still useful because they eliminate the need to specify the expected bool value. Additionally, all three are slightly useful because they wrap up the specification of the <strong class="source-inline" lang="">MereTDD</strong> namespace. Even though we won’t technically need to keep using the macros, I like to keep using them because I think that the all-caps names help the confirmations stand out in the <span class="No-Break" lang="">tests better.</span></p>
			<p lang="en-GB">This improvement would have<a id="_idIndexMarker168"/> been minor and limited to just the <strong class="source-inline" lang="">confirm</strong> functions and macros. So, should we still move to C++ 20 even though we can’t yet use <strong class="source-inline" lang="">source_location</strong>? I think so. If nothing else, this bug shows that changes are always being made to the standard libraries, and using the latest compiler and standard library is normally the <a id="_idIndexMarker169"/>best choice. Plus, there will be features we will use later in the book that are only found in C++20. For example, we’ll be using the <strong class="source-inline" lang="">std::map</strong> class and a useful method that was added in C++20 to determine whether the map contains an element already. We’ll be using <em class="italic" lang="">concepts</em> in <a href="B18567_12.xhtml#_idTextAnchor123"><span class="No-Break" lang=""><em class="italic" lang="">Chapter 12</em></span></a>, <em class="italic" lang="">Creating Better Test Confirmations</em>, which are only found <span class="No-Break" lang="">in C++20.</span></p>
			<p lang="en-GB">The next improvement will be a bit <span class="No-Break" lang="">more involved.</span></p>
			<h1 id="_idParaDest-61" lang="en-GB"><a id="_idTextAnchor063"/>Exploring lambdas for tests</h1>
			<p lang="en-GB">It’s getting more and more<a id="_idIndexMarker170"/> common for developers to avoid macros in their code. And I agree that there is almost no need for macros anymore. With <strong class="source-inline" lang="">std::source_location</strong> from the previous section, one of the last reasons to use macros has <span class="No-Break" lang="">been eliminated.</span></p>
			<p lang="en-GB">Some companies might <a id="_idIndexMarker171"/>even have rules against using macros anywhere in their code. I think that’s a bit too much especially given the trouble with <strong class="source-inline" lang="">std::source_location</strong>. Macros still have the ability to wrap up code so that it can be inserted instead of the <span class="No-Break" lang="">macro itself.</span></p>
			<p lang="en-GB">As the previous section shows, the <strong class="source-inline" lang="">CONFIRM_TRUE</strong>, <strong class="source-inline" lang="">CONFIRM_FALSE</strong>, and <strong class="source-inline" lang="">CONFIRM</strong> macros may no longer be absolutely necessary. I still like them. But if you don’t want to use them, then you don’t have to – at least once <strong class="source-inline" lang="">std::source_location</strong> works reliably in a <span class="No-Break" lang="">large project.</span></p>
			<p lang="en-GB">The <strong class="source-inline" lang="">TEST</strong> and <strong class="source-inline" lang="">TEST_EX</strong> macros are still needed because they wrap up the declaration of the derived test classes, give them unique names, and set up the code so that the test body can follow. The result looks like we’re declaring a simple function. This is the effect we want. A test should be simple to write. What we have now is about as simple as it gets. But the design uses macros. Is there anything we can do to remove the need for the <strong class="source-inline" lang="">TEST</strong> and <span class="No-Break" lang=""><strong class="source-inline" lang="">TEST_EX</strong></span><span class="No-Break" lang=""> macros?</span></p>
			<p lang="en-GB">Whatever changes we make, we should keep the simplicity of declaring a test in <strong class="source-inline" lang="">Creation.cpp</strong> so that it looks similar to <span class="No-Break" lang="">the following:</span></p>
			<pre class="source-code" lang="en-GB">
TEST("Test can be created")
{
}</pre>
			<p lang="en-GB">What we really need is <a id="_idIndexMarker172"/>something that introduces a test, gives it a name, lets the test register itself, and then lets us write the body of the test function. The <strong class="source-inline" lang="">TEST</strong> macro<a id="_idIndexMarker173"/> provides this ability by hiding the declaration of a global instance of a class derived from the <strong class="source-inline" lang="">TestBase</strong> class. This declaration is left unfinished by the macro, so we can provide the body of the test function inside the curly braces. The other <strong class="source-inline" lang="">TEST_EX</strong> macro does something similar with the addition of catching the exception provided to <span class="No-Break" lang="">the macro.</span></p>
			<p lang="en-GB">There is another way to write a function body in C++ without giving the function body a name. And that is to declare a <em class="italic" lang="">lambda</em>. What would a test look like if we stopped using the <strong class="source-inline" lang="">TEST</strong> macro and implemented the test function with a lambda instead? For now, let’s just focus on tests that do not expect an exception to be thrown. The following is what an empty test might <span class="No-Break" lang="">look like:</span></p>
			<pre class="source-code" lang="en-GB">
Test test123("Test can be created") = [] ()
{
};</pre>
			<p lang="en-GB">With this example, I’m trying to stick to the syntax needed by C++. This assumes we have a class called <strong class="source-inline" lang="">Test</strong> that we want to create an instance of. In this design, tests would reuse the <strong class="source-inline" lang="">Test</strong> class instead of defining a new class. The <strong class="source-inline" lang="">Test</strong> class would override the <strong class="source-inline" lang="">operator =</strong> method to accept a lambda. We need to give the instance a name so that the example uses <strong class="source-inline" lang="">test123</strong>. Why <strong class="source-inline" lang="">test123</strong>? Well, any object instance created still needs a unique name, so I’m using a number to provide something unique. We would need to continue using a macro to generate a unique number based on the line number if we decided to use this design. So, while this design avoids a new derived class for each test, it creates a new lambda for each <span class="No-Break" lang="">test instead.</span></p>
			<p lang="en-GB">There’s a bigger problem with this idea. The code doesn’t compile. It might be possible to get the code to compile within a function. But as a declaration of a global <strong class="source-inline" lang="">Test</strong> instance, we can’t call an assignment operator. The best I can come up with would be to put the lambda inside the constructor as a new argument, <span class="No-Break" lang="">as follows:</span></p>
			<pre class="source-code" lang="en-GB">
Test test123("Test can be created", [] ()
{
});</pre>
			<p lang="en-GB">While it works for this test, it causes problems in the expected failure tests when we try to call the <strong class="source-inline" lang="">setExpectedFailureReason</strong> method because <strong class="source-inline" lang="">setExpectedFailureReason</strong> is not in scope within the lambda body. Also, we’re getting further away from the simple way we have now of declaring a test. The extra lambda syntax and the closing <a id="_idIndexMarker174"/>parenthesis and semicolon at the end make this harder to <span class="No-Break" lang="">get right.</span></p>
			<p lang="en-GB">I’ve seen at least one<a id="_idIndexMarker175"/> other test library that does use lambdas and appears to avoid the need to declare a unique name and, thereby, avoid the need for a macro with something <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
int main ()
{
    Test("Test can be created") = [] ()
    {
    };
    return 0;
};</pre>
			<p lang="en-GB">But what this actually does is call a <em class="italic" lang="">function</em> named <strong class="source-inline" lang="">Test</strong> and pass the string literal as an argument. Then, the function returns a temporary object that overrides <strong class="source-inline" lang="">operator =</strong>, which is called to accept the lambda. The only place functions can be called is within other functions or class methods. That means a solution like this needs to declare tests from within a function, and the tests cannot be declared globally as instances like we <span class="No-Break" lang="">are doing.</span></p>
			<p lang="en-GB">Usually, this means you declare all your tests from within the <strong class="source-inline" lang="">main</strong> function. Or you declare your tests as simple functions and call those functions from within <strong class="source-inline" lang="">main</strong>. Either way, you end up modifying <strong class="source-inline" lang="">main</strong> to call every test function. If you forget to modify <strong class="source-inline" lang="">main</strong>, then your test won’t get run. We’re going to keep <strong class="source-inline" lang="">main</strong> simple and uncluttered. The only thing <strong class="source-inline" lang="">main</strong> will do in our solution is run the tests that have <span class="No-Break" lang="">been registered.</span></p>
			<p lang="en-GB">Even though lambdas won’t work for us because of the added complexity and because of the inability to call test methods such as <strong class="source-inline" lang="">setExpectedFailureReason</strong>, we can improve the current design a bit. The <strong class="source-inline" lang="">TEST</strong> and, especially, <strong class="source-inline" lang="">TEST_EX</strong> macros are doing work that we can remove from <span class="No-Break" lang="">the macros.</span></p>
			<p lang="en-GB">Let’s start by modifying <a id="_idIndexMarker176"/>the <strong class="source-inline" lang="">TestBase</strong> class in <strong class="source-inline" lang="">Test.h</strong> so that it registers itself instead of doing the registration with derived classes in the macros. Also, we need to move the <strong class="source-inline" lang="">getTests</strong> function right before the <strong class="source-inline" lang="">TestBase</strong> class. And we need to forward declare<a id="_idIndexMarker177"/> the <strong class="source-inline" lang="">TestBase</strong> class since <strong class="source-inline" lang="">getTests</strong> uses a pointer to <strong class="source-inline" lang="">TestBase</strong>, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
class TestBase;
inline std::vector&lt;TestBase *&gt; &amp; getTests ()
{
    static std::vector&lt;TestBase *&gt; tests;
    return tests;
}
class TestBase
{
public:
    TestBase (std::string_view name)
    : mName(name), mPassed(true), mConfirmLocation(-1)
    {
        getTests().push_back(this);
    }</pre>
			<p lang="en-GB">We’ll keep the rest of <strong class="source-inline" lang="">TestBase</strong> unchanged because it handles properties such as the name and whether the test passed or not. We still have derived classes, but the goal of this simplification is to remove any work that the <strong class="source-inline" lang="">TEST</strong> and <strong class="source-inline" lang="">TEST_EX</strong> macros need <span class="No-Break" lang="">to perform.</span></p>
			<p lang="en-GB">Most of the work that the <strong class="source-inline" lang="">TEST</strong> macro needs to do is to declare a derived class with a <strong class="source-inline" lang="">run</strong> method that will be filled in. The need to register the test is now handled by <strong class="source-inline" lang="">TestBase</strong>. The <strong class="source-inline" lang="">TEST_EX</strong> macro can be simplified further by creating another class called <strong class="source-inline" lang="">TestExBase</strong>, which will deal with the expected exception. Declare this new class right after <strong class="source-inline" lang="">TestBase</strong>. It looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
template &lt;typename ExceptionT&gt;
class TestExBase : public TestBase
{
public:
    TestExBase (std::string_view name,
        std::string_view exceptionName)
    : TestBase(name), mExceptionName(exceptionName)
    { }
    void runEx () override
    {
        try
        {
            run();
        }
        catch (ExceptionT const &amp;)
        {
            return;
        }
        throw MissingException(mExceptionName);
    }
private:
    std::string mExceptionName;
};</pre>
			<p lang="en-GB">The <strong class="source-inline" lang="">TestExBase</strong> class <a id="_idIndexMarker178"/>derives from <strong class="source-inline" lang="">TestBase</strong> and is a template class designed to catch the expected exception. This code is currently written into <strong class="source-inline" lang="">TEST_EX</strong>, and we <a id="_idIndexMarker179"/>will change <strong class="source-inline" lang="">TEST_EX</strong> to use this new base <span class="No-Break" lang="">class instead.</span></p>
			<p lang="en-GB">We’re ready to simplify the <strong class="source-inline" lang="">TEST</strong> and <strong class="source-inline" lang="">TEST_EX</strong> macros. The new <strong class="source-inline" lang="">TEST</strong> macro looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
#define TEST( testName ) \
namespace { \
class MERETDD_CLASS : public MereTDD::TestBase \
{ \
public: \
    MERETDD_CLASS (std::string_view name) \
    : TestBase(name) \
    { } \
    void run () override; \
}; \
} /* end of unnamed namespace */ \
MERETDD_CLASS MERETDD_INSTANCE(testName); \
void MERETDD_CLASS::run ()</pre>
			<p lang="en-GB">It’s slightly simpler than before. The constructor no longer needs to have code in the body because the registration is done in the<a id="_idIndexMarker180"/> <span class="No-Break" lang="">base class.</span></p>
			<p lang="en-GB">The bigger <a id="_idIndexMarker181"/>simplification is in the <strong class="source-inline" lang="">TEST_EX</strong> macro, which looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
#define TEST_EX( testName, exceptionType ) \
namespace { \
class MERETDD_CLASS : public MereTDD::TestExBase&lt;exceptionType&gt; \
{ \
public: \
    MERETDD_CLASS (std::string_view name, \
        std::string_view exceptionName) \
    : TestExBase(name, exceptionName) \
    { } \
    void run () override; \
}; \
} /* end of unnamed namespace */ \
MERETDD_CLASS MERETDD_INSTANCE(testName, #exceptionType); \
void MERETDD_CLASS::run ()</pre>
			<p lang="en-GB">It’s a lot simpler than before because all the exception handling is done in its direct base class. Notice how the macro still needs to use the <strong class="source-inline" lang="">#</strong> operator for <strong class="source-inline" lang="">exceptionType</strong> when constructing the instance. Additionally, notice how it uses <strong class="source-inline" lang="">exceptionType</strong> without the <strong class="source-inline" lang="">#</strong> operator when specifying the template type to <span class="No-Break" lang="">derive from.</span></p>
			<h1 id="_idParaDest-62" lang="en-GB"><a id="_idTextAnchor064"/>Summary</h1>
			<p lang="en-GB">This chapter explored ways in which to improve the test library by making use of a new feature in C++ 20 to get line numbers from the standard library instead of from the preprocessor. Even though the new code doesn’t work right now, it will eventually make the <strong class="source-inline" lang="">CONFIRM_TRUE</strong>, <strong class="source-inline" lang="">CONFIRM_FALSE</strong>, and <strong class="source-inline" lang="">CONFIRM</strong> macros optional. You will no longer have to use the macros. But I still like to use them because they help wrap up code that is easy to get wrong. And the macros are easier to spot in the tests because they use all <span class="No-Break" lang="">capital letters.</span></p>
			<p lang="en-GB">We also explored a trend to avoid macros when declaring tests and what it would look like if we used lambdas instead. The approach almost worked with a more complicated test declaration. The extra complexity doesn’t matter though because the design did not work for all <span class="No-Break" lang="">the tests.</span></p>
			<p lang="en-GB">It is still valuable for you to read about the proposed changes. You can learn about how other test libraries might work and understand why this book explains a solution that <span class="No-Break" lang="">embraces macros.</span></p>
			<p lang="en-GB">This chapter has also shown you how to follow the TDD process at a higher level. The step in the process to enhance a test can be applied to an overall design. We were able to improve and simplify the <strong class="source-inline" lang="">TEST</strong> and <strong class="source-inline" lang="">TEST_EX</strong> macros, which makes all of the <span class="No-Break" lang="">tests better.</span></p>
			<p lang="en-GB">The next chapter will explore what will be needed to add code that will run before and after the tests to help get things ready for the tests and clean things up after the <span class="No-Break" lang="">tests finish.</span></p>
		</div>
	</body></html>