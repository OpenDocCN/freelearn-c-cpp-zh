- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Bringing Structure with Methods and Classes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过方法和类引入结构
- en: In [*Chapter 3*](B19358_03.xhtml#_idTextAnchor100), we learned about collection
    types and loops. These powerful concepts helped us to structure our data and run
    code an arbitrary number of times.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B19358_03.xhtml#_idTextAnchor100)中，我们学习了集合类型和循环。这些强大的概念帮助我们结构化我们的数据并多次运行代码。
- en: Being able to reuse code in a loop is great, but what if we want to reuse this
    code at any arbitrary moment in time? And what if we want to reuse whole structures
    of code and data, such as – for example – enemies or vehicles?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在循环中重用代码是很好的，但如果我们想在任何任意时刻重用这段代码呢？如果我们想重用整个代码和数据结构，比如——例如——敌人或车辆呢？
- en: Methods and classes are exactly the concepts that will help us achieve this
    level of reuse!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 方法和类正是帮助我们达到这种重用水平的概念！
- en: Over the course of this chapter, we’ll see the last few basic concepts of programming.
    By the end, we will have learned everything that is needed to call ourselves real
    programmers.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将看到编程的几个基本概念。到结束时，我们将学会所有成为真正的程序员所需的技能。
- en: 'In this chapter, we cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Classes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Type hinting
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型提示
- en: Object-oriented programming (OOP)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'If you get stuck anywhere, don’t forget that you can find an example of everything
    we do in this chapter in the `chapter04` folder of the repository. You can find
    the repository here: [https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter04](https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter04).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到任何困难，不要忘记你可以在存储库的`chapter04`文件夹中找到我们在这个章节中做的所有示例。你可以在这里找到存储库：[https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter04](https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter04)。
- en: Methods are reusable bits of code
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法是可重用的代码块
- en: In [*Chapter 1*](B19358_01.xhtml#_idTextAnchor014), we learned to write code
    with the `_ready()` method of a node. We saw that the code contained in this function
    would be executed from the moment our game started to run. Now, let’s look closer
    at what functions are and how we can use them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第1章*](B19358_01.xhtml#_idTextAnchor014)中，我们学习了如何使用节点的`_ready()`方法编写代码。我们看到了这个函数中的代码将从我们的游戏开始运行的那一刻起执行。现在，让我们更详细地看看函数是什么以及我们如何使用它们。
- en: Method versus function
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 方法与函数的区别
- en: The terminologies *method* and *function* are often used interchangeably. They
    denote two very similar concepts but applied in different ways. In this book,
    we’ll use both interchangeably.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*方法*和*函数*经常被互换使用。它们表示两个非常相似的概念，但应用方式不同。在这本书中，我们将两者互换使用。
- en: What is a function?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数是什么？
- en: 'A `find()` function:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`find()`函数：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Under the hood, the interpreter looks up the code block that is associated with
    the `find` function, executes it with the `Bananas` string as input, and then
    returns the result to us.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，解释器查找与`find`函数关联的代码块，使用`Bananas`字符串作为输入执行它，然后将结果返回给我们。
- en: In the preceding case, we would print out the result. Note that the `print`
    statement we use in that code is also just a function!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们会打印出结果。请注意，我们在这段代码中使用的`print`语句也是一个函数！
- en: The input data we give to a function is called **arguments**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供给函数的输入数据被称为**参数**。
- en: To oversimplify the technical aspects, a function is just a detour that our
    program makes from its normal path of execution – a sidetrack through another
    code block.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化技术细节，函数只是我们的程序从其正常执行路径中做出的一个绕行——通过另一个代码块的旁路。
- en: Defining a function
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个函数
- en: 'Let’s have a look at a function that lowers the player’s health:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个降低玩家生命值的函数：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, to define a function, we need the following parts:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，要定义一个函数，我们需要以下部分：
- en: The `func` keyword. This indicates to GDScript that we are about to define a
    new function, such as the `var` keyword for variables.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func`关键字。这表示GDScript我们即将定义一个新的函数，就像`var`关键字用于变量一样。'
- en: A name. This is the name we will be using to call the function, `lower_player_health()`
    in this case. Make sure you select a descriptive name, just like with variable
    names.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名称。这是我们用来调用函数的名称，例如在这个例子中是`lower_player_health()`。确保你选择一个描述性的名称，就像变量名一样。
- en: 'A list of parameters that are separated by commas and surrounded by parentheses;
    in this case, we only have one parameter: `amount`. These are the pieces of data
    we want the user of the function to provide us. It is not mandatory to have any
    parameters.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列用逗号分隔并括在括号中的参数；在这种情况下，我们只有一个参数：`amount`。这些是我们希望函数用户提供给我们的数据。不一定需要任何参数。
- en: The code block that gets executed when we call the function. Within this code
    block, we can use the parameters of the function as if they were normal variables.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们调用函数时执行的代码块。在这个代码块中，我们可以将函数的参数用作普通变量。
- en: Arguments and parameters
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 参数和参数
- en: Attentive readers might have noticed that when we call a function, the input
    data is called **arguments**, and while inside the function, we call them **parameters**.
    Parameters are basically the input variables of a function, while arguments are
    specific values with which we call upon the function.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细的读者可能会注意到，当我们调用函数时，输入数据被称为**参数**，而在函数内部，我们称它们为**参数**。参数基本上是函数的输入变量，而参数是我们用来调用函数的具体值。
- en: But don’t worry about mixing the terminology up; almost every programmer does,
    and everyone will know what you are talking about.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 但不用担心术语的混淆；几乎每个程序员都会这样做，每个人都会知道你在说什么。
- en: 'The basic syntax of a function looks like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的基本语法如下所示：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It’s good to note that the number of defined parameters can vary. In the syntax
    example, we defined two parameters, but we could define none or even a hundred.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，定义的参数数量可以变化。在语法示例中，我们定义了两个参数，但我们可以定义零个甚至一百个。
- en: 'As an example, here is a function that simply prints out `Hello, World`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里有一个简单的函数，它只是打印出`Hello, World`：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Naming a function
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数命名
- en: 'Function names have the same constraints as variable names:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名称有与变量名称相同的约束：
- en: They contain only alphanumerical characters.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们只包含字母数字字符。
- en: There should be no spaces.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不应该有空格。
- en: They can’t begin with a number.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不能以数字开头。
- en: They should not be named after existing keywords.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不应该以现有关键字命名。
- en: But unlike variable names, it is important that a function’s name reflects what
    the code within the function does. This way, you know what to expect when running
    a function.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 但与变量名不同，一个函数的名称应该反映函数内部代码的功能。这样，当你运行一个函数时，你就知道可以期待什么。
- en: 'Here are some examples of good function names:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些好的函数名称示例：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And here are some examples of bad function names:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些不好的函数名称示例：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Naming functions, just like naming anything while programming, is difficult
    but important. But it is necessary to give everything clear descriptive names.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 命名函数，就像编程时命名任何事物一样，虽然困难但很重要。但有必要给一切清晰描述性的名称。
- en: The return keyword
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回关键字
- en: 'In `for` and `while` loops, we used the `break` keyword to prematurely exit
    the loop. In functions, we have a very similar keyword: `return`. This keyword
    will make the execution exit the function immediately. And to be fair, if you
    put a `return` statement within a loop, it will also stop that loop because we
    are no longer executing the function in general.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`和`while`循环中，我们使用`break`关键字提前退出循环。在函数中，我们有一个非常相似的关键字：`return`。这个关键字将使执行立即退出函数。而且公平地说，如果你在循环中放置一个`return`语句，它也会停止该循环，因为我们不再在一般情况下执行函数。
- en: 'Put it anywhere in a function and we can return to where we called the function,
    even if that means there is certain code that will never be executed:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在函数的任何地方放置它，我们就可以返回到调用函数的地方，即使这意味着某些代码永远不会被执行：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Functions can also return values, just like we saw with the `find()` function
    for arrays, which returned the index of the value we were searching for. To return
    a value, we use the `return` keyword again, but this time, we specify the value
    we want to return right after it:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也可以返回值，就像我们看到的数组`find()`函数一样，它返回了我们正在搜索的值的索引。要返回一个值，我们再次使用`return`关键字，但这次，我们在它后面指定我们想要返回的值：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: print(minimum(5, 2))
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: print(minimum(5, 2))
- en: var lowest_number = minimum(1, 300)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: var lowest_number = minimum(1, 300)
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'func _ready():'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 'func _ready():'
- en: pass keyword comes in. It is a line of code that does nothing at all. We can
    thus use it to create a code block that carries no logic. This way, we can create
    empty functions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`pass`关键字出现。这是一行什么也不做的代码。因此，我们可以用它创建一个不包含逻辑的代码块。这样，我们可以创建空函数。'
- en: Empty functions are very useful in OOP, which we will talk about in [*Chapter
    5*](B19358_05.xhtml#_idTextAnchor365).
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '在面向对象编程（OOP）中，空函数非常有用，我们将在[*第五章*](B19358_05.xhtml#_idTextAnchor365)中讨论。 '
- en: Optional parameters
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可选参数
- en: To make a function more flexible, you can decide to specify some parameters
    as optional. This way, you can later choose to provide the arguments or not. To
    do this, we must provide a default value for that argument.
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要使函数更灵活，你可以决定将一些参数指定为可选的。这样，你以后可以选择是否提供参数。为此，我们必须为该参数提供一个默认值。
- en: If you don’t give a value for these parameters while calling the function, GDScript
    will take the default values we specified.
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你调用函数时没有为这些参数提供值，GDScript将使用我们指定的默认值。
- en: 'We can use this technique to extend our previous function about removing life
    from the health total of the player:'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以使用这种技术来扩展我们之前关于从玩家生命值中移除生命的方法：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding example, the `lower_player_health()` function has one parameter,
    `amount`, which is optional. We know it is optional because we give it a default
    value within the definition using the equals sign. If we call this function and
    give it an argument, it will use that argument to fill in the amount. If we don’t
    give it any argument, it will default to `1` as the value for the amount. We can
    use this function like so:'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的例子中，`lower_player_health()` 函数有一个参数，`amount`，它是可选的。我们知道它是可选的，因为我们使用等号在定义中给它提供了一个默认值。如果我们调用这个函数并传递一个参数，它将使用该参数来填充数量。如果我们不传递任何参数，它将默认为`1`作为数量的值。我们可以这样使用这个函数：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If a function has multiple parameters, of which one or more are optional, the
    optional parameters should always come last in the definition. This is because
    if you leave out one of the arguments, GDScript cannot guess which one and just
    assumes it is the last one. If we accidentally misorder the parameters, we’ll
    get an error from the code editor to tell us to properly order them.
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果一个函数有多个参数，其中一个是或多个是可选的，那么可选参数应该始终在定义中放在最后。这是因为如果你省略了一个参数，GDScript无法猜测它是哪一个，只会假设它是最后一个。如果我们不小心错误地排列了参数，代码编辑器会给出错误提示，让我们正确地排列它们。
- en: 'Let’s say we have to write a function that moves the player at a certain angle,
    with a certain speed, and we also have to specify if the player is running and
    can collide with things in the world:'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设我们必须编写一个函数，该函数以特定角度、以特定速度移动玩家，并且我们还需要指定玩家是否在跑步以及是否可以与世界中的物体碰撞：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This `move_player()` function can be used in more diverse ways than the `lower_player_health()`
    function:'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个`move_player()`函数比`lower_player_health()`函数有更多样化的使用方式：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, we can choose which optional parameters to fill out, as long
    as we always give them in the order they were specified in the function definition.
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，我们可以选择填写哪些可选参数，只要我们始终按照函数定义中指定的顺序提供它们。
- en: Functions are the basis of all programming. Many programs work with just the
    data types we have learned about until now and functions. But let’s take it one
    step further and learn how we can group data and functions into one cohesive unit
    using classes.
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数是所有编程的基础。许多程序只使用我们至今所学的数据类型和函数。但让我们更进一步，学习如何使用类将数据和函数组合成一个统一的单元。
- en: Classes group code and data together
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类将代码和数据组合在一起
- en: 'Finally, we made it to one of the most important revolutions in computer science,
    something that shook the world of programming languages in the mid-60s: **classes**.'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们来到了计算机科学中最重要的一次革命之一，这是在20世纪60年代中期震撼了编程语言世界的事情：**类**。
- en: Some smart computer engineers thought about how we use data and functions and
    saw that we often use a select set of functions on a select set of data. This
    led them to group these two together so that they would live very closely with
    one another. Such a group is called a class.
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一些聪明的计算机工程师思考了我们是怎样使用数据和函数的，并发现我们经常在特定的数据集上使用一组特定的函数。这促使他们将这两个概念结合起来，使它们紧密地联系在一起。这样的组合被称为类。
- en: 'In games, classes often model specific separate entities. We could have a class
    for the following:'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在游戏中，类通常模拟特定的独立实体。我们可以为以下内容创建一个类：
- en: The player
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家
- en: Enemies
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敌人
- en: Collectibles
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可收集物品
- en: Obstacles
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 障碍物
- en: Each of these classes contains and manages its own data. The player class could
    manage the health and inventory of the player, while the collectibles manage what
    kind of collectibles they are and what effect they have on the player.
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个这些类都包含并管理自己的数据。玩家类可以管理玩家的生命值和库存，而可收集物品类则管理它们是什么类型的可收集物品以及它们对玩家有什么影响。
- en: In essence, each class is a custom data type, just like the ones we saw before.
    But now, we put in the data and functions ourselves! This is a very powerful concept,
    so let’s get started!
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从本质上讲，每个类都是一个自定义的数据类型，就像我们之前看到的那样。但现在，我们亲自放入数据和函数！这是一个非常强大的概念，所以让我们开始吧！
- en: Defining a class
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义一个类
- en: 'To create a simple class, we just use the `class` keyword with the name we
    would like the class to have. After that, we can start putting the class together
    by defining the variables and methods that it encompasses:'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要创建一个简单的类，我们只需使用`class`关键字并指定我们希望类拥有的名称。之后，我们可以通过定义它包含的变量和方法来开始构建类：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we see a class called `Enemy`; it has two member variables, `damage` and
    `health`, and two member methods, `take_damage()` and `die()`.
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们看到一个名为`Enemy`的类；它有两个成员变量，`damage`和`health`，以及两个成员方法，`take_damage()`和`die()`。
- en: Instancing a class
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实例化一个类
- en: 'You can see the class as a blueprint or template of our custom data type. So,
    once we have a class with member variables and functions defined, we can make
    a new instance from it. We call this instance an `.new()` function on it:'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以将类视为我们自定义数据类型的蓝图或模板。因此，一旦我们定义了具有成员变量和函数的类，我们就可以从中创建一个新的实例。我们称这个实例为`.new()`函数：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, this variable contains an object of our very own `Enemy` class! With this
    object, we can access its member variables and call its functions:'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，这个变量包含我们自己的`Enemy`类的对象！有了这个对象，我们可以访问其成员变量并调用其函数：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can also use this object in container types such as arrays and dictionaries
    and can pass it as an argument to functions:'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还可以将这个对象用于容器类型，如数组和字典，并将其作为参数传递给函数：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can see that instances of a class can be used just like any other kind of
    variable.
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以看到类的实例可以像任何其他类型的变量一样使用。
- en: Naming a class
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 命名一个类
- en: 'Classes need names, just like variables and methods. Although the name of a
    class has the same restrictions as that of a variable, the convention is to glue
    the words within the name against each other and capitalize the first letter of
    each. We call this **Pascal case** or **PascalCase** because it was popularized
    in Pascal, a programming language from 1970\. Here are a few examples:'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类需要名称，就像变量和方法一样。尽管类的名称与变量的名称有相同的限制，但惯例是将名称中的单词粘合在一起，并将每个单词的首字母大写。我们称这种格式为**Pascal
    case**或**PascalCase**，因为它在1970年代的Pascal编程语言中变得流行。以下是一些示例：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: These are all great class names. In [*Chapter 5*](B19358_05.xhtml#_idTextAnchor365),
    we’ll go over some more tips about naming classes.
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些都是很好的类名。在[*第五章*](B19358_05.xhtml#_idTextAnchor365)中，我们将讨论更多关于命名类的技巧。
- en: Extending a class
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 扩展一个类
- en: We can also create a new class by extending an already existing one. This is
    called **inheritance** because we inherit all the data and logic from a parent
    class into a child class and extend upon it with new data and logic.
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们也可以通过扩展一个已经存在的类来创建一个新的类。这被称为**继承**，因为我们从父类继承所有数据和逻辑到子类，并在此基础上添加新的数据和逻辑。
- en: 'To create a new enemy based on the previous one, for example, we follow this
    structure:'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，要创建基于上一个类的新的敌人，我们可以遵循以下结构：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can see that we follow the new class’s name with the `extends` keyword and
    then the class we want to inherit from. To overwrite the variables of the original
    class, we have to set them within the `_init()` function. This is a special function,
    called the `BuffEnemy` class is created. The constructor should initialize the
    object so that it is ready to be used.
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以看到我们在新类的名称后面跟随着`extends`关键字，然后是我们想要继承的类。为了覆盖原始类的变量，我们必须在`_init()`函数中设置它们。这是一个特殊函数，当创建`BuffEnemy`类时被调用。构造函数应该初始化对象，使其准备好使用。
- en: You can also see that we can redefine methods, as I overwrite the `die` function
    to print out a different string. When the `BuffEnemy` class takes damage and dies,
    it will call the `die` function of the inherited class and not of the parent class.
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以看到我们可以重新定义方法，因为我覆盖了`die`函数以打印出不同的字符串。当`BuffEnemy`类受到伤害并死亡时，它将调用继承类的`die`函数而不是父类的`die`函数。
- en: 'If we create an object of the `BuffEnemy` class, we can see that its health
    is indeed `100` and it will not die from `20` points of damage, and when the enemy
    dies, it will print out the new string from the overwritten function:'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们创建`BuffEnemy`类的对象，我们可以看到其健康值确实是`100`，并且它不会因为`20`点的伤害而死亡，当敌人死亡时，它将打印出覆盖函数中的新字符串：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As an experiment, try creating a new enemy by extending the `Enemy` class yourself.
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为实验，尝试通过自己扩展`Enemy`类来创建一个新的敌人。
- en: Each script is a class!
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个脚本都是一个类！
- en: I’ll let you in on a little secret. Each script we have written until now is
    already a class! You might already have realized this after reading the *Extending
    a class* section because the first line of each script we have written was to
    extend the `Node` class! This class is the base class for each type of node in
    the Godot engine.
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我会向你透露一个小秘密。我们至今为止所编写的每个脚本已经是一个类了！你可能已经在阅读了*扩展类*部分之后意识到了这一点，因为我们所编写的每个脚本的第一个命令都是扩展`Node`类！这个类是Godot引擎中每种类型节点的基类。
- en: 'This `Node` class has a bunch of boilerplate data and code that Godot needs
    to use it during the game. Most of this is not of interest to us at the moment.
    But some that are of interest include the following:'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个`Node`类包含了一些Godot在游戏过程中使用时需要的基本数据和代码。其中大部分对我们目前来说并不感兴趣。但一些感兴趣的内容包括以下：
- en: '**Life-cycle methods**: These are methods that get executed at certain times
    within the node’s life cycle – when it gets created, destroyed, or updated, for
    example.'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生命周期方法**：这些是在节点生命周期中的特定时间执行的方法——例如，当节点被创建、销毁或更新时。'
- en: '**The child and parent nodes**: In Godot, nodes follow a hierarchical structure,
    and each node has a reference to its children and parent nodes. Having access
    to these helps a lot when dealing with a given hierarchical structure.'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子节点和父节点**：在Godot中，节点遵循层次结构，每个节点都有一个对其子节点和父节点的引用。在处理给定的层次结构时，访问这些节点非常有帮助。'
- en: The node we attach the script to gets paired with that script, and so with the
    script’s data and logic, and is basically an instanced object of the script.
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们附加脚本的节点将与该脚本配对，以及脚本的数据和逻辑，基本上是脚本的实例化对象。
- en: In [*Chapter 7*](B19358_07.xhtml#_idTextAnchor523), we’ll also learn to extend
    more specific nodes, such as `Node2D` or `Sprite`.
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在[*第7章*](B19358_07.xhtml#_idTextAnchor523)中，我们还将学习扩展更具体的节点，例如`Node2D`或`Sprite`。
- en: 'While normal classes are required to have a name, the class that is derived
    from a script does not, although it is possible to do so. Just use the `class_name`
    keyword at the top of the script:'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然常规类需要有一个名称，但由脚本派生的类不需要，尽管这样做是可能的。只需在脚本顶部使用`class_name`关键字即可：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Godot makes it easy for us to start a new class.
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Godot使我们很容易开始一个新的类。
- en: When are certain variables available?
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 何时某些变量可用？
- en: 'You may have already noticed, but the variables we define are not accessible
    from everywhere. Each variable has a certain domain within which you can use it.
    Let’s take a closer look at the following piece of code:'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能已经注意到了，但我们定义的变量并非在所有地方都可以访问。每个变量都有一个特定的域，在这个域内你可以使用它。让我们更仔细地看看以下这段代码：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you type this code out in the script editor, which I encourage you to do,
    you’ll see an error pop up at the last line saying that the variable called `damage`
    is not in scope. This means that the variable is not available to us and we cannot
    use it.
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你在这段代码在脚本编辑器中输入，我鼓励你这样做，你会在最后一行看到一个错误弹出，说变量`damage`不在作用域内。这意味着该变量对我们不可用，我们无法使用它。
- en: 'In general, there are five scenarios in which a variable is available to us:'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，有五种情况变量对我们是可用的：
- en: 'The variable was defined within the same code block as where we use the variable,
    like so:'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量是在我们使用变量的同一代码块中定义的，如下所示：
- en: '[PRE22]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The variable was defined in a code block that is a parent to the current code
    block, like so:'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量是在当前代码块的父代码块中定义的，如下所示：
- en: '[PRE23]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The variable was defined within the current class, like so:'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量是在当前类内部定义的，如下所示：
- en: '[PRE24]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The variable was defined globally. We’ll learn more about this kind of variable
    in [*Chapter 10*](B19358_10.xhtml#_idTextAnchor632). But it suffices to say that
    this kind of variable is available anywhere any time, in any script, even in the
    editor itself. This kind of variable is very useful for storing information used
    by many different processes. We call these **autoloads**.
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量被全局定义。我们将在[*第10章*](B19358_10.xhtml#_idTextAnchor632)中了解更多关于这类变量的内容。但可以简单地说，这类变量在任何时间、任何脚本中都是可用的，甚至在编辑器本身中也是如此。这类变量对于存储被许多不同进程使用的信息非常有用。我们称之为**自动加载**。
- en: 'The variable was built into the engine. These variables are exposed to us on
    a global level; we did not define them ourselves. You can find a list of these
    global constants and functions here: [https://docs.godotengine.org/en/stable/classes/class_%40globalscope.html](https://docs.godotengine.org/en/stable/classes/class_%40globalscope.html).'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量是内置于引擎中的。这些变量在全局级别上对我们是可见的；我们并没有自己定义它们。你可以在这里找到这些全局常量和函数的列表：[https://docs.godotengine.org/en/stable/classes/class_%40globalscope.html](https://docs.godotengine.org/en/stable/classes/class_%40globalscope.html)。
- en: 'Here are a few examples:'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里有一些例子：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The domain within which a variable is accessible is called its **scope**.
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 变量可访问的域称为其**作用域**。
- en: 'While it is not possible to define two variables with the same name within
    the same scope, it is possible to define two variables with the same name when
    one is outside the current function and the other inside it. We call this **shadowing**
    because one lives in the shadow of the other. For example, one variable is defined
    within the class as a member variable and the other within a function, like so:'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然在同一个作用域内不可能定义两个具有相同名称的变量，但可以在一个变量在当前函数外部而另一个在函数内部时定义两个具有相同名称的变量。我们称这为**阴影**，因为一个变量生活在另一个的阴影中。例如，一个变量在类中作为成员变量定义，另一个在函数中定义，如下所示：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you run the preceding code, you will see it print out `100`, because when
    in doubt, GDScript will always take the closest defined variable:'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你运行前面的代码，你会看到它打印出`100`，因为当不确定时，GDScript 总是选择最近定义的变量：
- en: '![Figure 4.1 – A warning that tells us the damage variable is defined within
    the script and within the function](img/B19358_04_1.jpg)'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 4.1 – 一个警告，告诉我们损坏变量在脚本和函数中定义](img/B19358_04_1.jpg)'
- en: Figure 4.1 – A warning that tells us the damage variable is defined within the
    script and within the function
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.1 – 一个警告，告诉我们损坏变量在脚本和函数中定义
- en: However, as shown in *Figure 4**.1*, you will also see that the engine throws
    a warning telling us about the double usage of the variable name, which could
    lead to confusion for us as developers.
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，如图*图 4**.1*所示，你也会看到引擎抛出一个警告，告诉我们变量名的双重使用，这可能会让我们作为开发者感到困惑。
- en: The scope of a function
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数的作用域
- en: 'Functions also have a certain scope, though a little more restricted than the
    scope of a variable. You can use a function in the following scenarios:'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数也有一定的作用域，尽管比变量的作用域要小一些。你可以在以下场景中使用函数：
- en: The function was defined within the class we are using.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数是在我们使用的类中定义的。
- en: The function was defined within any parent class that our class inherits from.
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数是在我们类继承的任何父类中定义的。
- en: 'The function was built into the engine; these are available from anywhere.
    Here’s an example:'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数是内置于引擎中的；这些函数在任何地方都可以使用。以下是一个例子：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: But, as we saw earlier, we can also call a class function of an object. This
    way, the scope of that function is as big as the object’s scope.
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但，正如我们之前看到的，我们也可以调用对象的类函数。这样，该函数的作用域就与对象的作用域一样大。
- en: Types help us to know how to use a variable
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型帮助我们了解如何使用变量
- en: We saw different data types and even know how to create our own. But there was
    one big problem! Variables could change type mid-execution. This is particularly
    annoying because if we use the wrong type of data in a certain situation, the
    game will crash!
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们看到了不同的数据类型，甚至知道如何创建我们自己的。但有一个大问题！变量在执行过程中可能会改变类型。这尤其令人烦恼，因为如果我们在一个特定情况下使用了错误的数据类型，游戏就会崩溃！
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'var number_of_lives: int = 5'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`var number_of_lives: int = 5`'
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'var player_name: String = "Erik"'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`var player_name: String = "Erik"`'
- en: 'var inventory: Array = ["Cool glasses", "Drinks"]'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`var inventory: Array = ["Cool glasses", "Drinks"]`'
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'var inventory: Array = ["Cool glasses", "Drinks"]'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`var inventory: Array = ["Cool glasses", "Drinks"]`'
- en: inventory = 100
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`inventory = 100`'
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'var cool_numbers: Arraycool_numbers is an array of floating-point numbers,
    and thus every element of this array should be treated as a floating-point number.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`var cool_numbers: Arraycool_numbers`是一个浮点数数组，因此这个数组的每个元素都应该被视为浮点数。'
- en: As an experiment, try the following line of code. It will error; why?
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为实验，尝试以下代码行。它将出错；为什么？
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you try it out, you’ll see this will error because we are hinting that the
    `inventory` variable is an array filled with strings. But one of the values within
    the array is a number. The engine will see this and give an error.
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你尝试运行它，你会看到这会出错，因为我们暗示`inventory`变量是一个填充着字符串的数组。但数组中的一个值是数字。引擎会看到这一点并给出错误。
- en: Learning about the Variant type
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 了解 Variant 类型
- en: In the background, GDScript will use `Variant` as, almost, every variable’s
    type. The `Variant` class can hold almost any other data type; that is why we
    can switch the type of a variable mid-execution when we don’t specify a type at
    its creation.
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在后台，GDScript 将使用 `Variant` 作为几乎所有变量的类型。`Variant` 类可以存储几乎任何其他数据类型；这就是为什么我们可以在不指定创建时的类型的情况下，在执行过程中切换变量的类型。
- en: Also, variables that we type hinted are `Variant` types. But they have extra
    type requirements attached to them, such as that their value should be an integer
    or a dictionary.
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，我们类型提示的变量是 `Variant` 类型。但它们附加了额外的类型要求，例如它们的值应该是整数或字典。
- en: In GDScript, we never deal directly with the functionality of the `Variant`
    class. GDScript wraps it nicely around whatever value we assign it, and thus we
    don’t have to worry about the `Variant` type. We can just reason about the data
    type of the data we are storing in the variable.
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 GDScript 中，我们从不直接处理 `Variant` 类的功能。GDScript 将其很好地包装在我们分配给它的任何值周围，因此我们不必担心
    `Variant` 类型。我们只需考虑存储在变量中的数据类型。
- en: Type hinting function parameters
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数参数的类型提示
- en: 'In addition to hinting the type of a variable, we can also hint the type of
    the parameters of a function in the same manner:'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了提示变量的类型外，我们还可以以相同的方式提示函数参数的类型：
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, if you try to call this function with an argument that is not an integer,
    the editor will warn you that you are making a mistake. For example, take a look
    at the following line of code, which uses the `take_damage()` function from the
    previous code snippet:'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，如果你尝试使用非整数的参数调用此函数，编辑器会警告你正在犯错误。例如，看看以下使用上一段代码中 `take_damage()` 函数的代码行：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, the engine will throw an error because the `take_damage()` function expects
    an integer value, and a string is not compatible with an integer.
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，引擎将抛出一个错误，因为 `take_damage()` 函数期望一个整数值，而字符串与整数值不兼容。
- en: Automatic conversion of variables
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 变量的自动转换
- en: When you try `take_damage(1.5)`, you’ll see that the editor doesn’t show a warning
    or throw an error. This is because GDScript automatically converts certain variables
    from one type to another. This is called **implicit conversion**.
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你尝试 `take_damage(1.5)` 时，你会看到编辑器不会显示警告或抛出错误。这是因为 GDScript 会自动将某些变量从一种类型转换为另一种类型。这被称为
    **隐式转换**。
- en: One of these conversions happens between floating-point and integer numbers.
    In this case, GDScript will round the floating-point number down to the nearest
    integer value. For our little example at the start of this callout, this means
    that `1.5` will be rounded down to an integer value of `1`.
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中一种转换发生在浮点数和整数之间。在这种情况下，GDScript 将浮点数向下舍入到最接近的整数值。对于本调用开头的小例子，这意味着 `1.5` 将被舍入到整数值
    `1`。
- en: 'Type hinting can also be combined with a default value for the parameter; just
    put the type hint first and specify the default value after:'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型提示也可以与参数的默认值结合使用；只需将类型提示放在前面，然后指定默认值：
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `take_damage()` function now takes one parameter, `amount`, which is type
    hinted as an integer and has a default value of `1`.
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在的 `take_damage()` 函数接受一个参数，名为 `amount`，它被提示为整数类型，默认值为 `1`。
- en: Type hinting function returns
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数返回值的类型提示
- en: 'We can also type hint the value that will be returned by a function. This is
    very useful because it gives us a lot of information about what to expect from
    that function. The way to do this is like so:'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还可以提示函数将返回的值。这非常有用，因为它为我们提供了很多关于该函数预期内容的信息。要这样做的方式如下：
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This `minimum()` function will always have to return a floating-point number,
    no matter which `return` statement does so.
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个 `minimum()` 函数将始终返回一个浮点数，无论哪个 `return` 语句执行。
- en: As an experiment, try returning nothing in a function that is type hinted to
    return a floating-point number; you’ll see that we get an error thrown at us by
    the engine.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为实验，尝试在一个被提示为返回浮点数的函数中返回空值；你会看到引擎会向我们抛出一个错误。
- en: Using void as a function return
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `void` 作为函数返回值
- en: 'Sometimes, a function does not return a value at all. In that case, we can
    type hint the return value of that function using the `void` type. `void` cannot
    be used for variables, only in function definitions. So, `void` indicates that
    the function does not return anything:'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有时，一个函数根本不返回任何值。在这种情况下，我们可以使用 `void` 类型来提示该函数的返回值。`void` 不能用于变量，只能用于函数定义。因此，`void`
    表示该函数不返回任何内容：
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: However, most people will omit the `void` type hint when a function doesn’t
    return anything and only type hint the function when it actually does return something.
    It is good to know that the `void` type hint exists when you encounter it somewhere.
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，当函数不返回任何内容时，大多数人会省略`void`类型提示，并且只在函数实际返回内容时才对函数进行类型提示。当你遇到它时，了解`void`类型提示的存在是很好的。
- en: Inferred types
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 推断类型
- en: 'There is a second way of typing a variable without explicitly giving it a type.
    This method leverages the type recognition of the engine itself. We can namely
    use the type of the first value assigned to the variable as the type of that variable
    for the rest of the execution. We can do that like so:'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一种在不显式给出类型的情况下为变量添加类型的方法是利用引擎自身的类型识别。我们可以使用分配给变量的第一个值的类型作为该变量在其余执行中的类型。我们可以这样做：
- en: '[PRE38]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This looks very similar to a regular, untyped, variable definition. But this
    time, we put a colon before the equals sign. This will lock the type of the variable
    to the type of the value we are assigning to it.
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这看起来与常规的无类型变量定义非常相似。但这次，我们在等号之前放了一个冒号。这将锁定变量的类型为我们分配给它的值的类型。
- en: This technique is called **type inferring** because GDScript is just taking
    the type of the value we are passing it during assignment.
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种技术被称为**类型推断**，因为GDScript只是在赋值时获取我们传递给它的值的类型。
- en: 'Note that, just like with normal variable type hinting, we can only infer a
    variable’s type while defining it. So, the following code will not work:'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，就像正常的变量类型提示一样，我们只能在定义变量时推断变量类型。因此，以下代码将无法工作：
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Type inferring can make it easier for us to type hint variables without having
    to think about the actual type in advance.
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型推断可以使我们在不事先考虑实际类型的情况下更容易地为变量添加类型提示。
- en: null can be any type
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`null`可以是任何类型'
- en: 'Knowing what type a variable carries does not mean we don’t have to look out
    for variables that are `null`. `null` can be assigned to any kind of variable
    that is not a basic type (`int`, `float`, `String`, and so on). So, arrays, dictionaries,
    self-defined classes, and the like can still be `null` if they are not initialized:'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 知道一个变量携带的类型并不意味着我们不需要注意那些是`null`的变量。`null`可以被分配给任何不是基本类型（`int`、`float`、`String`等）的变量。因此，数组、字典、自定义类等，如果它们没有被初始化，仍然可以是`null`：
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`null` is often used to reset variables to an empty state.'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`null`常用于将变量重置为空状态。'
- en: Autocompletion
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自动补全
- en: 'Another great perk of typing our variables is that the text editor will help
    us out when we want to call a function or get to a member variable of a class
    by providing autocompletion. For example, if we have a string and we start typing
    to call a function on it, a little popup will show all the possible functions
    we are trying to get to. We can then just keep typing or use the arrow keys to
    select the right function and press *Enter* to select one. This helps tremendously
    if you know what you want to do but are not completely sure what the function
    was called, or just to speed up typing out long function names:'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一个打字变量的好处是，当我们要通过自动补全调用一个函数或访问一个类的成员变量时，文本编辑器会帮助我们。例如，如果我们有一个字符串并且开始打字来调用它上面的函数，一个小弹出窗口将显示我们试图访问的所有可能的函数。然后我们只需继续打字或使用箭头键选择正确的函数，然后按*Enter*键选择一个。如果你知道你想做什么但不确定函数的名称，或者只是想加快打字长函数名的速度，这非常有帮助：
- en: '![Figure 4.2 – The code editor will help us out with autocompletion when using
    type hinting](img/B19358_04_2.jpg)'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图4.2 – 当使用类型提示时，代码编辑器将帮助我们进行自动补全](img/B19358_04_2.jpg)'
- en: Figure 4.2 – The code editor will help us out with autocompletion when using
    type hinting
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.2 – 当使用类型提示时，代码编辑器将帮助我们进行自动补全
- en: Autocomplete is our friend in general, so making the autocomplete, well, more
    complete will only help us out in the long run.
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自动补全通常是我们的朋友，因此使自动补全更加完整只会从长远来看帮助我们。
- en: Using type hinting for named classes
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用类型提示为命名类
- en: 'In addition to built-in types, we can also type hint our own custom classes.
    But for that, we first have to register a name for the type of our class. To register
    the name, we can use the `class_name` keyword followed by the name we would like
    the data type of our class to have at the top of the file, like so:'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了内置类型外，我们还可以为自定义类添加类型提示。但为此，我们首先必须为类的类型注册一个名称。要注册名称，我们可以在文件顶部使用`class_name`关键字后跟我们希望数据类型具有的名称，如下所示：
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here, we see that we name our class `Player`. We can now use this type to type
    hint variables of the `Player` class and even use it to initiate a new instance
    of the class, like so:'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们看到我们命名我们的类为`Player`。现在我们可以使用这个类型来为`Player`类的变量添加类型提示，甚至可以用它来初始化一个新实例，如下所示：
- en: '[PRE42]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Naming classes is an easy way to type hint variables with instances of our custom
    classes.
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 命名类是使用我们自定义类的实例来为变量添加类型提示的简单方法。
- en: Performance
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 性能
- en: In addition to catching bugs before they happen and having autocompletion, type
    hinting has one last big advantage up its sleeve. If you type the variables in
    your game, the engine will be able to work with them way easier, resulting in
    better performance.
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了在发生之前捕获错误和自动补全之外，类型提示还有一个很大的优势。如果你在游戏中输入变量，引擎将能够更容易地与它们一起工作，从而提高性能。
- en: Because the engine doesn’t need to check if a variable will be able to perform
    certain operations, it can do more of these operations per second. In some cases,
    this will make your code twice as fast!
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于引擎不需要检查变量是否能够执行某些操作，它可以每秒执行更多的这些操作。在某些情况下，这会使你的代码速度提高一倍！
- en: Editor adding type hints
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编辑器添加类型提示
- en: 'As a last tip around type hinting, I would like to show you that the editor
    can help you out too! If you go into **Editor Settings** | **Text Editor** | **Completion**,
    there is a setting called **Add Type Hints**. This setting will let the editor
    autocomplete certain parts of your code with type hints. I recommend you turn
    it on:'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于类型提示的最后一个小贴士，我想向大家展示编辑器也能帮上忙！如果你进入**编辑器设置** | **文本编辑器** | **完成**，你会看到一个名为**添加类型提示**的设置。这个设置会让编辑器自动用类型提示来补全你的代码的某些部分。我建议你开启它：
- en: '![Figure 4.3 – The Add Type Hints setting](img/B19358_04_3.jpg)'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图4.3 – 添加类型提示设置](img/B19358_04_3.jpg)'
- en: Figure 4.3 – The Add Type Hints setting
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.3 – 添加类型提示设置
- en: With this setting enabled, the editor will automatically fill out type hints
    whenever it has to generate any code for us – for example, when generating an
    empty script.
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 启用此设置后，编辑器将自动在需要为我们生成任何代码时填充类型提示——例如，在生成空脚本时。
- en: 'In this section, we learned a lot about type hinting and saw how it can enhance
    our coding experience. Next, let’s take a look at a very important concepts in
    programming: OOP.'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了大量的类型提示知识，并看到了它如何增强我们的编码体验。接下来，让我们看看编程中一个非常重要的概念：面向对象编程（OOP）。
- en: OOP primer
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 面向对象编程入门
- en: 'So far in this chapter, we have learned about functions, classes, and objects.
    These concepts are very powerful: they give us a completely different way of working
    with data and the logic that accompanies it.'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经学习了函数、类和对象。这些概念非常强大：它们为我们提供了完全不同的处理数据和伴随逻辑的方式。
- en: In programming, there are multiple different paradigms of structuring code and
    data, one of them is **Object Oriented Programming** (**OOP**). GDScript is an
    **object-oriented** (**OO**) and **imperative** programming language, which means
    that we group data and its accompanying logic within classes and objects. The
    logic we write consists of statements that tell the computer fairly exactly what
    to do and how to do it for us. Each statement changes the internal state of the
    program. Most game engines and their accompanying programming languages are OO
    and imperative.
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在编程中，有多个不同的代码和数据结构化范式，其中之一是**面向对象编程**（**OOP**）。GDScript是一种**面向对象**（**OO**）和**命令式**编程语言，这意味着我们将数据和伴随的逻辑分组在类和对象中。我们编写的逻辑由告诉计算机如何为我们执行特定任务的语句组成。每个语句都会改变程序的内部状态。大多数游戏引擎及其伴随的编程语言都是面向对象和命令式的。
- en: 'OOP is built upon four key principles: inheritance, abstraction, encapsulation,
    and polymorphism. So, let’s have a look at these.'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）建立在四个关键原则之上：继承、抽象、封装和多态。让我们来看看这些。
- en: Inheritance
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 继承
- en: OOP allows classes to inherit from one another. This means that we get all the
    functionality from the parent class for free and can extend it with extra logic.
    This makes reusing code very easy.
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 面向对象编程允许类相互继承。这意味着我们可以免费获得父类所有的功能，并可以通过额外的逻辑来扩展它。这使得代码重用变得非常容易。
- en: For example, while there could be a lot of different enemies within a game,
    most of those would share some quite common code, and more common code would then
    differentiate them. Pathfinding, dealing damage, health management, inventory
    management, and so on would be shared by almost any enemy. So, we could define
    one class, `Enemy`, that encapsulates all of these functionalities and from which
    all other enemies can inherit.
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，虽然一个游戏中可能会有很多不同的敌人，但其中大部分都会共享一些相当常见的代码，而更常见的代码则会将它们区分开来。路径查找、造成伤害、健康管理、库存管理等几乎任何敌人都会共享。因此，我们可以定义一个类，`Enemy`，它封装了所有这些功能，并且所有其他敌人都可以从它继承。
- en: 'From here, we can define enemies that do the following:'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从这里，我们可以定义执行以下操作的敌人：
- en: Walk up to the player and use melee attacks.
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 走到玩家面前并使用近战攻击。
- en: Stay at a distance and shoot projectiles at the player.
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与玩家保持距离，并向玩家射击投射物。
- en: Move around a lot and heal other enemies.
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在很多地方移动，并治愈其他敌人。
- en: And so forth…
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以此类推…
- en: This list is non-exhaustive and shows that we can base a diverse cast of enemies
    on the same base `Enemy` class.
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个列表不是详尽的，它表明我们可以基于相同的基类 `Enemy` 建立一个多样化的敌人阵容。
- en: 'We can visually represent this inheritance, just like we do with humans and
    their families, using an inheritance tree:'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以用继承树来直观地表示这种继承，就像我们用人类及其家庭一样：
- en: '![Figure 4.4 – Different kinds of enemies can easily be derived from the base
    Enemy class](img/B19358_04_4.jpg)'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 4.4 – 不同类型的敌人可以很容易地从基础敌人类派生而来](img/B19358_04_4.jpg)'
- en: Figure 4.4 – Different kinds of enemies can easily be derived from the base
    Enemy class
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.4 – 不同类型的敌人可以很容易地从基础敌人类派生而来
- en: '*Figure 4**.4* clearly shows how certain classes are related and/or differ
    from one another.'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 4**.4* 清楚地显示了某些类是如何相互关联和/或不同的。'
- en: Abstraction
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 抽象
- en: A class hides its internal implementation, abstracting its functionality only
    by exposing higher-level functions. The user of the class doesn’t care how certain
    results are accomplished; for all the outside world knows, the actual process
    to get certain results could be pure magic.
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个类隐藏了其内部实现，仅通过暴露高级函数来抽象其功能。类的用户不关心某些结果是如何实现的；对于外部世界来说，获取某些结果的实际过程可能是纯粹的魔法。
- en: 'For the `Enemy` class example from earlier, this could mean that we can ask
    an enemy to move toward a certain point in the world, but not how. We have no
    business in how the enemy does its pathfinding or how it moves around the world.
    That is the enemy’s business:'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于之前提到的 `Enemy` 类示例，这意味着我们可以要求敌人向世界中的某个点移动，但不能指定如何移动。我们无权过问敌人如何进行路径查找或在世界中移动。这是敌人的事：
- en: '![Figure 4.5 – Public and private member variables and methods tell the outside
    world how to interact with a class](img/B19358_04_5.jpg)'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 4.5 – 公共和私有成员变量和方法告诉外部世界如何与类交互](img/B19358_04_5.jpg)'
- en: Figure 4.5 – Public and private member variables and methods tell the outside
    world how to interact with a class
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.5 – 公共和私有成员变量和方法告诉外部世界如何与类交互
- en: 'In most programming languages, abstraction comes in the form of public and
    private member functions and variables. They work like this:'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在大多数编程语言中，抽象以公共和私有成员函数和变量的形式出现。它们是这样工作的：
- en: '`public` and used to interact with the object.'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public` 用于与对象交互。'
- en: '`private` are inaccessible by the outside world and can only be used by the
    class itself. These support the internal functionality of the class.'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private` 对外部世界不可访问，只能由类本身使用。这些支持类的内部功能。'
- en: 'In GDScript, however, there is no way to explicitly mark variables or functions
    as public or private. Everything is public by default and accessible to the outside
    world. But there is a convention that GDScript developers took over from Python
    developers: we put an underscore (`_`) in front of variable and function names
    that are supposed to be private. This way, we can signal that a variable or method
    is supposed to be private and should not be used by anything outside of the class:'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 GDScript 中，然而，没有方法可以明确地将变量或函数标记为公共或私有。默认情况下，所有内容都是公共的，并且对外部世界是可访问的。但有一个GDScript开发者从Python开发者那里继承的约定：我们在应该为私有的变量和函数名前加上一个下划线（`_`）。这样，我们可以表明一个变量或方法应该是私有的，并且不应该被类外部的任何东西使用：
- en: '[PRE43]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The engine will not enforce such private members, so you can still call them,
    but this is a very bad practice. You can see this distinction between public and
    private members built into the scripts we’ve already written with functions that
    are already present in the nodes, such as `_ready()` and `_update()`.
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 引擎不会强制执行这样的私有成员，所以你仍然可以调用它们，但这是一种非常不好的做法。你可以在我们已编写的脚本中看到这种公共和私有成员之间的区别，例如节点中已经存在的函数，如`_ready()`和`_update()`。
- en: 'Abstraction has multiple advantages:'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 抽象具有多个优点：
- en: '**Security**: Because the user of the class knows only to use public methods
    and variables, there is a lower chance of them accidentally misusing the class.'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：因为类的使用者只知道使用公共方法和变量，所以它们意外误用类的可能性较低。'
- en: '**Maintainability**: Because the functionality of the class is hidden behind
    a few public functions, we can easily rewrite that functionality if needed without
    breaking other pieces of code.'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：因为类的功能隐藏在几个公共函数后面，所以如果需要，我们可以轻松地重写该功能，而不会破坏其他代码。'
- en: This protects against other classes or pieces of code meddling too much with
    the internals of a class. Because what if we rewrite the pathfinding of enemies?
    If we properly encapsulate this code, there is no problem, but if other pieces
    of code call upon the enemies’ pathfinding directly, we will have to rewrite all
    of these as well.
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这可以防止其他类或代码片段过多地干涉一个类的内部实现。因为如果我们重写敌人的寻路算法呢？如果我们正确地封装这段代码，那就没问题，但如果其他代码片段直接调用敌人的寻路算法，我们就必须重写所有这些代码。
- en: '**Hiding complexity**: Some code can be very complex, but by using classes,
    we can hide this behind easy-to-use methods and member variables.'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐藏复杂性**：某些代码可能非常复杂，但通过使用类，我们可以将这些复杂性隐藏在易于使用的函数和成员变量后面。'
- en: 'Now that we learned about abstraction, let’s look at the last principle: encapsulation.'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经了解了抽象，让我们来看看最后一个原则：封装。
- en: Encapsulation
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 封装
- en: A well-written class should encapsulate all important information within itself
    so that the user of the class doesn’t have to worry about the nitty-gritty details.
    This means that a class should only expose select information to the outside world.
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个编写良好的类应该将所有重要信息封装在自身内部，这样类的使用者就不必担心细节问题。这意味着类应该只向外界暴露选择的信息。
- en: Encapsulation is an extension of abstraction but homed in on a class’s data.
    The less the outside world has to deal with member variables of a class directly
    and the more with member functions, the better.
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 封装是抽象的扩展，但专注于类的数据。外部世界直接处理类的成员变量的程度越少，而通过成员函数处理的程度越多，就越好。
- en: Polymorphism
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 多态
- en: 'The last principle of OOP is polymorphism, which says that objects and methods
    can morph into multiple different forms. In GDScript, this happens in two distinct
    ways: over objects and over methods.'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 面向对象编程的最后一个原则是多态，它表示对象和方法可以转变为多种不同的形式。在GDScript中，这以两种不同的方式发生：通过对象和通过方法。
- en: Object polymorphism
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对象多态
- en: 'Let’s say we have a class structure such as the one in the earlier example:
    a base enemy from which other enemies inherit. The code could look something like
    this:'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设我们有一个类似于前面示例中的类结构：一个基类敌人，其他敌人从中继承。代码可能看起来像这样：
- en: '[PRE44]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, when we make instances of the `BuffEnemy` and `StrongEnemy` classes, we
    can type hint them as such, but we can also type hint them as their base class,
    `Enemy`:'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，当我们创建`BuffEnemy`和`StrongEnemy`类的实例时，我们可以将它们类型提示为这样的类型，但也可以将它们类型提示为它们的基类`Enemy`：
- en: '[PRE45]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This works because everything that inherits from the `Enemy` class should have
    the same member variables and functions at its core, so it can be put in a variable
    of the parent class.
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为从`Enemy`类继承的所有内容都应该在其核心具有相同的成员变量和函数，因此它可以放入父类的变量中。
- en: 'But you cannot assign an object from the `Enemy` type to a variable that is
    typed as one of its child classes. So, the next line will error:'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但是你不能将`Enemy`类型的对象分配给类型为它的子类之一的变量。所以，下一行也会出错：
- en: '[PRE46]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The two child classes are also not compatible. So, the next line will error
    too:'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这两个子类也不兼容。所以，下一行也会出错：
- en: '[PRE47]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: These preceding two examples don’t work because you are not guaranteed that
    the member variables and functions within the `Enemy` and `StrongEnemy` classes
    will be the same as those in the `BuffEnemy` class. And indeed, we can see that
    the `BuffEnemy` class has another member variable, `attack_distance`, that the
    `Enemy` and `StrongEnemy` classes do not have.
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前两个例子不工作，因为你不能保证 `Enemy` 和 `StrongEnemy` 类中的成员变量和函数与 `BuffEnemy` 类中的相同。实际上，我们可以看到
    `BuffEnemy` 类有一个 `attack_distance` 成员变量，而 `Enemy` 和 `StrongEnemy` 类没有。
- en: 'A good analogy for the concept of polymorphism is vehicles in the real world.
    Let’s say we have three vehicles:'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 多态概念的一个很好的类比是现实世界中的车辆。假设我们有三种车辆：
- en: Cars
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 汽车
- en: Bikes
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自行车
- en: Trucks
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卡车
- en: 'Although all three vehicles can move you from one point to another, have a
    certain number of wheels, and are made of metal, there is a certain hierarchy:'
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管所有三种车辆都能将你从一个地点移动到另一个地点，都有一定数量的轮子，并且由金属制成，但它们之间存在一定的层次结构：
- en: '![Figure 4.6 – The class structure of simple vehicles](img/B19358_04_6.jpg)'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图4.6 – 简单车辆的类结构](img/B19358_04_6.jpg)'
- en: Figure 4.6 – The class structure of simple vehicles
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.6 – 简单车辆的类结构
- en: A bike needs somebody to power it, while a car and a truck have motors. Furthermore,
    we could take the car as a template for the truck and say that the truck is a
    kind of long, big car.
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自行车需要有人来提供动力，而汽车和卡车有发动机。此外，我们可以将汽车作为卡车的模板，并说卡车是一种长而大的汽车。
- en: The truck is also unique from the car because it has a place to transport larger
    cargo. This makes it so that we can say a truck is a car, but a car is not a truck.
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 卡车也因其可以运输更大货物的地方而与汽车不同。这使得我们可以说卡车是汽车，但汽车不是卡车。
- en: Method overriding
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 方法覆盖
- en: 'Then, there is also the possibility to override methods from the parent class.
    This will completely replace the original function with a new one, but only for
    the given child class. This is very useful when the child class needs some logic
    to be slightly or even drastically different from that of the parent class. To
    do this in GDScript, the method in the child class should adhere to the following
    conventions:'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，还有覆盖父类方法的可能性。这将完全用新的函数替换原始函数，但仅限于给定的子类。这在子类需要与父类略有不同甚至截然不同的逻辑时非常有用。要在 GDScript
    中做到这一点，子类中的方法应遵循以下约定：
- en: Have the same name
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称必须相同
- en: Have the same number of parameters
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数数量必须相同
- en: If the parameters are typed, have the same types
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果参数被输入，它们应该具有相同的类型
- en: Have exactly the same default values, if any
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有任何默认值，它们必须完全相同
- en: You see that we need to be exact when we want to override a method. If we are
    not, the engine will recognize it as a separate function or error because the
    overriding was done incorrectly.
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会看到当我们想要覆盖一个方法时，我们需要非常精确。如果我们不是这样做的，引擎会将其识别为单独的函数或错误，因为覆盖操作执行不正确。
- en: 'Let’s look at two classes that demonstrate this. A base class, `Enemy`, has
    a function called `die()` that prints out `"Aaargh!"`. This `die` function just
    prints out an exclamation when the enemy dies. Then, we inherit the `BuffEnemy`
    class from this base and override the `die()` function to print out `"How did
    you` `defeat me?!?"`:'
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看两个演示这一点的类。一个基类 `Enemy` 有一个名为 `die()` 的函数，该函数打印出 `"Aaargh!"`。这个 `die` 函数只是在敌人死亡时打印出一个感叹号。然后，我们从基类继承
    `BuffEnemy` 类并覆盖 `die()` 函数以打印出 `"How did you` `defeat me?!?"`：
- en: '[PRE48]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If you call the `die()` function of each enemy type, you’ll see that they each
    have their own implementation of the function:'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你调用每种敌人的 `die()` 函数，你会看到它们各自都有自己函数的实现：
- en: '[PRE49]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The preceding code will print out `"Aaargh!"`, as expected. Now for the `BuffEnemy`
    class:'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的代码将按预期打印出 `"Aaargh!"`。现在对于 `BuffEnemy` 类：
- en: '[PRE50]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, we execute the overridden `die()` function, and the printout will read
    `"How did you` `defeat me?!?"`.
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们执行覆盖的 `die()` 函数，打印输出将显示 `"How did you` `defeat me?!?"`。
- en: 'Even if you put the `BuffEnemy` object in an `Enemy` variable, it will still
    use the overridden function from the `BuffEnemy` class:'
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 即使将 `BuffEnemy` 对象放入 `Enemy` 变量中，它仍然会使用来自 `BuffEnemy` 类的覆盖函数：
- en: '[PRE51]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Again, we’ll see `"How did you defeat me?!?"` printed out. This is because the
    `BuffEnemy` class inherits from `Enemy` and thus is of type `Enemy`, but the implementation
    of its functions can still be overridden.
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次，我们会看到打印出 `"How did you defeat me?!?"`。这是因为 `BuffEnemy` 类从 `Enemy` 类继承，因此它是
    `Enemy` 类型，但其函数的实现仍然可以被覆盖。
- en: We learned a lot about OOP and its principles. It’s a very interesting but complex
    subject. Don’t worry too much about getting all principles perfect directly. Knowing
    they exist is already half the work. Let’s wrap the chapter up with some extra
    exercises in the next section.
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们对面向对象编程（OOP）及其原则有了很多了解。这是一个非常有趣但复杂的主题。不必过于担心一开始就能完全掌握所有原则。知道它们的存在已经完成了一半的工作。让我们在下一节通过一些额外的练习来结束本章。
- en: Additional exercises – Sharpening the axe
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 额外练习 - 锋利斧头
- en: 'Write a function, `limit_inventory()`, that takes an array representing an
    inventory and an integer. The function checks if the array is longer than the
    provided integer; if it is, it should remove all items that are too much. Lastly,
    the function returns the resulting array:'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为 `limit_inventory()` 的函数，它接受一个表示库存的数组和整数。该函数检查数组是否比提供的整数长；如果是，它应该删除所有过多的项目。最后，该函数返回结果数组：
- en: '[PRE52]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This example should print out `["``Boots", "Sword"]`.
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个例子应该会打印出 `["``Boots", "Sword"]`。
- en: 'Rewrite the previous function so that the integer it takes has a default value
    of 3 for the following code to work:'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新编写之前的函数，使其接受的整数具有默认值3，以便以下代码能够正常工作：
- en: '[PRE53]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This should print out `["Boots", "``Sword", "Grapes"]`.
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会打印出 `["Boots", "``Sword", "Grapes"]`。
- en: 'Rewrite this code so that it does not error anymore:'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新编写此代码，使其不再出错：
- en: '[PRE54]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Write `Player` and `Enemy` classes that make the following code work. In this
    code, the player and enemy will damage each other until one of them has a health
    that is equal to or less than zero. See it as a primitive battle:'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写 `Player` 和 `Enemy` 类，使以下代码能够工作。在这段代码中，玩家和敌人将互相伤害，直到其中一方的生命值等于或低于零。将其视为一场原始的战斗：
- en: '[PRE55]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Rewrite the `Player` and `Enemy` classes from the previous exercise to inherit
    from the same base class.
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将之前的练习中的 `Player` 和 `Enemy` 类重写为从同一个基类继承。
- en: Summary
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 概述
- en: With functions, classes, and type hinting in our toolkit, we have finally learned
    all the basic building blocks of programming! From now on, the possibilities are
    endless!
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的工具箱中有了函数、类和类型提示后，我们终于学会了编程的所有基本构建块！从现在开始，可能性是无限的！
- en: In the next chapter, we will learn how to write and structure our code in a
    clean way so that it’s easy to use and understand for others.
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何以干净的方式编写和结构化我们的代码，以便其他人容易使用和理解。
- en: Quiz time
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测验时间
- en: Why do we use functions and classes?
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么我们使用函数和类？
- en: For which two purposes can the `return` keyword be used in functions?
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数中，`return` 关键字可以用于哪两个目的？
- en: What is the scope of a variable? What are the different tiers?
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量的作用域是什么？有哪些不同的层级？
- en: What is the scope of a function?
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的作用域是什么？
- en: Is a class a group of variables and functions?
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类是一组变量和函数的组合吗？
- en: Given the following code, how do we make a new instance of the `Enemy` class?
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定以下代码，我们如何创建 `Enemy` 类的新实例？
- en: '[PRE56]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: How do we call the instance of a class?
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何调用类的实例？
- en: What is type hinting?
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型提示是什么？
- en: 'Add type hinting to the following variables:'
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为以下变量添加类型提示：
- en: '`var player_health = 5`'
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var player_health = 5`'
- en: '`var can_take_damage =` `true`'
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var can_take_damage =` `true`'
- en: '`var sword = { "damage_type": "fire", "damage":` `6 }`'
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var sword = { "damage_type": "fire", "damage":` `6 }`'
- en: In addition to autocompletion and increased performances, what is the final
    benefit of using type hinting?
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了自动完成和性能提升之外，使用类型提示的最终好处是什么？
- en: '[PRE57]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
