- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bringing Structure with Methods and Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B19358_03.xhtml#_idTextAnchor100), we learned about collection
    types and loops. These powerful concepts helped us to structure our data and run
    code an arbitrary number of times.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to reuse code in a loop is great, but what if we want to reuse this
    code at any arbitrary moment in time? And what if we want to reuse whole structures
    of code and data, such as – for example – enemies or vehicles?
  prefs: []
  type: TYPE_NORMAL
- en: Methods and classes are exactly the concepts that will help us achieve this
    level of reuse!
  prefs: []
  type: TYPE_NORMAL
- en: Over the course of this chapter, we’ll see the last few basic concepts of programming.
    By the end, we will have learned everything that is needed to call ourselves real
    programmers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type hinting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object-oriented programming (OOP)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you get stuck anywhere, don’t forget that you can find an example of everything
    we do in this chapter in the `chapter04` folder of the repository. You can find
    the repository here: [https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter04](https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter04).'
  prefs: []
  type: TYPE_NORMAL
- en: Methods are reusable bits of code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B19358_01.xhtml#_idTextAnchor014), we learned to write code
    with the `_ready()` method of a node. We saw that the code contained in this function
    would be executed from the moment our game started to run. Now, let’s look closer
    at what functions are and how we can use them.
  prefs: []
  type: TYPE_NORMAL
- en: Method versus function
  prefs: []
  type: TYPE_NORMAL
- en: The terminologies *method* and *function* are often used interchangeably. They
    denote two very similar concepts but applied in different ways. In this book,
    we’ll use both interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: What is a function?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `find()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Under the hood, the interpreter looks up the code block that is associated with
    the `find` function, executes it with the `Bananas` string as input, and then
    returns the result to us.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding case, we would print out the result. Note that the `print`
    statement we use in that code is also just a function!
  prefs: []
  type: TYPE_NORMAL
- en: The input data we give to a function is called **arguments**.
  prefs: []
  type: TYPE_NORMAL
- en: To oversimplify the technical aspects, a function is just a detour that our
    program makes from its normal path of execution – a sidetrack through another
    code block.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s have a look at a function that lowers the player’s health:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, to define a function, we need the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The `func` keyword. This indicates to GDScript that we are about to define a
    new function, such as the `var` keyword for variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A name. This is the name we will be using to call the function, `lower_player_health()`
    in this case. Make sure you select a descriptive name, just like with variable
    names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A list of parameters that are separated by commas and surrounded by parentheses;
    in this case, we only have one parameter: `amount`. These are the pieces of data
    we want the user of the function to provide us. It is not mandatory to have any
    parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code block that gets executed when we call the function. Within this code
    block, we can use the parameters of the function as if they were normal variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arguments and parameters
  prefs: []
  type: TYPE_NORMAL
- en: Attentive readers might have noticed that when we call a function, the input
    data is called **arguments**, and while inside the function, we call them **parameters**.
    Parameters are basically the input variables of a function, while arguments are
    specific values with which we call upon the function.
  prefs: []
  type: TYPE_NORMAL
- en: But don’t worry about mixing the terminology up; almost every programmer does,
    and everyone will know what you are talking about.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic syntax of a function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It’s good to note that the number of defined parameters can vary. In the syntax
    example, we defined two parameters, but we could define none or even a hundred.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, here is a function that simply prints out `Hello, World`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Naming a function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Function names have the same constraints as variable names:'
  prefs: []
  type: TYPE_NORMAL
- en: They contain only alphanumerical characters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There should be no spaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can’t begin with a number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They should not be named after existing keywords.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But unlike variable names, it is important that a function’s name reflects what
    the code within the function does. This way, you know what to expect when running
    a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of good function names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And here are some examples of bad function names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Naming functions, just like naming anything while programming, is difficult
    but important. But it is necessary to give everything clear descriptive names.
  prefs: []
  type: TYPE_NORMAL
- en: The return keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `for` and `while` loops, we used the `break` keyword to prematurely exit
    the loop. In functions, we have a very similar keyword: `return`. This keyword
    will make the execution exit the function immediately. And to be fair, if you
    put a `return` statement within a loop, it will also stop that loop because we
    are no longer executing the function in general.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Put it anywhere in a function and we can return to where we called the function,
    even if that means there is certain code that will never be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions can also return values, just like we saw with the `find()` function
    for arrays, which returned the index of the value we were searching for. To return
    a value, we use the `return` keyword again, but this time, we specify the value
    we want to return right after it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: print(minimum(5, 2))
  prefs: []
  type: TYPE_NORMAL
- en: var lowest_number = minimum(1, 300)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'func _ready():'
  prefs: []
  type: TYPE_NORMAL
- en: pass keyword comes in. It is a line of code that does nothing at all. We can
    thus use it to create a code block that carries no logic. This way, we can create
    empty functions.
  prefs: []
  type: TYPE_NORMAL
- en: Empty functions are very useful in OOP, which we will talk about in [*Chapter
    5*](B19358_05.xhtml#_idTextAnchor365).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Optional parameters
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: To make a function more flexible, you can decide to specify some parameters
    as optional. This way, you can later choose to provide the arguments or not. To
    do this, we must provide a default value for that argument.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: If you don’t give a value for these parameters while calling the function, GDScript
    will take the default values we specified.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can use this technique to extend our previous function about removing life
    from the health total of the player:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the `lower_player_health()` function has one parameter,
    `amount`, which is optional. We know it is optional because we give it a default
    value within the definition using the equals sign. If we call this function and
    give it an argument, it will use that argument to fill in the amount. If we don’t
    give it any argument, it will default to `1` as the value for the amount. We can
    use this function like so:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If a function has multiple parameters, of which one or more are optional, the
    optional parameters should always come last in the definition. This is because
    if you leave out one of the arguments, GDScript cannot guess which one and just
    assumes it is the last one. If we accidentally misorder the parameters, we’ll
    get an error from the code editor to tell us to properly order them.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s say we have to write a function that moves the player at a certain angle,
    with a certain speed, and we also have to specify if the player is running and
    can collide with things in the world:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This `move_player()` function can be used in more diverse ways than the `lower_player_health()`
    function:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we can choose which optional parameters to fill out, as long
    as we always give them in the order they were specified in the function definition.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Functions are the basis of all programming. Many programs work with just the
    data types we have learned about until now and functions. But let’s take it one
    step further and learn how we can group data and functions into one cohesive unit
    using classes.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Classes group code and data together
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we made it to one of the most important revolutions in computer science,
    something that shook the world of programming languages in the mid-60s: **classes**.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Some smart computer engineers thought about how we use data and functions and
    saw that we often use a select set of functions on a select set of data. This
    led them to group these two together so that they would live very closely with
    one another. Such a group is called a class.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In games, classes often model specific separate entities. We could have a class
    for the following:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The player
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Enemies
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Collectibles
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Obstacles
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these classes contains and manages its own data. The player class could
    manage the health and inventory of the player, while the collectibles manage what
    kind of collectibles they are and what effect they have on the player.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In essence, each class is a custom data type, just like the ones we saw before.
    But now, we put in the data and functions ourselves! This is a very powerful concept,
    so let’s get started!
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Defining a class
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To create a simple class, we just use the `class` keyword with the name we
    would like the class to have. After that, we can start putting the class together
    by defining the variables and methods that it encompasses:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see a class called `Enemy`; it has two member variables, `damage` and
    `health`, and two member methods, `take_damage()` and `die()`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Instancing a class
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can see the class as a blueprint or template of our custom data type. So,
    once we have a class with member variables and functions defined, we can make
    a new instance from it. We call this instance an `.new()` function on it:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this variable contains an object of our very own `Enemy` class! With this
    object, we can access its member variables and call its functions:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use this object in container types such as arrays and dictionaries
    and can pass it as an argument to functions:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can see that instances of a class can be used just like any other kind of
    variable.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Naming a class
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Classes need names, just like variables and methods. Although the name of a
    class has the same restrictions as that of a variable, the convention is to glue
    the words within the name against each other and capitalize the first letter of
    each. We call this **Pascal case** or **PascalCase** because it was popularized
    in Pascal, a programming language from 1970\. Here are a few examples:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: These are all great class names. In [*Chapter 5*](B19358_05.xhtml#_idTextAnchor365),
    we’ll go over some more tips about naming classes.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Extending a class
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We can also create a new class by extending an already existing one. This is
    called **inheritance** because we inherit all the data and logic from a parent
    class into a child class and extend upon it with new data and logic.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To create a new enemy based on the previous one, for example, we follow this
    structure:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we follow the new class’s name with the `extends` keyword and
    then the class we want to inherit from. To overwrite the variables of the original
    class, we have to set them within the `_init()` function. This is a special function,
    called the `BuffEnemy` class is created. The constructor should initialize the
    object so that it is ready to be used.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: You can also see that we can redefine methods, as I overwrite the `die` function
    to print out a different string. When the `BuffEnemy` class takes damage and dies,
    it will call the `die` function of the inherited class and not of the parent class.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we create an object of the `BuffEnemy` class, we can see that its health
    is indeed `100` and it will not die from `20` points of damage, and when the enemy
    dies, it will print out the new string from the overwritten function:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As an experiment, try creating a new enemy by extending the `Enemy` class yourself.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Each script is a class!
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: I’ll let you in on a little secret. Each script we have written until now is
    already a class! You might already have realized this after reading the *Extending
    a class* section because the first line of each script we have written was to
    extend the `Node` class! This class is the base class for each type of node in
    the Godot engine.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This `Node` class has a bunch of boilerplate data and code that Godot needs
    to use it during the game. Most of this is not of interest to us at the moment.
    But some that are of interest include the following:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Life-cycle methods**: These are methods that get executed at certain times
    within the node’s life cycle – when it gets created, destroyed, or updated, for
    example.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The child and parent nodes**: In Godot, nodes follow a hierarchical structure,
    and each node has a reference to its children and parent nodes. Having access
    to these helps a lot when dealing with a given hierarchical structure.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The node we attach the script to gets paired with that script, and so with the
    script’s data and logic, and is basically an instanced object of the script.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In [*Chapter 7*](B19358_07.xhtml#_idTextAnchor523), we’ll also learn to extend
    more specific nodes, such as `Node2D` or `Sprite`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'While normal classes are required to have a name, the class that is derived
    from a script does not, although it is possible to do so. Just use the `class_name`
    keyword at the top of the script:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Godot makes it easy for us to start a new class.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: When are certain variables available?
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You may have already noticed, but the variables we define are not accessible
    from everywhere. Each variable has a certain domain within which you can use it.
    Let’s take a closer look at the following piece of code:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If you type this code out in the script editor, which I encourage you to do,
    you’ll see an error pop up at the last line saying that the variable called `damage`
    is not in scope. This means that the variable is not available to us and we cannot
    use it.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In general, there are five scenarios in which a variable is available to us:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The variable was defined within the same code block as where we use the variable,
    like so:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The variable was defined in a code block that is a parent to the current code
    block, like so:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The variable was defined within the current class, like so:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The variable was defined globally. We’ll learn more about this kind of variable
    in [*Chapter 10*](B19358_10.xhtml#_idTextAnchor632). But it suffices to say that
    this kind of variable is available anywhere any time, in any script, even in the
    editor itself. This kind of variable is very useful for storing information used
    by many different processes. We call these **autoloads**.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The variable was built into the engine. These variables are exposed to us on
    a global level; we did not define them ourselves. You can find a list of these
    global constants and functions here: [https://docs.godotengine.org/en/stable/classes/class_%40globalscope.html](https://docs.godotengine.org/en/stable/classes/class_%40globalscope.html).'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are a few examples:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The domain within which a variable is accessible is called its **scope**.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'While it is not possible to define two variables with the same name within
    the same scope, it is possible to define two variables with the same name when
    one is outside the current function and the other inside it. We call this **shadowing**
    because one lives in the shadow of the other. For example, one variable is defined
    within the class as a member variable and the other within a function, like so:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the preceding code, you will see it print out `100`, because when
    in doubt, GDScript will always take the closest defined variable:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.1 – A warning that tells us the damage variable is defined within
    the script and within the function](img/B19358_04_1.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.1 – A warning that tells us the damage variable is defined within the
    script and within the function
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: However, as shown in *Figure 4**.1*, you will also see that the engine throws
    a warning telling us about the double usage of the variable name, which could
    lead to confusion for us as developers.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The scope of a function
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Functions also have a certain scope, though a little more restricted than the
    scope of a variable. You can use a function in the following scenarios:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The function was defined within the class we are using.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The function was defined within any parent class that our class inherits from.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The function was built into the engine; these are available from anywhere.
    Here’s an example:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: But, as we saw earlier, we can also call a class function of an object. This
    way, the scope of that function is as big as the object’s scope.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Types help us to know how to use a variable
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We saw different data types and even know how to create our own. But there was
    one big problem! Variables could change type mid-execution. This is particularly
    annoying because if we use the wrong type of data in a certain situation, the
    game will crash!
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'var number_of_lives: int = 5'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'var player_name: String = "Erik"'
  prefs: []
  type: TYPE_NORMAL
- en: 'var inventory: Array = ["Cool glasses", "Drinks"]'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'var inventory: Array = ["Cool glasses", "Drinks"]'
  prefs: []
  type: TYPE_NORMAL
- en: inventory = 100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'var cool_numbers: Arraycool_numbers is an array of floating-point numbers,
    and thus every element of this array should be treated as a floating-point number.'
  prefs: []
  type: TYPE_NORMAL
- en: As an experiment, try the following line of code. It will error; why?
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If you try it out, you’ll see this will error because we are hinting that the
    `inventory` variable is an array filled with strings. But one of the values within
    the array is a number. The engine will see this and give an error.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Learning about the Variant type
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In the background, GDScript will use `Variant` as, almost, every variable’s
    type. The `Variant` class can hold almost any other data type; that is why we
    can switch the type of a variable mid-execution when we don’t specify a type at
    its creation.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Also, variables that we type hinted are `Variant` types. But they have extra
    type requirements attached to them, such as that their value should be an integer
    or a dictionary.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In GDScript, we never deal directly with the functionality of the `Variant`
    class. GDScript wraps it nicely around whatever value we assign it, and thus we
    don’t have to worry about the `Variant` type. We can just reason about the data
    type of the data we are storing in the variable.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Type hinting function parameters
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In addition to hinting the type of a variable, we can also hint the type of
    the parameters of a function in the same manner:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you try to call this function with an argument that is not an integer,
    the editor will warn you that you are making a mistake. For example, take a look
    at the following line of code, which uses the `take_damage()` function from the
    previous code snippet:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, the engine will throw an error because the `take_damage()` function expects
    an integer value, and a string is not compatible with an integer.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Automatic conversion of variables
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: When you try `take_damage(1.5)`, you’ll see that the editor doesn’t show a warning
    or throw an error. This is because GDScript automatically converts certain variables
    from one type to another. This is called **implicit conversion**.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: One of these conversions happens between floating-point and integer numbers.
    In this case, GDScript will round the floating-point number down to the nearest
    integer value. For our little example at the start of this callout, this means
    that `1.5` will be rounded down to an integer value of `1`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Type hinting can also be combined with a default value for the parameter; just
    put the type hint first and specify the default value after:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `take_damage()` function now takes one parameter, `amount`, which is type
    hinted as an integer and has a default value of `1`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Type hinting function returns
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can also type hint the value that will be returned by a function. This is
    very useful because it gives us a lot of information about what to expect from
    that function. The way to do this is like so:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This `minimum()` function will always have to return a floating-point number,
    no matter which `return` statement does so.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: As an experiment, try returning nothing in a function that is type hinted to
    return a floating-point number; you’ll see that we get an error thrown at us by
    the engine.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Using void as a function return
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Sometimes, a function does not return a value at all. In that case, we can
    type hint the return value of that function using the `void` type. `void` cannot
    be used for variables, only in function definitions. So, `void` indicates that
    the function does not return anything:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: However, most people will omit the `void` type hint when a function doesn’t
    return anything and only type hint the function when it actually does return something.
    It is good to know that the `void` type hint exists when you encounter it somewhere.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Inferred types
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There is a second way of typing a variable without explicitly giving it a type.
    This method leverages the type recognition of the engine itself. We can namely
    use the type of the first value assigned to the variable as the type of that variable
    for the rest of the execution. We can do that like so:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This looks very similar to a regular, untyped, variable definition. But this
    time, we put a colon before the equals sign. This will lock the type of the variable
    to the type of the value we are assigning to it.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: This technique is called **type inferring** because GDScript is just taking
    the type of the value we are passing it during assignment.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note that, just like with normal variable type hinting, we can only infer a
    variable’s type while defining it. So, the following code will not work:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Type inferring can make it easier for us to type hint variables without having
    to think about the actual type in advance.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: null can be any type
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Knowing what type a variable carries does not mean we don’t have to look out
    for variables that are `null`. `null` can be assigned to any kind of variable
    that is not a basic type (`int`, `float`, `String`, and so on). So, arrays, dictionaries,
    self-defined classes, and the like can still be `null` if they are not initialized:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '`null` is often used to reset variables to an empty state.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Autocompletion
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Another great perk of typing our variables is that the text editor will help
    us out when we want to call a function or get to a member variable of a class
    by providing autocompletion. For example, if we have a string and we start typing
    to call a function on it, a little popup will show all the possible functions
    we are trying to get to. We can then just keep typing or use the arrow keys to
    select the right function and press *Enter* to select one. This helps tremendously
    if you know what you want to do but are not completely sure what the function
    was called, or just to speed up typing out long function names:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.2 – The code editor will help us out with autocompletion when using
    type hinting](img/B19358_04_2.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.2 – The code editor will help us out with autocompletion when using
    type hinting
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Autocomplete is our friend in general, so making the autocomplete, well, more
    complete will only help us out in the long run.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Using type hinting for named classes
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In addition to built-in types, we can also type hint our own custom classes.
    But for that, we first have to register a name for the type of our class. To register
    the name, we can use the `class_name` keyword followed by the name we would like
    the data type of our class to have at the top of the file, like so:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we see that we name our class `Player`. We can now use this type to type
    hint variables of the `Player` class and even use it to initiate a new instance
    of the class, like so:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Naming classes is an easy way to type hint variables with instances of our custom
    classes.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In addition to catching bugs before they happen and having autocompletion, type
    hinting has one last big advantage up its sleeve. If you type the variables in
    your game, the engine will be able to work with them way easier, resulting in
    better performance.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Because the engine doesn’t need to check if a variable will be able to perform
    certain operations, it can do more of these operations per second. In some cases,
    this will make your code twice as fast!
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Editor adding type hints
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As a last tip around type hinting, I would like to show you that the editor
    can help you out too! If you go into **Editor Settings** | **Text Editor** | **Completion**,
    there is a setting called **Add Type Hints**. This setting will let the editor
    autocomplete certain parts of your code with type hints. I recommend you turn
    it on:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.3 – The Add Type Hints setting](img/B19358_04_3.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.3 – The Add Type Hints setting
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: With this setting enabled, the editor will automatically fill out type hints
    whenever it has to generate any code for us – for example, when generating an
    empty script.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In this section, we learned a lot about type hinting and saw how it can enhance
    our coding experience. Next, let’s take a look at a very important concepts in
    programming: OOP.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: OOP primer
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'So far in this chapter, we have learned about functions, classes, and objects.
    These concepts are very powerful: they give us a completely different way of working
    with data and the logic that accompanies it.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In programming, there are multiple different paradigms of structuring code and
    data, one of them is **Object Oriented Programming** (**OOP**). GDScript is an
    **object-oriented** (**OO**) and **imperative** programming language, which means
    that we group data and its accompanying logic within classes and objects. The
    logic we write consists of statements that tell the computer fairly exactly what
    to do and how to do it for us. Each statement changes the internal state of the
    program. Most game engines and their accompanying programming languages are OO
    and imperative.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'OOP is built upon four key principles: inheritance, abstraction, encapsulation,
    and polymorphism. So, let’s have a look at these.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: OOP allows classes to inherit from one another. This means that we get all the
    functionality from the parent class for free and can extend it with extra logic.
    This makes reusing code very easy.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: For example, while there could be a lot of different enemies within a game,
    most of those would share some quite common code, and more common code would then
    differentiate them. Pathfinding, dealing damage, health management, inventory
    management, and so on would be shared by almost any enemy. So, we could define
    one class, `Enemy`, that encapsulates all of these functionalities and from which
    all other enemies can inherit.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'From here, we can define enemies that do the following:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Walk up to the player and use melee attacks.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Stay at a distance and shoot projectiles at the player.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Move around a lot and heal other enemies.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: And so forth…
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: This list is non-exhaustive and shows that we can base a diverse cast of enemies
    on the same base `Enemy` class.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can visually represent this inheritance, just like we do with humans and
    their families, using an inheritance tree:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Different kinds of enemies can easily be derived from the base
    Enemy class](img/B19358_04_4.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.4 – Different kinds of enemies can easily be derived from the base
    Enemy class
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Figure 4**.4* clearly shows how certain classes are related and/or differ
    from one another.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Abstraction
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: A class hides its internal implementation, abstracting its functionality only
    by exposing higher-level functions. The user of the class doesn’t care how certain
    results are accomplished; for all the outside world knows, the actual process
    to get certain results could be pure magic.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For the `Enemy` class example from earlier, this could mean that we can ask
    an enemy to move toward a certain point in the world, but not how. We have no
    business in how the enemy does its pathfinding or how it moves around the world.
    That is the enemy’s business:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Public and private member variables and methods tell the outside
    world how to interact with a class](img/B19358_04_5.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.5 – Public and private member variables and methods tell the outside
    world how to interact with a class
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In most programming languages, abstraction comes in the form of public and
    private member functions and variables. They work like this:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`public` and used to interact with the object.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private` are inaccessible by the outside world and can only be used by the
    class itself. These support the internal functionality of the class.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In GDScript, however, there is no way to explicitly mark variables or functions
    as public or private. Everything is public by default and accessible to the outside
    world. But there is a convention that GDScript developers took over from Python
    developers: we put an underscore (`_`) in front of variable and function names
    that are supposed to be private. This way, we can signal that a variable or method
    is supposed to be private and should not be used by anything outside of the class:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The engine will not enforce such private members, so you can still call them,
    but this is a very bad practice. You can see this distinction between public and
    private members built into the scripts we’ve already written with functions that
    are already present in the nodes, such as `_ready()` and `_update()`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Abstraction has multiple advantages:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Security**: Because the user of the class knows only to use public methods
    and variables, there is a lower chance of them accidentally misusing the class.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability**: Because the functionality of the class is hidden behind
    a few public functions, we can easily rewrite that functionality if needed without
    breaking other pieces of code.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This protects against other classes or pieces of code meddling too much with
    the internals of a class. Because what if we rewrite the pathfinding of enemies?
    If we properly encapsulate this code, there is no problem, but if other pieces
    of code call upon the enemies’ pathfinding directly, we will have to rewrite all
    of these as well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Hiding complexity**: Some code can be very complex, but by using classes,
    we can hide this behind easy-to-use methods and member variables.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we learned about abstraction, let’s look at the last principle: encapsulation.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: A well-written class should encapsulate all important information within itself
    so that the user of the class doesn’t have to worry about the nitty-gritty details.
    This means that a class should only expose select information to the outside world.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Encapsulation is an extension of abstraction but homed in on a class’s data.
    The less the outside world has to deal with member variables of a class directly
    and the more with member functions, the better.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The last principle of OOP is polymorphism, which says that objects and methods
    can morph into multiple different forms. In GDScript, this happens in two distinct
    ways: over objects and over methods.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Object polymorphism
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s say we have a class structure such as the one in the earlier example:
    a base enemy from which other enemies inherit. The code could look something like
    this:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we make instances of the `BuffEnemy` and `StrongEnemy` classes, we
    can type hint them as such, but we can also type hint them as their base class,
    `Enemy`:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This works because everything that inherits from the `Enemy` class should have
    the same member variables and functions at its core, so it can be put in a variable
    of the parent class.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'But you cannot assign an object from the `Enemy` type to a variable that is
    typed as one of its child classes. So, the next line will error:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The two child classes are also not compatible. So, the next line will error
    too:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: These preceding two examples don’t work because you are not guaranteed that
    the member variables and functions within the `Enemy` and `StrongEnemy` classes
    will be the same as those in the `BuffEnemy` class. And indeed, we can see that
    the `BuffEnemy` class has another member variable, `attack_distance`, that the
    `Enemy` and `StrongEnemy` classes do not have.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A good analogy for the concept of polymorphism is vehicles in the real world.
    Let’s say we have three vehicles:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Cars
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Bikes
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Trucks
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Although all three vehicles can move you from one point to another, have a
    certain number of wheels, and are made of metal, there is a certain hierarchy:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.6 – The class structure of simple vehicles](img/B19358_04_6.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.6 – The class structure of simple vehicles
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: A bike needs somebody to power it, while a car and a truck have motors. Furthermore,
    we could take the car as a template for the truck and say that the truck is a
    kind of long, big car.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The truck is also unique from the car because it has a place to transport larger
    cargo. This makes it so that we can say a truck is a car, but a car is not a truck.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Method overriding
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, there is also the possibility to override methods from the parent class.
    This will completely replace the original function with a new one, but only for
    the given child class. This is very useful when the child class needs some logic
    to be slightly or even drastically different from that of the parent class. To
    do this in GDScript, the method in the child class should adhere to the following
    conventions:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Have the same name
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Have the same number of parameters
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the parameters are typed, have the same types
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Have exactly the same default values, if any
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You see that we need to be exact when we want to override a method. If we are
    not, the engine will recognize it as a separate function or error because the
    overriding was done incorrectly.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s look at two classes that demonstrate this. A base class, `Enemy`, has
    a function called `die()` that prints out `"Aaargh!"`. This `die` function just
    prints out an exclamation when the enemy dies. Then, we inherit the `BuffEnemy`
    class from this base and override the `die()` function to print out `"How did
    you` `defeat me?!?"`:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If you call the `die()` function of each enemy type, you’ll see that they each
    have their own implementation of the function:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will print out `"Aaargh!"`, as expected. Now for the `BuffEnemy`
    class:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now, we execute the overridden `die()` function, and the printout will read
    `"How did you` `defeat me?!?"`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Even if you put the `BuffEnemy` object in an `Enemy` variable, it will still
    use the overridden function from the `BuffEnemy` class:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Again, we’ll see `"How did you defeat me?!?"` printed out. This is because the
    `BuffEnemy` class inherits from `Enemy` and thus is of type `Enemy`, but the implementation
    of its functions can still be overridden.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We learned a lot about OOP and its principles. It’s a very interesting but complex
    subject. Don’t worry too much about getting all principles perfect directly. Knowing
    they exist is already half the work. Let’s wrap the chapter up with some extra
    exercises in the next section.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Additional exercises – Sharpening the axe
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write a function, `limit_inventory()`, that takes an array representing an
    inventory and an integer. The function checks if the array is longer than the
    provided integer; if it is, it should remove all items that are too much. Lastly,
    the function returns the resulting array:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This example should print out `["``Boots", "Sword"]`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Rewrite the previous function so that the integer it takes has a default value
    of 3 for the following code to work:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should print out `["Boots", "``Sword", "Grapes"]`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Rewrite this code so that it does not error anymore:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write `Player` and `Enemy` classes that make the following code work. In this
    code, the player and enemy will damage each other until one of them has a health
    that is equal to or less than zero. See it as a primitive battle:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Rewrite the `Player` and `Enemy` classes from the previous exercise to inherit
    from the same base class.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: With functions, classes, and type hinting in our toolkit, we have finally learned
    all the basic building blocks of programming! From now on, the possibilities are
    endless!
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to write and structure our code in a
    clean way so that it’s easy to use and understand for others.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Quiz time
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Why do we use functions and classes?
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For which two purposes can the `return` keyword be used in functions?
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the scope of a variable? What are the different tiers?
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the scope of a function?
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Is a class a group of variables and functions?
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Given the following code, how do we make a new instance of the `Enemy` class?
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How do we call the instance of a class?
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What is type hinting?
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add type hinting to the following variables:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`var player_health = 5`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`var can_take_damage =` `true`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`var sword = { "damage_type": "fire", "damage":` `6 }`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to autocompletion and increased performances, what is the final
    benefit of using type hinting?
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
