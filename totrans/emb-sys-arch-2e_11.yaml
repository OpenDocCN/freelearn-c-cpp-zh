- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Trusted Execution Environment
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可信执行环境
- en: An important step in the technological evolution of microcontroller hardware
    architecture has been recently achieved with the introduction of a domain separation
    mechanism, which is already present in other architectures, where it is usually
    referred to as a **Trusted Execution Environment**, or **TEE**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器硬件架构技术演变的 重要一步最近已经通过引入一种域分离机制而实现，这种机制在其他架构中已经存在，通常被称为**可信执行环境**（Trusted
    Execution Environment，简称TEE）或**TEE**。
- en: TEE is an abstraction that provides two or more separated execution domains,
    or “worlds”, with different capabilities and permissions to access devices, resources,
    and peripherals.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: TEE是一种抽象，它提供了两个或更多分离的执行域，或“世界”，它们具有不同的能力和权限来访问设备、资源和外围设备。
- en: Isolating the execution environment of one or more software components and modules,
    also generally known as **sandboxing**, consists of limiting their view of the
    system, without impacting their performance and normal operation. This is a requirement
    for many use cases and domains in computer science, and not only for increasing
    the security of embedded systems.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个或多个软件组件和模块的执行环境隔离出来，也通常被称为**沙盒技术**，包括限制它们对系统的“视图”，而不影响它们的性能和正常操作。这是计算机科学中许多用例和领域的需求，而不仅仅是提高嵌入式系统的安全性。
- en: Similar hardware-assisted isolation mechanisms in other domains are the building
    blocks of the cloud server infrastructure as we know it today, in the form of
    virtualization extensions and security isolation mechanisms that allow us to run
    multiple “guest” virtual machines or containers simultaneously on the same hardware.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他域中类似的硬件辅助隔离机制是我们今天所知道的云服务器基础设施的构建块，以虚拟化扩展和安全隔离机制的形式存在，这些机制允许我们在同一硬件上同时运行多个“客户”虚拟机或容器。
- en: 'The concepts and technologies analyzed in this chapter are as follows:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分析的概念和技术如下：
- en: Sandboxing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沙盒技术
- en: TrustZone-M
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TrustZone-M
- en: System resources separation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统资源分离
- en: Building and running the example
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和运行示例
- en: By the end of this chapter, you will have learned about TEE and how to configure
    and use TrustZone-M on Cortex-M microcontrollers to obtain two separate execution
    domains.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解TEE以及如何配置和使用TrustZone-M在Cortex-M微控制器上以获得两个独立的执行域。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In order to run the proposed example available in this book’s repository, an
    STM32L552 microcontroller is required. The TrustZone-M technology is only supported
    by the newest family of ARM Cortex-M microcontrollers. The STM32L552 is a Cortex-M33,
    fully supporting TrustZone-M, which makes it a convenient and affordable choice
    for taking our first steps when learning about this technology.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行本书存储库中提供的示例，需要一个STM32L552微控制器。TrustZone-M技术仅由最新的ARM Cortex-M微控制器系列支持。STM32L552是一款Cortex-M33，完全支持TrustZone-M，这使得它成为学习这项技术的便捷且经济实惠的选择。
- en: The code files for this chapter are available at [https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter11](https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter11).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可在[https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter11](https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter11)找到。
- en: Sandboxing
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 沙盒技术
- en: Sandboxing is a generic concept in computer security that refers to a set of
    hardware and software measures that limit the “view” of the system for one or
    more of its components, to restrict the area of the system affected by accidental
    malfunctions or purposedly forged malicious attacks and prevent them from spreading
    across the entire system. Sandboxing can have different forms and implementations,
    which may or may not leverage specific hardware functionalities to improve safety
    and effectiveness.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 沙盒技术是计算机安全领域的一个通用概念，它指的是一系列硬件和软件措施，这些措施限制了一个或多个系统组件的“视图”，以限制系统因意外故障或故意制造的恶意攻击而受影响的区域，并防止它们在整个系统中传播。沙盒技术可以有不同的形式和实现方式，这些方式可能或可能不利用特定的硬件功能来提高安全性和有效性。
- en: By the term TEE, we refer to those sandbox mechanisms that involve the CPU keeping
    track of the secure status of the running code at all times, without significantly
    impacting the performance of the running application. Due to these TEE mechanisms
    being intrinsically bonded to the CPU design, TEE behavior, management, and communication
    models in sandboxes differ across heterogeneous platforms and heavily depend on
    the architecture. Moreover, TEEs can be used for different purposes, often in
    combination with cryptography to preserve the integrity and authenticity of software
    through a hardware root of trust.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过术语TEE，我们指的是那些涉及CPU始终跟踪运行代码的安全状态的沙箱机制，而不会显著影响运行应用程序的性能。由于这些TEE机制与CPU设计内在绑定，因此沙箱中的TEE行为、管理和通信模型在不同异构平台之间有所不同，并且高度依赖于架构。此外，TEE可用于不同的目的，通常与密码学结合使用，通过硬件信任根来保护软件的完整性和真实性。
- en: In 2005, Intel implemented the first virtualization instructions (Intel VT)
    for x86 processors to run isolated virtual machine code natively (as opposed to
    emulating the CPU in a dedicated process on the host machine), by providing the
    hardware-assisted virtualization of the core components (CPU, RAM, and peripherals).
    Intel CPUs limit the access of the guest virtual machines to the real hardware
    using an extension of the existing hierarchical protection domains, often simply
    called **rings**, already used for kernel/userspace separation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在2005年，英特尔为x86处理器实现了第一套虚拟化指令（Intel VT），以便原生地运行隔离的虚拟机代码（而不是在宿主机器上的专用进程中模拟CPU），通过提供核心组件（CPU、RAM和外设）的硬件辅助虚拟化。英特尔CPU通过扩展现有的分层保护域（通常简称为**环**，已用于内核/用户空间分离）来限制客户虚拟机对真实硬件的访问。
- en: Virtual machines are not the only use case of TEE on x86 processors. Intel **Software
    Guard Extensions** (**SGX**) is a set of security-related instructions present
    in many x86 CPUs, protecting specific memory regions, or enclaves, from unauthorized
    access. While these instructions have been recently removed from consumer Intel
    CPUs, they are still present in specific microprocessors in the cloud and enterprise
    hardware segment. SGX can be used for several purposes, such as providing a secure
    vault to hide secret keys to be used securely by the applications. Originally,
    however, they were introduced to fulfill the specific task of implementing **Digital
    Rights Management** (**DRM**) on PCs, which would have enforced copyright protection
    on media and proprietary software content by authorizing access to the protected
    content only to pre-authorized, signed software applications. In this setup, the
    adversaries that TEE protects the system against are the final users themselves.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机并不是x86处理器上TEE的唯一用例。英特尔**软件保护扩展**（**SGX**）是一组存在于许多x86 CPU中的安全相关指令，用于保护特定的内存区域或区域，防止未经授权的访问。尽管这些指令最近已从消费级英特尔CPU中移除，但它们仍然存在于云和商业硬件领域的特定微处理器中。SGX可用于多种目的，例如提供一个安全的保险库来隐藏用于安全使用的秘密密钥。然而，最初，它们被引入是为了在PC上实现**数字版权管理**（**DRM**），这将通过仅授权预授权、签名的软件应用程序访问受保护的内容来强制执行媒体和专有软件内容的版权保护。在这种设置中，TEE保护系统免受的对手是最终用户本身。
- en: Later on, AMD added vendor-specific architecture extensions to their CPUs, grouped
    into a technology called **Secure Encrypted Virtualization** (**SEV**). In addition
    to providing a sandbox for running virtual machines managed by a hypervisor, SEV
    uses hardware-assisted encryption to ensure the confidentiality of the content
    of single memory pages, and even CPU registers, during execution.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，AMD为其CPU添加了特定的架构扩展，这些扩展被归类为一种称为**安全加密虚拟化**（**SEV**）的技术。除了为由虚拟机管理程序管理的虚拟机提供沙箱外，SEV还使用硬件辅助加密来确保在执行过程中单个内存页面甚至CPU寄存器内容的机密性。
- en: The Intel architectures, however, were not the first ones to introduce CPU-assisted,
    built-in, secure extensions. ARM started research on trusted computing in the
    early 2000s and finally announced support for a technology called TrustZone in
    2003\. Modern ARM microprocessors, such as those in the Cortex-A family, support
    a technology called TrustZone-A, which implements two separate Secure (S) and
    Non-Secure (NS) worlds, the latter having a restricted pre-configured view on
    the actual system, while the former is capable of accessing all the hardware resources
    directly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，英特尔架构并不是第一个引入CPU辅助、内置的安全扩展的。ARM在2000年代初开始研究可信计算，并于2003年最终宣布支持名为TrustZone的技术。现代ARM微处理器，如Cortex-A系列中的那些，支持名为TrustZone-A的技术，该技术实现了两个独立的Secure（S）和非Secure（NS）世界，后者对实际系统有一个受限的预配置视图，而前者能够直接访问所有硬件资源。
- en: To find the first microcontrollers implementing TEE, we have to look at the
    recently designed RISC-V architecture. Both microprocessors and microcontrollers
    within the RISC-V families offer complete sandboxes separate from each other,
    in both 32-bit and 64-bit architectures that implement “S” or “U” extensions.
    Each hardware-assisted container provides a subset of the resources available
    on the system and runs its own firmware.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到第一个实现TEE的微控制器，我们必须看看最近设计的RISC-V架构。RISC-V家族中的微处理器和微控制器都提供了相互独立的完整沙盒，无论是在32位还是64位架构中实现“S”或“U”扩展。每个硬件辅助容器都提供系统上可用资源的一个子集，并运行自己的固件。
- en: Finally, the newest family of microcontrollers by ARM, the ARMv8-M family, includes
    the extensions and the microcode needed to implement isolation between secure
    and non-secure execution domains, based on the existing and well-oiled TrustZone
    technology design. This feature is called TrustZone-M, and it is the specific
    technology that we will be focusing on in more detail later in this chapter. ARMv8-M
    is a direct evolution of the ARMv7-M family of microcontrollers that have been
    used as a reference platform in all the previous chapters of this book.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，ARM最新的微控制器系列，ARMv8-M系列，包括实现基于现有且成熟的TrustZone技术设计的安全和非安全执行域之间隔离所需的扩展和微代码。这个特性被称为TrustZone-M，这是我们将在本章后面更详细地关注的特定技术。ARMv8-M是作为本书前几章参考平台的ARMv7-M系列微控制器的直接演变。
- en: The rest of this chapter will refer exclusively to TrustZone-M and how to configure
    and develop components in an embedded system, implementing TEE on the ARMv8-M
    family of microcontrollers. The term TrustZone from now on will refer specifically
    to the TrustZone-M technology.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分将专门介绍TrustZone-M以及如何在嵌入式系统中配置和开发组件，实现ARMv8-M系列微控制器上的TEE。从现在起，术语TrustZone将专门指TrustZone-M技术。
- en: TrustZone-M
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TrustZone-M
- en: ARMv7-M cores, such as the Cortex-M0+ and Cortex-M4 microcontrollers, have dominated
    the embedded market for decades and are still the most popular choice for many
    embedded system designs. Although there have been a number of changes and additions,
    the new Cortex-M23 and Cortex-M33 cores, as well as the newer M35P and M55, have
    inherited and expanded many of the successful features of the Cortex-M0, Cortex-M4,
    and Cortex-M7 microcontrollers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ARMv7-M核心，如Cortex-M0+和Cortex-M4微控制器，几十年来一直主导着嵌入式市场，并且仍然是许多嵌入式系统设计的首选。尽管已经发生了一些变化和增加，但新的Cortex-M23和Cortex-M33核心，以及更新的M35P和M55，继承了并扩展了许多Cortex-M0、Cortex-M4和Cortex-M7微控制器的成功特性。
- en: In a typical TrustZone use case, multiple actors may be involved in the distinct
    phases of software development. The owner of a device may provide a base system,
    already equipped with all the software authorized to run in the secure world.
    This would still leave the possibility for a system integrator to customize the
    non-secure part but with a restricted view of the system, which depends on the
    configuration of the resources allowed by the secure domain. The system integrator
    in this case receives a system that is partially locked, with TrustZone enabled
    and flash memory protections in place to protect its integrity. The secure software
    provided supervises the execution of any custom software in the non-secure domain,
    while preserving the resources mapped in the secure world and limiting access
    from the running application. System integrators without authorized access to
    the secure execution domain can still run privileged or non-privileged software
    in the non-secure world, thus including operating systems and device drivers that
    access the interfaces authorized, either directly, or with some assistance from
    the secure supervisor.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的TrustZone用例中，软件开发的不同阶段可能涉及多个参与者。设备的所有者可能提供一个基础系统，该系统已经配备了在安全世界中授权运行的全部软件。这仍然为系统集成商提供了定制非安全部分的可能性，但视图受到安全域允许的资源配置的限制。在这种情况下，系统集成商接收到的系统部分锁定，TrustZone已启用，并设置了闪存保护以保护其完整性。提供的安全软件监督非安全域中任何自定义软件的执行，同时保留安全世界中映射的资源，并限制运行应用程序的访问。没有授权访问安全执行域的系统集成商仍然可以在非安全世界中运行特权或非特权软件，从而包括访问授权接口的操作系统和设备驱动程序，这些接口可以是直接访问，也可以得到安全监督的一些帮助。
- en: The example associated with this chapter can be compiled and run on the reference
    platform. This example is based on the bootloader example introduced in [*Chapter
    4*](B18730_04.xhtml#_idTextAnchor115), *The Boot-Up Procedure*. This is due to
    the similarity of the structure of the TrustZone-based solution that we want to
    describe, because the software for the two execution domains is shipped into separate
    binaries. In the TrustZone case, the separation between bootloader code executing
    in the secure domain and staging an application running in the non-secure world
    will help us understand the elements and tools used to build, configure, and run
    the components on a real system.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本章相关示例可以在参考平台上编译和运行。此示例基于在第[*第4章*](B18730_04.xhtml#_idTextAnchor115)“启动过程”中介绍的引导加载程序示例。这是因为我们想要描述的基于TrustZone的解决方案的结构相似性，因为两个执行域的软件被分别打包到不同的二进制文件中。在TrustZone的情况下，引导加载程序代码在安全域中执行与在非安全世界中运行的应用程序之间的分离将帮助我们理解构建、配置和运行真实系统组件所使用的元素和工具。
- en: The next subsection contains a description of the reference platform, and then
    we will briefly introduce the execution model behind the secure and non-secure
    domains, which will then bring us to a deeper analysis of the TrustZone-M units
    and controllers regulating resource separation on a system.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节包含对参考平台的描述，然后我们将简要介绍安全和非安全域背后的执行模型，这将使我们进一步分析TrustZone-M单元和控制器在系统资源分离方面的调节。
- en: Reference platform
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考平台
- en: The microcontroller used for reference in the examples is the STM32L552, a Cortex-M33
    CPU that can be found on development boards in the convenient Nucleo-144 format.
    The STM32L5 series of microcontrollers may be considered the closest evolution
    of the older STM32F4 series, targeting the same slice of the market by combining
    low-power modes with high performance. For this reason, a microcontroller in this
    series has been selected in this chapter as a reference platform for the examples
    provided. Most of the concepts and the components of the TrustZone-M technology
    that will be described are, however, applicable to all the microcontrollers in
    the ARMv8-M family available from ST Microelectronics and several other chip manufacturers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中用作参考的微控制器是STM32L552，这是一种Cortex-M33 CPU，可以在方便的Nucleo-144格式开发板上找到。STM32L5系列微控制器可能被认为是较老STM32F4系列的最新演变，通过结合低功耗模式和高性能来针对相同的市场份额。因此，本章选择该系列微控制器作为提供的示例的参考平台。然而，将要描述的大多数TrustZone-M技术和组件概念都适用于ST
    Microelectronics和其他几个芯片制造商提供的所有ARMv8-M系列微控制器。
- en: 'On the STM32L552ZE, the CPU clock can be configured to run at 110 MHz. The
    microcontroller is equipped with 256 KB of SRAM, divided into two banks SRAM1
    and SRAM2 mapped into separate regions. 512 KB of flash memory can be used as
    one contiguous space or configured as two separate banks. The ST microcontroller
    provides platform-specific libraries and tools that are not part of the provided
    examples, which as usual are based on a fresh implementation that begins with
    an understanding of the documentation. The only exception to this approach in
    the example we are going to introduce is the use of the STM32 programming command-line
    interface, `STM32_Programmer_CLI`, which can be used to display the current value
    of the programmable option bytes, just by connecting through the ST-Link debugger
    on board to the PC with a USB cable and running the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在STM32L552ZE上，CPU时钟可以配置为以110 MHz运行。微控制器配备了256 KB的SRAM，分为两个银行SRAM1和SRAM2，分别映射到不同的区域。512
    KB的闪存内存可以用作一个连续的空间，或者配置为两个独立的银行。ST微控制器提供了特定于平台的库和工具，这些库和工具不包括在提供的示例中，通常这些示例基于一个全新的实现，从理解文档开始。在将要介绍的示例中，此方法的唯一例外是使用STM32编程命令行界面`STM32_Programmer_CLI`，该界面可以通过连接到PC的USB电缆并通过ST-Link调试器在板子上运行以下命令来显示可编程选项字节的当前值：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This tool will be useful to set the *option bytes* required to turn TrustZone
    on and off and set up other options for separating areas of flash memory. Values
    for option bytes are stored in non-volatile memory, and the values will be retained
    after the board has been powered off.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此工具将用于设置开启和关闭TrustZone所需的**选项字节**以及设置其他用于分离闪存区域的选项。选项字节值存储在非易失性存储器中，且在板子断电后这些值将得以保留。
- en: Important note
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Modifying some of the option bytes accessible through a programmer tool may
    be irreversible and, in some cases, brick your device. Please refer to the reference
    manual and application notes of your microcontroller before changing any option.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编程工具修改一些可访问的选项字节可能是不可逆的，在某些情况下，可能会损坏您的设备。在更改任何选项之前，请参阅您的微控制器的参考手册和应用笔记。
- en: One of the option bytes contains the `TZEN` flag, which should be disabled per
    the factory default. Only when TrustZone-M has been configured will we then enable
    it on the target to upload and run the example. The bootloader part in the secure
    world will be responsible for setting up the environment for the application,
    installed as a different binary, and executing it in the non-secure domain. We
    will then demonstrate the transitions between the two worlds by introducing new
    ARMv8 assembly instructions introduced for this purpose.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个选项字节包含`TZEN`标志，根据出厂默认设置，该标志应被禁用。只有在TrustZone-M配置完成后，我们才会在目标设备上启用它以上传和运行示例。安全世界中的引导加载程序部分将负责为作为不同二进制文件安装的应用程序设置环境，并在非安全域中执行它。我们将通过引入为此目的引入的新ARMv8汇编指令来演示两个世界之间的转换。
- en: In the next subsection, we will introduce the extensions included in the ARMv8-M
    architecture for executing code and controlling execution domains. These extensions
    are generic and included in all the ARMv8-M microcontrollers that support TrustZone,
    and are the core component for the execution in separate domains.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将介绍ARMv8-M架构中用于执行代码和控制执行域的扩展。这些扩展是通用的，包含在所有支持TrustZone的ARMv8-M微控制器中，并且是分离域执行的核心组件。
- en: Secure and non-secure execution domains
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全和非安全执行域
- en: In [*Chapter 10*](B18730_10.xhtml#_idTextAnchor357), *Parallel Tasks and Scheduling*,
    we learned that resource separation among threads and between threads and the
    operating system is possible, with the help of memory segmentation. In the ARMv8-m
    family of microcontrollers, TrustZone-M is often referred to as a security extension
    because it does, in fact, add one additional level of privilege separation between
    software components that are running on the target. These security extensions
    do not replace the existing thread separation we implemented earlier in the safe
    version of the scheduler. Instead, they introduce an additional security mode
    on top of the existing separation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第10章*](B18730_10.xhtml#_idTextAnchor357)“并行任务和调度”中，我们了解到，在内存分段的帮助下，线程之间以及线程和操作系统之间的资源分离是可能的。在ARMv8-m系列微控制器中，TrustZone-M通常被称为安全扩展，因为它确实在目标上运行的应用程序软件组件之间增加了一个额外的权限分离级别。这些安全扩展并不取代我们在调度器的安全版本中之前实现的现有线程分离。相反，它们在现有的分离之上引入了一个额外的安全模式。
- en: Similar to how an OS running without these extensions enforces a separation
    between thread mode and privileged mode, and can set boundaries for accessing
    memory-mapped areas using a MPU, TrustZone-M adds **Secure** (**S**) and **Non-Secure**
    (**NS**) execution domains (or “worlds”) with CPU-controlled access to the single
    resources.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与没有这些扩展的操作系统强制执行线程模式和特权模式之间的分离，并可以使用MPU设置访问内存映射区域的边界类似，TrustZone-M添加了**安全**（**S**）和**非安全**（**NS**）执行域（或“世界”），CPU可以控制对单个资源的访问。
- en: 'Within each of those worlds, it is still possible to implement privileged/thread
    separation by using the existing mechanism based on the CONTROL bit. Each security
    world can have its own privileged and non-privileged execution modes. An OS running
    in the NS world can still use the classic privilege separation that has been inherited
    from the previous ARMv7-M architecture. This creates a total of four available
    execution contexts that can be followed simultaneously by the CPU, summarized
    in this table as a combination of domain and privilege levels:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些世界中的每一个，仍然可以通过使用基于CONTROL位的现有机制来实现特权/线程分离。每个安全世界都可以有自己的特权和非特权执行模式。在NS世界中运行的操作系统仍然可以使用从之前的ARMv7-M架构继承的经典特权分离。这总共创建了四个可用的执行上下文，CPU可以同时跟踪，如下表所示，为域和特权级别的组合：
- en: '| **Secure world** | **Non-secure world** |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **安全域** | **非安全域** |'
- en: '| Secure privileged execution | Non-secure privileged execution |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 安全特权执行 | 非安全特权执行 |'
- en: '| Secure thread execution | Non-secure thread execution |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 安全线程执行 | 非安全线程执行 |'
- en: Table 11.1 – Available execution modes in secure/non-secure domains
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.1 – 安全/非安全域中的可用执行模式
- en: As we pointed out in [*Chapter 10*](B18730_10.xhtml#_idTextAnchor357), *Parallel
    Tasks and Scheduling*, the Cortex-M4 provides two separate stack pointers (MSP
    and PSP) to keep track of the different contexts when executing threads or kernel
    code. In the Cortex-M33, there is a total of four different stack pointers, MSP_S,
    PSP_S, MSP_NS, and PSP_NS. Each stack pointer is aliased into the actual SP register
    during execution, depending on the current domain and context.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[*第10章*](B18730_10.xhtml#_idTextAnchor357)，“并行任务与调度”中指出的，Cortex-M4提供了两个独立的栈指针（MSP和PSP）来跟踪执行线程或内核代码时的不同上下文。在Cortex-M33中，总共有四个不同的栈指针，分别是MSP_S、PSP_S、MSP_NS和PSP_NS。每个栈指针在执行期间都会根据当前域和上下文被映射到实际的SP寄存器。
- en: A very convenient feature has been added to the ARMv8-M architecture when MAIN
    extensions are present on the CPU, as in our reference platform. Each one of the
    four stack pointers has a corresponding **stack pointer limit** (**SPLIM**) register
    (called MSPLIM_S, PSPLIM_S, MSPLIM_NS, and PSPLIM_NS respectively). These registers
    indicate the lower limit for the stack pointer value in the four cases. This is
    in fact an effective countermeasure to the issues analyzed in the *Stack overflows*
    subsection in[*Chapter 5*](B18730_05.xhtml#_idTextAnchor149), *Memory Management*.
    The CPU will constantly check at runtime that the stack never grows past its lower
    limit in memory by generating an exception when this happens. This mechanism provides
    a better hardware-assisted way to protect memory from accidental stack overflows
    and collisions with other memory regions than the one proposed in the examples
    from [*Chapter 5*](B18730_05.xhtml#_idTextAnchor149), *Memory Management*, where
    we introduced a guard region between the two memory areas assigned to heap and
    stack.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当CPU上存在MAIN扩展时，ARMv8-M架构增加了一个非常方便的功能，正如我们的参考平台所示。这四个栈指针中的每一个都有一个对应的**栈指针限制**（**SPLIM**）寄存器（分别称为MSPLIM_S、PSPLIM_S、MSPLIM_NS和PSPLIM_NS）。这些寄存器指示四种情况下栈指针值的下限。这实际上是对*栈溢出*子节中分析的问题的有效对策，该子节在[*第5章*](B18730_05.xhtml#_idTextAnchor149)，“内存管理”中。当发生这种情况时，CPU将不断在运行时检查栈是否超过其内存中的下限，并生成异常。这种机制提供了一种比在[*第5章*](B18730_05.xhtml#_idTextAnchor149)，“内存管理”中提出的示例中提出的在堆和栈分配的两个内存区域之间引入保护区域更好的硬件辅助方式来保护内存，防止意外栈溢出和与其他内存区域的冲突。
- en: We already analyzed how to switch between execution modes, and how setting or
    clearing the CONTROL bit while returning from system calls plays a role in the
    transactions between privilege and thread execution modes. The mechanisms for
    switching between secure and non-secure executions are implemented via specific
    assembly instructions, which we will explain later after introducing resource
    separation between secure and non-secure worlds.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经分析了如何在执行模式之间切换，以及如何在从系统调用返回时设置或清除 CONTROL 位在特权与线程执行模式之间的交易中扮演的角色。在安全和非安全世界之间切换安全和非安全执行机制是通过特定的汇编指令实现的，我们将在介绍资源分离之后进行解释。
- en: To better understand what system resources the software running in the non-secure
    world may or may not access, the next section will go into detail about the different
    possibilities provided by the TrustZone-M controller modules to isolate and separate
    hardware resources.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解非安全世界运行的软件可能访问或无法访问的系统资源，下一节将详细介绍 TrustZone-M 控制器模块提供的不同可能性，以隔离和分离硬件资源。
- en: System resources separation
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统资源隔离
- en: When TrustZone-M is enabled, all areas mapped in memory, including RAM, peripherals,
    and even FLASH storage, receive a new security attribute. Besides the secure and
    non-secure domains, a security attribute may assume a third value, **Non-Secure
    Callable** (**NSC**). This last attribute defines special regions of memory used
    to implement transactions from the non-secure world to the secure world through
    a specific mechanism, which will be explained in the last section, *Building and
    running the example*. An NSC area is used to offer secure APIs that act like system
    calls with new powers. The secure domain exposes service routines that can perform
    specific controlled actions while accessing secure resources from its non-secure
    counterpart.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当 TrustZone-M 启用时，所有映射到内存的区域，包括 RAM、外设，甚至 FLASH 存储器，都会获得一个新的安全属性。除了安全和非安全域之外，安全属性还可能假设第三个值，**非安全可调用**（**NSC**）。这个最后的属性定义了用于通过特定机制从非安全世界到安全世界执行交易的特定内存区域，该机制将在最后一节“构建和运行示例”中解释。NSC
    区域用于提供类似系统调用的安全 API，具有新的功能。安全域公开服务例程，可以在访问其非安全对应方的安全资源时执行特定的受控操作。
- en: Security attributes and memory regions
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全属性和内存区域
- en: Cortex-M33 microcontrollers offer various levels of protection. The combination
    of the effects of those levels determines which of the memory-mapped areas associated
    with a resource on the system are available to both execution domains and which
    of them are only accessible from the secure world.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Cortex-M33 微控制器提供各种级别的保护。这些级别效果的组合决定了与系统上资源相关的哪些内存映射区域对执行域可用，以及哪些仅从安全世界可访问。
- en: Enabling TrustZone-M will also duplicate the representation of some of the system
    resources. The flash memory usually mapped from the start of the address 0x08000000
    has an alias in the region 0x0C000000, which is used to access the same storage
    from the secure world. Many system registers are “banked” and have secure and
    non-secure versions at separate memory locations. For example, the GPIOA controller
    is mapped to the address 0x42020000 when TrustZone is disabled. When TrustZone
    is enabled, the same address is used by software running in the non-secure domain
    if the GPIOA controller is accessible from the non-secure world. However, software
    running in the secure domain will use the same controller mapped from the start
    of the address 0x52020000\. The same banking applies to many other registers in
    the peripheral region, which have secure and non-secure versions of the same registers
    mapped into two separate regions.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 TrustZone-M 还会复制一些系统资源的表示。通常从地址 0x08000000 开始映射的闪存，在区域 0x0C000000 有一个别名，用于从安全世界访问相同的存储。许多系统寄存器是“分区的”，并在不同的内存位置有安全和非安全版本。例如，当
    TrustZone 禁用时，GPIOA 控制器映射到地址 0x42020000。当 TrustZone 启用时，如果 GPIOA 控制器可以从非安全世界访问，则运行在非安全域的软件将使用相同的地址。然而，运行在安全域的软件将使用从地址
    0x52020000 开始映射的相同控制器。相同的分区也适用于外设区域中的许多其他寄存器，这些寄存器有相同寄存器的安全和非安全版本映射到两个单独的区域。
- en: 'Before being processed by other TrustZone-aware components, each memory access
    is monitored and filtered by two units responsible for configuring the attributes.
    These are the **Security Attribution Unit** (**SAU**) and **Implementation-Defined
    Attribution Unit** (**IDAU**). These units affect the accessibility of the entire
    memory mapping regardless of the type of resource associated with each region.
    While the SAU is configurable through a set of registers, the IDAU contains hardcoded
    mappings enforced by the chip manufacturer. The combination of the attributes
    of IDAU and SAU influences the accessibility of each memory-mapped region, the
    following in particular:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在由其他TrustZone感知组件处理之前，每个内存访问都由负责配置属性的单元进行监控和过滤。这些是**安全属性单元**（**SAU**）和**实现定义属性单元**（**IDAU**）。这些单元影响整个内存映射的可访问性，而不管每个区域关联的资源类型如何。虽然SAU可以通过一组寄存器进行配置，但IDAU包含由芯片制造商强制执行的硬编码映射。IDAU和SAU属性的组合影响每个内存映射区域的可访问性，特别是以下方面：
- en: Regions mapped as secure by IDAU are not influenced by SAU attributes and will
    always stay mapped as secure
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由IDAU映射为安全的区域不受SAU属性的影响，并且始终保持为安全映射
- en: Regions mapped as NSC by IDAU can be secure or NSC, based on the SAU attribute
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由IDAU映射为NSC的区域可以是安全的或NSC，这取决于SAU属性
- en: Regions mapped as non-secure by IDAU will follow the SAU mapping
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由IDAU映射为非安全的区域将遵循SAU映射
- en: 'The combination of the attributes and the resulting mapping for each region
    is summarized in the following table:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 每个区域的属性及其结果映射总结在下表中：
- en: '| **IDAU attribute** | **SAU attribute** | **Resulting attribute** |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| **IDAU属性** | **SAU属性** | **结果属性** |'
- en: '| Secure | Secure, NSC, or Non-secure | Secure |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 安全 | 安全、NSC或非安全 | 安全 |'
- en: '| NSC | Secure | Secure |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| NSC | 安全 | 安全 |'
- en: '| Non-secure | Secure | Secure |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 非安全 | 安全 | 安全 |'
- en: '| NSC | NSC or Non-secure | NSC |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| NSC | NSC或非安全 | NSC |'
- en: '| Non-secure | NSC | NSC |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 非安全 | NSC | NSC |'
- en: '| Non-secure | Non-secure | Non-secure |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 非安全 | 非安全 | 非安全 |'
- en: Table 11.2 – A combination of IDAU and SAU attributes
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.2 – IDAU和SAU属性的组合
- en: 'By default, our IDAU in the STM32L552 reference platform enforces the secure/NSC
    mapping of a few key regions:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们的STM32L552参考平台中的IDAU强制执行几个关键区域的保护/NSC映射：
- en: The flash memory mapping in secure space, starting at the address `0x0C000000`
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全空间中的闪存映射，从地址`0x0C000000`开始
- en: The second SRAM bank, SRAM2, mapped from the start of the address `0x30000000`
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个SRAM银行，SRAM2，从地址`0x30000000`开始映射
- en: The memory between `0x50000000` and `0x5FFFFFFF`, reserved for secure peripherals’
    control and configuration
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地址`0x50000000`到`0x5FFFFFFF`之间的内存，保留用于安全外设的控制和配置
- en: The SAU sets all the regions as secure upon reset and is disabled by default.
    To execute non-secure code, we must define at least two non-secure regions within
    the intervals allowed by the IDAU configuration.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: SAU在复位时将所有区域设置为安全，并且默认情况下是禁用的。要执行非安全代码，我们必须在IDAU配置允许的间隔内定义至少两个非安全区域。
- en: 'In our example, we initialize a few memory areas to allow access from the applications,
    before enabling SAU. SAU is controlled through four main 32-bit registers:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们在启用SAU之前初始化了一些内存区域，以允许应用程序访问。SAU通过四个主要的32位寄存器进行控制：
- en: '**SAU_CTRL** (SAU control): Used to activate SAU. It contains a flag to “invert”
    the logic of the SAU filter, by setting all the memory regions as non-secure.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SAU_CTRL**（SAU控制）：用于激活SAU。它包含一个标志来“反转”SAU过滤器的逻辑，通过将所有内存区域设置为非安全。'
- en: '**SAU_RNR** (SAU region number register): Contains the region number to select
    at the beginning of the configuration procedure for the memory regions. Further
    writes to SAU_RBAR and SAU_RLAR will refer to this numbered region.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SAU_RNR**（SAU区域号寄存器）：包含在配置内存区域时选择的区域号。对SAU_RBAR和SAU_RLAR的进一步写入将引用此编号区域。'
- en: '**SAU_RBAR** (SAU region base address register): Indicates the base address
    of the region that we want to configure.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SAU_RBAR**（SAU区域基址寄存器）：指示我们想要配置的区域的基本地址。'
- en: '**SAU_RLAR** (SAU region limit address register): Contains the end address
    of the region to configure. The least significant 5 bits are reserved for flags.
    Bit 1, when on, indicates that the region is secure or non-secure callable. Bit
    0 enables the region and indicates that its configuration is complete.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SAU_RLAR**（SAU区域限制地址寄存器）：包含要配置的区域结束地址。最低5位保留为标志位。位1，当开启时，表示区域是安全的或非安全可调用的。位0启用区域，并指示其配置已完成。'
- en: 'In the following example code, you can find the `sau_init_region` convenience
    function. Given a region identifier, base address, end address, and secure bit
    value, it will set all the register values accordingly:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例代码中，你可以找到`sau_init_region`便利函数。给定一个区域标识符、基址、结束地址和安全位值，它将相应地设置所有寄存器值：
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This function is called by the `secure_world_init` initialization function
    to map the four SAU regions that we want to configure for this example, which
    are, specifically, the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数由`secure_world_init`初始化函数调用，用于映射我们想要为此示例配置的四个SAU区域，具体如下：
- en: '`nsc_blue_led_toggle`, which will be the only way that the application can
    access an otherwise secure-only GPIO, wired to the blue LED on the Nucleo board.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nsc_blue_led_toggle`，这是应用程序访问连接到Nucleo板上蓝色LED的否则仅限安全的GPIO的唯一方式。'
- en: '`0x08040000`. This is where the code of our non-secure application will reside.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0x08040000`。这是我们的非安全应用程序代码将驻留的地方。'
- en: '**Region 2**: An non-secure part of the SRAM1 bank that can be used by the
    non-secure application for the stack and variables. This is a necessary step to
    ensure the application can access RAM addresses.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区域2**：SRAM1银行的一个非安全部分，可以被非安全应用程序用于堆栈和变量。这是确保应用程序可以访问RAM地址的必要步骤。'
- en: '`0x40000000`, including the non-secure GPIO controllers. This area will be
    accessed by the non-secure application to set the system clock and control the
    green led in the example.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0x40000000`，包括非安全GPIO控制器。此区域将由非安全应用程序访问以设置系统时钟并控制示例中的绿色LED。'
- en: 'The code for the SAU initialization in the example is the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中SAU初始化的代码如下：
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The code in the tail of this function activates the SAU and enables a specific
    handler that detects secure faults:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数末尾的代码激活了SAU并启用了一个特定处理程序，用于检测安全故障：
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By default, enabling SAU would mark all regions as secure, so each region configuration
    trims an non-secure or non-secure callable “window” within the addressable memory
    space. Region 0 is the only region marked with the NSC flag in our example configuration,
    which means that NSC code (explained later) will be installed here by the secure
    application. Regions 1, 2, and 3 are the only memory areas that may be accessed
    when running in the non-secure domain with TrustZone-M enabled.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，启用SAU会将所有区域标记为安全，因此每个区域配置都会在可寻址内存空间内裁剪一个非安全或非安全可调用“窗口”。在我们的示例配置中，区域0是唯一带有NSC标志的区域，这意味着安全应用程序（稍后解释）将在这里安装NSC代码。区域1、2和3是当在启用TrustZone-M的非安全域中运行时唯一可能访问的内存区域。
- en: As previously mentioned, IDAU/SAU is just the first level of filters for the
    TrustZone-M protection mechanisms. Flash memory and RAM are protected by additional
    secure gates, which can be block-based or watermark-based. The STM32L552 microcontroller
    is equipped with a **Global TrustZone Controller** (**GTZC**), which includes
    one watermark-based gate controller for the flash and one block-based to define
    secure/non-secure RAM blocks.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，IDAU/SAU只是TrustZone-M保护机制的第一个过滤级别。闪存和RAM通过额外的安全门进行保护，这些门可以是基于块的或基于水印的。STM32L552微控制器配备了一个**全局TrustZone控制器**（**GTZC**），它包括一个基于水印的门控制器用于闪存和一个基于块的控制器用于定义安全/非安全RAM块。
- en: Flash memory and secure watermarks
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闪存和安全的标志
- en: On the target platform, flash memory can be configured to be mapped as a single,
    contiguous space, or split in half by activating a dual bank configuration. For
    the sake of our TrustZone-M example, we will keep the flash memory in a single
    bank.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在目标平台上，闪存可以配置为映射为一个单一的、连续的空间，或者通过激活双银行配置将其分成两半。为了我们的TrustZone-M示例，我们将保持闪存在一个单独的银行中。
- en: In this configuration, when TrustZone is enabled, we can assign an non-secure
    area in the higher half of the contiguous flash memory space, starting at the
    address `0x08040000`. When the flash is divided into two banks, each bank can
    configure its own independent secure watermark. The flash area in between the
    start/end addresses is marked as secure, and everything left outside of the marks
    is non-secure. The secure area in each bank is delimited by the value of the option
    bytes, SECWMx_PSTRT and SECWMx_PEND. If the delimiters overlap – that is, when
    the value of SECWMx_PEND is bigger than that of SECWMx_PSTRT – the entire area
    is marked as non-secure.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置中，当 TrustZone 启用时，我们可以在连续闪存空间的高半部分分配一个非安全区域，起始地址为 `0x08040000`。当闪存分为两个银行时，每个银行都可以配置其自己的独立安全水印。起始/结束地址之间的闪存区域被标记为安全，而所有未标记的区域都是非安全的。每个银行中的安全区域由选项字节
    SECWMx_PSTRT 和 SECWMx_PEND 的值界定。如果界定符重叠——即 SECWMx_PEND 的值大于 SECWMx_PSTRT 的值——则整个区域被标记为非安全。
- en: 'Their value can be modified using the programmer tool provided, as shown here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 他们的值可以使用提供的程序员工具进行修改，如下所示：
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In single-bank mode, each flash sector is 4096 B. By setting these option bytes,
    we are marking the first 64 sectors (from `0x00` to `0x39`) as secure, which leaves
    the other half of the flash, starting from the address `0x08040000`, to be used
    by the non-secure application in our example. The programmer tool, launched with
    the `-ob displ` option, will show the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在单银行模式下，每个闪存扇区为 4096 B。通过设置这些选项字节，我们将前 64 个扇区（从 `0x00` 到 `0x39`）标记为安全，这留下了从地址
    `0x08040000` 开始的闪存另一半，供我们的示例中的非安全应用程序使用。使用 `-ob displ` 选项启动的程序员工具将显示以下内容：
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: GTZC configuration and block-based SRAM protection
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GTZC 配置和基于块的 SRAM 保护
- en: 'An additional gate to control access is present in the TrustZone controller
    on the reference platform. The block-based gate component of the GTZC allows us
    to configure the secure-only bit to portions of SRAM. SRAM on STM32L552 is divided
    into two main banks:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在参考平台的 TrustZone 控制器中存在一个用于控制访问的额外门。GTZC 的基于块的门组件允许我们配置仅安全位到 SRAM 的部分。STM32L552
    上的 SRAM 分为两个主要银行：
- en: 'SRAM1: 192 KB of RAM mapped at the address `0x08000000`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SRAM1：192 KB 的 RAM 映射到地址 `0x08000000`
- en: 'SRAM2: 64 KB of RAM mapped at the address `0x30000000` and set as NSC in IDAU'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SRAM2：64 KB 的 RAM 映射到地址 `0x30000000` 并在 IDAU 中设置为 NSC
- en: In our example, we are marking the higher half of SRAM1, starting at the address
    `0x2018000`, as non-secure. To do so, the GTZC provides two sets of registers,
    one for each bank, to configure the block-based gate to each page in RAM. Each
    block represents 25 6B, and each 32-bit register, by holding one secure bit per
    block, can map 32 pages, also defined as an 8 KB superblock. 24 registers are
    required to map the 24 superblocks for a total of 192 KB in SRAM1, and only 8
    are required to map the 64 KB area in SRAM2.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将 SRAM1 的高半部分标记为非安全，起始地址为 `0x2018000`。为此，GTZC 提供了两套寄存器，每套寄存器对应一个银行，以配置基于块的门到
    RAM 的每一页。每个块代表 25 个 6B，每个 32 位寄存器通过每个块保留一个安全位，可以映射 32 页，也定义为 8 KB 的超级块。需要 24 个寄存器来映射
    SRAM1 中的 24 个超级块，总共 192 KB，而映射 SRAM2 中的 64 KB 区域只需要 8 个。
- en: 'Like for the SAU initialization, once again the approach taken in the example
    relies on a convenient macro that, given a memory bank, the superblock number,
    and its register value, calculates the address for the right register that refers
    to the superblock and generates the right assignment statement:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 SAU 初始化一样，示例中采用的方法再次依赖于一个方便的宏，该宏给定一个内存区、超级块编号及其寄存器值，计算指向超级块的正确寄存器的地址，并生成正确的赋值语句：
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This way we can easily configure block-based gates of contiguous regions within
    a loop. The secure-world application example uses the following function to configure
    the block-based gates for the two banks:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以轻松地在循环中配置连续区域的基于块的门。安全世界应用程序示例使用以下函数来配置两个银行的基于块的门：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We now have everything required to run the simplest non-secure application on
    the system; we have defined the non-secure areas in SAU, set the watermark for
    the separation of the flash memory, and finally, set the block-based gates to
    enable non-secure access to the higher half of SRAM1.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了在系统上运行最简单的非安全应用程序所需的一切；我们在 SAU 中定义了非安全区域，设置了闪存分离的水印，并最终设置了基于块的门以启用对
    SRAM1 高半部分的非安全访问。
- en: There is, however, another aspect that deserves attention, and that is the possibility
    of configuring secure access to peripherals.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一个值得注意的方面，那就是配置对外围设备进行安全访问的可能性。
- en: Configuring secure access to peripherals
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置对外围设备的安全访问
- en: 'On the reference platforms, peripherals are divided into two categories:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在参考平台上，外围设备分为两类：
- en: '**Securable peripherals**: Peripherals are not directly connected to a local
    bus, but through a gate system controlled by the **TrustZone Secure** **Controller**
    (**TZSC**)'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可安全配置的外围设备**：外围设备不是直接连接到本地总线，而是通过由**TrustZone安全控制器**（**TZSC**）控制的门系统连接'
- en: '**TrustZone-aware peripherals**: These are peripherals that integrate with
    TrustZone mechanisms – for example, by offering separate interfaces to access
    their resources, depending on the execution domain'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信任区域感知的外围设备**：这些是与TrustZone机制集成的外围设备——例如，通过提供根据执行域提供单独接口来访问其资源'
- en: For the first category of peripherals, the configuration of the secure access
    and privileged access within secure and non-secure domains can be configured through
    the TZSC registers within the GTZC. At system startup, all devices are set as
    secure by default, so to enable access to UART, I2C, timers, and other peripherals,
    it will be necessary to turn off the secure bit associated with the specific controller.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一类外围设备，在安全和非安全域内配置安全访问和特权访问可以通过GTZC中的TZSC寄存器进行。在系统启动时，所有设备默认设置为安全，因此要启用对UART、I2C、定时器和其他外围设备的访问，需要关闭与特定控制器关联的安全位。
- en: 'TrustZone-aware peripherals have banked registers for both secure domains.
    In the next example, we configure three GPIO controllers (`GPIOA`, `GPIOB`, and
    `GPIOC`), which are connected to the LEDs on the Nucleo-144 board, via pins C7
    (the green LED), B7 (the blue LED), and A9 (the red LED). The GPIO controller
    registers, when TrustZone is enabled, are banked into two regions. You will notice
    in the example code the difference between the two LED driver interfaces in the
    secure and non-secure applications. In the secure version of `led.h`, we define
    the following address base for the GPIO controller registers:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 信任区域感知的外围设备在安全域和非安全域都有寄存器银行。在下一个示例中，我们配置了三个GPIO控制器（`GPIOA`、`GPIOB`和`GPIOC`），这些控制器通过引脚C7（绿色LED）、B7（蓝色LED）和A9（红色LED）连接到Nucleo-144板上的LED。当启用TrustZone时，GPIO控制器寄存器被分入两个区域。你会在示例代码中注意到安全和非安全应用程序中两个LED驱动接口之间的差异。在`led.h`的安全版本中，我们为GPIO控制器寄存器定义了以下地址基：
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The same controllers, in the non-secure world application, are mapped in the
    non-secure peripheral address space:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在非安全世界应用程序中，相同的控制器映射到非安全外围设备地址空间：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This ensures that the GPIO configuration is accessible only through the interface
    assigned to the non-secure space when running in the non-secure domain.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了当在非安全域运行时，GPIO配置只能通过分配给非安全空间的接口访问。
- en: Additionally, each GPIO controller provides an interface to secure each single
    controlled pin. This is achieved through a write-only register controlling the
    secure and non-secure access with a flag corresponding to each pin. The register
    is called GPIOx_SECCFG and is located at an offset of `0x24` in each GPIO controller
    space. This is only accessible for writing when running in a secure domain.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每个GPIO控制器都提供了一个接口来安全地控制每个单个受控引脚。这是通过一个只写寄存器实现的，该寄存器控制安全和非安全访问，并带有对应每个引脚的标志。该寄存器称为GPIOx_SECCFG，位于每个GPIO控制器空间的`0x24`偏移处。当在安全域运行时，该寄存器仅可写入。
- en: 'In the example, we define functions to set/clear the secure bit for each GPIO
    pin connected to the three LEDs. For example, we can set the secure state of the
    red LED, before staging the non-secure application to disallow changing the LED
    state in the application by calling `red_led_secure(1)`, which is implemented
    as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们定义了设置/清除每个连接到三个LED的GPIO引脚的安全位的函数。例如，我们可以在将非安全应用程序部署到舞台之前设置红色LED的安全状态，通过调用`red_led_secure(1)`来禁止在应用程序中更改LED状态，该函数的实现如下：
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Our secure-world example application in fact restricts access to the blue and
    red LED before staging while allowing access to the green LED:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的安全世界示例应用程序实际上在部署之前限制了蓝色和红色LED的访问，同时允许访问绿色LED：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After the domain switch, the non-secure application will attempt to turn on
    all three LEDs, but only the green one will actually be turned on, and the other
    will stay off because access through the non-secure interface is gated by the
    SECCFG bit set in the secure world and has no effect on the GPIO.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在域切换之后，非安全应用将尝试开启所有三个LED灯，但实际上只有绿色LED灯会被点亮，其他LED灯将保持关闭状态，因为通过非安全接口的访问受到在安全世界中设置的SECCFG位的控制，并且对GPIO没有影响。
- en: Blinking the blue LED, however, will still be done using a special non-secure
    callable interface, explained in the *Inter-domain transitions* subsection in
    the next section.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，闪烁蓝色LED仍然将使用一个特殊的非安全可调用接口来完成，这将在下一节“跨域转换”小节中解释。
- en: After configuring all the securable and TrustZone-aware peripherals, we are
    finally ready to build and install the firmware images for the two domains and
    observe their effects on the system.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置完所有可安全化和TrustZone感知的外设之后，我们最终准备好构建和安装两个域的固件镜像，并观察它们对系统的影响。
- en: Building and running the example
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和运行示例
- en: Finally, we are putting all we have learned about TrustZone-M into practice,
    by activating the option flags needed to enable TrustZone-M and running the two
    software components associated with the execution domains.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将所学到的关于TrustZone-M的所有知识付诸实践，通过激活启用TrustZone-M所需的选项标志，并运行与执行域相关的两个软件组件。
- en: Enabling TrustZone-M
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用TrustZone-M
- en: By default, TrustZone-M is turned off on our microcontroller when it is in its
    factory state. Turning on TrustZone is a one-way operation, but it is typically
    not irreversible unless combined with other hardware-assisted protection mechanisms
    that make it impossible to disable it when the embedded system is deployed. Disabling
    TrustZone once enabled, however, requires a more complex procedure than just clearing
    one bit in a register.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当我们的微控制器处于出厂状态时，TrustZone-M是关闭的。开启TrustZone是一个单向操作，但通常不是不可逆的，除非结合其他硬件辅助保护机制，使得在嵌入式系统部署时无法禁用它。然而，一旦启用，禁用TrustZone需要比仅仅清除寄存器中的一个位更复杂的程序。
- en: Important note
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Please refer to your microcontroller’s reference manual and application notes,
    and ensure that you understand the procedure and the consequences of enabling
    or attempting to disable TrustZone-M on your device.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考您的微控制器参考手册和应用笔记，并确保您理解启用或尝试禁用TrustZone-M在您的设备上的程序及其后果。
- en: 'On the reference platform, to enable TrustZone, we set the associated flag
    in the option bytes via the following command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在参考平台上，为了启用TrustZone，我们通过以下命令在选项字节中设置相关的标志：
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once TrustZone has been enabled, we can build and install the secure firmware.
    The next subsection highlights some important aspects to consider when building
    the secure part of the system.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦TrustZone被启用，我们就可以构建和安装安全固件。下一小节将突出构建系统安全部分时需要考虑的一些重要方面。
- en: Secure application entry point
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全应用入口点
- en: 'The regions defined in the secure-world linker script reflect the system resources
    as seen by the secure firmware. We allocate a RAM region covering the lower half
    of the SRAM1 bank:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在安全世界链接脚本中定义的区域反映了安全固件所看到的系统资源。我们分配了一个覆盖SRAM1银行下半部分的RAM区域：
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Our `.text` and `.data` LMSes end up in the FLASH region, mapped to its secure-domain
    address:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`.text`和`.data` LMS最终位于FLASH区域，映射到其安全域地址：
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For our simple example, 4 KB is enough to store the bootloader image. Additionally,
    we define a non-secure callable area, which will contain the implementation of
    our secure stubs. This is an area dedicated to accessing secure APIs from the
    non-secure world through pre-defined inter-domain special function calls:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的简单示例中，4 KB足以存储引导加载程序镜像。此外，我们定义了一个非安全可调用区域，该区域将包含我们安全stub的实现。这是一个专门用于从非安全世界通过预定义的跨域特殊功能调用来访问安全API的区域：
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The entry point of the secure application on the reference platform is hardcoded
    in the option bytes. Before installing our image, we must ensure that the option
    bytes for `SECBOOTADD0` are configured to point to the address `0x0C000000`, which
    is the beginning of the flash memory in the secure system view. If, for any reason,
    the value has been previously modified, it can be restored via the following command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 参考平台上的安全应用入口点硬编码在选项字节中。在安装我们的镜像之前，我们必须确保`SECBOOTADD0`的选项字节配置为指向地址`0x0C000000`，这是安全系统视图下闪存的开始地址。如果由于任何原因该值已被修改，可以通过以下命令恢复：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is because the granularity of `SECBOOTADD0` is 128 bytes, so setting a
    value of `0x180000` will result in a pointer to the address `0x0C000000`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`SECBOOTADD0`的粒度是128字节，所以设置`0x180000`的值将导致指向地址`0x0C000000`的指针。
- en: This last value completes the setup of option bytes, so we are finally ready
    to build and install the secure application.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后这个值完成了选项字节的设置，因此我们最终准备好构建和安装安全应用程序。
- en: A list of the option bytes and their values, assigned in order to configure
    the target run of the example code, is provided in the repository of this book,
    in the `Chapter11/option-bytes.txt` file.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一份选项字节及其值的列表，按顺序分配以配置示例代码的目标运行，可在本书的存储库中找到，在`Chapter11/option-bytes.txt`文件中。
- en: Compiling and linking secure-world applications
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译和链接安全世界应用程序
- en: 'If you look in the Makefile for the secure-world application, you will notice
    two new flags have been introduced in the build process. gcc requires us to use
    the `-mcmse` flag to indicate that we are compiling secure code for a TrustZone
    system. By adding this flag, we are telling the compiler to generate `nsc_led.c`
    file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看安全世界应用程序的Makefile，你将注意到在构建过程中引入了两个新的标志。gcc要求我们使用`-mcmse`标志来指示我们正在为TrustZone系统编译安全代码。通过添加此标志，我们告诉编译器生成`nsc_led.c`文件：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `__attribute__((cmse_nonsecure_entry))` compiler attribute tells gcc to
    generate the SG stub for this function. The `FLASH_NSC` section that we defined
    in the linker script is used to store the SG stubs for the secure API that we
    configure. The SG stubs are automatically placed in a section called `.gnu.sgstubs`,
    which we place in the `FLASH_NSC` region in the example linker script:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`__attribute__((cmse_nonsecure_entry))`编译器属性告诉gcc为该函数生成SG存根。我们在链接器脚本中定义的`FLASH_NSC`部分用于存储我们配置的安全API的SG存根。SG存根自动放置在名为`.gnu.sgstubs`的部分中，我们在示例链接器脚本中将它放置在`FLASH_NSC`区域：'
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The extra linker flags, `--cmse-implib` and `--out-implib=led_cmse.o`, have
    a different purpose that does not directly affect the secure domain. When linking
    the secure application, by adding these flags we are asking the linker to create
    a new object file, which will not be linked in the final secure application. This
    new object file instead will be linked in the non-secure world application and
    contains the veneers for the secure API. These veneers prepare the jump from non-secure
    to non-secure callable world. In other words, this new file, `led_cmse.o`, is
    the non-secure world counterpart implementation of the secure calls through a
    non-secure callable SG stub. The veneers are generated by the linker and contain
    the code needed to jump to the non-secure callable stub. To recap, to build the
    secure application, we need to introduce two specific set of flags:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的链接器标志`--cmse-implib`和`--out-implib=led_cmse.o`具有不同的目的，这不会直接影响安全域。当链接安全应用程序时，通过添加这些标志，我们要求链接器创建一个新的目标文件，这个文件将不会链接到最终的安全应用程序中。这个新的目标文件将链接到非安全世界应用程序中，并包含安全API的封装。这些封装准备从非安全到非安全可调用世界的跳转。换句话说，这个新的文件`led_cmse.o`是非安全世界对应的安全调用通过非安全可调用SG存根的实现。这些封装由链接器生成，并包含跳转到非安全可调用存根所需的代码。总结一下，为了构建安全应用程序，我们需要引入两组特定的标志：
- en: The`–mcmse` compile time flag, which tells gcc that we are generating secure
    code for TrustZone and enables SG stubs for non-secure entry points
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`–mcmse`编译时标志，它告诉gcc我们正在为TrustZone生成安全代码，并为非安全入口点启用SG存根'
- en: The`–cmse-implib` and `–out-implib=…` linker flags, which tell the linker to
    generate veneers in object file formats, which in turn will be linked to the non-secure
    domain to access the associated secure API calls
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`–cmse-implib`和`–out-implib=…`链接器标志，它们告诉链接器在目标文件格式中生成封装，这些封装随后将链接到非安全域以访问相关的安全API调用'
- en: 'Once built using `make`, the secure firmware image can be uploaded to the device
    flash, using the following command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用`make`构建，可以使用以下命令将安全固件映像上传到设备闪存：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The microcontroller flash is now populated with the secure firmware, our enhanced
    bootloader that is ready to set up all the parameters in the TrustZone controller
    and stage the non-secure application. The obvious next step is to compile and
    install the non-secure world counterpart.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器的闪存现在已填充了安全固件，我们的增强型引导加载程序，它已准备好设置TrustZone控制器中的所有参数并准备非安全应用程序。显然的下一步是编译和安装非安全世界的对应版本。
- en: Compiling and linking non-secure applications
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译和链接非安全应用程序
- en: 'The linker script for our non-secure application defines the boundaries for
    the world as seen from the non-secure execution domain. Secure and NSC regions
    are not reachable from here. Our view on the flash memory is restricted to its
    upper half, and the accessible RAM is limited to the upper half of the SRAM1 bank.
    The `target.ld` linker script in the non-secure application defines these regions
    as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们非安全应用的链接脚本定义了从非安全执行域看世界的边界。安全和NSC区域从这里无法访问。我们对闪存的看法仅限于其上半部分，可访问的RAM仅限于SRAM1银行的下半部分。非安全应用中的`target.ld`链接脚本如下定义这些区域：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: From this point onward, the build process is similar to building normal applications
    with no support for TrustZone. Unlike its secure counterpart, non-secure applications
    do not require any special compiler or linker flags.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，构建过程类似于构建没有TrustZone支持的正常应用。与它的安全对应物不同，非安全应用不需要任何特殊的编译器或链接器标志。
- en: The noticeable exception consists of the extra object file generated by the
    secure application build process, which allows the non-secure application to briefly
    interact with the secure world. The contract between the secure and non-secure
    domains consists of the secure API defined by the secure world. In our example,
    we have only defined one single secure function, `nsc_blue_led_toggle`. The object
    file containing the veneers (called `cmse_led.o` in our example), automatically
    generated when compiling the code for the secure domain, is linked within the
    non-secure application, and it is in fact the code that satisfies the symbol dependency
    in the secure application for these special symbols. We will explore the details
    of this procedure in the next subsection, *Inter-domain transitions*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是一个例外，即安全应用构建过程中生成的额外目标文件，允许非安全应用短暂地与安全世界交互。安全域和非安全域之间的合同由安全世界定义的安全API组成。在我们的例子中，我们只定义了一个单一的secure函数，`nsc_blue_led_toggle`。包含封装器（在我们的例子中称为`cmse_led.o`）的对象文件，在编译安全域代码时自动生成，并在非安全应用中链接，实际上它是满足安全应用中这些特殊符号符号依赖的代码。我们将在下一小节*跨域转换*中探讨此过程的细节。
- en: 'Once the non-secure application has been built by running `make`, we upload
    the non-secure firmware image into the internal flash of the target, starting
    from the address `0x08040000`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦通过运行`make`构建了非安全应用，我们将非安全固件镜像上传到目标设备的内部闪存中，起始地址为`0x08040000`：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We will now take a closer look at the transitions from secure to non-secure
    domains and vice versa, to understand how new ARMv8-M instructions are involved
    in the transition operations and how these should be used in such cases.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将更详细地研究从安全域到非安全域以及相反方向的转换，以了解新的ARMv8-M指令如何在转换操作中发挥作用，以及在这些情况下应该如何使用。
- en: Inter-domain transitions
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨域转换
- en: 'When our secure world example bootloader is ready to stage the non-secure world
    application, we can notice some differences in the assembly that prepares the
    CPU registers and executes the jump to the non-secure domain. First, the `VTOR`
    system register is banked when TrustZone is enabled. This means that there are
    two separate registers that hold the offset for the vector table, one for each
    execution domain – VTOR_S and VTOR_NS, for secure and non-secure domains, respectively.
    Before jumping into the entry point for non-secure world code, the VTOR_NS register
    should contain the offset of the interrupt vector for the non-secure world application.
    As we know, the IV sits at the beginning of the binary image, so the following
    assignment in the bootloader’s `main` procedure ensures that eventually our non-secure
    domain code will be able to execute interrupt service routines:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的安全世界示例引导加载程序准备阶段非安全世界应用时，我们可以在准备CPU寄存器和执行跳转到非安全域的汇编代码中注意到一些差异。首先，当启用TrustZone时，`VTOR`系统寄存器被分页。这意味着有两个独立的寄存器分别保存向量表的偏移量，每个执行域一个——VTOR_S和VTOR_NS，分别对应安全域和非安全域。在跳转到非安全世界代码的入口点之前，VTOR_NS寄存器应包含非安全世界应用的中断向量偏移量。正如我们所知，IV位于二进制图像的起始处，因此引导加载程序`main`过程中的以下赋值确保最终我们的非安全域代码能够执行中断服务例程：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After this system register is set, we acquire the two important pointers needed
    for staging, similar to how we would do for bootloaders without TrustZone-M capabilities,
    like the one proposed in [*Chapter 4*](B18730_04.xhtml#_idTextAnchor115), *The
    Boot-Up Procedure*. These pointers, stored in the first two 32-bit words of the
    non-secure application binary image, are the initial stack pointer and the actual
    entry point containing the address of the `isr_reset` handler respectively. We
    read these two addresses into local stack variables before staging:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置此系统寄存器之后，我们获取部署所需的两个重要指针，类似于我们为没有TrustZone-M功能的引导加载程序（如[*第4章*](B18730_04.xhtml#_idTextAnchor115)中提出的）所做的那样，*启动过程*。这些指针存储在非安全应用二进制映像的前两个32位字中，分别是初始堆栈指针和包含`isr_reset`处理程序地址的实际入口点。在部署之前，我们将这两个地址读入局部堆栈变量中：
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In our example, we size the stack area in advance for the non-secure application,
    calculating the lowest address allowed for the stack as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们提前为非安全应用确定堆栈区域的大小，如下计算允许的堆栈最低地址：
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We then assign this value to the MSPLIM_NS register. MSPLIM_NS is a special
    register, so as usual we must use the `msr` instruction:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将此值赋给MSPLIM_NS寄存器。MSPLIM_NS是一个特殊寄存器，因此，像往常一样，我们必须使用`msr`指令：
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We then set the value for the new stack pointer, which will replace SP once
    the domain transition is complete:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置新堆栈指针的值，一旦域转换完成，它将替换SP：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The actual jump to non-secure code is where things differ a lot from our previous
    bootloader introduced in [*Chapter 4*](B18730_04.xhtml#_idTextAnchor115), *The
    Boot-Up Procedure*. First, we must ensure that the address for the jump is adjusted
    to comply with the convention used in ARMv8 transitions. The value we read from
    the binary image into the `app_entry` local variable is in fact odd, which is
    the classic requirement when assigning a new value to the PC register when jumping
    within the same domain – for example, when using `mov pc, ...` instructions in
    ARMv7-M, such as the one in the example bootloader from [*Chapter 4*](B18730_04.xhtml#_idTextAnchor115),
    *The Boot-Up Procedure*. In ARMv8-M, the instruction that executes the jump and
    the domain transition into the non-secure world at the same time, is `blxns`.
    However, when invoking `blxns` or any other instruction that implies a jump to
    a non-secure address, we must ensure that the destination address for the jump
    has its least significant bit turned off. For this reason, we decrease the value
    of `app_entry` by one before executing `blxns`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 实际跳转到非安全代码的地方与我们在[*第4章*](B18730_04.xhtml#_idTextAnchor115)中介绍的先前引导加载程序有很大的不同，*启动过程*。首先，我们必须确保跳转的地址调整以符合ARMv8转换中使用的约定。我们从二进制映像中读取到`app_entry`局部变量的值实际上是奇数，这是在相同域内跳转时给PC寄存器分配新值时的经典要求——例如，在ARMv7-M中使用`mov
    pc, ...`指令，如[*第4章*](B18730_04.xhtml#_idTextAnchor115)中示例引导加载程序中的那样。在ARMv8-M中，同时执行跳转和域转换到非安全世界的指令是`blxns`。然而，在调用`blxns`或任何暗示跳转到非安全地址的指令时，我们必须确保跳转的目标地址的最低有效位被关闭。因此，在执行`blxns`之前，我们将`app_entry`的值减一：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is the last instruction executed in the secure domain before finally staging
    our non-secure application. If we use the debugger to check the values of the
    registers while stepping through these last instructions, we can see the values
    of the CPU registers being updated, and then finally, the SP register will point
    to the new context in the non-secure domain.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在最终部署我们的非安全应用之前，在安全域中执行的最后一个指令。如果我们使用调试器在执行这些最后指令时检查寄存器的值，我们可以看到CPU寄存器的值正在更新，然后最终，SP寄存器将指向非安全域中的新上下文。
- en: From this point onward, any attempt to jump back into the secure domain is,
    of course, not allowed and will generate an exception. However, as we have previously
    mentioned, the purpose of the functions placed in the NSC region is to provide
    temporary and controlled execution of secure functions from the non-secure domain.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，任何尝试跳回安全域的行为当然是不允许的，并且将生成一个异常。然而，正如我们之前提到的，放置在NSC区域中的函数的目的是为了从非安全域提供临时和受控的安全函数执行。
- en: In our example, before transitioning to the non-secure execution domain, we
    impose some limitation on access to the GPIO lines associated with the three LEDs,
    by setting the corresponding bits in the `GPIOx_SECCFG` register, as explained
    in the *Configuring secure access to peripherals* subsection previously in this
    chapter.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，在过渡到非安全执行域之前，我们通过设置`GPIOx_SECCFG`寄存器中的相应位，对与三个LED相关的GPIO线的访问施加了一些限制，正如本章之前在*配置对外设的安全访问*小节中解释的那样。
- en: When both images composing the example are uploaded to the target platform,
    we can power-cycle and observe the effects by looking at the three LEDs. After
    rebooting, we should see the red LED that will be turned on at startup and kept
    on while the secure code is running in the bootloader. After spinning for an arbitrary
    number of cycles, to give us enough time to inspect the LED status, the red LED
    will then be turned off and secured. The blue LED is secured too, through the
    `blue_led_secure(1)` call executed before staging. The green LED is not secured
    and can be accessed normally in the non-secure domain.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当示例的两个映像都上传到目标平台时，我们可以通过观察三个LED来观察电源循环和效果。重启后，我们应该看到启动时打开并保持开启状态的红LED，同时安全代码在引导加载程序中运行。经过任意数量的循环旋转后，给我们足够的时间检查LED状态，红LED将关闭并处于安全状态。蓝色LED也通过在部署前执行的`blue_led_secure(1)`调用而处于安全状态。绿色LED未处于安全状态，可以在非安全域中正常访问。
- en: When the non-secure application starts, we can see the green LED constantly
    on and the blue LED rapidly blinking. The latter is only possible thanks to the
    fact that non-secure applications can access a function within the secure APIs.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当非安全应用启动时，我们可以看到绿色LED常亮，而蓝色LED快速闪烁。后者之所以可能，是因为非安全应用可以访问安全API内的一个功能。
- en: 'We can have a look at the assembly generated for this function by running `arm-none-eabi-objdump
    –D` on the secure-world **elf** file. We immediately notice that the non-secure
    callable function stub generated is in fact a short procedure placed at the beginning
    of the non-callable section:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在安全世界的**elf**文件上运行`arm-none-eabi-objdump –D`来查看此函数生成的汇编代码。我们立即注意到生成的非安全可调用函数桩实际上是一个放置在非可调用部分开头的简短过程：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The most interesting part of the code running in the NSC area is the use of
    the special assembly instruction, `sg`, which is a new instruction introduced
    in ARMv8-M with the specific purpose of implementing secure calls from non-secure
    domains. This instruction prepares the branching to an secure call in the secure
    flash space, and it is only legal when it is executed from an non-secure callable
    area.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在NSC区域运行的代码中最有趣的部分是使用特殊的汇编指令`sg`，这是ARMv8-M中引入的新指令，其特定目的是从非安全域实现安全调用。此指令准备将分支到安全空间中的安全调用，并且仅在从非安全可调用区域执行时才是合法的。
- en: Also, note that the real implementation is in fact contained in the `__acle_se_nsc_blue_led_toggle`
    function, generated by the compiler and placed in the S region of the flash.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，实际实现实际上包含在由编译器生成的`__acle_se_nsc_blue_led_toggle`函数中，并放置在闪存的S区域。
- en: 'The assembly code generated by the veneer for `nsc_blue_led_toggle`, as seen
    by disassembling the non-secure application in the same way after including the
    generated object in the final image, should look like the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将生成的对象包含在最终映像中并以相同方式反汇编非安全应用，生成的`nsc_blue_led_toggle`覆盖层的汇编代码应该看起来像以下这样：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The conclusion of the procedure of calling an secure function from the non-secure
    domain is in the tail of the actual implementation of the secure function toggling
    the blue LED, `__acle_se_nsc_blue_led_toggle`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 从非安全域调用安全函数的过程的结论位于实际安全函数切换蓝色LED的实现尾部，即`__acle_se_nsc_blue_led_toggle`：
- en: '[PRE30]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This should already look familiar to us, as it is in fact the non-linked version
    of the `bxlns` instruction that we have seen before, performing a jump to the
    return address of the non-secure veneer stored in the link register, while also
    transitioning back to the non-secure domain. The following checklist is a recap
    of the steps involved when a secure function is called from the NS execution domain
    in this chapter’s example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该对我们来说已经很熟悉了，因为它实际上是之前见过的`bxlns`指令的非链接版本，它执行跳转到存储在链接寄存器中的非安全覆盖层的返回地址，同时返回到非安全域。以下清单是本章示例中当从NS执行域调用安全函数时涉及步骤的回顾：
- en: non-secure world code calls the veneer for `nsc_blue_led_toggle`, which is implemented
    in the `cmse_leds.o` object that is generated when compiling the secure code and
    linked to the non-secure application.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 非安全世界代码调用`nsc_blue_led_toggle`的包装器，该包装器在编译安全代码时实现，并在链接到非安全应用程序的`cmse_leds.o`对象中。
- en: The veneer knows the SG stub location in the NSC region. This region is accessible
    for execution from the secure world, while being placed in a specific region inside
    the secure firmware. The veneer then proceeds to jump to the SG stub.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包装器知道NSC区域中的SG占位符位置。这个区域可以从安全世界执行，同时被放置在安全固件中的特定区域。然后包装器继续跳转到SG占位符。
- en: The SG stub calls the `sg` instruction, initiating the transition to the secure
    world, and then jumps to the actual implementation, `__acle_se_nsc_blue_led_toggle`.
    This now executes in the secure domain, performing the requested action (in our
    example, this is toggling the value of the GPIO line connected to the blue LED).
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SG占位符调用`sg`指令，启动到安全世界的转换，然后跳转到实际实现，`__acle_se_nsc_blue_led_toggle`。现在它在安全域中执行，执行请求的操作（在我们的例子中，这是切换连接到蓝色LED的GPIO线的值）。
- en: When the procedure terminates, the secure function performs a transition back
    to the non-secure world by using the `bxns` instruction, while at the same time
    jumping back to the address of the original caller in the non-secure world.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当程序终止时，安全功能通过使用`bxns`指令返回到非安全世界，同时跳转回非安全世界原始调用者的地址。
- en: Despite its simplicity, our example shows how to configure and use all the features
    needed to separate the two execution domains, as well as the mechanisms to be
    used to implement the interactions between the two worlds. The design of these
    interactions in the secure domain will determine the capabilities offered to non-secure
    applications. The boundaries and the interface for the transitions act like a
    contract between the two parts, which is enforced by the hardware itself, thanks
    to TrustZone-M.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管很简单，我们的例子展示了如何配置和使用所有需要的特性来分离两个执行域，以及用于实现两个世界之间交互的机制。在安全域中这些交互的设计将决定提供给非安全应用程序的能力。转换的边界和接口就像两部分之间的合同，由硬件本身强制执行，多亏了TrustZone-M。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: ARMv8-M is the newest architecture defined by ARM for modern microcontrollers.
    It extends and completes the capabilities of its predecessor, ARMv7-M, by integrating
    several new features. The most important improvement for this novel architecture
    design is the possibility to implement a TEE by separating the execution domains
    and creating a sandboxed environment to execute non-secure applications.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ARMv8-M是ARM为现代微控制器定义的最新架构。它通过集成几个新功能扩展并完善了其前身ARMv7-M的能力。对于这种新型架构设计最重要的改进是实现TEE的可能性，通过分离执行域并创建一个沙盒环境来执行非安全应用程序。
- en: In real-life scenarios, this gives flexibility to the deployment of applications
    from different providers, with distinct levels of trust regarding accessing features
    and resources on a system.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际场景中，这为不同提供者的应用程序部署提供了灵活性，这些应用程序在访问系统上的功能和资源方面具有不同的信任级别。
- en: In this last chapter, we have analyzed the mechanisms available in the TrustZone-M
    technology. TrustZone-M can be activated on ARMv8-M systems for the purpose of
    integrating a powerful, hardware-assisted solution, aimed to protect system components
    from any access that has not been explicitly authorized by a system supervisor
    component running in the secure domain.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章中，我们分析了TrustZone-M技术中可用的机制。TrustZone-M可以在ARMv8-M系统上激活，目的是集成一个强大的、硬件辅助的解决方案，旨在保护系统组件免受安全域中运行的系统监督组件未明确授权的任何访问。
