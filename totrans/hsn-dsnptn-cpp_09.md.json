["```cpp\nclass City {\n  public:\n  enum center_t { KEEP, PALACE, CITADEL };\n  City(size_t number_of_buildings,\n       size_t number_of_towers,\n       size_t guard_strength,\n       center_t center,\n       bool with_forge,\n       bool with_granary,\n       bool has_fresh_water,\n       bool is_coastal,\n       bool has_forest);\n  ...\n};\n```", "```cpp\nCity Capital(2, 1, 1, City::KEEP,\n             false, false, false, false);\n```", "```cpp\nCity Capital(2, 1, 1, City::KEEP,\n             false, true, false, false, false);\n```", "```cpp\nclass City {\n  public:\n  enum center_t { KEEP, PALACE, CITADEL };\n  City(size_t number_of_buildings,\n       size_t number_of_towers,\n       size_t guard_strength,\n       enter_t center,\n       bool with_forge,\n       bool with_granary,\n       bool has_fresh_water = true,\n       bool is_coastal = false,\n       bool has_forest = true);\n  ...\n};\n```", "```cpp\nclass City {\n  public:\n  enum center_t { KEEP, PALACE, CITADEL };\n  City(size_t number_of_buildings,\n       size_t number_of_towers,\n       size_t guard_strength,\n       center_t center,\n       bool with_forge,\n       bool with_granary,\n       bool has_fresh_water = true,\n       bool is_coastal = false,\n       bool has_forest = true,\n       bool with_temple = false);\n  ...\n};\n```", "```cpp\nclass City {\n  public:\n  enum center_t { KEEP, PALACE, CITADEL };\n  City(size_t number_of_buildings,\n       size_t number_of_towers,\n       size_t guard_strength,\n       center_t center,\n       bool with_forge,\n       bool with_granary,\n       bool is_coastal = false,\n       bool has_forest = true,\n       bool with_temple = false,\n       bool is_desert = false);\n  ...\n};\n```", "```cpp\nCity Capital(2, 1, false, City::KEEP,\n             false, true, false, false, false);\n```", "```cpp\n// Example 01\nclass City {\n  public:\n  enum center_t { KEEP, PALACE, CITADEL };\n  City(size_t number_of_buildings,\n       size_t number_of_towers,\n       size_t guard_strength,\n       center_t center = KEEP,\n       bool with_forge = false,\n       bool with_granary = false,\n       bool has_fresh_water = true,\n       bool is_coastal = false,\n       bool has_forest = true,\n       bool with_temple = false,\n       bool is_desert = false);\n  ...\n};\n```", "```cpp\nCity Capital(2, 1, City::CITADEL);\n```", "```cpp\nstruct city_features_t {\n  size_t number_of_buildings = 1;\n  size_t number_of_towers = 0;\n  size_t guard_strength = 0;\n  enum center_t { KEEP, PALACE, CITADEL };\n  center_t center = KEEP;\n  bool with_forge = false;\n  bool with_granary = false;\n  bool with_temple = false;\n};\nstruct terrain_features_t {\n  bool has_fresh_water = true;\n  bool is_coastal = false;\n  bool has_forest = true;\n  bool is_desert = false;\n};\nclass City {\n  public:\n  City(city_features_t city_features,\n       terrain_features_t terrain_features);\n  ...\n};\n```", "```cpp\ncity_features_t city_features;\ncity_features.number_of_buildings = 2;\ncity_features.center = city_features::KEEP;\n...\nterrain_features_t terrain_features;\nterrain_features.has_fresh_water = true;\n...\nCity Capital(city_features, terrain_features);\n```", "```cpp\nstruct city_features_t {\n  size_t number_of_buildings = 1;\n  size_t number_of_towers = 0;\n  size_t guard_strength = 0;\n  enum center_t { KEEP, PALACE, CITADEL };\n  center_t center = KEEP;\n  bool with_forge = false;\n  bool with_granary = false;\n  bool with_temple = false;\n};\nstruct terrain_features_t {\n  bool has_fresh_water = true;\n  bool is_coastal = false;\n  bool has_forest = true;\n  bool is_desert = false;\n};\nCity Capital({2, 1, 0, KEEP, true, false, false},\n             {true, false, false, true});\n```", "```cpp\n// Example 02\nint i, j;\nstd::cout << i << j;\n```", "```cpp\n// Example 02-\nstd::cout.operator<<(i).operator<<(j);\n```", "```cpp\n// Example 02\nauto& out1 = std::cout.operator(i);\nout1.operator<<(j);\n```", "```cpp\nclass City {\n  ...\n  void day(bool flood = false, bool fire = false,\n    bool revolt = false, bool exotic_caravan = false,\n    bool holy_vision = false, bool festival = false, ... );\n  ...\n};\n```", "```cpp\nclass City {\n  ...\n  struct DayEvents {\n    bool flood = false;\n    bool fire = false;\n    ...\n  };\n  void day(DayEvents events);\n  ...\n};\nCity capital(...);\nCity::DayEvents events;\nevents.fire = true;\ncapital.day(events);\n```", "```cpp\n// Example 03\nclass City {\n  ...\n  class DayEvents {\n    friend City;\n    bool flood = false;\n    bool fire = false;\n    public:\n    DayEvents() = default;\n    DayEvents& SetFlood() { flood = true; return *this; }\n    DayEvents& SetFire() { fire = true; return *this; }\n    ...\n  };\n  void day(DayEvents events);\n  ...\n};\nCity capital(...);\ncapital.day(City::DayEvents().SetFire());\n```", "```cpp\nDayEvents& SetFire(bool value = true) {\n  fire = value;\n  return *this;\n}\n```", "```cpp\nCity capital(...);\ncapital.day(City::DayEvents().\n            SetMarket().\n            SetFestival().\n            SetGuard(3));\n```", "```cpp\n$CXX named_args.C named_args_extra.C -g -O4 -I. \\\n  -Wall -Wextra -Werror -pedantic --std=c++14 \\\n  -I$GBENCH_DIR/include $GBENCH_DIR/lib/libbenchmark.a \\\n  -lpthread -lrt -lm -o named_args\n```", "```cpp\n// Example 04\n// Positional arguments:\nPositional p(true, false, true, false);\n// Named arguments idiom:\nNamed n(Named::Options().SetA(true).SetC(true));\n// Aggregate object:\nAggregate::Options options;\noptions.a = true;\noptions.c = true;\nAggregate a(options));\n```", "```cpp\nBenchmark                 Time  UserCounters...\nBM_positional_const   0.233 ns  items_per_second=138.898G/s\nBM_named_const        0.238 ns  items_per_second=134.969G/s\nBM_aggregate_const    0.239 ns  items_per_second=135.323G/s\n```", "```cpp\n// Example 04\nstd::vector<int> v; // Fill v with random values\nsize_t i = 0;\n// ... Benchmark loop ...\nconst bool a = v[i++];\nconst bool b = v[i++];\nconst bool c = v[i++];\nconst bool d = v[i++];\nif (i == v.size()) i = 0; // Assume v.size() % 4 == 0\nPositional p(a, b, c, d); // Positional arguments\nNamed n(Named::Options().\n  SetA(a).SetC(b).SetC(c).SetD(d)); // Named arguments\nAggregate::Options options;\noptions.a = a;\noptions.b = b;\noptions.c = c;\noptions.d = d;\nAggregate a(options)); // Aggregate object\n```", "```cpp\nPositional p(v[i++], v[i++], v[i++], v[i++]);\n```", "```cpp\nBenchmark                 Time  UserCounters...\nBM_positional_vars     50.8 ns  items_per_second=630.389M/s\nBM_named_vars          49.4 ns  items_per_second=647.577M/s\nBM_aggregate_vars      45.8 ns  items_per_second=647.349M/s\n```", "```cpp\nvar opt = Options();\nopt.SetA()..SetB();\n```", "```cpp\nvar opt = Options();\nopt.SetA()\nopt.SetB();\n```", "```cpp\nOptions opt;\nopt.SetA().SetB();\n```", "```cpp\nOptions opt;\nOptions& opt1 = opt.SetA();\nOptions& opt2 = opt1.SetB();\n```", "```cpp\nOptions opt;\nopt.SetA();\nopt.SetB();\n```", "```cpp\nOptions opt;\nopt.SetA().SetB();\n```", "```cpp\nOptions opt;\nOptions& opt1 = opt.SetA();\nOptions& opt2 = opt1.SetB();\n```", "```cpp\nCollection c;\n... store data in the collection ...\nCollection valid_c = c.filter(is_valid);\nCollection sorted_valid_c = valid_c.sort();\n```", "```cpp\nCollection c;\n...\nCollection sorted_valid_c = c.filter(is_valid).sort();\n```", "```cpp\n// Example 05\nclass SortedCollection;\nclass Collection {\n  public:\n  Collection filter();\n  // sort() converts Collection to SortedCollection.\n  SortedCollection sort();\n};\nclass SortedCollection : public Collection {\n  public:\n  SortedCollection search();\n  SortedCollection median();\n};\nSortedCollection Collection::sort() {\n  SortedCollection sc;\n  ... sort the collection ...\n  return sc;\n}\nCollection c;\nauto c1 = c.sort().search().filter.median();\n```", "```cpp\nclass SortedCollection;\nclass Collection {\n  public:\n  Collection filter();\n  // Converts Collection to SortedCollection\n  SortedCollection sort();\n  virtual SortedCollection median();\n};\nclass SortedCollection : public Collection {\n  public:\n  SortedCollection search();\n  SortedCollection median() override;\n};\nSortedCollection Collection::sort() {\n  SortedCollection sc;\n  ... sort the collection ...\n  return sc;\n}\nSortedCollection Collection::median() {\n  cout << \"Collection::median called!!!\" << endl;\n  abort();\n  return {};     // Still need to return something\n}\nCollection c;\nauto c1 = c.sort().search().filter().median();\n```", "```cpp\ntemplate <typename T> class Collection {\n  public:\n  Collection() {}\n  T filter(); // \"*this\" is really a T, not a Collection\n  T sort() {\n    T sc; // Create new sorted collection\n    ...\n    return sc;\n  }\n};\nclass SortedCollection :\n  public Collection<SortedCollection> {\n  public:\n  SortedCollection search();\n  SortedCollection median();\n};\nCollection<SortedCollection> c;\nauto c1 = c.sort().search().filter().median();\n```", "```cpp\nCity GreensDale(City::Options()\n  .SetCenter(City::KEEP)\n  .SetBuildings(3)\n  .SetGuard(1)\n  .SetForge()\n);\n```", "```cpp\n// Example 08\nclass FibonacciBuilder {\n  using V = std::vector<unsigned long>;\n  V cache_ { 1, 1, 2, 3, 5 };\n  public:\n  V operator()(size_t n) {\n    while (cache_.size() < n) {     // Cache new numbers\n      cache_.push_back(cache_[cache_.size() - 1] +\n                       cache_[cache_.size() - 2]);\n    }\n    return V{cache_.begin(), cache_.begin() + n};\n  }\n};\n```", "```cpp\nFibonacciBuilder b;\nauto fib10 = b(10);\n```", "```cpp\n// Example 09\nclass Employee {\n  std::string prefix_;\n  std::string first_name_;\n  std::string middle_name_;\n  std::string last_name_;\n  std::string suffix_;\n  friend class EmployeeBuilder;\n  Employee() = default;\n  public:\n  friend std::ostream& operator<<(std::ostream& out,\n                                  const Employee& e);\n};\n```", "```cpp\n// Example 09\nclass EmployeeBuilder {\n  Employee e_;\n  public:\n  EmployeeBuilder& SetPrefix(std::string_view s) {\n    e_.prefix_ = s; return *this;\n  }\n  EmployeeBuilder& SetFirstName(std::string_view s) {\n    e_.first_name_ = s ; return *this;\n  }\n  EmployeeBuilder& SetMiddleName(std::string_view s) {\n    e_.middle_name_ = s; return *this;\n  }\n  EmployeeBuilder& SetLastName(std::string_view s) {\n    e_.last_name_ = s; return *this;\n  }\n  EmployeeBuilder& SetSuffix(std::string_view s) {\n    e_.suffix_ = s; return *this;\n  }\n  operator Employee() {\n    assert(!e_.first_name_.empty() &&\n           !e_.last_name_.empty());\n    return std::move(e_);\n  }\n};\n```", "```cpp\nEmployee Homer = EmployeeBuilder()\n  .SetFirstName(\"Homer\")\n  .SetMiddleName(\"J\")\n  .SetLastName(\"Simpson\")\n;\n```", "```cpp\n// Example 09\nEmployee Homer = EmployeeBuilder()\n  .SetFirstName(\"Homer\")\n  .SetMiddleName(\"J\")\n  .SetLastName(\"Simpson\")\n  .Job()\n    .SetTitle(\"Safety Inspector\")\n    .SetOffice(\"Sector 7G\")\n  .Address()\n    .SetHouse(\"742\")\n    .SetStreet(\"Evergreen Terrace\")\n    .SetCity(\"Springfield\")\n  .Awards()\n    .Add(\"Remorseless Eating Machine\")\n;\n```", "```cpp\n// Example 09\nclass JobBuilder;\nclass AwardBuilder;\nclass AbstractBuilder {\n  protected:\n  Employee& e_;\n  public:\n  explicit AbstractBuilder(Employee& e) : e_(e) {}\n  operator Employee() {\n    assert(!e_.first_name_.empty() &&\n           !e_.last_name_.empty());\n      return std::move(e_);\n  }\n  JobBuilder Job();\n  AddressBuilder Address();\n  AwardBuilder Awards();\n};\n```", "```cpp\nclass EmployeeBuilder : public AbstractBuilder {\n  Employee employee_;\n  public:\n  EmployeeBuilder() : AbstractBuilder(employee_) {}\n  EmployeeBuilder& SetPrefix(std::string_view s){\n    e_.prefix_ = s; return *this;\n  }\n  …\n};\n```", "```cpp\n// Example 09\nclass JobBuilder : public AbstractBuilder {\n  public:\n  explicit JobBuilder(Employee& e) : AbstractBuilder(e) {}\n  JobBuilder& SetTitle(std::string_view s) {\n    e_.title_ = s; return *this;\n  }\n  …\n  JobBuilder& SetManager(std::string_view s) {\n    e_.manager_ = s; return *this;\n  }\n  JobBuilder& SetManager(const Employee& manager) {\n    e_.manager_ = manager.first_name_ + \" \" +\n                  manager.last_name_;\n     return *this;\n  }\n  JobBuilder& CopyFrom(const Employee& other) {\n    e_.manager_ = other.manager_;\n    …\n    return *this;\n  }\n};\nJobBuilder AbstractBuilder::Job() {\n  return JobBuilder(e_);\n}\n```", "```cpp\n// Example 09\nclass Employee {\n  … name, job, address, etc …\n  std::vector<std::string> awards_;\n};\n```", "```cpp\n// Example 09\nclass AwardBuilder : public AbstractBuilder {\n  public:\n  explicit AwardBuilder(Employee& e) : AbstractBuilder(e)\n  {}\n  AwardBuilder& Add(std::string_view award) {\n    e_.awards_.emplace_back(award); return *this;\n  }\n};\nAwardBuilder AbstractBuilder::Awards() {\n  return AwardBuilder(e_);\n}\n```", "```cpp\nEmployee Barry = EmployeeBuilder()\n  .SetFirstName(\"Barnabas\")\n  .SetLastName(\"Mackleberry\")\n;\n```", "```cpp\nEmployee Homer = EmployeeBuilder()\n  .SetFirstName(\"Homer\")\n  .SetMiddleName(\"J\")\n  .SetLastName(\"Simpson\")\n  .Job()\n    .SetTitle(\"Safety Inspector\")\n    .SetOffice(\"Sector 7G\")\n    .SetManager(Barry) // Writes \"Barnabas Mackleberry\"\n  .Address()\n    .SetHouse(\"742\")\n    .SetStreet(\"Evergreen Terrace\")\n    .SetCity(\"Springfield\")\n  .Awards()\n    .Add(\"Remorseless Eating Machine\")\n;\n```", "```cpp\nEmployee Lenny = EmployeeBuilder()\n  .SetFirstName(\"Lenford\")\n  .SetLastName(\"Leonard\")\n  .Job()\n    .CopyFrom(Homer)\n;\n```", "```cpp\nEmployee Smithers = EmployeeBuilder()\n  .SetFirstName(\"Waylon\")\n  .SetLastName(\"Smithers\")\n  .SetSuffix(\"Jr\") // Only when needed!\n;\n```", "```cpp\nclass HTMLElement {\n  public:\n  const std::string name_;\n  const std::string text_;\n  const std::vector<HTMLElement> children_;\n  HTMLElement(std::string_view name, std::string_view text)\n    : name_(name), text_(text) {}\n  HTMLElement(std::string_view name, std::string_view text,\n              std::vector<HTMLElement>&& children)\n    : name_(name), text_(text),\n      children_(std::move(children)) {}\n  friend std::ostream& operator<<(std::ostream& out,\n    const HTMLElement& element);\n};\n```", "```cpp\nstd::ostream& operator<<(std::ostream& out,\n                         const HTMLElement& element) {\n  out << \"<\" << element.name_ << \">\\n\";\n  if (!element.text_.empty())\n    out << \"  \" << element.text_ << \"\\n\";\n  for (const auto& e : element.children_) out << e;\n  out << \"</\" << element.name_ << \">\" << std::endl;\n  return out;\n}\n```", "```cpp\nclass HTML : public HTMLElement {\n  public:\n  HTML() : HTMLElement(\"html\", \"\") {}\n  HTML(std::initializer_list<HTMLElement> children) :\n    HTMLElement(\"html\", \"\", children) {};\n};\n```", "```cpp\n// Example 10\nauto doc = HTML{\n  Head{\n    Title{\"Mary Had a Little Lamb\"}\n  },\n  Body{\n    P{\"Mary Had a Little Lamb\"},\n    OL{\n      LI{\"Its fleece was white as snow\"},\n      LI{\"And everywhere that Mary went\"},\n      LI{\"The lamb was sure to go\"}\n    }\n  }\n};\n```", "```cpp\n//Example 10\nclass LI : public HTMLElement {\n  public:\n  explicit LI(std::string_view text) :\n    HTMLElement(\"li\", text) {}\n  LI(std::string_view text,\n     std::initializer_list<HTMLElement> children) :\n    HTMLElement(\"li\", text, children) {}\n};\n```", "```cpp\n//Example 10\nLI{\"A\",\n  UL{\n    LI{\"B\"},\n    LI{\"C\"}\n  }\n}\n```", "```cpp\n//Example 10\nLI{\"A\",\n  {UL{        // Notice { before UL!\n    LI{\"B\"},\n    LI{\"C\"}\n  }}            // And closing } here\n}\n```", "```cpp\n//Example 11\nclass LI : public HTMLElement {\n  public:\n  explicit LI(std::string_view text) :\n    HTMLElement(\"li\", text) {}\n  template <typename ... Children>\n  LI(std::string_view text, const Children&... children) :\n    HTMLElement(\"li\", text,\n           std::initializer_list<HTMLElement>{children...})\n  {}\n};\n```", "```cpp\n// Example 12\nclass LI : public HTMLElement {\n  public:\n  explicit LI(std::string_view text) :\n    HTMLElement(\"li\", text) {}\n  LI(std::string_view text,\n     const std::derived_from<HTMLElement>\n     auto& ... children) :\n    HTMLElement(\"li\", text,\n           std::initializer_list<HTMLElement>{children...})\n  {}\n};\n```", "```cpp\n// Examples 11, 12\nauto doc = HTML{\n  Head{\n    Title{\"Mary Had a Little Lamb\"}\n  },\n  Body{\n    P{\"Mary Had a Little Lamb\"},\n    OL{\n      LI{\"Its fleece was white as snow\"},\n      LI{\"And everywhere that Mary went\"},\n      LI{\"The lamb was sure to go\"}\n    },\n    UL{\n      LI{\"It followed her to school one day\"},\n      LI{\"Which was against the rules\",\n        UL{\n          LI{\"It made the children laugh and play\"},\n          LI{\"To see a lamb at school\"}\n        }\n      },\n      LI{\"And so the teacher turned it out\"}\n    }\n  }\n};\n```"]