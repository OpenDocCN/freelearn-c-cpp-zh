<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-41"><a id="_idTextAnchor055"/>2</h1>
<h1 id="_idParaDest-42"><a id="_idTextAnchor056"/>Work Environment and Workflow Optimization</h1>
<p>The first step toward a successful software project is choosing the right tools. Embedded development requires a set of hardware and software instruments that make the developer’s life easier and may significantly improve productivity and cut down the total development time. This chapter provides a description of these tools and gives advice on how to use them to improve the workflow.</p>
<p>The first section gives us an overview of the workflow in native C programming, and gradually reveals the changes necessary to translate the model to an embedded development environment. The <strong class="bold">GCC toolchain</strong>, a set of <a id="_idIndexMarker079"/>development tools to build the embedded application, is introduced through the analysis of its components.</p>
<p>Finally, in the last two sections, strategies of interaction with the target are proposed, to provide mechanisms for the debugging and validation of the embedded software running on the platform.</p>
<p>The topics covered in this chapter are the following:</p>
<ul>
<li>Workflow overview</li>
<li>Text editors versus integrated environments</li>
<li>The GCC toolchain</li>
<li>Interaction with the target</li>
<li>Validation</li>
</ul>
<p>By the end of this chapter, you will have learned how to create an optimized workflow by following a few basic rules, keeping the focus on test preparation, and a smart approach to debugging.</p>
<h1 id="_idParaDest-43"><a id="_idTextAnchor057"/>Workflow overview</h1>
<p>Writing <a id="_idIndexMarker080"/>software in C, as well as in every other compiled language, requires the code to be transformed into an executable format for a specific target to run it. C is portable across different architectures and execution environments. Programmers rely on a set of tools to compile, link, execute, and debug software to a specific target.</p>
<p>Building the firmware image of an embedded system relies on a similar set of tools, which can produce firmware images for specific targets, called a <strong class="bold">toolchain</strong>. This<a id="_idIndexMarker081"/> section gives an overview of the common sets of tools required to write software in C and produce programs that are directly executable on the machine that compiled them. The workflow must then be extended and adapted to integrate the toolchain components and produce executable code for the target platform.</p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor058"/>The C compiler</h2>
<p>The <strong class="bold">C compiler</strong> is a <a id="_idIndexMarker082"/>tool <a id="_idIndexMarker083"/>responsible for translating source code into machine code, which can be interpreted by a specific CPU. Each compiler can produce machine code for one environment only, as it translates the functions into machine-specific instructions, and it is configured to use the address model and the register layout of one specific architecture. The native compiler included in most GNU/Linux distributions is<a id="_idIndexMarker084"/> the <strong class="bold">GNU Compiler Collection</strong>, commonly known as <strong class="bold">GCC</strong>. The GCC is a free software compiler system distributed under the GNU general public license since 1987, and since then, it has been successfully used to build UNIX-like systems. The GCC included in the system can compile C code into applications and libraries capable of running on the same architecture as that of the machine running the compiler.</p>
<p>The GCC compiler takes source code files as input, with the <code>.c</code> extension, and produces object files, with <code>.o</code> extensions, containing the functions and the initial values of the variables, translated from the input source code into machine instructions. The compiler can be configured to perform additional optimization steps at the end of the compilation that are specific to the target platform and insert debug data to facilitate debugging at a later stage.</p>
<p>A minimalist command line used to compile a source file into an object using the host compiler only requires the <code>-c</code> option, instructing the GCC program to compile the sources into an object of the same name:</p>
<pre class="console">
$ gcc -c hello.c</pre>
<p>This statement will try to <a id="_idIndexMarker085"/>compile the C source contained in the <code>hello.c</code> file and transform it into machine-specific code that is stored in the newly created <code>hello.o</code> file.</p>
<p>Compiling <a id="_idIndexMarker086"/>code for a specific target platform requires a set of tools designed for that purpose. Architecture-specific compilers exist, which provide compilers creating machine instructions for a specific target, different from the building machine. The process of generating code for a different target is<a id="_idIndexMarker087"/> called <strong class="bold">cross compilation</strong>. The <strong class="bold">cross compiler</strong> runs <a id="_idIndexMarker088"/>on a development machine, the host, to produce machine-specific code that can execute on the target.</p>
<p>In the next section, a GCC-based toolchain is introduced as the tool to create the firmware for an embedded target. The syntax and the characteristics of the GCC compiler are described there.</p>
<p>The first step for building a program made of separate modules is to compile all the sources into object files so that the components needed by the system are grouped and organized together in the final step, consisting of linking together all the required symbols and arranging the memory areas to prepare the final executable, which is done by another dedicated component in the toolchain.</p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor059"/>Linker</h2>
<p>The <strong class="bold">linker</strong> is <a id="_idIndexMarker089"/>the tool <a id="_idIndexMarker090"/>that composes executable programs and resolves the dependencies among object files provided as input.</p>
<p>The default executable format that is produced by the linker is the <strong class="bold">Executable and Linkable Format</strong> (<strong class="bold">ELF</strong>). The <a id="_idIndexMarker091"/>ELF is the default standard format for programs, objects, shared libraries, and even GDB core dumps on many Unix and Unix-like systems. The format has been designed to store programs on disks and other media supports, so the host operating system can execute it by loading the instructions in RAM and allocating the space for the program data.</p>
<p>Executable files are divided into sections, which can be mapped to specific areas in memory needed by the program to execute. The ELF file starts with a header containing the pointer to the various sections within the file itself, which contains the program’s code and data.</p>
<p>The linker<a id="_idIndexMarker092"/> maps<a id="_idIndexMarker093"/> the content of the areas describing an executable program into sections conventionally starting with a <code>.</code> (dot). The minimum set of sections required to run the executable consists of the following:</p>
<ul>
<li><code>.text</code>: Contains the code of the program, accessed in read-only mode. It contains the executable instructions of the program. The functions compiled into object files are arranged by the linker in this section, and the program always executes instructions within this memory area.</li>
<li><code>.rodata</code>: Contains the value of constants that cannot be altered at runtime. It is used by the compiler as the default section to store constants because it is not allowed to modify the stored values at runtime.</li>
<li><code>.data</code>: Contains the values of all the initialized variables of the program that are accessible in the read/write mode at runtime. It is the section that contains all the variables (static or global) that have been initialized in the code. Before executing, this area is generally remapped to a writable location in RAM, and the content of the ELF is automatically copied during the initialization of the program, at runtime, before executing the main function.</li>
<li><code>.bss</code>: This is a section reserved for uninitialized data, accessible in the read/write mode at runtime. It derives its name from an ancient assembly instruction of old microcode written for the IBM 704 in the 1950s. It was originally an acronym <a id="_idIndexMarker094"/>for <code>main()</code> function.</li>
</ul>
<p>When building<a id="_idIndexMarker095"/> native software on the host machine, much of the complexity of the linking step is hidden, but the linker is configured by default to arrange the compiled symbols into specific sections, which can be later used by the operating system to assign the corresponding <a id="_idIndexMarker096"/>segments in the process virtual address space when executing the program. It is possible to create a working executable for the host machine by simply invoking <code>gcc</code>, this time without the <code>-c</code> option, providing the list of the object files that must be linked together to produce the ELF file. The <code>-o</code> option is used to specify the output filename, which otherwise would default to <code>a.out</code>:</p>
<pre class="console">
$ gcc -o helloworld hello.o world.o</pre>
<p>This command will try to build the <code>helloworld</code> file, which is an ELF executable for the host system, using the symbols previously compiled into the two objects.</p>
<p>In an embedded system things change a bit, as booting a bare-metal application implies that the sections must be mapped to physical areas in memory at linking time. To instruct the linker to associate the sections to well-known physical addresses, a custom linker script file must be provided, describing the memory layout of the executable bare-metal application, and providing additional custom sections that may be required by the target system.</p>
<p>A more detailed explanation of the linking step is provided later, in the <em class="italic">Linking the </em><em class="italic">executable</em> section.</p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor060"/>Make: a build automation tool</h2>
<p>Several open<a id="_idIndexMarker097"/> source tools are available to automate a build process, and a few of them are widely used in different development environments. <strong class="bold">Make</strong> is<a id="_idIndexMarker098"/> the standard UNIX tool to automate the steps required to create the required binary images from the sources, check the dependencies for each component, and execute the steps in the right order. Make is a<a id="_idIndexMarker099"/> standard <strong class="bold">POSIX tool</strong>, and it is part of many UNIX-like systems. In a GNU/Linux distribution, it is implemented as a standalone tool, which is part of the GNU project. From this point on, the GNU Make implementation is simply referred to as Make.</p>
<p>Make is designed to execute the default build by simply invoking the <code>make</code> command with no arguments from the command line, provided<a id="_idIndexMarker100"/> that a <strong class="bold">makefile</strong> is present in the working directory. A makefile is a special instruction file, containing rules and recipes to build all the files needed until the expected output files are generated. Open source alternatives offering similar solutions for build automation exist, such as CMake and SCons, but all the examples in this book are built using Make because it provides a simple and essential enough environment to control the build system, and it is the one standardized by <strong class="bold">POSIX</strong>.</p>
<p>Some<a id="_idIndexMarker101"/> integrated development environments use built-in mechanisms to coordinate the building steps or generate makefiles before invoking Make automatically when the user requests to build the output files. However, editing makefiles manually gives complete control over the intermediate steps to generate the final images, where the user can customize the recipes and rules used to generate the desired output files.</p>
<p>There is no specific version that needs to be installed to cross compile code for the Cortex-M target, but some extra parameters, such as the location of the toolchain binaries, or the specific flags needed by the compiler, need to be taken care of when writing targets and directives within the makefile.</p>
<p>One of the advantages of using a build process is that targets may have implicit dependencies from other intermediate components that are automatically resolved at compile time. If all the dependencies are correctly configured, a makefile ensures that the intermediate steps are executed only when needed, reducing the compile time of the whole project when only a few sources are altered or when single object files have been deleted.</p>
<p>Makefiles have a specific syntax to describe rules. Each rule begins with the target files expected as the output of the rule, a colon, and the list of prerequisites, which are the files necessary to execute the rule. A set of recipe items follow, each one describing the actions that Make will execute to create the desired target:</p>
<pre class="source-code">
target: [prerequisites]
 recipe
 recipe
 ...</pre>
<p>By default, Make will execute the first rule encountered while parsing the file if no rule name is specified from the command line. If any of the prerequisites are not available, Make automatically looks for a rule in the same makefile that can create the required file recursively until the chain of requirements is satisfied.</p>
<p>Makefiles<a id="_idIndexMarker102"/> can assign a custom string of text to internal variables while executing. Variable names can be assigned using the <code>=</code> operator and referred to by prefixing them with <code>$</code>. For example, the following assignment is used to put the name of two object files into the <code>OBJS</code> variable:</p>
<pre class="source-code">
OBJS = hello.o world.o</pre>
<p>A few <a id="_idIndexMarker103"/>important variables that are assigned automatically within the rules are the following:</p>
<div><div><img alt="Table 2.1 – Some automatic variables that can be used in makefile recipes " src="img/011.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.1 – Some automatic variables that can be used in makefile recipes</p>
<p>These variables are handy to use within the recipe action lines. For example, the recipe to generate a <code>helloworld</code> ELF file from the two object files can be written as follows:</p>
<pre class="console">
helloworld: $(OBJS)
 gcc -o $(@) $(^)</pre>
<p>Some of the rules are implicitly defined by Make. For example, the rule to create the <code>hello.o</code> and <code>world.o</code> files from their respective source files can be omitted, as Make expects to be able to obtain each one of these object files in the most obvious way, which is by compiling the corresponding C source files with the same name if present. This means that this minimalist makefile is already able to compile the two objects from the sources and link them together using the default set of options for the host system.</p>
<p>The linking recipe can also be implicit if the executable has the same name as one of its prerequisite objects minus its <code>.o</code> extension. If the final ELF file is called <code>hello</code>, our makefile could simply become the following one-liner:</p>
<pre class="source-code">
hello: world.o</pre>
<p>This would <a id="_idIndexMarker104"/>automatically resolve the <code>hello.o</code> and <code>world.o</code> dependencies, and then link them together using an implicit linker recipe similar to the one we used in the explicit target.</p>
<p>Implicit rules use <a id="_idIndexMarker105"/>predefined variables, which are assigned automatically before the rules are executed, but can be modified within the makefile. For example, it is possible to change the default compiler by altering the <code>CC</code> variable. Here is a short list of the most important variables that may be used to alter implicit rules and recipes:</p>
<div><div><img alt="Table 2.2 – Implicit, predefined variables that specify the default toolchain and flags " src="img/02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.2 – Implicit, predefined variables that specify the default toolchain and flags</p>
<p>When linking a bare-metal application for embedded platforms, the makefile must be modified accordingly, and as shown later in this chapter, several flags are required to properly cross compile the sources and instruct the linker to use the desired memory layout to organize the memory sections. Moreover, additional steps are generally needed to manipulate the ELF file and translate it to a format that can be transferred to the target system. However, the syntax of the makefile is the same, and the simple rules shown here are not too different from those used to build the example. The default variables still need to be adjusted to modify the default behavior if implicit rules are used.</p>
<p>When all the <a id="_idIndexMarker106"/>dependencies are correctly configured in the makefile, Make ensures that the rules are only executed when the target is older than its dependencies, thus reducing the compile time of the whole project when only a few sources are altered or when single object files have been deleted.</p>
<p>Make is a<a id="_idIndexMarker107"/> very powerful tool, and its range of possibilities goes far beyond the few features used to generate the examples in this book. Mastering the automation process of builds may lead to optimized build processes. The syntax of makefiles includes useful features, such as conditionals, which can be used to produce different results by invoking a makefile using different targets or environment variables. For a better understanding of the <a id="_idIndexMarker108"/>capabilities of Make, please refer to the GNU Make manual available at <a href="https://www.gnu.org/software/make/manual">https://www.gnu.org/software/make/manual</a>.</p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor061"/>Debugger</h2>
<p>In the<a id="_idIndexMarker109"/> host environment, debugging an application that runs on top of the operating system is done by<a id="_idIndexMarker110"/> running a debugger tool, which can attach to an existing process or spawn a new one given an executable ELF file and its command-line arguments. The default debugging option provided by the GCC suite is called <strong class="bold">GDB</strong>, an acronym for <a id="_idIndexMarker111"/>the <strong class="bold">GNU Debugger</strong>. While GDB is a command-line tool, several frontends have been developed to provide better visualization of the state of the execution, and some integrated development environments provide built-in frontends for interacting with the debugger while tracing the single lines being executed.</p>
<p>Once again, the situation is slightly changed when the software to debug is running on a remote platform. A version of GDB, distributed with the toolchain and specific to the target platform, can be run on the development machine to connect to a remote debug session. A debug session on a remote target requires an intermediate tool that is configured to translate GDB commands into actual actions on the core CPU and the related hardware infrastructure to establish communication with the core.</p>
<p>Some embedded platforms provide hardware breakpoints, which are used to trigger system exceptions every time the selected instructions are executed.</p>
<p>Later in this chapter, we will<a id="_idIndexMarker112"/> see how a remote GDB session can be established with the target in order to interrupt its execution at the current point, proceed to step through the code, place breakpoints and watchpoints, and inspect and modify the values in memory.</p>
<p>A handful of <a id="_idIndexMarker113"/>GDB commands are introduced, giving a quick reference to some of the functionalities provided by the GDB command-line interface, which can be effectively used to debug embedded applications.</p>
<p>The<a id="_idIndexMarker114"/> debugger gives the best possible understanding of what the software is doing at runtime and facilitates the hunt for programming errors while directly looking at the effects of the execution on memory and CPU registers.</p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor062"/>Embedded workflow</h2>
<p>If <a id="_idIndexMarker115"/>compared to other domains, the embedded development life cycle includes some additional steps. The code must be cross compiled, the image manipulated then uploaded to a target, tests must be run, and possibly hardware tools are involved in the measurement and verification phases. The life cycle of native application software, when using compiled languages, looks like this diagram:</p>
<div><div><img alt="Figure 2.1 – A typical life cycle of application development" src="img/B18730_02_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – A typical life cycle of application development</p>
<p>When writing software within the same architecture, tests and debugging can be performed right after compiling, and it is often easier to detect issues. This results in a shorter time for the typical loop. Moreover, if the application crashes because of a bug, the underlying operating system can produce a core dump, which can be analyzed using the debugger at a later time by restoring the content of the virtual memory and the context of the CPU registers right at the moment when the bug shows up.</p>
<p>On <a id="_idIndexMarker116"/>the other hand, intercepting fatal errors on an embedded target might be slightly more challenging because of the potential side effect of memory and register corruption in the absence of virtual addresses and memory segmentation provided by the operating systems in other contexts. Even if some targets can intercept abnormal situations by triggering diagnostic interrupts, such as the hard fault handler in Cortex-M, restoring the original context that generated the error is often impossible.</p>
<p>Furthermore, every time new software is generated, there are a few time-consuming steps to perform, such as the translation of the image to a specific format, and uploading the image to the target itself, which may take anywhere from a few seconds up to a minute, depending on the size of the image and the speed of the interface used to communicate with the target:</p>
<div><div><img alt="Figure 2.2 – The embedded development life cycle, including additional steps required by the environment" src="img/B18730_02_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – The embedded development life cycle, including additional steps required by the environment</p>
<p>In <a id="_idIndexMarker117"/>some of the phases of the development, when multiple consecutive iterations may be required to finalize a feature implementation or detect a defect, the timing between compiling and testing the software has an impact on the efficiency of the whole life cycle. Specific tasks implemented in the software, which involve communication through serial or network interfaces, can only be verified with signal analysis or by observing the effect on the peripheral or the remote system involved. Analyzing the electrical effects on the embedded system requires some hardware setup and instrument configuration, which add more time to the equation.</p>
<p>Finally, developing a distributed embedded system composed of several devices running different software images may result in repeating the preceding iterations for each of these devices. Whenever possible, these steps should be eliminated by using the same image and different set configuration parameters on each device and by implementing parallel firmware upgrade mechanisms. Protocols such as JTAG support uploading the software image to multiple targets sharing the same bus, significantly cutting down the time required for the firmware upgrades, especially in those distributed systems with a larger number of devices involved.</p>
<p>No<a id="_idIndexMarker118"/> matter how complex the project is expected to be, it is, in general, worth spending as much time as needed to optimize the life cycle of the software development at the beginning in order to increase efficiency later on. No developer likes to switch the focus away from the actual coding steps for too long, and it might be frustrating to work in a suboptimal environment where stepping through the process requires too much time or human interaction.</p>
<p>An embedded project can be started from scratch using a text editor or by creating a new project in an integrated development environment.</p>
<h1 id="_idParaDest-49"><a id="_idTextAnchor063"/>Text editors versus integrated environments</h1>
<p>While mostly a <a id="_idIndexMarker119"/>matter of developer preferences, the debate is still open in the embedded community between those who use a standalone <a id="_idIndexMarker120"/>text editor and those who prefer to have all the components of the toolchain integrated into one GUI.</p>
<p>Modern IDEs incorporate tools for the following tasks:</p>
<ul>
<li>Managing the components of the project</li>
<li>Quickly accessing all the files for editing as well as extensions to upload the software on the board</li>
<li>Starting a debugging session with a single click</li>
</ul>
<p>Microcontroller manufacturers often distribute their development kits along with IDEs that make it easy to access advanced features that are specific to the microcontroller, thanks to preconfigured setups and wizards facilitating the creation of new projects. Most IDEs include widgets to automatically generate the setup code for pin multiplexing for specific microcontrollers, starting from a graphical interface. Some of them even offer simulators and tools to predict runtime resource usage, such as dynamic memory and power consumption.</p>
<p>The <a id="_idIndexMarker121"/>majority of these tools are based on <a id="_idIndexMarker122"/>some customization of Eclipse, a popular open source desktop IDE, originally designed as a tool for Java software development, then later on very successful in many other fields thanks to the possibilities to extend and customize its interface.</p>
<p>There are downsides to the IDE approach too. IDEs, in general, do not embed the actual toolchain in the code. Rather, they provide a frontend interface to interact with a compiler, linker, debugger, and other tools. To do so, they have to store all the flags, configuration options, the paths of included files, and compile-time-defined symbols in a machine-readable configuration file. Some users find those options difficult to access by navigating through the multiple menus of the GUI. Other key components of the project, such as the linker script, may also be well hidden under the hood, in some cases even automatically generated by the IDE and difficult to read. For most IDE users, however, these downsides are compensated by the perks of developing with an integrated environment.</p>
<p>There is one last caveat that has to be considered, though. The project will sooner or later be built and tested automatically, as previously analyzed in the <em class="italic">Make: a build automation tool</em> section. Robots are, in general, terrible users of IDEs, while they can build and run any test, even interacting with real targets, using a command-line interface. A development team using an IDE for embedded development should always consider providing an option to build and test any software through a command-line alternate strategy.</p>
<p>While some complexity of the toolchain can be abstracted with a GUI, it is useful to understand the functions of the set of applications under the hood. The remaining sections of this chapter explore the GCC toolchain, the most popular cross-architecture set of compilers for many 32-bit microcontrollers.</p>
<h1 id="_idParaDest-50"><a id="_idTextAnchor064"/>The GCC toolchain</h1>
<p>While in the<a id="_idIndexMarker123"/> case of the IDE, its complexity is abstracted through the user interface, a toolchain is a set of standalone software applications, each one serving a specific purpose.</p>
<p>GCC is one of the reference toolchains to build embedded systems due to its modular structure allowing backends for multiple architectures. Thanks to its open source model, and the flexibility in building tailored toolchains from it, GCC-based toolchains are among the most popular development tools in embedded systems.</p>
<p>Building software using a command-line-based toolchain has several advantages, including the possibility of automating the intermediate steps that would build all the modules up from the source code into the final image. This is particularly useful when it is required to program multiple devices in a row or to automate builds on a continuous integration server.</p>
<p>ARM distributes the GNU Arm Embedded Toolchain for all the most popular development hosts. Toolchains are prefixed with a triplet describing the target. In the case of the GNU Arm Embedded Toolchain, the prefix is <code>arm-none-eabi</code>, indicating that the cross compiler backend is configured to produce objects for ARM, with no specific support for an operating system API, and with the embedded ABI.</p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor065"/>The cross compiler</h2>
<p>The<a id="_idIndexMarker124"/> cross compiler<a id="_idIndexMarker125"/> distributed with a toolchain is a variant of GCC, with the backend configured to build object files that contain machine code for a specific architecture. The output of the compilation is one set of object files containing symbols that can only be interpreted by the specific target.<code> Arm-none-eabi-gcc</code>, the GCC variant provided by ARM to build software for microcontrollers, can compile C code into machine instructions and CPU optimizations for several different targets. Each architecture needs its own specific toolchain that will produce target-specific executables.</p>
<p>The GCC backend for the ARM architecture supports several machine-specific options to select the correct instruction set for the CPU and the machine-specific optimization parameters.</p>
<p>The following table lists some of the ARM-specific machine options available on the GCC backend as <code>-</code><code>m</code> flags:</p>
<div><div><img alt="Table 2.3 – Architecture-specific compiler options for GCC ARM " src="img/03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.3 – Architecture-specific compiler options for GCC ARM</p>
<p>To <a id="_idIndexMarker126"/>compile<a id="_idIndexMarker127"/> code that is compatible with a generic ARM Cortex M4, the <code>-mthumb</code> and <code>-mcpu=cortex-m4</code> options must be specified every time the compiler is invoked:</p>
<pre class="console">
$ arm-none-eabi-gcc -c test.c -mthumb -mcpu=cortex-m4</pre>
<p>The <code>test.o</code> file that is the result of this compile step is very different from the one that can be compiled, from the same source, using the <code>gcc</code> host. The difference can be better appreciated if, instead of the two object files, the intermediate assembly code is compared. The compiler is, in fact, capable of creating intermediate assembly code files instead of compiled and assembled objects when it is invoked with the <code>-</code><code>S</code> option.</p>
<p>In a similar way to the host GCC compiler, there are different levels of possible optimization available to activate. In some cases, it makes sense to activate the size optimization to generate smaller object files. It is preferable, though, that the non-optimized image can fit the flash during the development to facilitate the debugging procedures, as optimized code flow is more difficult to follow when the compiler may change the order of the execution of the code and hide away the content of some variables. The optimization parameter can be provided at the command line to select the desired optimization level:</p>
<div><div><img alt="Table 2.4 – GCC levels of optimization " src="img/04.jpg"/>
</div>
</div>
<p class="IMG---Figure">Table 2.4 – GCC levels of optimization</p>
<p>Another <a id="_idIndexMarker128"/>generic GCC command-line option that is often <a id="_idIndexMarker129"/>used while debugging and prototyping is the <code>-g</code> flag, which instructs the compiler to keep the debugging-related data in the final object in order to facilitate access to functions’ and variables’ readable handles while running within the debugger.</p>
<p>To inform the compiler that we are running a bare-metal application, the <code>-ffreestanding</code> command-line option is used. In GCC jargon, a freestanding environment is defined by the possible lack of a standard library in the linking step, and most importantly, this option alerts the compiler that it should not expect to use the main function as the entry point of the program or provide any preamble code before the beginning of the execution. This option is required when compiling code for the embedded platforms, as it enables the boot mechanism described in <a href="B18730_04.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">The </em><em class="italic">Boot-Up Procedure</em>.</p>
<p>The<a id="_idIndexMarker130"/> GCC program supports many more command-line options than those quickly introduced here. For a more complete overview of the functionalities offered, please refer to the GNU GCC manual, available at <a href="https://gcc.gnu.org/onlinedocs/">https://gcc.gnu.org/onlinedocs/</a>.</p>
<p>To integrate the cross compiling toolchain in the automated build using Make, a few changes are required in the makefile.</p>
<p>Assuming<a id="_idIndexMarker131"/> that the toolchain is correctly installed on the development host and reachable in its executing path, it is sufficient to change the default compiler command using the <code>CC</code> Make variable in the makefile:</p>
<pre class="source-code">
CC=arm-none-eabi-gcc</pre>
<p>The <a id="_idIndexMarker132"/>custom command-line options required to run the compile options may be exported through the <code>CFLAGS</code> variable:</p>
<pre class="source-code">
CFLAGS=-mthumb -mcpu=cortex-m4 -ffreestanding</pre>
<p>Using default makefile variables, such as <code>CC</code> and <code>CFLAGS</code>, enables implicit makefile rules, building object files from <code>C</code> sources with the same name, and a custom compiler configuration.</p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor066"/>Compiling the compiler</h2>
<p>Binary<a id="_idIndexMarker133"/> distributions of the GCC toolchain are available to download for several specific targets and host machines. To compile the code for the ARM Cortex-M microprocessors, the <code>arm-none-eabi</code> toolchain is made available for most GNU/Linux distributions. However, in some cases, it might be handy to build the toolchain entirely from the sources. This might be, for example, when the compiler for a certain target does not exist yet or is not shipped in binary format for our favorite development environment. This process is also useful to better understand the various components that are required to build the tools.</p>
<p><code>menuconfig</code> kernel. After installing crosstool-NG, the configurator can be invoked by using the following:</p>
<pre class="console">
$ ct-ng menuconfig</pre>
<p>Once the configuration has been created, the build process can be started. Since the operation requires retrieving all the components, patching them, and building the toolchain, it may take several minutes, depending on the speed of the host machine and the internet connection, to retrieve all the components. The build process can be started by issuing the following:</p>
<pre class="console">
$ ct-ng build</pre>
<p>Predefined<a id="_idIndexMarker135"/> configurations are available for compiling commonly used toolchains, mostly for targets running Linux. When compiling a toolchain for a Linux target, there are a few C libraries to choose from. In our case, since we want a bare-metal toolchain, <code>newlib</code> is the default choice. Several other libraries provide an implementation of a subset of the C standard library, such as <code>uClibc</code> and <code>musl</code>. The <code>newlib</code> library is a small cross-platform C library mostly designed for embedded systems with no operating system on board, and it is provided as the default in many GCC distributions, including the <code>arm-none-eabi</code> cross compiler distributed by ARM.</p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor067"/>Linking the executable</h2>
<p><code>-T filename</code> option at the command line, the linker is asked to replace the default memory layout for the program with a custom script, contained in the filename.</p>
<p>The <code>.ld</code> extension, and it is written in a specific language. As a rule of thumb, all the symbols from every single compiled object are grouped in the sections of the final executable image.</p>
<p>The script can interact with the C code, exporting symbols defined within the script and following indications provided in the code using GCC-specific attributes associated with symbols. The <code>__attribute__</code> keyword is provided by GCC to be put in front of the symbol definition to activate GCC-specific, non-standard attributes for each symbol.</p>
<p>Some GCC attributes can be used to communicate to the linker about the following:</p>
<ul>
<li>Weak symbols, which can be overridden by symbols with the same name</li>
<li>Symbols to be stored in a specific section in the ELF file, defined in the linker script</li>
<li>Implicitly used symbols, which prevent the linker from discarding the symbol because it is referred to nowhere in the code</li>
</ul>
<p>The <code>weak</code> attribute<a id="_idIndexMarker139"/> is used to define weak symbols, which can be overridden anywhere else in the code by another definition with the same name. Consider, for example, the following definition:</p>
<pre class="source-code">
void __attribute__(weak) my_procedure(int x) {/* do nothing */}</pre>
<p>In this case, the procedure is defined to do nothing, but it is possible to override it anywhere else in the code base by defining it again, using the same name, but this time without the <code>weak</code> attribute:</p>
<pre class="source-code">
void my_procedure(int x) { y = x; }</pre>
<p>The linker step ensures that the final executable contains exactly one copy of each defined symbol, which is the one without the attribute, if available. This mechanism introduces the possibility of having several different implementations of the same functionality within the code, which can be altered by including different object files in the linking phase. This is particularly useful when writing code that is portable to different targets while still maintaining the same abstractions.</p>
<p>Besides the default sections required in the ELF description, custom sections may be added to store specific symbols, such as functions and variables, at fixed memory addresses. This is useful when storing data at the beginning of a flash page, which might be uploaded to flash at a different time than the software itself. This is the case for target-specific settings in some cases.</p>
<p>Using the custom GCC <code>section</code> attribute when defining a symbol ensures that the symbol ends up at the desired position in the final image. Sections may have custom names as long as an entry exists in the linker to locate them. The <code>section</code> attribute can be added to a symbol definition as follows:</p>
<pre class="source-code">
const uint8_t
 __attribute__((section(".keys")))
 private_key[KEY_SIZE] = {0};</pre>
<p>In this example, the array is placed in the <code>.keys</code> section, which requires its own entry in the linker script as well.</p>
<p>It is <a id="_idIndexMarker140"/>considered good practice to have the linker discard the unused symbols in the final image, especially when using third-party libraries that are not completely utilized by the embedded application. This can be done in GCC using the linker garbage collector, activated via the <code>-gc-sections</code> command-line option. If this flag is provided, the sections that are unused in the code are automatically discarded, and the unused symbols will be kept out of the final image.</p>
<p>To prevent the linker from discarding symbols associated with a particular section, the <code>used</code> attribute marks the symbol as implicitly used by the program. Multiple attributes can be listed in the same declaration, separated by commas, as follows:</p>
<pre class="source-code">
const uint8_t    __attribute__((used,section(".keys")))
   private_key[KEY_SIZE] = {0};</pre>
<p>In this example, the attributes indicate both that the <code>private_key</code> array belongs to the <code>.keys</code> section and that it must not be discarded by the linker garbage collector because it is marked as used.</p>
<p>A simple linker script for an embedded target defines at least the two sections relative to <code>RAM</code> and <code>FLASH</code> mapping and exports some predefined symbols to instruct the assembler of the toolchain about the memory areas. A bare-metal system based on the GNU toolchain usually starts with a <code>MEMORY</code> section, describing the mapping of the two different areas in the system, such as the following:</p>
<pre class="source-code">
MEMORY {
  FLASH(rx) : ORIGIN = 0x00000000, LENGTH=256k
  RAM(rwx) : ORIGIN = 0x20000000, LENGTH=64k
}</pre>
<p>The preceding code snippet describes two memory areas used in the system. The first block is 256k mapped to <code>FLASH</code>, with the <em class="italic">r and x flags</em> indicating that the area is accessible for <em class="italic">read</em> and <em class="italic">execute</em> operations. This enforces the read-only attribute of the whole area and ensures that no variant sections are placed there. RAM, on the other hand, can be accessed in write mode directly, which means that variables are going to be placed in a section within that area. In this specific example, the target maps the FLASH mapping at the beginning of the address space, while the RAM is mapped starting at 512 MB. Each target has its address space mapping and flash/RAM size, which makes the linker script target-specific.</p>
<p>As mentioned earlier in this chapter, the <code>.text</code> and <code>.rodata</code> ELF sections can only be accessed for reading, so they can safely be stored in the FLASH area since they will not be modified while the target is running. On the other hand, both <code>.data</code> and <code>.bss</code> must be mapped in RAM to ensure that they are modifiable.</p>
<p>Additional <a id="_idIndexMarker141"/>custom sections can be added to the script where it is necessary to store additional sections at a specific location in memory. The linker script can also export symbols related to a specific position in memory or to the length of dynamically sized sections in memory, which can be referred to as external symbols and accessed in the C source code.</p>
<p>The second block of statements in the linker script is called <code>SECTIONS</code> and contains the allocation of the sections in specific positions of the defined memory areas. The <code>.</code> symbol, when associated with a variable in the script, represents the current position in the area, which is filled progressively from the lower addresses available.</p>
<p>Each section must specify the area where it has to be mapped. The following example, though still incomplete to run the binary executable, shows how the different sections can be deployed using the linker script. The <code>.text</code> and <code>.rodata</code> sections are mapped in the flash memory:</p>
<pre class="source-code">
SECTIONS
{
    /* Text section (code and read-only data) */
    .text :
    {
        . = ALIGN(4);
        _start_text = .;
        *(.text*) /* code */
        . = ALIGN(4);
        _end_text = .;
        *(.rodata*) /* read only data */
        . = ALIGN(4);
        _end_rodata = .;
} &gt; FLASH</pre>
<p>The modifiable sections are mapped in RAM, with two special cases to notice here.</p>
<p>The <code>AT</code> keyword<a id="_idIndexMarker142"/> is used to indicate the load address to the linker, which is the area where the original values of the variables in <code>.data</code> are stored, while the actual addresses used in the execution are in a different memory region. More details about the load address and the virtual address for the <code>.data</code> section are explained in <a href="B18730_04.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">The </em><em class="italic">Boot-Up Procedure</em>.</p>
<p>The <code>NOLOAD</code> attribute used for the <code>.bss</code> section ensures that no predefined values are stored in the ELF file for this section. Uninitialized global and static variables are mapped by the linker in the RAM area, which is allocated by the linker:</p>
<pre class="source-code">
_stored_data = .;
.data: AT(__stored_data)
{
    . = ALIGN(4);
    _start_data = .;
    *(.data*)
    . = ALIGN(4);
    _start_data = .;
} &gt; RAM
.bss (NOLOAD):
{
    . = ALIGN(4);
    _start_bss = .;
    *(.bss*)
    . = ALIGN(4);
    _end_bss = .;
} &gt; RAM</pre>
<p>The <a id="_idIndexMarker143"/>alternative way to force the linker to keep sections in the final executable, avoiding their removal due to the linker garbage collector, is the use of the <code>KEEP</code> instruction to mark sections. Please note that this is an alternative to the <code>__attribute__((used))</code> mechanism explained earlier:</p>
<pre class="source-code">
.keys :
{
    . = ALIGN(4);
    *(.keys*) = .;
    KEEP(*(.keys*));
} &gt; FLASH</pre>
<p>It is useful, and advisable in general, to have the linker create a <code>.map</code> file alongside the resultant binary. This is done by appending the <code>-Map=filename</code> option to the link step, such as in the following:</p>
<pre class="console">
$ arm-none-eabi-ld -o image.elf object1.o object2.o 
-T linker_script.ld -Map=map_file.map</pre>
<p>The map file contains the location and the description of all the symbols, grouped by sections. This is useful for looking for the specific location of symbols in the image, as well as for verifying that useful symbols are not accidentally discarded due to a misconfiguration.</p>
<p>Cross compiling toolchains provide standard C libraries for generic functionalities, such as string manipulation or standard type declarations. These are substantially a subset of the library calls available in the application space of an operating system, including standard input/output functions. The backend implementation of these functions is often left to the applications, so calling a function from the library that requires interaction with the hardware, such as <code>printf</code>, implies that a write function is implemented outside of the library, providing the final transfer to a device or peripheral.</p>
<p>The implementation of the backend write function determines which channel would act as the <a id="_idIndexMarker144"/>standard output for the embedded application. The linker is capable of resolving the dependencies towards standard library calls automatically, using the built-in <code>newlib</code> implementation. To exclude the standard C library symbols from the linking process, the <code>-nostdlib</code> option can be added to the options passed to GCC during the linking step.</p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor068"/>Binary format conversion</h2>
<p>Despite<a id="_idIndexMarker145"/> containing all the compiled symbols in binary format, an ELF file is prefixed with a header that contains a description of the content and pointers to the positions where the sections start within the file. All this extra information is not needed to run on an embedded target, so the ELF file produced by the linker has to be transformed into a plain binary file. A tool in the toolchain, called <code>objcopy</code>, converts images from one standard format to others, and what is generally done is a conversion of the ELF into a raw binary image without altering the symbols. To transform the image from ELF to binary format, invoke the following:</p>
<pre class="console">
$ arm-none-eabi-objcopy -I elf -O binary image.elf image.bin</pre>
<p>This creates a new file, called <code>image.bin</code>, from the symbols contained in the original ELF executable, which can be uploaded to the target.</p>
<p>Even if not suitable in general for direct upload on the target with third-party tools, it is possible to load the symbols through the debugger and upload them to the flash address. The original ELF file is also useful as the target of other diagnostic tools in the GNU toolchain, such as <code>nm</code> and <code>readelf</code>, which display the symbols in each module, with their type and relative address within the binary image. Furthermore, by using the <code>objdump</code> tool on the final image, or even on single object files, several details about the image can be retrieved, including the visualization of the entire assembly code, using the <code>-d</code> disassemble option:</p>
<pre class="console">
arm-none-eabi-objdump -d image.elf</pre>
<p>At this point, the toolchain has provided us with all the artifacts needed to run, debug, and analyze the compiled software on a target microcontroller. In order to transfer the image or start a debugging session, we need additional specific tools, described in the next section.</p>
<h1 id="_idParaDest-55"><a id="_idTextAnchor069"/>Interacting with the target</h1>
<p>For <a id="_idIndexMarker146"/>development purposes, embedded platforms are usually accessed through a JTAG or an SWD interface. Through these communication channels, it is possible to upload the software onto the flash of the target and access the on-chip debug functionality. Several self-contained JTAG/SWD adapters on the market can be controlled through a USB from the host, while some development boards are equipped with an extra chip controlling the JTAG channel that connects to the host through a USB.</p>
<p>A powerful generic open source tool to access JTAG/SWD functionalities on the target is the <strong class="bold">Open On-Chip Debugger</strong> (<strong class="bold">OpenOCD</strong>). Once<a id="_idIndexMarker147"/> properly configured, it creates local sockets that can be used as a command console and for interaction with the debugger frontend. Some development boards are distributed with additional interfaces to communicate with the core CPU. For example, STMicroelectronics prototyping<a id="_idIndexMarker148"/> boards for <strong class="bold">Cortex-M</strong> are rarely shipped without a chip technology called ST-Link, which allows direct access to debug and flash manipulation functionalities. Thanks to its flexible backend, OpenOCD can communicate with these devices using different transport types and physical interfaces, including ST-Link and other protocols. Several different boards are supported and the configuration files can be found by OpenOCD.</p>
<p>When started, OpenOCD opens two local TCP server sockets on preconfigured ports, providing communication services with the target platform. One socket provides an interactive command console that can be accessed through Telnet, while the other is a GDB server used for remote debugging, as described in the next section.</p>
<p>OpenOCD is distributed along with two sets of configuration files that describe the target microcontroller and peripherals (in the <code>target/</code> directory), and the debugging interface used to communicate to it via JTAG or SWD (in the <code>interface/</code> directory). A third set of configuration files (in the <code>board/</code> directory) contain configuration files for well-known systems, such as development boards equipped with an interface chip, which combines both interfaces and target settings by including the correct files.</p>
<p>In order to configure OpenOCD for<a id="_idIndexMarker149"/> the <code>openocd.cfg</code> configuration file:</p>
<pre class="source-code">
telnet_port 4444
gdb_port 3333
source [find board/stm32f7discovery.cfg]</pre>
<p>The <a id="_idIndexMarker150"/>board-specific configuration file, which was imported from <code>openocd.cfg</code>, through the <code>source</code> directive, instructs OpenOCD to use the ST-Link interface to communicate with the target and sets all the CPU-specific options for the STM32F7 family of microcontrollers.</p>
<p>The two ports specified in the main configuration file, using the <code>telnet_port</code> and <code>gdb_port</code> directives, instruct OpenOCD to open two listening TCP sockets.</p>
<p>The first socket, often referred to as the monitor console, can be accessed by connecting to the<a id="_idIndexMarker151"/> local <strong class="bold">4444 TCP port</strong>, using a Telnet client from the command line:</p>
<pre class="console">
$ telnet localhost 4444
Open On-Chip Debugger
&gt;</pre>
<p>The sequence of OpenOCD directives to initialize, erase the flash, and transfer the image starts with the following:</p>
<pre class="source-code">
&gt; init
&gt; halt
&gt; flash probe 0</pre>
<p>The execution is stopped at the beginning of the software image. After the <code>probe</code> command, the flash is initialized, and OpenOCD will print out some information, including the address mapped to write on the flash. The following information shows up with the STM32F746:</p>
<pre class="source-code">
device id = 0x10016449
flash size = 1024kbytes
flash "stm32f2x" found at 0x08000000</pre>
<p>The <a id="_idIndexMarker152"/>geometry of the flash can be retrieved using this command:</p>
<pre class="console">
&gt; flash info 0</pre>
<p>Which, on STM32F746 shows as the following:</p>
<pre class="source-code">
#0 : stm32f2x at 0x08000000, size 0x00100000, buswidth 0, chipwidth 0
# 0: 0x00000000 (0x8000 32kB) not protected
# 1: 0x00008000 (0x8000 32kB) not protected
# 2: 0x00010000 (0x8000 32kB) not protected
# 3: 0x00018000 (0x8000 32kB) not protected
# 4: 0x00020000 (0x20000 128kB) not protected
# 5: 0x00040000 (0x40000 256kB) not protected
# 6: 0x00080000 (0x40000 256kB) not protected
# 7: 0x000c0000 (0x40000 256kB) not protected
STM32F7[4|5]x - Rev: Z</pre>
<p>This flash contains eight sectors. If the OpenOCD target supports it, the flash can be completely erased by issuing the following command from the console:</p>
<pre class="console">
&gt; flash erase_sector 0 0 7</pre>
<p>Once the flash memory is erased, we can upload a software image to it, linked and converted to raw binary format using the <code>flash write_image</code> directive. As the raw binary format does not contain any information about its destination address in the mapped area, the starting address in the flash must be provided as the last argument, as follows:</p>
<pre class="console">
&gt; flash write_image /path/to/image.bin 0x08000000</pre>
<p>These directives can be appended to the <code>openocd.cfg</code> file, or to different configuration files, in order to automate all the steps needed for a specific action, such as erasing the flash and uploading an updated image.</p>
<p>Some <a id="_idIndexMarker153"/>hardware manufacturers offer their own set of tools to interact with the devices. STMicroelectronics devices can be programmed using the ST-Link utilities, an open source project that includes a flash tool (<code>st-flash</code>), and a GDB server counterpart (<code>st-util</code>). Some platforms have built-in bootloaders that accept alternative formats or binary transfer procedures. A <a id="_idIndexMarker154"/>common example is <code>dfu-util</code>, which is a free software tool.</p>
<p>Each tool, either generic or specific, tends to meet the same goal of communicating with the device and providing an interface for debugging the code, although often exposing a different interface toward the development tools.</p>
<p>Most IDEs provided by manufacturers to work with a specific family of microcontrollers incorporate in the IDE their own tools or third-party applications to access flash mapping and control the execution on the target. While, on one hand, they promise to hide the unnecessary complexity of the operation and provide firmware upload in one click, on the other, they generally do not provide a convenient interface for programming multiple targets at the same time, or at least efficiently, when it comes to production in large batches requiring to upload of the initial factory firmware.</p>
<p>Knowing the mechanisms and procedures from a command-line interface allows for understanding what is happening behind the scenes every time a new firmware is uploaded to the target, and anticipating the issues that would impact the life cycle during this phase.</p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor070"/>The GDB session</h2>
<p>Regardless <a id="_idIndexMarker155"/>of the programmer’s accuracy or the complexity of the project we are working on, most of the development time will be spent trying to understand what our software does, or most likely, what has gone wrong and why the software is not behaving as we would expect when the code was written for the first time. The debugger is the most powerful tool in our toolchain, allowing us to communicate directly with the CPU, place breakpoints, control the execution flow instruction by instruction, and check the values of CPU registers, local variables, and memory areas. Good knowledge of the debugger means less time spent trying to figure out what is going on, and a more effective hunt for bugs and defects.</p>
<p>The <code>arm-none-eabi</code> toolchain<a id="_idIndexMarker156"/> includes a GDB capable of interpreting the memory and the register layout of the remote target and can be accessed with the same interfaces as the host GDB, provided that its backend can communicate with the embedded platform, using OpenOCD or a similar host tool providing communication with the target through the GDB server protocol. As previously described, OpenOCD can be configured to provide a GDB server interface, which in the proposed configuration is on port <code>3333</code>.</p>
<p>After starting <code>arm-none-eabi-gdb</code>, we may connect to the running tool using the GDB <code>target</code> command. Connecting to the GDB server while OpenOCD is running can be done using the <code>target</code> command:</p>
<pre class="console">
&gt; target remote localhost:3333</pre>
<p>All GDB commands can be abbreviated, so the command often becomes the following:</p>
<pre class="console">
&gt; tar rem :3333</pre>
<p>Once connected, the target would typically stop the execution, allowing GDB to retrieve the information about the instruction that is currently being executed, the stack trace, and the values of the CPU registers.</p>
<p>From this moment on, the debugger interface can be used normally to step through the code, place breakpoints and watchpoints, and inspect and alter CPU registers and writable memory areas at runtime.</p>
<p>GDB can be used entirely from its command-line interface, using shortcuts and commands to start and stop the execution, and access memory and registers.</p>
<p>The following reference table enumerates a<a id="_idIndexMarker157"/> few of the GDB commands available in a debug session and provides a quick explanation of their usage:</p>
<div><div><img alt="Table 2.5 – A few commonly used GDB commands" src="img/05a.jpg"/>
</div>
</div>
<div><div><img alt="Table 2.5 – A few commonly used GDB commands" src="img/05b.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.5 – A few commonly used GDB commands</p>
<p>GDB is a <a id="_idIndexMarker158"/>very <a id="_idIndexMarker159"/>powerful and complete debugger, and the commands that have been shown in this section are a small portion of its actual potential. We advise you to discover the other features offered by GDB by going through its manual in order to find the set of commands that best fit your needs.</p>
<p>IDEs often offer a separate graphic mode to deal with debugging sessions, which is integrated with the editor and allows you to set breakpoints, watch variables, and explore the content of memory areas while the system is running in <em class="italic">debug mode</em>.</p>
<h1 id="_idParaDest-57"><a id="_idTextAnchor071"/>Validation</h1>
<p>Debugging <a id="_idIndexMarker160"/>alone, or even simple output analysis is often not enough when verifying system behavior and identifying issues and unwanted effects in the code. Different approaches may be taken to validate the implementation of single components, as well as the behavior of the entire system under different conditions. While, in some cases, the results can be directly measurable from the host machine, in more specific contexts, it is often difficult to reproduce the exact scenario or to acquire the necessary information from the system output.</p>
<p>External tools may come in handy, especially in the analysis of communication interfaces and network devices in a more complex, distributed system. In other cases, single modules can be tested off-target using simulated or emulated environments to run smaller portions of the code base.</p>
<p>Different tests, validation strategies, and tools are considered in this section to provide solutions for any scenario.</p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor072"/>Functional tests</h2>
<p>Writing<a id="_idIndexMarker161"/> test cases before writing the code is generally considered an <a id="_idIndexMarker162"/>optimal practice in modern programming. Writing tests first not only speeds up the development phases but also improves the structure of the workflow. By setting clear and measurable goals from the beginning, it is harder to introduce conceptual defects in the design of the single components, and it also forces a clearer separation among the modules. More specifically, an embedded developer has less possibility to verify the correct behavior of the system through direct interaction; thus <strong class="bold">test-driven development</strong> (<strong class="bold">TDD</strong>) is <a id="_idIndexMarker163"/>the preferred approach for the verification of single components as well as the functional behavior of the entire system, as long as the expected results can be directly measurable from the host system.</p>
<p>However, it must be considered that testing often introduces dependencies on specific hardware, and sometimes the output of an embedded system can only be validated through specific hardware tools or in a very unique and peculiar usage scenario. In all these cases, the usual TDD paradigm is less applicable, and the project can instead benefit from a modular design to give the possibility to test as many components as possible in a synthetic environment, such as emulators or unit test platforms.</p>
<p>Writing tests often involves programming the host so that it can retrieve information about the running target while the embedded software is executing or alongside an ongoing debugging session while the target executes in between breakpoints. The target can be configured to provide immediate output through a communication interface, such as a UART-based serial port, which can, in turn, be parsed by the host. It is usually more convenient to write test tools on the host using a higher-level interpreted programming language to better organize the test cases and easily integrate the parsing of test results using regular expressions. Python, Perl, Ruby, and other languages with similar characteristics, are often a good fit for this purpose, also thanks to the availability of libraries and components designed for collecting and analyzing test results and interacting with continuous integration engines. A good organization of the test and verification infrastructure contributes more than everything else to the stability of the project because regressions can be detected at the right time only if all the existing tests are repeated at every modification. Constantly running all the test cases while the development is ongoing not only improves the efficiency of detecting undesired effects as early as possible but helps keep the development goals visible at all times by directly measuring the number of failures and makes the refactoring of components more affordable at any stage in the project lifetime.</p>
<p>Efficiency is<a id="_idIndexMarker164"/> the key because embedded programming is an iterative process with several steps being repeated over and over, and the approach required from the developers is much more predictive than reactive.</p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor073"/>Hardware tools</h2>
<p>If there<a id="_idIndexMarker165"/> is a tool that is absolutely indispensable in assisting embedded software developers, it is the logic analyzer. By scoping the input and output signals involving the microcontroller, it is possible to detect the electrical behavior of the signals, their timing, and even the digital encoding of the single bits in the interface protocols. Most logic analyzers can identify and decode sequences of symbols by sensing the voltage of the wires, which is often the most effective way to verify that protocols are correctly implemented and compliant with the contracts to communicate with peripherals and network endpoints. While historically available only as standalone dedicated computers, a logic analyzer is often available in other forms, such as electronic instruments that can be connected to the host machine using USB or Ethernet interfaces, and use PC-based software to capture and decode the signals. The result of this process is a complete discrete analysis of the signals involved, which are sampled at a constant rate and then visualized on a screen.</p>
<p>While a similar task can be performed by oscilloscopes, they are often more complex to configure than logic analyzers when dealing with discrete signals. Nevertheless, an oscilloscope is the best tool for the analysis of analog signals, such as analog audio and communication among radio transceivers. Depending on the task, it might be better to use one or the other, but in general, the biggest advantage of a logic analyzer is that it provides better insight into discrete signals. Mixed-signal logic analyzers are often a good compromise between the flexibility of an oscilloscope, with the simplicity and insights of discrete signal-logic analysis.</p>
<p>Oscilloscopes and logic analyzers are often used to capture the activity of signals in a specific time window, which might be challenging to synchronize with the running software. Instead of capturing those signals continuously, the beginning of the capture can be synchronized with a physical event, such as a digital signal changing its value for the first time or an analog signal crossing a predefined threshold. This is done by configuring the instrument to initiate the capture using a trigger, which guarantees that the information captured only contains a time slice that is interesting for the ongoing diagnostic.</p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor074"/>Testing off-target</h2>
<p>Another <a id="_idIndexMarker166"/>efficient way to speed up the development is by limiting the interaction, as much as possible, with the actual target. This is, of course, not always possible, especially when developing device drivers that need to be tested on actual hardware, but tools and methodologies to partially test the software directly on the development machine exist.</p>
<p>Portions of code that are not CPU-specific can be compiled for the host machine architecture and run directly, as long as their surroundings are properly abstracted to simulate the real environment. The software to test can be as small as a single function, and in this case, a unit test can be written specifically for the development architecture.</p>
<p>Unit tests<a id="_idIndexMarker167"/> are, in general, small applications that verify the behavior of a single component by feeding them with well-known input and verifying its output. Several tools are available on a Linux system to assist in writing unit tests. The <code>check</code> library provides an interface for defining unit tests by writing a few preprocessor macros. The result is small self-contained applications that can be run every time the code is changed, directly on the host machine. Those components of the system that the function under test depends on are abstracted using mocks. For example, the following code detects and discards a specific escape sequence, <em class="italic">Esc</em> + <em class="italic">C</em>, from the input from a serial line interface, reading from the serial line until the <code>\0</code> character is returned:</p>
<pre class="source-code">
int serial_parser(char *buffer, uint32_t max_len)
{
  int pos = 0;
  while (pos &lt; max_len) {
    buffer[pos] = read_from_serial();
    if (buffer[pos] == (char)0)
      break;
    if (buffer[pos] == ESC) {
       buffer[++pos] = read_from_serial();
       if (buffer[pos] == 'c')
         pos = pos - 1;
         continue;
    }
    pos++;
  }
  return pos;
}</pre>
<p>A <a id="_idIndexMarker168"/>set of <a id="_idIndexMarker169"/>unit tests to verify this function using a check test suite may look like the following:</p>
<pre class="source-code">
START_TEST(test_plain) {
  const char test0[] = "hello world!";
  char buffer[40];
  set_mock_buffer(test0);
  fail_if(serial_parser(buffer, 40) != strlen(test0));
  fail_if(strcmp(test0,buffer) != 0);
}
END_TEST</pre>
<p>Each test case can be contained in its <code>START_TEST()/END_TEST</code> block and provide a different initial configuration:</p>
<pre class="source-code">
START_TEST(test_escape) {
  const char test0[] = "hello world!";
  const char test1[] = "hello \033cworld!";
  char buffer[40];
  set_mock_buffer(test1);
  fail_if(serial_parser(buffer, 40) != strlen(test0));
  fail_if(strcmp(test0,buffer) != 0);
}
END_TEST
START_TEST(test_other) {
  const char test2[] = "hello \033dworld!";
  char buffer[40];
  set_mock_buffer(test2);
  fail_if(serial_parser(buffer, 40) != strlen(test2));
  fail_if(strcmp(test2,buffer) != 0);
}
END_TEST</pre>
<p>This<a id="_idIndexMarker170"/> first <code>test_plain</code> test ensures that a string with no escape characters is parsed correctly. The second test ensures that the escape sequence is skipped, and the third one verifies that a similar escape string is left untouched by the output buffer.</p>
<p>Serial communication is simulated using a mock function that replaces the original <code>serial_read</code> functionality provided by the driver when running the code on the target. This is a simple mock that feeds the parser with a constant buffer that can be reinitialized using the <code>set_serial_buffer</code> helper function. The mock code looks like this:</p>
<pre class="source-code">
static int serial_pos = 0;
static char serial_buffer[40];
char read_from_serial(void) {
  return serial_buffer[serial_pos++];
}
void set_mock_buffer(const char *buf)
{
  serial_pos = 0;
  strncpy(serial_buffer, buf, 20);
}</pre>
<p>Unit tests<a id="_idIndexMarker171"/> are very useful to improve the quality of the code, but of course, achieving high code coverage consumes a large amount of time and resources in the economy of the project. Functional tests can also be run directly in the development environment by grouping functions into self-contained modules and implementing simulators that are slightly more complex than mocks for specific test cases. In the example of the serial parser, it would be possible to test the entire application logic on top of a different serial driver on the host machine, which is also able to simulate an entire conversation over the serial line, and interact with other components in the system, such as virtual terminals and other applications generating input sequences.</p>
<p>While covering a larger portion of the code within a single test case, the complexity of the simulated environment increases, and so does the amount of work required to reproduce the surroundings of the embedded system on the host machine. Nevertheless, it is good practice, especially when they could be used as verification tools throughout the whole development cycle and even integrated into the automated test process.</p>
<p>Sometimes, implementing a simulator allows for a much more complete set of tests, or it might be the only viable option. Think, for example, about those embedded systems using a GPS receiver for positioning: testing the application logic with negative latitude values would be impossible while sitting in the northern hemisphere, so writing a simulator that imitates the data coming from such a receiver is the quickest way to verify that our final device will not stop working across the equator.</p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor075"/>Emulators</h2>
<p>Another <a id="_idIndexMarker172"/>valid approach to running the code on the development machine, which is much less invasive for our code base and loosens the specific portability requirements, is emulating the whole platform on the host PC. An emulator is a computer program that can replicate the functionality of an entire system, including its core CPU, memory, and a set of peripherals. Some of the modern virtualization hypervisors for PCs are derived<a id="_idIndexMarker173"/> from <code>lm3s6965evb</code>, an old Cortex-M-based microcontroller, no longer recommended for new designs by the manufacturer, that is fu<a id="_idTextAnchor076"/>lly supported by QEMU.</p>
<p>Once a binary image has been created using <code>lm3s6965evb</code> as a target, and properly converted to raw binary format using <code>objcopy</code>, a fully emulated system can be run by invoking QEMU as follows:</p>
<pre class="console">
$ qemu-system-arm -M lm3s6965evb --kernel image.bin</pre>
<p>The <code>--kernel</code> option instructs the emulator to run the image at startup, and while it might sound misnamed, it is called <code>kernel</code> because QEMU is widely used to emulate headless Linux systems on other synthetic targets. Similarly, a convenient debugging session can be started by using QEMU’s built-in GDB server through the <code>-gdb</code> option, which can also halt the system until our GDB client is connected to it:</p>
<pre class="console">
$ qemu-system-arm -M lm3s6965evb --kernel image.bin -nographic -S -gdb tcp::3333</pre>
<p>In the same way, as with the real target, we can connect <code>arm-none-eabi-gdb</code> to TCP port <code>3333</code> on <code>localhost</code> and start debugging the software image exactly as it was running on the actual platform.</p>
<p>The limit of the emulation approach is that QEMU can only be used to debug generic features that do not involve interaction with actual modern hardware. Nevertheless, running QEMU with a Cortex-M3 target can be a quick way to learn about generic Cortex-M features, such as memory management, system interrupt handling, and processor modes, because many features of the Cortex-M CPU are accurately emulated.</p>
<p>More accurate emulation of microcontroller systems can be achieved <a id="_idIndexMarker175"/>using <strong class="bold">Renode</strong> (<a href="https://renode.io">https://renode.io</a>). Renode <a id="_idIndexMarker176"/>is an open source, configurable emulator for many different microcontrollers and CPU-based embedded systems. The emulation includes peripherals, sensors, LEDs, and even wireless and wired interfaces to interconnect multiple emulated systems and the host network.</p>
<p>Renode is a desktop application with a command-line console. A single configuration file must be provided from the command-line invocation, with several platforms and development board configurations provided under the <code>/scripts</code> directory. This means that once installed, the emulator for the <em class="italic">STM32F4 discovery board</em> can be started by invoking the following command:</p>
<pre class="console">
$ renode /opt/renode/scripts/single-node/stm32f4_discovery.resc</pre>
<p>This <a id="_idIndexMarker177"/>command will load the demo firmware on an emulated STM32F4 target flash memory and redirect the I/O of one of the emulated UART serial ports to a console in a new window. To start the demo, type <code>start</code> in the Renode console.</p>
<p>The example script comes with a demo firmware image running <em class="italic">Contiki OS</em>. The firmware image is loaded by the script via the Renode command:</p>
<pre class="console">
sysbus LoadELF $bin</pre>
<p>Where <code>$bin</code> is a variable pointing to the path (or the URL) of the firmware ELF file to load on the emulated flash memory. This option, as well as the UART analyzer port and other specific commands to execute when the emulator is started, can be easily changed by customizing the script file.</p>
<p>Renode integrates a GDB server that can be spawned from the Renode console or the startup script before starting the emulation, for example, using the following:</p>
<pre class="console">
machine StartGdbServer 3333</pre>
<p>In this case, <code>3333</code> is the TCP port the GDB server will be listening to, as in the other cases with QEMU and a debugger on the physical target.</p>
<p>Unlike QEMU, which is a very generic emulator, Renode is a project created with the purpose of assisting embedded developers throughout the entire life cycle. The possibility to emulate different complete platforms, creating mocks for sensors on several architectures, including RISC-V, makes it a unique tool to automate testing on multiple targets quickly or test on systems even when the actual hardware is not available.</p>
<p>Last but not least, thanks to its own scripting language, Renode<a id="_idIndexMarker178"/> is perfectly integrated with test automation systems, where the execution of the emulated target can be started, stopped, and resumed, and the configuration of all devices and peripherals altered while the test is running.</p>
<p>The approaches<a id="_idIndexMarker179"/> proposed for the definition of test strategies take into account different scenarios. The idea has been to introduce a range of possible solutions for software validation, from lab equipment to tests off-target in simulated and emulated environments, for the developer to choose from in a specific scenario.</p>
<h1 id="_idParaDest-62"><a id="_idTextAnchor077"/>Summary</h1>
<p>This chapter introduced the tools for working on the development of embedded systems. A hands-on approach has been proposed to get you up and running with the toolchain and the utilities required to communicate with the hardware platform. Using appropriate tools can make embedded development easier and shorten workflow iterations.</p>
<p>In the next chapter, we provide indications for workflow organization when working with larger teams. Based on real-life experiences, we propose solutions for splitting and organizing tasks, executing tests, iterating throughout the phases of design, and the definition and implementation of an embedded project.</p>
</div>


<div><h1 id="_idParaDest-63"><a id="_idTextAnchor078"/>Part 2 – Core System Architecture</h1>
<p>This part goes a little deeper into the rabbit hole, by introducing you to pragmatic software design at first and then guiding you step by step through the code needed for proper boot-up mechanisms and memory management, with a strong focus on a memory-safe approach.</p>
<p>This part has the following chapters:</p>
<ul>
<li><a href="B18730_03.xhtml#_idTextAnchor079"><em class="italic">Chapter 3</em></a>, <em class="italic">Architectural Patterns</em></li>
<li><a href="B18730_04.xhtml#_idTextAnchor115"><em class="italic">Chapter 4</em></a>, <em class="italic">The Boot-Up Procedure</em></li>
<li><a href="B18730_05.xhtml#_idTextAnchor149"><em class="italic">Chapter 5</em></a>, <em class="italic">Memory Management</em></li>
</ul>
</div>
<div><div></div>
</div>
</body></html>