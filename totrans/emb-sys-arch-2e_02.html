<html><head></head><body>
<div id="_idContainer018">
<h1 class="chapter-number" id="_idParaDest-41"><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-42"><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.2.1">Work Environment and Workflow Optimization</span></h1>
<p><span class="koboSpan" id="kobo.3.1">The first step toward a successful software project is choosing the right tools. </span><span class="koboSpan" id="kobo.3.2">Embedded development requires a set of hardware and software instruments that make the developerâ€™s life easier and may significantly improve productivity and cut down the total development time. </span><span class="koboSpan" id="kobo.3.3">This chapter provides a description of these tools and gives advice on how to use them to improve </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">the workflow.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">The first section gives us an overview of the workflow in native C programming, and gradually reveals the changes necessary to translate the model to an embedded development environment. </span><span class="koboSpan" id="kobo.5.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">GCC toolchain</span></strong><span class="koboSpan" id="kobo.7.1">, a set of </span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.8.1">development tools to build the embedded application, is introduced through the analysis of </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">its components.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">Finally, in the last two sections, strategies of interaction with the target are proposed, to provide mechanisms for the debugging and validation of the embedded software running on </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">the platform.</span></span></p>
<p><span class="koboSpan" id="kobo.12.1">The topics covered in this chapter are </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">the following:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.14.1">Workflow overview</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Text editors versus </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">integrated environments</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">The </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">GCC toolchain</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Interaction with </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">the target</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.21.1">Validation</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.22.1">By the end of this chapter, you will have learned how to create an optimized workflow by following a few basic rules, keeping the focus on test preparation, and a smart approach </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">to debugging.</span></span></p>
<h1 id="_idParaDest-43"><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.24.1">Workflow overview</span></h1>
<p><span class="koboSpan" id="kobo.25.1">Writing </span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.26.1">software in C, as well as in every other compiled language, requires the code to be transformed into an executable format for a specific target to run it. </span><span class="koboSpan" id="kobo.26.2">C is portable across different architectures and execution environments. </span><span class="koboSpan" id="kobo.26.3">Programmers rely on a set of tools to compile, link, execute, and debug software to a </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">specific target.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">Building the firmware image of an embedded system relies on a similar set of tools, which can produce firmware images for specific targets, called a </span><strong class="bold"><span class="koboSpan" id="kobo.29.1">toolchain</span></strong><span class="koboSpan" id="kobo.30.1">. </span><span class="koboSpan" id="kobo.30.2">This</span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.31.1"> section gives an overview of the common sets of tools required to write software in C and produce programs that are directly executable on the machine that compiled them. </span><span class="koboSpan" id="kobo.31.2">The workflow must then be extended and adapted to integrate the toolchain components and produce executable code for the </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">target platform.</span></span></p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.33.1">The C compiler</span></h2>
<p><span class="koboSpan" id="kobo.34.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.35.1">C compiler</span></strong><span class="koboSpan" id="kobo.36.1"> is a </span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.37.1">tool </span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.38.1">responsible for translating source code into machine code, which can be interpreted by a specific CPU. </span><span class="koboSpan" id="kobo.38.2">Each compiler can produce machine code for one environment only, as it translates the functions into machine-specific instructions, and it is configured to use the address model and the register layout of one specific architecture. </span><span class="koboSpan" id="kobo.38.3">The native compiler included in most GNU/Linux distributions is</span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.39.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.40.1">GNU Compiler Collection</span></strong><span class="koboSpan" id="kobo.41.1">, commonly known as </span><strong class="bold"><span class="koboSpan" id="kobo.42.1">GCC</span></strong><span class="koboSpan" id="kobo.43.1">. </span><span class="koboSpan" id="kobo.43.2">The GCC is a free software compiler system distributed under the GNU general public license since 1987, and since then, it has been successfully used to build UNIX-like systems. </span><span class="koboSpan" id="kobo.43.3">The GCC included in the system can compile C code into applications and libraries capable of running on the same architecture as that of the machine running </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">the compiler.</span></span></p>
<p><span class="koboSpan" id="kobo.45.1">The GCC compiler takes source code files as input, with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">.c</span></strong><span class="koboSpan" id="kobo.47.1"> extension, and produces object files, with </span><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">.o</span></strong><span class="koboSpan" id="kobo.49.1"> extensions, containing the functions and the initial values of the variables, translated from the input source code into machine instructions. </span><span class="koboSpan" id="kobo.49.2">The compiler can be configured to perform additional optimization steps at the end of the compilation that are specific to the target platform and insert debug data to facilitate debugging at a </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">later stage.</span></span></p>
<p><span class="koboSpan" id="kobo.51.1">A minimalist command line used to compile a source file into an object using the host compiler only requires the </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">-c</span></strong><span class="koboSpan" id="kobo.53.1"> option, instructing the GCC program to compile the sources into an object of the </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">same name:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.55.1">
$ gcc -c hello.c</span></pre>
<p><span class="koboSpan" id="kobo.56.1">This statement will try to </span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.57.1">compile the C source contained in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">hello.c</span></strong><span class="koboSpan" id="kobo.59.1"> file and transform it into machine-specific code that is stored in the newly created </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">hello.o</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.61.1"> file.</span></span></p>
<p><span class="koboSpan" id="kobo.62.1">Compiling </span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.63.1">code for a specific target platform requires a set of tools designed for that purpose. </span><span class="koboSpan" id="kobo.63.2">Architecture-specific compilers exist, which provide compilers creating machine instructions for a specific target, different from the building machine. </span><span class="koboSpan" id="kobo.63.3">The process of generating code for a different target is</span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.64.1"> called </span><strong class="bold"><span class="koboSpan" id="kobo.65.1">cross compilation</span></strong><span class="koboSpan" id="kobo.66.1">. </span><span class="koboSpan" id="kobo.66.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.67.1">cross compiler</span></strong><span class="koboSpan" id="kobo.68.1"> runs </span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.69.1">on a development machine, the host, to produce machine-specific code that can execute on </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">the target.</span></span></p>
<p><span class="koboSpan" id="kobo.71.1">In the next section, a GCC-based toolchain is introduced as the tool to create the firmware for an embedded target. </span><span class="koboSpan" id="kobo.71.2">The syntax and the characteristics of the GCC compiler are </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">described there.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">The first step for building a program made of separate modules is to compile all the sources into object files so that the components needed by the system are grouped and organized together in the final step, consisting of linking together all the required symbols and arranging the memory areas to prepare the final executable, which is done by another dedicated component in </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">the toolchain.</span></span></p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.75.1">Linker</span></h2>
<p><span class="koboSpan" id="kobo.76.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.77.1">linker</span></strong><span class="koboSpan" id="kobo.78.1"> is </span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.79.1">the tool </span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.80.1">that composes executable programs and resolves the dependencies among object files provided </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">as input.</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">The default executable format that is produced by the linker is the </span><strong class="bold"><span class="koboSpan" id="kobo.83.1">Executable and Linkable Format</span></strong><span class="koboSpan" id="kobo.84.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.85.1">ELF</span></strong><span class="koboSpan" id="kobo.86.1">). </span><span class="koboSpan" id="kobo.86.2">The </span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.87.1">ELF is the default standard format for programs, objects, shared libraries, and even GDB core dumps on many Unix and Unix-like systems. </span><span class="koboSpan" id="kobo.87.2">The format has been designed to store programs on disks and other media supports, so the host operating system can execute it by loading the instructions in RAM and allocating the space for the </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">program data.</span></span></p>
<p><span class="koboSpan" id="kobo.89.1">Executable files are divided into sections, which can be mapped to specific areas in memory needed by the program to execute. </span><span class="koboSpan" id="kobo.89.2">The ELF file starts with a header containing the pointer to the various sections within the file itself, which contains the programâ€™s code </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">and data.</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">The linker</span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.92.1"> maps</span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.93.1"> the content of the areas describing an executable program into sections conventionally starting with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">.</span></strong><span class="koboSpan" id="kobo.95.1"> (dot). </span><span class="koboSpan" id="kobo.95.2">The minimum set of sections required to run the executable consists of </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">the following:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">.text</span></strong><span class="koboSpan" id="kobo.98.1">: Contains the code of the program, accessed in read-only mode. </span><span class="koboSpan" id="kobo.98.2">It contains the executable instructions of the program. </span><span class="koboSpan" id="kobo.98.3">The functions compiled into object files are arranged by the linker in this section, and the program always executes instructions within this </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">memory area.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">.rodata</span></strong><span class="koboSpan" id="kobo.101.1">: Contains the value of constants that cannot be altered at runtime. </span><span class="koboSpan" id="kobo.101.2">It is used by the compiler as the default section to store constants because it is not allowed to modify the stored values </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">at runtime.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">.data</span></strong><span class="koboSpan" id="kobo.104.1">: Contains the values of all the initialized variables of the program that are accessible in the read/write mode at runtime. </span><span class="koboSpan" id="kobo.104.2">It is the section that contains all the variables (static or global) that have been initialized in the code. </span><span class="koboSpan" id="kobo.104.3">Before executing, this area is generally remapped to a writable location in RAM, and the content of the ELF is automatically copied during the initialization of the program, at runtime, before executing the </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">main function.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">.bss</span></strong><span class="koboSpan" id="kobo.107.1">: This is a section reserved for uninitialized data, accessible in the read/write mode at runtime. </span><span class="koboSpan" id="kobo.107.2">It derives its name from an ancient assembly instruction of old microcode written for the IBM 704 in the 1950s. </span><span class="koboSpan" id="kobo.107.3">It was originally an acronym </span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.108.1">for </span><strong class="bold"><span class="koboSpan" id="kobo.109.1">Block Started by Symbol</span></strong><span class="koboSpan" id="kobo.110.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.111.1">BSS</span></strong><span class="koboSpan" id="kobo.112.1">), used to reserve a fixed amount of uninitialized memory. </span><span class="koboSpan" id="kobo.112.2">In the ELF context, it contains all the uninitialized global and static symbols, which must be accessible in the read-write mode at runtime. </span><span class="koboSpan" id="kobo.112.3">Because there is no value assigned, the ELF file only describes the section in the header but does not provide any content for it. </span><span class="koboSpan" id="kobo.112.4">The initialization code should ensure that all the variables in this section are set to </span><em class="italic"><span class="koboSpan" id="kobo.113.1">zero</span></em><span class="koboSpan" id="kobo.114.1"> before the execution of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">main()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.116.1"> function.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.117.1">When building</span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.118.1"> native software on the host machine, much of the complexity of the linking step is hidden, but the linker is configured by default to arrange the compiled symbols into specific sections, which can be later used by the operating system to assign the corresponding </span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.119.1">segments in the process virtual address space when executing the program. </span><span class="koboSpan" id="kobo.119.2">It is possible to create a working executable for the host machine by simply invoking </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">gcc</span></strong><span class="koboSpan" id="kobo.121.1">, this time without the </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">-c</span></strong><span class="koboSpan" id="kobo.123.1"> option, providing the list of the object files that must be linked together to produce the ELF file. </span><span class="koboSpan" id="kobo.123.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">-o</span></strong><span class="koboSpan" id="kobo.125.1"> option is used to specify the output filename, which otherwise would default </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">a.out</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.129.1">
$ gcc -o helloworld hello.o world.o</span></pre>
<p><span class="koboSpan" id="kobo.130.1">This command will try to build the </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">helloworld</span></strong><span class="koboSpan" id="kobo.132.1"> file, which is an ELF executable for the host system, using the symbols previously compiled into the </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">two objects.</span></span></p>
<p><span class="koboSpan" id="kobo.134.1">In an embedded system things change a bit, as booting a bare-metal application implies that the sections must be mapped to physical areas in memory at linking time. </span><span class="koboSpan" id="kobo.134.2">To instruct the linker to associate the sections to well-known physical addresses, a custom linker script file must be provided, describing the memory layout of the executable bare-metal application, and providing additional custom sections that may be required by the </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">target system.</span></span></p>
<p><span class="koboSpan" id="kobo.136.1">A more detailed explanation of the linking step is provided later, in the </span><em class="italic"><span class="koboSpan" id="kobo.137.1">Linking the </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.138.1">executable</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.139.1"> section.</span></span></p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.140.1">Make: a build automation tool</span></h2>
<p><span class="koboSpan" id="kobo.141.1">Several open</span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.142.1"> source tools are available to automate a build process, and a few of them are widely used in different development environments. </span><strong class="bold"><span class="koboSpan" id="kobo.143.1">Make</span></strong><span class="koboSpan" id="kobo.144.1"> is</span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.145.1"> the standard UNIX tool to automate the steps required to create the required binary images from the sources, check the dependencies for each component, and execute the steps in the right order. </span><span class="koboSpan" id="kobo.145.2">Make is a</span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.146.1"> standard </span><strong class="bold"><span class="koboSpan" id="kobo.147.1">POSIX tool</span></strong><span class="koboSpan" id="kobo.148.1">, and it is part of many UNIX-like systems. </span><span class="koboSpan" id="kobo.148.2">In a GNU/Linux distribution, it is implemented as a standalone tool, which is part of the GNU project. </span><span class="koboSpan" id="kobo.148.3">From this point on, the GNU Make implementation is simply referred to </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">as Make.</span></span></p>
<p><span class="koboSpan" id="kobo.150.1">Make is designed to execute the default build by simply invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">make</span></strong><span class="koboSpan" id="kobo.152.1"> command with no arguments from the command line, provided</span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.153.1"> that a </span><strong class="bold"><span class="koboSpan" id="kobo.154.1">makefile</span></strong><span class="koboSpan" id="kobo.155.1"> is present in the working directory. </span><span class="koboSpan" id="kobo.155.2">A makefile is a special instruction file, containing rules and recipes to build all the files needed until the expected output files are generated. </span><span class="koboSpan" id="kobo.155.3">Open source alternatives offering similar solutions for build automation exist, such as CMake and SCons, but all the examples in this book are built using Make because it provides a simple and essential enough environment to control the build system, and it is the one standardized </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">by </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.157.1">POSIX</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.159.1">Some</span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.160.1"> integrated development environments use built-in mechanisms to coordinate the building steps or generate makefiles before invoking Make automatically when the user requests to build the output files. </span><span class="koboSpan" id="kobo.160.2">However, editing makefiles manually gives complete control over the intermediate steps to generate the final images, where the user can customize the recipes and rules used to generate the desired </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">output files.</span></span></p>
<p><span class="koboSpan" id="kobo.162.1">There is no specific version that needs to be installed to cross compile code for the Cortex-M target, but some extra parameters, such as the location of the toolchain binaries, or the specific flags needed by the compiler, need to be taken care of when writing targets and directives within </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">the makefile.</span></span></p>
<p><span class="koboSpan" id="kobo.164.1">One of the advantages of using a build process is that targets may have implicit dependencies from other intermediate components that are automatically resolved at compile time. </span><span class="koboSpan" id="kobo.164.2">If all the dependencies are correctly configured, a makefile ensures that the intermediate steps are executed only when needed, reducing the compile time of the whole project when only a few sources are altered or when single object files have </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">been deleted.</span></span></p>
<p><span class="koboSpan" id="kobo.166.1">Makefiles have a specific syntax to describe rules. </span><span class="koboSpan" id="kobo.166.2">Each rule begins with the target files expected as the output of the rule, a colon, and the list of prerequisites, which are the files necessary to execute the rule. </span><span class="koboSpan" id="kobo.166.3">A set of recipe items follow, each one describing the actions that Make will execute to create the </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">desired target:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.168.1">
target: [prerequisites]
 recipe
 recipe
 ...</span></pre>
<p><span class="koboSpan" id="kobo.169.1">By default, Make will execute the first rule encountered while parsing the file if no rule name is specified from the command line. </span><span class="koboSpan" id="kobo.169.2">If any of the prerequisites are not available, Make automatically looks for a rule in the same makefile that can create the required file recursively until the chain of requirements </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">is satisfied.</span></span></p>
<p><span class="koboSpan" id="kobo.171.1">Makefiles</span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.172.1"> can assign a custom string of text to internal variables while executing. </span><span class="koboSpan" id="kobo.172.2">Variable names can be assigned using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">=</span></strong><span class="koboSpan" id="kobo.174.1"> operator and referred to by prefixing them with </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">$</span></strong><span class="koboSpan" id="kobo.176.1">. </span><span class="koboSpan" id="kobo.176.2">For example, the following assignment is used to put the name of two object files into the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">OBJS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.178.1"> variable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.179.1">
OBJS = hello.o world.o</span></pre>
<p><span class="koboSpan" id="kobo.180.1">A few </span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.181.1">important variables that are assigned automatically within the rules are </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">the following:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer010">
<span class="koboSpan" id="kobo.183.1"><img alt="Table 2.1 â€“ Some automatic variables that can be used in makefile recipes " src="image/011.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.184.1">Table 2.1 â€“ Some automatic variables that can be used in makefile recipes</span></p>
<p><span class="koboSpan" id="kobo.185.1">These variables are handy to use within the recipe action lines. </span><span class="koboSpan" id="kobo.185.2">For example, the recipe to generate a </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">helloworld</span></strong><span class="koboSpan" id="kobo.187.1"> ELF file from the two object files can be written </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.189.1">
helloworld: $(OBJS)
 gcc -o $(@) $(^)</span></pre>
<p><span class="koboSpan" id="kobo.190.1">Some of the rules are implicitly defined by Make. </span><span class="koboSpan" id="kobo.190.2">For example, the rule to create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">hello.o</span></strong><span class="koboSpan" id="kobo.192.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">world.o</span></strong><span class="koboSpan" id="kobo.194.1"> files from their respective source files can be omitted, as Make expects to be able to obtain each one of these object files in the most obvious way, which is by compiling the corresponding C source files with the same name if present. </span><span class="koboSpan" id="kobo.194.2">This means that this minimalist makefile is already able to compile the two objects from the sources and link them together using the default set of options for the </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">host system.</span></span></p>
<p><span class="koboSpan" id="kobo.196.1">The linking recipe can also be implicit if the executable has the same name as one of its prerequisite objects minus its </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">.o</span></strong><span class="koboSpan" id="kobo.198.1"> extension. </span><span class="koboSpan" id="kobo.198.2">If the final ELF file is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">hello</span></strong><span class="koboSpan" id="kobo.200.1">, our makefile could simply become the </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">following one-liner:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.202.1">
hello: world.o</span></pre>
<p><span class="koboSpan" id="kobo.203.1">This would </span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.204.1">automatically resolve the </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">hello.o</span></strong><span class="koboSpan" id="kobo.206.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">world.o</span></strong><span class="koboSpan" id="kobo.208.1"> dependencies, and then link them together using an implicit linker recipe similar to the one we used in the </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">explicit target.</span></span></p>
<p><span class="koboSpan" id="kobo.210.1">Implicit rules use </span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.211.1">predefined variables, which are assigned automatically before the rules are executed, but can be modified within the makefile. </span><span class="koboSpan" id="kobo.211.2">For example, it is possible to change the default compiler by altering the </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">CC</span></strong><span class="koboSpan" id="kobo.213.1"> variable. </span><span class="koboSpan" id="kobo.213.2">Here is a short list of the most important variables that may be used to alter implicit rules </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">and recipes:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer011">
<span class="koboSpan" id="kobo.215.1"><img alt="Table 2.2 â€“ Implicit, predefined variables that specify the default toolchain and flags " src="image/02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.216.1">Table 2.2 â€“ Implicit, predefined variables that specify the default toolchain and flags</span></p>
<p><span class="koboSpan" id="kobo.217.1">When linking a bare-metal application for embedded platforms, the makefile must be modified accordingly, and as shown later in this chapter, several flags are required to properly cross compile the sources and instruct the linker to use the desired memory layout to organize the memory sections. </span><span class="koboSpan" id="kobo.217.2">Moreover, additional steps are generally needed to manipulate the ELF file and translate it to a format that can be transferred to the target system. </span><span class="koboSpan" id="kobo.217.3">However, the syntax of the makefile is the same, and the simple rules shown here are not too different from those used to build the example. </span><span class="koboSpan" id="kobo.217.4">The default variables still need to be adjusted to modify the default behavior if implicit rules </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">are used.</span></span></p>
<p><span class="koboSpan" id="kobo.219.1">When all the </span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.220.1">dependencies are correctly configured in the makefile, Make ensures that the rules are only executed when the target is older than its dependencies, thus reducing the compile time of the whole project when only a few sources are altered or when single object files have </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">been deleted.</span></span></p>
<p><span class="koboSpan" id="kobo.222.1">Make is a</span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.223.1"> very powerful tool, and its range of possibilities goes far beyond the few features used to generate the examples in this book. </span><span class="koboSpan" id="kobo.223.2">Mastering the automation process of builds may lead to optimized build processes. </span><span class="koboSpan" id="kobo.223.3">The syntax of makefiles includes useful features, such as conditionals, which can be used to produce different results by invoking a makefile using different targets or environment variables. </span><span class="koboSpan" id="kobo.223.4">For a better understanding of the </span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.224.1">capabilities of Make, please refer to the GNU Make manual available </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">at </span></span><a href="https://www.gnu.org/software/make/manual"><span class="No-Break"><span class="koboSpan" id="kobo.226.1">https://www.gnu.org/software/make/manual</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.227.1">.</span></span></p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.228.1">Debugger</span></h2>
<p><span class="koboSpan" id="kobo.229.1">In the</span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.230.1"> host environment, debugging an application that runs on top of the operating system is done by</span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.231.1"> running a debugger tool, which can attach to an existing process or spawn a new one given an executable ELF file and its command-line arguments. </span><span class="koboSpan" id="kobo.231.2">The default debugging option provided by the GCC suite is called </span><strong class="bold"><span class="koboSpan" id="kobo.232.1">GDB</span></strong><span class="koboSpan" id="kobo.233.1">, an acronym for </span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.234.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.235.1">GNU Debugger</span></strong><span class="koboSpan" id="kobo.236.1">. </span><span class="koboSpan" id="kobo.236.2">While GDB is a command-line tool, several frontends have been developed to provide better visualization of the state of the execution, and some integrated development environments provide built-in frontends for interacting with the debugger while tracing the single lines </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">being executed.</span></span></p>
<p><span class="koboSpan" id="kobo.238.1">Once again, the situation is slightly changed when the software to debug is running on a remote platform. </span><span class="koboSpan" id="kobo.238.2">A version of GDB, distributed with the toolchain and specific to the target platform, can be run on the development machine to connect to a remote debug session. </span><span class="koboSpan" id="kobo.238.3">A debug session on a remote target requires an intermediate tool that is configured to translate GDB commands into actual actions on the core CPU and the related hardware infrastructure to establish communication with </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">the core.</span></span></p>
<p><span class="koboSpan" id="kobo.240.1">Some embedded platforms provide hardware breakpoints, which are used to trigger system exceptions every time the selected instructions </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">are executed.</span></span></p>
<p><span class="koboSpan" id="kobo.242.1">Later in this chapter, we will</span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.243.1"> see how a remote GDB session can be established with the target in order to interrupt its execution at the current point, proceed to step through the code, place breakpoints and watchpoints, and inspect and modify the values </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">in memory.</span></span></p>
<p><span class="koboSpan" id="kobo.245.1">A handful of </span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.246.1">GDB commands are introduced, giving a quick reference to some of the functionalities provided by the GDB command-line interface, which can be effectively used to debug </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">embedded applications.</span></span></p>
<p><span class="koboSpan" id="kobo.248.1">The</span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.249.1"> debugger gives the best possible understanding of what the software is doing at runtime and facilitates the hunt for programming errors while directly looking at the effects of the execution on memory and </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">CPU registers.</span></span></p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.251.1">Embedded workflow</span></h2>
<p><span class="koboSpan" id="kobo.252.1">If </span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.253.1">compared to other domains, the embedded development life cycle includes some additional steps. </span><span class="koboSpan" id="kobo.253.2">The code must be cross compiled, the image manipulated then uploaded to a target, tests must be run, and possibly hardware tools are involved in the measurement and verification phases. </span><span class="koboSpan" id="kobo.253.3">The life cycle of native application software, when using compiled languages, looks like </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">this diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer012">
<span class="koboSpan" id="kobo.255.1"><img alt="Figure 2.1 â€“ A typical life cycle of application development" src="image/B18730_02_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.256.1">Figure 2.1 â€“ A typical life cycle of application development</span></p>
<p><span class="koboSpan" id="kobo.257.1">When writing software within the same architecture, tests and debugging can be performed right after compiling, and it is often easier to detect issues. </span><span class="koboSpan" id="kobo.257.2">This results in a shorter time for the typical loop. </span><span class="koboSpan" id="kobo.257.3">Moreover, if the application crashes because of a bug, the underlying operating system can produce a core dump, which can be analyzed using the debugger at a later time by restoring the content of the virtual memory and the context of the CPU registers right at the moment when the bug </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">shows up.</span></span></p>
<p><span class="koboSpan" id="kobo.259.1">On </span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.260.1">the other hand, intercepting fatal errors on an embedded target might be slightly more challenging because of the potential side effect of memory and register corruption in the absence of virtual addresses and memory segmentation provided by the operating systems in other contexts. </span><span class="koboSpan" id="kobo.260.2">Even if some targets can intercept abnormal situations by triggering diagnostic interrupts, such as the hard fault handler in Cortex-M, restoring the original context that generated the error is </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">often impossible.</span></span></p>
<p><span class="koboSpan" id="kobo.262.1">Furthermore, every time new software is generated, there are a few time-consuming steps to perform, such as the translation of the image to a specific format, and uploading the image to the target itself, which may take anywhere from a few seconds up to a minute, depending on the size of the image and the speed of the interface used to communicate with </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">the target:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer013">
<span class="koboSpan" id="kobo.264.1"><img alt="Figure 2.2 â€“ The embedded development life cycle, including additional steps required by the environment" src="image/B18730_02_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.265.1">Figure 2.2 â€“ The embedded development life cycle, including additional steps required by the environment</span></p>
<p><span class="koboSpan" id="kobo.266.1">In </span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.267.1">some of the phases of the development, when multiple consecutive iterations may be required to finalize a feature implementation or detect a defect, the timing between compiling and testing the software has an impact on the efficiency of the whole life cycle. </span><span class="koboSpan" id="kobo.267.2">Specific tasks implemented in the software, which involve communication through serial or network interfaces, can only be verified with signal analysis or by observing the effect on the peripheral or the remote system involved. </span><span class="koboSpan" id="kobo.267.3">Analyzing the electrical effects on the embedded system requires some hardware setup and instrument configuration, which add more time to </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">the equation.</span></span></p>
<p><span class="koboSpan" id="kobo.269.1">Finally, developing a distributed embedded system composed of several devices running different software images may result in repeating the preceding iterations for each of these devices. </span><span class="koboSpan" id="kobo.269.2">Whenever possible, these steps should be eliminated by using the same image and different set configuration parameters on each device and by implementing parallel firmware upgrade mechanisms. </span><span class="koboSpan" id="kobo.269.3">Protocols such as JTAG support uploading the software image to multiple targets sharing the same bus, significantly cutting down the time required for the firmware upgrades, especially in those distributed systems with a larger number of </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">devices involved.</span></span></p>
<p><span class="koboSpan" id="kobo.271.1">No</span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.272.1"> matter how complex the project is expected to be, it is, in general, worth spending as much time as needed to optimize the life cycle of the software development at the beginning in order to increase efficiency later on. </span><span class="koboSpan" id="kobo.272.2">No developer likes to switch the focus away from the actual coding steps for too long, and it might be frustrating to work in a suboptimal environment where stepping through the process requires too much time or </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">human interaction.</span></span></p>
<p><span class="koboSpan" id="kobo.274.1">An embedded project can be started from scratch using a text editor or by creating a new project in an integrated </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">development environment.</span></span></p>
<h1 id="_idParaDest-49"><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.276.1">Text editors versus integrated environments</span></h1>
<p><span class="koboSpan" id="kobo.277.1">While mostly a </span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.278.1">matter of developer preferences, the debate is still open in the embedded community between those who use a standalone </span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.279.1">text editor and those who prefer to have all the components of the toolchain integrated into </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">one GUI.</span></span></p>
<p><span class="koboSpan" id="kobo.281.1">Modern IDEs incorporate tools for the </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">following tasks:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.283.1">Managing the components of </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">the project</span></span></li>
<li><span class="koboSpan" id="kobo.285.1">Quickly accessing all the files for editing as well as extensions to upload the software on </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">the board</span></span></li>
<li><span class="koboSpan" id="kobo.287.1">Starting a debugging session with a </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">single click</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.289.1">Microcontroller manufacturers often distribute their development kits along with IDEs that make it easy to access advanced features that are specific to the microcontroller, thanks to preconfigured setups and wizards facilitating the creation of new projects. </span><span class="koboSpan" id="kobo.289.2">Most IDEs include widgets to automatically generate the setup code for pin multiplexing for specific microcontrollers, starting from a graphical interface. </span><span class="koboSpan" id="kobo.289.3">Some of them even offer simulators and tools to predict runtime resource usage, such as dynamic memory and </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">power consumption.</span></span></p>
<p><span class="koboSpan" id="kobo.291.1">The </span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.292.1">majority of these tools are based on </span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.293.1">some customization of Eclipse, a popular open source desktop IDE, originally designed as a tool for Java software development, then later on very successful in many other fields thanks to the possibilities to extend and customize </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">its interface.</span></span></p>
<p><span class="koboSpan" id="kobo.295.1">There are downsides to the IDE approach too. </span><span class="koboSpan" id="kobo.295.2">IDEs, in general, do not embed the actual toolchain in the code. </span><span class="koboSpan" id="kobo.295.3">Rather, they provide a frontend interface to interact with a compiler, linker, debugger, and other tools. </span><span class="koboSpan" id="kobo.295.4">To do so, they have to store all the flags, configuration options, the paths of included files, and compile-time-defined symbols in a machine-readable configuration file. </span><span class="koboSpan" id="kobo.295.5">Some users find those options difficult to access by navigating through the multiple menus of the GUI. </span><span class="koboSpan" id="kobo.295.6">Other key components of the project, such as the linker script, may also be well hidden under the hood, in some cases even automatically generated by the IDE and difficult to read. </span><span class="koboSpan" id="kobo.295.7">For most IDE users, however, these downsides are compensated by the perks of developing with an </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">integrated environment.</span></span></p>
<p><span class="koboSpan" id="kobo.297.1">There is one last caveat that has to be considered, though. </span><span class="koboSpan" id="kobo.297.2">The project will sooner or later be built and tested automatically, as previously analyzed in the </span><em class="italic"><span class="koboSpan" id="kobo.298.1">Make: a build automation tool</span></em><span class="koboSpan" id="kobo.299.1"> section. </span><span class="koboSpan" id="kobo.299.2">Robots are, in general, terrible users of IDEs, while they can build and run any test, even interacting with real targets, using a command-line interface. </span><span class="koboSpan" id="kobo.299.3">A development team using an IDE for embedded development should always consider providing an option to build and test any software through a command-line </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">alternate strategy.</span></span></p>
<p><span class="koboSpan" id="kobo.301.1">While some complexity of the toolchain can be abstracted with a GUI, it is useful to understand the functions of the set of applications under the hood. </span><span class="koboSpan" id="kobo.301.2">The remaining sections of this chapter explore the GCC toolchain, the most popular cross-architecture set of compilers for many </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">32-bit microcontrollers.</span></span></p>
<h1 id="_idParaDest-50"><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.303.1">The GCC toolchain</span></h1>
<p><span class="koboSpan" id="kobo.304.1">While in the</span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.305.1"> case of the IDE, its complexity is abstracted through the user interface, a toolchain is a set of standalone software applications, each one serving a </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">specific purpose.</span></span></p>
<p><span class="koboSpan" id="kobo.307.1">GCC is one of the reference toolchains to build embedded systems due to its modular structure allowing backends for multiple architectures. </span><span class="koboSpan" id="kobo.307.2">Thanks to its open source model, and the flexibility in building tailored toolchains from it, GCC-based toolchains are among the most popular development tools in </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">embedded systems.</span></span></p>
<p><span class="koboSpan" id="kobo.309.1">Building software using a command-line-based toolchain has several advantages, including the possibility of automating the intermediate steps that would build all the modules up from the source code into the final image. </span><span class="koboSpan" id="kobo.309.2">This is particularly useful when it is required to program multiple devices in a row or to automate builds on a continuous </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">integration server.</span></span></p>
<p><span class="koboSpan" id="kobo.311.1">ARM distributes the GNU Arm Embedded Toolchain for all the most popular development hosts. </span><span class="koboSpan" id="kobo.311.2">Toolchains are prefixed with a triplet describing the target. </span><span class="koboSpan" id="kobo.311.3">In the case of the GNU Arm Embedded Toolchain, the prefix is </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">arm-none-eabi</span></strong><span class="koboSpan" id="kobo.313.1">, indicating that the cross compiler backend is configured to produce objects for ARM, with no specific support for an operating system API, and with the </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">embedded ABI.</span></span></p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.315.1">The cross compiler</span></h2>
<p><span class="koboSpan" id="kobo.316.1">The</span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.317.1"> cross compiler</span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.318.1"> distributed with a toolchain is a variant of GCC, with the backend configured to build object files that contain machine code for a specific architecture. </span><span class="koboSpan" id="kobo.318.2">The output of the compilation is one set of object files containing symbols that can only be interpreted by the specific target.</span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1"> Arm-none-eabi-gcc</span></strong><span class="koboSpan" id="kobo.320.1">, the GCC variant provided by ARM to build software for microcontrollers, can compile C code into machine instructions and CPU optimizations for several different targets. </span><span class="koboSpan" id="kobo.320.2">Each architecture needs its own specific toolchain that will produce </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">target-specific executables.</span></span></p>
<p><span class="koboSpan" id="kobo.322.1">The GCC backend for the ARM architecture supports several machine-specific options to select the correct instruction set for the CPU and the machine-specific </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">optimization parameters.</span></span></p>
<p><span class="koboSpan" id="kobo.324.1">The following table lists some of the ARM-specific machine options available on the GCC backend as </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">-</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">m</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.327.1"> flags:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer014">
<span class="koboSpan" id="kobo.328.1"><img alt="Table 2.3 â€“ Architecture-specific compiler options for GCC ARM " src="image/03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.329.1">Table 2.3 â€“ Architecture-specific compiler options for GCC ARM</span></p>
<p><span class="koboSpan" id="kobo.330.1">To </span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.331.1">compile</span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.332.1"> code that is compatible with a generic ARM Cortex M4, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">-mthumb</span></strong><span class="koboSpan" id="kobo.334.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">-mcpu=cortex-m4</span></strong><span class="koboSpan" id="kobo.336.1"> options must be specified every time the compiler </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">is invoked:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.338.1">
$ arm-none-eabi-gcc -c test.c -mthumb -mcpu=cortex-m4</span></pre>
<p><span class="koboSpan" id="kobo.339.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">test.o</span></strong><span class="koboSpan" id="kobo.341.1"> file that is the result of this compile step is very different from the one that can be compiled, from the same source, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">gcc</span></strong><span class="koboSpan" id="kobo.343.1"> host. </span><span class="koboSpan" id="kobo.343.2">The difference can be better appreciated if, instead of the two object files, the intermediate assembly code is compared. </span><span class="koboSpan" id="kobo.343.3">The compiler is, in fact, capable of creating intermediate assembly code files instead of compiled and assembled objects when it is invoked with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">-</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">S</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.346.1"> option.</span></span></p>
<p><span class="koboSpan" id="kobo.347.1">In a similar way to the host GCC compiler, there are different levels of possible optimization available to activate. </span><span class="koboSpan" id="kobo.347.2">In some cases, it makes sense to activate the size optimization to generate smaller object files. </span><span class="koboSpan" id="kobo.347.3">It is preferable, though, that the non-optimized image can fit the flash during the development to facilitate the debugging procedures, as optimized code flow is more difficult to follow when the compiler may change the order of the execution of the code and hide away the content of some variables. </span><span class="koboSpan" id="kobo.347.4">The optimization parameter can be provided at the command line to select the desired </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">optimization level:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer015">
<span class="koboSpan" id="kobo.349.1"><img alt="Table 2.4 â€“ GCC levels of optimization " src="image/04.jpg"/></span>
</div>
</div>
<p class="IMG---Figure"><span class="koboSpan" id="kobo.350.1">Table 2.4 â€“ GCC levels of optimization</span></p>
<p><span class="koboSpan" id="kobo.351.1">Another </span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.352.1">generic GCC command-line option that is often </span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.353.1">used while debugging and prototyping is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">-g</span></strong><span class="koboSpan" id="kobo.355.1"> flag, which instructs the compiler to keep the debugging-related data in the final object in order to facilitate access to functionsâ€™ and variablesâ€™ readable handles while running within </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">the debugger.</span></span></p>
<p><span class="koboSpan" id="kobo.357.1">To inform the compiler that we are running a bare-metal application, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">-ffreestanding</span></strong><span class="koboSpan" id="kobo.359.1"> command-line option is used. </span><span class="koboSpan" id="kobo.359.2">In GCC jargon, a freestanding environment is defined by the possible lack of a standard library in the linking step, and most importantly, this option alerts the compiler that it should not expect to use the main function as the entry point of the program or provide any preamble code before the beginning of the execution. </span><span class="koboSpan" id="kobo.359.3">This option is required when compiling code for the embedded platforms, as it enables the boot mechanism described in </span><a href="B18730_04.xhtml#_idTextAnchor115"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.360.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.361.1">, </span><em class="italic"><span class="koboSpan" id="kobo.362.1">The </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.363.1">Boot-Up Procedure</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.365.1">The</span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.366.1"> GCC program supports many more command-line options than those quickly introduced here. </span><span class="koboSpan" id="kobo.366.2">For a more complete overview of the functionalities offered, please refer to the GNU GCC manual, available </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">at </span></span><a href="https://gcc.gnu.org/onlinedocs/"><span class="No-Break"><span class="koboSpan" id="kobo.368.1">https://gcc.gnu.org/onlinedocs/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.369.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.370.1">To integrate the cross compiling toolchain in the automated build using Make, a few changes are required in </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">the makefile.</span></span></p>
<p><span class="koboSpan" id="kobo.372.1">Assuming</span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.373.1"> that the toolchain is correctly installed on the development host and reachable in its executing path, it is sufficient to change the default compiler command using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">CC</span></strong><span class="koboSpan" id="kobo.375.1"> Make variable in </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">the makefile:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.377.1">
CC=arm-none-eabi-gcc</span></pre>
<p><span class="koboSpan" id="kobo.378.1">The </span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.379.1">custom command-line options required to run the compile options may be exported through the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">CFLAGS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.381.1"> variable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.382.1">
CFLAGS=-mthumb -mcpu=cortex-m4 -ffreestanding</span></pre>
<p><span class="koboSpan" id="kobo.383.1">Using default makefile variables, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">CC</span></strong><span class="koboSpan" id="kobo.385.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">CFLAGS</span></strong><span class="koboSpan" id="kobo.387.1">, enables implicit makefile rules, building object files from </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">C</span></strong><span class="koboSpan" id="kobo.389.1"> sources with the same name, and a custom </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">compiler configuration.</span></span></p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.391.1">Compiling the compiler</span></h2>
<p><span class="koboSpan" id="kobo.392.1">Binary</span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.393.1"> distributions of the GCC toolchain are available to download for several specific targets and host machines. </span><span class="koboSpan" id="kobo.393.2">To compile the code for the ARM Cortex-M microprocessors, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">arm-none-eabi</span></strong><span class="koboSpan" id="kobo.395.1"> toolchain is made available for most GNU/Linux distributions. </span><span class="koboSpan" id="kobo.395.2">However, in some cases, it might be handy to build the toolchain entirely from the sources. </span><span class="koboSpan" id="kobo.395.3">This might be, for example, when the compiler for a certain target does not exist yet or is not shipped in binary format for our favorite development environment. </span><span class="koboSpan" id="kobo.395.4">This process is also useful to better understand the various components that are required to build </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">the tools.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.397.1">Crosstool-NG</span></strong><span class="koboSpan" id="kobo.398.1"> is an</span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.399.1"> open source project that consists of a set of scripts aimed at automating the process of creating a toolchain. </span><span class="koboSpan" id="kobo.399.2">The tool retrieves the selected version of every component, then creates an archive of the toolchain that can be redistributed in binary form. </span><span class="koboSpan" id="kobo.399.3">This is normally not necessary, while sometimes useful when it is necessary to modify the sources for a specific component, such as, for example, the C libraries that are finally integrated into the toolchain. </span><span class="koboSpan" id="kobo.399.4">It is easy to create a new configuration in crosstool-NG, thanks to its configurator, based on the Linux </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">menuconfig</span></strong><span class="koboSpan" id="kobo.401.1"> kernel. </span><span class="koboSpan" id="kobo.401.2">After installing crosstool-NG, the configurator can be invoked by using </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.403.1">
$ ct-ng menuconfig</span></pre>
<p><span class="koboSpan" id="kobo.404.1">Once the configuration has been created, the build process can be started. </span><span class="koboSpan" id="kobo.404.2">Since the operation requires retrieving all the components, patching them, and building the toolchain, it may take several minutes, depending on the speed of the host machine and the internet connection, to retrieve all the components. </span><span class="koboSpan" id="kobo.404.3">The build process can be started by issuing </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.406.1">
$ ct-ng build</span></pre>
<p><span class="koboSpan" id="kobo.407.1">Predefined</span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.408.1"> configurations are available for compiling commonly used toolchains, mostly for targets running Linux. </span><span class="koboSpan" id="kobo.408.2">When compiling a toolchain for a Linux target, there are a few C libraries to choose from. </span><span class="koboSpan" id="kobo.408.3">In our case, since we want a bare-metal toolchain, </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">newlib</span></strong><span class="koboSpan" id="kobo.410.1"> is the default choice. </span><span class="koboSpan" id="kobo.410.2">Several other libraries provide an implementation of a subset of the C standard library, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">uClibc</span></strong><span class="koboSpan" id="kobo.412.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">musl</span></strong><span class="koboSpan" id="kobo.414.1">. </span><span class="koboSpan" id="kobo.414.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">newlib</span></strong><span class="koboSpan" id="kobo.416.1"> library is a small cross-platform C library mostly designed for embedded systems with no operating system on board, and it is provided as the default in many GCC distributions, including the </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">arm-none-eabi</span></strong><span class="koboSpan" id="kobo.418.1"> cross compiler distributed </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">by ARM.</span></span></p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.420.1">Linking the executable</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.421.1">Linking</span></strong><span class="koboSpan" id="kobo.422.1"> is </span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.423.1">the</span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.424.1"> last step in the creation of the ELF file. </span><span class="koboSpan" id="kobo.424.2">The cross compiling GCC groups all the object files together and resolves the dependencies among symbols. </span><span class="koboSpan" id="kobo.424.3">By passing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">-T filename</span></strong><span class="koboSpan" id="kobo.426.1"> option at the command line, the linker is asked to replace the default memory layout for the program with a custom script, contained in </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">the filename.</span></span></p>
<p><span class="koboSpan" id="kobo.428.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.429.1">linker script</span></strong><span class="koboSpan" id="kobo.430.1"> is a</span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.431.1"> file containing the description of the memory sections in the target, which need to be known in advance in order for the linker to place the symbols in the correct sections in flash, and instruct the software components about special locations in the memory mapping area that can be referenced in the code. </span><span class="koboSpan" id="kobo.431.2">The file is recognizable by its </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">.ld</span></strong><span class="koboSpan" id="kobo.433.1"> extension, and it is written in a specific language. </span><span class="koboSpan" id="kobo.433.2">As a rule of thumb, all the symbols from every single compiled object are grouped in the sections of the final </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">executable image.</span></span></p>
<p><span class="koboSpan" id="kobo.435.1">The script can interact with the C code, exporting symbols defined within the script and following indications provided in the code using GCC-specific attributes associated with symbols. </span><span class="koboSpan" id="kobo.435.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">__attribute__</span></strong><span class="koboSpan" id="kobo.437.1"> keyword is provided by GCC to be put in front of the symbol definition to activate GCC-specific, non-standard attributes for </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">each symbol.</span></span></p>
<p><span class="koboSpan" id="kobo.439.1">Some GCC attributes can be used to communicate to the linker about </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.441.1">Weak symbols, which can be overridden by symbols with the </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">same name</span></span></li>
<li><span class="koboSpan" id="kobo.443.1">Symbols to be stored in a specific section in the ELF file, defined in the </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">linker script</span></span></li>
<li><span class="koboSpan" id="kobo.445.1">Implicitly used symbols, which prevent the linker from discarding the symbol because it is referred to nowhere in </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">the code</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.447.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">weak</span></strong><span class="koboSpan" id="kobo.449.1"> attribute</span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.450.1"> is used to define weak symbols, which can be overridden anywhere else in the code by another definition with the same name. </span><span class="koboSpan" id="kobo.450.2">Consider, for example, the </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">following definition:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.452.1">
void __attribute__(weak) my_procedure(int x) {/* do nothing */}</span></pre>
<p><span class="koboSpan" id="kobo.453.1">In this case, the procedure is defined to do nothing, but it is possible to override it anywhere else in the code base by defining it again, using the same name, but this time without the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">weak</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.455.1"> attribute:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.456.1">
void my_procedure(int x) { y = x; }</span></pre>
<p><span class="koboSpan" id="kobo.457.1">The linker step ensures that the final executable contains exactly one copy of each defined symbol, which is the one without the attribute, if available. </span><span class="koboSpan" id="kobo.457.2">This mechanism introduces the possibility of having several different implementations of the same functionality within the code, which can be altered by including different object files in the linking phase. </span><span class="koboSpan" id="kobo.457.3">This is particularly useful when writing code that is portable to different targets while still maintaining the </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">same abstractions.</span></span></p>
<p><span class="koboSpan" id="kobo.459.1">Besides the default sections required in the ELF description, custom sections may be added to store specific symbols, such as functions and variables, at fixed memory addresses. </span><span class="koboSpan" id="kobo.459.2">This is useful when storing data at the beginning of a flash page, which might be uploaded to flash at a different time than the software itself. </span><span class="koboSpan" id="kobo.459.3">This is the case for target-specific settings in </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">some cases.</span></span></p>
<p><span class="koboSpan" id="kobo.461.1">Using the custom GCC </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">section</span></strong><span class="koboSpan" id="kobo.463.1"> attribute when defining a symbol ensures that the symbol ends up at the desired position in the final image. </span><span class="koboSpan" id="kobo.463.2">Sections may have custom names as long as an entry exists in the linker to locate them. </span><span class="koboSpan" id="kobo.463.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">section</span></strong><span class="koboSpan" id="kobo.465.1"> attribute can be added to a symbol definition </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.467.1">
const uint8_t
 __attribute__((section(".keys")))
 private_key[KEY_SIZE] = {0};</span></pre>
<p><span class="koboSpan" id="kobo.468.1">In this example, the array is placed in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">.keys</span></strong><span class="koboSpan" id="kobo.470.1"> section, which requires its own entry in the linker script </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.472.1">It is </span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.473.1">considered good practice to have the linker discard the unused symbols in the final image, especially when using third-party libraries that are not completely utilized by the embedded application. </span><span class="koboSpan" id="kobo.473.2">This can be done in GCC using the linker garbage collector, activated via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">-gc-sections</span></strong><span class="koboSpan" id="kobo.475.1"> command-line option. </span><span class="koboSpan" id="kobo.475.2">If this flag is provided, the sections that are unused in the code are automatically discarded, and the unused symbols will be kept out of the </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">final image.</span></span></p>
<p><span class="koboSpan" id="kobo.477.1">To prevent the linker from discarding symbols associated with a particular section, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">used</span></strong><span class="koboSpan" id="kobo.479.1"> attribute marks the symbol as implicitly used by the program. </span><span class="koboSpan" id="kobo.479.2">Multiple attributes can be listed in the same declaration, separated by commas, </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.481.1">
const uint8_tÂ Â Â Â __attribute__((used,section(".keys")))
Â Â Â private_key[KEY_SIZE] = {0};</span></pre>
<p><span class="koboSpan" id="kobo.482.1">In this example, the attributes indicate both that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">private_key</span></strong><span class="koboSpan" id="kobo.484.1"> array belongs to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">.keys</span></strong><span class="koboSpan" id="kobo.486.1"> section and that it must not be discarded by the linker garbage collector because it is marked </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">as used.</span></span></p>
<p><span class="koboSpan" id="kobo.488.1">A simple linker script for an embedded target defines at least the two sections relative to </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">RAM</span></strong><span class="koboSpan" id="kobo.490.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">FLASH</span></strong><span class="koboSpan" id="kobo.492.1"> mapping and exports some predefined symbols to instruct the assembler of the toolchain about the memory areas. </span><span class="koboSpan" id="kobo.492.2">A bare-metal system based on the GNU toolchain usually starts with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">MEMORY</span></strong><span class="koboSpan" id="kobo.494.1"> section, describing the mapping of the two different areas in the system, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.496.1">
MEMORY {
Â Â FLASH(rx) : ORIGIN = 0x00000000, LENGTH=256k
Â Â RAM(rwx) : ORIGIN = 0x20000000, LENGTH=64k
}</span></pre>
<p><span class="koboSpan" id="kobo.497.1">The preceding code snippet describes two memory areas used in the system. </span><span class="koboSpan" id="kobo.497.2">The first block is 256k mapped to </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">FLASH</span></strong><span class="koboSpan" id="kobo.499.1">, with the </span><em class="italic"><span class="koboSpan" id="kobo.500.1">r and x flags</span></em><span class="koboSpan" id="kobo.501.1"> indicating that the area is accessible for </span><em class="italic"><span class="koboSpan" id="kobo.502.1">read</span></em><span class="koboSpan" id="kobo.503.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.504.1">execute</span></em><span class="koboSpan" id="kobo.505.1"> operations. </span><span class="koboSpan" id="kobo.505.2">This enforces the read-only attribute of the whole area and ensures that no variant sections are placed there. </span><span class="koboSpan" id="kobo.505.3">RAM, on the other hand, can be accessed in write mode directly, which means that variables are going to be placed in a section within that area. </span><span class="koboSpan" id="kobo.505.4">In this specific example, the target maps the FLASH mapping at the beginning of the address space, while the RAM is mapped starting at 512 MB. </span><span class="koboSpan" id="kobo.505.5">Each target has its address space mapping and flash/RAM size, which makes the linker </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">script target-specific.</span></span></p>
<p><span class="koboSpan" id="kobo.507.1">As mentioned earlier in this chapter, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">.text</span></strong><span class="koboSpan" id="kobo.509.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">.rodata</span></strong><span class="koboSpan" id="kobo.511.1"> ELF sections can only be accessed for reading, so they can safely be stored in the FLASH area since they will not be modified while the target is running. </span><span class="koboSpan" id="kobo.511.2">On the other hand, both </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">.data</span></strong><span class="koboSpan" id="kobo.513.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">.bss</span></strong><span class="koboSpan" id="kobo.515.1"> must be mapped in RAM to ensure that they </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">are modifiable.</span></span></p>
<p><span class="koboSpan" id="kobo.517.1">Additional </span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.518.1">custom sections can be added to the script where it is necessary to store additional sections at a specific location in memory. </span><span class="koboSpan" id="kobo.518.2">The linker script can also export symbols related to a specific position in memory or to the length of dynamically sized sections in memory, which can be referred to as external symbols and accessed in the C </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">source code.</span></span></p>
<p><span class="koboSpan" id="kobo.520.1">The second block of statements in the linker script is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">SECTIONS</span></strong><span class="koboSpan" id="kobo.522.1"> and contains the allocation of the sections in specific positions of the defined memory areas. </span><span class="koboSpan" id="kobo.522.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">.</span></strong><span class="koboSpan" id="kobo.524.1"> symbol, when associated with a variable in the script, represents the current position in the area, which is filled progressively from the lower </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">addresses available.</span></span></p>
<p><span class="koboSpan" id="kobo.526.1">Each section must specify the area where it has to be mapped. </span><span class="koboSpan" id="kobo.526.2">The following example, though still incomplete to run the binary executable, shows how the different sections can be deployed using the linker script. </span><span class="koboSpan" id="kobo.526.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">.text</span></strong><span class="koboSpan" id="kobo.528.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">.rodata</span></strong><span class="koboSpan" id="kobo.530.1"> sections are mapped in the </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">flash memory:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.532.1">
SECTIONS
{
Â Â Â Â /* Text section (code and read-only data) */
Â Â Â Â .text :
Â Â Â Â {
Â Â Â Â Â Â Â Â . </span><span class="koboSpan" id="kobo.532.2">= ALIGN(4);
Â Â Â Â Â Â Â Â _start_text = .;
Â Â Â Â Â Â Â Â *(.text*) /* code */
Â Â Â Â Â Â Â Â . </span><span class="koboSpan" id="kobo.532.3">= ALIGN(4);
Â Â Â Â Â Â Â Â _end_text = .;
Â Â Â Â Â Â Â Â *(.rodata*) /* read only data */
Â Â Â Â Â Â Â Â . </span><span class="koboSpan" id="kobo.532.4">= ALIGN(4);
Â Â Â Â Â Â Â Â _end_rodata = .;
} &gt; FLASH</span></pre>
<p><span class="koboSpan" id="kobo.533.1">The modifiable sections are mapped in RAM, with two special cases to </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">notice here.</span></span></p>
<p><span class="koboSpan" id="kobo.535.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">AT</span></strong><span class="koboSpan" id="kobo.537.1"> keyword</span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.538.1"> is used to indicate the load address to the linker, which is the area where the original values of the variables in </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">.data</span></strong><span class="koboSpan" id="kobo.540.1"> are stored, while the actual addresses used in the execution are in a different memory region. </span><span class="koboSpan" id="kobo.540.2">More details about the load address and the virtual address for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">.data</span></strong><span class="koboSpan" id="kobo.542.1"> section are explained in </span><a href="B18730_04.xhtml#_idTextAnchor115"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.543.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.544.1">, </span><em class="italic"><span class="koboSpan" id="kobo.545.1">The </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.546.1">Boot-Up Procedure</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.548.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">NOLOAD</span></strong><span class="koboSpan" id="kobo.550.1"> attribute used for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">.bss</span></strong><span class="koboSpan" id="kobo.552.1"> section ensures that no predefined values are stored in the ELF file for this section. </span><span class="koboSpan" id="kobo.552.2">Uninitialized global and static variables are mapped by the linker in the RAM area, which is allocated by </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">the linker:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.554.1">
_stored_data = .;
.data: AT(__stored_data)
{
Â Â Â Â . </span><span class="koboSpan" id="kobo.554.2">= ALIGN(4);
Â Â Â Â _start_data = .;
Â Â Â Â *(.data*)
Â Â Â Â . </span><span class="koboSpan" id="kobo.554.3">= ALIGN(4);
Â Â Â Â _start_data = .;
} &gt; RAM
.bss (NOLOAD):
{
Â Â Â Â . </span><span class="koboSpan" id="kobo.554.4">= ALIGN(4);
Â Â Â Â _start_bss = .;
Â Â Â Â *(.bss*)
Â Â Â Â . </span><span class="koboSpan" id="kobo.554.5">= ALIGN(4);
Â Â Â Â _end_bss = .;
} &gt; RAM</span></pre>
<p><span class="koboSpan" id="kobo.555.1">The </span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.556.1">alternative way to force the linker to keep sections in the final executable, avoiding their removal due to the linker garbage collector, is the use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">KEEP</span></strong><span class="koboSpan" id="kobo.558.1"> instruction to mark sections. </span><span class="koboSpan" id="kobo.558.2">Please note that this is an alternative to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">__attribute__((used))</span></strong><span class="koboSpan" id="kobo.560.1"> mechanism </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">explained earlier:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.562.1">
.keys :
{
Â Â Â Â . </span><span class="koboSpan" id="kobo.562.2">= ALIGN(4);
Â Â Â Â *(.keys*) = .;
Â Â Â Â KEEP(*(.keys*));
} &gt; FLASH</span></pre>
<p><span class="koboSpan" id="kobo.563.1">It is useful, and advisable in general, to have the linker create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">.map</span></strong><span class="koboSpan" id="kobo.565.1"> file alongside the resultant binary. </span><span class="koboSpan" id="kobo.565.2">This is done by appending the </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">-Map=filename</span></strong><span class="koboSpan" id="kobo.567.1"> option to the link step, such as in </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.569.1">
$ arm-none-eabi-ld -o image.elf object1.o object2.o 
-T linker_script.ld -Map=map_file.map</span></pre>
<p><span class="koboSpan" id="kobo.570.1">The map file contains the location and the description of all the symbols, grouped by sections. </span><span class="koboSpan" id="kobo.570.2">This is useful for looking for the specific location of symbols in the image, as well as for verifying that useful symbols are not accidentally discarded due to </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">a misconfiguration.</span></span></p>
<p><span class="koboSpan" id="kobo.572.1">Cross compiling toolchains provide standard C libraries for generic functionalities, such as string manipulation or standard type declarations. </span><span class="koboSpan" id="kobo.572.2">These are substantially a subset of the library calls available in the application space of an operating system, including standard input/output functions. </span><span class="koboSpan" id="kobo.572.3">The backend implementation of these functions is often left to the applications, so calling a function from the library that requires interaction with the hardware, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">printf</span></strong><span class="koboSpan" id="kobo.574.1">, implies that a write function is implemented outside of the library, providing the final transfer to a device </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">or peripheral.</span></span></p>
<p><span class="koboSpan" id="kobo.576.1">The implementation of the backend write function determines which channel would act as the </span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.577.1">standard output for the embedded application. </span><span class="koboSpan" id="kobo.577.2">The linker is capable of resolving the dependencies towards standard library calls automatically, using the built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">newlib</span></strong><span class="koboSpan" id="kobo.579.1"> implementation. </span><span class="koboSpan" id="kobo.579.2">To exclude the standard C library symbols from the linking process, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">-nostdlib</span></strong><span class="koboSpan" id="kobo.581.1"> option can be added to the options passed to GCC during the </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">linking step.</span></span></p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.583.1">Binary format conversion</span></h2>
<p><span class="koboSpan" id="kobo.584.1">Despite</span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.585.1"> containing all the compiled symbols in binary format, an ELF file is prefixed with a header that contains a description of the content and pointers to the positions where the sections start within the file. </span><span class="koboSpan" id="kobo.585.2">All this extra information is not needed to run on an embedded target, so the ELF file produced by the linker has to be transformed into a plain binary file. </span><span class="koboSpan" id="kobo.585.3">A tool in the toolchain, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">objcopy</span></strong><span class="koboSpan" id="kobo.587.1">, converts images from one standard format to others, and what is generally done is a conversion of the ELF into a raw binary image without altering the symbols. </span><span class="koboSpan" id="kobo.587.2">To transform the image from ELF to binary format, invoke </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.589.1">
$ arm-none-eabi-objcopy -I elf -O binary image.elf image.bin</span></pre>
<p><span class="koboSpan" id="kobo.590.1">This creates a new file, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">image.bin</span></strong><span class="koboSpan" id="kobo.592.1">, from the symbols contained in the original ELF executable, which can be uploaded to </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">the target.</span></span></p>
<p><span class="koboSpan" id="kobo.594.1">Even if not suitable in general for direct upload on the target with third-party tools, it is possible to load the symbols through the debugger and upload them to the flash address. </span><span class="koboSpan" id="kobo.594.2">The original ELF file is also useful as the target of other diagnostic tools in the GNU toolchain, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">nm</span></strong><span class="koboSpan" id="kobo.596.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">readelf</span></strong><span class="koboSpan" id="kobo.598.1">, which display the symbols in each module, with their type and relative address within the binary image. </span><span class="koboSpan" id="kobo.598.2">Furthermore, by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">objdump</span></strong><span class="koboSpan" id="kobo.600.1"> tool on the final image, or even on single object files, several details about the image can be retrieved, including the visualization of the entire assembly code, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">-d</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.602.1">disassemble option:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.603.1">
arm-none-eabi-objdump -d image.elf</span></pre>
<p><span class="koboSpan" id="kobo.604.1">At this point, the toolchain has provided us with all the artifacts needed to run, debug, and analyze the compiled software on a target microcontroller. </span><span class="koboSpan" id="kobo.604.2">In order to transfer the image or start a debugging session, we need additional specific tools, described in the </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">next section.</span></span></p>
<h1 id="_idParaDest-55"><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.606.1">Interacting with the target</span></h1>
<p><span class="koboSpan" id="kobo.607.1">For </span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.608.1">development purposes, embedded platforms are usually accessed through a JTAG or an SWD interface. </span><span class="koboSpan" id="kobo.608.2">Through these communication channels, it is possible to upload the software onto the flash of the target and access the on-chip debug functionality. </span><span class="koboSpan" id="kobo.608.3">Several self-contained JTAG/SWD adapters on the market can be controlled through a USB from the host, while some development boards are equipped with an extra chip controlling the JTAG channel that connects to the host through </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">a USB.</span></span></p>
<p><span class="koboSpan" id="kobo.610.1">A powerful generic open source tool to access JTAG/SWD functionalities on the target is the </span><strong class="bold"><span class="koboSpan" id="kobo.611.1">Open On-Chip Debugger</span></strong><span class="koboSpan" id="kobo.612.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.613.1">OpenOCD</span></strong><span class="koboSpan" id="kobo.614.1">). </span><span class="koboSpan" id="kobo.614.2">Once</span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.615.1"> properly configured, it creates local sockets that can be used as a command console and for interaction with the debugger frontend. </span><span class="koboSpan" id="kobo.615.2">Some development boards are distributed with additional interfaces to communicate with the core CPU. </span><span class="koboSpan" id="kobo.615.3">For example, STMicroelectronics prototyping</span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.616.1"> boards for </span><strong class="bold"><span class="koboSpan" id="kobo.617.1">Cortex-M</span></strong><span class="koboSpan" id="kobo.618.1"> are rarely shipped without a chip technology called ST-Link, which allows direct access to debug and flash manipulation functionalities. </span><span class="koboSpan" id="kobo.618.2">Thanks to its flexible backend, OpenOCD can communicate with these devices using different transport types and physical interfaces, including ST-Link and other protocols. </span><span class="koboSpan" id="kobo.618.3">Several different boards are supported and the configuration files can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">by OpenOCD.</span></span></p>
<p><span class="koboSpan" id="kobo.620.1">When started, OpenOCD opens two local TCP server sockets on preconfigured ports, providing communication services with the target platform. </span><span class="koboSpan" id="kobo.620.2">One socket provides an interactive command console that can be accessed through Telnet, while the other is a GDB server used for remote debugging, as described in the </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">next section.</span></span></p>
<p><span class="koboSpan" id="kobo.622.1">OpenOCD is distributed along with two sets of configuration files that describe the target microcontroller and peripherals (in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">target/</span></strong><span class="koboSpan" id="kobo.624.1"> directory), and the debugging interface used to communicate to it via JTAG or SWD (in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">interface/</span></strong><span class="koboSpan" id="kobo.626.1"> directory). </span><span class="koboSpan" id="kobo.626.2">A third set of configuration files (in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">board/</span></strong><span class="koboSpan" id="kobo.628.1"> directory) contain configuration files for well-known systems, such as development boards equipped with an interface chip, which combines both interfaces and target settings by including the </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">correct files.</span></span></p>
<p><span class="koboSpan" id="kobo.630.1">In order to configure OpenOCD for</span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.631.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.632.1">STM32F746-Discovery target</span></strong><span class="koboSpan" id="kobo.633.1">, we can use the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">openocd.cfg</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.635.1">configuration file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.636.1">
telnet_port 4444
gdb_port 3333
source [find board/stm32f7discovery.cfg]</span></pre>
<p><span class="koboSpan" id="kobo.637.1">The </span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.638.1">board-specific configuration file, which was imported from </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">openocd.cfg</span></strong><span class="koboSpan" id="kobo.640.1">, through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">source</span></strong><span class="koboSpan" id="kobo.642.1"> directive, instructs OpenOCD to use the ST-Link interface to communicate with the target and sets all the CPU-specific options for the STM32F7 family </span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">of microcontrollers.</span></span></p>
<p><span class="koboSpan" id="kobo.644.1">The two ports specified in the main configuration file, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">telnet_port</span></strong><span class="koboSpan" id="kobo.646.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">gdb_port</span></strong><span class="koboSpan" id="kobo.648.1"> directives, instruct OpenOCD to open two listening </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">TCP sockets.</span></span></p>
<p><span class="koboSpan" id="kobo.650.1">The first socket, often referred to as the monitor console, can be accessed by connecting to the</span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.651.1"> local </span><strong class="bold"><span class="koboSpan" id="kobo.652.1">4444 TCP port</span></strong><span class="koboSpan" id="kobo.653.1">, using a Telnet client from the </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">command line:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.655.1">
$ telnet localhost 4444
Open On-Chip Debugger
&gt;</span></pre>
<p><span class="koboSpan" id="kobo.656.1">The sequence of OpenOCD directives to initialize, erase the flash, and transfer the image starts with </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.658.1">
&gt; init
&gt; halt
&gt; flash probe 0</span></pre>
<p><span class="koboSpan" id="kobo.659.1">The execution is stopped at the beginning of the software image. </span><span class="koboSpan" id="kobo.659.2">After the </span><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">probe</span></strong><span class="koboSpan" id="kobo.661.1"> command, the flash is initialized, and OpenOCD will print out some information, including the address mapped to write on the flash. </span><span class="koboSpan" id="kobo.661.2">The following information shows up with </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">the STM32F746:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.663.1">
device id = 0x10016449
flash size = 1024kbytes
flash "stm32f2x" found at 0x08000000</span></pre>
<p><span class="koboSpan" id="kobo.664.1">The </span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.665.1">geometry of the flash can be retrieved using </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">this command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.667.1">
&gt; flash info 0</span></pre>
<p><span class="koboSpan" id="kobo.668.1">Which, on STM32F746 shows as </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.670.1">
#0 : stm32f2x at 0x08000000, size 0x00100000, buswidth 0, chipwidth 0
# 0: 0x00000000 (0x8000 32kB) not protected
# 1: 0x00008000 (0x8000 32kB) not protected
# 2: 0x00010000 (0x8000 32kB) not protected
# 3: 0x00018000 (0x8000 32kB) not protected
# 4: 0x00020000 (0x20000 128kB) not protected
# 5: 0x00040000 (0x40000 256kB) not protected
# 6: 0x00080000 (0x40000 256kB) not protected
# 7: 0x000c0000 (0x40000 256kB) not protected
STM32F7[4|5]x - Rev: Z</span></pre>
<p><span class="koboSpan" id="kobo.671.1">This flash contains eight sectors. </span><span class="koboSpan" id="kobo.671.2">If the OpenOCD target supports it, the flash can be completely erased by issuing the following command from </span><span class="No-Break"><span class="koboSpan" id="kobo.672.1">the console:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.673.1">
&gt; flash erase_sector 0 0 7</span></pre>
<p><span class="koboSpan" id="kobo.674.1">Once the flash memory is erased, we can upload a software image to it, linked and converted to raw binary format using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">flash write_image</span></strong><span class="koboSpan" id="kobo.676.1"> directive. </span><span class="koboSpan" id="kobo.676.2">As the raw binary format does not contain any information about its destination address in the mapped area, the starting address in the flash must be provided as the last argument, </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.678.1">
&gt; flash write_image /path/to/image.bin 0x08000000</span></pre>
<p><span class="koboSpan" id="kobo.679.1">These directives can be appended to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">openocd.cfg</span></strong><span class="koboSpan" id="kobo.681.1"> file, or to different configuration files, in order to automate all the steps needed for a specific action, such as erasing the flash and uploading an </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">updated image.</span></span></p>
<p><span class="koboSpan" id="kobo.683.1">Some </span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.684.1">hardware manufacturers offer their own set of tools to interact with the devices. </span><span class="koboSpan" id="kobo.684.2">STMicroelectronics devices can be programmed using the ST-Link utilities, an open source project that includes a flash tool (</span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">st-flash</span></strong><span class="koboSpan" id="kobo.686.1">), and a GDB server counterpart (</span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">st-util</span></strong><span class="koboSpan" id="kobo.688.1">). </span><span class="koboSpan" id="kobo.688.2">Some platforms have built-in bootloaders that accept alternative formats or binary transfer procedures. </span><span class="koboSpan" id="kobo.688.3">A </span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.689.1">common example is </span><strong class="bold"><span class="koboSpan" id="kobo.690.1">Device Firmware Upgrade</span></strong><span class="koboSpan" id="kobo.691.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.692.1">DFU</span></strong><span class="koboSpan" id="kobo.693.1">), which is a mechanism to deploy firmware on targets through a USB. </span><span class="koboSpan" id="kobo.693.2">The reference implementation on the host side is </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">dfu-util</span></strong><span class="koboSpan" id="kobo.695.1">, which is a free </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">software tool.</span></span></p>
<p><span class="koboSpan" id="kobo.697.1">Each tool, either generic or specific, tends to meet the same goal of communicating with the device and providing an interface for debugging the code, although often exposing a different interface toward the </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">development tools.</span></span></p>
<p><span class="koboSpan" id="kobo.699.1">Most IDEs provided by manufacturers to work with a specific family of microcontrollers incorporate in the IDE their own tools or third-party applications to access flash mapping and control the execution on the target. </span><span class="koboSpan" id="kobo.699.2">While, on one hand, they promise to hide the unnecessary complexity of the operation and provide firmware upload in one click, on the other, they generally do not provide a convenient interface for programming multiple targets at the same time, or at least efficiently, when it comes to production in large batches requiring to upload of the initial </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">factory firmware.</span></span></p>
<p><span class="koboSpan" id="kobo.701.1">Knowing the mechanisms and procedures from a command-line interface allows for understanding what is happening behind the scenes every time a new firmware is uploaded to the target, and anticipating the issues that would impact the life cycle during </span><span class="No-Break"><span class="koboSpan" id="kobo.702.1">this phase.</span></span></p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.703.1">The GDB session</span></h2>
<p><span class="koboSpan" id="kobo.704.1">Regardless </span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.705.1">of the programmerâ€™s accuracy or the complexity of the project we are working on, most of the development time will be spent trying to understand what our software does, or most likely, what has gone wrong and why the software is not behaving as we would expect when the code was written for the first time. </span><span class="koboSpan" id="kobo.705.2">The debugger is the most powerful tool in our toolchain, allowing us to communicate directly with the CPU, place breakpoints, control the execution flow instruction by instruction, and check the values of CPU registers, local variables, and memory areas. </span><span class="koboSpan" id="kobo.705.3">Good knowledge of the debugger means less time spent trying to figure out what is going on, and a more effective hunt for bugs </span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">and defects.</span></span></p>
<p><span class="koboSpan" id="kobo.707.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">arm-none-eabi</span></strong><span class="koboSpan" id="kobo.709.1"> toolchain</span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.710.1"> includes a GDB capable of interpreting the memory and the register layout of the remote target and can be accessed with the same interfaces as the host GDB, provided that its backend can communicate with the embedded platform, using OpenOCD or a similar host tool providing communication with the target through the GDB server protocol. </span><span class="koboSpan" id="kobo.710.2">As previously described, OpenOCD can be configured to provide a GDB server interface, which in the proposed configuration is on </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">port </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">3333</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.714.1">After starting </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">arm-none-eabi-gdb</span></strong><span class="koboSpan" id="kobo.716.1">, we may connect to the running tool using the GDB </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">target</span></strong><span class="koboSpan" id="kobo.718.1"> command. </span><span class="koboSpan" id="kobo.718.2">Connecting to the GDB server while OpenOCD is running can be done using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">target</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.720.1"> command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.721.1">
&gt; target remote localhost:3333</span></pre>
<p><span class="koboSpan" id="kobo.722.1">All GDB commands can be abbreviated, so the command often becomes </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.724.1">
&gt; tar rem :3333</span></pre>
<p><span class="koboSpan" id="kobo.725.1">Once connected, the target would typically stop the execution, allowing GDB to retrieve the information about the instruction that is currently being executed, the stack trace, and the values of the </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">CPU registers.</span></span></p>
<p><span class="koboSpan" id="kobo.727.1">From this moment on, the debugger interface can be used normally to step through the code, place breakpoints and watchpoints, and inspect and alter CPU registers and writable memory areas </span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">at runtime.</span></span></p>
<p><span class="koboSpan" id="kobo.729.1">GDB can be used entirely from its command-line interface, using shortcuts and commands to start and stop the execution, and access memory </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">and registers.</span></span></p>
<p><span class="koboSpan" id="kobo.731.1">The following reference table enumerates a</span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.732.1"> few of the GDB commands available in a debug session and provides a quick explanation of </span><span class="No-Break"><span class="koboSpan" id="kobo.733.1">their usage:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer016">
<span class="koboSpan" id="kobo.734.1"><img alt="Table 2.5 â€“ A few commonly used GDB commands" src="image/05a.jpg"/></span>
</div>
</div>
<div>
<div class="IMG---Figure" id="_idContainer017">
<span class="koboSpan" id="kobo.735.1"><img alt="Table 2.5 â€“ A few commonly used GDB commands" src="image/05b.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.736.1">Table 2.5 â€“ A few commonly used GDB commands</span></p>
<p><span class="koboSpan" id="kobo.737.1">GDB is a </span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.738.1">very </span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.739.1">powerful and complete debugger, and the commands that have been shown in this section are a small portion of its actual potential. </span><span class="koboSpan" id="kobo.739.2">We advise you to discover the other features offered by GDB by going through its manual in order to find the set of commands that best fit </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">your needs.</span></span></p>
<p><span class="koboSpan" id="kobo.741.1">IDEs often offer a separate graphic mode to deal with debugging sessions, which is integrated with the editor and allows you to set breakpoints, watch variables, and explore the content of memory areas while the system is running in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.742.1">debug mode</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.743.1">.</span></span></p>
<h1 id="_idParaDest-57"><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.744.1">Validation</span></h1>
<p><span class="koboSpan" id="kobo.745.1">Debugging </span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.746.1">alone, or even simple output analysis is often not enough when verifying system behavior and identifying issues and unwanted effects in the code. </span><span class="koboSpan" id="kobo.746.2">Different approaches may be taken to validate the implementation of single components, as well as the behavior of the entire system under different conditions. </span><span class="koboSpan" id="kobo.746.3">While, in some cases, the results can be directly measurable from the host machine, in more specific contexts, it is often difficult to reproduce the exact scenario or to acquire the necessary information from the </span><span class="No-Break"><span class="koboSpan" id="kobo.747.1">system output.</span></span></p>
<p><span class="koboSpan" id="kobo.748.1">External tools may come in handy, especially in the analysis of communication interfaces and network devices in a more complex, distributed system. </span><span class="koboSpan" id="kobo.748.2">In other cases, single modules can be tested off-target using simulated or emulated environments to run smaller portions of the </span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.750.1">Different tests, validation strategies, and tools are considered in this section to provide solutions for </span><span class="No-Break"><span class="koboSpan" id="kobo.751.1">any scenario.</span></span></p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.752.1">Functional tests</span></h2>
<p><span class="koboSpan" id="kobo.753.1">Writing</span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.754.1"> test cases before writing the code is generally considered an </span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.755.1">optimal practice in modern programming. </span><span class="koboSpan" id="kobo.755.2">Writing tests first not only speeds up the development phases but also improves the structure of the workflow. </span><span class="koboSpan" id="kobo.755.3">By setting clear and measurable goals from the beginning, it is harder to introduce conceptual defects in the design of the single components, and it also forces a clearer separation among the modules. </span><span class="koboSpan" id="kobo.755.4">More specifically, an embedded developer has less possibility to verify the correct behavior of the system through direct interaction; thus </span><strong class="bold"><span class="koboSpan" id="kobo.756.1">test-driven development</span></strong><span class="koboSpan" id="kobo.757.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.758.1">TDD</span></strong><span class="koboSpan" id="kobo.759.1">) is </span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.760.1">the preferred approach for the verification of single components as well as the functional behavior of the entire system, as long as the expected results can be directly measurable from the </span><span class="No-Break"><span class="koboSpan" id="kobo.761.1">host system.</span></span></p>
<p><span class="koboSpan" id="kobo.762.1">However, it must be considered that testing often introduces dependencies on specific hardware, and sometimes the output of an embedded system can only be validated through specific hardware tools or in a very unique and peculiar usage scenario. </span><span class="koboSpan" id="kobo.762.2">In all these cases, the usual TDD paradigm is less applicable, and the project can instead benefit from a modular design to give the possibility to test as many components as possible in a synthetic environment, such as emulators or unit </span><span class="No-Break"><span class="koboSpan" id="kobo.763.1">test platforms.</span></span></p>
<p><span class="koboSpan" id="kobo.764.1">Writing tests often involves programming the host so that it can retrieve information about the running target while the embedded software is executing or alongside an ongoing debugging session while the target executes in between breakpoints. </span><span class="koboSpan" id="kobo.764.2">The target can be configured to provide immediate output through a communication interface, such as a UART-based serial port, which can, in turn, be parsed by the host. </span><span class="koboSpan" id="kobo.764.3">It is usually more convenient to write test tools on the host using a higher-level interpreted programming language to better organize the test cases and easily integrate the parsing of test results using regular expressions. </span><span class="koboSpan" id="kobo.764.4">Python, Perl, Ruby, and other languages with similar characteristics, are often a good fit for this purpose, also thanks to the availability of libraries and components designed for collecting and analyzing test results and interacting with continuous integration engines. </span><span class="koboSpan" id="kobo.764.5">A good organization of the test and verification infrastructure contributes more than everything else to the stability of the project because regressions can be detected at the right time only if all the existing tests are repeated at every modification. </span><span class="koboSpan" id="kobo.764.6">Constantly running all the test cases while the development is ongoing not only improves the efficiency of detecting undesired effects as early as possible but helps keep the development goals visible at all times by directly measuring the number of failures and makes the refactoring of components more affordable at any stage in the </span><span class="No-Break"><span class="koboSpan" id="kobo.765.1">project lifetime.</span></span></p>
<p><span class="koboSpan" id="kobo.766.1">Efficiency is</span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.767.1"> the key because embedded programming is an iterative process with several steps being repeated over and over, and the approach required from the developers is much more predictive </span><span class="No-Break"><span class="koboSpan" id="kobo.768.1">than reactive.</span></span></p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.769.1">Hardware tools</span></h2>
<p><span class="koboSpan" id="kobo.770.1">If there</span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.771.1"> is a tool that is absolutely indispensable in assisting embedded software developers, it is the logic analyzer. </span><span class="koboSpan" id="kobo.771.2">By scoping the input and output signals involving the microcontroller, it is possible to detect the electrical behavior of the signals, their timing, and even the digital encoding of the single bits in the interface protocols. </span><span class="koboSpan" id="kobo.771.3">Most logic analyzers can identify and decode sequences of symbols by sensing the voltage of the wires, which is often the most effective way to verify that protocols are correctly implemented and compliant with the contracts to communicate with peripherals and network endpoints. </span><span class="koboSpan" id="kobo.771.4">While historically available only as standalone dedicated computers, a logic analyzer is often available in other forms, such as electronic instruments that can be connected to the host machine using USB or Ethernet interfaces, and use PC-based software to capture and decode the signals. </span><span class="koboSpan" id="kobo.771.5">The result of this process is a complete discrete analysis of the signals involved, which are sampled at a constant rate and then visualized on </span><span class="No-Break"><span class="koboSpan" id="kobo.772.1">a screen.</span></span></p>
<p><span class="koboSpan" id="kobo.773.1">While a similar task can be performed by oscilloscopes, they are often more complex to configure than logic analyzers when dealing with discrete signals. </span><span class="koboSpan" id="kobo.773.2">Nevertheless, an oscilloscope is the best tool for the analysis of analog signals, such as analog audio and communication among radio transceivers. </span><span class="koboSpan" id="kobo.773.3">Depending on the task, it might be better to use one or the other, but in general, the biggest advantage of a logic analyzer is that it provides better insight into discrete signals. </span><span class="koboSpan" id="kobo.773.4">Mixed-signal logic analyzers are often a good compromise between the flexibility of an oscilloscope, with the simplicity and insights of discrete </span><span class="No-Break"><span class="koboSpan" id="kobo.774.1">signal-logic analysis.</span></span></p>
<p><span class="koboSpan" id="kobo.775.1">Oscilloscopes and logic analyzers are often used to capture the activity of signals in a specific time window, which might be challenging to synchronize with the running software. </span><span class="koboSpan" id="kobo.775.2">Instead of capturing those signals continuously, the beginning of the capture can be synchronized with a physical event, such as a digital signal changing its value for the first time or an analog signal crossing a predefined threshold. </span><span class="koboSpan" id="kobo.775.3">This is done by configuring the instrument to initiate the capture using a trigger, which guarantees that the information captured only contains a time slice that is interesting for the </span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">ongoing diagnostic.</span></span></p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.777.1">Testing off-target</span></h2>
<p><span class="koboSpan" id="kobo.778.1">Another </span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.779.1">efficient way to speed up the development is by limiting the interaction, as much as possible, with the actual target. </span><span class="koboSpan" id="kobo.779.2">This is, of course, not always possible, especially when developing device drivers that need to be tested on actual hardware, but tools and methodologies to partially test the software directly on the development </span><span class="No-Break"><span class="koboSpan" id="kobo.780.1">machine exist.</span></span></p>
<p><span class="koboSpan" id="kobo.781.1">Portions of code that are not CPU-specific can be compiled for the host machine architecture and run directly, as long as their surroundings are properly abstracted to simulate the real environment. </span><span class="koboSpan" id="kobo.781.2">The software to test can be as small as a single function, and in this case, a unit test can be written specifically for the </span><span class="No-Break"><span class="koboSpan" id="kobo.782.1">development architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.783.1">Unit tests</span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.784.1"> are, in general, small applications that verify the behavior of a single component by feeding them with well-known input and verifying its output. </span><span class="koboSpan" id="kobo.784.2">Several tools are available on a Linux system to assist in writing unit tests. </span><span class="koboSpan" id="kobo.784.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">check</span></strong><span class="koboSpan" id="kobo.786.1"> library provides an interface for defining unit tests by writing a few preprocessor macros. </span><span class="koboSpan" id="kobo.786.2">The result is small self-contained applications that can be run every time the code is changed, directly on the host machine. </span><span class="koboSpan" id="kobo.786.3">Those components of the system that the function under test depends on are abstracted using mocks. </span><span class="koboSpan" id="kobo.786.4">For example, the following code detects and discards a specific escape sequence, </span><em class="italic"><span class="koboSpan" id="kobo.787.1">Esc</span></em><span class="koboSpan" id="kobo.788.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.789.1">C</span></em><span class="koboSpan" id="kobo.790.1">, from the input from a serial line interface, reading from the serial line until the </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">\0</span></strong><span class="koboSpan" id="kobo.792.1"> character </span><span class="No-Break"><span class="koboSpan" id="kobo.793.1">is returned:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.794.1">
int serial_parser(char *buffer, uint32_t max_len)
{
Â Â int pos = 0;
Â Â while (pos &lt; max_len) {
Â Â Â Â buffer[pos] = read_from_serial();
Â Â Â Â if (buffer[pos] == (char)0)
Â Â Â Â Â Â break;
Â Â Â Â if (buffer[pos] == ESC) {
Â Â Â Â Â Â Â buffer[++pos] = read_from_serial();
Â Â Â Â Â Â Â if (buffer[pos] == 'c')
Â Â Â Â Â Â Â Â Â pos = pos - 1;
Â Â Â Â Â Â Â Â Â continue;
Â Â Â Â }
Â Â Â Â pos++;
Â Â }
Â Â return pos;
}</span></pre>
<p><span class="koboSpan" id="kobo.795.1">A </span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.796.1">set of </span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.797.1">unit tests to verify this function using a check test suite may look like </span><span class="No-Break"><span class="koboSpan" id="kobo.798.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.799.1">
START_TEST(test_plain) {
Â Â const char test0[] = "hello world!";
Â Â char buffer[40];
Â Â set_mock_buffer(test0);
Â Â fail_if(serial_parser(buffer, 40) != strlen(test0));
Â Â fail_if(strcmp(test0,buffer) != 0);
}
END_TEST</span></pre>
<p><span class="koboSpan" id="kobo.800.1">Each test case can be contained in its </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">START_TEST()/END_TEST</span></strong><span class="koboSpan" id="kobo.802.1"> block and provide a different </span><span class="No-Break"><span class="koboSpan" id="kobo.803.1">initial configuration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.804.1">
START_TEST(test_escape) {
Â Â const char test0[] = "hello world!";
Â Â const char test1[] = "hello \033cworld!";
Â Â char buffer[40];
Â Â set_mock_buffer(test1);
Â Â fail_if(serial_parser(buffer, 40) != strlen(test0));
Â Â fail_if(strcmp(test0,buffer) != 0);
}
END_TEST
START_TEST(test_other) {
Â Â const char test2[] = "hello \033dworld!";
Â Â char buffer[40];
Â Â set_mock_buffer(test2);
Â Â fail_if(serial_parser(buffer, 40) != strlen(test2));
Â Â fail_if(strcmp(test2,buffer) != 0);
}
END_TEST</span></pre>
<p><span class="koboSpan" id="kobo.805.1">This</span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.806.1"> first </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">test_plain</span></strong><span class="koboSpan" id="kobo.808.1"> test ensures that a string with no escape characters is parsed correctly. </span><span class="koboSpan" id="kobo.808.2">The second test ensures that the escape sequence is skipped, and the third one verifies that a similar escape string is left untouched by the </span><span class="No-Break"><span class="koboSpan" id="kobo.809.1">output buffer.</span></span></p>
<p><span class="koboSpan" id="kobo.810.1">Serial communication is simulated using a mock function that replaces the original </span><strong class="source-inline"><span class="koboSpan" id="kobo.811.1">serial_read</span></strong><span class="koboSpan" id="kobo.812.1"> functionality provided by the driver when running the code on the target. </span><span class="koboSpan" id="kobo.812.2">This is a simple mock that feeds the parser with a constant buffer that can be reinitialized using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">set_serial_buffer</span></strong><span class="koboSpan" id="kobo.814.1"> helper function. </span><span class="koboSpan" id="kobo.814.2">The mock code looks </span><span class="No-Break"><span class="koboSpan" id="kobo.815.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.816.1">
static int serial_pos = 0;
static char serial_buffer[40];
char read_from_serial(void) {
Â Â return serial_buffer[serial_pos++];
}
void set_mock_buffer(const char *buf)
{
Â Â serial_pos = 0;
Â Â strncpy(serial_buffer, buf, 20);
}</span></pre>
<p><span class="koboSpan" id="kobo.817.1">Unit tests</span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.818.1"> are very useful to improve the quality of the code, but of course, achieving high code coverage consumes a large amount of time and resources in the economy of the project. </span><span class="koboSpan" id="kobo.818.2">Functional tests can also be run directly in the development environment by grouping functions into self-contained modules and implementing simulators that are slightly more complex than mocks for specific test cases. </span><span class="koboSpan" id="kobo.818.3">In the example of the serial parser, it would be possible to test the entire application logic on top of a different serial driver on the host machine, which is also able to simulate an entire conversation over the serial line, and interact with other components in the system, such as virtual terminals and other applications generating </span><span class="No-Break"><span class="koboSpan" id="kobo.819.1">input sequences.</span></span></p>
<p><span class="koboSpan" id="kobo.820.1">While covering a larger portion of the code within a single test case, the complexity of the simulated environment increases, and so does the amount of work required to reproduce the surroundings of the embedded system on the host machine. </span><span class="koboSpan" id="kobo.820.2">Nevertheless, it is good practice, especially when they could be used as verification tools throughout the whole development cycle and even integrated into the automated </span><span class="No-Break"><span class="koboSpan" id="kobo.821.1">test process.</span></span></p>
<p><span class="koboSpan" id="kobo.822.1">Sometimes, implementing a simulator allows for a much more complete set of tests, or it might be the only viable option. </span><span class="koboSpan" id="kobo.822.2">Think, for example, about those embedded systems using a GPS receiver for positioning: testing the application logic with negative latitude values would be impossible while sitting in the northern hemisphere, so writing a simulator that imitates the data coming from such a receiver is the quickest way to verify that our final device will not stop working across </span><span class="No-Break"><span class="koboSpan" id="kobo.823.1">the equator.</span></span></p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.824.1">Emulators</span></h2>
<p><span class="koboSpan" id="kobo.825.1">Another </span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.826.1">valid approach to running the code on the development machine, which is much less invasive for our code base and loosens the specific portability requirements, is emulating the whole platform on the host PC. </span><span class="koboSpan" id="kobo.826.2">An emulator is a computer program that can replicate the functionality of an entire system, including its core CPU, memory, and a set of peripherals. </span><span class="koboSpan" id="kobo.826.3">Some of the modern virtualization hypervisors for PCs are derived</span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.827.1"> from </span><strong class="bold"><span class="koboSpan" id="kobo.828.1">QEMU</span></strong><span class="koboSpan" id="kobo.829.1">, a free software emulator capable of virtualizing entire systems, even with a different architecture </span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.830.1">from those of the machine where it runs. </span><span class="koboSpan" id="kobo.830.2">Since it contains the full implementation of the instruction set of many different targets, QEMU can run the firmware image, which had been compiled for our target, in a process on top of the development machineâ€™s operating system. </span><span class="koboSpan" id="kobo.830.3">One of the supported targets that can run ARM Cortex-M3 microcode is </span><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">lm3s6965evb</span></strong><span class="koboSpan" id="kobo.832.1">, an old Cortex-M-based microcontroller, no longer recommended for new designs by the manufacturer, that is fu</span><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.833.1">lly supported </span><span class="No-Break"><span class="koboSpan" id="kobo.834.1">by QEMU.</span></span></p>
<p><span class="koboSpan" id="kobo.835.1">Once a binary image has been created using </span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">lm3s6965evb</span></strong><span class="koboSpan" id="kobo.837.1"> as a target, and properly converted to raw binary format using </span><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">objcopy</span></strong><span class="koboSpan" id="kobo.839.1">, a fully emulated system can be run by invoking QEMU </span><span class="No-Break"><span class="koboSpan" id="kobo.840.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.841.1">
$ qemu-system-arm -M lm3s6965evb --kernel image.bin</span></pre>
<p><span class="koboSpan" id="kobo.842.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">--kernel</span></strong><span class="koboSpan" id="kobo.844.1"> option instructs the emulator to run the image at startup, and while it might sound misnamed, it is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.845.1">kernel</span></strong><span class="koboSpan" id="kobo.846.1"> because QEMU is widely used to emulate headless Linux systems on other synthetic targets. </span><span class="koboSpan" id="kobo.846.2">Similarly, a convenient debugging session can be started by using QEMUâ€™s built-in GDB server through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">-gdb</span></strong><span class="koboSpan" id="kobo.848.1"> option, which can also halt the system until our GDB client is connected </span><span class="No-Break"><span class="koboSpan" id="kobo.849.1">to it:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.850.1">
$ qemu-system-arm -M lm3s6965evb --kernel image.bin -nographic -S -gdb tcp::3333</span></pre>
<p><span class="koboSpan" id="kobo.851.1">In the same way, as with the real target, we can connect </span><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">arm-none-eabi-gdb</span></strong><span class="koboSpan" id="kobo.853.1"> to TCP port </span><strong class="source-inline"><span class="koboSpan" id="kobo.854.1">3333</span></strong><span class="koboSpan" id="kobo.855.1"> on </span><strong class="source-inline"><span class="koboSpan" id="kobo.856.1">localhost</span></strong><span class="koboSpan" id="kobo.857.1"> and start debugging the software image exactly as it was running on the </span><span class="No-Break"><span class="koboSpan" id="kobo.858.1">actual platform.</span></span></p>
<p><span class="koboSpan" id="kobo.859.1">The limit of the emulation approach is that QEMU can only be used to debug generic features that do not involve interaction with actual modern hardware. </span><span class="koboSpan" id="kobo.859.2">Nevertheless, running QEMU with a Cortex-M3 target can be a quick way to learn about generic Cortex-M features, such as memory management, system interrupt handling, and processor modes, because many features of the Cortex-M CPU are </span><span class="No-Break"><span class="koboSpan" id="kobo.860.1">accurately emulated.</span></span></p>
<p><span class="koboSpan" id="kobo.861.1">More accurate emulation of microcontroller systems can be achieved </span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.862.1">using </span><strong class="bold"><span class="koboSpan" id="kobo.863.1">Renode</span></strong><span class="koboSpan" id="kobo.864.1"> (</span><a href="https://renode.io"><span class="koboSpan" id="kobo.865.1">https://renode.io</span></a><span class="koboSpan" id="kobo.866.1">). </span><span class="koboSpan" id="kobo.866.2">Renode </span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.867.1">is an open source, configurable emulator for many different microcontrollers and CPU-based embedded systems. </span><span class="koboSpan" id="kobo.867.2">The emulation includes peripherals, sensors, LEDs, and even wireless and wired interfaces to interconnect multiple emulated systems and the </span><span class="No-Break"><span class="koboSpan" id="kobo.868.1">host network.</span></span></p>
<p><span class="koboSpan" id="kobo.869.1">Renode is a desktop application with a command-line console. </span><span class="koboSpan" id="kobo.869.2">A single configuration file must be provided from the command-line invocation, with several platforms and development board configurations provided under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">/scripts</span></strong><span class="koboSpan" id="kobo.871.1"> directory. </span><span class="koboSpan" id="kobo.871.2">This means that once installed, the emulator for the </span><em class="italic"><span class="koboSpan" id="kobo.872.1">STM32F4 discovery board</span></em><span class="koboSpan" id="kobo.873.1"> can be started by invoking the </span><span class="No-Break"><span class="koboSpan" id="kobo.874.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.875.1">
$ renode /opt/renode/scripts/single-node/stm32f4_discovery.resc</span></pre>
<p><span class="koboSpan" id="kobo.876.1">This </span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.877.1">command will load the demo firmware on an emulated STM32F4 target flash memory and redirect the I/O of one of the emulated UART serial ports to a console in a new window. </span><span class="koboSpan" id="kobo.877.2">To start the demo, type </span><strong class="source-inline"><span class="koboSpan" id="kobo.878.1">start</span></strong><span class="koboSpan" id="kobo.879.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.880.1">Renode console.</span></span></p>
<p><span class="koboSpan" id="kobo.881.1">The example script comes with a demo firmware image running </span><em class="italic"><span class="koboSpan" id="kobo.882.1">Contiki OS</span></em><span class="koboSpan" id="kobo.883.1">. </span><span class="koboSpan" id="kobo.883.2">The firmware image is loaded by the script via the </span><span class="No-Break"><span class="koboSpan" id="kobo.884.1">Renode command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.885.1">
sysbus LoadELF $bin</span></pre>
<p><span class="koboSpan" id="kobo.886.1">Where </span><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">$bin</span></strong><span class="koboSpan" id="kobo.888.1"> is a variable pointing to the path (or the URL) of the firmware ELF file to load on the emulated flash memory. </span><span class="koboSpan" id="kobo.888.2">This option, as well as the UART analyzer port and other specific commands to execute when the emulator is started, can be easily changed by customizing the </span><span class="No-Break"><span class="koboSpan" id="kobo.889.1">script file.</span></span></p>
<p><span class="koboSpan" id="kobo.890.1">Renode integrates a GDB server that can be spawned from the Renode console or the startup script before starting the emulation, for example, using </span><span class="No-Break"><span class="koboSpan" id="kobo.891.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.892.1">
machine StartGdbServer 3333</span></pre>
<p><span class="koboSpan" id="kobo.893.1">In this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.894.1">3333</span></strong><span class="koboSpan" id="kobo.895.1"> is the TCP port the GDB server will be listening to, as in the other cases with QEMU and a debugger on the </span><span class="No-Break"><span class="koboSpan" id="kobo.896.1">physical target.</span></span></p>
<p><span class="koboSpan" id="kobo.897.1">Unlike QEMU, which is a very generic emulator, Renode is a project created with the purpose of assisting embedded developers throughout the entire life cycle. </span><span class="koboSpan" id="kobo.897.2">The possibility to emulate different complete platforms, creating mocks for sensors on several architectures, including RISC-V, makes it a unique tool to automate testing on multiple targets quickly or test on systems even when the actual hardware is </span><span class="No-Break"><span class="koboSpan" id="kobo.898.1">not available.</span></span></p>
<p><span class="koboSpan" id="kobo.899.1">Last but not least, thanks to its own scripting language, Renode</span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.900.1"> is perfectly integrated with test automation systems, where the execution of the emulated target can be started, stopped, and resumed, and the configuration of all devices and peripherals altered while the test </span><span class="No-Break"><span class="koboSpan" id="kobo.901.1">is running.</span></span></p>
<p><span class="koboSpan" id="kobo.902.1">The approaches</span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.903.1"> proposed for the definition of test strategies take into account different scenarios. </span><span class="koboSpan" id="kobo.903.2">The idea has been to introduce a range of possible solutions for software validation, from lab equipment to tests off-target in simulated and emulated environments, for the developer to choose from in a </span><span class="No-Break"><span class="koboSpan" id="kobo.904.1">specific scenario.</span></span></p>
<h1 id="_idParaDest-62"><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.905.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.906.1">This chapter introduced the tools for working on the development of embedded systems. </span><span class="koboSpan" id="kobo.906.2">A hands-on approach has been proposed to get you up and running with the toolchain and the utilities required to communicate with the hardware platform. </span><span class="koboSpan" id="kobo.906.3">Using appropriate tools can make embedded development easier and shorten </span><span class="No-Break"><span class="koboSpan" id="kobo.907.1">workflow iterations.</span></span></p>
<p><span class="koboSpan" id="kobo.908.1">In the next chapter, we provide indications for workflow organization when working with larger teams. </span><span class="koboSpan" id="kobo.908.2">Based on real-life experiences, we propose solutions for splitting and organizing tasks, executing tests, iterating throughout the phases of design, and the definition and implementation of an </span><span class="No-Break"><span class="koboSpan" id="kobo.909.1">embedded project.</span></span></p>
</div>


<div class="Content" id="_idContainer019">
<h1 id="_idParaDest-63"><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.1.1">Part 2 â€“ </span><span lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2.1">Core System Architecture</span></span></h1>
<p><span class="koboSpan" id="kobo.3.1">This part goes a little deeper into the rabbit hole, by introducing you to pragmatic software design at first and then guiding you step by step through the code needed for proper boot-up mechanisms and memory management, with a strong focus on a </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">memory-safe approach.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">following chapters:</span></span></p>
<ul>
<li><a href="B18730_03.xhtml#_idTextAnchor079"><em class="italic"><span class="koboSpan" id="kobo.7.1">Chapter 3</span></em></a><span class="koboSpan" id="kobo.8.1">, </span><em class="italic"><span class="koboSpan" id="kobo.9.1">Architectural Patterns</span></em></li>
<li><a href="B18730_04.xhtml#_idTextAnchor115"><em class="italic"><span class="koboSpan" id="kobo.10.1">Chapter 4</span></em></a><span class="koboSpan" id="kobo.11.1">, </span><em class="italic"><span class="koboSpan" id="kobo.12.1">The Boot-Up Procedure</span></em></li>
<li><a href="B18730_05.xhtml#_idTextAnchor149"><em class="italic"><span class="koboSpan" id="kobo.13.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.14.1">, </span><em class="italic"><span class="koboSpan" id="kobo.15.1">Memory Management</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer020">
</div>
</div>
</body></html>