- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Caching Data to Decrease Bandwidth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When it comes to reducing bandwidth usage and optimizing network usage in game
    development, there is a powerful technique that always comes to mind: caching.'
  prefs: []
  type: TYPE_NORMAL
- en: Caching solves the question of why we should keep downloading the same data
    repeatedly when we can download it once, store it somewhere, and reuse it whenever
    needed. In this chapter, we will delve into caching techniques and learn how to
    apply them to efficiently download, store, and reuse images and other relevant
    data. For that, we will use a database that contains image URLs that we are going
    to download directly from the internet into our players’ machines.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate the implementation of these caching techniques, we will prototype
    a new feature in our game project, where players will have the ability to upload
    custom images for their spaceships. To save time and focus solely on the network
    aspect of this feature, we will avoid implementing user experience and user interface
    aspects, leaving those tasks to the talented individuals in our imaginary indie
    studio. Your role, as a developer, will be to tackle the network-related aspects
    of this feature and ensure its seamless integration.
  prefs: []
  type: TYPE_NORMAL
- en: In the following screenshot, you can witness the exciting results of this feature
    in action. Two players are engaging in the game with their own custom spaceship
    sprites, which have been downloaded from the server. These sprites are sourced
    from Twemoji, an open source repository of Creative Commons-licensed emojis maintained
    by Twitter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – The custom spaceship sprites downloaded from the server for
    the two players](img/Figure_13.01_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – The custom spaceship sprites downloaded from the server for the
    two players
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the `HTTPRequest` node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing texture caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing database caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going further with caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is worth mentioning that this chapter builds upon the concepts presented
    in [*Chapter 10*](B18527_10.xhtml#_idTextAnchor260), *Debugging and Profiling
    the Network*, as well as the project developed in [*Chapter 9*](B18527_09.xhtml#_idTextAnchor188),
    *Creating an Online Adventure Prototype*. Therefore, it is crucial to familiarize
    yourself with the concepts and techniques discussed in those chapters to fully
    grasp the optimization methods presented here. We will also build upon the final
    project from [*Chapter 12*](B18527_12.xhtml#_idTextAnchor285), *Implementing Lag
    Compensation*, for which you can get the files through the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/tree/12.prediction-and-interpolation](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/tree/12.prediction-and-interpolation)'
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, throughout this chapter, it is important to have a basic understanding
    of how to upload and host content on online services. For instance, we will be
    downloading files directly from the project’s GitHub repository and from a service
    called ImgBB, a free image-hosting platform. Without understanding the mechanisms
    behind content hosting and retrieval using direct links, you may encounter difficulties
    in understanding and implementing the processes we are about to explore.
  prefs: []
  type: TYPE_NORMAL
- en: To enrich your learning experience, I highly recommend downloading the latest
    version of the Twemoji repository, which can be obtained from [https://github.com/twitter/twemoji](https://github.com/twitter/twemoji).
    By exploring this repository, you will gain further insights into how images and
    other media content can be managed and incorporated into your game development
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: That said, let’s understand what caching is and how we are going to use it in
    our game project.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In online multiplayer games, every second counts. Players expect seamless, real-time
    experiences without interruptions. This is where caching becomes a powerful ally
    in optimizing game performance. So, what exactly is caching, and why is it crucial
    for online multiplayer games?
  prefs: []
  type: TYPE_NORMAL
- en: '**Caching** is the process of storing frequently accessed data or resources
    on a local device or intermediate server. These resources can include images,
    sound files, 3D models, or even small snippets of code. Instead of fetching these
    resources from a remote server every time they are needed, the game stores them
    locally. When a request for these resources arises, the game checks whether it
    already has a local copy. If it does, it uses the local version, significantly
    reducing loading times and conserving precious network bandwidth.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The principle behind caching is simple yet effective: if you’ve used something
    once, it’s likely you’ll need it again. In the context of our multiplayer game,
    this means that the images, sounds, and assets that players download to customize
    their spaceships can be cached locally on their devices. When another player comes
    into view, the game can retrieve these assets from the local cache instead of
    re-downloading them. This creates a more streamlined experience and reduces the
    stress on the network.'
  prefs: []
  type: TYPE_NORMAL
- en: Caching offers numerous advantages in online multiplayer games. The most prominent
    benefit is an enhanced gaming experience. By using cached resources, players can
    swiftly interact with others, see their personalized spaceship designs, and engage
    in combat without significant delays. Reduced loading times translate to more
    fluid and immersive gameplay. Moreover, this process eases the strain on the server,
    enabling it to handle more players simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Caching is not just about speed; it’s also about efficiency. Downloading the
    same resources repeatedly not only wastes bandwidth but also makes the game less
    environmentally friendly and potentially costly for players with limited data
    plans. By caching frequently used resources, the game becomes faster, more eco-friendly,
    and cost-effective.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will explore how to leverage the powerful `HTTPRequest`
    node to implement caching for customized spaceship images. We will dive into the
    processes of downloading these images and ensuring their availability in each
    player’s cache, enhancing the online multiplayer experience. Stay tuned for a
    step-by-step guide on how to implement caching in your game.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the HTTPRequest node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the chapter’s introduction, we are going to implement a feature
    that allows players to use custom sprites on their spaceships.
  prefs: []
  type: TYPE_NORMAL
- en: To prototype this feature, we will download images from a third-party image-hosting
    service that offers free image hosting. We will accomplish this by using a **Hypertext
    Transfer Protocol** (**HTTP**) request to retrieve the image file from the third-party
    servers. Let’s delve into the workings of HTTP to fully understand how it operates
    and grasp the implementation process.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the HTTP protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**HTTP** serves as the foundation for communication on the **World Wide Web**.
    It is a protocol that defines the interaction and data exchange between clients
    and servers. Invented by Tim Berners-Lee in the early 1990s, HTTP was initially
    designed to facilitate the retrieval of hypertext documents, commonly known as
    web pages. Over time, it has evolved to support various types of content, including
    images, videos, and files.'
  prefs: []
  type: TYPE_NORMAL
- en: When a client, such as our player, wants to retrieve a resource from a server,
    it initiates an HTTP request. This request consists of a method that specifies
    the desired action to be performed on the resource, along with a `GET`, `POST`,
    `PUT`, and `DELETE`. In the context of downloading images, the `GET` method is
    what we typically employ.
  prefs: []
  type: TYPE_NORMAL
- en: Upon receiving the HTTP request, the server processes it and prepares an HTTP
    response. This response contains the requested resource, accompanied by metadata
    such as the HTTP status code, content type, and content length.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the server includes headers in the response to provide further
    information or instructions to the client.
  prefs: []
  type: TYPE_NORMAL
- en: To download images using HTTP, the client sends a `GET` request to the server,
    specifying the URL of the image. The server then processes this request and sends
    back an HTTP response that contains the image data. The client receives this response
    and interprets it to display the image to the user.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP operates as a stateless protocol, meaning that each request-response cycle
    is independent and does not retain any information about previous interactions.
  prefs: []
  type: TYPE_NORMAL
- en: However, mechanisms such as cookies and session management can be employed to
    maintain state and enable more complex interactions.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, HTTP serves as the protocol that facilitates communication between
    clients and servers on the web. It enables us to download images and other resources
    by sending HTTP requests to servers and receiving HTTP responses that contain
    the requested data. Understanding the workings of HTTP is essential for implementing
    features such as downloading images in our game project.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we are going to use HTTP requests is because the types of files we
    want to cache are fairly large compared to the kind of data we usually transfer
    using `HTTPRequest` nodes and a minimal database where we will pair the players’
    usernames and the URLs of their custom spaceship sprites. This database is intended
    to go on the server side and be cached in the player’s machine later, as we will
    see in the *Implementing database* *caching* section.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the scenes and database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s begin setting up the scenes and database.
  prefs: []
  type: TYPE_NORMAL
- en: To create our database, let’s open the `res://09.prototyping-space-adventure/`
    folder and create a new text file. You can quickly do that by right-clicking the
    folder in the **FileSystem** dock. The following screenshot displays the menu
    that pops up. From there, select **New** | **TextFile...**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – Creating a new text file directly through the FileSystem dock](img/Figure_13.02_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – Creating a new text file directly through the FileSystem dock
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, create a file named `PlayerSpaceships.json`, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 13.3 – Creating a new text file named PlayerSpaceship\uFEFFs.json](img/Figure_13.03_B18527.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – Creating a new text file named PlayerSpaceships.json
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, regarding the content, we are going to maintain the users from the `PlayerSpaceships.json`
    file will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that you can experiment with other images and hosting services. As long
    as you have the image’s direct link, usually pointing to the `.png` file, you
    will be good.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it’s time to set up the `HTTPRequest` nodes. We are going to start by
    downloading the `PlayerSpaceships.json` file from the server. In our case, this
    file is hosted on GitHub, but you can store it on another server as long as you
    have a direct link to the actual database file. In our case you can find it here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[raw.githubusercontent.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/13.caching-data/source/09.prototyping-space-adventure/PlayerSpaceships.json](http://raw.githubusercontent.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/13.caching-data/source/09.prototyping-space-adventure/PlayerSpaceships.json)'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `PlayerSpaceships.json` file up on the internet, let’s see how we
    can download it to our players’ machines with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene and use an `HTTPRequest` node as the root node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename it to `SpaceshipsDatabaseDownloadHTTPRequest`, as this node will be responsible
    for downloading the database from the internet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach a new script to this node and save the scene and the script. Here I saved
    them directly as `res://09.prototyping-space-` `adventure/SpaceshipsDatabaseDownloadHTTPRequest`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, open the script, and let’s do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an exported variable for the path to the folder that we will use for
    caching. Here it’s important to use the `user://` data folder path so Godot Engine
    properly adapts the path depending on the platform the game is running on:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create a new exported variable that should point to where the database
    file is going to be saved. Let’s keep its default filename and put it into the
    `cache` folder:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we can export yet another variable. But now we need to store the
    link of the location where the `PlayerSpaceships.json` file will be downloaded
    from:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, we can move on to the actual downloading method. Create a new method
    called `download_spaceships_database()` and let’s start its implementation.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first thing we are going to do here is to check whether there’s a cache
    directory already. If we don’t have it yet, we will create it:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will check whether the `PlayerSpaceships.json` file exists. If it
    doesn’t, we will start the actual download. The first thing to start the download
    is to set the file path in the `download_file` member variable:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With `download_file` set, we can make the request to the file. For that, we
    will use the `request()` method, which asks for a URL. This method uses the `GET`
    method by default to make requests, which is what we want in this case. But you
    can change this in the third argument, right after passing some custom headers
    if you want. We don’t have to pass anything other than the URL in our case:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we need to wait for the request to finish. Remember, since this
    is an asynchronous procedure, the game needs to wait for it to complete before
    moving on to any logic that depends on this file:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After following the preceding steps, we should have our `SpaceshipsDatabaseDownloadHTTPRequest`
    working. If you want to, you can test it out. For that, call the `download_spaceship_database()`
    method in the `_ready()` callback and run the scene. After that, if you open the
    user data folder, you will see the `.cache/` folder and if you enter this folder
    you should find the `PlayerSpaceships.json` file there. Note that in this case
    the `.cache/` is a hidden folder, so make sure you can see hidden folders in your
    file manager. To quickly open the user data folder, you can go to **Project**
    | **Open User Data Folder**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 13.4 - Open\uFEFF User Data Folder from the Editor’s Project tab](img/Figure_13.04_B18527.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 13.4 - Open User Data Folder from the Editor’s Project tab
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s create the `TextureDownloadHTTPRequest` scene so we can use the
    data in `PlayerSpaceships.json` to effectively download the players’ custom spaceship
    sprites. For that, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene and use an `HTTPRequest` node as root.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename it `TextureDownloadHTTPRequest` as this is the one actually responsible
    for downloading the textures from the internet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save the scene as `res://09.prototyping-space-` `adventure/TextureDownloadHTTPRequest.tscn`
    and attach a script to it, then in the script let’s do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Export a variable that should point to the `PlayerSpaceships.json` file in
    the player’s machine, so this path should use the `user://` file path:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new method called `download_spaceship()`. This method should receive
    two arguments, one for the user and another one for the file path where the sprite
    will be saved:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, inside this method, we will create a new `Dictionary` called `players_spaceships`,
    which will start empty but will soon store the content from the `PlayerSpaceships.json`
    file:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we are going to check whether the file provided by the `spaceships_database_file`
    path exists. If it does, we will open it, convert it to a string using `FileAccess.get_as_text()`
    , and parse it from JSON format to `Dictionary` object format, storing it in the
    `players_spaceships` variable:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we can download the `user` sprite based on the URL provided by
    the `PlayerSpaceships.json` database and store it in the file path provided by
    the `sprite_file` argument. For that, we will use `HTTPRequest.download_file`
    and download it using the `HTTPRequest.request()` method. Note that this method
    returns an error if the request has any issues. Let’s store this in an `error`
    variable to allow other classes to verify whether the request was successful:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since HTTP requests may take some time to finish downloading the content requested,
    we need to wait for the `HTTPRequest.request_completed` signal before ending the
    function and returning the error. Note that if the function doesn’t reach any
    of these conditional statements, we should return `FAILED` to acknowledge to other
    classes that `spaceships_database_file` doesn’t exist or `user` doesn’t exist
    in the database:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alright, this ends our journey to set up HTTPRequests. We created the database
    and the two nodes responsible for working on its data, downloading the database
    to the players’ machines, and downloading the content in the database as well,
    in this case, the players’ spaceships’ custom sprites. You can test the scene
    as well by calling the `download_spaceship()` method using `"user1"` and `"user://.cache/user1_spaceship.png"`
    as arguments. Just make sure that you’ve run the `SpaceshipDatabaseDownloadHTTPRequest`
    scene first so the `PlayersSpaceships.json` file exists in the `user://.cache/`
    folder. With that, you should see a new image downloaded right in your user data
    folder! The following screenshot shows what my `user://.cache/` folder looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 13.5 – The \uFEFFuser data folder with the Player\uFEFFSpaceships.json\
    \ file and user1’s custom spaceship sprite](img/Figure_13.05_B18527.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 13.5 – The user data folder with the PlayerSpaceships.json file and user1’s
    custom spaceship sprite
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about the usage of HTTP requests for caching data
    and downloading images in the user data folder. We saw the difference between
    UDP and HTTP when it comes to transferring large files such as images and how
    to use the `HTTPRequest` node to use the HTTP protocol in Godot and transfer data
    from the internet to our machine.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming section, we will discuss the implementation of texture caching
    in the game itself, allowing for real-time changes to the players’ spaceships.
    This feature will be achieved by using the `HTTPRequest` nodes we created and
    our minimal database to get the URLs of the players’ custom spaceship sprites.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing texture caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we introduced the `HTTPRequest` node, a built-in solution
    offered by Godot Engine to make HTTP requests. Then we created `TextureDownloadHTTPRequest`,
    which is a custom node specialized in downloading images from our `PlayersSpaceship.json`
    database. Now, let’s dive deeper into integrating this node into our `Player2D`
    class so we can actually use it in our prototype.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will create a method to enable the server to change a player’s
    spaceship sprite dynamically. But we won’t just load any sprite; we’ll fetch the
    proper file from the `user://.cache/` folder we set up in the *Setting up the
    scenes and database* section. This approach will enhance the customization and
    interaction in your game, allowing the server to deliver custom sprites to players
    in real time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, we’ll create a method called `load_spaceship()`. This method
    will play a fundamental role in our implementation. It will be an RPC function
    that the server can trigger remotely for specific players. Well, let’s get started!
    Open the `res://09.prototyping-space-adventure/Actors/Player/Player2D.tscn` scene
    and work through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by adding an instance of `TextureDownloadHTTPRequest` directly as
    a child of the `Player` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 13.6 – \uFEFFTextureDownloadHTTPRequest instantiated in the Player\
    \ scene](img/Figure_13.06_B18527.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 13.6 – TextureDownloadHTTPRequest instantiated in the Player scene
  prefs: []
  type: TYPE_NORMAL
- en: Then, open the `res://09.prototyping-space-adventure/Actors/Player/Player2D.gd`
    script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s store a reference to the `TextureDownloadHTTPRequest` node. We can call
    it just `http_request` for short:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, right below the `setup_multiplayer()` method, let’s create the `load_spaceship()`
    method. It will be an RPC method that should only be remotely callable by the
    server and should also be called locally, so the server also updates the image.
    This method receives the user, which loads the spaceship:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, inside this method, we are going to create the file path to the spaceship
    texture file in the player’s machine and store it in a variable called `spaceship_file`.
    This file path is composed of the `"user://.cache/"` string, followed by the `user`
    value we got as an argument, and we will append `"_spaceship.png"` to create the
    proper file path with an image extension:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With a proper file path to work with, the next step is to see whether this
    file already exists because the whole idea of caching data is that, if it already
    exists in the player’s machine, we can load it instead of re-downloading it and
    reduce resource consumption. The following code checks whether the file exists.
    If it does, we call the `update_sprite()` method passing `spaceship_file` as an
    argument. We are going to create the `update_sprite()` method in a moment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, `TextureDownloadHTTPRequest` will play its role. If the file doesn’t exist
    in the cache folder, we call the `TextureDownloadHTTPRequest.download_texture()`
    method and wait for it to finish; remember, it’s an asynchronous method. And if
    this method returns an `OK` error, meaning there’s actually no error, we also
    call the `update_sprite()` method so the game performs the procedures to effectively
    update the spaceship’s sprite. The following code checks whether the `update_sprite()`
    method returns anything other than `OK`. If the `update_sprite()` method doesn’t
    return `OK`, it means no sprite will be loaded. Since the custom sprite doesn’t
    affect the player’s core experience, we can just assume we can keep the default
    sprite and let the game run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let’s create the `update_sprite()` method. This is the method that effectively
    changes the `Sprite` node’s `Texture` property. It will load the image from the
    file path using the `Image.load_from_file()` method and turn it into an `ImageTexture`
    using the `ImageTexture.create_from_image()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this section, we saw how to use the `TextureDownloadHTTPRequest` node to
    download and cache the images from our database. We also saw how to dynamically
    change a player’s spaceship sprite using the cached images, loading them as image
    resources and turning them into an actual `ImageTexture` that the spaceship’s
    `Sprite2D` node can use.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the missing part of this process is…how we actually get the `PlayersSpaceship.json`
    database and where we call the `load_spaceship()` method. Well, that’s what we
    are going to do in the next section!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing database caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With everything in place, it is time to go one step above and work on the `World`
    scene that is going to glue everything together and run the proper procedures
    to ensure that all players will see the same custom sprites. We do that in this
    node because this is the class responsible for setting up everything related to
    world synchronization, which includes the players’ spaceship custom sprites. We
    will need to make some changes in some core methods to achieve that, but this
    is for the better.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are working with a prototype, there’s no fear of altering function
    signatures and other core aspects of a class. But note that if this was production-ready,
    we would call this class “closed” and avoid making core changes like the ones
    we are about to make. This would keep our game code base consistent and avoid
    errors. Though the changes we are about to make will mostly extend the class functionalities,
    we will add an argument to the `World.create_spaceship()` method, breaking the
    function’s contract since it didn’t ask for any arguments before. But, as said,
    this is a prototype, and we have the freedom to tweak things as we want. So, let’s
    open the `res://09.prototyping-space-adventure/Levels/World.tscn` scene and implement
    the improvements by working through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First things first, let’s add an instance of the `SpaceshipsDatabaseDownloadHTTPRequest`
    node as a direct child of the `World` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 13.7 – \uFEFFSpaceshipsDatabaseDownloadHTTPRequest instantiated in\
    \ the World scene](img/Figure_13.07_B18527.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 13.7 – SpaceshipsDatabaseDownloadHTTPRequest instantiated in the World
    scene
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, let’s open the `res://09.prototyping-space-adventure/Levels/World.gd`
    script and start the code by adding a reference to the `SpaceshipsDatabaseDownloadHTTPRequest`
    node. We can simply call it `http_request` here as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will also create a new variable to store a `player_ids` and their `user`.
    This will allow us to look into this variable to find the proper username related
    to each player’s peer ID so we can easily map them in our database moving forward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in the `_ready()` callback, after waiting briefly for the `0.1` `SceneTree`’s
    timer to timeout, we will wait for `http_request` to download the spaceships database
    as well. Remember, this only happens if the instance running the game isn’t the
    server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Still in this `if` statement, we will make a small change. When making the RPC
    to the server’s `create_spaceship()` method, we will also pass the player’s user.
    For that, we will use the long-time-forgotten `AuthenticationCredentials` singleton!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Moving on to the `create_spaceship()`method, we need to, of course, change
    its function signature to support the `user` argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, before adding the `spaceship` as a child of the `Players` node, we will
    use its name (which is essentially a string version of the player’s peer ID) as
    a key in the `player_users` dictionary and set this key’s value to the `user`
    argument. With that, we effectively paired the player’s ID with their username:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After making the RPC to the newly instantiated player spaceship’s `setup_multiplayer()`
    method, we will make the magic happen by also making an RPC to the `load_spaceship()`
    method, triggering the procedures we made in the *Implementing texture caching*
    section. The updated version of the `create_spaceship()` method will look like
    this after these changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Great! With that, whenever a player jumps into the game, their spaceship will
    change its sprite to the custom sprite the player uploaded, if any. Now, we need
    to also make this happen to the spaceships that were already in the game world
    when the player joined. For that, we need to make some changes in the `_on_players_multiplayer_spawner_spawned()`
    callback. Still in the `res://09.prototyping- space-adventure/Levels/World.gd`
    script, let’s implement the changes by moving on to the `_on_players_multiplayer_spawner_spawned()`
    method and go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s revamp the whole logic of this callback and make it from scratch. We
    are going to start by creating a variable to store the player’s peer ID, which
    we can get by turning the recently spawned node’s name into an integer. Node names
    are `StringNames` so they are not pure strings, meaning we need to turn them into
    default strings before turning them into integers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we will make the global RPC to the `setup_multiplayer()` method,
    just as we did before, but now we pass `player_id` as the argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then comes the interesting part. After making this RPC, if the spawned node,
    in other words the spawned player, happens to be in another player’s game instance,
    instead of the server’s instance, we will also make an RPC directly to the server,
    asking it to sync this spaceship using a method (which we are going to create
    soon) called `sync_spaceship()`, which receives a player ID as its argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s move on to the `sync_spaceship()` method now. Let’s create this method
    with an RPC annotation that will allow any peer to remotely call it and it will
    also be called locally on the server. Remember, this method receives `player_id`
    as its argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `sync_spaceship()` method, we will first and foremost store a reference
    to the ID of whoever made the RPC to this function. This will allow us to make
    the `rpc_id()` method call directly to the player that just joined the game, instead
    of making a call to every player every time a player joins the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will find the correct player in the `Players` node children by using
    the `get_node()` method and appending the `player_id`. Remember, since the `player_id`
    is also the node’s name, this is how we can easily find it among all the `Players`
    children:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we will find the player’s username. For that, we will use `player_id`
    as a key in `player_users`, which will return us the proper username:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, with the user in our hands, we can make an RPC to the `load_spaceship()`
    method on this requester''s instance of the `node` that represents the spaceship
    spawned on their instance of the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And we did it! With this in place, the game is now able to load, store, and
    sync players’ custom spaceship sprites. If you run the game now you can see the
    game caching data to decrease bandwidth and downloading and updating the players’
    spaceship sprites in real time. The following screenshot displays the before and
    after of implementing this feature.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.8 – The before and after implementing the custom sprites feature](img/Figure_13.08_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.8 – The before and after implementing the custom sprites feature
  prefs: []
  type: TYPE_NORMAL
- en: 'Something interesting that you can check if you want to measure how much difference
    caching makes is to remove the statements that check whether the files exist in
    the `user://.cache/` folder and add a Monitor to monitor the `TextureDownloadHTTPRequest`
    and `SpaceshipsDatabaseDownloadHTTPRequest` downloaded bytes. For that, you can
    use the `HTTPRequest.get_downloaded_bytes()` method. For instance, the following
    code snippet displays how we can create a Monitor in the `TextureDownloadHTTPRequest`
    node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And with that, we can test our game multiple times to simulate players logging
    in and out of the game and see how the caching impacts each stage. Something you
    will notice is that after the images have been cached, they are almost instantaneously
    updated when players log in to the game again. The following screenshot displays
    the actual impact on the network usage in bytes before and after caching the images
    in the player’s machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.9 – A comparison between the network consumption the first time
    the player downloads the textures and after caching the textures in their machine](img/Figure_13.09_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.9 – A comparison between the network consumption the first time the
    player downloads the textures and after caching the textures in their machine
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we saw how to implement database caching for custom spaceship
    sprites in our game. The `World` scene is responsible for synchronizing the game
    world, including the players’ spaceship sprites. So, we made some changes to it
    to achieve the caching we’ve implemented in previous sections. We saw how to use
    the `SpaceshipsDatabaseDownloadHTTPRequest` node to download the spaceships database
    and make RPCs to update players’ spaceship sprites and sync spaceship sprites
    when players join the game. At the end of the section, we used a Monitor and the
    `HTTPRequest.get_downloaded_bytes()` method to see how caching reduces bandwidth
    usage and improves network efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Note the number of bytes saved in *Figure 13**.9* with only two textures cached!
    Imagine, in the long run, how this could impact hundreds and even thousands of
    players as they log in and out of the game multiple times a day. And we are only
    talking about textures here. What else can we cache and effectively save hundreds
    of thousands of network bytes on? Well, that’s what we are going to see in the
    upcoming section.
  prefs: []
  type: TYPE_NORMAL
- en: Going further with caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, as we saw, images are not the only type of data we can download through
    the internet using the `HTTPRequest` node; for instance, we also downloaded the
    `PlayersSpaceship.json` file, which is a text file. But we can download pretty
    much anything using this protocol, provided it is stored in an HTTP page. But
    sometimes, some files are not stored and made available publicly on an HTTP page
    that any browser can access. Usually in this type of situation, the backend engineer
    will create a REST API that we can use to retrieve these files directly from the
    database where they are stored.
  prefs: []
  type: TYPE_NORMAL
- en: This type of feature demands a physical infrastructure and the development of
    a custom REST API so we can work with it. Unfortunately, this goes way beyond
    the scope of this book. But the whole idea is that you can perform an HTTP request
    using custom headers and a custom URL that resembles an RPC. So, in the very URL
    itself you would add some parameters that the REST API would interpret as a method
    call and arguments. It’s very similar to what we did in [*Chapter 2*](B18527_02.xhtml#_idTextAnchor037)*,*
    *Sending and Receiving Data*, and REST APIs usually use JSON-formatted strings
    as the main data structure as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, you can check out a series on my YouTube channel that relies
    heavily on REST APIs to integrate a third-party service into a game of mine called
    *Moon Cheeser*. The REST API is provided by *LootLocker* and at some point, I
    download a whole `PacketScene` from their server to cache it in the player’s machine
    and allow them to always have a copy of their purchased skin. You can check this
    particular video at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://youtu.be/w0qz-pJMIBo?si=WF2KH9-FRyO8glVq](https://youtu.be/w0qz-pJMIBo?si=WF2KH9-FRyO8glVq)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, I’m going to use LootLocker’s public API as an example here too. This
    is the HTTP request I used to retrieve the file associated with the skin the player
    purchases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This translates into the following `GDScript` code, using an `HTTPRequest`
    node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now comes the interesting part that we haven’t explored yet. The `HTTPRequest.request_completed`
    signal is emitted when this request is completed and the server gives a response
    to the client with some very interesting data, including the response’s body,
    which usually is a JSON file containing the URL to the file we want. So, you can
    connect this signal to a signal callback and access the response’s body to get
    access to what the server provides you with regarding the request. This can go
    from the content of a file itself to a JSON file containing much more information,
    including the URL to download the file you want.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid going off on a tangent here, I highly recommend you watch the video
    and understand how we download a resource-intensive file. In this case, I downloaded
    a custom `PackedScene` instance together with its dependencies, such as an image
    necessary to make the purchased skin display properly, and cached it into players’
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: With this in your hands, you can implement all sorts of caching and save tons
    of resource usage, both for your players and your server, since it won’t be constantly
    delivering the same files to the same clients repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, it’s time to wrap this chapter up! In this chapter, we discussed what
    caching is and how it allows us to save bandwidth. We learned how to implement
    it for custom spaceship sprites in our game. For that, we saw how we can use the
    `HTTPRequest` node to download files over the internet by making HTTP requests.
    We also implemented a custom Monitor to see how much data we saved throughout
    a play session by caching textures. Finally, we saw how caching can go beyond
    image and text files and the possibility of using REST APIs to download all sorts
    of files using HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: With that, my fellow Godot Engine developers, we reach the end of our journey!
  prefs: []
  type: TYPE_NORMAL
- en: 'We started as people who didn’t know how to send a simple message to another
    computer, and became fully fledged network engineers ready to create the games
    of our dreams and allow players to have a shared experience, enjoy their time
    together, and build communities around the world. Congratulations on completing
    this journey. You are now capable of one of the most amazing things any human
    being can do: to connect people together toward a shared goal.'
  prefs: []
  type: TYPE_NORMAL
- en: This is my farewell. I’m very proud of what we went through, and I hope you
    use this power for good. You can definitely expect more from me to come. But for
    now, that’s it.
  prefs: []
  type: TYPE_NORMAL
- en: Thank you so much for reading. Keep developing, and until the next time!
  prefs: []
  type: TYPE_NORMAL
