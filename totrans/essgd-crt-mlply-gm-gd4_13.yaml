- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Caching Data to Decrease Bandwidth
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存数据以减少带宽
- en: 'When it comes to reducing bandwidth usage and optimizing network usage in game
    development, there is a powerful technique that always comes to mind: caching.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，谈到减少带宽使用和优化网络使用，总会想到一种强大的技术：缓存。
- en: Caching solves the question of why we should keep downloading the same data
    repeatedly when we can download it once, store it somewhere, and reuse it whenever
    needed. In this chapter, we will delve into caching techniques and learn how to
    apply them to efficiently download, store, and reuse images and other relevant
    data. For that, we will use a database that contains image URLs that we are going
    to download directly from the internet into our players’ machines.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存解决了这样一个问题：为什么我们可以在下载一次后，将其存储在某个地方，并在需要时重复使用，而无需反复下载相同的数据。在本章中，我们将深入研究缓存技术，并学习如何将它们应用于高效下载、存储和重复使用图像和其他相关数据。为此，我们将使用一个包含图像URL的数据库，我们将直接从互联网将其下载到玩家的机器中。
- en: To demonstrate the implementation of these caching techniques, we will prototype
    a new feature in our game project, where players will have the ability to upload
    custom images for their spaceships. To save time and focus solely on the network
    aspect of this feature, we will avoid implementing user experience and user interface
    aspects, leaving those tasks to the talented individuals in our imaginary indie
    studio. Your role, as a developer, will be to tackle the network-related aspects
    of this feature and ensure its seamless integration.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这些缓存技术的实现，我们将在我们的游戏项目中原型化一个新功能，玩家将能够上传自定义图像作为他们的飞船。为了节省时间并专注于这一功能的网络方面，我们将避免实现用户体验和用户界面方面，将这些任务留给我们想象中的独立工作室中的才华横溢的个体。作为开发者，您的角色将是处理这一功能的网络相关方面，并确保其无缝集成。
- en: In the following screenshot, you can witness the exciting results of this feature
    in action. Two players are engaging in the game with their own custom spaceship
    sprites, which have been downloaded from the server. These sprites are sourced
    from Twemoji, an open source repository of Creative Commons-licensed emojis maintained
    by Twitter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您可以见证这一功能在实际操作中的激动人心的结果。两位玩家正在使用从服务器下载的个性化飞船精灵进行游戏。这些精灵来自Twemoji，这是一个由Twitter维护的Creative
    Commons许可的开源表情符号仓库。
- en: '![Figure 13.1 – The custom spaceship sprites downloaded from the server for
    the two players](img/Figure_13.01_B18527.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1 – 为两位玩家从服务器下载的个性化飞船精灵](img/Figure_13.01_B18527.jpg)'
- en: Figure 13.1 – The custom spaceship sprites downloaded from the server for the
    two players
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – 为两位玩家从服务器下载的个性化飞船精灵
- en: 'The topics covered in this chapter are as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题如下：
- en: Understanding caching
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解缓存
- en: Setting up the `HTTPRequest` node
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置`HTTPRequest`节点
- en: Implementing texture caching
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现纹理缓存
- en: Implementing database caching
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现数据库缓存
- en: Going further with caching
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存的进一步应用
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'It is worth mentioning that this chapter builds upon the concepts presented
    in [*Chapter 10*](B18527_10.xhtml#_idTextAnchor260), *Debugging and Profiling
    the Network*, as well as the project developed in [*Chapter 9*](B18527_09.xhtml#_idTextAnchor188),
    *Creating an Online Adventure Prototype*. Therefore, it is crucial to familiarize
    yourself with the concepts and techniques discussed in those chapters to fully
    grasp the optimization methods presented here. We will also build upon the final
    project from [*Chapter 12*](B18527_12.xhtml#_idTextAnchor285), *Implementing Lag
    Compensation*, for which you can get the files through the following link:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，本章建立在第10章中提出的概念之上，即*调试和性能分析网络*，以及第9章中开发的项目，即*创建在线冒险原型*。因此，熟悉那些章节中讨论的概念和技术对于完全理解这里提出的优化方法至关重要。我们还将基于第12章的最终项目，即*实现延迟补偿*，您可以通过以下链接获取文件：
- en: '[https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/tree/12.prediction-and-interpolation](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/tree/12.prediction-and-interpolation)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/tree/12.prediction-and-interpolation](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/tree/12.prediction-and-interpolation)'
- en: Moreover, throughout this chapter, it is important to have a basic understanding
    of how to upload and host content on online services. For instance, we will be
    downloading files directly from the project’s GitHub repository and from a service
    called ImgBB, a free image-hosting platform. Without understanding the mechanisms
    behind content hosting and retrieval using direct links, you may encounter difficulties
    in understanding and implementing the processes we are about to explore.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在本章中，了解如何在在线服务上上传和托管内容的基本方法是很重要的。例如，我们将直接从项目的GitHub仓库以及名为ImgBB的服务下载文件，ImgBB是一个免费图像托管平台。如果不理解使用直接链接进行内容托管和检索的机制，你可能会在理解和实施我们即将探讨的过程时遇到困难。
- en: To enrich your learning experience, I highly recommend downloading the latest
    version of the Twemoji repository, which can be obtained from [https://github.com/twitter/twemoji](https://github.com/twitter/twemoji).
    By exploring this repository, you will gain further insights into how images and
    other media content can be managed and incorporated into your game development
    projects.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了丰富你的学习体验，我强烈推荐下载Twemoji仓库的最新版本，该版本可以从[https://github.com/twitter/twemoji](https://github.com/twitter/twemoji)获取。通过探索这个仓库，你将深入了解如何管理和将图像和其他媒体内容纳入你的游戏开发项目中。
- en: That said, let’s understand what caching is and how we are going to use it in
    our game project.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们来了解什么是缓存以及我们如何在我们的游戏项目中使用它。
- en: Understanding caching
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解缓存
- en: In online multiplayer games, every second counts. Players expect seamless, real-time
    experiences without interruptions. This is where caching becomes a powerful ally
    in optimizing game performance. So, what exactly is caching, and why is it crucial
    for online multiplayer games?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在在线多人游戏中，每一秒都很宝贵。玩家期望无缝、实时的体验，没有中断。这就是缓存成为优化游戏性能的强大盟友的地方。那么，缓存究竟是什么，为什么它对在线多人游戏至关重要？
- en: '**Caching** is the process of storing frequently accessed data or resources
    on a local device or intermediate server. These resources can include images,
    sound files, 3D models, or even small snippets of code. Instead of fetching these
    resources from a remote server every time they are needed, the game stores them
    locally. When a request for these resources arises, the game checks whether it
    already has a local copy. If it does, it uses the local version, significantly
    reducing loading times and conserving precious network bandwidth.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓存**是将频繁访问的数据或资源存储在本地设备或中间服务器上的过程。这些资源可以包括图像、声音文件、3D模型，甚至是一些小的代码片段。游戏不需要每次需要这些资源时都从远程服务器获取，而是将它们存储在本地。当出现对这些资源的请求时，游戏会检查是否已经有一个本地副本。如果有，它将使用本地版本，这显著减少了加载时间并节省了宝贵的网络带宽。'
- en: 'The principle behind caching is simple yet effective: if you’ve used something
    once, it’s likely you’ll need it again. In the context of our multiplayer game,
    this means that the images, sounds, and assets that players download to customize
    their spaceships can be cached locally on their devices. When another player comes
    into view, the game can retrieve these assets from the local cache instead of
    re-downloading them. This creates a more streamlined experience and reduces the
    stress on the network.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存的原理简单而有效：如果你曾经使用过某个东西，那么你很可能还需要它。在我们多人游戏的环境中，这意味着玩家下载到他们设备上的图像、声音和资产可以被本地缓存。当另一个玩家进入视野时，游戏可以从本地缓存中检索这些资产，而不是重新下载。这创造了一个更流畅的体验，并减少了网络的压力。
- en: Caching offers numerous advantages in online multiplayer games. The most prominent
    benefit is an enhanced gaming experience. By using cached resources, players can
    swiftly interact with others, see their personalized spaceship designs, and engage
    in combat without significant delays. Reduced loading times translate to more
    fluid and immersive gameplay. Moreover, this process eases the strain on the server,
    enabling it to handle more players simultaneously.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存在线多人游戏中提供了许多优势。最突出的好处是提升了游戏体验。通过使用缓存的资源，玩家可以迅速与其他人互动，看到他们个性化的飞船设计，并参与战斗而不会出现显著的延迟。减少的加载时间意味着更流畅和沉浸式的游戏体验。此外，这个过程减轻了服务器的负担，使其能够同时处理更多的玩家。
- en: Caching is not just about speed; it’s also about efficiency. Downloading the
    same resources repeatedly not only wastes bandwidth but also makes the game less
    environmentally friendly and potentially costly for players with limited data
    plans. By caching frequently used resources, the game becomes faster, more eco-friendly,
    and cost-effective.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存不仅仅是关于速度；它还关乎效率。重复下载相同的资源不仅浪费带宽，而且使游戏对环境不那么友好，对于数据计划有限的玩家来说可能还会产生额外成本。通过缓存常用资源，游戏变得更快、更环保、更经济。
- en: In the following sections, we will explore how to leverage the powerful `HTTPRequest`
    node to implement caching for customized spaceship images. We will dive into the
    processes of downloading these images and ensuring their availability in each
    player’s cache, enhancing the online multiplayer experience. Stay tuned for a
    step-by-step guide on how to implement caching in your game.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨如何利用强大的`HTTPRequest`节点来实现自定义宇宙飞船图像的缓存。我们将深入探讨下载这些图像并确保它们在每个玩家的缓存中可用，从而增强在线多人游戏体验。敬请期待一步步指导如何在您的游戏中实现缓存。
- en: Setting up the HTTPRequest node
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置HTTPRequest节点
- en: As mentioned in the chapter’s introduction, we are going to implement a feature
    that allows players to use custom sprites on their spaceships.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如同章节引言中提到的，我们将实现一个功能，允许玩家在他们的宇宙飞船上使用自定义精灵。
- en: To prototype this feature, we will download images from a third-party image-hosting
    service that offers free image hosting. We will accomplish this by using a **Hypertext
    Transfer Protocol** (**HTTP**) request to retrieve the image file from the third-party
    servers. Let’s delve into the workings of HTTP to fully understand how it operates
    and grasp the implementation process.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了原型化这个功能，我们将从提供免费图片托管服务的第三方图片托管服务下载图片。我们将通过使用**超文本传输协议**（**HTTP**）请求从第三方服务器检索图片文件来实现这一点。让我们深入了解HTTP的工作原理，以全面理解其操作并掌握实现过程。
- en: Understanding the HTTP protocol
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解HTTP协议
- en: '**HTTP** serves as the foundation for communication on the **World Wide Web**.
    It is a protocol that defines the interaction and data exchange between clients
    and servers. Invented by Tim Berners-Lee in the early 1990s, HTTP was initially
    designed to facilitate the retrieval of hypertext documents, commonly known as
    web pages. Over time, it has evolved to support various types of content, including
    images, videos, and files.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTTP**是万维网通信的基础。它是一种定义客户端和服务器之间交互和数据交换的协议。由蒂姆·伯纳斯-李在20世纪90年代初发明，HTTP最初是为了方便检索超文本文档，也就是我们常说的网页。随着时间的推移，它已经发展支持各种类型的内容，包括图片、视频和文件。'
- en: When a client, such as our player, wants to retrieve a resource from a server,
    it initiates an HTTP request. This request consists of a method that specifies
    the desired action to be performed on the resource, along with a `GET`, `POST`,
    `PUT`, and `DELETE`. In the context of downloading images, the `GET` method is
    what we typically employ.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端，比如我们的玩家，想要从服务器检索资源时，它会发起一个HTTP请求。这个请求包含一个方法，指定了对资源要执行的操作，以及`GET`、`POST`、`PUT`和`DELETE`。在下载图片的上下文中，我们通常使用`GET`方法。
- en: Upon receiving the HTTP request, the server processes it and prepares an HTTP
    response. This response contains the requested resource, accompanied by metadata
    such as the HTTP status code, content type, and content length.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器在接收到HTTP请求后，会处理它并准备一个HTTP响应。这个响应包含请求的资源，并伴随HTTP状态码、内容类型和内容长度等元数据。
- en: Additionally, the server includes headers in the response to provide further
    information or instructions to the client.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，服务器在响应中包含头部信息，以提供更多信息或指令给客户端。
- en: To download images using HTTP, the client sends a `GET` request to the server,
    specifying the URL of the image. The server then processes this request and sends
    back an HTTP response that contains the image data. The client receives this response
    and interprets it to display the image to the user.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用HTTP下载图片，客户端向服务器发送一个指定图片URL的`GET`请求。服务器处理这个请求，然后发送一个包含图片数据的HTTP响应。客户端接收这个响应，并将其解释为向用户显示图片。
- en: HTTP operates as a stateless protocol, meaning that each request-response cycle
    is independent and does not retain any information about previous interactions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP作为一个无状态协议运行，这意味着每个请求-响应周期都是独立的，并且不会保留任何关于之前交互的信息。
- en: However, mechanisms such as cookies and session management can be employed to
    maintain state and enable more complex interactions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可以使用诸如cookies和会话管理等机制来维护状态并启用更复杂的交互。
- en: In summary, HTTP serves as the protocol that facilitates communication between
    clients and servers on the web. It enables us to download images and other resources
    by sending HTTP requests to servers and receiving HTTP responses that contain
    the requested data. Understanding the workings of HTTP is essential for implementing
    features such as downloading images in our game project.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，HTTP作为协议，促进了客户端和服务器之间的通信。它使我们能够通过向服务器发送HTTP请求并接收包含所需数据的HTTP响应来下载图像和其他资源。理解HTTP的工作原理对于实现如在我们游戏项目中下载图像等特性至关重要。
- en: The reason we are going to use HTTP requests is because the types of files we
    want to cache are fairly large compared to the kind of data we usually transfer
    using `HTTPRequest` nodes and a minimal database where we will pair the players’
    usernames and the URLs of their custom spaceship sprites. This database is intended
    to go on the server side and be cached in the player’s machine later, as we will
    see in the *Implementing database* *caching* section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用HTTP请求的原因是，我们想要缓存的文件类型相对于我们通常使用`HTTPRequest`节点和最小数据库（我们将匹配玩家的用户名和他们的自定义飞船精灵的URL）传输的数据类型来说相当大。这个数据库打算放在服务器端，并在稍后缓存在玩家的机器上，正如我们将在*实现数据库*
    *缓存*部分中看到的那样。
- en: Setting up the scenes and database
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置场景和数据库
- en: Let’s begin setting up the scenes and database.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始设置场景和数据库。
- en: To create our database, let’s open the `res://09.prototyping-space-adventure/`
    folder and create a new text file. You can quickly do that by right-clicking the
    folder in the **FileSystem** dock. The following screenshot displays the menu
    that pops up. From there, select **New** | **TextFile...**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的数据库，让我们打开`res://09.prototyping-space-adventure/`文件夹并创建一个新的文本文件。你可以通过在**FileSystem**窗口中右键单击文件夹来快速完成此操作。下面的截图显示了弹出的菜单。从那里，选择**新建**
    | **文本文件...**。
- en: '![Figure 13.2 – Creating a new text file directly through the FileSystem dock](img/Figure_13.02_B18527.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图13.2 – 通过FileSystem窗口直接创建新文本文件](img/Figure_13.02_B18527.jpg)'
- en: Figure 13.2 – Creating a new text file directly through the FileSystem dock
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 – 通过FileSystem窗口直接创建新文本文件
- en: 'Then, create a file named `PlayerSpaceships.json`, as shown in the following
    screenshot:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个名为`PlayerSpaceships.json`的文件，如下面的截图所示：
- en: "![Figure 13.3 – Creating a new text file named PlayerSpaceship\uFEFFs.json](img/Figure_13.03_B18527.jpg)"
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图13.3 – 创建一个名为PlayerSpaceships.json的新文本文件](img/Figure_13.03_B18527.jpg)'
- en: Figure 13.3 – Creating a new text file named PlayerSpaceships.json
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 – 创建一个名为PlayerSpaceships.json的新文本文件
- en: 'Now, regarding the content, we are going to maintain the users from the `PlayerSpaceships.json`
    file will look like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于内容，我们将从`PlayerSpaceships.json`文件中维护的用户内容将如下所示：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that you can experiment with other images and hosting services. As long
    as you have the image’s direct link, usually pointing to the `.png` file, you
    will be good.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以尝试使用其他图像和托管服务。只要你有图像的直接链接，通常指向`.png`文件，你就没问题了。
- en: 'Now, it’s time to set up the `HTTPRequest` nodes. We are going to start by
    downloading the `PlayerSpaceships.json` file from the server. In our case, this
    file is hosted on GitHub, but you can store it on another server as long as you
    have a direct link to the actual database file. In our case you can find it here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候设置`HTTPRequest`节点了。我们将从从服务器下载`PlayerSpaceships.json`文件开始。在我们的例子中，这个文件托管在GitHub上，但你可以在任何其他服务器上存储它，只要你有指向实际数据库文件的直接链接。在我们的例子中，你可以在这里找到它：
- en: '[raw.githubusercontent.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/13.caching-data/source/09.prototyping-space-adventure/PlayerSpaceships.json](http://raw.githubusercontent.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/13.caching-data/source/09.prototyping-space-adventure/PlayerSpaceships.json)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[raw.githubusercontent.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/13.caching-data/source/09.prototyping-space-adventure/PlayerSpaceships.json](http://raw.githubusercontent.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/13.caching-data/source/09.prototyping-space-adventure/PlayerSpaceships.json)'
- en: 'With the `PlayerSpaceships.json` file up on the internet, let’s see how we
    can download it to our players’ machines with the following steps:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当`PlayerSpaceships.json`文件已上传到互联网上时，让我们看看如何通过以下步骤将其下载到玩家的机器上：
- en: Create a new scene and use an `HTTPRequest` node as the root node.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的场景，并使用`HTTPRequest`节点作为根节点。
- en: Rename it to `SpaceshipsDatabaseDownloadHTTPRequest`, as this node will be responsible
    for downloading the database from the internet.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其重命名为 `SpaceshipsDatabaseDownloadHTTPRequest`，因为这个节点将负责从互联网下载数据库。
- en: Attach a new script to this node and save the scene and the script. Here I saved
    them directly as `res://09.prototyping-space-` `adventure/SpaceshipsDatabaseDownloadHTTPRequest`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个新的脚本附加到这个节点上，并保存场景和脚本。在这里，我直接将它们保存为 `res://09.prototyping-space-` `adventure/SpaceshipsDatabaseDownloadHTTPRequest`。
- en: 'Now, open the script, and let’s do the following:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开脚本，让我们做以下操作：
- en: 'Create an exported variable for the path to the folder that we will use for
    caching. Here it’s important to use the `user://` data folder path so Godot Engine
    properly adapts the path depending on the platform the game is running on:'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个导出变量，用于存储我们将用于缓存的文件夹路径。在这里，使用 `user://` 数据文件夹路径非常重要，这样 Godot 引擎可以正确地根据游戏运行的平台调整路径：
- en: '[PRE1]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, create a new exported variable that should point to where the database
    file is going to be saved. Let’s keep its default filename and put it into the
    `cache` folder:'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个新的导出变量，它应该指向数据库文件将要保存的位置。让我们保持其默认文件名，并将其放入 `cache` 文件夹：
- en: '[PRE2]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After that, we can export yet another variable. But now we need to store the
    link of the location where the `PlayerSpaceships.json` file will be downloaded
    from:'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以导出另一个变量。但现在我们需要存储 `PlayerSpaceships.json` 文件下载位置的链接：
- en: '[PRE3]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With that, we can move on to the actual downloading method. Create a new method
    called `download_spaceships_database()` and let’s start its implementation.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了这些，我们可以继续到实际的下载方法。创建一个新的方法，命名为 `download_spaceships_database()`，然后开始它的实现。
- en: 'The first thing we are going to do here is to check whether there’s a cache
    directory already. If we don’t have it yet, we will create it:'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这里要做的第一件事是检查是否已经存在缓存目录。如果没有，我们将创建它：
- en: '[PRE4]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, we will check whether the `PlayerSpaceships.json` file exists. If it
    doesn’t, we will start the actual download. The first thing to start the download
    is to set the file path in the `download_file` member variable:'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将检查 `PlayerSpaceships.json` 文件是否存在。如果不存在，我们将开始实际的下载。开始下载的第一件事是在 `download_file`
    成员变量中设置文件路径：
- en: '[PRE5]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With `download_file` set, we can make the request to the file. For that, we
    will use the `request()` method, which asks for a URL. This method uses the `GET`
    method by default to make requests, which is what we want in this case. But you
    can change this in the third argument, right after passing some custom headers
    if you want. We don’t have to pass anything other than the URL in our case:'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置好 `download_file` 之后，我们可以向文件发出请求。为此，我们将使用 `request()` 方法，该方法请求一个 URL。这个方法默认使用
    `GET` 方法来发出请求，这正是我们想要的。但如果你想在传递一些自定义头信息后更改这个设置，你可以在第三个参数中更改它。在我们的情况下，我们不需要传递除了
    URL 之外的其他任何内容：
- en: '[PRE6]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After that, we need to wait for the request to finish. Remember, since this
    is an asynchronous procedure, the game needs to wait for it to complete before
    moving on to any logic that depends on this file:'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要等待请求完成。记住，由于这是一个异步过程，游戏需要在继续到任何依赖于这个文件的逻辑之前等待它完成：
- en: '[PRE7]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After following the preceding steps, we should have our `SpaceshipsDatabaseDownloadHTTPRequest`
    working. If you want to, you can test it out. For that, call the `download_spaceship_database()`
    method in the `_ready()` callback and run the scene. After that, if you open the
    user data folder, you will see the `.cache/` folder and if you enter this folder
    you should find the `PlayerSpaceships.json` file there. Note that in this case
    the `.cache/` is a hidden folder, so make sure you can see hidden folders in your
    file manager. To quickly open the user data folder, you can go to **Project**
    | **Open User Data Folder**, as shown in the following screenshot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循前面的步骤之后，我们应该让 `SpaceshipsDatabaseDownloadHTTPRequest` 开始工作。如果你想测试它，可以在 `_ready()`
    回调中调用 `download_spaceship_database()` 方法并运行场景。之后，如果你打开用户数据文件夹，你会看到 `.cache/` 文件夹，如果你进入这个文件夹，你应该在那里找到
    `PlayerSpaceships.json` 文件。注意，在这种情况下，`.cache/` 是一个隐藏文件夹，所以请确保你可以在文件管理器中看到隐藏文件夹。要快速打开用户数据文件夹，你可以转到
    **项目** | **打开用户数据文件夹**，如图下所示：
- en: "![Figure 13.4 - Open\uFEFF User Data Folder from the Editor’s Project tab](img/Figure_13.04_B18527.jpg)"
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.4 - 从编辑器的项目标签页打开用户数据文件夹](img/Figure_13.04_B18527.jpg)'
- en: Figure 13.4 - Open User Data Folder from the Editor’s Project tab
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4 - 从编辑器的项目标签页打开用户数据文件夹
- en: 'Now, let’s create the `TextureDownloadHTTPRequest` scene so we can use the
    data in `PlayerSpaceships.json` to effectively download the players’ custom spaceship
    sprites. For that, follow these steps:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个名为`TextureDownloadHTTPRequest`的场景，这样我们就可以使用`PlayerSpaceships.json`中的数据来有效地下载玩家的自定义飞船精灵。为此，请按照以下步骤操作：
- en: Create a new scene and use an `HTTPRequest` node as root.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的场景，并使用一个`HTTPRequest`节点作为根节点。
- en: Rename it `TextureDownloadHTTPRequest` as this is the one actually responsible
    for downloading the textures from the internet.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其重命名为`TextureDownloadHTTPRequest`，因为这个才是真正负责从互联网下载纹理的：
- en: 'Save the scene as `res://09.prototyping-space-` `adventure/TextureDownloadHTTPRequest.tscn`
    and attach a script to it, then in the script let’s do the following:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将场景保存为`res://09.prototyping-space-` `adventure/TextureDownloadHTTPRequest.tscn`，并将其附加到一个脚本上，然后在脚本中执行以下操作：
- en: 'Export a variable that should point to the `PlayerSpaceships.json` file in
    the player’s machine, so this path should use the `user://` file path:'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出一个变量，该变量应指向玩家机器上的`PlayerSpaceships.json`文件，因此此路径应使用`user://`文件路径：
- en: '[PRE8]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create a new method called `download_spaceship()`. This method should receive
    two arguments, one for the user and another one for the file path where the sprite
    will be saved:'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`download_spaceship()`的新方法。此方法应接收两个参数，一个用于用户，另一个用于精灵将被保存的文件路径：
- en: '[PRE9]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, inside this method, we will create a new `Dictionary` called `players_spaceships`,
    which will start empty but will soon store the content from the `PlayerSpaceships.json`
    file:'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在这个方法内部，我们将创建一个新的名为`players_spaceships`的`Dictionary`，它将开始为空，但很快将存储来自`PlayerSpaceships.json`文件的内容：
- en: '[PRE10]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we are going to check whether the file provided by the `spaceships_database_file`
    path exists. If it does, we will open it, convert it to a string using `FileAccess.get_as_text()`
    , and parse it from JSON format to `Dictionary` object format, storing it in the
    `players_spaceships` variable:'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将检查由`spaceships_database_file`路径提供的文件是否存在。如果存在，我们将打开它，使用`FileAccess.get_as_text()`将其转换为字符串，并从JSON格式解析为`Dictionary`对象格式，将其存储在`players_spaceships`变量中：
- en: '[PRE11]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After that, we can download the `user` sprite based on the URL provided by
    the `PlayerSpaceships.json` database and store it in the file path provided by
    the `sprite_file` argument. For that, we will use `HTTPRequest.download_file`
    and download it using the `HTTPRequest.request()` method. Note that this method
    returns an error if the request has any issues. Let’s store this in an `error`
    variable to allow other classes to verify whether the request was successful:'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们可以根据`PlayerSpaceships.json`数据库提供的URL下载`user`精灵，并将其存储在`sprite_file`参数提供的文件路径中。为此，我们将使用`HTTPRequest.download_file`和`HTTPRequest.request()`方法来下载。请注意，如果请求有任何问题，此方法会返回错误。让我们将其存储在`error`变量中，以便其他类可以验证请求是否成功：
- en: '[PRE12]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Since HTTP requests may take some time to finish downloading the content requested,
    we need to wait for the `HTTPRequest.request_completed` signal before ending the
    function and returning the error. Note that if the function doesn’t reach any
    of these conditional statements, we should return `FAILED` to acknowledge to other
    classes that `spaceships_database_file` doesn’t exist or `user` doesn’t exist
    in the database:'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于HTTP请求可能需要一些时间才能完成内容的下载，我们需要在结束函数并返回错误之前等待`HTTPRequest.request_completed`信号。请注意，如果函数没有达到这些条件语句中的任何一个，我们应该返回`FAILED`以告知其他类`spaceships_database_file`不存在或数据库中不存在`user`：
- en: '[PRE13]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Alright, this ends our journey to set up HTTPRequests. We created the database
    and the two nodes responsible for working on its data, downloading the database
    to the players’ machines, and downloading the content in the database as well,
    in this case, the players’ spaceships’ custom sprites. You can test the scene
    as well by calling the `download_spaceship()` method using `"user1"` and `"user://.cache/user1_spaceship.png"`
    as arguments. Just make sure that you’ve run the `SpaceshipDatabaseDownloadHTTPRequest`
    scene first so the `PlayersSpaceships.json` file exists in the `user://.cache/`
    folder. With that, you should see a new image downloaded right in your user data
    folder! The following screenshot shows what my `user://.cache/` folder looks like:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这就结束了我们设置HTTPRequests的旅程。我们创建了数据库和两个负责处理其数据的节点，将数据库下载到玩家的机器上，以及下载数据库中的内容，在这种情况下，是玩家的飞船自定义精灵。您也可以通过使用`"user1"`和`"user://.cache/user1_spaceship.png"`作为参数调用`download_spaceship()`方法来测试场景。只需确保您已经运行了`SpaceshipDatabaseDownloadHTTPRequest`场景，这样`PlayersSpaceships.json`文件就存在于`user://.cache/`文件夹中。有了这个，您应该会在用户数据文件夹中看到一个新的图像被下载！以下截图显示了我的`user://.cache/`文件夹的样子：
- en: "![Figure 13.5 – The \uFEFFuser data folder with the Player\uFEFFSpaceships.json\
    \ file and user1’s custom spaceship sprite](img/Figure_13.05_B18527.jpg)"
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图13.5 – 包含PlayerSpaceships.json文件和用户1自定义飞船精灵的用户数据文件夹](img/Figure_13.05_B18527.jpg)'
- en: Figure 13.5 – The user data folder with the PlayerSpaceships.json file and user1’s
    custom spaceship sprite
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5 – 包含PlayerSpaceships.json文件和用户1自定义飞船精灵的用户数据文件夹
- en: In this section, we learned about the usage of HTTP requests for caching data
    and downloading images in the user data folder. We saw the difference between
    UDP and HTTP when it comes to transferring large files such as images and how
    to use the `HTTPRequest` node to use the HTTP protocol in Godot and transfer data
    from the internet to our machine.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用HTTP请求在用户数据文件夹中缓存数据和下载图像。我们看到了UDP和HTTP在传输大型文件（如图像）时的区别，以及如何使用`HTTPRequest`节点在Godot中使用HTTP协议并将数据从互联网传输到我们的机器。
- en: In the upcoming section, we will discuss the implementation of texture caching
    in the game itself, allowing for real-time changes to the players’ spaceships.
    This feature will be achieved by using the `HTTPRequest` nodes we created and
    our minimal database to get the URLs of the players’ custom spaceship sprites.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论在游戏中实现纹理缓存的方法，允许实时更改玩家的飞船。这个功能将通过使用我们创建的`HTTPRequest`节点和我们的最小数据库来获取玩家自定义飞船精灵的URL来实现。
- en: Implementing texture caching
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现纹理缓存
- en: In the previous section, we introduced the `HTTPRequest` node, a built-in solution
    offered by Godot Engine to make HTTP requests. Then we created `TextureDownloadHTTPRequest`,
    which is a custom node specialized in downloading images from our `PlayersSpaceship.json`
    database. Now, let’s dive deeper into integrating this node into our `Player2D`
    class so we can actually use it in our prototype.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们介绍了`HTTPRequest`节点，这是Godot引擎提供的内置解决方案，用于进行HTTP请求。然后我们创建了`TextureDownloadHTTPRequest`，这是一个专门用于从我们的`PlayersSpaceship.json`数据库下载图像的自定义节点。现在，让我们深入了解将此节点集成到我们的`Player2D`类中，以便我们可以在原型中实际使用它。
- en: In this section, we will create a method to enable the server to change a player’s
    spaceship sprite dynamically. But we won’t just load any sprite; we’ll fetch the
    proper file from the `user://.cache/` folder we set up in the *Setting up the
    scenes and database* section. This approach will enhance the customization and
    interaction in your game, allowing the server to deliver custom sprites to players
    in real time.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个方法，使服务器能够动态地更改玩家的飞船精灵。但我们将不会加载任何精灵；我们将从我们在*设置场景和数据库*部分设置的`user://.cache/`文件夹中获取正确的文件。这种方法将增强游戏中的定制和交互，允许服务器实时向玩家发送自定义精灵。
- en: 'To achieve this, we’ll create a method called `load_spaceship()`. This method
    will play a fundamental role in our implementation. It will be an RPC function
    that the server can trigger remotely for specific players. Well, let’s get started!
    Open the `res://09.prototyping-space-adventure/Actors/Player/Player2D.tscn` scene
    and work through the following steps:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将创建一个名为`load_spaceship()`的方法。这个方法将在我们的实现中扮演基本角色。它将是一个RPC函数，服务器可以远程触发以针对特定玩家。好吧，让我们开始吧！打开`res://09.prototyping-space-adventure/Actors/Player/Player2D.tscn`场景，并按照以下步骤进行操作：
- en: Let’s start by adding an instance of `TextureDownloadHTTPRequest` directly as
    a child of the `Player` node.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先添加一个`TextureDownloadHTTPRequest`实例，直接作为`Player`节点的子节点。
- en: "![Figure 13.6 – \uFEFFTextureDownloadHTTPRequest instantiated in the Player\
    \ scene](img/Figure_13.06_B18527.jpg)"
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图13.6 – 在玩家场景中实例化的TextureDownloadHTTPRequest](img/Figure_13.06_B18527.jpg)'
- en: Figure 13.6 – TextureDownloadHTTPRequest instantiated in the Player scene
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6 – 在玩家场景中实例化的TextureDownloadHTTPRequest
- en: Then, open the `res://09.prototyping-space-adventure/Actors/Player/Player2D.gd`
    script.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开`res://09.prototyping-space-adventure/Actors/Player/Player2D.gd`脚本。
- en: 'Let’s store a reference to the `TextureDownloadHTTPRequest` node. We can call
    it just `http_request` for short:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们存储对`TextureDownloadHTTPRequest`节点的引用。我们可以简称为`http_request`：
- en: '[PRE14]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, right below the `setup_multiplayer()` method, let’s create the `load_spaceship()`
    method. It will be an RPC method that should only be remotely callable by the
    server and should also be called locally, so the server also updates the image.
    This method receives the user, which loads the spaceship:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`setup_multiplayer()`方法下面，让我们创建`load_spaceship()`方法。它将是一个RPC方法，只能由服务器远程调用，并且也应该在本地调用，因此服务器也会更新图像。此方法接收用户，加载飞船：
- en: '[PRE15]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, inside this method, we are going to create the file path to the spaceship
    texture file in the player’s machine and store it in a variable called `spaceship_file`.
    This file path is composed of the `"user://.cache/"` string, followed by the `user`
    value we got as an argument, and we will append `"_spaceship.png"` to create the
    proper file path with an image extension:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在这个方法内部，我们将创建玩家机器中飞船纹理文件的文件路径并将其存储在一个名为 `spaceship_file` 的变量中。这个文件路径由 `"user://.cache/"`
    字符串组成，后面跟着我们作为参数获取的 `user` 值，然后我们将追加 `"_spaceship.png"` 以创建带有图像扩展名的正确文件路径：
- en: '[PRE16]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With a proper file path to work with, the next step is to see whether this
    file already exists because the whole idea of caching data is that, if it already
    exists in the player’s machine, we can load it instead of re-downloading it and
    reduce resource consumption. The following code checks whether the file exists.
    If it does, we call the `update_sprite()` method passing `spaceship_file` as an
    argument. We are going to create the `update_sprite()` method in a moment:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在有了合适的文件路径后，下一步是查看该文件是否已经存在，因为缓存数据的整个想法是，如果它在玩家的机器中已经存在，我们可以加载它而不是重新下载它，从而减少资源消耗。以下代码检查文件是否存在。如果存在，我们将传递
    `spaceship_file` 作为参数调用 `update_sprite()` 方法。我们将在稍后创建 `update_sprite()` 方法：
- en: '[PRE17]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, `TextureDownloadHTTPRequest` will play its role. If the file doesn’t exist
    in the cache folder, we call the `TextureDownloadHTTPRequest.download_texture()`
    method and wait for it to finish; remember, it’s an asynchronous method. And if
    this method returns an `OK` error, meaning there’s actually no error, we also
    call the `update_sprite()` method so the game performs the procedures to effectively
    update the spaceship’s sprite. The following code checks whether the `update_sprite()`
    method returns anything other than `OK`. If the `update_sprite()` method doesn’t
    return `OK`, it means no sprite will be loaded. Since the custom sprite doesn’t
    affect the player’s core experience, we can just assume we can keep the default
    sprite and let the game run:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`TextureDownloadHTTPRequest` 将发挥其作用。如果文件不在缓存文件夹中，我们将调用 `TextureDownloadHTTPRequest.download_texture()`
    方法并等待其完成；记住，这是一个异步方法。如果这个方法返回一个 `OK` 错误，意味着实际上没有错误，我们也会调用 `update_sprite()` 方法，以便游戏执行更新飞船精灵的程序。以下代码检查
    `update_sprite()` 方法是否返回除了 `OK` 以外的任何内容。如果 `update_sprite()` 方法不返回 `OK`，这意味着不会加载任何精灵。由于自定义精灵不会影响玩家的核心体验，我们可以假设我们可以保留默认精灵并让游戏运行：
- en: '[PRE18]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now let’s create the `update_sprite()` method. This is the method that effectively
    changes the `Sprite` node’s `Texture` property. It will load the image from the
    file path using the `Image.load_from_file()` method and turn it into an `ImageTexture`
    using the `ImageTexture.create_from_image()` method:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建 `update_sprite()` 方法。这是一个有效更改 `Sprite` 节点的 `Texture` 属性的方法。它将使用 `Image.load_from_file()`
    方法从文件路径加载图像，并使用 `ImageTexture.create_from_image()` 方法将其转换为 `ImageTexture`：
- en: '[PRE19]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this section, we saw how to use the `TextureDownloadHTTPRequest` node to
    download and cache the images from our database. We also saw how to dynamically
    change a player’s spaceship sprite using the cached images, loading them as image
    resources and turning them into an actual `ImageTexture` that the spaceship’s
    `Sprite2D` node can use.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何使用 `TextureDownloadHTTPRequest` 节点从我们的数据库下载和缓存图像。我们还看到了如何使用缓存的图像动态更改玩家的飞船精灵，将它们作为图像资源加载，并将它们转换为飞船的
    `Sprite2D` 节点可以使用的实际 `ImageTexture`。
- en: Now, the missing part of this process is…how we actually get the `PlayersSpaceship.json`
    database and where we call the `load_spaceship()` method. Well, that’s what we
    are going to do in the next section!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个过程的缺失部分是…我们实际上是如何获取 `PlayersSpaceship.json` 数据库以及我们调用 `load_spaceship()`
    方法的。嗯，这正是我们将在下一节要做的事情！
- en: Implementing database caching
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现数据库缓存
- en: With everything in place, it is time to go one step above and work on the `World`
    scene that is going to glue everything together and run the proper procedures
    to ensure that all players will see the same custom sprites. We do that in this
    node because this is the class responsible for setting up everything related to
    world synchronization, which includes the players’ spaceship custom sprites. We
    will need to make some changes in some core methods to achieve that, but this
    is for the better.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一切就绪后，是时候再进一步，着手于将一切粘合在一起的 `World` 场景，并运行适当的程序以确保所有玩家都能看到相同的自定义精灵。我们在这个节点中这样做，因为这是一个负责设置与世界同步相关的一切的类，包括玩家的飞船自定义精灵。我们需要在一些核心方法中进行一些更改以实现这一点，但这会更好。
- en: 'Since we are working with a prototype, there’s no fear of altering function
    signatures and other core aspects of a class. But note that if this was production-ready,
    we would call this class “closed” and avoid making core changes like the ones
    we are about to make. This would keep our game code base consistent and avoid
    errors. Though the changes we are about to make will mostly extend the class functionalities,
    we will add an argument to the `World.create_spaceship()` method, breaking the
    function’s contract since it didn’t ask for any arguments before. But, as said,
    this is a prototype, and we have the freedom to tweak things as we want. So, let’s
    open the `res://09.prototyping-space-adventure/Levels/World.tscn` scene and implement
    the improvements by working through the following steps:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在处理原型，所以我们不用担心更改函数签名和类的其他核心方面。但请注意，如果这是生产就绪的，我们会称这个类为“封闭”的，并避免做出像我们即将做出的核心更改。这将保持我们的游戏代码库一致，并避免错误。尽管我们即将做出的更改将主要扩展类的功能，但我们将在
    `World.create_spaceship()` 方法中添加一个参数，由于该方法之前没有要求任何参数，这会破坏函数的契约。但，正如所说的，这是一个原型，我们有自由按自己的意愿调整事物。所以，让我们打开
    `res://09.prototyping-space-adventure/Levels/World.tscn` 场景，通过以下步骤实现改进：
- en: First things first, let’s add an instance of the `SpaceshipsDatabaseDownloadHTTPRequest`
    node as a direct child of the `World` node.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们将 `SpaceshipsDatabaseDownloadHTTPRequest` 节点的一个实例作为 `World` 节点的直接子节点添加。
- en: "![Figure 13.7 – \uFEFFSpaceshipsDatabaseDownloadHTTPRequest instantiated in\
    \ the World scene](img/Figure_13.07_B18527.jpg)"
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.7 – 在世界场景中实例化的 SpaceshipsDatabaseDownloadHTTPRequest](img/Figure_13.07_B18527.jpg)'
- en: Figure 13.7 – SpaceshipsDatabaseDownloadHTTPRequest instantiated in the World
    scene
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7 – 在世界场景中实例化的 SpaceshipsDatabaseDownloadHTTPRequest
- en: 'Then, let’s open the `res://09.prototyping-space-adventure/Levels/World.gd`
    script and start the code by adding a reference to the `SpaceshipsDatabaseDownloadHTTPRequest`
    node. We can simply call it `http_request` here as well:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们打开 `res://09.prototyping-space-adventure/Levels/World.gd` 脚本，通过添加对 `SpaceshipsDatabaseDownloadHTTPRequest`
    节点的引用来开始编写代码。在这里，我们也可以简单地将其称为 `http_request`：
- en: '[PRE20]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We will also create a new variable to store a `player_ids` and their `user`.
    This will allow us to look into this variable to find the proper username related
    to each player’s peer ID so we can easily map them in our database moving forward:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将创建一个新的变量来存储 `player_ids` 和它们的 `user`。这将允许我们查看此变量以找到与每个玩家的 peer ID 相关的正确用户名，这样我们就可以在数据库中轻松地将它们映射起来：
- en: '[PRE21]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, in the `_ready()` callback, after waiting briefly for the `0.1` `SceneTree`’s
    timer to timeout, we will wait for `http_request` to download the spaceships database
    as well. Remember, this only happens if the instance running the game isn’t the
    server:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `_ready()` 回调中，在等待 `0.1` 秒 `SceneTree` 的计时器超时后，我们将等待 `http_request` 下载飞船数据库。记住，这只有在运行游戏的实例不是服务器的情况下才会发生：
- en: '[PRE22]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Still in this `if` statement, we will make a small change. When making the RPC
    to the server’s `create_spaceship()` method, we will also pass the player’s user.
    For that, we will use the long-time-forgotten `AuthenticationCredentials` singleton!
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在这个 `if` 语句中，我们将进行一个小改动。当调用服务器的 `create_spaceship()` 方法进行 RPC 时，我们也将传递玩家的用户信息。为此，我们将使用长时间未被使用的
    `AuthenticationCredentials` 单例！
- en: '[PRE23]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Moving on to the `create_spaceship()`method, we need to, of course, change
    its function signature to support the `user` argument:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们进入 `create_spaceship()` 方法，当然，我们需要更改其函数签名以支持 `user` 参数：
- en: '[PRE24]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, before adding the `spaceship` as a child of the `Players` node, we will
    use its name (which is essentially a string version of the player’s peer ID) as
    a key in the `player_users` dictionary and set this key’s value to the `user`
    argument. With that, we effectively paired the player’s ID with their username:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在将 `spaceship` 作为 `Players` 节点的子节点之前，我们将使用其名称（这实际上是玩家 peer ID 的字符串版本）作为 `player_users`
    字典中的键，并将此键的值设置为 `user` 参数。这样，我们就有效地将玩家的 ID 与他们的用户名配对：
- en: '[PRE25]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After making the RPC to the newly instantiated player spaceship’s `setup_multiplayer()`
    method, we will make the magic happen by also making an RPC to the `load_spaceship()`
    method, triggering the procedures we made in the *Implementing texture caching*
    section. The updated version of the `create_spaceship()` method will look like
    this after these changes:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对新生成的玩家飞船的 `setup_multiplayer()` 方法进行 RPC 后，我们将通过也对该 `load_spaceship()` 方法进行
    RPC 来实现魔法，这将触发我们在 *实现纹理缓存* 部分中制作的程序。经过这些更改后，`create_spaceship()` 方法的更新版本将如下所示：
- en: '[PRE26]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Great! With that, whenever a player jumps into the game, their spaceship will
    change its sprite to the custom sprite the player uploaded, if any. Now, we need
    to also make this happen to the spaceships that were already in the game world
    when the player joined. For that, we need to make some changes in the `_on_players_multiplayer_spawner_spawned()`
    callback. Still in the `res://09.prototyping- space-adventure/Levels/World.gd`
    script, let’s implement the changes by moving on to the `_on_players_multiplayer_spawner_spawned()`
    method and go through the following steps:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！有了这个，每当玩家跳入游戏时，他们的宇宙飞船将改变其精灵为玩家上传的定制精灵（如果有的话）。现在，我们还需要让在玩家加入游戏时已经在游戏世界中的宇宙飞船也发生同样的变化。为此，我们需要在
    `_on_players_multiplayer_spawner_spawned()` 回调中进行一些更改。仍然在 `res://09.prototyping-
    space-adventure/Levels/World.gd` 脚本中，让我们通过转到 `_on_players_multiplayer_spawner_spawned()`
    方法并执行以下步骤来实现这些更改：
- en: 'Let’s revamp the whole logic of this callback and make it from scratch. We
    are going to start by creating a variable to store the player’s peer ID, which
    we can get by turning the recently spawned node’s name into an integer. Node names
    are `StringNames` so they are not pure strings, meaning we need to turn them into
    default strings before turning them into integers:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们重新设计这个回调函数的整体逻辑，并从头开始。我们将首先创建一个变量来存储玩家的对等节点 ID，我们可以通过将最近生成的节点的名称转换为整数来获取它。节点名称是
    `StringNames`，这意味着它们不是纯字符串，因此我们需要在将它们转换为整数之前将它们转换为默认字符串：
- en: '[PRE27]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After that, we will make the global RPC to the `setup_multiplayer()` method,
    just as we did before, but now we pass `player_id` as the argument:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将对 `setup_multiplayer()` 方法进行全局 RPC，就像我们之前做的那样，但现在我们传递 `player_id` 作为参数：
- en: '[PRE28]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then comes the interesting part. After making this RPC, if the spawned node,
    in other words the spawned player, happens to be in another player’s game instance,
    instead of the server’s instance, we will also make an RPC directly to the server,
    asking it to sync this spaceship using a method (which we are going to create
    soon) called `sync_spaceship()`, which receives a player ID as its argument:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后是有趣的部分。在执行这个 RPC 之后，如果生成的节点，换句话说，生成的玩家，恰好位于另一个玩家的游戏实例中，而不是服务器的实例中，我们将直接对服务器进行
    RPC，要求它使用一个方法（我们很快就会创建）来同步这个宇宙飞船，该方法接收一个玩家 ID 作为其参数：
- en: '[PRE29]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let’s move on to the `sync_spaceship()` method now. Let’s create this method
    with an RPC annotation that will allow any peer to remotely call it and it will
    also be called locally on the server. Remember, this method receives `player_id`
    as its argument:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们继续到 `sync_spaceship()` 方法。让我们使用 RPC 注解来创建这个方法，这样任何对等节点都可以远程调用它，同时它也会在服务器本地被调用。记住，这个方法接收
    `player_id` 作为其参数：
- en: '[PRE30]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Inside the `sync_spaceship()` method, we will first and foremost store a reference
    to the ID of whoever made the RPC to this function. This will allow us to make
    the `rpc_id()` method call directly to the player that just joined the game, instead
    of making a call to every player every time a player joins the game:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `sync_spaceship()` 方法内部，我们首先存储对调用此函数的人的 ID 的引用。这将允许我们直接调用刚刚加入游戏的玩家，而不是每次有玩家加入游戏时都调用每个玩家：
- en: '[PRE31]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, we will find the correct player in the `Players` node children by using
    the `get_node()` method and appending the `player_id`. Remember, since the `player_id`
    is also the node’s name, this is how we can easily find it among all the `Players`
    children:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将通过使用 `get_node()` 方法并附加 `player_id` 在 `Players` 节点的子节点中找到正确的玩家。记住，由于 `player_id`
    也是节点的名称，这就是我们如何在所有 `Players` 子节点中轻松找到它的方法：
- en: '[PRE32]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After that, we will find the player’s username. For that, we will use `player_id`
    as a key in `player_users`, which will return us the proper username:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将找到玩家的用户名。为此，我们将使用 `player_id` 作为 `player_users` 的键，这将返回正确的用户名：
- en: '[PRE33]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, with the user in our hands, we can make an RPC to the `load_spaceship()`
    method on this requester''s instance of the `node` that represents the spaceship
    spawned on their instance of the game:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在我们手中有了用户之后，我们可以对这个请求者的 `node` 实例上的 `load_spaceship()` 方法进行 RPC，该 `node`
    代表在他们的游戏实例上生成的宇宙飞船：
- en: '[PRE34]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: And we did it! With this in place, the game is now able to load, store, and
    sync players’ custom spaceship sprites. If you run the game now you can see the
    game caching data to decrease bandwidth and downloading and updating the players’
    spaceship sprites in real time. The following screenshot displays the before and
    after of implementing this feature.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做到了！有了这个，游戏现在能够加载、存储和同步玩家的自定义飞船精灵。如果你现在运行游戏，你可以看到游戏正在缓存数据以减少带宽，并实时下载和更新玩家的飞船精灵。以下截图显示了实现此功能前后的对比：
- en: '![Figure 13.8 – The before and after implementing the custom sprites feature](img/Figure_13.08_B18527.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.8 – 实现自定义精灵功能前后的对比](img/Figure_13.08_B18527.jpg)'
- en: Figure 13.8 – The before and after implementing the custom sprites feature
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.8 – 实现自定义精灵功能前后的对比
- en: 'Something interesting that you can check if you want to measure how much difference
    caching makes is to remove the statements that check whether the files exist in
    the `user://.cache/` folder and add a Monitor to monitor the `TextureDownloadHTTPRequest`
    and `SpaceshipsDatabaseDownloadHTTPRequest` downloaded bytes. For that, you can
    use the `HTTPRequest.get_downloaded_bytes()` method. For instance, the following
    code snippet displays how we can create a Monitor in the `TextureDownloadHTTPRequest`
    node:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要测量缓存带来的差异，一个有趣的方法是删除检查 `user://.cache/` 文件夹中文件是否存在的语句，并添加一个监控器来监控 `TextureDownloadHTTPRequest`
    和 `SpaceshipsDatabaseDownloadHTTPRequest` 下载的字节数。为此，你可以使用 `HTTPRequest.get_downloaded_bytes()`
    方法。例如，以下代码片段显示了如何在 `TextureDownloadHTTPRequest` 节点中创建一个监控器：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And with that, we can test our game multiple times to simulate players logging
    in and out of the game and see how the caching impacts each stage. Something you
    will notice is that after the images have been cached, they are almost instantaneously
    updated when players log in to the game again. The following screenshot displays
    the actual impact on the network usage in bytes before and after caching the images
    in the player’s machine:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以多次测试我们的游戏来模拟玩家登录和退出游戏，并查看缓存对每个阶段的影响。你会注意到，在图像被缓存后，当玩家再次登录游戏时，它们几乎是瞬间更新的。以下截图显示了在玩家机器中缓存图像前后对网络使用（以字节为单位）的实际影响：
- en: '![Figure 13.9 – A comparison between the network consumption the first time
    the player downloads the textures and after caching the textures in their machine](img/Figure_13.09_B18527.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.9 – 比较玩家首次下载纹理和缓存纹理后的网络消耗](img/Figure_13.09_B18527.jpg)'
- en: Figure 13.9 – A comparison between the network consumption the first time the
    player downloads the textures and after caching the textures in their machine
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.9 – 比较玩家首次下载纹理和缓存纹理后的网络消耗
- en: In this section, we saw how to implement database caching for custom spaceship
    sprites in our game. The `World` scene is responsible for synchronizing the game
    world, including the players’ spaceship sprites. So, we made some changes to it
    to achieve the caching we’ve implemented in previous sections. We saw how to use
    the `SpaceshipsDatabaseDownloadHTTPRequest` node to download the spaceships database
    and make RPCs to update players’ spaceship sprites and sync spaceship sprites
    when players join the game. At the end of the section, we used a Monitor and the
    `HTTPRequest.get_downloaded_bytes()` method to see how caching reduces bandwidth
    usage and improves network efficiency.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何在我们的游戏中实现数据库缓存自定义飞船精灵。`World` 场景负责同步游戏世界，包括玩家的飞船精灵。因此，我们对它进行了一些修改，以实现我们在前几节中实现的缓存。我们看到了如何使用
    `SpaceshipsDatabaseDownloadHTTPRequest` 节点下载飞船数据库，并通过 RPC 更新玩家的飞船精灵并同步飞船精灵，当玩家加入游戏时。在本节的最后，我们使用了一个监控器和
    `HTTPRequest.get_downloaded_bytes()` 方法来查看缓存如何减少带宽使用并提高网络效率。
- en: Note the number of bytes saved in *Figure 13**.9* with only two textures cached!
    Imagine, in the long run, how this could impact hundreds and even thousands of
    players as they log in and out of the game multiple times a day. And we are only
    talking about textures here. What else can we cache and effectively save hundreds
    of thousands of network bytes on? Well, that’s what we are going to see in the
    upcoming section.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在 *图 13.9* 中仅缓存两个纹理时节省的字节数！想象一下，从长远来看，这将对每天多次登录和退出游戏的数百甚至数千名玩家产生怎样的影响。而我们在这里只谈论纹理。我们还能缓存什么，并有效地节省数十万网络字节？这正是我们将在下一节中要探讨的内容。
- en: Going further with caching
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步探讨缓存
- en: Well, as we saw, images are not the only type of data we can download through
    the internet using the `HTTPRequest` node; for instance, we also downloaded the
    `PlayersSpaceship.json` file, which is a text file. But we can download pretty
    much anything using this protocol, provided it is stored in an HTTP page. But
    sometimes, some files are not stored and made available publicly on an HTTP page
    that any browser can access. Usually in this type of situation, the backend engineer
    will create a REST API that we can use to retrieve these files directly from the
    database where they are stored.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，正如我们所见，图像并不是我们通过 `HTTPRequest` 节点从互联网下载的唯一数据类型；例如，我们还下载了 `PlayersSpaceship.json`
    文件，这是一个文本文件。但我们可以使用此协议下载几乎所有内容，前提是它存储在 HTTP 页面上。但有时，一些文件并未存储，也没有在任何人都可以访问的 HTTP
    页面上公开。通常在这种情况下，后端工程师会创建一个 REST API，我们可以用它直接从存储这些文件的数据库中检索这些文件。
- en: This type of feature demands a physical infrastructure and the development of
    a custom REST API so we can work with it. Unfortunately, this goes way beyond
    the scope of this book. But the whole idea is that you can perform an HTTP request
    using custom headers and a custom URL that resembles an RPC. So, in the very URL
    itself you would add some parameters that the REST API would interpret as a method
    call and arguments. It’s very similar to what we did in [*Chapter 2*](B18527_02.xhtml#_idTextAnchor037)*,*
    *Sending and Receiving Data*, and REST APIs usually use JSON-formatted strings
    as the main data structure as well.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这种功能需要物理基础设施和自定义 REST API 的开发，以便我们可以与之交互。不幸的是，这远远超出了本书的范围。但整个想法是，你可以使用自定义头和类似
    RPC 的自定义 URL 来执行 HTTP 请求。因此，在 URL 本身中，你会添加一些参数，REST API 会将其解释为方法调用和参数。这与我们在 [*第
    2 章*](B18527_02.xhtml#_idTextAnchor037)*，* 发送和接收数据* 中所做的是非常相似的，而且 REST API 通常使用
    JSON 格式的字符串作为主要的数据结构。
- en: 'For instance, you can check out a series on my YouTube channel that relies
    heavily on REST APIs to integrate a third-party service into a game of mine called
    *Moon Cheeser*. The REST API is provided by *LootLocker* and at some point, I
    download a whole `PacketScene` from their server to cache it in the player’s machine
    and allow them to always have a copy of their purchased skin. You can check this
    particular video at the following link:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以在我的 YouTube 频道上查看一系列视频，这些视频大量使用 REST API 将第三方服务集成到我的游戏 *Moon Cheeser*
    中。REST API 由 *LootLocker* 提供，在某个时刻，我从他们的服务器下载了一个完整的 `PacketScene`，并在玩家的机器上缓存它，以便他们始终拥有他们购买的皮肤的副本。你可以在以下链接中查看这个特定的视频：
- en: '[https://youtu.be/w0qz-pJMIBo?si=WF2KH9-FRyO8glVq](https://youtu.be/w0qz-pJMIBo?si=WF2KH9-FRyO8glVq)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://youtu.be/w0qz-pJMIBo?si=WF2KH9-FRyO8glVq](https://youtu.be/w0qz-pJMIBo?si=WF2KH9-FRyO8glVq)'
- en: 'Well, I’m going to use LootLocker’s public API as an example here too. This
    is the HTTP request I used to retrieve the file associated with the skin the player
    purchases:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我这里也要用 LootLocker 的公共 API 作为例子。这是我用来自取玩家购买皮肤相关文件的 HTTP 请求：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This translates into the following `GDScript` code, using an `HTTPRequest`
    node:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以翻译成以下 `GDScript` 代码，使用 `HTTPRequest` 节点：
- en: '[PRE37]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now comes the interesting part that we haven’t explored yet. The `HTTPRequest.request_completed`
    signal is emitted when this request is completed and the server gives a response
    to the client with some very interesting data, including the response’s body,
    which usually is a JSON file containing the URL to the file we want. So, you can
    connect this signal to a signal callback and access the response’s body to get
    access to what the server provides you with regarding the request. This can go
    from the content of a file itself to a JSON file containing much more information,
    including the URL to download the file you want.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是我们要探索的有趣部分。当这个请求完成并且服务器向客户端发送响应，包括一些非常有趣的数据时，`HTTPRequest.request_completed`
    信号会被触发，这些数据通常包括响应体，它通常是一个包含我们想要文件 URL 的 JSON 文件。因此，你可以将这个信号连接到一个信号回调，并访问响应体以获取服务器为你提供的关于请求的信息。这可以从文件本身的内容到一个包含更多信息的
    JSON 文件，包括下载你想要文件的 URL。
- en: To avoid going off on a tangent here, I highly recommend you watch the video
    and understand how we download a resource-intensive file. In this case, I downloaded
    a custom `PackedScene` instance together with its dependencies, such as an image
    necessary to make the purchased skin display properly, and cached it into players’
    devices.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免跑题，我强烈建议你观看视频，了解我们如何下载资源密集型文件。在这种情况下，我下载了一个自定义 `PackedScene` 实例及其依赖项，例如一个必要的图像，用于正确显示购买的皮肤，并将其缓存在玩家的设备中。
- en: With this in your hands, you can implement all sorts of caching and save tons
    of resource usage, both for your players and your server, since it won’t be constantly
    delivering the same files to the same clients repeatedly.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这个工具，你就可以实现各种缓存功能，并大幅节省资源使用，无论是对于你的玩家还是服务器，因为它不会反复向相同的客户端发送相同的文件。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Well, it’s time to wrap this chapter up! In this chapter, we discussed what
    caching is and how it allows us to save bandwidth. We learned how to implement
    it for custom spaceship sprites in our game. For that, we saw how we can use the
    `HTTPRequest` node to download files over the internet by making HTTP requests.
    We also implemented a custom Monitor to see how much data we saved throughout
    a play session by caching textures. Finally, we saw how caching can go beyond
    image and text files and the possibility of using REST APIs to download all sorts
    of files using HTTP.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，是时候结束这一章了！在本章中，我们讨论了缓存是什么以及它是如何帮助我们节省带宽的。我们学习了如何在游戏中为自定义飞船精灵实现缓存。为此，我们看到了如何通过发起HTTP请求使用`HTTPRequest`节点从互联网下载文件。我们还实现了一个自定义监控器，通过缓存纹理来查看在整个游戏会话中我们节省了多少数据。最后，我们看到了缓存如何超越图像和文本文件，以及使用REST
    API通过HTTP下载各种文件的可能性。
- en: With that, my fellow Godot Engine developers, we reach the end of our journey!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我的Godot引擎开发者们，我们的旅程就到此结束了！
- en: 'We started as people who didn’t know how to send a simple message to another
    computer, and became fully fledged network engineers ready to create the games
    of our dreams and allow players to have a shared experience, enjoy their time
    together, and build communities around the world. Congratulations on completing
    this journey. You are now capable of one of the most amazing things any human
    being can do: to connect people together toward a shared goal.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是从不知道如何向另一台计算机发送简单消息的人开始的，现在我们已经成为了完全合格的网络工程师，准备创造我们梦想中的游戏，并允许玩家拥有共享的体验，享受彼此的时光，并在世界各地建立社区。祝贺您完成这段旅程。您现在能够做到任何人类能够做到的最令人惊叹的事情之一：将人们连接起来，共同追求一个目标。
- en: This is my farewell. I’m very proud of what we went through, and I hope you
    use this power for good. You can definitely expect more from me to come. But for
    now, that’s it.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我的告别。我为我们所经历的一切感到非常自豪，并希望您能善用这份力量。您绝对可以期待我未来会有更多的作品。但就目前而言，这就是全部了。
- en: Thank you so much for reading. Keep developing, and until the next time!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 非常感谢您的阅读。继续开发，直到下次再见！
