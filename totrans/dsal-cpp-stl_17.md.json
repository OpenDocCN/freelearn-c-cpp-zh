["```cpp\n#include <iostream>\n#include <map>\n#include <type_traits>\n#include <vector>\n// Function Template\ntemplate <typename T> void swap(T &a, T &b) {\n  T temp = a;\n  a = b;\n  b = temp;\n}\n// Variadic Template\ntemplate <typename... Args> void print(Args... args) {\n  (std::cout << ... << args) << '\\n';\n}\n// SFINAE with std::enable_if\ntemplate <typename T, typename std::enable_if<\n                          std::is_integral<T>::value>::type\n                          * = nullptr>\nvoid process(T t) {\n  std::cout << \"Processing integral: \" << t << '\\n';\n}\ntemplate <typename T,\n          typename std::enable_if<std::is_floating_point<\n              T>::value>::type * = nullptr>\nvoid process(T t) {\n  std::cout << \"Processing floating point: \" << t << '\\n';\n}\n// SFINAE for STL containers\ntemplate <\n    typename T,\n    typename std::enable_if<std::is_same<\n        T, std::vector<int>>::value>::type * = nullptr>\nvoid processContainer(T &t) {\n  std::cout << \"Processing vector: \";\n  for (const auto &i : t) { std::cout << i << ' '; }\n  std::cout << '\\n';\n}\ntemplate <\n    typename T,\n    typename std::enable_if<std::is_same<\n        T, std::map<int, int>>::value>::type * = nullptr>\nvoid processContainer(T &t) {\n  std::cout << \"Processing map: \";\n  for (const auto &[key, value] : t) {\n    std::cout << \"{\" << key << \": \" << value << \"} \";\n  }\n  std::cout << '\\n';\n}\nint main() {\n  // Function Template\n  int a = 5, b = 10;\n  swap(a, b);\n  std::cout << \"Swapped values: \" << a << \", \" << b\n            << '\\n';\n  // Variadic Template\n  print(\"Hello\", \" \", \"World\", \"!\");\n  // SFINAE with std::enable_if\n  process(10);\n  process(3.14);\n  // SFINAE for STL containers\n  std::vector<int> vec = {1, 2, 3, 4, 5};\n  processContainer(vec);\n  std::map<int, int> map = {{1, 2}, {3, 4}, {5, 6}};\n  processContainer(map);\n  return 0;\n}\n```", "```cpp\nSwapped values: 10, 5\nHello World!\nProcessing integral: 10\nProcessing floating point: 3.14\nProcessing vector: 1 2 3 4 5\nProcessing map: {1: 2} {3: 4} {5: 6}\n```", "```cpp\n// This function only takes a specific kind of vector\nvoid printElements(const std::vector<int> &vec) {\n  std::for_each(vec.begin(), vec.end(),\n                [](int x) { std::cout << x << \" \"; });\n  std::cout << \"\\n\";\n}\n// Template function that operates on iterators, making it\n// applicable to any container type\ntemplate <typename Iterator>\nvoid printElements(Iterator begin, Iterator end) {\n  while (begin != end) {\n    std::cout << *begin << \" \";\n    ++begin;\n  }\n  std::cout << \"\\n\";\n}\n```", "```cpp\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <vector>\n// Decorator for adding logging to the compare function\ntemplate <typename Compare> class LoggingCompareDecorator {\npublic:\n  LoggingCompareDecorator(Compare comp) : comp(comp) {}\n  template <typename T>\n  bool operator()(const T &lhs, const T &rhs) {\n    bool result = comp(lhs, rhs);\n    std::cout << \"Comparing \" << lhs << \" and \" << rhs\n              << \": \"\n              << (result ? \"lhs < rhs\" : \"lhs >= rhs\")\n              << \"\\n\";\n    return result;\n  }\nprivate:\n  Compare comp;\n};\nint main() {\n  std::vector<int> numbers = {4, 2, 5, 1, 3};\n  // Original comparison function\n  auto comp = std::less<int>();\n  // Decorating the comparison function with logging\n  LoggingCompareDecorator<decltype(comp)> decoratedComp(\n      comp);\n  // Using the decorated comparison in sort algorithm\n  std::sort(numbers.begin(), numbers.end(), decoratedComp);\n  // Output the sorted numbers\n  std::cout << \"Sorted numbers: \";\n  for (int num : numbers) { std::cout << num << \" \"; }\n  std::cout << \"\\n\";\n  return 0;\n}\n```", "```cpp\nComparing 2 and 4: lhs < rhs\nComparing 4 and 2: lhs >= rhs\nComparing 5 and 2: lhs >= rhs\nComparing 5 and 4: lhs >= rhs\nComparing 1 and 2: lhs < rhs\nComparing 2 and 1: lhs >= rhs\nComparing 3 and 1: lhs >= rhs\nComparing 3 and 5: lhs < rhs\nComparing 5 and 3: lhs >= rhs\nComparing 3 and 4: lhs < rhs\nComparing 4 and 3: lhs >= rhs\nComparing 3 and 2: lhs >= rhs\nSorted numbers: 1 2 3 4 5\n```", "```cpp\nstd::transform(vec.begin(), vec.end(), vec.begin(),\n               [](int x) { return x * x; });\n```", "```cpp\nvoid vectorTransform(std::vector<int> &vec, int factor) {\n  std::transform(vec.begin(), vec.end(), vec.begin(),\n                 [factor](int x) { return x * factor; });\n}\n```", "```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\n// Define a Strategy interface\nclass Strategy {\npublic:\n  virtual void\n  execute(const std::vector<int> &data) const = 0;\n};\n// Define a Concrete Strategy that uses std::for_each and a\n// lambda function\nclass ForEachStrategy : public Strategy {\npublic:\n  void\n  execute(const std::vector<int> &data) const override {\n    std::for_each(data.begin(), data.end(), [](int value) {\n      std::cout << \"ForEachStrategy: \" << value << \"\\n\";\n    });\n  }\n};\n// Define a Concrete Strategy that uses std::transform and\n// a lambda function\nclass TransformStrategy : public Strategy {\npublic:\n  void\n  execute(const std::vector<int> &data) const override {\n    std::vector<int> transformedData(data.size());\n    std::transform(data.begin(), data.end(),\n                   transformedData.begin(),\n                   [](int value) { return value * 2; });\n    for (const auto &value : transformedData) {\n      std::cout << \"TransformStrategy: \" << value << \"\\n\";\n    }\n  }\n};\n// Define a Context that uses a Strategy\nclass Context {\npublic:\n  Context(Strategy *strategy) : strategy(strategy) {}\n  void setStrategy(Strategy *newStrategy) {\n    strategy = newStrategy;\n  }\n  void executeStrategy(const std::vector<int> &data) {\n    strategy->execute(data);\n  }\nprivate:\n  Strategy *strategy;\n};\nint main() {\n  std::vector<int> data = {1, 2, 3, 4, 5};\n  ForEachStrategy forEachStrategy;\n  TransformStrategy transformStrategy;\n  Context context(&forEachStrategy);\n  context.executeStrategy(data);\n  context.setStrategy(&transformStrategy);\n  context.executeStrategy(data);\n  return 0;\n}\n```", "```cpp\nForEachStrategy: 1\nForEachStrategy: 2\nForEachStrategy: 3\nForEachStrategy: 4\nForEachStrategy: 5\nTransformStrategy: 2\nTransformStrategy: 4\nTransformStrategy: 6\nTransformStrategy: 8\nTransformStrategy: 10\n```"]