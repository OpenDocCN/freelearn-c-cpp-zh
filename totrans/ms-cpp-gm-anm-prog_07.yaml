- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Saving and Loading the Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to *Chapter 5*! In the previous chapter, we added a separate view mode
    to the application. In this view-only mode, the user interface and selection functionality
    are disabled. Then, we added a simplified and, eventually, a full version of undo/redo
    for the instances. Setting changes to an instance can now be reverted, or reapplied.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will add the ability to save the configuration of the application
    to a file. First, we will explore different file types to store the data. After
    considering the pros and cons of each type of file and determining a suitable
    file format, we will dive into the structure of the file format. Then, we’ll implement
    a parser class that will allow us to load and save our configuration. Finally,
    we will load a default configuration at application startup, allowing the user
    to play around with the application.
  prefs: []
  type: TYPE_NORMAL
- en: For any bigger application, it is crucial to be able to save the current state
    of data that was created or changed, stop the application, and load the data again
    to continue working. It’s also crucial to recover from a hanging or crashed application
    by restoring the latest saved version. You don’t want to risk losing hours of
    your work because the application cannot save the data properly to local or remote
    storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Textual or binary file formats – pros and cons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing a text format to save our data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the structure of a YAML file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a YAML parser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving and loading the configuration file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading a default configuration file at startup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example source code for this chapter is in the `chapter05` folder, in the
    `01_opengl_load_sve` subfolder for OpenGL and `02_vulkan_load_save` for Vulkan.
  prefs: []
  type: TYPE_NORMAL
- en: Before we add save and load functionality to our application, let’s take a look
    at some ways to save the data to a storage device.
  prefs: []
  type: TYPE_NORMAL
- en: Textual or binary file formats – pros and Cons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever you play a game, cut a video, edit a photo, or write a piece of text
    or a book, you will make use of the integrated load and save functions integrated
    with the software you are using. Saving a game at a safe spot, storing a video
    sequence after making a large number of edits, or pressing *Ctrl* + *S* every
    now and then in the text editor has become normal to us.
  prefs: []
  type: TYPE_NORMAL
- en: 'But have you ever thought about the data that is saved and loaded? You might
    have some questions regarding the following functions, like:'
  prefs: []
  type: TYPE_NORMAL
- en: What needs to be stored to fully restore your latest state?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What format should be used to save the data?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens if a program is updated? Will I be able to load the saved data?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can I read or change the saved file without the original program?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For all programs you only use, the decision about the format and amount of data
    lies in the hands of their developers. But, for our application, we must decide
    which data needs to be saved, and how to save the data to the storage.
  prefs: []
  type: TYPE_NORMAL
- en: All types of data formats have pros and cons; here is a short round-up.
  prefs: []
  type: TYPE_NORMAL
- en: Saving and loading binary data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the early times of the computer era, storage space and computation time were
    expensive, precious, and scarce. To minimize space and time during the save and
    restore process, the data was more or less only a memory dump.
  prefs: []
  type: TYPE_NORMAL
- en: The data to save was stored in internal data types, into a memory area of the
    computer and then literally copied byte by byte to a floppy disk or a hard drive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading the same data was as easy and fast as saving it: read the data from
    the storage device to the computer’s memory (again, byte by byte) and interpret
    it as the same internal data types that were used while saving.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at some of the advantages and disadvantages of binary data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantages**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files are small.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving and loading the data can be done by just copying the data, leading to
    a higher speed for save and load operations.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disadvantages**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To change the data outside the application, special knowledge is needed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Corrupted data could cause unpredictable side effects or crashes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Updates to the save file format may be hard. *Magic bytes* are needed to find
    the actual version and to map the loaded data to the correct internal data types.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary data may not be portable across architectures due to different endianness.
    For this reason, it is generally good advice to avoid binary save files unless
    absolutely necessary. We can still read `CONFIG.SYS` and `AUTOEXEC.BAT` files
    created on MS-DOS systems 30 years ago, but the binary save files from spreadsheet
    calculators or word processors of the same time are unusable, at least without
    the correct tools or hard work to reverse-engineer the file format. Outside of
    well-documented and standardized formats, like pictures or sound files, saving
    binary data **will** cause trouble, as you may not be able to open the binary
    files on a different operating system, or even just a newer version of the same
    system. Also, loading the file on a different CPU architecture, bit width, or
    endianness will most probably fail due to a different memory layout of the data
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Since CPU time and storage space are no longer limited, the advantages of text
    formats now clearly outweigh those of binary saves.
  prefs: []
  type: TYPE_NORMAL
- en: Saving and loading textual data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After more and more CPU power, network bandwidth, and storage space became available,
    textual formats started to become the first choice to save data. Developing code
    is much easier when you can create or adjust the saved files with a simple text
    editor, or when you can find errors by printing the text lines to log files.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a text-based save file, the conditions differ from those for a binary save:'
  prefs: []
  type: TYPE_NORMAL
- en: Files are larger, except when they are compressed into a .zip file or similar.
    Then, another transformation step (pack/unpack) is needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data must be transformed from binary representation to text and back, every
    time the data is loaded and saved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Domain-specific knowledge of the file format may be required for larger changes,
    or to create a save file *from scratch*. But for simple value changes, a text
    editor is the only tool we need.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Corrupted data can be fixed, or the corrupt data elements may be simply deleted
    from the text file. Better to lose only some data than all of it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File format updates can be detected by advancing a version number in the file,
    helping the application to use the correct transformations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading the same file on a computer with a different architecture or operating
    system is no problem at all. The textual representation is the same, and due to
    the transformation from text to binary data types, endianness or data type lengths
    do not matter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some caveats still exist for cross-platform usage, like different path separators
    in Windows and Linux, or the different interpretation of points and commas in
    the locale settings of the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the configuration needs to be split into multiple files, packing all files
    into a compressed file is the most common way. By adding all configuration files
    in a `.zip` or `.tar.gz` file, you end up with only a single file, and save some
    disk space due to the compression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a textual representation for our save file is the way to go. And, by defining
    a simple file format, it is even possible to create a configuration file by hand.
  prefs: []
  type: TYPE_NORMAL
- en: But, before we start creating a file format on our own, let’s check some available
    file formats. By using a well-known file format, we can save a lot of time since
    we don’t have to create the functions to parse and write a file.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a text format to save our data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will look at three popular configuration file formats in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '**INI**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JSON**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**YAML**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All three formats find applications in certain fields but may not be suitable
    in others.
  prefs: []
  type: TYPE_NORMAL
- en: The INI file format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the oldest formats to store configuration data is the so-called INI format.
    The name comes from the file extension `.ini`, which is a three-letter abbreviation
    for initialization. An INI file is mostly used to configure programs.
  prefs: []
  type: TYPE_NORMAL
- en: In the INI file, simple key/value pairs are stored and organized in optional
    sections. A section name is enclosed in square brackets, and the section scope
    runs from the start of the section to the start of another section, or the end
    of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a section and some key/value pairs for a database connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Sections can be nested to create some sort of hierarchy by separating sections
    and subsections by special characters, like a dot (`.`) or a backslash (`\`).
    It’s crucial for the parser to recognize these section divisions; otherwise, each
    section will be treated independently, without considering their hierarchical
    relationship.
  prefs: []
  type: TYPE_NORMAL
- en: The lack of duplicate key names makes it hard to store hierarchical or non-trivial
    data where the same key may occur more than once, like a model file or an instance
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The JSON file format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSON, short for JavaScript Object Notation, made its debut in the early 2000s.
    As in the INI file, key/value pairs are stored in a JSON file. Sections similar
    to the INI file sections do not exist; instead, a JSON file allows the creation
    of complex, tree-like hierarchies. Also, arrays of the same data type can be defined.
  prefs: []
  type: TYPE_NORMAL
- en: The main usage for JSON files is electronic data interchange, for instance,
    between web applications and backend servers. Good readability of the file format
    by humans is only a side effect; JSON files are mostly read and written by applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of a JSON file, containing the same data as the INI file
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Sadly, due to the large number of braces, the file format is hard to write correctly
    on the first try. Also, no comments are allowed, so testing different options
    *on the fly* can only be done by saving a copy of the original file and adjusting
    the content.
  prefs: []
  type: TYPE_NORMAL
- en: The YAML file format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The name YAML was originally an acronym for *Yet Another Markup Language*. At
    the start of the 2000s, the *yet another* prefix for a product name was used as
    computer-related humor, stating the ever-growing repetition of unoriginal ideas.
    But, since YAML is not a markup language like HTML or XML, the meaning of the
    name was changed to the recursive acronym *YAML Ain’t Markup Language*.
  prefs: []
  type: TYPE_NORMAL
- en: YAML and JSON are closely related. A JSON file can be transformed into a YAML
    file, and vice versa. The main difference between the two formats is that instead
    of using curly braces, the hierarchy in YAML is created by indents.
  prefs: []
  type: TYPE_NORMAL
- en: YAML’s main goal was to be readable by humans. The YAML format is widely used
    to create and maintain structured and hierarchical configuration files (i.e.,
    in configuration management systems and cloud environments).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of the YAML file format, again with the same data as INI
    and JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Since the YAML format is simple and powerful, has all the features we need,
    and can be read and written without stumbling over missing braces, like in JSON,
    we will use a YAML file to store the configuration data for our application.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the structure of a YAML file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s look at the three main components of a YAML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Nodes**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maps**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sequences**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start with the node.
  prefs: []
  type: TYPE_NORMAL
- en: The YAML node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main object of a YAML file is a so-called node. A node represents the data
    structure below it, which can be a scalar value, a map, or a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Both `database-config` and `type` are YAML nodes. While the `database-config`
    node holds a map containing the key `type` and the value `mysql`, the node type
    just has the scalar value `mysql` in it.
  prefs: []
  type: TYPE_NORMAL
- en: The YAML map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A YAML map contains between zero and an arbitrary number of key/value pairs.
    Plus, there is an interesting correlation between nodes and maps: the key and
    the value may be another node, creating the hierarchy in the file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s extend the configuration snippet from the node section before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As stated before, `database-config` is both a node and a map. The key of the
    map named `database-config` is the name `database-config`, and the value is another
    map, containing the three key/value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: The YAML sequence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To enumerate similar elements, a YAML sequence is used. A sequence can be seen
    as a C++ `std::vector`, where all elements must be of the same kind. Like the
    C++ vector, you iterate over the sequence, reading the data elements one by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sequences come in two different flavors: the *block style* and the *flow style*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the block style, an indented dash (`-`) is used as an indicator of the elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast, the flow style uses square brackets, and the elements are separated
    by commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Both styles represent the same data. It is a matter of personal preference and
    readability.
  prefs: []
  type: TYPE_NORMAL
- en: By combining maps and sequences, complex data structures can be created.
  prefs: []
  type: TYPE_NORMAL
- en: Combinations of maps and sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A powerful way to represent data can be achieved by mixing maps and sequences.
    For instance, we could store the `position` and `rotation` of all our model instances
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, both combinations of maps and sequences are used.
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a map out of the keys `position` and `rotation`; the values
    are flow-style sequences of numbers, representing a `glm::vec3`. YAML always stores
    the shortest possible representation of a scalar number. So, as long as values
    have no fractional part, an integer value will be used, even for `float` and `double`
    types. Then, the map of `position` and `rotation` is used in a block sequence
    to create an array-style representation of the model instances.
  prefs: []
  type: TYPE_NORMAL
- en: To read the data of the instances into our application, we must first iterate
    over the model instance sequence, and for every instance, we can extract the position
    and rotation values.
  prefs: []
  type: TYPE_NORMAL
- en: After the basic excurse into the YAML file format, we will now implement a YAML
    parser and writer class for our application to save and load its configuration.
    Having the configuration stored on disk is like saving a text document – we can
    quit the application and continue to work in the virtual world later. We can also
    use the saved files to return to the previous state of the virtual world.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a YAML parser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like other tools we are already using (the Open Asset Import Library, GLFW,
    or ImGui), we will use a freely available open source solution: `yaml-cpp`.'
  prefs: []
  type: TYPE_NORMAL
- en: By integrating `yaml-cpp`, we can read and write YAML files from C++ with minimal
    effort. The biggest step is to make sure our custom data types are known to `yaml-cpp`.
    Plus, we have to think about a proper structure for the data file.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by exploring how to integrate `yaml-cpp` into our project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting yaml-cpp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For Linux systems, getting `yaml-cpp` is easy. Similar to the other tools,
    most distributions already contain the `yaml-cpp` library and header files. For
    instance, in Ubuntu 22.04 or later, `yaml-cpp` and its development files can be
    installed with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using an Arch based Linux distribution, you can install `yaml-cpp`
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For Windows, we are also in luck. `yaml-cpp` uses CMake, and by using the CMake
    `FetchContent` commands, downloading `yaml-cpp` can be added to the project with
    only a couple of lines. First, we add the `FetchContent` declaration to the `CMakeLists.txt`
    file in the project root. We are using version `0.8.0` of `yaml-cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Make sure we are inside a `WIN32` section in the `CMakeLists.txt` file. We do
    not need to download the library on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we trigger the download of `yaml-cpp` and add the variables for the directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Windows also needs a script to detect the downloaded dependency. The detection
    script must be named `Findyaml-cpp.cmake` and placed into the `cmake` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main function of the script boils down to these two CMake functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to CMake’s `FetchContent`, the `YAML-CPP_DIR` variable is populated with
    the path to the downloaded `yaml-cpp` code. So, the script only checks if the
    header and library can be found.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating yaml-cpp into the CMake build
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For Linux and Windows, we must set the proper include path for the compiler,
    and we must add the `yaml-cpp` libraries to the list of linked libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'To update the `include` path, add the `YAML_CPP_INCLUDE_DIR` variable to the
    `include_directories` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And for the linker, add `yaml-cpp::yaml-cpp` to `target_link_libraries` in
    Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'For Linux, only the name `yaml-cpp` of the shared library is needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: After running CMake again, `yaml-cpp` will be downloaded and made available
    to the rest of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the parser class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Parsing the YAML file for loading and creating the content for writing will
    be done in a new class called `YamlParser`, located in the `tools` directory.
    We can use `yaml-cpp` in our code after including the header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To store the intermediate data while loading or creating a data structure to
    save to disk, two additional private members are needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`YAML::Node` transforms the nodes of a YAML file from the disk into a C++ data
    structure, simplifying the access to the data that has been loaded. `YAML::Emitter`
    is used to create a YAML file in memory by appending data elements, eventually
    writing the structured data to a file.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the node type of yaml-cpp
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Accessing the structured or scalar data of a `yaml-cpp` node is done by using
    the node name as the index to the C++ map stored in the `YAML::Node` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To retrieve the scalar value of a simple key/value map, the special operator
    `as` exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Since a YAML file has no knowledge of the data types stored in the value, we
    have to explicitly tell `yaml-cpp` how to interpret the incoming data. Here, `yaml-cpp`
    will try to get the value of the `dataNode` node as `int`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After defining a transformation template, custom data types like structs can
    also be read directly into a variable of the same type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We will handle transformation templates in the *Saving and loading the configuration
    file* section.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing sequences and maps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In `yaml-cpp`, sequences can be read by iterating over them using a `for` loop,
    and accessing the element by the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The elements of the sequence are made available in the same order as they appear
    in the YAML file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For maps, an iterator-style `for` loop is needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The key of the map element can be read via the `first` accessor of the C++ map
    container. Again, we must tell `yaml-cpp` which data type the map key is. Then,
    the value can be retrieved with the `second` accessor of the C++ map container.
  prefs: []
  type: TYPE_NORMAL
- en: If reading a value fails, for instance, because the type is wrong or no such
    node exists, an exception will be thrown. To avoid our program being terminated,
    we must handle all thrown exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions thrown by yaml-cpp
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Instead of returning an error code, `yaml-cpp` throws exceptions whenever something
    goes wrong. By default, any unhandled exception terminates the program. Handling
    an exception in C++ is done like in other languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The call that may cause an exception will be enclosed in a `try` block, and
    in case of an exception, the `catch` block will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: We can simply catch all exceptions since any parsing failure may result in an
    empty or incomplete configuration file. If you want to have more detailed exception
    handling, you can explore the `yaml-cpp` source code.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with the basics of `yaml-cpp`, we can start implementing the code to save
    and load a YAML file. We will start with the save functionality because after
    we have created a file on disk, loading the data elements back into the application
    will be much easier compared to hand-crafting a configuration file first.
  prefs: []
  type: TYPE_NORMAL
- en: Saving and loading the configuration file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building our configuration file starts with the decision of what needs to be
    stored and how we want to store the elements. By reusing our custom data types
    like the `InstanceSettings`, creating the functions to save and load a file can
    be simplified. Now we no longer have to read each value individually, but we can
    use calls like `getInstanceSettings()` and `setInstanceSettings()` from the `AssimpInstance`
    class to transfer the values directly between the parser and the instance.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by exploring what we want to save, and after adding the code to
    write our custom data to the file, a user interface dialog will be added, allowing
    a simple way to save the file to disk. Finally, we will step through the process
    of loading the configuration back into the application.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding what to store in the configuration file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned in the *Saving and loading textual data* section, adding a version
    number can help a lot during the development of an application. If we need to
    change the data format, even slightly, raising the version number can help us
    to simplify branching between the old and new format(s) when reading a file.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we should store the information about the selection. Restoring the selected
    model and instance, we can continue exactly from the same spot where we saved
    the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we should store the camera information. When working with more complex
    scenes later in the book, restoring the camera to the default position and angles
    may confuse the application user.
  prefs: []
  type: TYPE_NORMAL
- en: As the most important parts, we must store all information about the models
    and all instances on the screen required to restore the application to the same
    state as at the time of saving the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the model, the file name and path are sufficient, as we use the file name
    as the model’s name. The path to the model file will be saved relative to the
    application executable, and not as an absolute path, at least as long as the model
    resides on the same partition as the executable (Windows only). Both methods have
    their pros and cons:'
  prefs: []
  type: TYPE_NORMAL
- en: A relative path allows the user to check out the code from the book anywhere
    on their system, being able to use the example configuration file and example
    models *out of the box*. However, moving the executable to another directory or
    partition requires all configuration data and models to be moved too, or the configuration
    files must be manually adjusted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an absolute path may become handy to store a new configuration at a fixed
    location on the PC (i.e., in the home directory of the user). This way, the application
    could be started from any place on the PC and still find the configuration files
    and models.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To restore all instances, we need all information stored in the `InstanceSetting`s
    struct plus the model name. To simplify restoring the instance via the model name,
    we add the model name as a `std::string` to the `InstanceSettings` struct. Having
    the model name in the struct allows us to hand over a `std::vector` of `InstanceSettings`
    values from the YAML parser to the renderer class; we don’t need more complex
    data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start the implementation by creating custom element writer overloads.
  prefs: []
  type: TYPE_NORMAL
- en: Overloading the output operator of the emitter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The creators of `yaml-cpp` added a nice method to output the contents of complex
    structures to the `YAML::Emitter`. We only have to overload the `operator<<` in
    the `YamlParser.cpp` file in the `tools` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `glm::vec3` data type, we add a flow type sequence, and then the three
    elements of the vector will be added to the stream. In the final file, a default
    YAML sequence will appear, containing the values of the `glm::vec3` vector as
    in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `InstanceSettings` struct must be added as the key/value pairs of a YAML
    map. The start and end of the map are set in the function storing the `InstanceSettings`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The resulting maps will be added as the value of a YAML sequence, storing all
    relevant instance data in the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and writing the configuration file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a configuration file, the renderer will instantiate a local object
    of our `YamlParser` class, and call `createConfigFile()` on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `createConfigFile()` method, the `YAML::Emitter` will be filled with
    the structures of our data. As an example, we will add a comment at the top of
    the file, and save the version number in the second line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the final YAML file, the following first lines will appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Aa another example, to store the instance settings, we create a map named `instances`,
    and start creating a sequence as the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can create a `for` loop over the instances and use the `getInstanceSettings()`
    call of the instance to directly store the instance settings to the emitter stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to the `operator<<` overload, no complex handling inside the loop is
    required.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the last step, we close the sequence of instance settings, and close the
    map for the `instances` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The final YAML file will contain a sequence of all instances, including the
    newly added model file name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to view the contents of the created configuration file before doing
    any disk writes, we can create a C string and output the string via the logger
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Writing the file to disk will be done with a `std::ostream`. The error handling
    for the stream has been excluded for brevity in the following listing, but saving
    the file to disk is essentially done in just three lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: First, we create the output stream with the given file name. Then, we convert
    the `std::string` of the `YAML::Emitter` to a C string and write the string to
    the output stream. By closing the stream, the file will be flushed to the storage
    device.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a file dialog to the user interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To allow the user to store the configuration file in an arbitrary location and
    with a custom name, we will add a file dialog in the user interface. We are already
    using the ImGui-based file dialog to load a model file, and we can reuse the same
    dialog instance to present a **Save File** dialog to the user.
  prefs: []
  type: TYPE_NORMAL
- en: To create a dialog that lets the user choose a file name and location, three
    changes to the `IGFD::FileDialogConfig` variable named `config` must be made.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, by selecting an existing file, we need an extra dialog to confirm an
    overwriting of the file. Luckily, the file dialog has such a confirmation dialog
    already built in. All we must do is add the flag `ImGuiFileDialogFlags_ConfirmOverwrite`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If we select an existing file, a new dialog will be shown, asking the user to
    confirm whether to replace the existing file or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will present a default path and file name for the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using the `config` folder and a file named `config.acfg` to present
    a default file to the user. The file dialog code will automatically enter the
    `config` folder and fill out the file name and extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a last step, we add `.acfg` as the only file extension to the dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: By using a new extension for the configuration file, we avoid trouble, like
    attempts to load a different file format or overwriting other files on the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **OK** button of the file dialog retrieves the selected file name, and
    calls the callback function responsible for saving the configuration to disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We store the result of the callback function in the Boolean `saveSuccessful`.
    This way, we can check for any errors and present the user a dialog in case saving
    the configuration was not successful.
  prefs: []
  type: TYPE_NORMAL
- en: To inform the user about save errors, only a simple dialog is implemented, notifying
    the user to check the output messages of the application for details about the
    cause of the write error.
  prefs: []
  type: TYPE_NORMAL
- en: If you load some models now, create instances or clones, and save the configuration,
    you can inspect the created configuration file. All data from the *Deciding what
    to store in the configuration file* section should be in the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Saving the data to disk is only half the job. To continue working from the same
    spot where we saved the file, we need to load the configuration file back into
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the configuration file back and parsing the nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To support parsing custom data types in a YAML file, `yaml-cpp` allows us to
    define a C++ template for a struct named `convert`, located in the YAML `namespace`.
    The `convert` struct must implement two methods called `encode` and `decode`,
    doing the process of serializing the C++ types to YAML (`encode`) and deserializing
    from YAML back to C++ (`decode`). By using these two methods, `yaml-cpp` allows
    a seamless transformation between C++ types and YAML entries. The `encode` method
    creates a new YAML node from a primitive or custom data type, while the `decode`
    method reads the YAML node data and returns the primitive or custom data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'For writing a `glm::vec3` element to a YAML node and reading back a YAML node
    to a `glm::vec3`, the following template code must be implemented in a header
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: To save the data from the `glm::vec3`, we create a new YAML node called `node`
    and add the three elements `x`, `y`, and `z` of the `glm::vec3` to the node. The
    node is then returned to the caller of the `encode()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reading back the data from a node into a `glm::vec3` variable is done with
    the `decode()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Checking the node type for the right type and size is optional, but it is a
    good style assuring we have the correct data for the custom data type to prevent
    runtime errors. Skipping this check and trying to parse the wrong data type will
    lead to an exception, terminating the entire program if unhandled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we read the data from a node by the sequence index, and set the three
    elements `x`, `y`, and `z` of the `glm::vec3` to the float values from the node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'After defining the `encode()` and `decode()` methods, we can exchange data
    between a YAML `node` and a `glm::vec3` by a normal assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The same two methods are implemented for the `InstanceSettings` struct, helping
    us to read the settings of the instance directly back into a variable of the type
    `InstanceSettings`. To avoid polluting the header for our parser class, a new
    header called `YamlParserTypes.h` has been created in the `tools` folder. The
    `YamlParserTypes.h` header will be included in the header of the `YamlParser`
    class to make the new conversions available.
  prefs: []
  type: TYPE_NORMAL
- en: Once the configuration file is successfully parsed, all settings, model paths,
    and instance settings are extracted. But before we can load the models and create
    new instances, we must first clear the current list of models and instances.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up and recreating the scene from the saved values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Removing all models and instances is a simple and straightforward process.
    In the renderer, we must do the following steps to have a fresh environment:'
  prefs: []
  type: TYPE_NORMAL
- en: Set `miSelectedInstance` and `miSelectedModel` containing the currently selected
    instance and model to zero. The variables from this step and from *steps 2 and
    3* were introduced in the *Dynamic model and instance management* section of [*Chapter
    1*](Chapter_1.xhtml). Then, at index zero, the new null model and null instance
    will be created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Erase the `miAssimpInstances` vector and clear the `miAssimpInstancesPerModel`
    map. Now, all models are unused.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Erase the `miModelList` vector. Since all instances were already deleted, the
    shared pointers of the models will be no longer referenced, and the models will
    be deleted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new null model and a null instance. Both the null model and the null instance
    must be the first elements of the model list and the instances vector and map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clear the undo and redo stacks. In the stacks, we used only weak pointers, so
    this step can be done at any time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the triangle count. After all models and instances were removed, the
    triangle count should be zero.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The entire procedure of cleaning up all models and instances has been added
    to the new `removeAllModelsAndInstances()` method of the renderer class, simplifying
    the usage whenever we need a clean and fresh environment.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can load the model files from disk, but without creating the default
    instance. After all models are loaded, we search the model from the `InstanceSettings`
    in the model list, create a new instance, and apply the settings from the configuration
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we should enumerate the instances as the instance index number is not
    stored in the `InstanceSettings`. But the instance should remain at the same index
    they had at save time, due to the linear reading of the `miAssimpInstances` vector
    when the YAML emitter is created and the same linear reading of the nodes when
    parsing the YAML file.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we restore the camera settings, selected model, and instance plus the
    status of the selection highlight from the parser.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the configuration should be fully loaded, and the application
    should contain the same models, instances, and settings as at the time of the
    save operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'One question remains for the load process: What should we do if parsing the
    configuration file fails only partially? Maybe a model file was renamed or deleted,
    or the file was truncated or corrupted and the settings of the last instance are
    incomplete.'
  prefs: []
  type: TYPE_NORMAL
- en: Strict or relaxed configuration file loading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One option to overcome parsing errors is to discard the entire configuration
    prior to deleting all current content of the application. This strict loading
    type is easy to implement; any kind of parsing error invalidates the configuration
    file at parsing time. We ignore the loading request and present just an error
    message to the user.
  prefs: []
  type: TYPE_NORMAL
- en: The other option is relaxed parsing. We try our best to load the valid models
    and fill in the missing configuration parts with default values but also tell
    the user that parts of the configuration file cannot be loaded.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, the error message should give detailed hints at which point the
    parsing failed. Therefore, the exception handling could be extended to know exactly
    what went wrong, and where. For relaxed handling, as much additional information
    about affected models, instances, or settings as possible should be presented
    to the user.
  prefs: []
  type: TYPE_NORMAL
- en: It is up to the creator of an application to decide which strategy fits best.
    Usually, an attempt to recover as much data as possible should be made. Losing
    only a small part of the created work is better than losing all data.
  prefs: []
  type: TYPE_NORMAL
- en: Common errors leading to corrupted files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A couple of factors can render your saved configuration file corrupt. Some
    common causes are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Disk or partition is filled up to 100% while writing the file: Even with the
    large amount of storage we have today, this may happen, and you have only parts
    of your data saved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Permission problems: Sometimes, you might have permission to create files but
    not to write file content. So, your files seem to be saved, but the file has a
    length of zero bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Connection errors when saving to remote places: Your connection may be interrupted
    while writing a larger file, resulting in a partially written file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Conversion errors, for instance, by sending files per email: A mail program
    or a mail server may convert the file in an incorrect manner, leading to a partially
    corrupt file with some replaced characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Incompatible locale setting: The machine where the file was saved could have
    used the comma as a decimal separator while your computer uses a point as the
    decimal separator. The numbers in the file will be misinterpreted or even set
    to zero if parsing fails. This problem is tricky to find and gets overlooked easily.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Coding errors, like wrong version handling, wrong conversions, or incomplete
    error/exception handling: You might save not all data, convert the data by accident
    to a wrong format, or miss parsing some of the data in the file. You should test
    the code reading and writing files for as many possible data types and object
    combinations as possible to find such errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should be aware that your save files could get corrupted on your machine
    or on the way from or to you. So, save your work often, use a versioning system
    like Git to store different versions of the files, and back up all your configuration
    files on a regular basis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have the code to save and load the state of the application, we
    can provide a predefined default configuration at application startup.
  prefs: []
  type: TYPE_NORMAL
- en: Loading a default configuration file at startup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To help a user explore a new application, next to an extensive tutorial, a simple
    example of the content created with the application can be loaded at the first
    start, or maybe at any start of the application. Tinkering around with the available
    options helps us understand how the application works, and what kind of content
    manipulations are possible.
  prefs: []
  type: TYPE_NORMAL
- en: Loading a default configuration at startup can be achieved in different ways.
    A configuration file could be added at compile time (*baked* into the application),
    or one or more example files could be placed in a reachable folder, and the example
    file loaded at startup. Often, a separate configuration setting for the application
    is available to disable the automated loading of an example file.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we will load the configuration file `config/conf.acfg` from the
    load and save dialogs at application startup. Thanks to the already implemented
    YAML parser and file-loading code, the changes to the renderer class can be done
    with only a couple of lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the default configuration file as a new `private` member variable
    `mDefaultConfigFileName` of the renderer class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Hard-coding file paths or file names should be avoided in general, but for the
    first configuration file, we end up in a chicken/egg problem. If we want to store
    the name of the default configuration in another configuration file, instead of
    hard-coding the file name in the code, we will need another hard-coded file name.
    Such a bootstrapping problem can only be solved by hard-coding the first value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the `init()` method of the renderer, we try to load the default configuration
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If the file cannot be found or fails to load, we only create the null model
    and the null instance. Since all other values are set as defaults at the first
    start, we end up with the same application as if we would have no default configuration
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing load and save functionality to an application requires a bit of
    research for the right type of save file, and some more work to actually implement
    the features into the existing code. All changes and new features should be reflected
    in the save file of the application, thus requiring more work to keep the load
    and save code up to date as application features change. By adding a versioning
    schema to the configuration file, we are even able to load configurations from
    different development stages of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we added the ability to save the current configuration of the
    application to a file and load the same configuration back into the application.
    First, we evaluated the advantages and disadvantages of binary and textual save
    files and checked three common text file types to find a fitting format for our
    save files. Next, we explored the chosen YAML file format and implemented the
    save and load functionalities. Finally, we added a default file to load at application
    startup to help the user with the first steps of the application handling.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, will take care of custom cameras in the application. Currently,
    we use only the *internal* camera to fly around in the virtual world. By adding
    custom camera types, more visualization options for the virtual world are possible.
    We will add a third-person-style camera, following one of the instances similar
    to an action game, and a stationary camera that follows one instance. Additionally,
    a simple camera manager will be added, and the configuration of the cameras will
    be also saved in the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Practical sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are some additions you could make to the code:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a menu entry to create a new, empty scene.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Right now, we can only load and save a configuration file. Removing all models
    and instances must still be done by hand. Add a menu entry plus code to remove
    all models and instances at once, giving the user a simple way to start from nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Add a flag and confirmation dialogs if a setting is changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the settings of one model are altered, set a `dirty` flag to remember that
    the user of the application changed the loaded model instance or a saved state.
    Then, if the user wants to load another configuration file, start over with an
    empty configuration or exit the application and show a confirmation dialog to
    make sure a chance is given to save the current settings.
  prefs: []
  type: TYPE_NORMAL
- en: Add a `dirty` marker to the title.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several other applications are presenting some kind of notice to the user, stating
    that changes have been made since the last save. The title of the application
    window gets adjusted to show whether we are in edit or view mode, so adding a
    star (*) to the window title, or some words like “Not saved” should be easy.
  prefs: []
  type: TYPE_NORMAL
- en: Additional resource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is the GitHub repository for `yaml-cpp`: [https://github.com/jbeder/yaml-cpp](https://github.com/jbeder/yaml-cpp).'
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/cppgameanimation](https://packt.link/cppgameanimation)'
  prefs: []
  type: TYPE_NORMAL
- en: '![A qr code with black squares  AI-generated content may be incorrect.](img/QR_code_Discord.png)'
  prefs: []
  type: TYPE_IMG
