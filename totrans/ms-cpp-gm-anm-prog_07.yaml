- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Saving and Loading the Configuration
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存和加载配置
- en: Welcome to *Chapter 5*! In the previous chapter, we added a separate view mode
    to the application. In this view-only mode, the user interface and selection functionality
    are disabled. Then, we added a simplified and, eventually, a full version of undo/redo
    for the instances. Setting changes to an instance can now be reverted, or reapplied.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到*第五章*！在前一章中，我们向应用程序添加了一个单独的视图模式。在这个仅查看模式下，用户界面和选择功能被禁用。然后，我们添加了实例的简化版和最终的全版本撤销/重做。现在，实例的设置更改可以被撤销或重新应用。
- en: In this chapter, we will add the ability to save the configuration of the application
    to a file. First, we will explore different file types to store the data. After
    considering the pros and cons of each type of file and determining a suitable
    file format, we will dive into the structure of the file format. Then, we’ll implement
    a parser class that will allow us to load and save our configuration. Finally,
    we will load a default configuration at application startup, allowing the user
    to play around with the application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将添加将应用程序配置保存到文件的能力。首先，我们将探索不同的文件类型来存储数据。在考虑每种文件类型的优缺点并确定合适的文件格式后，我们将深入研究文件格式的结构。然后，我们将实现一个解析器类，使我们能够加载和保存配置。最后，我们将在应用程序启动时加载默认配置，使用户能够尝试使用应用程序。
- en: For any bigger application, it is crucial to be able to save the current state
    of data that was created or changed, stop the application, and load the data again
    to continue working. It’s also crucial to recover from a hanging or crashed application
    by restoring the latest saved version. You don’t want to risk losing hours of
    your work because the application cannot save the data properly to local or remote
    storage.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何更大的应用程序，能够保存创建或更改的数据的当前状态，停止应用程序，然后再次加载数据以继续工作至关重要。从挂起或崩溃的应用程序中恢复到最新保存版本也同样重要。你不希望因为应用程序无法正确地将数据保存到本地或远程存储而丢失数小时的工作。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Textual or binary file formats – pros and cons
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本或二进制文件格式——优缺点
- en: Choosing a text format to save our data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一种文本格式来保存我们的数据
- en: Exploring the structure of a YAML file
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索YAML文件的结构
- en: Adding a YAML parser
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加YAML解析器
- en: Saving and loading the configuration file
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存和加载配置文件
- en: Loading a default configuration file at startup
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动时加载默认配置文件
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The example source code for this chapter is in the `chapter05` folder, in the
    `01_opengl_load_sve` subfolder for OpenGL and `02_vulkan_load_save` for Vulkan.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例源代码位于`chapter05`文件夹中，在`01_opengl_load_sve`子文件夹中为OpenGL，在`02_vulkan_load_save`中为Vulkan。
- en: Before we add save and load functionality to our application, let’s take a look
    at some ways to save the data to a storage device.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们向应用程序添加保存和加载功能之前，让我们看看一些将数据保存到存储设备的方法。
- en: Textual or binary file formats – pros and Cons
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本或二进制文件格式——优缺点
- en: Whenever you play a game, cut a video, edit a photo, or write a piece of text
    or a book, you will make use of the integrated load and save functions integrated
    with the software you are using. Saving a game at a safe spot, storing a video
    sequence after making a large number of edits, or pressing *Ctrl* + *S* every
    now and then in the text editor has become normal to us.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你玩游戏、剪辑视频、编辑照片、编写文本或书籍时，你都会使用与所使用的软件集成的集成加载和保存功能。在安全位置保存游戏、在大量编辑后存储视频序列，或者在文本编辑器中不时按下*Ctrl*
    + *S*已经变得很正常了。
- en: 'But have you ever thought about the data that is saved and loaded? You might
    have some questions regarding the following functions, like:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，你有没有想过保存和加载数据？你可能对以下功能有一些疑问，比如：
- en: What needs to be stored to fully restore your latest state?
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要存储什么才能完全恢复你的最新状态？
- en: What format should be used to save the data?
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该使用什么格式来保存数据？
- en: What happens if a program is updated? Will I be able to load the saved data?
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果程序更新了会发生什么？我能否加载保存的数据？
- en: Can I read or change the saved file without the original program?
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我能否在没有原始程序的情况下读取或更改保存的文件？
- en: For all programs you only use, the decision about the format and amount of data
    lies in the hands of their developers. But, for our application, we must decide
    which data needs to be saved, and how to save the data to the storage.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你使用的所有程序，关于格式和数据量的决定在于它们的开发者。但是，对于我们的应用程序，我们必须决定哪些数据需要保存，以及如何将数据保存到存储中。
- en: All types of data formats have pros and cons; here is a short round-up.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类型的数据格式都有其优缺点；以下是一个简要总结。
- en: Saving and loading binary data
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存和加载二进制数据
- en: In the early times of the computer era, storage space and computation time were
    expensive, precious, and scarce. To minimize space and time during the save and
    restore process, the data was more or less only a memory dump.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机时代的早期，存储空间和计算时间都很昂贵、宝贵且稀缺。为了在保存和恢复过程中最小化空间和时间，数据基本上只是内存转储。
- en: The data to save was stored in internal data types, into a memory area of the
    computer and then literally copied byte by byte to a floppy disk or a hard drive.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要保存的数据存储在内部数据类型中，进入计算机的内存区域，然后逐字节地复制到软盘或硬盘上。
- en: 'Loading the same data was as easy and fast as saving it: read the data from
    the storage device to the computer’s memory (again, byte by byte) and interpret
    it as the same internal data types that were used while saving.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 加载相同的数据与保存它一样简单快捷：从存储设备读取数据到计算机内存（再次，逐字节）并将其解释为保存时使用的相同内部数据类型。
- en: 'Let’s take a look at some of the advantages and disadvantages of binary data:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看二进制数据的优点和缺点：
- en: '**Advantages**:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**：'
- en: Files are small.
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件较小。
- en: Saving and loading the data can be done by just copying the data, leading to
    a higher speed for save and load operations.
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过仅复制数据即可保存和加载数据，这导致保存和加载操作的速度更快。
- en: '**Disadvantages**:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**：'
- en: To change the data outside the application, special knowledge is needed.
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在应用程序外部更改数据，需要特殊知识。
- en: Corrupted data could cause unpredictable side effects or crashes.
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 损坏的资料可能会引起不可预测的副作用或崩溃。
- en: Updates to the save file format may be hard. *Magic bytes* are needed to find
    the actual version and to map the loaded data to the correct internal data types.
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存文件格式的更新可能很困难。需要使用**魔数**来找到实际版本，并将加载的数据映射到正确的内部数据类型。
- en: Binary data may not be portable across architectures due to different endianness.
    For this reason, it is generally good advice to avoid binary save files unless
    absolutely necessary. We can still read `CONFIG.SYS` and `AUTOEXEC.BAT` files
    created on MS-DOS systems 30 years ago, but the binary save files from spreadsheet
    calculators or word processors of the same time are unusable, at least without
    the correct tools or hard work to reverse-engineer the file format. Outside of
    well-documented and standardized formats, like pictures or sound files, saving
    binary data **will** cause trouble, as you may not be able to open the binary
    files on a different operating system, or even just a newer version of the same
    system. Also, loading the file on a different CPU architecture, bit width, or
    endianness will most probably fail due to a different memory layout of the data
    types.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不同的字节序，二进制数据可能无法在不同的架构之间移植。因此，除非绝对必要，否则通常建议避免使用二进制保存文件。我们仍然可以读取30年前在MS-DOS系统上创建的`CONFIG.SYS`和`AUTOEXEC.BAT`文件，但同一时期的电子表格计算器或文字处理器的二进制保存文件是无法使用的，至少在没有正确工具或进行逆向工程文件格式的艰苦工作的情况下是这样。在像图片或声音文件这样有良好文档和标准化的格式之外，保存二进制数据**将会**引起麻烦，因为你可能无法在不同的操作系统上打开二进制文件，甚至可能无法打开同一系统的较新版本。
- en: Since CPU time and storage space are no longer limited, the advantages of text
    formats now clearly outweigh those of binary saves.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于CPU时间和存储空间不再受限，文本格式的优势现在明显超过了二进制保存的优势。
- en: Saving and loading textual data
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存和加载文本数据
- en: After more and more CPU power, network bandwidth, and storage space became available,
    textual formats started to become the first choice to save data. Developing code
    is much easier when you can create or adjust the saved files with a simple text
    editor, or when you can find errors by printing the text lines to log files.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 随着CPU性能、网络带宽和存储空间的不断增加，文本格式开始成为保存数据的首选。当你可以使用简单的文本编辑器创建或调整保存文件，或者可以通过将文本行打印到日志文件中查找错误时，编写代码会变得容易得多。
- en: 'For a text-based save file, the conditions differ from those for a binary save:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于文本的保存文件，条件与二进制保存文件的条件不同：
- en: Files are larger, except when they are compressed into a .zip file or similar.
    Then, another transformation step (pack/unpack) is needed.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件较大，除非它们被压缩成.zip文件或类似的格式。那时，还需要另一个转换步骤（打包/解包）。
- en: Data must be transformed from binary representation to text and back, every
    time the data is loaded and saved.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次加载数据和保存数据时，数据都必须从二进制表示形式转换为文本，然后再转换回来。
- en: Domain-specific knowledge of the file format may be required for larger changes,
    or to create a save file *from scratch*. But for simple value changes, a text
    editor is the only tool we need.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于较大的更改或从头创建保存文件，可能需要特定于域的文件格式知识。但对于简单的值更改，我们只需要一个文本编辑器。
- en: Corrupted data can be fixed, or the corrupt data elements may be simply deleted
    from the text file. Better to lose only some data than all of it.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 损坏的文件可以修复，或者可以直接从文本文件中删除损坏的数据元素。宁愿丢失一些数据，也不要全部丢失。
- en: File format updates can be detected by advancing a version number in the file,
    helping the application to use the correct transformations.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在文件中增加版本号，可以检测文件格式的更新，帮助应用程序使用正确的转换。
- en: Loading the same file on a computer with a different architecture or operating
    system is no problem at all. The textual representation is the same, and due to
    the transformation from text to binary data types, endianness or data type lengths
    do not matter.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在具有不同架构或操作系统的计算机上加载相同的文件根本不是问题。文本表示法是相同的，并且由于从文本到二进制数据类型的转换，字节序或数据类型长度并不重要。
- en: Some caveats still exist for cross-platform usage, like different path separators
    in Windows and Linux, or the different interpretation of points and commas in
    the locale settings of the system.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于跨平台使用，仍然存在一些注意事项，例如 Windows 和 Linux 中的不同路径分隔符，或者系统区域设置中点号和逗号的不同解释。
- en: If the configuration needs to be split into multiple files, packing all files
    into a compressed file is the most common way. By adding all configuration files
    in a `.zip` or `.tar.gz` file, you end up with only a single file, and save some
    disk space due to the compression.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要将配置分割成多个文件，将所有文件打包到压缩文件中是最常见的方式。通过将所有配置文件添加到 `.zip` 或 `.tar.gz` 文件中，最终得到一个单独的文件，并且由于压缩节省了一些磁盘空间。
- en: Using a textual representation for our save file is the way to go. And, by defining
    a simple file format, it is even possible to create a configuration file by hand.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文本表示法来保存文件是可行的。通过定义简单的文件格式，甚至可以手动创建配置文件。
- en: But, before we start creating a file format on our own, let’s check some available
    file formats. By using a well-known file format, we can save a lot of time since
    we don’t have to create the functions to parse and write a file.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在我们自己创建文件格式之前，让我们检查一些可用的文件格式。通过使用众所周知的文件格式，我们可以节省大量时间，因为我们不需要创建解析和写入文件的函数。
- en: Choosing a text format to save our data
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择文本格式来保存我们的数据
- en: 'We will look at three popular configuration file formats in this section:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨三种流行的配置文件格式：
- en: '**INI**'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**INI**'
- en: '**JSON**'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSON**'
- en: '**YAML**'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**YAML**'
- en: All three formats find applications in certain fields but may not be suitable
    in others.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三种格式在某些领域都有应用，但可能不适合其他领域。
- en: The INI file format
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: INI 文件格式
- en: One of the oldest formats to store configuration data is the so-called INI format.
    The name comes from the file extension `.ini`, which is a three-letter abbreviation
    for initialization. An INI file is mostly used to configure programs.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 存储配置数据的最古老格式之一是所谓的 INI 格式。这个名字来自文件扩展名 `.ini`，它是初始化的三个字母缩写。INI 文件主要用于配置程序。
- en: In the INI file, simple key/value pairs are stored and organized in optional
    sections. A section name is enclosed in square brackets, and the section scope
    runs from the start of the section to the start of another section, or the end
    of the file.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 INI 文件中，简单的键/值对存储并组织在可选的部分中。部分名称用方括号括起来，部分作用域从部分的开始到另一个部分的开始，或文件的末尾。
- en: 'Here is an example of a section and some key/value pairs for a database connection:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个数据库连接的示例部分和一些键/值对：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Sections can be nested to create some sort of hierarchy by separating sections
    and subsections by special characters, like a dot (`.`) or a backslash (`\`).
    It’s crucial for the parser to recognize these section divisions; otherwise, each
    section will be treated independently, without considering their hierarchical
    relationship.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用特殊字符（如点`.`或反斜杠`\`）分隔部分和子部分，可以嵌套部分以创建某种层次结构。对于解析器识别这些部分划分至关重要；否则，每个部分都将独立处理，不考虑它们之间的层次关系。
- en: The lack of duplicate key names makes it hard to store hierarchical or non-trivial
    data where the same key may occur more than once, like a model file or an instance
    configuration.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 缺乏重复键名使得存储具有重复键的分层或非平凡数据变得困难，例如模型文件或实例配置。
- en: The JSON file format
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON 文件格式
- en: JSON, short for JavaScript Object Notation, made its debut in the early 2000s.
    As in the INI file, key/value pairs are stored in a JSON file. Sections similar
    to the INI file sections do not exist; instead, a JSON file allows the creation
    of complex, tree-like hierarchies. Also, arrays of the same data type can be defined.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: JSON，即 JavaScript 对象表示法，在 2000 年代初首次亮相。与 INI 文件一样，键/值对存储在 JSON 文件中。与 INI 文件部分类似的部分不存在；相反，JSON
    文件允许创建复杂、树状的结构。此外，可以定义相同数据类型的数组。
- en: The main usage for JSON files is electronic data interchange, for instance,
    between web applications and backend servers. Good readability of the file format
    by humans is only a side effect; JSON files are mostly read and written by applications.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 文件的主要用途是电子数据交换，例如，在 Web 应用程序和后端服务器之间。文件格式的良好可读性只是副作用；JSON 文件主要是由应用程序读取和编写的。
- en: 'This is an example of a JSON file, containing the same data as the INI file
    example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 JSON 文件的示例，包含与 INI 文件示例相同的数据：
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Sadly, due to the large number of braces, the file format is hard to write correctly
    on the first try. Also, no comments are allowed, so testing different options
    *on the fly* can only be done by saving a copy of the original file and adjusting
    the content.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，由于大括号数量众多，第一次尝试正确编写文件格式是困难的。此外，不允许注释，因此只能在保存原始文件的副本并调整内容的情况下，*实时* 测试不同的选项。
- en: The YAML file format
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: YAML 文件格式
- en: The name YAML was originally an acronym for *Yet Another Markup Language*. At
    the start of the 2000s, the *yet another* prefix for a product name was used as
    computer-related humor, stating the ever-growing repetition of unoriginal ideas.
    But, since YAML is not a markup language like HTML or XML, the meaning of the
    name was changed to the recursive acronym *YAML Ain’t Markup Language*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 的名字最初是一个缩写，代表 *Yet Another Markup Language*。在 2000 年代初，产品名称前缀的 *yet another*
    被用作与计算机相关的幽默，表明原创想法的不断重复。但是，由于 YAML 不是一个像 HTML 或 XML 那样的标记语言，因此名字的含义被改为递归缩写 *YAML
    Ain’t Markup Language*。
- en: YAML and JSON are closely related. A JSON file can be transformed into a YAML
    file, and vice versa. The main difference between the two formats is that instead
    of using curly braces, the hierarchy in YAML is created by indents.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 和 JSON 密切相关。一个 JSON 文件可以被转换成 YAML 文件，反之亦然。这两种格式之间的主要区别是，YAML 中使用缩进来创建层次结构，而不是使用大括号。
- en: YAML’s main goal was to be readable by humans. The YAML format is widely used
    to create and maintain structured and hierarchical configuration files (i.e.,
    in configuration management systems and cloud environments).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 的主要目标是使人类可读。YAML 格式广泛用于创建和维护结构化和层次化的配置文件（例如，在配置管理系统和云环境中）。
- en: 'Here is an example of the YAML file format, again with the same data as INI
    and JSON:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个 YAML 文件格式的示例，再次使用与 INI 和 JSON 相同的数据：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Since the YAML format is simple and powerful, has all the features we need,
    and can be read and written without stumbling over missing braces, like in JSON,
    we will use a YAML file to store the configuration data for our application.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 YAML 格式简单且强大，具备我们所需的所有功能，并且可以像 JSON 一样无需在缺失的大括号上卡壳进行读写，因此我们将使用 YAML 文件来存储我们应用程序的配置数据。
- en: Exploring the structure of a YAML file
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 YAML 文件的结构
- en: 'Let’s look at the three main components of a YAML file:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 YAML 文件的主要三个组成部分：
- en: '**Nodes**'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点**'
- en: '**Maps**'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**映射**'
- en: '**Sequences**'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**序列**'
- en: Let’s start with the node.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从节点开始。
- en: The YAML node
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: YAML 节点
- en: The main object of a YAML file is a so-called node. A node represents the data
    structure below it, which can be a scalar value, a map, or a sequence.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 文件的主要对象是一个所谓的节点。节点代表其下面的数据结构，可以是标量值、映射或序列。
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Both `database-config` and `type` are YAML nodes. While the `database-config`
    node holds a map containing the key `type` and the value `mysql`, the node type
    just has the scalar value `mysql` in it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`database-config` 和 `type` 都是 YAML 节点。虽然 `database-config` 节点包含一个包含键 `type`
    和值 `mysql` 的映射，但 `type` 节点中仅包含标量值 `mysql`。'
- en: The YAML map
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: YAML 映射
- en: 'A YAML map contains between zero and an arbitrary number of key/value pairs.
    Plus, there is an interesting correlation between nodes and maps: the key and
    the value may be another node, creating the hierarchy in the file.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 YAML 映射包含零个或任意数量的键/值对。此外，节点和映射之间存在一个有趣的关联：键和值可能又是另一个节点，从而在文件中创建层次结构。
- en: 'Let’s extend the configuration snippet from the node section before:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展节点部分之前的配置片段：
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As stated before, `database-config` is both a node and a map. The key of the
    map named `database-config` is the name `database-config`, and the value is another
    map, containing the three key/value pairs.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`database-config` 既是节点也是地图。名为 `database-config` 的地图的键是名称 `database-config`，值是另一个包含三个键值对的地图。
- en: The YAML sequence
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: YAML 序列
- en: To enumerate similar elements, a YAML sequence is used. A sequence can be seen
    as a C++ `std::vector`, where all elements must be of the same kind. Like the
    C++ vector, you iterate over the sequence, reading the data elements one by one.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了列举相似元素，使用 YAML 序列。序列可以看作是一个 C++ `std::vector`，其中所有元素必须是同一类型。像 C++ 向量一样，你遍历序列，逐个读取数据元素。
- en: 'Sequences come in two different flavors: the *block style* and the *flow style*.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 序列有两种不同的风格：*块风格*和*流风格*。
- en: 'In the block style, an indented dash (`-`) is used as an indicator of the elements:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在块风格中，缩进的破折号（`-`）用作元素的指示符：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In contrast, the flow style uses square brackets, and the elements are separated
    by commas:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，流风格使用方括号，元素之间用逗号分隔：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Both styles represent the same data. It is a matter of personal preference and
    readability.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种风格表示相同的数据。这取决于个人喜好和可读性。
- en: By combining maps and sequences, complex data structures can be created.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过组合地图和序列，可以创建复杂的数据结构。
- en: Combinations of maps and sequences
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地图和序列的组合
- en: 'A powerful way to represent data can be achieved by mixing maps and sequences.
    For instance, we could store the `position` and `rotation` of all our model instances
    like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过混合地图和序列，可以实现表示数据的一种强大方式。例如，我们可以像这样存储所有模型实例的 `position` 和 `rotation`：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, both combinations of maps and sequences are used.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了地图和序列的组合。
- en: First, we create a map out of the keys `position` and `rotation`; the values
    are flow-style sequences of numbers, representing a `glm::vec3`. YAML always stores
    the shortest possible representation of a scalar number. So, as long as values
    have no fractional part, an integer value will be used, even for `float` and `double`
    types. Then, the map of `position` and `rotation` is used in a block sequence
    to create an array-style representation of the model instances.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个由键 `position` 和 `rotation` 组成的地图；值是表示 `glm::vec3` 的流式序列数字。YAML 总是存储标量数字的最短可能表示形式。因此，只要值没有小数部分，就会使用整数值，即使对于
    `float` 和 `double` 类型也是如此。然后，使用 `position` 和 `rotation` 的地图在块序列中创建模型实例的数组式表示。
- en: To read the data of the instances into our application, we must first iterate
    over the model instance sequence, and for every instance, we can extract the position
    and rotation values.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要将实例的数据读入我们的应用程序，我们必须首先遍历模型实例序列，并且对于每个实例，我们可以提取位置和旋转值。
- en: After the basic excurse into the YAML file format, we will now implement a YAML
    parser and writer class for our application to save and load its configuration.
    Having the configuration stored on disk is like saving a text document – we can
    quit the application and continue to work in the virtual world later. We can also
    use the saved files to return to the previous state of the virtual world.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在对 YAML 文件格式的基本介绍之后，我们现在将为我们的应用程序实现一个 YAML 解析器和写入器类，以便保存和加载其配置。将配置存储在磁盘上就像保存一个文本文档一样——我们可以退出应用程序，稍后再继续在虚拟世界中工作。我们还可以使用保存的文件返回到虚拟世界的先前状态。
- en: Adding a YAML parser
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 YAML 解析器
- en: 'Like other tools we are already using (the Open Asset Import Library, GLFW,
    or ImGui), we will use a freely available open source solution: `yaml-cpp`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们正在使用的其他工具（如 Open Asset Import Library、GLFW 或 ImGui）一样，我们将使用一个免费的开源解决方案：`yaml-cpp`。
- en: By integrating `yaml-cpp`, we can read and write YAML files from C++ with minimal
    effort. The biggest step is to make sure our custom data types are known to `yaml-cpp`.
    Plus, we have to think about a proper structure for the data file.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过集成 `yaml-cpp`，我们可以用最小的努力从 C++ 中读取和写入 YAML 文件。最大的步骤是确保我们的自定义数据类型为 `yaml-cpp`
    所知。此外，我们必须考虑数据文件的正确结构。
- en: Let’s start by exploring how to integrate `yaml-cpp` into our project.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先探讨如何将 `yaml-cpp` 集成到我们的项目中。
- en: Getting yaml-cpp
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取 yaml-cpp
- en: 'For Linux systems, getting `yaml-cpp` is easy. Similar to the other tools,
    most distributions already contain the `yaml-cpp` library and header files. For
    instance, in Ubuntu 22.04 or later, `yaml-cpp` and its development files can be
    installed with the following command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Linux 系统，获取 `yaml-cpp` 很容易。与其他工具类似，大多数发行版已经包含了 `yaml-cpp` 库和头文件。例如，在 Ubuntu
    22.04 或更高版本中，可以使用以下命令安装 `yaml-cpp` 和其开发文件：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you are using an Arch based Linux distribution, you can install `yaml-cpp`
    with the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是基于 Arch 的 Linux 发行版，可以使用以下命令安装 `yaml-cpp`：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For Windows, we are also in luck. `yaml-cpp` uses CMake, and by using the CMake
    `FetchContent` commands, downloading `yaml-cpp` can be added to the project with
    only a couple of lines. First, we add the `FetchContent` declaration to the `CMakeLists.txt`
    file in the project root. We are using version `0.8.0` of `yaml-cpp`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows，我们也同样幸运。`yaml-cpp` 使用 CMake，通过使用 CMake 的 `FetchContent` 命令，只需几行代码就可以将
    `yaml-cpp` 添加到项目中。首先，我们在项目根目录下的 `CMakeLists.txt` 文件中添加 `FetchContent` 声明。我们使用
    `yaml-cpp` 的 `0.8.0` 版本：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Make sure we are inside a `WIN32` section in the `CMakeLists.txt` file. We do
    not need to download the library on Linux.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 确保我们在 `CMakeLists.txt` 文件的 `WIN32` 部分内部。在 Linux 上我们不需要下载库。
- en: 'Then, we trigger the download of `yaml-cpp` and add the variables for the directories:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们触发 `yaml-cpp` 的下载并添加目录变量：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Windows also needs a script to detect the downloaded dependency. The detection
    script must be named `Findyaml-cpp.cmake` and placed into the `cmake` folder.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 还需要一个脚本来检测下载的依赖项。检测脚本必须命名为 `Findyaml-cpp.cmake` 并放置在 `cmake` 文件夹中。
- en: 'The main function of the script boils down to these two CMake functions:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的主要功能归结为这两个 CMake 函数：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Thanks to CMake’s `FetchContent`, the `YAML-CPP_DIR` variable is populated with
    the path to the downloaded `yaml-cpp` code. So, the script only checks if the
    header and library can be found.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢 CMake 的 `FetchContent`，`YAML-CPP_DIR` 变量被填充为下载的 `yaml-cpp` 代码的路径。因此，脚本只需检查头文件和库是否可以找到。
- en: Integrating yaml-cpp into the CMake build
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 yaml-cpp 集成到 CMake 构建
- en: For Linux and Windows, we must set the proper include path for the compiler,
    and we must add the `yaml-cpp` libraries to the list of linked libraries.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Linux 和 Windows，我们必须为编译器设置正确的包含路径，并将 `yaml-cpp` 库添加到链接库列表中。
- en: 'To update the `include` path, add the `YAML_CPP_INCLUDE_DIR` variable to the
    `include_directories` directive:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新 `include` 路径，将 `YAML_CPP_INCLUDE_DIR` 变量添加到 `include_directories` 指令中：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And for the linker, add `yaml-cpp::yaml-cpp` to `target_link_libraries` in
    Windows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于链接器，需要在 Windows 中将 `yaml-cpp::yaml-cpp` 添加到 `target_link_libraries`：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For Linux, only the name `yaml-cpp` of the shared library is needed:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Linux，只需要共享库的名称 `yaml-cpp`：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After running CMake again, `yaml-cpp` will be downloaded and made available
    to the rest of the code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行 CMake 后，`yaml-cpp` 将被下载并可供代码的其他部分使用。
- en: Adding the parser class
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加解析器类
- en: 'Parsing the YAML file for loading and creating the content for writing will
    be done in a new class called `YamlParser`, located in the `tools` directory.
    We can use `yaml-cpp` in our code after including the header file:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 解析 YAML 文件以加载和创建写入内容将在一个名为 `YamlParser` 的新类中完成，该类位于 `tools` 目录中。我们可以在包含头文件后使用
    `yaml-cpp`：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To store the intermediate data while loading or creating a data structure to
    save to disk, two additional private members are needed:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载或创建用于保存到磁盘的数据结构时，需要两个额外的私有成员来存储中间数据：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`YAML::Node` transforms the nodes of a YAML file from the disk into a C++ data
    structure, simplifying the access to the data that has been loaded. `YAML::Emitter`
    is used to create a YAML file in memory by appending data elements, eventually
    writing the structured data to a file.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`YAML::Node` 将 YAML 文件的节点从磁盘转换为 C++ 数据结构，简化了对已加载数据的访问。`YAML::Emitter` 用于通过追加数据元素在内存中创建
    YAML 文件，最终将结构化数据写入文件。'
- en: Using the node type of yaml-cpp
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 yaml-cpp 的节点类型
- en: 'Accessing the structured or scalar data of a `yaml-cpp` node is done by using
    the node name as the index to the C++ map stored in the `YAML::Node` class:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用节点名称作为 `YAML::Node` 类中存储的 C++ 映射的索引来访问 `yaml-cpp` 节点的结构化或标量数据：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To retrieve the scalar value of a simple key/value map, the special operator
    `as` exists:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索简单键/值映射的标量值，存在特殊运算符 `as`：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Since a YAML file has no knowledge of the data types stored in the value, we
    have to explicitly tell `yaml-cpp` how to interpret the incoming data. Here, `yaml-cpp`
    will try to get the value of the `dataNode` node as `int`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 YAML 文件不了解存储在值中的数据类型，我们必须明确告诉 `yaml-cpp` 如何解释传入的数据。在这里，`yaml-cpp` 将尝试获取 `dataNode`
    节点的值为 `int`。
- en: 'After defining a transformation template, custom data types like structs can
    also be read directly into a variable of the same type:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了转换模板之后，也可以直接将自定义数据类型如结构体读入相同类型的变量中：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We will handle transformation templates in the *Saving and loading the configuration
    file* section.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在**保存和加载配置文件**部分处理转换模板。
- en: Accessing sequences and maps
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问序列和映射
- en: 'In `yaml-cpp`, sequences can be read by iterating over them using a `for` loop,
    and accessing the element by the index:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `yaml-cpp` 中，可以通过使用 `for` 循环遍历它们来读取序列，并通过索引访问元素：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The elements of the sequence are made available in the same order as they appear
    in the YAML file.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 序列的元素以它们在 YAML 文件中出现的顺序提供。
- en: 'For maps, an iterator-style `for` loop is needed:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于映射，需要一个迭代风格的 `for` 循环：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The key of the map element can be read via the `first` accessor of the C++ map
    container. Again, we must tell `yaml-cpp` which data type the map key is. Then,
    the value can be retrieved with the `second` accessor of the C++ map container.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 映射元素的键可以通过 C++ 映射容器的 `first` 访问器读取。同样，我们必须告诉 `yaml-cpp` 映射键的数据类型。然后，可以使用 C++
    映射容器的 `second` 访问器检索值。
- en: If reading a value fails, for instance, because the type is wrong or no such
    node exists, an exception will be thrown. To avoid our program being terminated,
    we must handle all thrown exceptions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果读取值失败，例如，因为类型错误或不存在这样的节点，将抛出异常。为了避免我们的程序被终止，我们必须处理所有抛出的异常。
- en: Handling exceptions thrown by yaml-cpp
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理由 yaml-cpp 抛出的异常
- en: 'Instead of returning an error code, `yaml-cpp` throws exceptions whenever something
    goes wrong. By default, any unhandled exception terminates the program. Handling
    an exception in C++ is done like in other languages:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`yaml-cpp` 在出错时抛出异常，而不是返回错误代码。默认情况下，任何未处理的异常都会终止程序。在 C++ 中处理异常的方式与其他语言类似：'
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The call that may cause an exception will be enclosed in a `try` block, and
    in case of an exception, the `catch` block will be executed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 可能引发异常的调用将被包含在 `try` 块中，如果发生异常，则执行 `catch` 块。
- en: We can simply catch all exceptions since any parsing failure may result in an
    empty or incomplete configuration file. If you want to have more detailed exception
    handling, you can explore the `yaml-cpp` source code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地捕获所有异常，因为任何解析失败可能会导致配置文件为空或不完整。如果您想要更详细的异常处理，可以探索 `yaml-cpp` 的源代码。
- en: Armed with the basics of `yaml-cpp`, we can start implementing the code to save
    and load a YAML file. We will start with the save functionality because after
    we have created a file on disk, loading the data elements back into the application
    will be much easier compared to hand-crafting a configuration file first.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 借助 `yaml-cpp` 的基础知识，我们可以开始实现保存和加载 YAML 文件的代码。我们将从保存功能开始，因为在我们已经在磁盘上创建了一个文件之后，将数据元素重新加载到应用程序中将会比首先手工制作配置文件要容易得多。
- en: Saving and loading the configuration file
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存和加载配置文件
- en: Building our configuration file starts with the decision of what needs to be
    stored and how we want to store the elements. By reusing our custom data types
    like the `InstanceSettings`, creating the functions to save and load a file can
    be simplified. Now we no longer have to read each value individually, but we can
    use calls like `getInstanceSettings()` and `setInstanceSettings()` from the `AssimpInstance`
    class to transfer the values directly between the parser and the instance.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 构建我们的配置文件始于决定需要存储什么以及我们希望如何存储元素。通过重用我们的自定义数据类型，如 `InstanceSettings`，创建保存和加载文件的函数可以简化。现在我们不再需要逐个读取每个值，而是可以使用来自
    `AssimpInstance` 类的 `getInstanceSettings()` 和 `setInstanceSettings()` 调用来直接在解析器和实例之间传递值。
- en: We will start by exploring what we want to save, and after adding the code to
    write our custom data to the file, a user interface dialog will be added, allowing
    a simple way to save the file to disk. Finally, we will step through the process
    of loading the configuration back into the application.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先探索我们想要保存的内容，在添加将我们的自定义数据写入文件的代码之后，将添加一个用户界面对话框，允许以简单的方式将文件保存到磁盘。最后，我们将逐步通过将配置重新加载到应用程序中的过程。
- en: Deciding what to store in the configuration file
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 决定在配置文件中存储什么
- en: As mentioned in the *Saving and loading textual data* section, adding a version
    number can help a lot during the development of an application. If we need to
    change the data format, even slightly, raising the version number can help us
    to simplify branching between the old and new format(s) when reading a file.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如**保存和加载文本数据**部分所述，添加版本号可以在应用程序的开发过程中非常有帮助。如果我们需要更改数据格式，即使只是轻微的更改，提高版本号可以帮助我们在读取文件时简化在旧格式和新格式之间的分支。
- en: Next, we should store the information about the selection. Restoring the selected
    model and instance, we can continue exactly from the same spot where we saved
    the configuration file.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该存储有关选择的信息。恢复选定的模型和实例后，我们可以从保存配置文件的地方继续。
- en: Also, we should store the camera information. When working with more complex
    scenes later in the book, restoring the camera to the default position and angles
    may confuse the application user.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还应该存储相机信息。在本书后面处理更复杂的场景时，将相机恢复到默认位置和角度可能会让应用程序用户感到困惑。
- en: As the most important parts, we must store all information about the models
    and all instances on the screen required to restore the application to the same
    state as at the time of saving the configuration.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最重要的部分，我们必须存储所有关于模型和所有屏幕上所需的信息，以便将应用程序恢复到保存配置时的相同状态。
- en: 'For the model, the file name and path are sufficient, as we use the file name
    as the model’s name. The path to the model file will be saved relative to the
    application executable, and not as an absolute path, at least as long as the model
    resides on the same partition as the executable (Windows only). Both methods have
    their pros and cons:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于模型，文件名和路径就足够了，因为我们使用文件名作为模型的名称。模型文件的路径将相对于应用程序的可执行文件保存，而不是绝对路径，至少在模型位于与可执行文件相同的分区上时是这样（仅限
    Windows）。这两种方法都有其优缺点：
- en: A relative path allows the user to check out the code from the book anywhere
    on their system, being able to use the example configuration file and example
    models *out of the box*. However, moving the executable to another directory or
    partition requires all configuration data and models to be moved too, or the configuration
    files must be manually adjusted.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相对路径允许用户从系统上的任何位置检出代码，能够直接使用示例配置文件和示例模型。然而，将可执行文件移动到另一个目录或分区时，需要移动所有配置数据和模型，或者必须手动调整配置文件。
- en: Using an absolute path may become handy to store a new configuration at a fixed
    location on the PC (i.e., in the home directory of the user). This way, the application
    could be started from any place on the PC and still find the configuration files
    and models.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用绝对路径可能便于在 PC 上的固定位置（例如，在用户的家目录中）存储新的配置。这样，应用程序可以从 PC 上的任何位置启动，并且仍然可以找到配置文件和模型。
- en: To restore all instances, we need all information stored in the `InstanceSetting`s
    struct plus the model name. To simplify restoring the instance via the model name,
    we add the model name as a `std::string` to the `InstanceSettings` struct. Having
    the model name in the struct allows us to hand over a `std::vector` of `InstanceSettings`
    values from the YAML parser to the renderer class; we don’t need more complex
    data structures.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了恢复所有实例，我们需要存储在 `InstanceSetting`s 结构中的所有信息以及模型名称。为了简化通过模型名称恢复实例，我们将模型名称作为
    `std::string` 添加到 `InstanceSettings` 结构中。在结构中拥有模型名称允许我们将从 YAML 解析器传递给渲染类的一个 `InstanceSettings`
    值的 `std::vector`；我们不需要更复杂的数据结构。
- en: Let’s start the implementation by creating custom element writer overloads.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建自定义元素写入器重载开始实现。
- en: Overloading the output operator of the emitter
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重载发射器的输出运算符
- en: 'The creators of `yaml-cpp` added a nice method to output the contents of complex
    structures to the `YAML::Emitter`. We only have to overload the `operator<<` in
    the `YamlParser.cpp` file in the `tools` folder:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`yaml-cpp` 的创建者增加了一个很好的方法，可以将复杂结构的输出内容添加到 `YAML::Emitter` 中。我们只需在 `tools` 文件夹中的
    `YamlParser.cpp` 文件中重载 `operator<<` 即可：'
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For the `glm::vec3` data type, we add a flow type sequence, and then the three
    elements of the vector will be added to the stream. In the final file, a default
    YAML sequence will appear, containing the values of the `glm::vec3` vector as
    in this example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `glm::vec3` 数据类型，我们添加一个流类型序列，然后向流中添加向量的三个元素。在最终的文件中，将出现一个默认的 YAML 序列，包含 `glm::vec3`
    向量的值，如下例所示：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Our `InstanceSettings` struct must be added as the key/value pairs of a YAML
    map. The start and end of the map are set in the function storing the `InstanceSettings`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `InstanceSettings` 结构必须作为 YAML 映射的键/值对添加。映射的开始和结束在存储 `InstanceSettings`
    的函数中设置：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The resulting maps will be added as the value of a YAML sequence, storing all
    relevant instance data in the configuration file.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的映射将被添加为 YAML 序列的值，将所有相关实例数据存储在配置文件中。
- en: Creating and writing the configuration file
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和写入配置文件
- en: 'To create a configuration file, the renderer will instantiate a local object
    of our `YamlParser` class, and call `createConfigFile()` on it:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建配置文件，渲染器将实例化我们的 `YamlParser` 类的一个本地对象，并对其调用 `createConfigFile()`：
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the `createConfigFile()` method, the `YAML::Emitter` will be filled with
    the structures of our data. As an example, we will add a comment at the top of
    the file, and save the version number in the second line:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `createConfigFile()` 方法中，`YAML::Emitter` 将填充我们的数据结构。例如，我们将在文件顶部添加一条注释，并在第二行保存版本号：
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the final YAML file, the following first lines will appear:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终的 YAML 文件中，以下第一行将出现：
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Aa another example, to store the instance settings, we create a map named `instances`,
    and start creating a sequence as the value:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个示例，为了存储实例设置，我们创建一个名为 `instances` 的映射，并开始创建一个序列作为其值：
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, we can create a `for` loop over the instances and use the `getInstanceSettings()`
    call of the instance to directly store the instance settings to the emitter stream:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建一个遍历实例的 `for` 循环，并使用实例的 `getInstanceSettings()` 调用来直接将实例设置存储到发射流中：
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Thanks to the `operator<<` overload, no complex handling inside the loop is
    required.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 `operator<<` 重载，循环内不需要复杂的处理。
- en: 'As the last step, we close the sequence of instance settings, and close the
    map for the `instances` key:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们关闭实例设置的序列，并关闭 `instances` 键的映射：
- en: '[PRE33]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The final YAML file will contain a sequence of all instances, including the
    newly added model file name:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的 YAML 文件将包含所有实例的序列，包括新添加的模型文件名：
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If we want to view the contents of the created configuration file before doing
    any disk writes, we can create a C string and output the string via the logger
    class:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在执行任何磁盘写入之前查看创建的配置文件内容，我们可以创建一个 C 字符串并通过日志类输出该字符串：
- en: '[PRE35]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Writing the file to disk will be done with a `std::ostream`. The error handling
    for the stream has been excluded for brevity in the following listing, but saving
    the file to disk is essentially done in just three lines:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件写入磁盘将使用 `std::ostream` 完成。为了简洁，以下列表中省略了流的错误处理，但将文件保存到磁盘实际上只需三行代码：
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: First, we create the output stream with the given file name. Then, we convert
    the `std::string` of the `YAML::Emitter` to a C string and write the string to
    the output stream. By closing the stream, the file will be flushed to the storage
    device.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用给定的文件名创建输出流。然后，我们将 `YAML::Emitter` 的 `std::string` 转换为 C 字符串，并将字符串写入输出流。通过关闭流，文件将被刷新到存储设备。
- en: Adding a file dialog to the user interface
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向用户界面添加文件对话框
- en: To allow the user to store the configuration file in an arbitrary location and
    with a custom name, we will add a file dialog in the user interface. We are already
    using the ImGui-based file dialog to load a model file, and we can reuse the same
    dialog instance to present a **Save File** dialog to the user.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许用户将配置文件存储在任意位置并使用自定义名称，我们将在用户界面中添加一个文件对话框。我们已经在使用基于 ImGui 的文件对话框来加载模型文件，并且我们可以重用相同的对话框实例向用户展示一个
    **保存文件** 对话框。
- en: To create a dialog that lets the user choose a file name and location, three
    changes to the `IGFD::FileDialogConfig` variable named `config` must be made.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个允许用户选择文件名和位置的对话框，必须对名为 `config` 的 `IGFD::FileDialogConfig` 变量进行三项更改。
- en: 'First, by selecting an existing file, we need an extra dialog to confirm an
    overwriting of the file. Luckily, the file dialog has such a confirmation dialog
    already built in. All we must do is add the flag `ImGuiFileDialogFlags_ConfirmOverwrite`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过选择现有文件，我们需要一个额外的对话框来确认文件覆盖。幸运的是，文件对话框已经内置了这样的确认对话框。我们只需添加标志 `ImGuiFileDialogFlags_ConfirmOverwrite`：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If we select an existing file, a new dialog will be shown, asking the user to
    confirm whether to replace the existing file or not.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择一个现有文件，将显示一个新对话框，询问用户是否要替换现有文件。
- en: 'Next, we will present a default path and file name for the configuration:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将展示默认路径和文件名用于配置：
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, we are using the `config` folder and a file named `config.acfg` to present
    a default file to the user. The file dialog code will automatically enter the
    `config` folder and fill out the file name and extension.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `config` 文件夹和一个名为 `config.acfg` 的文件向用户展示一个默认文件。文件对话框代码将自动进入 `config`
    文件夹并填写文件名和扩展名。
- en: 'As a last step, we add `.acfg` as the only file extension to the dialog:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们将 `.acfg` 作为对话框的唯一文件扩展名添加：
- en: '[PRE39]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: By using a new extension for the configuration file, we avoid trouble, like
    attempts to load a different file format or overwriting other files on the system.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为配置文件使用新的扩展名，我们避免了麻烦，例如尝试加载不同的文件格式或覆盖系统上的其他文件。
- en: 'The **OK** button of the file dialog retrieves the selected file name, and
    calls the callback function responsible for saving the configuration to disk:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 文件对话框中的 **OK** 按钮获取选定的文件名，并调用负责将配置保存到磁盘的回调函数：
- en: '[PRE40]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We store the result of the callback function in the Boolean `saveSuccessful`.
    This way, we can check for any errors and present the user a dialog in case saving
    the configuration was not successful.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回调函数的结果存储在布尔变量 `saveSuccessful` 中。这样，我们可以检查任何错误，并在保存配置不成功的情况下向用户显示对话框。
- en: To inform the user about save errors, only a simple dialog is implemented, notifying
    the user to check the output messages of the application for details about the
    cause of the write error.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通知用户保存错误，仅实现了一个简单的对话框，提示用户检查应用程序的输出消息以获取关于写入错误原因的详细信息。
- en: If you load some models now, create instances or clones, and save the configuration,
    you can inspect the created configuration file. All data from the *Deciding what
    to store in the configuration file* section should be in the configuration file.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在加载一些模型，创建实例或克隆，并保存配置，你可以检查创建的配置文件。所有来自 *决定在配置文件中存储什么* 部分的数据都应该包含在配置文件中。
- en: Saving the data to disk is only half the job. To continue working from the same
    spot where we saved the file, we need to load the configuration file back into
    the application.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据保存到磁盘只是工作的一半。为了从保存文件的位置继续工作，我们需要将配置文件重新加载到应用程序中。
- en: Loading the configuration file back and parsing the nodes
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新加载配置文件并解析节点
- en: To support parsing custom data types in a YAML file, `yaml-cpp` allows us to
    define a C++ template for a struct named `convert`, located in the YAML `namespace`.
    The `convert` struct must implement two methods called `encode` and `decode`,
    doing the process of serializing the C++ types to YAML (`encode`) and deserializing
    from YAML back to C++ (`decode`). By using these two methods, `yaml-cpp` allows
    a seamless transformation between C++ types and YAML entries. The `encode` method
    creates a new YAML node from a primitive or custom data type, while the `decode`
    method reads the YAML node data and returns the primitive or custom data type.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持在 YAML 文件中解析自定义数据类型，`yaml-cpp` 允许我们定义一个位于 YAML `namespace` 中的名为 `convert`
    的 C++ 模板结构体。`convert` 结构体必须实现两个方法，即 `encode` 和 `decode`，这两个方法分别负责将 C++ 类型序列化为
    YAML (`encode`) 以及从 YAML 反序列化回 C++ (`decode`)。通过使用这两个方法，`yaml-cpp` 允许在 C++ 类型与
    YAML 条目之间实现无缝转换。`encode` 方法从一个原始或自定义数据类型创建一个新的 YAML 节点，而 `decode` 方法读取 YAML 节点数据并返回原始或自定义数据类型。
- en: 'For writing a `glm::vec3` element to a YAML node and reading back a YAML node
    to a `glm::vec3`, the following template code must be implemented in a header
    file:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于将 `glm::vec3` 元素写入 YAML 节点并将 YAML 节点读取回 `glm::vec3`，必须在头文件中实现以下模板代码：
- en: '[PRE41]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: To save the data from the `glm::vec3`, we create a new YAML node called `node`
    and add the three elements `x`, `y`, and `z` of the `glm::vec3` to the node. The
    node is then returned to the caller of the `encode()` method.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 `glm::vec3` 保存数据，我们创建一个新的 YAML 节点称为 `node`，并将 `glm::vec3` 的三个元素 `x`、`y` 和
    `z` 添加到节点中。然后，节点被返回给 `encode()` 方法的调用者。
- en: 'Reading back the data from a node into a `glm::vec3` variable is done with
    the `decode()` method:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `decode()` 方法将数据从节点读取到 `glm::vec3` 变量中：
- en: '[PRE42]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Checking the node type for the right type and size is optional, but it is a
    good style assuring we have the correct data for the custom data type to prevent
    runtime errors. Skipping this check and trying to parse the wrong data type will
    lead to an exception, terminating the entire program if unhandled.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 检查节点类型以获取正确类型和大小是可选的，但这是一个良好的风格，确保我们有正确的自定义数据类型数据，以防止运行时错误。跳过此检查并尝试解析错误的数据类型将导致异常，如果未处理，则终止整个程序。
- en: 'Then, we read the data from a node by the sequence index, and set the three
    elements `x`, `y`, and `z` of the `glm::vec3` to the float values from the node:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过序列索引从节点中读取数据，并将 `glm::vec3` 的三个元素 `x`、`y` 和 `z` 设置为节点中的浮点值：
- en: '[PRE43]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After defining the `encode()` and `decode()` methods, we can exchange data
    between a YAML `node` and a `glm::vec3` by a normal assignment:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了 `encode()` 和 `decode()` 方法之后，我们可以通过正常赋值在 YAML `node` 和 `glm::vec3` 之间交换数据：
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The same two methods are implemented for the `InstanceSettings` struct, helping
    us to read the settings of the instance directly back into a variable of the type
    `InstanceSettings`. To avoid polluting the header for our parser class, a new
    header called `YamlParserTypes.h` has been created in the `tools` folder. The
    `YamlParserTypes.h` header will be included in the header of the `YamlParser`
    class to make the new conversions available.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`InstanceSettings`结构，实现了相同的方法，帮助我们直接将实例设置读回到`InstanceSettings`类型的变量中。为了避免污染我们的解析器类头文件，已在`tools`文件夹中创建了一个新的头文件`YamlParserTypes.h`。`YamlParserTypes.h`头文件将被包含在`YamlParser`类的头文件中，以便新的转换可用。
- en: Once the configuration file is successfully parsed, all settings, model paths,
    and instance settings are extracted. But before we can load the models and create
    new instances, we must first clear the current list of models and instances.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置文件成功解析，所有设置、模型路径和实例设置都被提取出来。但在我们可以加载模型和创建新实例之前，我们必须首先清除当前模型和实例列表。
- en: Cleaning up and recreating the scene from the saved values
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从保存的值中清理和重新创建场景
- en: 'Removing all models and instances is a simple and straightforward process.
    In the renderer, we must do the following steps to have a fresh environment:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 移除所有模型和实例是一个简单直接的过程。在渲染器中，我们必须执行以下步骤以获得一个新鲜的环境：
- en: Set `miSelectedInstance` and `miSelectedModel` containing the currently selected
    instance and model to zero. The variables from this step and from *steps 2 and
    3* were introduced in the *Dynamic model and instance management* section of [*Chapter
    1*](Chapter_1.xhtml). Then, at index zero, the new null model and null instance
    will be created.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将包含当前选定的实例和模型的`miSelectedInstance`和`miSelectedModel`设置为零。从本步骤以及*步骤2和3*中引入的变量在[*第一章*](Chapter_1.xhtml)的*动态模型和实例管理*部分中介绍。然后，在索引零处，将创建新的空模型和空实例。
- en: Erase the `miAssimpInstances` vector and clear the `miAssimpInstancesPerModel`
    map. Now, all models are unused.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`miAssimpInstances`向量和清除`miAssimpInstancesPerModel`映射。现在，所有模型都未使用。
- en: Erase the `miModelList` vector. Since all instances were already deleted, the
    shared pointers of the models will be no longer referenced, and the models will
    be deleted.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`miModelList`向量。由于所有实例都已删除，模型的共享指针将不再被引用，模型将被删除。
- en: Add a new null model and a null instance. Both the null model and the null instance
    must be the first elements of the model list and the instances vector and map.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的空模型和一个空实例。空模型和空实例必须是模型列表和实例向量以及映射中的第一个元素。
- en: Clear the undo and redo stacks. In the stacks, we used only weak pointers, so
    this step can be done at any time.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除撤销和重做栈。在栈中，我们只使用了弱指针，因此这一步可以在任何时候进行。
- en: Update the triangle count. After all models and instances were removed, the
    triangle count should be zero.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新三角形计数。在所有模型和实例被移除后，三角形计数应为零。
- en: The entire procedure of cleaning up all models and instances has been added
    to the new `removeAllModelsAndInstances()` method of the renderer class, simplifying
    the usage whenever we need a clean and fresh environment.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 清理所有模型和实例的整个流程已被添加到渲染类的新`removeAllModelsAndInstances()`方法中，简化了每次需要干净且新鲜环境时的使用。
- en: Now, we can load the model files from disk, but without creating the default
    instance. After all models are loaded, we search the model from the `InstanceSettings`
    in the model list, create a new instance, and apply the settings from the configuration
    file.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从磁盘加载模型文件，但不需要创建默认实例。在所有模型加载完毕后，我们从模型列表中的`InstanceSettings`中搜索模型，创建一个新的实例，并应用配置文件中的设置。
- en: Next, we should enumerate the instances as the instance index number is not
    stored in the `InstanceSettings`. But the instance should remain at the same index
    they had at save time, due to the linear reading of the `miAssimpInstances` vector
    when the YAML emitter is created and the same linear reading of the nodes when
    parsing the YAML file.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该列举实例，因为实例索引号并未存储在`InstanceSettings`中。但由于在创建YAML发射器时对`miAssimpInstances`向量的线性读取以及解析YAML文件时对节点的相同线性读取，实例应保持其在保存时的相同索引。
- en: Finally, we restore the camera settings, selected model, and instance plus the
    status of the selection highlight from the parser.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们从解析器中恢复相机设置、选定的模型、实例以及选择高亮的状态。
- en: At this point, the configuration should be fully loaded, and the application
    should contain the same models, instances, and settings as at the time of the
    save operation.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，配置应该已经完全加载，应用程序应包含与保存操作时相同的模型、实例和设置。
- en: 'One question remains for the load process: What should we do if parsing the
    configuration file fails only partially? Maybe a model file was renamed or deleted,
    or the file was truncated or corrupted and the settings of the last instance are
    incomplete.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 对于加载过程，还有一个问题：如果配置文件解析只部分失败，我们应该怎么办？可能是一个模型文件被重命名或删除，或者文件被截断或损坏，导致最后一个实例的设置不完整。
- en: Strict or relaxed configuration file loading
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 严格或宽松配置文件加载
- en: One option to overcome parsing errors is to discard the entire configuration
    prior to deleting all current content of the application. This strict loading
    type is easy to implement; any kind of parsing error invalidates the configuration
    file at parsing time. We ignore the loading request and present just an error
    message to the user.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 一种克服解析错误的方法是在删除应用程序当前所有内容之前丢弃整个配置。这种严格的加载类型易于实现；任何类型的解析错误都会在解析时使配置文件无效。我们忽略加载请求，并向用户显示错误信息。
- en: The other option is relaxed parsing. We try our best to load the valid models
    and fill in the missing configuration parts with default values but also tell
    the user that parts of the configuration file cannot be loaded.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是宽松解析。我们尽力加载有效的模型，并用默认值填充缺失的配置部分，同时也会告知用户配置文件的部分内容无法加载。
- en: In both cases, the error message should give detailed hints at which point the
    parsing failed. Therefore, the exception handling could be extended to know exactly
    what went wrong, and where. For relaxed handling, as much additional information
    about affected models, instances, or settings as possible should be presented
    to the user.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，错误信息应该给出详细的提示，说明解析失败的位置。因此，异常处理可以扩展为确切知道出了什么问题，以及在哪里。对于宽松处理，应尽可能向用户展示受影响模型、实例或设置的相关附加信息。
- en: It is up to the creator of an application to decide which strategy fits best.
    Usually, an attempt to recover as much data as possible should be made. Losing
    only a small part of the created work is better than losing all data.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的创建者决定哪种策略最适合。通常，应尝试尽可能恢复数据。只丢失创建工作的很小一部分比丢失所有数据要好。
- en: Common errors leading to corrupted files
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导致文件损坏的常见错误
- en: 'A couple of factors can render your saved configuration file corrupt. Some
    common causes are listed here:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 几个因素可能导致保存的配置文件损坏。以下列出了一些常见原因：
- en: 'Disk or partition is filled up to 100% while writing the file: Even with the
    large amount of storage we have today, this may happen, and you have only parts
    of your data saved.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在写入文件时磁盘或分区已满至100%：即使我们今天有大量的存储空间，这也可能发生，您只能保存部分数据。
- en: 'Permission problems: Sometimes, you might have permission to create files but
    not to write file content. So, your files seem to be saved, but the file has a
    length of zero bytes.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 权限问题：有时，您可能有创建文件的权限，但没有写入文件内容的权限。因此，您的文件看起来已经保存，但文件长度为零字节。
- en: 'Connection errors when saving to remote places: Your connection may be interrupted
    while writing a larger file, resulting in a partially written file.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存到远程位置时出现的连接错误：在写入较大文件时，您的连接可能会中断，导致文件只部分写入。
- en: 'Conversion errors, for instance, by sending files per email: A mail program
    or a mail server may convert the file in an incorrect manner, leading to a partially
    corrupt file with some replaced characters.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换错误，例如通过电子邮件发送文件：邮件程序或邮件服务器可能会以错误的方式转换文件，导致部分损坏的文件，其中一些字符被替换。
- en: 'Incompatible locale setting: The machine where the file was saved could have
    used the comma as a decimal separator while your computer uses a point as the
    decimal separator. The numbers in the file will be misinterpreted or even set
    to zero if parsing fails. This problem is tricky to find and gets overlooked easily.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不兼容的区域设置：保存文件的机器可能使用逗号作为小数分隔符，而您的计算机使用点作为小数分隔符。文件中的数字可能会被误解，甚至在解析失败时被设置为零。这个问题很难找到，并且很容易被忽视。
- en: 'Coding errors, like wrong version handling, wrong conversions, or incomplete
    error/exception handling: You might save not all data, convert the data by accident
    to a wrong format, or miss parsing some of the data in the file. You should test
    the code reading and writing files for as many possible data types and object
    combinations as possible to find such errors.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程错误，如版本处理错误、转换错误或不完整的错误/异常处理：您可能无法保存所有数据，意外地将数据转换为错误的格式，或者错过解析文件中的某些数据。您应该尽可能多地测试代码的文件读取和写入功能，以找到此类错误。
- en: You should be aware that your save files could get corrupted on your machine
    or on the way from or to you. So, save your work often, use a versioning system
    like Git to store different versions of the files, and back up all your configuration
    files on a regular basis.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您应该意识到，您的保存文件可能在您的机器上或从您那里到那里的路上损坏。因此，经常保存您的作品，使用版本控制系统如Git存储文件的不同版本，并定期备份所有配置文件。
- en: Now that we have the code to save and load the state of the application, we
    can provide a predefined default configuration at application startup.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了保存和加载应用程序状态的代码，我们可以在应用程序启动时提供一个预定义的默认配置。
- en: Loading a default configuration file at startup
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在启动时加载默认配置文件
- en: To help a user explore a new application, next to an extensive tutorial, a simple
    example of the content created with the application can be loaded at the first
    start, or maybe at any start of the application. Tinkering around with the available
    options helps us understand how the application works, and what kind of content
    manipulations are possible.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助用户探索新的应用程序，除了广泛的教程外，还可以在第一次启动时或在任何启动时加载使用应用程序创建的内容的简单示例。通过调整可用的选项可以帮助我们了解应用程序的工作方式，以及可能进行的内容操作。
- en: Loading a default configuration at startup can be achieved in different ways.
    A configuration file could be added at compile time (*baked* into the application),
    or one or more example files could be placed in a reachable folder, and the example
    file loaded at startup. Often, a separate configuration setting for the application
    is available to disable the automated loading of an example file.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动时加载默认配置可以通过不同的方式实现。可以在编译时添加配置文件（*嵌入*到应用程序中），或者在一个可访问的文件夹中放置一个或多个示例文件，并在启动时加载示例文件。通常，应用程序有一个单独的配置设置，可以用来禁用自动加载示例文件。
- en: As an example, we will load the configuration file `config/conf.acfg` from the
    load and save dialogs at application startup. Thanks to the already implemented
    YAML parser and file-loading code, the changes to the renderer class can be done
    with only a couple of lines.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将在应用程序启动时从加载和保存对话框中加载配置文件`config/conf.acfg`。多亏了已经实现的YAML解析器和文件加载代码，对渲染类所做的更改只需几行代码即可完成。
- en: 'First, we define the default configuration file as a new `private` member variable
    `mDefaultConfigFileName` of the renderer class:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将默认配置文件定义为渲染类的一个新的`private`成员变量`mDefaultConfigFileName`：
- en: '[PRE45]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Hard-coding file paths or file names should be avoided in general, but for the
    first configuration file, we end up in a chicken/egg problem. If we want to store
    the name of the default configuration in another configuration file, instead of
    hard-coding the file name in the code, we will need another hard-coded file name.
    Such a bootstrapping problem can only be solved by hard-coding the first value.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 通常应避免硬编码文件路径或文件名，但对于第一个配置文件，我们最终陷入了一个鸡生蛋的问题。如果我们想将默认配置的名称存储在另一个配置文件中，而不是在代码中硬编码文件名，我们需要另一个硬编码的文件名。这种启动问题只能通过硬编码第一个值来解决。
- en: 'Then, in the `init()` method of the renderer, we try to load the default configuration
    file:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在渲染器的`init()`方法中，我们尝试加载默认配置文件：
- en: '[PRE46]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If the file cannot be found or fails to load, we only create the null model
    and the null instance. Since all other values are set as defaults at the first
    start, we end up with the same application as if we would have no default configuration
    at all.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到文件或加载失败，我们只会创建空模型和空实例。由于所有其他值在第一次启动时都设置为默认值，所以我们最终得到的应用程序与完全没有默认配置的情况相同。
- en: Implementing load and save functionality to an application requires a bit of
    research for the right type of save file, and some more work to actually implement
    the features into the existing code. All changes and new features should be reflected
    in the save file of the application, thus requiring more work to keep the load
    and save code up to date as application features change. By adding a versioning
    schema to the configuration file, we are even able to load configurations from
    different development stages of the application.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 将加载和保存功能实现到应用程序中需要一些研究来确定合适的保存文件类型，并且还需要更多的工作来实现这些功能到现有代码中。所有更改和新功能都应该反映在应用程序的保存文件中，因此需要更多的工作来保持加载和保存代码与应用程序功能的更新同步。通过在配置文件中添加版本控制方案，我们甚至能够从应用程序的不同开发阶段加载配置。
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we added the ability to save the current configuration of the
    application to a file and load the same configuration back into the application.
    First, we evaluated the advantages and disadvantages of binary and textual save
    files and checked three common text file types to find a fitting format for our
    save files. Next, we explored the chosen YAML file format and implemented the
    save and load functionalities. Finally, we added a default file to load at application
    startup to help the user with the first steps of the application handling.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们添加了将应用程序当前配置保存到文件并重新加载相同配置到应用程序中的功能。首先，我们评估了二进制和文本保存文件的优缺点，并检查了三种常见的文本文件类型，以找到适合我们保存文件的格式。接下来，我们探讨了选择的
    YAML 文件格式并实现了保存和加载功能。最后，我们添加了一个默认文件，在应用程序启动时加载，以帮助用户处理应用程序的第一步。
- en: In the next chapter, will take care of custom cameras in the application. Currently,
    we use only the *internal* camera to fly around in the virtual world. By adding
    custom camera types, more visualization options for the virtual world are possible.
    We will add a third-person-style camera, following one of the instances similar
    to an action game, and a stationary camera that follows one instance. Additionally,
    a simple camera manager will be added, and the configuration of the cameras will
    be also saved in the configuration file.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将处理应用程序中的自定义相机。目前，我们只使用 *内部* 相机在虚拟世界中飞行。通过添加自定义相机类型，可以为虚拟世界提供更多的可视化选项。我们将添加一个第三人称风格的相机，类似于动作游戏中的跟随一个实例，以及一个固定相机，它跟随一个实例。此外，还将添加一个简单的相机管理器，相机的配置也将保存在配置文件中。
- en: Practical sessions
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践课程
- en: 'There are some additions you could make to the code:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在代码中添加一些内容：
- en: Add a menu entry to create a new, empty scene.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个菜单项以创建一个新的空场景。
- en: Right now, we can only load and save a configuration file. Removing all models
    and instances must still be done by hand. Add a menu entry plus code to remove
    all models and instances at once, giving the user a simple way to start from nothing.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只能加载和保存配置文件。移除所有模型和实例仍然需要手动完成。添加一个菜单项和代码，以便一次性移除所有模型和实例，为用户提供一种简单的方法从头开始。
- en: Add a flag and confirmation dialogs if a setting is changed.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果更改了设置，添加一个标志和确认对话框。
- en: If the settings of one model are altered, set a `dirty` flag to remember that
    the user of the application changed the loaded model instance or a saved state.
    Then, if the user wants to load another configuration file, start over with an
    empty configuration or exit the application and show a confirmation dialog to
    make sure a chance is given to save the current settings.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果更改了一个模型的设置，设置一个 `dirty` 标志以记住应用程序用户更改了加载的模型实例或保存的状态。然后，如果用户想要加载另一个配置文件，可以从一个空配置开始，或者退出应用程序并显示一个确认对话框以确保有机会保存当前设置。
- en: Add a `dirty` marker to the title.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在标题中添加一个 `dirty` 标记。
- en: Several other applications are presenting some kind of notice to the user, stating
    that changes have been made since the last save. The title of the application
    window gets adjusted to show whether we are in edit or view mode, so adding a
    star (*) to the window title, or some words like “Not saved” should be easy.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 几个其他应用程序向用户显示了一些通知，说明自上次保存以来已进行了更改。应用程序窗口的标题会相应调整以显示我们是在编辑模式还是查看模式，因此向窗口标题添加一个星号
    (*) 或一些像“未保存”这样的词应该很容易。
- en: Additional resource
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: 'Here is the GitHub repository for `yaml-cpp`: [https://github.com/jbeder/yaml-cpp](https://github.com/jbeder/yaml-cpp).'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `yaml-cpp` 的 GitHub 仓库：[https://github.com/jbeder/yaml-cpp](https://github.com/jbeder/yaml-cpp)。
- en: Join our community on Discord
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/cppgameanimation](https://packt.link/cppgameanimation)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：[https://packt.link/cppgameanimation](https://packt.link/cppgameanimation)
- en: '![A qr code with black squares  AI-generated content may be incorrect.](img/QR_code_Discord.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![带有黑色方块的二维码，AI生成的内容可能不正确。](img/QR_code_Discord.png)'
