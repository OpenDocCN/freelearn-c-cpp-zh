["```cpp\n<banalities reason=\"these were discussed somewhere else\">\n```", "```cpp\n</banalities>\n```", "```cpp\nint template(int this) {\n    int class = 0, using = 1, delete;\n    if (this == 0) return class;\n    if (this == 1) return using;\n    for (int friend = 2; friend <= this; friend++) {\n        delete = class + using;\n        class = using;\n        using = delete;\n    }\n    return delete;\n}\n```", "```cpp\nwarning: null passed to a callee which requires a non-null argument\n```", "```cpp\nvoid update1(int *a, int *b) {\n    *a = *a + *b;\n    *b = *b + *a;\n}\n```", "```cpp\nvoid update2(int *restrict a, int *restrict b) {\n    *a = *a + *b;\n    *b = *b + *a;\n}\n```", "```cpp\nupdate1:\n  mov eax, DWORD PTR [rsi]; Load b from [rsi] into eax\n  add eax, DWORD PTR [rdi]; Add a from [rdi] to eax\n  mov DWORD PTR [rdi], eax; Store eax into [rdi] (a)\n  add DWORD PTR [rsi], eax; Add eax to [rsi] (b)\n  ret                     ; Return\n```", "```cpp\nupdate2:\n  mov eax, DWORD PTR [rsi]; Load b from [rsi] into eax\n  mov edx, DWORD PTR [rdi]; Load a from [rdi] into edx\n  add edx, eax            ; eax + edx (result in edx) - a\n  add eax, edx            ; edx + eax (result in eax) - b\n  mov DWORD PTR [rdi], edx; Store edx into [rdi] - a\n  mov DWORD PTR [rsi], eax; Store eax into [rsi] - b\n  ret                     ; Return\n```", "```cpp\n#include <cstdio>\n#define STR_I(x) #x\n#define STR(x) STR_I(x)\n#define JOIN(x,y) (x y)\n#define Hello(x) HELLO\nint main(void){\n    printf(\"%s\\n\", STR(JOIN(Hello, World)));\n    printf(\"%s\\n\", STR(JOIN(Hello,World )));\n}\n```", "```cpp\n#include <iostream>\nconst int value = 1;\ntemplate <class T>\nstruct D {\n    operator bool() {return true;}\n    static const int value = 2;\n};\ntemplate<int t> struct C {\n    typedef int value ;\n};\nint main() {\n    const int x = 1;\n    if(D<C< ::value>>::value>::value>::value) {\n        std::cout << \"C++98 compiler\";\n    } else {\n        std::cout << \"C++11 compiler\";\n    }\n}\n```", "```cpp\nif(static_cast<bool>(D<int>::value)) { ... }\n```", "```cpp\nif((static_cast<int>(D<C<1> >::value > ::value)) > ::value) { ... }\n```", "```cpp\n#include <iostream>\n#include <typeinfo>\n#include <string>\ntemplate<typename T> std::string typeof(T t) {\n    std::string res = typeid(t).name();\n    return res;\n}\nint main() {\n    auto a1 = 0;\n    auto a2(0);\n    auto a3 {0};\n    auto a4 = {0};\n    std::cout << typeof(a1) << std::endl\n            << typeof(a2) << std::endl\n            << typeof(a3) << std::endl\n            << typeof(a4) << std::endl;\n}\n```", "```cpp\nint\nint\nint\nclass std::initializer_list<int>\n```", "```cpp\ni\ni\ni\nSt16initializer_listIiE\n```", "```cpp\ni\ni\nSt16initializer_listIiE\nSt16initializer_listIiE\n```", "```cpp\n<source>:19:13: warning: direct list initialization of a variable with a deduced type will change meaning in a future version of Clang; insert an '=' to avoid a change in behavior [-Wfuture-compat]\n    auto a3 {0};\n```", "```cpp\nstd::cout << typeof( {0} );\n```", "```cpp\nstruct D { D(int i) {} };\nvoid fun(D d) { }\nfun({0});\n```"]