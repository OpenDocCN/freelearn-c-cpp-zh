<html><head></head><body>
<div id="_idContainer009">
<h1 class="chapter-number" id="_idParaDest-15"><a id="_idTextAnchor014"/><span class="koboSpan" id="kobo.1.1">1</span></h1>
<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/><span class="koboSpan" id="kobo.2.1">An Introduction to Inheritance and Polymorphism</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.3.1">C++</span></strong><span class="koboSpan" id="kobo.4.1"> is, first and foremost, an object-oriented language, and objects are the fundamental building blocks of a C++ program. </span><span class="koboSpan" id="kobo.4.2">Class hierarchies are used to express relationships and interactions between different parts of a software system, define and implement interfaces between components, and organize data and code. </span><span class="koboSpan" id="kobo.4.3">While this isn’t a book for teaching C++, the aim of this chapter is to give the reader enough knowledge about C++ language features as they relate to classes and inheritance, which will be used in later chapters. </span><span class="koboSpan" id="kobo.4.4">To that end, we won’t attempt to completely describe the C++ tools for working with classes but introduce the concepts and language constructs that will be used throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.6.1">The following topics will be covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.8.1">What are classes and what is their role </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">in C++?</span></span></li>
<li><span class="koboSpan" id="kobo.10.1">What are class hierarchies and how does C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">use inheritance?</span></span><a id="_idTextAnchor016"/></li>
<li><span class="koboSpan" id="kobo.12.1">What is runtime polymorphism and how is it used </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">in C++?</span></span></li>
</ul>
<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/><span class="koboSpan" id="kobo.14.1">Classes and objects</span></h1>
<p><span class="koboSpan" id="kobo.15.1">Object-oriented programming is a</span><a id="_idIndexMarker000"/><span class="koboSpan" id="kobo.16.1"> way to structure a program by combining the algorithms and the data that the algorithms operate on into single entities </span><a id="_idIndexMarker001"/><span class="koboSpan" id="kobo.17.1">called </span><strong class="bold"><span class="koboSpan" id="kobo.18.1">objects</span></strong><span class="koboSpan" id="kobo.19.1">. </span><span class="koboSpan" id="kobo.19.2">Most object-oriented languages, including C++, are class-based. </span><span class="koboSpan" id="kobo.19.3">A </span><strong class="bold"><span class="koboSpan" id="kobo.20.1">class</span></strong><span class="koboSpan" id="kobo.21.1"> is a definition of an object—it describes the algorithms and the data, its format, and its relations to other classes. </span><span class="koboSpan" id="kobo.21.2">An object is a concrete instantiation of a class, that is, a variable. </span><span class="koboSpan" id="kobo.21.3">An object has an address, which is a location in memory. </span><span class="koboSpan" id="kobo.21.4">A class is a user-defined type. </span><span class="koboSpan" id="kobo.21.5">In general, any number of objects can be instantiated from the definition provided by the class (some classes limit the number of objects that can be created, but this is an exception, not </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">the norm</span><a id="_idTextAnchor018"/><span class="koboSpan" id="kobo.23.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.24.1">In C++, the data contained in a class is organized as a collection of data members, or variables, of different types. </span><span class="koboSpan" id="kobo.24.2">The algorithms are implemented as functions—the methods of the class. </span><span class="koboSpan" id="kobo.24.3">While there’s no language requirement that the data members of a class should be somehow relevant to the implementation of its methods, it’s one of the signs of good design when the data is well encapsulated in the classes, and the methods have limited interaction with </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">external data.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">This concept of </span><strong class="bold"><span class="koboSpan" id="kobo.27.1">encapsulation</span></strong><span class="koboSpan" id="kobo.28.1"> is central </span><a id="_idIndexMarker002"/><span class="koboSpan" id="kobo.29.1">to the classes in C++—the language allows us to control which data members and methods are public—visible outside of the class, and which are internal—private to the class. </span><span class="koboSpan" id="kobo.29.2">A well-designed class has mostly, or only, private data members, and the only public methods are those needed to express the public interface of the class—in other words, what the class does. </span><span class="koboSpan" id="kobo.29.3">This public interface is like a contract—the class designer promises that this class provides certain features and operations. </span><span class="koboSpan" id="kobo.29.4">The private data and methods of the class are part of the implementation, and they can be changed as long as the public interface, the contract we’ve committed to, remains valid. </span><span class="koboSpan" id="kobo.29.5">For example, the following class represents a rational number and supports the</span><a id="_idIndexMarker003"/><span class="koboSpan" id="kobo.30.1"> increment </span><a id="_idIndexMarker004"/><span class="koboSpan" id="kobo.31.1">operation, as exposed by its </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">public </span></span><span class="No-Break"><a id="_idIndexMarker005"/></span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">interface:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.34.1">
class Rational { public:
  Rational&amp; operator+=(const Rational&amp; rhs);
};</span></pre>
<p><span class="koboSpan" id="kobo.35.1">A well-designed class doesn’t expose any more of the implementation details than it has to through its public interface. </span><span class="koboSpan" id="kobo.35.2">The implementation isn’t part of the contract, although the documented interface may impose some restrictions on it. </span><span class="koboSpan" id="kobo.35.3">For example, if we promise that all rational numbers don’t contain any common multipliers in the numerator and denomination, the addition should include the step of canceling them. </span><span class="koboSpan" id="kobo.35.4">That would be a good use of a private member function—the implementation of several other operations will need to call it, but the client of the class never needs to call it because every rational number is already reduced to its lowest terms before it’s exposed to </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">the callers:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.37.1">
class Rational {
  public:
  Rational&amp; operator+=(const Rational&amp; rhs); private:
  long n_; // numerator
  long d_; // denominator
  void  reduce();
};
Rational&amp; Rational::operator+=(const Rational&amp; rhs) {
  n_ = n_*rhs.d_ + rhs.n_*d_;
  d_ = d_*rhs.d_; red</span><a id="_idTextAnchor019"/><span class="koboSpan" id="kobo.38.1">uce();
  return *this;
}
Rational a, b; a += b;</span></pre>
<p><span class="koboSpan" id="kobo.39.1">The class methods have special access to the data members—they can access the private data of the class. </span><span class="koboSpan" id="kobo.39.2">Note the distinction between the class and the object here—</span><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">operator+=()</span></strong><span class="koboSpan" id="kobo.41.1"> is a method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">Rational</span></strong><span class="koboSpan" id="kobo.43.1"> class and is invoked on the object, </span><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">a</span></strong><span class="koboSpan" id="kobo.45.1">. </span><span class="koboSpan" id="kobo.45.2">However, it has access to the private data of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">b</span></strong><span class="koboSpan" id="kobo.47.1"> object as well, because </span><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">a</span></strong><span class="koboSpan" id="kobo.49.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">b</span></strong><span class="koboSpan" id="kobo.51.1"> are objects of the same class. </span><span class="koboSpan" id="kobo.51.2">If a member function references a class member by name without any additional qualifiers, then it’s accessing a member of the same class it’s invoked on (we can make it explicit by writing </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">this-&gt;n_</span></strong><span class="koboSpan" id="kobo.53.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">this-&gt;d_</span></strong><span class="koboSpan" id="kobo.55.1">). </span><span class="koboSpan" id="kobo.55.2">Accessing members of </span><a id="_idIndexMarker006"/><span class="koboSpan" id="kobo.56.1">another object of the same class requires a pointer or a</span><a id="_idIndexMarker007"/><span class="koboSpan" id="kobo.57.1"> reference</span><a id="_idIndexMarker008"/><span class="koboSpan" id="kobo.58.1"> to that object, but is otherwise not restricted, as would have been the case if we tried to access a private data member from a </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">non-member function.</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">By the way, C++ also supports C-style structs. </span><span class="koboSpan" id="kobo.60.2">But in C++, a struct isn’t limited to just an aggregate of data members—it can have methods, public and private access modifiers, and anything else classes have. </span><span class="koboSpan" id="kobo.60.3">From a language point of view, the only difference between a class and a struct is the default access—in a class, all members and methods are private by default, while in a struct they’re public. </span><span class="koboSpan" id="kobo.60.4">Beyond that, the use of structs instead of classes is a matter of convention—traditionally, structs are used for C-style structs (structs that would be legal in C) as well as </span><em class="italic"><span class="koboSpan" id="kobo.61.1">almost</span></em><span class="koboSpan" id="kobo.62.1"> C-style structs, for example, a struct with only a constructor added. </span><span class="koboSpan" id="kobo.62.2">Of course, this boundary isn’t precise and is a matter of coding styles and practices in each project </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">or team.</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">In addition to the methods and data members we’ve seen, C++ also supports static data and methods. </span><span class="koboSpan" id="kobo.64.2">A static method is very similar to a regular non-member function—it isn’t invoked on any particular object, and the only way it can get access to an object of any type is through its arguments. </span><span class="koboSpan" id="kobo.64.3">However, unlike a non-member function, a static method retains its privileged access to the private data of </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">the class.</span></span></p>
<p><span class="koboSpan" id="kobo.66.1">Classes by themselves are a useful way to group together (encapsulate) the algorithms and the data</span><a id="_idIndexMarker009"/><span class="koboSpan" id="kobo.67.1"> they</span><a id="_idIndexMarker010"/><span class="koboSpan" id="kobo.68.1"> operate on and to limit access to some data. </span><span class="koboSpan" id="kobo.68.2">However, the </span><a id="_idIndexMarker011"/><span class="koboSpan" id="kobo.69.1">most powerful object-oriented features of C++ are inheritance and the resulting </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">class </span><a id="_idTextAnchor020"/><a id="_idTextAnchor021"/><a id="_idTextAnchor022"/><span class="koboSpan" id="kobo.71.1">hierarchies.</span></span></p>
<h1 id="_idParaDest-18"><a id="_idTextAnchor023"/><span class="koboSpan" id="kobo.72.1">Inheritance and class hierarchies</span></h1>
<p><span class="koboSpan" id="kobo.73.1">Class hierarchies</span><a id="_idIndexMarker012"/><span class="koboSpan" id="kobo.74.1"> in C++ serve a</span><a id="_idIndexMarker013"/><span class="koboSpan" id="kobo.75.1"> dual purpose. </span><span class="koboSpan" id="kobo.75.2">On the one hand, they allow us to express relations between objects. </span><span class="koboSpan" id="kobo.75.3">On the other hand, they let us compose more complex types from simpler ones. </span><span class="koboSpan" id="kobo.75.4">Both uses are accomplished </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">through inheritance.</span></span></p>
<p><span class="koboSpan" id="kobo.77.1">The concept of inheritance is central to the C++ use of classes and objects. </span><span class="koboSpan" id="kobo.77.2">Inheritance allows us to define new classes as extensions of existing ones. </span><span class="koboSpan" id="kobo.77.3">When a derived class is inherited from the base class, it contains, in some form, all of the data and the algorithms that were in the base class, and it adds some of its own. </span><span class="koboSpan" id="kobo.77.4">In C++, it’s important to distinguish between two primary types of inheritance—public </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">and private.</span></span></p>
<p><span class="koboSpan" id="kobo.79.1">Public inheritance inherits the public interface of the class. </span><span class="koboSpan" id="kobo.79.2">It also inherits the implementation—the data members of the base class are also a part of the derived class. </span><span class="koboSpan" id="kobo.79.3">But the inheritance of the interface is what distinguishes public inheritance—the derived class has, as a part of its public interface, the public member functions of the </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">base class.</span></span></p>
<p><span class="koboSpan" id="kobo.81.1">Remember that the public interface is like a contract—we promise to the clients of the class that it supports certain operations, maintains some invariants, and obeys the specified restrictions. </span><span class="koboSpan" id="kobo.81.2">By publicly inheriting from the base class, we bind the derived class to the same contract (plus any extensions of the contract, should we decide to define additional public interfaces). </span><span class="koboSpan" id="kobo.81.3">Because the derived class also respects the interface contract of the base class, we could use a derived class in any place in the code where a base class is expected—we would not be able to use any of the extensions to the interface (the code expects the base class, we don’t know about any extensions at that point), but the base class interface and its restrictions have to </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">be valid.</span></span></p>
<p><span class="koboSpan" id="kobo.83.1">This is often expressed as the </span><em class="italic"><span class="koboSpan" id="kobo.84.1">is-a principle</span></em><span class="koboSpan" id="kobo.85.1">—an instance of a derived class is also an instance of the base class. </span><span class="koboSpan" id="kobo.85.2">However, the way we interpret the </span><em class="italic"><span class="koboSpan" id="kobo.86.1">is-a</span></em><span class="koboSpan" id="kobo.87.1"> relationship in C++ isn’t exactly intuitive. </span><span class="koboSpan" id="kobo.87.2">For example, is a square a rectangle? </span><span class="koboSpan" id="kobo.87.3">If it is, then we can derive the </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">Square</span></strong><span class="koboSpan" id="kobo.89.1"> class from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">Rectangle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.91.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.92.1">
class Rectangle {
  public:
  double Length() const { return length_; }
  double Width() const { return width_; }
  ...
</span><span class="koboSpan" id="kobo.92.2">  private:
  double l_;
  double w_;
};
class Square : public Rectang</span><a id="_idTextAnchor024"/><span class="koboSpan" id="kobo.93.1">le {
  ...
</span><span class="koboSpan" id="kobo.93.2">};</span></pre>
<p><span class="koboSpan" id="kobo.94.1">Right away, there’s </span><a id="_idIndexMarker014"/><span class="koboSpan" id="kobo.95.1">something </span><a id="_idIndexMarker015"/><span class="koboSpan" id="kobo.96.1">that doesn’t seem right—the derived class has two data members for dimensions, but it really needs only one. </span><span class="koboSpan" id="kobo.96.2">We would have to somehow enforce that they’re always the same. </span><span class="koboSpan" id="kobo.96.3">This doesn’t seem so bad—the </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">Rectangle</span></strong><span class="koboSpan" id="kobo.98.1"> class has the interface that allows for any positive values of length and width, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">Square</span></strong><span class="koboSpan" id="kobo.100.1"> imposes additional restrictions. </span><span class="koboSpan" id="kobo.100.2">But it’s worse than that—the </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">Rectangle</span></strong><span class="koboSpan" id="kobo.102.1"> class has a contract that allows the user to make the dimensions different. </span><span class="koboSpan" id="kobo.102.2">This can be </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">quite explicit:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.104.1">
class Rectangle {
  public:
  void Scale(double sl, double sw) {
     // Scale the dimensions
    length_ *= sl;
    width_ *= sw;
  }
  ...
</span><span class="koboSpan" id="kobo.104.2">};</span></pre>
<p><span class="koboSpan" id="kobo.105.1">Now, we have a public method that allows us to distort the rectangle, altering its aspect ratio. </span><span class="koboSpan" id="kobo.105.2">As with any other public method, it’s inherited by the derived classes, so now the </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">Square</span></strong><span class="koboSpan" id="kobo.107.1"> class has it too. </span><span class="koboSpan" id="kobo.107.2">In fact, by using public inheritance, we assert that a </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">Square</span></strong><span class="koboSpan" id="kobo.109.1"> object can be used anywhere a </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">Rectangle</span></strong><span class="koboSpan" id="kobo.111.1"> object is used, without even knowing that it’s really a </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">Square</span></strong><span class="koboSpan" id="kobo.113.1">. </span><span class="koboSpan" id="kobo.113.2">Clearly, this is a promise we can’t keep—when the client of our class hierarchy tries to change the aspect ratio of a square, we can’t do it. </span><span class="koboSpan" id="kobo.113.3">We could ignore the call or report an error at runtime. </span><span class="koboSpan" id="kobo.113.4">Either way, we’ve violated the contract provided by the base class. </span><span class="koboSpan" id="kobo.113.5">There’s only one solution—in C++, a square isn’t a rectangle. </span><span class="koboSpan" id="kobo.113.6">Note that a rectangle is usually not a square, either—the contract provided by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">Square</span></strong><span class="koboSpan" id="kobo.115.1"> interface could contain any number of guarantees that we can’t maintain if we derive the </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">Rectangle</span></strong><span class="koboSpan" id="kobo.117.1"> class </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">Square</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.121.1">Similarly, a penguin isn’t a bird in C++ if the bird interface includes flying. </span><span class="koboSpan" id="kobo.121.2">The correct design for such cases usually includes a more abstract base class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">Bird</span></strong><span class="koboSpan" id="kobo.123.1">, that doesn’t make any promises that at least one derived class can’t keep (for example, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">Bird</span></strong><span class="koboSpan" id="kobo.125.1"> object doesn’t make a guarantee that it can fly). </span><span class="koboSpan" id="kobo.125.2">Then, we create intermediate-based classes, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">FlyingBird</span></strong><span class="koboSpan" id="kobo.127.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">FlightlessBird</span></strong><span class="koboSpan" id="kobo.129.1">, that are derived from the common base class and serve as base classes for the more specific classes such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">Eagle</span></strong><span class="koboSpan" id="kobo.131.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">Penguin</span></strong><span class="koboSpan" id="kobo.133.1">. </span><span class="koboSpan" id="kobo.133.2">The </span><a id="_idIndexMarker016"/><span class="koboSpan" id="kobo.134.1">important </span><a id="_idIndexMarker017"/><span class="koboSpan" id="kobo.135.1">lesson here is that whether or not a penguin is a bird in C++ depends on how we define what a bird is, or, in C++ terms, what the public interface of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">Bird</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.137.1">class is.</span></span></p>
<p><span class="koboSpan" id="kobo.138.1">Because the public inheritance implies the </span><em class="italic"><span class="koboSpan" id="kobo.139.1">is-a </span></em><span class="koboSpan" id="kobo.140.1">relationship, the language allows a wide range of conversions between references and pointers to different classes in the same hierarchy. </span><span class="koboSpan" id="kobo.140.2">First of all, a conversion from a pointer to a derived class into a pointer to the base class is implicit (this is the same </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">for references):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.142.1">
class Base { ... </span><span class="koboSpan" id="kobo.142.2">};
class Derived : pub</span><a id="_idTextAnchor025"/><span class="koboSpan" id="kobo.143.1">lic Base { ... </span><span class="koboSpan" id="kobo.143.2">};
Derived* d = new Derived;
Base* b = d;    // Implicit conversion</span></pre>
<p><span class="koboSpan" id="kobo.144.1">This conversion is always valid because an instance of the derived class is also an instance of the base class. </span><span class="koboSpan" id="kobo.144.2">The inverse conversion is possible but has to be </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">made explicit:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.146.1">
Base* b = new Derived;     // *b is really Derived
Derived* d = b; // Does not compile, not implicit Derived*
Derived* d1 =
     static_cast&lt;Derived*&gt;(b);    // Explicit conversion</span></pre>
<p><span class="koboSpan" id="kobo.147.1">The reason this conversion isn’t implicit is that it’s valid only if the base class pointer really points to a derived object (otherwise, the behavior is undefined). </span><span class="koboSpan" id="kobo.147.2">The programmer, therefore, must explicitly assert, using the static cast, that somehow, through the logic of the program or a prior test or by some other means, it’s known that this conversion is valid. </span><span class="koboSpan" id="kobo.147.3">If you aren’t sure that the conversion is valid, there’s a safer way to try it without causing undefined behavior; we’ll learn about this in the </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">next section.</span></span></p>
<p><span class="koboSpan" id="kobo.149.1">Note that the static (or implicit) conversion between pointers to base and derived classes is not quite as straightforward as you might think. </span><span class="koboSpan" id="kobo.149.2">The first base of any object always has the same address as the derived object itself, but then it gets more complicated. </span><span class="koboSpan" id="kobo.149.3">There is generally </span><a id="_idIndexMarker018"/><span class="koboSpan" id="kobo.150.1">no</span><a id="_idIndexMarker019"/><span class="koboSpan" id="kobo.151.1"> standard requirement on the memory layout of derived classes with </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">multiple bases:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.153.1">
class Base1 { ... </span><span class="koboSpan" id="kobo.153.2">};
class Base2 { ... </span><span class="koboSpan" id="kobo.153.3">};
class Derived : public Base1, public Base2 { ... </span><span class="koboSpan" id="kobo.153.4">};</span></pre>
<p><span class="koboSpan" id="kobo.154.1">Most compilers will lay out the base classes first, then the data members of the </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">derived class:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer008">
<span class="koboSpan" id="kobo.156.1"><img alt="" src="image/Figure_1.1_B19262.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.157.1">Figure 1.1 – Possible memory layout of a derived class</span></p>
<p><span class="koboSpan" id="kobo.158.1">From </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.159.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.160.1">.1</span></em><span class="koboSpan" id="kobo.161.1">, it is evident that pointer conversion between the base and derived classes generally involves offset calculations. </span><span class="koboSpan" id="kobo.161.2">We can easily see this in </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.163.1">
// Example 01_cast.C
Derived d;
Derived* p = &amp;d;
std::cout &lt;&lt; "Derived: " &lt;&lt; (void*)(p) &lt;&lt;
  " Base1: " &lt;&lt; (void*)(static_cast&lt;Base1*&gt;(p)) &lt;&lt;
  " Base2: " &lt;&lt; (void*)(static_cast&lt;Base2*&gt;(p)) &lt;&lt;
  std::endl;</span></pre>
<p><span class="koboSpan" id="kobo.164.1">The program prints something </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">like this:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.166.1">
Derived: 0x7f97e550 Base1: 0x7f97e550 Base2: 0x7f97e560</span></pre>
<p><span class="koboSpan" id="kobo.167.1">You can see that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">Base1</span></strong><span class="koboSpan" id="kobo.169.1"> object is located at the same address as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">Derived</span></strong><span class="koboSpan" id="kobo.171.1"> object, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">Base2</span></strong><span class="koboSpan" id="kobo.173.1"> starts with an offset (16 bytes, in our case). </span><span class="koboSpan" id="kobo.173.2">Seems like the cast is an easy calculation: If you</span><a id="_idIndexMarker020"/><span class="koboSpan" id="kobo.174.1"> have a pointer to </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">Derived</span></strong><span class="koboSpan" id="kobo.176.1"> and you want to cast to </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">Base2</span></strong><span class="koboSpan" id="kobo.178.1">, add 16. </span><span class="koboSpan" id="kobo.178.2">The offsets between base classes are known at compile time, and the compiler knows the layout it is using. </span><span class="koboSpan" id="kobo.178.3">Pointer offset calculations are usually implemented in hardware (all modern CPUs support them and do not require a separate addition instruction). </span><span class="koboSpan" id="kobo.178.4">This doesn’t sound so hard </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">at all.</span></span></p>
<p><span class="koboSpan" id="kobo.180.1">Now, what do you do if the pointer is </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">null</span></strong><span class="koboSpan" id="kobo.182.1">? </span><span class="koboSpan" id="kobo.182.2">The pointer has a value of 0. </span><span class="koboSpan" id="kobo.182.3">If you apply the same </span><em class="italic"><span class="koboSpan" id="kobo.183.1">conversion</span></em><span class="koboSpan" id="kobo.184.1">, you get </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">16 (0x10)</span></strong><span class="koboSpan" id="kobo.186.1">, and now your check for </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">null</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.188.1"> fails:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.189.1">
void f(Base2* p) {
  if (p != nullptr) do_work(*p);
}
Derived* p = nullptr;
f(p); // Will it try to dereference 0x10?</span></pre>
<p><span class="koboSpan" id="kobo.190.1">Obviously, this would be very bad, so we can assume that </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">null</span></strong><span class="koboSpan" id="kobo.192.1"> pointers remain so. </span><span class="koboSpan" id="kobo.192.2">Indeed, </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">they do:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.194.1">
Derived* p = nullptr;
std::cout &lt;&lt; "Derived: " &lt;&lt; (void*)(p) &lt;&lt;
  " Base1: " &lt;&lt; (void*)(static_cast&lt;Base1*&gt;(p)) &lt;&lt;
  " Base2: " &lt;&lt; (void*)(static_cast&lt;Base2*&gt;(p)) &lt;&lt;
  std::endl;</span></pre>
<p><span class="koboSpan" id="kobo.195.1">This prints the same values for </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">all pointers:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.197.1">
Derived: 0x0 Base1: 0x0 Base2: 0x0</span></pre>
<p><span class="koboSpan" id="kobo.198.1">This is the only way to do casts, but it implies that a simple implicit cast from </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">Derived*</span></strong><span class="koboSpan" id="kobo.200.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">Base*</span></strong><span class="koboSpan" id="kobo.202.1"> hides inside a conditional computation with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">null</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.204.1">pointer check.</span></span></p>
<p><span class="koboSpan" id="kobo.205.1">The other kind of</span><a id="_idIndexMarker021"/><span class="koboSpan" id="kobo.206.1"> inheritance in C++ is </span><strong class="bold"><span class="koboSpan" id="kobo.207.1">private inheritance</span></strong><span class="koboSpan" id="kobo.208.1">. </span><span class="koboSpan" id="kobo.208.2">When inheriting privately, the derived classes don’t extend the public interface of the base class—all base class methods become private in the derived class. </span><span class="koboSpan" id="kobo.208.3">Any public interface has to be created by the derived class, starting from a clean slate. </span><span class="koboSpan" id="kobo.208.4">There’s no assumption that an object of the derived class can be used in place of an object of the base class. </span><span class="koboSpan" id="kobo.208.5">What the derived class does get from the base class is the implementation details—both the methods and the data members can be used by the derived class to implement its own algorithms. </span><span class="koboSpan" id="kobo.208.6">It’s said, therefore, that private inheritance implements a </span><em class="italic"><span class="koboSpan" id="kobo.209.1">has-a</span></em><span class="koboSpan" id="kobo.210.1"> relationship—the derived object has an instance of the base class contained inside </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">of it.</span></span></p>
<p><span class="koboSpan" id="kobo.212.1">The relation of </span><a id="_idIndexMarker022"/><span class="koboSpan" id="kobo.213.1">the</span><a id="_idIndexMarker023"/><span class="koboSpan" id="kobo.214.1"> privately derived class to its base class is, therefore, similar to that of the relationship of a class to its data members. </span><span class="koboSpan" id="kobo.214.2">The latter implementation technique is </span><a id="_idIndexMarker024"/><span class="koboSpan" id="kobo.215.1">known as </span><strong class="bold"><span class="koboSpan" id="kobo.216.1">composition</span></strong><span class="koboSpan" id="kobo.217.1">—an object is composed of any number of other objects, which are all used as its data members. </span><span class="koboSpan" id="kobo.217.2">In the absence of any reason to do otherwise, the composition should be preferred to private inheritance. </span><span class="koboSpan" id="kobo.217.3">What, then, might be the reasons to use private inheritance? </span><span class="koboSpan" id="kobo.217.4">There are several possibilities. </span><span class="koboSpan" id="kobo.217.5">First of all, it’s possible, within the derived class, to re-expose one of the public member functions of the base class with the help of a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">using</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.219.1"> declaration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.220.1">
class Container : private std::vector&lt;int&gt; {
  public:
  using std::vector&lt;int&gt;::size;
  ...
</span><span class="koboSpan" id="kobo.220.2">};</span></pre>
<p><span class="koboSpan" id="kobo.221.1">This can be useful in rare cases, but it’s also equivalent to an inline </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">forwarding function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.223.1">
class Container {
  private:
  std::vector&lt;int&gt; v_;
  public:
  size_t size() const { return v_.size(); }
  ...
</span><span class="koboSpan" id="kobo.223.2">};</span></pre>
<p><span class="koboSpan" id="kobo.224.1">Second, a pointer or reference to a derived object can be converted into a pointer or reference to the base object, but only inside a member function of the derived class. </span><span class="koboSpan" id="kobo.224.2">Again, the equivalent functionality for composition is provided by taking the address of a data member. </span><span class="koboSpan" id="kobo.224.3">So far, we haven’t seen a good reason to use private inheritance, and indeed, the common advice is to prefer composition. </span><span class="koboSpan" id="kobo.224.4">But the next two reasons are more significant, and either one could be motivation enough to use </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">private inheritance.</span></span></p>
<p><span class="koboSpan" id="kobo.226.1">One good reason to use private inheritance has to do with the size of the composed or derived objects. </span><span class="koboSpan" id="kobo.226.2">It isn’t uncommon to have base classes that provide only methods but no data members. </span><span class="koboSpan" id="kobo.226.3">Such classes have no data of their own and, therefore, should not occupy any memory. </span><span class="koboSpan" id="kobo.226.4">But in C++, they have to be given a non-zero size. </span><span class="koboSpan" id="kobo.226.5">This has to do with the requirement that any two different objects or variables have different and unique addresses. </span><span class="koboSpan" id="kobo.226.6">Typically, if we have two variables declared one after the other, the address of the second one is the address of the first one, plus the size of the </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">first one:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.228.1">
int x;     // Created at address 0xffff0000, size is 4
int y;     // Created at address 0xffff0004</span></pre>
<p><span class="koboSpan" id="kobo.229.1">To avoid the need </span><a id="_idIndexMarker025"/><span class="koboSpan" id="kobo.230.1">to</span><a id="_idIndexMarker026"/><span class="koboSpan" id="kobo.231.1"> handle zero-sized objects differently, C++ assigns an empty object the size of one. </span><span class="koboSpan" id="kobo.231.2">If such an object is used as a data member of a class, it occupies at least 1 byte (the alignment requirements for the next data member may increase this value). </span><span class="koboSpan" id="kobo.231.3">This is wasted memory; it’ll never be used for anything. </span><span class="koboSpan" id="kobo.231.4">On the other hand, if an empty class is used as a base class, there’s no requirement that the base part of an object must have a non-zero size. </span><span class="koboSpan" id="kobo.231.5">The entire object of the derived class must have a non-zero size, but the address of a derived object, its base object, and its first data member can all be at the same address. </span><span class="koboSpan" id="kobo.231.6">Therefore, it’s legal in C++ to allocate no memory for an empty base class, even though </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">sizeof()</span></strong><span class="koboSpan" id="kobo.233.1"> returns 1 for this class. </span><span class="koboSpan" id="kobo.233.2">While legal, such empty base class optimization isn’t required and is considered an optimization. </span><span class="koboSpan" id="kobo.233.3">Nonetheless, most modern compilers do </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">this optimization:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.235.1">
class Empty {
  public:
  void useful_function();
};
class </span><a id="_idTextAnchor026"/><span class="koboSpan" id="kobo.236.1">Derived : private Empty {
  int i;
};    // sizeof(Derived) == 4
class Composed {
  int i;
  Empty e;
};    // sizeof(Composed) == 8</span></pre>
<p><span class="koboSpan" id="kobo.237.1">If we create many derived objects, the memory saved by the empty base optimization can </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">be significant.</span></span></p>
<p><span class="koboSpan" id="kobo.239.1">The second </span><a id="_idIndexMarker027"/><span class="koboSpan" id="kobo.240.1">reason</span><a id="_idIndexMarker028"/><span class="koboSpan" id="kobo.241.1"> to possibly use private inheritance has to do </span><a id="_idTextAnchor027"/><span class="koboSpan" id="kobo.242.1">with virtual functions, and this will be exp</span><a id="_idTextAnchor028"/><span class="koboSpan" id="kobo.243.1">lained in the </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">next section.</span></span></p>
<h1 id="_idParaDest-19"><a id="_idTextAnchor029"/><span class="koboSpan" id="kobo.245.1">Polymorphism and virtual functions</span></h1>
<p><span class="koboSpan" id="kobo.246.1">When we discussed</span><a id="_idIndexMarker029"/><span class="koboSpan" id="kobo.247.1"> public</span><a id="_idIndexMarker030"/><span class="koboSpan" id="kobo.248.1"> inheritance earlier, we mentioned that a derived object can be used in any place where a base object is expected. </span><span class="koboSpan" id="kobo.248.2">Even with this requirement, it’s often useful to know what the actual type of the object is—in other words, what type the object was </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">created as:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.250.1">
Derived d;
Base&amp; b = d;
...
</span><span class="koboSpan" id="kobo.250.2">b.some_method(); // b is really a Derived object</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">some_method()</span></strong><span class="koboSpan" id="kobo.252.1"> is a part of the public interface of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">Base</span></strong><span class="koboSpan" id="kobo.254.1"> class and has to be valid for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">Derived</span></strong><span class="koboSpan" id="kobo.256.1"> class as well. </span><span class="koboSpan" id="kobo.256.2">But, within the flexibility allowed by the contract of the base class interface, it can do something different. </span><span class="koboSpan" id="kobo.256.3">As an example, we’ve already used the avian hierarchy before to represent different birds, in particular, birds that can fly. </span><span class="koboSpan" id="kobo.256.4">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">FlyingBird</span></strong><span class="koboSpan" id="kobo.258.1"> class can be assumed to have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">fly()</span></strong><span class="koboSpan" id="kobo.260.1"> method, and every specific bird class derived from it has to support flight. </span><span class="koboSpan" id="kobo.260.2">But eagles fly differently from vultures, and so the implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">fly()</span></strong><span class="koboSpan" id="kobo.262.1"> method in the two derived classes, </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">Eagle</span></strong><span class="koboSpan" id="kobo.264.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">Vulture</span></strong><span class="koboSpan" id="kobo.266.1">, can be different. </span><span class="koboSpan" id="kobo.266.2">Any code that operates on arbitrary </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">FlyingBird</span></strong><span class="koboSpan" id="kobo.268.1"> objects can call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">fly()</span></strong><span class="koboSpan" id="kobo.270.1"> method, but the results will vary depending on the actual type of </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">the object.</span></span></p>
<p><span class="koboSpan" id="kobo.272.1">This functionality </span><a id="_idIndexMarker031"/><span class="koboSpan" id="kobo.273.1">is</span><a id="_idIndexMarker032"/><span class="koboSpan" id="kobo.274.1"> implemented in C++ using virtual functions. </span><span class="koboSpan" id="kobo.274.2">A virtual public function must be declared in the </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">base class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.276.1">
class FlyingBird : public Bird {
  public:
  virtual void fly(double speed, double direction) {
    ... </span><span class="koboSpan" id="kobo.276.2">move the bird at the specified speed
        in the given direction ...
</span><span class="koboSpan" id="kobo.276.3">  }
  ...
</span><span class="koboSpan" id="kobo.276.4">};</span></pre>
<p><span class="koboSpan" id="kobo.277.1">A derived class inherits both the declaration and the implementation of this function. </span><span class="koboSpan" id="kobo.277.2">The declaration and the contract it provides must be respected. </span><span class="koboSpan" id="kobo.277.3">If the implementation meets the needs of the derived class, there’s no need to do anything more. </span><span class="koboSpan" id="kobo.277.4">But if the derived class needs to change the implementation, it can override the implementation of the </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">base class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.279.1">
class Vulture : public FlyingBird {
  public:
  virtual void fly(double speed, double direction) {
    ... </span><span class="koboSpan" id="kobo.279.2">move the bird but accumulate
        exhaustion if too fast ...
</span><span class="koboSpan" id="kobo.279.3">  }
};</span></pre>
<p><span class="koboSpan" id="kobo.280.1">Note that the keyword </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">virtual</span></strong><span class="koboSpan" id="kobo.282.1">, when used in a derived class for methods that override base class virtual functions, is entirely optional and has no effect; we will see later that there are good reasons to </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">omit that.</span></span></p>
<p><span class="koboSpan" id="kobo.284.1">When a virtual function is called, the C++ runtime system must determine what the real type of the object is. </span><span class="koboSpan" id="kobo.284.2">Usually, this information isn’t known at compile time and must be determined </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">at runtime:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.286.1">
void hunt(FlyingBird&amp; b) {
  b.fly(...);    // Could be Vulture or Eagle
  ...
</span><span class="koboSpan" id="kobo.286.2">};
Eagle e;
hunt(e);   // Now b in hunt() is Eagle
           // FlyingBird::fly() is called
Vulture v;
hunt(v);   // Now b in hunt() is Vulture
           // Vulture::fly() is called</span></pre>
<p><span class="koboSpan" id="kobo.287.1">The programming </span><a id="_idIndexMarker033"/><span class="koboSpan" id="kobo.288.1">technique </span><a id="_idIndexMarker034"/><span class="koboSpan" id="kobo.289.1">where some code operates on any number of base objects and invokes the same methods, but the results depend on the actual type of these objects, is </span><a id="_idIndexMarker035"/><span class="koboSpan" id="kobo.290.1">known as </span><strong class="bold"><span class="koboSpan" id="kobo.291.1">runtime polymorphism</span></strong><span class="koboSpan" id="kobo.292.1">, and the objects that support this technique are </span><strong class="bold"><span class="koboSpan" id="kobo.293.1">polymorphic</span></strong><span class="koboSpan" id="kobo.294.1">. </span><span class="koboSpan" id="kobo.294.2">In C++, polymorphic </span><a id="_idIndexMarker036"/><span class="koboSpan" id="kobo.295.1">objects must have at least one virtual function, and only the parts of their interface that use virtual functions for some or all of the implementation </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">are polymorphic.</span></span></p>
<p><span class="koboSpan" id="kobo.297.1">It should be evident from this explanation that the declaration of the virtual function and its overrides should be identical—the programmer calls the function on a base object, but the version that’s implemented in the derived class runs instead. </span><span class="koboSpan" id="kobo.297.2">This can happen only if the two functions have identical arguments and return types. </span><span class="koboSpan" id="kobo.297.3">One exception is that if a virtual function in the base class returns a pointer or a reference to an object of some type, the override can return a pointer or a reference to an object derived from that type (this i</span><a id="_idTextAnchor030"/><span class="koboSpan" id="kobo.298.1">s known</span><a id="_idIndexMarker037"/><span class="koboSpan" id="kobo.299.1"> as </span><strong class="bold"><span class="koboSpan" id="kobo.300.1">covariant </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.301.1">return types</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.303.1">A very common special case of polymorphic hierarchies is one where the base class doesn’t have a good </span><em class="italic"><span class="koboSpan" id="kobo.304.1">default</span></em><span class="koboSpan" id="kobo.305.1"> implementation of the virtual function. </span><span class="koboSpan" id="kobo.305.2">For example, all flying birds fly, but they all fly at different speeds, so there’s no reason to select one speed as the default. </span><span class="koboSpan" id="kobo.305.3">In C++, we can refuse to provide any implementation for a virtual function in the </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">base class.</span></span></p>
<p><span class="koboSpan" id="kobo.307.1">Such functions are</span><a id="_idIndexMarker038"/><span class="koboSpan" id="kobo.308.1"> called </span><strong class="bold"><span class="koboSpan" id="kobo.309.1">pure virtual</span></strong><span class="koboSpan" id="kobo.310.1">, and any base class that contains a pure virtual function is known</span><a id="_idIndexMarker039"/><span class="koboSpan" id="kobo.311.1"> as an </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.312.1">abstract class</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.314.1">
class FlyingBird {
  public:
  virtual void fly(...) = 0;     // Pure virtual function
};</span></pre>
<p><span class="koboSpan" id="kobo.315.1">An abstract class defines an interface only; it’s the job of the concrete derived classes to implement it. </span><span class="koboSpan" id="kobo.315.2">If the base class contains a pure virtual function, every derived class that’s instantiated in the program must provide an implementation. </span><span class="koboSpan" id="kobo.315.3">In other words, an object of a base class can’t be created (a derived class could also be an abstract class, but then it cannot be instantiated directly either, we must derive another class from it). </span><span class="koboSpan" id="kobo.315.4">We can, however, have a pointer </span><a id="_idIndexMarker040"/><span class="koboSpan" id="kobo.316.1">or</span><a id="_idIndexMarker041"/><span class="koboSpan" id="kobo.317.1"> a reference to an object of a base class—they really point to a derived class, but we can operate on it through the base </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">class interface.</span></span></p>
<p><span class="koboSpan" id="kobo.319.1">A few notes on the C++ syntax—when overriding a virtual function, it isn’t required to repeat the </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">virtual</span></strong><span class="koboSpan" id="kobo.321.1"> keyword. </span><span class="koboSpan" id="kobo.321.2">If the base class declares a virtual function with the same name and arguments, the one in the derived class will always be a virtual function and will override the one from the base class. </span><span class="koboSpan" id="kobo.321.3">Note that, if the arguments differ, the derived class function doesn’t override anything and instead shadows the name of the base class function. </span><span class="koboSpan" id="kobo.321.4">This can lead to subtle bugs where the programmer intended to override a base class function but didn’t copy the </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">declaration correctly:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.323.1">
class Eagle : public FlyingBird {
  public:
  void fly(int speed, double direction);
};</span></pre>
<p><span class="koboSpan" id="kobo.324.1">Here, the types of the arguments are slightly different. </span><span class="koboSpan" id="kobo.324.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">Eagle::fly()</span></strong><span class="koboSpan" id="kobo.326.1"> function is also virtual, but it doesn’t override </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">FlyingBird::fly()</span></strong><span class="koboSpan" id="kobo.328.1">. </span><span class="koboSpan" id="kobo.328.2">If the latter is a pure virtual function, the bug will be caught because every pure virtual function must be implemented in a derived class. </span><span class="koboSpan" id="kobo.328.3">But if </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">FlyingBird::fly()</span></strong><span class="koboSpan" id="kobo.330.1"> has the default implementation, then the bug will go undetected by the compiler. </span><span class="koboSpan" id="kobo.330.2">C++11 provides a very useful feature that greatly simplifies finding such bugs—any function that’s intended to be an override of a base class virtual function can be declared with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">override</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.332.1"> keyword:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.333.1">
class Eagle : public FlyingBird {
  public:
  void fly(i</span><a id="_idTextAnchor031"/><span class="koboSpan" id="kobo.334.1">nt speed, double direction) override;
};</span></pre>
<p><span class="koboSpan" id="kobo.335.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">virtual</span></strong><span class="koboSpan" id="kobo.337.1"> keyword is still optional, but if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">FlyingBird</span></strong><span class="koboSpan" id="kobo.339.1"> class doesn’t have a virtual function that we could be overriding with this declaration, this code </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">won’t compile.</span></span></p>
<p><span class="koboSpan" id="kobo.341.1">It is also possible to</span><a id="_idIndexMarker042"/><span class="koboSpan" id="kobo.342.1"> prevent </span><a id="_idIndexMarker043"/><span class="koboSpan" id="kobo.343.1">the derived classes from overriding a virtual function by declaring </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">final</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.347.1">
class Eagle : public FlyingBird {
  public:
  // All Eagles fly the same way, derived classes BaldEagle
  // and GoldenEagle cannot change this.
</span><span class="koboSpan" id="kobo.347.2">  void fly(int speed, double direction) final;
};</span></pre>
<p><span class="koboSpan" id="kobo.348.1">Note that the use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">final</span></strong><span class="koboSpan" id="kobo.350.1"> keyword is rare: it is unusual for the design to require that from this point on, the customizations should be disabled in the hierarchy. </span><span class="koboSpan" id="kobo.350.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">final</span></strong><span class="koboSpan" id="kobo.352.1"> keyword can also be applied to the entire class: it means that no more classes can be derived from this one. </span><span class="koboSpan" id="kobo.352.2">Again, this is a </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">rare situation.</span></span></p>
<p><span class="koboSpan" id="kobo.354.1">So, should or shouldn’t you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">virtual</span></strong><span class="koboSpan" id="kobo.356.1"> keyword on overrides? </span><span class="koboSpan" id="kobo.356.2">This is a matter of style, but the style affects the readability and maintainability of the code. </span><span class="koboSpan" id="kobo.356.3">The following is the </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">recommended practice:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.358.1">Any virtual function that does not override one in the base class must use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">virtual</span></strong><span class="koboSpan" id="kobo.360.1"> keyword. </span><span class="koboSpan" id="kobo.360.2">This includes both the functions in classes that have no bases and the functions added in </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">derived classes.</span></span></li>
<li><span class="koboSpan" id="kobo.362.1">Any other virtual function should not use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">virtual</span></strong><span class="koboSpan" id="kobo.364.1"> keyword. </span><span class="koboSpan" id="kobo.364.2">All overrides should use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">override</span></strong><span class="koboSpan" id="kobo.366.1"> keyword, with the following exception, which is also </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">another rule.</span></span></li>
<li><span class="koboSpan" id="kobo.368.1">A final override must use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">final</span></strong><span class="koboSpan" id="kobo.370.1"> keyword and should not use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">override</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.372.1"> keyword.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.373.1">There are two advantages to this approach. </span><span class="koboSpan" id="kobo.373.2">The first is clarity and readability: if you see </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">virtual</span></strong><span class="koboSpan" id="kobo.375.1">, this is a virtual function that does not override anything. </span><span class="koboSpan" id="kobo.375.2">If you see </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">override</span></strong><span class="koboSpan" id="kobo.377.1">, this must be an override (otherwise the code would not compile). </span><span class="koboSpan" id="kobo.377.2">If you see </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">final</span></strong><span class="koboSpan" id="kobo.379.1">, this is also an override (again, the code would not compile otherwise) and it’s the last such in the hierarchy. </span><span class="koboSpan" id="kobo.379.2">The second advantage shows up during code maintenance. </span><span class="koboSpan" id="kobo.379.3">One of the greatest </span><a id="_idIndexMarker044"/><span class="koboSpan" id="kobo.380.1">problems </span><a id="_idIndexMarker045"/><span class="koboSpan" id="kobo.381.1">with maintaining hierarchies is the base class fragility: you write a set of base and derived classes, someone else comes along and adds an argument to the base class function, and suddenly all your derived class functions don’t override the base class ones and never get called. </span><span class="koboSpan" id="kobo.381.2">With consistent use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">override</span></strong><span class="koboSpan" id="kobo.383.1"> keyword, this will </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">not happen.</span></span></p>
<p><span class="koboSpan" id="kobo.385.1">The most common use of virtual functions, by far, is in hierarchies that use public inheritance—since every derived object is also a base object (</span><em class="italic"><span class="koboSpan" id="kobo.386.1">is-a </span></em><span class="koboSpan" id="kobo.387.1">relationship), a program can often operate on a collection of derived objects as if they were all of the same types, and the virtual function overrides ensure that the right processing happens for </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">every object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.389.1">
void MakeLoudBoom(std::vector&lt;FlyingBird*&gt; birds)
  for (auto bird : birds) {
    bird-&gt;fly(...);   // Same action, different results
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.390.1">But virtual functions can also be used with private inheritance. </span><span class="koboSpan" id="kobo.390.2">The use is less straightforward (and much less common)—after all, an object that’s derived privately can’t be accessed through a base class pointer (a private base class is referred to as an </span><strong class="bold"><span class="koboSpan" id="kobo.391.1">inaccessible base</span></strong><span class="koboSpan" id="kobo.392.1">, and</span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.393.1"> an attempt to cast a derived class pointer to the base class will fail). </span><span class="koboSpan" id="kobo.393.2">However, there’s one context in which this cast is permitted, and that’s within a member function of the derived class. </span><span class="koboSpan" id="kobo.393.3">Here’s, then, the way to arrange a virtual function call from a privately inherited base class to the </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">derived one:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.395.1">
class Base {
  public:
  virtual void f() {
      std::cout &lt;&lt; "Base::f()" &lt;&lt; std::endl;
    }
  void g() { f(); }
};
class Derived : private Base {
  public:
  virtual void f() {
    std::cout &lt;&lt; "Derived::f()" &lt;&lt; std::endl;
  }
  void h() { g(); }
};
Derived d;
d.h(); // Prints "Derived::f()"</span></pre>
<p><span class="koboSpan" id="kobo.396.1">The public </span><a id="_idIndexMarker047"/><span class="koboSpan" id="kobo.397.1">methods</span><a id="_idIndexMarker048"/><span class="koboSpan" id="kobo.398.1"> of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">Base</span></strong><span class="koboSpan" id="kobo.400.1"> class become private in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">Derived</span></strong><span class="koboSpan" id="kobo.402.1"> class, so we can’t call them directly. </span><span class="koboSpan" id="kobo.402.2">We can, however, call them from another method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">Derived</span></strong><span class="koboSpan" id="kobo.404.1"> class, such as the public method </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">h()</span></strong><span class="koboSpan" id="kobo.406.1">. </span><span class="koboSpan" id="kobo.406.2">We can then call </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">f()</span></strong><span class="koboSpan" id="kobo.408.1"> directly from </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">h()</span></strong><span class="koboSpan" id="kobo.410.1">, but that doesn’t prove anything—it would come as no surprise if </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">Derived::h()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.412.1">invoked </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">Derived::f()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.415.1">Instead, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">Base::g()</span></strong><span class="koboSpan" id="kobo.417.1"> function that’s inherited from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">Base</span></strong><span class="koboSpan" id="kobo.419.1"> class. </span><span class="koboSpan" id="kobo.419.2">Inside that function, we’re in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">Base</span></strong><span class="koboSpan" id="kobo.421.1"> class—the body of this function may have been written and compiled long before the </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">Derived</span></strong><span class="koboSpan" id="kobo.423.1"> class was implemented. </span><span class="koboSpan" id="kobo.423.2">And yet, in this context, the virtual function override works correctly and </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">Derived::f()</span></strong><span class="koboSpan" id="kobo.425.1"> is called, just as it would if the inheritance </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">were public.</span></span></p>
<p><span class="koboSpan" id="kobo.427.1">In the previous section, we recommended that composition is preferred to private inheritance unless there’s a reason to do otherwise. </span><span class="koboSpan" id="kobo.427.2">There’s no good way to implement similar functionality using composition; so, if the virtual function behavior is desired, private inheritance is the only way </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">to go.</span></span></p>
<p><span class="koboSpan" id="kobo.429.1">A class with a virtual method has to have its type encoded into every object—this is the only way to know, at runtime, what was the type of the object when it was constructed, after we converted the pointer into a base class pointer and lost any other information about the original type. </span><span class="koboSpan" id="kobo.429.2">That type information isn’t free; it takes space—a polymorphic object is always larger than an object with the same data members but no virtual methods (usually by the size of </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">a pointer).</span></span></p>
<p><span class="koboSpan" id="kobo.431.1">The extra size doesn’t depend on how many virtual functions the class has—at long as it has one, the type information must be encoded in the object. </span><span class="koboSpan" id="kobo.431.2">Now, recall that a pointer to the base class can be converted into a pointer to the derived class, but only if we know the correct type of the derived class. </span><span class="koboSpan" id="kobo.431.3">With the static cast, there’s no way to test whether our knowledge is correct. </span><span class="koboSpan" id="kobo.431.4">For non-polymorphic classes (classes without any virtual functions), there </span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.432.1">can</span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.433.1"> be no better way; once their original type is lost, there is no way to recover it. </span><span class="koboSpan" id="kobo.433.2">But for polymorphic objects, the type is encoded in the object, so there has to be a way to use that information to check whether our assumption is correct about which derived object this really is. </span><span class="koboSpan" id="kobo.433.3">Indeed, there is a way. </span><span class="koboSpan" id="kobo.433.4">It’s provided by the </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">dynamic cast:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.435.1">
class Base { ... </span><span class="koboSpan" id="kobo.435.2">};
class Derived : public Base { ... </span><span class="koboSpan" id="kobo.435.3">};
Base* b1 = new Derived;     // Really Derived
Base* b2 = new Base;   // Not Derived
Derived* d1 = dynamic_cast&lt;Derived*&gt;(b1);  // Succeeds
Derived* d2 = dynamic_cast&lt;Derived*&gt;(b2);  // d2 == nullptr</span></pre>
<p><span class="koboSpan" id="kobo.436.1">The dynamic cast doesn’t tell us what the real type of the object is; rather, it allows us to ask the question—Is the real type </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">Derived</span></strong><span class="koboSpan" id="kobo.438.1">? </span><span class="koboSpan" id="kobo.438.2">If our guess at the type is correct, the cast succeeds and returns the pointer to the derived object. </span><span class="koboSpan" id="kobo.438.3">If the real type is something else, the cast fails and returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">null</span></strong><span class="koboSpan" id="kobo.440.1"> pointer. </span><span class="koboSpan" id="kobo.440.2">The dynamic cast can also be used with references, with similar effects, save one—there’s no </span><em class="italic"><span class="koboSpan" id="kobo.441.1">null reference</span></em><span class="koboSpan" id="kobo.442.1">. </span><span class="koboSpan" id="kobo.442.2">A function that returns a reference must always return a reference to some valid object. </span><span class="koboSpan" id="kobo.442.3">Since the dynamic cast can’t return a reference to a valid object if the requested type doesn’t match the actual type. </span><span class="koboSpan" id="kobo.442.4">The only alternative is to throw </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">an exception.</span></span></p>
<p><span class="koboSpan" id="kobo.444.1">For performance-conscious code, it is important to be aware of the run-time cost of the dynamic cast. </span><span class="koboSpan" id="kobo.444.2">Naively, one might think that a virtual function call and a dynamic cast take about the same time: both boil down to the question – is this pointer to </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">Base</span></strong><span class="koboSpan" id="kobo.446.1"> really a </span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.447.1">pointer </span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.448.1">to </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">Derived</span></strong><span class="koboSpan" id="kobo.450.1">? </span><span class="koboSpan" id="kobo.450.2">A simple benchmark shows that this is </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">not so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.452.1">
// Example 02_dynamic_cast.C
class Base {
  protected:
  int i = 0;
  public:
  virtual ~Base() {}
  virtual int f() { return ++i; }
};
class Derived : public Base {
  int f() override { return --i; }
};
Derived* p = new Derived;
// Measure the runtime of p-&gt;f();
// Measure the runtime of dynamic_cast&lt;Derived*&gt;(p);</span></pre>
<p><span class="koboSpan" id="kobo.453.1">The benchmark results should look something like this (the absolute numbers will depend on the hardware): 1 nanosecond for the virtual call, and 5 to 10 nanoseconds for the dynamic cast. </span><span class="koboSpan" id="kobo.453.2">Why is the dynamic cast so expensive? </span><span class="koboSpan" id="kobo.453.3">We need to learn more about the hierarchies before we can answer </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">this question.</span></span></p>
<p><span class="koboSpan" id="kobo.455.1">So far, we’ve limited ourselves to only one base class. </span><span class="koboSpan" id="kobo.455.2">While it’s much easier to think about class hierarchies if we imagine them as trees, with the base class and the root and branches where multiple</span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.456.1"> classes </span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.457.1">are derived from the same base, C++ doesn’t impose such limitations. </span><span class="koboSpan" id="kobo.457.2">Next, we’ll lear</span><a id="_idTextAnchor032"/><a id="_idTextAnchor033"/><a id="_idTextAnchor034"/><span class="koboSpan" id="kobo.458.1">n about inheriting from several base classes </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">at once.</span></span></p>
<h1 id="_idParaDest-20"><a id="_idTextAnchor035"/><span class="koboSpan" id="kobo.460.1">Multiple inheritance</span></h1>
<p><span class="koboSpan" id="kobo.461.1">In C++, a class can</span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.462.1"> be derived from several base classes. </span><span class="koboSpan" id="kobo.462.2">Going </span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.463.1">back to our birds, let’s make an observation—while flying birds have a lot in common with each other, they also have something in common with other flying animals, specifically, the ability to fly. </span><span class="koboSpan" id="kobo.463.2">Since flight isn’t limited to birds, we may want to move the data and the algorithms related to processing flight into a separate base class. </span><span class="koboSpan" id="kobo.463.3">But there’s also no denying that an eagle is a bird. </span><span class="koboSpan" id="kobo.463.4">We could express this relation if we used two base classes to construct the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">Eagle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.465.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.466.1">
class Eagle : public Bird, public FlyingAnimal { ... </span><span class="koboSpan" id="kobo.466.2">};</span></pre>
<p><span class="koboSpan" id="kobo.467.1">In this case, the inheritance from both base classes is public, which means that the derived class inherits both interfaces and must fulfill two separate contracts. </span><span class="koboSpan" id="kobo.467.2">What happens if both interfaces define a method with the same name? </span><span class="koboSpan" id="kobo.467.3">If this method isn’t virtual, then an attempt to invoke it on the derived class is ambiguous, and the program doesn’t compile. </span><span class="koboSpan" id="kobo.467.4">If the method is virtual and the derived class has an override for it, then there’s no ambiguity since the method of the derived class is called. </span><span class="koboSpan" id="kobo.467.5">Also, </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">Eagle</span></strong><span class="koboSpan" id="kobo.469.1"> is now both </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">Bird</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.471.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">FlyingAnimal</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.474.1">
Eagle* e = new Eagle;
Bird* b = e;
FlyingAnimal* f = e;</span></pre>
<p><span class="koboSpan" id="kobo.475.1">Both conversions from the derived class into the base class pointer are allowed. </span><span class="koboSpan" id="kobo.475.2">The reverse conversions must be made explicitly using a static or a dynamic cast. </span><span class="koboSpan" id="kobo.475.3">There’s another interesting conversion—if we have a pointer to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">FlyingAnimal</span></strong><span class="koboSpan" id="kobo.477.1"> class that’s also a </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">Bird</span></strong><span class="koboSpan" id="kobo.479.1"> class, can we cast from one to the other? </span><span class="koboSpan" id="kobo.479.2">Yes, we can with a </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">dynamic cast:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.481.1">
Bird* b = new Eagle;   // Also a FlyingAnimal
FlyingAnimal* f = dynamic_cast&lt;FlyingAnimal*&gt;(b);</span></pre>
<p><span class="koboSpan" id="kobo.482.1">When used in this context, the dynamic cast is sometimes</span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.483.1"> called a </span><strong class="bold"><span class="koboSpan" id="kobo.484.1">cross-cast</span></strong><span class="koboSpan" id="kobo.485.1">—we aren’t casting up or down the hierarchy (between derived and based classes) but across the hierarchy—between the classes on different branches of the </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">hierarchy tree.</span></span></p>
<p><span class="koboSpan" id="kobo.487.1">Cross-cast is also mostly responsible for the high runtime cost of the dynamic cast we have seen in the previous section. </span><span class="koboSpan" id="kobo.487.2">While the most common use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">dynamic_cast</span></strong><span class="koboSpan" id="kobo.489.1"> is to cast from </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">Base*</span></strong><span class="koboSpan" id="kobo.491.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">Derived*</span></strong><span class="koboSpan" id="kobo.493.1"> to verify that a given object is really of the derived class, the cast could also be used to cast between bases of the same derived class. </span><span class="koboSpan" id="kobo.493.2">This is a much harder problem. </span><span class="koboSpan" id="kobo.493.3">If you just want to check that the base class object is really a derived one, the compiler knows the </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">Derived</span></strong><span class="koboSpan" id="kobo.495.1"> type at this point (you cannot use the dynamic cast on </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">incomplete types).</span></span></p>
<p><span class="koboSpan" id="kobo.497.1">Therefore, the compiler knows exactly what base classes this derived type has and can trivially check if yours is one of them. </span><span class="koboSpan" id="kobo.497.2">But when casting across the hierarchy, the compiler knows only two base classes: at the time when this code was written, a derived class that combines both may not exist, it will be written later. </span><span class="koboSpan" id="kobo.497.3">But the compiler must generate the correct code now. </span><span class="koboSpan" id="kobo.497.4">So, the compiler has to generate code that, at run time, digs through all the possible classes that are derived from both base classes to see if yours is one of them (the</span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.498.1"> actual implementation is less</span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.499.1"> straightforward and more efficient than that, but the task to be accomplished remains </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">the same).</span></span></p>
<p><span class="koboSpan" id="kobo.501.1">In reality, this overhead is often unnecessary because, most of the time, the dynamic cast is indeed used to find out whether the base class pointer really points to a derived object. </span><span class="koboSpan" id="kobo.501.2">In many cases, the overhead is not significant. </span><span class="koboSpan" id="kobo.501.3">But if better performance is required, there is no way to make the dynamic cast faster. </span><span class="koboSpan" id="kobo.501.4">If you want a fast way to check whether a polymorphic object is really of a given type, you have to use virtual functions and, unfortunately, a list of all possible types (or at least all the ones you might be </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">interested in):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.503.1">
enum type_t { typeBase, typeDerived1, typeDerived2 };
class Base {
  virtual type_t type() const { return typeBase; }
};
class Derived1 : public Base {
  type_t type() const override { return typeDerived1; }
};
…
void process_derived1(Derived1* p);
void do_work(Base* p) {
  if (p-&gt;type() == typeDerived1) {
    process_derived1(static_cast&lt;Derived1*&gt;(p));
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.504.1">Multiple inheritance is often maligned and disfavored in C++. </span><span class="koboSpan" id="kobo.504.2">Much of this advice is outdated and stems from the time when compilers implemented multiple inheritance poorly and inefficiently. </span><span class="koboSpan" id="kobo.504.3">Today, with modern compilers, this isn’t a concern. </span><span class="koboSpan" id="kobo.504.4">It’s often said that multiple inheritance makes the class hierarchy harder to understand and reason about. </span><span class="koboSpan" id="kobo.504.5">Perhaps it would be more accurate to say that it’s harder to design a good multiple inheritance hierarchy that accurately reflects the relations between different properties, and that a poorly desig</span><a id="_idTextAnchor036"/><span class="koboSpan" id="kobo.505.1">ned hierarchy is difficult to understand and </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">reason about.</span></span></p>
<p><span class="koboSpan" id="kobo.507.1">These concerns mostly apply to hierarchies that use public inheritance. </span><span class="koboSpan" id="kobo.507.2">Multiple inheritance can be private as well. </span><span class="koboSpan" id="kobo.507.3">There’s even less reason to use multiple private inheritance instead of</span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.508.1"> composition than there was to use</span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.509.1"> single private inheritance. </span><span class="koboSpan" id="kobo.509.2">However, the empty base optimization can be done on multiple empty base classes and remains a valid reason to use private inheritance, if </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">it applies:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.511.1">
class Empty1 {};
class Empty2 {};
class Derived : private Empty1, private Empty2 {
  int i;
};   // sizeof(Derived) == 4
class Composed {
  int i;
  Empty1 e1;
  Empty2 e2;
};   // sizeof(Composed) == 8</span></pre>
<p><span class="koboSpan" id="kobo.512.1">Multiple inheritance can be particularly effective when the derived class represents a system that combines several unrelated, non-overlapping attributes. </span><span class="koboSpan" id="kobo.512.2">We’ll encounter such cases </span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.513.1">throughout</span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.514.1"> this book when we </span><a id="_idTextAnchor037"/><span class="koboSpan" id="kobo.515.1">explore various design patterns and their </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">C++ representations.</span></span></p>
<h1 id="_idParaDest-21"><a id="_idTextAnchor038"/><span class="koboSpan" id="kobo.517.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.518.1">While by no means a complete guide or reference to classes and objects, this chapter introduced and explained the concepts you will need to understand the examples and explanations in the rest of this book. </span><span class="koboSpan" id="kobo.518.2">As our interest is and will be in representing design patterns in C++, this chapter focused on the proper use of classes and inheritance. </span><span class="koboSpan" id="kobo.518.3">We paid particular attention to what relations are expressed through different C++ features—it’s through these features we’ll express relations and interactions between different components that form a </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">design pattern.</span></span></p>
<p><span class="koboSpan" id="kobo.520.1">The next chapter will similarly cover knowledge of C++ templates, which will be</span><a id="_idTextAnchor039"/><span class="koboSpan" id="kobo.521.1"> necessary to understand the subsequent chapters of </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">this book.</span></span></p>
<h1 id="_idParaDest-22"><a id="_idTextAnchor040"/><span class="koboSpan" id="kobo.523.1">Questions</span></h1>
<ul>
<li><span class="koboSpan" id="kobo.524.1">What is the importance of objects </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">in C++?</span></span></li>
<li><span class="koboSpan" id="kobo.526.1">Which relation is expressed by public inheritance? </span><span class="koboSpan" id="kobo.526.2">Which relation is expressed by private inheritance? </span><span class="koboSpan" id="kobo.526.3">What is a </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">polymorphic object?</span></span></li>
<li><span class="koboSpan" id="kobo.528.1">What is the difference between the dynamic c</span><a id="_idTextAnchor041"/><span class="koboSpan" id="kobo.529.1">ast and the static cast? </span><span class="koboSpan" id="kobo.529.2">Why is the dynamic cast </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">so expensive?</span></span></li>
</ul>
<h1 id="_idParaDest-23"><a id="_idTextAnchor042"/><span class="koboSpan" id="kobo.531.1">Further reading</span></h1>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.532.1">Deciphering Object-Oriented Programming with </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.533.1">C++</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">: </span></span><a href="https://www.packtpub.com/product/deciphering-object-oriented-programming-with-c/9781804613900"><span class="No-Break"><span class="koboSpan" id="kobo.535.1">https://www.packtpub.com/product/deciphering-object-oriented-programming-with-c/9781804613900</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.536.1">Software Architecture with </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.537.1">C++</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">: </span></span><a href="https://www.packtpub.com/product/software-architecture-with-c/9781838554590"><span class="No-Break"><span class="koboSpan" id="kobo.539.1">https://www.packtpub.com/product/software-architecture-with-c/9781838554590</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.540.1">C++ </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.541.1">Fundamentals</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">: </span></span><a href="https://www.packtpub.com/product/c-fundamentals"><span class="No-Break"><span class="koboSpan" id="kobo.543.1">https://www.packtpub.com/product/c-fundamentals</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.544.1">C++ Data Structures and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.545.1">Algorithms</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">: </span></span><a href="https://www.packtpub.com/product/c-data-structures-and-algorithm-design-principles"><span class="No-Break"><span class="koboSpan" id="kobo.547.1">https://www.packtpub.com/product/c-data-structures-and-algorithm-design-principles</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.548.1">Mastering C++ </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.549.1">Programming</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">: </span></span><a href="https://www.packtpub.com/product/mastering-c-programming"><span class="No-Break"><span class="koboSpan" id="kobo.551.1">https://www.packtpub.com/product/mastering-c-programming</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.552.1">Beginning C++ </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.553.1">Programming</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">: </span></span><a href="https://www.packtpub.com/product/beginning-c-programming"><span class="No-Break"><span class="koboSpan" id="kobo.555.1">https://www.packtpub.com/product/beginning-c-programming</span></span></a></li>
</ul>
</div>
</body></html>