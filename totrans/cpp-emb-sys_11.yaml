- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Generic and Reusable Code with Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have used class templates in previous examples in this book without explaining
    them in detail. You should by now have a basic understanding of templates in C++
    and know how to use template container classes from the standard library to specialize
    containers with different underlying types. We have also covered the `std::optional`
    and `std::expected` template classes, which we can use to handle different return
    types from functions.
  prefs: []
  type: TYPE_NORMAL
- en: As you have already seen, templates are used heavily in the C++ standard library.
    They allow us to implement the same functionality for different types, making
    our code reusable and generic, which is one of the strengths of C++. Templates
    are an extremely complex topic; entire books have been written on templates and
    metaprogramming in C++. This chapter will help you understand templates in C++
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Template basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metaprogramming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile-time polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get the most out of this chapter, I strongly recommend using Compiler Explorer
    ([https://godbolt.org/](https://godbolt.org/)) as you read through the examples.
    Select GCC as your compiler for x86 architecture. This will allow you to see standard
    output and better observe the code’s behavior. As we are using modern C++, make
    sure to select C++23 standard, by adding `-std=c++23` in the compiler options
    box.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler Explorer makes it easy to try the code, tweak it, and immediately see
    how it affects the output and generated assembly code. The examples from this
    chapter are available on GitHub ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter08](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter08)).
  prefs: []
  type: TYPE_NORMAL
- en: Template basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One definition of the word “template” is “a gauge, pattern, or mold (such as
    a thin plate or board) used as a guide to the form of a piece being made. “ This
    definition can be applied to templates in C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C++, templates serve as patterns or molds for functions and classes, allowing
    the creation of actual functions and classes. From this perspective, templates
    are not real functions or types themselves; rather, they act as guides for generating
    concrete functions and types. To better understand this definition, let us take
    a look at the following code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have a template function, `add`, with the template type
    parameter `T`. In the `main` function, we see two calls to the `add` function:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one has integers as arguments and a return value stored in `result_int`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second one has float arguments and a return value stored in the `result_float`
    float variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we previously said that template types and functions are not actual types
    and functions, so how can we make a call to the template function if it’s not
    a real function?
  prefs: []
  type: TYPE_NORMAL
- en: Making a call to the template function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, when the compiler sees a call to add a template function,
    it deduces the template argument and replaces the template parameter, in this
    case, type `T`, with type `int` in the first call and `float` in the second call
    to `add`. After argument deduction, the template is instantiated; that is, the
    compiler creates two instances of the `add` function: one with integers as arguments
    and one with floats. We can see this in the assembly output of the preceding example
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding assembly output, we see there are two instances of the `add`
    function: `_Z3addIiET_S0_S0_`, accepting integers, and `_Z3addIfET_S0_S0_`, accepting
    floats. The compiler instantiated these two functions from the `add` template
    function, after it deduced template arguments on the call site of this function.
    This is the basic working principle of templates in C++.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example of the `add` template function, the compiler will instantiate
    a new function for every type for which there is a defined `operator+`. So, what
    would happen if we tried to call the `add` template function on a type for which
    there is no defined `operator+`? Let’s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we defined a `point` struct, for which there is no
    defined `operator+`, and we made a call to the `add` template function. This will
    result in a compiler error similar to the one shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So, what happened? When the compiler tried to instantiate a function using
    the `add` template with `point` as type `T`, the compilation failed due to `no
    match for ''operator+'' (operand types are ''point'' and ''point'')`. We can solve
    this by defining `operator+` for the `point` struct as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding implementation, we defined `operator+` for the `point` struct,
    and we also defined the `print` function, which will help us to print the point.
    After this change, we can compile the example successfully.
  prefs: []
  type: TYPE_NORMAL
- en: What if we wanted, for some reason, that `add` function when used with type
    `point` behaves differently than just applying the `operator+`? Let’s say we want
    to increment both `x` and `y` by 1 after summation. We can use template specialization
    for this.
  prefs: []
  type: TYPE_NORMAL
- en: Template specialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Template specialization** allows us to provide the compiler with the implementation
    of a template function for a specific type, as in the following example of specializing
    the `add` function for type `point`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, when the `add` function is called with arguments of type `point`,
    the compiler skips the generic template instantiation and uses this specialized
    version instead. This allows us to customize the behavior of the function specifically
    for point objects, adding an extra 1 to each coordinate when two point instances
    are added together. Let us take a look at the full `main` function now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the example with template specialization from the previous step,
    we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The compiler used function specialization for the `point` type. Template specialization
    makes templates a flexible tool, allowing us to provide compilers with custom
    implementations when needed.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we can see that for variable `c`, we used `auto` as
    a type specifier. The `auto` keyword was introduced in C++11, and when used, the
    compiler deduces the actual type of a variable from the initialization expression.
    In order to confirm that the deduced type of variable `c` is `point`, we used
    `static_assert`, which performs compile-time assertion checking.
  prefs: []
  type: TYPE_NORMAL
- en: As the argument of `static_assert`, we use a type trait from the metaprogramming
    library, `std::is_same_v`, which checks whether two types are identical and evaluates
    to `true` if they are. We determine the type of `c` using the `decltype` specifier,
    which retrieves the type of an expression at compile time. This allows us to verify
    that the type deduced for `c` is indeed `point`. If this assertion fails, the
    compiler will generate an error.
  prefs: []
  type: TYPE_NORMAL
- en: Template metaprogramming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Template metaprogramming** involves using templates to write code that generates
    different functions, types, and constants at compile time based on the types used
    in the template arguments. Template metaprogramming is an advanced technique heavily
    utilized in modern C++ libraries. It may be overwhelming, so it is perfectly fine
    if it appears to be hard to understand. Take this as merely an introduction and
    an exploration of this interesting topic.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us go back to the example of the `add` template function. Is there something
    we can do if we want to enforce that this template function is used only for arithmetic
    types such as integers and floats?
  prefs: []
  type: TYPE_NORMAL
- en: '`<type_traits>` header from metaprogramming library provides us with the `std::enable_if`
    template type, which accepts two parameters, a Boolean and a type. If a Boolean
    is true, the resulting type will have a public `typedef` member, `type`. Let’s
    take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we used `std::enable_if` in place of the return type
    of the `add` template function. As we set the Boolean argument to `true`, it will
    have a public `typedef` type, `T`, meaning that the return type of the `add` function
    template will be `T`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will expand this example using type trait class template `std::is_arithmetic<T>`,
    which will have a public Boolean named `value` set to `true` if `T` is an arithmetic
    type. The preceding example will result in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, instead of hardcoding `true` as the condition for
    `std::enable_if`, we use the `std::is_arithmetic<T>::value`. Let’s take a look
    at the `main` function using this template function and the `point` type from
    the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to compile this code, the compilation will fail with a lengthy error
    message containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding compiler error looks intimidating, and it is hard to read. This
    is one of those things that templates are notorious for. Before we tackle this
    concern, let’s focus on analyzing what happened in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Template argument deduction/substitution failed as `std::is_arithmetic<point>::value`
    results in `false`, meaning that the `std::enable_if` template type will not have
    a public typedef `type T`. Effectively, any attempt at the usage of the `add`
    template function in this example with a type that’s not arithmetic will result
    in a compiler error, even if `operator+` is defined for that type. We can think
    of `std::enable_if` as an enabler or disabler of a template function in C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify the `add` template function so that it prints the result of the
    sum operation. As both integers and floats are arithmetic types, we need to treat
    them differently. We could use `std::enable_if` and create two template functions
    using the `std::is_integral` and `std::is_floating_point` type traits as in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you remember, `std::enable_if` is a template enabler or disabler, meaning
    it will enable the first template function for integer types and print them using
    `printf` and the `%d` format specifier. Template substitution will fail for the
    second template function with integer types, but this will not be treated as an
    error as there is a valid function candidate for integer arguments from the first
    template. This principle is called **Subsitution Failure Is Not An Error** (**SFINAE**).
    For the floating-point types, the first template function will be disabled, but
    the second one will be enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the example functions we used are very simple, but let’s for a moment
    pretend that the `add` function template is doing a heavy-lifting task and that
    between integer and floating-point versions, the only difference is how we print
    the result. So, if we used two different function templates, we would copy a lot
    of the same code. We can avoid this by using `constexpr if`, which will enable
    or disable certain paths in code at compile time. Let us take a look at a modified
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we used the `constexpr if` statement to enable certain
    paths of the program based on the compile-time evaluation of the `std::is_integral_v<T>`
    and `std::is_floating_point_v<T>` expressions. `constexpr if` was introduced in
    C++17\. You can also notice that we used aliases for type traits as `std::enable_if_t<T>`,
    which is equivalent to `std::enable_if<T>::type`, and `std::is_floating_point_v<T>`,
    which is equivalent to `std::is_floating_point<T>::value`.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we used type traits and `std::enable_if` to enable the `add`
    function template only for arithmetic types. C++20 introduced concepts, which
    we can use to put restraints on template types.
  prefs: []
  type: TYPE_NORMAL
- en: Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Concepts** are named sets of template parameter requirements. They are evaluated
    at compile time and are used during overload resolution to select the most appropriate
    function overload; that is, they are used to determine which function template
    will be instantiated and compiled.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a concept for arithmetic types and use it in our `add` template
    function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we created the `Arithmetic` concept and used it in the
    `add` function template to put requirements on the `T` template type. The `add`
    template function is now easier to read. It is visible from the template declaration
    that type `T` must meet the requirements of the `Arithmetic` concept, which makes
    the code easier to read and comprehend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Concepts not only make the code easier to read but also improve readability
    of compiler errors. If we tried to call the function template `add` on type `point`,
    we would now get an error similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding compiler error is way easier to read and understand what happened
    than the one we had previously when we didn’t use concepts. We can easily trace
    the origin of the error to the fact that constraints imposed by the `Arithmetic`
    concept are not satisfied for the `point` type.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will move on to discuss compile-time polymorphism and see how we can
    utilize concepts to help us enforce strong interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Compile-time polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 5*](Chapter_05.xhtml), we discussed dynamic, or runtime, polymorphism.
    We used it to define an interface for `uart`, which was implemented by the `uart_stm32`
    class. The `gsm_lib` class has a dependency on the `uart` interface only, not
    on the concrete implementation, which is contained in `uart_stm32`. This is called
    **loose coupling** and allows us to have portable code for the `gsm_lib` class.
  prefs: []
  type: TYPE_NORMAL
- en: We can easily supply `gsm_lib` with another `uart` interface implementation
    on a different hardware platform. This principle is called **dependency inversion**.
    It says that high-level modules (classes) shouldn’t depend on low-level modules
    and that both should depend on abstractions (interfaces). We can implement this
    principle by using inheritance and virtual functions in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual functions result in indirection, causing the runtime overhead and increased
    binary size needed for their implementation. They allow runtime dispatching of
    function calls, but they come with a price. In embedded applications, we usually
    know all our types, meaning that we can use templates and overload resolution
    for the static or compile-time dispatch of function calls.
  prefs: []
  type: TYPE_NORMAL
- en: Using Class Templates for Compile-Time Polymorphism
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can make `gsm_lib` a class template that has one parameter that we will
    use for the `uart` type, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the compiler will instantiate the `gsm_lib` template
    class using the `uart_stm32` class as a template argument. This will result in
    using a reference to an object of the `uart_stm32` class in the `gsm_lib` code.
    We can still easily reuse `gsm_lib` by using it with a different type that provides
    all the methods needed to compile it. In this example, the type that used with
    the `gsm_lib` class template must provide a `write` method accepting `std::span<char>`
    as its parameter. But this also means that any type that has such a method will
    allow us to compile the code.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic polymorphism requires interface classes implemented in concrete classes
    and used in high-level code. It makes intended behavior of the code clear when
    reading it. Can we do something similar using templates? It turns out we can.
    We can use the **curiously recurring template pattern** (**CRTP**) to implement
    compile-time subtype polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Curiously recurring template pattern (CRTP)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CRTP is a C++ idiom where the derived class uses a template class instantiated
    with itself as a base class. Yes, it sounds confusing, so let’s jump into the
    code to better understand this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code implements CRTP. The `uart_stm32` derived class inherits
    from the `uart_interface` class template instantiated with the `uart_stm32` class
    itself. The base class template exposes an interface from which it can access
    the derived class using `static_cast` on `this` (pointer to itself). It provides
    the `init` method, which calls `initImpl` on the object of the `uart_stm32` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'CRTP allows us to define our interface in the base class and implement it in
    a derived class, similar to the inheritance mechanism we are using for runtime
    polymorphism. The remaining part to ensure that this interface is used in `gsm_lib`
    is to create type constraints using concepts, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is a concept that we will use to restrain types accepted
    by the `gsm_lib` class template. It will accept only types that are derived from
    the `uart_interface` class template instantiated by that type itself. The following
    is the full code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we used CRTP to implement compile-time or static subtype
    polymorphism. `uart_stm32` is a concrete class that depends on the interface defined
    by the `uart_interface` class template. We used the `TheUart` concept to constrain
    high-level code in `gsm_lib` on types derived from `uart_interface`. We achieved
    dependency inversion, and it is clearly defined thanks to CRTP and concepts.
  prefs: []
  type: TYPE_NORMAL
- en: The major benefit of compile-time polymorphism over inheritance (runtime polymorphism)
    is static binding; that is, there are no virtual functions. This comes at the
    price of template syntax, which may make the code harder to read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered template basics, template metaprogramming, concepts,
    and compile-time polymorphism. While templates are an advanced topic that encompasses
    many deeper concepts, this chapter aims to serve as a solid starting point for
    new learners. By understanding the fundamentals covered here, you should be well
    equipped to explore more complex aspects of templates and leverage their full
    potential in embedded systems programming.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss type safety in C++.
  prefs: []
  type: TYPE_NORMAL
