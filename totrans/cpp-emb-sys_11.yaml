- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Building Generic and Reusable Code with Templates
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模板构建通用和可重用代码
- en: We have used class templates in previous examples in this book without explaining
    them in detail. You should by now have a basic understanding of templates in C++
    and know how to use template container classes from the standard library to specialize
    containers with different underlying types. We have also covered the `std::optional`
    and `std::expected` template classes, which we can use to handle different return
    types from functions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的先前示例中，我们已经使用了类模板，但没有对其进行详细解释。到现在为止，你应该对C++中的模板有基本的了解，并且知道如何使用标准库中的模板容器类来专门化具有不同底层类型的容器。我们还介绍了`std::optional`和`std::expected`模板类，我们可以使用它们来处理函数的不同返回类型。
- en: As you have already seen, templates are used heavily in the C++ standard library.
    They allow us to implement the same functionality for different types, making
    our code reusable and generic, which is one of the strengths of C++. Templates
    are an extremely complex topic; entire books have been written on templates and
    metaprogramming in C++. This chapter will help you understand templates in C++
    in more detail.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，模板在C++标准库中被广泛使用。它们允许我们对不同类型实现相同的功能，使我们的代码可重用和通用，这是C++的一个优点。模板是一个极其复杂的话题；关于C++模板和元编程的整本书都已经被写出来了。本章将帮助你更详细地了解C++中的模板。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Template basics
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板基础
- en: Metaprogramming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元编程
- en: Concepts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概念
- en: Compile-time polymorphism
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译时多态
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To get the most out of this chapter, I strongly recommend using Compiler Explorer
    ([https://godbolt.org/](https://godbolt.org/)) as you read through the examples.
    Select GCC as your compiler for x86 architecture. This will allow you to see standard
    output and better observe the code’s behavior. As we are using modern C++, make
    sure to select C++23 standard, by adding `-std=c++23` in the compiler options
    box.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用本章内容，我强烈建议你在阅读示例时使用Compiler Explorer ([https://godbolt.org/](https://godbolt.org/))。选择GCC作为x86架构的编译器。这将允许你看到标准输出并更好地观察代码的行为。由于我们使用现代C++，请确保选择C++23标准，通过在编译器选项框中添加`-std=c++23`来实现。
- en: Compiler Explorer makes it easy to try the code, tweak it, and immediately see
    how it affects the output and generated assembly code. The examples from this
    chapter are available on GitHub ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter08](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter08)).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Compiler Explorer使得尝试代码、调整代码并立即看到它如何影响输出和生成的汇编代码变得容易。本章的示例可以在GitHub上找到（[https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter08](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter08))。
- en: Template basics
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板基础
- en: One definition of the word “template” is “a gauge, pattern, or mold (such as
    a thin plate or board) used as a guide to the form of a piece being made. “ This
    definition can be applied to templates in C++.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: “模板”这个词的一个定义是“一个用于指导正在制作的零件形状的量规、图案或模具（如薄板或板）。”这个定义可以应用于C++中的模板。
- en: 'In C++, templates serve as patterns or molds for functions and classes, allowing
    the creation of actual functions and classes. From this perspective, templates
    are not real functions or types themselves; rather, they act as guides for generating
    concrete functions and types. To better understand this definition, let us take
    a look at the following code sample:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，模板充当函数和类的模式或模具，允许创建实际的函数和类。从这个角度来看，模板本身不是真正的函数或类型；相反，它们作为生成具体函数和类型的指南。为了更好地理解这个定义，让我们看一下以下代码示例：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this example, we have a template function, `add`, with the template type
    parameter `T`. In the `main` function, we see two calls to the `add` function:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们有一个模板函数`add`，其模板类型参数为`T`。在`main`函数中，我们看到对`add`函数的两次调用：
- en: The first one has integers as arguments and a return value stored in `result_int`
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个模板接受整数参数，并将返回值存储在`result_int`
- en: The second one has float arguments and a return value stored in the `result_float`
    float variable
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个模板接受浮点数参数，并将返回值存储在`result_float`浮点变量中
- en: Now, we previously said that template types and functions are not actual types
    and functions, so how can we make a call to the template function if it’s not
    a real function?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们之前说过，模板类型和函数不是真正的类型和函数，那么如果它不是一个真正的函数，我们如何调用模板函数呢？
- en: Making a call to the template function
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用模板函数
- en: 'In this example, when the compiler sees a call to add a template function,
    it deduces the template argument and replaces the template parameter, in this
    case, type `T`, with type `int` in the first call and `float` in the second call
    to `add`. After argument deduction, the template is instantiated; that is, the
    compiler creates two instances of the `add` function: one with integers as arguments
    and one with floats. We can see this in the assembly output of the preceding example
    shown here:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当编译器看到对模板函数的调用时，它会推断模板参数，并用类型 `int` 替换第一个调用中的模板参数 `T`，在第二个调用中用 `float`
    替换。在参数推断之后，模板被实例化；也就是说，编译器创建了两个 `add` 函数实例：一个接受整数作为参数，另一个接受浮点数。我们可以在前面示例的汇编输出中看到这一点：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding assembly output, we see there are two instances of the `add`
    function: `_Z3addIiET_S0_S0_`, accepting integers, and `_Z3addIfET_S0_S0_`, accepting
    floats. The compiler instantiated these two functions from the `add` template
    function, after it deduced template arguments on the call site of this function.
    This is the basic working principle of templates in C++.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的汇编输出中，我们看到有两个 `add` 函数实例：`_Z3addIiET_S0_S0_`，接受整数，和 `_Z3addIfET_S0_S0_`，接受浮点数。编译器在确定了此函数调用点的模板参数后，从
    `add` 模板函数中实例化了这两个函数。这是 C++ 中模板的基本工作原理。
- en: 'In the example of the `add` template function, the compiler will instantiate
    a new function for every type for which there is a defined `operator+`. So, what
    would happen if we tried to call the `add` template function on a type for which
    there is no defined `operator+`? Let’s take a look at the following example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `add` 模板函数的例子中，编译器将为每个定义了 `operator+` 的类型实例化一个新的函数。那么，如果我们尝试对一个没有定义 `operator+`
    的类型调用 `add` 模板函数会发生什么？让我们看一下以下例子：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding example, we defined a `point` struct, for which there is no
    defined `operator+`, and we made a call to the `add` template function. This will
    result in a compiler error similar to the one shown here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们定义了一个 `point` 结构体，对于它没有定义 `operator+`，并且调用了 `add` 模板函数。这将导致编译器错误，类似于下面显示的错误：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So, what happened? When the compiler tried to instantiate a function using
    the `add` template with `point` as type `T`, the compilation failed due to `no
    match for ''operator+'' (operand types are ''point'' and ''point'')`. We can solve
    this by defining `operator+` for the `point` struct as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，发生了什么？当编译器尝试使用 `add` 模板并使用 `point` 作为类型 `T` 实例化函数时，由于 `no match for 'operator+'
    (operand types are 'point' and 'point')`，编译失败。我们可以通过如下定义 `point` 结构体的 `operator+`
    来解决这个问题：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding implementation, we defined `operator+` for the `point` struct,
    and we also defined the `print` function, which will help us to print the point.
    After this change, we can compile the example successfully.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的实现中，我们为 `point` 结构体定义了 `operator+`，并且还定义了 `print` 函数，这将帮助我们打印点。在此更改之后，我们可以成功编译示例。
- en: What if we wanted, for some reason, that `add` function when used with type
    `point` behaves differently than just applying the `operator+`? Let’s say we want
    to increment both `x` and `y` by 1 after summation. We can use template specialization
    for this.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出于某种原因，我们想让 `add` 函数在类型 `point` 上使用时表现得与直接应用 `operator+` 不同，会怎样？比如说，我们想在求和后同时将
    `x` 和 `y` 增加 1。我们可以使用模板特化来实现这一点。
- en: Template specialization
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板特化
- en: '**Template specialization** allows us to provide the compiler with the implementation
    of a template function for a specific type, as in the following example of specializing
    the `add` function for type `point`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板特化** 允许我们向编译器提供特定类型的模板函数的实现，如下面的例子所示，特化了 `add` 函数以适用于类型 `point`：'
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this case, when the `add` function is called with arguments of type `point`,
    the compiler skips the generic template instantiation and uses this specialized
    version instead. This allows us to customize the behavior of the function specifically
    for point objects, adding an extra 1 to each coordinate when two point instances
    are added together. Let us take a look at the full `main` function now:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当使用类型 `point` 的参数调用 `add` 函数时，编译器会跳过泛型模板实例化，而是使用这个专门的版本。这允许我们针对点对象特别定制函数的行为，当两个点实例相加时，每个坐标都会增加
    1。现在让我们看一下完整的 `main` 函数：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we run the example with template specialization from the previous step,
    we will get the following output:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行之前步骤中的模板特化示例，我们将得到以下输出：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The compiler used function specialization for the `point` type. Template specialization
    makes templates a flexible tool, allowing us to provide compilers with custom
    implementations when needed.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器为`point`类型使用了函数特化。模板特化使模板成为一个灵活的工具，允许我们在需要时向编译器提供自定义实现。
- en: In the preceding example, we can see that for variable `c`, we used `auto` as
    a type specifier. The `auto` keyword was introduced in C++11, and when used, the
    compiler deduces the actual type of a variable from the initialization expression.
    In order to confirm that the deduced type of variable `c` is `point`, we used
    `static_assert`, which performs compile-time assertion checking.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们可以看到对于变量`c`，我们使用了`auto`作为类型指定符。`auto`关键字是在C++11中引入的，当使用时，编译器会从初始化表达式中推导出变量的实际类型。为了确认变量`c`推导出的类型是`point`，我们使用了`static_assert`，它执行编译时断言检查。
- en: As the argument of `static_assert`, we use a type trait from the metaprogramming
    library, `std::is_same_v`, which checks whether two types are identical and evaluates
    to `true` if they are. We determine the type of `c` using the `decltype` specifier,
    which retrieves the type of an expression at compile time. This allows us to verify
    that the type deduced for `c` is indeed `point`. If this assertion fails, the
    compiler will generate an error.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`static_assert`的参数，我们使用元编程库中的类型特性`std::is_same_v`，它检查两个类型是否相同，如果相同则评估为`true`。我们使用`decltype`指定符确定`c`的类型，它会在编译时检索表达式的类型。这允许我们验证为`c`推导出的类型确实是`point`。如果这个断言失败，编译器将生成错误。
- en: Template metaprogramming
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板元编程
- en: '**Template metaprogramming** involves using templates to write code that generates
    different functions, types, and constants at compile time based on the types used
    in the template arguments. Template metaprogramming is an advanced technique heavily
    utilized in modern C++ libraries. It may be overwhelming, so it is perfectly fine
    if it appears to be hard to understand. Take this as merely an introduction and
    an exploration of this interesting topic.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板元编程**涉及使用模板编写在编译时根据模板参数中使用的类型生成不同函数、类型和常量的代码。模板元编程是现代C++库中广泛使用的高级技术。它可能令人难以理解，所以如果它看起来很难理解，那完全没问题。把这仅仅看作是对这个有趣主题的介绍和探索。'
- en: Let us go back to the example of the `add` template function. Is there something
    we can do if we want to enforce that this template function is used only for arithmetic
    types such as integers and floats?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`add`模板函数的例子。如果我们想强制这个模板函数只用于整数和浮点数等算术类型，我们能做些什么呢？
- en: '`<type_traits>` header from metaprogramming library provides us with the `std::enable_if`
    template type, which accepts two parameters, a Boolean and a type. If a Boolean
    is true, the resulting type will have a public `typedef` member, `type`. Let’s
    take a look at the following example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 来自元编程库的`<type_traits>`头文件为我们提供了`std::enable_if`模板类型，它接受两个参数，一个布尔值和一个类型。如果布尔值为真，结果类型将有一个公共`typedef`成员`type`。让我们看看以下例子：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding example, we used `std::enable_if` in place of the return type
    of the `add` template function. As we set the Boolean argument to `true`, it will
    have a public `typedef` type, `T`, meaning that the return type of the `add` function
    template will be `T`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们用`std::enable_if`代替了`add`模板函数的返回类型。因为我们设置了布尔参数为`true`，它将有一个公共`typedef`类型`T`，这意味着`add`函数模板的返回类型将是`T`。
- en: 'We will expand this example using type trait class template `std::is_arithmetic<T>`,
    which will have a public Boolean named `value` set to `true` if `T` is an arithmetic
    type. The preceding example will result in the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用类型特性类模板`std::is_arithmetic<T>`扩展这个例子，它将有一个名为`value`的公共布尔值，如果`T`是算术类型则设置为`true`。前面的例子将产生以下代码：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding example, instead of hardcoding `true` as the condition for
    `std::enable_if`, we use the `std::is_arithmetic<T>::value`. Let’s take a look
    at the `main` function using this template function and the `point` type from
    the previous example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们不是将`true`硬编码为`std::enable_if`的条件，而是使用了`std::is_arithmetic<T>::value`。让我们看看使用这个模板函数和前面例子中的`point`类型的`main`函数：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we try to compile this code, the compilation will fail with a lengthy error
    message containing the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试编译这段代码，编译将失败，并显示一个包含以下内容的冗长错误消息：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding compiler error looks intimidating, and it is hard to read. This
    is one of those things that templates are notorious for. Before we tackle this
    concern, let’s focus on analyzing what happened in this case.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的编译器错误看起来很吓人，很难阅读。这是模板臭名昭著的问题之一。在我们解决这个问题之前，让我们专注于分析这个案例中发生了什么。
- en: Template argument deduction/substitution failed as `std::is_arithmetic<point>::value`
    results in `false`, meaning that the `std::enable_if` template type will not have
    a public typedef `type T`. Effectively, any attempt at the usage of the `add`
    template function in this example with a type that’s not arithmetic will result
    in a compiler error, even if `operator+` is defined for that type. We can think
    of `std::enable_if` as an enabler or disabler of a template function in C++.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 模板参数推导/替换失败，因为 `std::is_arithmetic<point>::value` 结果为 `false`，这意味着 `std::enable_if`
    模板类型将不会有公共 typedef `type T`。实际上，任何尝试在这个例子中使用非算术类型的 `add` 模板函数都将导致编译器错误，即使该类型定义了
    `operator+`。我们可以将 `std::enable_if` 视为 C++ 中模板函数的启用器或禁用器。
- en: 'Let’s modify the `add` template function so that it prints the result of the
    sum operation. As both integers and floats are arithmetic types, we need to treat
    them differently. We could use `std::enable_if` and create two template functions
    using the `std::is_integral` and `std::is_floating_point` type traits as in the
    following example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改 `add` 模板函数，使其打印求和操作的结果。由于整数和浮点数都是算术类型，我们需要对它们进行不同的处理。我们可以使用 `std::enable_if`
    并创建两个模板函数，使用 `std::is_integral` 和 `std::is_floating_point` 类型特性，如下例所示：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you remember, `std::enable_if` is a template enabler or disabler, meaning
    it will enable the first template function for integer types and print them using
    `printf` and the `%d` format specifier. Template substitution will fail for the
    second template function with integer types, but this will not be treated as an
    error as there is a valid function candidate for integer arguments from the first
    template. This principle is called **Subsitution Failure Is Not An Error** (**SFINAE**).
    For the floating-point types, the first template function will be disabled, but
    the second one will be enabled.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所记，`std::enable_if` 是一个模板启用器或禁用器，意味着它将启用整数类型的第一个模板函数，并使用 `printf` 和 `%d` 格式说明符打印它们。对于整数类型的第二个模板函数，模板替换将失败，但不会被视为错误，因为第一个模板对于整数参数有一个有效的函数候选者。这个原则被称为
    **替换失败不是错误**（**SFINAE**）。对于浮点类型，第一个模板函数将被禁用，但第二个将被启用。
- en: 'Now, the example functions we used are very simple, but let’s for a moment
    pretend that the `add` function template is doing a heavy-lifting task and that
    between integer and floating-point versions, the only difference is how we print
    the result. So, if we used two different function templates, we would copy a lot
    of the same code. We can avoid this by using `constexpr if`, which will enable
    or disable certain paths in code at compile time. Let us take a look at a modified
    example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用的示例函数非常简单，但让我们暂时假设 `add` 函数模板正在执行一个繁重的任务，并且整数和浮点数版本之间的唯一区别是我们如何打印结果。因此，如果我们使用两个不同的函数模板，我们将复制大量的相同代码。我们可以通过使用
    `constexpr if` 来避免这种情况，它将在编译时启用或禁用代码中的某些路径。让我们看看一个修改后的示例：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding example, we used the `constexpr if` statement to enable certain
    paths of the program based on the compile-time evaluation of the `std::is_integral_v<T>`
    and `std::is_floating_point_v<T>` expressions. `constexpr if` was introduced in
    C++17\. You can also notice that we used aliases for type traits as `std::enable_if_t<T>`,
    which is equivalent to `std::enable_if<T>::type`, and `std::is_floating_point_v<T>`,
    which is equivalent to `std::is_floating_point<T>::value`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了 `constexpr if` 语句根据 `std::is_integral_v<T>` 和 `std::is_floating_point_v<T>`
    表达式的编译时评估来启用程序的某些路径。`constexpr if` 是在 C++17 中引入的。你还可以注意到，我们使用了类型特性的别名作为 `std::enable_if_t<T>`，它等价于
    `std::enable_if<T>::type`，以及 `std::is_floating_point_v<T>`，它等价于 `std::is_floating_point<T>::value`。
- en: In this example, we used type traits and `std::enable_if` to enable the `add`
    function template only for arithmetic types. C++20 introduced concepts, which
    we can use to put restraints on template types.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了类型特性和 `std::enable_if` 来仅对算术类型启用 `add` 函数模板。C++20 引入了概念，我们可以用它来对模板类型施加限制。
- en: Concepts
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概念
- en: '**Concepts** are named sets of template parameter requirements. They are evaluated
    at compile time and are used during overload resolution to select the most appropriate
    function overload; that is, they are used to determine which function template
    will be instantiated and compiled.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念**是模板参数要求的命名集合。它们在编译时评估，并在重载解析期间用于选择最合适的函数重载；也就是说，它们用于确定哪个函数模板将被实例化和编译。'
- en: 'We will create a concept for arithmetic types and use it in our `add` template
    function, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个用于算术类型的概念，并在我们的`add`模板函数中使用它，如下所示：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, we created the `Arithmetic` concept and used it in the
    `add` function template to put requirements on the `T` template type. The `add`
    template function is now easier to read. It is visible from the template declaration
    that type `T` must meet the requirements of the `Arithmetic` concept, which makes
    the code easier to read and comprehend.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了`Arithmetic`概念，并在`add`函数模板中使用它来对`T`模板类型提出要求。现在`add`模板函数更容易阅读。从模板声明中可以看出，类型`T`必须满足`Arithmetic`概念的要求，这使得代码更容易阅读和理解。
- en: 'Concepts not only make the code easier to read but also improve readability
    of compiler errors. If we tried to call the function template `add` on type `point`,
    we would now get an error similar to the following one:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 概念不仅使代码更容易阅读，还提高了编译器错误的可读性。如果我们尝试在`point`类型上调用函数模板`add`，我们现在会得到一个类似于以下错误的错误：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding compiler error is way easier to read and understand what happened
    than the one we had previously when we didn’t use concepts. We can easily trace
    the origin of the error to the fact that constraints imposed by the `Arithmetic`
    concept are not satisfied for the `point` type.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的编译器错误比我们之前没有使用概念时的错误更容易阅读和理解发生了什么。我们可以轻松地追踪错误的起源，即`Arithmetic`概念对`point`类型施加的约束没有得到满足。
- en: Next, we will move on to discuss compile-time polymorphism and see how we can
    utilize concepts to help us enforce strong interfaces.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将继续讨论编译时多态，并看看我们如何利用概念来帮助我们强制执行强接口。
- en: Compile-time polymorphism
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译时多态
- en: In [*Chapter 5*](Chapter_05.xhtml), we discussed dynamic, or runtime, polymorphism.
    We used it to define an interface for `uart`, which was implemented by the `uart_stm32`
    class. The `gsm_lib` class has a dependency on the `uart` interface only, not
    on the concrete implementation, which is contained in `uart_stm32`. This is called
    **loose coupling** and allows us to have portable code for the `gsm_lib` class.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第五章*](Chapter_05.xhtml)中，我们讨论了动态的或运行时多态。我们用它来定义`uart`的接口，该接口由`uart_stm32`类实现。`gsm_lib`类只依赖于`uart`接口，而不是具体的实现，该实现包含在`uart_stm32`中。这被称为**松耦合**，使我们能够为`gsm_lib`类拥有可移植的代码。
- en: We can easily supply `gsm_lib` with another `uart` interface implementation
    on a different hardware platform. This principle is called **dependency inversion**.
    It says that high-level modules (classes) shouldn’t depend on low-level modules
    and that both should depend on abstractions (interfaces). We can implement this
    principle by using inheritance and virtual functions in C++.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地在不同的硬件平台上为`gsm_lib`提供另一个`uart`接口实现。这个原则被称为**依赖倒置**。它表示高层模块（类）不应该依赖于低层模块，而两者都应该依赖于抽象（接口）。我们可以通过在C++中使用继承和虚函数来实现这个原则。
- en: Virtual functions result in indirection, causing the runtime overhead and increased
    binary size needed for their implementation. They allow runtime dispatching of
    function calls, but they come with a price. In embedded applications, we usually
    know all our types, meaning that we can use templates and overload resolution
    for the static or compile-time dispatch of function calls.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 虚函数会导致间接引用，从而增加运行时开销和实现所需的二进制大小。它们允许运行时调度函数调用，但这也带来了代价。在嵌入式应用中，我们通常知道所有我们的类型，这意味着我们可以使用模板和重载解析来进行静态或编译时调度函数调用。
- en: Using Class Templates for Compile-Time Polymorphism
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用类模板进行编译时多态
- en: 'We can make `gsm_lib` a class template that has one parameter that we will
    use for the `uart` type, as shown in the following example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`gsm_lib`制作成一个类模板，它有一个参数，我们将用它来指定`uart`类型，如下面的示例所示：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding example, the compiler will instantiate the `gsm_lib` template
    class using the `uart_stm32` class as a template argument. This will result in
    using a reference to an object of the `uart_stm32` class in the `gsm_lib` code.
    We can still easily reuse `gsm_lib` by using it with a different type that provides
    all the methods needed to compile it. In this example, the type that used with
    the `gsm_lib` class template must provide a `write` method accepting `std::span<char>`
    as its parameter. But this also means that any type that has such a method will
    allow us to compile the code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，编译器将使用`uart_stm32`类作为模板参数实例化`gsm_lib`模板类。这将导致在`gsm_lib`代码中使用`uart_stm32`类的对象引用。我们仍然可以通过使用提供所有编译所需方法的不同类型来轻松重用`gsm_lib`。在这个例子中，与`gsm_lib`类模板一起使用的类型必须提供一个接受`std::span<char>`作为其参数的`write`方法。但这同时也意味着任何具有此类方法的类型都将允许我们编译代码。
- en: Dynamic polymorphism requires interface classes implemented in concrete classes
    and used in high-level code. It makes intended behavior of the code clear when
    reading it. Can we do something similar using templates? It turns out we can.
    We can use the **curiously recurring template pattern** (**CRTP**) to implement
    compile-time subtype polymorphism.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 动态多态需要接口类在具体类中实现并在高级代码中使用。当阅读代码时，它使代码的预期行为变得清晰。我们能否使用模板做类似的事情？结果是我们可以的。我们可以使用**奇特重复的模板模式**（**CRTP**）来实现编译时子类型多态。
- en: Curiously recurring template pattern (CRTP)
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 奇特重复的模板模式 (CRTP)
- en: 'CRTP is a C++ idiom where the derived class uses a template class instantiated
    with itself as a base class. Yes, it sounds confusing, so let’s jump into the
    code to better understand this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: CRTP是C++的一种惯用法，其中派生类使用一个以自身作为基类的模板类实例化。是的，听起来很复杂，所以让我们通过代码更好地理解这一点：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding code implements CRTP. The `uart_stm32` derived class inherits
    from the `uart_interface` class template instantiated with the `uart_stm32` class
    itself. The base class template exposes an interface from which it can access
    the derived class using `static_cast` on `this` (pointer to itself). It provides
    the `init` method, which calls `initImpl` on the object of the `uart_stm32` class.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码实现了CRTP。`uart_stm32`派生类从使用`uart_stm32`类本身实例化的`uart_interface`类模板继承。基类模板公开了一个接口，它可以通过对`this`（指向自身的指针）使用`static_cast`来访问派生类。它提供了`init`方法，该方法在`uart_stm32`类的对象上调用`initImpl`。
- en: 'CRTP allows us to define our interface in the base class and implement it in
    a derived class, similar to the inheritance mechanism we are using for runtime
    polymorphism. The remaining part to ensure that this interface is used in `gsm_lib`
    is to create type constraints using concepts, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: CRTP允许我们在基类中定义我们的接口并在派生类中实现它，类似于我们用于运行时多态的继承机制。为了确保此接口在`gsm_lib`中使用，我们需要使用概念创建类型约束，如下所示：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding code is a concept that we will use to restrain types accepted
    by the `gsm_lib` class template. It will accept only types that are derived from
    the `uart_interface` class template instantiated by that type itself. The following
    is the full code example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是我们将用于限制`gsm_lib`类模板接受类型的概念。它将仅接受由该类型本身实例化的`uart_interface`类模板派生的类型。以下是一个完整的代码示例：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code, we used CRTP to implement compile-time or static subtype
    polymorphism. `uart_stm32` is a concrete class that depends on the interface defined
    by the `uart_interface` class template. We used the `TheUart` concept to constrain
    high-level code in `gsm_lib` on types derived from `uart_interface`. We achieved
    dependency inversion, and it is clearly defined thanks to CRTP and concepts.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用CRTP实现了编译时或静态子类型多态。`uart_stm32`是一个具体类，它依赖于由`uart_interface`类模板定义的接口。我们使用`TheUart`概念来约束`gsm_lib`中从`uart_interface`派生的类型的高级代码。我们通过CRTP和概念实现了依赖反转，并且它得到了清晰的定义。
- en: The major benefit of compile-time polymorphism over inheritance (runtime polymorphism)
    is static binding; that is, there are no virtual functions. This comes at the
    price of template syntax, which may make the code harder to read and understand.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与继承（运行时多态）相比，编译时多态的主要优势是静态绑定；也就是说，没有虚拟函数。这以模板语法为代价，可能会使代码更难阅读和理解。
- en: Summary
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered template basics, template metaprogramming, concepts,
    and compile-time polymorphism. While templates are an advanced topic that encompasses
    many deeper concepts, this chapter aims to serve as a solid starting point for
    new learners. By understanding the fundamentals covered here, you should be well
    equipped to explore more complex aspects of templates and leverage their full
    potential in embedded systems programming.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了模板基础、模板元编程、概念以及编译时多态。虽然模板是一个包含许多更深层次概念的先进主题，但本章旨在为新学习者提供一个坚实的起点。通过理解这里涵盖的基本原理，你应该能够很好地探索模板的更复杂方面，并在嵌入式系统编程中充分利用它们的全部潜力。
- en: In the next chapter, we will discuss type safety in C++.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论 C++ 中的类型安全。
