- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Event Handling – Signals and Slots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The signals and slots mechanism in Qt 6 is one of its most important features.
    It’s a method that allows communication between objects, which is a crucial part
    of a program’s graphical user interface. A signal can be emitted from any `QObject`
    object or its subclasses, which will then trigger any slot functions of any objects
    that are connected to the signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Signals and slots in a nutshell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI events with signals and slots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous programming made easier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function callbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The technical requirements for this chapter include **Qt 6.6.1 MinGW 64-bit**
    and **Qt Creator 12.0.2**. All the code used in this chapter can be downloaded
    from the following GitHub repository: [https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter02](https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter02).'
  prefs: []
  type: TYPE_NORMAL
- en: Signals and slots in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compared to **callbacks** (which Qt 6 also supports), the **signals and slots**
    mechanism is comparably more fluid and flexible for the programmer to use. It
    is both type-safe and not strongly coupled to the processing function, which makes
    it better than callback implementation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s get started by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a `mainwindow.ui`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag and drop a **PushButton** widget from the **Widget Box** to the UI canvas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Dragging and dropping a push button to the UI canvas](img/B20976_02_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Dragging and dropping a push button to the UI canvas
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the **PushButton** widget and select **Go to slot**. A window
    will appear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Selecting the clicked() signal and pressing OK](img/B20976_02_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Selecting the clicked() signal and pressing OK
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see a list of built-in slot functions available for the push button.
    Let’s select the `on_pushButton_clicked()` will now appear in both `mainwindow.h`
    and `mainwindow.cpp`. Qt Creator automatically added the slot function to your
    source code after you pressed the `mainwindow.h` now, you should be able to see
    an extra function under the `private` `slots` keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The same goes for `mainwindow.cpp`, where the `on_pushButton_clicked()` function
    has been added for you:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s add a `QMessageBox` header to the top of your source file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the following code within the `on_pushButton_clicked()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, build and run the project. Then, click on the **Push** button; you should
    see that a message box pops out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.3 – A message box pops out after pressing the push button](img/B20976_02_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – A message box pops out after pressing the push button
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to create our own signals and slot functions. Go to **File**
    | **New File or Project**, then create a new C++ class under the **Files and**
    **Classes** category:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Creating a new C++ class](img/B20976_02_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Creating a new C++ class
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we need to name our class `MyClass` and make sure that the base class
    is **QObject**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Defining your custom class, which inherits the QObject class](img/B20976_02_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Defining your custom class, which inherits the QObject class
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have created the class, open up `myclass.h` and add the following
    code, which is highlighted here for clarity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, open up `myclass.cpp` and implement the `doSomething()` slot function.
    We’ll copy the message box function from the previous example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, open up `mainwindow.h` and include the `myclass.h` header at the top:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, declare a `doNow()` signal in `myclass.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, open up `mainwindow.cpp` and define a `MyClass` object. Then, we’ll
    connect the `doNow()` signal that we created in the previous step with our `doSomething()`
    slot function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we have to change the code of the `on_pushButton_clicked()` function
    to something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you build and run the program now, you will get a result that is similar
    to what’s shown in the previous example. However, we have placed the message box
    code in the `MyClass` object instead of in `MainWindow`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding steps demonstrated how we can utilize the slot-and-signal feature
    in Qt 6 to easily link a widget action to an event function. It really is that
    simple.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The signals and slots mechanism has gone through some changes in the recent
    version of Qt, most notably its coding syntax. Qt 6 no longer supports the older
    syntax; therefore, if you are trying to port your older Qt 5 project to Qt 6,
    you must change your code to comply with the newer syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the good old days, we would typically connect a signal to a slot like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'However, things have changed slightly since then. In the new syntax, the `SIGNAL`
    and `SLOT` macros are now gone, and you must specify the type of your object,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The new syntax also allows you to connect a signal directly to a function instead
    of `QObject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, you can also connect your signal to a **lambda expression**. We
    will talk more about this in the *Asynchronous programming made* *easier* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A signal of an `arbitrary` class can trigger any private slots of an unrelated
    class that is going to be invoked, which is not possible with callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All Qt projects come with a project file with the `.pro` extension. This project
    file is used specifically by Qt’s own **qmake** build system, which helps simplify
    most of the complex build process by using a straightforward declarative style,
    defining standard variables to indicate the source and header files that are used
    in the project.
  prefs: []
  type: TYPE_NORMAL
- en: There’s an alternative build system called `CMakeLists.txt` with Qt Creator
    and it will open the project just like using Qt’s project file. However, it’s
    not recommended for beginners to use CMake when developing their first application
    with Qt, as CMake is much more manual and it takes longer time to grasp its functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about CMake, please visit [https://doc.qt.io/qt-6/cmake-get-started.html](https://doc.qt.io/qt-6/cmake-get-started.html).
  prefs: []
  type: TYPE_NORMAL
- en: Qt categorizes its features and functionality in the form of modules and classes.
    Each module contains a set of related functionalities that can be added to your
    project separately when needed. This allows the programmer to keep their program
    in optimum size and performance. The Qt Core and Qt GUI modules are included in
    every Qt project by default. To add additional modules, you simply need to add
    the module keyword to your Qt project file or add the package and link its libraries
    in `CMakeLists.txt` if you are using CMake for your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if I want to add the Qt `Network` module to my project, I will
    add the following keyword to my Qt project file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In CMake, however, it gets slightly longer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: After you have added the Qt `Network` module, you can now access its C++ classes
    such as `QNetworkAccessManager`, `QNetworkInterface`, `QNetworkRequest`, and so
    on. This modular approach creates an expandable ecosystem for Qt while allowing
    the developers to maintain this complex and powerful framework with ease.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about all the different Qt modules, please visit [https://doc.qt.io/qt.html](https://doc.qt.io/qt.html).
  prefs: []
  type: TYPE_NORMAL
- en: UI events with signals and slots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we demonstrated the use of signals and slots on a push
    button. Now, let’s explore the signals and slots that are available in other common
    widget types.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn how to use signals and slots with UI events, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a new **Qt Widgets** **Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag and drop a **PushButton**, **Combo Box**, **Line Edit**, **Spin Box**,
    and **Slider** widget from the **Widget Box** into your UI canvas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Placing several widgets on the UI canvas](img/B20976_02_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Placing several widgets on the UI canvas
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, right-click on the push button, select **clicked()**, and press the **OK**
    button to proceed. A slot function will be created for you by Qt Creator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Selecting the clicked() signal and pressing OK](img/B20976_02_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Selecting the clicked() signal and pressing OK
  prefs: []
  type: TYPE_NORMAL
- en: 'Repeat the previous step, but this time, select the next selection until every
    function in `QAbstractButton` has been added to the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, repeat the same steps on the combo box until all the slot functions available
    under the `QComboBox` class have been added to the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The same goes for `lineEdit`, all of which are under the `QLineEdit` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, add the slot functions from the `QSpinBox` class for our `spin
    box` widget as well, which is relatively short:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, repeat the same step for our `slider` widget, which yields similar
    results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you’re done with that, open up `mainwindow.h` and add the `QDebug` header,
    as highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s implement the slot functions for our push button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you build and run the project now, and then click on the push button, you
    will see that a different status gets printed out but at a slightly different
    time. This is due to different signals being emitted at different actions during
    the whole clicking process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will move on to the combo box. Since the default combo box is empty,
    let’s add some options to it by double-clicking on it from `mainwindow.ui` and
    adding the options that are shown in the pop-up window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Adding more options to the combo box](img/B20976_02_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – Adding more options to the combo box
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, let’s implement the slot functions for the combo box in `mainwindow.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will continue to implement the rest of the slot functions for the combo
    box:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build and run the project. Then, try to click on the combo box, hover over
    the other options, and select an option by clicking on it. You should see similar
    results to the following in your debug output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will move on to line edit and implement its slot functions, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will continue to implement the rest of the slot functions of line edit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build and run the project. Then, click on the line edit and type `Hey`. You
    should see results similar to the following appearing in the debug output panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we need to implement the slot functions for the spin box widget,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try to build and run the program. Then, click the arrow buttons on the spin
    box, or directly edit the value in the box – you should get something similar
    to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we’ll implement the slot functions for the horizontal slider widget:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Continue to implement the slot function for the slider, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build and run the program. Then, click and drag the slider to the left and
    right – you should see results that are similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Almost every widget has a set of slot functions associated with its usage or
    purpose. For example, a push button will start emitting signals that trigger the
    slot functions associated with it when it’s pressed or released. These expected
    behaviors that define the widget have slot functions that get called when the
    user triggers an action. As programmers, all we need to do is implement the slot
    functions and tell Qt what to do when these slot functions are being triggered.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous programming made easier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the signals and slots mechanism is *asynchronous* in nature, we can make
    use of it for things other than user interfaces. In programming terms, an *asynchronous
    operation* is a process that works independently, allowing the program to continue
    its operation without waiting for the process to complete, which may stall the
    whole program. Qt 6 allows you to make use of its signals and slots mechanism
    to easily achieve asynchronous processes without much effort. This is even more
    true after Qt 6 enforced the new syntax for signals and slots, which allows a
    signal to trigger a normal function instead of a slot function from a `Qobject`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we will further explore this opportunity and learn
    how we can improve our program’s efficiency by using asynchronous operations through
    the signals and slots mechanism that’s provided by Qt 6.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn how to achieve asynchronous operations using the signals and slots
    mechanism, let’s follow this example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a **Qt Console** **Application** project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Creating a new Qt Console Application project](img/B20976_02_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – Creating a new Qt Console Application project
  prefs: []
  type: TYPE_NORMAL
- en: 'This type of project will only provide a `main.cpp` file for you, instead of
    `mainwindow.h` and `mainwindow.cpp`, like our previous example projects. Let’s
    open up `main.cpp` and add the following headers to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the following code to our `main()` function. We will be using the
    `QNetworkAccessManager` class to initiate a `GET` request to the following web
    URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we use C++11’s `QNetworkReply` signals to inline functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also use a lambda expression with `connect()` to call a function that
    is not under a `QObject` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we define the `printHTML()` function, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you build and run the program now, you will see that it’s functional even
    without declaring any slot function. **Lambda expressions** make declaring a slot
    function optional, but this is only recommended if your code is really short:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Printing HTML source code on the terminal window](img/B20976_02_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – Printing HTML source code on the terminal window
  prefs: []
  type: TYPE_NORMAL
- en: If the terminal window does not appear after you build and run your Qt console
    application project, go to **Edit** | **Preferences** | **Build & Run** and select
    **Enabled** for the **Default for “Run in** **terminal”** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.11 – Enabling the terminal window from the Preferences settings](img/B20976_02_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – Enabling the terminal window from the Preferences settings
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example demonstrated how we can run a lambda function within the
    network reply slot function. This way, we can ensure that our code is shorter
    and easier to debug, but the lambda function is only suitable if the function
    is meant to be called only once.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding example is a very simple application that showcases the use of
    lambda expressions to connect a signal with a lambda function or a regular function
    without declaring any slot function and thus does not need to be inherited from
    a `QObject` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is especially useful for calling asynchronous processes that are not under
    UI objects. Lambda expressions are functions that get defined within another function
    anonymously, which is quite similar to the anonymous functions in **JavaScript**.
    The format of a lambda function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: You can insert variables into a lambda expression by placing them into the `captured
    variables` part, as we did in the example project in this recipe. We capture the
    `QNetworkReply` object called `reply`, and the `QString` object called `html`,
    and put them in our lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can use these variables within our lambda code, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The argument part is similar to an ordinary function, where you input values
    to the arguments and use them within your lambda code. In this case, the values
    of `bytesReceived` and `bytesTotal` are coming from the `downloadProgress` signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also capture all variables that are used in your function using the
    `=` sign. In this case, we captured the `html` variable without specifying it
    in the `captured` `variables` area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Function callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though Qt 6 supports the signals and slots mechanism, some of the features
    in Qt 6 still use **function callbacks**, such as keyboard input, window resizing,
    graphics painting, and others. Since these events only need to be implemented
    once, there is no need to use the signals and slots mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s get started by following this example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `mainwindow.h`, and add the following headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, declare these functions in `mainwindow.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent),'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ui(new Ui::MainWindow) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ui->setupUi(this);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: this->setMouseTracking(true);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ui->centralWidget->setMouseTracking(true);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, define the `resizeEvent()` and `keyPressedEvent()` functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Continue to implement the rest of the functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build and run the program. Then, try and move the mouse around, rescale the
    main window, press some random keys on your keyboard, and finally press the *Esc*
    key on your keyboard to close the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should be seeing debug texts similar to the ones that are being printed
    out on the application output window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Qt 6 objects, especially the main window, have a dozen built-in callback functions
    that exist as **virtual functions**. These functions can be overridden to perform
    your intended behavior when called. Qt 6 may invoke these **callback functions**
    when its expected condition has been met, such as a keyboard button has been pressed,
    the mouse cursor has been moved, the window has been resized, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The functions that we declared in the `mainwindow.h` file are virtual functions
    that are built into the `QWidget` class. We are just overriding them with our
    own code to define their new behavior when they are called.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Do take note that you must call `setMouseTracking(true)` for both `MainWindow`
    and `centralWidget` for the `mouseMoveEvent()` callback to work.
  prefs: []
  type: TYPE_NORMAL
- en: Without features such as function callbacks, signals and slots, we as programmers
    will have a more difficult time developing applications that are responsive and
    intuitive to use. Qt 6 shortens our development cycles and allows us to focus
    more on designing user-friendly applications.
  prefs: []
  type: TYPE_NORMAL
