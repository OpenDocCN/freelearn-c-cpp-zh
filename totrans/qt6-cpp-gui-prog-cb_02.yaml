- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Event Handling – Signals and Slots
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The signals and slots mechanism in Qt 6 is one of its most important features.
    It’s a method that allows communication between objects, which is a crucial part
    of a program’s graphical user interface. A signal can be emitted from any `QObject`
    object or its subclasses, which will then trigger any slot functions of any objects
    that are connected to the signal.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Signals and slots in a nutshell
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI events with signals and slots
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous programming made easier
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function callbacks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The technical requirements for this chapter include **Qt 6.6.1 MinGW 64-bit**
    and **Qt Creator 12.0.2**. All the code used in this chapter can be downloaded
    from the following GitHub repository: [https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter02](https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter02).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Signals and slots in a nutshell
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compared to **callbacks** (which Qt 6 also supports), the **signals and slots**
    mechanism is comparably more fluid and flexible for the programmer to use. It
    is both type-safe and not strongly coupled to the processing function, which makes
    it better than callback implementation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s get started by following these steps:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a `mainwindow.ui`.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag and drop a **PushButton** widget from the **Widget Box** to the UI canvas:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Dragging and dropping a push button to the UI canvas](img/B20976_02_001.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Dragging and dropping a push button to the UI canvas
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the **PushButton** widget and select **Go to slot**. A window
    will appear:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Selecting the clicked() signal and pressing OK](img/B20976_02_002.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Selecting the clicked() signal and pressing OK
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see a list of built-in slot functions available for the push button.
    Let’s select the `on_pushButton_clicked()` will now appear in both `mainwindow.h`
    and `mainwindow.cpp`. Qt Creator automatically added the slot function to your
    source code after you pressed the `mainwindow.h` now, you should be able to see
    an extra function under the `private` `slots` keyword:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The same goes for `mainwindow.cpp`, where the `on_pushButton_clicked()` function
    has been added for you:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let’s add a `QMessageBox` header to the top of your source file:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, add the following code within the `on_pushButton_clicked()` function:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, build and run the project. Then, click on the **Push** button; you should
    see that a message box pops out:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.3 – A message box pops out after pressing the push button](img/B20976_02_003.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – A message box pops out after pressing the push button
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to create our own signals and slot functions. Go to **File**
    | **New File or Project**, then create a new C++ class under the **Files and**
    **Classes** category:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Creating a new C++ class](img/B20976_02_004.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Creating a new C++ class
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we need to name our class `MyClass` and make sure that the base class
    is **QObject**:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Defining your custom class, which inherits the QObject class](img/B20976_02_005.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Defining your custom class, which inherits the QObject class
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have created the class, open up `myclass.h` and add the following
    code, which is highlighted here for clarity:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, open up `myclass.cpp` and implement the `doSomething()` slot function.
    We’ll copy the message box function from the previous example:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, open up `mainwindow.h` and include the `myclass.h` header at the top:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Also, declare a `doNow()` signal in `myclass.h`:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After that, open up `mainwindow.cpp` and define a `MyClass` object. Then, we’ll
    connect the `doNow()` signal that we created in the previous step with our `doSomething()`
    slot function:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we have to change the code of the `on_pushButton_clicked()` function
    to something like this:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you build and run the program now, you will get a result that is similar
    to what’s shown in the previous example. However, we have placed the message box
    code in the `MyClass` object instead of in `MainWindow`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding steps demonstrated how we can utilize the slot-and-signal feature
    in Qt 6 to easily link a widget action to an event function. It really is that
    simple.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The signals and slots mechanism has gone through some changes in the recent
    version of Qt, most notably its coding syntax. Qt 6 no longer supports the older
    syntax; therefore, if you are trying to port your older Qt 5 project to Qt 6,
    you must change your code to comply with the newer syntax.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'In the good old days, we would typically connect a signal to a slot like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'However, things have changed slightly since then. In the new syntax, the `SIGNAL`
    and `SLOT` macros are now gone, and you must specify the type of your object,
    as shown in the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The new syntax also allows you to connect a signal directly to a function instead
    of `QObject`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Additionally, you can also connect your signal to a **lambda expression**. We
    will talk more about this in the *Asynchronous programming made* *easier* recipe.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: A signal of an `arbitrary` class can trigger any private slots of an unrelated
    class that is going to be invoked, which is not possible with callbacks.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All Qt projects come with a project file with the `.pro` extension. This project
    file is used specifically by Qt’s own **qmake** build system, which helps simplify
    most of the complex build process by using a straightforward declarative style,
    defining standard variables to indicate the source and header files that are used
    in the project.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: There’s an alternative build system called `CMakeLists.txt` with Qt Creator
    and it will open the project just like using Qt’s project file. However, it’s
    not recommended for beginners to use CMake when developing their first application
    with Qt, as CMake is much more manual and it takes longer time to grasp its functionality.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about CMake, please visit [https://doc.qt.io/qt-6/cmake-get-started.html](https://doc.qt.io/qt-6/cmake-get-started.html).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Qt categorizes its features and functionality in the form of modules and classes.
    Each module contains a set of related functionalities that can be added to your
    project separately when needed. This allows the programmer to keep their program
    in optimum size and performance. The Qt Core and Qt GUI modules are included in
    every Qt project by default. To add additional modules, you simply need to add
    the module keyword to your Qt project file or add the package and link its libraries
    in `CMakeLists.txt` if you are using CMake for your project.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if I want to add the Qt `Network` module to my project, I will
    add the following keyword to my Qt project file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In CMake, however, it gets slightly longer:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After you have added the Qt `Network` module, you can now access its C++ classes
    such as `QNetworkAccessManager`, `QNetworkInterface`, `QNetworkRequest`, and so
    on. This modular approach creates an expandable ecosystem for Qt while allowing
    the developers to maintain this complex and powerful framework with ease.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about all the different Qt modules, please visit [https://doc.qt.io/qt.html](https://doc.qt.io/qt.html).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: UI events with signals and slots
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we demonstrated the use of signals and slots on a push
    button. Now, let’s explore the signals and slots that are available in other common
    widget types.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn how to use signals and slots with UI events, follow these steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a new **Qt Widgets** **Application** project.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag and drop a **PushButton**, **Combo Box**, **Line Edit**, **Spin Box**,
    and **Slider** widget from the **Widget Box** into your UI canvas:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Placing several widgets on the UI canvas](img/B20976_02_006.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Placing several widgets on the UI canvas
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, right-click on the push button, select **clicked()**, and press the **OK**
    button to proceed. A slot function will be created for you by Qt Creator:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Selecting the clicked() signal and pressing OK](img/B20976_02_007.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Selecting the clicked() signal and pressing OK
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Repeat the previous step, but this time, select the next selection until every
    function in `QAbstractButton` has been added to the source code:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, repeat the same steps on the combo box until all the slot functions available
    under the `QComboBox` class have been added to the source code:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The same goes for `lineEdit`, all of which are under the `QLineEdit` class:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After that, add the slot functions from the `QSpinBox` class for our `spin
    box` widget as well, which is relatively short:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Lastly, repeat the same step for our `slider` widget, which yields similar
    results:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once you’re done with that, open up `mainwindow.h` and add the `QDebug` header,
    as highlighted in the following code:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s implement the slot functions for our push button:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you build and run the project now, and then click on the push button, you
    will see that a different status gets printed out but at a slightly different
    time. This is due to different signals being emitted at different actions during
    the whole clicking process:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we will move on to the combo box. Since the default combo box is empty,
    let’s add some options to it by double-clicking on it from `mainwindow.ui` and
    adding the options that are shown in the pop-up window:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Adding more options to the combo box](img/B20976_02_008.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – Adding more options to the combo box
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, let’s implement the slot functions for the combo box in `mainwindow.cpp`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will continue to implement the rest of the slot functions for the combo
    box:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Build and run the project. Then, try to click on the combo box, hover over
    the other options, and select an option by clicking on it. You should see similar
    results to the following in your debug output:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we will move on to line edit and implement its slot functions, as shown
    in the following code:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We will continue to implement the rest of the slot functions of line edit:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Build and run the project. Then, click on the line edit and type `Hey`. You
    should see results similar to the following appearing in the debug output panel:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After that, we need to implement the slot functions for the spin box widget,
    as shown in the following code:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Try to build and run the program. Then, click the arrow buttons on the spin
    box, or directly edit the value in the box – you should get something similar
    to this:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Lastly, we’ll implement the slot functions for the horizontal slider widget:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Continue to implement the slot function for the slider, as shown in the following
    code:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Build and run the program. Then, click and drag the slider to the left and
    right – you should see results that are similar to the following:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Almost every widget has a set of slot functions associated with its usage or
    purpose. For example, a push button will start emitting signals that trigger the
    slot functions associated with it when it’s pressed or released. These expected
    behaviors that define the widget have slot functions that get called when the
    user triggers an action. As programmers, all we need to do is implement the slot
    functions and tell Qt what to do when these slot functions are being triggered.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous programming made easier
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the signals and slots mechanism is *asynchronous* in nature, we can make
    use of it for things other than user interfaces. In programming terms, an *asynchronous
    operation* is a process that works independently, allowing the program to continue
    its operation without waiting for the process to complete, which may stall the
    whole program. Qt 6 allows you to make use of its signals and slots mechanism
    to easily achieve asynchronous processes without much effort. This is even more
    true after Qt 6 enforced the new syntax for signals and slots, which allows a
    signal to trigger a normal function instead of a slot function from a `Qobject`
    object.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we will further explore this opportunity and learn
    how we can improve our program’s efficiency by using asynchronous operations through
    the signals and slots mechanism that’s provided by Qt 6.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn how to achieve asynchronous operations using the signals and slots
    mechanism, let’s follow this example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a **Qt Console** **Application** project:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Creating a new Qt Console Application project](img/B20976_02_009.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – Creating a new Qt Console Application project
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'This type of project will only provide a `main.cpp` file for you, instead of
    `mainwindow.h` and `mainwindow.cpp`, like our previous example projects. Let’s
    open up `main.cpp` and add the following headers to it:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, add the following code to our `main()` function. We will be using the
    `QNetworkAccessManager` class to initiate a `GET` request to the following web
    URL:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, we use C++11’s `QNetworkReply` signals to inline functions:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can also use a lambda expression with `connect()` to call a function that
    is not under a `QObject` class:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Lastly, we define the `printHTML()` function, as shown in the following code:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If you build and run the program now, you will see that it’s functional even
    without declaring any slot function. **Lambda expressions** make declaring a slot
    function optional, but this is only recommended if your code is really short:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Printing HTML source code on the terminal window](img/B20976_02_010.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – Printing HTML source code on the terminal window
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: If the terminal window does not appear after you build and run your Qt console
    application project, go to **Edit** | **Preferences** | **Build & Run** and select
    **Enabled** for the **Default for “Run in** **terminal”** option.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.11 – Enabling the terminal window from the Preferences settings](img/B20976_02_011.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – Enabling the terminal window from the Preferences settings
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example demonstrated how we can run a lambda function within the
    network reply slot function. This way, we can ensure that our code is shorter
    and easier to debug, but the lambda function is only suitable if the function
    is meant to be called only once.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding example is a very simple application that showcases the use of
    lambda expressions to connect a signal with a lambda function or a regular function
    without declaring any slot function and thus does not need to be inherited from
    a `QObject` class.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'This is especially useful for calling asynchronous processes that are not under
    UI objects. Lambda expressions are functions that get defined within another function
    anonymously, which is quite similar to the anonymous functions in **JavaScript**.
    The format of a lambda function looks like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You can insert variables into a lambda expression by placing them into the `captured
    variables` part, as we did in the example project in this recipe. We capture the
    `QNetworkReply` object called `reply`, and the `QString` object called `html`,
    and put them in our lambda expression.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can use these variables within our lambda code, as shown in the following
    code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The argument part is similar to an ordinary function, where you input values
    to the arguments and use them within your lambda code. In this case, the values
    of `bytesReceived` and `bytesTotal` are coming from the `downloadProgress` signal:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can also capture all variables that are used in your function using the
    `=` sign. In this case, we captured the `html` variable without specifying it
    in the `captured` `variables` area:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Function callbacks
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though Qt 6 supports the signals and slots mechanism, some of the features
    in Qt 6 still use **function callbacks**, such as keyboard input, window resizing,
    graphics painting, and others. Since these events only need to be implemented
    once, there is no need to use the signals and slots mechanism.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s get started by following this example:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `mainwindow.h`, and add the following headers:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, declare these functions in `mainwindow.h`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent),'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ui(new Ui::MainWindow) {
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ui->setupUi(this);
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: this->setMouseTracking(true);
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ui->centralWidget->setMouseTracking(true);
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, define the `resizeEvent()` and `keyPressedEvent()` functions:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Continue to implement the rest of the functions:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Build and run the program. Then, try and move the mouse around, rescale the
    main window, press some random keys on your keyboard, and finally press the *Esc*
    key on your keyboard to close the program.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should be seeing debug texts similar to the ones that are being printed
    out on the application output window:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works…
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Qt 6 objects, especially the main window, have a dozen built-in callback functions
    that exist as **virtual functions**. These functions can be overridden to perform
    your intended behavior when called. Qt 6 may invoke these **callback functions**
    when its expected condition has been met, such as a keyboard button has been pressed,
    the mouse cursor has been moved, the window has been resized, and so on.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The functions that we declared in the `mainwindow.h` file are virtual functions
    that are built into the `QWidget` class. We are just overriding them with our
    own code to define their new behavior when they are called.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `mainwindow.h` 文件中声明的函数是 `QWidget` 类中内置的虚函数。我们只是用我们自己的代码覆盖它们，以定义它们被调用时的新行为。
- en: Note
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Do take note that you must call `setMouseTracking(true)` for both `MainWindow`
    and `centralWidget` for the `mouseMoveEvent()` callback to work.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 请务必注意，为了使 `mouseMoveEvent()` 回调正常工作，您必须对 `MainWindow` 和 `centralWidget` 都调用
    `setMouseTracking(true)`。
- en: Without features such as function callbacks, signals and slots, we as programmers
    will have a more difficult time developing applications that are responsive and
    intuitive to use. Qt 6 shortens our development cycles and allows us to focus
    more on designing user-friendly applications.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 没有诸如函数回调、信号和槽等特性，我们作为程序员将更难开发出响应迅速且易于使用的应用程序。Qt 6 缩短了我们的开发周期，并允许我们更多地专注于设计用户友好的应用程序。
