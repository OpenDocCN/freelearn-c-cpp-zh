- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Event Handling – Signals and Slots
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件处理 – 信号和槽
- en: The signals and slots mechanism in Qt 6 is one of its most important features.
    It’s a method that allows communication between objects, which is a crucial part
    of a program’s graphical user interface. A signal can be emitted from any `QObject`
    object or its subclasses, which will then trigger any slot functions of any objects
    that are connected to the signal.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 6 中的信号和槽机制是其最重要的特性之一。这是一种允许对象之间通信的方法，这是程序图形用户界面的重要组成部分。任何 `QObject` 对象或其子类都可以发出信号，然后触发连接到该信号的任何对象的任何槽函数。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Signals and slots in a nutshell
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号和槽概述
- en: UI events with signals and slots
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用信号和槽处理 UI 事件
- en: Asynchronous programming made easier
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步编程变得更容易
- en: Function callbacks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数回调
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The technical requirements for this chapter include **Qt 6.6.1 MinGW 64-bit**
    and **Qt Creator 12.0.2**. All the code used in this chapter can be downloaded
    from the following GitHub repository: [https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter02](https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter02).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求包括 **Qt 6.6.1 MinGW 64-bit** 和 **Qt Creator 12.0.2**。本章中使用的所有代码都可以从以下
    GitHub 仓库下载：[https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter02](https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter02)。
- en: Signals and slots in a nutshell
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号和槽概述
- en: Compared to **callbacks** (which Qt 6 also supports), the **signals and slots**
    mechanism is comparably more fluid and flexible for the programmer to use. It
    is both type-safe and not strongly coupled to the processing function, which makes
    it better than callback implementation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与 **回调**（Qt 6 也支持）相比，**信号和槽**机制对程序员来说更加流畅和灵活。它既类型安全，又没有与处理函数强耦合，这使得它比回调实现更好。
- en: How to do it…
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let’s get started by following these steps:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤开始：
- en: Let’s create a `mainwindow.ui`.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个 `mainwindow.ui`。
- en: 'Drag and drop a **PushButton** widget from the **Widget Box** to the UI canvas:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **小部件框** 将 **PushButton** 小部件拖放到 UI 画布上：
- en: '![Figure 2.1 – Dragging and dropping a push button to the UI canvas](img/B20976_02_001.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 将推按钮拖放到 UI 画布上](img/B20976_02_001.jpg)'
- en: Figure 2.1 – Dragging and dropping a push button to the UI canvas
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 将推按钮拖放到 UI 画布上
- en: 'Right-click on the **PushButton** widget and select **Go to slot**. A window
    will appear:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 **PushButton** 小部件并选择 **转到槽**。会出现一个窗口：
- en: '![Figure 2.2 – Selecting the clicked() signal and pressing OK](img/B20976_02_002.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 选择 clicked() 信号并按确定](img/B20976_02_002.jpg)'
- en: Figure 2.2 – Selecting the clicked() signal and pressing OK
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 选择 clicked() 信号并按确定
- en: 'You will see a list of built-in slot functions available for the push button.
    Let’s select the `on_pushButton_clicked()` will now appear in both `mainwindow.h`
    and `mainwindow.cpp`. Qt Creator automatically added the slot function to your
    source code after you pressed the `mainwindow.h` now, you should be able to see
    an extra function under the `private` `slots` keyword:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到可用于推按钮的内置槽函数列表。让我们选择 `on_pushButton_clicked()`，它现在将出现在 `mainwindow.h` 和
    `mainwindow.cpp` 中。在按下 `mainwindow.h` 后，Qt Creator 会自动将槽函数添加到你的源代码中，现在你应该能够在 `private`
    `slots` 关键字下看到一个额外的函数：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The same goes for `mainwindow.cpp`, where the `on_pushButton_clicked()` function
    has been added for you:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，对于 `mainwindow.cpp`，其中已经为你添加了 `on_pushButton_clicked()` 函数：
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let’s add a `QMessageBox` header to the top of your source file:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将 `QMessageBox` 头文件添加到源文件的顶部：
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, add the following code within the `on_pushButton_clicked()` function:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 `on_pushButton_clicked()` 函数内添加以下代码：
- en: '[PRE3]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, build and run the project. Then, click on the **Push** button; you should
    see that a message box pops out:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，构建并运行项目。然后，单击 **Push** 按钮；你应该能看到一个消息框弹出：
- en: '![Figure 2.3 – A message box pops out after pressing the push button](img/B20976_02_003.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 按下推按钮后弹出消息框](img/B20976_02_003.jpg)'
- en: Figure 2.3 – A message box pops out after pressing the push button
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 按下推按钮后弹出消息框
- en: 'Next, we want to create our own signals and slot functions. Go to **File**
    | **New File or Project**, then create a new C++ class under the **Files and**
    **Classes** category:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们想要创建自己的信号和槽函数。转到 **文件** | **新建文件或项目**，然后在 **文件和类** 类别下创建一个新的 C++ 类：
- en: '![Figure 2.4 – Creating a new C++ class](img/B20976_02_004.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – 创建一个新的 C++ 类](img/B20976_02_004.jpg)'
- en: Figure 2.4 – Creating a new C++ class
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 创建一个新的 C++ 类
- en: 'Then, we need to name our class `MyClass` and make sure that the base class
    is **QObject**:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要将我们的类命名为 `MyClass` 并确保基类是 **QObject**：
- en: '![Figure 2.5 – Defining your custom class, which inherits the QObject class](img/B20976_02_005.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – 定义你的自定义类，该类继承自 QObject 类](img/B20976_02_005.jpg)'
- en: Figure 2.5 – Defining your custom class, which inherits the QObject class
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 定义你的自定义类，该类继承自 QObject 类
- en: 'Once you have created the class, open up `myclass.h` and add the following
    code, which is highlighted here for clarity:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了类，打开 `myclass.h` 并添加以下代码，这里为了清晰起见进行了高亮：
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, open up `myclass.cpp` and implement the `doSomething()` slot function.
    We’ll copy the message box function from the previous example:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开 `myclass.cpp` 并实现 `doSomething()` 槽函数。我们将从上一个示例中复制消息框函数：
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, open up `mainwindow.h` and include the `myclass.h` header at the top:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开 `mainwindow.h` 并在顶部包含 `myclass.h` 头文件：
- en: '[PRE6]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Also, declare a `doNow()` signal in `myclass.h`:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在 `myclass.h` 中声明一个 `doNow()` 信号：
- en: '[PRE7]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After that, open up `mainwindow.cpp` and define a `MyClass` object. Then, we’ll
    connect the `doNow()` signal that we created in the previous step with our `doSomething()`
    slot function:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，打开 `mainwindow.cpp` 并定义一个 `MyClass` 对象。然后，我们将之前步骤中创建的 `doNow()` 信号与我们的 `doSomething()`
    槽函数连接起来：
- en: '[PRE8]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we have to change the code of the `on_pushButton_clicked()` function
    to something like this:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须将 `on_pushButton_clicked()` 函数的代码更改为如下所示：
- en: '[PRE9]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you build and run the program now, you will get a result that is similar
    to what’s shown in the previous example. However, we have placed the message box
    code in the `MyClass` object instead of in `MainWindow`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果现在构建并运行程序，您将得到一个类似于上一个示例的结果。然而，我们将消息框代码放置在了 `MyClass` 对象中，而不是在 `MainWindow`
    中。
- en: The preceding steps demonstrated how we can utilize the slot-and-signal feature
    in Qt 6 to easily link a widget action to an event function. It really is that
    simple.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的步骤展示了我们如何利用 Qt 6 中的槽和信号功能，轻松地将小部件动作链接到事件函数。这真的非常简单。
- en: How it works…
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The signals and slots mechanism has gone through some changes in the recent
    version of Qt, most notably its coding syntax. Qt 6 no longer supports the older
    syntax; therefore, if you are trying to port your older Qt 5 project to Qt 6,
    you must change your code to comply with the newer syntax.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Qt 的最新版本中，信号和槽机制经历了一些变化，最显著的是其编码语法。Qt 6 不再支持旧语法；因此，如果您正在尝试将旧的 Qt 5 项目移植到 Qt
    6，您必须更改代码以符合新的语法。
- en: 'In the good old days, we would typically connect a signal to a slot like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个美好的旧时光里，我们通常会像这样将一个信号连接到一个槽上：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'However, things have changed slightly since then. In the new syntax, the `SIGNAL`
    and `SLOT` macros are now gone, and you must specify the type of your object,
    as shown in the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从那时起，事情发生了一些变化。在新语法中，`SIGNAL` 和 `SLOT` 宏已经不再使用，您必须指定您对象的数据类型，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The new syntax also allows you to connect a signal directly to a function instead
    of `QObject`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 新语法还允许您直接将信号连接到一个函数，而不是 `QObject`：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Additionally, you can also connect your signal to a **lambda expression**. We
    will talk more about this in the *Asynchronous programming made* *easier* recipe.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以将信号连接到一个 **lambda 表达式**。我们将在 *Asynchronous programming made* *easier*
    菜谱中更多地讨论这一点。
- en: Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A signal of an `arbitrary` class can trigger any private slots of an unrelated
    class that is going to be invoked, which is not possible with callbacks.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `任意` 类的信号可以触发一个与之无关的类的任何私有槽，这在回调中是不可能的。
- en: There’s more…
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: All Qt projects come with a project file with the `.pro` extension. This project
    file is used specifically by Qt’s own **qmake** build system, which helps simplify
    most of the complex build process by using a straightforward declarative style,
    defining standard variables to indicate the source and header files that are used
    in the project.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Qt 项目都附带一个以 `.pro` 扩展名的项目文件。这个项目文件专门用于 Qt 自身的 **qmake** 构建系统，它通过使用直接的声明性风格，定义标准变量来指示项目中使用的源文件和头文件，从而帮助简化了大多数复杂的构建过程。
- en: There’s an alternative build system called `CMakeLists.txt` with Qt Creator
    and it will open the project just like using Qt’s project file. However, it’s
    not recommended for beginners to use CMake when developing their first application
    with Qt, as CMake is much more manual and it takes longer time to grasp its functionality.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为`CMakeLists.txt`的替代构建系统，与Qt Creator一起使用，它将以使用Qt项目文件相同的方式打开项目。然而，不建议初学者在用Qt开发他们的第一个应用程序时使用CMake，因为CMake更加手动，并且需要更长的时间来掌握其功能。
- en: Note
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about CMake, please visit [https://doc.qt.io/qt-6/cmake-get-started.html](https://doc.qt.io/qt-6/cmake-get-started.html).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于CMake的信息，请访问[https://doc.qt.io/qt-6/cmake-get-started.html](https://doc.qt.io/qt-6/cmake-get-started.html)。
- en: Qt categorizes its features and functionality in the form of modules and classes.
    Each module contains a set of related functionalities that can be added to your
    project separately when needed. This allows the programmer to keep their program
    in optimum size and performance. The Qt Core and Qt GUI modules are included in
    every Qt project by default. To add additional modules, you simply need to add
    the module keyword to your Qt project file or add the package and link its libraries
    in `CMakeLists.txt` if you are using CMake for your project.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Qt将它的特性和功能以模块和类的形式进行分类。每个模块都包含一组相关的功能，可以在需要时单独添加到您的项目中。这允许程序员保持他们的程序在最佳大小和性能。Qt核心和Qt
    GUI模块默认包含在每一个Qt项目中。要添加额外的模块，您只需将模块关键字添加到您的Qt项目文件中，或者如果您使用CMake进行项目，则在`CMakeLists.txt`中添加包并链接其库。
- en: 'For example, if I want to add the Qt `Network` module to my project, I will
    add the following keyword to my Qt project file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我想将Qt的`Network`模块添加到我的项目中，我将在我的Qt项目文件中添加以下关键字：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In CMake, however, it gets slightly longer:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在CMake中，这会稍微长一些：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After you have added the Qt `Network` module, you can now access its C++ classes
    such as `QNetworkAccessManager`, `QNetworkInterface`, `QNetworkRequest`, and so
    on. This modular approach creates an expandable ecosystem for Qt while allowing
    the developers to maintain this complex and powerful framework with ease.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在您添加了Qt的`Network`模块之后，现在您可以访问其C++类，如`QNetworkAccessManager`、`QNetworkInterface`、`QNetworkRequest`等。这种模块化方法为Qt创建了一个可扩展的生态系统，同时允许开发者轻松地维护这个复杂而强大的框架。
- en: Note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about all the different Qt modules, please visit [https://doc.qt.io/qt.html](https://doc.qt.io/qt.html).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于所有不同的Qt模块的信息，请访问[https://doc.qt.io/qt.html](https://doc.qt.io/qt.html)。
- en: UI events with signals and slots
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用信号和槽的UI事件
- en: In the previous recipe, we demonstrated the use of signals and slots on a push
    button. Now, let’s explore the signals and slots that are available in other common
    widget types.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们演示了在按钮上使用信号和槽的方法。现在，让我们探索其他常见小部件类型中可用的信号和槽。
- en: How to do it…
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To learn how to use signals and slots with UI events, follow these steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习如何使用信号和槽处理UI事件，请按照以下步骤操作：
- en: Let’s create a new **Qt Widgets** **Application** project.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个新的**Qt Widgets** **应用程序**项目。
- en: 'Drag and drop a **PushButton**, **Combo Box**, **Line Edit**, **Spin Box**,
    and **Slider** widget from the **Widget Box** into your UI canvas:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**小部件框**中将**按钮**、**组合框**、**行编辑**、**微调框**和**滑块**小部件拖放到您的UI画布上：
- en: '![Figure 2.6 – Placing several widgets on the UI canvas](img/B20976_02_006.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6 – 在UI画布上放置多个小部件](img/B20976_02_006.jpg)'
- en: Figure 2.6 – Placing several widgets on the UI canvas
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 在UI画布上放置多个小部件
- en: 'Then, right-click on the push button, select **clicked()**, and press the **OK**
    button to proceed. A slot function will be created for you by Qt Creator:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，右键单击按钮，选择**clicked()**，然后按**确定**按钮继续。Qt Creator将为您创建一个槽函数：
- en: '![Figure 2.7 – Selecting the clicked() signal and pressing OK](img/B20976_02_007.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – 选择clicked()信号并按确定](img/B20976_02_007.jpg)'
- en: Figure 2.7 – Selecting the clicked() signal and pressing OK
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 选择clicked()信号并按确定
- en: 'Repeat the previous step, but this time, select the next selection until every
    function in `QAbstractButton` has been added to the source code:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复前面的步骤，但这次选择下一个选择，直到将`QAbstractButton`中的每个函数都添加到源代码中：
- en: '[PRE15]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, repeat the same steps on the combo box until all the slot functions available
    under the `QComboBox` class have been added to the source code:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在组合框上重复相同的步骤，直到将`QComboBox`类下的所有槽函数都添加到源代码中：
- en: '[PRE16]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The same goes for `lineEdit`, all of which are under the `QLineEdit` class:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`lineEdit`也是如此，它们都属于`QLineEdit`类：
- en: '[PRE17]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After that, add the slot functions from the `QSpinBox` class for our `spin
    box` widget as well, which is relatively short:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，为我们的`spin box`小部件也添加来自`QSpinBox`类的槽函数，它相对较短：
- en: '[PRE18]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Lastly, repeat the same step for our `slider` widget, which yields similar
    results:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，对我们的`slider`小部件重复相同的步骤，得到类似的结果：
- en: '[PRE19]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once you’re done with that, open up `mainwindow.h` and add the `QDebug` header,
    as highlighted in the following code:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些后，打开`mainwindow.h`并添加`QDebug`头文件，如下代码所示：
- en: '[PRE20]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s implement the slot functions for our push button:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们实现我们的按钮的槽函数：
- en: '[PRE21]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you build and run the project now, and then click on the push button, you
    will see that a different status gets printed out but at a slightly different
    time. This is due to different signals being emitted at different actions during
    the whole clicking process:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在构建并运行项目，然后点击按钮，你会看到打印出不同的状态，但时间略有不同。这是由于在整个点击过程中不同动作发出不同信号造成的：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we will move on to the combo box. Since the default combo box is empty,
    let’s add some options to it by double-clicking on it from `mainwindow.ui` and
    adding the options that are shown in the pop-up window:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将转向组合框。由于默认的组合框是空的，让我们通过在`mainwindow.ui`中双击它并添加弹出窗口中显示的选项来向其中添加一些选项：
- en: '![Figure 2.8 – Adding more options to the combo box](img/B20976_02_008.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8 – 向组合框添加更多选项](img/B20976_02_008.jpg)'
- en: Figure 2.8 – Adding more options to the combo box
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 向组合框添加更多选项
- en: 'Then, let’s implement the slot functions for the combo box in `mainwindow.cpp`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们在`mainwindow.cpp`中实现组合框的槽函数：
- en: '[PRE23]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will continue to implement the rest of the slot functions for the combo
    box:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将继续实现组合框的其余槽函数：
- en: '[PRE24]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Build and run the project. Then, try to click on the combo box, hover over
    the other options, and select an option by clicking on it. You should see similar
    results to the following in your debug output:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行项目。然后，尝试点击组合框，悬停在其他选项上，并通过点击选择一个选项。你应该在你的调试输出中看到类似以下的结果：
- en: '[PRE25]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we will move on to line edit and implement its slot functions, as shown
    in the following code:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将转向行编辑并实现其槽函数，如下代码所示：
- en: '[PRE26]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We will continue to implement the rest of the slot functions of line edit:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将继续实现行编辑的其余槽函数：
- en: '[PRE27]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Build and run the project. Then, click on the line edit and type `Hey`. You
    should see results similar to the following appearing in the debug output panel:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行项目。然后，点击行编辑并输入`Hey`。你应该在调试输出面板中看到类似以下的结果：
- en: '[PRE28]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After that, we need to implement the slot functions for the spin box widget,
    as shown in the following code:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们需要实现滑块小部件的槽函数，如下代码所示：
- en: '[PRE29]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Try to build and run the program. Then, click the arrow buttons on the spin
    box, or directly edit the value in the box – you should get something similar
    to this:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试构建并运行程序。然后，点击滑块上的箭头按钮，或直接在框中编辑值 - 你应该得到类似以下的结果：
- en: '[PRE30]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Lastly, we’ll implement the slot functions for the horizontal slider widget:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将实现水平滑块小部件的槽函数：
- en: '[PRE31]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Continue to implement the slot function for the slider, as shown in the following
    code:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续实现滑块的槽函数，如下代码所示：
- en: '[PRE32]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Build and run the program. Then, click and drag the slider to the left and
    right – you should see results that are similar to the following:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行程序。然后，点击并拖动滑块向左或向右 - 你应该看到类似以下的结果：
- en: '[PRE33]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Almost every widget has a set of slot functions associated with its usage or
    purpose. For example, a push button will start emitting signals that trigger the
    slot functions associated with it when it’s pressed or released. These expected
    behaviors that define the widget have slot functions that get called when the
    user triggers an action. As programmers, all we need to do is implement the slot
    functions and tell Qt what to do when these slot functions are being triggered.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个小部件都有一组与其使用或目的相关的槽函数。例如，一个按钮在被按下或释放时将开始发出触发其相关槽函数的信号。这些定义小部件的预期行为具有在用户触发动作时被调用的槽函数。作为程序员，我们只需要实现槽函数并告诉Qt当这些槽函数被触发时应该做什么。
- en: Asynchronous programming made easier
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步编程变得更容易
- en: Since the signals and slots mechanism is *asynchronous* in nature, we can make
    use of it for things other than user interfaces. In programming terms, an *asynchronous
    operation* is a process that works independently, allowing the program to continue
    its operation without waiting for the process to complete, which may stall the
    whole program. Qt 6 allows you to make use of its signals and slots mechanism
    to easily achieve asynchronous processes without much effort. This is even more
    true after Qt 6 enforced the new syntax for signals and slots, which allows a
    signal to trigger a normal function instead of a slot function from a `Qobject`
    object.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于信号和槽机制本质上是**异步的**，我们可以用它来做除了用户界面之外的事情。在编程术语中，**异步操作**是一个独立工作的过程，允许程序在不需要等待该过程完成的情况下继续其操作，这可能会使整个程序停滞。Qt
    6 允许你利用其信号和槽机制轻松实现异步过程，而不需要付出太多努力。在 Qt 6 强制实施信号和槽的新语法之后，这一点更是如此，它允许信号触发一个普通函数，而不是从
    `Qobject` 对象的槽函数。
- en: In the following example, we will further explore this opportunity and learn
    how we can improve our program’s efficiency by using asynchronous operations through
    the signals and slots mechanism that’s provided by Qt 6.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将进一步探索这个机会，并学习我们如何通过使用 Qt 6 提供的信号和槽机制中的异步操作来提高我们程序的功效。
- en: How to do it…
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To learn how to achieve asynchronous operations using the signals and slots
    mechanism, let’s follow this example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用信号和槽机制实现异步操作，请遵循以下示例：
- en: 'Create a **Qt Console** **Application** project:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 **Qt 控制台应用程序** 项目：
- en: '![Figure 2.9 – Creating a new Qt Console Application project](img/B20976_02_009.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.9 – 创建新的 Qt 控制台应用程序项目](img/B20976_02_009.jpg)'
- en: Figure 2.9 – Creating a new Qt Console Application project
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 – 创建新的 Qt 控制台应用程序项目
- en: 'This type of project will only provide a `main.cpp` file for you, instead of
    `mainwindow.h` and `mainwindow.cpp`, like our previous example projects. Let’s
    open up `main.cpp` and add the following headers to it:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种类型的项目只会为你提供一个 `main.cpp` 文件，而不是像我们之前的示例项目那样提供 `mainwindow.h` 和 `mainwindow.cpp`。让我们打开
    `main.cpp` 并向其中添加以下头文件：
- en: '[PRE34]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, add the following code to our `main()` function. We will be using the
    `QNetworkAccessManager` class to initiate a `GET` request to the following web
    URL:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将以下代码添加到我们的 `main()` 函数中。我们将使用 `QNetworkAccessManager` 类来向以下网页 URL 发起 `GET`
    请求：
- en: '[PRE35]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, we use C++11’s `QNetworkReply` signals to inline functions:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用 C++11 的 `QNetworkReply` 信号内联函数：
- en: '[PRE36]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can also use a lambda expression with `connect()` to call a function that
    is not under a `QObject` class:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以使用 lambda 表达式与 `connect()` 一起调用不在 `QObject` 类下的函数：
- en: '[PRE37]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Lastly, we define the `printHTML()` function, as shown in the following code:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义 `printHTML()` 函数，如下所示：
- en: '[PRE38]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If you build and run the program now, you will see that it’s functional even
    without declaring any slot function. **Lambda expressions** make declaring a slot
    function optional, but this is only recommended if your code is really short:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在构建并运行程序，你会看到即使没有声明任何槽函数，它也是可用的。**Lambda 表达式**使声明槽函数成为可选的，但只有在你的代码真的很短的情况下才推荐这样做：
- en: '![Figure 2.10 – Printing HTML source code on the terminal window](img/B20976_02_010.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.10 – 在终端窗口中打印 HTML 源代码](img/B20976_02_010.jpg)'
- en: Figure 2.10 – Printing HTML source code on the terminal window
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – 在终端窗口中打印 HTML 源代码
- en: If the terminal window does not appear after you build and run your Qt console
    application project, go to **Edit** | **Preferences** | **Build & Run** and select
    **Enabled** for the **Default for “Run in** **terminal”** option.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在构建并运行你的 Qt 控制台应用程序项目后终端窗口没有出现，请转到 **编辑** | **首选项** | **构建和运行** 并选择 **启用**
    选项的 **默认“运行在”终端**。
- en: '![Figure 2.11 – Enabling the terminal window from the Preferences settings](img/B20976_02_011.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.11 – 从首选项设置中启用终端窗口](img/B20976_02_011.jpg)'
- en: Figure 2.11 – Enabling the terminal window from the Preferences settings
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11 – 从首选项设置中启用终端窗口
- en: The preceding example demonstrated how we can run a lambda function within the
    network reply slot function. This way, we can ensure that our code is shorter
    and easier to debug, but the lambda function is only suitable if the function
    is meant to be called only once.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例演示了如何在网络回复槽函数中运行 lambda 函数。这样，我们可以确保我们的代码更短，更容易调试，但 lambda 函数仅适用于函数只打算调用一次的情况。
- en: How it works…
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The preceding example is a very simple application that showcases the use of
    lambda expressions to connect a signal with a lambda function or a regular function
    without declaring any slot function and thus does not need to be inherited from
    a `QObject` class.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例是一个非常简单的应用程序，展示了使用 lambda 表达式连接信号与 lambda 函数或普通函数，而不需要声明任何槽函数，因此不需要从 `QObject`
    类继承。
- en: 'This is especially useful for calling asynchronous processes that are not under
    UI objects. Lambda expressions are functions that get defined within another function
    anonymously, which is quite similar to the anonymous functions in **JavaScript**.
    The format of a lambda function looks like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于调用不在 UI 对象下的异步过程特别有用。Lambda 表达式是在另一个函数内部匿名定义的函数，这与 **JavaScript** 中的匿名函数非常相似。Lambda
    函数的格式如下：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You can insert variables into a lambda expression by placing them into the `captured
    variables` part, as we did in the example project in this recipe. We capture the
    `QNetworkReply` object called `reply`, and the `QString` object called `html`,
    and put them in our lambda expression.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将它们放入 `捕获变量` 部分来将变量插入 lambda 表达式，就像我们在本食谱的示例项目中做的那样。我们捕获了名为 `reply` 的 `QNetworkReply`
    对象和名为 `html` 的 `QString` 对象，并将它们放入我们的 lambda 表达式中。
- en: 'Then, we can use these variables within our lambda code, as shown in the following
    code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在我们的 lambda 代码中使用这些变量，如下面的代码所示：
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The argument part is similar to an ordinary function, where you input values
    to the arguments and use them within your lambda code. In this case, the values
    of `bytesReceived` and `bytesTotal` are coming from the `downloadProgress` signal:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 参数部分类似于一个普通函数，其中你输入值到参数中，并在你的 lambda 代码中使用它们。在这种情况下，`bytesReceived` 和 `bytesTotal`
    的值来自 `downloadProgress` 信号：
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can also capture all variables that are used in your function using the
    `=` sign. In this case, we captured the `html` variable without specifying it
    in the `captured` `variables` area:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `=` 符号捕获你函数中使用的所有变量。在这种情况下，我们捕获了 `html` 变量，而没有在 `捕获变量` 区域中指定它：
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Function callbacks
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数回调
- en: Even though Qt 6 supports the signals and slots mechanism, some of the features
    in Qt 6 still use **function callbacks**, such as keyboard input, window resizing,
    graphics painting, and others. Since these events only need to be implemented
    once, there is no need to use the signals and slots mechanism.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Qt 6 支持信号和槽机制，但 Qt 6 中的一些功能仍然使用 **函数回调**，例如键盘输入、窗口调整大小、图形绘制等。由于这些事件只需要实现一次，因此不需要使用信号和槽机制。
- en: How to do it…
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Let’s get started by following this example:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下示例开始：
- en: 'Create a `mainwindow.h`, and add the following headers:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `mainwindow.h` 文件，并添加以下头文件：
- en: '[PRE43]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, declare these functions in `mainwindow.h`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 `mainwindow.h` 中声明这些函数：
- en: '[PRE44]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent),'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent),'
- en: ui(new Ui::MainWindow) {
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ui(new Ui::MainWindow) {
- en: ui->setupUi(this);
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ui->setupUi(this);
- en: this->setMouseTracking(true);
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: this->setMouseTracking(true);
- en: ui->centralWidget->setMouseTracking(true);
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ui->centralWidget->setMouseTracking(true);
- en: '}'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE45]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, define the `resizeEvent()` and `keyPressedEvent()` functions:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义 `resizeEvent()` 和 `keyPressedEvent()` 函数：
- en: '[PRE46]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Continue to implement the rest of the functions:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续实现其余的函数：
- en: '[PRE47]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Build and run the program. Then, try and move the mouse around, rescale the
    main window, press some random keys on your keyboard, and finally press the *Esc*
    key on your keyboard to close the program.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行程序。然后，尝试移动鼠标，调整主窗口的大小，按下键盘上的随机键，最后按下键盘上的 *Esc* 键来关闭程序。
- en: 'You should be seeing debug texts similar to the ones that are being printed
    out on the application output window:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到类似于在应用程序输出窗口中打印出的调试文本：
- en: '[PRE48]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works…
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Qt 6 objects, especially the main window, have a dozen built-in callback functions
    that exist as **virtual functions**. These functions can be overridden to perform
    your intended behavior when called. Qt 6 may invoke these **callback functions**
    when its expected condition has been met, such as a keyboard button has been pressed,
    the mouse cursor has been moved, the window has been resized, and so on.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 6 对象，尤其是主窗口，有十几个内置的回调函数，它们作为 **虚函数** 存在。这些函数可以在被调用时覆盖以执行你期望的行为。Qt 6 可能在其预期条件满足时调用这些
    **回调函数**，例如键盘按钮被按下、鼠标光标被移动、窗口被调整大小等。
- en: The functions that we declared in the `mainwindow.h` file are virtual functions
    that are built into the `QWidget` class. We are just overriding them with our
    own code to define their new behavior when they are called.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `mainwindow.h` 文件中声明的函数是 `QWidget` 类中内置的虚函数。我们只是用我们自己的代码覆盖它们，以定义它们被调用时的新行为。
- en: Note
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Do take note that you must call `setMouseTracking(true)` for both `MainWindow`
    and `centralWidget` for the `mouseMoveEvent()` callback to work.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 请务必注意，为了使 `mouseMoveEvent()` 回调正常工作，您必须对 `MainWindow` 和 `centralWidget` 都调用
    `setMouseTracking(true)`。
- en: Without features such as function callbacks, signals and slots, we as programmers
    will have a more difficult time developing applications that are responsive and
    intuitive to use. Qt 6 shortens our development cycles and allows us to focus
    more on designing user-friendly applications.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 没有诸如函数回调、信号和槽等特性，我们作为程序员将更难开发出响应迅速且易于使用的应用程序。Qt 6 缩短了我们的开发周期，并允许我们更多地专注于设计用户友好的应用程序。
