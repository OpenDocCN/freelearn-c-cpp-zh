- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Introduction to Inheritance and Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**C++** is, first and foremost, an object-oriented language, and objects are
    the fundamental building blocks of a C++ program. Class hierarchies are used to
    express relationships and interactions between different parts of a software system,
    define and implement interfaces between components, and organize data and code.
    While this isn’t a book for teaching C++, the aim of this chapter is to give the
    reader enough knowledge about C++ language features as they relate to classes
    and inheritance, which will be used in later chapters. To that end, we won’t attempt
    to completely describe the C++ tools for working with classes but introduce the
    concepts and language constructs that will be used throughout this book.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What are classes and what is their role in C++?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are class hierarchies and how does C++ use inheritance?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is runtime polymorphism and how is it used in C++?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes and objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object-oriented programming is a way to structure a program by combining the
    algorithms and the data that the algorithms operate on into single entities called
    **objects**. Most object-oriented languages, including C++, are class-based. A
    **class** is a definition of an object—it describes the algorithms and the data,
    its format, and its relations to other classes. An object is a concrete instantiation
    of a class, that is, a variable. An object has an address, which is a location
    in memory. A class is a user-defined type. In general, any number of objects can
    be instantiated from the definition provided by the class (some classes limit
    the number of objects that can be created, but this is an exception, not the norm).
  prefs: []
  type: TYPE_NORMAL
- en: In C++, the data contained in a class is organized as a collection of data members,
    or variables, of different types. The algorithms are implemented as functions—the
    methods of the class. While there’s no language requirement that the data members
    of a class should be somehow relevant to the implementation of its methods, it’s
    one of the signs of good design when the data is well encapsulated in the classes,
    and the methods have limited interaction with external data.
  prefs: []
  type: TYPE_NORMAL
- en: 'This concept of **encapsulation** is central to the classes in C++—the language
    allows us to control which data members and methods are public—visible outside
    of the class, and which are internal—private to the class. A well-designed class
    has mostly, or only, private data members, and the only public methods are those
    needed to express the public interface of the class—in other words, what the class
    does. This public interface is like a contract—the class designer promises that
    this class provides certain features and operations. The private data and methods
    of the class are part of the implementation, and they can be changed as long as
    the public interface, the contract we’ve committed to, remains valid. For example,
    the following class represents a rational number and supports the increment operation,
    as exposed by its public interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A well-designed class doesn’t expose any more of the implementation details
    than it has to through its public interface. The implementation isn’t part of
    the contract, although the documented interface may impose some restrictions on
    it. For example, if we promise that all rational numbers don’t contain any common
    multipliers in the numerator and denomination, the addition should include the
    step of canceling them. That would be a good use of a private member function—the
    implementation of several other operations will need to call it, but the client
    of the class never needs to call it because every rational number is already reduced
    to its lowest terms before it’s exposed to the callers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The class methods have special access to the data members—they can access the
    private data of the class. Note the distinction between the class and the object
    here—`operator+=()` is a method of the `Rational` class and is invoked on the
    object, `a`. However, it has access to the private data of the `b` object as well,
    because `a` and `b` are objects of the same class. If a member function references
    a class member by name without any additional qualifiers, then it’s accessing
    a member of the same class it’s invoked on (we can make it explicit by writing
    `this->n_` and `this->d_`). Accessing members of another object of the same class
    requires a pointer or a reference to that object, but is otherwise not restricted,
    as would have been the case if we tried to access a private data member from a
    non-member function.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, C++ also supports C-style structs. But in C++, a struct isn’t limited
    to just an aggregate of data members—it can have methods, public and private access
    modifiers, and anything else classes have. From a language point of view, the
    only difference between a class and a struct is the default access—in a class,
    all members and methods are private by default, while in a struct they’re public.
    Beyond that, the use of structs instead of classes is a matter of convention—traditionally,
    structs are used for C-style structs (structs that would be legal in C) as well
    as *almost* C-style structs, for example, a struct with only a constructor added.
    Of course, this boundary isn’t precise and is a matter of coding styles and practices
    in each project or team.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the methods and data members we’ve seen, C++ also supports static
    data and methods. A static method is very similar to a regular non-member function—it
    isn’t invoked on any particular object, and the only way it can get access to
    an object of any type is through its arguments. However, unlike a non-member function,
    a static method retains its privileged access to the private data of the class.
  prefs: []
  type: TYPE_NORMAL
- en: Classes by themselves are a useful way to group together (encapsulate) the algorithms
    and the data they operate on and to limit access to some data. However, the most
    powerful object-oriented features of C++ are inheritance and the resulting class
    hierarchies.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance and class hierarchies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Class hierarchies in C++ serve a dual purpose. On the one hand, they allow us
    to express relations between objects. On the other hand, they let us compose more
    complex types from simpler ones. Both uses are accomplished through inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of inheritance is central to the C++ use of classes and objects.
    Inheritance allows us to define new classes as extensions of existing ones. When
    a derived class is inherited from the base class, it contains, in some form, all
    of the data and the algorithms that were in the base class, and it adds some of
    its own. In C++, it’s important to distinguish between two primary types of inheritance—public
    and private.
  prefs: []
  type: TYPE_NORMAL
- en: Public inheritance inherits the public interface of the class. It also inherits
    the implementation—the data members of the base class are also a part of the derived
    class. But the inheritance of the interface is what distinguishes public inheritance—the
    derived class has, as a part of its public interface, the public member functions
    of the base class.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the public interface is like a contract—we promise to the clients
    of the class that it supports certain operations, maintains some invariants, and
    obeys the specified restrictions. By publicly inheriting from the base class,
    we bind the derived class to the same contract (plus any extensions of the contract,
    should we decide to define additional public interfaces). Because the derived
    class also respects the interface contract of the base class, we could use a derived
    class in any place in the code where a base class is expected—we would not be
    able to use any of the extensions to the interface (the code expects the base
    class, we don’t know about any extensions at that point), but the base class interface
    and its restrictions have to be valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is often expressed as the *is-a principle*—an instance of a derived class
    is also an instance of the base class. However, the way we interpret the *is-a*
    relationship in C++ isn’t exactly intuitive. For example, is a square a rectangle?
    If it is, then we can derive the `Square` class from the `Rectangle` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Right away, there’s something that doesn’t seem right—the derived class has
    two data members for dimensions, but it really needs only one. We would have to
    somehow enforce that they’re always the same. This doesn’t seem so bad—the `Rectangle`
    class has the interface that allows for any positive values of length and width,
    and the `Square` imposes additional restrictions. But it’s worse than that—the
    `Rectangle` class has a contract that allows the user to make the dimensions different.
    This can be quite explicit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have a public method that allows us to distort the rectangle, altering
    its aspect ratio. As with any other public method, it’s inherited by the derived
    classes, so now the `Square` class has it too. In fact, by using public inheritance,
    we assert that a `Square` object can be used anywhere a `Rectangle` object is
    used, without even knowing that it’s really a `Square`. Clearly, this is a promise
    we can’t keep—when the client of our class hierarchy tries to change the aspect
    ratio of a square, we can’t do it. We could ignore the call or report an error
    at runtime. Either way, we’ve violated the contract provided by the base class.
    There’s only one solution—in C++, a square isn’t a rectangle. Note that a rectangle
    is usually not a square, either—the contract provided by the `Square` interface
    could contain any number of guarantees that we can’t maintain if we derive the
    `Rectangle` class from `Square`.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, a penguin isn’t a bird in C++ if the bird interface includes flying.
    The correct design for such cases usually includes a more abstract base class,
    `Bird`, that doesn’t make any promises that at least one derived class can’t keep
    (for example, a `Bird` object doesn’t make a guarantee that it can fly). Then,
    we create intermediate-based classes, such as `FlyingBird` and `FlightlessBird`,
    that are derived from the common base class and serve as base classes for the
    more specific classes such as `Eagle` or `Penguin`. The important lesson here
    is that whether or not a penguin is a bird in C++ depends on how we define what
    a bird is, or, in C++ terms, what the public interface of the `Bird` class is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the public inheritance implies the *is-a* relationship, the language
    allows a wide range of conversions between references and pointers to different
    classes in the same hierarchy. First of all, a conversion from a pointer to a
    derived class into a pointer to the base class is implicit (this is the same for
    references):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This conversion is always valid because an instance of the derived class is
    also an instance of the base class. The inverse conversion is possible but has
    to be made explicit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The reason this conversion isn’t implicit is that it’s valid only if the base
    class pointer really points to a derived object (otherwise, the behavior is undefined).
    The programmer, therefore, must explicitly assert, using the static cast, that
    somehow, through the logic of the program or a prior test or by some other means,
    it’s known that this conversion is valid. If you aren’t sure that the conversion
    is valid, there’s a safer way to try it without causing undefined behavior; we’ll
    learn about this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the static (or implicit) conversion between pointers to base and
    derived classes is not quite as straightforward as you might think. The first
    base of any object always has the same address as the derived object itself, but
    then it gets more complicated. There is generally no standard requirement on the
    memory layout of derived classes with multiple bases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Most compilers will lay out the base classes first, then the data members of
    the derived class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_1.1_B19262.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – Possible memory layout of a derived class
  prefs: []
  type: TYPE_NORMAL
- en: 'From *Figure 1**.1*, it is evident that pointer conversion between the base
    and derived classes generally involves offset calculations. We can easily see
    this in an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The program prints something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that the `Base1` object is located at the same address as the `Derived`
    object, and `Base2` starts with an offset (16 bytes, in our case). Seems like
    the cast is an easy calculation: If you have a pointer to `Derived` and you want
    to cast to `Base2`, add 16\. The offsets between base classes are known at compile
    time, and the compiler knows the layout it is using. Pointer offset calculations
    are usually implemented in hardware (all modern CPUs support them and do not require
    a separate addition instruction). This doesn’t sound so hard at all.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what do you do if the pointer is `null`? The pointer has a value of 0\.
    If you apply the same *conversion*, you get `16 (0x10)`, and now your check for
    `null` fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, this would be very bad, so we can assume that `null` pointers remain
    so. Indeed, they do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints the same values for all pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is the only way to do casts, but it implies that a simple implicit cast
    from `Derived*` to `Base*` hides inside a conditional computation with a `null`
    pointer check.
  prefs: []
  type: TYPE_NORMAL
- en: The other kind of inheritance in C++ is **private inheritance**. When inheriting
    privately, the derived classes don’t extend the public interface of the base class—all
    base class methods become private in the derived class. Any public interface has
    to be created by the derived class, starting from a clean slate. There’s no assumption
    that an object of the derived class can be used in place of an object of the base
    class. What the derived class does get from the base class is the implementation
    details—both the methods and the data members can be used by the derived class
    to implement its own algorithms. It’s said, therefore, that private inheritance
    implements a *has-a* relationship—the derived object has an instance of the base
    class contained inside of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The relation of the privately derived class to its base class is, therefore,
    similar to that of the relationship of a class to its data members. The latter
    implementation technique is known as `using` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be useful in rare cases, but it’s also equivalent to an inline forwarding
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Second, a pointer or reference to a derived object can be converted into a pointer
    or reference to the base object, but only inside a member function of the derived
    class. Again, the equivalent functionality for composition is provided by taking
    the address of a data member. So far, we haven’t seen a good reason to use private
    inheritance, and indeed, the common advice is to prefer composition. But the next
    two reasons are more significant, and either one could be motivation enough to
    use private inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'One good reason to use private inheritance has to do with the size of the composed
    or derived objects. It isn’t uncommon to have base classes that provide only methods
    but no data members. Such classes have no data of their own and, therefore, should
    not occupy any memory. But in C++, they have to be given a non-zero size. This
    has to do with the requirement that any two different objects or variables have
    different and unique addresses. Typically, if we have two variables declared one
    after the other, the address of the second one is the address of the first one,
    plus the size of the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid the need to handle zero-sized objects differently, C++ assigns an
    empty object the size of one. If such an object is used as a data member of a
    class, it occupies at least 1 byte (the alignment requirements for the next data
    member may increase this value). This is wasted memory; it’ll never be used for
    anything. On the other hand, if an empty class is used as a base class, there’s
    no requirement that the base part of an object must have a non-zero size. The
    entire object of the derived class must have a non-zero size, but the address
    of a derived object, its base object, and its first data member can all be at
    the same address. Therefore, it’s legal in C++ to allocate no memory for an empty
    base class, even though `sizeof()` returns 1 for this class. While legal, such
    empty base class optimization isn’t required and is considered an optimization.
    Nonetheless, most modern compilers do this optimization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If we create many derived objects, the memory saved by the empty base optimization
    can be significant.
  prefs: []
  type: TYPE_NORMAL
- en: The second reason to possibly use private inheritance has to do with virtual
    functions, and this will be explained in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism and virtual functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we discussed public inheritance earlier, we mentioned that a derived object
    can be used in any place where a base object is expected. Even with this requirement,
    it’s often useful to know what the actual type of the object is—in other words,
    what type the object was created as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`some_method()` is a part of the public interface of the `Base` class and has
    to be valid for the `Derived` class as well. But, within the flexibility allowed
    by the contract of the base class interface, it can do something different. As
    an example, we’ve already used the avian hierarchy before to represent different
    birds, in particular, birds that can fly. The `FlyingBird` class can be assumed
    to have a `fly()` method, and every specific bird class derived from it has to
    support flight. But eagles fly differently from vultures, and so the implementation
    of the `fly()` method in the two derived classes, `Eagle` and `Vulture`, can be
    different. Any code that operates on arbitrary `FlyingBird` objects can call the
    `fly()` method, but the results will vary depending on the actual type of the
    object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This functionality is implemented in C++ using virtual functions. A virtual
    public function must be declared in the base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'A derived class inherits both the declaration and the implementation of this
    function. The declaration and the contract it provides must be respected. If the
    implementation meets the needs of the derived class, there’s no need to do anything
    more. But if the derived class needs to change the implementation, it can override
    the implementation of the base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that the keyword `virtual`, when used in a derived class for methods that
    override base class virtual functions, is entirely optional and has no effect;
    we will see later that there are good reasons to omit that.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a virtual function is called, the C++ runtime system must determine what
    the real type of the object is. Usually, this information isn’t known at compile
    time and must be determined at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The programming technique where some code operates on any number of base objects
    and invokes the same methods, but the results depend on the actual type of these
    objects, is known as **runtime polymorphism**, and the objects that support this
    technique are **polymorphic**. In C++, polymorphic objects must have at least
    one virtual function, and only the parts of their interface that use virtual functions
    for some or all of the implementation are polymorphic.
  prefs: []
  type: TYPE_NORMAL
- en: It should be evident from this explanation that the declaration of the virtual
    function and its overrides should be identical—the programmer calls the function
    on a base object, but the version that’s implemented in the derived class runs
    instead. This can happen only if the two functions have identical arguments and
    return types. One exception is that if a virtual function in the base class returns
    a pointer or a reference to an object of some type, the override can return a
    pointer or a reference to an object derived from that type (this is known as **covariant**
    **return types**).
  prefs: []
  type: TYPE_NORMAL
- en: A very common special case of polymorphic hierarchies is one where the base
    class doesn’t have a good *default* implementation of the virtual function. For
    example, all flying birds fly, but they all fly at different speeds, so there’s
    no reason to select one speed as the default. In C++, we can refuse to provide
    any implementation for a virtual function in the base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Such functions are called **pure virtual**, and any base class that contains
    a pure virtual function is known as an **abstract class**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: An abstract class defines an interface only; it’s the job of the concrete derived
    classes to implement it. If the base class contains a pure virtual function, every
    derived class that’s instantiated in the program must provide an implementation.
    In other words, an object of a base class can’t be created (a derived class could
    also be an abstract class, but then it cannot be instantiated directly either,
    we must derive another class from it). We can, however, have a pointer or a reference
    to an object of a base class—they really point to a derived class, but we can
    operate on it through the base class interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few notes on the C++ syntax—when overriding a virtual function, it isn’t
    required to repeat the `virtual` keyword. If the base class declares a virtual
    function with the same name and arguments, the one in the derived class will always
    be a virtual function and will override the one from the base class. Note that,
    if the arguments differ, the derived class function doesn’t override anything
    and instead shadows the name of the base class function. This can lead to subtle
    bugs where the programmer intended to override a base class function but didn’t
    copy the declaration correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the types of the arguments are slightly different. The `Eagle::fly()`
    function is also virtual, but it doesn’t override `FlyingBird::fly()`. If the
    latter is a pure virtual function, the bug will be caught because every pure virtual
    function must be implemented in a derived class. But if `FlyingBird::fly()` has
    the default implementation, then the bug will go undetected by the compiler. C++11
    provides a very useful feature that greatly simplifies finding such bugs—any function
    that’s intended to be an override of a base class virtual function can be declared
    with the `override` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `virtual` keyword is still optional, but if the `FlyingBird` class doesn’t
    have a virtual function that we could be overriding with this declaration, this
    code won’t compile.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to prevent the derived classes from overriding a virtual
    function by declaring it `final`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the use of the `final` keyword is rare: it is unusual for the design
    to require that from this point on, the customizations should be disabled in the
    hierarchy. The `final` keyword can also be applied to the entire class: it means
    that no more classes can be derived from this one. Again, this is a rare situation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, should or shouldn’t you use the `virtual` keyword on overrides? This is
    a matter of style, but the style affects the readability and maintainability of
    the code. The following is the recommended practice:'
  prefs: []
  type: TYPE_NORMAL
- en: Any virtual function that does not override one in the base class must use the
    `virtual` keyword. This includes both the functions in classes that have no bases
    and the functions added in derived classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any other virtual function should not use the `virtual` keyword. All overrides
    should use the `override` keyword, with the following exception, which is also
    another rule.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A final override must use the `final` keyword and should not use the `override`
    keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two advantages to this approach. The first is clarity and readability:
    if you see `virtual`, this is a virtual function that does not override anything.
    If you see `override`, this must be an override (otherwise the code would not
    compile). If you see `final`, this is also an override (again, the code would
    not compile otherwise) and it’s the last such in the hierarchy. The second advantage
    shows up during code maintenance. One of the greatest problems with maintaining
    hierarchies is the base class fragility: you write a set of base and derived classes,
    someone else comes along and adds an argument to the base class function, and
    suddenly all your derived class functions don’t override the base class ones and
    never get called. With consistent use of the `override` keyword, this will not
    happen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common use of virtual functions, by far, is in hierarchies that use
    public inheritance—since every derived object is also a base object (*is-a* relationship),
    a program can often operate on a collection of derived objects as if they were
    all of the same types, and the virtual function overrides ensure that the right
    processing happens for every object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'But virtual functions can also be used with private inheritance. The use is
    less straightforward (and much less common)—after all, an object that’s derived
    privately can’t be accessed through a base class pointer (a private base class
    is referred to as an **inaccessible base**, and an attempt to cast a derived class
    pointer to the base class will fail). However, there’s one context in which this
    cast is permitted, and that’s within a member function of the derived class. Here’s,
    then, the way to arrange a virtual function call from a privately inherited base
    class to the derived one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The public methods of the `Base` class become private in the `Derived` class,
    so we can’t call them directly. We can, however, call them from another method
    of the `Derived` class, such as the public method `h()`. We can then call `f()`
    directly from `h()`, but that doesn’t prove anything—it would come as no surprise
    if `Derived::h()` invoked `Derived::f()`.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we call the `Base::g()` function that’s inherited from the `Base` class.
    Inside that function, we’re in the `Base` class—the body of this function may
    have been written and compiled long before the `Derived` class was implemented.
    And yet, in this context, the virtual function override works correctly and `Derived::f()`
    is called, just as it would if the inheritance were public.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we recommended that composition is preferred to private
    inheritance unless there’s a reason to do otherwise. There’s no good way to implement
    similar functionality using composition; so, if the virtual function behavior
    is desired, private inheritance is the only way to go.
  prefs: []
  type: TYPE_NORMAL
- en: A class with a virtual method has to have its type encoded into every object—this
    is the only way to know, at runtime, what was the type of the object when it was
    constructed, after we converted the pointer into a base class pointer and lost
    any other information about the original type. That type information isn’t free;
    it takes space—a polymorphic object is always larger than an object with the same
    data members but no virtual methods (usually by the size of a pointer).
  prefs: []
  type: TYPE_NORMAL
- en: 'The extra size doesn’t depend on how many virtual functions the class has—at
    long as it has one, the type information must be encoded in the object. Now, recall
    that a pointer to the base class can be converted into a pointer to the derived
    class, but only if we know the correct type of the derived class. With the static
    cast, there’s no way to test whether our knowledge is correct. For non-polymorphic
    classes (classes without any virtual functions), there can be no better way; once
    their original type is lost, there is no way to recover it. But for polymorphic
    objects, the type is encoded in the object, so there has to be a way to use that
    information to check whether our assumption is correct about which derived object
    this really is. Indeed, there is a way. It’s provided by the dynamic cast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The dynamic cast doesn’t tell us what the real type of the object is; rather,
    it allows us to ask the question—Is the real type `Derived`? If our guess at the
    type is correct, the cast succeeds and returns the pointer to the derived object.
    If the real type is something else, the cast fails and returns a `null` pointer.
    The dynamic cast can also be used with references, with similar effects, save
    one—there’s no *null reference*. A function that returns a reference must always
    return a reference to some valid object. Since the dynamic cast can’t return a
    reference to a valid object if the requested type doesn’t match the actual type.
    The only alternative is to throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'For performance-conscious code, it is important to be aware of the run-time
    cost of the dynamic cast. Naively, one might think that a virtual function call
    and a dynamic cast take about the same time: both boil down to the question –
    is this pointer to `Base` really a pointer to `Derived`? A simple benchmark shows
    that this is not so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The benchmark results should look something like this (the absolute numbers
    will depend on the hardware): 1 nanosecond for the virtual call, and 5 to 10 nanoseconds
    for the dynamic cast. Why is the dynamic cast so expensive? We need to learn more
    about the hierarchies before we can answer this question.'
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve limited ourselves to only one base class. While it’s much easier
    to think about class hierarchies if we imagine them as trees, with the base class
    and the root and branches where multiple classes are derived from the same base,
    C++ doesn’t impose such limitations. Next, we’ll learn about inheriting from several
    base classes at once.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In C++, a class can be derived from several base classes. Going back to our
    birds, let’s make an observation—while flying birds have a lot in common with
    each other, they also have something in common with other flying animals, specifically,
    the ability to fly. Since flight isn’t limited to birds, we may want to move the
    data and the algorithms related to processing flight into a separate base class.
    But there’s also no denying that an eagle is a bird. We could express this relation
    if we used two base classes to construct the `Eagle` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the inheritance from both base classes is public, which means
    that the derived class inherits both interfaces and must fulfill two separate
    contracts. What happens if both interfaces define a method with the same name?
    If this method isn’t virtual, then an attempt to invoke it on the derived class
    is ambiguous, and the program doesn’t compile. If the method is virtual and the
    derived class has an override for it, then there’s no ambiguity since the method
    of the derived class is called. Also, `Eagle` is now both `Bird` and `FlyingAnimal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Both conversions from the derived class into the base class pointer are allowed.
    The reverse conversions must be made explicitly using a static or a dynamic cast.
    There’s another interesting conversion—if we have a pointer to a `FlyingAnimal`
    class that’s also a `Bird` class, can we cast from one to the other? Yes, we can
    with a dynamic cast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When used in this context, the dynamic cast is sometimes called a **cross-cast**—we
    aren’t casting up or down the hierarchy (between derived and based classes) but
    across the hierarchy—between the classes on different branches of the hierarchy
    tree.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-cast is also mostly responsible for the high runtime cost of the dynamic
    cast we have seen in the previous section. While the most common use of `dynamic_cast`
    is to cast from `Base*` to `Derived*` to verify that a given object is really
    of the derived class, the cast could also be used to cast between bases of the
    same derived class. This is a much harder problem. If you just want to check that
    the base class object is really a derived one, the compiler knows the `Derived`
    type at this point (you cannot use the dynamic cast on incomplete types).
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the compiler knows exactly what base classes this derived type has
    and can trivially check if yours is one of them. But when casting across the hierarchy,
    the compiler knows only two base classes: at the time when this code was written,
    a derived class that combines both may not exist, it will be written later. But
    the compiler must generate the correct code now. So, the compiler has to generate
    code that, at run time, digs through all the possible classes that are derived
    from both base classes to see if yours is one of them (the actual implementation
    is less straightforward and more efficient than that, but the task to be accomplished
    remains the same).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In reality, this overhead is often unnecessary because, most of the time, the
    dynamic cast is indeed used to find out whether the base class pointer really
    points to a derived object. In many cases, the overhead is not significant. But
    if better performance is required, there is no way to make the dynamic cast faster.
    If you want a fast way to check whether a polymorphic object is really of a given
    type, you have to use virtual functions and, unfortunately, a list of all possible
    types (or at least all the ones you might be interested in):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Multiple inheritance is often maligned and disfavored in C++. Much of this advice
    is outdated and stems from the time when compilers implemented multiple inheritance
    poorly and inefficiently. Today, with modern compilers, this isn’t a concern.
    It’s often said that multiple inheritance makes the class hierarchy harder to
    understand and reason about. Perhaps it would be more accurate to say that it’s
    harder to design a good multiple inheritance hierarchy that accurately reflects
    the relations between different properties, and that a poorly designed hierarchy
    is difficult to understand and reason about.
  prefs: []
  type: TYPE_NORMAL
- en: 'These concerns mostly apply to hierarchies that use public inheritance. Multiple
    inheritance can be private as well. There’s even less reason to use multiple private
    inheritance instead of composition than there was to use single private inheritance.
    However, the empty base optimization can be done on multiple empty base classes
    and remains a valid reason to use private inheritance, if it applies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Multiple inheritance can be particularly effective when the derived class represents
    a system that combines several unrelated, non-overlapping attributes. We’ll encounter
    such cases throughout this book when we explore various design patterns and their
    C++ representations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While by no means a complete guide or reference to classes and objects, this
    chapter introduced and explained the concepts you will need to understand the
    examples and explanations in the rest of this book. As our interest is and will
    be in representing design patterns in C++, this chapter focused on the proper
    use of classes and inheritance. We paid particular attention to what relations
    are expressed through different C++ features—it’s through these features we’ll
    express relations and interactions between different components that form a design
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will similarly cover knowledge of C++ templates, which will
    be necessary to understand the subsequent chapters of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the importance of objects in C++?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which relation is expressed by public inheritance? Which relation is expressed
    by private inheritance? What is a polymorphic object?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the difference between the dynamic cast and the static cast? Why is
    the dynamic cast so expensive?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Deciphering Object-Oriented Programming with* *C++*: [https://www.packtpub.com/product/deciphering-object-oriented-programming-with-c/9781804613900](https://www.packtpub.com/product/deciphering-object-oriented-programming-with-c/9781804613900)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Software Architecture with* *C++*: [https://www.packtpub.com/product/software-architecture-with-c/9781838554590](https://www.packtpub.com/product/software-architecture-with-c/9781838554590)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C++* *Fundamentals*: [https://www.packtpub.com/product/c-fundamentals](https://www.packtpub.com/product/c-fundamentals)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C++ Data Structures and* *Algorithms*: [https://www.packtpub.com/product/c-data-structures-and-algorithm-design-principles](https://www.packtpub.com/product/c-data-structures-and-algorithm-design-principles)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mastering C++* *Programming*: [https://www.packtpub.com/product/mastering-c-programming](https://www.packtpub.com/product/mastering-c-programming)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Beginning C++* *Programming*: [https://www.packtpub.com/product/beginning-c-programming](https://www.packtpub.com/product/beginning-c-programming)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
