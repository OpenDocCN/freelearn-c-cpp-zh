["```cpp\n{\n    \"inputs\":\n    [\n        {\n            \"type\": \"attachment\",\n            \"name\": \"depth\"\n        }\n    ],\n    \"name\": \"gbuffer_pass\",\n    \"outputs\":\n    [\n        {\n            \"type\": \"attachment\",\n            \"name\": \"gbuffer_colour\",\n            \"format\": \"VK_FORMAT_B8G8R8A8_UNORM\",\n            \"resolution\": [ 1280, 800 ],\n            \"op\": \"VK_ATTACHMENT_LOAD_OP_CLEAR\"\n        },\n        {\n            \"type\": \"attachment\",\n            \"name\": \"gbuffer_normals\",\n            \"format\": \"VK_FORMAT_R16G16B16A16_SFLOAT\",\n            \"resolution\": [ 1280, 800 ],\n            \"op\": \"VK_ATTACHMENT_LOAD_OP_CLEAR\"\n        },\n        ...\n    ]\n}\n```", "```cpp\n{\n    \"inputs\":\n    [\n        {\n            \"type\": \"attachment\",\n            \"name\": \"lighting\"\n        },\n        {\n            \"type\": \"attachment\",\n            \"name\": \"depth\"\n        }\n    ],\n    \"name\": \"transparent_pass\",\n    \"outputs\":\n    [\n        {\n            \"type\": \"reference\",\n            \"name\": \"lighting\"\n        }\n    ]\n}\n```", "```cpp\nstruct FrameGraphResource {\n    FrameGraphResourceType type;\n    FrameGraphResourceInfo resource_info;\n    FrameGraphNodeHandle producer;\n    FrameGraphResourceHandle output_handle;\n    i32 ref_count = 0;\n    const char* name = nullptr;\n};\n```", "```cpp\nstruct FrameGraphNode {\n    RenderPassHandle render_pass;\n    FramebufferHandle framebuffer;\n    FrameGraphRenderPass* graph_render_pass;\n    Array<FrameGraphResourceHandle> inputs;\n    Array<FrameGraphResourceHandle> outputs;\n    Array<FrameGraphNodeHandle> edges;\n    const char* name = nullptr;\n};\n```", "```cpp\n    FrameGraphBuilder frame_graph_builder;\n    ```", "```cpp\n    frame_graph_builder.init( &gpu );\n    ```", "```cpp\n    FrameGraph frame_graph;\n    ```", "```cpp\n    frame_graph.init( &frame_graph_builder );\n    ```", "```cpp\n    frame_graph.parse( frame_graph_path,\n    ```", "```cpp\n                       &scratch_allocator );\n    ```", "```cpp\n    frame_graph.compile();\n    ```", "```cpp\n    frame_graph->builder->register_render_pass(\n    ```", "```cpp\n        \"depth_pre_pass\", &depth_pre_pass );\n    ```", "```cpp\n    frame_graph->builder->register_render_pass(\n    ```", "```cpp\n        \"gbuffer_pass\", &gbuffer_pass );\n    ```", "```cpp\n    frame_graph->builder->register_render_pass(\n    ```", "```cpp\n        \"lighting_pass\", &light_pass );\n    ```", "```cpp\n    frame_graph->builder->register_render_pass(\n    ```", "```cpp\n        \"transparent_pass\", &transparent_pass );\n    ```", "```cpp\n    frame_graph->builder->register_render_pass(\n    ```", "```cpp\n        \"depth_of_field_pass\", &dof_pass );\n    ```", "```cpp\n    frame_graph->render( gpu_commands, scene );\n    ```", "```cpp\n    for ( u32 r = 0; r < node->inputs.size; ++r ) {\n    ```", "```cpp\n        FrameGraphResource* resource = frame_graph->\n    ```", "```cpp\n            get_resource( node->inputs[ r ].index );\n    ```", "```cpp\n        u32 output_index = frame_graph->find_resource(\n    ```", "```cpp\n            hash_calculate( resource->name ) );\n    ```", "```cpp\n        FrameGraphResource* output_resource = frame_graph\n    ```", "```cpp\n            ->get_resource( output_index );\n    ```", "```cpp\n        resource->producer = output_resource->producer;\n    ```", "```cpp\n        resource->resource_info = output_resource->\n    ```", "```cpp\n                                  resource_info;\n    ```", "```cpp\n        resource->output_handle = output_resource->\n    ```", "```cpp\n                                  output_handle;\n    ```", "```cpp\n        FrameGraphNode* parent_node = ( FrameGraphNode*)\n    ```", "```cpp\n                                        frame_graph->\n    ```", "```cpp\n                                        get_node(\n    ```", "```cpp\n                                        resource->\n    ```", "```cpp\n                                        producer.index );\n    ```", "```cpp\n        parent_node->edges.push( frame_graph->nodes[\n    ```", "```cpp\n                                 node_index ] );\n    ```", "```cpp\n    }\n    ```", "```cpp\n    Array<FrameGraphNodeHandle> sorted_nodes;\n    ```", "```cpp\n    sorted_nodes.init( &local_allocator, nodes.size );\n    ```", "```cpp\n    Array<u8> visited;\n    ```", "```cpp\n    visited.init( &local_allocator, nodes.size, nodes.size\n    ```", "```cpp\n    );\n    ```", "```cpp\n    memset( visited.data, 0, sizeof( bool ) * nodes.size );\n    ```", "```cpp\n    Array<FrameGraphNodeHandle> stack;\n    ```", "```cpp\n    stack.init( &local_allocator, nodes.size );\n    ```", "```cpp\n    for ( u32 n = 0; n < nodes.size; ++n ) {\n    ```", "```cpp\n        stack.push( nodes[ n ] );\n    ```", "```cpp\n        while ( stack.size > 0 ) {\n    ```", "```cpp\n            FrameGraphNodeHandle node_handle =\n    ```", "```cpp\n                stack.back();\n    ```", "```cpp\n            if (visited[ node_handle.index ] == 2) {\n    ```", "```cpp\n                stack.pop();\n    ```", "```cpp\n                continue;\n    ```", "```cpp\n            }\n    ```", "```cpp\n            if ( visited[ node_handle.index ]  == 1) {\n    ```", "```cpp\n                visited[ node_handle.index ] = 2; // added\n    ```", "```cpp\n                sorted_nodes.push( node_handle );\n    ```", "```cpp\n                stack.pop();\n    ```", "```cpp\n                continue;\n    ```", "```cpp\n            }\n    ```", "```cpp\n            visited[ node_handle.index ] = 1; // visited\n    ```", "```cpp\n            FrameGraphNode* node = ( FrameGraphNode* )\n    ```", "```cpp\n                                     builder->node_cache.\n    ```", "```cpp\n                                     nodes.access_resource\n    ```", "```cpp\n                                     ( node_handle.index\n    ```", "```cpp\n                                    );\n    ```", "```cpp\n            // Leaf node\n    ```", "```cpp\n            if ( node->edges.size == 0 ) {\n    ```", "```cpp\n                continue;\n    ```", "```cpp\n            }\n    ```", "```cpp\n            for ( u32 r = 0; r < node->edges.size; ++r ) {\n    ```", "```cpp\n                FrameGraphNodeHandle child_handle =\n    ```", "```cpp\n                    node->edges[ r ];\n    ```", "```cpp\n                if ( !visited[ child_handle.index ] ) {\n    ```", "```cpp\n                    stack.push( child_handle );\n    ```", "```cpp\n                }\n    ```", "```cpp\n            }\n    ```", "```cpp\n    for ( i32 i = sorted_nodes.size - 1; i >= 0; --i ) {\n    ```", "```cpp\n        nodes.push( sorted_nodes[ i ] );\n    ```", "```cpp\n    }\n    ```", "```cpp\nsizet resource_count = builder->resource_cache.resources.\n                       used_indices;\nArray<FrameGraphNodeHandle> allocations;\nallocations.init( &local_allocator, resource_count,\n                  resource_count );\nfor ( u32 i = 0; i < resource_count; ++i) {\n    allocations[ i ].index = k_invalid_index;\n}\nArray<FrameGraphNodeHandle> deallocations;\ndeallocations.init( &local_allocator, resource_count,\n                    resource_count );\nfor ( u32 i = 0; i < resource_count; ++i) {\n    deallocations[ i ].index = k_invalid_index;\n}\nArray<TextureHandle> free_list;\nfree_list.init( &local_allocator, resource_count );\n```", "```cpp\nfor ( u32 i = 0; i < nodes.size; ++i ) {\n    FrameGraphNode* node = ( FrameGraphNode* )builder->\n                             node_cache.nodes.access\n                             _resource( nodes[ i ].index );\n    for ( u32 j = 0; j < node->inputs.size; ++j ) {\n        FrameGraphResource* input_resource =\n            builder->resource_cache.resources.get(\n                node->inputs[ j ].index );\n        FrameGraphResource* resource =\n            builder->resource_cache.resources.get(\n                input_resource->output_handle.index );\n        resource->ref_count++;\n    }\n}\n```", "```cpp\nfor ( u32 i = 0; i < nodes.size; ++i ) {\n    FrameGraphNode* node = builder->get_node(\n                           nodes[ i ].index );\n    for ( u32 j = 0; j < node->outputs.size; ++j ) {\n        u32 resource_index = node->outputs[ j ].index;\n        FrameGraphResource* resource =\n            builder->resource_cache.resources.get(\n                resource_index );\n```", "```cpp\nif ( !resource->resource_info.external && \n  allocations[ resource_index ].index == \n  k_invalid_index ) { \n      allocations[ resource_index ] = nodes[ i ]; \nif ( resource->type == \n  FrameGraphResourceType_Attachment ) { \n     FrameGraphResourceInfo& info = \n        resource->resource_info; \n                if ( free_list.size > 0 ) {\n                    TextureHandle alias_texture =\n                        free_list.back();\n                    free_list.pop();\n                    TextureCreation texture_creation{ };\n                    TextureHandle handle =\n                        builder->device->create_texture(\n                            texture_creation );\n                    info.texture.texture = handle;\n                } else {\n                    TextureCreation texture_creation{ };\n                    TextureHandle handle =\n                        builder->device->create_texture(\n                            texture_creation );\n                    info.texture.texture = handle;\n                }\n            }\n         }\n    }\n```", "```cpp\n    for ( u32 j = 0; j < node->inputs.size; ++j ) {\n        FrameGraphResource* input_resource =\n            builder->resource_cache.resources.get(\n                node->inputs[ j ].index );\n        u32 resource_index = input_resource->\n                             output_handle.index;\n        FrameGraphResource* resource =\n            builder->resource_cache.resources.get(\n                resource_index );\n        resource->ref_count--;\nif ( !resource->resource_info.external && \n  resource->ref_count == 0 ) { \n     deallocations[ resource_index ] = nodes[ i ]; \nif ( resource->type == \n  FrameGraphResourceType_Attachment || \n  resource->type == \n  FrameGraphResourceType_Texture ) { \n     free_list.push( resource->resource_info. \n     texture.texture ); \n            }\n         }\n    }\n}\n```", "```cpp\nfor ( u32 n = 0; n < nodes.size; ++n ) {\n    FrameGraphNode*node = builder->get_node( nodes\n                          [ n ].index );\n    gpu_commands->clear( 0.3, 0.3, 0.3, 1 );\n    gpu_commands->clear_depth_stencil( 1.0f, 0 );\nfor ( u32 i = 0; i < node->inputs.size; ++i ) { \n   FrameGraphResource* resource = \n   builder->get_resource( node->inputs[ i ].index \n   );\nif ( resource->type == \n  FrameGraphResourceType_Texture ) { \n     Texture* texture = \n     gpu_commands->device->access_texture( \n     resource->resource_info.texture.texture \n     ); \nutil_add_image_barrier( gpu_commands-> \n    vk_command_buffer, texture->vk_image, \n    RESOURCE_STATE_RENDER_TARGET, \n    RESOURCE_STATE_PIXEL_SHADER_RESOURCE, \n    0, 1, resource->resource_info. \n    texture.format == \n    VK_FORMAT_D32_SFLOAT ); \n        } else if ( resource->type ==\n                    FrameGraphResourceType_Attachment ) {\n            Texture*texture = gpu_commands->device->\n                              access_texture( resource->\n                              resource_info.texture.texture\n                              ); }\n    }\n```", "```cpp\n    for ( u32 o = 0; o < node->outputs.size; ++o ) {\n        FrameGraphResource* resource =\n            builder->resource_cache.resources.get(\n                node->outputs[ o ].index );\n        if ( resource->type ==\n             FrameGraphResourceType_Attachment ) {\n            Texture* texture =\n                gpu_commands->device->access_texture(\n                    resource->resource_info.texture.texture\n                );\n            width = texture->width;\n            height = texture->height;\n        if ( texture->vk_format == VK_FORMAT_D32_SFLOAT ) {\n            util_add_image_barrier(\n            gpu_commands->vk_command_buffer,\n            texture->vk_image, RESOURCE_STATE_UNDEFINED,\n            RESOURCE_STATE_DEPTH_WRITE, 0, 1, resource->\n            resource_info.texture.format ==\n            VK_FORMAT_D32_SFLOAT );\n            } else {\n                 util_add_image_barrier( gpu_commands->\n                 vk_command_buffer, texture->vk_image,\n                 RESOURCE_STATE_UNDEFINED,\n                 RESOURCE_STATE_RENDER_TARGET, 0, 1,\n                 resource->resource_info.texture.format ==\n                 VK_FORMAT_D32_SFLOAT );\n            }\n        }\n    }\n```", "```cpp\n    Rect2DInt scissor{ 0, 0,( u16 )width, ( u16 )height };\n    gpu_commands->set_scissor( &scissor );\n    Viewport viewport{ };\n    viewport.rect = { 0, 0, ( u16 )width, ( u16 )height };\n    viewport.min_depth = 0.0f;\n    viewport.max_depth = 1.0f;\n    gpu_commands->set_viewport( &viewport );\n```", "```cpp\n    node->graph_render_pass->pre_render( gpu_commands,\n                                         render_scene );\n```", "```cpp\n    gpu_commands->bind_pass( node->render_pass, node->\n                             framebuffer, false );\n    node->graph_render_pass->render( gpu_commands,\n                                     render_scene );\n    gpu_commands->end_current_render_pass();\n}\n```"]