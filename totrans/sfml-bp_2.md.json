["```cpp\nclass Game\n{\n    public:\n        Game(const Game&) = delete;\n        Game& operator=(const Game&) = delete;\n        Game();\n        void run();\n\n    private:\n        void processEvents();\n        void update();\n        void render();\n\n        sf::RenderWindow _window;\n        sf::CircleShape  _player;\n};\n\nint main(int argc,char* argv[])\n{\n    Game game;\n    game.run();\n\n    return 0;\n}\n```", "```cpp\n    Game::Game() : _window(sf::VideoMode(800, 600),\"02_Game_Archi\"), _player(150)\n    {\n            _player.setFillColor(sf::Color::Blue);\n            _player.setPosition(10, 20);\n    }\n    ```", "```cpp\n    void Game::run()\n    {\n        while (_window.isOpen())\n        {\n            processEvents();\n            update();\n            render();\n        }\n    }\n    ```", "```cpp\n    void Game::processEvents() {\n      sf::Event event;\n      while(_window.pollEvent(event)) {\n        if ((event.type == sf::Event::Closed)\n        or ((event.type == sf::Event::KeyPressed) and (event.key.code == sf::Keyboard::Escape))) {\n          _window.close();\n        }\n      }\n    }\n    ```", "```cpp\n    void Game::update(){}\n    ```", "```cpp\n    void Game::render() {\n      _window.clear();\n      _window.draw(_player);\n      _window.display();\n    }\n    ```", "```cpp\nvoid Game::run(int frame_per_seconds)\n{\n    sf::Clock clock;\n    sf::Time timeSinceLastUpdate = sf::Time::Zero;\n    sf::Time TimePerFrame = sf::seconds(1.f/frame_per_seconds);\n\n    while (_window.isOpen())\n    {\n        processEvents();\n        bool repaint = false;\n\n        timeSinceLastUpdate += clock.restart();\n        while (timeSinceLastUpdate > TimePerFrame)\n        {\n            timeSinceLastUpdate -= TimePerFrame;\n            repaint = true;\n            update(TimePerFrame);\n        }\n        if(repaint)\n            render();\n    }\n}\n```", "```cpp\nvoid update(sf::Time deltaTime);\n```", "```cpp\nvoid Game::run()\n{\n    sf::Clock clock;\n\n    while (_window.isOpen())\n    {\n        processEvents();\n        update(clock.restart());\n        render();\n    }\n}\n```", "```cpp\nvoid Game::run(int minimum_frame_per_seconds)) { \n    sf::Clock clock; \n   sf::Time timeSinceLastUpdate; \n    sf::Time TimePerFrame = sf::seconds(1.f/minimum_frame_per_seconds); \n\n   while (_window.isOpen()) { \n       processEvents(); \n      timeSinceLastUpdate = clock.restart(); \n\n      while (timeSinceLastUpdate > TimePerFrame) { \n           timeSinceLastUpdate -= TimePerFrame; \n           update(TimePerFrame); \n      } \n     update(timeSinceLastUpdate); \n     render(); \n   } \n} \n```", "```cpp\nclass Player : public sf::Drawable {\n  public:\n    Player(const Player&) = delete;\n    Player& operator=(const Player&) = delete;\n    Player();\n\n    template<typename ... Args>\n    void setPosition(Args&& ... args) {\n      _shape.setPosition(std::forward<Args>(args)...);\n    }\n\n    void update(sf::Time deltaTime);\n    bool isMoving;\n    int rotation;\n\n  private:\n     virtual void draw(sf::RenderTarget& target, sf::RenderStates states) const override;\n     sf::RectangleShape  _shape;\n     sf::Vector2f        _velocity;\n}\n```", "```cpp\ntemplate<typename Arg> void setPosition(Arg arg);\n```", "```cpp\ntemplate<typename … Args> void setPosition(Args ... args);\n```", "```cpp\ntemplate<typename … Args> void setPosition(Args&& ... args);\n```", "```cpp\n_shape.setPosition(std::forward<Args>(args)...);\n```", "```cpp\nPlayer::Player() : _shape(sf::Vector2f(32,32))\n {\n     _shape.setFillColor(sf::Color::Blue);\n     _shape.setOrigin(16,16);\n }\n```", "```cpp\nvoid Player::update(sf::Time deltaTime)\n{\n    float seconds = deltaTime.asSeconds();\n    if(rotation != 0)\n    {\n        float angle = (rotation>0?1:-1)*180*seconds;\n        _shape.rotate(angle);\n    }\n    if(isMoving)\n    {\n        float angle = _shape.getRotation() / 180 * M_PI - M_PI / 2;\n        _velocity += sf::Vector2f(std::cos(angle),std::sin(angle)) * 60.f * seconds;\n    }\n    _shape.move(seconds * _velocity);\n}\n```", "```cpp\nvoid Player::draw(sf::RenderTarget& target, sf::RenderStates states) const\n{\n    target.draw(_shape,states);\n}\n```", "```cpp\nvoid Game::processEvents()\n{\n    sf::Event event;\n\n    while(_window.pollEvent(event))\n    {\n        if (event.type == sf::Event::Closed)\n            _window.close();\n        else if (event.type == sf::Event::KeyPressed)\n        {\n            if (event.key.code == sf::Keyboard::Escape)\n                _window.close();\n            else if(event.key.code == sf::Keyboard::Up)\n                _player.isMoving = true;\n            else if (event.key.code == sf::Keyboard::Left)\n                _player.rotation = -1;\n            else if (event.key.code == sf::Keyboard::Right)\n                _player.rotation = 1;\n        }\n        else if (event.type == sf::Event::KeyReleased)\n        {\n            if(event.key.code == sf::Keyboard::Up)\n                _player.isMoving = false;\n            else if (event.key.code == sf::Keyboard::Left)\n                _player.rotation = 0;\n            else if (event.key.code == sf::Keyboard::Right)\n                _player.rotation = 0;\n        }\n    }\n}\n```", "```cpp\nbool sf::Window::pollEvent(sf::Event& event);\n```", "```cpp\nsf::Event event;\nwhile(_window.pollEvent(event))\n{\n    // do something with the event\n}\n```", "```cpp\nvoid processEvents();\n```", "```cpp\nvoid Player::processEvents()\n{\n    isMoving = sf::Keyboard::isKeyPressed(sf::Keyboard::Up);\n    rotation = 0;\n    rotation-= sf::Keyboard::isKeyPressed(sf::Keyboard::Left);\n    rotation+= sf::Keyboard::isKeyPressed(sf::Keyboard::Right);\n}\n```", "```cpp\nstatic bool sf::Keyboard::isKeyPressed(sf::Keyboard::Key);\n```", "```cpp\nfloat angle = (rotation>0?1:-1)*180*seconds;\n```", "```cpp\nfloat angle = rotation*180*seconds;\n```", "```cpp\nvoid Game::processEvents()\n{\n    sf::Event event;\n    while(_window.pollEvent(event))\n    {\n        if (event.type == sf::Event::Closed)//Close window\n            _window.close();\n        else if (event.type == sf::Event::KeyPressed) //keyboard input\n        {\n            if (event.key.code == sf::Keyboard::Escape)\n                _window.close();\n        }\n    }                      \n    _player.processEvents();\n}\n```", "```cpp\nclass Action\n{\n    public:\n\n        enum Type\n        {\n            RealTime=1,\n            Pressed=1<<1,\n            Released=1<<2\n        };\n\n        Action(const sf::Keyboard::Key& key,int type=Type::RealTime|Type::Pressed);\n        Action(const sf::Mouse::Button& button,int type=Type::RealTime|Type::Pressed);                                                          \n\n        bool test()const;                                                                                        \n\n        bool operator==(const sf::Event& event)const;\n        bool operator==(const Action& other)const;\n\n    private:\n        friend class ActionTarget;\n        sf::Event _event;\n        int _type;\n};\n```", "```cpp\nAction::Action(const Action& other) : _type(other._type)\n{\n    std::memcpy(&_event,&other._event,sizeof(sf::Event));\n}\nAction& Action::operator=(const Action& other)\n{\n    std::memcpy(&_event,&other._event,sizeof(sf::Event));\n    _type = other._type;\n    return *this;\n}\n```", "```cpp\nAction::Action(const sf::Keyboard::Key& key,int type) : _type(type)\n{\n    _event.type = sf::Event::EventType::KeyPressed;\n    _event.key.code = key;\n}\n```", "```cpp\nAction::Action(const sf::Mouse::Button& button,int type) : _type(type)\n{\n    _event.type = sf::Event::EventType::MouseButtonPressed;\n    _event.mouseButton.button = button;\n}\n```", "```cpp\nbool Action::operator==(const sf::Event& event)const\n{\n    bool res = false;                                                                                                       \n    switch(event.type)\n    {\n        case sf::Event::EventType::KeyPressed:\n        {\n            if(_type & Type::Pressed and _event.type == sf::Event::EventType::KeyPressed)\n                res = event.key.code == _event.key.code;\n        }break;\n        case sf::Event::EventType::KeyReleased:\n        {\n            if(_type & Type::Released and _event.type == sf::Event::EventType::KeyPressed)\n                res = event.key.code == _event.key.code;\n        }break;\n        case sf::Event::EventType::MouseButtonPressed:\n        {\n            if(_type & Type::Pressed and _event.type == sf::Event::EventType::MouseButtonPressed)\n                res = event.mouseButton.button == _event.mouseButton.button;\n        }break;\n        case sf::Event::EventType::MouseButtonReleased:\n        {\n            if(_type & Type::Released and _event.type == sf::Event::EventType::MouseButtonPressed)\n                res = event.mouseButton.button == _event.mouseButton.button;\n        }break;\n        default: break;\n    }\n    return res;\n}\n```", "```cpp\nbool Action::operator==(const Action& other)const\n{\n    return _type == other._type and other == _event;\n}\n```", "```cpp\nbool Action::test()const\n{\n    bool res = false;\n    if(_event.type == sf::Event::EventType::KeyPressed)\n    {\n        if(_type & Type::Pressed)\n            res = sf::Keyboard::isKeyPressed(_event.key.code);\n    }\n    else if (_event.type == sf::Event::EventType::MouseButtonPressed)\n    {\n        if(_type & Type::Pressed)\n            res = sf::Mouse::isButtonPressed(_event.mouseButton.button);\n    }\n    return res;\n}\n```", "```cpp\nclass ActionTarget\n{\n    public:\n        using FuncType = std::function<void(const sf::Event&)>;\n\n        ActionTarget();\n\n        bool processEvent(const sf::Event& event)const;\n        void processEvents()const;\n\n        void bind(const Action& action,const FuncType& callback);\n        void unbind(const Action& action);\n\n    private:\n        std::list<std::pair<Action,FuncType>> _eventsRealTime;\n        std::list<std::pair<Action,FuncType>> _eventsPoll;\n};\n```", "```cpp\nActionTarget::ActionTarget()\n{\n}\n\nbool ActionTarget::processEvent(const sf::Event& event)const\n{\n    bool res = false;\n    for(auto& action : _eventsPoll)\n    {\n        if(action.first == event)\n        {\n            action.second(event);\n            res = true;\n            break;\n        }\n    }\n    return res;\n}\n\nvoid ActionTarget::processEvents()const\n{\n    for(auto& action : _eventsRealTime)\n    {\n        if(action.first.test())\n            action.second(action.first._event);\n    }\n}\n```", "```cpp\nvoid ActionTarget::bind(const book::Action& action,const FuncType& callback)\n{\n    if(action._type & Action::Type::RealTime)\n        _eventsRealTime.emplace_back(action,callback);\n    else\n        _eventsPoll.emplace_back(action,callback)\n}\n```", "```cpp\nvoid ActionTarget::unbind(const book::Action& action)\n{\n    auto remove_func = [&action](const std::pair<book::Action,FuncType>& pair) -> bool\n    {\n        return pair.first == action;\n    };\n\n    if(action._type & Action::Type::RealTime)\n        _eventsRealTime.remove_if(remove_func);\n    else\n        _eventsPoll.remove_if(remove_func);\n}\n```", "```cpp\n[captured, variables](parameters) -> returnType { definition };\n```", "```cpp\nclass Player : public sf::Drawable {…};\n```", "```cpp\nclass Player : public sf::Drawable , public ActionTarget {…};.\n```", "```cpp\nPlayer::Player() : _shape(sf::Vector2f(32,32))\n                   ,_isMoving(false)\n                   _rotation(0)\n{\n    _shape.setFillColor(sf::Color::Blue);\n    _shape.setOrigin(16,16);\n\n    bind(Action(sf::Keyboard::Up),[this](const sf::Event&){\n         _isMoving = true;\n    });\n\n    bind(Action(sf::Keyboard::Left),[this](const sf::Event&){\n         _rotation-= 1;\n     });\n\n    bind(Action(sf::Keyboard::Right),[this](const sf::Event&){\n         _rotation+= 1;\n     });\n}\n```", "```cpp\nvoid Player::processEvents()\n{\n    _isMoving = false;\n    _rotation = 0;\n    ActionTarget::processEvents();\n}\n```", "```cpp\ntemplate<typename T = int>\nclass ActionMap\n{\n    public:\n        ActionMap(const ActionMap<T>&) = delete;\n        ActionMap<T>& operator=(const ActionMap<T>&) = delete;\n\n        ActionMap() = default;\n\n        void map(const T& key,const Action& action);\n        const Action& get(const T& key)const;\n\n    private:\n        std::unordered_map<T,Action> _map;\n};\n```", "```cpp\ntemplate<typename T>\nvoid ActionMap<T>::map(const T& key,const Action& action)\n{\n    _map.emplace(key,action);\n}\n\ntemplate<typename T>\nconst Action& ActionMap<T>::get(const T& key)const\n{\n    return _map.at(key);\n}\n```", "```cpp\ntemplate<typename T = int>\nclass ActionTarget\n{\n    public:\n        ActionTarget(const ActionTarget<T>&) = delete;\n        ActionTarget<T>& operator=(const ActionTarget<T>&) = delete;\n\n        using FuncType = std::function<void(const sf::Event&)>;\n\n        ActionTarget(const ActionMap<T>& map);\n\n        bool processEvent(const sf::Event& event)const;\n        void processEvents()const;\n\n        void bind(const T& key,const FuncType& callback);\n        void unbind(const T& key);\n\n    private:\n        std::list<std::pair<T,FuncType>> _eventsRealTime;\n        std::list<std::pair<T,FuncType>> _eventsPoll;                                                                  \n\n        const ActionMap<T>& _actionMap;\n};\n```", "```cpp\nclass Player : public sf::Drawable , public ActionTarget<int>\n{\n    public:\n        Player(const Player&) = delete;\n        Player& operator=(const Player&) = delete;\n\n        Player();\n\n        template<typename ... Args>\n        void setPosition(Args&& ... args);\n\n        void processEvents();\n\n        void update(sf::Time deltaTime);\n\n        enum PlayerInputs {Up,Left,Right};\n        static void setDefaultsInputs();\n\n    private:\n         virtual void draw(sf::RenderTarget& target, sf::RenderStates states) const override;\n\n        sf::RectangleShape  _shape;\n        sf::Vector2f        _velocity;\n\n        bool _isMoving;\n        int _rotation;\n\n        static ActionMap<int> _playeInputs;\n};\n```", "```cpp\nPlayer::Player() : ActionTarget(_playerInputs)\n                   ,_shape(sf::Vector2f(32,32))\n                   ,_isMoving(false)\n                   ,_rotation(0)\n{\n    _shape.setFillColor(sf::Color::Blue);\n    _shape.setOrigin(16,16);\n\n    bind(PlayerInputs::Up,[this](const sf::Event&){\n         _isMoving = true;\n    });\n\n    bind(PlayerInputs::Left,[this](const sf::Event&){\n         _rotation-= 1;\n     });\n\n    bind(PlayerInputs::Right,[this](const sf::Event&){\n         _rotation+= 1;\n     });\n}\n```", "```cpp\nvoid Player::setDefaultsInputs()\n{\n    _playerInputs.map(PlayerInputs::Up,Action(sf::Keyboard::Up));\n    _playerInputs.map(PlayerInputs::Right,Action(sf::Keyboard::Right));\n    _playerInputs.map(PlayerInputs::Left,Action(sf::Keyboard::Left));\n}\n```", "```cpp\nActionMap<int> Player::_playerInputs;\n```", "```cpp\nint main(int argc,char* argv[])\n{\n    book::Player::setDefaultsInputs();\n\n    book::Game game;\n    game.run();\n\n    return 0;\n}\n```", "```cpp\nbool loadFomFile(const std::string &filename);\n```", "```cpp\nbool loadFromStream(sf::InputStream& stream);\n```", "```cpp\ntemplate<typename RESOURCE,typename IDENTIFIER = int>\nclass ResourceManager\n{\n    public:\n        ResourceManager(const ResourceManager&) = delete;\n        ResourceManager& operator=(const ResourceManager&) = delete;\n\n        ResourceManager() = default;\n\n        template<typename ... Args>\n        void load(const IDENTIFIER& id,Args&& ... args);\n\n        RESOURCE& get(const IDENTIFIER& id)const;\n\n    private:\n        std::unordered_map<IDENTIFIER,std::unique_ptr<RESOURCE>> _map;\n};\n```", "```cpp\ntemplate<typename RESOURCE,typename IDENTIFIER>\ntemplate<typename ... Args>\nvoid ResourceManager<RESOURCE,IDENTIFIER>::load(const IDENTIFIER& id,Args&& ... args)\n{\n    std::unique_ptr<RESOURCE> ptr(new RESOURCE);\n    if(not ptr->loadFromFile(std::forward<Args>(args)...))\n        throw std::runtime_error(\"Impossible to load file\");\n    _map.emplace(id,std::move(ptr));\n}\n```", "```cpp\ntemplate<typename RESOURCE,typename IDENTIFIER>\nRESOURCE& ResourceManager<RESOURCE,IDENTIFIER>::get(const IDENTIFIER& id)const\n{\n    return *_map.at(id);\n}\n```", "```cpp\ntemplate<typename IDENTIFIER>\nclass ResourceManager<sf::Music,IDENTIFIER>\n{\n    public:\n        ResourceManager(const ResourceManager&) = delete;\n        ResourceManager& operator=(const ResourceManager&) = delete;\n\n        ResourceManager() = default;\n\n        template<typename ... Args>\n        void load(const IDENTIFIER& id,Args&& ... args);\n\n        sf::Music& get(const IDENTIFIER& id)const;\n\n    private:\n        std::unordered_map<IDENTIFIER,std::unique_ptr<sf::Music>> _map;\n};\n```", "```cpp\ntemplate<typename IDENTIFIER>\ntemplate<typename ... Args>\nvoid ResourceManager<sf::Music,IDENTIFIER>::load(const IDENTIFIER& id,Args&& ... args)\n{\n    std::unique_ptr<sf::Music> ptr(new sf::Music);\n\n    if(not ptr->openFromFile(std::forward<Args>(args)...))\n        throw std::runtime_error(\"Impossible to load file\");\n    _map.emplace(id,std::move(ptr));\n};\n\ntemplate<typename IDENTIFIER>\nsf::Music& ResourceManager<sf::Music,IDENTIFIER>::get(const IDENTIFIER& id) const\n{\n    return *_map.at(id);\n}\n```", "```cpp\nclass Configuration\n{\n    public:\n        Configuration() = delete;\n        Configuration(const Configuration&) = delete;\n        Configuration& operator=(const Configuration&) = delete;\n\n        enum Textures : int {Player};\n        static ResourceManager<sf::Texture,int> textures;\n\n        enum PlayerInputs : int {Up,Left,Right};\n        static ActionMap<int> player_inputs;\n\n        static void initialize();\n\n    private:\n\n        static void initTextures();       \n        static void initPlayerInputs();\n};\n```", "```cpp\nResourceManager<sf::Texture,int> Configuration::textures;\nActionMap<int> Configuration::player_inputs;\n\nvoid Configuration::initialize()\n{\n    initTextures();\n    initPlayerInputs();\n}\n\nvoid Configuration::initTextures()\n{\n    textures.load(Textures::Player,\"media/Player/Ship.png\");\n}\n\nvoid Configuration::initPlayerInputs()\n{\n    player_inputs.map(PlayerInputs::Up,Action(sf::Keyboard::Up));\n    player_inputs.map(PlayerInputs::Right,Action(sf::Keyboard::Right));\n    player_inputs.map(PlayerInputs::Left,Action(sf::Keyboard::Left));\n}\n```", "```cpp\n_ship.setTexture(Configuration::textures.get(Configuration::Textures::Player));\n_ship.setOrigin(49.5,37.5);\n```"]