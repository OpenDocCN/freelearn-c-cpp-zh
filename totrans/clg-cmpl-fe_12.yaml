- en: Appendix 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compilation Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The test examples considered in the book do not require special compilation
    flags and typically can be compiled without any flags. However, this is not the
    scenario if you want to employ the material on a real project, such as running
    a lint check on your code base. In that situation, you will need to furnish special
    compilation flags for each file to be processed. Clang offers various methods
    for supplying these flags. We will explore in detail the JSON Compilation Database,
    which is one of the primary tools for delivering compilation flags to Clang tools
    such as Clang-Tidy and Clangd.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1 Compilation database definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **compilation database (CDB)** is a JSON file that specifies how each source
    file in a code base should be compiled. This JSON file is typically named `compile``_commands.json`
    and resides in the root directory of a project. It provides a machine-readable
    record of all compiler invocations in the build process and is often used by various
    tools for more accurate analysis, refactoring, and more. Each entry in this JSON
    file typically contains the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '**directory**: The working directory of the compilation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**command**: The actual compile command, including compiler options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**arguments**: Another field that can be used to specify compilation arguments.
    It contains the list of arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**file**: The path to the source file being compiled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**output**: The path to the output created by this compilation step.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we can see from the fields description, there are two ways to specify compilation
    flags: using the **command** or **arguments** field. Let’s look at a specific
    example. Suppose our C++ file `ProjectLib.cpp` is located at the `/home/user/project/src/lib`
    folder and can be compiled with Clang using the following invocation command (the
    command is used as an example, and you can ignore the meaning of its arguments)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following CDB can be used to represent the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 9.1**: Compilation Database for ProjectLib.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `"command"` field was used in the example. We can also create the CDB in
    another form and use the `arguments` field. The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 9.2**: CDB for ProjectLib.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: The **CDB** shown in [Figure 9.2](#x1-182029r2) represents the same compilation
    recipe as in [Figure 9.1](#x1-182012r1), but it uses a list of arguments (the
    ”arguments” field) instead of the invocation command (the ”command” field) used
    in [Figure 9.1](#x1-182012r1). It’s important to note that the list of arguments
    also contains the executable ”clang” as its first argument. CDB processing tools
    can use this argument to make a decision about which compiler should be used for
    the compilation in environments where different compilers are available, such
    as GCC versus Clang.
  prefs: []
  type: TYPE_NORMAL
- en: The provided CDB example contains only one record for one file. A real project
    might contain thousands of records. LLVM is a good example, and if you look at
    the `build` folder that we used for the LLVM build (see [*Section** 1.3.1*](B19722_01.xhtml#x1-270001)*,
    Configuration with CMake*), you may notice that it contains a `compile``_commands.json`
    file with the CDB for the projects we selected to be built. It’s worth noting
    that LLVM creates the CDB by default, but your project might require some special
    manipulations to create it. Let’s look at how the CDB can be created in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 9.2 CDB creation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `shell`compile˙commands.json file can be generated in various ways. For
    example, the build system CMake has built-in support for generating a compilation
    database. Some tools can also generate this file from Makefiles or other build
    systems. There are even tools such as Bear and intercept-build that can generate
    a CDB by intercepting the actual compile commands as they are run.
  prefs: []
  type: TYPE_NORMAL
- en: So while the term is commonly associated with Clang and LLVM-based tools, the
    concept itself is more general and could theoretically be used by any tool that
    needs to understand the compilation settings for a set of source files. We will
    start with CDB generation using CMake, one of the most popular build systems.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a CDB with CMake
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Generating a CDB with CMake involves a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, open a terminal or command prompt and navigate to your project’s root
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, run CMake with the `-DCMAKE``_EXPORT``_COMPILE``_COMMANDS=ON` option,
    which instructs CMake to create a `compile``_commands.json` file. This file contains
    the compilation commands for all source files in your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After configuring your project with CMake, you can find the `compile``_commands.json`
    file in the same directory where you ran the configuration command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As we noticed before, LLVM created the CDB by default. It’s achievable because
    `llvm/CMakeLists.txt` contains the following setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 9.3**: LLVM-18.x CMake configuration from llvm/CMakeLists.txt'
  prefs: []
  type: TYPE_NORMAL
- en: i.e., it set up the CDB generation by default.
  prefs: []
  type: TYPE_NORMAL
- en: Ninja to Generate a CDB
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Ninja can also be used to generate a CDB. We can use a Ninja subtool called
    `"compdb"` to dump the CDB to stdout. To run the subtool, we use the `-t <subtool>`
    command-line option in Ninja. Thus, we will use the following command to produce
    the CDB with Ninja:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 9.4**: Creating a CDB with Ninja'
  prefs: []
  type: TYPE_NORMAL
- en: This command instructs Ninja to generate the CDB information and save it in
    the `compile``_commands.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: The generated compilation database can be used with the different Clang tools
    that we have described in the book. Let’s look at two of the most valuable examples,
    which include Clang-Tidy and Clangd.
  prefs: []
  type: TYPE_NORMAL
- en: 9.3 Clang tools and a CDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The concept of a CDB is not specific to Clang but Clang-based tools make extensive
    use of it. For instance, the Clang compiler itself can use a compilation database
    to understand how to compile files in a project. Tools such as Clang-Tidy and
    Clangd (for language support in IDEs) can also use it to ensure they understand
    code as it was built, making their analyses and transformations more accurate.
  prefs: []
  type: TYPE_NORMAL
- en: Clang-Tidy Configuration for Large Projects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To use clang-tidy with a CDB, you typically don’t need any additional configuration.
    Clang-tidy can automatically detect and utilize the `compile``_commands.json`
    file in your project’s root directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, Clang Tools provide a special option, **-p**, defined as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use this option to run Clang-Tidy on a file from the Clang source code.
    For example, if you run it from the llvm-project folder where the source code
    was cloned, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 9.5**: Running Clang-Tidy on the LLVM code base'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we are running Clang-Tidy from the folder, where we installed
    it, as described in [*Section** 5.2.1*](B19722_05.xhtml#x1-1020001)*, Building
    and testing Clang-Tidy*. We have also specified the `build` folder as the project
    root folder containing the CDB.
  prefs: []
  type: TYPE_NORMAL
- en: Clang-Tidy is one of the tools that actively uses the CDB to be executed on
    large projects. Another tool is Clangd, which we will also explore.
  prefs: []
  type: TYPE_NORMAL
- en: Clangd Setup for Large Projects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Clangd offers a special configuration option to specify the path to the CDB.
    This option is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 9.6**: Description for ’–compile-commands-dir’ option from ’clangd
    –help’ output'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can specify this option in Visual Studio Code via the **Settings** panel,
    as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7: Configure the CDB path for clangd ](img/file12.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 9.7**: Configure the CDB path for clangd'
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, if you open a file from the Clang source code, you will have access
    to navigation support provided by Clangd as you can see in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8: Hover provided for Parser::Parser method by Clangd at clang/lib/Parse/Parser.cpp
    ](img/file13.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 9.8**: Hover provided for Parser::Parser method by Clangd at clang/lib/Parse/Parser.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: Integration of compile commands with Clang tools, such as Clang-Tidy or Clangd,
    provides a powerful tool for exploring and analyzing your source code.
  prefs: []
  type: TYPE_NORMAL
- en: 9.4 Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clang Documentation - JSON Compilation Database Format Specification: [https://clang.llvm.org/docs/JSONCompilationDatabase.html](https://clang.llvm.org/docs/JSONCompilationDatabase.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Clangd documentation - Compile commands: [https://clangd.llvm.org/design/compile-commands](https://clangd.llvm.org/design/compile-commands)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
