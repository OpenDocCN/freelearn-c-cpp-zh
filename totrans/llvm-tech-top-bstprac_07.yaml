- en: '*Chapter 5*: Exploring Clang''s Architecture'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Clang** is LLVM''s official frontend for **C-family** programming languages,
    including C, C++, and Objective-C. It processes the input source code (parsing,
    type checking, and semantic reasoning, to name a few) and generates equivalent
    LLVM IR code, which is then taken over by other LLVM subsystems to perform optimization
    and native code generation. Many *C-like* dialects or language extensions also
    find Clang easy to host their implementations. For example, Clang provides official
    support for OpenCL, OpenMP, and CUDA C/C++. In addition to normal frontend jobs,
    Clang has been evolving to partition its functionalities into libraries and modules
    so that developers can use them to create all kinds of tools related to **source
    code processing**; for example, code refactoring, code formatting, and syntax
    highlighting. Learning Clang development can not only bring you more engagement
    into the LLVM project but also open up a wide range of possibilities for creating
    powerful applications and tools.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Unlike LLVM, which arranges most of its tasks into a single pipeline (that is,
    **PassManager**) and runs them sequentially, there is more diversity in how Clang
    organizes its subcomponents. In this chapter, we will show you a clear picture
    of how Clang's important subsystems are organized, what their roles are, and which
    part of the code base you should be looking for.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Terminology
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: From this chapter through to the rest of this book, we will be using Clang (which
    starts with an uppercase C and a Minion Pro font face) to refer to the *project*
    and its *techniques* as a whole. Whenever we use `clang` (all in lowercase with
    a Courier font face), we are referring to the *executable program*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Learning Clang's subsystems and their roles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring Clang's tooling features and extension options
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a roadmap of this system so that you
    can kickstart your own projects and have some gravity for later chapters related
    to Clang development.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 1*](B14590_01_Final_JC_ePub.xhtml#_idTextAnchor014), *Saving Resources
    When Building LLVM*, we showed you how to build LLVM. Those instructions, however,
    did not build Clang. To include Clang in the build list, please edit the value
    that''s been assigned to the `LLVM_ENABLE_PROJECTS` CMake variable, like so:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The value of that variable should be a semi-colon-separated list, where each
    item is one of LLVM's subprojects. In this case, we're including Clang and `clang-tools-extra`,
    which contains a bunch of useful tools based on Clang's techniques. For example,
    the `clang-format` tool is used by countless open source projects, especially
    large-scale ones, to impose a unified coding style in their code base.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Adding Clang to an existing build
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: If you already have an LLVM build where Clang was not enabled, you can edit
    the `LLVM_ENABLE_PROJECTS` CMake argument's value in `CMakeCache.txt` without
    invoking the original CMake command again. CMake should reconfigure itself once
    you've edited the file and run Ninja (or a build system of your choice) again.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'You can build `clang`, Clang''s driver, and the main program using the following
    command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can run all the Clang tests using the following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, you should have the `clang` executable in the `/<your build directory>/bin`
    folder.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Learning Clang's subsystems and their roles
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will give you an overview of Clang's structures and organizations.
    We will briefly introduce some of the important components or subsystems, before
    using dedicated sections or chapters to expand them further in later parts of
    this book. We hope this will give you some idea of Clang's internals and how they
    will benefit your development.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s look at the big picture. The following diagram shows the high-level
    structure of Clang:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – High-level structure of Clang'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.1_B14590.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – High-level structure of Clang
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: As explained in the legend, rectangles with rounded corners represent subsystems
    that might consist of multiple components with similar functionalities. For example,
    the **frontend** can be further dissected into components such as the preprocessor,
    parser, and code generation logic, to name a few. In addition, there are intermediate
    results, depicted as ovals in the preceding diagram. We are especially interested
    in two of them – **Clang AST** and **LLVM IR**. The former will be discussed in
    depth in [*Chapter 7*](B14590_07_Final_JC_ePub.xhtml#_idTextAnchor093), *Handling
    AST*, while the latter is the main character of *Part 3*, *Middle-End Development*,
    which will talk about optimizations and analyses you can apply to LLVM IR.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by looking at an overview of the driver. The following subsections
    will give you a brief introduction to each of these driver components.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Driver
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common misunderstanding is that `clang`, the executable, is the compiler frontend.
    While `clang` does use Clang's frontend components, the executable itself is actually
    a kind of program called a **compiler driver**, or **driver** for short.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Compiling source code is a complex process. First, it consists of multiple
    phases, including the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '**Frontend**: Parsing and semantic checking'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Middle-end**: Program analysis and optimization'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Backend**: Native code generation'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assembling**: Running the assembler'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linking**: Running the linker'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Among these phases and their enclosing components, there are countless options/arguments
    and flags, such as the option to tell compilers where to search for include files
    (that is, the `-I` command-line option in GCC and Clang). Furthermore, we hope
    that the compiler can figure out the values for some of these options. For example,
    it would be great if the compiler could include some folders of C/C++ standard
    libraries (for example, `/include` and `/usr/include` in Linux systems) in the
    header file search paths *by default*, so that we don't need to assign each of
    those folders manually in the command line. Continuing with this example, it's
    clear that we want our compilers to be **portable** across different operating
    systems and platforms, but many operating systems use a different C/C++ standard
    library path. So, how do compilers pick the correct one accordingly?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'In this situation, a driver is designed to come to the rescue. It''s a piece
    of software that acts as a housekeeper for core compiler components, serving them
    essential information (for example, a OS-specific system include path, as we mentioned
    earlier) and arranging their executions so that users only need to supply important
    command-line arguments. A good way to observe the hard work of a driver is to
    use the `-###` command-line flag on a normal `clang` invocation. For example,
    you could try to compile a simple hello world program with that flag:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following is part of the output after running the preceding command on
    a macOS computer:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These are essentially the flags being passed to the *real* Clang frontend after
    the driver's *translation*. While you don't need to understand all these flags,
    it's true that even for a simple program, the compilation flow consists of an
    enormous amount of compiler options and many subcomponents.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: The source code for the driver can be found under `clang/lib/Driver`. In [*Chapter
    8*](B14590_08_Final_JC_ePub.xhtml#_idTextAnchor108), *Working with Compiler Flags
    and Toolchains*, we will look at this in more detail.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Frontend
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: A typical compiler textbook might tell you that a compiler frontend consists
    of a **lexer** and a **parser**, which generates an **abstract syntax tree** (**AST**).
    Clang's frontend also uses this skeleton, but with some major differences. First,
    the lexer is usually coupled with the **preprocessor**, and the semantic analysis
    that's performed on the source code is detached into a separate subsystem, called
    the **Sema**. This builds an AST and does all kinds of semantic checking.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Lexer and preprocessor
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Due to the complexity of programming language standards and the scale of real-world
    source code, preprocessing becomes non-trivial. For example, resolving included
    files becomes tricky when you have 10+ layers of a header file hierarchy, which
    is common in large-scale projects. Advanced directives such as `#pragma` can be
    challenged in cases where OpenMP uses `#pragma` to parallelize for loops. Solving
    these challenges requires close cooperation between the preprocessor and the lexer,
    which provides primitives for all the preprocessing actions. Their source code
    can be found under `clang/lib/Lex`. In [*Chapter 6*](B14590_06_Final_JC_ePub.xhtml#_idTextAnchor078),
    *Extending the Preprocessor*, you will become familiar with preprocessor and lexer
    development, and learn how to implement custom logic with a powerful extension
    system.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Parser and Sema
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Clang's parser consumes token streams from the preprocessor and lexer and tries
    to realize their semantic structures. Here, the Sema sub-system performs more
    semantic checking and analysis from the parser's result before generating the
    AST. Historically, there was another layer of abstraction where you could create
    your own *parser action* callbacks to specify what actions you wanted to perform
    when certain language directives (for example, identifiers such as variable names)
    were parsed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Back then, Sema was one of these parser actions. However, later on, people found
    that this additional layer of abstraction was not necessary, so the parser only
    interacts with Sema nowadays. Nevertheless, Sema still retains this kind of callback-style
    design. For example, the `clang::Sema::ActOnForStmt(…)` function (defined in `clang/lib/Sema/SemaStmt.cpp`)
    will be invoked when a for loop structure is parsed. It will then do all kinds
    of checking to make sure the syntax is correct and generate the AST node for the
    for loop; that is, a `ForStmt` object.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: AST
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The AST is the most important primitive when it comes to extending Clang with
    your custom logic. All the common Clang extensions/plugins that we will introduce
    operate on an AST. To get a taste of AST, you can use the following command to
    print out the an AST from the source code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For example, on my computer, I have used the following simple code, which only
    contains one function:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will yield the following output:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This command is pretty useful because it tells you the C++ AST class that represents
    certain language directives, which is crucial for writing AST callbacks – the
    core of many Clang plugins. For example, from the previous lines, we can know
    that a variable reference site (`c` in the `c + 1` expression) is represented
    by the `DeclRefExpr` class.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Similar to how the parser was organized, you can register different kinds of
    `ASTConsumer` instances to visit or manipulate the AST. **CodeGen**, which we
    will introduce shortly, is one of them. In [*Chapter 7*](B14590_07_Final_JC_ePub.xhtml#_idTextAnchor093),
    *Handling AST*, we will show you how to implement custom AST processing logic
    using plugins.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 与解析器的组织方式类似，你可以注册不同类型的`ASTConsumer`实例来访问或操作AST。**CodeGen**，我们将在稍后介绍，是其中之一。在[*第7章*](B14590_07_Final_JC_ePub.xhtml#_idTextAnchor093)
    *处理AST*中，我们将向您展示如何使用插件实现自定义AST处理逻辑。
- en: CodeGen
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CodeGen
- en: Though there are no prescriptions for how you should process the AST (for example,
    if you use the `-ast-dump` command-line option shown previously, the frontend
    will print the textual AST representation), the most common task that's performed
    by the CodeGen subsystem is emitting the LLVM IR code, which will later be compiled
    into native assembly or object code by LLVM.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有关于如何处理AST（例如，如果你使用前面显示的`-ast-dump`命令行选项，前端将打印文本AST表示）的规定，但CodeGen子系统执行的最常见任务是生成LLVM
    IR代码，该代码随后将被LLVM编译成本地汇编或目标代码。
- en: LLVM, assemblers, and linkers
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LLVM、汇编器和链接器
- en: Once the LLVM IR code has been emitted by the CodeGen subsystem, it will be
    processed by the LLVM compilation pipeline to generate native code, either assembly
    code or object code. LLVM provides a framework called the **MC layer**, in which
    architectures can choose to implement assemblers that have been directly integrated
    into LLVM's pipeline. Major architectures such as x86 and ARM use this approach.
    If you don't do this, any textual assembly code that's emitted at the end of LLVM's
    pipeline needs to be processed by external assembler programs invoked by the driver.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码生成子系统生成了LLVM IR代码，它将被LLVM编译管道处理以生成本地代码，无论是汇编代码还是目标代码。LLVM提供了一个名为**MC层**的框架，其中架构可以选择实现直接集成到LLVM管道中的汇编器。主要架构如x86和ARM都采用这种方法。如果你不这样做，LLVM管道末尾生成的任何文本汇编代码都需要由驱动程序调用的外部汇编程序处理。
- en: Despite the fact that LLVM already has its own linker, known as the **LLD**
    project, an *integrated* linker is still not a mature option yet. Therefore, external
    linker programs are always invoked by the driver to link the object files and
    generate the final binary artifacts.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管LLVM已经拥有自己的链接器，即被称为**LLD**项目，但一个**集成**链接器仍然不是一个成熟的选项。因此，外部链接器程序总是由驱动程序调用以链接目标文件并生成最终的二进制工件。
- en: External versus integrated
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 外部与集成
- en: Using external assemblers or linkers means invoking a *separate process* to
    run the program. For example, to run an external assembler, the frontend needs
    to put assembly code into a temporary file before launching the assembler with
    that file path as one of its command-line arguments. On the other hand, using
    integrated assemblers/linkers means the functionalities of assembling or linking
    are packaged into *libraries* rather than an executable. So, at the end of the
    compilation pipeline, LLVM will call APIs to process the assembly code's *in-memory*
    instances to emit object code. The advantage of this integrated approach is, of
    course, saving many indirections (writing into temporary files and reading them
    back right away). It also makes the code more concise to some extent.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用外部汇编器或链接器意味着调用一个**独立进程**来运行程序。例如，要运行外部汇编器，前端需要将汇编代码放入一个临时文件中，然后使用该文件路径作为其命令行参数之一来启动汇编器。另一方面，使用集成汇编器/链接器意味着汇编或链接的功能被打包到**库**中，而不是可执行文件。因此，在编译管道的末尾，LLVM将调用API来处理汇编代码的**内存中**实例以生成目标代码。这种集成方法的优点当然是节省许多间接操作（写入临时文件并立即读取）。这在一定程度上也使代码更加简洁。
- en: With that, you have been given an overview of a normal compilation flow, from
    the source code all the way to the native code. In the next section, we will go
    beyond the `clang` executable and provide an overview of the tooling and extension
    options provided by Clang. This not only augments the functionalities of `clang`,
    but also provides a way to use Clang's amazing techniques in out-of-tree projects.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，你已经对正常的编译流程有了概述，从源代码到本地代码。在下一节中，我们将超越`clang`可执行文件，并提供Clang提供的工具和扩展选项的概述。这不仅增强了`clang`的功能，还提供了一种在树外项目中使用Clang惊人技术的方法。
- en: Exploring Clang's tooling features and extension options
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Clang的工具功能和扩展选项
- en: The Clang project contains not just the `clang` executable. It also provides
    interfaces for developers to extend its tools, as well as to export its functionalities
    as libraries. In this section, we will give you an overview of all these options.
    Some of them will be covered in later chapters.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Clang 项目不仅包含 `clang` 可执行文件。它还为开发者提供了扩展其工具的接口，以及将其功能作为库导出的接口。在本节中，我们将为您概述所有这些选项。其中一些将在后面的章节中介绍。
- en: 'There are currently three kinds of tooling and extension options available
    in Clang: `clang::FrontendAction` class.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 目前在 Clang 中有三种工具和扩展选项可用：`clang::FrontendAction` 类。
- en: The FrontendAction class
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`FrontendAction` 类'
- en: 'In the *Learning Clang''s subsystems and their roles* section, we went through
    a variety of Clang''s frontend components, such as the preprocessor and Sema,
    to name a few. Many of these important components are encapsulated by a single
    data type, called `FrontendAction`. A `FrontendAction` instance can be treated
    as a single task running inside the frontend. It provides a unified interface
    for the task to consume and interact with various resources, such as input source
    files and ASTs, which is similar to the role of an **LLVM Pass** from this perspective
    (an LLVM Pass provides a unified interface to process LLVM IR). However, there
    are some significant differences with an LLVM Pass:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *学习 Clang 的子系统及其角色* 部分，我们探讨了 Clang 的各种前端组件，例如预处理器和 Sema，仅举几个例子。许多这些重要的组件都被一个单一的数据类型封装，称为
    `FrontendAction`。一个 `FrontendAction` 实例可以被视为在前端运行的单个任务。它提供了一个统一的接口，以便任务可以消费和与各种资源进行交互，例如输入源文件和
    AST，从这个角度来看，它类似于 **LLVM Pass** 的角色（LLVM Pass 提供了一个统一的接口来处理 LLVM IR）。然而，与 LLVM
    Pass 也有一些显著的不同：
- en: Not all of the frontend components are encapsulated into a `FrontendAction`,
    such as the parser and Sema. They are standalone components that generate materials
    (for example, the AST) for other FrontendActions to run.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并非所有前端组件都被封装到 `FrontendAction` 中，例如解析器和 Sema。它们是独立的组件，为其他 FrontendAction 运行生成材料（例如，AST）。
- en: Except for a few scenarios (the Clang plugin is one of them), a Clang compilation
    instance rarely runs multiple FrontendActions. Normally, only one `FrontendAction`
    will be executed.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了少数场景（Clang 插件就是其中之一）外，Clang 编译实例很少运行多个 FrontendAction。通常情况下，只有一个 `FrontendAction`
    将被执行。
- en: Generally speaking, a `FrontendAction` describes the task to be done at one
    or two important places in the frontend. This explains why it's so important for
    tooling or extension development – we're basically building our logic into a `FrontendAction`
    (one of FrontendAction's derived classes, to be more precise) instance to control
    and customize the behavior of a normal Clang compilation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，一个 `FrontendAction` 描述了在前端一个或两个重要位置要执行的任务。这也解释了为什么它对于工具或扩展开发如此重要——我们基本上是将我们的逻辑构建到一个
    `FrontendAction`（更精确地说，是 `FrontendAction` 的一个派生类）实例中，以控制和定制正常 Clang 编译的行为。
- en: 'To give you a feel for the `FrontendAction` module, here are some of its important
    APIs:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你对 `FrontendAction` 模块有一个感觉，这里列出了一些它的重要 API：
- en: '`FrontendAction::BeginSourceFileAction(…)/EndSourceFileAction(…)`: These are
    callbacks that derived classes can override to perform actions right before processing
    a source file and once it has been processed, respectively.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FrontendAction::BeginSourceFileAction(…)/EndSourceFileAction(…)`: 这些是派生类可以覆盖的回调，分别在处理源文件之前和之后执行操作。'
- en: '`FrontendAction::ExecuteAction(…)`: This callback describes the main actions
    to do for this `FrontendAction`. Note that while no one stops you from overriding
    this method directly, many of FrontendAction''s derived classes already provide
    simpler interfaces to describe some common tasks. For example, if you want to
    process an AST, you should inherit from `ASTFrontendAction` instead and leverage
    its infrastructures.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FrontendAction::ExecuteAction(…)`: 这个回调描述了为这个 `FrontendAction` 需要执行的主要操作。请注意，虽然没有人阻止你直接覆盖这个方法，但许多
    `FrontendAction` 的派生类已经提供了更简单的接口来描述一些常见任务。例如，如果你想处理一个 AST，你应该从 `ASTFrontendAction`
    继承并利用其基础设施。'
- en: '`FrontendAction::CreateASTConsumer(…)`: This is a factory function that''s
    used to create an `ASTConsumer` instance, which is a group of callbacks that will
    be invoked by the frontend when it''s traversing different parts of the AST (for
    example, a callback to be called when the frontend encounters a group of declarations).
    Note that while the majority of FrontendActions work after the AST has been generated,
    the AST might not be generated at all. This may happen if the user only wants
    to run the preprocessor, for example (such as to dump the preprocessed content
    using Clang''s `-E` command-line option). Thus, you don''t always need to implement
    this function in your custom `FrontendAction`.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, normally, you won't derive your class directly from `FrontendAction`,
    but understanding FrontendAction's internal role in Clang and its interfaces can
    give you more material to work with when it comes to tooling or plugin development.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Clang plugins
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Clang plugin allows you to dynamically register a new `FrontendAction` (more
    specifically, an `ASTFrontendAction`) that can process the AST either before or
    after, or even replace, the main action of `clang`. A real-world example can be
    found in the `virtual` keyword has been placed on methods that should be virtual.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'A plugin can be easily loaded into a normal `clang` by using simple command-line
    options:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is really useful if you want to customize the compilation but have no control
    over the `clang` executable (that is, you can't use a modified version of `clang`).
    In addition, using the Clang plugin allows you to integrate with the build system
    more tightly; for example, if you want to rerun your logic once the source files
    or even arbitrary build dependencies have been modified. Since the Clang plugin
    is still using `clang` as the driver and modern build systems are pretty good
    at resolving normal compilation command dependencies, this can be done by making
    a few compile flag tweaks.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: However, the biggest downside of using the Clang plugin is its `clang` executable,
    but only if the C++ APIs (and the ABI) are used by your plugin and the `clang`
    executable matches it. Unfortunately, for now, Clang (and also the whole LLVM
    project) has no intention to make any of its C++ APIs stable. In other words,
    to take the safest path, you need to make sure both your plugin and `clang` are
    using the *exact same* (major) version of LLVM. This issue makes the Clang plugin
    pretty hard to be released standalone.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: We will look at this in more detail in [*Chapter 7*](B14590_07_Final_JC_ePub.xhtml#_idTextAnchor093),
    *Handling AST*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: LibTooling and Clang Tools
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`clang` executable. Also, the APIs are designed to be more high-level so that
    you don''t need to deal with many of Clang''s internal details, making it more
    friendly to non-Clang developers.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '**Language server** is one of the most famous use cases of libTooling. A Language
    server is launched as a daemon process and accepts requests from editors or IDEs.
    These requests can be as simple as syntax checking a code snippet or complicated
    tasks such as code completions. While a Language server does not need to compile
    the incoming source code into native code as normal compilers do, it needs a way
    to parse and analyze that code, which is non-trivial to build from scratch. libTooling
    avoids the need to *recreate the wheels* in this case by taking Clang''s techniques
    off-the-shelf and providing an easier interface for Language server developers.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'To give you a more concrete idea of how libTooling differs from the Clang plugin,
    here is a (simplified) code snippet for executing a custom `ASTFrontendAction`
    called `MyCustomAction`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As shown in the previous code, you can't just embed this code into *any* code
    base. libTooling also provides lots of nice utilities, such as `CommonOptionsParser`,
    which parses textual command-line options and transforms them into Clang options
    for you.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: libTooling's API Stability
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, libTooling doesn't provide stable C++ APIs either. Nevertheless,
    this isn't a problem since you have full control over what LLVM version you're
    using.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least, `clang-refactor` to refactor the code. This includes renaming
    a variable, as shown in the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we want to rename the `Lat` member variable in the `Location` struct `Latitude`,
    we can use the following command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Building clang-refactor
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to follow the instructions at the beginning of this chapter to include
    `clang-tools-extra` in the list for the `LLVM_ENABLE_PROJECTS` CMake variable.
    By doing this, you'll be able to build `clang-refactor` using the `ninja clang-refactor`
    command.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'You will get the following output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is done by the refactoring framework built inside libTooling; `clang-refactor`
    merely provides a command-line interface for it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how Clang is organized and the functionalities
    of some of its important subsystems and components. Then, we learned about the
    differences between Clang's major extension and tooling options – the Clang plugin,
    libTooling, and Clang Tools – including what each of them looks like and what
    their pros and cons are. The Clang plugin provides an easy way to insert custom
    logic into Clang's compilation pipeline via dynamically loaded plugins but suffers
    from API stability issues; libTooling has a different focus than the Clang plugin
    in that it aims to provide a toolbox for developers to create a standalone tool;
    and Clang Tools provides various applications.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about preprocessor development. We will learn
    how the preprocessor and the lexer work in Clang, and show you how to write plugins
    for the sake of customizing preprocessing logic.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a list of checks that are done by Chromium''s Clang plugin: [https://chromium.googlesource.com/chromium/src/tools/clang/+/refs/heads/master/plugins/FindBadConstructsAction.h](https://chromium.googlesource.com/chromium/src/tools/clang/+/refs/heads/master/plugins/FindBadConstructsAction.h).'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里是Chromium的Clang插件执行的检查列表：[https://chromium.googlesource.com/chromium/src/tools/clang/+/refs/heads/master/plugins/FindBadConstructsAction.h](https://chromium.googlesource.com/chromium/src/tools/clang/+/refs/heads/master/plugins/FindBadConstructsAction.h).
- en: 'You can learn more about choosing the right Clang extension interface here:
    [https://clang.llvm.org/docs/Tooling.html](https://clang.llvm.org/docs/Tooling.html).'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于选择正确的Clang扩展接口的信息：[https://clang.llvm.org/docs/Tooling.html](https://clang.llvm.org/docs/Tooling.html).
- en: 'LLVM also has its own libTooling-based Language server, called `clangd`: [http://clangd.llvm.org](http://clangd.llvm.org).'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLVM还有一个基于libTooling的自己的语言服务器，称为`clangd`：[http://clangd.llvm.org](http://clangd.llvm.org).
