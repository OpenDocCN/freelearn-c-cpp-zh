["```cpp\n\n    void initializeM88kDivInstrPass(PassRegistry &);\n    ```", "```cpp\n\n    FunctionPass *createM88kDivInstr(const M88kTargetMachine &);\n    ```", "```cpp\n\n    using namespace llvm;\n    static cl::opt<bool>\n        NoZeroDivCheck(\"m88k-no-check-zero-division\", cl::Hidden,\n                       cl::desc(\"M88k: Don't trap on integer division by zero.\"),\n                       cl::init(false));\n    ```", "```cpp\n\n    M88kTargetMachine::~M88kTargetMachine() {}\n    bool M88kTargetMachine::noZeroDivCheck() const { return NoZeroDivCheck; }\n    ```", "```cpp\n\n    extern \"C\" LLVM_EXTERNAL_VISIBILITY void LLVMInitializeM88kTarget() {\n       RegisterTargetMachine<M88kTargetMachine> X(getTheM88kTarget());\n       auto &PR = *PassRegistry::getPassRegistry();\n       initializeM88kDAGToDAGISelPass(PR);\n       initializeM88kDivInstrPass(PR);\n     }\n    ```", "```cpp\n\n       bool addInstSelector() override;\n       void addPreEmitPass() override;\n       void addMachineSSAOptimization() override;\n    . . .\n    void M88kPassConfig::addMachineSSAOptimization() {\n       addPass(createM88kDivInstr(getTM<M88kTargetMachine>()));\n       TargetPassConfig::addMachineSSAOptimization();\n    }\n    ```", "```cpp\n\n       ~M88kTargetMachine() override;\n       bool noZeroDivCheck() const;\n    ```", "```cpp\n\n    #include \"M88k.h\"\n    #include \"M88kInstrInfo.h\"\n    #include \"M88kTargetMachine.h\"\n    #include \"MCTargetDesc/M88kMCTargetDesc.h\"\n    #include \"llvm/ADT/Statistic.h\"\n    #include \"llvm/CodeGen/MachineFunction.h\"\n    #include \"llvm/CodeGen/MachineFunctionPass.h\"\n    #include \"llvm/CodeGen/MachineInstrBuilder.h\"\n    #include \"llvm/CodeGen/MachineRegisterInfo.h\"\n    #include \"llvm/IR/Instructions.h\"\n    #include \"llvm/Support/Debug.h\"\n    ```", "```cpp\n\n    #define DEBUG_TYPE \"m88k-div-instr\"\n    ```", "```cpp\n\n    using namespace llvm;\n    STATISTIC(InsertedChecks, \"Number of inserted checks for division by zero\");\n    namespace {\n    ```", "```cpp\n\n    enum class CC0 : unsigned {\n      EQ0 = 0x2,\n      NE0 = 0xd,\n      GT0 = 0x1,\n      LT0 = 0xc,\n      GE0 = 0x3,\n      LE0 = 0xe\n    };\n    ```", "```cpp\n\n    class M88kDivInstr : public MachineFunctionPass {\n      friend class M88kBuilder;\n      const M88kTargetMachine *TM;\n      const TargetInstrInfo *TII;\n      const TargetRegisterInfo *TRI;\n      const RegisterBankInfo *RBI;\n      MachineRegisterInfo *MRI;\n      bool AddZeroDivCheck;\n    ```", "```cpp\n\n    public:\n      static char ID;\n      M88kDivInstr(const M88kTargetMachine *TM = nullptr);\n      MachineFunctionProperties getRequiredProperties() const override;\n      bool runOnMachineFunction(MachineFunction &MF) override;\n      bool runOnMachineBasicBlock(MachineBasicBlock &MBB);\n    ```", "```cpp\n\n    private:\n      void addZeroDivCheck(MachineBasicBlock &MBB, MachineInstr *DivInst);\n    };\n    ```", "```cpp\n\n    class M88kBuilder {\n      MachineBasicBlock *MBB;\n      MachineBasicBlock::iterator I;\n      const DebugLoc &DL;\n      const TargetInstrInfo &TII;\n      const TargetRegisterInfo &TRI;\n      const RegisterBankInfo &RBI;\n    ```", "```cpp\n\n    public:\n      M88kBuilder(M88kDivInstr &Pass, MachineBasicBlock *MBB, const DebugLoc &DL)\n          : MBB(MBB), I(MBB->end()), DL(DL), TII(*Pass.TII), TRI(*Pass.TRI),\n            RBI(*Pass.RBI) {}\n    ```", "```cpp\n\n      void setMBB(MachineBasicBlock *NewMBB) {\n        MBB = NewMBB;\n        I = MBB->end();\n      }\n    ```", "```cpp\n\n      void constrainInst(MachineInstr *MI) {\n        if (!constrainSelectedInstRegOperands(*MI, TII, TRI, RBI))\n          llvm_unreachable(\"Could not constrain register operands\");\n      }\n    ```", "```cpp\n\n      MachineInstr *bcnd(CC0 Cc, Register Reg, MachineBasicBlock *TargetMBB) {\n        MachineInstr *MI = BuildMI(*MBB, I, DL, TII.get(M88k::BCND))\n                               .addImm(static_cast<int64_t>(Cc))\n                               .addReg(Reg)\n                               .addMBB(TargetMBB);\n        constrainInst(MI);\n        return MI;\n      }\n    ```", "```cpp\n\n      MachineInstr *trap503(Register Reg) {\n        MachineInstr *MI = BuildMI(*MBB, I, DL, TII.get(M88k::TRAP503)).addReg(Reg);\n        constrainInst(MI);\n        return MI;\n      }\n    };\n    } // end anonymous namespace\n    ```", "```cpp\n\n    void M88kDivInstr::addZeroDivCheck(MachineBasicBlock &MBB,\n                                       MachineInstr *DivInst) {\n     assert(DivInst->getOpcode() == M88k::DIVSrr ||\n             DivInst->getOpcode() == M88k::DIVUrr && \"Unexpected          opcode\");\n      MachineBasicBlock *TailBB = MBB.splitAt(*DivInst);\n      M88kBuilder B(*this, &MBB, DivInst->getDebugLoc());\n      B.bcnd(CC0::NE0, DivInst->getOperand(2).getReg(), TailBB);\n      B.trap503(DivInst->getOperand(2).getReg());\n      ++InsertedChecks;\n    }\n    ```", "```cpp\n\n    bool M88kDivInstr::runOnMachineFunction(MachineFunction &MF) {\n      const M88kSubtarget &Subtarget =   MF.getSubtarget<M88kSubtarget>();\n      TII = Subtarget.getInstrInfo();\n      TRI = Subtarget.getRegisterInfo();\n      RBI = Subtarget.getRegBankInfo();\n      MRI = &MF.getRegInfo();\n      AddZeroDivCheck = !TM->noZeroDivCheck();\n      bool Changed = false;\n      for (MachineBasicBlock &MBB : reverse(MF))\n        Changed |= runOnMachineBasicBlock(MBB);\n      return Changed;\n    }\n    ```", "```cpp\n\n    bool M88kDivInstr::runOnMachineBasicBlock(MachineBasicBlock &MBB) {\n      bool Changed = false;\n      for (MachineBasicBlock::reverse_instr_iterator I =   MBB.instr_rbegin();\n           I != MBB.instr_rend(); ++I) {\n        unsigned Opc = I->getOpcode();\n        if ((Opc == M88k::DIVUrr || Opc == M88k::DIVSrr) &&     AddZeroDivCheck) {\n          addZeroDivCheck(MBB, &*I);\n          Changed = true;\n        }\n      }\n      return Changed;\n    }\n    ```", "```cpp\n\n    M88kDivInstr::M88kDivInstr(const M88kTargetMachine *TM)\n        : MachineFunctionPass(ID), TM(TM) {\n      initializeM88kDivInstrPass(*PassRegistry::getPassRegistry());\n    }\n    MachineFunctionProperties M88kDivInstr::getRequiredProperties() const {\n      return MachineFunctionProperties().set(\n          MachineFunctionProperties::Property::IsSSA);\n    }\n    ```", "```cpp\n\n    char M88kDivInstr::ID = 0;\n    INITIALIZE_PASS(M88kDivInstr, DEBUG_TYPE, \"Handle div instructions\", false, false)\n    ```", "```cpp\n\n    namespace llvm {\n    FunctionPass *createM88kDivInstr(const M88kTargetMachine &TM) {\n      return new M88kDivInstr(&TM);\n    }\n    } // end namespace llvm\n    ```", "```cpp\n\nadd_llvm_target(M88kCodeGen\n   M88kAsmPrinter.cpp\n   M88kDivInstr.cpp\n   M88kFrameLowering.cpp\n   M88kInstrInfo.cpp\n   M88kISelDAGToDAG.cpp\n```", "```cpp\n\n$ cmake -G Ninja ../llvm-project/llvm -DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=M88k -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS=\"llvm\"\n$ ninja\n```", "```cpp\n\n$ cat m88k-divzero.ll\ntarget datalayout = \"E-m:e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-a:8:16-n32\"\ntarget triple = \"m88k-unknown-openbsd\"\n@dividend = dso_local global i32 5, align 4\ndefine dso_local i32 @testDivZero() #0 {\n  %1 = load i32, ptr @dividend, align 4\n  %2 = sdiv i32 %1, 0\n  ret i32 %2\n}\n```", "```cpp\n\n$ llc m88k-divzero.ll\n```", "```cpp\n\n| %bb.1:\n     subu %r2, %r0, %r2\n     bcnd.n ne0, %r0, .LBB0_2\n     divu %r2, %r2, 0\n     tb0 0, %r3, 503\n. . .\n.LBB0_3:\n     bcnd.n ne0, %r0, .LBB0_4\n     divu %r2, %r2, 0\n     tb0 0, %r3, 503\n```", "```cpp\n\n$ llc m88k-divzero.ll –m88k-no-check-zero-division\n```", "```cpp\n\n| %bb.1:\n     subu %r2, %r0, %r2\n     divu %r2, %r2, 0\n     jmp.n %r1\n     subu %r2, %r0, %r2\n```", "```cpp\n\n    enum BuiltinVaListKind {\n    . . .\n        // typedef struct __va_list_tag {\n        //    int __va_arg;\n        //    int *__va_stk;\n        //    int *__va_reg;\n        //} va_list;\n        M88kBuiltinVaList\n      };\n    ```", "```cpp\n\n    #ifndef LLVM_CLANG_LIB_BASIC_TARGETS_M88K_H\n    #define LLVM_CLANG_LIB_BASIC_TARGETS_M88K_H\n    #include \"OSTargets.h\"\n    #include \"clang/Basic/TargetInfo.h\"\n    #include \"clang/Basic/TargetOptions.h\"\n    #include \"llvm/Support/Compiler.h\"\n    #include \"llvm/TargetParser/Triple.h\"\n    ```", "```cpp\n\n    namespace clang {\n    namespace targets {\n    ```", "```cpp\n\n    class LLVM_LIBRARY_VISIBILITY M88kTargetInfo: public TargetInfo {\n    ```", "```cpp\n\n      static const char *const GCCRegNames[];\n      enum CPUKind { CK_Unknown, CK_88000, CK_88100, CK_88110 } CPU = CK_Unknown;\n    ```", "```cpp\n\n    public:\n      M88kTargetInfo(const llvm::Triple &Triple, const TargetOptions &);\n      void getTargetDefines(const LangOptions &Opts,\n                            MacroBuilder &Builder) const override;\n      ArrayRef<Builtin::Info> getTargetBuiltins() const override;\n      ArrayRef<const char *> getGCCRegNames() const override;\n      ArrayRef<TargetInfo::GCCRegAlias> getGCCRegAliases() const override;\n      BuiltinVaListKind getBuiltinVaListKind() const override {\n        return TargetInfo::M88kBuiltinVaList;\n      }\n    ```", "```cpp\n\n      bool hasFeature(StringRef Feature) const override;\n      bool validateAsmConstraint(const char *&Name,\n                                 TargetInfo::ConstraintInfo &info)                              const override;\n      bool isValidCPUName(StringRef Name) const override;\n    ```", "```cpp\n\n      bool setCPU(const std::string &Name) override;\n      void fillValidCPUList(SmallVectorImpl<StringRef> &Values)   const override;\n    };\n    ```", "```cpp\n\n    } // namespace targets\n    } // namespace clang\n    #endif // LLVM_CLANG_LIB_BASIC_TARGETS_M88K_H\n    ```", "```cpp\n\n    #include \"M88k.h\"\n    #include \"clang/Basic/Builtins.h\"\n    #include \"clang/Basic/Diagnostic.h\"\n    #include \"clang/Basic/TargetBuiltins.h\"\n    #include \"llvm/ADT/StringExtras.h\"\n    #include \"llvm/ADT/StringRef.h\"\n    #include \"llvm/ADT/StringSwitch.h\"\n    #include \"llvm/TargetParser/TargetParser.h\"\n    #include <cstring>\n    ```", "```cpp\n\n    namespace clang {\n    namespace targets {\n    M88kTargetInfo::M88kTargetInfo(const llvm::Triple &Triple,\n                                   const TargetOptions &)\n        : TargetInfo(Triple) {\n    ```", "```cpp\n\n      std::string Layout = \"\";\n      Layout += \"E\"; // M68k is Big Endian\n      Layout += \"-m:e\";\n      Layout += \"-p:32:32:32\"; // Pointers are 32 bit.\n      // All scalar types are naturally aligned.\n      Layout += \"-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\";\n      // Floats and doubles are also naturally aligned.\n      Layout += \"-f32:32:32-f64:64:64\";\n      // We prefer 16 bits of aligned for all globals; see above.\n      Layout += \"-a:8:16\";\n      Layout += \"-n32\"; // Integer registers are 32bits.\n      resetDataLayout(Layout);\n    ```", "```cpp\n\n      IntMaxType = SignedLongLong;\n      Int64Type = SignedLongLong;\n      SizeType = UnsignedLong;\n      PtrDiffType = SignedInt;\n      IntPtrType = SignedInt;\n    }\n    ```", "```cpp\n\n    bool M88kTargetInfo::setCPU(const std::string &Name) {\n      StringRef N = Name;\n      CPU = llvm::StringSwitch<CPUKind>(N)\n                .Case(\"generic\", CK_88000)\n                .Case(\"mc88000\", CK_88000)\n                .Case(\"mc88100\", CK_88100)\n                .Case(\"mc88110\", CK_88110)\n                .Default(CK_Unknown);\n      return CPU != CK_Unknown;\n    }\n    ```", "```cpp\n\n    static constexpr llvm::StringLiteral ValidCPUNames[] = {\n        {\"generic\"}, {\"mc88000\"}, {\"mc88100\"}, {\"mc88110\"}};\n    void M88kTargetInfo::fillValidCPUList(\n        SmallVectorImpl<StringRef> &Values) const {\n      Values.append(std::begin(ValidCPUNames),   std::end(ValidCPUNames));\n    }\n    bool M88kTargetInfo::isValidCPUName(StringRef Name) const {\n      return llvm::is_contained(ValidCPUNames, Name);\n    }\n    ```", "```cpp\n\n    void M88kTargetInfo::getTargetDefines(const LangOptions &Opts,\n                                          MacroBuilder &Builder) const {\n      using llvm::Twine;\n      Builder.defineMacro(\"__m88k__\");\n      Builder.defineMacro(\"__m88k\");\n      switch (CPU) { // For sub-architecture\n      case CK_88000:\n        Builder.defineMacro(\"__mc88000__\");\n        break;\n      case CK_88100:\n        Builder.defineMacro(\"__mc88100__\");\n        break;\n      case CK_88110:\n        Builder.defineMacro(\"__mc88110__\");\n        break;\n      default:\n        break;\n      }\n    }\n    ```", "```cpp\n\n    ArrayRef<Builtin::Info> M88kTargetInfo::getTargetBuiltins() const {\n      return std::nullopt;\n    }\n    bool M88kTargetInfo::hasFeature(StringRef Feature) const {\n      return Feature == \"M88000\";\n    }\n    ```", "```cpp\n\n    const char *const M88kTargetInfo::GCCRegNames[] = {\n        \"r0\",  \"r1\",  \"r2\",  \"r3\",  \"r4\",  \"r5\",  \"r6\",  \"r7\",  \n        \"r8\",  \"r9\",  \"r10\",  \"r11\", \"r12\", \"r13\", \"r14\", \"r15\", \n        \"r16\", \"r17\", \"r18\",  \"r19\", \"r20\", \"r21\",  \"r22\", \"r23\", \n        \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\",  \"r39\", \"r31\"};\n    ArrayRef<const char *> M88kTargetInfo::getGCCRegNames() const {\n      return llvm::makeArrayRef(GCCRegNames);\n    }\n    ArrayRef<TargetInfo::GCCRegAlias> M88kTargetInfo::getGCCRegAliases() const {\n      return std::nullopt; // No aliases.\n    }\n    ```", "```cpp\n\n    bool M88kTargetInfo::validateAsmConstraint(\n        const char *&Name, TargetInfo::ConstraintInfo &info) const {\n      switch (*Name) {\n      case 'a': // address register\n      case 'd': // data register\n      case 'f': // floating point register\n        info.setAllowsRegister();\n        return true;\n      case 'K': // the constant 1\n      case 'L': // constant -1^20 .. 1^19\n      case 'M': // constant 1-4:\n        return true;\n      }\n      return false;\n    }\n    ```", "```cpp\n\n    } // namespace targets\n    } // namespace clang\n    ```", "```cpp\n\n    def m_m88k_Features_Group: OptionGroup<\"<m88k features group>\">,\n                               Group<m_Group>, DocName<\"M88k\">;\n    ```", "```cpp\n\n    def m88000 : Flag<[\"-\"], \"m88000\">, Group<m_m88k_Features_Group>;\n    def m88100 : Flag<[\"-\"], \"m88100\">, Group<m_m88k_Features_Group>;\n    def m88110 : Flag<[\"-\"], \"m88110\">, Group<m_m88k_Features_Group>;\n    ```", "```cpp\n\n    std::unique_ptr<TargetCodeGenInfo> createM88kTargetCodeGenInfo(CodeGenModule &CGM);\n    ```", "```cpp\n\n     #include \"Targets/M88k.h\"\n     #include \"Targets/MSP430.h\"\n    . . .\n       case llvm::Triple::m88k:\n         switch (os) {\n         case llvm::Triple::OpenBSD:\n           return std::make_unique<OpenBSDTargetInfo<M88kTargetInfo>>(Triple, Opts);\n         default:\n           return std::make_unique<M88kTargetInfo>(Triple, Opts);\n         }\n       case llvm::Triple::le32:\n    . . .\n    ```", "```cpp\n\n    #include \"ABIInfoImpl.h\"\n    #include \"TargetInfo.h\"\n    using namespace clang;\n    using namespace clang::CodeGen;\n    ```", "```cpp\n\n    namespace {\n    class M88kABIInfo final : public ABIInfo {\n      DefaultABIInfo defaultInfo;\n    ```", "```cpp\n\n    public:\n      explicit M88kABIInfo(CodeGen::CodeGenTypes &CGT)\n          : ABIInfo(CGT), defaultInfo(CGT) {}\n      void computeInfo(CodeGen::CGFunctionInfo &FI) const override {}\n      CodeGen::Address EmitVAArg(CodeGen::CodeGenFunction &CGF,\n                                 CodeGen::Address VAListAddr,\n                                 QualType Ty) const override {\n        return VAListAddr;\n      }\n    };\n    ```", "```cpp\n\n    class M88kTargetCodeGenInfo final : public TargetCodeGenInfo {\n    public:\n      explicit M88kTargetCodeGenInfo(CodeGen::CodeGenTypes &CGT)\n          : TargetCodeGenInfo(std::make_unique<DefaultABIInfo>(CGT)) {} };\n    }\n    ```", "```cpp\n\n    std::unique_ptr<TargetCodeGenInfo>\n    CodeGen::createM88kTargetCodeGenInfo(CodeGenModule &CGM) {\n      return std::make_unique<M88kTargetCodeGenInfo>(CGM.getTypes());\n    }\n    ```", "```cpp\n\n    #ifndef LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_ARCH_M88K_H\n    #define LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_ARCH_M88K_H\n    #include \"clang/Driver/Driver.h\"\n    #include \"llvm/ADT/StringRef.h\"\n    #include \"llvm/Option/Option.h\"\n    #include <string>\n    #include <vector>\n    namespace clang {\n    namespace driver {\n    namespace tools {\n    namespace m88k {\n    ```", "```cpp\n\n    enum class FloatABI { Invalid, Soft, Hard, };\n    ```", "```cpp\n\n    FloatABI getM88kFloatABI(const Driver &D, const llvm::opt::ArgList &Args);\n    StringRef getM88kTargetCPU(const llvm::opt::ArgList &Args);\n    StringRef getM88kTuneCPU(const llvm::opt::ArgList &Args);\n    void getM88kTargetFeatures(const Driver &D, const llvm::Triple &Triple, const llvm::opt::ArgList &Args, std::vector<llvm::StringRef> &Features);\n    ```", "```cpp\n\n    } // end namespace m88k\n    } // end namespace tools\n    } // end namespace driver\n    } // end namespace clang\n    #endif // LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_ARCH_M88K_H\n    ```", "```cpp\n\n    #include \"M88k.h\"\n    #include \"ToolChains/CommonArgs.h\"\n    #include \"clang/Driver/Driver.h\"\n    #include \"clang/Driver/DriverDiagnostic.h\"\n    #include \"clang/Driver/Options.h\"\n    #include \"llvm/ADT/SmallVector.h\"\n    #include \"llvm/ADT/StringSwitch.h\"\n    #include \"llvm/Option/ArgList.h\"\n    #include \"llvm/Support/Host.h\"\n    #include \"llvm/Support/Regex.h\"\n    #include <sstream>\n    using namespace clang::driver;\n    using namespace clang::driver::tools;\n    using namespace clang;\n    using namespace llvm::opt;\n    ```", "```cpp\n\n    static StringRef normalizeCPU(StringRef CPUName) {\n      if (CPUName == \"native\") {\n        StringRef CPU = std::string(llvm::sys::getHostCPUName());\n        if (!CPU.empty() && CPU != \"generic\")\n          return CPU;\n      }\n      return llvm::StringSwitch<StringRef>(CPUName)\n          .Cases(\"mc88000\", \"m88000\", \"88000\", \"generic\", \"mc88000\")\n          .Cases(\"mc88100\", \"m88100\", \"88100\", \"mc88100\")\n          .Cases(\"mc88110\", \"m88110\", \"88110\", \"mc88110\")\n          .Default(CPUName);\n    }\n    ```", "```cpp\n\n    StringRef m88k::getM88kTargetCPU(const ArgList &Args) {\n      Arg *A = Args.getLastArg(options::OPT_m88000, options::OPT_m88100, options::OPT_m88110, options::OPT_mcpu_EQ);\n      if (!A)\n        return StringRef();\n      switch (A->getOption().getID()) {\n      case options::OPT_m88000:\n        return \"mc88000\";\n      case options::OPT_m88100:\n        return \"mc88100\";\n      case options::OPT_m88110:\n        return \"mc88110\";\n      case options::OPT_mcpu_EQ:\n        return normalizeCPU(A->getValue());\n      default:\n        llvm_unreachable(\"Impossible option ID\");\n      }\n    }\n    ```", "```cpp\n\n    StringRef m88k::getM88kTuneCPU(const ArgList &Args) {\n      if (const Arg *A = Args.getLastArg(options::OPT_mtune_EQ))\n        return normalizeCPU(A->getValue());\n      return StringRef();\n    }\n    ```", "```cpp\n\n    m88k::FloatABI m88k::getM88kFloatABI(const Driver &D, const ArgList &Args) {\n      m88k::FloatABI ABI = m88k::FloatABI::Invalid;\n      if (Arg *A =\n              Args.getLastArg(options::OPT_msoft_float, options::OPT_mhard_float)) {\n        if (A->getOption().matches(options::OPT_msoft_float))\n          ABI = m88k::FloatABI::Soft;\n        else if (A->getOption().matches(options::OPT_mhard_float))\n          ABI = m88k::FloatABI::Hard;\n      }\n      if (ABI == m88k::FloatABI::Invalid)\n        ABI = m88k::FloatABI::Hard;\n      return ABI;\n    }\n    ```", "```cpp\n\n    void m88k::getM88kTargetFeatures(const Driver &D, const llvm::Triple &Triple,\n                                     const ArgList &Args,\n                                     std::vector<StringRef> &Features) {\n      m88k::FloatABI FloatABI = m88k::getM88kFloatABI(D, Args);\n      if (FloatABI == m88k::FloatABI::Soft)\n        Features.push_back(\"-hard-float\");\n    }\n    ```", "```cpp\n\n$ cmake -G Ninja ../llvm-project/llvm -DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=M88k -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS=\"clang;llvm\"\n$ ninja\n```", "```cpp\n\n$ clang --print-targets | grep M88k\n    m88k        - M88k\n```", "```cpp\n\n$ sudo apt –y install gcc-12-aarch64-linux-gnu \\\n  g++-12-aarch64-linux-gnu binutils-aarch64-linux-gnu \\\n  libstdc++-12-dev-arm64-cross\n```", "```cpp\n\n$ mkdir build-host\n$ cd build-host\n$ cmake -G Ninja \\\n  -DLLVM_TARGETS_TO_BUILD=\"X86\" \\\n  -DLLVM_ENABLE_ASSERTIONS=ON \\\n  -DCMAKE_BUILD_TYPE=Release \\\n  ../llvm-project/llvm\n$ ninja llvm-tblgen\n$ cd ..\n```", "```cpp\n\n$ mkdir build-target\n$ cd build-target\n$ cmake -G Ninja \\\n  -DCMAKE_CROSSCOMPILING=True \\\n  -DLLVM_TABLEGEN=../build-host/bin/llvm-tblgen \\\n  -DLLVM_DEFAULT_TARGET_TRIPLE=aarch64-linux-gnu \\\n  -DLLVM_TARGET_ARCH=AArch64 \\\n  -DLLVM_TARGETS_TO_BUILD=AArch64 \\\n  -DLLVM_ENABLE_ASSERTIONS=ON \\\n  -DLLVM_EXTERNAL_PROJECTS=tinylang \\\n  -DLLVM_EXTERNAL_TINYLANG_SOURCE_DIR=../tinylang \\\n  -DCMAKE_INSTALL_PREFIX=../target-tinylang \\\n  -DCMAKE_BUILD_TYPE=Release \\\n  -DCMAKE_C_COMPILER=aarch64-linux-gnu-gcc-12 \\\n  -DCMAKE_CXX_COMPILER=aarch64-linux-gnu-g++-12 \\\n  ../llvm-project/llvm\n$ ninja\n```"]