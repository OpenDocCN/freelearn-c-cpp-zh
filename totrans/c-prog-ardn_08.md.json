["```cpp\n// Pin 8 is the one connected to our pretty LED\nint ledPin = 8;                // ledPin is an integer variable initialized at 8\n\nvoid setup() {                \n  pinMode(ledPin, OUTPUT);     // initialize the digital pin as an output\n}\n\n// --------- the loop routine runs forever\nvoid loop() {\n  digitalWrite(ledPin, HIGH);   // turn the LED on\n  delay(250);                   // wait for 250ms in the current state\n  digitalWrite(ledPin, LOW);    // turn the LED off\n  delay(1000);                  // wait for 1s in the current state\n}\n```", "```cpp\n#include <Bounce.h>   // include the (magic) Bounce library\n\n#define BUTTON01 2    // pin of the button #1\n#define BUTTON02 3    // pin of the button #2\n\n#define LED01 8       // pin of the button #1\n#define LED02 9       // pin of the button #2\n\n// let's instantiate the 2 debouncers with a debounce time of 7 ms\nBounce bouncer_button01 = Bounce (BUTTON01, 7);\nBounce bouncer_button02 = Bounce (BUTTON02, 7);\n\nvoid setup() {\n\n  pinMode(BUTTON01, INPUT); // the switch pin 2 is setup as an input\n  pinMode(BUTTON02, INPUT); // the switch pin 3 is setup as an input\n\n  pinMode(LED01, OUTPUT);   // the switch pin 8 is setup as an output\n  pinMode(LED02, OUTPUT);   // the switch pin 9 is setup as an output\n}\n\nvoid loop(){\n\n  // let's update the two debouncers\n  bouncer_button01.update();\n  bouncer_button02.update();\n\n  // let's read each button state, debounced!\n  int button01_state = bouncer_button01.read();\n  int button02_state = bouncer_button02.read();\n\n  // let's test each button state and switch leds on or off\n  if ( button01_state == HIGH ) digitalWrite(LED01, HIGH);\n  else digitalWrite(LED01, LOW);\n\n  if ( button02_state == HIGH ) digitalWrite(LED02, HIGH);\n  else digitalWrite(LED02, LOW);\n}\n```", "```cpp\nBounce bouncer_button01 = Bounce (BUTTON01, 7);\nBounce bouncer_button02 = Bounce (BUTTON02, 7);\n```", "```cpp\n// 595 clock pin connecting to pin 4\nint CLOCK_595 = 4;\n\n// 595 latch pin connecting to pin 3\nint LATCH_595 = 3;\n\n// 595 serial data input pin connecting to pin 2\nint DATA_595 = 2;\n\n// random groove machine variables\nint counter = 0;\nbyte LED_states = B00000000 ;\n\nvoid setup() {\n\n  // Let's set all serial related pins as outputs\n  pinMode(LATCH_595, OUTPUT);\n  pinMode(CLOCK_595, OUTPUT);\n  pinMode(DATA_595, OUTPUT);\n\n  // use a seed coming from the electronic noise of the ADC \n  randomSeed(analogRead(0));\n}\n\nvoid loop(){\n\n  // generate a random byte\n  for (int i = 0 ; i < 8 ; i++)\n  {\n    bitWrite(LED_states, i, random(2));\n  }\n\n  // Put latch pin to LOW (ground) while transmitting data to 595\n  digitalWrite(LATCH_595, LOW);\n\n  // Shifting Out bits i.e. using the random byte for LEDs states\n  shiftOut(DATA_595, CLOCK_595, MSBFIRST, LED_states);\n\n  // Put latch pin to HIGH (5V) & all data are pushed to outputs\n  digitalWrite(LATCH_595, HIGH);\n\n  // each 5000 loop() execution, grab a new seed for the random function\n  if (counter < 5000) counter++;\n  else \n  {\n    randomSeed(analogRead(0));    // read a new value from analog pin 0\n    counter = 0;                  // reset the counter\n  }\n\n  // make a short pause before changing LEDs states\n  delay(45);\n}\n```", "```cpp\ndigitalWrite(latch-pin, LOW)\nshiftOut(data-pin, clock-pin, MSBFIRST, my_states)\ndigitalWrite(latch-pin, HIGH)\n```", "```cpp\n#include <ShiftOutX.h>\n#include <ShiftPinNo.h>\n\nint CLOCK_595 = 4;    // first 595 clock pin connecting to pin 4\nint LATCH_595 = 3;    // first 595 latch pin connecting to pin 3\nint DATA_595 = 2;     // first 595 serial data input pin connecting to pin 2\n\nint SR_Number = 2;    // number of shift registers in the chain\n\n// instantiate and enabling the shiftOutX library with our circuit parameters\nshiftOutX regGroupOne(LATCH_595, DATA_595, CLOCK_595, MSBFIRST, SR_Number);\n\n// random groove machine variables\nint counter = 0;\nbyte LED0to7_states = B00000000 ;\nbyte LED8to15_states = B00000000 ;\n\nvoid setup() {\n\n  // NO MORE setup for each digital pin of the Arduino\n  // EVERYTHING is made by the library :-)\n\n  // use a seed coming from the electronic noise of the ADC \n  randomSeed(analogRead(0));\n}\n\nvoid loop(){ \n\n  // generate a 2 random bytes\n  for (int i = 0 ; i < 8 ; i++)\n  {\n    bitWrite(LED0to7_states, i, random(2));\n    bitWrite(LED8to15_states, i, random(2));\n  }\n\n  unsigned long int data; // declaring the data container as a very local variable\n  data = LED0to7_states | (LED8to15_states << 8); // aggregating the 2 random bytes\n  shiftOut_16(DATA_595, CLOCK_595, MSBFIRST, data);  // pushing the whole data to SRs\n\n  // each 5000 loop() execution, grab a new seed for the random function\n  if (counter < 5000) counter++;\n  else \n  {\n    randomSeed(analogRead(0));    // read a new value from analog pin 0\n    counter = 0;                  // reset the counter\n  }\n\n  // make a short pause before changing LEDs states\n  delay(45);\n}\n```", "```cpp\nshiftOutX regGroupOne(LATCH_595, DATA_595, CLOCK_595, MSBFIRST, SR_Number);\n```", "```cpp\n0 1 1 1 0 1 0 0\n1 1 0 1 0 0 0 1\n```", "```cpp\n0 1 1 1 0 1 0 0 << 8 = 0 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0\n```", "```cpp\n0 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0\n       |                             1 1 0 1 0 0 0 1\n       =    0 1 1 1 0 1 0 0 1 1 0 1 0 0 0 1\n```", "```cpp\nint pinR = 4; // pin related to Red of RGB LED\nint pinG = 3; // pin related to Green of RGB LED\nint pinB = 2; // pin related to Blue of RGB LED\n\nvoid setup() {\n\n  pinMode(pinR, OUTPUT);\n  pinMode(pinG, OUTPUT);\n  pinMode(pinB, OUTPUT);\n}\n\nvoid loop() {\n\n  for (int r = 0 ; r < 2 ; r++)\n  {\n    for (int g = 0 ; g < 2 ; g++)\n    {\n      for (int b = 0 ; b < 2 ; b++)\n      {\n        digitalWrite(pinR,r); // turning red pin to value r\n        digitalWrite(pinG,g); // turning green pin to value g\n        digitalWrite(pinB,b); // turning blue pin to value b\n\n        delay(150); // pausing a bit\n      }\n    }\n  }\n\n}\n```", "```cpp\n#define HIGH 0x1\n#define LOW  0x0\n```", "```cpp\nFor each column\n\tSwitch On the column\n\t\tFor each row\n\t\t\tSwitch on the row if the corresponding LED has to be switched On\n\n```", "```cpp\nint CLOCK_595 = 4;    // first 595 clock pin connecting to pin 4\nint LATCH_595 = 3;    // first 595 latch pin connecting to pin 3\nint DATA_595 = 2;     // first 595 serial data pin connecting to pin 2\n\n// random groove machine variables\nint counter = 0;\nboolean LED_states[9] ;\n\nvoid setup() {\n\n  pinMode(LATCH_595, OUTPUT);\n  pinMode(CLOCK_595, OUTPUT);\n  pinMode(DATA_595, OUTPUT);\n\n  // use a seed coming from the electronic noise of the ADC \n  randomSeed(analogRead(0));\n}\n\nvoid loop() {\n\n  // generate random state for each 9 LEDs\n  for (int i = 0 ; i < 9 ; i++)\n  {\n    LED_states[i] = random(2) ;\n  }\n\n  // initialize data at each loop()\n  byte data = 0;\n  byte dataRow = 0;\n  byte dataColumn = 0;\n  int currentLed = 0;\n\n  // cycling columns\n  for (int c = 0 ; c < 3 ; c++)\n  {\n    // write the 1 at the correct bit place (= current column)\n    dataColumn = 1 << (4 - c); \n\n    // cycling rows\n    for (int r = 0 ; r < 3 ; r++)\n    {\n      // IF that LED has to be up, according to LED_states array\n      // write the 1 at the correct bit place (= current row)\n      if (LED_states[currentLed]) dataRow = 1 << (4 - c);\n\n      // sum the two half-bytes results in the data to be sent\n      data = dataRow | dataColumn;\n\n      // Put latch pin to LOW (ground) while transmitting data to 595\n      digitalWrite(LATCH_595, LOW);\n\n      // Shifting Out bits \n      shiftOut(DATA_595, CLOCK_595, MSBFIRST, data);\n\n      // Put latch pin to HIGH (5V) & all data are pushed to outputs\n      digitalWrite(LATCH_595, HIGH);\n\n      dataRow = 0; // resetting row bits for next turn\n      currentLed++;// incrementing to next LED to process\n    }\n\n    dataColumn = 0;// resetting column bits for next turn\n  }\n\n  // each 5000 loop() execution, grab a new seed for the random function\n  if (counter < 5000) counter++;\n  else \n  {\n    randomSeed(analogRead(0));    // read a new value from analog pin 0\n    counter = 0;                  // reset the counter\n  }\n\n  // pause a bit to provide a cuter fx\n  delay(150);\n}\n```", "```cpp\ndataColumn = 1 << (4 â€“ c);\n```", "```cpp\nint ledPin = 11;    // LED connected to digital pin 11 (!!)\n\nvoid setup()  { \n  // nothing happens in setup \n} \n\nvoid loop()  { \n  // fade in from min to max in increments of 5 points:\n  for(int fadeValue = 0 ; fadeValue <= 255; fadeValue +=5) { \n    // sets the value (range from 0 to 255):\n    analogWrite(ledPin, fadeValue);         \n    // wait for 30 milliseconds to see the dimming effect    \n    delay(30);                            \n  } \n\n  // fade out from max to min in increments of 5 points:\n  for(int fadeValue = 255 ; fadeValue >= 0; fadeValue -=5) { \n    // sets the value (range from 0 to 255):\n    analogWrite(ledPin, fadeValue);         \n    // wait for 30 milliseconds to see the dimming effect    \n    delay(30);                            \n  } \n}\n```", "```cpp\n#include <LiquidCrystal.h>\n\nString manyMessages[4];\nint counter = 0;\n\n// Initialize the library with pins number of the circuit\n// 4-bit mode here without RW\nLiquidCrystal lcd(12, 11, 5, 4, 3, 2);\n\nvoid setup() {\n\n  // set up the number of column and row of the LCD\n  lcd.begin(16, 2);\n\n  manyMessages[0] = \"I am the Arduino\";\n  manyMessages[1] = \"I can talk\";\n  manyMessages[2] = \"I can feel\";\n  manyMessages[3] = \"I can react\";\n\n  // shaking the dice!\n  randomSeed(analogRead(0);\n}\n\nvoid loop() {\n\n  // set the cursor to column 0 and row 0\n  lcd.setCursor(0, 0);\n\n  // each 5s\n  if (millis() - counter > 5000)\n  {\n    lcd.clear(); // clear the whole LCD\n    lcd.print(manyMessages[random(4)]); // display a random message\n    counter = millis();  // store the current time\n  }\n\n  // set the cursor to column 0 and row 1\n  lcd.setCursor(0, 1);\n  // print the value of millis() at each loop() execution\n  lcd.print(\"up since: \" + millis() + \"ms\");\n}\n```"]