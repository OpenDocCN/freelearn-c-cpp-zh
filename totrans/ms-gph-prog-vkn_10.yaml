- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Adding Volumetric Fog
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加体积雾
- en: 'After adding variable rate shading in the previous chapter, we will implement
    another modern technique that will enhance the visuals of the Raptor Engine: **Volumetric
    Fog**. Volumetric rendering and fog are very old topics in rendering literature,
    but until a few years ago, they were considered impossible for real-time usage.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章添加了可变率着色后，我们将实现另一种现代技术，这将增强Raptor引擎的视觉效果：**体积雾**。体积渲染和雾在渲染文献中是非常古老的话题，但直到几年前，它们还被认为不适合实时使用。
- en: The possibility of making this technique feasible in real-time stems from the
    observation that fog is a low-frequency effect; thus the rendering can be at a
    much lower resolution than the screen, increasing the performance in real-time
    usage.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使这一技术在实时中可行的是观察到的雾是一个低频效应；因此渲染可以比屏幕分辨率低得多，从而提高实时使用中的性能。
- en: Also, the introduction of compute shaders, and thus generic GPU programming,
    paired with clever observations about approximations and optimizations of the
    volumetric aspect of the technique, paved the way to unlocking real-time Volumetric
    Fog.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，计算着色器的引入，以及因此通用的GPU编程，加上对技术体积方面的近似和优化巧妙观察，为实时体积雾的解锁铺平了道路。
- en: The main idea comes from the seminal paper by Bart Wronski ([https://bartwronski.files.wordpress.com/2014/08/bwronski_volumetric_fog_siggraph2014.pdf](https://bartwronski.files.wordpress.com/2014/08/bwronski_volumetric_fog_siggraph2014.pdf))
    at Siggraph 2014, where he described what is still the core idea behind this technique
    even after almost 10 years.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 主要思想来源于巴特·沃罗尼斯基在2014年Siggraph会议上发表的奠基性论文([https://bartwronski.files.wordpress.com/2014/08/bwronski_volumetric_fog_siggraph2014.pdf](https://bartwronski.files.wordpress.com/2014/08/bwronski_volumetric_fog_siggraph2014.pdf))，他在那里描述了即使在几乎10年后，这一技术的核心思想仍然如此。
- en: 'Implementing this technique will also be important for learning more about
    the synergies between different rendering parts of a frame: developing a single
    technique can be challenging, but the interaction with the rest of the technology
    is a very important part as well and can add to the challenge of the technique'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一技术对于了解帧的不同渲染部分之间的协同作用也很重要：开发单一技术可能具有挑战性，但与其他技术的交互同样重要，并且可以增加技术的挑战性
- en: 'In this chapter, we’ll cover the following main topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Introducing Volumetric Fog rendering
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍体积雾渲染
- en: Implementing the Volumetric Fog base technique
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现体积雾基础技术
- en: Adding spatial and temporal filtering to improve visuals
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加空间和时间滤波以改善视觉效果
- en: 'By the end of this chapter, we will have Volumetric Fog integrated into the
    Raptor Engine, interacting with the scenery and all the dynamic lights, as shown
    in the following figure:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将把体积雾集成到Raptor引擎中，与场景和所有动态灯光交互，如下图所示：
- en: '![Figure 10.1 – Volumetric Fog with a density volume and three shadow casting
    lights](img/B18395_10_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 带有密度体积和三个投射阴影的光的体积雾](img/B18395_10_01.jpg)'
- en: Figure 10.1 – Volumetric Fog with a density volume and three shadow casting
    lights
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 带有密度体积和三个投射阴影的光的体积雾
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter can be found at the following URL: [https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter10](https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter10).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下URL找到：[https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter10](https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter10)。
- en: Introducing Volumetric Fog Rendering
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍体积雾渲染
- en: What exactly is **Volumetric Fog Rendering**? As the name suggests, it is the
    combination of Volumetric Rendering and the fog phenomena. We will now give some
    background on those components and see how they are combined in the final technique.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，**体积雾渲染**究竟是什么？正如其名所示，它是体积渲染和雾现象的结合。现在我们将对这些组件进行一些背景介绍，并看看它们如何在最终技术中结合在一起。
- en: Let’s begin with Volumetric Rendering.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从体积渲染开始。
- en: Volumetric Rendering
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 体积渲染
- en: This rendering technique describes the visuals associated with what happens
    to light when it travels through a participating medium. A participating medium
    is a volume that contains local changes to density or albedo.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这种渲染技术描述了当光线穿过参与介质时发生的视觉效果。参与介质是一个包含密度或反照率局部变化的体积。
- en: 'The following diagram summarizes what happens to photons in a participating
    medium:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表总结了在参与介质中光子发生的情况：
- en: '![Figure 10.2 – Light behavior in a participating medium](img/B18395_10_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 参与介质中的光行为](img/B18395_10_02.jpg)'
- en: Figure 10.2 – Light behavior in a participating medium
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 参与介质中的光行为
- en: What we are trying to describe is how light changes when going through a participating
    medium, namely a fog volume (or clouds or atmospheric scattering).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们试图描述的是光通过参与介质（即雾体积、云或大气散射）时的变化。
- en: 'There are three main phenomena that happen, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种主要现象发生，如下所述：
- en: '**Absorption**: This happens when light is simply trapped inside the medium
    and does not go outside. It is a net loss of energy.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**吸收**：这发生在光线简单地被困在介质内部，无法逸出。这是一个能量的净损失。'
- en: '**Out-scattering**: This is depicted using green arrows in *Figure 10**.2*
    and is again a loss of energy coming out (and thus visible) from the medium.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外散射**：这在图10.2中用绿色箭头表示，并且是能量从介质中逸出（因此可见）的损失。'
- en: '**In-scattering**: This is the energy coming from the lights that are interacting
    with the medium.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内散射**：这是来自与介质相互作用的灯光的能量。'
- en: While these three phenomena are enough to describe what happens to light, there
    are three other components that need to be understood before having a complete
    picture of volumetric rendering.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这三个现象足以描述光的行为，但在完全理解体渲染之前，还需要了解三个其他组成部分。
- en: Phase function
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相位函数
- en: The first component is the **phase function**. This function describes the scattering
    of light in different directions. It is dependent on the angle between the light
    vector and the outgoing directions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个组成部分是**相位函数**。这个函数描述了光在不同方向上的散射。它依赖于光向量与出射方向之间的角度。
- en: This function can be complex and tries to describe scattering in a realistic
    way, but the most commonly used is the Henyey-Greenstein function, a function
    that also takes into consideration anisotropy.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可能很复杂，试图以现实的方式描述散射，但最常用的是亨尼海-格林斯坦函数，这是一个也考虑各向异性的函数。
- en: 'The formula for the Henyey-Greenstein function is as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 亨尼海-格林斯坦函数的公式如下：
- en: '![Figure 10.3 – The Henyey-Greenstein function](img/B18395_10_03.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 亨尼海-格林斯坦函数](img/B18395_10_03.jpg)'
- en: Figure 10.3 – The Henyey-Greenstein function
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 亨尼海-格林斯坦函数
- en: In the preceding equation, the angle theta is the angle between the view vector
    and the light vector. We will see in the shader code how to translate this to
    something usable.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方程中，角度theta是视向量与光向量之间的角度。我们将在着色器代码中看到如何将其转换为可用的东西。
- en: Extinction
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 灭减
- en: The second component is **extinction**. Extinction is a quantity that describes
    how much light is scattered. We will use this in the intermediate steps of the
    algorithm, but to apply the calculated fog, we will need transmittance.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个组成部分是**灭减**。灭减是描述光散射程度的量。我们将在算法的中间步骤中使用它，但为了应用计算出的雾，我们需要透射率。
- en: Transmittance
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 透射率
- en: 'The third and final component is **transmittance**. Transmittance is the extinction
    of light through a segment of the medium, and it is calculated using the Beer-Lambert
    law:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个也是最后一个组成部分是**透射率**。透射率是光通过介质一段的灭减，它使用比尔-朗伯定律来计算：
- en: '![Figure 10.4 – The Beer-Lambert law](img/B18395_10_04.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 比尔-朗伯定律](img/B18395_10_04.jpg)'
- en: Figure 10.4 – The Beer-Lambert law
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 比尔-朗伯定律
- en: In the final integration step, we will calculate the transmittance and use it
    to choose how to apply fog to the scene. The important thing here is to get a
    basic grasp of the concepts; there will be links provided to deepen your understanding
    of the mathematical background at the end of the chapter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终的积分步骤中，我们将计算透射率并使用它来选择如何将雾应用到场景中。这里重要的是要掌握基本概念；章节末尾将提供链接以加深对数学背景的理解。
- en: We now have all the concepts needed to see the implementation details of Volumetric
    Fog.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有了查看体雾实现细节所需的所有概念。
- en: Volumetric Fog
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 体雾
- en: 'Now that we have an idea of the different components that contribute to Volumetric
    Rendering, we can take a bird’s-eye view of the algorithm. One of the first and
    most clever ideas that Bart Wronski had while developing this technique is the
    usage of a Frustum Aligned Volume Texture, like so:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了贡献于体渲染的不同组成部分，我们可以从算法的角度进行鸟瞰。巴特·沃罗尼斯基在开发这项技术时，第一个也是最巧妙的想法之一是使用一个截锥体对齐的体积纹理，如下所示：
- en: '![Figure 10.5 – Frustum Aligned Volume Texture](img/B18395_10_05.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – 视锥对齐体积纹理](img/B18395_10_05.jpg)'
- en: Figure 10.5 – Frustum Aligned Volume Texture
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – 视锥对齐体积纹理
- en: Using a volume texture and math associated with standard rasterization rendering,
    we can create a mapping between the camera frustum and the texture. This mapping
    is already happening in the different stages of rendering, for example, when multiplying
    a vertex position for the view-projection matrix, so it is not something new.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用体积纹理和与标准光栅化渲染相关的数学，我们可以创建相机视锥和纹理之间的映射。这种映射已经在渲染的不同阶段发生，例如，在乘以视图投影矩阵的顶点位置时，所以这不是什么新东西。
- en: What is new is storing information in a volume texture to calculate the volumetric
    rendering. Each element of this texture is commonly called the **froxel**, that
    stands for **frustum voxel**.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 新的是在体积纹理中存储信息以计算体积渲染。这个纹理的每个元素通常被称为**froxel**，代表**视锥体素**。
- en: We chose to have a texture with a width, height, and depth of 128 units, but
    other solutions use a width and height dependent on the screen resolution, similar
    to clustered shading.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择了一个宽度、高度和深度为128个单位的纹理，但其他解决方案使用宽度高度取决于屏幕分辨率，类似于聚簇着色。
- en: We will use different textures with this resolution as an intermediate step,
    and for additional filtering, we will discuss this later. One additional decision
    is to increase the resolution of the camera by using a non-linear depth distribution
    to map a linear range to an exponential one.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用具有这种分辨率的纹理作为中间步骤，并且对于额外的滤波，我们将在稍后讨论。一个额外的决定是使用非线性深度分布来增加相机的分辨率，将线性范围映射到指数范围。
- en: 'We will use a distribution function, such as the one used by Id in their iD
    Tech engine, like so:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个分布函数，例如Id在他们的iD Tech引擎中使用的函数，如下所示：
- en: '![Figure 10.6 – Volume texture depth slice on the Z coordinate function](img/B18395_10_06.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – 体积纹理在Z坐标函数上的深度切片](img/B18395_10_06.jpg)'
- en: Figure 10.6 – Volume texture depth slice on the Z coordinate function
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – 体积纹理在Z坐标函数上的深度切片
- en: Now that we have decided on the mapping between the volumetric texture and world
    units, we can describe the steps needed to have a fully working Volumetric Fog
    solution.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经决定了体积纹理和世界单位之间的映射，我们可以描述实现完整工作体积雾解决方案所需的步骤。
- en: 'The algorithm is outlined in the following diagram, where rectangles represent
    shader executions while ellipses represent textures:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 算法在以下图中概述，其中矩形代表着色器执行，而椭圆代表纹理：
- en: '![Figure 10.7 – Algorithm overview](img/B18395_10_07.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7 – 算法概述](img/B18395_10_07.jpg)'
- en: Figure 10.7 – Algorithm overview
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 算法概述
- en: We will now see each step of the algorithm to create a mind model of what is
    happening, and we will review the shader later in the chapter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将逐步查看算法的每个步骤，以创建一个心理模型来了解正在发生的事情，我们将在本章后面回顾着色器。
- en: Data injection
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据注入
- en: The first step is the data injection. This shader will add some colored fog
    in the form of color and density into the first Frustum Aligned Texture containing
    only data. We decided to add a constant fog, a height-based fog, and a fog volume
    to mimic a more realistic game development setup.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是数据注入。这个着色器将把一些以颜色和密度形式存在的彩色雾添加到只包含数据的第一个视锥对齐纹理中。我们决定添加一个常量雾、一个基于高度的雾和一个雾体积，以模拟更真实的游戏开发设置。
- en: Light scattering
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 光散射
- en: When performing the light scattering, we calculate the in-scattering coming
    from the lights in the scene.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行光散射时，我们计算场景中灯光的入射散射。
- en: Having a working Clustered Lighting algorithm, we will reuse the same data structures
    to calculate the light contribution for each froxel, paying attention to treating
    the light in a different way than the standard Clustered Lighting – we don’t have
    diffuse or specular here, but just a global term given by attenuation, shadow,
    and phase.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在拥有一个工作的聚簇光照算法后，我们将重用相同的数据结构来计算每个froxel的光贡献，注意以不同于标准聚簇光照的方式处理光 – 这里没有漫反射或镜面反射，而只是一个由衰减、阴影和相位给出的全局项。
- en: We also sample shadow maps associated with the lights for even more realistic
    behavior.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还采样与灯光相关的阴影图，以实现更逼真的行为。
- en: Spatial filtering
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空间滤波
- en: To remove some of the noise, we apply a Gaussian filter only on the *X* and
    *Y* axis of the Frustum Aligned Texture, and then we pass to the most important
    filter, the temporal one.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除一些噪声，我们仅在视锥对齐纹理的X轴和Y轴上应用高斯滤波器，然后传递到最重要的滤波器，即时间滤波器。
- en: Temporal filtering
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间滤波
- en: This filter is what really improves the visuals by giving the possibility of
    adding some noise at different steps of the algorithm to remove some banding.
    It will read the previous frame’s final texture (the one before the integration)
    and blend the current light scattering result with the previous one based on some
    constant factor.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过滤器通过在算法的不同步骤添加一些噪声来消除一些色带，从而真正提高了视觉效果。它将读取前一帧的最终纹理（集成之前的那个），并根据某个常数因子将当前的光散射结果与之前的结果混合。
- en: This is a very difficult topic, as temporal filtering and reprojection can cause
    a few issues. We will have a much bigger discussion in the next chapter when talking
    about **Temporal** **Anti-Aliasing** (**TAA**)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常困难的话题，因为时间滤波和重投影可能会引起一些问题。我们将在下一章讨论**时间****反走样**（**TAA**）时进行更深入的讨论。
- en: With the scattering and extinction finalized, we can perform the light integration
    and thus prepare the texture that will be sampled by the scene.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在散射和消光完成后，我们可以执行光积分，从而准备场景将要采样的纹理。
- en: Light integration
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 光积分
- en: This step prepares another Frustum Aligned Volumetric Texture to contain an
    integration of the fog. Basically, this shader simulates a low-resolution ray
    marching so that this result can be sampled by the scene.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步准备另一个对齐体积纹理来包含雾的积分。基本上，这个着色器模拟了低分辨率的射线投射，以便这个结果可以被场景采样。
- en: Ray marching normally starts from the camera toward the far plane of the scene.
    The combination of the Frustum Aligned Texture and this integration gives, for
    each froxel, a cached ray marching of the light scattering to be easily sampled
    by the scene. In this step, from all the extinction saved in previous textures,
    we finally calculate the transmittance with the Beer-Lambert law and use that
    to merge the fog into the scene.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 射线投射通常从摄像机开始，向场景的远平面延伸。对齐体积纹理和这个积分的结合为每个froxel提供了一个缓存的射线投射光散射，以便场景可以轻松采样。在这个步骤中，我们从之前纹理中保存的所有消光中最终计算出透射率，并使用它将雾合并到场景中。
- en: This and temporal filtering are some of the big innovations that unlocked the
    real-time possibility of this algorithm. In more advanced solutions, such as in
    the game Red Dead Redemption 2, an additional ray marching can be added to simulate
    fog at much further distances.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这和时序滤波是一些重大创新，解锁了此算法的实时可能性。在更高级的解决方案中，例如在游戏《荒野大镖客救赎2》中，可以添加额外的射线投射来模拟更远距离的雾。
- en: It also allows for blending fog and Volumetric Clouds, which use a pure ray
    marching approach, to have an almost seamless transition. This is explained in
    detail in the Siggraph presentation about Red Dead Redemption 2 rendering.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 它还允许雾和体积云（使用纯射线投射方法）混合，实现几乎无缝的过渡。这在上Siggraph关于《荒野大镖客救赎2》渲染的演示中详细解释。
- en: Scene application in Clustered Lighting
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集群光照中的场景应用
- en: The final step is to read the Volumetric Texture in the lighting shader using
    the world position. We can read the depth buffer, calculate the world position,
    calculate the froxel coordinates and sample the texture.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是使用世界位置在光照着色器中读取体积纹理。我们可以读取深度缓冲区，计算世界位置，计算froxel坐标并采样纹理。
- en: An additional step to further smooth the volumetric look is to render to a half-resolution
    texture the scene application and then apply it to the scene with a geometry-aware
    upsampling, but this will be left as an exercise for you to complete.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步平滑体积外观，可以先将场景应用渲染到半分辨率纹理，然后使用几何感知上采样将其应用到场景中，但这个步骤将留给你作为练习来完成。
- en: Implementing Volumetric Fog Rendering
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现体积雾渲染
- en: We now have all the knowledge necessary to read the code needed to get this
    algorithm fully working. From a CPU perspective, it is just a series of compute
    shaders dispatches, so it is straightforward.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了读取使此算法完全工作的代码所需的所有知识。从CPU的角度来看，它只是一系列计算着色器调度，所以很简单。
- en: The core of this technique is implemented throughout various shaders, and thus
    on the GPU, working for almost all steps on the frustum aligned Volumetric Texture
    we talked about in the previous section.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的核心在各个着色器中实现，因此也在GPU上实现，几乎处理了我们在上一节中提到的关于对齐体积纹理的几乎所有步骤。
- en: '*Figure 10**.7* shows the different algorithm steps, and we will see each one
    individually in the following sections.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.7* 展示了不同的算法步骤，我们将在接下来的章节中逐一介绍。'
- en: Data injection
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据注入
- en: In the first shader, we will write scattering and extinction, starting from
    the color and density of different fog phenomena.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个着色器中，我们将从不同雾现象的颜色和密度开始编写散射和消光：
- en: 'We decided to add three different fog effects, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定添加三种不同的雾效果，如下所示：
- en: A constant fog
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恒定雾
- en: Height fog
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高度雾
- en: Fog in a volume
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 体积中的雾
- en: For each fog, we need to calculate scattering and extinction and accumulate
    them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种雾，我们需要计算散射和消光并将它们累积：
- en: 'The following code converts color and density to scattering and extinction:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将颜色和密度转换为散射和消光：
- en: '[PRE0]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can now have a look at the main shader. This shader, as most of the others
    in this chapter, will be scheduled to have one thread for one froxel cell.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以查看主着色器。这个着色器，就像本章中的大多数其他着色器一样，将被调度为每个froxel单元一个线程：
- en: 'In the first section, we will see the dispatch and code to calculate world
    position:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，我们将看到用于计算世界位置的调度和代码：
- en: '[PRE1]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We add an optional noise to animate the fog and break the constant density:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个可选的噪声来动画化雾并打破恒定的密度：
- en: '[PRE2]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we add and accumulate constant fog:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们添加并累积恒定雾：
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, add and accumulate height fog:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加并累积高度雾：
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And finally, add density from a box:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，从盒子中添加密度：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We finally store the scattering and extinction, ready to be lit in the next
    shader:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终存储散射和消光，以便在下一个着色器中照明：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Calculating the lighting contribution
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算光照贡献
- en: Lighting will be performed using the Clustered Lighting data structures already
    used in general lighting functions. In this shader, we calculate the in-scattering
    of light.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 照明将使用已在通用照明函数中使用的Clustered Lighting数据结构执行。在这个着色器中，我们计算光线的入射散射：
- en: 'Shader dispatching is the same as for the previous shader, one thread for one
    froxel:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器调度与上一个着色器相同，一个线程对应一个froxel：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We read scattering and extinction from the result of the injection shader:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从注入着色器的结果中读取散射和消光：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We then start accumulating light and using clustered bins.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后开始累积光线并使用集群的箱子：
- en: 'Notice the cooperation between different rendering algorithms: having the clustered
    bin already developed, we can use that to query lights in a defined volume starting
    from the world space position:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意不同渲染算法之间的协作：由于已经开发了集群的箱子，我们可以使用它从世界空间位置查询定义体积中的光源：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Up until now, the code is almost identical to the one used in lighting, but
    we add `phase_function` to finalize the lighting factor:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，代码几乎与照明中使用的代码相同，但我们添加了`phase_function`来最终化光照因子：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Final scattering is calculated and stored, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的散射计算并存储，如下所示：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We will now have a look at the integration/ray marching shader to conclude the
    main shaders needed to have the algorithm work for the volumetric part.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将查看积分/光线追踪着色器，以总结实现算法体积部分所需的主要着色器。
- en: Integrating scattering and extinction
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 散射和消光的积分
- en: This shader is responsible for performing the ray marching in the froxel texture
    and performing the intermediate calculations in each cell. It will still write
    in a frustum-aligned texture, but each cell will contain the accumulated scattering
    and transmittance starting from that cell.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个着色器负责在froxel纹理中执行光线追踪并在每个单元格中进行中间计算。它仍然会写入一个与锥体对齐的纹理，但每个单元格将包含从该单元格开始的累积散射和透射率：
- en: Notice that we now use transmittance instead of extinction, transmittance being
    a quantity that integrates extinction to a certain space. The dispatch is just
    on the *X* and *Y* axis of the frustum texture, reading the light scattering texture,
    as we will perform the integration steps and write to each froxel in the main
    loop.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们现在使用透射率而不是消光，透射率是一个将消光积分到一定空间的量。调度仅针对锥体纹理的 *X* 和 *Y* 轴，读取光线散射纹理，因为我们将在主循环中执行积分步骤并将结果写入每个froxel：
- en: 'The final stored result is scattering and transmittance, so it can be easier
    to apply it to the scene:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最终存储的结果是散射和透射率，因此可以更容易地将其应用于场景：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We integrate on the *Z* axis as this texture is frustum aligned.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *Z* 轴上积分，因为该纹理是锥体对齐的：
- en: 'First, we calculate the depth difference to have the thickness needed for the
    extinction integral:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们计算深度差以获得消光积分所需的厚度：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We will calculate scattering and transmittance and accumulate them for the
    following cell on the *Z* axis:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将计算散射和透射率，并将它们累积到下一个在 *Z* 轴上的单元格：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We now have a volume texture containing ray marched scattering and transmittance
    values that can be queried from anywhere in the frame to know how much fog there
    is and what color it is at that point.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个包含光线追踪散射和透射值的体积纹理，可以从帧中的任何位置查询，以了解有多少雾以及该点的颜色。
- en: This concludes the main volumetric rendering aspect of the algorithm. We will
    now have a look at how easy it is to apply the fog to a scene.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了算法的主要体积渲染方面。我们现在来看看将雾应用于场景有多容易。
- en: Applying Volumetric Fog to the scene
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将体积雾应用于场景
- en: We can finally apply the Volumetric Fog. To do that, we use the screen space
    coordinates to calculate the sampling coordinates for the texture. This function
    will be used at the end of the lighting calculations for both deferred and forward
    rendering paths.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终可以应用体积雾。为此，我们使用屏幕空间坐标来计算纹理的采样坐标。这个函数将在延迟和前向渲染路径的照明计算结束时使用。
- en: 'We first calculate the sampling coordinates:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先计算采样坐标：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After we read the scattering and transmittance at the specified position, we
    use the transmittance to modulate the current scene color and add the fog scattered
    color, like so:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取指定位置的散射和透射值之后，我们使用透射值来调制当前场景颜色并添加雾散射颜色，如下所示：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And this concludes the necessary steps to fully implement Volumetric Fog rendering.
    But still, there is a big problem: **banding**.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了完全实现体积雾渲染的必要步骤。但仍然存在一个大问题：**带状效应**。
- en: This is a large topic covered in several papers, but for the sake of simplicity,
    we can say that having a low-resolution volume texture adds banding problems,
    but it is necessary for achieving real-time performance.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在几篇论文中讨论的广泛主题，但为了简单起见，我们可以这样说，拥有低分辨率的体积纹理会增加带状问题，但这是实现实时性能所必需的。
- en: Adding filters
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加过滤器
- en: 'To further improve the visuals, we add two different filters: a temporal and
    a spatial one.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步提高视觉效果，我们添加了两个不同的过滤器：一个时间过滤器和空间过滤器。
- en: The temporal filter is what really makes the difference because it gives us
    the possibility of adding noise in different parts of the algorithm and thus removing
    banding. The spatial filter smooths out the fog even further.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 时间过滤器真正实现了差异，因为它给了我们在算法的不同部分添加噪声的可能性，从而消除了带状效应。空间过滤器进一步平滑了雾。
- en: Spatial filtering
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空间过滤
- en: This shader will smooth out the volumetric texture in the *X* and *Y* axis by
    applying a Gaussian filter. It will read the result of the light scattering and
    write into the froxel data texture, unused at this point of the frame, removing
    the need to create a temporary texture.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个着色器将通过应用高斯过滤器来平滑体积纹理的X和Y轴。它将读取光散射的结果并将其写入froxel数据纹理，在当前帧的这个点尚未使用，从而消除了创建临时纹理的需要。
- en: 'We first define the Gaussian function and its representing code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义高斯函数及其表示代码：
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We then read the light scattering texture and accumulate values and weight
    only if the calculated coordinates are valid:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们读取光散射纹理，并且只有在计算出的坐标有效时才累加值和权重：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We store the result in the froxel data texture:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将结果存储在froxel数据纹理中：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The next step is temporal filtering.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是时间过滤。
- en: Temporal filtering
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间过滤
- en: This shader will take the currently calculated 3D light scattering texture and
    apply a temporal filter. In order to do that it will need two textures, one for
    the current and one for the previous frame, and thanks to bindless, we just need
    to change the indices to use them.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个着色器将接受当前计算的3D光散射纹理并应用一个时间过滤器。为了做到这一点，它将需要两个纹理，一个用于当前帧，一个用于前一帧，多亏了无绑定，我们只需要更改索引来使用它们。
- en: Dispatch is like most of the shaders in this chapter, with one thread for each
    froxel element of the volume texture. Let’s begin with reading the current light
    scattering texture.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 分派与本章中的大多数着色器类似，每个froxel元素都有一个线程。让我们从读取当前光散射纹理开始。
- en: 'This currently resides in `froxel_data_texture`, coming from the spatial filtering:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这目前位于`froxel_data_texture`中，来自空间过滤：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We need to calculate the previous screen space position to read the previous
    frame texture.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要计算之前的屏幕空间位置来读取前一个帧的纹理。
- en: 'We will calculate the world position and then use the previous view projection
    to get the UVW coordinates to read the texture:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将计算世界位置，然后使用之前的视图投影来获取UVW坐标以读取纹理：
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We then check whether the calculated UVWs are valid and if so, we will read
    the previous texture:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查计算出的UVW是否有效，如果是，我们将读取前一个纹理：
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once we read the sample, we can merge the current result with the previous
    one based on a user-defined percentage:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦读取了样本，我们可以根据用户定义的百分比将当前结果与上一个结果合并：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We store the result back into the light scattering texture so that the integration
    can use it for the last step of the volumetric side of the algorithm.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将结果存储回光散射纹理中，以便积分可以在算法的体积部分的最后一步使用它。
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: At this point, we have seen all of the steps for the complete algorithm for
    the Volumetric Fog.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了体积雾完整算法的所有步骤。
- en: The last thing to see is the volumetric noise generation used to animate the
    fog and briefly talk about noise and jittering used to remove banding.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要看到的是用于动画雾的体积噪声生成，并简要讨论用于去除条纹的噪声和抖动。
- en: Volumetric noise generation
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 体积噪声生成
- en: To break the fog density up a bit so that it is more interesting, we can sample
    a volumetric noise texture to modify the density a little. We can add a single
    execution compute shader that creates and stores Perlin noise in a 3D texture
    and then reads it when sampling the fog density.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使雾密度更有趣，我们可以采样体积噪声纹理来稍微修改密度。我们可以添加一个单次执行的计算着色器，它将Perlin噪声存储在3D纹理中，然后在采样雾密度时读取它。
- en: 'Additionally, we can animate this noise to simulate wind animation. The shader
    is straightforward and uses Perlin noise functions as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以动画化这个噪声来模拟风动画。着色器很简单，并使用以下Perlin噪声函数：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The result is a volume texture with a single channel and Perlin noise to be
    sampled. We also use a special Sampler that has a repeat filter on the *U*, *V,*
    and *W* axes.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个单通道体积纹理，其中包含用于采样的Perlin噪声。我们还使用一个特殊的采样器，它在*U*、*V*和*W*轴上有重复过滤器。
- en: Blue noise
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 蓝色噪声
- en: As an additional noise used to offset sampling in different areas of the algorithm,
    we use blue noise, reading it from a texture and adding a temporal component to
    it.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 作为用于在不同区域偏移采样的附加噪声，我们使用蓝色噪声，从纹理中读取它，并给它添加一个时间组件。
- en: There are many interesting properties of blue noise and much literature on why
    it is a great noise for visual perception, and we will post links at the end of
    this chapter, but for now, we just read the noise from a texture with two channels
    and map it to the `–1` to `1` range.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝色噪声有许多有趣的特性，并且有许多关于为什么它是视觉感知中优秀噪声的文献，我们将在本章末尾提供链接，但现在，我们只是从具有两个通道的纹理中读取噪声，并将其映射到`-1`到`1`的范围。
- en: 'The mapping function is as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 映射函数如下：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And the following is performed to read the blue noise:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下操作用于读取蓝色噪声：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The final value will be between `–1` and `1` and can be scaled to any need and
    used everywhere.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最终值将在`-1`和`1`之间，并且可以按任何需要缩放并用于任何地方。
- en: There is an animated blue noise paper that promises even better quality, but
    due to licensing problems, we opted to use this free version.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个动画蓝色噪声论文承诺更好的质量，但由于许可问题，我们选择了使用这个免费版本。
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the Volumetric Fog rendering technique. We provided
    a brief mathematical background and algorithmic overview before showing the code.
    We also showed the different techniques available to improve banding – a vast
    topic that requires a careful balance of noise and temporal reprojection.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了体积雾渲染技术。在展示代码之前，我们提供了简短的数学背景和算法概述。我们还展示了不同的技术，以改善条纹——这是一个需要仔细平衡噪声和时间重投影的广泛主题。
- en: The algorithm presented is also an almost complete implementation that can be
    found behind many commercial games. We also talked about filtering, especially
    the temporal filter, which is linked to the next chapter, where we will talk about
    an anti-aliasing technique that uses temporal reprojection.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 提出的算法也是一个几乎完整的实现，可以在许多商业游戏中找到。我们还讨论了过滤，特别是与下一章相关的时间滤波器，我们将讨论一种使用时间重投影的防锯齿技术。
- en: In the next chapter, we will see how the synergy between Temporal Anti-Aliasing
    and noises used to jitter the sampling in Volumetric Fog will ease out the visual
    bandings. We will also show a feasible way to generate custom textures with a
    single-use compute shader used to generate a volumetric noise.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到时间抗锯齿和用于在体积雾中抖动采样的噪声之间的协同作用如何减轻视觉条纹。我们还将展示一种使用用于生成体积噪声的单次使用计算着色器生成自定义纹理的可行方法。
- en: This technique is also used for other volumetric algorithms, such as Volumetric
    Clouds, to store more custom noises used for generating the cloud shapes.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术也用于其他体积算法，如体积云，以存储更多用于生成云形状的自定义噪声。
- en: Further reading
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'There are many different papers that are referenced in this chapter, but the
    most important is the *Real-Time Volumetric Rendering* paper for general GPU-based
    volumetric rendering: [https://patapom.com/topics/Revision2013/Revision%202013%20-%20Real-time%20Volumetric%20Rendering%20Course%20Notes.pdf](https://patapom.com/topics/Revision2013/Revision%202013%20-%20Real-time%20Volumetric%20Rendering%20Course%20Notes.pdf).'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 本章引用了许多不同的论文，但最重要的是关于基于GPU的实时体积渲染的*实时体积渲染*论文：[https://patapom.com/topics/Revision2013/Revision%202013%20-%20Real-time%20Volumetric%20Rendering%20Course%20Notes.pdf](https://patapom.com/topics/Revision2013/Revision%202013%20-%20Real-time%20Volumetric%20Rendering%20Course%20Notes.pdf).
- en: 'The algorithm is still a derivation of the seminal paper from Bart Wronski:
    [https://bartwronski.files.wordpress.com/2014/08/bwronski_volumetric_fog_siggraph2014.pdf](https://bartwronski.files.wordpress.com/2014/08/bwronski_volumetric_fog_siggraph2014.pdf).'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法仍然是Bart Wronski的开创性论文的衍生：[https://bartwronski.files.wordpress.com/2014/08/bwronski_volumetric_fog_siggraph2014.pdf](https://bartwronski.files.wordpress.com/2014/08/bwronski_volumetric_fog_siggraph2014.pdf).
- en: 'With some evolutions and mathematical improvements in the following link: [https://www.ea.com/frostbite/news/physically-based-unified-volumetric-rendering-in-frostbite](https://www.ea.com/frostbite/news/physically-based-unified-volumetric-rendering-in-frostbite).'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下链接中，有一些进化和数学改进：[https://www.ea.com/frostbite/news/physically-based-unified-volumetric-rendering-in-frostbite](https://www.ea.com/frostbite/news/physically-based-unified-volumetric-rendering-in-frostbite).
- en: 'For the depth distribution, we referenced the formula used in iD Tech 6: [https://advances.realtimerendering.com/s2016/Siggraph2016_idTech6.pdf](https://advances.realtimerendering.com/s2016/Siggraph2016_idTech6.pdf).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于深度分布，我们参考了iD Tech 6中使用的公式：[https://advances.realtimerendering.com/s2016/Siggraph2016_idTech6.pdf](https://advances.realtimerendering.com/s2016/Siggraph2016_idTech6.pdf).
- en: 'For banding and noise, the most comprehensive papers come from Playdead:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于带状和噪声，最全面的论文来自Playdead：
- en: '[https://loopit.dk/rendering_inside.pdf](https://loopit.dk/rendering_inside.pdf)'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://loopit.dk/rendering_inside.pdf](https://loopit.dk/rendering_inside.pdf)'
- en: '[https://loopit.dk/banding_in_games.pdf](https://loopit.dk/banding_in_games.pdf)'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://loopit.dk/banding_in_games.pdf](https://loopit.dk/banding_in_games.pdf)'
- en: 'For information on animated blue noise: [https://blog.demofox.org/2017/10/31/animating-noise-for-integration-over-time/](https://blog.demofox.org/2017/10/31/animating-noise-for-integration-over-time/)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 关于动画蓝色噪声的信息：[https://blog.demofox.org/2017/10/31/animating-noise-for-integration-over-time/](https://blog.demofox.org/2017/10/31/animating-noise-for-integration-over-time/)
- en: 'For information on dithering, blue noise, and the golden ratio sequence: [https://bartwronski.com/2016/10/30/dithering-part-two-golden-ratio-sequence-blue-noise-and-highpass-and-remap/](https://bartwronski.com/2016/10/30/dithering-part-two-golden-ratio-sequence-blue-noise-and-highpass-and-remap/)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 关于抖动、蓝色噪声和黄金比例序列的信息：[https://bartwronski.com/2016/10/30/dithering-part-two-golden-ratio-sequence-blue-noise-and-highpass-and-remap/](https://bartwronski.com/2016/10/30/dithering-part-two-golden-ratio-sequence-blue-noise-and-highpass-and-remap/)
- en: 'A free blue noise texture can be found here: [http://momentsingraphics.de/BlueNoise.xhtml](http://momentsingraphics.de/BlueNoise.xhtml).'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在这里找到免费的蓝色噪声纹理：[http://momentsingraphics.de/BlueNoise.xhtml](http://momentsingraphics.de/BlueNoise.xhtml).
- en: 'Part 3: Advanced Rendering Techniques'
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分：高级渲染技术
- en: In this part, we will continue to add advanced techniques to our renderer and
    we will also explore how to replace or improve some of the techniques developed
    in earlier chapters using ray tracing.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们将继续向我们的渲染器添加高级技术，并探讨如何使用光线追踪替换或改进早期章节中开发的一些技术。
- en: 'We will cover the following chapters in this section:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖以下章节：
- en: '[*Chapter 11*](B18395_11.xhtml#_idTextAnchor178)*, Temporal Anti-Aliasing*'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B18395_11.xhtml#_idTextAnchor178)*，时间反走样*'
- en: '[*Chapter 12*](B18395_12.xhtml#_idTextAnchor205)*, Getting Started with Ray
    Tracing*'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B18395_12.xhtml#_idTextAnchor205)*，Ray Tracing入门*'
- en: '[*Chapter 13*](B18395_13.xhtml#_idTextAnchor213)*, Revisiting Shadows with
    Ray Tracing*'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B18395_13.xhtml#_idTextAnchor213)*，使用Ray Tracing重新审视阴影*'
- en: '[*Chapter 14*](B18395_14.xhtml#_idTextAnchor241)*, Adding Dynamic Diffuse Global
    Illumination with Ray Tracing*'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B18395_14.xhtml#_idTextAnchor241)*，使用Ray Tracing添加动态漫反射全局照明*'
- en: '[*Chapter 15*](B18395_15.xhtml#_idTextAnchor280)*, Adding Reflections with
    Ray Tracing*'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B18395_15.xhtml#_idTextAnchor280)*，使用Ray Tracing添加反射*'
