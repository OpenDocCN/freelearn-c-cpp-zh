["```cpp\n#include <algorithm>\n#include <array>\n#include <iostream>\nstruct Point {\n  int x{0}, y{0};\n};\nconstexpr int sumArray(const std::array<int, 5> &arr) {\n  int sum = 0;\n  for (const auto &val : arr) { sum += val; }\n  return sum;\n}\nint main() {\n  std::array<int, 5> numbers = {5, 3, 8, 1, 4};\n  std::array<Point, 3> points = {{{1, 2}, {3, 4}, {5, 6}}};\n  // Demonstrating structured bindings with &[x, y]\n  for (const auto &[x, y] : points) {\n    std::cout << \"(\" << x << \", \" << y << \")\\n\";\n  }\n  constexpr std::array<int, 5> constNumbers = {1, 2, 3, 4,\n                                               5};\n  constexpr int totalSum = sumArray(constNumbers);\n  std::cout << \"\\nCompile-time sum of array elements: \"\n            << totalSum << \"\\n\";\n  std::sort(numbers.begin(), numbers.end());\n  std::cout << \"\\nSorted numbers: \";\n  for (const auto &num : numbers) {\n    std::cout << num << \" \";\n  }\n  std::cout << \"\\n\";\n  int searchFor = 3;\n  if (std::find(numbers.begin(), numbers.end(),\n                searchFor) != numbers.end()) {\n    std::cout << \"\\nFound \" << searchFor\n              << \" in the array.\\n\";\n  } else {\n    std::cout << \"\\nDidn't find \" << searchFor\n              << \" in the array.\\n\";\n  }\n  return 0;\n}\n```", "```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\nclass Employee {\npublic:\n  Employee(int _id, const std::string &_name)\n      : id(_id), name(_name) {}\n  int getId() const { return id; }\n  const std::string &getName() const { return name; }\n  void setName(const std::string &newName) {\n    name = newName;\n  }\nprivate:\n  int id{0};\n  std::string name;\n};\nint main() {\n  std::vector<Employee> employees;\n  employees.reserve(5);\n  employees.emplace_back(1, \"Lisa\");\n  employees.emplace_back(2, \"Corbin\");\n  employees.emplace_back(3, \"Aaron\");\n  employees.emplace_back(4, \"Amanda\");\n  employees.emplace_back(5, \"Regan\");\n  for (const auto &emp : employees) {\n    std::cout << \"ID: \" << emp.getId()\n              << \", Name: \" << emp.getName() << \"\\n\";\n  }\n  auto it = std::find_if(\n      employees.begin(), employees.end(),\n      [](const Employee &e) { return e.getId() == 3; });\n  if (it != employees.end()) { it->setName(\"Chuck\"); }\n  std::cout << \"\\nAfter Modification:\\n\";\n  for (const auto &emp : employees) {\n    std::cout << \"ID: \" << emp.getId()\n              << \", Name: \" << emp.getName() << \"\\n\";\n  }\n  employees.erase(std::remove_if(employees.begin(),\n                                 employees.end(),\n                                 [](const Employee &e) {\n                                   return e.getId() == 2;\n                                 }),\n                  employees.end());\n  std::cout << \"\\nAfter Removal:\\n\";\n  for (const auto &emp : employees) {\n    std::cout << \"ID: \" << emp.getId()\n              << \", Name: \" << emp.getName() << \"\\n\";\n  }\n  return 0;\n}\n```", "```cpp\n#include <iostream>\n#include <vector>\nint main() {\n  std::vector<bool> boolVec = {true, false, true, true,\n                               false};\n  boolVec[1] = true;\n  std::cout << \"Second element: \" << boolVec[1] << '\\n';\n  auto ref = boolVec[1];\n  ref = false;\n  std::cout << \"Second element after modifying copy: \"\n            << boolVec[1] << '\\n';\n  // Iterating over the vector\n  for (bool val : boolVec) { std::cout << val << ' '; }\n  std::cout << '\\n';\n  // Pushing values\n  boolVec.push_back(false);\n  // Resizing\n  boolVec.resize(10, true);\n  // Capacity and size\n  std::cout << \"Size: \" << boolVec.size()\n            << \", Capacity: \" << boolVec.capacity()\n            << '\\n';\n  // Clearing the vector\n  boolVec.clear();\n  return 0;\n}\n```", "```cpp\n#include <algorithm>\n#include <deque>\n#include <iostream>\n// A function to demonstrate using a deque as a sliding\n// window over data.\nvoid processInSlidingWindow(const std::deque<int> &data,\n                            size_t windowSize) {\n  for (size_t i = 0; i <= data.size() - windowSize; ++i) {\n    int sum = 0;\n    for (size_t j = i; j < i + windowSize; ++j) {\n      sum += data[j];\n    }\n    std::cout << \"Average of window starting at index \"\n              << i << \": \"\n              << static_cast<double>(sum) / windowSize\n              << \"\\n\";\n  }\n}\nint main() {\n  std::deque<int> numbers;\n  for (int i = 1; i <= 5; ++i) {\n    numbers.push_back(i * 10);   // 10, 20, ..., 50\n    numbers.push_front(-i * 10); // -10, -20, ..., -50\n  }\n  std::cout << \"Numbers in deque: \";\n  for (const auto &num : numbers) {\n    std::cout << num << \" \";\n  }\n  std::cout << \"\\n\";\n  numbers.pop_front();\n  numbers.pop_back();\n  std::cout << \"After removing front and back: \";\n  for (const auto &num : numbers) {\n    std::cout << num << \" \";\n  }\n  std::cout << \"\\n\";\n  processInSlidingWindow(numbers, 3);\n  std::transform(numbers.begin(), numbers.end(),\n                 numbers.begin(),\n                 [](int n) { return n * 2; });\n  std::cout << \"After doubling each element: \";\n  for (const auto &num : numbers) {\n    std::cout << num << \" \";\n  }\n  std::cout << \"\\n\";\n  return 0;\n}\n```", "```cpp\n#include <algorithm>\n#include <iostream>\n#include <list>\nvoid display(const std::list<int> &lst) {\n  for (const auto &val : lst) { std::cout << val << \" \"; }\n  std::cout << \"\\n\";\n}\nint main() {\n  std::list<int> numbers = {5, 1, 8, 3, 7};\n  std::cout << \"Numbers in reverse: \";\n  for (auto it = numbers.rbegin(); it != numbers.rend();\n       ++it) {\n    std::cout << *it << \" \";\n  }\n  std::cout << \"\\n\";\n  auto pos = std::find(numbers.begin(), numbers.end(), 8);\n  numbers.insert(pos, 2112);\n  std::cout << \"After insertion: \";\n  display(numbers);\n  numbers.sort();\n  std::list<int> more_numbers = {2, 6, 4};\n  more_numbers.sort();\n  numbers.merge(more_numbers);\n  std::cout << \"After sorting and merging: \";\n  display(numbers);\n  std::list<int> additional_numbers = {99, 100, 101};\n  numbers.splice(numbers.end(), additional_numbers);\n  std::cout << \"After splicing: \";\n  display(numbers);\n  numbers.remove_if([](int n) { return n % 2 == 0; });\n  std::cout << \"After removing all even numbers: \";\n  display(numbers);\n  return 0;\n}\n```", "```cpp\n#include <forward_list>\n#include <iostream>\n#include <vector>\ntemplate <typename KeyType, typename ValueType>\nclass ChainedHashTable {\npublic:\n  ChainedHashTable(size_t capacity) : capacity(capacity) {\n    table.resize(capacity);\n  }\n  bool get(const KeyType &key, ValueType &value) const {\n    const auto &list = table[hash(key)];\n    for (const auto &bucket : list) {\n      if (bucket.key == key) {\n        value = bucket.value;\n        return true;\n      }\n    }\n    return false;\n  }\n  void put(const KeyType &key, const ValueType &value) {\n    auto &list = table[hash(key)];\n    for (auto &bucket : list) {\n      if (bucket.key == key) {\n        bucket.value = value;\n        return;\n      }\n    }\n    list.emplace_front(key, value);\n  }\n  bool remove(const KeyType &key) {\n    auto &list = table[hash(key)];\n    return list.remove_if([&](const Bucket &bucket) {\n      return bucket.key == key;\n    });\n  }\nprivate:\n  struct Bucket {\n    KeyType key;\n    ValueType value;\n    Bucket(KeyType k, ValueType v) : key(k), value(v) {}\n  };\n  std::vector<std::forward_list<Bucket>> table;\n  size_t capacity;\n  size_t hash(const KeyType &key) const {\n    return std::hash<KeyType>{}(key) % capacity;\n  }\n};\nint main() {\n  ChainedHashTable<std::string, int> hashTable(10);\n  hashTable.put(\"apple\", 10);\n  hashTable.put(\"banana\", 20);\n  hashTable.put(\"cherry\", 30);\n  int value;\n  if (hashTable.get(\"apple\", value)) {\n    std::cout << \"apple: \" << value << \"\\n\";\n  }\n  if (hashTable.get(\"banana\", value)) {\n    std::cout << \"banana: \" << value << \"\\n\";\n  }\n  hashTable.remove(\"banana\");\n  if (!hashTable.get(\"banana\", value)) {\n    std::cout << \"banana not found!\\n\";\n  }\n  return 0;\n}\n```", "```cpp\n#include <algorithm>\n#include <iostream>\n#include <string>\nint main() {\n  std::string s = \"Hello, C++ World!\";\n  std::cout << \"Size: \" << s.size() << \"\\n\";\n  std::cout << \"First char: \" << s[0] << \"\\n\";\n  std::string greet = \"Hello\";\n  std::string target = \"World\";\n  std::string combined = greet + \", \" + target + \"!\";\n  std::cout << \"Combined: \" << combined << \"\\n\";\n  if (s.find(\"C++\") != std::string::npos) {\n    std::cout << \"String contains 'C++'\\n\";\n  }\n  std::transform(\n      s.begin(), s.end(), s.begin(),\n      [](unsigned char c) { return std::toupper(c); });\n  std::cout << \"Uppercase: \" << s << \"\\n\";\n  std::transform(\n      s.begin(), s.end(), s.begin(),\n      [](unsigned char c) { return std::tolower(c); });\n  std::cout << \"Lowercase: \" << s << \"\\n\";\n  s.erase(std::remove(s.begin(), s.end(), ' '), s.end());\n  std::cout << \"Without spaces: \" << s << \"\\n\";\n  std::string first = \"apple\";\n  std::string second = \"banana\";\n  if (first < second) {\n    std::cout << first << \" comes before \" << second\n              << \"\\n\";\n  }\n  int number = 2112;\n  std::string numStr = std::to_string(number);\n  std::cout << \"Number as string: \" << numStr << \"\\n\";\n  int convertedBack = std::stoi(numStr);\n  std::cout << \"String back to number: \" << convertedBack\n            << \"\\n\";\n  return 0;\n}\n```"]