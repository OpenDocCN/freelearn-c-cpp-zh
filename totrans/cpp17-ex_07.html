<html><head></head><body>
        

                            
                    <h1 class="header-title">The Games</h1>
                
            
            
                
<p>In <a href="f20d7a19-156f-43e8-92a5-46b9068128fc.xhtml" target="_blank">Chapter 6</a>, <em>Enhancing the QT Graphical Applications</em>, we developed an analog clock, a drawing program, and an editor with the Qt graphical library. In this chapter, we continue by developing the Othello and Noughts and Crosses games with the Qt library. You will find a description of these games after this introduction. We start in this chapter with basic versions, where two players play against each other. In <a href="ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml" target="_blank">Chapter 8</a>, <em>The Computer Plays</em>, we improve the games so that the computer plays against the human.</p>
<p>Topics we will cover in this chapter include:</p>
<ul>
<li class="mce-root">Introduction to game theory. We develop a game grid where the players take turns to add their marks to the game grid.</li>
<li class="mce-root">We announce the winner. In Othello, after each move, we calculate how many of the opponent's marks can be changed. When every position of the game grid has been occupied, we declare the winner or a draw.</li>
<li class="mce-root">In Noughts and Crosses, we count the number of marks in a row. If there are five marks in a row, we declare the winner.</li>
<li class="mce-root">We continue to use C++ features such as classes, fields, and methods. We also continue to use Qt features such as windows and widgets.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Othello</h1>
                
            
            
                
<p>In Othello, the game grid is empty at the beginning of the game. During the game, two players take turns adding marks, colored in black and white, to the game grid. Each time a player adds a mark, we look at the other marks and see if the new mark causes any of the opponent’s marks to be enclosed. In that case, we swap the color of the opponent’s enclosed marks.</p>
<p class="mce-root">For instance, if the black player adds a black mark in a position where the three marks to the left are white and the fourth mark is black, the three white marks are being enclosed by the two black marks, and they are swapped to black marks. When every position on the game grid has been occupied by white and black marks, we count the marks and the player with the most marks is the winner. If there is an equal number of black and white marks, it is a draw.</p>
<p>Here's what our game should look like:</p>
<div><img src="img/c7a9a4b5-274d-46fc-8bde-d9d10a94b08f.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">The game widget</h1>
                
            
            
                
<p>First of all, we need a game grid. The <kbd>GameWidget</kbd> class is common to all the applications of this chapter and of <a href="ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml" target="_blank">Chapter 8</a>, <em>The Computer Plays</em>. In <a href="411aae8c-9215-4315-8a2e-882bf028834c.xhtml" target="_blank">Chapter 5</a>, <em>Qt Graphical Applications</em> and <a href="f20d7a19-156f-43e8-92a5-46b9068128fc.xhtml" target="_blank">Chapter 6</a>, <em>Enhancing the QT Graphical Applications</em>, we developed the <kbd>DocumentWidget</kbd> class, since we worked with document-based applications. In this chapter and <a href="ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml" target="_blank">Chapter 8</a>, <em>The Computer Plays,</em> we instead develop the <kbd>GameWidget</kbd> class.</p>
<p class="mce-root">The <kbd>DocumentWidget</kbd> class of the two previous chapters and the <kbd>GameWidget</kbd> class of this chapter and the next chapter have both similarities and differences. They are both subclasses of the Qt class <kbd>QWidget</kbd>, and they are both intended to be embedded in a window. However, while <kbd>DocumentWidget</kbd> was intended to hold a document, <kbd>GameWidget</kbd> is intended to hold a game grid. It draws the grid and catches mouse clicks in the positions of the grid. <kbd>GameWidget</kbd> is an abstract class that lets it its subclass define methods that are called when the user clicks the mouse or when a mark in one of the positions of the game grid needs to be repainted.</p>
<p>However, we reuse the <kbd>MainWindow</kbd> class from the previous chapters to hold the main window of the application, with its menu bar.</p>
<p><strong>GameWidget.h</strong></p>
<pre style="padding-left: 60px">#ifndef GAMEWIDGET_H 
#define GAMEWIDGET_H 
 
#include &lt;QPainter&gt; 
#include &lt;QMouseEvent&gt; 
#include &lt;QMessageBox&gt; 
 
#include "..\MainWindow\MainWindow.h" 
 
class GameWidget : public QWidget { 
  Q_OBJECT </pre>
<p>The constructor initializes the number of rows and columns of the game grid:</p>
<pre style="padding-left: 30px">    public: 
      GameWidget(int rows, int columns, QWidget* parentWidget); </pre>
<p>The <kbd>clearGrid</kbd> method sets every position in the game grid to zero, which is assumed to represent an empty position. Therefore, every class that inherits <kbd>GameWidget</kbd> shall let the value zero represent an empty position:</p>
<pre style="padding-left: 30px">      void clearGrid(); </pre>
<p>The <kbd>resizeEvent</kbd> method is called when the user changes the size of the window. Since the number of rows and columns is constant, the width and height of each position is changed in accordance with the new size of the window:</p>
<pre style="padding-left: 30px">    void resizeEvent(QResizeEvent *eventPtr); </pre>
<p>The <kbd>mousePressEvent</kbd> is called when the user presses one of the mouse buttons, <kbd>paintEvent</kbd> is called when the window needs to be repainted, and <kbd>closeEvent</kbd> is called when the user clicks on the close box at the top-right corner of the window:</p>
<pre style="padding-left: 30px">      void mousePressEvent(QMouseEvent *eventPtr); 
      void paintEvent(QPaintEvent *eventPtr); 
      void closeEvent(QCloseEvent *eventPtr); </pre>
<p>The <kbd>mouseMark</kbd> and <kbd>drawMark</kbd> methods are pure virtual methods intended to be overridden by subclasses; <kbd>mouseMark</kbd> is called when the user clicks at a position in the grid, and <kbd>drawMark</kbd> is called when a position needs to be repainted. They are pure virtual methods, whereas <kbd>GameWidget</kbd> is abstract, which means that it is only possible to use <kbd>GameWidget</kbd> as a base class. The subclasses of <kbd>GameWidget</kbd> must override the methods to become non-abstract:</p>
<pre style="padding-left: 30px">    virtual void mouseMark(int row, int column) = 0; 
    virtual void drawMark(QPainter&amp; painter, 
                          const QRect&amp; markRect, int mark) = 0; </pre>
<p>The <kbd>isQuitOk</kbd> method displays a message box that asks the user if they really want to quit the game:</p>
<pre style="padding-left: 30px">  private: 
    bool isQuitOk(); </pre>
<p>The <kbd>isQuitEnabled</kbd> method is called before the <kbd>Game</kbd> menu becomes visible. The <kbd>Quit</kbd> item is enabled when a game is in progress:</p>
<pre style="padding-left: 30px">  public slots: 
    DEFINE_LISTENER(GameWidget, isQuitEnabled); </pre>
<p>The <kbd>onQuit</kbd> and <kbd>onExit</kbd> methods are called when the user selects the Quit or Exit menu items:</p>
<pre style="padding-left: 30px">    void onQuit(); 
    void onExit(); </pre>
<p>The <kbd>isGameInProgress</kbd> and <kbd>setGameInProgress</kbd> methods return and set the value of the <kbd>m_gameInProgress</kbd> field:</p>
<pre style="padding-left: 30px">  protected: 
    bool isGameInProgress() const {return m_gameInProgress;} 
    void setGameInProgress(bool active) 
                          {m_gameInProgress = active;} </pre>
<p>The <kbd>get</kbd> and <kbd>set</kbd> methods get and set a value at a position in the game grid. The value is an integer; remember that an empty position is assumed to hold the value zero:</p>
<pre style="padding-left: 30px">    protected: 
      int get(int row, int column) const; 
      void set(int row, int column, int value); </pre>
<p>The <kbd>m_gameInProgress</kbd> field is true as long as a game is in progress. The <kbd>m_rows</kbd> and <kbd>m_columns</kbd> fields hold the number of rows and columns of the game grid; <kbd>m_rowHeight</kbd> and <kbd>m_columnWidth</kbd> hold the height and width in pixels of each position in the game grid. Finally, <kbd>m_gameGrid</kbd> is a pointer to a buffer holding the values of the positions of the game grid:</p>
<pre style="padding-left: 30px">     private: 
       bool m_gameInProgress = false; 
       int m_rows, m_columns; 
       int m_rowHeight, m_columnWidth; 
       int* m_gameGrid; 
     }; 
 
     #endif // GAMEWIDGET_H </pre>
<p>The <kbd>GameWidget.cpp</kbd> file holds the definitions of the methods of the <kbd>GameWidget</kbd> class, the mouse event methods, and the menu methods, as well as the drawings and settings of the marks.</p>
<p><strong>GameWidget.cpp</strong></p>
<pre style="padding-left: 60px">#include "GameWidget.h" 
#include &lt;QApplication&gt; 
#include &lt;CAssert&gt; </pre>
<p>The constructor initializes the number of rows and columns of the grid, dynamically allocates its memory, and calls <kbd>clearGrid</kbd> to clear the grid:</p>
<pre style="padding-left: 60px">GameWidget::GameWidget(int rows, int columns, 
                       QWidget* parentWidget) 
 :QWidget(parentWidget), 
  m_rows(rows), 
  m_columns(columns), 
  m_gameGrid(new int[rows * columns]) { 
  assert(rows &gt; 0); 
  assert(columns &gt; 0); 
  clearGrid(); 
} </pre>
<p>The <kbd>get</kbd> method returns the value at the position indicated by the row and column and <kbd>set</kbd> sets the value. The buffer holding the values is organized in rows. That is, the first part of the buffer holds the first row, and then the second row, and so on:</p>
<pre style="padding-left: 60px">int GameWidget::get(int row, int column) const { 
  return m_gameGrid[(row * m_columns) + column]; 
} 
 
void GameWidget::set(int row, int column, int value) { 
  m_gameGrid[(row * m_columns) + column] = value; 
} </pre>
<p>The <kbd>clearGrid</kbd> method sets every position to zero, since zero is assumed to represent an empty position:</p>
<pre style="padding-left: 60px">void GameWidget::clearGrid() { 
  for (int row = 0; row &lt; m_rows; ++row) { 
    for (int column = 0; column &lt; m_columns; ++column) { 
      set(row, column, 0); 
    } 
  } 
} </pre>
<p>The <kbd>Quit</kbd> menu item is enabled as long as a game is in progress:</p>
<pre style="padding-left: 60px">bool GameWidget::isQuitEnabled() { 
  return m_gameInProgress; 
} </pre>
<p>If a game is in progress when the user selects to quit the game, a message box with a confirmation question is displayed:</p>
<pre style="padding-left: 60px">bool GameWidget::isQuitOk() { 
  if (m_gameInProgress) { 
    QMessageBox messageBox(QMessageBox::Warning, 
                           tr("Quit"), QString()); 
    messageBox.setText(tr("Quit the Game.")); 
    messageBox.setInformativeText 
                  (tr("Do you really want to quit the game?")); 
    messageBox.setStandardButtons(QMessageBox::Yes | 
                                  QMessageBox::No); 
    messageBox.setDefaultButton(QMessageBox::No); </pre>
<p>If the user presses the <kbd>Yes</kbd> button, <kbd>true</kbd> is returned:</p>
<pre style="padding-left: 60px">    return (messageBox.exec() == QMessageBox::Yes); 
  } 
 
  return true; 
}
 </pre>
<p>The <kbd>onQuit</kbd> method is called when the user selects the Quit menu item. If the call to <kbd>isQuitOk</kbd> returns true, <kbd>m_gameInProgress</kbd> is set to false and update is called, which eventually forces a repaint of the window where the game grid is cleared.</p>
<pre style="padding-left: 60px">void GameWidget::onQuit() { 
  if (isQuitOk()) { 
    m_gameInProgress = false; 
    update(); 
  } 
} </pre>
<p>The <kbd>onExit</kbd> method is called when the user selects the Exit menu item. If the call to <kbd>isQuitOk</kbd> returns true, the application is exited. This is shown in the following code:</p>
<pre style="padding-left: 60px">void GameWidget::onExit() { 
  if (isQuitOk()) { 
    qApp-&gt;exit(0); 
  } 
} </pre>
<p>The <kbd>resizeEvent</kbd> method is called when the user resizes the window. The row height and column width are recalculated since the number of rows and columns is constant regardless of the size of the window. We divide the height and width of the window by the number of rows and columns plus two, since we add extra rows and columns as margins. Consider the following code:</p>
<pre style="padding-left: 60px">void GameWidget::resizeEvent(QResizeEvent* eventPtr) { 
  m_rowHeight = height() / (m_rows + 2); 
  m_columnWidth = width() / (m_columns + 2); 
  QWidget::resizeEvent(eventPtr); 
  update(); 
} </pre>
<p>The <kbd>mousePressEvent</kbd> method is called when the user clicks on the window:</p>
<pre style="padding-left: 30px">    void GameWidget::mousePressEvent(QMouseEvent* eventPtr) { 
       if (m_gameInProgress &amp;&amp;<br/>             (eventPtr-&gt;button() == Qt::LeftButton)) { 
       QPoint mousePoint = eventPtr-&gt;pos(); </pre>
<p>The column width and row height are subtracted from the mouse point, since the game grid is enclosed by margins:</p>
<pre style="padding-left: 30px">    mousePoint.setX(mousePoint.x() - m_columnWidth); 
    mousePoint.setY(mousePoint.y() - m_rowHeight); </pre>
<p>If the mouse point is located inside one of the game grid positions, and that position is empty (zero), the pure virtual method <kbd>mouseMark</kbd> is called, which takes care of the actual action of the mouse click. In the next section, black and white marks are added to the game grid, and in the Noughts and Crosses application later on. Noughts and crosses are added to the game grid:</p>
<pre>      int row = mousePoint.y() / m_rowHeight, 
         column = mousePoint.x() / m_columnWidth; </pre>
<p>If the rows and columns clicked are located in the game grid (rather than in the margins outside the game grid) and the position is empty (zero), we call the <kbd>mouseMark</kbd>, which is a pure virtual method, with the row and column:</p>
<pre style="padding-left: 60px">    if ((row &lt; m_rows) &amp;&amp; (column &lt; m_columns) &amp;&amp; 
        (get(row, column) == 0)) { 
      mouseMark(row, column); 
      update(); 
    } 
  } 
} </pre>
<p>The <kbd>paintEvent</kbd> method is called when the window needs to be repainted. If a game is in progress (<kbd>m_gameInProgress</kbd> is true), the rows and columns are written, and then for each position in the game grid, the pure virtual method <kbd>drawMark</kbd> is called, which takes care of the actual painting of each position:</p>
<pre style="padding-left: 60px">void GameWidget::paintEvent(QPaintEvent* /*eventPtr*/) { 
  if (m_gameInProgress) { 
    QPainter painter(this); 
    painter.setRenderHint(QPainter::Antialiasing); 
    painter.setRenderHint(QPainter::TextAntialiasing); </pre>
<p>First, we iterate through the rows and for each row, we write a letter from <kbd>A</kbd> to <kbd>Z</kbd>. There are 26 letters of the alphabet, and we assume there are no more than 26 rows:</p>
<pre style="padding-left: 60px">    for (int row = 0; row &lt; m_rows; ++row) { 
      QString text; 
      text.sprintf("%c", (char) (((int) 'A') + row)); 
      QRect charRect(0, (row + 1) * m_rowHeight, 
                     m_columnWidth, m_rowHeight); 
      painter.drawText(charRect, Qt::AlignCenter | 
                       Qt::AlignHCenter, text); 
    } </pre>
<p>Then we iterate through the columns, and for each column, we write its number:</p>
<pre style="padding-left: 60px">    for (int column = 0; column &lt; m_columns; ++column) { 
      QString text; 
      text.sprintf("%i", column); 
      QRect charRect((column + 1) * m_columnWidth, 0, 
                     m_columnWidth, m_rowHeight); 
      painter.drawText(charRect, Qt::AlignCenter | 
                       Qt::AlignHCenter, text); 
    } 
 
    painter.save(); 
    painter.translate(m_columnWidth, m_rowHeight); </pre>
<p>A pure virtual method is a method that is not intended to be defined in the class, only in its subclasses. A class holding at least one pure virtual method becomes abstract, which means that it is not possible to create objects of the class. The class can only be used as a base class in a class hierarchy. A class that inherits an abstract class must define each pure virtual method of the base class, or become abstract itself.</p>
<p>Finally, we iterate through the game grid, and for each position, we call the pure virtual method <kbd>drawMark</kbd> with the rectangle of the position and its current mark:</p>
<pre style="padding-left: 30px">    for (int row = 0; row &lt; m_rows; ++row) { 
      for (int column = 0; column &lt; m_columns; ++column) { 
        QRect markRect(column * m_columnWidth, row * m_rowHeight, 
                       m_columnWidth, m_rowHeight); 
        painter.setPen(Qt::black); 
        painter.drawRect(markRect); 
        painter.fillRect(markRect, Qt::lightGray); 
        drawMark(painter, markRect, get(row, column)); 
      } 
    } 
 
    painter.restore(); 
     } 
    } </pre>
<p>The <kbd>closeEvent</kbd> method is called when the user clicks on the close box at the top-right corner of the window. If the call to <kbd>isQuitOk</kbd> returns true, the window is closed, and the application is exited:</p>
<pre style="padding-left: 60px">void GameWidget::closeEvent(QCloseEvent* eventPtr) { 
  if (isQuitOk()) { 
    eventPtr-&gt;accept(); 
    qApp-&gt;exit(0); 
  } 
  else { 
    eventPtr-&gt;ignore(); 
  } 
} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The OthelloWindow class</h1>
                
            
            
                
<p>The <kbd>Othello</kbd> class is a subclass of <kbd>MainWindow</kbd> from <a href="f20d7a19-156f-43e8-92a5-46b9068128fc.xhtml" target="_blank">Chapter 6</a>, <em>Enhancing the QT Graphical Applications</em>. It adds menus to the window and sets the <kbd>OthelloWidget</kbd> class here, which is a subclass of <kbd>GameWidget</kbd>, to its central widget.</p>
<p><strong>OthelloWindow.h</strong></p>
<pre style="padding-left: 30px">  #ifndef OTHELLOWINDOW_H 
  #define OTHELLOWINDOW_H 
 
  #include "..\MainWindow\MainWindow.h" 
  #include "OthelloWidget.h" 
 
  class OthelloWindow : public MainWindow { 
    Q_OBJECT 
 
    public: 
      OthelloWindow(QWidget *parentWidget = nullptr); 
      ~OthelloWindow(); 
 
      void closeEvent(QCloseEvent *eventPtr) 
        {m_othelloWidgetPtr-&gt;closeEvent(eventPtr);} </pre>
<p>The <kbd>m_othelloWidgetPtr</kbd> field holds a pointer to the widget located in the center of the window. It points at an object of the <kbd>OthelloWidget</kbd> class. This is shown in the following code:</p>
<pre style="padding-left: 30px">  private: 
    OthelloWidget* m_othelloWidgetPtr; 
}; 
 
#endif // OTHELLOWINDOW_H </pre>
<p>The <kbd>OthelloWindow.cpp</kbd> file defines the methods of the <kbd>OthelloWIndow</kbd> class.</p>
<p><strong>OthelloWindow.cpp</strong></p>
<pre style="padding-left: 30px">#include "OthelloWidget.h" 
#include "OthelloWindow.h" 
#include &lt;QtWidgets&gt; </pre>
<p>The constructor sets the title of the window to <kbd>Othello</kbd> and the size to <em>1000</em> x <em>500</em> pixels:</p>
<pre>OthelloWindow::OthelloWindow(QWidget *parentWidget /*= nullptr*/)<br/> :MainWindow(parentWidget) {<br/>  setWindowTitle(tr("Othello"));<br/>  resize(1000, 500);</pre>
<p>An <kbd>OthelloWidget</kbd> object is dynamically created and placed at the center of the window:</p>
<pre>    m_othelloWidgetPtr = new OthelloWidget(this); 
    setCentralWidget(m_othelloWidgetPtr); </pre>
<p>We add the menu <kbd>Game</kbd> to the menu bar and connect the <kbd>onMenuShow</kbd> method to the menu, which causes it to be called before the menu becomes visible:</p>
<pre style="padding-left: 30px">  { QMenu* gameMenuPtr = menuBar()-&gt;addMenu(tr("&amp;Game")); 
    connect(gameMenuPtr, SIGNAL(aboutToShow()), 
            this, SLOT(onMenuShow())); </pre>
<p>The user can choose the black or white color to make the first move. The <kbd>isBlackStartsEnabled</kbd> and <kbd>isWhiteStartsEnabled</kbd> methods are called before the items become visible. The items become disabled when a game is in progress:</p>
<pre>    addAction(gameMenuPtr, tr("&amp;Black Starts"), 
              SLOT(onBlackStarts()), 0, 
              tr("Black Starts"), nullptr,tr("Black Starts"), 
              LISTENER(isBlackStartsEnabled)); 
 
    addAction(gameMenuPtr, tr("&amp;White Starts"), 
              SLOT(onWhiteStarts()), 0, 
              tr("White Starts"), nullptr, tr("White Starts"), 
              LISTENER(isWhiteStartsEnabled)); 
 
    gameMenuPtr-&gt;addSeparator(); </pre>
<p>When a game is in progress, the user can quit the game. The item becomes disabled when no game is in progress:</p>
<pre>    addAction(gameMenuPtr, tr("&amp;Quit the Game"), 
              SLOT(onQuit()), 
              QKeySequence(Qt::CTRL + Qt::Key_Q), 
              tr("Quit Game"), nullptr, tr("Quit the Game"), 
              LISTENER(isQuitEnabled)); </pre>
<p>The user can exit the application at any time:</p>
<pre style="padding-left: 60px">    addAction(gameMenuPtr, tr("E&amp;xit"), 
              SLOT(onExit()), QKeySequence::Quit); 
  } 
} </pre>
<p>The destructor deallocates the <kbd>Othello</kbd> widget in the center of the window:</p>
<pre style="padding-left: 60px">OthelloWindow::~OthelloWindow() { 
  delete m_othelloWidgetPtr; 
} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The OthelloWidget class</h1>
                
            
            
                
<p><kbd>OthelloWidget</kbd> is a subclass of the <kbd>GameWidget</kbd> class we defined at the beginning of this chapter. It becomes a non-abstract class by overriding <kbd>mouseMark</kbd> and <kbd>drawMark</kbd>, which are called when the user clicks at a position in the game grid and when a position needs to be repainted.</p>
<p><strong>OthelloWidget.h</strong></p>
<pre style="padding-left: 60px">#ifndef OTHELLOWIDGET_H 
#define OTHELLOWIDGET_H 
 
#include "..\MainWindow\GameWidget.h" 
 
#define ROWS    8 
#define COLUMNS 8 </pre>
<p>A mark in Othello can be black or white. We use the <kbd>Mark</kbd> enumeration to store values on the game grid. The <kbd>Empty</kbd> item holds a value of zero, which is assumed to be <kbd>GameWidget</kbd> to represent an empty position:</p>
<pre style="padding-left: 60px">enum Mark {Empty = 0, Black, White}; 
 
class OthelloWidget : public GameWidget { 
  Q_OBJECT 
 
  public: 
    OthelloWidget(QWidget* parentWidget); 
 
    void mouseMark(int row, int column); 
    void drawMark(QPainter&amp; painter, 
                  const QRect&amp; markRect, int mark); </pre>
<p>The <kbd>isBlackStartsEnabled</kbd> and <kbd>isWhiteStartsEnabled</kbd> listeners are called before the <kbd>BlackStarts</kbd> and <kbd>WhiteStarts</kbd> menu items become visible in order to enable them. Note that the listeners and methods must be marked as public slots for the menu framework to allow them as listeners:</p>
<pre style="padding-left: 60px">    public slots: 
     DEFINE_LISTENER(OthelloWidget, isBlackStartsEnabled); 
     DEFINE_LISTENER(OthelloWidget, isWhiteStartsEnabled); </pre>
<p>The <kbd>onBlackStarts</kbd> and <kbd>onWhiteStarts</kbd> methods are called when the <kbd>BlackStarts</kbd> and <kbd>WhiteStarts</kbd> menu items are selected by the user:</p>
<pre style="padding-left: 60px">    void onBlackStarts(); 
    void onWhiteStarts(); </pre>
<p>The <kbd>checkWinner</kbd> method checks if every position on the game grid has been occupied by a black or white mark. If it has, the marks are counted, and the winner is announced unless it is a draw:</p>
<pre style="padding-left: 60px">   private: 
     void checkWinner(); </pre>
<p>The <kbd>turn</kbd> method is called when one of the players has made a move. It calculates the positions to be turned as a result of the move:</p>
<pre style="padding-left: 60px">     void turn(int row, int column, Mark mark); </pre>
<p>The <kbd>calculateMark</kbd> method calculates the set of marks to be turned if the player places the mark in the position given by the row and column:</p>
<pre style="padding-left: 60px">    void calculateMark(int row, int column, Mark mark, 
                       QSet&lt;QPair&lt;int,int&gt;&gt;&amp; resultSet); </pre>
<p>The <kbd>m_nextMark</kbd> field is alternatively given the values <kbd>Black</kbd> and <kbd>White</kbd> of the preceding <kbd>Mark</kbd> enumeration, depending on which player is about to do the next move.</p>
<p>It is initialized by <kbd>onBlackStarts</kbd> or <kbd>onWhiteStarts</kbd>, as shown in the previous code:</p>
<pre style="padding-left: 90px">    Mark m_nextMark; 
}; 
 
#endif // OTHELLOWIDGET_H </pre>
<p>The <kbd>OthelloWidget</kbd> class holds the functionality of the game. It allows the player to add black and white marks to the game grid, turn marks, and announce the winner.</p>
<p><strong>OthelloWidget.cpp</strong></p>
<pre style="padding-left: 60px">#include "OthelloWidget.h" 
#include "OthelloWindow.h" 
 
#include &lt;QTime&gt; 
#include &lt;CTime&gt; 
#include &lt;CAssert&gt; 
using namespace std; 
 
OthelloWidget::OthelloWidget(QWidget* parentWidget) 
 :GameWidget(ROWS, COLUMNS, parentWidget) { 
  // Empty. 
} </pre>
<p>The <kbd>BlackStarts</kbd> and <kbd>WhiteStarts</kbd> menu items are enabled when there is not already a game in progress:</p>
<pre style="padding-left: 60px">bool OthelloWidget::isBlackStartsEnabled() { 
  return !isGameInProgress(); 
} 
 
bool OthelloWidget::isWhiteStartsEnabled() { 
  return !isGameInProgress(); 
} </pre>
<p>The <kbd>onBlackStarts</kbd> and <kbd>onWhiteStarts</kbd> methods set a new game in progress, set the mark to make the first move (black or white), clear the grid, and update the window to paint an empty game grid:</p>
<pre style="padding-left: 60px">void OthelloWidget::onBlackStarts() { 
  setGameInProgress(true); 
  m_nextMark = Black; 
  update(); 
} 
 
void OthelloWidget::onWhiteStarts() { 
  setGameInProgress(true); 
  m_nextMark = White; 
  update(); 
} </pre>
<p>The <kbd>onMouseMark</kbd> is called when the player clicks an empty position on the game grid. We set the position with the next mark, turn every mark that is affected by the move, and update the window to reflect the change:</p>
<pre style="padding-left: 60px">void OthelloWidget::mouseMark(int row, int column) { 
  set(row, column, m_nextMark); 
  turn(row, column, m_nextMark); 
  update(); </pre>
<p>We check if the move has caused the game grid to become full and switch the next mark:</p>
<pre style="padding-left: 60px">  checkWinner(); 
  m_nextMark = (m_nextMark == Black) ? White : Black; 
} </pre>
<p>The <kbd>drawMark</kbd> method is called when a position in the game grid needs to be repainted. We draw a black or white ellipse with black borders if the position is not empty. If the position is empty, we do nothing. Note that the framework clears the window before the call to repaint:</p>
<pre style="padding-left: 60px">void OthelloWidget::drawMark(QPainter&amp; painter, 
     const QRect&amp; markRect, int mark) { 
  painter.setPen(Qt::black); 
  painter.drawRect(markRect); 
  painter.fillRect(markRect, Qt::lightGray); 
 
  switch (mark) { 
    case Black: 
      painter.setPen(Qt::black); 
      painter.setBrush(Qt::black); 
      painter.drawEllipse(markRect); 
      break; 
 
    case White: 
      painter.setPen(Qt::white); 
      painter.setBrush(Qt::white); 
      painter.drawEllipse(markRect); 
      break; 
 
    case Empty: 
      break;</pre>
<pre style="padding-left: 60px">  } 
} </pre>
<p>The <kbd>checkWinner</kbd> method counts the number of positions that are occupied by black and white marks or are empty:</p>
<pre style="padding-left: 60px">void OthelloWidget::checkWinner() { 
  int blacks = 0, whites = 0, empties = 0; 
 
  for (int row = 0; row &lt; ROWS; ++row) { 
    for (int column = 0; column &lt; COLUMNS; ++column) { 
      switch (get(row, column)) { 
        case Black: 
          ++blacks; 
          break; 
 
        case White: 
          ++whites; 
          break; 
 
        case Empty: 
          ++empties; 
          break; 
      } 
    } 
  } </pre>
<p>If there are no empty positions left, the game is over, and we announce the winner, unless it is a draw. The winner is the player with the most marks in their color:</p>
<pre style="padding-left: 60px">  if (empties == 0) { 
    QMessageBox messageBox(QMessageBox::Information, 
        tr("Victory"), QString()); 
    QString text; 
 
    if (blacks == whites) { 
      text.sprintf("A Draw."); 
    } 
    else if (blacks &gt; whites) { 
      text.sprintf("The Winner: Black"); 
    } 
    else { 
      text.sprintf("The Winner: White"); 
    } 
 
    messageBox.setText(text); 
    messageBox.setStandardButtons(QMessageBox::Ok); 
    messageBox.exec(); 
    setGameInProgress(false); 
 
    clearGrid(); 
    update(); 
  } 
} </pre>
<p>The <kbd>turn</kbd> method calls <kbd>calculateMark</kbd> to obtain the set of positions where the mark shall be turned. Then each position in the set is set to the mark in question.</p>
<p>In this application, <kbd>turn</kbd> is the only method that calls <kbd>calculateMark</kbd>. However, in <a href="ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml" target="_blank">Chapter 8</a>, <em>The Computer Plays</em>, <kbd>calculateMark</kbd> will also be called to calculate the move of the computer player. Therefore, the functionality of <kbd>turn</kbd> and <kbd>calculateMark</kbd> are divided into two methods:</p>
<pre style="padding-left: 60px">void OthelloWidget::turn(int row, int column, Mark mark) { 
  QSet&lt;QPair&lt;int,int&gt;&gt; totalSet; 
  calculateMark(row, column, mark, totalSet); 
 
  for (QPair&lt;int,int&gt; pair : totalSet) { 
    int row = pair.first, column = pair.second; 
    set(row, column, mark); 
  } 
} </pre>
<p>The <kbd>calculateMark</kbd> method counts the number of marks that will be turned for each position on the game grid, in all eight directions:</p>
<pre style="padding-left: 60px">void OthelloWidget::calculateMark(int row, int column, 
    Mark playerMark, QSet&lt;QPair&lt;int,int&gt;&gt;&amp; totalSet){ </pre>
<p>Each integer pair in <kbd>directionArray</kbd> refers to a direction in accordance with the compass rising:</p>
<pre style="padding-left: 30px">  QPair&lt;int,int&gt; directionArray[] = 
    {QPair&lt;int,int&gt;(-1, 0),   // North 
     QPair&lt;int,int&gt;(-1, 1),   // Northeast 
     QPair&lt;int,int&gt;(0, 1),    // East 
     QPair&lt;int,int&gt;(1, 1),    // Southeast 
     QPair&lt;int,int&gt;(1, 0),    // South 
     QPair&lt;int,int&gt;(1, -1),   // Southwest 
     QPair&lt;int,int&gt;(0, -1),   // West 
     QPair&lt;int,int&gt;(-1, -1)}; // Northwest </pre>
<p>The size of an array can be decided by dividing its total size (in bytes) by the size of its first value:</p>
<pre style="padding-left: 30px">  int arraySize = 
    (sizeof directionArray) / (sizeof directionArray[0]); </pre>
<p>We iterate through the directions and, for each direction, keep moving as long as we find the mark of the opponent:</p>
<pre style="padding-left: 30px">  for (int index = 0; index &lt; arraySize; ++index) { 
    QPair&lt;int,int&gt; pair = directionArray[index]; </pre>
<p>The <kbd>row</kbd> and <kbd>column</kbd> fields hold the current row and column as long as we iterate in that direction:</p>
<pre style="padding-left: 30px">    int rowStep = pair.first, columnStep = pair.second, 
        currRow = row, currColumn = column; </pre>
<p>We gather the marks we find during the iteration in <kbd>directionSet</kbd>:</p>
<pre style="padding-left: 30px">    QSet&lt;QPair&lt;int,int&gt;&gt; directionSet; 
 
    while (true) { 
      currRow += rowStep; 
      currColumn += columnStep; </pre>
<p>If we reach one of the borders of the game grid, or if we find an empty position, we break the iteration:</p>
<pre style="padding-left: 60px">if ((currRow &lt; 0) || (currRow == ROWS) || 
          (currColumn &lt; 0) || (currColumn == COLUMNS) || 
          (get(currRow, currColumn) == Empty)) { 
break; 
} </pre>
<p>If we find the player's mark, we add the direction set to the total set and break the iteration:</p>
<pre style="padding-left: 60px">else if (get(currRow, currColumn) == playerMark) { 
  totalSet += directionSet; 
  break; 
} </pre>
<p>If we do not find the player's mark or an empty position, we have found the opponent's mark, and we add its position to the direction set:</p>
<pre style="padding-left: 60px">      else { 
        directionSet.insert(QPair&lt;int,int&gt;(row, column)); 
      } 
    } 
  } 
} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The main function</h1>
                
            
            
                
<p>The <kbd>main</kbd> function works in the same way as in the previous Qt applications. It creates an application, shows the Othello window, and executes the applications. The execution continues until the <kbd>exit</kbd> method is called, which it is when the user closes the window or selects the Exit menu item.</p>
<p><strong>Main.cpp</strong></p>
<pre style="padding-left: 60px">#include "OthelloWidget.h" 
#include "OthelloWindow.h" 
#include &lt;QApplication&gt; 
 
int main(int argc, char *argv[]) { 
  QApplication application(argc, argv); 
  OthelloWindow othelloWindow; 
  othelloWindow.show(); 
  return application.exec(); 
} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Noughts and crosses</h1>
                
            
            
                
<p>The Noughts and Crosses application sets up a game grid and allows two players to play each other. In Noughts and Crosses, two players take turns adding noughts and crosses to a game grid. The player that first manages to place five marks in a row wins the game. The marks can be placed horizontally, vertically, or diagonally. While each player tries to place five of their own marks in a row, they must also try to prevent the opponent from placing five marks in a row.</p>
<p>In <a href="ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml" target="_blank">Chapter 8</a>, <em>The Computer Plays</em>, the computer plays against the human.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The NaCWindow class</h1>
                
            
            
                
<p>We reuse the <kbd>GameWidget</kbd> from the game widget section. The <kbd>NaCWindow</kbd> class is similar to <kbd>OthelloWindow</kbd>. It adds the <kbd>Nought Begins</kbd> and <kbd>Cross Begins</kbd> menu items to the window's menu bar.</p>
<p><strong>NaCWindow.h</strong></p>
<pre style="padding-left: 60px">#ifndef NACWINDOW_H 
#define NACWINDOW_H 
 
#include "..\MainWindow\MainWindow.h" 
#include "NaCWidget.h" 
 
class NaCWindow : public MainWindow { 
  Q_OBJECT 
 
  public: 
    NaCWindow(QWidget *parentWidget = nullptr); 
    ~NaCWindow(); 
 
  public: 
    void closeEvent(QCloseEvent *eventPtr) override 
                   {m_nacWidgetPtr-&gt;closeEvent(eventPtr);} 
 
  private: 
    NaCWidget* m_nacWidgetPtr; 
}; 
 
#endif // NACWINDOW_H </pre>
<p>The <kbd>NaCWindow.cpp</kbd> file holds the definitions of the methods of the <kbd>NacWindow</kbd> class.</p>
<p><strong>NaCWindow.cpp</strong></p>
<pre style="padding-left: 60px">#include "NaCWindow.h" 
#include &lt;QtWidgets&gt; 
 
NaCWindow::NaCWindow(QWidget *parentWidget /*= nullptr*/) 
 :MainWindow(parentWidget) { 
  setWindowTitle(tr("Noughts and Crosses")); 
  resize(1000, 500); 
 
  m_nacWidgetPtr = new NaCWidget(this); 
  setCentralWidget(m_nacWidgetPtr); 
 
  { QMenu* gameMenuPtr = menuBar()-&gt;addMenu(tr("&amp;Game")); 
    connect(gameMenuPtr, SIGNAL(aboutToShow()), 
            this, SLOT(onMenuShow())); 
 
    addAction(gameMenuPtr, tr("&amp;Nought Starts"), 
              SLOT(onNoughtStarts()), 0, 
              tr("Nought Starts"), nullptr, tr("Nought Starts"), 
              LISTENER(isNoughtStartsEnabled)); 
 
    addAction(gameMenuPtr, tr("&amp;Cross Starts"), 
              SLOT(onCrossStarts()), 0, 
              tr("Cross Starts"), nullptr, tr("Cross Starts"), 
              LISTENER(isCrossStartsEnabled)); 
 
    gameMenuPtr-&gt;addSeparator(); 
 
    addAction(gameMenuPtr, tr("&amp;Quit the Game"), 
              SLOT(onQuit()), 
              QKeySequence(Qt::CTRL + Qt::Key_Q), tr("Quit Game"), 
              nullptr, tr("Quit the Game"), 
              LISTENER(isQuitEnabled)); 
 
    addAction(gameMenuPtr, tr("E&amp;xit"), 
              SLOT(onExit()), QKeySequence::Quit); 
  } 
} 
 
NaCWindow::~NaCWindow() { 
  delete m_nacWidgetPtr; 
} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The NaCWidget class</h1>
                
            
            
                
<p>The <kbd>NaCWidget</kbd> class handles the functionality of Noughts and Crosses. It allows two players to play each other. In <a href="ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml" target="_blank">Chapter 8</a>, <em>The Computer Plays</em>, we will write a game where the computer plays the human.</p>
<p><strong>NaCWidget.h</strong></p>
<pre style="padding-left: 60px">#ifndef NACWIDGET_H 
#define NACWIDGET_H 
 
#include "..\MainWindow\GameWidget.h" 
 
#define ROWS    26 
#define COLUMNS 26 </pre>
<p>Similar to the Othello application, a position in the game grid can hold one of three values:</p>
<ul>
<li><kbd>Empty</kbd> (which is zero)</li>
<li><kbd>Nought</kbd></li>
<li><kbd>Cross</kbd></li>
</ul>
<p>The <kbd>Mark</kbd> enumeration corresponds to the <kbd>Empty</kbd>, <kbd>Nought</kbd>, and <kbd>Cross</kbd> values: </p>
<pre style="padding-left: 60px">enum Mark {Empty = 0, Nought, Cross}; 
 
class NaCWidget : public GameWidget { 
  Q_OBJECT 
 
  public: 
    NaCWidget(QWidget* parentWidget); 
 
    void mouseMark(int row, int column); 
    void drawMark(QPainter&amp; painter, 
                  const QRect&amp; markRect, int mark); 
 
  public slots: 
    DEFINE_LISTENER(NaCWidget, isNoughtStartsEnabled); 
    void onNoughtStarts(); 
 
    DEFINE_LISTENER(NaCWidget, isCrossStartsEnabled); 
    void onCrossStarts(); 
 
  private: 
    void checkWinner(int row, int column, Mark mark); 
    int countMarks(int row, int column, int rowStep, 
                   int columnStep, Mark mark); 
 
    Mark m_nextMark; 
}; 
 
#endif // NACWIDGET_H </pre>
<p>The <kbd>NaCWidget.cpp</kbd> file holds the definitions of the methods of the <kbd>NaCWidget</kbd> class.</p>
<p><strong>NaCWidget.cpp</strong></p>
<pre style="padding-left: 60px">#include "NaCWidget.h" 
#include &lt;CTime&gt; 
 
NaCWidget::NaCWidget(QWidget* parentWidget) 
 :GameWidget(ROWS, COLUMNS, parentWidget) { 
  // Empty. 
} </pre>
<p>The <kbd>isNoughtStartsEnabled</kbd> and <kbd>isCrossStartsEnabled</kbd> methods are called before the <kbd>Game</kbd> menu becomes visible. The <kbd>Noughts Begins</kbd> and <kbd>Cross Begins</kbd> menu items are enabled if there is no game in progress:</p>
<pre style="padding-left: 90px">bool NaCWidget::isCrossStartsEnabled() { 
  return !isGameInProgress(); 
} 
 
bool NaCWidget::isNoughtStartsEnabled() { 
  return !isGameInProgress(); 
} </pre>
<p>The <kbd>onNoughtBegins</kbd> and <kbd>onCrossBegins</kbd> methods are called when the user selects the <kbd>Nought Begins</kbd> and <kbd>Cross Begins</kbd> menu items. They set the game in progress, set the first mark to make the first move (<kbd>m_nextMark</kbd>), and force a repainting of the game grid by calling <kbd>update</kbd>:</p>
<pre style="padding-left: 60px">void NaCWidget::onNoughtStarts() { 
  setGameInProgress(true); 
  m_nextMark = Nought; 
  update(); 
} 
 
void NaCWidget::onCrossStarts() { 
  setGameInProgress(true); 
  m_nextMark = Cross; 
  update(); 
} </pre>
<p>The <kbd>mouseMark</kbd> method is called when the players click a position in the game grid. We set the next mark at the position, check if one of the players has won the game, swap the next move, and repaint the window by calling <kbd>update</kbd>:</p>
<pre style="padding-left: 60px">void NaCWidget::mouseMark(int row, int column) { 
  set(row, column, m_nextMark); 
  checkWinner(row, column, m_nextMark); 
  m_nextMark = (m_nextMark == Nought) ? Cross : Nought; 
  update(); 
} </pre>
<p>The <kbd>drawMark</kbd> method is called when a position in the game grid needs to be repainted:</p>
<pre style="padding-left: 60px">void NaCWidget::drawMark(QPainter&amp; painter, 
    const QRect&amp; markRect, int mark) { </pre>
<p>We set the pen color to black, and in the case of a nought, we draw an ellipse, as follows:</p>
<pre style="padding-left: 60px">  painter.setPen(Qt::black); 
  switch (mark) { 
    case Nought: 
      painter.drawEllipse(markRect); 
      break; </pre>
<p>In the case of a cross, we draw two lines between the top-left and bottom-right corners and between the top-right and bottom-left corners:</p>
<pre style="padding-left: 60px">    case Cross: 
      painter.drawLine(markRect.topLeft(), 
                       markRect.bottomRight()); 
      painter.drawLine(markRect.topRight(), 
                       markRect.bottomLeft()); 
      break; </pre>
<p>In the case of an empty position, we do nothing. Remember that the framework clears the window before the repainting:</p>
<pre style="padding-left: 60px">    case Empty: 
      break; 
  } 
} </pre>
<p>When a player has made a move, we check if the move has led to victory. We call <kbd>countMarks</kbd> in four directions to <kbd>checkWinner</kbd> and see if the move has caused five marks in a row:</p>
<pre style="padding-left: 60px">    void NaCWidget::checkWinner(int row, int column, Mark mark) { </pre>
<p>For the north and south directions, the code would be:</p>
<pre style="padding-left: 60px">  if ((countMarks(row, column, -1, 0, mark) &gt;= 5) || </pre>
<p> For the west and east directions, the code would be:</p>
<pre style="padding-left: 60px">      (countMarks(row, column, 0, -1, mark) &gt;= 5) || </pre>
<p> </p>
<p>For the northwest and southeast directions, the code would be:</p>
<pre style="padding-left: 60px">      (countMarks(row, column, -1, 1, mark) &gt;=5)|| </pre>
<p>For southeast and northwest, it would be:</p>
<pre style="padding-left: 60px">      (countMarks(row, column, 1, 1, mark) &gt;= 5)) { </pre>
<p>If the move has caused five marks in a row, we display a message box with the winner (black or white). In Noughts and Crosses, there can be no draw:</p>
<pre style="padding-left: 60px">    QMessageBox messageBox(QMessageBox::Information, 
                           tr("Victory"), QString()); 
    QString text; 
    text.sprintf("The Winner: %s.", 
                 (mark == Nought) ? "Nought" : "Cross"); 
 
    messageBox.setText(text); 
    messageBox.setStandardButtons(QMessageBox::Ok); 
    messageBox.exec(); 
    setGameInProgress(false); </pre>
<p>The game grid is cleared, and is thereby ready for another game:</p>
<pre style="padding-left: 60px">    clearGrid(); 
    update(); 
  } 
} </pre>
<p>The <kbd>countMarks</kbd> method counts the number of marks in a row. We <kbd>countMarks</kbd> the number of marks in both directions. For instance, if both <kbd>rowStep</kbd> and <kbd>columnStep</kbd> are minus one, we decrease the current row and column by one for each iteration. That means that we call <kbd>countMarks</kbd> in the northeast direction in the first iteration. In the second iteration, we call <kbd>countMarks</kbd> in the opposite direction, that is, in the southwest direction:</p>
<pre style="padding-left: 60px">int NaCWidget::countMarks(int row, int column, int rowStep, 
                          int columnStep, Mark mark) { 
  int countMarks = 0; </pre>
<p>We keep counting until we encounter one of the game grid borders, or we find a mark that is not the mark we are counting, that is, the mark of the opposite player or an empty mark:</p>
<pre style="padding-left: 60px">    { int currentRow = row, currentColumn = column; 
      while ((currentRow &gt;= 0) &amp;&amp; (currentRow &lt; ROWS) &amp;&amp; 
             (currentColumn &gt;= 0) &amp;&amp; (currentColumn &lt; COLUMNS) &amp;&amp; 
             (get(currentRow, currentColumn) == mark)) { 
          ++countMarks; 
          currentRow += rowStep; 
          currentColumn += columnStep; 
         } 
    } </pre>
<p>In the second iteration, we subtract the row and column steps instead of adding them. In this way, we call <kbd>countMarks</kbd> in the opposite direction. We also initialize the current rows and columns by adding the steps in order, so we do not <kbd>countMarks</kbd> the middle mark twice:</p>
<pre style="padding-left: 60px">  { int currentRow = row + rowStep, 
        currentColumn = column + columnStep; 
      while ((currentRow &gt;= 0) &amp;&amp; (currentRow &lt; ROWS) &amp;&amp; 
           (currentColumn &gt;= 0) &amp;&amp; (currentColumn &lt; COLUMNS) &amp;&amp; 
           (get(currentRow, currentColumn) == mark)) { 
        ++countMarks; 
        currentRow -= rowStep; 
        currentColumn -= columnStep; 
      } 
     } 
 
    return countMarks; 
  } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The main function</h1>
                
            
            
                
<p>The <kbd>main</kbd> function creates the application, shows the window, and executes the application until the user closes the window or selects the Exit menu item.</p>
<p><strong>Main.cpp</strong></p>
<pre style="padding-left: 60px">#include "NaCWidget.h" 
#include "NaCWindow.h" 
#include &lt;QApplication&gt; 
 
int main(int argc, char *argv[]) { 
  QApplication application(argc, argv); 
  NaCWindow mainWindow; 
  mainWindow.show(); 
  return application.exec(); 
} </pre>
<p>The output for the preceding code is as follows:</p>
<div><img src="img/d0111dd0-efe7-4911-8851-1bfa61a04170.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we developed the two games, Othello and Noughts and Crosses. We were introduced to game theory, and we developed a game grid where the players take turns to add their marks. In Othello, we developed methods to count the number of marks to change for each move, and in Noughts and Crosses, we developed methods to recognize if one of the players had managed to place five marks in a row—if they had, we declared them the winner.</p>
<p>In <a href="ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml" target="_blank">Chapter 8</a>, <em>The Computer Plays</em>, we will develop more advanced versions of these games, where the computer plays against a human.</p>


            

            
        
    </body></html>