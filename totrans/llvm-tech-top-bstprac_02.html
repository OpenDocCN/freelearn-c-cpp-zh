<html><head></head><body>
		<div id="_idContainer006">
			<h1 id="_idParaDest-15"><em class="italic"><a id="_idTextAnchor014"/>Chapter 1</em>: Saving Resources When Building LLVM</h1>
			<p>LLVM is the state-of-the-art compiler optimization and code generation framework adopted by many amazing industrial and academic projects, such as the <strong class="bold">Just-In-Time</strong> (<strong class="bold">JIT</strong>) compiler in JavaScript engines and <strong class="bold">machine learning</strong> (<strong class="bold">ML</strong>) frameworks. It is a useful toolbox for building programming languages and binary file tools. However, despite the project's robustness, its learning resources are scattered, and it doesn't have the best documentation either. Due to this, it has a pretty steep learning curve, even for developers with some LLVM experience. This book aims to tackle these issues by providing you with knowledge of common and important domains in LLVM in a pragmatic fashion â€“ showing you some useful engineering tips, pointing out lesser-known but handy features, and illustrating useful examples.</p>
			<p>As an <strong class="bold">LLVM</strong> developer, building LLVM from source has always been the first thing you should do. Given the scale of LLVM nowadays, this task can take hours to finish. Even worse, rebuilding the project to reflect changes might also take a long time and hinder your productivity. Therefore, it's crucial to know how to use the right tools and how to find the best build configurations for your project for the sake of saving various resources, especially your precious time.</p>
			<p>In this chapter, we are going to cover the following topics:</p>
			<ul>
				<li>Cutting down building resources with better tooling</li>
				<li>Saving building resources by tweaking CMake arguments</li>
				<li>Learning how to use GN, an alternative LLVM build system, and its pros and cons</li>
			</ul>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Technical requirements</h1>
			<p>At the time of writing this book, LLVM only has a few software requirements:</p>
			<ul>
				<li>A C/C++ compiler that supports C++14</li>
				<li>CMake</li>
				<li>One of the build systems supported by CMake, such as GNU Make or Ninja</li>
				<li>Python (2.7 is fine too, but I strongly recommend using 3.x)</li>
				<li>zlib</li>
			</ul>
			<p>The exact versions of these items change from time to time. Check out <a href="https://llvm.org/docs/GettingStarted.html#software">https://llvm.org/docs/GettingStarted.html#software</a> for more details.</p>
			<p>This chapter assumes you have built an LLVM before. If that's not the case, perform the following steps:</p>
			<ol>
				<li value="1">Grab a copy of the LLVM source tree from GitHub:<p class="source-code"><strong class="bold">$ git clone https://github.com/llvm/llvm-project</strong></p></li>
				<li>Usually, the default branch should build without errors. If you want to use release versions that are more stable, such as release version 10.x, use the following command:<p class="source-code"><strong class="bold">$ git clone -b release/10.x https://github.com/llvm/llvm-project</strong></p></li>
				<li>Finally, you should create a build folder where you're going to invoke the CMake command. All the building artifacts will also be placed inside this folder. This can be done using the following command:<p class="source-code"><strong class="bold">$ mkdir .my_build</strong></p><p class="source-code"><strong class="bold">$ cd .my_build</strong></p></li>
			</ol>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Cutting down building resources with better tooling</h1>
			<p>As we mentioned <a id="_idIndexMarker000"/>at the beginning of this chapter, if you build LLVM with the <a id="_idIndexMarker001"/>default (CMake) configurations, by invoking <strong class="bold">CMake</strong> and <a id="_idIndexMarker002"/>building the project in the following way, there is a high chance that the whole process will take <em class="italic">hours</em> to finish:</p>
			<p class="source-code">$ cmake ../llvm</p>
			<p class="source-code">$ make all</p>
			<p>This can be avoided by simply using better tools and changing some environments. In this <a id="_idIndexMarker003"/>section, we will cover some guidelines <a id="_idIndexMarker004"/>to help you choose the right tools and configurations that can both speed up your building time and improve memory footprints.</p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>Replacing GNU Make with Ninja</h2>
			<p>The first <a id="_idIndexMarker005"/>improvement we can do is using the <strong class="bold">Ninja</strong> build tool (<a href="https://ninja-build.org">https://ninja-build.org</a>) rather <a id="_idIndexMarker006"/>than GNU Make, which <a id="_idIndexMarker007"/>is the default build system generated by CMake on major Linux/Unix platforms. </p>
			<p>Here are the steps you can use to set up Ninja on your system:</p>
			<ol>
				<li value="1">On Ubuntu, for example, you can install Ninja by using this command:<p class="source-code"><strong class="bold">$ sudo apt install ninja-build</strong></p><p>Ninja is also available in most Linux distributions.</p></li>
				<li>Then, when you're invoking CMake for your LLVM build, add an extra argument:<p class="source-code"><strong class="bold">$ cmake -G "Ninja" ../llvm</strong></p></li>
				<li>Finally, use the following build command instead:<p class="source-code"><strong class="bold">$ ninja all</strong></p></li>
			</ol>
			<p>Ninja runs <em class="italic">significantly</em> faster than GNU Make on large code bases such as LLVM. One of the secrets behind Ninja's blazing fast running speed is that while the majority of build scripts such as <strong class="source-inline">Makefile</strong> are designed to be written manually, the syntax of Ninja's build script, <strong class="source-inline">build.ninja</strong>, is more similar to assembly code, which should <em class="italic">not</em> be edited by developers but generated by other higher-level build systems such as CMake. The fact that Ninja uses an assembly-like build script allows it to do many optimizations under the hood and get rid of many redundancies, such as slower parsing speeds, when invoking the build. Ninja also has a good reputation for generating better dependencies among build targets.</p>
			<p>Ninja makes clever decisions in terms of its <em class="italic">degree of parallelization</em>; that is, how many jobs you want to execute in parallel. So, usually, you don't need to worry about this. If you <a id="_idIndexMarker008"/>want to explicitly assign the number of <a id="_idIndexMarker009"/>worker threads, the same command-line option used by GNU Make still works here:</p>
			<p class="source-code">$ ninja -j8 all</p>
			<p>Let's now see how you can avoid using the BFD linker.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Avoiding the use of the BFD linker</h2>
			<p>The second improvement we can do is using linkers <em class="italic">other than</em> the BFD linker, which is the default <a id="_idIndexMarker010"/>linker used in most Linux systems. The BFD linker, despite being the most mature linker on Unix/Linux systems, is not optimized for speed or memory consumption. This would create a performance bottleneck, especially for large projects such as LLVM. This is because, unlike the compiling phase, it's pretty hard for the linking phase to do file-level parallelization. Not to mention the fact that the BFD linker's peak memory consumption when building LLVM usually takes about 20 GB, causing a burden on computers with small amounts of memory. Fortunately, there are at least two linkers in the wild that provide both good single-thread performance and low <a id="_idIndexMarker011"/>memory consumption: the <strong class="bold">GNU gold linker</strong> and LLVM's own linker, <strong class="bold">LLD</strong>.</p>
			<p>The gold <a id="_idIndexMarker012"/>linker was originally developed by Google and donated to GNU's <strong class="source-inline">binutils</strong>. You should have it sitting in the <strong class="source-inline">binutils</strong> package by default in modern Linux distributions. LLD is one of LLVM's subprojects with even faster linking speed and an experimental parallel linking technique. Some of the Linux distributions (newer Ubuntu versions, for example) already have LLD in their package repository. You can also download the prebuilt version from LLVM's official website.</p>
			<p>To use the gold linker or LLD to build your LLVM source tree, add an extra CMake argument with the name of the linker you want to use. </p>
			<p>For the gold linker, use the following command:</p>
			<p class="source-code">$ cmake -G "Ninja" -DLLVM_USE_LINKER=gold ../llvm</p>
			<p>Similarly, for LLD, use the following command:</p>
			<p class="source-code">$ cmake -G "Ninja" -DLLVM_USE_LINKER=lld ../llvm</p>
			<p class="callout-heading">Limiting the number of parallel threads for Linking</p>
			<p class="callout">Limiting the number of parallel threads for linking is another way to reduce (peak) memory consumption. You can achieve this by assigning the <strong class="source-inline">LLVM_PARALLEL_LINK_JOBS=&lt;N&gt;</strong> CMake variable, where <strong class="source-inline">N</strong> is the desired number of working threads.</p>
			<p>With that, we've <a id="_idIndexMarker013"/>learned that by simply using different tools, the building time could be reduced <em class="italic">significantly</em>. In the next section, we're going to improve this building speed by tweaking LLVM's CMake arguments.</p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>Tweaking CMake arguments</h1>
			<p>This section will show you some of the most common CMake arguments in LLVM's build system that <a id="_idIndexMarker014"/>can help you customize your build and achieve maximum efficiency.</p>
			<p>Before we start, you should have a build folder that has been CMake-configured. Most of the following subsections will modify a file in the build folder; that is, <strong class="source-inline">CMakeCache.txt</strong>.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Choosing the right build type</h2>
			<p>LLVM uses <a id="_idIndexMarker015"/>several predefined build types provided by CMake. The most common types among them are as follows:</p>
			<ul>
				<li><strong class="source-inline">Release</strong>: This is the default build type if you didn't specify any. It will adopt the highest optimization level (usually -O3) and eliminate most of the debug information. Usually, this build type will make the building speed slightly slower.</li>
				<li><strong class="source-inline">Debug</strong>: This build type will compile without any optimization applied (that is, -O0). It preserves all the debug information. Note that this will generate a <em class="italic">huge</em> number of artifacts and usually take up ~20 GB of space, so please be sure you have enough storage space when using this build type. This will usually make the building speed slightly faster since no optimization is being performed.</li>
				<li><strong class="source-inline">RelWithDebInfo</strong>: This build type applies as much compiler optimization as possible (usually -O2) and preserves all the debug information. This is an option balanced between space consumption, runtime speed, and debuggability.</li>
			</ul>
			<p>You can choose one of them using the <strong class="source-inline">CMAKE_BUILD_TYPE</strong> CMake variable. For example, to use the <strong class="source-inline">RelWithDebInfo</strong> type, you can use the following command:</p>
			<p class="source-code">$ cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo â€¦</p>
			<p>It is recommended to use <strong class="source-inline">RelWithDebInfo</strong> first (if you're going to debug LLVM later). Modern compilers have gone a long way to improve the debug information's quality in optimized <a id="_idIndexMarker016"/>program binaries. So, always give it a try first to avoid unnecessary storage waste; you can always go back to the <strong class="source-inline">Debug</strong> type if things don't work out.</p>
			<p>In addition to configuring build types, <strong class="source-inline">LLVM_ENABLE_ASSERTIONS</strong> is another CMake (Boolean) argument that controls whether assertions (that is, the <strong class="source-inline">assert(bool predicate)</strong> function, which will terminate the program if the predicate argument is not true) are enabled. By default, this flag will only be true if the build type is <strong class="source-inline">Debug</strong>, but you can always turn it on manually to enforce stricter checks, even in other build types.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Avoiding building all targets</h2>
			<p>The number of LLVM's supported targets (hardware) has grown rapidly in the past few years. At the <a id="_idIndexMarker017"/>time of writing this book, there are nearly 20 officially supported targets. Each of them deals with non-trivial tasks such as native code generation, so it takes a significant amount of time to build. However, the chances that you're going to be working on <em class="italic">all</em> of these targets at the same time are low. Thus, you can select a subset of targets to build using the <strong class="source-inline">LLVM_TARGETS_TO_BUILD</strong> CMake argument. For example, to build the X86 target only, we can use the following command:</p>
			<p class="source-code">$ cmake -DLLVM_TARGETS_TO_BUILD="X86" â€¦</p>
			<p>You can also specify multiple targets using a semicolon-separated list, as follows:</p>
			<p class="source-code">$ cmake -DLLVM_TARGETS_TO_BUILD="X86;AArch64;AMDGPU" â€¦</p>
			<p class="callout-heading">Surround the list of targets with double quotes!</p>
			<p class="callout">In some shells, such as <strong class="source-inline">BASH</strong>, a semicolon is an ending symbol for a command. So, the rest of the CMake command will be cut off if you don't surround the list of targets with <em class="italic">double-quotes</em>.</p>
			<p>Let's <a id="_idIndexMarker018"/>see how building shared libraries can help tweak CMake arguments.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Building as shared libraries</h2>
			<p>One of the <a id="_idIndexMarker019"/>most iconic features of LLVM is its <strong class="bold">modular design</strong>. Each component, optimization algorithm, code generation, and <a id="_idIndexMarker020"/>utility libraries, to name a few, are put into their own libraries where developers can link individual ones, depending on their usage. By default, each <a id="_idIndexMarker021"/>component is built as a <strong class="bold">static library</strong> (<strong class="source-inline">*.a</strong> in Unix/Linux and <strong class="source-inline">*.lib</strong> in Windows). However, in this <a id="_idIndexMarker022"/>case, static libraries have the following drawbacks:</p>
			<ul>
				<li>Linking against static libraries usually takes more time than linking against dynamic libraries (<strong class="source-inline">*.so</strong> in Unix/Linux and <strong class="source-inline">*.dll</strong> in Windows).</li>
				<li>If multiple executables link against the same set of libraries, like many of the LLVM tools do, the total size of these executables will be <em class="italic">significantly</em> larger when you adopt the static library approach compared to its dynamic library counterpart. This is because each of the executables has a copy of those libraries.</li>
				<li>When you're debugging LLVM programs with debuggers (GDB, for example), they usually spend quite some time loading the statically linked executables at the very beginning, hindering the debugging experience.</li>
			</ul>
			<p>Thus, it's recommended to build every LLVM component as a dynamic library during the development phase by using the <strong class="source-inline">BUILD_SHARED_LIBS</strong> CMake argument:</p>
			<p class="source-code">$ cmake -DBUILD_SHARED_LIBS=ON â€¦</p>
			<p>This will save you a significant amount of storage space and speed up the building process.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Splitting the debug info</h2>
			<p>When you're <a id="_idIndexMarker023"/>building a program in debug mode â€“ adding the <strong class="source-inline">-g</strong> flag when using you're GCC and Clang, for example â€“ by default, the generated <a id="_idIndexMarker024"/>binary contains a section that stores <strong class="bold">debug information</strong>. This information is essential for using a debugger (for example, GDB) to debug that program. LLVM is a large and complex project, so when you're building it in debug mode â€“ using the <strong class="source-inline">cm</strong><strong class="source-inline">AKE_BUILD_TYPE=Debug</strong> variable â€“ the compiled libraries and executables come with a huge amount of debug information that takes up a lot of disk space. This causes the following problems:</p>
			<ul>
				<li>Due to the design of C/C++, several <em class="italic">duplicates</em> of the same debug information might be embedded in different object files (for example, the debug information for a header file might be embedded in every library that includes it), which wastes lots of disk space.</li>
				<li>The linker needs to load object files AND their associated debug information into memory during the linking stage, meaning that memory pressure will increase if the object file contains a non-trivial amount of debug information.</li>
			</ul>
			<p>To solve these problems, the build system in LLVM provides allows us to <em class="italic">split</em> debug information into separate files from the original object files. By detaching debug information from object files, the debug info of the same source file is condensed into one place, thus avoiding unnecessary duplicates being created and saving lots of disk space. In addition, since debug info is not part of the object files anymore, the linker no longer needs to load them into memory and thus saves lots of memory resources. Last but not least, this feature can also improve our <em class="italic">incremental</em> building speed â€“ that is, rebuild the project after a (small) code change â€“ since we only need to update the modified debug information in a single place.</p>
			<p>To use this feature, please use the <strong class="source-inline">LLVM_USE_SPLIT_DWARF</strong> cmake variable:</p>
			<p class="source-code">$ cmake -DcmAKE_BUILD_TYPE=Debug <strong class="bold">-DLLVM_USE_SPLIT_DWARF=ON</strong> â€¦</p>
			<p>Note that this CMake variable only works for compilers that use the DWARF debug format, including GCC and Clang.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Building an optimized version of llvm-tblgen</h2>
			<p><strong class="bold">TableGen</strong> is a <strong class="bold">Domain-Specific Language</strong> (<strong class="bold">DSL</strong>) for describing structural data that will be <a id="_idIndexMarker025"/>converted into the <a id="_idIndexMarker026"/>corresponding C/C++ code as part of LLVM's building process (we will learn <a id="_idIndexMarker027"/>more about this in the chapters to come). The conversion tool is called <strong class="source-inline">llvm-tblgen</strong>. In other words, the running time of <strong class="source-inline">llvm-tblgen</strong> will affect the building time of LLVM itself. Therefore, if you're not developing the TableGen part, it's always a good idea to build an optimized version of <strong class="source-inline">llvm-tblgen</strong>, regardless of the global build type (that is, <strong class="source-inline">CMAKE_BUILD_TYPE</strong>), making <strong class="source-inline">llvm-tblgen</strong> run faster and shortening the overall building time.</p>
			<p>The following CMake command, for example, will create build configurations that build a debug version of everything <em class="italic">except</em> the <strong class="source-inline">llvm-tblgen</strong> executable, which will be built as an optimized version:</p>
			<p class="source-code">$ cmake -DLLVM_OPTIMIZED_TABLEGEN=ON -DCMAKE_BUILD_TYPE=Debug â€¦</p>
			<p>Lastly, you'll see how you can use Clang and the new PassManager.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Using the new PassManager and Clang</h2>
			<p><strong class="bold">Clang</strong> is LLVM's <a id="_idIndexMarker028"/>official C-family frontend (including C, C++, and Objective-C). It uses LLVM's libraries to generate machine code, which is organized by one of the most <a id="_idIndexMarker029"/>important subsystems in LLVM â€“ <strong class="bold">PassManager</strong>. PassManager <a id="_idIndexMarker030"/>puts together all the tasks (that is, the Passes) required <a id="_idIndexMarker031"/>for optimization and code generation.</p>
			<p>In <a href="B14590_09_Final_JC_ePub.xhtml#_idTextAnchor127"><em class="italic">Chapter 9</em></a>, <em class="italic">Working with PassManager and AnalysisManager</em>, will introduce LLVM's <em class="italic">new</em> PassManager, which builds from the ground up to replace the existing one somewhere in the future. The new PassManager has a faster runtime speed compared to the legacy PassManager. This advantage indirectly brings better runtime performance for Clang. Therefore, the idea here is pretty simple: if we build LLVM's source tree using Clang, with the new PassManager enabled, the compilation speed will be faster. Most of the mainstream Linux distribution package repositories already contain Clang. It's recommended to use Clang 6.0 or later if you want a more stable PassManager implementation. Use the <strong class="source-inline">LLVM_USE_NEWPM</strong> CMake variable to build LLVM with the new PassManager, as follows:</p>
			<p class="source-code">$ env CC=`which clang` CXX=`which clang++` \</p>
			<p class="source-code">Â Â cmake -DLLVM_USE_NEWPM=ON â€¦</p>
			<p>LLVM is a <a id="_idIndexMarker032"/>huge project that takes a lot of time to build. The <a id="_idIndexMarker033"/>previous two sections introduced some useful tricks and tips for improving its building speed. In the next section, we're going to introduce an <em class="italic">alternative</em> build system to build LLVM. It has some advantages over the default CMake build system, which means it will be more suitable in some scenarios.</p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/>Using GN for a faster turnaround time</h1>
			<p>CMake is portable and flexible, and it has been battle-tested by many industrial projects. However, it has <a id="_idIndexMarker034"/>some serious issues when it comes to reconfigurations. As we saw in the previous sections, you can modify some of the CMake arguments once build files have been generated by editing the <strong class="source-inline">CMakeCache.txt</strong> file in the build folder. When you invoke the <strong class="source-inline">build</strong> command again, CMake will reconfigure the build files. If you edit the <strong class="source-inline">CMakeLists.txt</strong> files in your source folders, the same reconfiguration will also kick in. There are primarily two <a id="_idIndexMarker035"/>drawbacks of CMake's reconfiguration process:</p>
			<ul>
				<li>In some systems, the CMake configuration process is pretty slow. Even for reconfiguration, which theoretically only runs part of the process, it still takes a long time sometimes.</li>
				<li>Sometimes, CMake will fail to resolve the dependencies among different variables and build targets, so your changes will not reflect this. In the worst case, it will just silently fail and take you a long time to dig out the problem.</li>
			</ul>
			<p><strong class="bold">Generate Ninja</strong>, better <a id="_idIndexMarker036"/>known as <strong class="bold">GN</strong>, is a build file generator used by many of Google's projects, such as Chromium. GN generates Ninja files from its own description language. It has a good reputation for having a fast configuration time and reliable argument management. LLVM has brought GN support as an alternative (and experimental) building method since late 2018 (around version 8.0.0). GN is especially useful if your developments make changes to build files, or if you want to try out different building options in a short period.</p>
			<p>Perform <a id="_idIndexMarker037"/>the following steps to use GN to build LLVM:</p>
			<ol>
				<li value="1">LLVM's GN support is sitting in the <strong class="source-inline">llvm/utils/gn</strong> folder. After switching to that folder, run the following <strong class="source-inline">get.py</strong> script to download GN's executable locally:<p class="source-code"><strong class="bold">$ cd llvm/utils/gn</strong></p><p class="source-code"><strong class="bold">$ ./get.py</strong></p><p class="callout-heading">Using a specific version of GN</p><p class="callout">If you want to use a custom GN executable instead of the one fetched by <strong class="source-inline">get.py</strong>, simply put your version into the system's <strong class="source-inline">PATH</strong>. If you are wondering what other GN versions are available, you <a id="_idIndexMarker038"/>might want to check out the instructions for installing <strong class="source-inline">depot_tools</strong> at <a href="https://dev.chromium.org/developers/how-tos/install-depot-tools">https://dev.chromium.org/developers/how-tos/install-depot-tools</a>.</p></li>
				<li>Use <strong class="source-inline">gn.py</strong> in the <em class="italic">same</em> folder to generate build files (the local version of <strong class="source-inline">gn.py</strong> is just a wrapper around the real <strong class="source-inline">gn</strong>, to set up the essential environment):<p class="source-code"><strong class="bold">$ ./gn.py gen out/x64.release</strong></p><p><strong class="source-inline">out/x64.release</strong> is the name of the build folder. Usually, GN users will name the build folder in <strong class="source-inline">&lt;architecture&gt;.&lt;build type&gt;.&lt;other features&gt;</strong> format.</p></li>
				<li>Finally, you can switch into the build folder and launch Ninja:<p class="source-code"><strong class="bold">$ cd out/x64.release</strong></p><p class="source-code"><strong class="bold">$ ninja &lt;build target&gt;</strong></p></li>
				<li>Alternatively, you can use the <strong class="source-inline">-C</strong> Ninja option:<p class="source-code"><strong class="bold">$ ninja -C out/x64.release &lt;build target&gt;</strong></p></li>
			</ol>
			<p>You probably already know that the initial build file generation process is super fast. Now, if you want to change some of the build arguments, please navigate to the <strong class="source-inline">args.gn</strong> file under the build folder (<strong class="source-inline">out/x64.release/args.gn</strong>, in this case); for example, if you want to change the build type to <strong class="source-inline">debug</strong> and change the targets to build (that is, the <strong class="source-inline">LLVM_TARGETS_TO_BUILD</strong> CMake argument) into <strong class="source-inline">X86</strong> and <strong class="source-inline">AArch64</strong>. It is recommended to use the following command to launch an editor to edit <strong class="source-inline">args.gn</strong>:</p>
			<p class="source-code">$ ./gn.py args out/x64.release</p>
			<p>In the editor of <strong class="source-inline">args.gn</strong>, input the following contents:</p>
			<p class="source-code"># Inside args.gn</p>
			<p class="source-code">is_debug = true</p>
			<p class="source-code">llvm_targets_to_build = ["X86", "AArch64"]</p>
			<p>Once you've saved and exited the editor, GN will do some syntax checking and regenerate <a id="_idIndexMarker039"/>the build files (of course, you can edit <strong class="source-inline">args.gn</strong> without using the <strong class="source-inline">gn</strong> command and the build files won't be regenerated until you invoke the <strong class="source-inline">ninja</strong> command). This regeneration/reconfiguration will also be fast. Most importantly, there won't be any infidelity behavior. Thanks to GN's language design, relationships between different build arguments can be easily analyzed with little ambiguity.</p>
			<p>The list of GN's build arguments can be found by running this command:</p>
			<p class="source-code">$ ./gn.py args --list out/x64.release</p>
			<p>Unfortunately, at the time of writing this book, there are still plenty of CMake arguments that haven't been ported to GN. GN is <em class="italic">not</em> a replacement for LLVM's existing CMake build system, but it is an <em class="italic">alternative</em>. Nevertheless, GN is still a decent building method if you want a fast turnaround time in your developments that involve many build configuration changes.</p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>Summary</h1>
			<p>LLVM is a useful framework when it comes to building tools for code optimization and code generation. However, the size and complexity of its code base induces a non-trivial amount of build time. This chapter provided some tips for speeding up the build time of the LLVM source tree, including using different building tools, choosing the right CMake arguments, and even adopting a build system other than CMake. These skills cut down on unnecessary resource wasting and improve your productivity when developing with LLVM.</p>
			<p>In the next chapter, we will dig into LLVM's CMake-based building infrastructure and show you how to build system features and guidelines that are crucial in many different development environments.</p>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor028"/>Further reading</h1>
			<ul>
				<li>You can check out the complete list of CMake variables that are used by LLVM at <a href="https://llvm.org/docs/CMake.html#frequently-used-CMake-variables">https://llvm.org/docs/CMake.html#frequently-used-CMake-variables</a>.<p>You can learn more about GN at <a href="https://gn.googlesource.com/gn">https://gn.googlesource.com/gn</a>. The quick start guides at <a href="https://gn.googlesource.com/gn/+/master/docs/quick_start.md">https://gn.googlesource.com/gn/+/master/docs/quick_start.md</a> are also very helpful.</p></li>
			</ul>
		</div>
	</body></html>